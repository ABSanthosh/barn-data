{
  "id": "4db5ad0b-357c-4ebc-b28e-9812b2a13d8a",
  "title": "A Smart Feature Flagging System for iOS",
  "link": "https://albertodebortoli.com/2019/11/26/a-smart-feature-flagging-system-for-ios/",
  "description": "At Just Eat we have experimentation and feature flagging at our heart and we've developed a component, named JustTweak, to make things easier on iOS.",
  "author": "Alberto De Bortoli",
  "published": "Tue, 26 Nov 2019 20:17:00 GMT",
  "source": "https://albertodebortoli.com/rss/",
  "categories": [
    "iOS",
    "feature flags",
    "Optimizely",
    "Just Eat"
  ],
  "byline": "Alberto De Bortoli",
  "length": 18988,
  "excerpt": "At Just Eat we have experimentation and feature flagging at our heart and we've developed a component, named JustTweak, to make things easier on iOS.",
  "siteName": "Alberto De Bortoli",
  "favicon": "",
  "text": "How the iOS team at Just Eat built a scalable open-source solution to handle local and remote flags.Originally published on the Just Eat Engineering Blog. OverviewAt Just Eat we have experimentation at our heart, and it is very much dependent on feature flagging/toggling. If we may be so bold, here's an analogy: feature flagging is to experimentation as machine learning is to AI, you cannot have the second without the first one.We've developed an in-house component, named JustTweak, to handle feature flags and experiments on iOS without the hassle. We open-sourced JustTweak on github.com in 2017 and we have been evolving it ever since; in particular, with support for major experimentation platforms such as Optimizely and Firebase Remote Config.JustTweak has been instrumental in evolving the consumer Just Eat app in a fast and controlled manner, as well as to support a large number of integrations and migrations happening under the hood.In this article, we describe the feature flagging architecture and engine, with code samples and integration suggestions.What is feature flaggingFeature flagging, in its original form, is a software development technique that provides an alternative to maintaining multiple source-code branches, so that a feature can be tested even before it is completed and ready for release. Feature flags are used in code to show/hide or enable/disable specific features at runtime. The technique also allows developers to release a version of a product that has unfinished features, that can be hidden from the user. Feature toggles also allow shorter software integration cycles and small incremental versions of software to be delivered without the cost of constant branching and merging - needless to say, this is crucial to have on iOS due to the App Store review process not allowing continuous delivery.A boolean flag in code is used to drive what code branch will run, but the concept can easily be extended to non-boolean flags, making them more of configuration flags that drive behavior. As an example, at Just Eat we have been gradually rewriting the whole application over time, swapping and customizing entire modules via configuration flags, allowing gradual switches from old to new features in a way transparent to the user.Throughout this article, the term 'tweaks' is used to refer to feature/configuration flags. A tweak can have a value of different raw types, namely Bool, String, Int, Float, and Double.Boolean tweaks can be used to drive features, like so:let isFeatureXEnabled: Bool = ... if isFeatureXEnabled { // show feature X } else { // don't show feature X } Other types of tweaks are instead useful to customise a given feature. Here is an example of configuring the environment using tweaks:let publicApiHost: String = ... let publicApiPort: Int? = ... let endpoint = Endpoint(scheme: \"https\", host: publicApiHost, port: publicApiPort, path: \"/restaurant/:id/menu\") // perform a request using the above endpoint object ProblemThe crucial part to get right is how and from where the flag values (isFeatureXEnabled, publicApiHost, and publicApiPort in the examples above) are fetched. Every major feature flagging/experimentation platform in the market provides its own way to fetch the values, and sometimes the APIs to do so significantly differ (e.g. Firebase Remote Config Vs Optimizely).Aware of the fact that itâ€™s increasingly difficult to build any kind of non-trivial app without leveraging external dependencies, it's important to bear in mind that external dependencies pose a great threat to the long term stability and viability of any application.Following are some issues related to third-party experimentation solutions:third-party SDKs are not under your controlusing third-party SDKs in a modular architected app would easily cause dependency hellthird-party SDKs are easily abused and various areas of your code will become entangled with themyour company might decide to move to a different solution in the future and such switch comes with costsdepending on the adopted solution, you might end up tying your app more and more to the platform-specific features that don't find correspondence elsewhereit is very hard to support multiple feature flag providersFor the above reasons, it is best to hide third-party SDKs behind some sort of a layer and to implement an orchestration mechanism to allow fetching of flag values from different providers. We'll describe how we've achieved this in JustTweak.A note on the approachWhen designing software solutions, a clear trait was identified over time in the iOS team, which boils down to the kind of mindset and principle been used:Always strive to find solutions to problems that are scalable and hide complexity as much as possible.One word you would often hear if you were to work in the iOS team is 'Facade', which is a design pattern that serves as a front-facing interface masking more complex underlying or structural code. Facades are all over the place in our code: we try to keep components' interfaces as simple as possible so that other engineers could utilize them with minimal effort without necessarily knowing the implementation details. Furthermore, the more succinct an interface is, the rarer the possibility of misusages would be.We have some open source components embracing this approach, such as JustPersist, JustLog, and JustTrack. JustTweak makes no exception and the code to integrate it successfully in a project is minimal.Sticking to the above principle, the idea behind JustTweak is to have a single entry point to gather flag values, hiding the implementation details regarding which source the flag values are gathered from.JustTweak to the rescueJustTweak provides a simple facade interface interacting with multiple configurations that are queried respecting a certain priority. Configurations wrap specific sources of tweaks, that are then used to drive decisions or configurations in the client code.You can find JustTweak on CocoaPods and it's on version 5.0.0 at the time of writing. We plan to add support for Carthage and Swift Package Manager in the future. A demo app is also available for you to try it out.With JustTweak you can achieve the following:use a JSON local configuration providing default tweak valuesuse a number of remote configuration providers, such as Firebase and Optmizely, to run A/B tests and feature flaggingenable, disable, and customize features locally at runtimeprovide a dedicated UI for customization (this comes particularly handy for features that are under development to showcase the progress to stakeholders)Here is a screenshot of the TweakViewController taken from the demo app. Tweak values changed via this screen are immediately available to your code at runtime.Stack setupThe facade class previously mentioned is represented by the TweakManager. There should only be a single instance of the manager, ideally configured at startup, passed around via dependency injection, and kept alive for the whole lifespan of the app. Following is an example of the kind of stack implemented as a static let.static let tweakManager: TweakManager = { // mutable configuration (to override tweaks from other configurations) let userDefaultsConfiguration = UserDefaultsConfiguration(userDefaults: .standard) // remote configurations (optional) let optimizelyConfiguration = OptimizelyConfiguration() let firebaseConfiguration = FirebaseConfiguration() // local JSON configuration (default tweaks) let jsonFileURL = Bundle.main.url(forResource: \"Tweaks\", withExtension: \"json\")! let localConfiguration = LocalConfiguration(jsonURL: jsonFileURL) // priority is defined by the order in the configurations array // (from highest to lowest) let configurations: [Configuration] = [userDefaultsConfiguration, optimizelyConfiguration, firebaseConfiguration, localConfiguration] return TweakManager(configurations: configurations) }() ``` JustTweak comes with three configurations out-of-the-box:UserDefaultsConfiguration which is mutable and uses UserDefaults as a key/value storeLocalConfiguration which is read-only and uses a JSON configuration file that is meant to be the default configurationEphemeralConfiguration which is simply an instance of NSMutableDictionaryBesides, JustTweak defines Configuration and MutableConfiguration protocols you can implement to create your own configurations to fit your needs. In the example project, you can find a few example configurations which you can use as a starting point. You can have any source of flags via wrapping it in a concrete implementation of the above protocols. Since the protocol methods are synchronous, you'll have to make sure that the underlying source has been initialised as soon as possible at startup. All the experimentation platforms provide mechanisms to do so, for example here is how Optimizely does it.The order of the objects in the configurations array defines the configurations' priority. The MutableConfiguration with the highest priority, such as UserDefaultsConfiguration in the example above, will be used to reflect the changes made in the UI (TweakViewController). The LocalConfiguration should have the lowest priority as it provides the default values from a local JSON file. It's also the one used by the TweakViewController to populate the UI.When fetching a tweak, the engine will inspect the chain of configurations in order and pick the tweak from the first configuration having it. The following diagram outlines a possible setup where values present in Optimizely override others in the subsequent configurations. Eventually, if no override is found, the local configuration would return the default tweak baked in the app.Structuring the stack this way brings various advantages:the same engine is used to customise the app for development, production, and test runsconsumers only interface with the facade and can ignore the implementation detailsnew code put behind flags can be shipped with confidence since we rely on a tested engineability to remotely override tweaks de facto allowing to greatly customise the app without the need for a new releaseTweakManager gets populated with the tweaks listed in the JSON file used as backing store of the LocalConfiguration instance. It is therefore important to list every supported tweak in there so that development builds of the app can allow tweaking the values. Here is an excerpt from the file used in the TweakViewController screenshot above.{ \"ui_customization\": { \"display_red_view\": { \"Title\": \"Display Red View\", \"Description\": \"shows a red view in the main view controller\", \"Group\": \"UI Customization\", \"Value\": false }, ... \"red_view_alpha_component\": { \"Title\": \"Red View Alpha Component\", \"Description\": \"defines the alpha level of the red view\", \"Group\": \"UI Customization\", \"Value\": 1.0 }, \"label_text\": { \"Title\": \"Label Text\", \"Description\": \"the title of the main label\", \"Group\": \"UI Customization\", \"Value\": \"Test value\" } }, \"general\": { \"greet_on_app_did_become_active\": { \"Title\": \"Greet on app launch\", \"Description\": \"shows an alert on applicationDidBecomeActive\", \"Group\": \"General\", \"Value\": false }, ... } } Testing considerationsWe've seen that the described architecture allows customization via configurations. We've shown in the above diagram that JustTweak can come handy when used in conjunction with our AutomationTools framework too, which is open-source. An Ephemeral configuration would define the app environment at run-time greatly simplifying the implementation of UI tests, which is well-known to be a tedious activity.UsageThe two main features of JustTweak can be accessed from the TweakManager.Checking if a feature is enabled// check for a feature to be enabled let isFeatureXEnabled = tweakManager.isFeatureEnabled(\"feature_X\") if isFeatureXEnabled { // show feature X } else { // hide feature X } Getting and setting the value of a flag for a given feature/variable. JustTweak will return the value from the configuration with the highest priority that provides it, or nil if none of the configurations have that feature/variable.// check for a tweak value let tweak = tweakManager.tweakWith(feature: \u003c#feature_key#\u003e, variable: \u003c#variable_key#\u003e\") if let tweak = tweak { // tweak was found in some configuration, use tweak.value } else { // tweak was not found in any configuration } The Configuration and MutableConfiguration protocols define the following methods:func tweakWith(feature: String, variable: String) -\u003e Tweak? func set(_ value: TweakValue, feature: String, variable: String) func deleteValue(feature: String, variable: String) You might wonder why is there a distinction between feature and variable. The reason is that we want to support the Optimizely lingo for features and related variables and therefore the design of JustTweak has to necessarily reflect that. Other experimentation platforms (such as Firebase) have a single parameter key, but we had to harmonise for the most flexible platform we support.Property WrappersWith SE-0258, Swift 5.1 introduces Property Wrappers. If you haven't read about them, we suggest you watch the WWDC 2019 \"Modern Swift API Design talk where Property Wrappers are explained starting at 23:11.In short, a property wrapper is a generic data structure that encapsulates read/write access to a property while adding some extra behavior to augment its semantics. Common examples are @AtomicWrite and @UserDefault but more creative usages are up for grabs and we couldn't help but think of how handy it would be to have property wrappers for feature flags, and so we implemented them.@TweakProperty and @OptionalTweakProperty are available to mark properties representing feature flags.Here are a couple of examples, making the code so much nicer than before.@TweakProperty(fallbackValue: \u003c#default_value#\u003e, feature: \u003c#feature_key#\u003e, variable: \u003c#variable_key#\u003e, tweakManager: tweakManager) var isFeatureXEnabled: Bool @TweakProperty(fallbackValue: \u003c#default_value#\u003e, feature: \u003c#feature_key#\u003e, variable: \u003c#variable_key#\u003e, tweakManager: tweakManager) var publicApiHost: String @OptionalTweakProperty(fallbackValue: \u003c#default_value_or_nil#\u003e, feature: \u003c#feature_key#\u003e, variable: \u003c#variable_key#\u003e, tweakManager: tweakManager) var publicApiPort: Int? Mind that by using these property wrappers, a static instance of TweakManager must be available.Update a configuration at runtimeJustTweak comes with a ViewController that allows the user to edit the tweaks while running the app. That is achieved by using the MutableConfiguration with the highest priority from the configurations array. This is de facto a debug menu, useful for development and internal builds but not to include in release builds.#if DEBUG func presentTweakViewController() { let tweakViewController = TweakViewController(style: .grouped, tweakManager: tweakManager) // either present it modally or push it on a UINavigationController } #endif Additionally, when a value is modified in any MutableConfiguration, a notification is fired to give the clients the opportunity to react and reflect changes in the UI.override func viewDidLoad() { super.viewDidLoad() NotificationCenter.defaultCenter().addObserver(self, selector: #selector(updateUI), name: TweakConfigurationDidChangeNotification, object: nil) } @objc func updateUI() { // update the UI accordingly } A note on modular architectureIt's reasonable to assume that any non-trivial application approaching 2020 is composed of a number of modules and our Just Eat iOS app surely is too. With more than 30 modules developed in-house, it's crucial to find a way to inject flags into the modules but also to avoid every module to depend on an external library such as JustTweak. One way to achieve this would be:define one or more protocols in the module with the set of properties desiredstructure the modules to allow dependency injection of objects conforming to the above protocolimplement logic in the module to consume the injected objectsFor instance, you could have a class wrapping the manager like so:protocol ModuleASettings { var isFeatureXEnabled: Bool { get } } protocol ModuleBSettings { var publicApiHost: String { get } var publicApiPort: Int? { get } } import JustTweak public class AppConfiguration: ModuleASettings, ModuleBSettings { static let tweakManager: TweakManager = { ... } @TweakProperty(...) var isFeatureXEnabled: Bool @TweakProperty(...) var publicApiHost: String @OptionalTweakProperty(...) var publicApiPort: Int? } Future evolutionWith recent versions of Swift and especially with 5.1, developers have a large set of powerful new tools, such as generics, associated types, opaque types, type erasure, etc.With Combine and SwiftUI entering the scene, developers are also starting adopting new paradigms to write code.Sensible paths to evolve JustTweak could be to have the Tweak object be generic on TweakValue have TweakManager be an ObservableObject which will enable publishing of events via Combine, and use @EnvironmentObject to ease the dependency injection in the SwiftUI view hierarchy.While such changes will need time to be introduced since our contribution to JustTweak is in-line with the evolution of the Just Eat app (and therefore a gradual adoption of SwiftUI), we can't wait to see them implemented. If you desire to contribute, we are more than happy to receive pull requests.ConclusionIn this article, we illustrated how JustTweak can be of great help in adding flexible support to feature flagging. Integrations with external providers/experimentation platforms such as Optimizely, allow remote override of flags without the need of building a new version of the app, while the UI provided by the framework allows local overrides in development builds. We've shown how to integrate JustTweak in a project, how to setup a reasonable stack with a number of configurations and weâ€™ve given you some guidance on how to leverage it when writing UI tests.We believe JustTweak to be a great tool with no similar open source alternatives nor proprietary ones and we hope developers will adopt it more and more.",
  "image": "https://albertodebortoli.com/content/images/size/w1200/2024/02/joshua-fuller-N2q8hRVzEg8-unsplash.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cblockquote\u003eHow the iOS team at Just Eat built a scalable open-source solution to handle local and remote flags.\u003c/blockquote\u003e\u003cp\u003e\u003cem\u003eOriginally published on the \u003ca href=\"https://tech.just-eat.com/2019/11/26/a-smart-feature-flagging-system-for-ios/?ref=albertodebortoli.com\"\u003eJust Eat Engineering Blog\u003c/a\u003e. \u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\u003cp\u003eAt \u003ca href=\"https://www.just-eat.com/?ref=albertodebortoli.com\"\u003eJust Eat\u003c/a\u003e we have experimentation at our heart, and it is very much dependent on feature flagging/toggling. If we may be so bold, here\u0026#39;s an analogy: feature flagging is to experimentation as machine learning is to AI, you cannot have the second without the first one.\u003c/p\u003e\u003cp\u003eWe\u0026#39;ve developed an in-house component, named JustTweak, to handle feature flags and experiments on iOS without the hassle. We open-sourced JustTweak on \u003ca href=\"https://github.com/justeat/JustTweak?ref=albertodebortoli.com\"\u003egithub.com\u003c/a\u003e in 2017 and we have been evolving it ever since; in particular, with support for major experimentation platforms such as \u003ca href=\"https://optimizely.com/?ref=albertodebortoli.com\"\u003eOptimizely\u003c/a\u003e and \u003ca href=\"https://firebase.google.com/docs/remote-config/?gclid=EAIaIQobChMI8fursI_25QIVVODtCh2p1A8zEAAYASAAEgI3tvD_BwE\u0026amp;ref=albertodebortoli.com\"\u003eFirebase Remote Config\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eJustTweak has been instrumental in evolving the consumer \u003ca href=\"https://apps.apple.com/gb/app/just-eat-food-delivery/id566347057?ref=albertodebortoli.com\"\u003eJust Eat app\u003c/a\u003e in a fast and controlled manner, as well as to support a large number of integrations and migrations happening under the hood.\u003c/p\u003e\u003cp\u003eIn this article, we describe the feature flagging architecture and engine, with code samples and integration suggestions.\u003c/p\u003e\u003ch2 id=\"what-is-feature-flagging\"\u003eWhat is feature flagging\u003c/h2\u003e\u003cp\u003eFeature flagging, in its original form, is a software development technique that provides an alternative to maintaining multiple source-code branches, so that a feature can be tested even before it is completed and ready for release. Feature flags are used in code to show/hide or enable/disable specific features at runtime. The technique also allows developers to release a version of a product that has unfinished features, that can be hidden from the user. Feature toggles also allow shorter software integration cycles and small incremental versions of software to be delivered without the cost of constant branching and merging - needless to say, this is crucial to have on iOS due to the App Store review process not allowing continuous delivery.\u003c/p\u003e\u003cp\u003eA boolean flag in code is used to drive what code branch will run, but the concept can easily be extended to non-boolean flags, making them more of configuration flags that drive behavior. As an example, at Just Eat we have been gradually rewriting the whole application over time, swapping and customizing entire modules via configuration flags, allowing gradual switches from old to new features in a way transparent to the user.\u003c/p\u003e\u003cp\u003eThroughout this article, the term \u0026#39;tweaks\u0026#39; is used to refer to feature/configuration flags. A tweak can have a value of different raw types, namely \u003ccode\u003eBool\u003c/code\u003e, \u003ccode\u003eString\u003c/code\u003e, \u003ccode\u003eInt\u003c/code\u003e, \u003ccode\u003eFloat\u003c/code\u003e, and \u003ccode\u003eDouble\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eBoolean tweaks can be used to drive features, like so:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003elet isFeatureXEnabled: Bool = ...\nif isFeatureXEnabled {\n    // show feature X\n}\nelse {\n    // don\u0026#39;t show feature X\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOther types of tweaks are instead useful to customise a given feature. Here is an example of configuring the environment using tweaks:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003elet publicApiHost: String = ...\nlet publicApiPort: Int? = ...\nlet endpoint = Endpoint(scheme: \u0026#34;https\u0026#34;,\n                        host: publicApiHost,\n                        port: publicApiPort,\n                        path: \u0026#34;/restaurant/:id/menu\u0026#34;)\n// perform a request using the above endpoint object\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"problem\"\u003eProblem\u003c/h2\u003e\u003cp\u003eThe crucial part to get right is how and from where the flag values (\u003ccode\u003eisFeatureXEnabled\u003c/code\u003e, \u003ccode\u003epublicApiHost\u003c/code\u003e, and \u003ccode\u003epublicApiPort\u003c/code\u003e in the examples above) are fetched. Every major feature flagging/experimentation platform in the market provides its own way to fetch the values, and sometimes the APIs to do so significantly differ (e.g. \u003ca href=\"https://firebase.google.com/docs/remote-config/use-config-ios?ref=albertodebortoli.com\"\u003eFirebase Remote Config\u003c/a\u003e Vs \u003ca href=\"https://docs.developers.optimizely.com/full-stack/docs/example-usage?ref=albertodebortoli.com\"\u003eOptimizely\u003c/a\u003e).\u003c/p\u003e\u003cp\u003eAware of the fact that itâ€™s increasingly difficult to build any kind of non-trivial app without leveraging external dependencies, it\u0026#39;s important to bear in mind that external dependencies pose a great threat to the long term stability and viability of any application.\u003c/p\u003e\u003cp\u003eFollowing are some issues related to third-party experimentation solutions:\u003c/p\u003e\u003cul\u003e\u003cli\u003ethird-party SDKs are not under your control\u003c/li\u003e\u003cli\u003eusing third-party SDKs in a modular architected app would easily cause \u003ca href=\"https://en.wikipedia.org/wiki/Dependency_hell?ref=albertodebortoli.com\"\u003edependency hell\u003c/a\u003e\u003c/li\u003e\u003cli\u003ethird-party SDKs are easily abused and various areas of your code will become entangled with them\u003c/li\u003e\u003cli\u003eyour company might decide to move to a different solution in the future and such switch comes with costs\u003c/li\u003e\u003cli\u003edepending on the adopted solution, you might end up tying your app more and more to the platform-specific features that don\u0026#39;t find correspondence elsewhere\u003c/li\u003e\u003cli\u003eit is very hard to support multiple feature flag providers\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFor the above reasons, it is best to hide third-party SDKs behind some sort of a layer and to implement an orchestration mechanism to allow fetching of flag values from different providers. We\u0026#39;ll describe how we\u0026#39;ve achieved this in JustTweak.\u003c/p\u003e\u003ch2 id=\"a-note-on-the-approach\"\u003eA note on the approach\u003c/h2\u003e\u003cp\u003eWhen designing software solutions, a clear trait was identified over time in the iOS team, which boils down to the kind of mindset and principle been used:\u003c/p\u003e\u003cp\u003eAlways strive to find solutions to problems that are scalable and hide complexity as much as possible.\u003c/p\u003e\u003cp\u003eOne word you would often hear if you were to work in the iOS team is \u0026#39;\u003ca href=\"https://en.wikipedia.org/wiki/Facade_pattern?ref=albertodebortoli.com\"\u003eFacade\u003c/a\u003e\u0026#39;, which is a design pattern that serves as a front-facing interface masking more complex underlying or structural code. Facades are all over the place in our code: we try to keep components\u0026#39; interfaces as simple as possible so that other engineers could utilize them with minimal effort without necessarily knowing the implementation details. Furthermore, the more succinct an interface is, the rarer the possibility of misusages would be.\u003c/p\u003e\u003cp\u003eWe have some open source components embracing this approach, such as \u003ca href=\"https://github.com/justeat/JustPersist?ref=albertodebortoli.com\"\u003eJustPersist\u003c/a\u003e, \u003ca href=\"https://github.com/justeat/JustLog?ref=albertodebortoli.com\"\u003eJustLog\u003c/a\u003e, and \u003ca href=\"https://github.com/justeat/JustTrack?ref=albertodebortoli.com\"\u003eJustTrack\u003c/a\u003e. \u003ca href=\"https://github.com/justeat/JustTweak?ref=albertodebortoli.com\"\u003eJustTweak\u003c/a\u003e makes no exception and the code to integrate it successfully in a project is minimal.\u003c/p\u003e\u003cp\u003eSticking to the above principle, the idea behind JustTweak is to have a single entry point to gather flag values, hiding the implementation details regarding which source the flag values are gathered from.\u003c/p\u003e\u003ch2 id=\"justtweak-to-the-rescue\"\u003eJustTweak to the rescue\u003c/h2\u003e\u003cp\u003eJustTweak provides a simple facade interface interacting with multiple configurations that are queried respecting a certain priority. Configurations wrap specific sources of tweaks, that are then used to drive decisions or configurations in the client code.\u003c/p\u003e\u003cp\u003eYou can find JustTweak on \u003ca href=\"https://github.com/CocoaPods/CocoaPods?ref=albertodebortoli.com\"\u003eCocoaPods\u003c/a\u003e and it\u0026#39;s on version 5.0.0 at the time of writing. We plan to add support for \u003ca href=\"https://github.com/Carthage/Carthage?ref=albertodebortoli.com\"\u003eCarthage\u003c/a\u003e and \u003ca href=\"https://swift.org/package-manager/?ref=albertodebortoli.com\"\u003eSwift Package Manager\u003c/a\u003e in the future. A demo app is also available for you to try it out.\u003c/p\u003e\u003cp\u003eWith JustTweak you can achieve the following:\u003c/p\u003e\u003cul\u003e\u003cli\u003euse a JSON local configuration providing default tweak values\u003c/li\u003e\u003cli\u003euse a number of remote configuration providers, such as Firebase and Optmizely, to run A/B tests and feature flagging\u003c/li\u003e\u003cli\u003eenable, disable, and customize features locally at runtime\u003c/li\u003e\u003cli\u003eprovide a dedicated UI for customization (this comes particularly handy for features that are under development to showcase the progress to stakeholders)\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eHere is a screenshot of the \u003ccode\u003eTweakViewController\u003c/code\u003e taken from the demo app. Tweak values changed via this screen are immediately available to your code at runtime.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/11/demo_app_view_controller.png\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003ch2 id=\"stack-setup\"\u003eStack setup\u003c/h2\u003e\u003cp\u003eThe facade class previously mentioned is represented by the \u003ccode\u003eTweakManager\u003c/code\u003e. There should only be a single instance of the manager, ideally configured at startup, passed around via dependency injection, and kept alive for the whole lifespan of the app. Following is an example of the kind of stack implemented as a \u003ccode\u003estatic let\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003estatic let tweakManager: TweakManager = {        \n    // mutable configuration (to override tweaks from other configurations)\n    let userDefaultsConfiguration = UserDefaultsConfiguration(userDefaults: .standard)\n\n    // remote configurations (optional)\n    let optimizelyConfiguration = OptimizelyConfiguration()\n    let firebaseConfiguration = FirebaseConfiguration()\n\n    // local JSON configuration (default tweaks)\n    let jsonFileURL = Bundle.main.url(forResource: \u0026#34;Tweaks\u0026#34;,\n                                      withExtension: \u0026#34;json\u0026#34;)!\n    let localConfiguration = LocalConfiguration(jsonURL: jsonFileURL)\n\n    // priority is defined by the order in the configurations array\n    // (from highest to lowest)\n    let configurations: [Configuration] = [userDefaultsConfiguration,\n                                           optimizelyConfiguration,\n                                           firebaseConfiguration,\n                                           localConfiguration]\n    return TweakManager(configurations: configurations)\n}()\n```\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJustTweak comes with three configurations out-of-the-box:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eUserDefaultsConfiguration\u003c/code\u003e which is mutable and uses \u003ccode\u003eUserDefaults\u003c/code\u003e as a key/value store\u003c/li\u003e\u003cli\u003e\u003ccode\u003eLocalConfiguration\u003c/code\u003e which is read-only and uses a JSON configuration file that is meant to be the default configuration\u003c/li\u003e\u003cli\u003e\u003ccode\u003eEphemeralConfiguration\u003c/code\u003e which is simply an instance of \u003ccode\u003eNSMutableDictionary\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eBesides, JustTweak defines \u003ccode\u003eConfiguration\u003c/code\u003e and \u003ccode\u003eMutableConfiguration\u003c/code\u003e protocols you can implement to create your own configurations to fit your needs. In the example project, you can find a few example configurations which you can use as a starting point. You can have any source of flags via wrapping it in a concrete implementation of the above protocols. Since the protocol methods are synchronous, you\u0026#39;ll have to make sure that the underlying source has been initialised as soon as possible at startup. All the experimentation platforms provide mechanisms to do so, for example \u003ca href=\"https://docs.developers.optimizely.com/full-stack/docs/initialize-sdk-swift?ref=albertodebortoli.com#section-use-synchronous-or-asynchronous-initialization\"\u003ehere\u003c/a\u003e is how Optimizely does it.\u003c/p\u003e\u003cp\u003eThe order of the objects in the \u003ccode\u003econfigurations\u003c/code\u003e array defines the configurations\u0026#39; priority. The \u003ccode\u003eMutableConfiguration\u003c/code\u003e with the highest priority, such as \u003ccode\u003eUserDefaultsConfiguration\u003c/code\u003e in the example above, will be used to reflect the changes made in the UI (\u003ccode\u003eTweakViewController\u003c/code\u003e). The \u003ccode\u003eLocalConfiguration\u003c/code\u003e should have the lowest priority as it provides the default values from a local JSON file. It\u0026#39;s also the one used by the \u003ccode\u003eTweakViewController\u003c/code\u003e to populate the UI.\u003c/p\u003e\u003cp\u003eWhen fetching a tweak, the engine will inspect the chain of configurations in order and pick the tweak from the first configuration having it. The following diagram outlines a possible setup where values present in Optimizely override others in the subsequent configurations. Eventually, if no override is found, the local configuration would return the default tweak baked in the app.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/11/JustTweak_stack.png\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cp\u003eStructuring the stack this way brings various advantages:\u003c/p\u003e\u003cul\u003e\u003cli\u003ethe same engine is used to customise the app for development, production, and test runs\u003c/li\u003e\u003cli\u003econsumers only interface with the facade and can ignore the implementation details\u003c/li\u003e\u003cli\u003enew code put behind flags can be shipped with confidence since we rely on a tested engine\u003c/li\u003e\u003cli\u003eability to remotely override tweaks de facto allowing to greatly customise the app without the need for a new release\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003eTweakManager\u003c/code\u003e gets populated with the tweaks listed in the JSON file used as backing store of the \u003ccode\u003eLocalConfiguration\u003c/code\u003e instance. It is therefore important to list every supported tweak in there so that development builds of the app can allow tweaking the values. Here is an excerpt from the file used in the \u003ccode\u003eTweakViewController\u003c/code\u003e screenshot above.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;ui_customization\u0026#34;: {\n    \u0026#34;display_red_view\u0026#34;: {\n      \u0026#34;Title\u0026#34;: \u0026#34;Display Red View\u0026#34;,\n      \u0026#34;Description\u0026#34;: \u0026#34;shows a red view in the main view controller\u0026#34;,\n      \u0026#34;Group\u0026#34;: \u0026#34;UI Customization\u0026#34;,\n      \u0026#34;Value\u0026#34;: false\n    },\n    ...\n    \u0026#34;red_view_alpha_component\u0026#34;: {\n      \u0026#34;Title\u0026#34;: \u0026#34;Red View Alpha Component\u0026#34;,\n      \u0026#34;Description\u0026#34;: \u0026#34;defines the alpha level of the red view\u0026#34;,\n      \u0026#34;Group\u0026#34;: \u0026#34;UI Customization\u0026#34;,\n      \u0026#34;Value\u0026#34;: 1.0\n    },\n    \u0026#34;label_text\u0026#34;: {\n      \u0026#34;Title\u0026#34;: \u0026#34;Label Text\u0026#34;,\n      \u0026#34;Description\u0026#34;: \u0026#34;the title of the main label\u0026#34;,\n      \u0026#34;Group\u0026#34;: \u0026#34;UI Customization\u0026#34;,\n      \u0026#34;Value\u0026#34;: \u0026#34;Test value\u0026#34;\n    }\n  },\n  \u0026#34;general\u0026#34;: {\n    \u0026#34;greet_on_app_did_become_active\u0026#34;: {\n      \u0026#34;Title\u0026#34;: \u0026#34;Greet on app launch\u0026#34;,\n      \u0026#34;Description\u0026#34;: \u0026#34;shows an alert on applicationDidBecomeActive\u0026#34;,\n      \u0026#34;Group\u0026#34;: \u0026#34;General\u0026#34;,\n      \u0026#34;Value\u0026#34;: false\n    },\n    ...\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"testing-considerations\"\u003eTesting considerations\u003c/h3\u003e\u003cp\u003eWe\u0026#39;ve seen that the described architecture allows customization via configurations. We\u0026#39;ve shown in the above diagram that JustTweak can come handy when used in conjunction with our \u003ca href=\"https://github.com/justeat/AutomationTools?ref=albertodebortoli.com\"\u003eAutomationTools\u003c/a\u003e framework too, which is open-source. An Ephemeral configuration would define the app environment at run-time greatly simplifying the implementation of UI tests, which is well-known to be a tedious activity.\u003c/p\u003e\u003ch2 id=\"usage\"\u003eUsage\u003c/h2\u003e\u003cp\u003eThe two main features of JustTweak can be accessed from the \u003ccode\u003eTweakManager\u003c/code\u003e.\u003c/p\u003e\u003cul\u003e\u003cli\u003eChecking if a feature is enabled\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003e// check for a feature to be enabled\nlet isFeatureXEnabled = tweakManager.isFeatureEnabled(\u0026#34;feature_X\u0026#34;)\nif isFeatureXEnabled {\n    // show feature X\n} else {\n    // hide feature X\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003eGetting and setting the value of a flag for a given feature/variable. JustTweak will return the value from the configuration with the highest priority that provides it, or nil if none of the configurations have that feature/variable.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003e// check for a tweak value\nlet tweak = tweakManager.tweakWith(feature: \u0026lt;#feature_key#\u0026gt;, variable: \u0026lt;#variable_key#\u0026gt;\u0026#34;)\nif let tweak = tweak {\n    // tweak was found in some configuration, use tweak.value\n} else {\n    // tweak was not found in any configuration\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003eConfiguration\u003c/code\u003e and \u003ccode\u003eMutableConfiguration\u003c/code\u003e protocols define the following methods:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc tweakWith(feature: String, variable: String) -\u0026gt; Tweak?\nfunc set(_ value: TweakValue, feature: String, variable: String)\nfunc deleteValue(feature: String, variable: String)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou might wonder why is there a distinction between feature and variable. The reason is that we want to support the Optimizely \u003ca href=\"https://docs.developers.optimizely.com/full-stack/docs/define-feature-variables?ref=albertodebortoli.com\"\u003elingo\u003c/a\u003e for features and related variables and therefore the design of JustTweak has to necessarily reflect that. Other experimentation platforms (such as Firebase) have a single parameter key, but we had to harmonise for the most flexible platform we support.\u003c/p\u003e\u003ch2 id=\"property-wrappers\"\u003eProperty Wrappers\u003c/h2\u003e\u003cp\u003eWith \u003ca href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md?ref=albertodebortoli.com\"\u003eSE-0258\u003c/a\u003e, Swift 5.1 introduces Property Wrappers. If you haven\u0026#39;t read about them, we suggest you watch the WWDC 2019 \u0026#34;\u003ca href=\"https://developer.apple.com/videos/play/wwdc2019/415/?ref=albertodebortoli.com\"\u003eModern Swift API Design\u003c/a\u003e talk where Property Wrappers are explained starting at 23:11.\u003c/p\u003e\u003cp\u003eIn short, a property wrapper is a generic data structure that encapsulates read/write access to a property while adding some extra behavior to augment its semantics. Common examples are \u003ccode\u003e@AtomicWrite\u003c/code\u003e and \u003ccode\u003e@UserDefault\u003c/code\u003e but more creative usages are up for grabs and we couldn\u0026#39;t help but think of how handy it would be to have property wrappers for feature flags, and so we \u003ca href=\"https://github.com/justeat/JustTweak/blob/master/JustTweak/Classes/Utilities/PropertyWrapper.swift?ref=albertodebortoli.com\"\u003eimplemented them\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ccode\u003e@TweakProperty\u003c/code\u003e and \u003ccode\u003e@OptionalTweakProperty\u003c/code\u003e are available to mark properties representing feature flags.\u003c/p\u003e\u003cp\u003eHere are a couple of examples, making the code so much nicer than before.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@TweakProperty(fallbackValue: \u0026lt;#default_value#\u0026gt;,\n               feature: \u0026lt;#feature_key#\u0026gt;,\n               variable: \u0026lt;#variable_key#\u0026gt;,\n               tweakManager: tweakManager)\nvar isFeatureXEnabled: Bool\n\n@TweakProperty(fallbackValue: \u0026lt;#default_value#\u0026gt;,\n               feature: \u0026lt;#feature_key#\u0026gt;,\n               variable: \u0026lt;#variable_key#\u0026gt;,\n               tweakManager: tweakManager)\nvar publicApiHost: String\n    \n@OptionalTweakProperty(fallbackValue: \u0026lt;#default_value_or_nil#\u0026gt;,\n                       feature: \u0026lt;#feature_key#\u0026gt;,\n                       variable: \u0026lt;#variable_key#\u0026gt;,\n                       tweakManager: tweakManager)\nvar publicApiPort: Int?\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMind that by using these property wrappers, a static instance of \u003ccode\u003eTweakManager\u003c/code\u003e must be available.\u003c/p\u003e\u003ch2 id=\"update-a-configuration-at-runtime\"\u003eUpdate a configuration at runtime\u003c/h2\u003e\u003cp\u003eJustTweak comes with a ViewController that allows the user to edit the tweaks while running the app. That is achieved by using the \u003ccode\u003eMutableConfiguration\u003c/code\u003e with the highest priority from the configurations array. This is de facto a debug menu, useful for development and internal builds but not to include in release builds.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e#if DEBUG\nfunc presentTweakViewController() {\n    let tweakViewController = TweakViewController(style: .grouped, tweakManager: tweakManager)    \n    // either present it modally or push it on a UINavigationController\n}\n#endif\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAdditionally, when a value is modified in any \u003ccode\u003eMutableConfiguration\u003c/code\u003e, a notification is fired to give the clients the opportunity to react and reflect changes in the UI.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eoverride func viewDidLoad() {\n    super.viewDidLoad()\n    NotificationCenter.defaultCenter().addObserver(self,\n                                                   selector: #selector(updateUI),\n                                                   name: TweakConfigurationDidChangeNotification,\n                                                   object: nil)\n}\n\n@objc func updateUI() {\n    // update the UI accordingly\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"a-note-on-modular-architecture\"\u003eA note on modular architecture\u003c/h2\u003e\u003cp\u003eIt\u0026#39;s reasonable to assume that any non-trivial application approaching 2020 is composed of a number of modules and our Just Eat iOS app surely is too. With more than 30 modules developed in-house, it\u0026#39;s crucial to find a way to inject flags into the modules but also to avoid every module to depend on an external library such as JustTweak. One way to achieve this would be:\u003c/p\u003e\u003cul\u003e\u003cli\u003edefine one or more protocols in the module with the set of properties desired\u003c/li\u003e\u003cli\u003estructure the modules to allow dependency injection of objects conforming to the above protocol\u003c/li\u003e\u003cli\u003eimplement logic in the module to consume the injected objects\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFor instance, you could have a class wrapping the manager like so:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eprotocol ModuleASettings {\n    var isFeatureXEnabled: Bool { get }\n}\n\nprotocol ModuleBSettings {\n    var publicApiHost: String { get }\n    var publicApiPort: Int? { get }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003eimport JustTweak\n\npublic class AppConfiguration: ModuleASettings, ModuleBSettings {    \n    static let tweakManager: TweakManager = {\n        ...\n    }\n\n    @TweakProperty(...)\n    var isFeatureXEnabled: Bool\n\n    @TweakProperty(...)\n    var publicApiHost: String\n    \n    @OptionalTweakProperty(...)\n    var publicApiPort: Int?\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"future-evolution\"\u003eFuture evolution\u003c/h2\u003e\u003cp\u003eWith recent versions of Swift and especially with 5.1, developers have a large set of powerful new tools, such as generics, associated types, opaque types, type erasure, etc.\u003cbr/\u003eWith \u003ca href=\"https://developer.apple.com/documentation/combine?ref=albertodebortoli.com\"\u003eCombine\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/documentation/swiftui?ref=albertodebortoli.com\"\u003eSwiftUI\u003c/a\u003e entering the scene, developers are also starting adopting new paradigms to write code.\u003cbr/\u003eSensible paths to evolve JustTweak could be to have the \u003ccode\u003eTweak\u003c/code\u003e object be generic on \u003ccode\u003eTweakValue\u003c/code\u003e have \u003ccode\u003eTweakManager\u003c/code\u003e be an \u003ca href=\"https://developer.apple.com/documentation/combine/observableobject?ref=albertodebortoli.com\"\u003eObservableObject\u003c/a\u003e which will enable publishing of events via Combine, and use \u003ca href=\"https://developer.apple.com/documentation/swiftui/environmentobject?ref=albertodebortoli.com\"\u003e@EnvironmentObject\u003c/a\u003e to ease the dependency injection in the SwiftUI view hierarchy.\u003c/p\u003e\u003cp\u003eWhile such changes will need time to be introduced since our contribution to JustTweak is in-line with the evolution of the Just Eat app (and therefore a gradual adoption of SwiftUI), we can\u0026#39;t wait to see them implemented. If you desire to contribute, we are more than happy to receive \u003ca href=\"https://github.com/justeat/JustTweak/pulls?ref=albertodebortoli.com\"\u003epull requests\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eIn this article, we illustrated how JustTweak can be of great help in adding flexible support to feature flagging. Integrations with external providers/experimentation platforms such as Optimizely, allow remote override of flags without the need of building a new version of the app, while the UI provided by the framework allows local overrides in development builds. We\u0026#39;ve shown how to integrate JustTweak in a project, how to setup a reasonable stack with a number of configurations and weâ€™ve given you some guidance on how to leverage it when writing UI tests.\u003cbr/\u003eWe believe JustTweak to be a great tool with no similar open source alternatives nor proprietary ones and we hope developers will adopt it more and more.\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2019-11-26T20:17:00Z",
  "modifiedTime": "2019-12-04T17:21:05Z"
}
