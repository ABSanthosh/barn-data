{
  "id": "40c46f67-7383-46ca-96e3-4414f5b12fd0",
  "title": "What even is code signing in iOS? (Runway)",
  "link": "https://www.runway.team/blog/what-even-is-code-signing-in-ios",
  "description": "If you have been developing for iOS for a while, chances are you had one of two issues involving code signing, the process where Apple/Xcode forces you to \"sign\" your app with a developer certificate in order to be able to archive it and submit it to the App Store. I find code signing to be interesting not just because of what it does, but because it's one of those things that iOS developers kinda just take for granted. We know it's there and we know how to deal with it, but we don't really stop to think why it's there or what it's doing under the hood. We just follow Apple's convoluted steps on how to make it work and move on with our lives. In practice, code signing is an incredibly important safety feature of Apple's ecosystems. Knowing what it is and why it exists makes debugging issues related to it considerably easier, so I've written this article to help you understand it.",
  "author": "Bruno Rocha",
  "published": "Fri, 15 Dec 2023 13:00:00 GMT+1",
  "source": "https://swiftrocks.com/rss.xml",
  "categories": null,
  "byline": "Isabel BarreraMarch 29, 2022",
  "length": 14604,
  "excerpt": "I find code signing to be interesting not just because of what it does, but because it's one of those things that iOS developers kinda just take for granted. We know it's there and we know how to deal with it, but we don't really stop to think why it's there or what it's doing under the hood. We just follow Apple's convoluted steps on how to make it work and move on with our lives.",
  "siteName": "Runway",
  "favicon": "https://cdn.prod.website-files.com/5edfa38a1bd219267bdf69b7/5fd2fc79b614d609d9628766_favicon-32.png",
  "text": "If you have been developing for iOS for a while, chances are you had one of two issues involving code signing, the process where Apple/Xcode forces you to \"sign\" your app with a developer certificate in order to be able to archive it and submit it to the App Store.I find code signing to be interesting not just because of what it does, but because it's one of those things that iOS developers kinda just take for granted. We know it's there and we know how to deal with it, but we don't really stop to think why it's there or what it's doing under the hood. We just follow Apple's convoluted steps on how to make it work and move on with our lives.In practice, code signing is an incredibly important safety feature of Apple's ecosystems. Knowing what it is and why it exists makes debugging issues related to it considerably easier, so I've written this article to help you understand it.Modern internet security: From sort-of safe to pretty safe Code signing is not something that was invented by Apple. Rather, it's just a different name for the same security practices that power most of the modern internet. In order to understand code signing, we need to take a step back and explore what those broader security practices are.One of the earliest ways of encrypting content on the internet came in the form of symmetric cryptography, which dictates algorithms that can encrypt and decrypt a message given a single special \"secret key\" or \"password\":Message + secret key = Encrypted messageEncrypted message + secret key = MessageThe word \"symmetric\" is used here because the same key is used for both encryption and decryption. This form of encryption works fine for things that happen in person, but not so much for things that happen entirely over the internet.Imagine you're trying to communicate with someone over the internet, and you'd like to do so in an encrypted fashion. You need to agree on which secret key to use, but you don't have the option to meet in person. How can you communicate this secret key to each other?It's easy to think that we could just send our secret keys to each other via the web, but that wouldn't be safe in the context of this example. If someone's secretly watching your network, they could intercept this message and get a hold of your secret key. That would be an absolute disaster as this person would not only be able to read what you're doing, but they would also have the power to pretend to be either of you by encrypting their own messages!Enter asymmetric cryptographyIn order to avoid this disastrous scenario, modern internet relies heavily on asymmetric algorithms. In this type of cryptography, instead of having a single secret key that does both the encryption and decryption, the algorithms rely on a pair of keys that encrypt/decrypt each other's messages:Message + Key 1 = Encrypted messageEncrypted message + Key 2 = Message(or, vice-versa:)Message + Key 2 = Encrypted messageEncrypted message + Key 1 = MessageAs you can see in the above example, one important feature of those algorithms is that the encryption also works in reverse. It's not only that messages encrypted by key one can only be decrypted by key two, you can also do the opposite.Now, assume that we created one such pair of keys and that we sent one of the keys (but not both!) to the person with whom we're trying to communicate, via the web. Can you see why this is safer than the symmetric encryption example?In this example, even if someone manages to intercept the key we sent over, we already have something that is safer than the first scenario. While the bad actor would theoretically still have the ability to decrypt what you're sending to the other person, they now cannot pretend to be you anymore because they don't have the other key in the pair. Why? Because it never left your machine!In practice, the pair of keys we're talking about here is usually referred to as the public/private key pair precisely to denominate the use case we've described here. The \"public\" key is named as such because it's what you transmit across the web and don't care if a bad actor has access to it, while the \"private\" key is what you keep to yourself and protect at all costs. In iOS development, you very likely had to directly deal with these more than once not just because of code signing, but also because most modern SDKs rely on you setting up such keys in order to protect your account.But as you might've noticed, this is not exactly 100% secure either. If the bad actor were to intercept the public key you sent over and replace it with a bogus one that they created themselves, they would not only be able to pretend to be you again, they would completely be able to lock you out as your original secret key wouldn't be a valid pair for their bogus one.Certificates and Certificate Authorities (CAs)To prevent disasters like that, systems where security is critical have an additional layer of protection on top of those public keys.Instead of blindly sending the raw public key over the web and hoping for the best, such systems bundle that public key within a file that aims to prove to the recipient that the public key they're looking at came from where it was supposed to come from and can be trusted that it wasn't modified or intercepted. Such files are called certificates.The way the proof works is by having an entity (like a person or a company) encrypt a small message that describes the contents of that certificate with a private key of their own and ship that message within the certificate itself. If you decrypt that message with that entity's public key and confirm that what they described is in fact what you received, then you have proof that the certificate and its bundled public key did in fact come from that entity. If you can trust that the entity is not lying to you, then you can trust that the public key is legit. In the security field, these entities are called Certificate Authorities (CAs), and this process of encrypting small \"proof messages\" into files is what's referred to as signing.This system is called chain of trust, and as the name implies, its security relies completely on you having trust in the CA and everyone else involved in that chain. Because of that, while technically anyone can be a certificate authority, you'll find that the internet mostly relies on a small group of large and heavily audited ones. Apple is one of them.For additional security, certificates themselves usually come in the form of a chain. Instead of being signed by a single \"main\" private key that handles everything pertaining to that CA, your end-user certificate will instead usually be signed by the private key of another certificate that is more specific to your use case. Such certificates are called intermediate certificates, and their purpose is not only to allow the CA to limit the damage in the event of a leak, but also to allow the CA to regularly generate new keys for such intermediate certificates without losing the ability to validate the certificates at the end of the chain (the ones we developers deal with). Much like your end-user certificates, intermediate certificates are themselves signed by other certificates, in a chain that goes all the way up to a single root certificate lying at the top which effectively owns all other certificates in the chain.‍Diagram from Bing Kuo's Beginner's Guide to Code SigningOther important security features of CAs and certificates worth mentioning include expiration dates and the ability to revoke certificates in cases where they cannot be trusted anymore (such as a leak). In the case of Apple specifically, you can find information about all of the root and intermediate certificates issued by their CA on this page, as well as any relevant information pertaining to them (such as if they were revoked).\"But wait, this doesn't solve the problem we talked about. What if a bad actor forges the public keys of a CA?\", you might think. \"Wouldn't they then be able to create their own chain of fake certificates and cause damage that way? \"If every single public key were to be transferred over the web, then theoretically yes. Luckily, the internet doesn't do that! To prevent forgery, products that rely on certificates as their security mechanism generally hardcode the root certificates that they care about. By shipping those critical public keys alongside their code, attacks involving intercepting keys via the network become impossible. As an example, Apple's root certificates are hardcoded in your iOS/macOS devices. Another example is your browser, which comes with root certificates from CAs related to HTTPS.When put together, this system of public/private keys and chains of trusted certificates/CAs is called Public Key Infrastructure (PKI). PKI is a critical component of modern secure communication and plays a central role in ensuring the confidentiality, integrity, and authenticity of digital transactions and data exchanges.What about iOS?In the context of iOS development, code signing is the process of employing PKI to prove that some piece of code is legitimate. In other words, this is a security feature to prevent unauthorized or malicious code from running on the user's devices.When you create your developer account, the process of uploading something to the App Store involves having you ask Apple to create a new certificate for you. This results in Apple giving you a private key that you're meant to store securely in your Keychain, which is then used by Xcode to sign your app bundles before finally sending them to Apple. Since Apple has access to your certificate, they have the power to prove that those bundles actually came from you, and not someone pretending to you.In macOS, the process of having Xcode sign your app bundles is deep-down handled by the codesign CLI tool, and is a tool that I recommend learning how to use as it can be very handy when attempting to debug code signing problems in general.iOS continued: Device safety with Provisioning ProfilesProvisioning profiles are also an important safety feature that is connected to the overall code signing process, but unlike everything we've seen so far, they are specific to Apple platforms and have otherwise nothing to do with PKI.While on the one hand the purpose of code signing is to make sure a particular piece of code can be trusted, the purpose of provisioning profiles is to make sure a particular device is allowed to run that same particular piece of code.While platforms like Android allow you to download binaries from third-party app stores and install them on your phone without any restrictions, iOS forbids you from doing so unless the developer explicitly acknowledges during the submission process that your specific device is allowed to install that particular binary. This is because iOS is designed to be a closed ecosystem, and is the reason why you cannot for example install apps from a source that is not the official App Store. This is a critical component of the overall safety of Apple devices, although most iOS users would agree that a little bit more freedom would be appreciated. (In fact, the EU has long been attempting to force Apple to relax those restrictions, and it seems likely that they will succeed.)You already know what these acknowledgments are: that's the provisioning profiles. During the code signing process, Xcode will grab the relevant provisioning profiles and copy them inside your app's bundle so that it can later in the process be inspected by the device trying to install your app to confirm that it's actually allowed to do so.Developers are required to provide provisioning profiles when targeting physical devices, and they contain information such as the bundle identifier of the app, the certificates tied to it, and the capabilities of the app (e.g camera access).All builds targeting physical devices require provisioning profiles, but only debug and ad-hoc builds require an explicit list of devices. For Enterprise and App Store builds, profiles do not need to include device data since they refer to builds where the users are not known in advance.How code signing is handled in release processesWhile Xcode can automatically manage code signing for you, one of the first things you learn in iOS development is that you should turn it off and never EVER press that darned \"Fix Issues\" button.To be clearer, Xcode's automatic code signing features work perfectly when you're working on a project completely by yourself. But when working on a project where you have teammates, automatic code signing is guaranteed to cause some serious damage to your release process if you don't turn it off.The reason is that you need to have access to your developer certificate's private key when submitting your app to the store or compiling a build that targets a physical device. If Xcode complains that you don't have a copy of the private key on your machine and you click the \"Fix Issues\" button, Xcode will not magically fetch the key from your teammate's computer (it couldn't possibly do so); it will instead revoke their certificates and create a brand new one for you. This means that the next time your teammates try to compile the app, they will be greeted by a message telling them that their certificate is not valid anymore. If everyone keeps on pressing that button, your team's developer account may end up with an ocean of dead certificates, and if one of those teammates happens to be a CI server, your entire release workflow will halt every time it happens.To avoid that, teams disable Xcode's automatic signing features in favor of using external tools that were specially designed to solve this problem. Perhaps the most popular one is match, which is a plugin for fastlane that stores and manages all of your team's certificates and profiles in a central repository. When everyone in the team has access to that repo, the plugin can make sure everyone has a copy of the private keys on their machine and that there are no duplicate/outdated certificates or profiles in your team's developer account.In essence, iOS code signing is not just a formality; it's a crucial security feature used to verify the legitimacy of an app and protect users from malicious software. While you certainly don't need to master the details of how code signing works to be able to develop your apps, knowing a little bit of PKI and how it's used in practice in iOS can come in handy not just for debugging iOS-related signing issues, but also for helping you understand the modern internet in general.‍‍",
  "image": "https://cdn.prod.website-files.com/5ef1f28e08458502ba614d85/628fa700c770c1a3545ef352_certificates-min.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"content\"\u003e\u003cp\u003eIf you have been developing for iOS for a while, chances are you had one of two issues involving \u003cstrong\u003ecode signing\u003c/strong\u003e, the process where Apple/Xcode forces you to \u0026#34;sign\u0026#34; your app with a developer certificate in order to be able to archive it and submit it to the App Store.\u003c/p\u003e\u003cp\u003eI find code signing to be interesting not just because of what it does, but because it\u0026#39;s one of those things that iOS developers kinda just take for granted. We know it\u0026#39;s there and we know how to deal with it, but we don\u0026#39;t really stop to think \u003cstrong\u003ewhy\u003c/strong\u003e it\u0026#39;s there or what it\u0026#39;s doing under the hood. We just follow Apple\u0026#39;s convoluted steps on how to make it work and move on with our lives.\u003c/p\u003e\u003cp\u003eIn practice, code signing is an incredibly important safety feature of Apple\u0026#39;s ecosystems. Knowing what it is and why it exists makes debugging issues related to it considerably easier, so I\u0026#39;ve written this article to help you understand it.\u003c/p\u003e\u003ch2\u003eModern internet security: From sort-of safe to pretty safe \u003c/h2\u003e\u003cp\u003eCode signing is not something that was invented by Apple. Rather, it\u0026#39;s just a different name for the same security practices that power most of the modern internet. In order to understand code signing, we need to take a step back and explore what those broader security practices are.\u003c/p\u003e\u003cp\u003eOne of the earliest ways of encrypting content on the internet came in the form of \u003cstrong\u003esymmetric cryptography, \u003c/strong\u003ewhich dictates algorithms that can encrypt and decrypt a message given a single special \u0026#34;secret key\u0026#34; or \u0026#34;password\u0026#34;:\u003c/p\u003e\u003cul role=\"list\"\u003e\u003cli\u003eMessage + secret key = Encrypted message\u003c/li\u003e\u003cli\u003eEncrypted message + secret key = Message\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe word \u0026#34;symmetric\u0026#34; is used here because the same key is used for both encryption and decryption. This form of encryption works fine for things that happen in person, but not so much for things that happen entirely over the internet.\u003c/p\u003e\u003cp\u003eImagine you\u0026#39;re trying to communicate with someone over the internet, and you\u0026#39;d like to do so in an encrypted fashion. You need to agree on which secret key to use, but you don\u0026#39;t have the option to meet in person. How can you communicate this secret key to each other?\u003c/p\u003e\u003cp\u003eIt\u0026#39;s easy to think that we could just send our secret keys to each other via the web, but that wouldn\u0026#39;t be safe in the context of this example. If someone\u0026#39;s secretly watching your network, they could intercept this message and get a hold of your secret key. That would be an absolute disaster\u003cstrong\u003e \u003c/strong\u003eas this person would not only be able to read what you\u0026#39;re doing, but they would also have the power to \u003cstrong\u003epretend\u003c/strong\u003e to be either of you by encrypting their own messages!\u003c/p\u003e\u003ch3\u003eEnter asymmetric cryptography\u003c/h3\u003e\u003cp\u003eIn order to avoid this disastrous scenario, modern internet relies heavily on \u003cstrong\u003easymmetric algorithms\u003c/strong\u003e. In this type of cryptography, instead of having a single secret key that does both the encryption and decryption, the algorithms rely on a \u003cstrong\u003epair of keys\u003c/strong\u003e that encrypt/decrypt each other\u0026#39;s messages:\u003c/p\u003e\u003cul role=\"list\"\u003e\u003cli\u003eMessage + Key 1 = Encrypted message\u003c/li\u003e\u003cli\u003eEncrypted message + Key 2 = Message\u003c/li\u003e\u003cli\u003e(or, vice-versa:)\u003c/li\u003e\u003cli\u003eMessage + Key 2 = Encrypted message\u003c/li\u003e\u003cli\u003eEncrypted message + Key 1 = Message\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAs you can see in the above example, one important feature of those algorithms is that the encryption also works in reverse. It\u0026#39;s not only that messages encrypted by key one can only be decrypted by key two, you can also do the opposite.\u003c/p\u003e\u003cp\u003eNow, assume that we created one such pair of keys and that we sent one of the keys \u003cstrong\u003e(but not both!) \u003c/strong\u003eto the person with whom we\u0026#39;re trying to communicate, via the web. Can you see why this is safer than the symmetric encryption example?\u003c/p\u003e\u003cp\u003eIn this example, even if someone manages to intercept the key we sent over, we already have something that is safer than the first scenario. While the bad actor would theoretically still have the ability to decrypt what you\u0026#39;re sending to the other person,\u003cstrong\u003e they now cannot pretend to be you anymore because they don\u0026#39;t have the other key in the pair\u003c/strong\u003e. Why? Because it never left your machine!\u003c/p\u003e\u003cp\u003eIn practice, the pair of keys we\u0026#39;re talking about here is usually referred to as the \u003cstrong\u003epublic/private key pair\u003c/strong\u003e precisely to denominate the use case we\u0026#39;ve described here. The \u0026#34;public\u0026#34; key is named as such because it\u0026#39;s what you transmit across the web and don\u0026#39;t care if a bad actor has access to it, while the \u0026#34;private\u0026#34; key is what you keep to yourself and protect at all costs. In iOS development, you very likely had to directly deal with these more than once not just because of code signing, but also because most modern SDKs rely on you setting up such keys in order to protect your account.\u003c/p\u003e\u003cp\u003eBut as you might\u0026#39;ve noticed, this is not exactly 100% secure either. If the bad actor were to \u003cstrong\u003eintercept\u003c/strong\u003e the public key you sent over and replace it with a bogus one that they created themselves, they would not only be able to pretend to be you again, they would completely be able to lock you out as your original secret key wouldn\u0026#39;t be a valid pair for their bogus one.\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content\"\u003e\u003ch3\u003eCertificates and Certificate Authorities (CAs)\u003c/h3\u003e\u003cp\u003eTo prevent disasters like that, systems where security is critical have an additional layer of protection on top of those public keys.\u003c/p\u003e\u003cp\u003eInstead of blindly sending the raw public key over the web and hoping for the best, such systems bundle that public key within a file that aims to prove to the recipient that the public key they\u0026#39;re looking at came from where it was supposed to come from and can be trusted that it wasn\u0026#39;t modified or intercepted. Such files are called \u003cstrong\u003ecertificates.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe way the proof works is by having an entity (like a person or a company) encrypt a small message that describes the contents of that certificate with a private key of their own and ship that message within the certificate itself. If you decrypt that message with that entity\u0026#39;s public key and confirm that what they described is in fact what you received, then you have proof that the certificate and its bundled public key did in fact come from that entity. If you can trust that the entity is not lying to you, then you can trust that the public key is legit. In the security field, these entities are called \u003cstrong\u003eCertificate Authorities (CAs), \u003c/strong\u003eand this process of encrypting small \u0026#34;proof messages\u0026#34; into files is what\u0026#39;s referred to as \u003cstrong\u003esigning.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis system is called \u003cstrong\u003echain of trust\u003c/strong\u003e, and as the name implies, its security relies completely on you having trust in the CA and everyone else involved in that chain. Because of that, while technically anyone can be a certificate authority, you\u0026#39;ll find that the internet mostly relies on a small group of large and heavily audited ones. Apple is one of them.\u003c/p\u003e\u003cp\u003eFor additional security, certificates themselves usually come in the form of a chain. Instead of being signed by a single \u0026#34;main\u0026#34; private key that handles everything pertaining to that CA, your end-user certificate will instead usually be signed by the private key of \u003cem\u003eanother\u003c/em\u003e certificate that is more specific to your use case. Such certificates are called \u003cstrong\u003eintermediate certificates\u003c/strong\u003e, and their purpose is not only to allow the CA to limit the damage in the event of a leak, but also to allow the CA to regularly generate new keys for such intermediate certificates without losing the ability to validate the certificates at the end of the chain (the ones we developers deal with). Much like your end-user certificates, intermediate certificates are themselves signed by other certificates, in a chain that goes all the way up to a single \u003cstrong\u003eroot certificate\u003c/strong\u003e lying at the top which effectively owns all other certificates in the chain.\u003c/p\u003e\u003cp\u003e‍\u003c/p\u003e\u003cfigure\u003e\u003cp\u003e\u003cimg src=\"https://cdn.prod.website-files.com/5ef1f28e08458502ba614d85/66e451435e40fe9e35a739bb_6578bac39ae4ce49520c175c_image1.png\" loading=\"lazy\" alt=\"\"/\u003e\u003c/p\u003e\u003cfigcaption\u003eDiagram from Bing Kuo\u0026#39;s \u003ca href=\"https://medium.com/@bingkuo/a-beginners-guide-to-code-signing-in-ios-development-d3d5285f0960\"\u003eBeginner\u0026#39;s Guide to Code Signing\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003e\u003cbr/\u003eOther important security features of CAs and certificates worth mentioning include \u003cstrong\u003eexpiration dates\u003c/strong\u003e and \u003cstrong\u003ethe ability to revoke certificates\u003c/strong\u003e in cases where they cannot be trusted anymore (such as a leak). \u003c/p\u003e\u003cp\u003eIn the case of Apple specifically, you can find information about all of the root and intermediate certificates issued by their CA \u003ca href=\"https://www.apple.com/certificateauthority/\"\u003eon this page\u003c/a\u003e, as well as any relevant information pertaining to them (such as if they were revoked).\u003c/p\u003e\u003cp\u003e\u0026#34;But wait, this doesn\u0026#39;t solve the problem we talked about. What if a bad actor forges the public keys of a CA?\u0026#34;, you might think. \u0026#34;Wouldn\u0026#39;t they then be able to create their own chain of fake certificates and cause damage that way? \u0026#34;\u003c/p\u003e\u003cp\u003eIf every single public key were to be transferred over the web, then theoretically yes. Luckily, the internet doesn\u0026#39;t do that! To prevent forgery, products that rely on certificates as their security mechanism \u003cstrong\u003egenerally hardcode the root certificates that they care about.\u003c/strong\u003e By shipping those critical public keys alongside their code, attacks involving intercepting keys via the network become impossible. As an example, Apple\u0026#39;s root certificates are hardcoded in your iOS/macOS devices. Another example is your browser, which comes with root certificates from CAs related to HTTPS.\u003c/p\u003e\u003cp\u003eWhen put together, this system of public/private keys and chains of trusted certificates/CAs is called\u003cstrong\u003e Public Key Infrastructure (PKI)\u003c/strong\u003e. PKI is a critical component of modern secure communication and plays a central role in ensuring the confidentiality, integrity, and authenticity of digital transactions and data exchanges.\u003c/p\u003e\u003ch2\u003eWhat about iOS?\u003c/h2\u003e\u003cp\u003eIn the context of iOS development, \u003cstrong\u003ecode signing is the process of employing PKI to prove that some piece of code is legitimate.\u003c/strong\u003e In other words, this is a security feature to prevent unauthorized or malicious code from running on the user\u0026#39;s devices.\u003c/p\u003e\u003cp\u003eWhen you create your developer account, the process of uploading something to the App Store involves having you ask Apple to create a new certificate for you. This results in Apple giving you a private key that you\u0026#39;re meant to store securely in your Keychain, which is then used by Xcode to sign your app bundles before finally sending them to Apple. Since Apple has access to your certificate, they have the power to prove that those bundles actually came from you, and not someone pretending to you.\u003c/p\u003e\u003cp\u003eIn macOS, the process of having Xcode sign your app bundles is deep-down handled by the \u003ca href=\"https://www.manpagez.com/man/1/codesign/\"\u003ecodesign\u003c/a\u003e CLI tool, and is a tool that I recommend learning how to use as it can be very handy when attempting to debug code signing problems in general.\u003c/p\u003e\u003ch2\u003eiOS continued: Device safety with Provisioning Profiles\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eProvisioning profiles\u003c/strong\u003e are \u003cem\u003ealso\u003c/em\u003e an important safety feature that is connected to the overall code signing process, but unlike everything we\u0026#39;ve seen so far, they are specific to Apple platforms and have otherwise nothing to do with PKI.\u003c/p\u003e\u003cp\u003eWhile on the one hand the purpose of code signing is to make sure a particular piece of code can be trusted, the purpose of provisioning profiles is to make sure a particular device is allowed to run that same particular piece of code.\u003c/p\u003e\u003cp\u003eWhile platforms like Android allow you to download binaries from third-party app stores and install them on your phone without any restrictions, iOS forbids you from doing so unless the developer explicitly acknowledges during the submission process that your specific device is allowed to install that particular binary. This is because iOS is designed to be a closed ecosystem, and is the reason why you cannot for example install apps from a source that is not the official App Store. This is a critical component of the overall safety of Apple devices, although most iOS users would agree that a little bit more freedom would be appreciated. (In fact, \u003ca href=\"https://www.macrumors.com/2023/11/17/apple-files-legal-challenge-against-eu/#:~:text=Apple%20Files%20Legal%20Challenge%20Against%20EU%20Law%20as%20Sideloading%20Requirement%20Looms,-Friday%20November%2017\u0026amp;text=Apple%20today%20filed%20a%20legal,its%20devices%20(via%20Reuters).\"\u003ethe EU has long been attempting to force Apple to relax those restrictions,\u003c/a\u003e and it seems likely that they will succeed.)\u003c/p\u003e\u003cp\u003eYou already know what these acknowledgments are: that\u0026#39;s the provisioning profiles. During the code signing process, Xcode will grab the relevant provisioning profiles and copy them inside your app\u0026#39;s bundle so that it can later in the process be inspected by the device trying to install your app to confirm that it\u0026#39;s actually allowed to do so.\u003c/p\u003e\u003cp\u003eDevelopers are required to provide provisioning profiles when targeting physical devices, and they contain information such as the bundle identifier of the app, the certificates tied to it, and the capabilities of the app (e.g camera access).\u003c/p\u003e\u003cp\u003eAll builds targeting physical devices require provisioning profiles, but only debug and ad-hoc builds require an explicit list of devices. For Enterprise and App Store builds, profiles do not need to include device data since they refer to builds where the users are not known in advance.\u003c/p\u003e\u003ch2\u003eHow code signing is handled in release processes\u003c/h2\u003e\u003cp\u003eWhile Xcode can automatically manage code signing for you, one of the first things you learn in iOS development is that you should turn it off and never EVER press that darned \u0026#34;Fix Issues\u0026#34; button.\u003c/p\u003e\u003cp\u003eTo be clearer, Xcode\u0026#39;s automatic code signing features work perfectly when you\u0026#39;re working on a project completely by yourself. But when working on a project where you have teammates, automatic code signing is guaranteed to cause some serious damage to your release process if you don\u0026#39;t turn it off.\u003c/p\u003e\u003cp\u003eThe reason is that you need to have access to your developer certificate\u0026#39;s private key when submitting your app to the store or compiling a build that targets a physical device. If Xcode complains that you don\u0026#39;t have a copy of the private key on your machine and you click the \u0026#34;Fix Issues\u0026#34; button, Xcode will not magically fetch the key from your teammate\u0026#39;s computer (it couldn\u0026#39;t possibly do so); it will instead \u003cstrong\u003erevoke\u003c/strong\u003e their certificates and create a brand new one for you. This means that the next time your teammates try to compile the app, they will be greeted by a message telling them that their certificate is not valid anymore. If everyone keeps on pressing that button, your team\u0026#39;s developer account may end up with an ocean of dead certificates, and if one of those teammates happens to be a CI server, your entire release workflow will halt every time it happens.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003eTo avoid that, teams disable Xcode\u0026#39;s automatic signing features in favor of using external tools that were specially designed to solve this problem. Perhaps the most popular one is \u003ca href=\"https://docs.fastlane.tools/actions/match/\"\u003ematch\u003c/a\u003e, which is a plugin for fastlane that stores and manages all of your team\u0026#39;s certificates and profiles in a central repository. When everyone in the team has access to that repo, the plugin can make sure everyone has a copy of the private keys on their machine and that there are no duplicate/outdated certificates or profiles in your team\u0026#39;s developer account.\u003c/p\u003e\u003cp\u003eIn essence, iOS code signing is not just a formality; it\u0026#39;s a crucial security feature used to verify the legitimacy of an app and protect users from malicious software. While you certainly don\u0026#39;t need to master the details of how code signing works to be able to develop your apps, knowing a little bit of PKI and how it\u0026#39;s used in practice in iOS can come in handy not just for debugging iOS-related signing issues, but also for helping you understand the modern internet in general.\u003c/p\u003e\u003c/div\u003e\u003cp\u003e‍\u003c/p\u003e\u003cp\u003e‍\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": null,
  "modifiedTime": null
}
