{
  "id": "80037f57-d42b-46b0-bee8-127f20816c41",
  "title": "How the relative size modifier interacts with stack views",
  "link": "https://oleb.net/2023/swiftui-relative-size-in-stacks/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2023-03-24T20:14:49Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann …",
  "length": 6444,
  "excerpt": "The relative sizing modifier interacts in an interesting way with stack views and other containers that distribute the available space among their children. Understanding why can teach us a lot about SwiftUI’s layout algorithm.",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "I have one more thing to say on the relative sizing view modifier from my previous post, Working with percentages in SwiftUI layout. I’m assuming you’ve read that article. The following is good to know if you want to use the modifier in your own code, but I hope you’ll also learn some general tidbits about SwiftUI’s layout algorithm for HStacks and VStacks. Using relative sizing inside a stack view Let’s apply the relativeProposed modifier to one of the subviews of an HStack: HStack(spacing: 10) { Color.blue .relativeProposed(width: 0.5) Color.green Color.yellow } .border(.primary) .frame(height: 80) What do you expect to happen here? Will the blue view take up 50 % of the available width? The answer is no. In fact, the blue rectangle becomes narrower than the others: This is because the HStack only proposes a proportion of its available width to each of its children. Here, the stack proposes one third of the available space to its first child, the relative sizing modifier. The modifier then halves this value, resulting in one sixth of the total width (minus spacing) for the blue color. The other two rectangles then become wider than one third because the first child view didn’t use up its full proposed width. Update May 1, 2024: SwiftUI’s built-in containerRelativeFrame modifier (introduced after I wrote my modifier) doesn’t exhibit this behavior because it uses the size of the nearest container view as its reference, and stack views don’t count as containers in this context (which I find somewhat unintuitive, but that’s the way it is). Order matters Now let’s move the modifier to the green color in the middle: HStack(spacing: 10) { Color.blue Color.green .relativeProposed(width: 0.5) Color.yellow } Naively, I’d expect an equivalent result: the green rectangle should become 100 pt wide, and blue and yellow should be 250 pt each. But that’s not what happens — the yellow view ends up being wider than the blue one: I found this unintuitive at first, but it makes sense if you understand that the HStack processes its children in sequence: The HStack proposes one third of its available space to the blue view: (620 – 20) / 3 = 200. The blue view accepts the proposal and becomes 200 pt wide. Next up is the relativeProposed modifier. The HStack divides the remaining space by the number of remaining subviews and proposes that: 400 / 2 = 200. Our modifier halves this proposal and proposes 100 pt to the green view, which accepts it. The modifier in turn adopts the size of its child and returns 100 pt to the HStack. Since the second subview used less space than proposed, the HStack now has 300 pt left over to propose to its final child, the yellow color. Important: the order in which the stack lays out its subviews happens to be from left to right in this example, but that’s not always the case. In general, HStacks and VStacks first group their subviews by layout priority (more on that below), and then order the views inside each group by flexibility such that the least flexible views are laid out first. For more on this, see How an HStack Lays out Its Children by Chris Eidhof. The views in our example are all equally flexible (they all can become any width between 0 and infinity), so the stack processes them in their “natural” order. Leftover space isn’t redistributed By now you may be able guess how the layout turns out when we move our view modifier to the last child view: HStack(spacing: 10) { Color.blue Color.green Color.yellow .relativeProposed(width: 0.5) } Blue and green each receive one third of the available width and become 200 pt wide. No surprises there. When the HStack reaches the relativeProposed modifier, it has 200 pt left to distribute. Again, the modifier and the yellow rectangle only use half of this amount. The end result is that the HStack ends up with 100 pt left over. The process stops here — the HStack does not start over in an attempt to find a “better” solution. The stack makes itself just big enough to contain its subviews (= 520 pt incl. spacing) and reports that size to its parent. Layout priority We can use the layoutPriority view modifier to influence how stacks and other containers lay out their children. Let’s give the subview with the relative sizing modifier a higher layout priority (the default priority is 0): HStack(spacing: 10) { Color.blue Color.green Color.yellow .relativeProposed(width: 0.5) .layoutPriority(1) } This results in a layout where the yellow rectangle actually takes up 50 % of the available space: Explanation: The HStack groups its children by layout priority and then processes each group in sequence, from highest to lowest priority. Each group is proposed the entire remaining space. The first layout group only contains a single view, our relative sizing modifier with the yellow color. The HStack proposes the entire available space (minus spacing) = 600 pt. Our modifier halves the proposal, resulting in 300 pt for the yellow view. There are 300 pt left over for the second layout group. These are distributed equally among the two children because each subview accepts the proposed size. Conclusion The code I used to generate the images in this article is available on GitHub. I only looked at HStacks here, but VStacks work in exactly the same way for the vertical dimension. SwiftUI’s layout algorithm always follows this basic pattern of proposed sizes and responses. Each of the built-in “primitive” views (e.g. fixed and flexible frames, stacks, Text, Image, Spacer, shapes, padding, background, overlay) has a well-defined (if not always well-documented) layout behavior that can be expressed as a function (ProposedViewSize) -\u003e CGSize. You’ll need to learn the behavior for view to work effectively with SwiftUI. A concrete lesson I’m taking away from this analysis: HStack and VStack don’t treat layout as an optimization problem that tries to find the optimal solution for a set of constraints (autolayout style). Rather, they sort their children in a particular way and then do a single proposal-and-response pass over them. If there’s space leftover at the end, or if the available space isn’t enough, then so be it.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003eI have one more thing to say on the relative sizing view modifier from my previous post, \u003ca href=\"https://oleb.net/2023/swiftui-relative-size/\"\u003eWorking with percentages in SwiftUI layout\u003c/a\u003e. I’m assuming you’ve read that article. The following is good to know if you want to use the modifier in your own code, but I hope you’ll also learn some general tidbits about SwiftUI’s layout algorithm for HStacks and VStacks.\u003c/p\u003e\n\n\u003ch2 id=\"using-relative-sizing-inside-a-stack-view\"\u003eUsing relative sizing inside a stack view\u003c/h2\u003e\n\n\u003cp\u003eLet’s apply the \u003ccode\u003erelativeProposed\u003c/code\u003e modifier to one of the subviews of an \u003ca href=\"https://developer.apple.com/documentation/swiftui/hstack\"\u003e\u003ccode\u003eHStack\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eHStack\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003espacing\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eblue\u003c/span\u003e\n        \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erelativeProposed\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0.5\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egreen\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eyellow\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eborder\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprimary\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWhat do you expect to happen here? Will the blue view take up 50 % of the available width? The answer is no. In fact, the blue rectangle becomes narrower than the others:\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cfigure\u003e\n    \u003ca href=\"https://oleb.net/media/2023-03-24-SwiftUI-relative-sizing-HStack-1-1294px.png\"\u003e\n    \u003cimg src=\"https://oleb.net/media/2023-03-24-SwiftUI-relative-sizing-HStack-1-1294px.png\" alt=\"A blue, a green, and a yellow rectangle in a horizontal line. The blue rectangle is 100 units wide, the other two 250 units each.\"/\u003e\n    \u003c/a\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003cp\u003eThis is because the HStack only proposes a proportion of its available width to each of its children. Here, the stack proposes one third of the available space to its first child, the relative sizing modifier. The modifier then halves this value, resulting in one sixth of the total width (minus spacing) for the blue color. The other two rectangles then become wider than one third because the first child view didn’t use up its full proposed width.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eUpdate May 1, 2024:\u003c/strong\u003e SwiftUI’s built-in \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/containerrelativeframe(_:alignment:_:)\"\u003e\u003ccode\u003econtainerRelativeFrame\u003c/code\u003e\u003c/a\u003e modifier (introduced after I wrote my modifier) doesn’t exhibit this behavior because it uses the size of the nearest \u003cem\u003econtainer\u003c/em\u003e view as its reference, and stack views \u003cem\u003edon’t\u003c/em\u003e count as containers in this context (which I find somewhat unintuitive, but that’s the way it is).\u003c/p\u003e\n\n\u003ch2 id=\"order-matters\"\u003eOrder matters\u003c/h2\u003e\n\n\u003cp\u003eNow let’s move the modifier to the green color in the middle:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eHStack\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003espacing\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eblue\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egreen\u003c/span\u003e\n        \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erelativeProposed\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0.5\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eyellow\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNaively, I’d expect an equivalent result: the green rectangle should become 100 pt wide, and blue and yellow should be 250 pt each. But that’s not what happens — the yellow view ends up being wider than the blue one:\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cfigure\u003e\n    \u003ca href=\"https://oleb.net/media/2023-03-24-SwiftUI-relative-sizing-HStack-2-1294px.png\"\u003e\n    \u003cimg src=\"https://oleb.net/media/2023-03-24-SwiftUI-relative-sizing-HStack-2-1294px.png\" alt=\"A blue, a green, and a yellow rectangle in a horizontal line. The blue rectangle is 200 units wide, the green 100, and the yellow 300.\"/\u003e\n    \u003c/a\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003cp\u003eI found this unintuitive at first, but it makes sense if you understand that the HStack processes its children in sequence:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eThe HStack proposes one third of its available space to the blue view: \u003ccode\u003e(620 – 20) / 3 = 200\u003c/code\u003e. The blue view accepts the proposal and becomes 200 pt wide.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eNext up is the \u003ccode\u003erelativeProposed\u003c/code\u003e modifier. The HStack divides the remaining space by the number of remaining subviews and proposes that: \u003ccode\u003e400 / 2 = 200\u003c/code\u003e. Our modifier halves this proposal and proposes 100 pt to the green view, which accepts it. The modifier in turn adopts the size of its child and returns 100 pt to the HStack.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eSince the second subview used less space than proposed, the HStack now has 300 pt left over to propose to its final child, the yellow color.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eImportant: the order in which the stack lays out its subviews happens to be from left to right in this example, but that’s not always the case. \u003cstrong\u003eIn general, HStacks and VStacks first group their subviews by layout priority (more on that below), and then order the views inside each group by \u003cem\u003eflexibility\u003c/em\u003e such that the least flexible views are laid out first.\u003c/strong\u003e For more on this, see \u003ca href=\"https://www.objc.io/blog/2020/11/10/hstacks-child-ordering/\"\u003eHow an HStack Lays out Its Children\u003c/a\u003e by Chris Eidhof. The views in our example are all equally flexible (they all can become any width between 0 and infinity), so the stack processes them in their “natural” order.\u003c/p\u003e\n\n\u003ch2 id=\"leftover-space-isnt-redistributed\"\u003eLeftover space isn’t redistributed\u003c/h2\u003e\n\n\u003cp\u003eBy now you may be able guess how the layout turns out when we move our view modifier to the last child view:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eHStack\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003espacing\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eblue\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egreen\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eyellow\u003c/span\u003e\n        \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erelativeProposed\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0.5\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv\u003e\n\u003cfigure\u003e\n    \u003ca href=\"https://oleb.net/media/2023-03-24-SwiftUI-relative-sizing-HStack-3-1294px.png\"\u003e\n    \u003cimg src=\"https://oleb.net/media/2023-03-24-SwiftUI-relative-sizing-HStack-3-1294px.png\" alt=\"A blue, a green, and a yellow rectangle in a horizontal line. The blue and green rectangles are each 200 units wide, the yellow one is 100 units wide. The complete HStack is 520 units wide, the available width is 620 units.\"/\u003e\n    \u003c/a\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eBlue and green each receive one third of the available width and become 200 pt wide. No surprises there.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eWhen the HStack reaches the \u003ccode\u003erelativeProposed\u003c/code\u003e modifier, it has 200 pt left to distribute. Again, the modifier and the yellow rectangle only use half of this amount.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe end result is that the HStack ends up with 100 pt left over. The process stops here — the HStack does \u003cem\u003enot\u003c/em\u003e start over in an attempt to find a “better” solution. The stack makes itself just big enough to contain its subviews (= 520 pt incl. spacing) and reports that size to its parent.\u003c/p\u003e\n\n\u003ch2 id=\"layout-priority\"\u003eLayout priority\u003c/h2\u003e\n\n\u003cp\u003eWe can use the \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/layoutpriority(_:)\"\u003e\u003ccode\u003elayoutPriority\u003c/code\u003e\u003c/a\u003e view modifier to influence how stacks and other containers lay out their children. Let’s give the subview with the relative sizing modifier a higher layout priority (the default priority is 0):\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eHStack\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003espacing\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eblue\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egreen\u003c/span\u003e\n    \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eyellow\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erelativeProposed\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0.5\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elayoutPriority\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis results in a layout where the yellow rectangle actually takes up 50 % of the available space:\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cfigure\u003e\n    \u003ca href=\"https://oleb.net/media/2023-03-24-SwiftUI-relative-sizing-HStack-4-1294px.png\"\u003e\n    \u003cimg src=\"https://oleb.net/media/2023-03-24-SwiftUI-relative-sizing-HStack-4-1294px.png\" alt=\"A blue, a green, and a yellow rectangle in a horizontal line. The blue and green rectangles are each 150 units wide, and the yellow 300.\"/\u003e\n    \u003c/a\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003cp\u003eExplanation:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eThe HStack groups its children by layout priority and then processes each group in sequence, from highest to lowest priority. Each group is proposed the \u003cem\u003eentire\u003c/em\u003e remaining space.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eThe first layout group only contains a single view, our relative sizing modifier with the yellow color. The HStack proposes the entire available space (minus spacing) = 600 pt. Our modifier halves the proposal, resulting in 300 pt for the yellow view.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eThere are 300 pt left over for the second layout group. These are distributed equally among the two children because each subview accepts the proposed size.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eThe code I used to generate the images in this article \u003ca href=\"https://gist.github.com/ole/7577deed8081ef6294f761704cff8a1d#file-znestedinhstack-swift\"\u003eis available on GitHub\u003c/a\u003e. I only looked at HStacks here, but VStacks work in exactly the same way for the vertical dimension.\u003c/p\u003e\n\n\u003cp\u003eSwiftUI’s layout algorithm always follows this basic pattern of proposed sizes and responses. Each of the built-in “primitive” views (e.g. \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/frame(width:height:alignment:)\"\u003efixed\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/frame(minwidth:idealwidth:maxwidth:minheight:idealheight:maxheight:alignment:)\"\u003eflexible frames\u003c/a\u003e, \u003ca href=\"https://developer.apple.com/documentation/swiftui/layout-fundamentals\"\u003estacks\u003c/a\u003e, \u003ca href=\"https://developer.apple.com/documentation/swiftui/text\"\u003e\u003ccode\u003eText\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://developer.apple.com/documentation/swiftui/image\"\u003e\u003ccode\u003eImage\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://developer.apple.com/documentation/swiftui/spacer\"\u003e\u003ccode\u003eSpacer\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://developer.apple.com/documentation/swiftui/shape\"\u003eshapes\u003c/a\u003e, \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/padding(_:)-68shk\"\u003e\u003ccode\u003epadding\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/background(alignment:content:)\"\u003e\u003ccode\u003ebackground\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/overlay(alignment:content:)\"\u003e\u003ccode\u003eoverlay\u003c/code\u003e\u003c/a\u003e) has a well-defined (if not always well-documented) layout behavior that can be expressed as a function \u003ccode\u003e(ProposedViewSize) -\u0026gt; CGSize\u003c/code\u003e. You’ll need to learn the behavior for view to work effectively with SwiftUI.\u003c/p\u003e\n\n\u003cp\u003eA concrete lesson I’m taking away from this analysis: \u003ccode\u003eHStack\u003c/code\u003e and \u003ccode\u003eVStack\u003c/code\u003e don’t treat layout as an optimization problem that tries to find the optimal solution for a set of constraints (autolayout style). Rather, they sort their children in a particular way and then do a single proposal-and-response pass over them. If there’s space leftover at the end, or if the available space isn’t enough, then so be it.\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2023-03-24T20:14:49Z",
  "modifiedTime": "2024-05-01T17:14:31Z"
}
