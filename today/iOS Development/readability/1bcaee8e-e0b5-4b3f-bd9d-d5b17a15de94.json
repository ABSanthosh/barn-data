{
  "id": "1bcaee8e-e0b5-4b3f-bd9d-d5b17a15de94",
  "title": "Dependency injection and Generics to create a modular app in Swift",
  "link": "https://benoitpasquier.com/modular-app-dependency-injection-generics-swift/",
  "description": "When we talk about modular app, we rarely mention how complex it can be over time and get out of hand. In most cases, importing frameworks into one another is a reasonable solution but we can do more. Let’s explore how with dependency inversion in Swift and how to create order into our components.",
  "author": "",
  "published": "Tue, 10 Aug 2021 08:00:00 +0000",
  "source": "https://benoitpasquier.com/index.xml",
  "categories": null,
  "byline": "Benoit Pasquier",
  "length": 7543,
  "excerpt": "When we talk about modular app, we rarely mention how complex it can be over time and get out of hand. In most cases, importing frameworks into one another is a reasonable solution but we can do more. Let’s explore how with dependency inversion in Swift and how to create order into our components.",
  "siteName": "Benoit Pasquier",
  "favicon": "https://benoitpasquier.com/favicon.png",
  "text": "When we talk about modular app, we rarely mention how complex it can be over time and get out of hand. In most cases, importing frameworks into one another is a reasonable solution but we can do more. Let’s explore how with dependency inversion in Swift and how to create order into our components. A while back, I shared the first steps how to build a modular architecture for an iOS app. By creating a framework and importing into the main app, I could decouple the business logic from the UI layer. Simple and easy, it works great. But then, when it comes to bigger projects, it gets a bit different. We can easily reach dozens of modules, which themselves depends of others. It exposes the code to break due to necessary cascading changes. The idea of decoupling the layers and logic is the great, but in the execution, if you change a low level framework method signature, how many dependent frameworks you need to change? Ideally, if it’s decoupled, only one. Let’s see it through an example. I have 2 frameworks, an Analytics used for company metrics, and a LoginUI to isolate Login journey. At the moment LoginUI depends from Analytics, it imports it as dependency. // Analytics public protocol EventHandlerProtocol { func send(key: String, params: [String: Any]?) } public class EventHandler: EventHandlerProtocol { func send(key: String, params: [String: Any]?) { print(\"SEND - \\(event.key)\") } } // LoginUI import Analytics public class LoginViewController: UIViewController { let eventHandler: EventHandlerProtocol public init(eventHandler: EventHandlerProtocol) { self.eventHandler = eventHandler super.init(nibName: nil, bundle: nil) } public required init?(coder: NSCoder) { fatalError(\"not implemented\") } public override func viewDidLoad() { super.viewDidLoad() eventHandler.send(\"login.screen\", params: nil) } } The EventHandler is the implementation of the interface EventHandlerProtocol. The analytics logic is decoupled. So far so good. On the other end, I use dependency injection in the LoginViewController to pass along the event handler from the interface. When the viewDidLoad is executed, we get a log. The final piece to make it work is in the main app to glue it together. import Analytics import LoginUI func makeLoginViewController() -\u003e UIViewController { return LoginViewController(eventHandler: EventHandler()) } So far so good. All the implementation is hidden from the frameworks, and the app puts all the pieces together. But here comes trouble. We have to make a change in the Analytics to pass a data structure rather than key and params. Turns out, it will require to make changed in LoginUI framework. Actually, it requires to make changes across any feature components that uses it. Tough one. What could we have done differently to support this changes in future without breaking anything? That’s where come dependency inversion. Part of SOLID principle, Dependency Inversion Principle aims to loosen-up the coupling between two components. Instead of one depending on the other, both relies on the same interface. Following this direction, on paper, Analytics would depend of AnalyticsProtocol, so does LoginUI. // AnalyticsProtocol public protocol EventHandlerProtocol { func send(key: String, params: [String: Any]?) } // Analytics import AnalyticsProtocol public class EventHandler: EventHandlerProtocol { func send(key: String, params: [String: Any]?) { print(\"SEND - \\(event.key)\") } } // LoginUI import AnalyticsProtocol public class LoginViewController: UIViewController { let eventHandler: EventHandlerProtocol // same code ... } It doesn’t look much but we’ve decoupled a little more Analytics and LoginUI modules. We created a middle layer for the abstraction and we could replace Analytics implementation tomorrow with another similar component, as long as it follows AnalyticsProtocol. However, the problem stays the same: if the interface has to change, we have still as many dependencies to change. So what else can we do? One way I found interesting is through generic type. With a small refactoring, we can completely remove the dependencies between components. At the moment, LoginUI still depends of a AnalyticsProtocol, but what if it didn’t. We could create a bridge in the main app to connect the two components without an extra interface. Let’s revisit the code to check this out. // LoginUI public struct LoginEvent { public let key: String public let params: [String: Any]? } public protocol LoginEventHandler { func send(_ event: LoginEvent) } public class LoginViewController: UIViewController { let eventHandler: LoginEventHandler public init(eventHandler: LoginEventHandler) { self.eventHandler = eventHandler super.init(nibName: nil, bundle: nil) } public required init?(coder: NSCoder) { fatalError(\"not implemented\") } public override func viewDidLoad() { super.viewDidLoad() eventHandler.send(LoginEvent(key: \"login.screen\", params: nil)) } } In this new version, we create a new interface, and still handle the tracking the same way. But how is it implemented? We need first to update the Analytics implementation for a more generic approach. // Analytics public protocol EventProtocol { var key: String { get } var params: [String: Any]? { get } } public protocol EventHandlerProtocol { func send\u003cT: EventProtocol\u003e(_ event: T) } public class EventHandler: EventHandlerProtocol { public init() { } public func send\u003cT: EventProtocol\u003e(_ event: T) { // TODO private implementation print(\"SEND - \\(event.key)\") } } With this new interface based on generic type, the implementation can be much more modular as long as the event follows the same interface. Wait, but how does Analytics and LoginUI communicates? That’s the beauty part, they are not exposed to each other. The app will create the connection // App import Analytics import LoginUI // extends LoginUI events to Analytics event definition extension LoginEvent: EventProtocol { } // extends Analytics handler to LoginUI handler definition extension EventHandler: LoginEventHandler { } func makeLoginViewController() -\u003e UIViewController { return LoginViewController(eventHandler: EventHandler()) } Creating this bridge allows us to avoid importing Analytics into LoginUI at the first place. If one of those components had to change tomorrow, it doesn’t automatically enforce to cascade to many more changes. In this case, similar to Dependency Inversion Principle, we loose-up the coupling of those two modules enough to be flexible and replaceable. It also allow new components to do the same as well. At the end of the day, only the application knows how those layers are interfaced and we can interface a lot more components without risking creating unnecessary dependencies between one another. As usual, there is never one solution for all problems, maybe your app architecture design works already well today, but it’s still interesting to know what’s out there that might help you find a new solution to face any upcoming problems. In this case, we created a modular app and leveraged generic type to follow the dependency inversion principle. Each layer is separated, testable and maintainable. Pretty cool. What about you? What are you tips and tweaks to face complex architectures? Feel free to share.",
  "image": "https://benoitpasquier.com/images/2021/08/modular-app-preview.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n              \u003cp\u003eWhen we talk about modular app, we rarely mention how complex it can be over time and get out of hand. In most cases, importing frameworks into one another is a reasonable solution but we can do more. Let’s explore how with dependency inversion in Swift and how to create order into our components.\u003c/p\u003e\n\u003cp\u003eA while back, I shared the first steps \u003ca href=\"https://benoitpasquier.com/how-build-modular-architecture-ios/\"\u003ehow to build a modular architecture for an iOS app\u003c/a\u003e. By creating a framework and importing into the main app, I could decouple the business logic from the UI layer. Simple and easy, it works great.\u003c/p\u003e\n\u003cp\u003eBut then, when it comes to bigger projects, it gets a bit different. We can easily reach dozens of modules, which themselves depends of others. It exposes the code to break due to necessary cascading changes.\u003c/p\u003e\n\u003cp\u003eThe idea of decoupling the layers and logic is the great, but in the execution, if you change a low level framework method signature, how many dependent frameworks you need to change? Ideally, if it’s decoupled, only one.\u003c/p\u003e\n\u003cp\u003eLet’s see it through an example.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2021/08/swift-modular-dependency.png\" alt=\"swift-modular-app\"/\u003e\u003c/p\u003e\n\u003cp\u003eI have 2 frameworks, an \u003ccode\u003eAnalytics\u003c/code\u003e used for company metrics, and a \u003ccode\u003eLoginUI\u003c/code\u003e to isolate Login journey. At the moment \u003ccode\u003eLoginUI\u003c/code\u003e depends from \u003ccode\u003eAnalytics\u003c/code\u003e, it imports it as dependency.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Analytics\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eprotocol\u003c/span\u003e \u003cspan\u003eEventHandlerProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esend\u003c/span\u003e(\u003cspan\u003ekey\u003c/span\u003e: \u003cspan\u003eString\u003c/span\u003e, \u003cspan\u003eparams\u003c/span\u003e: [\u003cspan\u003eString\u003c/span\u003e: \u003cspan\u003eAny\u003c/span\u003e]?)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eEventHandler\u003c/span\u003e: \u003cspan\u003eEventHandlerProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esend\u003c/span\u003e(\u003cspan\u003ekey\u003c/span\u003e: \u003cspan\u003eString\u003c/span\u003e, \u003cspan\u003eparams\u003c/span\u003e: [\u003cspan\u003eString\u003c/span\u003e: \u003cspan\u003eAny\u003c/span\u003e]?) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;SEND - \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003e\u003cspan\u003eevent\u003c/span\u003e.\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// LoginUI\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eAnalytics\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eLoginViewController\u003c/span\u003e: \u003cspan\u003eUIViewController\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eeventHandler\u003c/span\u003e: \u003cspan\u003eEventHandlerProtocol\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003eeventHandler\u003c/span\u003e: \u003cspan\u003eEventHandlerProtocol\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eeventHandler\u003c/span\u003e = \u003cspan\u003eeventHandler\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003esuper\u003c/span\u003e.\u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003enibName\u003c/span\u003e: \u003cspan\u003enil\u003c/span\u003e, \u003cspan\u003ebundle\u003c/span\u003e: \u003cspan\u003enil\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003erequired\u003c/span\u003e \u003cspan\u003einit\u003c/span\u003e?(\u003cspan\u003ecoder\u003c/span\u003e: \u003cspan\u003eNSCoder\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003efatalError\u003c/span\u003e(\u003cspan\u003e\u0026#34;not implemented\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eviewDidLoad\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003esuper\u003c/span\u003e.\u003cspan\u003eviewDidLoad\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eeventHandler\u003c/span\u003e.\u003cspan\u003esend\u003c/span\u003e(\u003cspan\u003e\u0026#34;login.screen\u0026#34;\u003c/span\u003e, \u003cspan\u003eparams\u003c/span\u003e: \u003cspan\u003enil\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e} \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe \u003ccode\u003eEventHandler\u003c/code\u003e is the implementation of the interface \u003ccode\u003eEventHandlerProtocol\u003c/code\u003e. The analytics logic is decoupled. So far so good.\u003c/p\u003e\n\u003cp\u003eOn the other end, I use dependency injection in the \u003ccode\u003eLoginViewController\u003c/code\u003e to pass along the event handler from the interface. When the \u003ccode\u003eviewDidLoad\u003c/code\u003e is executed, we get a log.\u003c/p\u003e\n\u003cp\u003eThe final piece to make it work is in the main app to glue it together.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eAnalytics\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eLoginUI\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003emakeLoginViewController\u003c/span\u003e() -\u0026gt; \u003cspan\u003eUIViewController\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eLoginViewController\u003c/span\u003e(\u003cspan\u003eeventHandler\u003c/span\u003e: \u003cspan\u003eEventHandler\u003c/span\u003e())\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSo far so good. All the implementation is hidden from the frameworks, and the app puts all the pieces together.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eBut here comes trouble.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eWe have to make a change in the Analytics to pass a data structure rather than \u003ccode\u003ekey\u003c/code\u003e and \u003ccode\u003eparams\u003c/code\u003e. Turns out, it will require to make changed in \u003ccode\u003eLoginUI\u003c/code\u003e framework. Actually, it requires to make changes across any feature components that uses it. \u003cem\u003eTough one.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eWhat could we have done differently to support this changes in future without breaking anything? That’s where come dependency inversion.\u003c/p\u003e\n\u003cp\u003ePart of \u003ca href=\"https://en.wikipedia.org/wiki/SOLID\"\u003eSOLID principle\u003c/a\u003e, Dependency Inversion Principle aims to loosen-up the coupling between two components. Instead of one depending on the other, both relies on the same interface.\u003c/p\u003e\n\u003cp\u003eFollowing this direction, on paper, \u003ccode\u003eAnalytics\u003c/code\u003e would depend of \u003ccode\u003eAnalyticsProtocol\u003c/code\u003e, so does \u003ccode\u003eLoginUI\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2021/08/swift-dependency-inversion.png\" alt=\"swift-dependency-inversion\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// AnalyticsProtocol\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eprotocol\u003c/span\u003e \u003cspan\u003eEventHandlerProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esend\u003c/span\u003e(\u003cspan\u003ekey\u003c/span\u003e: \u003cspan\u003eString\u003c/span\u003e, \u003cspan\u003eparams\u003c/span\u003e: [\u003cspan\u003eString\u003c/span\u003e: \u003cspan\u003eAny\u003c/span\u003e]?)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Analytics\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eAnalyticsProtocol\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eEventHandler\u003c/span\u003e: \u003cspan\u003eEventHandlerProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esend\u003c/span\u003e(\u003cspan\u003ekey\u003c/span\u003e: \u003cspan\u003eString\u003c/span\u003e, \u003cspan\u003eparams\u003c/span\u003e: [\u003cspan\u003eString\u003c/span\u003e: \u003cspan\u003eAny\u003c/span\u003e]?) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;SEND - \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003e\u003cspan\u003eevent\u003c/span\u003e.\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// LoginUI\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eAnalyticsProtocol\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eLoginViewController\u003c/span\u003e: \u003cspan\u003eUIViewController\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eeventHandler\u003c/span\u003e: \u003cspan\u003eEventHandlerProtocol\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// same code ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e} \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIt doesn’t look much but we’ve decoupled a little more \u003ccode\u003eAnalytics\u003c/code\u003e and \u003ccode\u003eLoginUI\u003c/code\u003e modules. We created a middle layer for the abstraction and we could replace \u003ccode\u003eAnalytics\u003c/code\u003e implementation tomorrow with another similar component, as long as it follows \u003ccode\u003eAnalyticsProtocol\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, the problem stays the same: if the interface has to change, we have still as many dependencies to change. So what else can we do?\u003c/p\u003e\n\u003cp\u003eOne way I found interesting is through generic type. With a small refactoring, we can \u003cem\u003ecompletely remove the dependencies between components\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAt the moment, \u003ccode\u003eLoginUI\u003c/code\u003e still depends of a \u003ccode\u003eAnalyticsProtocol\u003c/code\u003e, but what if it didn’t. We could create a bridge in the main app to connect the two components without an extra interface.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2021/08/swift-dependency-generics.png\" alt=\"swift-dependency-generics\"/\u003e\u003c/p\u003e\n\u003cp\u003eLet’s revisit the code to check this out.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// LoginUI\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eLoginEvent\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ekey\u003c/span\u003e: \u003cspan\u003eString\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eparams\u003c/span\u003e: [\u003cspan\u003eString\u003c/span\u003e: \u003cspan\u003eAny\u003c/span\u003e]?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eprotocol\u003c/span\u003e \u003cspan\u003eLoginEventHandler\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esend\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eevent\u003c/span\u003e: \u003cspan\u003eLoginEvent\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eLoginViewController\u003c/span\u003e: \u003cspan\u003eUIViewController\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eeventHandler\u003c/span\u003e: \u003cspan\u003eLoginEventHandler\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003eeventHandler\u003c/span\u003e: \u003cspan\u003eLoginEventHandler\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eeventHandler\u003c/span\u003e = \u003cspan\u003eeventHandler\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003esuper\u003c/span\u003e.\u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003enibName\u003c/span\u003e: \u003cspan\u003enil\u003c/span\u003e, \u003cspan\u003ebundle\u003c/span\u003e: \u003cspan\u003enil\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003erequired\u003c/span\u003e \u003cspan\u003einit\u003c/span\u003e?(\u003cspan\u003ecoder\u003c/span\u003e: \u003cspan\u003eNSCoder\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003efatalError\u003c/span\u003e(\u003cspan\u003e\u0026#34;not implemented\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eviewDidLoad\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003esuper\u003c/span\u003e.\u003cspan\u003eviewDidLoad\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eeventHandler\u003c/span\u003e.\u003cspan\u003esend\u003c/span\u003e(\u003cspan\u003eLoginEvent\u003c/span\u003e(\u003cspan\u003ekey\u003c/span\u003e: \u003cspan\u003e\u0026#34;login.screen\u0026#34;\u003c/span\u003e, \u003cspan\u003eparams\u003c/span\u003e: \u003cspan\u003enil\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e} \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIn this new version, we create a new interface, and still handle the tracking the same way. But how is it implemented?\u003c/p\u003e\n\u003cp\u003eWe need first to update the \u003ccode\u003eAnalytics\u003c/code\u003e implementation for a more generic approach.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Analytics\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eprotocol\u003c/span\u003e \u003cspan\u003eEventProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ekey\u003c/span\u003e: \u003cspan\u003eString\u003c/span\u003e { \u003cspan\u003eget\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eparams\u003c/span\u003e: [\u003cspan\u003eString\u003c/span\u003e: \u003cspan\u003eAny\u003c/span\u003e]? { \u003cspan\u003eget\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eprotocol\u003c/span\u003e \u003cspan\u003eEventHandlerProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esend\u003c/span\u003e\u0026lt;\u003cspan\u003eT\u003c/span\u003e: \u003cspan\u003eEventProtocol\u003c/span\u003e\u0026gt;(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eevent\u003c/span\u003e: \u003cspan\u003eT\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eEventHandler\u003c/span\u003e: \u003cspan\u003eEventHandlerProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003einit\u003c/span\u003e() { }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esend\u003c/span\u003e\u0026lt;\u003cspan\u003eT\u003c/span\u003e: \u003cspan\u003eEventProtocol\u003c/span\u003e\u0026gt;(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eevent\u003c/span\u003e: \u003cspan\u003eT\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// TODO private implementation\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;SEND - \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003e\u003cspan\u003eevent\u003c/span\u003e.\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWith this new interface based on generic type, the implementation can be much more \u003cem\u003emodular\u003c/em\u003e as long as the event follows the same interface.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWait, but how does \u003ccode\u003eAnalytics\u003c/code\u003e and \u003ccode\u003eLoginUI\u003c/code\u003e communicates?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThat’s the beauty part, they are not exposed to each other. The app will create the connection\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// App\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eAnalytics\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eLoginUI\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// extends LoginUI events to Analytics event definition\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eLoginEvent\u003c/span\u003e: \u003cspan\u003eEventProtocol\u003c/span\u003e { }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// extends Analytics handler to LoginUI handler definition\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eEventHandler\u003c/span\u003e: \u003cspan\u003eLoginEventHandler\u003c/span\u003e { }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003emakeLoginViewController\u003c/span\u003e() -\u0026gt; \u003cspan\u003eUIViewController\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eLoginViewController\u003c/span\u003e(\u003cspan\u003eeventHandler\u003c/span\u003e: \u003cspan\u003eEventHandler\u003c/span\u003e())\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eCreating this bridge allows us to avoid importing \u003ccode\u003eAnalytics\u003c/code\u003e into \u003ccode\u003eLoginUI\u003c/code\u003e at the first place. If one of those components had to change tomorrow, it doesn’t automatically enforce to cascade to many more changes.\u003c/p\u003e\n\u003cp\u003eIn this case, similar to Dependency Inversion Principle, we loose-up the coupling of those two modules enough to be flexible and replaceable. It also allow new components to do the same as well.\u003c/p\u003e\n\u003cp\u003eAt the end of the day, only the application knows how those layers are interfaced and we can interface a lot more components without risking creating unnecessary dependencies between one another.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2021/08/swift-modular-generics.png\" alt=\"swift-modular-generics\"/\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eAs usual, there is never one solution for all problems, maybe your app architecture design works already well today, but it’s still interesting to know what’s out there that might help you find a new solution to face any upcoming problems.\u003c/p\u003e\n\u003cp\u003eIn this case, we created a modular app and leveraged generic type to follow the dependency inversion principle. Each layer is separated, testable and maintainable. Pretty cool.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eWhat about you?\u003c/em\u003e What are you tips and tweaks to face complex architectures? Feel free to share.\u003c/p\u003e\n              \n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2021-08-10T08:00:00Z",
  "modifiedTime": "2021-08-10T08:00:00Z"
}
