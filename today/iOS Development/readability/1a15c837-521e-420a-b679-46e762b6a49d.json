{
  "id": "1a15c837-521e-420a-b679-46e762b6a49d",
  "title": "Faster iOS performance debugging with ETTrace",
  "link": "https://swiftrocks.com/faster-performance-debugging-with-ettrace",
  "description": "Performance problems can be rare in this era of blazing-fast iPhones, but chances are you're still having to deal with them every once in a while. Classic performance issues such as scroll hitches are still very easy to introduce if you're not careful about them, and when it happens, you'll want to be properly equipped to get to the bottom of it. The \"standard\" way of debugging performance issues in iOS is to use Xcode's Time Profiler instrument, but I personally never had a good experience with it. While it contains all the information you need to understand a particular problem, that information is not exactly easy to make sense of. To make it worse, sometimes even getting the information to show up in the first place can be quite the challenge, as Instruments in iOS in general have been historically broken and plagued by bad UX. Thankfully, you don't have to go through any of that! Today much better performance debugging tools are available (and for free), and in this article, I'll show you one of them. Enter ETTrace ETTrace is an open-source performance measurement framework for iOS developed by the folks behind Emerge, and I can say that today this is my favorite tool for measuring and debugging performance problems in iOS. As mentioned in the beginning, while the Time Profiler does technically provide you with all the information that you need, actually understanding this information or even getting it to show up in the first place can be a big challenge, even if you know exactly what you're doing. For me, personally, there are three things that make the Time Profiler hard to use. The first one is that you need to compile a special Profile build for it to work, meaning you cannot run it ad-hoc on an existing build or device. The second is that the Time Profiler has a really annoying tendency to simply refuse to work every once in a while, mostly when it comes to symbolication. Finally, last but not least, when you do manage to get it to work, the way in which the data is presented to you is not very helpful when it comes to locating the source of a particular performance bottleneck. In other words, there are better ways to display this data. ETTrace, on the other hand, has none of these problems. It doesn't require a special build, it automatically handles symbolication for you, and it displays the data in a much more readable way. It's basically the Time Profiler on steroids, and I have found it to be in most cases a complete replacement for it. Example: Using ETTrace to find and fix a bottleneck For instructions on how to install ETTrace, check out the official repo. As of writing, ETTrace is installed by linking a dynamic framework into your app and installing a special ettrace CLI tool in your Mac. You can trace any build of your app that links against this framework, which is why you don't need to compile a special Profile build like you would when using Xcode and the Time Profiler. In practice you could even ship this framework alongside your App Store builds in order to be able to directly debug issues found in production, but I would personally not do that and keep it restricted to debug builds. To see how ETTrace can help us debug performance issues better than the standard Time Profiler, let's pretend that we have a view controller called ExploreCardViewController, and that we have noticed that tapping a specific collection view cell in this VC is causing the app to freeze for a while. To find out exactly why this is happening, we just need to run ETTrace. After following the usage steps as described on the repo, you'd be presented with something like this: This way of displaying information is called a Flame Graph, and I find it to be a very efficient way of locating performance bottlenecks in your app's code. Each \"entry\" that you see here is a single method call in your app, with the X axis dictating when it was called (and how long it took to run), and the Y axis dictating where/who called it. In the example above, the first 3 frames (start/main/UIApplicationMain) represent functions internal to iOS that are responsible for launching and keeping the app alive, while everything else below it is actual code from our example app. To find performance bottlenecks in a flame graph, all we need to do is look for the presence of a \"chunky\" stack trace and then go down the Y axis until we find which frame exactly is the source of the chunkiness. Consider how ExploreCardViewController is shown in the report. It's very large, which means that this method is taking a really long time to run. But what exactly is causing it? Is it the literal call to didSelectItemAt, or is it something else further down the stack trace? By going down the trace we can see that at its very bottom there's a very expensive call to usleep originating from ArticleViewController.viewDidLoad(), which is the reason why that entire stack trace is being reported as being expensive: Oops, seems like we forgot some debug code in our class! func viewDidLoad() { sleep(1) // TODO: remove this! } After deleting the call, the bottleneck was gone! You may find this to be a dumb example, but I find that debugging real performance issues doesn't stray too far from this. The difference is just that instead of a dumb call to sleep, you'd see some other expensive operation. Otherwise, the process to locate it and the different ways in which you could fix it are the same. Other useful ETTrace features The example above showed a bottleneck that originated from a single very expensive call, but that's not the only source of performance issues. Sometimes the bottleneck may originate not from one large call, but multiple small ones in rapid sequence. ETTrace's Invert and Cluster Libraries allow you to quickly debug issues like this by merging all those small calls together. For clarity, this is something that the Time Profiler can also do, but again, it's just that I personally find that ETTrace's flame graphs are much easier to understand than the Time Profiler's tree structure. Another feature I find myself using a lot is the comparison view. By uploading a second trace file, ETTrace will present you the difference between both traces, allowing you to quickly determine which methods became faster and which methods became slower. This can be good for getting some quick information about whether or something improves or causes a bottleneck, but note that this is not a very reliable way of determining how fast/slow exactly a particular method is. If you need very accurate information, then I recommend using Attabench. Alternatively, if your company happens to pay for Emerge's enterprise solutions, you can also use their performance analysis product, which is similar to ETTrace but with the difference that it can actually provide you with data that is statistically significant. Does it completely replace the Time Profiler? I have been using ETTrace for most of my performance debugging work, but there are still a couple of cases where you might need to use the Time Profiler. The first case that comes to my mind is when you need to debug something that you cannot reproduce, which is something that I've covered previously here at SwiftRocks. For cases like this you'll find Apple's performance trace profiles to be the best solution, which currently require you to use Xcode and the Time Profiler. Another case you might still need the Time Profiler for is when you're looking not just for performance data, but also other types of iOS-related information such as thread state, device temperature, battery level, os_logs, signposts, hangs, and so on. Nothing currently matches Xcode's Instruments when it comes to putting all this device information into one single place, so issues that require looking at multiple types of device information are still perfectly suited for it.",
  "author": "Bruno Rocha",
  "published": "Thu, 7 Sep 2023 14:00:00 GMT+2",
  "source": "https://swiftrocks.com/rss.xml",
  "categories": null,
  "byline": "Bruno Rocha",
  "length": 7886,
  "excerpt": "Still using the Time Profiler? Better performance debugging tools are available today, and in this article, I'll show you one of them.",
  "siteName": "SwiftRocks",
  "favicon": "https://swiftrocks.com/images/favicon/iconsmall2.png",
  "text": "Performance problems can be rare in this era of blazing-fast iPhones, but chances are you're still having to deal with them every once in a while. Classic performance issues such as scroll hitches are still very easy to introduce if you're not careful about them, and when it happens, you'll want to be properly equipped to get to the bottom of it. The \"standard\" way of debugging performance issues in iOS is to use Xcode's Time Profiler instrument, but I personally never had a good experience with it. While it contains all the information you need to understand a particular problem, that information is not exactly easy to make sense of. To make it worse, sometimes even getting the information to show up in the first place can be quite the challenge, as Instruments in iOS in general have been historically broken and plagued by bad UX. Thankfully, you don't have to go through any of that! Today much better performance debugging tools are available (and for free), and in this article, I'll show you one of them. Enter ETTrace ETTrace is an open-source performance measurement framework for iOS developed by the folks behind Emerge, and I can say that today this is my favorite tool for measuring and debugging performance problems in iOS. As mentioned in the beginning, while the Time Profiler does technically provide you with all the information that you need, actually understanding this information or even getting it to show up in the first place can be a big challenge, even if you know exactly what you're doing. For me, personally, there are three things that make the Time Profiler hard to use. The first one is that you need to compile a special Profile build for it to work, meaning you cannot run it ad-hoc on an existing build or device. The second is that the Time Profiler has a really annoying tendency to simply refuse to work every once in a while, mostly when it comes to symbolication. Finally, last but not least, when you do manage to get it to work, the way in which the data is presented to you is not very helpful when it comes to locating the source of a particular performance bottleneck. In other words, there are better ways to display this data. ETTrace, on the other hand, has none of these problems. It doesn't require a special build, it automatically handles symbolication for you, and it displays the data in a much more readable way. It's basically the Time Profiler on steroids, and I have found it to be in most cases a complete replacement for it. Example: Using ETTrace to find and fix a bottleneck For instructions on how to install ETTrace, check out the official repo. As of writing, ETTrace is installed by linking a dynamic framework into your app and installing a special ettrace CLI tool in your Mac. You can trace any build of your app that links against this framework, which is why you don't need to compile a special Profile build like you would when using Xcode and the Time Profiler. In practice you could even ship this framework alongside your App Store builds in order to be able to directly debug issues found in production, but I would personally not do that and keep it restricted to debug builds. To see how ETTrace can help us debug performance issues better than the standard Time Profiler, let's pretend that we have a view controller called ExploreCardViewController, and that we have noticed that tapping a specific collection view cell in this VC is causing the app to freeze for a while. To find out exactly why this is happening, we just need to run ETTrace. After following the usage steps as described on the repo, you'd be presented with something like this: This way of displaying information is called a Flame Graph, and I find it to be a very efficient way of locating performance bottlenecks in your app's code. Each \"entry\" that you see here is a single method call in your app, with the X axis dictating when it was called (and how long it took to run), and the Y axis dictating where/who called it. In the example above, the first 3 frames (start/main/UIApplicationMain) represent functions internal to iOS that are responsible for launching and keeping the app alive, while everything else below it is actual code from our example app. To find performance bottlenecks in a flame graph, all we need to do is look for the presence of a \"chunky\" stack trace and then go down the Y axis until we find which frame exactly is the source of the chunkiness. Consider how ExploreCardViewController is shown in the report. It's very large, which means that this method is taking a really long time to run. But what exactly is causing it? Is it the literal call to didSelectItemAt, or is it something else further down the stack trace? By going down the trace we can see that at its very bottom there's a very expensive call to usleep originating from ArticleViewController.viewDidLoad(), which is the reason why that entire stack trace is being reported as being expensive: Oops, seems like we forgot some debug code in our class! func viewDidLoad() { sleep(1) // TODO: remove this! } After deleting the call, the bottleneck was gone! You may find this to be a dumb example, but I find that debugging real performance issues doesn't stray too far from this. The difference is just that instead of a dumb call to sleep, you'd see some other expensive operation. Otherwise, the process to locate it and the different ways in which you could fix it are the same. Other useful ETTrace features The example above showed a bottleneck that originated from a single very expensive call, but that's not the only source of performance issues. Sometimes the bottleneck may originate not from one large call, but multiple small ones in rapid sequence. ETTrace's Invert and Cluster Libraries allow you to quickly debug issues like this by merging all those small calls together. For clarity, this is something that the Time Profiler can also do, but again, it's just that I personally find that ETTrace's flame graphs are much easier to understand than the Time Profiler's tree structure. Another feature I find myself using a lot is the comparison view. By uploading a second trace file, ETTrace will present you the difference between both traces, allowing you to quickly determine which methods became faster and which methods became slower. This can be good for getting some quick information about whether or something improves or causes a bottleneck, but note that this is not a very reliable way of determining how fast/slow exactly a particular method is. If you need very accurate information, then I recommend using Attabench. Alternatively, if your company happens to pay for Emerge's enterprise solutions, you can also use their performance analysis product, which is similar to ETTrace but with the difference that it can actually provide you with data that is statistically significant. Does it completely replace the Time Profiler? I have been using ETTrace for most of my performance debugging work, but there are still a couple of cases where you might need to use the Time Profiler. The first case that comes to my mind is when you need to debug something that you cannot reproduce, which is something that I've covered previously here at SwiftRocks. For cases like this you'll find Apple's performance trace profiles to be the best solution, which currently require you to use Xcode and the Time Profiler. Another case you might still need the Time Profiler for is when you're looking not just for performance data, but also other types of iOS-related information such as thread state, device temperature, battery level, os_logs, signposts, hangs, and so on. Nothing currently matches Xcode's Instruments when it comes to putting all this device information into one single place, so issues that require looking at multiple types of device information are still perfectly suited for it.",
  "image": "https://swiftrocks.com/images/thumbs/thumb.jpg?4",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \n  \n\u003cp\u003ePerformance problems can be rare in this era of blazing-fast iPhones, but chances are you\u0026#39;re still having to deal with them every once in a while. Classic performance issues such as scroll hitches are still very easy to introduce if you\u0026#39;re not careful about them, and when it happens, you\u0026#39;ll want to be properly equipped to get to the bottom of it.\u003c/p\u003e\n\n\u003cp\u003eThe \u0026#34;standard\u0026#34; way of debugging performance issues in iOS is to use Xcode\u0026#39;s \u003ci\u003eTime Profiler\u003c/i\u003e instrument, but I personally never had a good experience with it. While it contains all the information you need to understand a particular problem, that information is not exactly easy to make sense of. To make it worse, sometimes \u003ci\u003eeven getting the information to show up\u003c/i\u003e in the first place can be quite the challenge, \u003ca href=\"https://swiftrocks.com/reverse-engineering-xcode-issue-crash-symbol\"\u003eas Instruments in iOS in general have been historically broken and plagued by bad UX.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eThankfully, you don\u0026#39;t have to go through any of that! Today much better performance debugging tools are available (and for free), and in this article, I\u0026#39;ll show you one of them.\u003c/p\u003e\n\u003ch2\u003eEnter ETTrace\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/EmergeTools/ETTrace\"\u003eETTrace\u003c/a\u003e is an open-source performance measurement framework for iOS developed by the folks behind \u003ca href=\"https://www.emergetools.com/\"\u003eEmerge\u003c/a\u003e, and I can say that today this is my favorite tool for measuring and debugging performance problems in iOS.\u003c/p\u003e\n\u003cp\u003eAs mentioned in the beginning, while the Time Profiler does technically provide you with all the information that you need, actually understanding this information or even getting it to show up in the first place can be a big challenge, even if you know exactly what you\u0026#39;re doing.\u003c/p\u003e\n\u003cp\u003eFor me, personally, there are three things that make the Time Profiler hard to use. The first one is that you need to compile a special \u003ci\u003eProfile\u003c/i\u003e build for it to work, meaning you cannot run it ad-hoc on an existing build or device. The second is that the Time Profiler has a really annoying tendency to simply refuse to work every once in a while, mostly when it comes to symbolication. Finally, last but not least, when you do manage to get it to work, the way in which the data is presented to you is not very helpful when it comes to locating the source of a particular performance bottleneck. In other words, there are better ways to display this data.\u003c/p\u003e\n\u003cp\u003eETTrace, on the other hand, has none of these problems. \u003cb\u003eIt doesn\u0026#39;t require a special build, it automatically handles symbolication for you, and it displays the data in a much more readable way.\u003c/b\u003e It\u0026#39;s basically the Time Profiler on steroids, and I have found it to be in most cases a complete replacement for it.\u003c/p\u003e\n\u003ch2\u003eExample: Using ETTrace to find and fix a bottleneck\u003c/h2\u003e\n\u003cp\u003eFor instructions on how to install ETTrace, \u003ca href=\"https://github.com/EmergeTools/ETTrace\"\u003echeck out the official repo.\u003c/a\u003e As of writing, ETTrace is installed by linking a dynamic framework into your app and installing a special \u003ccode\u003eettrace\u003c/code\u003e CLI tool in your Mac. You can trace any build of your app that links against this framework, which is why you don\u0026#39;t need to compile a special \u003ci\u003eProfile\u003c/i\u003e build like you would when using Xcode and the Time Profiler. In practice you could even ship this framework alongside your App Store builds in order to be able to directly debug issues found in production, but I would personally not do that and keep it restricted to debug builds.\u003c/p\u003e\n\u003cp\u003eTo see how ETTrace can help us debug performance issues better than the standard Time Profiler, let\u0026#39;s pretend that we have a view controller called \u003ccode\u003eExploreCardViewController\u003c/code\u003e, and that we have noticed that tapping a specific collection view cell in this VC is causing the app to freeze for a while.\u003c/p\u003e\n\u003cp\u003eTo find out exactly why this is happening, we just need to run ETTrace. After following the usage steps as described on the repo, you\u0026#39;d be presented with something like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://i.imgur.com/83Xzhe7.png\" alt=\"Emerge\"/\u003e\n\u003c/p\u003e\n\u003cp\u003eThis way of displaying information is called a \u003cb\u003eFlame Graph\u003c/b\u003e, and I find it to be a very efficient way of locating performance bottlenecks in your app\u0026#39;s code. Each \u0026#34;entry\u0026#34; that you see here is a single method call in your app, with the X axis dictating \u003cb\u003ewhen\u003c/b\u003e it was called (and how long it took to run), and the Y axis dictating \u003cb\u003ewhere/who\u003c/b\u003e called it. In the example above, the first 3 frames (start/main/UIApplicationMain) represent functions internal to iOS that are responsible for launching and keeping the app alive, while everything else below it is actual code from our example app.\u003c/p\u003e\n\u003cp\u003eTo find performance bottlenecks in a flame graph, all we need to do is look for the presence of a \u0026#34;chunky\u0026#34; stack trace and then go down the Y axis until we find \u003ci\u003ewhich frame exactly\u003c/i\u003e is the source of the chunkiness.\u003c/p\u003e\n\u003cp\u003eConsider how \u003ccode\u003eExploreCardViewController\u003c/code\u003e is shown in the report. It\u0026#39;s very large, which means that this method is taking a really long time to run. But what exactly is \u003ci\u003ecausing\u003c/i\u003e it? Is it the literal call to \u003ccode\u003edidSelectItemAt\u003c/code\u003e, or is it something else further down the stack trace?\u003c/p\u003e\n\u003cp\u003eBy going down the trace we can see that at its very bottom there\u0026#39;s a \u003ci\u003every\u003c/i\u003e expensive call to \u003ccode\u003eusleep\u003c/code\u003e originating from \u003ccode\u003eArticleViewController.viewDidLoad()\u003c/code\u003e, which is the reason why that entire stack trace is being reported as being expensive:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://i.imgur.com/HclPx0t.png\" alt=\"Emerge\"/\u003e\n\u003c/p\u003e\n\u003cp\u003eOops, seems like we forgot some debug code in our class!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc viewDidLoad() {\u003c/code\u003e\n\u003ccode\u003e    sleep(1) // TODO: remove this!\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eAfter deleting the call, the bottleneck was gone!\u003c/p\u003e\n\u003cp\u003eYou may find this to be a dumb example, but I find that debugging real performance issues doesn\u0026#39;t stray too far from this. The difference is just that instead of a dumb call to \u003ccode\u003esleep\u003c/code\u003e, you\u0026#39;d see some other expensive operation. Otherwise, the process to locate it and the different ways in which you could fix it are the same.\u003c/p\u003e\n\u003ch2\u003eOther useful ETTrace features\u003c/h2\u003e\n\u003cp\u003eThe example above showed a bottleneck that originated from a single very expensive call, but that\u0026#39;s not the only source of performance issues. Sometimes the bottleneck may originate not from one large call, but multiple small ones in rapid sequence.\u003c/p\u003e\n\u003cp\u003eETTrace\u0026#39;s \u003cb\u003eInvert\u003c/b\u003e and \u003cb\u003eCluster Libraries\u003c/b\u003e allow you to quickly debug issues like this by merging all those small calls together. For clarity, this is something that the Time Profiler can also do, but again, it\u0026#39;s just that I personally find that ETTrace\u0026#39;s flame graphs are much easier to understand than the Time Profiler\u0026#39;s tree structure.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://i.imgur.com/nu9JB0Z.png\" alt=\"Emerge\"/\u003e\n\u003c/p\u003e\n\u003cp\u003eAnother feature I find myself using a lot is the \u003cb\u003ecomparison view\u003c/b\u003e. By uploading a second trace file, ETTrace will present you the \u003cb\u003edifference\u003c/b\u003e between both traces, allowing you to quickly determine which methods became faster and which methods became slower. This can be good for getting some quick information about whether or something improves or causes a bottleneck, but note that this is not a very reliable way of determining how fast/slow exactly a particular method is. If you need very accurate information, then I recommend using \u003ca href=\"https://swiftrocks.com/benchmarking-swift-code-properly-with-attabench\"\u003eAttabench\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://i.imgur.com/Wh1RsYZ.png\" alt=\"Emerge\"/\u003e\n\u003c/p\u003e\n\u003cp\u003eAlternatively, if your company happens to pay for Emerge\u0026#39;s enterprise solutions, you can also use their performance analysis product, which is similar to ETTrace but with the difference that it can actually provide you with data that is statistically significant.\u003c/p\u003e\n\u003ch2\u003eDoes it completely replace the Time Profiler?\u003c/h2\u003e\n\u003cp\u003eI have been using ETTrace for most of my performance debugging work, but there are still a couple of cases where you might need to use the Time Profiler.\u003c/p\u003e\n\u003cp\u003eThe first case that comes to my mind is when you need to \u003cb\u003edebug something that you cannot reproduce\u003c/b\u003e, which is something that \u003ca href=\"https://swiftrocks.com/debugging-ios-performance-issues-you-cant-reproduce-with-performance-trace-profiles\"\u003eI\u0026#39;ve covered previously here at SwiftRocks.\u003c/a\u003e For cases like this you\u0026#39;ll find Apple\u0026#39;s performance trace profiles to be the best solution, which currently require you to use Xcode and the Time Profiler.\u003c/p\u003e\n\n\u003cp\u003eAnother case you might still need the Time Profiler for is when you\u0026#39;re looking not just for performance data, but also other types of iOS-related information such as thread state, device temperature, battery level, os_logs, signposts, hangs, and so on. Nothing currently matches Xcode\u0026#39;s Instruments when it comes to putting all this device information into one single place, so issues that require looking at multiple types of device information are still perfectly suited for it.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2023-09-07T14:00:00+02:00",
  "modifiedTime": null
}
