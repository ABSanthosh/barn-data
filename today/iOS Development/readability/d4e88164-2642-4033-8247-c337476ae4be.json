{
  "id": "d4e88164-2642-4033-8247-c337476ae4be",
  "title": "Magical Particle Effects with SwiftUI Canvas",
  "link": "https://nerdyak.tech/development/2024/06/27/particle-effects-with-SwiftUI-Canvas.html",
  "description": "In one of the previous posts, I shared a simple way of Creating particle effects in SwiftUI. The approach is super easy and utilizes the power of viewModifiers, but I would not recommend it for production use as it is performance-greedy when having a bigger amount of particles in place (because each particle is a single view)",
  "author": "Pavel Zak",
  "published": "2024-06-27T00:00:00+00:00",
  "source": "https://nerdyak.tech/atom.xml",
  "categories": [
    "development",
    "SwiftUI",
    "Canvas",
    "Particles",
    "BlendMode",
    "TimelineView"
  ],
  "byline": "Pavel Zak",
  "length": 11123,
  "excerpt": "In one of the previous posts, I shared a simple way of Creating particle effects in SwiftUI. The approach is super easy and utilizes the power of viewModifiers, but I would not recommend it for production use as it is performance-greedy when having a bigger amount of particles in place (because each particle is a single view)",
  "siteName": "Pavel Zak",
  "favicon": "",
  "text": "In one of the previous posts, I shared a simple way of Creating particle effects in SwiftUI. The approach is super easy and utilizes the power of viewModifiers, but I would not recommend it for production use as it is performance-greedy when having a bigger amount of particles in place (because each particle is a single view) In this post, I will introduce you to an alternate and better approach - rendering the particles with the Canvas view. So letâ€™s get into it ðŸ’ª. Setup We will start with the following view outline: struct ParticleCanvasView: View { var body: some View { TimelineView(.animation) { context in Canvas { context, size in let particleSymbol = context.resolveSymbol(id: 0)! let position = CGPoint(x: size.width/2, y: size.height/2) context.draw(particleSymbol, at: position, anchor: .center) } symbols: { SingleParticleView() .tag(0) } } } } This view features an outer TimelineView that ensures its content (inner view) is regularly re-drawn. (note the .animation parameter allowing the system to decide the optimal refresh rate) The content here is a Canvas view. Those of you who come from good old UIKit days might be already familiar with the concept of the drawing context. In simple words, we get a canvas area with the view dimensions and we can draw/rasterize various entities on it - like shapes and images. In our case, we will draw a single particle represented with a SingleParticleView. Please note, how the SingleParticleView is being used as a drawing element. It is added to a symbols parameter allowing SwiftUI to pre-render it and thus be very performant later in the drawing calls - thus an ideal candidate for the many particles in the place ;) At this moment, letâ€™s just set the SingleParticleView as an orange dot, but we will tune it soon struct SingleParticleView: View { var body: some View { Circle().fill(Color.orange) .frame(width:35, height:35) } } So far, we have managed to draw a small orange dot, but it is about to change soon ;) I like to move it Now, letâ€™s move that particle. I will build here a fire-ish effect blending multiple upwards moving particles - so as a good start letâ€™s periodically move the single particle up from the canvas bottom: struct ParticleCanvasView: View { let movementDuration = 2.0 var body: some View { TimelineView(.animation) { context in let timeInterval = context.date.timeIntervalSinceReferenceDate; let time = timeInterval.truncatingRemainder(dividingBy: movementDuration)/movementDuration Canvas { context, size in let particleSymbol = context.resolveSymbol(id: 0)! let position = CGPoint(x: size.width/2, y: (1-time)*size.height) context.draw(particleSymbol, at: position, anchor: .center) } symbols: { SingleParticleView() .tag(0) } } } } You can see, that I am controlling the upwards movement with the time variable. What exactly is it in this context? Well, the timeline view already gives us access to the time property, but for our use, I want to have something normalized that can be easily bound with the particle movement. I want the particle movement to take exactly 2 seconds (see movementDuration) so the code computes time as a truncating remainder, making sure it will periodically grow from 0 to 1 forever. As you can see in the following video: Remember goniometry? As a next step, we will upgrade the movement from the simple linear to something more firey :). My perception of fire movement is that it is waving, so let me change the code to move the particle along a cosinus wave whose amplitude is smaller the higher the particle is: struct ParticleCanvasView: View { let movementDuration = 2.0 func particlePosition(timeInterval: Double, canvasSize: CGSize) -\u003e CGPoint { let time = timeInterval.truncatingRemainder(dividingBy: movementDuration)/movementDuration let rotations:CGFloat = 3 let amplitude: CGFloat = 0.1+0.8*(1-time) let x = canvasSize.width/2 + cos(rotations*time*CGFloat.pi*2)*canvasSize.width/2*amplitude return CGPoint(x: x, y: (1-time)*canvasSize.height) } var body: some View { TimelineView(.animation) { context in let timeInterval = context.date.timeIntervalSinceReferenceDate; Canvas { context, size in let particleSymbol = context.resolveSymbol(id: 0)! let position = particlePosition(timeInterval: timeInterval, canvasSize: size) context.draw(particleSymbol, at: position, anchor: .center) } symbols: { SingleParticleView() .tag(0) } } } } please note the position computation was moved to a separate function so the Canvas content remains clean. Make it many At this point, I am quite happy with the movement. I am sure we will fine-tune the constants here and there, but that can come later. Now, we want to draw more particles so letâ€™s wrap the drawing into the for-cycle like this: let particleCount = 100 // â€¦ for i in 0..\u003cparticleCount { let position = particlePosition(timeInterval: timeInterval+(Double(i)/Double(particleCount)), canvasSize: size) context.draw(particleSymbol, at: position, anchor: .center) } Randomize We can finally see more particles, but they all share the same path, so let me initiate each particle with random starting wave rotation and starting time offset: struct ParticleCanvasView: View { let movementDuration: Double let particleCount: Int let startingParticleOffsets: [CGFloat] let startingParticleAlphas: [CGFloat] init(particleCount: Int = 200, movementDuration: Double = 3.0) { self.particleCount = particleCount self.movementDuration = movementDuration self.startingParticleOffsets = Array(0..\u003cparticleCount).map {_ in CGFloat.random(in: 0...1)} self.startingParticleAlphas = Array(0..\u003cparticleCount).map {_ in CGFloat.random(in: 0...CGFloat.pi*2)} } func particlePosition(index: Int, timeInterval: Double, canvasSize: CGSize) -\u003e CGPoint { let startingRotation: CGFloat = startingParticleAlphas[index]//CGFloat(index)/CGFloat(particleCount)*CGFloat.pi let startingTimeOffset = startingParticleOffsets[index]*movementDuration let time = (timeInterval+startingTimeOffset).truncatingRemainder(dividingBy: movementDuration)/movementDuration let rotations:CGFloat = 3 let amplitude: CGFloat = 0.1+0.8*(1-time) let x = canvasSize.width/2 + cos(rotations*time*CGFloat.pi*2+startingRotation)*canvasSize.width/2*amplitude return CGPoint(x: x, y: (1-time)*canvasSize.height) } Improving the effect appearance In terms of particle motion, I consider this done, but we still need to fine-tune this effectâ€™s appearance to get some juiciness. The first improvement is changing the particle opacity during the opacity movement - this is quite simple by changing the context opacity before a draw call: context.opacity = positionAndAlpha.1 Next, letâ€™s utilize the blending capabilities of SwiftUI and set the particle appearance like this: struct SingleParticleView: View { var body: some View { Circle().fill(Color.orange.opacity(0.4)) .frame(width:35, height:35) .blendMode(.plusLighter) .blur(radius: 10) } } We make particles here as a nice big blurry spots, that blends together to form a fire volume. The blendMode(.plusLighter) combines overlapping orange dots, effectively brightening the result where the patrticles intersect. At this point, I am still not very happy with the result and will need to introduce more tweaks. This is very typical in such a creative process that your initial idea is not exactly aligned with the implementation and you are required to iterate on it. The thing that bothers me is that the particles are more dense at the top of the view, while I would prefer otherwise. To fix that, let me get rid of the even y-axis distribution and adjust the y-coordinate like this: let y = (1-time*time)*canvasSize.height Also, I would like to boost the particle vanishing effect so let me decrease the particle opacity with time. The final effect I am happy with is: struct ParticleCanvasView: View { let movementDuration: Double let particleCount: Int let startingParticleOffsets: [CGFloat] let startingParticleAlphas: [CGFloat] init(particleCount: Int = 200, movementDuration: Double = 3.0) { self.particleCount = particleCount self.movementDuration = movementDuration self.startingParticleOffsets = Array(0..\u003cparticleCount).map {_ in CGFloat.random(in: 0...1)} self.startingParticleAlphas = Array(0..\u003cparticleCount).map {_ in CGFloat.random(in: 0...CGFloat.pi*2)} } func particlePositionAndAlpha(index: Int, timeInterval: Double, canvasSize: CGSize) -\u003e (CGPoint, CGFloat) { let startingRotation: CGFloat = startingParticleAlphas[index] let startingTimeOffset = startingParticleOffsets[index]*movementDuration let time = (timeInterval+startingTimeOffset).truncatingRemainder(dividingBy: movementDuration)/movementDuration let rotations:CGFloat = 1.5 let amplitude: CGFloat = 0.1+0.8*(1-time) let x = canvasSize.width/2 + cos(rotations*time*CGFloat.pi*2 + startingRotation)*canvasSize.width/2*amplitude*0.8 let y = (1-time*time)*canvasSize.height return (CGPoint(x: x, y: y), 1-time) } var body: some View { TimelineView(.animation) { context in let timeInterval = context.date.timeIntervalSinceReferenceDate; Canvas { context, size in let particleSymbol = context.resolveSymbol(id: 0)! for i in 0..\u003cparticleCount { let positionAndAlpha = particlePositionAndAlpha(index: i, timeInterval: timeInterval, canvasSize: size) context.opacity = positionAndAlpha.1 context.draw(particleSymbol, at: positionAndAlpha.0, anchor: .center) } } symbols: { SingleParticleView() .tag(0) } } } } Your turn! Now it is your time to get creative! Things to try change particle appearance change particle movement paths combine multiple particle types react to user inputs ðŸ’« â€¦ Here is a result of more experiments and adjustments: Enjoy! And let me know, if you find this article helpful, and send me your animations on Twitter.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\" aria-label=\"Content\"\u003e\n    \u003carticle\u003e\n      \u003cdiv\u003e\n        \u003cp\u003eIn one of the previous posts, I shared a simple way of \u003ca href=\"https://nerdyak.tech/development/2020/12/12/create-particles-in-swiftui.html\"\u003eCreating particle effects in SwiftUI\u003c/a\u003e. The approach is super easy and utilizes the power of viewModifiers, but I would not recommend it for production use as it is performance-greedy when having a bigger amount of particles in place (because each particle is a single view)\u003c/p\u003e\n\n\u003cp\u003eIn this post, I will introduce you to an \u003cstrong\u003ealternate and better\u003c/strong\u003e approach - rendering the particles with the \u003ccode\u003eCanvas\u003c/code\u003e view. So letâ€™s get into it ðŸ’ª.\u003c/p\u003e\n\n\u003ch2 id=\"setup\"\u003eSetup\u003c/h2\u003e\n\n\u003cp\u003eWe will start with the following view outline:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eParticleCanvasView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eTimelineView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n            \u003cspan\u003eCanvas\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\t       \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eparticleSymbol\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresolveSymbol\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\n                \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eposition\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e                    \n                \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edraw\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparticleSymbol\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eat\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eposition\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eanchor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003esymbols\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003eSingleParticleView\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n                    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etag\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eThis view features an outer \u003ca href=\"https://developer.apple.com/documentation/swiftui/timelineview\"\u003eTimelineView\u003c/a\u003e that ensures its content (inner view) is regularly re-drawn. (note the \u003ccode\u003e.animation\u003c/code\u003e parameter allowing the system to decide the optimal refresh rate)\nThe content here is a \u003ca href=\"https://developer.apple.com/documentation/swiftui/canvas/\"\u003eCanvas\u003c/a\u003e view. Those of you who come from good old UIKit days might be already familiar with the concept of the drawing context. In simple words, we get a canvas area with the view dimensions and we can draw/rasterize\nvarious entities on it - like shapes and images.\u003c/p\u003e\n\n\u003cp\u003eIn our case, we will draw a single particle represented with a \u003ccode\u003eSingleParticleView\u003c/code\u003e. Please note, how the SingleParticleView is being used as a \u003cstrong\u003edrawing element\u003c/strong\u003e. It is added to a symbols parameter allowing SwiftUI to \u003cstrong\u003epre-render\u003c/strong\u003e it and thus be very performant later in the drawing calls - thus an ideal candidate for the many particles in the place ;)\u003c/p\u003e\n\n\u003cp\u003eAt this moment, letâ€™s just set the \u003ccode\u003eSingleParticleView\u003c/code\u003e as an orange dot, but we will tune it soon\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eSingleParticleView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eCircle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efill\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eorange\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e35\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e35\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eSo far, we have managed to draw a small orange dot, but it is about to change soon ;)\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/16_01.png\" alt=\"image1\" title=\"Static particle\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"i-like-to-move-it\"\u003eI like to move it\u003c/h2\u003e\n\n\u003cp\u003eNow, letâ€™s move that particle.\u003c/p\u003e\n\n\u003cp\u003eI will build here a fire-ish effect blending multiple upwards moving particles - so as a good start letâ€™s periodically move the single particle up from the canvas bottom:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eParticleCanvasView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2.0\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eTimelineView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etimeInterval\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etimeIntervalSinceReferenceDate\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n            \n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etime\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etruncatingRemainder\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edividingBy\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003emovementDuration\u003c/span\u003e\n            \n            \u003cspan\u003eCanvas\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n                \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eparticleSymbol\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresolveSymbol\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\n                \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eposition\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                    \n                \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edraw\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparticleSymbol\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eat\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eposition\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eanchor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003esymbols\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003eSingleParticleView\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n                    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etag\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eYou can see, that I am controlling the upwards movement with the \u003cem\u003etime\u003c/em\u003e variable. What exactly is it in this context? Well, the timeline view already gives us access to the time property, but for our use, I want to have something normalized that can be easily bound with the particle movement.\nI want the particle movement to take exactly 2 seconds (see movementDuration) so the code computes time as a truncating remainder, making sure it will periodically grow from 0 to 1 forever. As you can see in the following video:\u003c/p\u003e\n\n\u003ccenter\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" controls=\"controls\" width=\"400\"\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_01.mov\"/\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_01.webm\" type=\"video/webm\"/\u003e\n\u003c/video\u003e\n\u003c/center\u003e\n\n\u003ch2 id=\"remember-goniometry\"\u003eRemember goniometry?\u003c/h2\u003e\n\n\u003cp\u003eAs a next step, we will upgrade the movement from the simple linear to something more firey :). My perception of fire movement is that it is waving, so let me change the code to move the particle along a cosinus wave whose amplitude is smaller the higher the particle is:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eParticleCanvasView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2.0\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eparticlePosition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etime\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etruncatingRemainder\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edividingBy\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003emovementDuration\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003erotations\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eamplitude\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0.1\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e0.8\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003ecos\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erotations\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epi\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2*\u003c/span\u003e\u003cspan\u003eamplitude\u003c/span\u003e\n        \n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eTimelineView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etimeInterval\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etimeIntervalSinceReferenceDate\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n            \n            \u003cspan\u003eCanvas\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n                \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eparticleSymbol\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresolveSymbol\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\n                \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eposition\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eparticlePosition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                \n                \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edraw\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparticleSymbol\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eat\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eposition\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eanchor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003esymbols\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003eSingleParticleView\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n                    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etag\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003ccenter\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" controls=\"controls\" width=\"400\"\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_02.mov\"/\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_02.webm\" type=\"video/webm\"/\u003e\n\u003c/video\u003e\n\u003c/center\u003e\n\n\u003cp\u003eplease note the position computation was moved to a separate function so the Canvas content remains clean.\u003c/p\u003e\n\n\u003ch2 id=\"make-it-many\"\u003eMake it many\u003c/h2\u003e\n\n\u003cp\u003eAt this point, I am quite happy with the movement. I am sure we will fine-tune the constants here and there, but that can come later. Now, we want to draw more particles so letâ€™s wrap the drawing into the for-cycle like this:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eparticleCount\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e100\u003c/span\u003e\n\u003cspan\u003e// â€¦\u003c/span\u003e\n\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003eparticleCount\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eposition\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eparticlePosition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparticleCount\u003c/span\u003e\u003cspan\u003e)),\u003c/span\u003e \u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edraw\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparticleSymbol\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eat\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eposition\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eanchor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003ccenter\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" controls=\"controls\" width=\"400\"\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_03.mov\"/\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_03.webm\" type=\"video/webm\"/\u003e\n\u003c/video\u003e\n\u003c/center\u003e\n\n\u003ch2 id=\"randomize\"\u003eRandomize\u003c/h2\u003e\n\n\u003cp\u003eWe can finally see more particles, but they all share the same path, so let me initiate each particle with random starting wave rotation and starting time offset:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eParticleCanvasView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eparticleCount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartingParticleOffsets\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartingParticleAlphas\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n    \n    \u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparticleCount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e200\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e3.0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eparticleCount\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eparticleCount\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emovementDuration\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estartingParticleOffsets\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eArray\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003eparticleCount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erandom\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)}\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estartingParticleAlphas\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eArray\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003eparticleCount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erandom\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epi\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eparticlePosition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartingRotation\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e  \u003cspan\u003estartingParticleAlphas\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e//CGFloat(index)/CGFloat(particleCount)*CGFloat.pi\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartingTimeOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estartingParticleOffsets\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003emovementDuration\u003c/span\u003e\n        \n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etime\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003estartingTimeOffset\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etruncatingRemainder\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edividingBy\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003emovementDuration\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003erotations\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eamplitude\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0.1\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e0.8\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003ecos\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erotations\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epi\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003estartingRotation\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2*\u003c/span\u003e\u003cspan\u003eamplitude\u003c/span\u003e\n        \n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003ccenter\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" controls=\"controls\" width=\"400\"\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_04.mov\"/\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_04.webm\" type=\"video/webm\"/\u003e\n\u003c/video\u003e\n\u003c/center\u003e\n\n\u003ch2 id=\"improving-the-effect-appearance\"\u003eImproving the effect appearance\u003c/h2\u003e\n\n\u003cp\u003eIn terms of particle motion, I consider this done, but we still need to fine-tune this effectâ€™s appearance to get some juiciness.\u003c/p\u003e\n\n\u003cp\u003eThe first improvement is changing the particle opacity during the opacity movement - this is quite simple by changing the context opacity before a draw call:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eopacity\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003epositionAndAlpha\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eNext, letâ€™s utilize the blending capabilities of SwiftUI and set the particle appearance like this:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eSingleParticleView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eCircle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efill\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eorange\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eopacity\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0.4\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e35\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e35\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eblendMode\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eplusLighter\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eblur\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eradius\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eWe make particles here as a nice big blurry spots, that blends together to form a fire volume. The blendMode(.plusLighter) combines overlapping orange dots, effectively brightening the result where the patrticles intersect.\u003c/p\u003e\n\n\u003ccenter\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" controls=\"controls\" width=\"400\"\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_07.mov\"/\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_07.webm\" type=\"video/webm\"/\u003e\n\u003c/video\u003e\n\u003c/center\u003e\n\n\u003cp\u003eAt this point, I am still not very happy with the result and will need to introduce more tweaks. This is very typical in such a creative process that your initial idea is not exactly aligned with the implementation and you are required to iterate on it.\u003c/p\u003e\n\n\u003cp\u003eThe thing that bothers me is that the particles are more dense at the top of the view, while I would prefer otherwise. To fix that, let me get rid of the even y-axis distribution and adjust the y-coordinate like this:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eAlso, I would like to boost the particle vanishing effect so let me decrease the particle opacity with time.\u003c/p\u003e\n\n\u003cp\u003eThe final effect I am happy with is:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eParticleCanvasView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eparticleCount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartingParticleOffsets\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartingParticleAlphas\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n    \n    \u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparticleCount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e200\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e3.0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eparticleCount\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eparticleCount\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emovementDuration\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estartingParticleOffsets\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eArray\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003eparticleCount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erandom\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)}\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estartingParticleAlphas\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eArray\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003eparticleCount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erandom\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epi\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eparticlePositionAndAlpha\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartingRotation\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estartingParticleAlphas\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartingTimeOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estartingParticleOffsets\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003emovementDuration\u003c/span\u003e\n        \n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etime\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003estartingTimeOffset\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etruncatingRemainder\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edividingBy\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emovementDuration\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003emovementDuration\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003erotations\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1.5\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eamplitude\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0.1\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e0.8\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003ecos\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erotations\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epi\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003estartingRotation\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2*\u003c/span\u003e\u003cspan\u003eamplitude\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e0.8\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\n        \n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003etime\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eTimelineView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etimeInterval\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etimeIntervalSinceReferenceDate\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n            \n            \u003cspan\u003eCanvas\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n                \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eparticleSymbol\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresolveSymbol\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\n                \n                \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003eparticleCount\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003epositionAndAlpha\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eparticlePositionAndAlpha\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etimeInterval\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecanvasSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                    \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eopacity\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003epositionAndAlpha\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\n                    \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edraw\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparticleSymbol\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eat\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003epositionAndAlpha\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eanchor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003esymbols\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003eSingleParticleView\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n                    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etag\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003ccenter\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" controls=\"controls\" width=\"400\"\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_05.mov\"/\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_05.webm\" type=\"video/webm\"/\u003e\n\u003c/video\u003e\n\u003c/center\u003e\n\n\u003ch2 id=\"your-turn\"\u003eYour turn!\u003c/h2\u003e\n\n\u003cp\u003eNow it is your time to get creative!\u003c/p\u003e\n\n\u003cp\u003eThings to try\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003echange particle appearance\u003c/li\u003e\n  \u003cli\u003echange particle movement paths\u003c/li\u003e\n  \u003cli\u003ecombine multiple particle types\u003c/li\u003e\n  \u003cli\u003ereact to user inputs\u003c/li\u003e\n  \u003cli\u003eðŸ’« â€¦\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eHere is a result of more experiments and adjustments:\u003c/p\u003e\n\n\u003ccenter\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" controls=\"controls\" width=\"400\"\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_06.mov\"/\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/16_video_06.webm\" type=\"video/webm\"/\u003e\n\u003c/video\u003e\n\u003c/center\u003e\n\n\u003cp\u003eEnjoy! And let me know, if you find this article helpful, and send me your animations on \u003ca href=\"https://twitter.com/myridiphis\"\u003eTwitter\u003c/a\u003e.\u003c/p\u003e\n\n\n      \u003c/div\u003e\n      \n    \u003c/article\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2024-06-27T00:00:00Z",
  "modifiedTime": null
}
