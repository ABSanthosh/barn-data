{
  "id": "e711a354-e783-437c-9fd6-05ed8ba646a7",
  "title": "Deep Linking at Scale on iOS",
  "link": "https://albertodebortoli.com/2019/04/16/deep-linking-at-scale-on-ios/",
  "description": "How the iOS team at Just Eat built a scalable architecture to support navigation and deep linking. Originally published on the Just Eat Engineering Blog. In this article, we propose an architecture to implement a scalable solution to Deep Linking on iOS using an underlying Flow Controller-based architecture, all powered",
  "author": "Alberto De Bortoli",
  "published": "Tue, 16 Apr 2019 06:43:00 GMT",
  "source": "https://albertodebortoli.com/rss/",
  "categories": [
    "deep links",
    "deep linking",
    "universal links",
    "iOS",
    "navigation",
    "flow controllers",
    "state machine",
    "futures",
    "promises",
    "Just Eat"
  ],
  "byline": "Alberto De Bortoli",
  "length": 22156,
  "excerpt": "\u003e How the iOS team at Just Eat built a scalable architecture to support navigation and deep linking. Originally published on the Just Eat Engineering Blog [https://tech.just-eat.com/2019/04/16/deep-linking-at-scale-on-ios/]. In this article, we propose an architecture to implement a scalable solution to Deep Linking on iOS using an underlying Flow Controller-based architecture, all powered by a state machine and the Futures \u0026 Promises [https://en.wikipedia.org/wiki/Futures_and_promises] parad",
  "siteName": "Alberto De Bortoli",
  "favicon": "",
  "text": "How the iOS team at Just Eat built a scalable architecture to support navigation and deep linking. Originally published on the Just Eat Engineering Blog. In this article, we propose an architecture to implement a scalable solution to Deep Linking on iOS using an underlying Flow Controller-based architecture, all powered by a state machine and the Futures \u0026 Promises paradigm to keep the code more readable.At Just Eat, we use a dedicated component named NavigationEngine that is domain-specific to the Just Eat apps and their use cases. A demo project named NavigationEngineDemo that includes the NavigationEngine architecture (stripped out of many details not necessary to showcase the solution) is available on GitHub.OverviewDeep linking is one of the most underestimated problems to solve on mobile. A na√Øve explanation would say that given some sort of input, mobile apps can load a specific screen, but it only has practical meaning when combined with Universal Links on iOS and App Links on Android. In such cases, the input is a URL that would load a web page on the companion website.Let's use an example from Just Eat: opening the URL https://www.just-eat.co.uk/area/ec4m-london on a web browser would load the list of restaurants in the UK London area for the postcode EC4M. Deep linking to the mobile apps using the same URL should give a similar experience to the user.In reality, the problem is more complex than what it seems at first glance; non-tech people - and sometimes even developers - find it hard to grasp. Loading a web page in a browser is fundamentally different from implementing dedicated logic on mobile to show a UIViewController (iOS) or Activity (Android) to the user and populate it with information that will most likely be gathered from an API call.The logic to perform deep linking starts with parsing the URL, understanding the intent, constructing the user journey, performing the navigation to the target screen passing the info all the way down, and ultimately loading any required data asynchronously from a remote API. On top of all this, it also has to consider the state of the app: the user might have previously left the app in a particular state and dedicated logic would be needed to deep link from the existing to the target screen. A scenario to consider is when the user is not logged in and therefore some sections of the app may not be available.Deep linking can actually be triggered from a variety of sources:Safari web browserany app that allows tapping on a link (iMessage, Notes, etc.)any app that explicitly tries to open the app using custom URL schemesthe app itself (to perform jumps between sections)TodayExtensionShortcut items (Home Screen Quick Actions)Spotlight itemsIt should be evident that implementing a comprehensive and scalable solution that fully addresses deep linking is far from being trivial. It shouldn't be an after-thought but rather be baked into the app architecture from the initial app design.It should also be quite glaring what the main problem that needs to be solved first is: the app Navigation.Navigation itself is not a problem with a single solution (if it was, the solution would be provided by Apple/Google and developers would simply stick to it). A number of solutions were proposed over the years trying to make it simpler and generic to some degree - Router, Compass, XCoordinator to name just a few open-source components.I proposed the concept of Flow Controllers in my article Flow Controllers on iOS for a better navigation control back in 2014 when the community had already (I believe) started shifting towards similar approaches. Articles such as Improve your iOS Architecture with FlowControllers (by Krzysztof Zab≈Çocki), A Better MVC, Part 2: Fixing Encapsulation (by Dave DeLong), Flow Coordinators in iOS (by Dennis Walsh), and even as recently as 2019, Navigation with Flow Controllers (by Majid Jabrayilov) was published.To me, all the proposals share one main common denominator: flow controllers/coordinator and their API are necessarily domain-specific. Consider the following methods taken from one of the articles mentioned above referring to specific use cases:func showLoginViewController() { ... } func showSignupViewController() { ... } func showPasswordViewController() { ... } With the support of colleagues and friends, I tried proposing a generic and abstract solution but ultimately hit a wall. Attempts were proposed using enums to list the supported transitions (as XCoordinator shows in its README for instance) or relying on meta-programming dark magic in Objective-C (which is definitely the sign of a terrible design), neither of which satisfied me in terms of reusability and abstraction. I ultimately realized that it's perfectly normal for such problem to be domain-specific and that we don't necessarily have to find abstract solutions to all problems.TerminologyFor clarity on some of the terminology used in this article. Deep Linking: the ability to reach specific screens (via a flow) in the app either via a Deep Link or a Universal Link. Deep Link: URI with custom scheme (e.g. just-eat://just-eat.co.uk/login, just-eat-dk://just-eat.co.uk/settings) containing the information to perform deep linking in the app. When it comes to deep links, the host is irrelevant but it's good to keep it as part of the URL since it makes it easier to construct the URL using URLComponents and it keeps things more 'standard'. Universal Link: URI with http/https scheme (e.g. https://just-eat.co.uk/login) containing the information to perform deep linking in the app. Intent: the abstract intent of reaching a specific area of the app. E.g. goToOrderDetails(OrderId). State machine transition: transitions in the state machine allow navigating to a specific area in the app (state) from another one. If the app is in a state where the deep linking to a specific screen should not be allowed, the underlying state machine should not have the corresponding transition. SolutionNavigationEngine is the iOS module (pod) used by the teams at Just Eat, that holds the isolated logic for navigation and deep linking. As mentioned above, the magic sauce includes the usage of: FlowControllers to handle the transitions between ViewControllers in a clear and pre-defined way. Stateful state machines to allow transitions according to the current application state. More information on FSM (Finite State Machine) here and on the library at The easiest State Machine in Swift. Promis to keep the code readable using Futures \u0026 Promises to help avoiding the Pyramid of doom. Sticking to such a paradigm is also a key aspect for the whole design since every API in the stack is async. More info on the library at The easiest Promises in Swift. a pretty heavy amount of üß† NavigationEngine maintains separation of concerns between URL Parsing, Navigation, and Deep Linking. Readers can inspect the code in the NavigationEngineDemo project that also includes unit tests with virtually 100% code coverage. Following is an overview of the class diagram of the entire architecture stack.Architecture class diagramWhile the navigation is powered by a FlowController-based architecture, the deep linking logic is powered by NavigationIntentHandler and NavigationTransitioner (on top of the navigation stack).Note the single entry point named DeepLinkingFacade exposes the following API to cover the various input/sources we mentioned earlier:public func handleURL(_ url: URL) -\u003e Future\u003cBool\u003e public func openDeepLink(_ deepLink: DeepLink) -\u003e Future\u003cBool\u003e public func openShortcutItem(_ item: UIApplicationShortcutItem) -\u003e Future\u003cBool\u003e public func openSpotlightItem(_ userActivity: NSUserActivityProtocol) -\u003e Future\u003cBool\u003e Here are the sequence diagrams for each one. Refer to the demo project to inspect the code.NavigationAs mentioned earlier, the important concept to grasp is that there is simply no single solution to Navigation. I've noticed that such a topic quickly raises discussions and each engineer has different, sometimes strong opinions. It's more important to agree on a working solution that satisfies the given requirements rather than forcing personal preferences.Our NavigationEngine relies on the following navigation rules (based on Flow Controllers): FlowControllers wire up the domain-specific logic for the navigation ViewControllers don't allocate FlowControllers Only FlowControllers, AppDelegate and similar top-level objects can allocate ViewControllers FlowControllers are owned (retained) by the creators FlowControllers can have children FlowControllers and create a parent-child chain and can, therefore, be in a 1-to-many relationship FlowControllers in parent-child relationships communicate via delegation ViewControllers have weak references to FlowControllers ViewControllers are in a 1-to-1 relationship with FlowControllers All the FlowController domain-specific API must be future-based with Future\u003cBool\u003e as return type Deep linking navigation should occur with no more than one animation (i.e. for long journeys, only the last step should be animated) Deep linking navigation that pops a stack should occur without animation In the demo project, there are a number of *FlowControllerProtocols, each corresponding to a different section/domain of the hosting app. Examples such as RestaurantsFlowControllerProtocol and OrdersFlowControllerProtocol are taken from the Just Eat app and each one has domain specific APIs, e.g:func goToSearchAnimated(postcode: Postcode?, cuisine: Cuisine?, animated: Bool) -\u003e Future\u003cBool\u003e func goToOrder(orderId: OrderId, animated: Bool) -\u003e Future\u003cBool\u003e func goToRestaurant(restaurantId: RestaurantId) -\u003e Future\u003cBool\u003e func goToCheckout(animated: Bool) -\u003e Future\u003cBool\u003e Note that each one:accepts the animated parameterreturns Future\u003cBool\u003e so that flow sequence can be combinedFlow controllers should be combined sensibly to represent the app UI structure. In the case of Just Eat we have a RootFlowController as the root-level flow controller orchestrating the children. A FlowControllerProvider, used by the NavigationTransitioner, is instead the single entry point to access the entire tree of flow controllers.NavigationTransitioner provides an API such as:func goToLogin(animated: Bool) -\u003e Future\u003cBool\u003e func goFromHomeToSearch(postcode: Postcode?, cuisine: Cuisine?, animated: Bool) -\u003e Future\u003cBool\u003e This is responsible to keep the underlying state machine and what the app actually shows in sync. Note the goFromHomeToSearch method being verbose on purpose; it takes care of the specific transition from a given state (home).One level up in the stack, NavigationIntentHandler is responsible for combining the actions available from the NavigationTransitioner starting from a given NavigationIntent and creating a complete deep linking journey. It also takes into account the current state of the app. For example, showing the history of the orders should be allowed only if the user is logged in, but it would also be advisable to prompt the user to log in in case he/she is not, and then resume the original action. Allowing so provides a superior user experience rather than simply aborting the flow (it's what websites achieve by using the referring URL). Here is the implementation of the .goToOrderHistory intent in the NavigationIntentHandler:case .goToOrderHistory: switch userStatusProvider.userStatus { case .loggedIn: return navigationTransitioner.goToRoot(animated: false).thenWithResult { _ -\u003e Future\u003cBool\u003e in self.navigationTransitioner.goToOrderHistory(animated: true) } case .loggedOut: return navigationTransitioner.requestUserToLogin().then { future in switch future.state { case .result: return self.handleIntent(intent) // go recursive default: return Future\u003cBool\u003e.futureWithResolution(of: future) } } } Since in the design we make the entire API future-based, we can potentially interrupt the deep linking flow to prompt the user for details or simply gather missing information from a remote API. This is crucial and allows us to construct complex flows.By design, all journeys start by resetting the state of the app by calling goToRoot. This vastly reduces the number of possible transitions to take care of as we will describe in more detail in the next section dedicated to the underlying state machine.State MachineAs you might have realized by now, the proposed architecture makes use of an underlying Finite State Machine to keep track of the state of the app during a deep linking journey.Here is a simplified version of the state machine configurations used in the Just Eat iOS apps.In the picture, the red arrows are transitions that are available for logged in users only, the blue ones are for logged out users only, while the black ones can always be performed.Note that every state should allow going back to the .allPoppedToRoot state so that, regardless of what the current state of the app is, we can always reset the state and perform a deep linking action starting afresh. This drastically simplifies the graph, avoiding unnecessary transitions such as the one shown in the next picture.Notice that intents (NavigationIntent) are different from transitions (NavigationEngine.StateMachine.EventType). An intent contains the information to perform a deep linking journey, while the event type is the transition from one FSM state to another (or the same).NavigationTransitioner is the class that performs the transitions and applies the companion navigation changes. A navigation step is performed only if the corresponding transition is allowed and completed successfully. If a transition is not allowed, the flow is interrupted, reporting an error in the future. You can showcase a failure in the demo app by trying to follow the Login Universal Link (https://just-eat.co.uk/login) after having faked the login when following the Order History Universal Link (https://just-eat.co.uk/orders).UsageNavigationEngineDemo includes the whole stack that readers can use in client projects. Here are the steps for a generic integration of the code.Add the NavigationEngine stack (NavigationEngineDemo/NavigationEngine folder) to the client project. This can be done by either creating a dedicated pod as we do at Just Eat or by directly including the code.Include Promis and Stateful as dependencies in your Podfile (assuming the usage of Cocoapods).Modify according to your needs, implement classes for all the *FlowControllerProtocols, and connect them to the ViewControllers of the client. This step can be quite tedious depending on the status of your app and we suggest trying to mimic what has been done in the demo app.Add CFBundleTypeRole and CFBundleURLSchemes to the main target Info.plist file to support Deep Links. E.g.\u003ckey\u003eCFBundleURLTypes\u003c/key\u003e \u003carray\u003e \u003cdict\u003e \u003ckey\u003eCFBundleTypeRole\u003c/key\u003e \u003cstring\u003eEditor\u003c/string\u003e \u003ckey\u003eCFBundleURLSchemes\u003c/key\u003e \u003carray\u003e \u003cstring\u003eje-internal\u003c/string\u003e \u003cstring\u003ejusteat\u003c/string\u003e \u003cstring\u003ejust-eat\u003c/string\u003e \u003cstring\u003ejust-eat-uk\u003c/string\u003e \u003c/array\u003e \u003c/dict\u003e \u003c/array\u003e Add the applinks (in the Capabilities -\u003e Associated Domains section of the main target) you'd like to support. This will allow iOS to register the app for Universal Links on the given domains looking for the apple-app-site-association file at the root of those domains once the app is installed. E.g.Implement concrete classes for DeepLinkingSettingsProtocol and UserStatusProviding according to your needs. Again, see the examples in the demo project. The internalDeepLinkSchemes property in DeepLinkSettingsProtocol should contain the same values previously added to CFBundleURLSchemes, while the universalLinkHosts should contain the same applinks: values defined in Capabilities -\u003e Associated Domains.Setup the NavigationEngine stack in the AppDelegate's applicationDidFinishLaunching. To some degree, it should be something similar to the following:var window: UIWindow? var rootFlowController: RootFlowController! var deepLinkingFacade: DeepLinkingFacade! var userStatusProvider = UserStatusProvider() let deepLinkingSettings = DeepLinkingSettings() func applicationDidFinishLaunching(_ application: UIApplication) { // Init UI Stack let window = UIWindow(frame: UIScreen.main.bounds) let tabBarController = TabBarController.instantiate() // Root Flow Controller rootFlowController = RootFlowController(with: tabBarController) tabBarController.flowController = rootFlowController // Deep Linking core let flowControllerProvider = FlowControllerProvider(rootFlowController: rootFlowController) deepLinkingFacade = DeepLinkingFacade(flowControllerProvider: flowControllerProvider, navigationTransitionerDataSource: self, settings: deepLinkingSettings, userStatusProvider: userStatusProvider) // Complete UI Stack window.rootViewController = tabBarController window.makeKeyAndVisible() self.window = window } Modify NavigationTransitionerDataSource according to your needs and implement its methods. You might want to have a separate component and not using the AppDelegate.extension AppDelegate: NavigationTransitionerDataSource { func navigationTransitionerDidRequestUserToLogin() -\u003e Future\u003cBool\u003e { \u003c#async logic#\u003e } ... } Implement the entry points for handling incoming URLs/inputs in the AppDelegate:func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -\u003e Bool { // from internal deep links \u0026 TodayExtension deepLinkingFacade.openDeeplink(url).finally { future in \u003c#...#\u003e } return true } func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -\u003e Void) -\u003e Bool { switch userActivity.activityType { // from Safari case NSUserActivityTypeBrowsingWeb: if let webpageURL = userActivity.webpageURL { self.deepLinkingFacade.handleURL(webpageURL).finally { future in \u003c#...#\u003e } return true } return false // from Spotlight case CSSearchableItemActionType: self.deepLinkingFacade.openSpotlightItem(userActivity).finally { future in let originalInput = userActivity.userInfo![CSSearchableItemActivityIdentifier] as! String \u003c#...#\u003e } return true default: return false } } func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -\u003e Void) { // from shortcut items (Home Screen Quick Actions) deepLinkingFacade.openShortcutItem(shortcutItem).finally { future in let originalInput = shortcutItem.type \u003c#...#\u003e completionHandler(future.hasResult()) } } N.B. Since a number of tasks are usually performed at startup (both from cold and warm starts), it's suggested to schedule them using operation queues. The deep linking task should be one of the last tasks in the queue to make sure that dependencies are previously set up. Here is the great Advanced NSOperations talk by Dave DeLong from WWDC15.The UniversalLinkConverter class should be modified to match the paths in the apple-app-site-association, which should be reachable at the root of the website (the associated domain). It should be noted that if the app is opened instead of the browser, it would be because the Universal Link can be handled; and redirecting the user back to the web would be a fundamental mistake that should be solved by correctly defining the supported paths in the apple-app-site-association file.To perform internal app navigation via deep linking, the DeeplinkFactory class should be used to create DeepLink objects that can be fed into either handleURL(_ url: URL) or openDeepLink(_ deepLink: DeepLink).In-app testingThe module exposes a DeepLinkingTesterViewController that can be used to easily test deep linking within an app.Simply define a JSON file containing the Universal Links and Deep Links to test:{ \"universal_links\": [ \"https://just-eat.co.uk/\", \"https://just-eat.co.uk/home\", \"https://just-eat.co.uk/login\", ... ], \"deep_links\": [ \"JUSTEAT://irrelev.ant/home\", \"justeat://irrelev.ant/login\", \"just-eat://irrelev.ant/resetPassword?resetToken=xyz\", ... ] } Then feed it to the view controller as shown below. Alternatively, use a storyboard reference as shown in the demo app.let deepLinkingTesterViewController = DeepLinkingTesterViewController.instantiate() deepLinkingTesterViewController.delegate = self let path = Bundle.main.path(forResource: \"deeplinking_test_list\", ofType: \"json\")! deepLinkingTesterViewController.loadTestLinks(atPath: path) and implement the DeepLinkingTesterViewControllerDelegateextension AppDelegate: DeepLinkingTesterViewControllerDelegate { func deepLinkingTesterViewController(_ deepLinkingTesterViewController: DeepLinkingTesterViewController, didSelect url: URL) { self.deepLinkingFacade.handleURL(universalLink).finally { future in self.handleFuture(future, originalInput: universalLink.absoluteString) } } } ConclusionThe solution proposed in this article has proven to be highly scalable and customizable. We shipped it in the Just Eat iOS apps in March 2019 and our teams are gradually increasing the number of Universal Links supported as you can see from our apple-app-site-association.Before implementing and adopting NavigationEngine, supporting new kinds of links was a real hassle. Thanks to this architecture, it is now easy for each team in the company to support new deep link journeys. The declarative approach in defining the API, states, transitions, and intents forces a single way to extend the code which enables a coherent approach throughout the codebase.",
  "image": "https://albertodebortoli.com/content/images/size/w1200/2019/04/class_diagram_demo-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cblockquote\u003eHow the iOS team at Just Eat built a scalable architecture to support navigation and deep linking. \u003c/blockquote\u003e\u003cp\u003e\u003cem\u003eOriginally published on the \u003ca href=\"https://tech.just-eat.com/2019/04/16/deep-linking-at-scale-on-ios/?ref=albertodebortoli.com\"\u003eJust Eat Engineering Blog\u003c/a\u003e. \u003c/em\u003e\u003c/p\u003e\u003cp\u003eIn this article, we propose an architecture to implement a scalable solution to Deep Linking on iOS using an underlying Flow Controller-based architecture, all powered by a state machine and the \u003ca href=\"https://en.wikipedia.org/wiki/Futures_and_promises?ref=albertodebortoli.com\"\u003eFutures \u0026amp; Promises\u003c/a\u003e paradigm to keep the code more readable.\u003c/p\u003e\u003cp\u003eAt Just Eat, we use a dedicated component named \u003cstrong\u003eNavigationEngine\u003c/strong\u003e that is domain-specific to the Just Eat apps and their use cases. A demo project named NavigationEngineDemo that includes the NavigationEngine architecture (stripped out of many details not necessary to showcase the solution) is available on \u003ca href=\"https://github.com/justeat/NavigationEngineDemo?ref=albertodebortoli.com\"\u003eGitHub\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\u003cp\u003eDeep linking is one of the most underestimated problems to solve on mobile. A na√Øve explanation would say that given some sort of input, mobile apps can load a specific screen, but it only has practical meaning when combined with \u003ca href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html?ref=albertodebortoli.com\"\u003eUniversal Links\u003c/a\u003e on iOS and \u003ca href=\"https://developer.android.com/training/app-links?ref=albertodebortoli.com\"\u003eApp Links\u003c/a\u003e on Android. In such cases, the input is a URL that would load a web page on the companion website.\u003c/p\u003e\u003cp\u003eLet\u0026#39;s use an example from Just Eat: opening the URL \u003ca href=\"https://www.just-eat.co.uk/area/ec4m-london?ref=albertodebortoli.com\"\u003ehttps://www.just-eat.co.uk/area/ec4m-london\u003c/a\u003e on a web browser would load the list of restaurants in the UK London area for the postcode EC4M. Deep linking to the mobile apps using the same URL should give a similar experience to the user.\u003c/p\u003e\u003cp\u003eIn reality, the problem is more complex than what it seems at first glance; non-tech people - and sometimes even developers - find it hard to grasp. Loading a web page in a browser is fundamentally different from implementing dedicated logic on mobile to show a UIViewController (iOS) or Activity (Android) to the user and populate it with information that will most likely be gathered from an API call.\u003c/p\u003e\u003cp\u003eThe logic to perform deep linking starts with parsing the URL, understanding the intent, constructing the user journey, performing the navigation to the target screen passing the info all the way down, and ultimately loading any required data asynchronously from a remote API. On top of all this, it also has to consider the state of the app: the user might have previously left the app in a particular state and dedicated logic would be needed to deep link from the existing to the target screen. A scenario to consider is when the user is not logged in and therefore some sections of the app may not be available.\u003c/p\u003e\u003cp\u003eDeep linking can actually be triggered from a variety of sources:\u003c/p\u003e\u003cul\u003e\u003cli\u003eSafari web browser\u003c/li\u003e\u003cli\u003eany app that allows tapping on a link (iMessage, Notes, etc.)\u003c/li\u003e\u003cli\u003eany app that explicitly tries to open the app using \u003ca href=\"https://developer.apple.com/documentation/uikit/core_app/allowing_apps_and_websites_to_link_to_your_content/defining_a_custom_url_scheme_for_your_app?ref=albertodebortoli.com\"\u003ecustom URL schemes\u003c/a\u003e\u003c/li\u003e\u003cli\u003ethe app itself (to perform jumps between sections)\u003c/li\u003e\u003cli\u003eTodayExtension\u003c/li\u003e\u003cli\u003eShortcut items (\u003ca href=\"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/?ref=albertodebortoli.com\"\u003eHome Screen Quick Actions\u003c/a\u003e)\u003c/li\u003e\u003cli\u003eSpotlight items\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt should be evident that implementing a comprehensive and scalable solution that fully addresses deep linking is far from being trivial. It shouldn\u0026#39;t be an after-thought but rather be baked into the app architecture from the initial app design.\u003c/p\u003e\u003cp\u003eIt should also be quite glaring what the main problem that needs to be solved first is: \u003cstrong\u003ethe app Navigation\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eNavigation itself is not a problem with a single solution (if it was, the solution would be provided by Apple/Google and developers would simply stick to it). A number of solutions were proposed over the years trying to make it simpler and generic to some degree - \u003ca href=\"https://github.com/freshOS/Router?ref=albertodebortoli.com\"\u003eRouter\u003c/a\u003e, \u003ca href=\"https://github.com/hyperoslo/Compass?ref=albertodebortoli.com\"\u003eCompass\u003c/a\u003e, \u003ca href=\"https://github.com/quickbirdstudios/XCoordinator?ref=albertodebortoli.com\"\u003eXCoordinator\u003c/a\u003e to name just a few open-source components.\u003c/p\u003e\u003cp\u003eI proposed the concept of Flow Controllers in my article \u003ca href=\"https://albertodebortoli.com/2014/09/03/flow-controllers-on-ios-for-a-better-navigation-control/\"\u003eFlow Controllers on iOS for a better navigation control\u003c/a\u003e back in 2014 when the community had already (I believe) started shifting towards similar approaches. Articles such as \u003ca href=\"http://merowing.info/2016/01/improve-your-ios-architecture-with-flowcontrollers/?ref=albertodebortoli.com\"\u003eImprove your iOS Architecture with FlowControllers\u003c/a\u003e (by \u003cem\u003eKrzysztof Zab≈Çocki\u003c/em\u003e), \u003ca href=\"https://davedelong.com/blog/2017/11/06/a-better-mvc-part-2-fixing-encapsulation/?ref=albertodebortoli.com\"\u003eA Better MVC, Part 2: Fixing Encapsulation\u003c/a\u003e (by \u003cem\u003eDave DeLong\u003c/em\u003e), \u003ca href=\"https://medium.com/@dkw5877/flow-coordinators-333ed64f3dd?ref=albertodebortoli.com\"\u003eFlow Coordinators in iOS\u003c/a\u003e (by \u003cem\u003eDennis Walsh\u003c/em\u003e), and even as recently as 2019, \u003ca href=\"https://mecid.github.io/2019/02/20/navigation-with-flow-controllers/?ref=albertodebortoli.com\"\u003eNavigation with Flow Controllers\u003c/a\u003e (by \u003cem\u003eMajid Jabrayilov\u003c/em\u003e) was published.\u003c/p\u003e\u003cp\u003eTo me, all the proposals share one main common denominator: flow controllers/coordinator and their API are necessarily \u003cem\u003edomain-specific\u003c/em\u003e. Consider the following methods taken from one of the articles mentioned above referring to specific use cases:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc showLoginViewController() { ... }\nfunc showSignupViewController() { ... }\nfunc showPasswordViewController() { ... }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith the support of colleagues and friends, I tried proposing a generic and abstract solution but ultimately hit a wall. Attempts were proposed using enums to list the supported transitions (as \u003ca href=\"https://github.com/quickbirdstudios/XCoordinator?ref=albertodebortoli.com\"\u003eXCoordinator\u003c/a\u003e shows in its \u003ca href=\"https://github.com/quickbirdstudios/XCoordinator?ref=albertodebortoli.com#%EF%B8%8Fgetting-started\"\u003eREADME\u003c/a\u003e for instance) or relying on meta-programming dark magic in Objective-C (which is definitely the sign of a terrible design), neither of which satisfied me in terms of reusability and abstraction. I ultimately realized that it\u0026#39;s perfectly normal for such problem to be domain-specific and that we don\u0026#39;t necessarily have to find abstract solutions to all problems.\u003c/p\u003e\u003ch2 id=\"terminology\"\u003eTerminology\u003c/h2\u003e\u003cp\u003eFor clarity on some of the terminology used in this article.\u003c/p\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eDeep Linking\u003c/strong\u003e: the ability to reach specific screens (via a flow) in the app either via a Deep Link or a Universal Link.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eDeep Link\u003c/strong\u003e: URI with custom scheme (e.g. \u003ccode\u003ejust-eat://just-eat.co.uk/login\u003c/code\u003e, \u003ccode\u003ejust-eat-dk://just-eat.co.uk/settings\u003c/code\u003e) containing the information to perform deep linking in the app. When it comes to deep links, the host is irrelevant but it\u0026#39;s good to keep it as part of the URL since it makes it easier to construct the URL using \u003ccode\u003eURLComponents\u003c/code\u003e and it keeps things more \u0026#39;standard\u0026#39;.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eUniversal Link\u003c/strong\u003e: URI with http/https scheme (e.g. \u003ccode\u003ehttps://just-eat.co.uk/login\u003c/code\u003e) containing the information to perform deep linking in the app.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIntent\u003c/strong\u003e: the abstract intent of reaching a specific area of the app. E.g. \u003ccode\u003egoToOrderDetails(OrderId)\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eState machine transition\u003c/strong\u003e: transitions in the state machine allow navigating to a specific area in the app (state) from another one. If the app is in a state where the deep linking to a specific screen should not be allowed, the underlying state machine should not have the corresponding transition.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\u003cp\u003eNavigationEngine is the iOS module (pod) used by the teams at Just Eat, that holds the isolated logic for navigation and deep linking. As mentioned above, the magic sauce includes the usage of:\u003c/p\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://albertodebortoli.com/2014/09/03/flow-controllers-on-ios-for-a-better-navigation-control/\"\u003e\u003cstrong\u003eFlowControllers\u003c/strong\u003e\u003c/a\u003e to handle the transitions between ViewControllers in a clear and pre-defined way.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/albertodebortoli/Stateful?ref=albertodebortoli.com\"\u003e\u003cstrong\u003eStateful\u003c/strong\u003e\u003c/a\u003e state machines to allow transitions according to the current application state. More information on FSM (Finite State Machine) \u003ca href=\"https://brilliant.org/wiki/finite-state-machines/?ref=albertodebortoli.com\"\u003ehere\u003c/a\u003e and on the library at \u003ca href=\"https://albertodebortoli.com/2018/12/16/the-easiest-state-machine-in-swift/\"\u003eThe easiest State Machine in Swift\u003c/a\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/albertodebortoli/Promis?ref=albertodebortoli.com\"\u003e\u003cstrong\u003ePromis\u003c/strong\u003e\u003c/a\u003e to keep the code readable using Futures \u0026amp; Promises to help avoiding the \u003ca href=\"https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)?ref=albertodebortoli.com\"\u003ePyramid of doom\u003c/a\u003e. Sticking to such a paradigm is also a key aspect for the whole design since every API in the stack is async. More info on the library at \u003ca href=\"https://albertodebortoli.com/2018/02/12/the-easiest-promises-in-swift/\"\u003eThe easiest Promises in Swift\u003c/a\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ea pretty heavy amount of üß†\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNavigationEngine maintains separation of concerns between \u003cem\u003eURL Parsing\u003c/em\u003e, \u003cem\u003eNavigation\u003c/em\u003e, and \u003cem\u003eDeep Linking\u003c/em\u003e. Readers can inspect the code in the \u003ca href=\"https://github.com/justeat/NavigationEngineDemo?ref=albertodebortoli.com\"\u003eNavigationEngineDemo\u003c/a\u003e project that also includes unit tests with virtually 100% code coverage. Following is an overview of the class diagram of the entire architecture stack.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/04/class_diagram_demo-2.png\" alt=\"\" loading=\"lazy\"/\u003e\u003cfigcaption\u003eArchitecture class diagram\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eWhile the navigation is powered by a FlowController-based architecture, the deep linking logic is powered by \u003ccode\u003eNavigationIntentHandler\u003c/code\u003e and \u003ccode\u003eNavigationTransitioner\u003c/code\u003e (on top of the navigation stack).\u003c/p\u003e\u003cp\u003eNote the single entry point named \u003ccode\u003eDeepLinkingFacade\u003c/code\u003e exposes the following API to cover the various input/sources we mentioned earlier:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic func handleURL(_ url: URL) -\u0026gt; Future\u0026lt;Bool\u0026gt;\npublic func openDeepLink(_ deepLink: DeepLink) -\u0026gt; Future\u0026lt;Bool\u0026gt;\npublic func openShortcutItem(_ item: UIApplicationShortcutItem) -\u0026gt; Future\u0026lt;Bool\u0026gt;\npublic func openSpotlightItem(_ userActivity: NSUserActivityProtocol) -\u0026gt; Future\u0026lt;Bool\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere are the sequence diagrams for each one. Refer to the demo project to inspect the code.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/04/handleURL-5.svg\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/04/openDeepLink-3.svg\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/04/openShortcutItem-4.svg\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/04/openSpotlightItem-4.svg\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003ch2 id=\"navigation\"\u003eNavigation\u003c/h2\u003e\u003cp\u003eAs mentioned earlier, the important concept to grasp is that there is simply no single solution to Navigation. I\u0026#39;ve noticed that such a topic quickly raises discussions and each engineer has different, sometimes strong opinions. It\u0026#39;s more important to agree on a working solution that satisfies the given requirements rather than forcing personal preferences.\u003c/p\u003e\u003cp\u003eOur NavigationEngine relies on the following navigation rules (based on Flow Controllers):\u003c/p\u003e\u003cul\u003e\n\u003cli\u003e\u003cem\u003eFlowControllers\u003c/em\u003e wire up the domain-specific logic for the navigation\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eViewControllers\u003c/em\u003e don\u0026#39;t allocate \u003cem\u003eFlowControllers\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eOnly \u003cem\u003eFlowControllers\u003c/em\u003e, \u003cem\u003eAppDelegate\u003c/em\u003e and similar top-level objects can allocate \u003cem\u003eViewControllers\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eFlowControllers\u003c/em\u003e are owned (retained) by the creators\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eFlowControllers\u003c/em\u003e can have children \u003cem\u003eFlowControllers\u003c/em\u003e and create a parent-child chain and can, therefore, be in a 1-to-many relationship\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eFlowControllers\u003c/em\u003e in parent-child relationships communicate via delegation\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eViewControllers\u003c/em\u003e have weak references to \u003cem\u003eFlowControllers\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eViewControllers\u003c/em\u003e are in a 1-to-1 relationship with \u003cem\u003eFlowControllers\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eAll the \u003cem\u003eFlowController\u003c/em\u003e domain-specific API must be future-based with \u003ccode\u003eFuture\u0026lt;Bool\u0026gt;\u003c/code\u003e as return type\u003c/li\u003e\n\u003cli\u003eDeep linking navigation should occur with no more than one animation (i.e. for long journeys, only the last step should be animated)\u003c/li\u003e\n\u003cli\u003eDeep linking navigation that pops a stack should occur without animation\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the demo project, there are a number of \u003ccode\u003e*FlowControllerProtocols\u003c/code\u003e, each corresponding to a different section/domain of the hosting app. Examples such as \u003ccode\u003eRestaurantsFlowControllerProtocol\u003c/code\u003e and \u003ccode\u003eOrdersFlowControllerProtocol\u003c/code\u003e are taken from the Just Eat app and each one has domain specific APIs, e.g:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc goToSearchAnimated(postcode: Postcode?, cuisine: Cuisine?, animated: Bool) -\u0026gt; Future\u0026lt;Bool\u0026gt;\nfunc goToOrder(orderId: OrderId, animated: Bool) -\u0026gt; Future\u0026lt;Bool\u0026gt;\nfunc goToRestaurant(restaurantId: RestaurantId) -\u0026gt; Future\u0026lt;Bool\u0026gt;\nfunc goToCheckout(animated: Bool) -\u0026gt; Future\u0026lt;Bool\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that each one:\u003c/p\u003e\u003cul\u003e\u003cli\u003eaccepts the \u003ccode\u003eanimated\u003c/code\u003e parameter\u003c/li\u003e\u003cli\u003ereturns \u003ccode\u003eFuture\u0026lt;Bool\u0026gt;\u003c/code\u003e so that flow sequence can be combined\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFlow controllers should be combined sensibly to represent the app UI structure. In the case of Just Eat we have a \u003ccode\u003eRootFlowController\u003c/code\u003e as the root-level flow controller orchestrating the children. A \u003ccode\u003eFlowControllerProvider\u003c/code\u003e, used by the \u003ccode\u003eNavigationTransitioner\u003c/code\u003e, is instead the single entry point to access the entire tree of flow controllers.\u003c/p\u003e\u003cp\u003e\u003ccode\u003eNavigationTransitioner\u003c/code\u003e provides an API such as:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc goToLogin(animated: Bool) -\u0026gt; Future\u0026lt;Bool\u0026gt;\nfunc goFromHomeToSearch(postcode: Postcode?, cuisine: Cuisine?, animated: Bool) -\u0026gt; Future\u0026lt;Bool\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is responsible to keep the underlying state machine and what the app actually shows in sync. Note the \u003ccode\u003egoFromHomeToSearch\u003c/code\u003e method being verbose on purpose; it takes care of the specific transition from a given state (home).\u003c/p\u003e\u003cp\u003eOne level up in the stack, \u003ccode\u003eNavigationIntentHandler\u003c/code\u003e is responsible for combining the actions available from the \u003ccode\u003eNavigationTransitioner\u003c/code\u003e starting from a given \u003ccode\u003eNavigationIntent\u003c/code\u003e and creating a complete deep linking journey. It also takes into account the current state of the app. For example, showing the history of the orders should be allowed only if the user is logged in, but it would also be advisable to prompt the user to log in in case he/she is not, and then resume the original action. Allowing so provides a superior user experience rather than simply aborting the flow (it\u0026#39;s what websites achieve by using the referring URL). Here is the implementation of the \u003ccode\u003e.goToOrderHistory\u003c/code\u003e intent in the \u003ccode\u003eNavigationIntentHandler\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ecase .goToOrderHistory:\n    switch userStatusProvider.userStatus {\n    case .loggedIn:\n        return navigationTransitioner.goToRoot(animated: false).thenWithResult { _ -\u0026gt; Future\u0026lt;Bool\u0026gt; in\n            self.navigationTransitioner.goToOrderHistory(animated: true)\n        }\n    case .loggedOut:\n        return navigationTransitioner.requestUserToLogin().then { future in\n            switch future.state {\n            case .result:\n                return self.handleIntent(intent) // go recursive\n            default:\n                return Future\u0026lt;Bool\u0026gt;.futureWithResolution(of: future)\n            }\n        }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSince in the design we make the entire API future-based, we can potentially interrupt the deep linking flow to prompt the user for details or simply gather missing information from a remote API. This is crucial and allows us to construct complex flows.\u003c/p\u003e\u003cp\u003eBy design, all journeys start by resetting the state of the app by calling \u003ccode\u003egoToRoot\u003c/code\u003e. This vastly reduces the number of possible transitions to take care of as we will describe in more detail in the next section dedicated to the underlying state machine.\u003c/p\u003e\u003ch2 id=\"state-machine\"\u003eState Machine\u003c/h2\u003e\u003cp\u003eAs you might have realized by now, the proposed architecture makes use of an underlying \u003ca href=\"https://brilliant.org/wiki/finite-state-machines/?ref=albertodebortoli.com\"\u003eFinite State Machine\u003c/a\u003e to keep track of the state of the app during a deep linking journey.\u003c/p\u003e\u003cp\u003eHere is a simplified version of the state machine configurations used in the Just Eat iOS apps.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/04/state_machine_just_eat-5.png\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cp\u003eIn the picture, the red arrows are transitions that are available for logged in users only, the blue ones are for logged out users only, while the black ones can always be performed.\u003c/p\u003e\u003cp\u003eNote that every state should allow going back to the \u003ccode\u003e.allPoppedToRoot\u003c/code\u003e state so that, regardless of what the current state of the app is, we can always reset the state and perform a deep linking action starting afresh. This drastically simplifies the graph, avoiding unnecessary transitions such as the one shown in the next picture.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/04/state_machine_sample-3.png\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cp\u003eNotice that intents (\u003ccode\u003eNavigationIntent\u003c/code\u003e) are different from transitions (\u003ccode\u003eNavigationEngine.StateMachine.EventType\u003c/code\u003e). An \u003cem\u003eintent\u003c/em\u003e contains the information to perform a deep linking journey, while the \u003cem\u003eevent type\u003c/em\u003e is the transition from one FSM state to another (or the same).\u003c/p\u003e\u003cp\u003e\u003ccode\u003eNavigationTransitioner\u003c/code\u003e is the class that performs the transitions and applies the companion navigation changes. A navigation step is performed only if the corresponding transition is allowed and completed successfully. If a transition is not allowed, the flow is interrupted, reporting an error in the future. You can showcase a failure in the demo app by trying to follow the \u003cem\u003eLogin Universal Link\u003c/em\u003e (\u003ccode\u003ehttps://just-eat.co.uk/login\u003c/code\u003e) after having faked the login when following the \u003cem\u003eOrder History Universal Link\u003c/em\u003e (\u003ccode\u003ehttps://just-eat.co.uk/orders\u003c/code\u003e).\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.ghost.io/content/images/2019/04/test_deep_linking_failure.png\" alt=\"test_deep_linking_failure\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003ch2 id=\"usage\"\u003eUsage\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eNavigationEngineDemo\u003c/strong\u003e includes the whole stack that readers can use in client projects. Here are the steps for a generic integration of the code.\u003c/p\u003e\u003cp\u003eAdd the \u003cem\u003eNavigationEngine\u003c/em\u003e stack (\u003ccode\u003eNavigationEngineDemo/NavigationEngine\u003c/code\u003e folder) to the client project. This can be done by either creating a dedicated pod as we do at Just Eat or by directly including the code.\u003c/p\u003e\u003cp\u003eInclude \u003ccode\u003ePromis\u003c/code\u003e and \u003ccode\u003eStateful\u003c/code\u003e as dependencies in your Podfile (assuming the usage of Cocoapods).\u003c/p\u003e\u003cp\u003eModify according to your needs, implement classes for all the \u003ccode\u003e*FlowControllerProtocols\u003c/code\u003e, and connect them to the \u003cem\u003eViewControllers\u003c/em\u003e of the client. This step can be quite tedious depending on the status of your app and we suggest trying to mimic what has been done in the demo app.\u003c/p\u003e\u003cp\u003eAdd \u003ccode\u003eCFBundleTypeRole\u003c/code\u003e and \u003ccode\u003eCFBundleURLSchemes\u003c/code\u003e to the main target \u003ccode\u003eInfo.plist\u003c/code\u003e file to support Deep Links. E.g.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;key\u0026gt;CFBundleURLTypes\u0026lt;/key\u0026gt;\n\u0026lt;array\u0026gt;\n  \u0026lt;dict\u0026gt;\n    \u0026lt;key\u0026gt;CFBundleTypeRole\u0026lt;/key\u0026gt;\n    \u0026lt;string\u0026gt;Editor\u0026lt;/string\u0026gt;\n    \u0026lt;key\u0026gt;CFBundleURLSchemes\u0026lt;/key\u0026gt;\n    \u0026lt;array\u0026gt;\n      \u0026lt;string\u0026gt;je-internal\u0026lt;/string\u0026gt;\n      \u0026lt;string\u0026gt;justeat\u0026lt;/string\u0026gt;\n      \u0026lt;string\u0026gt;just-eat\u0026lt;/string\u0026gt;\n      \u0026lt;string\u0026gt;just-eat-uk\u0026lt;/string\u0026gt;\n    \u0026lt;/array\u0026gt;\n  \u0026lt;/dict\u0026gt;\n\u0026lt;/array\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003eAdd the applinks (in the Capabilities -\u0026gt; Associated Domains section of the main target) you\u0026#39;d like to support. This will allow iOS to register the app for Universal Links on the given domains looking for the \u003ccode\u003eapple-app-site-association\u003c/code\u003e file at the root of those domains once the app is installed. E.g.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.ghost.io/content/images/2019/04/associated_domains-1.png\" alt=\"associated_domains-1\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cp\u003eImplement concrete classes for \u003ccode\u003eDeepLinkingSettingsProtocol\u003c/code\u003e and \u003ccode\u003eUserStatusProviding\u003c/code\u003e according to your needs. Again, see the examples in the demo project. The \u003ccode\u003einternalDeepLinkSchemes\u003c/code\u003e property in \u003ccode\u003eDeepLinkSettingsProtocol\u003c/code\u003e should contain the same values previously added to \u003ccode\u003eCFBundleURLSchemes\u003c/code\u003e, while the \u003ccode\u003euniversalLinkHosts\u003c/code\u003e should contain the same \u003ccode\u003eapplinks:\u003c/code\u003e values defined in Capabilities -\u0026gt; Associated Domains.\u003c/p\u003e\u003cp\u003eSetup the \u003ccode\u003eNavigationEngine\u003c/code\u003e stack in the AppDelegate\u0026#39;s \u003ccode\u003eapplicationDidFinishLaunching\u003c/code\u003e. To some degree, it should be something similar to the following:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003evar window: UIWindow?\nvar rootFlowController: RootFlowController!\nvar deepLinkingFacade: DeepLinkingFacade!\n\nvar userStatusProvider = UserStatusProvider()\nlet deepLinkingSettings = DeepLinkingSettings()\n\nfunc applicationDidFinishLaunching(_ application: UIApplication) {\n\n    // Init UI Stack\n    let window = UIWindow(frame: UIScreen.main.bounds)\n    let tabBarController = TabBarController.instantiate()\n\n    // Root Flow Controller\n    rootFlowController = RootFlowController(with: tabBarController)\n    tabBarController.flowController = rootFlowController\n\n    // Deep Linking core\n    let flowControllerProvider = FlowControllerProvider(rootFlowController: rootFlowController)\n    deepLinkingFacade = DeepLinkingFacade(flowControllerProvider: flowControllerProvider,\n                                          navigationTransitionerDataSource: self,\n                                          settings: deepLinkingSettings,\n                                          userStatusProvider: userStatusProvider)\n\n    // Complete UI Stack\n    window.rootViewController = tabBarController\n    window.makeKeyAndVisible()\n    self.window = window\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003eModify \u003ccode\u003eNavigationTransitionerDataSource\u003c/code\u003e according to your needs and implement its methods. You might want to have a separate component and not using the AppDelegate.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003eextension AppDelegate: NavigationTransitionerDataSource {\n    func navigationTransitionerDidRequestUserToLogin() -\u0026gt; Future\u0026lt;Bool\u0026gt; {\n        \u0026lt;#async logic#\u0026gt;\n    }\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003eImplement the entry points for handling incoming URLs/inputs in the \u003cem\u003eAppDelegate\u003c/em\u003e:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003efunc application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -\u0026gt; Bool {\n    // from internal deep links \u0026amp; TodayExtension\n    deepLinkingFacade.openDeeplink(url).finally { future in\n        \u0026lt;#...#\u0026gt;\n    }\n    return true\n}\n\nfunc application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -\u0026gt; Void) -\u0026gt; Bool {\n    switch userActivity.activityType {\n    // from Safari\n    case NSUserActivityTypeBrowsingWeb:\n        if let webpageURL = userActivity.webpageURL {\n            self.deepLinkingFacade.handleURL(webpageURL).finally { future in\n                \u0026lt;#...#\u0026gt;\n            }\n            return true\n        }\n        return false\n\n    // from Spotlight\n    case CSSearchableItemActionType:\n        self.deepLinkingFacade.openSpotlightItem(userActivity).finally { future in\n            let originalInput = userActivity.userInfo![CSSearchableItemActivityIdentifier] as! String\n            \u0026lt;#...#\u0026gt;\n        }\n        return true\n\n    default:\n        return false\n    }\n}\n\nfunc application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -\u0026gt; Void) {\n    // from shortcut items (Home Screen Quick Actions)\n    deepLinkingFacade.openShortcutItem(shortcutItem).finally { future in\n        let originalInput = shortcutItem.type\n        \u0026lt;#...#\u0026gt;\n        completionHandler(future.hasResult())\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eN.B. Since a number of tasks are usually performed at startup (both from cold and warm starts), it\u0026#39;s suggested to schedule them using operation queues. The deep linking task should be one of the last tasks in the queue to make sure that dependencies are previously set up. Here is the great \u003ca href=\"https://developer.apple.com/videos/play/wwdc2015/226/?ref=albertodebortoli.com\"\u003eAdvanced NSOperations\u003c/a\u003e talk by \u003ca href=\"https://twitter.com/davedelong?ref=albertodebortoli.com\"\u003e\u003cem\u003eDave DeLong\u003c/em\u003e \u003c/a\u003e from WWDC15.\u003c/p\u003e\u003cul\u003e\u003cli\u003eThe \u003ccode\u003eUniversalLinkConverter\u003c/code\u003e class should be modified to match the paths in the \u003ccode\u003eapple-app-site-association\u003c/code\u003e, which should be reachable at the root of the website (the associated domain). It should be noted that if the app is opened instead of the browser, it would be because the Universal Link can be handled; and redirecting the user back to the web would be a fundamental mistake that should be solved by correctly defining the supported paths in the \u003ccode\u003eapple-app-site-association\u003c/code\u003e file.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTo perform internal app navigation via deep linking, the DeeplinkFactory class should be used to create \u003ccode\u003eDeepLink\u003c/code\u003e objects that can be fed into either \u003ccode\u003ehandleURL(_ url: URL)\u003c/code\u003e or \u003ccode\u003eopenDeepLink(_ deepLink: DeepLink)\u003c/code\u003e.\u003c/p\u003e\u003ch3 id=\"in-app-testing\"\u003eIn-app testing\u003c/h3\u003e\u003cp\u003eThe module exposes a \u003ccode\u003eDeepLinkingTesterViewController\u003c/code\u003e that can be used to easily test deep linking within an app.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.ghost.io/content/images/2019/04/deeplinking-tester-2.png\" alt=\"deeplinking-tester-2\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cp\u003eSimply define a JSON file containing the Universal Links and Deep Links to test:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;universal_links\u0026#34;: [\n    \u0026#34;https://just-eat.co.uk/\u0026#34;,\n    \u0026#34;https://just-eat.co.uk/home\u0026#34;,\n    \u0026#34;https://just-eat.co.uk/login\u0026#34;,\n    ...\n  ],\n  \u0026#34;deep_links\u0026#34;: [\n    \u0026#34;JUSTEAT://irrelev.ant/home\u0026#34;,\n    \u0026#34;justeat://irrelev.ant/login\u0026#34;,\n    \u0026#34;just-eat://irrelev.ant/resetPassword?resetToken=xyz\u0026#34;,\n    ...\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen feed it to the view controller as shown below. Alternatively, use a storyboard reference as shown in the demo app.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003elet deepLinkingTesterViewController = DeepLinkingTesterViewController.instantiate()\ndeepLinkingTesterViewController.delegate = self\nlet path = Bundle.main.path(forResource: \u0026#34;deeplinking_test_list\u0026#34;, ofType: \u0026#34;json\u0026#34;)!\ndeepLinkingTesterViewController.loadTestLinks(atPath: path)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eand implement the DeepLinkingTesterViewControllerDelegate\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eextension AppDelegate: DeepLinkingTesterViewControllerDelegate {\n    func deepLinkingTesterViewController(_ deepLinkingTesterViewController: DeepLinkingTesterViewController, didSelect url: URL) {\n        self.deepLinkingFacade.handleURL(universalLink).finally { future in\n            self.handleFuture(future, originalInput: universalLink.absoluteString)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eThe solution proposed in this article has proven to be highly scalable and customizable. We shipped it in the Just Eat iOS apps in March 2019 and our teams are gradually increasing the number of Universal Links supported as you can see from our \u003ca href=\"https://www.just-eat.co.uk/apple-app-site-association?ref=albertodebortoli.com\"\u003eapple-app-site-association\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eBefore implementing and adopting \u003cem\u003eNavigationEngine\u003c/em\u003e, supporting new kinds of links was a real hassle. Thanks to this architecture, it is now easy for each team in the company to support new deep link journeys. The declarative approach in defining the API, states, transitions, and intents forces a single way to extend the code which enables a coherent approach throughout the codebase.\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "24 min read",
  "publishedTime": "2019-04-16T06:43:00Z",
  "modifiedTime": "2019-12-04T17:21:30Z"
}
