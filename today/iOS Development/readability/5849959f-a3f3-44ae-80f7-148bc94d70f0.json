{
  "id": "5849959f-a3f3-44ae-80f7-148bc94d70f0",
  "title": "Where View.task gets its main-actor isolation from",
  "link": "https://oleb.net/2022/swiftui-task-mainactor/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2022-10-11T16:41:34Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann …",
  "length": 6179,
  "excerpt": "If you call SwiftUI’s task modifier inside a view’s body property, the async operation will run on the main actor. However, this isn’t the case if you call task from a helper property or function that isn’t main-actor-annotated. Why?",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "SwiftUI’s .task modifier inherits its actor context from the surrounding function. If you call .task inside a view’s body property, the async operation will run on the main actor because View.body is (semi-secretly) annotated with @MainActor. However, if you call .task from a helper property or function that isn’t @MainActor-annotated, the async operation will run in the cooperative thread pool. Example Here’s an example. Notice the two .task modifiers in body and helperView. The code is identical in both, yet only one of them compiles — in helperView, the call to a main-actor-isolated function fails because we’re not on the main actor in that context: We can call a main-actor-isolated function from inside body, but not from a helper property. import SwiftUI @MainActor func onMainActor() { print(\"on MainActor\") } struct ContentView: View { var body: some View { VStack { helperView Text(\"in body\") .task { // We can call a @MainActor func without await onMainActor() } } } var helperView: some View { Text(\"in helperView\") .task { // ❗️ Error: Expression is 'async' but is not marked with 'await' onMainActor() } } } Why does it work like this? This behavior is caused by two (semi-)hidden annotations in the SwiftUI framework: The View protocol annotates its body property with @MainActor. This transfers to all conforming types. View.task annotates its action parameter with @_inheritActorContext, causing it to adopt the actor context from its use site. Sadly, none of these annotations are visible in the SwiftUI documentation, making it very difficult to understand what’s going on. The @MainActor annotation on View.body is present in Xcode’s generated Swift interface for SwiftUI (Jump to Definition of View), but that feature doesn’t work reliably for me, and as we’ll see, it doesn’t show the whole truth, either. View.body is annotated with @MainActor in Xcode’s generated interface for SwiftUI. SwiftUI’s module interface To really see the declarations the compiler sees, we need to look at SwiftUI’s module interface file. A module interface is like a header file for Swift modules. It lists the module’s public declarations and even the implementations of inlinable functions. Module interfaces use normal Swift syntax and have the .swiftinterface file extension. SwiftUI’s module interface is located at: [Path to Xcode.app]/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/SwiftUI.framework/Modules/SwiftUI.swiftmodule/arm64e-apple-ios.swiftinterface (There can be multiple .swiftinterface files in that directory, one per CPU architecture. Pick any one of them. Pro tip for viewing the file in Xcode: Editor \u003e Syntax Coloring \u003e Swift enables syntax highlighting.) Inside, you’ll find that View.body has the @MainActor(unsafe) attribute: @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *) @_typeEraser(AnyView) public protocol View { // … @SwiftUI.ViewBuilder @_Concurrency.MainActor(unsafe) var body: Self.Body { get } } And you’ll find this declaration for .task, including the @_inheritActorContext attribute: @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *) extension SwiftUI.View { #if compiler(\u003e=5.3) \u0026\u0026 $AsyncAwait \u0026\u0026 $Sendable \u0026\u0026 $InheritActorContext @inlinable public func task( priority: _Concurrency.TaskPriority = .userInitiated, @_inheritActorContext _ action: @escaping @Sendable () async -\u003e Swift.Void ) -\u003e some SwiftUI.View { modifier(_TaskModifier(priority: priority, action: action)) } #endif // … } SwiftUI’s module interface file shows the @_inheritActorContext annotatation on View.task. Putting it all together Armed with this knowledge, everything makes more sense: When used inside body, task inherits the @MainActor context from body. When used outside of body, there is no implicit @MainActor annotation, so task will run its operation on the cooperative thread pool by default. Unless the view contains an @ObservedObject or @StateObject property, which makes the entire view @MainActor via this obscure rule for property wrappers whose wrappedValue property is bound to a global actor: A struct or class containing a wrapped instance property with a global actor-qualified wrappedValue infers actor isolation from that property wrapper Update May 1, 2024: SE-0401: Remove Actor Isolation Inference caused by Property Wrappers removes the above rule when compiling in Swift 6 language mode. This is a good change because it makes reasoning about actor isolation simpler. In the Swift 5 language mode, you can opt into the better behavior with the -enable-upcoming-feature DisableOutwardActorInference compiler flags. I recommend you do. The lesson: if you use helper properties or functions in your view, consider annotating them with @MainActor to get the same semantics as body. By the way, note that the actor context only applies to code that is placed directly inside the async closure, as well as to synchronous functions the closure calls. Async functions choose their own execution context, so any call to an async function can switch to a different executor. For example, if you call URLSession.data(from:) inside a main-actor-annotated function, the runtime will hop to the global cooperative executor to execute that method. See SE-0338: Clarify the Execution of Non-Actor-Isolated Async Functions for the precise rules. On Apple’s policy to hide annotations in documentation I understand Apple’s impetus not to show unofficial API or language features in the documentation lest developers get the preposterous idea to use these features in their own code! But it makes understanding so much harder. Before I saw the annotations in the .swiftinterface file, the behavior of the code at the beginning of this article never made sense to me. Hiding the details makes things seem like magic when they actually aren’t. And that’s not good, either.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003carticle\u003e\n        \u003cheader\u003e\n          \n        \u003c/header\u003e\n\n        \n\n        \u003cdiv\u003e\n          \u003cp\u003eSwiftUI’s \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/task(priority:_:)\"\u003e\u003ccode\u003e.task\u003c/code\u003e modifier\u003c/a\u003e inherits its actor context from the surrounding function. If you call \u003ccode\u003e.task\u003c/code\u003e inside a view’s \u003ccode\u003ebody\u003c/code\u003e property, the async operation will run on \u003ca href=\"https://developer.apple.com/documentation/swift/mainactor\"\u003ethe main actor\u003c/a\u003e because \u003ccode\u003eView.body\u003c/code\u003e is (semi-secretly) annotated with \u003ccode\u003e@MainActor\u003c/code\u003e. However, if you call \u003ccode\u003e.task\u003c/code\u003e from a helper property or function that isn’t \u003ccode\u003e@MainActor\u003c/code\u003e-annotated, the async operation will run in the cooperative thread pool.\u003c/p\u003e\n\n\u003ch2 id=\"example\"\u003eExample\u003c/h2\u003e\n\n\u003cp\u003eHere’s an example. Notice the two \u003ccode\u003e.task\u003c/code\u003e modifiers in \u003ccode\u003ebody\u003c/code\u003e and \u003ccode\u003ehelperView\u003c/code\u003e. The code is identical in both, yet only one of them compiles — in \u003ccode\u003ehelperView\u003c/code\u003e, the call to a main-actor-isolated function fails because we’re not on the main actor in that context:\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cfigure\u003e\n  \u003ca href=\"https://oleb.net/media/xcode-error-expression-async-not-marked-with-await-1470px.png\"\u003e\n  \u003cimg src=\"https://oleb.net/media/xcode-error-expression-async-not-marked-with-await-1470px.png\" alt=\"Xcode showing the compiler diagnostic \u0026#39;Expression is \u0026#39;async\u0026#39; but is not marked with await\u0026#39;\"/\u003e\n  \u003c/a\u003e\n  \u003cfigcaption\u003e\n    We can call a main-actor-isolated function from inside \u003ccode\u003ebody\u003c/code\u003e, but not from a helper property.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eSwiftUI\u003c/span\u003e\n\n\u003cspan\u003e@MainActor\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eonMainActor\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;on MainActor\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eContentView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eVStack\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003ehelperView\u003c/span\u003e\n      \u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;in body\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etask\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n          \u003cspan\u003e// We can call a @MainActor func without await\u003c/span\u003e\n          \u003cspan\u003eonMainActor\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ehelperView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;in helperView\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etask\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// ❗️ Error: Expression is \u0026#39;async\u0026#39; but is not marked with \u0026#39;await\u0026#39;\u003c/span\u003e\n        \u003cspan\u003eonMainActor\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n      \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"why-does-it-work-like-this\"\u003eWhy does it work like this?\u003c/h2\u003e\n\n\u003cp\u003eThis behavior is caused by two (semi-)hidden annotations in the SwiftUI framework:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eThe \u003ca href=\"https://developer.apple.com/documentation/swiftui/view\"\u003e\u003ccode\u003eView\u003c/code\u003e\u003c/a\u003e protocol annotates its \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/body-swift.property\"\u003e\u003ccode\u003ebody\u003c/code\u003e\u003c/a\u003e property with \u003ccode\u003e@MainActor\u003c/code\u003e. This transfers to all conforming types.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ca href=\"https://developer.apple.com/documentation/swiftui/view/task(priority:_:)\"\u003e\u003ccode\u003eView.task\u003c/code\u003e\u003c/a\u003e annotates its \u003ccode\u003eaction\u003c/code\u003e parameter with \u003ca href=\"https://github.com/apple/swift/blob/main/docs/ReferenceGuides/UnderscoredAttributes.md#_inheritactorcontext\"\u003e\u003ccode\u003e@_inheritActorContext\u003c/code\u003e\u003c/a\u003e, causing it to adopt the actor context from its use site.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eSadly, none of these annotations are visible in the SwiftUI documentation, making it very difficult to understand what’s going on. The \u003ccode\u003e@MainActor\u003c/code\u003e annotation on \u003ccode\u003eView.body\u003c/code\u003e \u003cem\u003eis\u003c/em\u003e present in Xcode’s generated Swift interface for SwiftUI (Jump to Definition of \u003ccode\u003eView\u003c/code\u003e), but that feature doesn’t work reliably for me, and as we’ll see, it doesn’t show the whole truth, either.\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cfigure\u003e\n  \u003ca href=\"https://oleb.net/media/xcode-swiftui-generated-interface-view-body-1582px.png\"\u003e\n  \u003cimg src=\"https://oleb.net/media/xcode-swiftui-generated-interface-view-body-1582px.png\" alt=\"Xcode showing the generated interface for SwiftUI’s View protocol. The @MainActor annotation on View.body is selected.\"/\u003e\n  \u003c/a\u003e\n  \u003cfigcaption\u003e\n    \u003ccode\u003eView.body\u003c/code\u003e is annotated with \u003ccode\u003e@MainActor\u003c/code\u003e in Xcode’s generated interface for SwiftUI.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"swiftuis-module-interface\"\u003eSwiftUI’s module interface\u003c/h2\u003e\n\n\u003cp\u003eTo really see the declarations the compiler sees, we need to look at SwiftUI’s \u003cem\u003emodule interface\u003c/em\u003e file. A module interface is like a \u003ca href=\"https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html\"\u003eheader file\u003c/a\u003e for Swift modules. It lists the module’s public declarations and even the implementations of inlinable functions. Module interfaces use normal Swift syntax and have the \u003ccode\u003e.swiftinterface\u003c/code\u003e file extension.\u003c/p\u003e\n\n\u003cp\u003eSwiftUI’s module interface is located at:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e[Path to Xcode.app]/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/SwiftUI.framework/Modules/SwiftUI.swiftmodule/arm64e-apple-ios.swiftinterface\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003csmall\u003e\n(There can be multiple \u003ccode\u003e.swiftinterface\u003c/code\u003e files in that directory, one per CPU architecture. Pick any one of them. Pro tip for viewing the file in Xcode: Editor \u0026gt; Syntax Coloring \u0026gt; Swift enables syntax highlighting.)\n\u003c/small\u003e\u003c/p\u003e\n\n\u003cp\u003eInside, you’ll find that \u003ccode\u003eView.body\u003c/code\u003e has the \u003ccode\u003e@MainActor(unsafe)\u003c/code\u003e attribute:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e@available\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eiOS\u003c/span\u003e \u003cspan\u003e13.0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emacOS\u003c/span\u003e \u003cspan\u003e10.15\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etvOS\u003c/span\u003e \u003cspan\u003e13.0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ewatchOS\u003c/span\u003e \u003cspan\u003e6.0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e@_typeEraser\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eAnyView\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eprotocol\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// …\u003c/span\u003e\n  \u003cspan\u003e@SwiftUI\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eViewBuilder\u003c/span\u003e \u003cspan\u003e@_Concurrency\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eMainActor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSelf\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eBody\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eget\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAnd you’ll find this declaration for \u003ccode\u003e.task\u003c/code\u003e, including the \u003ccode\u003e@_inheritActorContext\u003c/code\u003e attribute:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e@available\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eiOS\u003c/span\u003e \u003cspan\u003e15.0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emacOS\u003c/span\u003e \u003cspan\u003e12.0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etvOS\u003c/span\u003e \u003cspan\u003e15.0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ewatchOS\u003c/span\u003e \u003cspan\u003e8.0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eSwiftUI\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e#if compiler(\u0026gt;=5.3) \u0026amp;\u0026amp; $AsyncAwait \u0026amp;\u0026amp; $Sendable \u0026amp;\u0026amp; $InheritActorContext\u003c/span\u003e\n    \u003cspan\u003e@inlinable\u003c/span\u003e \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etask\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n      \u003cspan\u003epriority\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e_Concurrency\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eTaskPriority\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003euserInitiated\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n      \u003cspan\u003e@_inheritActorContext\u003c/span\u003e \u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eaction\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e@escaping\u003c/span\u003e \u003cspan\u003e@Sendable\u003c/span\u003e \u003cspan\u003e()\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eSwift\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eVoid\u003c/span\u003e\n    \u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eSwiftUI\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003emodifier\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e_TaskModifier\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epriority\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003epriority\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eaction\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eaction\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e#endif\u003c/span\u003e\n  \u003cspan\u003e// …\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv\u003e\n\u003cfigure\u003e\n  \u003ca href=\"https://oleb.net/media/xcode-swiftui-swiftinterface-task-1728px.png\"\u003e\n  \u003cimg src=\"https://oleb.net/media/xcode-swiftui-swiftinterface-task-1728px.png\" alt=\"Xcode showing the declaration for the View.task method in the SwiftUI.swiftinterface file. The @_inheritActorContext annotation is selected.\"/\u003e\n  \u003c/a\u003e\n  \u003cfigcaption\u003e\n    SwiftUI’s module interface file shows the \u003ccode\u003e@_inheritActorContext\u003c/code\u003e annotatation on \u003ccode\u003eView.task\u003c/code\u003e.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"putting-it-all-together\"\u003ePutting it all together\u003c/h2\u003e\n\n\u003cp\u003eArmed with this knowledge, everything makes more sense:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eWhen used inside \u003ccode\u003ebody\u003c/code\u003e, \u003ccode\u003etask\u003c/code\u003e inherits the \u003ccode\u003e@MainActor\u003c/code\u003e context from \u003ccode\u003ebody\u003c/code\u003e.\u003c/li\u003e\n  \u003cli\u003eWhen used outside of \u003ccode\u003ebody\u003c/code\u003e, there is no implicit \u003ccode\u003e@MainActor\u003c/code\u003e annotation, so \u003ccode\u003etask\u003c/code\u003e will run its operation on the cooperative thread pool by default.\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eUnless the view contains an \u003ccode\u003e@ObservedObject\u003c/code\u003e or \u003ccode\u003e@StateObject\u003c/code\u003e property, which makes the entire view \u003ccode\u003e@MainActor\u003c/code\u003e via \u003ca href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0316-global-actors.md#:~:text=a%20struct%20or%20class,that%20property%20wrapper\"\u003ethis obscure rule for property wrappers whose \u003ccode\u003ewrappedValue\u003c/code\u003e property is bound to a global actor\u003c/a\u003e:\u003c/p\u003e\n\n    \u003cblockquote\u003e\n      \u003cp\u003eA struct or class containing a wrapped instance property with a global actor-qualified \u003ccode\u003ewrappedValue\u003c/code\u003e infers actor isolation from that property wrapper\u003c/p\u003e\n    \u003c/blockquote\u003e\n\n    \u003cp\u003e\u003cstrong\u003eUpdate May 1, 2024:\u003c/strong\u003e \u003ca href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0401-remove-property-wrapper-isolation.md\"\u003eSE-0401: Remove Actor Isolation Inference caused by Property Wrappers\u003c/a\u003e removes the above rule when compiling in Swift 6 language mode. This is a good change because it makes reasoning about actor isolation simpler. In the Swift 5 language mode, you can opt into the better behavior with the \u003ccode\u003e-enable-upcoming-feature\u003c/code\u003e \u003ccode\u003eDisableOutwardActorInference\u003c/code\u003e compiler flags. I recommend you do.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe lesson: if you use helper properties or functions in your view, consider annotating them with \u003ccode\u003e@MainActor\u003c/code\u003e to get the same semantics as \u003ccode\u003ebody\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eBy the way, note that the actor context only applies to code that is placed directly inside the async closure, as well as to synchronous functions the closure calls. Async functions choose their own execution context, so any call to an async function can switch to a different executor. For example, if you call \u003ca href=\"https://developer.apple.com/documentation/foundation/urlsession/3767353-data\"\u003e\u003ccode\u003eURLSession.data(from:)\u003c/code\u003e\u003c/a\u003e inside a main-actor-annotated function, the runtime will hop to the global cooperative executor to execute that method. See \u003ca href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0338-clarify-execution-non-actor-async.md\"\u003eSE-0338: Clarify the Execution of Non-Actor-Isolated Async Functions\u003c/a\u003e for the precise rules.\u003c/p\u003e\n\n\u003ch2 id=\"on-apples-policy-to-hide-annotations-in-documentation\"\u003eOn Apple’s policy to hide annotations in documentation\u003c/h2\u003e\n\n\u003cp\u003eI understand Apple’s impetus not to show unofficial API or language features in the documentation lest developers get the preposterous idea to use these features in their own code!\u003c/p\u003e\n\n\u003cp\u003eBut it makes understanding \u003cem\u003eso\u003c/em\u003e much harder. Before I saw the annotations in the \u003ccode\u003e.swiftinterface\u003c/code\u003e file, the behavior of the code at the beginning of this article never made sense to me. Hiding the details makes things seem like magic when they actually aren’t. And that’s not good, either.\u003c/p\u003e\n\n        \u003c/div\u003e\n      \u003c/article\u003e\n      \n      \n      \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2022-10-11T16:41:34Z",
  "modifiedTime": "2024-05-01T17:51:27Z"
}
