{
  "id": "9ed8ea4c-305f-40b4-a969-a0f351515f16",
  "title": "Switching between SwiftUI’s HStack and VStack",
  "link": "https://www.swiftbysundell.com/articles/switching-between-swiftui-hstack-vstack",
  "description": "Different ways to implement a dynamic SwiftUI stack that renders its content either horizontally or vertically, depending on the current context.",
  "author": "",
  "published": "Fri, 8 Jul 2022 15:50:00 +0200",
  "source": "https://www.swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 11692,
  "excerpt": "Different ways to implement a dynamic SwiftUI stack that renders its content either horizontally or vertically, depending on the current context.",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "SwiftUI’s various stacks are some of the framework’s most fundamental layout tools, and enable us to define groups of views that are aligned either horizontally, vertically, or stacked in terms of depth.When it comes to the horizontal and vertical variants (HStack and VStack), we might sometimes end up in a situation where we want to dynamically switch between the two. For example, let’s say that we’re building an app that contains the following LoginActionsView, which lets the user pick from a list of actions when logging in:struct LoginActionsView: View { ... var body: some View { VStack { Button(\"Login\") { ... } Button(\"Reset password\") { ... } Button(\"Create account\") { ... } } .buttonStyle(ActionButtonStyle()) } } struct ActionButtonStyle: ButtonStyle { func makeBody(configuration: Configuration) -\u003e some View { configuration.label .fixedSize() .frame(maxWidth: .infinity) .padding() .foregroundColor(.white) .background(Color.blue) .cornerRadius(10) } }Above, we’re using the fixedSize modifier to prevent our button labels from getting truncated, which is something that we should only do if we’re sure that a given view’s content won’t ever be larger than the view itself. To learn more, check out part three of my guide to SwiftUI’s layout system.Currently, our buttons are stacked vertically, and fill all of the available space on the horizontal axis (you can use the above code sample’s PREVIEW button to see what that looks like). While that looks great on iPhones that are in portrait orientation, let’s say that we instead wanted to use a horizontal stack when our UI is rendered in landscape mode.GeometryReader to the rescue?One way to do that would be to use a GeometryReader to measure the currently available space, and based on whether the width of that space is larger than its height, we render our content using either an HStack or a VStack.While we could definitely place that logic right within our LoginActionsView itself, chances are quite high that we’ll want to reuse that code at some point in the future, so let’s instead create a dedicated view that’ll perform our dynamic stack-switching logic as a stand-alone component.To make our code even more future-proof, we won’t hard-code what alignment or spacing that our two stack variants will use. Instead, let’s do what SwiftUI itself does, and parametrize those attributes while also assigning the same default values that the framework uses — like this:struct DynamicStack\u003cContent: View\u003e: View { var horizontalAlignment = HorizontalAlignment.center var verticalAlignment = VerticalAlignment.center var spacing: CGFloat? @ViewBuilder var content: () -\u003e Content var body: some View { GeometryReader { proxy in Group { if proxy.size.width \u003e proxy.size.height { HStack( alignment: verticalAlignment, spacing: spacing, content: content ) } else { VStack( alignment: horizontalAlignment, spacing: spacing, content: content ) } } } } }Since we made our new DynamicStack use the same kind of API that HStack and VStack use, we can now simply swap out our previous VStack for an instance of our new, custom stack within our LoginActionsView:struct LoginActionsView: View { ... var body: some View { DynamicStack { Button(\"Login\") { ... } Button(\"Reset password\") { ... } Button(\"Create account\") { ... } } .buttonStyle(ActionButtonStyle()) } }Neat! However, like the above code sample’s PREVIEW shows, using a GeometeryReader to perform our dynamic stack switching does come with a quite significant downside, in that geometry readers always fill all of the available space on both the horizontal and vertical axis (in order to actually be able to measure that space). In our case, that means that our LoginActionsView will no longer just stretch out horizontally, but it’ll now also move to the top of the screen.While there are various ways that we could address those problems (for example by using a technique similar to the one we used to make multiple views have the same width or height in this Q\u0026A article), the question is really whether measuring the available space is really a good approach when it comes to determining the orientation of our dynamic stacks.A case for size classesInstead, let’s use Apple’s size class system to decide whether our DynamicStack should use an HStack or a VStack under the hood. The benefit of doing that is not just that we’ll be able to retain the same compact layout that we had before introducing a GeometryReader into the mix, but also that our DynamicStack will start behaving in a way that’s very similar to how built-in system components behave across all devices and orientations.To start observing the current horizontal size class, all we have to do is to use SwiftUI’s environment system — by declaring an @Environment-marked property (with the horizontalSizeClass key path) within our DynamicStack, which will then let us switch on the current sizeClass value within our view’s body:struct DynamicStack\u003cContent: View\u003e: View { ... @Environment(\\.horizontalSizeClass) private var sizeClass var body: some View { switch sizeClass { case .regular: hStack case .compact, .none: vStack @unknown default: vStack } } } private extension DynamicStack { var hStack: some View { HStack( alignment: verticalAlignment, spacing: spacing, content: content ) } var vStack: some View { VStack( alignment: horizontalAlignment, spacing: spacing, content: content ) } }With the above in place, our LoginActionsView will now dynamically switch between having a horizontal layout when rendered using the regular size class (for example in landscape on larger iPhones, or in either orientation when running full-screen on iPad), and a vertical layout when any other size class configuration is used. All while still using a compact vertical layout that doesn’t use any more space than what’s needed to render its content.Using the Layout protocolAlthough we’ve already ended up with a neat solution that works across all iOS versions that support SwiftUI, let’s also explore a few new layout tools that are being introduced in iOS 16 (which at the time of writing is still in beta as part of Xcode 14).One such tool is the new Layout protocol, which both enables us to build completely custom layouts that can be integrated directly into SwiftUI’s own layout system (more on that in a future article), while also providing us with a new way to dynamically switch between various layouts in a very smooth, full animatable way.That’s because it turns out that Layout is not just an API for us third-party developers, but Apple have also made SwiftUI’s own layout containers use that new protocol as well. So, rather than using HStack and VStack directly as container views, we can instead use them as Layout-conforming instances that are wrapped using the AnyLayout type — like this:private extension DynamicStack { var currentLayout: AnyLayout { switch sizeClass { case .regular, .none: return horizontalLayout case .compact: return verticalLayout @unknown default: return verticalLayout } } var horizontalLayout: AnyLayout { AnyLayout(HStack( alignment: verticalAlignment, spacing: spacing )) } var verticalLayout: AnyLayout { AnyLayout(VStack( alignment: horizontalAlignment, spacing: spacing )) } }The above works since both HStack and VStack directly conform to the new Layout protocol when their Content type is EmptyView (which is the case when we don’t pass any content closure to such a stack), as we can see if we take a peak at SwiftUI’s public interface:extension VStack: Layout where Content == EmptyView { ... }Note that, due to a regression, the above conditional conformance was omitted from Xcode 14 beta 3. According to Matt Ricketson from the SwiftUI team, a temporary workaround would be to instead use the underlying _HStackLayout and _VStackLayout types directly. Hopefully that regression will be fixed in future betas.Now that we’re able to resolve what layout to use through our new currentLayout property, we can now update our body implementation to simply call the AnyLayout that’s returned from that property as if it was a function — like this:struct DynamicStack\u003cContent: View\u003e: View { ... var body: some View { currentLayout(content) } }The reason that we can apply our layout by calling it as a function (even though it’s actually a struct) is because the Layout protocol uses Swift’s “call as function” feature.So what’s the difference between our previous solution and the above, Layout-based one? The key difference (besides the fact that the latter requires iOS 16) is that switching layouts preserves the identity of the underlying views that are being rendered, which isn’t the case when swapping between an HStack and a VStack. The result of that is that animations will be much smoother, for example when switching device orientations, and we’re also likely to get a small performance boost when performing such changes as well (since SwiftUI always performs best when its view hierarchies are as static as possible).Picking the view that fitsBut we’re not quite done yet, because iOS 16 also gives us another interesting new layout tool that could potentially be used to implement our DynamicStack — which is a new view type called ViewThatFits. Like its name implies, that new container will pick the view that best fits within the current context, based on a list of candidates that we pass when initializing it.In our case, that means that we could pass it both an HStack and a VStack, and it’ll automatically switch between them on our behalf:struct DynamicStack\u003cContent: View\u003e: View { ... var body: some View { ViewThatFits { HStack( alignment: verticalAlignment, spacing: spacing, content: content ) VStack( alignment: horizontalAlignment, spacing: spacing, content: content ) } } }Note that it’s important that we place the HStack first in this case, since the VStack will likely always fit, even within contexts where we want our layout to be horizontal (such as in full-screen mode on iPad). It’s also important to point out that the above ViewThatFits-based technique will always attempt to use our HStack, even when rendered with the compact size class, and will only pick our VStack-based layout when the HStack doesn’t fit.ConclusionSo that’s four different ways to implement a dedicated DynamicStack view that dynamically switches between an HStack and a VStack depending on the current context. I hope you enjoyed this article, and if you have any questions, comments, or feedback, then feel free to reach out via either Twitter or email.Thanks for reading!",
  "image": "https://www.swiftbysundell.com/images/articles/switching-between-swiftui-hstack-vstack.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eSwiftUI’s various stacks are some of the framework’s most fundamental layout tools, and enable us to define groups of views that are aligned either horizontally, vertically, or stacked in terms of depth.\u003c/p\u003e\u003cp\u003eWhen it comes to the horizontal and vertical variants (\u003ccode\u003eHStack\u003c/code\u003e and \u003ccode\u003eVStack\u003c/code\u003e), we might sometimes end up in a situation where we want to dynamically switch between the two. For example, let’s say that we’re building an app that contains the following \u003ccode\u003eLoginActionsView\u003c/code\u003e, which lets the user pick from a list of actions when logging in:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e LoginActionsView: \u003cspan\u003eView\u003c/span\u003e {\n    ...\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eVStack\u003c/span\u003e {\n            \u003cspan\u003eButton\u003c/span\u003e(\u003cspan\u003e\u0026#34;Login\u0026#34;\u003c/span\u003e) { ... }\n            \u003cspan\u003eButton\u003c/span\u003e(\u003cspan\u003e\u0026#34;Reset password\u0026#34;\u003c/span\u003e) { ... }\n            \u003cspan\u003eButton\u003c/span\u003e(\u003cspan\u003e\u0026#34;Create account\u0026#34;\u003c/span\u003e) { ... }\n        }\n        .\u003cspan\u003ebuttonStyle\u003c/span\u003e(\u003cspan\u003eActionButtonStyle\u003c/span\u003e())\n    }\n}\n\n\u003cspan\u003estruct\u003c/span\u003e ActionButtonStyle: \u003cspan\u003eButtonStyle\u003c/span\u003e {\n    \u003cspan\u003efunc\u003c/span\u003e makeBody(configuration: \u003cspan\u003eConfiguration\u003c/span\u003e) -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        configuration.\u003cspan\u003elabel\u003c/span\u003e\n            .\u003cspan\u003efixedSize\u003c/span\u003e()\n            .\u003cspan\u003eframe\u003c/span\u003e(maxWidth: .\u003cspan\u003einfinity\u003c/span\u003e)\n            .\u003cspan\u003epadding\u003c/span\u003e()\n            .\u003cspan\u003eforegroundColor\u003c/span\u003e(.\u003cspan\u003ewhite\u003c/span\u003e)\n            .\u003cspan\u003ebackground\u003c/span\u003e(\u003cspan\u003eColor\u003c/span\u003e.\u003cspan\u003eblue\u003c/span\u003e)\n            .\u003cspan\u003ecornerRadius\u003c/span\u003e(\u003cspan\u003e10\u003c/span\u003e)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAbove, we’re using the \u003ccode\u003efixedSize\u003c/code\u003e modifier to prevent our button labels from getting truncated, which is something that we should only do if we’re sure that a given view’s content won’t ever be larger than the view itself. To learn more, check out part three of my \u003ca href=\"https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-3/#fixed-dimensions\"\u003eguide to SwiftUI’s layout system\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eCurrently, our buttons are stacked vertically, and fill all of the available space on the horizontal axis (you can use the above code sample’s \u003ccode\u003ePREVIEW\u003c/code\u003e button to see what that looks like). While that looks great on iPhones that are in portrait orientation, let’s say that we instead wanted to use a horizontal stack when our UI is rendered in landscape mode.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"geometryreader-to-the-rescue\" href=\"#geometryreader-to-the-rescue\"\u003eGeometryReader to the rescue?\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eOne way to do that would be to use a \u003ccode\u003eGeometryReader\u003c/code\u003e to measure the currently available space, and based on whether the width of that space is larger than its height, we render our content using either an \u003ccode\u003eHStack\u003c/code\u003e or a \u003ccode\u003eVStack\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eWhile we \u003cem\u003ecould\u003c/em\u003e definitely place that logic right within our \u003ccode\u003eLoginActionsView\u003c/code\u003e itself, chances are quite high that we’ll want to reuse that code at some point in the future, so let’s instead create a dedicated view that’ll perform our dynamic stack-switching logic as a stand-alone component.\u003c/p\u003e\u003cp\u003eTo make our code even more future-proof, we won’t hard-code what alignment or spacing that our two stack variants will use. Instead, let’s do what SwiftUI itself does, and parametrize those attributes while also assigning the same default values that the framework uses — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e DynamicStack\u0026lt;Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003evar\u003c/span\u003e horizontalAlignment = \u003cspan\u003eHorizontalAlignment\u003c/span\u003e.\u003cspan\u003ecenter\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e verticalAlignment = \u003cspan\u003eVerticalAlignment\u003c/span\u003e.\u003cspan\u003ecenter\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e spacing: \u003cspan\u003eCGFloat\u003c/span\u003e?\u003c/span\u003e\n    \u003cspan\u003e@ViewBuilder var\u003c/span\u003e content: () -\u0026gt; \u003cspan\u003eContent\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003e\u003cspan\u003eGeometryReader\u003c/span\u003e\u003c/span\u003e { proxy \u003cspan\u003ein\u003c/span\u003e\n            \u003cspan\u003eGroup\u003c/span\u003e {\n                \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003eproxy.\u003cspan\u003esize\u003c/span\u003e.\u003cspan\u003ewidth\u003c/span\u003e \u0026gt; proxy.\u003cspan\u003esize\u003c/span\u003e.\u003cspan\u003eheight\u003c/span\u003e\u003c/span\u003e {\n                    \u003cspan\u003eHStack\u003c/span\u003e(\n                        alignment: verticalAlignment,\n                        spacing: spacing,\n                        content: content\n                    )\n                } \u003cspan\u003eelse\u003c/span\u003e {\n                    \u003cspan\u003eVStack\u003c/span\u003e(\n                        alignment: horizontalAlignment,\n                        spacing: spacing,\n                        content: content\n                    )\n                }\n            }\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSince we made our new \u003ccode\u003eDynamicStack\u003c/code\u003e use the same kind of API that \u003ccode\u003eHStack\u003c/code\u003e and \u003ccode\u003eVStack\u003c/code\u003e use, we can now simply swap out our previous \u003ccode\u003eVStack\u003c/code\u003e for an instance of our new, custom stack within our \u003ccode\u003eLoginActionsView\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e LoginActionsView: \u003cspan\u003eView\u003c/span\u003e {\n    ...\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003e\u003cspan\u003eDynamicStack\u003c/span\u003e\u003c/span\u003e {\n            \u003cspan\u003eButton\u003c/span\u003e(\u003cspan\u003e\u0026#34;Login\u0026#34;\u003c/span\u003e) { ... }\n            \u003cspan\u003eButton\u003c/span\u003e(\u003cspan\u003e\u0026#34;Reset password\u0026#34;\u003c/span\u003e) { ... }\n            \u003cspan\u003eButton\u003c/span\u003e(\u003cspan\u003e\u0026#34;Create account\u0026#34;\u003c/span\u003e) { ... }\n        }\n        .\u003cspan\u003ebuttonStyle\u003c/span\u003e(\u003cspan\u003eActionButtonStyle\u003c/span\u003e())\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNeat! However, like the above code sample’s \u003ccode\u003ePREVIEW\u003c/code\u003e shows, using a \u003ccode\u003eGeometeryReader\u003c/code\u003e to perform our dynamic stack switching does come with a quite significant downside, in that geometry readers always fill all of the available space on both the horizontal and vertical axis (in order to actually be able to measure that space). In our case, that means that our \u003ccode\u003eLoginActionsView\u003c/code\u003e will no longer just stretch out horizontally, but it’ll now also move to the top of the screen.\u003c/p\u003e\u003cp\u003eWhile there are various ways that we could address those problems (for example by using a technique similar to the one we used to make multiple views have the same width or height \u003ca href=\"https://www.swiftbysundell.com/questions/syncing-the-width-or-height-of-two-swiftui-views\"\u003ein this Q\u0026amp;A article\u003c/a\u003e), the question is really whether measuring the available space is really a good approach when it comes to determining the orientation of our dynamic stacks.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"a-case-for-size-classes\" href=\"#a-case-for-size-classes\"\u003eA case for size classes\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eInstead, let’s use Apple’s size class system to decide whether our \u003ccode\u003eDynamicStack\u003c/code\u003e should use an \u003ccode\u003eHStack\u003c/code\u003e or a \u003ccode\u003eVStack\u003c/code\u003e under the hood. The benefit of doing that is not just that we’ll be able to retain the same compact layout that we had before introducing a \u003ccode\u003eGeometryReader\u003c/code\u003e into the mix, but also that our \u003ccode\u003eDynamicStack\u003c/code\u003e will start behaving in a way that’s very similar to how built-in system components behave across all devices and orientations.\u003c/p\u003e\u003cp\u003eTo start observing the current horizontal size class, all we have to do is to use SwiftUI’s \u003ca href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#observing-and-modifying-the-environment\"\u003eenvironment system\u003c/a\u003e — by declaring an \u003ccode\u003e@Environment\u003c/code\u003e-marked property (with the \u003ccode\u003ehorizontalSizeClass \u003c/code\u003e \u003ca href=\"https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift\"\u003ekey path\u003c/a\u003e) within our \u003ccode\u003eDynamicStack\u003c/code\u003e, which will then let us switch on the current \u003ccode\u003esizeClass\u003c/code\u003e value within our view’s \u003ccode\u003ebody\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e DynamicStack\u0026lt;Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    ...\n    \u003cspan\u003e\u003cspan\u003e@Environment\u003c/span\u003e(\\.\u003cspan\u003ehorizontalSizeClass\u003c/span\u003e) \u003cspan\u003eprivate var\u003c/span\u003e sizeClass\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eswitch\u003c/span\u003e \u003cspan\u003esizeClass\u003c/span\u003e {\n        \u003cspan\u003ecase\u003c/span\u003e .\u003cspan\u003eregular\u003c/span\u003e:\n            hStack\n        \u003cspan\u003ecase\u003c/span\u003e .\u003cspan\u003ecompact\u003c/span\u003e, .\u003cspan\u003enone\u003c/span\u003e:\n            vStack\n        \u003cspan\u003e@unknown default\u003c/span\u003e:\n            vStack\n        }\n    }\n}\n\n\u003cspan\u003eprivate extension\u003c/span\u003e \u003cspan\u003eDynamicStack\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e hStack: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eHStack\u003c/span\u003e(\n            alignment: verticalAlignment,\n            spacing: spacing,\n            content: content\n        )\n    }\n\n    \u003cspan\u003evar\u003c/span\u003e vStack: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eVStack\u003c/span\u003e(\n            alignment: horizontalAlignment,\n            spacing: spacing,\n            content: content\n        )\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith the above in place, our \u003ccode\u003eLoginActionsView\u003c/code\u003e will now dynamically switch between having a horizontal layout when rendered using the \u003ccode\u003eregular\u003c/code\u003e size class (for example in landscape on larger iPhones, or in either orientation when running full-screen on iPad), and a vertical layout when any other size class configuration is used. All while still using a compact vertical layout that doesn’t use any more space than what’s needed to render its content.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"using-the-layout-protocol\" href=\"#using-the-layout-protocol\"\u003eUsing the Layout protocol\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAlthough we’ve already ended up with a neat solution that works across all iOS versions that support SwiftUI, let’s also explore a few new layout tools that are being introduced in iOS 16 (which at the time of writing is still in beta as part of Xcode 14).\u003c/p\u003e\u003cp\u003eOne such tool is the new \u003ccode\u003eLayout\u003c/code\u003e protocol, which both enables us to build completely custom layouts that can be integrated directly into SwiftUI’s own layout system (more on that in a future article), while also providing us with a new way to dynamically switch between various layouts in a very smooth, full animatable way.\u003c/p\u003e\u003cp\u003eThat’s because it turns out that \u003ccode\u003eLayout\u003c/code\u003e is not just an API for us third-party developers, but Apple have also made SwiftUI’s own layout containers use that new protocol as well. So, rather than using \u003ccode\u003eHStack\u003c/code\u003e and \u003ccode\u003eVStack\u003c/code\u003e directly as container views, we can instead use them as \u003ccode\u003eLayout\u003c/code\u003e-conforming instances that are wrapped using the \u003ccode\u003eAnyLayout\u003c/code\u003e type — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprivate extension\u003c/span\u003e \u003cspan\u003eDynamicStack\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e currentLayout: \u003cspan\u003eAnyLayout\u003c/span\u003e {\n        \u003cspan\u003eswitch\u003c/span\u003e sizeClass {\n        \u003cspan\u003ecase\u003c/span\u003e .\u003cspan\u003eregular\u003c/span\u003e, .\u003cspan\u003enone\u003c/span\u003e:\n            \u003cspan\u003ereturn\u003c/span\u003e horizontalLayout\n        \u003cspan\u003ecase\u003c/span\u003e .\u003cspan\u003ecompact\u003c/span\u003e:\n            \u003cspan\u003ereturn\u003c/span\u003e verticalLayout\n        \u003cspan\u003e@unknown default\u003c/span\u003e:\n            \u003cspan\u003ereturn\u003c/span\u003e verticalLayout\n        }\n    }\n\n    \u003cspan\u003evar\u003c/span\u003e horizontalLayout: \u003cspan\u003eAnyLayout\u003c/span\u003e {\n        \u003cspan\u003eAnyLayout\u003c/span\u003e(\u003cspan\u003eHStack\u003c/span\u003e(\n            alignment: verticalAlignment,\n            spacing: spacing\n        ))\n    }\n\n    \u003cspan\u003evar\u003c/span\u003e verticalLayout: \u003cspan\u003eAnyLayout\u003c/span\u003e {\n        \u003cspan\u003eAnyLayout\u003c/span\u003e(\u003cspan\u003eVStack\u003c/span\u003e(\n            alignment: horizontalAlignment,\n            spacing: spacing\n        ))\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above works since both \u003ccode\u003eHStack\u003c/code\u003e and \u003ccode\u003eVStack\u003c/code\u003e directly conform to the new \u003ccode\u003eLayout\u003c/code\u003e protocol when their \u003ccode\u003eContent\u003c/code\u003e type is \u003ccode\u003eEmptyView\u003c/code\u003e (which is the case when we don’t pass any \u003ccode\u003econtent\u003c/code\u003e closure to such a stack), as we can see if we take a peak at SwiftUI’s public interface:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eVStack\u003c/span\u003e: \u003cspan\u003eLayout\u003c/span\u003e \u003cspan\u003e\u003cspan\u003ewhere\u003c/span\u003e \u003cspan\u003eContent\u003c/span\u003e == \u003cspan\u003eEmptyView\u003c/span\u003e\u003c/span\u003e {\n    ...\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that, due to a regression, the above conditional conformance was omitted from Xcode 14 beta 3. According to \u003ca href=\"https://twitter.com/ricketson_/status/1544784314453282817\"\u003eMatt Ricketson from the SwiftUI team\u003c/a\u003e, a temporary workaround would be to instead use the underlying \u003ccode\u003e_HStackLayout\u003c/code\u003e and \u003ccode\u003e_VStackLayout\u003c/code\u003e types directly. Hopefully that regression will be fixed in future betas.\u003c/p\u003e\u003cp\u003eNow that we’re able to resolve what layout to use through our new \u003ccode\u003ecurrentLayout\u003c/code\u003e property, we can now update our \u003ccode\u003ebody\u003c/code\u003e implementation to simply call the \u003ccode\u003eAnyLayout\u003c/code\u003e that’s returned from that property as if it was a function — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e DynamicStack\u0026lt;Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    ...\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003e\u003cspan\u003ecurrentLayout\u003c/span\u003e(content)\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe reason that we can apply our layout by calling it as a function (even though it’s actually a struct) is because the \u003ccode\u003eLayout\u003c/code\u003e protocol uses Swift’s \u003ca href=\"https://www.swiftbysundell.com/articles/exploring-swift-5-2s-new-functional-features/#calling-types-as-functions\"\u003e“call as function” feature\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eSo what’s the difference between our previous solution and the above, \u003ccode\u003eLayout\u003c/code\u003e-based one? The key difference (besides the fact that the latter requires iOS 16) is that switching layouts preserves the identity of the underlying views that are being rendered, which isn’t the case when swapping between an \u003ccode\u003eHStack\u003c/code\u003e and a \u003ccode\u003eVStack\u003c/code\u003e. The result of that is that animations will be much smoother, for example when switching device orientations, and we’re also likely to get a small performance boost when performing such changes as well (since SwiftUI always performs best when its view hierarchies are as static as possible).\u003c/p\u003e\u003ch2\u003e\u003ca id=\"picking-the-view-that-fits\" href=\"#picking-the-view-that-fits\"\u003ePicking the view that fits\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eBut we’re not quite done yet, because iOS 16 also gives us \u003cem\u003eanother\u003c/em\u003e interesting new layout tool that could potentially be used to implement our \u003ccode\u003eDynamicStack\u003c/code\u003e — which is a new view type called \u003ccode\u003eViewThatFits\u003c/code\u003e. Like its name implies, that new container will pick the view that best fits within the current context, based on a list of candidates that we pass when initializing it.\u003c/p\u003e\u003cp\u003eIn our case, that means that we could pass it both an \u003ccode\u003eHStack\u003c/code\u003e and a \u003ccode\u003eVStack\u003c/code\u003e, and it’ll automatically switch between them on our behalf:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e DynamicStack\u0026lt;Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    ...\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003e\u003cspan\u003eViewThatFits\u003c/span\u003e\u003c/span\u003e {\n            \u003cspan\u003eHStack\u003c/span\u003e(\n                alignment: verticalAlignment,\n                spacing: spacing,\n                content: content\n            )\n\n            \u003cspan\u003eVStack\u003c/span\u003e(\n                alignment: horizontalAlignment,\n                spacing: spacing,\n                content: content\n            )\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that it’s important that we place the \u003ccode\u003eHStack\u003c/code\u003e first in this case, since the \u003ccode\u003eVStack\u003c/code\u003e will likely always fit, even within contexts where we want our layout to be horizontal (such as in full-screen mode on iPad). It’s also important to point out that the above \u003ccode\u003eViewThatFits\u003c/code\u003e-based technique will \u003cem\u003ealways\u003c/em\u003e attempt to use our \u003ccode\u003eHStack\u003c/code\u003e, even when rendered with the compact size class, and will only pick our \u003ccode\u003eVStack\u003c/code\u003e-based layout when the \u003ccode\u003eHStack\u003c/code\u003e doesn’t fit.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"conclusion\" href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSo that’s four different ways to implement a dedicated \u003ccode\u003eDynamicStack\u003c/code\u003e view that dynamically switches between an \u003ccode\u003eHStack\u003c/code\u003e and a \u003ccode\u003eVStack\u003c/code\u003e depending on the current context. I hope you enjoyed this article, and if you have any questions, comments, or feedback, then feel free to reach out via either \u003ca href=\"https://twitter.com/johnsundell\"\u003eTwitter\u003c/a\u003e or \u003ca href=\"https://www.swiftbysundell.com/contact\"\u003eemail\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": null,
  "modifiedTime": null
}
