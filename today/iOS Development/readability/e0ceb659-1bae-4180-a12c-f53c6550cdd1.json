{
  "id": "e0ceb659-1bae-4180-a12c-f53c6550cdd1",
  "title": "Open Source checklist for your next Swift library",
  "link": "https://benoitpasquier.com/open-source-checklist-swift-library/",
  "description": "Like many developers, I use open source tools on daily basis. Recently, I’ve got the chance to create one for other teammates and try to think about what I should consider before launching it. Today I share this checklist.",
  "author": "",
  "published": "Sat, 11 Sep 2021 08:00:00 +0000",
  "source": "https://benoitpasquier.com/index.xml",
  "categories": null,
  "byline": "Benoit Pasquier",
  "length": 6036,
  "excerpt": "Like many developers, I use open source tools on daily basis. Recently, I’ve got the chance to create one for other teammates and try to think about what I should consider before launching it. Today I share this checklist.",
  "siteName": "Benoit Pasquier",
  "favicon": "https://benoitpasquier.com/favicon.png",
  "text": "Like many developers, I use open source tools on daily basis. Recently, I’ve got the chance to create one for other teammates and try to think about what I should consider before launching it. Today I share this checklist. License Before sharing anything, it’s quite important to know what would be the license for your project. Thing is there are so many that it can be tricky to know what to consider for this. Fortunately, Github helps developers quite a lot to navigate in this area. It’s directly part of the steps when creating a new repository, so it makes it even easier for us to consider it from the start. If you wonder why licenses are important, it defines how your software can be used, edited or distributed. Some have different restrictions, for instance for commercial use. To understand more in-depth the most popular licenses and what applies to your own project, Opensource.org can be a good place to start. In my case, it’s an internal tool for my current company, so all rights reserved applied. Compatibility It’s important to know early on the compatibility of your project. It can be defined at different level. It could be based on the language used: what Swift version? Is Swift 5 and above enough? It could be based on the available platform: is it iOS only? macOS too? And what version of the operation system? It could be based on its dependencies: if you need latest Ruby version or Python, make sure to be explicit from the start. Finally, it can be about other system it interact with, like a dependency manager. Distributing a library through Swift Packager Manager, CocoaPods or Carthage requires a different effort. Often, contributors use badges on the header of their repositories to help clarify those information. With a quick look, you can see what is required to make use of this project. Clarity is essential in open source projects. Stability Once the compatibility is define, next step is stability. As a developer, when I evaluate if I can use a third-party library for work, I like to see how stable it is. For instance, does the project has unit-test? Is there unit-test coverage rate? Is there a continuous-integration set to run those tests? How about documentation? Is there a Wiki space? Maybe a sample app to navigate? On the other hand, how many issues are known? How often are they resolved? If those are my questions before using a third-part library, it makes sense to have the same requirements when creating a similar library for others to use. Those information are really important for other developers, it help to build confidence in your tool that it won’t break at the first try. But what about you? If you compare two exact same libraries with the exact same codebase, but one repository has a continuous integration, a built-in documentation, an extra sample app and all badges in green. Which one would you be more confident using? Documentation Early on in your project, I also believe it’s important to document as much as possible. For instance, sharing your vision and your long term plan for your library could be a good start. You can also illustrate what project you want to tackle and what are the advantages of your solutions. It can also be to share your design choices and trade-off made or any other technical decisions. This kind of content will avoid other developers to ask later “why not doing X rather than Y?”. There is also a need of documentation when it comes to installation and usage. It’s always good to have some code snippet or a sample app to showcase your tool. When diving deeper into the technical aspect, it also great to document the code and potentially have a Wiki / web documentation outside too. Fortunately, there are plenty of tools to generate documentation based on the codebase. For Swift project, my go-to are swift-doc and SourceDocs. Collaboration We can’t talk about open source projects without mentioning collaboration and contributions of peers. After all, it’s a community effort to maintain all those amazing projects. This is also why it’s best practice to share guidelines how to contribute and be part of this community. Using template for pull request can be a good start to standardize any new contribution format. If you’re open for external contribution, make sure to have also a CI/CD pipeline setup. At this stage, it would be a shame to have to manually re-test every available feature. If your tool is heavily used and your community get bigger and bigger, it could be good to even create new standard how to submit feature request and bug reports. That’s something Fastlane community put in place to help triage and prioritize their work. It could be good to create a space for maintainers and users to discuss and help each others. That can be a forum like Appium or Swift, or create a Slack or Discord. Finally, as a maintainer, it’s very important to stay open to other contributors’ feedback and suggestion. If maintainers became rude and dismissive to others, then it will most likely kill the community all together. Remember that openness is the key to open source development. Know when to stop One last thing that is worth mentioning is to know when deprecating and archiving your work. You built this amazing library few years back and don’t feel the energy to support and maintain it? That’s okay. Life goes on, and you move to new projects, people will understand. When you leave this project, if you can find new maintainers to take over, that’s really great. If you can’t, just highlight your library is deprecated or archive it moving forward. This will help any developers to know the status of it if they ever find it. In conclusion, if open source projects are really exciting to start and a great opportunity to share your latest tool or framework, there is a lot more to consider for it to survive over time. After all, it’s not just a project but it becomes a product on its own with its users. Resources: Best Practices for Maintainers Scaling Photo credits Glenn Carstens-Peters",
  "image": "https://benoitpasquier.com/images/2021/09/open-source-checklist.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n              \u003cp\u003eLike many developers, I use open source tools on daily basis. Recently, I’ve got the chance to create one for other teammates and try to think about what I should consider before launching it. Today I share this checklist.\u003c/p\u003e\n\u003ch2 id=\"license\"\u003eLicense\u003c/h2\u003e\n\u003cp\u003eBefore sharing anything, it’s quite important to know what would be the license for your project. Thing is there are so many that it can be tricky to know what to consider for this.\u003c/p\u003e\n\u003cp\u003eFortunately, \u003ca href=\"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/licensing-a-repository\"\u003eGithub\u003c/a\u003e helps developers quite a lot to navigate in this area.\u003c/p\u003e\n\u003cp\u003eIt’s directly part of the steps when creating a new repository, so it makes it even easier for us to consider it from the start.\u003c/p\u003e\n\u003cp\u003eIf you wonder why licenses are important, it defines how your software can be used, edited or distributed. Some have different restrictions, for instance for commercial use.\u003c/p\u003e\n\u003cp\u003eTo understand more in-depth the most popular licenses and what applies to your own project, \u003ca href=\"https://opensource.org/licenses\"\u003eOpensource.org\u003c/a\u003e can be a good place to start.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eIn my case\u003c/em\u003e, it’s an internal tool for my current company, so all rights reserved applied.\u003c/p\u003e\n\u003ch2 id=\"compatibility\"\u003eCompatibility\u003c/h2\u003e\n\u003cp\u003eIt’s important to know early on the compatibility of your project. It can be defined at different level.\u003c/p\u003e\n\u003cp\u003eIt could be based on the language used: what Swift version? Is Swift 5 and above enough?\u003c/p\u003e\n\u003cp\u003eIt could be based on the available platform: is it iOS only? macOS too? And what version of the operation system?\u003c/p\u003e\n\u003cp\u003eIt could be based on its dependencies: if you need latest Ruby version or Python, make sure to be explicit from the start.\u003c/p\u003e\n\u003cp\u003eFinally, it can be about other system it interact with, like a \u003cem\u003edependency manager\u003c/em\u003e. Distributing a library through Swift Packager Manager, CocoaPods or Carthage requires a different effort.\u003c/p\u003e\n\u003cp\u003eOften, contributors use badges on the header of their repositories to help clarify those information. With a quick look, you can see what is required to make use of this project.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eClarity is essential in open source projects.\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"stability\"\u003eStability\u003c/h2\u003e\n\u003cp\u003eOnce the compatibility is define, next step is \u003cem\u003estability\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAs a developer, when I evaluate if I can use a third-party library for work, I like to see how stable it is.\u003c/p\u003e\n\u003cp\u003eFor instance, does the project has unit-test? Is there unit-test coverage rate? Is there a continuous-integration set to run those tests?\u003c/p\u003e\n\u003cp\u003eHow about documentation? Is there a Wiki space? Maybe a sample app to navigate?\u003c/p\u003e\n\u003cp\u003eOn the other hand, how many issues are known? How often are they resolved?\u003c/p\u003e\n\u003cp\u003eIf those are my questions before using a third-part library, it makes sense to have the same requirements when creating a similar library for others to use.\u003c/p\u003e\n\u003cp\u003eThose information are really important for other developers, it help to build confidence in your tool that it won’t break at the first try.\u003c/p\u003e\n\u003cp\u003eBut what about you? If you compare two exact same libraries with the exact same codebase, but one repository has a continuous integration, a built-in documentation, an extra sample app and all badges in green. \u003cem\u003eWhich one would you be more confident using?\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"documentation\"\u003eDocumentation\u003c/h2\u003e\n\u003cp\u003eEarly on in your project, I also believe it’s important to document as much as possible.\u003c/p\u003e\n\u003cp\u003eFor instance, sharing your vision and your long term plan for your library could be a good start. You can also illustrate what project you want to tackle and what are the advantages of your solutions.\u003c/p\u003e\n\u003cp\u003eIt can also be to share your design choices and trade-off made or any other technical decisions. This kind of content will avoid other developers to ask later “why not doing \u003cem\u003eX\u003c/em\u003e rather than \u003cem\u003eY\u003c/em\u003e?”.\u003c/p\u003e\n\u003cp\u003eThere is also a need of documentation when it comes to installation and usage. It’s always good to have some code snippet or a sample app to showcase your tool.\u003c/p\u003e\n\u003cp\u003eWhen diving deeper into the technical aspect, it also great to document the code and potentially have a Wiki / web documentation outside too. Fortunately, there are plenty of tools to generate documentation based on the codebase. For Swift project, my go-to are \u003ca href=\"https://github.com/SwiftDocOrg/swift-doc\"\u003eswift-doc\u003c/a\u003e and \u003ca href=\"https://github.com/eneko/SourceDocs\"\u003eSourceDocs\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"collaboration\"\u003eCollaboration\u003c/h2\u003e\n\u003cp\u003eWe can’t talk about open source projects without mentioning collaboration and contributions of peers. After all, it’s a community effort to maintain all those amazing projects.\u003c/p\u003e\n\u003cp\u003eThis is also why it’s best practice to share guidelines how to contribute and be part of this community.\u003c/p\u003e\n\u003cp\u003eUsing template for pull request can be a good start to standardize any new contribution format.\u003c/p\u003e\n\u003cp\u003eIf you’re open for external contribution, make sure to have also a CI/CD pipeline setup. At this stage, it would be a shame to have to manually re-test every available feature.\u003c/p\u003e\n\u003cp\u003eIf your tool is heavily used and your community get bigger and bigger, it could be good to even create new standard how to submit feature request and bug reports. That’s something \u003ca href=\"https://github.com/fastlane/fastlane/issues/16811\"\u003eFastlane\u003c/a\u003e community put in place to help triage and prioritize their work.\u003c/p\u003e\n\u003cp\u003eIt could be good to create a space for maintainers and users to discuss and help each others. That can be a forum like \u003ca href=\"https://discuss.appium.io/\"\u003eAppium\u003c/a\u003e or \u003ca href=\"https://forums.swift.org/\"\u003eSwift\u003c/a\u003e, or create a Slack or Discord.\u003c/p\u003e\n\u003cp\u003eFinally, as a maintainer, it’s very important to stay open to other contributors’ feedback and suggestion. If maintainers became rude and dismissive to others, then it will most likely kill the community all together.\u003c/p\u003e\n\u003cp\u003eRemember that openness is the key to open source development.\u003c/p\u003e\n\u003ch2 id=\"know-when-to-stop\"\u003eKnow when to stop\u003c/h2\u003e\n\u003cp\u003eOne last thing that is worth mentioning is to know when deprecating and archiving your work.\u003c/p\u003e\n\u003cp\u003eYou built this amazing library few years back and don’t feel the energy to support and maintain it?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThat’s okay.\u003c/em\u003e Life goes on, and you move to new projects, people will understand.\u003c/p\u003e\n\u003cp\u003eWhen you \u003cem\u003eleave\u003c/em\u003e this project, if you can find new maintainers to take over, that’s really great. If you can’t, just highlight your library is deprecated or archive it moving forward. This will help any developers to know the status of it if they  ever find it.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eIn conclusion, if open source projects are really exciting to start and a great opportunity to share your latest tool or framework, there is a lot more to consider for it to survive over time. After all, it’s not just \u003cem\u003ea\u003c/em\u003e project but it becomes a \u003cem\u003eproduct on its own\u003c/em\u003e with its users.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003e\u003cem\u003eResources:\u003c/em\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://opensource.guide/best-practices/\"\u003eBest Practices for Maintainers\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://krausefx.com/blog/scaling-open-source-communities\"\u003eScaling \u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003ePhoto credits \u003ca href=\"https://unsplash.com/@glenncarstenspeters\"\u003eGlenn Carstens-Peters\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n              \n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2021-09-11T08:00:00Z",
  "modifiedTime": "2021-09-11T08:00:00Z"
}
