{
  "id": "a3bbdd5e-6491-4b76-a73a-99ee0e5ff7f6",
  "title": "Setting up Auto Layout constraints programmatically in Swift",
  "link": "https://benoitpasquier.com/auto-layout-constraint-swift/",
  "description": "In iOS development, content alignment and spacing is something that can take a lot of our time. Today, let’s explore how to set constraint with UIKit, update them and resolve constraint conflicts.",
  "author": "",
  "published": "Mon, 14 Mar 2022 01:00:00 +0000",
  "source": "https://benoitpasquier.com/index.xml",
  "categories": null,
  "byline": "Benoit Pasquier",
  "length": 7936,
  "excerpt": "In iOS development, content alignment and spacing is something that can take a lot of our time. Today, let’s explore how to set constraint with UIKit, update them and resolve constraint conflicts.",
  "siteName": "Benoit Pasquier",
  "favicon": "https://benoitpasquier.com/favicon.png",
  "text": "In iOS development, content alignment and spacing is something that can take a lot of our time. Today, let’s explore how to set constraint with UIKit, update them and resolve constraint conflicts. Let’s start with a simple definition: a constraint is a rule to let the operating system how to place your UI component. It was introduced in iOS6 and iPadOS6. It was a simpler way to create scalable and reusable design across Apple devices. With UIKit, there are 2 main ways to setup constraints: using interface builder and programmatically. This article will only focus on the code approach. Creating new constraint First thing we have to do is to enable the view for Auto Layout: let view = UIView(frame: .zero) view.translatesAutoresizingMaskIntoConstraints = false From there, we have few options to setup the constraint, either by Anchors or Visual Format Language (or VFL). Here is two examples of the same constraints, setting height and width to 100. // Anchors view.heightAnchor.constraint(equalToConstant: 100) view.widthAnchor.constraint(equalToConstant: 100) // VFL let viewDictionary = [\"view\": view] let horizontalConstraints = NSLayoutConstraint.constraints(withVisualFormat: \"H:[view(100)]\", metrics: nil, views: viewDictionary) let verticalConstraints = NSLayoutConstraint.constraints(withVisualFormat: \"V:[view(100)]\", metrics: nil, views: viewDictionary) VFL can be a good fit for a simple view, but the syntax is not always easy to read if we have a lot of views to handle. Compared to VFL, Anchors is more commonly used and doesn’t require to handle constraints from its superView. You get the idea though, anything we can do with Anchors, we can do with Visual Format Language, and vice-versa. It’s more a code flavor. For the rest of the article, I’ll stick with Anchors. Regarding the constraint itself, we can define a lot of them. It can be for the dimension like width and height, but also the position of the view, from its edges (left, right, top and bottom) or center. We can also create constraint between different views to match alignment or dimensions, and so on. Activating constraints An important step to make constraints work is to activate them. It doesn’t apply by default. To do so, you can either switch the constraint to isActive, one at a time, or use .activate() function to update a batch of constraints at once. let heightConstraint = view.heightAnchor.constraint(equalToConstant: 100) // Activate one at a time heightConstraint.isActive = true // Activate multiple at a time NSLayoutConstraint.activate([ heightConstraint, ... ]) You can deactivate them the same way. // Deactivate one at a time heightConstraint.isActive = false // Deactivate multiple at a time NSLayoutConstraint.deactivate([ heightConstraint, ... ]) Note that to deactivate a constraint, it requires to access the reference to the activated constraint. You cannot just copy/paste the definition of it. // Activating view.heightAnchor.constraint(equalToConstant: 100).isActive = true // Deactivating? Not really view.heightAnchor.constraint(equalToConstant: 100).isActive = false This code doesn’t deactivate the first one, it create a separate (duplicated) constraint and deactivate it. The first one still applies. Manipulating constraints Constraints can be updated after being applied, to change spacing or dimension for instance. let heightConstraint = view.heightAnchor.constraint(equalToConstant: 100) heightConstraint.constant = 50 We can also animate view through constraints. The key is to make sure to call layoutIfNeeded(). UIView.animate(withDuration: 1.0, animations: { heightConstraint.constant = 50 view.layoutIfNeeded() }) Resolving constraint conflicts Now that we have explore the basics how to add, edit and activate constraints, here comes the trouble: resolving conflicting constraints. In most cases, Xcode will indicate it in the Console that it cannot resolve constraints in the Console. When opening Debug View Hierarchy, we can inspect each constraint and detect where the conflict comes from. Conflicts almost always due to priority issues. If I set a view height constraint to 100 then another constraint to 50, the system cannot tell which one to enforce. This will create a conflict. view.heightAnchor.constraint(equalToConstant: 100).isActive = true view.heightAnchor.constraint(equalToConstant: 50).isActive = true To detect this kind of conflict, we can setup a Symbolic Breakpoint with UIViewAlertForUnsatisfiableConstraints to detect those wrongly setup. Once we identified which constraints are conflicting, then we can change the priority in favor of one and reduce the second, highest being 1000. let heightConstraint1 = view.heightAnchor.constraint(equalToConstant: 100) let heightConstraint2 = view.heightAnchor.constraint(equalToConstant: 50) // height 100 applies heightConstraint1.priority = 1000 heightConstraint2.priority = 999 // height 50 applies heightConstraint1.priority = 999 heightConstraint2.priority = 1000 If you don’t want to manipulate the priority yourself and get confused with value, there are predefined values we can reuse. heightConstraint1.priority = .required heightConstraint2.priority = .defaultLow Auto Layout and Constraint Resistance For some UIView, we cannot always enforce a specific dimension. For instance, if we have a UIButton with Tap and hardcode the value, when we localize it to other regions, the text could be cut off. To handle this without requiring to change the priority, we can use different set of constraint functions to avoid those behaviors. Two of them are Content Hugging and Content Resistance. Hugging is to make sure the view shouldn’t grow further Resistance is to make sure the view shouldn’t shrink further Back to my UIButton Tap, instead of setting up width constraint to avoid any cut off, I can enforce resistance to avoid any shrinking. A different localization text will extend it to always be fully displayed. button.setContentResistancePriority(.required, for: .horizontal) It can work the same for Content Hugging, horizontal or vertical, with a different set of priority view.setContentHuggingPriority(.defaultLow, for: .vertical) Safe area constraints With multiple devices to support, anchoring only might not be enough. For instance, what if you have a status bar or navigation bar, how do we factor the home button area for new iPhones? Thankfully, UIKit comes with a property safeAreaLayoutGuide to adapt to its safe area so we can focus on the view and less on the device spacing area. It allows us to have same spacing for an iPhone8 or iPhone13 for instance. In this example, I safely set a UITextView to fit another view safe area. NSLayoutConstraint.activate([ textView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor), textView.leftAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leftAnchor), textView.rightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.rightAnchor), textView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor), ]) Conclusion In conclusion, Auto Layout is a very powerful api. It definitely made development easier to apply a design across multiple devices and resize to the right dimension. With safe area constraint and different priority, it gets easier and easier to adapt to new devices, from iPhone 13 mini to iPad Pro. As we can create a lot of them very quickly, it can be hard to keep track of all of them when a conflict occurs. Thankfully, Xcode came with different tools to monitor this. Should you set constraints programmatically? I would say it’s more about code flavor. I often chose to set constraints programmatically to make it easier to maintain and debug as I have many teammates. That being said, you know best your project, you can try and see what make more sense to you and your team. What about you? What do you use and prefer when it comes to Auto Layout?",
  "image": "https://benoitpasquier.com/images/2022/03/ios-constraints.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n              \u003cp\u003eIn iOS development, content alignment and spacing is something that can take a lot of our time. Today, let’s explore how to set constraint with UIKit, update them and resolve constraint conflicts.\u003c/p\u003e\n\u003cp\u003eLet’s start with a simple definition: a constraint is a rule to let the operating system how to place your UI component.\u003c/p\u003e\n\u003cp\u003eIt was introduced in iOS6 and iPadOS6. It was a simpler way to create scalable and reusable design across Apple devices.\u003c/p\u003e\n\u003cp\u003eWith UIKit, there are 2 main ways to setup constraints: using interface builder and programmatically. This article will only focus on the code approach.\u003c/p\u003e\n\u003ch2 id=\"creating-new-constraint\"\u003eCreating new constraint\u003c/h2\u003e\n\u003cp\u003eFirst thing we have to do is to enable the view for Auto Layout:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eview\u003c/span\u003e = \u003cspan\u003eUIView\u003c/span\u003e(\u003cspan\u003eframe\u003c/span\u003e: .\u003cspan\u003ezero\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003etranslatesAutoresizingMaskIntoConstraints\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFrom there, we have few options to setup the constraint, either by \u003cem\u003eAnchors\u003c/em\u003e or \u003cem\u003eVisual Format Language\u003c/em\u003e (or VFL).\u003c/p\u003e\n\u003cp\u003eHere is two examples of the same constraints, setting height and width to \u003ccode\u003e100\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Anchors\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eheightAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalToConstant\u003c/span\u003e: \u003cspan\u003e100\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003ewidthAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalToConstant\u003c/span\u003e: \u003cspan\u003e100\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// VFL\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eviewDictionary\u003c/span\u003e = [\u003cspan\u003e\u0026#34;view\u0026#34;\u003c/span\u003e: \u003cspan\u003eview\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ehorizontalConstraints\u003c/span\u003e = \u003cspan\u003eNSLayoutConstraint\u003c/span\u003e.\u003cspan\u003econstraints\u003c/span\u003e(\u003cspan\u003ewithVisualFormat\u003c/span\u003e: \u003cspan\u003e\u0026#34;H:[view(100)]\u0026#34;\u003c/span\u003e, \u003cspan\u003emetrics\u003c/span\u003e: \u003cspan\u003enil\u003c/span\u003e, \u003cspan\u003eviews\u003c/span\u003e: \u003cspan\u003eviewDictionary\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003everticalConstraints\u003c/span\u003e = \u003cspan\u003eNSLayoutConstraint\u003c/span\u003e.\u003cspan\u003econstraints\u003c/span\u003e(\u003cspan\u003ewithVisualFormat\u003c/span\u003e: \u003cspan\u003e\u0026#34;V:[view(100)]\u0026#34;\u003c/span\u003e, \u003cspan\u003emetrics\u003c/span\u003e: \u003cspan\u003enil\u003c/span\u003e, \u003cspan\u003eviews\u003c/span\u003e: \u003cspan\u003eviewDictionary\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eVFL can be a good fit for a simple view, but the syntax is not always easy to read if we have a lot of views to handle. Compared to VFL, \u003cem\u003eAnchors\u003c/em\u003e is more commonly used and doesn’t require to handle constraints from its \u003ccode\u003esuperView\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYou get the idea though, anything we can do with \u003cem\u003eAnchors\u003c/em\u003e, we can do with \u003cem\u003eVisual Format Language\u003c/em\u003e, and vice-versa. It’s more a code flavor. For the rest of the article, I’ll stick with Anchors.\u003c/p\u003e\n\u003cp\u003eRegarding the constraint itself, we can define a lot of them. It can be for the dimension like width and height, but also the position of the view, from its edges (left, right, top and bottom) or center. We can also create constraint between different views to match alignment or dimensions, and so on.\u003c/p\u003e\n\u003ch2 id=\"activating-constraints\"\u003eActivating constraints\u003c/h2\u003e\n\u003cp\u003eAn important step to make constraints work is to activate them. It doesn’t apply by default.\u003c/p\u003e\n\u003cp\u003eTo do so, you can either switch the constraint to \u003ccode\u003eisActive\u003c/code\u003e, one at a time, or use \u003ccode\u003e.activate()\u003c/code\u003e function to update a batch of constraints at once.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eheightConstraint\u003c/span\u003e = \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eheightAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalToConstant\u003c/span\u003e: \u003cspan\u003e100\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Activate one at a time\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eheightConstraint\u003c/span\u003e.\u003cspan\u003eisActive\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Activate multiple at a time\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eNSLayoutConstraint\u003c/span\u003e.\u003cspan\u003eactivate\u003c/span\u003e([\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eheightConstraint\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eYou can deactivate them the same way.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Deactivate one at a time\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eheightConstraint\u003c/span\u003e.\u003cspan\u003eisActive\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Deactivate multiple at a time\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eNSLayoutConstraint\u003c/span\u003e.\u003cspan\u003edeactivate\u003c/span\u003e([\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eheightConstraint\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNote that to deactivate a constraint, it requires to access the reference to the activated constraint. You cannot just copy/paste the definition of it.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Activating\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eheightAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalToConstant\u003c/span\u003e: \u003cspan\u003e100\u003c/span\u003e).\u003cspan\u003eisActive\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Deactivating? Not really\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eheightAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalToConstant\u003c/span\u003e: \u003cspan\u003e100\u003c/span\u003e).\u003cspan\u003eisActive\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis code doesn’t deactivate the first one, it create a separate (duplicated) constraint and deactivate it. The first one still applies.\u003c/p\u003e\n\u003ch2 id=\"manipulating-constraints\"\u003eManipulating constraints\u003c/h2\u003e\n\u003cp\u003eConstraints can be updated after being applied, to change spacing or dimension for instance.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eheightConstraint\u003c/span\u003e = \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eheightAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalToConstant\u003c/span\u003e: \u003cspan\u003e100\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eheightConstraint\u003c/span\u003e.\u003cspan\u003econstant\u003c/span\u003e = \u003cspan\u003e50\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe can also animate view through constraints. The key is to make sure to call \u003ccode\u003elayoutIfNeeded()\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eUIView\u003c/span\u003e.\u003cspan\u003eanimate\u003c/span\u003e(\u003cspan\u003ewithDuration\u003c/span\u003e: \u003cspan\u003e1.0\u003c/span\u003e, \u003cspan\u003eanimations\u003c/span\u003e: {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eheightConstraint\u003c/span\u003e.\u003cspan\u003econstant\u003c/span\u003e = \u003cspan\u003e50\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003elayoutIfNeeded\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"resolving-constraint-conflicts\"\u003eResolving constraint conflicts\u003c/h2\u003e\n\u003cp\u003eNow that we have explore the basics how to add, edit and activate constraints, here comes the trouble: resolving conflicting constraints.\u003c/p\u003e\n\u003cp\u003eIn most cases, Xcode will indicate it in the Console that it cannot resolve constraints in the Console. When opening \u003cem\u003eDebug View Hierarchy\u003c/em\u003e, we can inspect each constraint and detect where the conflict comes from.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2022/03/constraints-debugger.png\" alt=\"constraint-debugger\"/\u003e\u003c/p\u003e\n\u003cp\u003eConflicts almost always due to priority issues. If I set a view height constraint to \u003ccode\u003e100\u003c/code\u003e then another constraint to \u003ccode\u003e50\u003c/code\u003e, the system cannot tell which one to enforce.\u003c/p\u003e\n\u003cp\u003eThis will create a conflict.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eheightAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalToConstant\u003c/span\u003e: \u003cspan\u003e100\u003c/span\u003e).\u003cspan\u003eisActive\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eheightAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalToConstant\u003c/span\u003e: \u003cspan\u003e50\u003c/span\u003e).\u003cspan\u003eisActive\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTo detect this kind of conflict, we can setup a Symbolic Breakpoint with \u003ccode\u003eUIViewAlertForUnsatisfiableConstraints\u003c/code\u003e to detect those wrongly setup.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2022/03/constraints-breakpoint.png\" alt=\"constraint-breakpoint\"/\u003e\u003c/p\u003e\n\u003cp\u003eOnce we identified which constraints are conflicting, then we can change the priority in favor of one and reduce the second, highest being 1000.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eheightConstraint1\u003c/span\u003e = \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eheightAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalToConstant\u003c/span\u003e: \u003cspan\u003e100\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eheightConstraint2\u003c/span\u003e = \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eheightAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalToConstant\u003c/span\u003e: \u003cspan\u003e50\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// height 100 applies\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eheightConstraint1\u003c/span\u003e.\u003cspan\u003epriority\u003c/span\u003e = \u003cspan\u003e1000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eheightConstraint2\u003c/span\u003e.\u003cspan\u003epriority\u003c/span\u003e = \u003cspan\u003e999\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// height 50 applies\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eheightConstraint1\u003c/span\u003e.\u003cspan\u003epriority\u003c/span\u003e = \u003cspan\u003e999\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eheightConstraint2\u003c/span\u003e.\u003cspan\u003epriority\u003c/span\u003e = \u003cspan\u003e1000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf you don’t want to manipulate the priority yourself and get confused with value, there are predefined values we can reuse.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eheightConstraint1\u003c/span\u003e.\u003cspan\u003epriority\u003c/span\u003e = .\u003cspan\u003erequired\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eheightConstraint2\u003c/span\u003e.\u003cspan\u003epriority\u003c/span\u003e = .\u003cspan\u003edefaultLow\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"auto-layout-and-constraint-resistance\"\u003eAuto Layout and Constraint Resistance\u003c/h2\u003e\n\u003cp\u003eFor some UIView, we cannot always enforce a specific dimension. For instance, if we have a UIButton with \u003ccode\u003eTap\u003c/code\u003e and hardcode the value, when we localize it to other regions, the text could be cut off.\u003c/p\u003e\n\u003cp\u003eTo handle this without requiring to change the priority, we can use different set of constraint functions to avoid those behaviors. Two of them are \u003cem\u003eContent Hugging\u003c/em\u003e and \u003cem\u003eContent Resistance\u003c/em\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHugging is to make sure the view shouldn’t grow further\u003c/li\u003e\n\u003cli\u003eResistance is to make sure the view shouldn’t shrink further\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBack to my UIButton \u003ccode\u003eTap\u003c/code\u003e, instead of setting up width constraint to avoid any cut off, I can enforce resistance to avoid any shrinking. A different localization text will extend it to always be fully displayed.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ebutton\u003c/span\u003e.\u003cspan\u003esetContentResistancePriority\u003c/span\u003e(.\u003cspan\u003erequired\u003c/span\u003e, \u003cspan\u003efor\u003c/span\u003e: .\u003cspan\u003ehorizontal\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIt can work the same for Content Hugging, horizontal or vertical, with a different set of priority\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003esetContentHuggingPriority\u003c/span\u003e(.\u003cspan\u003edefaultLow\u003c/span\u003e, \u003cspan\u003efor\u003c/span\u003e: .\u003cspan\u003evertical\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"safe-area-constraints\"\u003eSafe area constraints\u003c/h2\u003e\n\u003cp\u003eWith multiple devices to support, anchoring only might not be enough. For instance, what if you have a status bar or navigation bar, how do we factor the home button area for new iPhones?\u003c/p\u003e\n\u003cp\u003eThankfully, UIKit comes with a property \u003ca href=\"https://developer.apple.com/documentation/uikit/uiview/2891102-safearealayoutguide\"\u003esafeAreaLayoutGuide\u003c/a\u003e to adapt to its safe area so we can focus on the view and less on the device spacing area. It allows us to have same spacing for an iPhone8 or iPhone13 for instance.\u003c/p\u003e\n\u003cp\u003eIn this example, I safely set a \u003ccode\u003eUITextView\u003c/code\u003e to fit another view safe area.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eNSLayoutConstraint\u003c/span\u003e.\u003cspan\u003eactivate\u003c/span\u003e([\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003etextView\u003c/span\u003e.\u003cspan\u003etopAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalTo\u003c/span\u003e: \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003esafeAreaLayoutGuide\u003c/span\u003e.\u003cspan\u003etopAnchor\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003etextView\u003c/span\u003e.\u003cspan\u003eleftAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalTo\u003c/span\u003e: \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003esafeAreaLayoutGuide\u003c/span\u003e.\u003cspan\u003eleftAnchor\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003etextView\u003c/span\u003e.\u003cspan\u003erightAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalTo\u003c/span\u003e: \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003esafeAreaLayoutGuide\u003c/span\u003e.\u003cspan\u003erightAnchor\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003etextView\u003c/span\u003e.\u003cspan\u003ebottomAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalTo\u003c/span\u003e: \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003esafeAreaLayoutGuide\u003c/span\u003e.\u003cspan\u003ebottomAnchor\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eIn conclusion, Auto Layout is a \u003cem\u003every powerful api\u003c/em\u003e. It definitely made development easier to apply a design across multiple devices and resize to the right dimension.\u003c/p\u003e\n\u003cp\u003eWith safe area constraint and different priority, it gets easier and easier to adapt to new devices, from iPhone 13 mini to iPad Pro.\u003c/p\u003e\n\u003cp\u003eAs we can create a lot of them very quickly, it can be hard to keep track of all of them when a conflict occurs. Thankfully, Xcode came with different tools to monitor this.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eShould you set constraints programmatically?\u003c/em\u003e I would say it’s more about code flavor.\u003c/p\u003e\n\u003cp\u003eI often chose to set constraints programmatically to make it easier to maintain and debug as I have many teammates. That being said, you know best your project, you can try and see what make more sense to you and your team.\u003c/p\u003e\n\u003cp\u003eWhat about \u003cem\u003eyou\u003c/em\u003e? What do you use and prefer when it comes to Auto Layout?\u003c/p\u003e\n              \n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2022-03-14T01:00:00Z",
  "modifiedTime": "2022-03-14T01:00:00Z"
}
