{
  "id": "7d330eeb-f6ec-41f2-94c1-92dcef743831",
  "title": "A heterogeneous dictionary with strong types in Swift",
  "link": "https://oleb.net/2022/heterogeneous-dictionary/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2022-04-19T15:52:08Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann …",
  "length": 7491,
  "excerpt": "I wrote a dictionary type where each key defines the type of value it stores. The public API is fully type-safe.",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "The environment in SwiftUI is sort of like a global dictionary but with stronger types: each key (represented by a key path) can have its own specific value type. For example, the \\.isEnabled key stores a boolean value, whereas the \\.font key stores an Optional\u003cFont\u003e. I wrote a custom dictionary type that can do the same thing. The HeterogeneousDictionary struct I show in this article stores mixed key-value pairs where each key defines the type of value it stores. The public API is fully type-safe, no casting required. Usage I’ll start with an example of the finished API. Here’s a dictionary for storing text formatting attributes: import AppKit var dict = HeterogeneousDictionary\u003cTextAttributes\u003e() dict[ForegroundColor.self] // → nil // The value type of this key is NSColor dict[ForegroundColor.self] = NSColor.systemRed dict[ForegroundColor.self] // → NSColor.systemRed dict[FontSize.self] // → nil // The value type of this key is Double dict[FontSize.self] = 24 dict[FontSize.self] // → 24 (type: Optional\u003cDouble\u003e) We also need some boilerplate to define the set of keys and their associated value types. The code to do this for three keys (font, font size, foreground color) looks like this: // The domain (aka \"keyspace\") enum TextAttributes {} struct FontSize: HeterogeneousDictionaryKey { typealias Domain = TextAttributes typealias Value = Double } struct Font: HeterogeneousDictionaryKey { typealias Domain = TextAttributes typealias Value = NSFont } struct ForegroundColor: HeterogeneousDictionaryKey { typealias Domain = TextAttributes typealias Value = NSColor } Yes, this is fairly long, which is one of the downsides of this approach. At least you only have to write it once per “keyspace”. I’ll walk you through it step by step. Notes on the API Using types as keys As you can see in this line, the dictionary keys are types (more precisely, metatype values): This is another parallel with the SwiftUI environment, which also uses types as keys (the public environment API uses key paths as keys, but you’ll see the types underneath if you ever define your own environment key). Why use types as keys? We want to establish a relationship between a key and the type of values it stores, and we want to make this connection known to the type system. The way to do this is by defining a type that sets up this link. Domains aka “keyspaces” A standard Dictionary is generic over its key and value types. This doesn’t work for our heterogeneous dictionary because we have multiple value types (and we want more type safety than Any provides). Instead, a HeterogeneousDictionary is parameterized with a domain: // The domain (aka \"keyspace\") enum TextAttributes {} var dict = HeterogeneousDictionary\u003cTextAttributes\u003e() The domain is the “keyspace” that defines the set of legal keys for this dictionary. Only keys that belong to the domain can be put into the dictionary. The domain type has no protocol constraints; you can use any type for this. Defining keys A key is a type that conforms to the HeterogeneousDictionaryKey protocol. The protocol has two associated types that define the relationships between the key and its domain and value type: protocol HeterogeneousDictionaryKey { /// The \"namespace\" the key belongs to. associatedtype Domain /// The type of values that can be stored /// under this key in the dictionary. associatedtype Value } You define a key by creating a type and adding the conformance: struct Font: HeterogeneousDictionaryKey { typealias Domain = TextAttributes typealias Value = NSFont } Implementation notes A minimal implementation of the dictionary type is quite short: struct HeterogeneousDictionary\u003cDomain\u003e { private var storage: [ObjectIdentifier: Any] = [:] var count: Int { self.storage.count } subscript\u003cKey\u003e(key: Key.Type) -\u003e Key.Value? where Key: HeterogeneousDictionaryKey, Key.Domain == Domain { get { self.storage[ObjectIdentifier(key)] as! Key.Value? } set { self.storage[ObjectIdentifier(key)] = newValue } } } Internal storage private var storage: [ObjectIdentifier: Any] = [:] Internally, HeterogeneousDictionary uses a dictionary of type [ObjectIdentifier: Any] for storage. We can’t use a metatype such as Font.self directly as a dictionary key because metatypes aren’t hashable. But we can use the metatype’s ObjectIdentifier, which is essentially the address of the type’s representation in memory. Subscript subscript\u003cKey\u003e(key: Key.Type) -\u003e Key.Value? where Key: HeterogeneousDictionaryKey, Key.Domain == Domain { get { self.storage[ObjectIdentifier(key)] as! Key.Value? } set { self.storage[ObjectIdentifier(key)] = newValue } } The subscript implementation constrains its arguments to keys in the same domain as the dictionary’s domain. This ensures that you can’t subscript a dictionary for text attributes with some other unrelated key. If you find this too restrictive, you could also remove all references to the Domain type from the code; it would still work. Using key paths as keys Types as keys don’t have the best syntax. I think you’ll agree that dict[FontSize.self] doesn’t read as nice as dict[\\.fontSize], so I looked into providing a convenience API based on key paths. My preferred solution would be if users could define static helper properties on the domain type, which the dictionary subscript would then accept as key paths, like so: extension TextAttributes { static var fontSize: FontSize.Type { FontSize.self } // Same for font and foregroundColor } Sadly, this doesn’t work because Swift 5.6 doesn’t (yet?) support key paths to static properties (relevant forum thread). We have to introduce a separate helper type that acts as a namespace for these helper properties. Since the dictionary type can create an instance of the helper type, it can access the non-static helper properties. This doesn’t feel as clean to me, but it works. I called the helper type HeterogeneousDictionaryValues as a parallel with EnvironmentValues, which serves the same purpose in SwiftUI. The code for this is included in the Gist. Drawbacks Is the HeterogeneousDictionary type useful? I’m not sure. I wrote this mostly as an exercise and haven’t used it yet in a real project. In most cases, if you need a heterogeneous record with full type safety, it’s probably easier to just write a new struct where each property is optional — the boilerplate for defining the dictionary keys is certainly longer and harder to read. For representing partial values, i.e. struct-like records where some but not all properties have values, take a look at these two approaches from 2018: Ian Keen, Type-safe temporary models (2018-06-05) Joseph Duffy, Partial in Swift (2018-07-10), also available as a library These use a similar storage approach (a dictionary of Any values with custom accessors to make it type-safe), but they use an existing struct as the domain/keyspace, combined with partial key paths into that struct as the keys. I honestly think that this is the better design for most situations. Aside from the boilerplate, here are a few more weaknesses of HeterogeneousDictionary: Storage is inefficient because values are boxed in Any containers Accessing values is inefficient: every access requires unboxing HeterogeneousDictionary can’t easily conform to Sequence and Collection because these protocols require a uniform element type The code The full code is available in a Gist.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003eThe \u003ca href=\"https://developer.apple.com/documentation/swiftui/environment\"\u003eenvironment in SwiftUI\u003c/a\u003e is sort of like a global dictionary but with stronger types: each key (represented by a key path) can have its own specific value type. For example, the \u003ca href=\"https://developer.apple.com/documentation/swiftui/environmentvalues/isenabled\"\u003e\u003ccode\u003e\\.isEnabled\u003c/code\u003e\u003c/a\u003e key stores a boolean value, whereas the \u003ca href=\"https://developer.apple.com/documentation/swiftui/environmentvalues/font\"\u003e\u003ccode\u003e\\.font\u003c/code\u003e\u003c/a\u003e key stores an \u003ccode\u003eOptional\u0026lt;Font\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eI wrote a custom dictionary type that can do the same thing. The \u003ccode\u003eHeterogeneousDictionary\u003c/code\u003e struct I show in this article stores mixed key-value pairs where each key defines the type of value it stores. The public API is fully type-safe, no casting required.\u003c/p\u003e\n\n\u003ch2 id=\"usage\"\u003eUsage\u003c/h2\u003e\n\n\u003cp\u003eI’ll start with an example of the finished API. Here’s a dictionary for storing text formatting attributes:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eAppKit\u003c/span\u003e\n\n\u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edict\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eHeterogeneousDictionary\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eTextAttributes\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\n\u003cspan\u003edict\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eForegroundColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e// → nil\u003c/span\u003e\n\u003cspan\u003e// The value type of this key is NSColor\u003c/span\u003e\n\u003cspan\u003edict\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eForegroundColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNSColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esystemRed\u003c/span\u003e\n\u003cspan\u003edict\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eForegroundColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e// → NSColor.systemRed\u003c/span\u003e\n\n\u003cspan\u003edict\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eFontSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e// → nil\u003c/span\u003e\n\u003cspan\u003e// The value type of this key is Double\u003c/span\u003e\n\u003cspan\u003edict\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eFontSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e24\u003c/span\u003e\n\u003cspan\u003edict\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eFontSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e// → 24 (type: Optional\u0026lt;Double\u0026gt;)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWe also need some boilerplate to define the set of keys and their associated value types. The code to do this for three keys (font, font size, foreground color) looks like this:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// The domain (aka \u0026#34;keyspace\u0026#34;)\u003c/span\u003e\n\u003cspan\u003eenum\u003c/span\u003e \u003cspan\u003eTextAttributes\u003c/span\u003e \u003cspan\u003e{}\u003c/span\u003e\n\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eFontSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eHeterogeneousDictionaryKey\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003etypealias\u003c/span\u003e \u003cspan\u003eDomain\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eTextAttributes\u003c/span\u003e\n  \u003cspan\u003etypealias\u003c/span\u003e \u003cspan\u003eValue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eFont\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eHeterogeneousDictionaryKey\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003etypealias\u003c/span\u003e \u003cspan\u003eDomain\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eTextAttributes\u003c/span\u003e\n  \u003cspan\u003etypealias\u003c/span\u003e \u003cspan\u003eValue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNSFont\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eForegroundColor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eHeterogeneousDictionaryKey\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003etypealias\u003c/span\u003e \u003cspan\u003eDomain\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eTextAttributes\u003c/span\u003e\n  \u003cspan\u003etypealias\u003c/span\u003e \u003cspan\u003eValue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNSColor\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eYes, this is fairly long, which is one of the downsides of this approach. At least you only have to write it once per “keyspace”. I’ll walk you through it step by step.\u003c/p\u003e\n\n\u003ch2 id=\"notes-on-the-api\"\u003eNotes on the API\u003c/h2\u003e\n\n\u003ch2 id=\"using-types-as-keys\"\u003eUsing types as keys\u003c/h2\u003e\n\n\u003cp\u003eAs you can see in this line, the dictionary keys are types (more precisely, \u003ca href=\"https://docs.swift.org/swift-book/ReferenceManual/Types.html#ID455\"\u003emetatype values\u003c/a\u003e):\u003c/p\u003e\n\n\n\u003cp\u003eThis is another parallel with the SwiftUI environment, which also uses types as keys (the public environment API uses key paths as keys, but you’ll see the types underneath if you ever define your own environment key).\u003c/p\u003e\n\n\u003cp\u003eWhy use types as keys? We want to establish a relationship between a key and the type of values it stores, and we want to make this connection known to the type system. The way to do this is by defining a type that sets up this link.\u003c/p\u003e\n\n\u003ch2 id=\"domains-aka-keyspaces\"\u003eDomains aka “keyspaces”\u003c/h2\u003e\n\n\u003cp\u003eA standard \u003ca href=\"https://developer.apple.com/documentation/swift/dictionary\"\u003e\u003ccode\u003eDictionary\u003c/code\u003e\u003c/a\u003e is generic over its key and value types. This doesn’t work for our heterogeneous dictionary because we have multiple value types (and we want more type safety than \u003ccode\u003eAny\u003c/code\u003e provides). Instead, a \u003ccode\u003eHeterogeneousDictionary\u003c/code\u003e is parameterized with a domain:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// The domain (aka \u0026#34;keyspace\u0026#34;)\u003c/span\u003e\n\u003cspan\u003eenum\u003c/span\u003e \u003cspan\u003eTextAttributes\u003c/span\u003e \u003cspan\u003e{}\u003c/span\u003e\n\n\u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edict\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eHeterogeneousDictionary\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eTextAttributes\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe domain is the “keyspace” that defines the set of legal keys for this dictionary. Only keys that belong to the domain can be put into the dictionary. The domain type has no protocol constraints; you can use any type for this.\u003c/p\u003e\n\n\u003ch2 id=\"defining-keys\"\u003eDefining keys\u003c/h2\u003e\n\n\u003cp\u003eA key is a type that conforms to the \u003ccode\u003eHeterogeneousDictionaryKey\u003c/code\u003e protocol. The protocol has two associated types that define the relationships between the key and its domain and value type:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprotocol\u003c/span\u003e \u003cspan\u003eHeterogeneousDictionaryKey\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e/// The \u0026#34;namespace\u0026#34; the key belongs to.\u003c/span\u003e\n  \u003cspan\u003eassociatedtype\u003c/span\u003e \u003cspan\u003eDomain\u003c/span\u003e\n  \u003cspan\u003e/// The type of values that can be stored\u003c/span\u003e\n  \u003cspan\u003e/// under this key in the dictionary.\u003c/span\u003e\n  \u003cspan\u003eassociatedtype\u003c/span\u003e \u003cspan\u003eValue\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eYou define a key by creating a type and adding the conformance:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eFont\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eHeterogeneousDictionaryKey\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003etypealias\u003c/span\u003e \u003cspan\u003eDomain\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eTextAttributes\u003c/span\u003e\n  \u003cspan\u003etypealias\u003c/span\u003e \u003cspan\u003eValue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNSFont\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"implementation-notes\"\u003eImplementation notes\u003c/h2\u003e\n\n\u003cp\u003eA minimal implementation of the dictionary type is quite short:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eHeterogeneousDictionary\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eDomain\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003estorage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eObjectIdentifier\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAny\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[:]\u003c/span\u003e\n\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estorage\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003esubscript\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eType\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eValue\u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e\n    \u003cspan\u003ewhere\u003c/span\u003e \u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eHeterogeneousDictionaryKey\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eDomain\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eDomain\u003c/span\u003e\n  \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eget\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estorage\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eObjectIdentifier\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e)]\u003c/span\u003e \u003cspan\u003eas!\u003c/span\u003e \u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eValue\u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003eset\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estorage\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eObjectIdentifier\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e)]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enewValue\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"internal-storage\"\u003eInternal storage\u003c/h2\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003estorage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eObjectIdentifier\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAny\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[:]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eInternally, \u003ccode\u003eHeterogeneousDictionary\u003c/code\u003e uses a dictionary of type \u003ccode\u003e[ObjectIdentifier: Any]\u003c/code\u003e for storage. We can’t use a metatype such as \u003ccode\u003eFont.self\u003c/code\u003e directly as a dictionary key because metatypes aren’t \u003ca href=\"https://developer.apple.com/documentation/swift/hashable\"\u003ehashable\u003c/a\u003e. But we can use the metatype’s \u003ca href=\"https://developer.apple.com/documentation/swift/objectidentifier\"\u003e\u003ccode\u003eObjectIdentifier\u003c/code\u003e\u003c/a\u003e, which is essentially the address of the type’s representation in memory.\u003c/p\u003e\n\n\u003ch2 id=\"subscript\"\u003eSubscript\u003c/h2\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003esubscript\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eType\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eValue\u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e\n  \u003cspan\u003ewhere\u003c/span\u003e \u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eHeterogeneousDictionaryKey\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eDomain\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eDomain\u003c/span\u003e\n\u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eget\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estorage\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eObjectIdentifier\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e)]\u003c/span\u003e \u003cspan\u003eas!\u003c/span\u003e \u003cspan\u003eKey\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eValue\u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003eset\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estorage\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eObjectIdentifier\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e)]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enewValue\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe subscript implementation constrains its arguments to keys in the same domain as the dictionary’s domain. This ensures that you can’t subscript a dictionary for text attributes with some other unrelated key. If you find this too restrictive, you could also remove all references to the \u003ccode\u003eDomain\u003c/code\u003e type from the code; it would still work.\u003c/p\u003e\n\n\u003ch2 id=\"using-key-paths-as-keys\"\u003eUsing key paths as keys\u003c/h2\u003e\n\n\u003cp\u003eTypes as keys don’t have the best syntax. I think you’ll agree that \u003ccode\u003edict[FontSize.self]\u003c/code\u003e doesn’t read as nice as \u003ccode\u003edict[\\.fontSize]\u003c/code\u003e, so I looked into providing a convenience API based on key paths.\u003c/p\u003e\n\n\u003cp\u003eMy preferred solution would be if users could define static helper properties on the domain type, which the dictionary subscript would then accept as key paths, like so:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eTextAttributes\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003efontSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eFontSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eType\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eFontSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e// Same for font and foregroundColor\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eSadly, this doesn’t work because Swift 5.6 doesn’t (yet?) support key paths to static properties (\u003ca href=\"https://forums.swift.org/t/key-path-cannot-refer-to-static-member/28055\"\u003erelevant forum thread\u003c/a\u003e).\u003c/p\u003e\n\n\u003cp\u003eWe have to introduce a separate helper type that acts as a namespace for these helper properties. Since the dictionary type can create an instance of the helper type, it can access the non-static helper properties. This doesn’t feel as clean to me, but it works. I called the helper type \u003ccode\u003eHeterogeneousDictionaryValues\u003c/code\u003e as a parallel with \u003ca href=\"https://developer.apple.com/documentation/swiftui/environmentvalues\"\u003e\u003ccode\u003eEnvironmentValues\u003c/code\u003e\u003c/a\u003e, which serves the same purpose in SwiftUI.\u003c/p\u003e\n\n\u003cp\u003eThe code for this is included \u003ca href=\"https://gist.github.com/ole/0473d8e063762ebfb1a403d069fdddaf\"\u003ein the Gist\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"drawbacks\"\u003eDrawbacks\u003c/h2\u003e\n\n\u003cp\u003eIs the \u003ccode\u003eHeterogeneousDictionary\u003c/code\u003e type useful? I’m not sure. I wrote this mostly as an exercise and haven’t used it yet in a real project. In most cases, if you need a heterogeneous record with full type safety, it’s probably easier to just write a new struct where each property is optional — the boilerplate for defining the dictionary keys is certainly longer and harder to read.\u003c/p\u003e\n\n\u003cp\u003eFor representing \u003cem\u003epartial values\u003c/em\u003e, i.e. struct-like records where some but not all properties have values, take a look at these two approaches from 2018:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://iankeen.tech/2018/06/05/type-safe-temporary-models/\"\u003eIan Keen, Type-safe temporary models (2018-06-05)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://josephduffy.co.uk/posts/partial-in-swift\"\u003eJoseph Duffy, Partial in Swift (2018-07-10)\u003c/a\u003e, also available \u003ca href=\"https://github.com/JosephDuffy/Partial\"\u003eas a library\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThese use a similar storage approach (a dictionary of \u003ccode\u003eAny\u003c/code\u003e values with custom accessors to make it type-safe), but they use an existing struct as the domain/keyspace, combined with \u003ca href=\"https://developer.apple.com/documentation/swift/partialkeypath\"\u003epartial key paths\u003c/a\u003e into that struct as the keys. I honestly think that this is the better design for most situations.\u003c/p\u003e\n\n\u003cp\u003eAside from the boilerplate, here are a few more weaknesses of \u003ccode\u003eHeterogeneousDictionary\u003c/code\u003e:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eStorage is inefficient because values are boxed in \u003ccode\u003eAny\u003c/code\u003e containers\u003c/li\u003e\n  \u003cli\u003eAccessing values is inefficient: every access requires unboxing\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eHeterogeneousDictionary\u003c/code\u003e can’t easily conform to \u003ccode\u003eSequence\u003c/code\u003e and \u003ccode\u003eCollection\u003c/code\u003e because these protocols require a uniform element type\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"the-code\"\u003eThe code\u003c/h2\u003e\n\n\u003cp\u003eThe full code is available \u003ca href=\"https://gist.github.com/ole/0473d8e063762ebfb1a403d069fdddaf\"\u003ein a Gist\u003c/a\u003e.\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2022-04-19T15:52:08Z",
  "modifiedTime": "2022-04-20T17:54:06Z"
}
