{
  "id": "ec5435bf-48f5-4662-8da2-1a3e45b0b4da",
  "title": "Context-Bound Types",
  "link": "https://fabisevi.ch/2020/09/21/Context-Bound-Types/",
  "description": "I've been thinking about privacy lately. No, not online privacy, but about how APIs can balance exposing the right amount of implementation details without revealing too much. I'll walk through a task I find myself doing often when building iOS apps, creating a view controller with header view, and four different ways to go about it.",
  "author": "Joe Fabisevich",
  "published": "Mon, 21 Sep 2020 00:00:00 GMT",
  "source": "https://www.fabisevi.ch/feed.xml",
  "categories": null,
  "byline": "",
  "length": 6926,
  "excerpt": "I've been thinking about privacy lately. No, not online privacy, but about how APIs can balance exposing the right amount of implementation details without revealing too much. I'll walk through a task I find myself doing often when building iOS apps, creating a view controller with header view, and four different ways to go about it.",
  "siteName": "",
  "favicon": "https://fabisevi.ch/icons/icon-512x512.png?v=b60b950dc439294a707fb76cdaca4274",
  "text": "I've been thinking about privacy lately. No, not online privacy, but about how APIs can balance exposing the right amount of implementation details without revealing too much. I'll walk through a task I find myself doing often when building iOS apps, creating a view controller with header view, and four different ways to go about it. SettingsViewController.swift final class SettingsViewController: UIViewController { private let headerView = UIView() private let tableView = UITableView() override func viewDidLoad() { super.viewDidLoad() self.view.addSubview(self.tableView) self.setupTableView() self.configureHeaderView() } func setupTableView() { self.tableView.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ self.tableView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor), self.tableView.trailingAnchor.constraint(equalTo: self.view.trailingAnchor), self.tableView.topAnchor.constraint(equalTo: self.view.topAnchor), self.tableView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor), ]) } func configureHeaderView() { // Some code configuring self.headerView // ... // ... self.tableView.tableHeaderView = self.headerView } } For folks new to iOS development, this is a common approach I see when adding a header. It makes sense, you want to have a header, and a header is a view, so why not configure and style UIView to be the UITableView header. While this is a good first try, it lacks the encapsulation that makes your code easy to edit and reason about. SettingsViewController.swift final class SettingsViewController: UIViewController { private let headerView = SettingsTableHeaderView() private let tableView = UITableView() override func viewDidLoad() { super.viewDidLoad() self.view.addSubview(self.tableView) self.setupTableView() self.tableView.tableHeaderView = self.headerView } } SettingsTableHeaderView.swift final class SettingsTableHeaderView: UIView { // Some code creating and configuring SettingsTableHeaderView // ... // ... } A naive approach to improve our readability would have been to move our configuration code into a function, but an even nicer improvement is to move it into its own class. This looks a lot better, it's easier to reason about and it's well-encapsulated. But a new problem this introduces is adding SettingsTableHeaderView into our moduleâ€™s namespace. Now I'll admit this isn't the world's biggest problem, but as you start adding different view controllers with different headers, suddenly finding the right header view for a given view controller becomes difficult. SettingsViewController.swift final class SettingsViewController: UIViewController { private let headerView = HeaderView() private let tableView = UITableView() override func viewDidLoad() { super.viewDidLoad() self.view.addSubview(self.tableView) self.setupTableView() self.tableView.tableHeaderView = self.headerView } private final class HeaderView: UIView { // Some code creating and configuring SettingsViewController.HeaderView // ... // ... } } Now this is a solution that I'm really liking. We've moved SettingsTableHeaderView out of our moduleâ€™s namespace and into one dependent on the context it's in, SettingsViewController. When referring to SettingsViewController.HeaderView inside of this class we can plainly refer to it as HeaderView, which is not only less verbose, but emphasizes the pairing between HeaderView and SettingsViewController. There is a downside to this approach though, the more views we add to SettingsViewController, the harder this file becomes to parse. Now again this may not seem like a big problem, but if you have a well encapsulated view, you may have many subviews that belong to either SettingsViewController or HeaderView, and your file can get pretty large. (Trust me, Iâ€™ve seen written some pretty large files.) Two Files with Namespaced Internal Classes SettingsViewController.swift final class SettingsViewController: UIViewController { private let headerView = HeaderView() private let tableView = UITableView() override func viewDidLoad() { super.viewDidLoad() self.view.addSubview(self.tableView) self.setupTableView() self.tableView.tableHeaderView = self.headerView } } SettingsViewController.HeaderView.swift extension SettingsViewController { final class HeaderView: UIView { // Some code creating and configuring SettingsViewController.HeaderView // ... // ... } } This is the approach I've settled on today. You'll notice that HeaderView is no longer private, but it's also not particularly easy to access publicly. You still end up with the benefits from namespacing the API, and this extension can go into its own file, unlike the earlier approach. If you were to accidentally misuse this API, it would be pretty clear. When calling HeaderView inside of SettingsViewController the call-site is clean and simple. But if someone were to attempt to use it from another class, they would have to reference the fully-qualified type, SettingsViewController.HeaderView. While Iâ€™ve walked through one example with four approaches, binding a type to its context is something you can do throughout a codebase. In an ideal world Swift would have a submodule keyword to make types less ambiguous, but in the mean time this is a reasonable substitute that developers can take advantage of. While we donâ€™t have a submodule keyword, we have a close approximation by using empty enums. One notable example is Combineâ€™s usage of Publishers and Subscribers to help people have context and understanding for their subtypes. As always, Iâ€™d love to know what you think or if youâ€™ve come up with better solutions, so please donâ€™t be shy about reaching out. Special shoutout to Jasdev for taking a very rough first draft and helping me turn it into something coherent.Joe Fabisevich is an indie developer creating software at Red Panda Club Inc. while writing about design, development, and building a company. Formerly an iOS developer working on societal issues @Twitter. These days I don't tweet, but I do post on Threads.Like my writing? You can keep up with it in your favorite RSS reader, or get posts emailed in newsletter form. I promise to never spam you or send you anything other than my posts, it's just a way for you to read my writing wherever's most comfortable for you.If you'd like to know more, wanna talk, or need some advice, feel free to sign up for office hours, I'm very friendly. ðŸ™‚",
  "image": "https://fabisevi.ch/static/pic-f5999ef8dd476bfbf9d65ddbace7e387.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cp\u003eI\u0026#39;ve been thinking about privacy lately. No, not \u003ca href=\"https://www.fabisevi.ch/2018/01/16/the-future-will-be-signed/\"\u003eonline\u003c/a\u003e \u003ca href=\"https://www.fabisevi.ch/2019/01/01/pushing-the-boundaries-of-technology/\"\u003eprivacy\u003c/a\u003e, but about how APIs can balance exposing the right amount of implementation details without revealing too much.\u003c/p\u003e\n\u003cp\u003eI\u0026#39;ll walk through a task I find myself doing often when building iOS apps, creating a view controller with header view, and four different ways to go about it.\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e\u003cem\u003eSettingsViewController.swift\u003c/em\u003e\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003efinal class SettingsViewController: UIViewController {\n    \n    private let headerView = UIView()\n    \n    private let tableView = UITableView()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n    \n        self.view.addSubview(self.tableView)\n        self.setupTableView()\n        self.configureHeaderView()\n    }\n    \n    func setupTableView() {\n        self.tableView.translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            self.tableView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor),\n            self.tableView.trailingAnchor.constraint(equalTo: self.view.trailingAnchor),\n            self.tableView.topAnchor.constraint(equalTo: self.view.topAnchor),\n            self.tableView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor),\n        ])\n    }\n    \n    func configureHeaderView() {\n        // Some code configuring self.headerView\n        // ...\n        // ...\n        self.tableView.tableHeaderView = self.headerView\n    }\n\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eFor folks new to iOS development, this is a common approach I see when adding a header. It makes sense, you want to have a header, and a header is a view, so why not configure and style \u003ccode\u003eUIView\u003c/code\u003e to be the \u003ccode\u003eUITableView\u003c/code\u003e header. While this is a good first try, it lacks the encapsulation that makes your code easy to edit and reason about.\u003c/p\u003e\n\u003chr/\u003e\n\n\u003cp\u003e\u003cem\u003eSettingsViewController.swift\u003c/em\u003e\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003efinal class SettingsViewController: UIViewController {\n    \n    private let headerView = SettingsTableHeaderView()\n    \n    private let tableView = UITableView()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n    \n        self.view.addSubview(self.tableView)\n        self.setupTableView()\n    \n        self.tableView.tableHeaderView = self.headerView\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003cem\u003eSettingsTableHeaderView.swift\u003c/em\u003e\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003efinal class SettingsTableHeaderView: UIView {\n    // Some code creating and configuring SettingsTableHeaderView\n    // ...\n    // ...\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eA naive approach to improve our readability would have been to move our configuration code into a function, but an even nicer improvement is to move it into its own class. This looks a lot better, it\u0026#39;s easier to reason about and it\u0026#39;s well-encapsulated. But a new problem this introduces is adding \u003ccode\u003eSettingsTableHeaderView\u003c/code\u003e into our moduleâ€™s namespace. Now I\u0026#39;ll admit this isn\u0026#39;t the world\u0026#39;s biggest problem, but as you start adding different view controllers with different headers, suddenly finding the right header view for a given view controller becomes difficult.\u003c/p\u003e\n\u003chr/\u003e\n\n\u003cp\u003e\u003cem\u003eSettingsViewController.swift\u003c/em\u003e\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003efinal class SettingsViewController: UIViewController {\n    \n    private let headerView = HeaderView()\n    \n    private let tableView = UITableView()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n    \n        self.view.addSubview(self.tableView)\n        self.setupTableView()\n    \n        self.tableView.tableHeaderView = self.headerView\n    }\n    \n    private final class HeaderView: UIView {\n      // Some code creating and configuring SettingsViewController.HeaderView\n      // ...\n      // ...\n    }\n    \n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNow this is a solution that I\u0026#39;m really liking. We\u0026#39;ve moved \u003ccode\u003eSettingsTableHeaderView\u003c/code\u003e out of our moduleâ€™s namespace and into one dependent on the context it\u0026#39;s in, \u003ccode\u003eSettingsViewController\u003c/code\u003e. When referring to \u003ccode\u003eSettingsViewController.HeaderView\u003c/code\u003e inside of this class we can plainly refer to it as \u003ccode\u003eHeaderView\u003c/code\u003e, which is not only less verbose, but emphasizes the pairing between \u003ccode\u003eHeaderView\u003c/code\u003e and \u003ccode\u003eSettingsViewController\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThere is a downside to this approach though, the more views we add to \u003ccode\u003eSettingsViewController\u003c/code\u003e, the harder this file becomes to parse. Now again this may not seem like a big problem, but if you have a well encapsulated view, you may have many subviews that belong to either \u003ccode\u003eSettingsViewController\u003c/code\u003e or \u003ccode\u003eHeaderView\u003c/code\u003e, and your file can get pretty large. (Trust me, Iâ€™ve \u003cdel\u003eseen\u003c/del\u003e written some pretty large files.)\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"two-files-with-namespaced-internal-classes\"\u003e\u003ca href=\"#two-files-with-namespaced-internal-classes\" aria-label=\"two files with namespaced internal classes permalink\"\u003e\u003c/a\u003eTwo Files with Namespaced Internal Classes\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eSettingsViewController.swift\u003c/em\u003e\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003efinal class SettingsViewController: UIViewController {\n    \n    private let headerView = HeaderView()\n    \n    private let tableView = UITableView()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n    \n        self.view.addSubview(self.tableView)\n        self.setupTableView()\n    \n        self.tableView.tableHeaderView = self.headerView\n    }\n\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003cem\u003eSettingsViewController.HeaderView.swift\u003c/em\u003e\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003eextension SettingsViewController {\n    \n    final class HeaderView: UIView {\n      // Some code creating and configuring SettingsViewController.HeaderView\n      // ...\n      // ... \n    }\n    \n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis is the approach I\u0026#39;ve settled on today. You\u0026#39;ll notice that \u003ccode\u003eHeaderView\u003c/code\u003e is no longer private, but it\u0026#39;s also not particularly easy to access publicly. You still end up with the benefits from namespacing the API, and this extension can go into its own file, unlike the earlier approach.\u003c/p\u003e\n\u003cp\u003eIf you were to accidentally misuse this API, it would be pretty clear. When calling \u003ccode\u003eHeaderView\u003c/code\u003e inside of \u003ccode\u003eSettingsViewController\u003c/code\u003e the call-site is clean and simple. But if someone were to attempt to use it from another class, they would have to reference the fully-qualified type, \u003ccode\u003eSettingsViewController.HeaderView\u003c/code\u003e.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eWhile Iâ€™ve walked through one example with four approaches, binding a type to its context is something you can do throughout a codebase. In an ideal world Swift would have a \u003ccode\u003esubmodule\u003c/code\u003e keyword to make types less ambiguous, but in the mean time this is a reasonable substitute that developers can take advantage of. While we donâ€™t have a \u003ccode\u003esubmodule\u003c/code\u003e keyword, we have a close approximation by using empty enums. One notable example is Combineâ€™s usage of \u003ca href=\"https://developer.apple.com/documentation/combine/publishers\"\u003ePublishers\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/documentation/combine/subscribers/\"\u003eSubscribers\u003c/a\u003e to help people have context and understanding for their subtypes.\u003c/p\u003e\n\u003cp\u003eAs always, Iâ€™d love to know what you think or if youâ€™ve come up with better solutions, so please donâ€™t be shy about \u003ca href=\"https://twitter.com/mergesort\"\u003ereaching out\u003c/a\u003e.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eSpecial shoutout to \u003ca href=\"https://twitter.com/jasdev\"\u003eJasdev\u003c/a\u003e for taking a \u003cem\u003every rough\u003c/em\u003e first draft and helping me turn it into something coherent.\u003c/p\u003e\u003c/div\u003e\u003cp\u003eJoe Fabisevich is an indie developer creating software at \u003ca href=\"https://redpanda.club\"\u003eRed Panda Club Inc.\u003c/a\u003e while writing about design, development, and building a company. Formerly an iOS developer working on societal issues \u003ca href=\"https://threads.net/mergesort\"\u003e@Twitter\u003c/a\u003e. These days I don\u0026#39;t tweet, but I do post on \u003ca href=\"https://threads.net/mergesort\"\u003eThreads\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eLike my writing? You can keep up with it in your favorite \u003ca href=\"https://fabisevi.ch/feed.xml\"\u003eRSS\u003c/a\u003e reader, or get posts \u003ca href=\"https://mailchi.mp/3237be1819ae/fabisevich-blog-posts\"\u003eemailed\u003c/a\u003e in newsletter form. I promise to never spam you or send you anything other than my posts, it\u0026#39;s just a way for you to read my writing wherever\u0026#39;s most comfortable for you.\u003c/p\u003e\u003cp\u003eIf you\u0026#39;d like to know more, wanna talk, or need some advice, feel free to sign up for \u003ca href=\"https://cal.com/mergesort/office-hours\"\u003eoffice hours\u003c/a\u003e, I\u0026#39;m very friendly. ðŸ™‚\u003c/p\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
