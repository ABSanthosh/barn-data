{
  "id": "976a52c6-2887-460e-afa1-54bae6744ace",
  "title": "Using the ‘some’ and ‘any’ keywords to reference generic protocols in Swift 5.7",
  "link": "https://www.swiftbysundell.com/articles/referencing-generic-protocols-with-some-and-any-keywords",
  "description": "How Swift 5.7 makes generic protocols more powerful and easier to work with, thanks to the ‘some’ and ‘any’ keywords.",
  "author": "",
  "published": "Thu, 9 Jun 2022 00:20:00 +0200",
  "source": "https://swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 10261,
  "excerpt": "How Swift 5.7 makes generic protocols more powerful and easier to work with, thanks to the ‘some’ and ‘any’ keywords.",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "Combining Swift’s flexible generics system with protocol-oriented programming can often lead to some really powerful implementations, all while minimizing code duplication and enabling us to establish clearly defined levels of abstraction across our code bases. However, when writing that sort of code before Swift 5.7, it’s been very common to run into the following compiler error:Protocol 'X' can only be used as a generic constraint because it has Self or associated type requirements.Let’s take a look at how Swift 5.7 (which is currently in beta as part of Xcode 14) introduces a few key new features that aim to make the above kind error a thing of the past.Opaque parameter typesLike we took a closer look at in the Q\u0026A article “Why can’t certain protocols, like Equatable and Hashable, be referenced directly?”, the reason why it’s so common to encounter the above compiler error when working with generic protocols is that as soon as a protocol defines an associated type, the compiler starts placing limitations on how that protocol can be referenced.For example, let’s say that we’re working on an app that deals with various kinds of groups, and to be able to reuse as much of our group handling code as possible, we’ve chosen to define our core Group type as a generic protocol that lets each implementing type define what kind of Item values that it contains:protocol Group { associatedtype Item var items: [Item] { get } var users: [User] { get } }Now, because of that associated Item type, we can’t reference our Group protocol directly — even within code that has nothing to do with a group’s items, such as this function that computes what names to display from a given group’s list of users:// Error: Protocol 'Group' can only be used as a generic constraint // because it has Self or associated type requirements. func namesOfUsers(addedTo group: Group) -\u003e [String] { group.users.compactMap { user in isUserAnonymous(user) ? nil : user.name } }One way to solve the above problem when using Swift versions lower than 5.7 would be to make our namesOfUsers function generic, and to then do what the above error message tells us, and only use our Group protocol as a generic type constraint — like this:func namesOfUsers\u003cT: Group\u003e(addedTo group: T) -\u003e [String] { group.users.compactMap { user in isUserAnonymous(user) ? nil : user.name } }There’s of course nothing wrong with that technique, but it does make our function declaration quite a bit more complicated compared to when working with non-generic protocols, or any other form of Swift type (including concrete generic types).Thankfully, this is a problem that Swift 5.7 neatly solves by expanding the some keyword (that was introduced back in Swift 5.1) to also be applicable to function arguments. So, just like how we can declare that a SwiftUI view returns some View from its body property, we can now make our namesOfUsers function accept some Group as its input:func namesOfUsers(addedTo group: some Group) -\u003e [String] { group.users.compactMap { user in isUserAnonymous(user) ? nil : user.name } }Just like when using the some keyword to define opaque return types (like we do when building SwiftUI views), the compiler will automatically infer what actual concrete type that’s passed to our function at each call site, without requiring us to write any extra code. Neat!Primary associated typesSometimes, though, we might want to add a few more requirements to a given parameter, rather than just requiring it to conform to a certain protocol. For example, let’s say that we’re now working on an app that lets our users bookmark their favorite articles, and that we’ve created a BookmarksController with a method that lets us pass an array of articles to bookmark:class BookmarksController { ... func bookmarkArticles(_ articles: [Article]) { ... } }However, not all of our call sites might store their articles using an array. The following ArticleSelectionController, for instance, uses a ‌dictionary to keep track of what articles that have been selected for what IndexPath within a UITableView or UICollectionView. So, when passing that collection of articles to our bookmarkArticles method, we first need to manually convert it into an array — like this:class ArticleSelectionController { var selection = [IndexPath: Article]() private let bookmarksController: BookmarksController ... func bookmarkSelection() { bookmarksController.bookmarkArticles(Array(selection.values)) ... } }But if we instead wanted to update that bookmarkArticles method to work well for any kind of Collection that contains Article values, then we couldn’t simply change its parameter type to some Collection, since that wouldn’t be enough to specify that we’re looking for a collection that has a specific Element type as input.We could, however, once again use a set of generic type constraints to solve that problem:class BookmarksController { ... func bookmarkArticles\u003cT: Collection\u003e( _ articles: T ) where T.Element == Article { ... } }Again, nothing wrong with that — but Swift 5.7 once again introduces a much more lightweight way to express the above kind of declaration, which works the exact same way as when specializing a concrete generic type (such as Array\u003cArticle\u003e). That is, we now can simply tell the compiler what Element type that we’d like our input Collection to contain by adding that type within angle brackets right after the protocol name:class BookmarksController { ... func bookmarkArticles(_ articles: some Collection\u003cArticle\u003e) { ... } }Very cool! We can even nest those kinds of declarations — so if we wanted to make our BookmarksController capable of bookmarking any kind of value that conforms to a generic ContentItem protocol, then we could specify some ContentItem as our collection’s expected Element type, rather than using the concrete Article type:protocol ContentItem: Identifiable where ID == UUID { var title: String { get } var imageURL: URL { get } } class BookmarksController { ... func bookmark(_ items: some Collection\u003csome ContentItem\u003e) { ... } }The above works thanks to a new Swift feature called primary associated types, and the fact that Swift’s Collection protocol declares Element as such an associated type, like this:protocol Collection\u003cElement\u003e: Sequence { associatedtype Element ... }Of course, being a proper Swift feature, we can also use primary associated types within our own protocols as well, using the exact same kind of syntax.Existentials and the ‘any’ keywordFinally, let’s take things one step further by also turning our ArticleSelectionController into a generic type that can be used to select any ContentItem-conforming value, rather than just articles. As we’re now looking to mix multiple concrete types that all conform to the same protocol, the some keyword won’t do the trick — since, like we saw earlier, it works by having the compiler infer a single concrete type for each call site, not multiple ones.This is where the new any keyword (which was introduced in Swift 5.6) comes in, which enables us to refer to our ContentItem protocol as an existential. Now, doing that does have certain performance and memory implications, as it effectively works as an automatic form of type erasure, but in situations where we want to be able to dynamically store a heterogeneous collection of elements, it can be incredibly useful.For example, by simply using any ContentItem as our selection dictionary’s value type, we’ll now be able to store any value conforming to that protocol within that dictionary:class ContentSelectionController { var selection = [IndexPath: any ContentItem]() private let bookmarksController: BookmarksController ... func bookmarkSelection() { bookmarksController.bookmark(selection.values) ... } }However, making that change does introduce a new compiler error, since our BookmarksController is expecting to receive a collection that contains values that all have the exact same type — which isn’t the case within our new ContentSelectionController implementation.Thankfully, fixing that issue is as simple as replacing some ContentItem with any ContentItem within our bookmark method declaration:class BookmarksController { ... func bookmark(_ items: some Collection\u003cany ContentItem\u003e) { ... } }We’re even able to mix any and some references, and the compiler will automatically help us translate between the two. For example, if we wanted to introduce a second, single-element bookmark method overload, which our first one then simply calls, then we could do so like this (even though the first method’s items collection contains any ContentItem and the second method accepts some ContentItem):class BookmarksController { ... func bookmark(_ items: some Collection\u003cany ContentItem\u003e) { for item in items { bookmark(item) } } func bookmark(_ item: some ContentItem) { ... } }Again, it’s important to emphasize the using any does introduce type erasure under the hood, even if it’s all done automatically by the compiler — so using static types (which is still the case when using the some keyword) is definitely the preferred way to go whenever possible.ConclusionSwift 5.7 doesn’t just make Swift’s generics system more powerful, it arguably makes it much more accessible as well, as it reduces the need to use generic type constraints and other more advanced generic programming techniques just to be able to refer to certain protocols.Generics is definitely not the right tool for every single problem, but when it turns out to be, being able to use Swift’s generics system in a much more lightweight way is definitely a big win.I hope that you found this article useful. If you have any questions, comments, or feedback, then feel free to reach out via either Twitter or email. For more information about these new generics features, I recommend watching the excellent “What’s new in Swift” and “Embrace Swift generics” sessions from this year’s WWDC.Thanks for reading!",
  "image": "https://www.swiftbysundell.com/images/articles/referencing-generic-protocols-with-some-and-any-keywords.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eCombining Swift’s flexible generics system with protocol-oriented programming can often lead to some really powerful implementations, all while minimizing code duplication and enabling us to establish clearly defined levels of abstraction across our code bases. However, when writing that sort of code before Swift 5.7, it’s been very common to run into the following compiler error:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eProtocol \u0026#39;X\u0026#39; can only be used as a generic constraint because it\nhas Self or associated type requirements.\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet’s take a look at how Swift 5.7 (which is currently in beta as part of Xcode 14) introduces a few key new features that aim to make the above kind error a thing of the past.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"opaque-parameter-types\" href=\"#opaque-parameter-types\"\u003eOpaque parameter types\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLike we took a closer look at in the Q\u0026amp;A article \u003ca href=\"https://www.swiftbysundell.com/questions/referencing-generic-protocols\"\u003e“Why can’t certain protocols, like Equatable and Hashable, be referenced directly?”\u003c/a\u003e, the reason why it’s so common to encounter the above compiler error when working with generic protocols is that as soon as a protocol defines an \u003cem\u003eassociated type\u003c/em\u003e, the compiler starts placing limitations on how that protocol can be referenced.\u003c/p\u003e\u003cp\u003eFor example, let’s say that we’re working on an app that deals with various kinds of groups, and to be able to reuse as much of our group handling code as possible, we’ve chosen to define our core \u003ccode\u003eGroup\u003c/code\u003e type as a generic protocol that lets each implementing type define what kind of \u003ccode\u003eItem\u003c/code\u003e values that it contains:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprotocol\u003c/span\u003e Group {\n    \u003cspan\u003eassociatedtype\u003c/span\u003e Item\n\n    \u003cspan\u003evar\u003c/span\u003e items: [\u003cspan\u003eItem\u003c/span\u003e] { \u003cspan\u003eget\u003c/span\u003e }\n    \u003cspan\u003evar\u003c/span\u003e users: [\u003cspan\u003eUser\u003c/span\u003e] { \u003cspan\u003eget\u003c/span\u003e }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, because of that associated \u003ccode\u003eItem\u003c/code\u003e type, we can’t reference our \u003ccode\u003eGroup\u003c/code\u003e protocol directly — even within code that has nothing to do with a group’s \u003ccode\u003eitems\u003c/code\u003e, such as this function that computes what names to display from a given group’s list of users:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Error: Protocol \u0026#39;Group\u0026#39; can only be used as a generic constraint\n// because it has Self or associated type requirements.\u003c/span\u003e\n\u003cspan\u003efunc\u003c/span\u003e namesOfUsers(addedTo group: \u003cspan\u003e\u003cspan\u003eGroup\u003c/span\u003e\u003c/span\u003e) -\u0026gt; [\u003cspan\u003eString\u003c/span\u003e] {\n    group.\u003cspan\u003eusers\u003c/span\u003e.\u003cspan\u003ecompactMap\u003c/span\u003e { user \u003cspan\u003ein\u003c/span\u003e\n        \u003cspan\u003eisUserAnonymous\u003c/span\u003e(user) ? \u003cspan\u003enil\u003c/span\u003e : user.\u003cspan\u003ename\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOne way to solve the above problem when using Swift versions lower than 5.7 would be to make our \u003ccode\u003enamesOfUsers\u003c/code\u003e function generic, and to then do what the above error message tells us, and only use our \u003ccode\u003eGroup\u003c/code\u003e protocol as a \u003ca href=\"https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4\"\u003egeneric type constraint\u003c/a\u003e — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efunc\u003c/span\u003e namesOfUsers\u003cspan\u003e\u0026lt;T: \u003cspan\u003eGroup\u003c/span\u003e\u0026gt;\u003c/span\u003e(addedTo group: \u003cspan\u003e\u003cspan\u003eT\u003c/span\u003e\u003c/span\u003e) -\u0026gt; [\u003cspan\u003eString\u003c/span\u003e] {\n    group.\u003cspan\u003eusers\u003c/span\u003e.\u003cspan\u003ecompactMap\u003c/span\u003e { user \u003cspan\u003ein\u003c/span\u003e\n        \u003cspan\u003eisUserAnonymous\u003c/span\u003e(user) ? \u003cspan\u003enil\u003c/span\u003e : user.\u003cspan\u003ename\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere’s of course nothing wrong with that technique, but it does make our function declaration quite a bit more complicated compared to when working with non-generic protocols, or any other form of Swift type (including concrete generic types).\u003c/p\u003e\u003cp\u003eThankfully, this is a problem that Swift 5.7 neatly solves by expanding the \u003ccode\u003esome\u003c/code\u003e keyword (that was introduced back in Swift 5.1) to also be applicable to function arguments. So, just like how we can declare that a SwiftUI view returns \u003ccode\u003esome View\u003c/code\u003e from its \u003ccode\u003ebody\u003c/code\u003e property, we can now make our \u003ccode\u003enamesOfUsers\u003c/code\u003e function accept \u003ccode\u003esome Group\u003c/code\u003e as its input:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efunc\u003c/span\u003e namesOfUsers(addedTo group: \u003cspan\u003e\u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eGroup\u003c/span\u003e\u003c/span\u003e) -\u0026gt; [\u003cspan\u003eString\u003c/span\u003e] {\n    group.\u003cspan\u003eusers\u003c/span\u003e.\u003cspan\u003ecompactMap\u003c/span\u003e { user \u003cspan\u003ein\u003c/span\u003e\n        \u003cspan\u003eisUserAnonymous\u003c/span\u003e(user) ? \u003cspan\u003enil\u003c/span\u003e : user.\u003cspan\u003ename\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eJust like when using the \u003ccode\u003esome\u003c/code\u003e keyword to define \u003ca href=\"https://www.swiftbysundell.com/articles/opaque-return-types-in-swift\"\u003eopaque return types\u003c/a\u003e (like we do when building SwiftUI views), the compiler will automatically infer what actual concrete type that’s passed to our function at each call site, without requiring us to write any extra code. Neat!\u003c/p\u003e\u003ch2\u003e\u003ca id=\"primary-associated-types\" href=\"#primary-associated-types\"\u003ePrimary associated types\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSometimes, though, we might want to add a few more requirements to a given parameter, rather than just requiring it to conform to a certain protocol. For example, let’s say that we’re now working on an app that lets our users bookmark their favorite articles, and that we’ve created a \u003ccode\u003eBookmarksController\u003c/code\u003e with a method that lets us pass an array of articles to bookmark:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e BookmarksController {\n    ...\n\n    \u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e bookmarkArticles(\u003cspan\u003e_\u003c/span\u003e articles: [\u003cspan\u003eArticle\u003c/span\u003e])\u003c/span\u003e {\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, not all of our call sites might store their articles using an array. The following \u003ccode\u003eArticleSelectionController\u003c/code\u003e, for instance, uses a ‌dictionary to keep track of what articles that have been selected for what \u003ccode\u003eIndexPath\u003c/code\u003e within a \u003ccode\u003eUITableView\u003c/code\u003e or \u003ccode\u003eUICollectionView\u003c/code\u003e. So, when passing that collection of articles to our \u003ccode\u003ebookmarkArticles\u003c/code\u003e method, we first need to manually convert it into an array — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e ArticleSelectionController {\n    \u003cspan\u003evar\u003c/span\u003e selection = \u003cspan\u003e[\u003cspan\u003eIndexPath\u003c/span\u003e: \u003cspan\u003eArticle\u003c/span\u003e]()\u003c/span\u003e\n    \u003cspan\u003eprivate let\u003c/span\u003e bookmarksController: \u003cspan\u003eBookmarksController\u003c/span\u003e\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e bookmarkSelection() {\n        bookmarksController.\u003cspan\u003ebookmarkArticles\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003eArray\u003c/span\u003e(selection.\u003cspan\u003evalues\u003c/span\u003e)\u003c/span\u003e)\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut if we instead wanted to update that \u003ccode\u003ebookmarkArticles\u003c/code\u003e method to work well for \u003cem\u003eany\u003c/em\u003e kind of \u003ccode\u003eCollection\u003c/code\u003e that contains \u003ccode\u003eArticle\u003c/code\u003e values, then we couldn’t simply change its parameter type to \u003ccode\u003esome Collection\u003c/code\u003e, since that wouldn’t be enough to specify that we’re looking for a collection that has a specific \u003ccode\u003eElement\u003c/code\u003e type as input.\u003c/p\u003e\u003cp\u003eWe could, however, once again use a set of generic type constraints to solve that problem:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e BookmarksController {\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e bookmarkArticles\u003cspan\u003e\u0026lt;T: \u003cspan\u003eCollection\u003c/span\u003e\u0026gt;\u003c/span\u003e(\n        \u003cspan\u003e_\u003c/span\u003e articles: \u003cspan\u003eT\u003c/span\u003e\n    ) \u003cspan\u003e\u003cspan\u003ewhere\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e.\u003cspan\u003eElement\u003c/span\u003e == \u003cspan\u003eArticle\u003c/span\u003e\u003c/span\u003e {\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAgain, nothing wrong with that — but Swift 5.7 once again introduces a much more lightweight way to express the above kind of declaration, which works the exact same way as when specializing a \u003cem\u003econcrete\u003c/em\u003e generic type (such as \u003ccode\u003eArray\u0026lt;Article\u0026gt;\u003c/code\u003e). That is, we now can simply tell the compiler what \u003ccode\u003eElement\u003c/code\u003e type that we’d like our input \u003ccode\u003eCollection\u003c/code\u003e to contain by adding that type within angle brackets right after the protocol name:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e BookmarksController {\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e bookmarkArticles(\u003cspan\u003e_\u003c/span\u003e articles: \u003cspan\u003e\u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eCollection\u003c/span\u003e\u0026lt;\u003cspan\u003eArticle\u003c/span\u003e\u0026gt;\u003c/span\u003e) {\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eVery cool! We can even nest those kinds of declarations — so if we wanted to make our \u003ccode\u003eBookmarksController\u003c/code\u003e capable of bookmarking any kind of value that conforms to a generic \u003ccode\u003eContentItem\u003c/code\u003e protocol, then we could specify \u003ccode\u003esome ContentItem\u003c/code\u003e as our collection’s expected \u003ccode\u003eElement\u003c/code\u003e type, rather than using the concrete \u003ccode\u003eArticle\u003c/code\u003e type:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eprotocol\u003c/span\u003e ContentItem: \u003cspan\u003eIdentifiable\u003c/span\u003e \u003cspan\u003ewhere\u003c/span\u003e \u003cspan\u003eID\u003c/span\u003e == \u003cspan\u003eUUID\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e title: \u003cspan\u003eString\u003c/span\u003e { \u003cspan\u003eget\u003c/span\u003e }\n    \u003cspan\u003evar\u003c/span\u003e imageURL: \u003cspan\u003eURL\u003c/span\u003e { \u003cspan\u003eget\u003c/span\u003e }\n}\n\n\u003cspan\u003eclass\u003c/span\u003e BookmarksController {\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e bookmark(\u003cspan\u003e_\u003c/span\u003e items: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eCollection\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eContentItem\u003c/span\u003e\u0026gt;\u003c/span\u003e) {\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above works thanks to a new Swift feature called \u003cem\u003eprimary associated types\u003c/em\u003e, and the fact that Swift’s \u003ccode\u003eCollection\u003c/code\u003e protocol declares \u003ccode\u003eElement\u003c/code\u003e as such an associated type, like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprotocol\u003c/span\u003e Collection\u003cspan\u003e\u0026lt;Element\u0026gt;\u003c/span\u003e: \u003cspan\u003eSequence\u003c/span\u003e {\n    \u003cspan\u003eassociatedtype\u003c/span\u003e Element\n    ...\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOf course, being a proper Swift feature, we can also use primary associated types within our own protocols as well, using the exact same kind of syntax.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"existentials-and-the-any-keyword\" href=\"#existentials-and-the-any-keyword\"\u003eExistentials and the ‘any’ keyword\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFinally, let’s take things one step further by also turning our \u003ccode\u003eArticleSelectionController\u003c/code\u003e into a generic type that can be used to select any \u003ccode\u003eContentItem\u003c/code\u003e-conforming value, rather than just articles. As we’re now looking to mix multiple concrete types that all conform to the same protocol, the \u003ccode\u003esome\u003c/code\u003e keyword won’t do the trick — since, like we saw earlier, it works by having the compiler infer a single concrete type for each call site, not multiple ones.\u003c/p\u003e\u003cp\u003eThis is where the new \u003ccode\u003eany\u003c/code\u003e keyword (which was introduced in Swift 5.6) comes in, which enables us to refer to our \u003ccode\u003eContentItem\u003c/code\u003e protocol as an \u003cem\u003eexistential\u003c/em\u003e. Now, doing that does have certain performance and memory implications, as it effectively works as an automatic form of \u003ca href=\"https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift\"\u003etype erasure\u003c/a\u003e, but in situations where we want to be able to dynamically store a heterogeneous collection of elements, it can be incredibly useful.\u003c/p\u003e\u003cp\u003eFor example, by simply using \u003ccode\u003eany ContentItem\u003c/code\u003e as our \u003ccode\u003eselection\u003c/code\u003e dictionary’s value type, we’ll now be able to store any value conforming to that protocol within that dictionary:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e ContentSelectionController {\n    \u003cspan\u003evar\u003c/span\u003e selection = \u003cspan\u003e[\u003cspan\u003eIndexPath\u003c/span\u003e: \u003cspan\u003eany\u003c/span\u003e \u003cspan\u003eContentItem\u003c/span\u003e]()\u003c/span\u003e\n    \u003cspan\u003eprivate let\u003c/span\u003e bookmarksController: \u003cspan\u003eBookmarksController\u003c/span\u003e\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e bookmarkSelection() {\n        bookmarksController.\u003cspan\u003ebookmark\u003c/span\u003e(selection.\u003cspan\u003evalues\u003c/span\u003e)\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, making that change does introduce a new compiler error, since our \u003ccode\u003eBookmarksController\u003c/code\u003e is expecting to receive a collection that contains values that all have the exact same type — which isn’t the case within our new \u003ccode\u003eContentSelectionController\u003c/code\u003e implementation.\u003c/p\u003e\u003cp\u003eThankfully, fixing that issue is as simple as replacing \u003ccode\u003esome ContentItem\u003c/code\u003e with \u003ccode\u003eany ContentItem\u003c/code\u003e within our \u003ccode\u003ebookmark\u003c/code\u003e method declaration:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e BookmarksController {\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e bookmark(\u003cspan\u003e_\u003c/span\u003e items: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eCollection\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003cspan\u003eany\u003c/span\u003e \u003cspan\u003eContentItem\u003c/span\u003e\u0026gt;\u003c/span\u003e) {\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe’re even able to mix \u003ccode\u003eany\u003c/code\u003e and \u003ccode\u003esome\u003c/code\u003e references, and the compiler will automatically help us translate between the two. For example, if we wanted to introduce a second, single-element \u003ccode\u003ebookmark\u003c/code\u003e method overload, which our first one then simply calls, then we could do so like this (even though the first method’s \u003ccode\u003eitems\u003c/code\u003e collection contains \u003ccode\u003eany ContentItem\u003c/code\u003e and the second method accepts \u003ccode\u003esome ContentItem\u003c/code\u003e):\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e BookmarksController {\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e bookmark(\u003cspan\u003e_\u003c/span\u003e items: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eCollection\u003c/span\u003e\u0026lt;\u003cspan\u003eany\u003c/span\u003e \u003cspan\u003eContentItem\u003c/span\u003e\u0026gt;) {\n        \u003cspan\u003efor\u003c/span\u003e item \u003cspan\u003ein\u003c/span\u003e items {\n            \u003cspan\u003e\u003cspan\u003ebookmark\u003c/span\u003e(item)\u003c/span\u003e\n        }\n    }\n\n    \u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e bookmark(\u003cspan\u003e_\u003c/span\u003e item: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eContentItem\u003c/span\u003e)\u003c/span\u003e {\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAgain, it’s important to emphasize the using \u003ccode\u003eany\u003c/code\u003e does introduce type erasure under the hood, even if it’s all done automatically by the compiler — so using static types (which is still the case when using the \u003ccode\u003esome\u003c/code\u003e keyword) is definitely the preferred way to go whenever possible.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"conclusion\" href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSwift 5.7 doesn’t just make Swift’s generics system more powerful, it arguably makes it much more \u003cem\u003eaccessible\u003c/em\u003e as well, as it reduces the need to use generic type constraints and other more advanced generic programming techniques just to be able to refer to certain protocols.\u003c/p\u003e\u003cp\u003eGenerics is definitely not the right tool for every single problem, but when it turns out to be, being able to use Swift’s generics system in a much more lightweight way is definitely a big win.\u003c/p\u003e\u003cp\u003eI hope that you found this article useful. If you have any questions, comments, or feedback, then feel free to reach out via either \u003ca href=\"https://twitter.com/johnsundell\"\u003eTwitter\u003c/a\u003e or \u003ca href=\"https://www.swiftbysundell.com/contact\"\u003eemail\u003c/a\u003e. For more information about these new generics features, I recommend watching the excellent \u003ca href=\"https://developer.apple.com/wwdc22/110354\"\u003e“What’s new in Swift”\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/wwdc22/110352\"\u003e“Embrace Swift generics”\u003c/a\u003e sessions from this year’s WWDC.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": null,
  "modifiedTime": null
}
