{
  "id": "be7d4022-6c13-4c5b-9cb5-e2d2daa03cf9",
  "title": "Modular iOS Architecture @ Just Eat",
  "link": "https://albertodebortoli.com/2019/12/19/modular-ios-architecture-at-just-eat/",
  "description": "The journey towards a modular architecture taken by the Just Eat iOS team.",
  "author": "Alberto De Bortoli",
  "published": "Thu, 19 Dec 2019 00:43:15 GMT",
  "source": "https://albertodebortoli.com/rss/",
  "categories": [
    "iOS",
    "Just Eat",
    "architecture",
    "modulrization",
    "Cocoapods"
  ],
  "byline": "Alberto De Bortoli",
  "length": 19971,
  "excerpt": "The journey we took to restructure our mobile apps towards a modular architecture. Originally published on the Just Eat Engineering Blog. Overview Modular mobile architectures have been a hot topic over the past 2 years, counting a plethora of articles and conference talks. Almost every big company promoted and discussed modularization publicly as a way to scale big projects. At Just Eat, we jumped on the modular architecture train probably before it was mainstream and, as we'll discuss in t",
  "siteName": "Alberto De Bortoli",
  "favicon": "",
  "text": "The journey we took to restructure our mobile apps towards a modular architecture.Originally published on the Just Eat Engineering Blog.OverviewModular mobile architectures have been a hot topic over the past 2 years, counting a plethora of articles and conference talks. Almost every big company promoted and discussed modularization publicly as a way to scale big projects. At Just Eat, we jumped on the modular architecture train probably before it was mainstream and, as we'll discuss in this article, the root motivation was quite peculiar in the industry.Over the years (2016-2019), we've completely revamped our iOS products from the ground up and learned a lot during this exciting and challenging journey. There is so much to say about the way we structured our iOS stack that it would probably deserve a series of articles, some of which have previously been posted. Here we summarize the high-level iOS architecture we crafted, covering the main aspects in a way concise enough for the reader to get a grasp of them and hopefully learn some valuable tips.Lots of information can be found online on modular architectures. In short: A modular architecture is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each one contains everything necessary to execute only one aspect of the desired functionality.Note that modular design applies to the code you own. A project with several third-party dependencies but no sensible separation for the code written by your team is not considered modular.A modular design is more about the principle rather than the specific technology. One could achieve it in a variety of ways and with different tools. Here are some key points and examples that should inform the decision of the ifs and the hows of implementing modularization:Business reasonsThe company requires that parts of the codebase are reused and shared across projects, products, and teams;The company requires multiple products to be unified into a single one.Tech reasonsThe codebase has grown to a state where things become harder and harder to maintain and to iterate over;Development is slowed down due to multiple developers working on the same monolithic codebase;Besides reusing code, you need to port functionalities across projects/products.Multiple teamsThe company structured teams following strategic models (e.g. Spotify model) and functional teams only work on a subset of the final product;Ownership of small independent modules distributed across teams enables faster iterations;The much smaller cognitive overhead of working on a smaller part of the whole product can vastly simplify the overall development.Pre-existing knowledge Members of the team might already be familiar with specific solutions (Carthage, CocoaPods, Swift Package Manager, manual frameworks setup within Xcode). In the case of a specific familiarity with a system, it's recommended to start with it since all solutions come with pros and cons and there's not a clear winner at the time of writing.Modularizing code (if done sensibly) is almost always a good thing: it enforces separation of concerns, keeps complexity under control, allows faster development, etc. It has to be said that it's not necessarily what one needs for small projects and its benefits become tangible only after a certain complexity threshold is crossed.Journey to a new architectureIn 2014, Just Eat was a completely different environment from today and back then the business decided to split the tech department into separate departments: one for UK and one for the other countries. While this was done with the best intentions to allow faster evolution in the main market (UK), it quickly created a hard division between teams, services, and people. In less than 6 months, the UK and International APIs and consumer clients deeply diverged introducing country-specific logic and behaviors.By mid-2016 the intent of \"merging back\" into a single global platform was internally announced and at that time it almost felt like a company acquisition. This is when we learned the importance of integrating people before technology.The teams didnâ€™t know each other very well and became reasonably territorial on their codebase. It didnâ€™t help that the teams span multiple cities. It's understandable that getting to an agreement on how going back to a single, global, and unified platform took months. The options we considered spanned from rewriting the product from scratch to picking one of the two existing ones and make it global. A complete rewrite would have eventually turned out to be a big-bang release with the risk of regressions being too high; not something sensible or safe to pursue. Picking one codebase over the other would have necessarily let down one of the two teams and caused the re-implementation of some missing features present in the other codebase. At that time, the UK project was in a better shape and new features were developed for the UK market first. The international project was a bit behind due to the extra complexity of supporting multiple countries and features being too market-specific.During that time, the company was also undergoing massive growth and with multiple functional teams having been created internally, there was an increasing need to move towards modularization. Therefore, we decided to gradually and strategically modularize parts of the mobile products and onboard them onto the other codebase in a controlled and safe way. In doing so, we took the opportunity to deeply refactor and, in the vast majority of the cases, rewrite parts in their entirety enabling new designs, better tests, higher code coverage, and - holistically - a fully Swift codebase.We knew that the best way to refactor and clean up the code was by following a bottom-up approach. We started with the foundations to solve small and well-defined problems - such as logging, tracking, theming - enabling the team to learn to think modular. We later moved to isolating big chunks of code into functional modules to be able to onboard them into the companion codebase and ship them on a phased rollout. We soon realized we needed a solid engine to handle run-time configurations and remote feature flagging to allow switching ON and OFF features as well as entire modules. As discussed in a previous article, we developed JustTweak to achieve this goal.At the end of the journey, the UK and the International projects would look very similar, sharing a number of customizable modules, and differing only in the orchestration layer in the apps.The Just Eat iOS apps are far bigger and more complex than they might look at first glance. Generically speaking, merging different codebases takes orders of magnitude longer than separating them, and for us, it was a process that took over 3 years, being possible thanks to unparalleled efforts of engineers brought to work together. Over this time, the whole team learned a lot, from the basics of developing code in isolation to how to scale a complex system.Holistic Design ðŸ¤˜The following diagram outlines the modular architecture in its entirety as it is at the time of writing this article (December 2019). We can appreciate a fair number of modules clustered by type and the different consumer apps.Modular iOS architecture - holistic designWhenever possible, we took the opportunity to abstract some modules having them in a state that allows open-sourcing the code. All of our open-source modules are licensed under Apache 2 and can be found at github.com/justeat.AppsDue to the history of Just Eat described above, we build different appsper countryper brandfrom different codebasesAll the modularization work we did bottom-up brought us to a place where the apps differ only in the layer orchestrating the modules. With all the consumer-facing features been moved to the domain modules, there is very little code left in the apps.Domain ModulesDomain modules contain features specific to an area of the product. As the diagram above shows, the sum of all those parts makes up the Just Eat apps. These modules are constantly modified and improved by our teams and updating the consumer apps to use newer versions is an explicit action. We don't particularly care about backward compatibility here since we are the sole consumers and it's common to break the public interface quite often if necessary. It might seem at first that domain modules should depend on some Core modules (e.g. APIClient) but doing so would complicate the dependency tree as we'll discuss further in the \"Dependency Management\" section of this article. Instead, we inject core modules' services, simply making them conformant to protocols defined in the domain module. In this way, we maintain a good abstraction and avoid tangling the dependency graph.Core \u0026 Shared modulesThe Core and Shared modules represent the foundations of our stack, things like:custom UI frameworktheming enginelogging, tracking, and analytics librariestest utilitiesclient for all the Just Eat APIsfeature flagging and experimentation engineand so forth. These modules - which are sometimes also made open-source - should not change frequently due to their nature. Here backward compatibility is important and we deprecate old APIs when introducing new ones. Both apps and domain modules can have shared modules as dependencies, while core modules can only be used by the apps. Updating the backbone of a system requires the propagation of the changes up in the stack (with its maintenance costs) and for this reason, we try to keep the number of shared modules very limited.Structure of a moduleAs we touched on in previous articles, one of our fundamental principles is \"always strive to find solutions to problems that are scalable and hide complexity as much as possible\". We are almost obsessed with making things as simple as they can be.When building a module, our root principle is:Every module should be well tested, maintainable, readable, easily pluggable, and reasonably documented.The order of the adjectives implies some sort of priority.First of all, the code must be unit tested, and in the case of domain modules, UI tests are required too. Without reasonable code coverage, no code is shipped to production. This is the first step to code maintainability, where maintainable code is intended as \"code that is easy to modify or extend\". Readability is down to reasonable design, naming convention, coding standards, formatting, and all that jazz.Every module exposes a Facade that is very succinct, usually no more than 200 lines long. This entry point is what makes a module easily pluggable. In our module blueprint, the bare minimum is a combination of a facade class, injected dependencies, and one or more configuration objects driving the behavior of the module (leveraging the underlying feature flagging system powered by JustTweak discussed in a previous article).The facade should be all a developer needs to know in order to consume a module without having to look at implementation details. Just to give you an idea, here is an excerpt from the generated public interface of the Account module (not including the protocols):public typealias PasswordManagementService = ForgottenPasswordServiceProtocol \u0026 ResetPasswordServiceProtocol public typealias AuthenticationService = LoginServiceProtocol \u0026 SignUpServiceProtocol \u0026 PasswordManagementService \u0026 RecaptchaServiceProtocol public typealias UserAccountService = AccountInfoServiceProtocol \u0026 ChangePasswordServiceProtocol \u0026 ForgottenPasswordServiceProtocol \u0026 AccountCreditServiceProtocol public class AccountModule { public init(settings: Settings, authenticationService: AuthenticationService, userAccountService: UserAccountService, socialLoginServices: [SocialLoginService], userInfoProvider: UserInfoProvider) public func startLogin(on viewController: UIViewController) -\u003e FlowCoordinator public func startResetPassword(on viewController: UIViewController, token: Token) -\u003e FlowCoordinator public func startAccountInfo(on navigationController: UINavigationController) -\u003e FlowCoordinator public func startAccountCredit(on navigationController: UINavigationController) -\u003e FlowCoordinator public func loginUsingSharedWebCredentials(handler: @escaping (LoginResult) -\u003e Void) }Domain module public interface example (Account module)We believe code should be self-descriptive and we tend to put comments only on code that really deserves some explanation, very much embracing John Ousterhout's approach described in A Philosophy of Software Design. Documentation is mainly relegated to the README file and we treat every module as if it was an open-source project: the first thing consumers would look at is the README file, and so we make it as descriptive as possible.Overall designWe generate all our modules using CocoaPods via $ pod lib create which creates the project with a standard template generating the Podfile, podspec, and demo app in a breeze. The podspec could specify additional dependencies (both third-party and Core modules) that the demo app's Podfile could specify core modules dependencies alongside the module itself which is treated as a development pod as per standard setup.The backbone of the module, which is the framework itself, encompasses both business logic and UI meaning that both source and asset files are part of it. In this way, the demo apps are very much lightweight and only showcase module features that are implemented in the framework.The following diagram should summarize it all.Design of a module with Podfile and podspec examplesDemo AppsEvery module comes with a demo app we give particular care to. Demo apps are treated as first-class citizens and the stakeholders are both engineers and product managers. They massively help to showcase the module features - especially those under development - vastly simplify collaboration across Engineering, Product, and Design, and force a good mock-based test-first approach.Following is a SpringBoard page showing our demo apps, very useful to individually showcase all the functionalities implemented over time, some of which might not surface in the final product to all users. Some features are behind experiments, some still in development, while others might have been retired but still present in the modules.Every demo app has a main menu to:access the featuresforce a specific languagetoggle configuration flags via JustTweakcustomize mock dataWe show the example of the Account module demo app on the right.Domain modules demo appsInternal designIt's worth noting that our root principle mentioned above does not include any reference to the internal architecture of a module and this is intentional. It's common for iOS teams in the industry to debate on which architecture to adopt across the entire codebase but the truth is that such debate aims to find an answer to a non-existing problem. With an increasing number of modules and engineers, it's fundamentally impossible to align on a single paradigm shared and agreed upon by everyone. Betting on a single architectural design would ultimately let down some engineers who would complain down the road that a different design would have played out better.We decided to stick with the following rule of thumb:Developers are free to use the architectural design they feel would work better for a given problem.This approach brought us to have a variety of different designs - spanning from simple old-school MVC, to a more evolved VIPER - and we constantly learn from each other's code. What's important at the end of the day is that techniques such as inversion of control, dependency injection, and more generally the SOLID principles, are used appropriately to embrace our root principle.Dependency ManagementWe rely heavily on CocoaPods since we adopted it in the early days as it felt like the best and most mature choice at the time we started modularizing our codebase. We think this still holds at the time of writing this article but we can envision a shift to SPM (Swift Package Manager) in 1-2 years time.With a growing number of modules, comes the responsibility of managing the dependencies between them. No panacea can cure dependency hell, but one should adopt some tricks to keep the complexity of the stack under reasonable control.Here's a summary of what worked for us:Always respect semantic versioning;Keep the dependency graph as shallow as possible. From our apps to the leaves of the graph there are no more than 2 levels;Use a minimal amount of shared dependencies. Be aware that every extra level with shared modules brings in higher complexity;Reduce the number of third-party libraries to the bare minimum. Code that's not written and owned by your team is not under your control;Never make modules within a group (domain, core, shared) depend on other modules of the same group;Automate the publishing of new versions. When a pull request gets merged into the master branch, it must also contain a version change in the podspec. Our continuous integration system will automatically validate the podspec, publish it to our private spec repository, and in just a matter of minutes the new version becomes available;Fix the version for dependencies in the Podfile. Whether it is a consumer app or a demo app, we want both our modules and third-party libraries not to be updated unintentionally. It's acceptable to use the optimistic operator for third-party libraries to allow automatic updates of new patch versions;Fix the version for third-party libraries in the modules' podspec. This guarantees that modules' behavior won't change in the event of changes in external libraries. Failing to do so would allow defining different versions in the app's Podfile, potentially causing the module to not function correctly or even to not compile;Do not fix the version for shared modules in the modules' podspec. In this way, we let the apps define the version in the Podfile, which is particularly useful for modules that change often, avoiding the hassle of updating the version of the shared modules in every podspec referencing it. If a new version of a shared module is not backward compatible with the module consuming it, the failure would be reported by the continuous integration system as soon as a new pull request gets raised.A note on the Monorepo approachWhen it comes to dependency management it would be unfair not to mention the opinable monorepo approach. Monorepos have been discussed quite a lot by the community to pose a remedy to dependency management (de facto ignoring it), some engineers praise them, others are quite contrary. Facebook, Google, and Uber are just some of the big companies known to have adopted this technique, but in hindsight, it's still unclear if it was the best decision for them.In our opinion, monorepos can sometimes be a good choice.For example, in our case, a great benefit a monorepo would give us is the ability to prepare a single pull request for both implementing a code change in a module and integrating it into the apps. This will have an even greater impact when all the Just Eat consumer apps are globalized into a single codebase.Onwards and upwardsModularizing the iOS product has been a long journey and the learnings were immense. All in all, it took more than 3 years, from May 2016 to October 2019, always balancing tech and product improvements. Our natural next step is unifying the apps into a single global project, migrating the international countries over to the UK project to ultimately reach the utopian state of having a single global app. All the modules have been implemented in a fairly abstract way and following a white labeling approach, allowing us to extend support to new countries and onboard acquired companies in the easiest possible way.",
  "image": "https://albertodebortoli.com/content/images/size/w1200/2019/12/lego-1629073_1920-1.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cblockquote\u003eThe journey we took to restructure our mobile apps towards a modular architecture.\u003c/blockquote\u003e\u003cp\u003e\u003cem\u003eOriginally published on the \u003c/em\u003e\u003ca href=\"https://tech.just-eat.com/2019/12/18/modular-ios-architecture-just-eat/?ref=albertodebortoli.com\"\u003e\u003cem\u003eJust Eat Engineering Blog\u003c/em\u003e\u003c/a\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\u003cp\u003eModular mobile architectures have been a hot topic over the past 2 years, counting a plethora of articles and conference talks. Almost every big company promoted and discussed modularization publicly as a way to scale big projects. At Just Eat, we jumped on the modular architecture train probably before it was mainstream and, as we\u0026#39;ll discuss in this article, the root motivation was quite peculiar in the industry.\u003c/p\u003e\u003cp\u003eOver the years (2016-2019), we\u0026#39;ve completely revamped our iOS products from the ground up and learned a lot during this exciting and challenging journey. There is so much to say about the way we structured our iOS stack that it would probably deserve a series of articles, some of which have previously been posted. Here we summarize the high-level iOS architecture we crafted, covering the main aspects in a way concise enough for the reader to get a grasp of them and hopefully learn some valuable tips.\u003c/p\u003e\u003cp\u003eLots of information can be found online on modular architectures. In short: \u003c/p\u003e\u003cblockquote\u003eA modular architecture is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each one contains everything necessary to execute only one aspect of the desired functionality.\u003c/blockquote\u003e\u003cp\u003eNote that modular design applies to the code you own. A project with several third-party dependencies but no sensible separation for the code written by your team is not considered modular.\u003c/p\u003e\u003cp\u003eA modular design is more about the principle rather than the specific technology. One could achieve it in a variety of ways and with different tools. Here are some key points and examples that should inform the decision of the ifs and the hows of implementing modularization:\u003c/p\u003e\u003ch3 id=\"business-reasons\"\u003eBusiness reasons\u003c/h3\u003e\u003cul\u003e\u003cli\u003eThe company requires that parts of the codebase are reused and shared across projects, products, and teams;\u003c/li\u003e\u003cli\u003eThe company requires multiple products to be unified into a single one.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"tech-reasons\"\u003eTech reasons\u003c/h3\u003e\u003cul\u003e\u003cli\u003eThe codebase has grown to a state where things become harder and harder to maintain and to iterate over;\u003c/li\u003e\u003cli\u003eDevelopment is slowed down due to multiple developers working on the same monolithic codebase;\u003c/li\u003e\u003cli\u003eBesides reusing code, you need to port functionalities across projects/products.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"multiple-teams\"\u003eMultiple teams\u003c/h3\u003e\u003cul\u003e\u003cli\u003eThe company structured teams following strategic models (e.g. Spotify model) and functional teams only work on a subset of the final product;\u003c/li\u003e\u003cli\u003eOwnership of small independent modules distributed across teams enables faster iterations;\u003c/li\u003e\u003cli\u003eThe much smaller cognitive overhead of working on a smaller part of the whole product can vastly simplify the overall development.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"pre-existing-knowledge\"\u003ePre-existing knowledge \u003c/h3\u003e\u003cul\u003e\u003cli\u003eMembers of the team might already be familiar with specific solutions (Carthage, CocoaPods, Swift Package Manager, manual frameworks setup within Xcode). In the case of a specific familiarity with a system, it\u0026#39;s recommended to start with it since all solutions come with pros and cons and there\u0026#39;s not a clear winner at the time of writing.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eModularizing code (if done sensibly) is almost always a good thing: it enforces separation of concerns, keeps complexity under control, allows faster development, etc. It has to be said that it\u0026#39;s not necessarily what one needs for small projects and its benefits become tangible only after a certain complexity threshold is crossed.\u003c/p\u003e\u003ch2 id=\"journey-to-a-new-architecture\"\u003eJourney to a new architecture\u003c/h2\u003e\u003cp\u003eIn 2014, Just Eat was a completely different environment from today and back then the business decided to split the tech department into separate departments: one for UK and one for the other countries. While this was done with the best intentions to allow faster evolution in the main market (UK), it quickly created a hard division between teams, services, and people. In less than 6 months, the UK and International APIs and consumer clients deeply diverged introducing country-specific logic and behaviors.\u003c/p\u003e\u003cp\u003eBy mid-2016 the intent of \u0026#34;merging back\u0026#34; into a single global platform was internally announced and at that time it almost felt like a company acquisition. This is when we learned the importance of \u003cem\u003eintegrating people before technology.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eThe teams didnâ€™t know each other very well and became reasonably territorial on their codebase. It didnâ€™t help that the teams span multiple cities. It\u0026#39;s understandable that getting to an agreement on how going back to a single, global, and unified platform took months. The options we considered spanned from rewriting the product from scratch to picking one of the two existing ones and make it global. A complete rewrite would have eventually turned out to be a big-bang release with the risk of regressions being too high; not something sensible or safe to pursue. Picking one codebase over the other would have necessarily let down one of the two teams and caused the re-implementation of some missing features present in the other codebase. At that time, the UK project was in a better shape and new features were developed for the UK market first. The international project was a bit behind due to the extra complexity of supporting multiple countries and features being too market-specific.\u003c/p\u003e\u003cp\u003eDuring that time, the company was also undergoing massive growth and with multiple functional teams having been created internally, there was an increasing need to move towards modularization. Therefore, we decided to gradually and strategically modularize parts of the mobile products and onboard them onto the other codebase in a controlled and safe way. In doing so, we took the opportunity to deeply refactor and, in the vast majority of the cases, rewrite parts in their entirety enabling new designs, better tests, higher code coverage, and - holistically - a fully Swift codebase.\u003c/p\u003e\u003cp\u003eWe knew that the best way to refactor and clean up the code was by following a bottom-up approach. We started with the foundations to solve small and well-defined problems - such as logging, tracking, theming - enabling the team to learn to \u003cem\u003ethink modular\u003c/em\u003e. We later moved to isolating big chunks of code into functional modules to be able to onboard them into the companion codebase and ship them on a phased rollout. We soon realized we needed a solid engine to handle run-time configurations and remote feature flagging to allow switching ON and OFF features as well as entire modules. As discussed in a previous \u003ca href=\"https://albertodebortoli.com/2019/11/26/a-smart-feature-flagging-system-for-ios/\"\u003earticle\u003c/a\u003e, we developed \u003ca href=\"https://github.com/justeat/JustTweak?ref=albertodebortoli.com\"\u003eJustTweak\u003c/a\u003e to achieve this goal.\u003c/p\u003e\u003cp\u003eAt the end of the journey, the UK and the International projects would look very similar, sharing a number of customizable modules, and differing only in the orchestration layer in the apps.\u003c/p\u003e\u003cp\u003eThe Just Eat iOS apps are far bigger and more complex than they might look at first glance. Generically speaking, merging different codebases takes orders of magnitude longer than separating them, and for us, it was a process that took over 3 years, being possible thanks to unparalleled efforts of engineers brought to work together. Over this time, the whole team learned a lot, from the basics of developing code in isolation to how to scale a complex system.\u003c/p\u003e\u003ch2 id=\"holistic-design-%F0%9F%A4%98\"\u003eHolistic Design ðŸ¤˜\u003c/h2\u003e\u003cp\u003eThe following diagram outlines the modular architecture in its entirety as it is at the time of writing this article (December 2019). We can appreciate a fair number of modules clustered by type and the different consumer apps.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/12/The-Just-Eat-iOS-Stack---Holistic-Design--2.svg\" alt=\"\" loading=\"lazy\"/\u003e\u003cfigcaption\u003e\u003cspan\u003eModular iOS architecture - holistic design\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eWhenever possible, we took the opportunity to abstract some modules having them in a state that allows open-sourcing the code. All of our open-source modules are licensed under Apache 2 and can be found at \u003ca href=\"https://github.com/justeat?ref=albertodebortoli.com\"\u003egithub.com/justeat\u003c/a\u003e.\u003c/p\u003e\u003ch3 id=\"apps\"\u003eApps\u003c/h3\u003e\u003cp\u003eDue to the history of Just Eat described above, we build different apps\u003c/p\u003e\u003cul\u003e\u003cli\u003eper country\u003c/li\u003e\u003cli\u003eper brand\u003c/li\u003e\u003cli\u003efrom different codebases\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAll the modularization work we did bottom-up brought us to a place where the apps differ only in the layer orchestrating the modules. With all the consumer-facing features been moved to the domain modules, there is very little code left in the apps.\u003c/p\u003e\u003ch3 id=\"domain-modules\"\u003eDomain Modules\u003c/h3\u003e\u003cp\u003eDomain modules contain features specific to an area of the product. As the diagram above shows, the sum of all those parts makes up the Just Eat apps. These modules are constantly modified and improved by our teams and updating the consumer apps to use newer versions is an explicit action. We don\u0026#39;t particularly care about backward compatibility here since we are the sole consumers and it\u0026#39;s common to break the public interface quite often if necessary. It might seem at first that domain modules should depend on some Core modules (e.g. APIClient) but doing so would complicate the dependency tree as we\u0026#39;ll discuss further in the \u0026#34;Dependency Management\u0026#34; section of this article. Instead, we inject core modules\u0026#39; services, simply making them conformant to protocols defined in the domain module.  In this way, we maintain a good abstraction and avoid tangling the dependency graph.\u003c/p\u003e\u003ch3 id=\"core-shared-modules\"\u003eCore \u0026amp; Shared modules\u003c/h3\u003e\u003cp\u003eThe Core and Shared modules represent the foundations of our stack, things like:\u003c/p\u003e\u003cul\u003e\u003cli\u003ecustom UI framework\u003c/li\u003e\u003cli\u003etheming engine\u003c/li\u003e\u003cli\u003elogging, tracking, and analytics libraries\u003c/li\u003e\u003cli\u003etest utilities\u003c/li\u003e\u003cli\u003eclient for all the Just Eat APIs\u003c/li\u003e\u003cli\u003efeature flagging and experimentation engine\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eand so forth. These modules - which are sometimes also made open-source - should not change frequently due to their nature. Here backward compatibility is important and we deprecate old APIs when introducing new ones. Both apps and domain modules can have shared modules as dependencies, while core modules can only be used by the apps. Updating the backbone of a system requires the propagation of the changes up in the stack (with its maintenance costs) and for this reason, we try to keep the number of shared modules very limited.\u003c/p\u003e\u003ch2 id=\"structure-of-a-module\"\u003eStructure of a module\u003c/h2\u003e\u003cp\u003eAs we touched on in previous articles, one of our fundamental principles is \u0026#34;\u003cem\u003ealways strive to find solutions to problems that are scalable and hide complexity as much as possible\u003c/em\u003e\u0026#34;. We are almost obsessed with making things as simple as they can be.\u003c/p\u003e\u003cp\u003eWhen building a module, our root \u003cem\u003eprinciple\u003c/em\u003e is:\u003c/p\u003e\u003cblockquote\u003eEvery module should be well tested, maintainable, readable, easily pluggable, and reasonably documented.\u003c/blockquote\u003e\u003cp\u003eThe order of the adjectives implies some sort of priority.\u003c/p\u003e\u003cp\u003eFirst of all, the code must be unit \u003cem\u003etested\u003c/em\u003e, and in the case of domain modules, UI tests are required too. Without reasonable code coverage, no code is shipped to production. This is the first step to code \u003cem\u003emaintainability\u003c/em\u003e, where maintainable code is intended as \u0026#34;code that is easy to modify or extend\u0026#34;. \u003cem\u003eReadability\u003c/em\u003e is down to reasonable design, naming convention, coding standards, formatting, and all that jazz.\u003c/p\u003e\u003cp\u003eEvery module exposes a Facade that is very succinct, usually no more than 200 lines long. This entry point is what makes a module easily \u003cem\u003epluggable\u003c/em\u003e. In our module blueprint, the bare minimum is a combination of a facade class, injected dependencies, and one or more configuration objects driving the behavior of the module (leveraging the underlying feature flagging system powered by JustTweak discussed in a \u003ca href=\"https://albertodebortoli.com/2019/11/26/a-smart-feature-flagging-system-for-ios/\"\u003eprevious article\u003c/a\u003e).\u003c/p\u003e\u003cp\u003eThe facade should be all a developer needs to know in order to consume a module without having to look at implementation details. Just to give you an idea, here is an excerpt from the generated public interface of the \u003cem\u003eAccount\u003c/em\u003e module (not including the protocols):\u003c/p\u003e\u003cfigure\u003e\u003cpre\u003e\u003ccode\u003epublic typealias PasswordManagementService = ForgottenPasswordServiceProtocol \u0026amp; ResetPasswordServiceProtocol\npublic typealias AuthenticationService = LoginServiceProtocol \u0026amp; SignUpServiceProtocol \u0026amp; PasswordManagementService \u0026amp; RecaptchaServiceProtocol\npublic typealias UserAccountService = AccountInfoServiceProtocol \u0026amp; ChangePasswordServiceProtocol \u0026amp; ForgottenPasswordServiceProtocol \u0026amp; AccountCreditServiceProtocol\n\npublic class AccountModule {\n    public init(settings: Settings,\n                authenticationService: AuthenticationService,\n                userAccountService: UserAccountService,\n                socialLoginServices: [SocialLoginService],\n                userInfoProvider: UserInfoProvider)\n\n    public func startLogin(on viewController: UIViewController) -\u0026gt; FlowCoordinator\n    public func startResetPassword(on viewController: UIViewController, token: Token) -\u0026gt; FlowCoordinator\n    public func startAccountInfo(on navigationController: UINavigationController) -\u0026gt; FlowCoordinator\n    public func startAccountCredit(on navigationController: UINavigationController) -\u0026gt; FlowCoordinator\n    public func loginUsingSharedWebCredentials(handler: @escaping (LoginResult) -\u0026gt; Void)\n}\u003c/code\u003e\u003c/pre\u003e\u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003eDomain module public interface example (Account module)\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eWe believe code should be self-descriptive and we tend to put comments only on code that \u003cem\u003ereally\u003c/em\u003e deserves some explanation, very much embracing John Ousterhout\u0026#39;s approach described in \u003ca href=\"https://www.goodreads.com/en/book/show/39996759-a-philosophy-of-software-design?ref=albertodebortoli.com\"\u003eA Philosophy of Software Design\u003c/a\u003e. \u003cem\u003eDocumentation\u003c/em\u003e is mainly relegated to the README file and we treat every module as if it was an open-source project: the first thing consumers would look at is the README file, and so we make it as descriptive as possible.\u003c/p\u003e\u003ch3 id=\"overall-design\"\u003eOverall design\u003c/h3\u003e\u003cp\u003eWe generate all our modules using CocoaPods via \u003ccode\u003e$ pod lib create\u003c/code\u003e which creates the project with a standard template generating the Podfile, podspec, and demo app in a breeze. The podspec could specify additional dependencies (both third-party and Core modules) that the demo app\u0026#39;s Podfile could specify core modules dependencies alongside the module itself which is treated as a development pod as per standard setup.\u003c/p\u003e\u003cp\u003eThe backbone of the module, which is the framework itself, encompasses both business logic and UI meaning that both source and asset files are part of it. In this way, the demo apps are very much lightweight and only showcase module features that are implemented in the framework.\u003c/p\u003e\u003cp\u003eThe following diagram should summarize it all.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/12/The-Just-Eat-iOS-Stack---Module-Design-6.svg\" alt=\"Design of a module with Podfile and podspec examples\" loading=\"lazy\"/\u003e\u003cfigcaption\u003e\u003cspan\u003eDesign of a module with Podfile and podspec examples\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003ch3 id=\"demo-apps\"\u003eDemo Apps\u003c/h3\u003e\u003cp\u003eEvery module comes with a demo app we give particular care to. Demo apps are treated as first-class citizens and the stakeholders are both engineers and product managers. They massively help to showcase the module features - especially those under development - vastly simplify collaboration across Engineering, Product, and Design, and force a good mock-based test-first approach.\u003c/p\u003e\u003cp\u003eFollowing is a SpringBoard page showing our demo apps, very useful to individually showcase all the functionalities implemented over time, some of which might not surface in the final product to all users. Some features are behind experiments, some still in development, while others might have been retired but still present in the modules.\u003c/p\u003e\u003cp\u003eEvery demo app has a main menu to:\u003c/p\u003e\u003cul\u003e\u003cli\u003eaccess the features\u003c/li\u003e\u003cli\u003eforce a specific language\u003c/li\u003e\u003cli\u003etoggle configuration flags via JustTweak\u003c/li\u003e\u003cli\u003ecustomize mock data\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWe show the example of the \u003cem\u003eAccount\u003c/em\u003e module demo app on the right.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/12/asd.png\" alt=\"\" loading=\"lazy\"/\u003e\u003cfigcaption\u003e\u003cspan\u003eDomain modules demo apps\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003ch3 id=\"internal-design\"\u003eInternal design\u003c/h3\u003e\u003cp\u003eIt\u0026#39;s worth noting that our root principle mentioned above does not include any reference to the internal architecture of a module and this is intentional. It\u0026#39;s common for iOS teams in the industry to debate on which architecture to adopt across the entire codebase but the truth is that such debate aims to find an answer to a non-existing problem. With an increasing number of modules and engineers, it\u0026#39;s fundamentally impossible to align on a single paradigm shared and agreed upon by everyone. Betting on a single architectural design would ultimately let down some engineers who would complain down the road that a different design would have played out better.\u003c/p\u003e\u003cp\u003eWe decided to stick with the following rule of thumb:\u003c/p\u003e\u003cblockquote\u003eDevelopers are free to use the architectural design they feel would work better for a given problem.\u003c/blockquote\u003e\u003cp\u003eThis approach brought us to have a variety of different designs - spanning from simple old-school MVC, to a more evolved VIPER - and we constantly learn from each other\u0026#39;s code. What\u0026#39;s important at the end of the day is that techniques such as inversion of control, dependency injection, and more generally the SOLID principles, are used appropriately to embrace our root principle.\u003c/p\u003e\u003ch2 id=\"dependency-management\"\u003eDependency Management\u003c/h2\u003e\u003cp\u003eWe rely heavily on CocoaPods since we adopted it in the early days as it felt like the best and most mature choice at the time we started modularizing our codebase. We think this still holds at the time of writing this article but we can envision a shift to SPM (Swift Package Manager) in 1-2 years time.\u003c/p\u003e\u003cp\u003eWith a growing number of modules, comes the responsibility of managing the dependencies between them. No panacea can cure \u003ca href=\"https://en.wikipedia.org/wiki/Dependency_hell?ref=albertodebortoli.com\"\u003edependency hell\u003c/a\u003e, but one should adopt some tricks to keep the complexity of the stack under reasonable control.\u003c/p\u003e\u003cp\u003eHere\u0026#39;s a summary of what worked for us:\u003c/p\u003e\u003cul\u003e\u003cli\u003eAlways respect \u003ca href=\"https://semver.org/?ref=albertodebortoli.com\"\u003esemantic versioning\u003c/a\u003e;\u003c/li\u003e\u003cli\u003eKeep the dependency graph as shallow as possible. From our apps to the leaves of the graph there are no more than 2 levels;\u003c/li\u003e\u003cli\u003eUse a minimal amount of shared dependencies. Be aware that every extra level with shared modules brings in higher complexity;\u003c/li\u003e\u003cli\u003eReduce the number of third-party libraries to the bare minimum. Code that\u0026#39;s not written and owned by your team is not under your control;\u003c/li\u003e\u003cli\u003eNever make modules within a group (domain, core, shared) depend on other modules of the same group;\u003c/li\u003e\u003cli\u003eAutomate the publishing of new versions. When a pull request gets merged into the master branch, it must also contain a version change in the podspec. Our continuous integration system will automatically validate the podspec, publish it to our private spec repository, and in just a matter of minutes the new version becomes available;\u003c/li\u003e\u003cli\u003eFix the version for dependencies in the Podfile. Whether it is a consumer app or a demo app, we want both our modules and third-party libraries not to be updated unintentionally. It\u0026#39;s acceptable to use the \u003ca href=\"https://guides.cocoapods.org/using/the-podfile.html?ref=albertodebortoli.com#specifying-pod-versions\"\u003eoptimistic operator\u003c/a\u003e for third-party libraries to allow automatic updates of new patch versions;\u003c/li\u003e\u003cli\u003eFix the version for third-party libraries in the modules\u0026#39; podspec. This guarantees that modules\u0026#39; behavior won\u0026#39;t change in the event of changes in external libraries. Failing to do so would allow defining different versions in the app\u0026#39;s Podfile, potentially causing the module to not function correctly or even to not compile;\u003c/li\u003e\u003cli\u003eDo not fix the version for shared modules in the modules\u0026#39; podspec. In this way, we let the apps define the version in the Podfile, which is particularly useful for modules that change often, avoiding the hassle of updating the version of the shared modules in every podspec referencing it. If a new version of a shared module is not backward compatible with the module consuming it, the failure would be reported by the continuous integration system as soon as a new pull request gets raised.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"a-note-on-the-monorepo-approach\"\u003eA note on the Monorepo approach\u003c/h3\u003e\u003cp\u003eWhen it comes to dependency management it would be unfair not to mention the opinable \u003ca href=\"https://en.wikipedia.org/wiki/Monorepo?ref=albertodebortoli.com\"\u003emonorepo\u003c/a\u003e approach. Monorepos have been discussed quite a lot by the community to pose a remedy to dependency management (de facto ignoring it), some engineers praise them, others are quite contrary. Facebook, Google, and Uber are just some of the big companies known to have adopted this technique, but in hindsight, it\u0026#39;s still unclear if it was the best decision for them.\u003c/p\u003e\u003cp\u003eIn our opinion, monorepos can sometimes be a good choice.\u003c/p\u003e\u003cp\u003eFor example, in our case, a great benefit a monorepo would give us is the ability to prepare a single pull request for both implementing a code change in a module and integrating it into the apps. This will have an even greater impact when all the Just Eat consumer apps are globalized into a single codebase.\u003c/p\u003e\u003ch2 id=\"onwards-and-upwards\"\u003eOnwards and upwards\u003c/h2\u003e\u003cp\u003eModularizing the iOS product has been a long journey and the learnings were immense. All in all, it took more than 3 years, from May 2016 to October 2019, always balancing tech and product improvements. Our natural next step is unifying the apps into a single global project, migrating the international countries over to the UK project to ultimately reach the utopian state of having a single global app. All the modules have been implemented in a fairly abstract way and following a white labeling approach, allowing us to extend support to new countries and onboard acquired companies in the easiest possible way.\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "21 min read",
  "publishedTime": "2019-12-19T00:43:15Z",
  "modifiedTime": "2024-01-03T22:29:21Z"
}
