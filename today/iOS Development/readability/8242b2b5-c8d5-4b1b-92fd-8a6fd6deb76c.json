{
  "id": "8242b2b5-c8d5-4b1b-92fd-8a6fd6deb76c",
  "title": "What's the 'any' keyword? Understanding Type Erasure in Swift",
  "link": "https://swiftrocks.com/whats-any-understanding-type-erasure-in-swift",
  "description": "The concept of Type Erasure is not new to Swift, but was radically improved in Swift 5.7 with the addition of the any prefix keyword (not to be confused with the capitalized Any type!) and improvements to the already existing some Opaque Type keyword. In this article, we'll explain the concept of type erasure, how it used to be done, what's different in Swift 5.7, and how these changes work under the hood. What the hell is Type Erasure? In programming languages with support for generic types, Type Erasure is the process of abstracting constrained generic types inside an unconstrained non-generic type that can be passed around freely. If you don't know why that's necessary, consider the following example where we define a protocol and a few conforming types: protocol Shape {} struct Circle: Shape {} struct Triangle: Shape {} Because the Shape protocol is unconstrained, Swift allows us to quite easily refer to Circle and Triangle as their bare conformances: var userShapes = [Shape]() func userDidCreate(shape: Shape) userShapes.append(shape) } userDidCreate(shape: Circle()) userDidCreate(shape: Triangle()) // No problems will arise here. It's fine to refer to these types as just \"Shape\". This will not be the case if the protocol has generic requirements. If the protocol has, for example, associated types that each underlying type provides on its own, Swift will strictly forbid you from referring to this protocol if you're also not providing appropriate generic constraints: protocol Sequence { associatedtype Element } var sequences = [Sequence]() // Can't do! // Error: Protocol 'Sequence' can only be used as a generic constraint // because it has Self or associated type requirements The reason you can't do this is that Swift is designed to be a type-safe language. Even though the compiler has no problem determining the underlying type of a Sequence type in the previous snippet, Swift has these features in order to allow you to ship safer products (runtime-wise). Think of access control properties like public and private; they are good examples of concepts that have absolutely no impact on the final binary. In the end, everything is accessible from everywhere, but inside your IDE, the compiler forces access control conventions to be followed so at the very least you are able to write code that is used the way you intended it to be used. The issue here with generic constraints is similar. The compiler does know what the underlying type of a particular generic protocol is in runtime, but because Swift is designed to be type-safe, for safety reasons, if it can't be determined in compile time, it will not let you do it. This is the complete opposite of Objective-C where you could easily do whatever you wanted for the (very big) cost of runtime safety. Before Swift 5.7, the solution to this problem was to box these objects into unconstrained and generally unsafe \"Any\" variations of their protocols, like this: class AnySequence { let value: Any init(_ sequence: T) { self.value = shape } } This process is called type erasure, and the Swift standard library itself contains many such objects. There are many situations in Swift where you'd need to do this, and one of them was covered in our 2020 article on how to use type erasure to build a dependency injection system. In general, you'll find yourself needing to type erase a protocol with generic requirements whenever you're in a situation where knowing the actual constraints of said protocols are irrelevant. After Swift 5.7: Enter \"any\" As far as I'm aware, this process was widely disliked by the Swift community. Not only it was a symptom of a design mistake in the language, but the process itself was also quite unsafe as it often involved the extensive usage of force-unwrapping (due to the need of referring to everything as Any). This has changed in Swift 5.7. With the addition of the new any existential type keyword, type erasure is now a feature of the Swift compiler. You do not need to create your own \"AnyMyType\" abstraction anymore; by adding any before a type, the Swift compiler will now automatically abstract it for you. While I like to call these \"type-erased values\" for simplicity, you should know that the proper terminology for referring to a value as an abstract representation is existential type. let erased: any Sequence = MyConcreteSequenceType() This also means that the old \"protocol can only be used as a generic constraint\" error has changed. In Swift 5.7, trying to use such protocols without their constraints will now make the compiler prompt you to refer to it as an existential. let erased: Sequence = MyConcreteSequenceType() // Error: Use of protocol 'Sequence' as a type must be written 'any Sequence' Type-safety of \"any\" One amazing benefit of this new keyword is that unlike manual type-erasure, using the new any keyword is type-safe. While before Swift 5.7 you generally had to force-unwrap your type-erased values in order to \"unbox\" them and access their constraints (and hope you didn't get anything wrong), the Swift 5.7 compiler will watch your back and prevent you from making mistakes. The way in which you achieve this is a bit tricky though, so I've modified an example from WWDC 2022's session about the feature to clarify it. Let's assume that we have a Animal protocol that defines a generic food type and a method to feed said food. We also have a FoodProvider protocol that is able to provide said food. protocol Animal { associatedtype Food func eat(_ food: Food) } protocol FoodProvider { func getFood(for animal: T) -\u003e T.Food } Let's now pretend that we have a helper method that receives a group of animals and tries to feed all of them. Because the particular type of animal doesn't matter to us in this scenario, we want to do so without declaring any generic constraints. func feedAll(_ animals: [Animal], provider: FoodProvider) { animals.forEach { let food = provider.getFood(for: $0) $0.eat(food) } } As you might expect after reading this article, the existence of an associated type will make Swift prevent us from doing that. Before Swift 5.7, the solution to this was generally to create a AnyAnimal type and abstract these actions under unsafe closures powered by force-unwrapping: final class AnyAnimal { var getFood: (FoodProvider) -\u003e Any var eatFood: (Any) -\u003e Void init(_ animal: T) { self.getFood = { provider in provider.getFood(for: animal) } self.eatFood = { food in animal.eat(food as! T.Food) } } } func feedAll(_ animals: [AnyAnimal], provider: FoodProvider) { animals.forEach { let food = $0.getFood(provider) $0.eatFood(food) } } While this solution will work for this case, it's not safe as you could quite easily pass the wrong food type to the erased value and cause a crash. Swift 5.7's any keyword solves this problem by enforcing complete type-safety on any existential value, but there's a small catch (Note: This refers to a limitation of Swift 5.7. If you're reading this in the future, this might not be the case anymore.). While Swift will freely allow you to call any unconstrained methods of the existential type, attempting to use any constrained methods can prove to be a bit challenging: func feedAll(_ animals: [any Animal], provider: FoodProvider) { animals.forEach { let food = provider.getFood(for: $0) $0.eat(food) // Member 'eat' cannot be used on value of type 'any Animal' } } Even though the naked eye might tell you that the output of getFood(_:) definitely matches the input of getFood(_:), Swift will not allow you to call any methods involving generic parameters unless you first explicitly \"unbox\" the existential by passing it to a generic method that receives a non-erased value (with no constraints): func feedAll(_ animals: [any Animal], provider: FoodProvider) { animals.forEach { feed($0, provider: provider) // Now works! } } func feed(_ animal: T, provider: FoodProvider) { let food = provider.getFood(for: animal) animal.eat(food) } I thought this seemed like a pointless step since they're both doing the same thing, so I asked about it on the official Swift Forums and it turns out that this is indeed a limitation of Swift 5.7. To be more specific, the proposal that introduced the ability to \"unbox\" existential types in a type-safe manner has a negative side-effect that makes the compiler \"lose\" information about a particular existential outside of said \"unboxing\" contexts. You can read more about it in the proposal. It's important to keep in mind though that the any keyword doesn't replace all cases in which you'd need to erase generic types. While it takes care of the basic case of hiding a type's constraints, more special cases such as transforming constraints (like in our tutorial about it) still require you to go with the manual approach for the time being. Supporting Features Despite not being directly related to the concept of type erasure, Swift 5.7 comes with some additional features that greatly empower it. Let's check them out. Opaque Parameters One thing we mentioned is the necessity of \"unboxing\" existentials by writing empty generic clauses. These empty clauses are very common even outside type erasure, and were improved in Swift 5.7 by the addition of the new Opaque Parameters feature. Now, instead of writing this: func feed(_ animal: T) You can write it like this: func feed(_ animal: some Animal) Deep down, these are exactly the same thing. Declaring a parameter as some Type is simply a syntax sugar for declaring an empty generic constraint clause. Despite not being a ground-breaking feature, this is a very welcome change as generic methods with several parameters tended to become borderline unreadable. Note: This is not to be confused with Swift 5.1's Opaque Return Types feature. Despite using the same keyword and behaving relatively similarly, they are different features that work in very different ways. Primary Associated Types Starting on Swift 5.7, you can now declare one or more of your protocol's associated types as its primary associated types by adding them between angle brackets in the protocol's declaration: protocol Sequence { // Element is now a primary associated type associatedtype Element associatedtype Iterator } This has two purposes. The first one is that it gives you a very welcome syntax sugar when declaring generic constraints just like the one we saw in the Opaque Parameters section; instead of declaring ugly constraint clauses for that particular type like this: extension Sequence where Element == Int { func grabSomeNumbers() { ... } } // or func grabSomeNumbers(_ s: T) where T.Element == Int { ... } ...you are now able to inform this directly in the type! extension Sequence { func grabSomeNumbers() { } } // or func grabSomeNumbers(_ s: Sequence) { ... } In addition to doing this to your own types, you may find it interesting that many protocols of Swift's Standard Library have already been updated to declare primary associated types. The second and most ground-breaking purpose is that this is not restricted to extensions and methods; you can combine with the any keyword to declare type-erased, partially constrained stored properties: let intSequences: [any Sequence] This was previously unheard of in Swift as we were never allowed to define generic constraints in properties. I'm partially disappointed though that they didn't go to the full way to allow us to declare any type of constraint on the fly (like Sequence), but the proposal indicates that the existence of primary associated types does not prevent this from being potentially implemented in the future.",
  "author": "Bruno Rocha",
  "published": "Mon, 12 Sep 2022 14:00:00 GMT+2",
  "source": "https://swiftrocks.com/rss.xml",
  "categories": null,
  "byline": "Bruno Rocha",
  "length": 11988,
  "excerpt": "In this article, we'll explain the concept of type erasure, how it used to be done, what's different in Swift 5.7, and how these changes work under the hood.",
  "siteName": "SwiftRocks",
  "favicon": "https://swiftrocks.com/images/favicon/iconsmall2.png",
  "text": "The concept of Type Erasure is not new to Swift, but was radically improved in Swift 5.7 with the addition of the any prefix keyword (not to be confused with the capitalized Any type!) and improvements to the already existing some Opaque Type keyword. In this article, we'll explain the concept of type erasure, how it used to be done, what's different in Swift 5.7, and how these changes work under the hood. What the hell is Type Erasure? In programming languages with support for generic types, Type Erasure is the process of abstracting constrained generic types inside an unconstrained non-generic type that can be passed around freely. If you don't know why that's necessary, consider the following example where we define a protocol and a few conforming types: protocol Shape {} struct Circle: Shape {} struct Triangle: Shape {} Because the Shape protocol is unconstrained, Swift allows us to quite easily refer to Circle and Triangle as their bare conformances: var userShapes = [Shape]() func userDidCreate(shape: Shape) userShapes.append(shape) } userDidCreate(shape: Circle()) userDidCreate(shape: Triangle()) // No problems will arise here. It's fine to refer to these types as just \"Shape\". This will not be the case if the protocol has generic requirements. If the protocol has, for example, associated types that each underlying type provides on its own, Swift will strictly forbid you from referring to this protocol if you're also not providing appropriate generic constraints: protocol Sequence { associatedtype Element } var sequences = [Sequence]() // Can't do! // Error: Protocol 'Sequence' can only be used as a generic constraint // because it has Self or associated type requirements The reason you can't do this is that Swift is designed to be a type-safe language. Even though the compiler has no problem determining the underlying type of a Sequence type in the previous snippet, Swift has these features in order to allow you to ship safer products (runtime-wise). Think of access control properties like public and private; they are good examples of concepts that have absolutely no impact on the final binary. In the end, everything is accessible from everywhere, but inside your IDE, the compiler forces access control conventions to be followed so at the very least you are able to write code that is used the way you intended it to be used. The issue here with generic constraints is similar. The compiler does know what the underlying type of a particular generic protocol is in runtime, but because Swift is designed to be type-safe, for safety reasons, if it can't be determined in compile time, it will not let you do it. This is the complete opposite of Objective-C where you could easily do whatever you wanted for the (very big) cost of runtime safety. Before Swift 5.7, the solution to this problem was to box these objects into unconstrained and generally unsafe \"Any\" variations of their protocols, like this: class AnySequence { let value: Any init\u003cT: Sequence\u003e(_ sequence: T) { self.value = shape } } This process is called type erasure, and the Swift standard library itself contains many such objects. There are many situations in Swift where you'd need to do this, and one of them was covered in our 2020 article on how to use type erasure to build a dependency injection system. In general, you'll find yourself needing to type erase a protocol with generic requirements whenever you're in a situation where knowing the actual constraints of said protocols are irrelevant. After Swift 5.7: Enter \"any\" As far as I'm aware, this process was widely disliked by the Swift community. Not only it was a symptom of a design mistake in the language, but the process itself was also quite unsafe as it often involved the extensive usage of force-unwrapping (due to the need of referring to everything as Any). This has changed in Swift 5.7. With the addition of the new any existential type keyword, type erasure is now a feature of the Swift compiler. You do not need to create your own \"AnyMyType\" abstraction anymore; by adding any before a type, the Swift compiler will now automatically abstract it for you. While I like to call these \"type-erased values\" for simplicity, you should know that the proper terminology for referring to a value as an abstract representation is existential type. let erased: any Sequence = MyConcreteSequenceType() This also means that the old \"protocol can only be used as a generic constraint\" error has changed. In Swift 5.7, trying to use such protocols without their constraints will now make the compiler prompt you to refer to it as an existential. let erased: Sequence = MyConcreteSequenceType() // Error: Use of protocol 'Sequence' as a type must be written 'any Sequence' Type-safety of \"any\" One amazing benefit of this new keyword is that unlike manual type-erasure, using the new any keyword is type-safe. While before Swift 5.7 you generally had to force-unwrap your type-erased values in order to \"unbox\" them and access their constraints (and hope you didn't get anything wrong), the Swift 5.7 compiler will watch your back and prevent you from making mistakes. The way in which you achieve this is a bit tricky though, so I've modified an example from WWDC 2022's session about the feature to clarify it. Let's assume that we have a Animal protocol that defines a generic food type and a method to feed said food. We also have a FoodProvider protocol that is able to provide said food. protocol Animal { associatedtype Food func eat(_ food: Food) } protocol FoodProvider { func getFood\u003cT: Animal\u003e(for animal: T) -\u003e T.Food } Let's now pretend that we have a helper method that receives a group of animals and tries to feed all of them. Because the particular type of animal doesn't matter to us in this scenario, we want to do so without declaring any generic constraints. func feedAll(_ animals: [Animal], provider: FoodProvider) { animals.forEach { let food = provider.getFood(for: $0) $0.eat(food) } } As you might expect after reading this article, the existence of an associated type will make Swift prevent us from doing that. Before Swift 5.7, the solution to this was generally to create a AnyAnimal type and abstract these actions under unsafe closures powered by force-unwrapping: final class AnyAnimal { var getFood: (FoodProvider) -\u003e Any var eatFood: (Any) -\u003e Void init\u003cT: Animal\u003e(_ animal: T) { self.getFood = { provider in provider.getFood(for: animal) } self.eatFood = { food in animal.eat(food as! T.Food) } } } func feedAll(_ animals: [AnyAnimal], provider: FoodProvider) { animals.forEach { let food = $0.getFood(provider) $0.eatFood(food) } } While this solution will work for this case, it's not safe as you could quite easily pass the wrong food type to the erased value and cause a crash. Swift 5.7's any keyword solves this problem by enforcing complete type-safety on any existential value, but there's a small catch (Note: This refers to a limitation of Swift 5.7. If you're reading this in the future, this might not be the case anymore.). While Swift will freely allow you to call any unconstrained methods of the existential type, attempting to use any constrained methods can prove to be a bit challenging: func feedAll(_ animals: [any Animal], provider: FoodProvider) { animals.forEach { let food = provider.getFood(for: $0) $0.eat(food) // Member 'eat' cannot be used on value of type 'any Animal' } } Even though the naked eye might tell you that the output of getFood(_:) definitely matches the input of getFood(_:), Swift will not allow you to call any methods involving generic parameters unless you first explicitly \"unbox\" the existential by passing it to a generic method that receives a non-erased value (with no constraints): func feedAll(_ animals: [any Animal], provider: FoodProvider) { animals.forEach { feed($0, provider: provider) // Now works! } } func feed\u003cT: Animal\u003e(_ animal: T, provider: FoodProvider) { let food = provider.getFood(for: animal) animal.eat(food) } I thought this seemed like a pointless step since they're both doing the same thing, so I asked about it on the official Swift Forums and it turns out that this is indeed a limitation of Swift 5.7. To be more specific, the proposal that introduced the ability to \"unbox\" existential types in a type-safe manner has a negative side-effect that makes the compiler \"lose\" information about a particular existential outside of said \"unboxing\" contexts. You can read more about it in the proposal. It's important to keep in mind though that the any keyword doesn't replace all cases in which you'd need to erase generic types. While it takes care of the basic case of hiding a type's constraints, more special cases such as transforming constraints (like in our tutorial about it) still require you to go with the manual approach for the time being. Supporting Features Despite not being directly related to the concept of type erasure, Swift 5.7 comes with some additional features that greatly empower it. Let's check them out. Opaque Parameters One thing we mentioned is the necessity of \"unboxing\" existentials by writing empty generic clauses. These empty clauses are very common even outside type erasure, and were improved in Swift 5.7 by the addition of the new Opaque Parameters feature. Now, instead of writing this: func feed\u003cT: Animal\u003e(_ animal: T) You can write it like this: func feed(_ animal: some Animal) Deep down, these are exactly the same thing. Declaring a parameter as some Type is simply a syntax sugar for declaring an empty generic constraint clause. Despite not being a ground-breaking feature, this is a very welcome change as generic methods with several parameters tended to become borderline unreadable. Note: This is not to be confused with Swift 5.1's Opaque Return Types feature. Despite using the same keyword and behaving relatively similarly, they are different features that work in very different ways. Primary Associated Types Starting on Swift 5.7, you can now declare one or more of your protocol's associated types as its primary associated types by adding them between angle brackets in the protocol's declaration: protocol Sequence\u003cElement\u003e { // Element is now a primary associated type associatedtype Element associatedtype Iterator } This has two purposes. The first one is that it gives you a very welcome syntax sugar when declaring generic constraints just like the one we saw in the Opaque Parameters section; instead of declaring ugly constraint clauses for that particular type like this: extension Sequence where Element == Int { func grabSomeNumbers() { ... } } // or func grabSomeNumbers\u003cT: Sequence\u003e(_ s: T) where T.Element == Int { ... } ...you are now able to inform this directly in the type! extension Sequence\u003cInt\u003e { func grabSomeNumbers() { } } // or func grabSomeNumbers(_ s: Sequence\u003cInt\u003e) { ... } In addition to doing this to your own types, you may find it interesting that many protocols of Swift's Standard Library have already been updated to declare primary associated types. The second and most ground-breaking purpose is that this is not restricted to extensions and methods; you can combine with the any keyword to declare type-erased, partially constrained stored properties: let intSequences: [any Sequence\u003cInt\u003e] This was previously unheard of in Swift as we were never allowed to define generic constraints in properties. I'm partially disappointed though that they didn't go to the full way to allow us to declare any type of constraint on the fly (like Sequence\u003cwhere Element == String, Iterator = MyIterator\u003e), but the proposal indicates that the existence of primary associated types does not prevent this from being potentially implemented in the future.",
  "image": "https://swiftrocks.com/images/thumbs/thumb.jpg?4",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \n  \n\u003cp\u003eThe concept of \u003cb\u003eType Erasure\u003c/b\u003e is not new to Swift, but was radically improved in Swift 5.7 with the addition of the \u003ccode\u003eany\u003c/code\u003e prefix keyword (not to be confused with the capitalized \u003ccode\u003eAny\u003c/code\u003e type!) and improvements to the already existing \u003ccode\u003esome\u003c/code\u003e \u003cb\u003eOpaque Type\u003c/b\u003e keyword. In this article, we\u0026#39;ll explain the concept of type erasure, how it used to be done, what\u0026#39;s different in Swift 5.7, and how these changes work under the hood.\u003c/p\u003e\n\u003ch2\u003eWhat the hell is Type Erasure?\u003c/h2\u003e\n\u003cp\u003eIn programming languages with support for generic types, \u003cb\u003eType Erasure\u003c/b\u003e is the process of abstracting constrained generic types inside an \u003cb\u003eunconstrained non-generic type\u003c/b\u003e that can be passed around freely.\u003c/p\u003e\n\n\u003cp\u003eIf you don\u0026#39;t know why that\u0026#39;s necessary, consider the following example where we define a protocol and a few conforming types:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprotocol Shape {}\u003c/code\u003e\n\u003ccode\u003estruct Circle: Shape {}\u003c/code\u003e\n\u003ccode\u003estruct Triangle: Shape {}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eBecause the \u003ccode\u003eShape\u003c/code\u003e protocol is \u003cb\u003eunconstrained\u003c/b\u003e, Swift allows us to quite easily refer to \u003ccode\u003eCircle\u003c/code\u003e and \u003ccode\u003eTriangle\u003c/code\u003e as their bare conformances:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar userShapes = [Shape]()\u003c/code\u003e\n\u003ccode\u003efunc userDidCreate(shape: Shape)\u003c/code\u003e\n\u003ccode\u003e    userShapes.append(shape)\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003ccode\u003euserDidCreate(shape: Circle())\u003c/code\u003e\n\u003ccode\u003euserDidCreate(shape: Triangle())\u003c/code\u003e\n\u003ccode\u003e// No problems will arise here. It\u0026#39;s fine to refer to these types as just \u0026#34;Shape\u0026#34;.\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eThis will \u003cb\u003enot\u003c/b\u003e be the case if the protocol has generic requirements. If the protocol has, for example, associated types that each underlying type provides on its own, Swift will strictly forbid you from referring to this protocol if you\u0026#39;re also not providing appropriate generic constraints:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprotocol Sequence {\u003c/code\u003e\n\u003ccode\u003e    associatedtype Element\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003ccode\u003evar sequences = [Sequence]() // Can\u0026#39;t do!\u003c/code\u003e\n\u003ccode\u003e// Error: Protocol \u0026#39;Sequence\u0026#39; can only be used as a generic constraint\u003c/code\u003e\n\u003ccode\u003e// because it has Self or associated type requirements\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eThe reason you can\u0026#39;t do this is that Swift is designed to be a \u003cb\u003etype-safe\u003c/b\u003e language. Even though the compiler has no problem determining the underlying type of a \u003ccode\u003eSequence\u003c/code\u003e type in the previous snippet, Swift has these features in order to allow you to ship safer products (runtime-wise). Think of access control properties like public and private; they are good examples of concepts that have absolutely no impact on the final binary. In the end, everything is accessible from everywhere, but inside your IDE, the compiler forces access control conventions to be followed so at the very least you are able to write code that is used the way you intended it to be used.\u003c/p\u003e\n\u003cp\u003eThe issue here with generic constraints is similar. The compiler does know what the underlying type of a particular generic protocol is in runtime, but because Swift is designed to be type-safe, for safety reasons, if it can\u0026#39;t be determined in compile time, it will not let you do it. This is the complete opposite of Objective-C where you could easily do whatever you wanted for the (very big) cost of runtime safety.\u003c/p\u003e\n\u003cp\u003eBefore Swift 5.7, the solution to this problem was to box these objects into \u003cb\u003eunconstrained\u003c/b\u003e and generally unsafe \u0026#34;Any\u0026#34; variations of their protocols, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass AnySequence {\u003c/code\u003e\n\u003ccode\u003e    let value: Any\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e    init\u0026lt;T: Sequence\u0026gt;(_ sequence: T) {\u003c/code\u003e\n\u003ccode\u003e        self.value = shape\u003c/code\u003e\n\u003ccode\u003e    }\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eThis process is called \u003cb\u003etype erasure\u003c/b\u003e, and the Swift standard library itself contains many such objects. There are many situations in Swift where you\u0026#39;d need to do this, and one of them was covered in \u003ca href=\"https://swiftrocks.com/using-type-erasure-to-build-a-dependency-injector-in-swift\"\u003eour 2020 article on how to use type erasure to build a dependency injection system.\u003c/a\u003e In general, you\u0026#39;ll find yourself needing to type erase a protocol with generic requirements whenever you\u0026#39;re in a situation where knowing the actual constraints of said protocols are irrelevant.\u003c/p\u003e\n\u003ch2\u003eAfter Swift 5.7: Enter \u0026#34;any\u0026#34;\u003c/h2\u003e\n\u003cp\u003eAs far as I\u0026#39;m aware, this process was widely disliked by the Swift community. Not only it was a symptom of a design mistake in the language, but the process itself was also quite unsafe as it often involved the extensive usage of force-unwrapping (due to the need of referring to everything as \u003ccode\u003eAny\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eThis has changed in Swift 5.7. With the addition of the new \u003ccode\u003eany\u003c/code\u003e \u003ci\u003eexistential type\u003c/i\u003e keyword, \u003cb\u003etype erasure is now a feature of the Swift compiler\u003c/b\u003e. You do not need to create your own \u0026#34;AnyMyType\u0026#34; abstraction anymore; by adding \u003ccode\u003eany\u003c/code\u003e before a type, the Swift compiler will now automatically abstract it for you. While I like to call these \u0026#34;type-erased values\u0026#34; for simplicity, you should know that the proper terminology for referring to a value as an abstract representation is \u003cb\u003eexistential type\u003c/b\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet erased: any Sequence = MyConcreteSequenceType()\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eThis also means that the old \u0026#34;protocol can only be used as a generic constraint\u0026#34; error has changed. In Swift 5.7, trying to use such protocols without their constraints will now make the compiler prompt you to refer to it as an existential.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet erased: Sequence = MyConcreteSequenceType()\u003c/code\u003e\n\u003ccode\u003e// Error: Use of protocol \u0026#39;Sequence\u0026#39; as a type must be written \u0026#39;any Sequence\u0026#39;\u003c/code\u003e\n\u003c/pre\u003e\n\u003ch3\u003eType-safety of \u0026#34;any\u0026#34;\u003c/h3\u003e\n\u003cp\u003eOne amazing benefit of this new keyword is that unlike manual type-erasure, \u003cb\u003eusing the new \u003ccode\u003eany\u003c/code\u003e keyword is type-safe.\u003c/b\u003e While before Swift 5.7 you generally had to force-unwrap your type-erased values in order to \u0026#34;unbox\u0026#34; them and access their constraints (and hope you didn\u0026#39;t get anything wrong), the Swift 5.7 compiler will watch your back and prevent you from making mistakes. The way in which you achieve this is a bit tricky though, so I\u0026#39;ve modified an example from WWDC 2022\u0026#39;s session about the feature to clarify it.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s assume that we have a \u003ccode\u003eAnimal\u003c/code\u003e protocol that defines a generic food type and a method to feed said food. We also have a \u003ccode\u003eFoodProvider\u003c/code\u003e protocol that is able to provide said food.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprotocol Animal {\u003c/code\u003e\n\u003ccode\u003e    associatedtype Food\u003c/code\u003e\n\u003ccode\u003e    func eat(_ food: Food)\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eprotocol FoodProvider {\u003c/code\u003e\n\u003ccode\u003e    func getFood\u0026lt;T: Animal\u0026gt;(for animal: T) -\u0026gt; T.Food\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eLet\u0026#39;s now pretend that we have a helper method that receives a group of animals and tries to feed all of them. Because the particular type of animal doesn\u0026#39;t matter to us in this scenario, we want to do so without declaring any generic constraints.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc feedAll(_ animals: [Animal], provider: FoodProvider) {\u003c/code\u003e\n\u003ccode\u003e    animals.forEach {\u003c/code\u003e\n\u003ccode\u003e        let food = provider.getFood(for: $0)\u003c/code\u003e\n\u003ccode\u003e        $0.eat(food)\u003c/code\u003e\n\u003ccode\u003e    }\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eAs you might expect after reading this article, the existence of an associated type will make Swift prevent us from doing that. Before Swift 5.7, the solution to this was generally to create a \u003ccode\u003eAnyAnimal\u003c/code\u003e type and abstract these actions under unsafe closures powered by force-unwrapping:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efinal class AnyAnimal {\u003c/code\u003e\n\u003ccode\u003e    var getFood: (FoodProvider) -\u0026gt; Any\u003c/code\u003e\n\u003ccode\u003e    var eatFood: (Any) -\u0026gt; Void\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e    init\u0026lt;T: Animal\u0026gt;(_ animal: T) {\u003c/code\u003e\n\u003ccode\u003e        self.getFood = { provider in\u003c/code\u003e\n\u003ccode\u003e            provider.getFood(for: animal)\u003c/code\u003e\n\u003ccode\u003e        }\u003c/code\u003e\n\u003ccode\u003e        self.eatFood = { food in\u003c/code\u003e\n\u003ccode\u003e            animal.eat(food as! T.Food)\u003c/code\u003e\n\u003ccode\u003e        }\u003c/code\u003e\n\u003ccode\u003e    }\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003efunc feedAll(_ animals: [AnyAnimal], provider: FoodProvider) {\u003c/code\u003e\n\u003ccode\u003e    animals.forEach {\u003c/code\u003e\n\u003ccode\u003e        let food = $0.getFood(provider)\u003c/code\u003e\n\u003ccode\u003e        $0.eatFood(food)\u003c/code\u003e\n\u003ccode\u003e    }\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eWhile this solution will work for this case, it\u0026#39;s not safe as you could quite easily pass the wrong food type to the erased value and cause a crash. Swift 5.7\u0026#39;s \u003ccode\u003eany\u003c/code\u003e keyword solves this problem by enforcing complete type-safety on any existential value, but there\u0026#39;s a small catch \u003ci\u003e(Note: This refers to a limitation of Swift 5.7. If you\u0026#39;re reading this in the future, this might not be the case anymore.)\u003c/i\u003e. While Swift will freely allow you to call any unconstrained methods of the existential type, attempting to use any constrained methods can prove to be a bit challenging:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc feedAll(_ animals: [any Animal], provider: FoodProvider) {\u003c/code\u003e\n\u003ccode\u003e    animals.forEach {\u003c/code\u003e\n\u003ccode\u003e        let food = provider.getFood(for: $0)\u003c/code\u003e\n\u003ccode\u003e        $0.eat(food) // Member \u0026#39;eat\u0026#39; cannot be used on value of type \u0026#39;any Animal\u0026#39;\u003c/code\u003e\n\u003ccode\u003e    }\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eEven though the naked eye might tell you that the output of \u003ccode\u003egetFood(_:)\u003c/code\u003e definitely matches the input of \u003ccode\u003egetFood(_:)\u003c/code\u003e, Swift will not allow you to call any methods involving generic parameters unless you first explicitly \u0026#34;unbox\u0026#34; the existential by passing it to a generic method that receives a non-erased value (with no constraints):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc feedAll(_ animals: [any Animal], provider: FoodProvider) {\u003c/code\u003e\n\u003ccode\u003e    animals.forEach {\u003c/code\u003e\n\u003ccode\u003e        feed($0, provider: provider) // Now works!\u003c/code\u003e\n\u003ccode\u003e    }\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003efunc feed\u0026lt;T: Animal\u0026gt;(_ animal: T, provider: FoodProvider) {\u003c/code\u003e\n\u003ccode\u003e    let food = provider.getFood(for: animal)\u003c/code\u003e\n\u003ccode\u003e    animal.eat(food)\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eI thought this seemed like a pointless step since they\u0026#39;re both doing the same thing, so I asked about it on the official Swift Forums and it turns out that this is indeed a limitation of Swift 5.7. To be more specific, the proposal that introduced the ability to \u0026#34;unbox\u0026#34; existential types in a type-safe manner has a negative side-effect that makes the compiler \u0026#34;lose\u0026#34; information about a particular existential outside of said \u0026#34;unboxing\u0026#34; contexts. \u003ca href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0352-implicit-open-existentials.md#losing-constraints-when-type-erasing-resulting-values\"\u003eYou can read more about it in the proposal.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s important to keep in mind though that the \u003ccode\u003eany\u003c/code\u003e keyword doesn\u0026#39;t replace all cases in which you\u0026#39;d need to erase generic types. While it takes care of the basic case of hiding a type\u0026#39;s constraints, more special cases such as \u003cb\u003etransforming\u003c/b\u003e constraints (\u003ca href=\"https://swiftrocks.com/using-type-erasure-to-build-a-dependency-injector-in-swift\"\u003elike in our tutorial about it\u003c/a\u003e) still require you to go with the manual approach for the time being.\u003c/p\u003e\n\u003ch2\u003eSupporting Features\u003c/h2\u003e\n\u003cp\u003eDespite not being directly related to the concept of type erasure, Swift 5.7 comes with some additional features that greatly empower it. Let\u0026#39;s check them out.\u003c/p\u003e\n\u003ch3\u003eOpaque Parameters\u003c/h3\u003e\n\u003cp\u003eOne thing we mentioned is the necessity of \u0026#34;unboxing\u0026#34; existentials by writing empty generic clauses. These empty clauses are very common even outside type erasure, and were improved in Swift 5.7 by the addition of the new \u003cb\u003eOpaque Parameters\u003c/b\u003e feature. Now, instead of writing this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc feed\u0026lt;T: Animal\u0026gt;(_ animal: T)\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eYou can write it like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc feed(_ animal: some Animal)\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eDeep down, these are exactly the same thing. Declaring a parameter as \u003ccode\u003esome Type\u003c/code\u003e is simply a syntax sugar for declaring an empty generic constraint clause. Despite not being a ground-breaking feature, this is a very welcome change as generic methods with several parameters tended to become borderline unreadable.\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eNote: This is not to be confused with Swift 5.1\u0026#39;s \u003ca href=\"https://swiftrocks.com/understanding-opaque-return-types-in-swift\"\u003eOpaque Return Types\u003c/a\u003e feature.\u003c/b\u003e Despite using the same keyword and behaving relatively similarly, they are different features that work in very different ways.\u003c/p\u003e\n\u003ch3\u003ePrimary Associated Types\u003c/h3\u003e\n\u003cp\u003eStarting on Swift 5.7, you can now declare one or more of your protocol\u0026#39;s associated types as its \u003cb\u003eprimary associated types\u003c/b\u003e by adding them between angle brackets in the protocol\u0026#39;s declaration:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprotocol Sequence\u0026lt;Element\u0026gt; { // Element is now a primary associated type\u003c/code\u003e\n\u003ccode\u003e    associatedtype Element\u003c/code\u003e\n\u003ccode\u003e    associatedtype Iterator\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eThis has two purposes. The first one is that it gives you a very welcome syntax sugar when declaring generic constraints just like the one we saw in the Opaque Parameters section; instead of declaring ugly constraint clauses for that particular type like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eextension Sequence where Element == Int {\u003c/code\u003e\n\u003ccode\u003e    func grabSomeNumbers() { ... }\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e// or\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003efunc grabSomeNumbers\u0026lt;T: Sequence\u0026gt;(_ s: T) where T.Element == Int { ... }\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e...you are now able to inform this directly in the type!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eextension Sequence\u0026lt;Int\u0026gt; {\u003c/code\u003e\n\u003ccode\u003e    func grabSomeNumbers() { }\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e// or\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003efunc grabSomeNumbers(_ s: Sequence\u0026lt;Int\u0026gt;) { ... }\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eIn addition to doing this to your own types, you may find it interesting that many protocols of Swift\u0026#39;s Standard Library have already been updated to declare primary associated types.\u003c/p\u003e\n\u003cp\u003eThe second and most ground-breaking purpose is that this is not restricted to extensions and methods; you can combine with the \u003ccode\u003eany\u003c/code\u003e keyword to \u003cb\u003edeclare type-erased, partially constrained stored properties:\u003c/b\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet intSequences: [any Sequence\u0026lt;Int\u0026gt;]\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eThis was previously unheard of in Swift as we were never allowed to define generic constraints in properties. I\u0026#39;m partially disappointed though that they didn\u0026#39;t go to the full way to allow us to declare any type of constraint on the fly (like \u003ccode\u003eSequence\u0026lt;where Element == String, Iterator = MyIterator\u0026gt;\u003c/code\u003e), but the proposal indicates that the existence of primary associated types does not prevent this from being potentially implemented in the future.\u003c/p\u003e\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2022-09-12T14:00:00+02:00",
  "modifiedTime": null
}
