{
  "id": "0b7354ef-ec5e-4b0d-8c64-04bfce990e97",
  "title": "Deep linking and URL scheme in iOS",
  "link": "https://benoitpasquier.com/deep-linking-url-scheme-ios/",
  "description": "Opening an app from an URL is such a powerful iOS feature. Its drives users to your app, and can create shortcuts to specific features. This week, we’ll dive into deep linking on iOS and how to create an URL scheme for your app.",
  "author": "",
  "published": "Sun, 13 Feb 2022 01:00:00 +0000",
  "source": "https://benoitpasquier.com/index.xml",
  "categories": null,
  "byline": "Benoit Pasquier",
  "length": 10113,
  "excerpt": "Opening an app from an URL is such a powerful iOS feature. Its drives users to your app, and can create shortcuts to specific features. This week, we’ll dive into deep linking on iOS and how to create an URL scheme for your app.",
  "siteName": "Benoit Pasquier",
  "favicon": "https://benoitpasquier.com/favicon.png",
  "text": "February 13, 2022 in Mobile Opening an app from an URL is such a powerful iOS feature. Its drives users to your app, and can create shortcuts to specific features. This week, we’ll dive into deep linking on iOS and how to create an URL scheme for your app. When we talk about deep linking for mobile app, it means creating a specific URL to open a mobile application. It separate into two formats: a custom URL scheme that your app registers: scheme://videos a universal link that opens your app from a registered domain: mydomain.com/videos Today, we’ll focus on the former one. I’ll mostly focus on the code for an UIKit implementation but I’ll also briefly cover SwiftUI one if that’s what you’re looking for too. Setting up URL Scheme Setting up an custom URL scheme for iOS is same regardless you are using SwiftUI or UIKit. In Xcode, under your project configuration, select your target and navigates to Info tab. You’ll see an URL Types section at the bottom. Clicking +, I can create a new type. For the identifier, I often reuse the app bundle. For the URL Schemes, I would suggest to use the app name (or shortened) to be as short as possible. It shouldn’t include any custom character. For the example, I’ll use deeplink. That’s it. The app is ready to recognize the new URL, now we need to handle it when we receive one. SwiftUI deep linking. If you don’t have any AppDelegate and SceneDelegate files, which is most of the case for SwiftUI implementation, we don’t have much work to do. In the App implementation, we can capture the url open from onOpenURL(perform:) action. import SwiftUI @main struct DeeplinkSampleApp: App { var body: some Scene { WindowGroup { ContentView() .onOpenURL { url in print(url.absoluteString) } } } } To test it, I can install the app on a simulator and launch the given url from the Terminal app xcrun simctl openurl booted \"deeplink://test\" Pretty cool! Let’s look how UIKit implementation is different. UIKit deep link On paper, UIKit or SwiftUI shouldn’t make a difference in the way we handle deep linking. However, it mostly falls down to having an AppDelegate or SceneDelegate which are more common for UIKit apps. For older apps that only have AppDelegate, the app captures the deeplink opening from the following method. extension AppDelegate { func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any]) -\u003e Bool { print(url.absolueString) return true } } The function return a Boolean if the app can handle that given url. For newer apps that includes SceneDelegate, the callback will be there. It’s important to note that the AppDelegate won’t get called, even if you implement it. extension SceneDelegate { func scene(_ scene: UIScene, openURLContexts URLContexts: Set\u003cUIOpenURLContext\u003e) { guard let firstUrl = URLContexts.first?.url else { return } print(firstUrl.absoluteString) } } In this implementation, we can notice we don’t need anymore to return any result. However, the parameter passed is now a Set\u003c\u003e and not just a URL anymore, it’s to open one or more URLs. I don’t have a use-case where we would have more than URL so I’ll just keep one for the moment. The same way as earlier, we can install the app on our simulator and try to see if all is setup correctly. We should see print our deeplink URL. xcrun simctl openurl booted \"deeplink://test\" Once it’s setup, the idea is to create routes to identify and open the right screen. Let’s dive in. Deeplink handler implementations The idea is pretty simple, for a given link, we need to identify what user journey or screen we should open. Since they can be many features across the app, and because we want to avoid a massive switch case to handle it, we’ll be smarter and divide to conquer. For this example, let’s image we have a video editing app. They are 3 main tabs, to edit a new video, to list the videos edited, then an account page with different app and user information. We can think of three main paths deeplink://videos/new - start a new video edition journey deeplink://videos - lands on videos listing tab screen deeplink://account - lands on account screen First, I’ll create a protocol of deeplink handler to define the minimum requirements of any new handlers. protocol DeeplinkHandlerProtocol { func canOpenURL(_ url: URL) -\u003e Bool func openURL(_ url: URL) } I will also define a DeeplinkCoordinator that will holds on the handlers and find the right one to use. It also returns a Boolean like the AppDelegate has, so we can use in different implementations. protocol DeeplinkCoordinatorProtocol { @discardableResult func handleURL(_ url: URL) -\u003e Bool } final class DeeplinkCoordinator { let handlers: [DeeplinkHandlerProtocol] init(handlers: [DeeplinkHandlerProtocol]) { self.handlers = handlers } } extension DeeplinkCoordinator: DeeplinkCoordinatorProtocol { @discardableResult func handleURL(_ url: URL) -\u003e Bool{ guard let handler = handlers.first(where: { $0.canOpenURL(url) }) else { return false } handler.openURL(url) return true } } Now we can define separate handlers, one for each different path. Let’s start first with the Account journey, the simplest one. final class AccountDeeplinkHandler: DeeplinkHandlerProtocol { private weak var rootViewController: UIViewController? init(rootViewController: UIViewController?) { self.rootViewController = rootViewController } // MARK: - DeeplinkHandlerProtocol func canOpenURL(_ url: URL) -\u003e Bool { return url.absoluteString == \"deeplink://account\" } func openURL(_ url: URL) { guard canOpenURL(url) else { return } // mock the navigation let viewController = UIViewController() viewController.title = \"Account\" viewController.view.backgroundColor = .yellow rootViewController?.present(viewController, animated: true) } } To keep it simple, I only test for the matching url and navigate to the right screen. I also set a background color to see what is my landing. In your case, we can just set the right UIViewController rather than an empty one. I will do the same for the different video journeys. final class VideoDeeplinkHandler: DeeplinkHandlerProtocol { private weak var rootViewController: UIViewController? init(rootViewController: UIViewController?) { self.rootViewController = rootViewController } // MARK: - DeeplinkHandlerProtocol func canOpenURL(_ url: URL) -\u003e Bool { return url.absoluteString.hasPrefix(\"deeplink://videos\") } func openURL(_ url: URL) { guard canOpenURL(url) else { return } // mock the navigation let viewController = UIViewController() switch url.path { case \"/new\": viewController.title = \"Video Editing\" viewController.view.backgroundColor = .orange default: viewController.title = \"Video Listing\" viewController.view.backgroundColor = .cyan } rootViewController?.present(viewController, animated: true) } } Now we can inject them into the DeeplinkCoordinator and let it handle the right route. We’ll have two variations, the first one for AppDelegate. class AppDelegate: UIResponder, UIApplicationDelegate { lazy var deeplinkCoordinator: DeeplinkCoordinatorProtocol = { return DeeplinkCoordinator(handlers: [ AccountDeeplinkHandler(rootViewController: self.rootViewController), VideoDeeplinkHandler(rootViewController: self.rootViewController) ]) } var rootViewController: UIViewController? { return window?.rootViewController } // ... func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any]) -\u003e Bool { return deeplinkCoordinator.handleURL(url) } } And the second one for the SceneDelegate class SceneDelegate: UIResponder, UIWindowSceneDelegate { lazy var deeplinkCoordinator: DeeplinkCoordinatorProtocol = { return DeeplinkCoordinator(handlers: [ AccountDeeplinkHandler(rootViewController: self.rootViewController), VideoDeeplinkHandler(rootViewController: self.rootViewController) ]) }() var rootViewController: UIViewController? { return window?.rootViewController } // ... func scene(_ scene: UIScene, openURLContexts URLContexts: Set\u003cUIOpenURLContext\u003e) { guard let firstUrl = URLContexts.first?.url else { return } deeplinkCoordinator.handleURL(firstUrl) } We can test it again the same way we did so far, hoping to land on the right screen (expecting orange background). xcrun simctl openurl booted \"deeplink://videos/new\" To summarize, once the URL scheme was setup, we defined a funnel to capture all the deep links used to open the app and leveraged protocol oriented programming to create multiple implementations of handlers, one for each specific path. This implementation is extensible for newer path and can easily be unit tested to make sure each parts behaves as expected. That being said, there could be few improvements, like verifying full path rather than relative one, for safer behavior. The navigation only present but it’s to focus on the handler and not the transition itself. On a security note, if you also pass parameters within your deeplink, make sure to verify the type and values expected. It could expose different injection vulnerabilities if we’re not careful. From there, you should have a good understanding of how to use and handle deeplink to open your app and jump to a specific screen. This code is available on Github. Happy coding 🎉",
  "image": "https://benoitpasquier.com/images/2022/02/deep-linking-description.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \n    \n  \n  \n  \u003cp\u003e\u003ctime itemprop=\"datePublished\" datetime=\"2022-02-13T01:00:00Z\"\u003e\n        \n  February 13, 2022\n\n      \u003c/time\u003e\n    \n    \n  \n  \n    \u003cspan\u003ein\u003c/span\u003e\n    \n      \u003ca href=\"https://benoitpasquier.com/categories/mobile\"\u003eMobile\u003c/a\u003e\n    \n  \n\n  \u003c/p\u003e\n\n\u003c/div\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n              \u003cp\u003eOpening an app from an URL is such a powerful iOS feature. Its drives users to your app, and can create shortcuts to specific features. This week, we’ll dive into deep linking on iOS and how to create an URL scheme for your app.\u003c/p\u003e\n\u003cp\u003eWhen we talk about deep linking for mobile app, it means creating a specific URL to open a mobile application. It separate into two formats:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea custom URL scheme that your app registers: \u003ccode\u003escheme://videos\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ea \u003ca href=\"https://benoitpasquier.com/universal-links-ios/\"\u003euniversal link\u003c/a\u003e that opens your app from a registered domain: \u003ccode\u003emydomain.com/videos\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eToday, we’ll focus on the former one.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eI’ll mostly focus on the code for an UIKit implementation but I’ll also briefly cover SwiftUI one if that’s what you’re looking for too.\u003c/p\u003e\n\u003ch2 id=\"setting-up-url-scheme\"\u003eSetting up URL Scheme\u003c/h2\u003e\n\u003cp\u003eSetting up an custom URL scheme for iOS is same regardless you are using SwiftUI or UIKit. In Xcode, under your project configuration, select your target and navigates to \u003cem\u003eInfo\u003c/em\u003e tab. You’ll see an \u003ccode\u003eURL Types\u003c/code\u003e section at the bottom.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2022/02/deep-linking-url-scheme.png\" alt=\"deep-linking-url-scheme\"/\u003e\u003c/p\u003e\n\u003cp\u003eClicking \u003ccode\u003e+\u003c/code\u003e, I can create a new type. For the identifier, I often reuse the app bundle. For the URL Schemes, I would suggest to use the app name (or shortened) to be as short as possible. It shouldn’t include any custom character. For the example, I’ll use \u003ccode\u003edeeplink\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThat’s it.\u003c/em\u003e The app is ready to recognize the new URL, now we need to handle it when we receive one.\u003c/p\u003e\n\u003ch2 id=\"swiftui-deep-linking\"\u003eSwiftUI deep linking.\u003c/h2\u003e\n\u003cp\u003eIf you don’t have any \u003ccode\u003eAppDelegate\u003c/code\u003e and \u003ccode\u003eSceneDelegate\u003c/code\u003e files, which is most of the case for SwiftUI implementation, we don’t have much work to do.\u003c/p\u003e\n\u003cp\u003eIn the App implementation, we can capture the url open from \u003ccode\u003eonOpenURL(perform:)\u003c/code\u003e action.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eSwiftUI\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e@\u003cspan\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eDeeplinkSampleApp\u003c/span\u003e: \u003cspan\u003eApp\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eScene\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eWindowGroup\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eContentView\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                .\u003cspan\u003eonOpenURL\u003c/span\u003e { \u003cspan\u003eurl\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003eurl\u003c/span\u003e.\u003cspan\u003eabsoluteString\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTo test it, I can install the app on a simulator and launch the given url from the Terminal app\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"sh\"\u003e\u003cspan\u003e\u003cspan\u003excrun simctl openurl booted \u003cspan\u003e\u0026#34;deeplink://test\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cem\u003ePretty cool!\u003c/em\u003e Let’s look how UIKit implementation is different.\u003c/p\u003e\n\u003ch2 id=\"uikit-deep-link\"\u003eUIKit deep link\u003c/h2\u003e\n\u003cp\u003eOn paper, UIKit or SwiftUI shouldn’t make a difference in the way we handle deep linking. However, it mostly falls down to having an \u003ccode\u003eAppDelegate\u003c/code\u003e or \u003ccode\u003eSceneDelegate\u003c/code\u003e which are more common for UIKit apps.\u003c/p\u003e\n\u003cp\u003eFor older apps that only have \u003ccode\u003eAppDelegate\u003c/code\u003e, the app captures the deeplink opening from the following method.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eAppDelegate\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eapplication\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eapp\u003c/span\u003e: \u003cspan\u003eUIApplication\u003c/span\u003e, \u003cspan\u003eopen\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e: \u003cspan\u003eURL\u003c/span\u003e, \u003cspan\u003eoptions\u003c/span\u003e: [\u003cspan\u003eUIApplication\u003c/span\u003e.\u003cspan\u003eOpenURLOptionsKey\u003c/span\u003e: \u003cspan\u003eAny\u003c/span\u003e]) -\u0026gt; \u003cspan\u003eBool\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003eurl\u003c/span\u003e.\u003cspan\u003eabsolueString\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe function return a Boolean if the app can handle that given url.\u003c/p\u003e\n\u003cp\u003eFor newer apps that includes \u003ccode\u003eSceneDelegate\u003c/code\u003e, the callback will be there. It’s important to note that the \u003ccode\u003eAppDelegate\u003c/code\u003e won’t get called, even if you implement it.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eSceneDelegate\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003escene\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003escene\u003c/span\u003e: \u003cspan\u003eUIScene\u003c/span\u003e, \u003cspan\u003eopenURLContexts\u003c/span\u003e \u003cspan\u003eURLContexts\u003c/span\u003e: \u003cspan\u003eSet\u003c/span\u003e\u0026lt;\u003cspan\u003eUIOpenURLContext\u003c/span\u003e\u0026gt;) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003efirstUrl\u003c/span\u003e = \u003cspan\u003eURLContexts\u003c/span\u003e.\u003cspan\u003efirst\u003c/span\u003e?.\u003cspan\u003eurl\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003efirstUrl\u003c/span\u003e.\u003cspan\u003eabsoluteString\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIn this implementation, we can notice we don’t need anymore to return any result. However, the parameter passed is now a \u003ccode\u003eSet\u0026lt;\u0026gt;\u003c/code\u003e and not just a \u003ccode\u003eURL\u003c/code\u003e anymore, it’s to open one or more URLs. I don’t have a use-case where we would have more than URL so I’ll just keep one for the moment.\u003c/p\u003e\n\u003cp\u003eThe same way as earlier, we can install the app on our simulator and try to see if all is setup correctly. We should see print our deeplink URL.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"sh\"\u003e\u003cspan\u003e\u003cspan\u003excrun simctl openurl booted \u003cspan\u003e\u0026#34;deeplink://test\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eOnce it’s setup, the idea is to create \u003cem\u003eroutes\u003c/em\u003e to identify and open the right screen. \u003cem\u003eLet’s dive in.\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"deeplink-handler-implementations\"\u003eDeeplink handler implementations\u003c/h2\u003e\n\u003cp\u003eThe idea is pretty simple, for a given link, we need to identify what user journey or screen we should open. Since they can be many features across the app, and because we want to avoid a massive \u003ccode\u003eswitch case\u003c/code\u003e to handle it, we’ll be smarter and \u003cem\u003edivide to conquer.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eFor this example, let’s image we have a video editing app. They are 3 main tabs, to edit a new video, to list the videos edited, then an account page with different app and user information.\u003c/p\u003e\n\u003cp\u003eWe can think of three main paths\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edeeplink://videos/new\u003c/code\u003e - start a new video edition journey\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edeeplink://videos\u003c/code\u003e - lands on videos listing tab screen\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edeeplink://account\u003c/code\u003e - lands on account screen\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFirst, I’ll create a protocol of deeplink handler to define the minimum requirements of any new handlers.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eprotocol\u003c/span\u003e \u003cspan\u003eDeeplinkHandlerProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ecanOpenURL\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e: \u003cspan\u003eURL\u003c/span\u003e) -\u0026gt; \u003cspan\u003eBool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eopenURL\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e: \u003cspan\u003eURL\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI will also define a \u003ccode\u003eDeeplinkCoordinator\u003c/code\u003e that will holds on the handlers and find the right one to use. It also returns a Boolean like the \u003ccode\u003eAppDelegate\u003c/code\u003e has, so we can use in different implementations.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eprotocol\u003c/span\u003e \u003cspan\u003eDeeplinkCoordinatorProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    @\u003cspan\u003ediscardableResult\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ehandleURL\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e: \u003cspan\u003eURL\u003c/span\u003e) -\u0026gt; \u003cspan\u003eBool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eDeeplinkCoordinator\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ehandlers\u003c/span\u003e: [\u003cspan\u003eDeeplinkHandlerProtocol\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003ehandlers\u003c/span\u003e: [\u003cspan\u003eDeeplinkHandlerProtocol\u003c/span\u003e]) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003ehandlers\u003c/span\u003e = \u003cspan\u003ehandlers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eDeeplinkCoordinator\u003c/span\u003e: \u003cspan\u003eDeeplinkCoordinatorProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    @\u003cspan\u003ediscardableResult\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ehandleURL\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e: \u003cspan\u003eURL\u003c/span\u003e) -\u0026gt; \u003cspan\u003eBool\u003c/span\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ehandler\u003c/span\u003e = \u003cspan\u003ehandlers\u003c/span\u003e.\u003cspan\u003efirst\u003c/span\u003e(\u003cspan\u003ewhere\u003c/span\u003e: { \u003cspan\u003e$0\u003c/span\u003e.\u003cspan\u003ecanOpenURL\u003c/span\u003e(\u003cspan\u003eurl\u003c/span\u003e) }) \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e              \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ehandler\u003c/span\u003e.\u003cspan\u003eopenURL\u003c/span\u003e(\u003cspan\u003eurl\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow we can define separate handlers, one for each different path. Let’s start first with the Account journey, the simplest one.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eAccountDeeplinkHandler\u003c/span\u003e: \u003cspan\u003eDeeplinkHandlerProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003erootViewController\u003c/span\u003e: \u003cspan\u003eUIViewController\u003c/span\u003e?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003erootViewController\u003c/span\u003e: \u003cspan\u003eUIViewController\u003c/span\u003e?) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003erootViewController\u003c/span\u003e = \u003cspan\u003erootViewController\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// \u003c/span\u003e\u003cspan\u003eMARK:\u003c/span\u003e\u003cspan\u003e - DeeplinkHandlerProtocol\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ecanOpenURL\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e: \u003cspan\u003eURL\u003c/span\u003e) -\u0026gt; \u003cspan\u003eBool\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e.\u003cspan\u003eabsoluteString\u003c/span\u003e == \u003cspan\u003e\u0026#34;deeplink://account\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eopenURL\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e: \u003cspan\u003eURL\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003ecanOpenURL\u003c/span\u003e(\u003cspan\u003eurl\u003c/span\u003e) \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// mock the navigation\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eviewController\u003c/span\u003e = \u003cspan\u003eUIViewController\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eviewController\u003c/span\u003e.\u003cspan\u003etitle\u003c/span\u003e = \u003cspan\u003e\u0026#34;Account\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eviewController\u003c/span\u003e.\u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003ebackgroundColor\u003c/span\u003e = .\u003cspan\u003eyellow\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003erootViewController\u003c/span\u003e?.\u003cspan\u003epresent\u003c/span\u003e(\u003cspan\u003eviewController\u003c/span\u003e, \u003cspan\u003eanimated\u003c/span\u003e: \u003cspan\u003etrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTo keep it simple, I only test for the matching url and navigate to the right screen.\nI also set a background color to see what is my landing. In your case, we can just set the right \u003ccode\u003eUIViewController\u003c/code\u003e rather than an empty one.\u003c/p\u003e\n\u003cp\u003eI will do the same for the different video journeys.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eVideoDeeplinkHandler\u003c/span\u003e: \u003cspan\u003eDeeplinkHandlerProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003erootViewController\u003c/span\u003e: \u003cspan\u003eUIViewController\u003c/span\u003e?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003erootViewController\u003c/span\u003e: \u003cspan\u003eUIViewController\u003c/span\u003e?) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003erootViewController\u003c/span\u003e = \u003cspan\u003erootViewController\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// \u003c/span\u003e\u003cspan\u003eMARK:\u003c/span\u003e\u003cspan\u003e - DeeplinkHandlerProtocol\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ecanOpenURL\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e: \u003cspan\u003eURL\u003c/span\u003e) -\u0026gt; \u003cspan\u003eBool\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e.\u003cspan\u003eabsoluteString\u003c/span\u003e.\u003cspan\u003ehasPrefix\u003c/span\u003e(\u003cspan\u003e\u0026#34;deeplink://videos\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eopenURL\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e: \u003cspan\u003eURL\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003ecanOpenURL\u003c/span\u003e(\u003cspan\u003eurl\u003c/span\u003e) \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// mock the navigation\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eviewController\u003c/span\u003e = \u003cspan\u003eUIViewController\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eswitch\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e.\u003cspan\u003epath\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e\u0026#34;/new\u0026#34;\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eviewController\u003c/span\u003e.\u003cspan\u003etitle\u003c/span\u003e = \u003cspan\u003e\u0026#34;Video Editing\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eviewController\u003c/span\u003e.\u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003ebackgroundColor\u003c/span\u003e = .\u003cspan\u003eorange\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003edefault\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eviewController\u003c/span\u003e.\u003cspan\u003etitle\u003c/span\u003e = \u003cspan\u003e\u0026#34;Video Listing\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eviewController\u003c/span\u003e.\u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003ebackgroundColor\u003c/span\u003e = .\u003cspan\u003ecyan\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003erootViewController\u003c/span\u003e?.\u003cspan\u003epresent\u003c/span\u003e(\u003cspan\u003eviewController\u003c/span\u003e, \u003cspan\u003eanimated\u003c/span\u003e: \u003cspan\u003etrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow we can inject them into the \u003ccode\u003eDeeplinkCoordinator\u003c/code\u003e and let it handle the right route.\nWe’ll have two variations, the first one for \u003ccode\u003eAppDelegate\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eAppDelegate\u003c/span\u003e: \u003cspan\u003eUIResponder\u003c/span\u003e, \u003cspan\u003eUIApplicationDelegate\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elazy\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edeeplinkCoordinator\u003c/span\u003e: \u003cspan\u003eDeeplinkCoordinatorProtocol\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eDeeplinkCoordinator\u003c/span\u003e(\u003cspan\u003ehandlers\u003c/span\u003e: [\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eAccountDeeplinkHandler\u003c/span\u003e(\u003cspan\u003erootViewController\u003c/span\u003e: \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003erootViewController\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eVideoDeeplinkHandler\u003c/span\u003e(\u003cspan\u003erootViewController\u003c/span\u003e: \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003erootViewController\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        ])\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003erootViewController\u003c/span\u003e: \u003cspan\u003eUIViewController\u003c/span\u003e? {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ewindow\u003c/span\u003e?.\u003cspan\u003erootViewController\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eapplication\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eapp\u003c/span\u003e: \u003cspan\u003eUIApplication\u003c/span\u003e, \u003cspan\u003eopen\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e: \u003cspan\u003eURL\u003c/span\u003e, \u003cspan\u003eoptions\u003c/span\u003e: [\u003cspan\u003eUIApplication\u003c/span\u003e.\u003cspan\u003eOpenURLOptionsKey\u003c/span\u003e: \u003cspan\u003eAny\u003c/span\u003e]) -\u0026gt; \u003cspan\u003eBool\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003edeeplinkCoordinator\u003c/span\u003e.\u003cspan\u003ehandleURL\u003c/span\u003e(\u003cspan\u003eurl\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAnd the second one for the \u003ccode\u003eSceneDelegate\u003c/code\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eSceneDelegate\u003c/span\u003e: \u003cspan\u003eUIResponder\u003c/span\u003e, \u003cspan\u003eUIWindowSceneDelegate\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elazy\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edeeplinkCoordinator\u003c/span\u003e: \u003cspan\u003eDeeplinkCoordinatorProtocol\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eDeeplinkCoordinator\u003c/span\u003e(\u003cspan\u003ehandlers\u003c/span\u003e: [\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eAccountDeeplinkHandler\u003c/span\u003e(\u003cspan\u003erootViewController\u003c/span\u003e: \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003erootViewController\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eVideoDeeplinkHandler\u003c/span\u003e(\u003cspan\u003erootViewController\u003c/span\u003e: \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003erootViewController\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        ])\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003erootViewController\u003c/span\u003e: \u003cspan\u003eUIViewController\u003c/span\u003e? {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ewindow\u003c/span\u003e?.\u003cspan\u003erootViewController\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003escene\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003escene\u003c/span\u003e: \u003cspan\u003eUIScene\u003c/span\u003e, \u003cspan\u003eopenURLContexts\u003c/span\u003e \u003cspan\u003eURLContexts\u003c/span\u003e: \u003cspan\u003eSet\u003c/span\u003e\u0026lt;\u003cspan\u003eUIOpenURLContext\u003c/span\u003e\u0026gt;) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003efirstUrl\u003c/span\u003e = \u003cspan\u003eURLContexts\u003c/span\u003e.\u003cspan\u003efirst\u003c/span\u003e?.\u003cspan\u003eurl\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003edeeplinkCoordinator\u003c/span\u003e.\u003cspan\u003ehandleURL\u003c/span\u003e(\u003cspan\u003efirstUrl\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe can test it again the same way we did so far, hoping to land on the right screen (expecting orange background).\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"sh\"\u003e\u003cspan\u003e\u003cspan\u003excrun simctl openurl booted \u003cspan\u003e\u0026#34;deeplink://videos/new\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2022/02/deep-linking-ios.png\" alt=\"deep-linking-ios\"/\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eTo summarize, once the URL scheme was setup, we defined a funnel to capture all the deep links used to open the app and leveraged protocol oriented programming to create multiple implementations of handlers, one for each specific path.\u003c/p\u003e\n\u003cp\u003eThis implementation is extensible for newer path and can easily be unit tested to make sure each parts behaves as expected.\u003c/p\u003e\n\u003cp\u003eThat being said, there could be few improvements, like verifying full path rather than relative one, for safer behavior. The navigation only \u003ccode\u003epresent\u003c/code\u003e but it’s to focus on the handler and not the transition itself.\u003c/p\u003e\n\u003cp\u003eOn a security note, if you also pass parameters within your deeplink, make sure to verify the type and values expected. It could expose different injection vulnerabilities if we’re not careful.\u003c/p\u003e\n\u003cp\u003eFrom there, you should have a good understanding of how to use and handle deeplink to open your app and jump to a specific screen.\nThis code is available on \u003ca href=\"https://github.com/popei69/samples/tree/master/DeeplinkSample\"\u003eGithub\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eHappy coding 🎉\u003c/em\u003e\u003c/p\u003e\n              \n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2022-02-13T01:00:00Z",
  "modifiedTime": "2022-02-13T01:00:00Z"
}
