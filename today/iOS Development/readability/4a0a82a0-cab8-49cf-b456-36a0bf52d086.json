{
  "id": "4a0a82a0-cab8-49cf-b456-36a0bf52d086",
  "title": "iOS Monorepo \u0026 CI Pipelines",
  "link": "https://albertodebortoli.com/2021/06/16/ios-monorepo-ci-pipelines/",
  "description": "We have presented our modular iOS architecture in a previous article and I gave a talk at Swift Heroes 2020 about it. In this article, we’ll analyse the challenges we faced to have the modular architecture integrated with our CI pipelines and the reasoning behind migrating to a monorepo.",
  "author": "Alberto De Bortoli",
  "published": "Wed, 16 Jun 2021 12:01:10 GMT",
  "source": "https://albertodebortoli.com/rss/",
  "categories": [
    "iOS",
    "Monorepo",
    "Continuous Integration",
    "Jenkins",
    "Cocoapods"
  ],
  "byline": "Alberto De Bortoli",
  "length": 19170,
  "excerpt": "We have presented our modular iOS architecture in a previous article and I gave a talk at Swift Heroes 2020 about it. In this article, we’ll analyse the challenges we faced to have the modular architecture integrated with our CI pipelines and the reasoning behind migrating to a monorepo.",
  "siteName": "Alberto De Bortoli",
  "favicon": "",
  "text": "Originally published on the Just Eat Takeaway Engineering Blog.We have presented our modular iOS architecture in a previous article and I gave a talk at Swift Heroes 2020 about it. In this article, we’ll analyse the challenges we faced to have the modular architecture integrated with our CI pipelines and the reasoning behind migrating to a monorepo.The ProblemHaving several modules in separate repositories brings forward 2 main problems:Each module is versioned independently from the consuming appEach change involves at least 2 pull requests: 1 for the module and 1 for the integration in the appWhile the above was acceptable in a world where we had 2 different codebases, it soon became unnecessarily convoluted after we migrated to a new, global codebase. New module versions are implemented with the ultimate goal of being adopted by the only global codebase in use, making us realise we could simplify the change process.The monorepo approach has been discussed at length by the community for a few years now. Many talking points have come out of these conversations, even leading to an interesting story as told by Uber. In short, it entails putting all the code owned by the team in a single repository, precisely solving the 2 problems stated above.Monorepo structureThe main advantage of a monorepo is a streamlined PR process that doesn’t require us to raise multiple PRs, de facto reducing the number of pull requests to one.It also simplifies the versioning, allowing module and app code (ultimately shipped together) to be aligned using the same versioning.The first step towards a monorepo was to move the content of the repositories of the modules to the main app repo (we’ll call it “monorepo” from now on). Since we rely on CocoaPods, the modules would be consumed as development pods.Here’s a brief summary of the steps used to migrate a module to the monorepo:Inform the relevant teams about the upcoming migrationMake sure there are no open PRs in the module repoMake the repository read-only and archive itCopy the module to the Modules folder of the monorepo (it’s possible to merge 2 repositories to keep the history but we felt we wanted to keep the process simple, the old history is still available in the old repo anyway)Delete the module .git folder (or it would cause a git submodule)Remove Gemfile and Gemfile.lock fastlane folder, .gitignore file, sonar-project.properties, .swiftlint.yml so to use those in the monorepoUpdate the monorepo’s CODEOWNERS file with the module codeownersRemove the .github folderModify the app Podfile to point to the module as a dev pod and install itMake sure all the modules’ demo apps in the monorepo refer to the new module as a dev pod (if they depend on it at all). The same applies to the module under migration.Delete the CI jobs related to the moduleLeave the podspecs in the private Specs repo (might be needed to build old versions of the app)The above assumes that CI is configured in a way that preserves the same integration steps upon a module change. We’ll discuss them later in this article.Not all the modules could be migrated to the monorepo, due to the fact the second-level dependencies need to live in separate repositories in order to be referenced in the podspec of a development pod. If not done correctly, CocoaPods will not be able to install them. We considered moving these dependencies to the monorepo whilst maintaining separate versioning, however, the main problem with this approach is that the version tags might conflict with the ones of the app. Even though CocoaPods supports tags that don’t respect semantic versioning (for example prepending the tag with the name of the module), violating it just didn’t feel right.EDIT: we’ve learned that it’s possible to move such dependencies to the monorepo. This is done not by defining :path=\u003e in the podspecs but instead by doing so in the Podfile of the main app, which is all Cocoapods needs to work out the location of the dependency on disk.Swift Package Manager considerationsWe investigated the possibility of migrating from CocoaPods to Apple’s Swift Package Manager. Unfortunately, when it comes to handling the equivalent of development pods, Swift Package Manager really falls down for us. It turns out that Swift Package Manager only supports one package per repo, which is frustrating because the process of working with editable packages is surprisingly powerful and transparent.Version pinning rulesWhile development pods don’t need to be versioned, other modules still need to. This is either because of their open-source nature or because they are second-level dependencies (referenced in other modules’ podspecs).Here’s a revised overview of the current modular architecture in 2021.We categorised our pods to better clarify what rules should apply when it comes to version pinning both in the Podfiles and in the podspecs.Open-Source podsOur open-source repositories on github.com/justeat are only used by the app.Examples: JustTweak, AutomationTools, ShockPinning in other modules’ podspec: NOT APPLICABLE open-source pods don’t appear in any podspec, those that do are called ‘open-source shared’Pinning in other modules’ Podfile (demo apps): PIN (e.g. AutomationTools in Orders demo app’s Podfile)Pinning in main app’s Podfile: PIN (e.g. AutomationTools)Open-Source shared podsThe Just Eat pods we put open-source on github.com/justeat and are used by modules and apps.Examples: JustTrack, JustLog, ScrollingStackViewController, ErrorUtilitiesPinning in other modules’ podspec: PIN w/ optimistic operator (e.g. JustTrack in Orders)Pinning in other modules’ Podfile (demo apps): PIN (e.g. JustTrack in Orders demo app’s Podfile)Pinning in main app’s Podfile: DON’T LIST latest compatible version is picked by CocoaPods (e.g. JustTrack). LIST \u0026 PIN if the pod is explicitly used in the app too, so we don’t magically inherit it.Internal Domain podsDomain modules (yellow).Examples: Orders, SERP, etc.Pinning in other modules’ podspec: NOT APPLICABLE domain pods don’t appear in other pods’ podspecs (domain modules don’t depend on other domain modules)Pinning in other modules’ Podfile (demo apps): PIN only if the pod is used in the app code, rarely the case (e.g. Account in Orders demo app’s Podfile)Pinning in main app’s Podfile: PIN (e.g. Orders)Internal Core podsCore modules (blue) minus those open-source.Examples: APIClient, AssetProviderPinning in other modules’ podspec: NOT APPLICABLE core pods don’t appear in other pods’ podspecs (core modules are only used in the app(s))Pinning in other modules’ Podfile (demo apps): PIN only if pod is used in the app code (e.g. APIClient in Orders demo app’s Podfile)Pinning in main app’s Podfile: PIN (e.g. NavigationEngine)Internal shared podsShared modules (green) minus those open-source.Examples: JustUI, JustAnalyticsPinning in other modules’ podspec: DON’T PIN (e.g. JustUI in Orders podspec)Pinning in other modules’ Podfile (demo apps): PIN (e.g. JustUI in Orders demo app’s Podfile)Pinning in main app’s Podfile: PIN (e.g. JustUI)External shared podsAny non-Just Eat pod used by any internal or open-source pod.Examples: Usabilla, SDWebImagePinning in other modules’ podspec: PIN (e.g. Usabilla in Orders)Pinning in other modules’ Podfile (demo apps): DON’T LIST because the version is forced by the podspec. LIST \u0026 PIN if the pod is explicitly used in the app too, so we don’t magically inherit it. Pinning is irrelevant but good practice.Pinning in main app’s Podfile: DON’T LIST because the version is forced by the podspec(s). LIST \u0026 PIN if the pod is explicitly used in the app too, so we don’t magically inherit it. Pinning is irrelevant but good practice.External podsAny non-Just Eat pod used by the app only.Examples: Instabug, GoogleAnalyticsPinning in other modules’ podspec: NOT APPLICABLE external pods don’t appear in any podspec, those that do are called ‘external shared’Pinning in other modules’ Podfile (demo apps): PIN only if the pod is used in the app code, rarely the case (e.g. Promis)Pinning in main app’s Podfile: PIN (e.g. Adjust)Pinning is a good solution because it guarantees that we always build the same software regardless of new released versions of dependencies. It’s also true that pinning every dependency all the time makes the dependency graph hard to keep updated. This is why we decided to allow some flexibility in some cases.Following is some more reasoning.Open-sourceFor “open-source shared” pods, we are optimistic enough (pun intended) to tolerate the usage of the optimistic operator ~\u003e in podspecs of other pods (i.e Orders using JustTrack) so that when a new patch version is released, the consuming pod gets it for free upon running pod update.We have control over our code and, by respecting semantic versioning, we guarantee the consuming pod to always build. In case of new minor or major versions, we would have to update the podspecs of the consuming pods, which is appropriate.Also, we do need to list any “open-source shared” pod in the main app’s Podfile only if directly used by the app code.ExternalWe don’t have control over the “external” and “external shared” pods, therefore we always pin the version in the appropriate place. New patch versions might not respect semantic versioning for real and we don’t want to pull in new code unintentionally. As a rule of thumb, we prefer injecting external pods instead of creating a dependency in the podspec.InternalInternal shared pods could change frequently (not as much as domain modules). For this reason, we’ve decided to relax a constraint we had and not to pin the version in the podspec. This might cause the consuming pod to break when a new version of an “internal shared” pod is released and we run pod update. This is a compromise we can tolerate. The alternative would be to pin the version causing too much work to update the podspec of the domain modules.Continuous Integration changesWith modules in separate repositories, the CI was quite simply replicating the same steps for each module:install podsrun unit testsrun UI testsgenerated code coveragesubmit code coverage to SonarQubeMoving the modules to the monorepo meant creating smart CI pipelines that would run the same steps upon modules’ changes.If a pull request is to change only app code, there is no need to run any step for the modules, just the usual steps for the app:If instead, a pull request applies changes to one or more modules, we want the pipeline to first run the steps for the modules, and then the steps for the app:Even if there are no changes in the app code, module changes could likely impact the app behaviour, so it’s important to always run the app tests.We have achieved the above setup through constructing our Jenkins pipelines dynamically. The solution should scale when new modules are added to the monorepo and for this reason, it’s important that all modules:respect the same project setup (generated by CocoaPods w/ the pod lib create command)use the same naming conventions for the test schemes (UnitTests/ContractTests/UITests)make use of Apple Test Plansare in the same location ( ./Modules/ folder).Following is an excerpt of the code that constructs the modules’ stages from the Jenkinsfile used for pull request jobs.scripts = load \"./Jenkins/scripts/scripts.groovy\" def modifiedModules = scripts.modifiedModulesFromReferenceBranch(env.CHANGE_TARGET) def modulesThatNeedUpdating = scripts.modulesThatNeedUpdating(env.CHANGE_TARGET) def modulesToRun = (modulesThatNeedUpdating + modifiedModules).unique() sh \"echo \\\"List of modules modified on this branch: ${modifiedModules}\\\"\" sh \"echo \\\"List of modules that need updating: ${modulesThatNeedUpdating}\\\"\" sh \"echo \\\"Pipeline will run the following modules: ${modulesToRun}\\\"\" for (int i = 0; i \u003c modulesToRun.size(); ++i) { def moduleName = modulesToRun[i] stage('Run pod install') { sh \"bundle exec fastlane pod_install module:${moduleName}\" } def schemes = scripts.testSchemesForModule(moduleName) schemes.each { scheme -\u003e switch (scheme) { case \"UnitTests\": stage(\"${moduleName} Unit Tests\") { sh \"bundle exec fastlane module_unittests \\ module_name:${moduleName} \\ device:'${env.IPHONE_DEVICE}'\" } stage(\"Generate ${moduleName} code coverage\") { sh \"bundle exec fastlane generate_sonarqube_coverage_xml\" } stage(\"Submit ${moduleName} code coverage to SonarQube\") { sh \"bundle exec fastlane sonar_scanner_pull_request \\ component_type:'module' \\ source_branch:${env.BRANCH_NAME} \\ target_branch:${env.CHANGE_TARGET} \\ pull_id:${env.CHANGE_ID} \\ project_key:'ios-${moduleName}' \\ project_name:'iOS ${moduleName}' \\ sources_path:'./Modules/${moduleName}/${moduleName}'\" } break; case \"ContractTests\": stage('Install pact mock service') { sh \"bundle exec fastlane install_pact_mock_service\" } stage(\"${moduleName} Contract Tests\") { sh \"bundle exec fastlane module_contracttests \\ module_name:${moduleName} \\ device:'${env.IPHONE_DEVICE}'\" } break; case \"UITests\": stage(\"${moduleName} UI Tests\") { sh \"bundle exec fastlane module_uitests \\ module_name:${moduleName} \\ number_of_simulators:${env.NUMBER_OF_SIMULATORS} \\ device:'${env.IPHONE_DEVICE}'\" } break; default: break; } } }and here are the helper functions to make it all work:def modifiedModulesFromReferenceBranch(String referenceBranch) { def script = \"git diff --name-only remotes/origin/${referenceBranch}\" def filesChanged = sh script: script, returnStdout: true Set modulesChanged = [] filesChanged.tokenize(\"\\n\").each { def components = it.split('/') if (components.size() \u003e 1 \u0026\u0026 components[0] == 'Modules') { def module = components[1] modulesChanged.add(module) } } return modulesChanged } def modulesThatNeedUpdating(String referenceBranch) { def modifiedModules = modifiedModulesFromReferenceBranch(referenceBranch) def allModules = allMonorepoModules() def modulesThatNeedUpdating = [] for (module in allModules) { def podfileLockPath = \"Modules/${module}/Example/Podfile.lock\" def dependencies = podfileDependencies(podfileLockPath) def dependenciesIntersection = dependencies.intersect(modifiedModules) as TreeSet Boolean moduleNeedsUpdating = (dependenciesIntersection.size() \u003e 0) if (moduleNeedsUpdating == true \u0026\u0026 modifiedModules.contains(module) == false) { modulesThatNeedUpdating.add(module) } } return modulesThatNeedUpdating } def podfileDependencies(String podfileLockPath) { def dependencies = [] def fileContent = readFile(file: podfileLockPath) fileContent.tokenize(\"\\n\").each { line -\u003e def lineComponents = line.split('\\\\(') if (lineComponents.length \u003e 1) { def dependencyLineSubComponents = lineComponents[0].split('-') if (dependencyLineSubComponents.length \u003e 1) { def moduleName = dependencyLineSubComponents[1].trim() dependencies.add(moduleName) } } } return dependencies } def allMonorepoModules() { def modulesList = sh script: \"ls Modules\", returnStdout: true return modulesList.tokenize(\"\\n\").collect { it.trim() } } def testSchemesForModule(String moduleName) { def script = \"xcodebuild -project ./Modules/${moduleName}/Example/${moduleName}.xcodeproj -list\" def projectEntitites = sh script: script, returnStdout: true def schemesPart = projectEntitites.split('Schemes:')[1] def schemesPartLines = schemesPart.split(/\\n/) def trimmedLined = schemesPartLines.collect { it.trim() } def filteredLines = trimmedLined.findAll { !it.allWhitespace } def allowedSchemes = ['UnitTests', 'ContractTests', 'UITests'] def testSchemes = filteredLines.findAll { allowedSchemes.contains(it) } return testSchemes }You might have noticed the modulesThatNeedUpdating method in the code above. Each module comes with a demo app using the dependencies listed in its Podfile and it’s possible that other monorepo modules are listed there as development pods. This not only means that we have to run the steps for the main app, but also the steps for every module consuming modules that show changes.For example, the Orders demo app uses APIClient, meaning that pull requests with changes in APIClient will generate pipelines including the Orders steps.Pipeline parallelizationSomething we initially thought was sensible to consider is the parallelisation of the pipelines across different nodes. We use parallelisation for the release pipelines and learned that, while it seems to be a fundamental requirement at first, it soon became apparent not to be so desirable nor truly fundamental for the pull requests pipeline.We’ll discuss our CI setup in a separate article, but suffice to say that we have aggressively optimized it and managed to reduce the agent pool from 10 to 5, still maintaining a good level of service.Parallelisation sensibly complicates the Jenkinsfiles and their maintainability, spreads the cost of checking out the repository across nodes and makes the logs harder to read. The main benefit would come from running the app UI tests on different nodes. In the WWDC session 413, Apple recommends generating the .xctestrun file using the build-for-testing option in xcodebuild and distribute it across the other nodes. Since our app is quite large, such file is also large and transferring it has its costs, both in time and bandwidth usage.All things considered, we decided to keep the majority of our pipelines serial.EDIT: In 2022 we have parallelised our PR pipeline in 4 branches:Validation steps (linting, Fastlane lanes tests, etc.)App unit testsApp UI tests (short enough that there's no need to share .xctestrun across nodes)Modified modules unit testsModified modules UI testsConclusionsWe have used the setup described in this article since mid-2020 and we are very satisfied with it. We discussed the pipeline used for the pull requests which is the most relevant one when it comes to embracing a monorepo structure. We have a few more pipelines for various use cases, such as verifying changes in release branches, keeping the code coverage metrics up-to-date with jobs running of triggers, archiving the app for internal usage and for App Store.We hope to have given you some useful insights on how to structure a monorepo and its CI pipelines, especially if you have a structure similar to ours.",
  "image": "https://albertodebortoli.com/content/images/size/w1200/2021/06/GettyImages-1297512889.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cp\u003e\u003cem\u003e\u003cem\u003eOriginally published on the \u003c/em\u003e\u003ca href=\"https://medium.com/takeaway-tech/ios-monorepo-ci-pipelines-99a3b69240a9?ref=albertodebortoli.com\"\u003e\u003cem\u003eJust Eat \u003c/em\u003eTakeaway \u003cem\u003eEngineering Blog\u003c/em\u003e\u003c/a\u003e\u003cem\u003e.\u003c/em\u003e\u003c/em\u003e\u003c/p\u003e\u003cp\u003eWe have presented our modular iOS architecture in a previous\u003ca href=\"https://tech.justeattakeaway.com/2019/12/18/modular-ios-architecture-just-eat/?ref=albertodebortoli.com\" rel=\"noopener nofollow\"\u003e article\u003c/a\u003e and I gave a \u003ca href=\"https://www.youtube.com/watch?v=QzM3lsFewN4\u0026amp;ref=albertodebortoli.com\" rel=\"noopener nofollow\"\u003etalk\u003c/a\u003e at Swift Heroes 2020 about it. In this article, we’ll analyse the challenges we faced to have the modular architecture integrated with our CI pipelines and the reasoning behind migrating to a monorepo.\u003c/p\u003e\u003ch2 id=\"the-problem\"\u003eThe Problem\u003c/h2\u003e\u003cp\u003eHaving several modules in separate repositories brings forward 2 main problems:\u003c/p\u003e\u003col\u003e\u003cli\u003eEach module is versioned independently from the consuming app\u003c/li\u003e\u003cli\u003eEach change involves at least 2 pull requests: 1 for the module and 1 for the integration in the app\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eWhile the above was acceptable in a world where we had 2 different codebases, it soon became unnecessarily convoluted after we migrated to a new, global codebase. New module versions are implemented with the ultimate goal of being adopted by the only global codebase in use, making us realise we could simplify the change process.\u003c/p\u003e\u003cp\u003eThe monorepo approach has been discussed at length by the community for a few years now. Many talking points have come out of these conversations, even leading to an interesting story as told by Uber. In short, it entails putting all the code owned by the team in a single repository, precisely solving the 2 problems stated above.\u003c/p\u003e\u003ch2 id=\"monorepo-structure\"\u003eMonorepo structure\u003c/h2\u003e\u003cp\u003eThe main advantage of a monorepo is a streamlined PR process that doesn’t require us to raise multiple PRs, de facto reducing the number of pull requests to one.\u003c/p\u003e\u003cp\u003eIt also simplifies the versioning, allowing module and app code (ultimately shipped together) to be aligned using the same versioning.\u003c/p\u003e\u003cp\u003eThe first step towards a monorepo was to move the content of the repositories of the modules to the main app repo (we’ll call it “monorepo” from now on). Since we rely on \u003ca href=\"https://cocoapods.org/?ref=albertodebortoli.com\" rel=\"noopener nofollow\"\u003eCocoaPods\u003c/a\u003e, the modules would be consumed as\u003ca href=\"https://guides.cocoapods.org/making/making-a-cocoapod.html?ref=albertodebortoli.com#development\" rel=\"noopener nofollow\"\u003e development pods\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eHere’s a brief summary of the steps used to migrate a module to the monorepo:\u003c/p\u003e\u003cul\u003e\u003cli\u003eInform the relevant teams about the upcoming migration\u003c/li\u003e\u003cli\u003eMake sure there are no open PRs in the module repo\u003c/li\u003e\u003cli\u003eMake the repository read-only and archive it\u003c/li\u003e\u003cli\u003eCopy the module to the Modules folder of the monorepo (it’s possible to\u003ca href=\"https://saintgimp.org/2013/01/22/merging-two-git-repositories-into-one-repository-without-losing-file-history/?ref=albertodebortoli.com\" rel=\"noopener nofollow\"\u003e merge 2 repositories to keep the history\u003c/a\u003e but we felt we wanted to keep the process simple, the old history is still available in the old repo anyway)\u003c/li\u003e\u003cli\u003eDelete the module \u003ccode\u003e.git\u003c/code\u003e folder (or it would cause a git submodule)\u003c/li\u003e\u003cli\u003eRemove \u003ccode\u003eGemfile\u003c/code\u003e and \u003ccode\u003eGemfile.lock\u003c/code\u003e \u003ccode\u003efastlane\u003c/code\u003e folder, \u003ccode\u003e.gitignore\u003c/code\u003e file, \u003ccode\u003esonar-project.properties\u003c/code\u003e, \u003ccode\u003e.swiftlint.yml\u003c/code\u003e so to use those in the monorepo\u003c/li\u003e\u003cli\u003eUpdate the monorepo’s \u003ccode\u003eCODEOWNERS\u003c/code\u003e file with the module codeowners\u003c/li\u003e\u003cli\u003eRemove the \u003ccode\u003e.github\u003c/code\u003e folder\u003c/li\u003e\u003cli\u003eModify the app \u003ccode\u003ePodfile\u003c/code\u003e to point to the module as a dev pod and install it\u003c/li\u003e\u003cli\u003eMake sure all the modules’ demo apps in the monorepo refer to the new module as a dev pod (if they depend on it at all). The same applies to the module under migration.\u003c/li\u003e\u003cli\u003eDelete the CI jobs related to the module\u003c/li\u003e\u003cli\u003eLeave the podspecs in the private Specs repo (might be needed to build old versions of the app)\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe above assumes that CI is configured in a way that preserves the same integration steps upon a module change. We’ll discuss them later in this article.\u003c/p\u003e\u003cp\u003eNot all the modules could be migrated to the monorepo, due to the fact the second-level dependencies need to live in separate repositories in order to be referenced in the podspec of a development pod. If not done correctly, CocoaPods will not be able to install them. We considered moving these dependencies to the monorepo whilst maintaining separate versioning, however, the main problem with this approach is that the version tags might conflict with the ones of the app. Even though CocoaPods supports tags that don’t respect \u003ca href=\"https://semver.org/?ref=albertodebortoli.com\" rel=\"noopener nofollow\"\u003esemantic versioning\u003c/a\u003e (for example prepending the tag with the name of the module), violating it just didn’t feel right.\u003c/p\u003e\u003cp\u003eEDIT: we’ve learned that it’s possible to move such dependencies to the monorepo. This is done not by defining \u003ccode\u003e:path=\u0026gt;\u003c/code\u003e in the podspecs but instead by doing so in the Podfile of the main app, which is all Cocoapods needs to work out the location of the dependency on disk.\u003c/p\u003e\u003ch3 id=\"swift-package-manager-considerations\"\u003eSwift Package Manager considerations\u003c/h3\u003e\u003cp\u003eWe investigated the possibility of migrating from CocoaPods to Apple’s \u003ca href=\"https://swift.org/package-manager/?ref=albertodebortoli.com\" rel=\"noopener nofollow\"\u003eSwift Package Manager\u003c/a\u003e. Unfortunately, when it comes to handling the equivalent of development pods, Swift Package Manager really falls down for us. It turns out that Swift Package Manager only supports\u003ca href=\"https://stackoverflow.com/a/50095567?ref=albertodebortoli.com\" rel=\"noopener nofollow\"\u003e one package per repo\u003c/a\u003e, which is frustrating because the process of working with editable packages is surprisingly powerful and transparent.\u003c/p\u003e\u003ch2 id=\"version-pinning-rules\"\u003eVersion pinning rules\u003c/h2\u003e\u003cp\u003eWhile development pods don’t need to be versioned, other modules still need to. This is either because of their open-source nature or because they are second-level dependencies (referenced in other modules’ podspecs).\u003c/p\u003e\u003cp\u003eHere’s a revised overview of the current modular architecture in 2021.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2021/06/The-Just-Eat-iOS-Stack---Holistic-Design-2021.png\" alt=\"\" loading=\"lazy\" width=\"950\" height=\"653\" srcset=\"https://albertodebortoli.com/content/images/size/w600/2021/06/The-Just-Eat-iOS-Stack---Holistic-Design-2021.png 600w, https://albertodebortoli.com/content/images/2021/06/The-Just-Eat-iOS-Stack---Holistic-Design-2021.png 950w\"/\u003e\u003c/figure\u003e\u003cp\u003eWe categorised our pods to better clarify what rules should apply when it comes to version pinning both in the \u003ccode\u003ePodfile\u003c/code\u003es and in the \u003ccode\u003epodspec\u003c/code\u003es.\u003c/p\u003e\u003ch3 id=\"open-source-pods\"\u003eOpen-Source pods\u003c/h3\u003e\u003cp\u003eOur open-source repositories on \u003ca href=\"https://github.com/justeat?ref=albertodebortoli.com\" rel=\"noopener nofollow\"\u003egithub.com/justeat\u003c/a\u003e are only used by the app.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003eExamples: \u003c/em\u003e\u003c/em\u003eJustTweak, AutomationTools, Shock\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ podspec:\u003c/em\u003e\u003c/em\u003e \u003cstrong\u003e\u003cstrong\u003eNOT APPLICABLE\u003c/strong\u003e\u003c/strong\u003e open-source pods don’t appear in any podspec, those that do are called ‘open-source shared’\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ Podfile (demo apps): \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e (e.g. AutomationTools in Orders demo app’s Podfile)\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in main app’s Podfile: \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e (e.g. AutomationTools)\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"open-source-shared-pods\"\u003eOpen-Source shared pods\u003c/h3\u003e\u003cp\u003eThe Just Eat pods we put open-source on \u003ca href=\"https://github.com/justeat?ref=albertodebortoli.com\" rel=\"noopener nofollow\"\u003egithub.com/justeat\u003c/a\u003e and are used by modules and apps.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003eExamples:\u003c/em\u003e\u003c/em\u003e JustTrack, JustLog, ScrollingStackViewController, ErrorUtilities\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ podspec:\u003c/em\u003e\u003c/em\u003e \u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e w/ optimistic operator (e.g. JustTrack in Orders)\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ Podfile (demo apps): \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e (e.g. JustTrack in Orders demo app’s Podfile)\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in main app’s Podfile: \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003eDON’T LIST\u003c/strong\u003e\u003c/strong\u003e latest compatible version is picked by CocoaPods (e.g. JustTrack). \u003cstrong\u003e\u003cstrong\u003eLIST \u0026amp; PIN\u003c/strong\u003e\u003c/strong\u003e if the pod is explicitly used in the app too, so we don’t magically inherit it.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"internal-domain-pods\"\u003eInternal Domain pods\u003c/h3\u003e\u003cp\u003eDomain modules (yellow).\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003eExamples:\u003c/em\u003e\u003c/em\u003e Orders, SERP, etc.\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ podspec:\u003c/em\u003e\u003c/em\u003e \u003cstrong\u003e\u003cstrong\u003eNOT APPLICABLE\u003c/strong\u003e\u003c/strong\u003e domain pods don’t appear in other pods’ podspecs (domain modules don’t depend on other domain modules)\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ Podfile (demo apps): \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e only if the pod is used in the app code, rarely the case (e.g. Account in Orders demo app’s Podfile)\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in main app’s Podfile: \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e (e.g. Orders)\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"internal-core-pods\"\u003eInternal Core pods\u003c/h3\u003e\u003cp\u003eCore modules (blue) minus those open-source.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003eExamples:\u003c/em\u003e\u003c/em\u003e APIClient, AssetProvider\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ podspec:\u003c/em\u003e\u003c/em\u003e \u003cstrong\u003e\u003cstrong\u003eNOT APPLICABLE\u003c/strong\u003e\u003c/strong\u003e core pods don’t appear in other pods’ podspecs (core modules are only used in the app(s))\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ Podfile (demo apps): \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e only if pod is used in the app code (e.g. APIClient in Orders demo app’s Podfile)\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in main app’s Podfile: \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e (e.g. NavigationEngine)\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"internal-shared-pods\"\u003eInternal shared pods\u003c/h3\u003e\u003cp\u003eShared modules (green) minus those open-source.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003eExamples:\u003c/em\u003e\u003c/em\u003e JustUI, JustAnalytics\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ podspec:\u003c/em\u003e\u003c/em\u003e \u003cstrong\u003e\u003cstrong\u003eDON’T PIN\u003c/strong\u003e\u003c/strong\u003e (e.g. JustUI in Orders podspec)\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ Podfile (demo apps): \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e (e.g. JustUI in Orders demo app’s Podfile)\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in main app’s Podfile: \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e (e.g. JustUI)\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"external-shared-pods\"\u003eExternal shared pods\u003c/h3\u003e\u003cp\u003eAny non-Just Eat pod used by any internal or open-source pod.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003eExamples:\u003c/em\u003e\u003c/em\u003e Usabilla, SDWebImage\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ podspec:\u003c/em\u003e\u003c/em\u003e \u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e (e.g. Usabilla in Orders)\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ Podfile (demo apps): \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003eDON’T LIST\u003c/strong\u003e\u003c/strong\u003e because the version is forced by the podspec. \u003cstrong\u003e\u003cstrong\u003eLIST \u0026amp; PIN\u003c/strong\u003e\u003c/strong\u003e if the pod is explicitly used in the app too, so we don’t magically inherit it. Pinning is irrelevant but good practice.\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in main app’s Podfile: \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003eDON’T LIST\u003c/strong\u003e\u003c/strong\u003e because the version is forced by the podspec(s). \u003cstrong\u003e\u003cstrong\u003eLIST \u0026amp; PIN\u003c/strong\u003e\u003c/strong\u003e if the pod is explicitly used in the app too, so we don’t magically inherit it. Pinning is irrelevant but good practice.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"external-pods\"\u003eExternal pods\u003c/h3\u003e\u003cp\u003eAny non-Just Eat pod used by the app only.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003eExamples:\u003c/em\u003e\u003c/em\u003e Instabug, GoogleAnalytics\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ podspec:\u003c/em\u003e\u003c/em\u003e \u003cstrong\u003e\u003cstrong\u003eNOT APPLICABLE\u003c/strong\u003e\u003c/strong\u003e external pods don’t appear in any podspec, those that do are called ‘external shared’\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in other modules’ Podfile (demo apps): \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e only if the pod is used in the app code, rarely the case (e.g. Promis)\u003c/li\u003e\u003cli\u003e\u003cem\u003e\u003cem\u003ePinning in main app’s Podfile: \u003c/em\u003e\u003c/em\u003e\u003cstrong\u003e\u003cstrong\u003ePIN\u003c/strong\u003e\u003c/strong\u003e (e.g. Adjust)\u003c/li\u003e\u003c/ul\u003e\u003cp\u003ePinning is a good solution because it guarantees that we always build the same software regardless of new released versions of dependencies. It’s also true that pinning every dependency all the time makes the dependency graph hard to keep updated. This is why we decided to allow some flexibility in some cases.\u003c/p\u003e\u003cp\u003eFollowing is some more reasoning.\u003c/p\u003e\u003ch3 id=\"open-source\"\u003eOpen-source\u003c/h3\u003e\u003cp\u003eFor “open-source shared” pods, we are optimistic enough (pun intended) to tolerate the usage of the optimistic operator \u003ccode\u003e~\u0026gt;\u003c/code\u003e in podspecs of other pods (i.e Orders using JustTrack) so that when a new patch version is released, the consuming pod gets it for free upon running \u003ccode\u003epod update\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eWe have control over our code and, by respecting semantic versioning, we guarantee the consuming pod to always build. In case of new minor or major versions, we would have to update the podspecs of the consuming pods, which is appropriate.\u003c/p\u003e\u003cp\u003eAlso, we do need to list any “open-source shared” pod in the main app’s Podfile only if directly used by the app code.\u003c/p\u003e\u003ch3 id=\"external\"\u003eExternal\u003c/h3\u003e\u003cp\u003eWe don’t have control over the “external” and “external shared” pods, therefore we always pin the version in the appropriate place. New patch versions might not respect semantic versioning for real and we don’t want to pull in new code unintentionally. As a rule of thumb, we prefer injecting external pods instead of creating a dependency in the podspec.\u003c/p\u003e\u003ch3 id=\"internal\"\u003eInternal\u003c/h3\u003e\u003cp\u003eInternal shared pods could change frequently (not as much as domain modules). For this reason, we’ve decided to relax a constraint we had and not to pin the version in the podspec. This might cause the consuming pod to break when a new version of an “internal shared” pod is released and we run \u003ccode\u003epod update\u003c/code\u003e. This is a compromise we can tolerate. The alternative would be to pin the version causing too much work to update the podspec of the domain modules.\u003c/p\u003e\u003ch2 id=\"continuous-integration-changes\"\u003eContinuous Integration changes\u003c/h2\u003e\u003cp\u003eWith modules in separate repositories, the CI was quite simply replicating the same steps for each module:\u003c/p\u003e\u003cul\u003e\u003cli\u003einstall pods\u003c/li\u003e\u003cli\u003erun unit tests\u003c/li\u003e\u003cli\u003erun UI tests\u003c/li\u003e\u003cli\u003egenerated code coverage\u003c/li\u003e\u003cli\u003esubmit code coverage to SonarQube\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eMoving the modules to the monorepo meant creating smart CI pipelines that would run the same steps upon modules’ changes.\u003c/p\u003e\u003cp\u003eIf a pull request is to change only app code, there is no need to run any step for the modules, just the usual steps for the app:\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2021/06/0_iE4VY6rYjdrFzu5K.png\" alt=\"\" loading=\"lazy\" width=\"1600\" height=\"182\" srcset=\"https://albertodebortoli.com/content/images/size/w600/2021/06/0_iE4VY6rYjdrFzu5K.png 600w, https://albertodebortoli.com/content/images/size/w1000/2021/06/0_iE4VY6rYjdrFzu5K.png 1000w, https://albertodebortoli.com/content/images/2021/06/0_iE4VY6rYjdrFzu5K.png 1600w\" sizes=\"(min-width: 1200px) 1200px\"/\u003e\u003c/figure\u003e\u003cp\u003eIf instead, a pull request applies changes to one or more modules, we want the pipeline to first run the steps for the modules, and then the steps for the app:\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2021/06/0_JEC2Pxzbispwi531.png\" alt=\"\" loading=\"lazy\" width=\"1600\" height=\"153\" srcset=\"https://albertodebortoli.com/content/images/size/w600/2021/06/0_JEC2Pxzbispwi531.png 600w, https://albertodebortoli.com/content/images/size/w1000/2021/06/0_JEC2Pxzbispwi531.png 1000w, https://albertodebortoli.com/content/images/2021/06/0_JEC2Pxzbispwi531.png 1600w\" sizes=\"(min-width: 1200px) 1200px\"/\u003e\u003c/figure\u003e\u003cp\u003eEven if there are no changes in the app code, module changes could likely impact the app behaviour, so it’s important to always run the app tests.\u003c/p\u003e\u003cp\u003eWe have achieved the above setup through constructing our Jenkins pipelines dynamically. The solution should scale when new modules are added to the monorepo and for this reason, it’s important that all modules:\u003c/p\u003e\u003cul\u003e\u003cli\u003erespect the same project setup (generated by CocoaPods w/ the \u003ccode\u003epod lib create\u003c/code\u003e command)\u003c/li\u003e\u003cli\u003euse the same naming conventions for the test schemes (\u003ccode\u003eUnitTests\u003c/code\u003e/\u003ccode\u003eContractTests\u003c/code\u003e/\u003ccode\u003eUITests\u003c/code\u003e)\u003c/li\u003e\u003cli\u003emake use of Apple Test Plans\u003c/li\u003e\u003cli\u003eare in the same location ( \u003ccode\u003e./Modules/\u003c/code\u003e folder).\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFollowing is an excerpt of the code that constructs the modules’ stages from the Jenkinsfile used for pull request jobs.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003escripts = load \u0026#34;./Jenkins/scripts/scripts.groovy\u0026#34;\n\ndef modifiedModules = scripts.modifiedModulesFromReferenceBranch(env.CHANGE_TARGET)\n\ndef modulesThatNeedUpdating = scripts.modulesThatNeedUpdating(env.CHANGE_TARGET)\n\ndef modulesToRun = (modulesThatNeedUpdating + modifiedModules).unique()\n\nsh \u0026#34;echo \\\u0026#34;List of modules modified on this branch: ${modifiedModules}\\\u0026#34;\u0026#34;\n\nsh \u0026#34;echo \\\u0026#34;List of modules that need updating: ${modulesThatNeedUpdating}\\\u0026#34;\u0026#34;\n\nsh \u0026#34;echo \\\u0026#34;Pipeline will run the following modules: ${modulesToRun}\\\u0026#34;\u0026#34;\n\nfor (int i = 0; i \u0026lt; modulesToRun.size(); ++i) {\n    def moduleName = modulesToRun[i]\n    stage(\u0026#39;Run pod install\u0026#39;) {\n        sh \u0026#34;bundle exec fastlane pod_install module:${moduleName}\u0026#34;\n    }\n\n    def schemes = scripts.testSchemesForModule(moduleName)\n    schemes.each { scheme -\u0026gt;\n        switch (scheme) {\n            case \u0026#34;UnitTests\u0026#34;:\n                stage(\u0026#34;${moduleName} Unit Tests\u0026#34;) {\n                    sh \u0026#34;bundle exec fastlane module_unittests \\\n                    module_name:${moduleName} \\\n                    device:\u0026#39;${env.IPHONE_DEVICE}\u0026#39;\u0026#34;\n                }\n                stage(\u0026#34;Generate ${moduleName} code coverage\u0026#34;) {\n                    sh \u0026#34;bundle exec fastlane generate_sonarqube_coverage_xml\u0026#34;\n                }\n                stage(\u0026#34;Submit ${moduleName} code coverage to SonarQube\u0026#34;) {\n                    sh \u0026#34;bundle exec fastlane sonar_scanner_pull_request \\\n                    component_type:\u0026#39;module\u0026#39; \\\n                    source_branch:${env.BRANCH_NAME} \\\n                    target_branch:${env.CHANGE_TARGET} \\\n                    pull_id:${env.CHANGE_ID} \\\n                    project_key:\u0026#39;ios-${moduleName}\u0026#39; \\\n                    project_name:\u0026#39;iOS ${moduleName}\u0026#39; \\\n                    sources_path:\u0026#39;./Modules/${moduleName}/${moduleName}\u0026#39;\u0026#34;\n                }\n                break;\n            case \u0026#34;ContractTests\u0026#34;:\n                stage(\u0026#39;Install pact mock service\u0026#39;) {\n                    sh \u0026#34;bundle exec fastlane install_pact_mock_service\u0026#34;\n                }\n                stage(\u0026#34;${moduleName} Contract Tests\u0026#34;) {\n                    sh \u0026#34;bundle exec fastlane module_contracttests \\\n                    module_name:${moduleName} \\\n                    device:\u0026#39;${env.IPHONE_DEVICE}\u0026#39;\u0026#34;\n                }\n                break;\n            case \u0026#34;UITests\u0026#34;:\n                stage(\u0026#34;${moduleName} UI Tests\u0026#34;) {\n                    sh \u0026#34;bundle exec fastlane module_uitests \\\n                    module_name:${moduleName} \\\n                    number_of_simulators:${env.NUMBER_OF_SIMULATORS} \\\n                    device:\u0026#39;${env.IPHONE_DEVICE}\u0026#39;\u0026#34;\n                }\n                break;\n            default: break;\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eand here are the helper functions to make it all work:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003edef modifiedModulesFromReferenceBranch(String referenceBranch) {\n    def script = \u0026#34;git diff --name-only remotes/origin/${referenceBranch}\u0026#34;\n    def filesChanged = sh script: script, returnStdout: true\n    Set modulesChanged = []\n    filesChanged.tokenize(\u0026#34;\\n\u0026#34;).each {\n        def components = it.split(\u0026#39;/\u0026#39;)\n        if (components.size() \u0026gt; 1 \u0026amp;\u0026amp; components[0] == \u0026#39;Modules\u0026#39;) { \n            def module = components[1]\n            modulesChanged.add(module)\n        }\n    }\n    return modulesChanged\n}\n\ndef modulesThatNeedUpdating(String referenceBranch) {\n    def modifiedModules = modifiedModulesFromReferenceBranch(referenceBranch)\n    def allModules = allMonorepoModules()\n    def modulesThatNeedUpdating = []\n    for (module in allModules) {\n        def podfileLockPath = \u0026#34;Modules/${module}/Example/Podfile.lock\u0026#34;\n        def dependencies = podfileDependencies(podfileLockPath)\n        def dependenciesIntersection = dependencies.intersect(modifiedModules) as TreeSet\n        Boolean moduleNeedsUpdating = (dependenciesIntersection.size() \u0026gt; 0)\n        if (moduleNeedsUpdating == true \u0026amp;\u0026amp; modifiedModules.contains(module) == false) {\n            modulesThatNeedUpdating.add(module)\n        }\n    }\n    return modulesThatNeedUpdating\n}\n\ndef podfileDependencies(String podfileLockPath) {\n    def dependencies = []\n    def fileContent = readFile(file: podfileLockPath)\n    fileContent.tokenize(\u0026#34;\\n\u0026#34;).each { line -\u0026gt;\n        def lineComponents = line.split(\u0026#39;\\\\(\u0026#39;)\n        if (lineComponents.length \u0026gt; 1) {\n            def dependencyLineSubComponents = lineComponents[0].split(\u0026#39;-\u0026#39;)\n            if (dependencyLineSubComponents.length \u0026gt; 1) {\n                def moduleName = dependencyLineSubComponents[1].trim()\n                dependencies.add(moduleName)\n            }\n        }\n    }\n    return dependencies\n}\n\ndef allMonorepoModules() {\n    def modulesList = sh script: \u0026#34;ls Modules\u0026#34;, returnStdout: true\n    return modulesList.tokenize(\u0026#34;\\n\u0026#34;).collect { it.trim() }\n}\n\ndef testSchemesForModule(String moduleName) {\n    def script = \u0026#34;xcodebuild -project ./Modules/${moduleName}/Example/${moduleName}.xcodeproj -list\u0026#34;\n    def projectEntitites = sh script: script, returnStdout: true\n    def schemesPart = projectEntitites.split(\u0026#39;Schemes:\u0026#39;)[1]\n    def schemesPartLines = schemesPart.split(/\\n/)\n    def trimmedLined = schemesPartLines.collect { it.trim() }\n    def filteredLines = trimmedLined.findAll { !it.allWhitespace }\n    def allowedSchemes = [\u0026#39;UnitTests\u0026#39;, \u0026#39;ContractTests\u0026#39;, \u0026#39;UITests\u0026#39;]\n    def testSchemes = filteredLines.findAll { allowedSchemes.contains(it) }\n    return testSchemes\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou might have noticed the \u003ccode\u003emodulesThatNeedUpdating\u003c/code\u003e method in the code above. Each module comes with a demo app using the dependencies listed in its Podfile and it’s possible that other monorepo modules are listed there as development pods. This not only means that we have to run the steps for the main app, but also the steps for every module consuming modules that show changes.\u003c/p\u003e\u003cp\u003eFor example, the Orders demo app uses APIClient, meaning that pull requests with changes in APIClient will generate pipelines including the Orders steps.\u003c/p\u003e\u003ch2 id=\"pipeline-parallelization\"\u003ePipeline parallelization\u003c/h2\u003e\u003cp\u003eSomething we initially thought was sensible to consider is the parallelisation of the pipelines across different nodes. We use parallelisation for the release pipelines and learned that, while it seems to be a fundamental requirement at first, it soon became apparent not to be so desirable nor truly fundamental for the pull requests pipeline.\u003c/p\u003e\u003cp\u003eWe’ll discuss our CI setup in a separate article, but suffice to say that we have aggressively optimized it and managed to reduce the agent pool from 10 to 5, still maintaining a good level of service.\u003c/p\u003e\u003cp\u003eParallelisation sensibly complicates the Jenkinsfiles and their maintainability, spreads the cost of checking out the repository across nodes and makes the logs harder to read. The main benefit would come from running the app UI tests on different nodes. In the WWDC\u003ca href=\"https://developer.apple.com/videos/play/wwdc2019/413/?ref=albertodebortoli.com\" rel=\"noopener nofollow\"\u003e session 413\u003c/a\u003e, Apple recommends generating the \u003ccode\u003e.xctestrun\u003c/code\u003e file using the build-for-testing option in xcodebuild and distribute it across the other nodes. Since our app is quite large, such file is also large and transferring it has its costs, both in time and bandwidth usage.\u003c/p\u003e\u003cp\u003eAll things considered, we decided to keep the majority of our pipelines serial.\u003c/p\u003e\u003cp\u003eEDIT: In 2022 we have parallelised our PR pipeline in 4 branches:\u003c/p\u003e\u003cul\u003e\u003cli\u003eValidation steps (linting, Fastlane lanes tests, etc.)\u003c/li\u003e\u003cli\u003eApp unit tests\u003c/li\u003e\u003cli\u003eApp UI tests (short enough that there\u0026#39;s no need to share \u003ccode\u003e.xctestrun\u003c/code\u003e across nodes)\u003c/li\u003e\u003cli\u003eModified modules unit tests\u003c/li\u003e\u003cli\u003eModified modules UI tests\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"conclusions\"\u003eConclusions\u003c/h2\u003e\u003cp\u003eWe have used the setup described in this article since mid-2020 and we are very satisfied with it. We discussed the pipeline used for the pull requests which is the most relevant one when it comes to embracing a monorepo structure. We have a few more pipelines for various use cases, such as verifying changes in release branches, keeping the code coverage metrics up-to-date with jobs running of triggers, archiving the app for internal usage and for App Store.\u003c/p\u003e\u003cp\u003eWe hope to have given you some useful insights on how to structure a monorepo and its CI pipelines, especially if you have a structure similar to ours.\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "21 min read",
  "publishedTime": "2021-06-16T12:01:10Z",
  "modifiedTime": "2022-04-30T11:50:00Z"
}
