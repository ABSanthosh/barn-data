{
  "id": "2f10280e-2d30-4aed-bc61-e050c709163e",
  "title": "Understanding SwiftUI view lifecycles",
  "link": "https://oleb.net/2022/swiftui-view-lifecycle/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2022-12-15T20:52:46Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann …",
  "length": 4278,
  "excerpt": "I wrote an app for observing how various SwiftUI constructs and container views affect view lifecycles, including the lifetime of state.",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "I wrote an app called SwiftUI View Lifecycle. The app allows you to observe how different SwiftUI constructs and containers affect a view’s lifecycle, including the lifetime of its state and when onAppear gets called. The code for the app is on GitHub. It can be built for iOS and macOS. The view tree and the render tree When we write SwiftUI code, we construct a view tree that consists of nested view values. Instances of the view tree are ephemeral: SwiftUI constantly destroys and recreates (parts of) the view tree as it processes state changes. The view tree serves as a blueprint from which SwiftUI creates a second tree, which represents the actual view “objects” that are “on screen” at any given time (the “objects” could be actual UIView or NSView objects, but also other representations; the exact meaning of “on screen” can vary depending on context). Chris Eidhof likes to call this second tree the render tree (the link points to a 3 minute video where Chris demonstrates this duality, highly recommended). The render tree persists across state changes and is used by SwiftUI to establish view identity. When a state change causes a change in a view’s value, SwiftUI will find the corresponding view object in the render tree and update it in place, rather than recreating a new view object from scratch. This is of course key to making SwiftUI efficient, but the render tree has another important function: it controls the lifetimes of views and their state. View lifecycles and state We can define a view’s lifetime as the timespan it exists in the render tree. The lifetime begins with the insertion into the render tree and ends with the removal. Importantly, the lifetime extends to view state defined with @State and @StateObject: when a view gets removed from the render tree, its state is lost; when the view gets inserted again later, the state will be recreated with its initial value. The SwiftUI View Lifecycle app tracks three lifecycle events for a view and displays them as timestamps: @State = when the view’s state was created (equivalent to the start of the view’s lifetime) onAppear = when onAppear was last called onDisappear = when onDisappear was last called The lifecycle monitor view displays the timestamps when certain lifecycle events last occurred. The app allows you to observe these events in different contexts. As you click your way through the examples, you’ll notice that the timing of these events changes depending on the context a view is embedded in. For example: An if/else statement creates and destroys its child views every time the condition changes; state is not preserved. A ScrollView eagerly inserts all of its children into the render tree, regardless of whether they’re inside the viewport or not. All children appear right away and never disappear. A List with dynamic content (using ForEach) lazily inserts only the child views that are currently visible. But once a child view’s lifetime has started, the list will keep its state alive even when it gets scrolled offscreen again. onAppear and onDisappear get called repeatedly as views are scrolled into and out of the viewport. A NavigationStack calls onAppear and onDisappear as views are pushed and popped. State for parent levels in the stack is preserved when a child view is pushed. A TabView starts the lifetime of all child views right away, even the non-visible tabs. onAppear and onDisappear get called repeatedly as the user switches tabs, but the tab view keeps the state alive for all tabs. Lessons Here are a few lessons to take away from this: Different container views may have different performance and memory usage behaviors, depending on how long they keep child views alive. onAppear isn’t necessarily called when the state is created. It can happen later (but never earlier). onAppear can be called multiple times in some container views. If you need a side effect to happen exactly once in a view’s lifetime, consider writing yourself an onFirstAppear helper, as shown by Ian Keen and Jordan Morgan in Running Code Only Once in SwiftUI (2022-11-01). I’m sure you’ll find more interesting tidbits when you play with the app. Feedback is welcome!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003eI wrote an app called \u003ca href=\"https://github.com/ole/swiftui-view-lifecycle\"\u003eSwiftUI View Lifecycle\u003c/a\u003e. The app allows you to observe how different SwiftUI constructs and containers affect a view’s lifecycle, including the lifetime of its state and when \u003ccode\u003eonAppear\u003c/code\u003e gets called. \u003ca href=\"https://github.com/ole/swiftui-view-lifecycle\"\u003eThe code for the app is on GitHub\u003c/a\u003e. It can be built for iOS and macOS.\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cfigure\u003e\n  \u003ca href=\"https://oleb.net/media/2022-12-15-swiftui-view-lifecycle-ios.png\"\u003e\n  \u003cimg src=\"https://oleb.net/media/2022-12-15-swiftui-view-lifecycle-ios-1334px.png\" alt=\"iPhone screenshots of the SwiftUI View Lifecycle app\"/\u003e\n  \u003c/a\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003cdiv\u003e\n\u003cfigure\u003e\n  \u003ca href=\"https://oleb.net/media/2022-12-15-swiftui-view-lifecycle-mac.png\"\u003e\n  \u003cimg src=\"https://oleb.net/media/2022-12-15-swiftui-view-lifecycle-mac-1500px.png\" alt=\"Mac screenshot of the SwiftUI View Lifecycle app\"/\u003e\n  \u003c/a\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"the-view-tree-and-the-render-tree\"\u003eThe view tree and the render tree\u003c/h2\u003e\n\n\u003cp\u003eWhen we write SwiftUI code, we construct a view tree that consists of nested view \u003cem\u003evalues\u003c/em\u003e. Instances of the view tree are ephemeral: SwiftUI constantly destroys and recreates (parts of) the view tree as it processes state changes.\u003c/p\u003e\n\n\u003cp\u003eThe view tree serves as a blueprint from which SwiftUI creates a second tree, which represents the actual view “objects” that are “on screen” at any given time (the “objects” could be actual \u003ccode\u003eUIView\u003c/code\u003e or \u003ccode\u003eNSView\u003c/code\u003e objects, but also other representations; the exact meaning of “on screen” can vary depending on context). \u003ca href=\"https://twitter.com/chriseidhof/status/1593508702081916930\"\u003eChris Eidhof likes to call this second tree the \u003cem\u003erender tree\u003c/em\u003e\u003c/a\u003e (the link points to a 3 minute video where Chris demonstrates this duality, highly recommended).\u003c/p\u003e\n\n\u003cp\u003eThe render tree persists across state changes and is used by SwiftUI to establish view \u003cem\u003eidentity\u003c/em\u003e. When a state change causes a change in a view’s \u003cem\u003evalue\u003c/em\u003e, SwiftUI will find the corresponding view \u003cem\u003eobject\u003c/em\u003e in the render tree and update it in place, rather than recreating a new view object from scratch. This is of course key to making SwiftUI efficient, but the render tree has another important function: it controls the lifetimes of views and their state.\u003c/p\u003e\n\n\u003ch2 id=\"view-lifecycles-and-state\"\u003eView lifecycles and state\u003c/h2\u003e\n\n\u003cp\u003eWe can define a view’s \u003cem\u003elifetime\u003c/em\u003e as the timespan it exists in the render tree. The lifetime begins with the insertion into the render tree and ends with the removal. Importantly, the lifetime extends to view state defined with \u003ca href=\"https://developer.apple.com/documentation/swiftui/state\"\u003e\u003ccode\u003e@State\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/documentation/swiftui/stateobject\"\u003e\u003ccode\u003e@StateObject\u003c/code\u003e\u003c/a\u003e: when a view gets removed from the render tree, its state is lost; when the view gets inserted again later, the state will be recreated with its initial value.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/ole/swiftui-view-lifecycle\"\u003eThe SwiftUI View Lifecycle app\u003c/a\u003e tracks three lifecycle events for a view and displays them as timestamps:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e@State = when the view’s state was created (equivalent to the start of the view’s lifetime)\u003c/li\u003e\n  \u003cli\u003eonAppear = when \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/onappear(perform:)\"\u003e\u003ccode\u003eonAppear\u003c/code\u003e\u003c/a\u003e was last called\u003c/li\u003e\n  \u003cli\u003eonDisappear = when \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/ondisappear(perform:)\"\u003e\u003ccode\u003eonDisappear\u003c/code\u003e\u003c/a\u003e was last called\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv\u003e\n\u003cfigure\u003e\n  \u003ca href=\"https://oleb.net/media/2022-12-15-swiftui-view-lifecycle-monitor.png\"\u003e\n  \u003cimg src=\"https://oleb.net/media/2022-12-15-swiftui-view-lifecycle-monitor.png\" alt=\"A table with three rows. @State: 1:26 ago. onAppear: 0:15 ago. onDisappear: 0:47 ago.\"/\u003e\n  \u003c/a\u003e\n  \u003cfigcaption\u003e\n    The lifecycle monitor view displays the timestamps when certain lifecycle events last occurred.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003cp\u003eThe app allows you to observe these events in different contexts. As you click your way through the examples, you’ll notice that the timing of these events changes depending on the context a view is embedded in. For example:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eAn \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e statement creates and destroys its child views every time the condition changes; state is not preserved.\u003c/li\u003e\n  \u003cli\u003eA \u003ca href=\"https://developer.apple.com/documentation/swiftui/scrollview\"\u003e\u003ccode\u003eScrollView\u003c/code\u003e\u003c/a\u003e eagerly inserts all of its children into the render tree, regardless of whether they’re inside the viewport or not. All children \u003cem\u003eappear\u003c/em\u003e right away and never \u003cem\u003edisappear\u003c/em\u003e.\u003c/li\u003e\n  \u003cli\u003eA \u003ca href=\"https://developer.apple.com/documentation/swiftui/list\"\u003e\u003ccode\u003eList\u003c/code\u003e\u003c/a\u003e with dynamic content (using \u003ca href=\"https://developer.apple.com/documentation/swiftui/foreach\"\u003e\u003ccode\u003eForEach\u003c/code\u003e\u003c/a\u003e) lazily inserts only the child views that are currently visible. But once a child view’s lifetime has started, the list will keep its state alive even when it gets scrolled offscreen again. \u003ccode\u003eonAppear\u003c/code\u003e and \u003ccode\u003eonDisappear\u003c/code\u003e get called repeatedly as views are scrolled into and out of the viewport.\u003c/li\u003e\n  \u003cli\u003eA \u003ca href=\"https://developer.apple.com/documentation/swiftui/navigationstack\"\u003e\u003ccode\u003eNavigationStack\u003c/code\u003e\u003c/a\u003e calls \u003ccode\u003eonAppear\u003c/code\u003e and \u003ccode\u003eonDisappear\u003c/code\u003e as views are pushed and popped. State for parent levels in the stack is preserved when a child view is pushed.\u003c/li\u003e\n  \u003cli\u003eA \u003ca href=\"https://developer.apple.com/documentation/swiftui/tabview\"\u003e\u003ccode\u003eTabView\u003c/code\u003e\u003c/a\u003e starts the lifetime of all child views right away, even the non-visible tabs. \u003ccode\u003eonAppear\u003c/code\u003e and \u003ccode\u003eonDisappear\u003c/code\u003e get called repeatedly as the user switches tabs, but the tab view keeps the state alive for all tabs.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"lessons\"\u003eLessons\u003c/h2\u003e\n\n\u003cp\u003eHere are a few lessons to take away from this:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eDifferent container views may have different performance and memory usage behaviors, depending on how long they keep child views alive.\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eonAppear\u003c/code\u003e isn’t necessarily called when the state is created. It can happen later (but never earlier).\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eonAppear\u003c/code\u003e can be called multiple times in some container views. If you need a side effect to happen exactly once in a view’s lifetime, consider writing yourself an \u003ccode\u003eonFirstAppear\u003c/code\u003e helper, as shown by Ian Keen and Jordan Morgan in \u003ca href=\"https://www.swiftjectivec.com/swiftui-run-code-only-once-versus-onappear-or-task/\"\u003eRunning Code Only Once in SwiftUI (2022-11-01)\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eI’m sure you’ll find more interesting tidbits when you play with the app. Feedback is welcome!\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2022-12-15T20:52:46Z",
  "modifiedTime": "2022-12-16T09:52:45Z"
}
