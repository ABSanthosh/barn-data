{
  "id": "fbc4d67d-0051-4b7d-8210-92deb884528c",
  "title": "JSON vs Property Lists, Revisited",
  "link": "https://atomicbird.com/blog/json-vs-plists-2020/",
  "description": "In a previous post I wrote about How JSON compares to Apple property lists and the obstacles to converting data between them. That was a while ago but the post is still accurate, as far as it goes. But Swift changes the situation in some ways, so an update is in order. Recap: JSON vs. Property Lists The previous post was motivated by the problems some people encountered trying to download JSON from a server and then save it as a property list.",
  "author": "",
  "published": "Tue, 03 Mar 2020 00:00:00 +0000",
  "source": "https://atomicbird.com/index.xml",
  "categories": null,
  "byline": "",
  "length": 6522,
  "excerpt": "In a previous post I wrote about How JSON compares to Apple property lists and the obstacles to converting data between them. That was a while ago but the post is still accurate, as far as it goes. But Swift changes the situation in some ways, so an update is in order. Recap: JSON vs. Property Lists The previous post was motivated by the problems some people encountered trying to download JSON from a server and then save it as a property list.",
  "siteName": "Title",
  "favicon": "https://atomicbird.com/apple-touch-icon-144-precomposed.png",
  "text": "In a previous post I wrote about How JSON compares to Apple property lists and the obstacles to converting data between them. That was a while ago but the post is still accurate, as far as it goes. But Swift changes the situation in some ways, so an update is in order. Recap: JSON vs. Property Lists The previous post was motivated by the problems some people encountered trying to download JSON from a server and then save it as a property list. Converting between JSON and property lists often works but can fail due to conflicts in data types. JSON often includes null values for keys. These would be translated to NSNull when parsing JSON, which would mean the data wasn‚Äôt a valid property list. Property lists can include dates, base64-encoded data, and floating point numbers where the value is ¬±infinity or ‚Äúnot a number‚Äù. None of these can exist in JSON without converting the data somehow, only Foundation didn‚Äôt provide any built-in conversions. But, why? Why convert JSON to a property list? It‚Äôs a good question, and more relevant now than when I wrote the original post. JSON support has drastically improved, as I‚Äôll discuss below. It‚Äôs reasonable to keep JSON data as JSON. But property lists are still ubiquitous in iOS and Mac development, so conversion still happens sometimes. I‚Äôm hoping that this post can help smooth out the bumps when converting is needed. Revisting [NS]JSONSerialization If you‚Äôre using Objective-C, NSJSONSerialization hasn‚Äôt changed. Go see my previous post if you‚Äôre having trouble converting to or from a property list. If you‚Äôre using Swift, then JSONSerialization includes a slight change in behavior, related to differences in how Swift dictionaries work compared to Objective-C. Depending on your code, a JSON null might be represented by a doubly-wrapped nil value in the resulting dictionary. That‚Äôs something Swift dictionaries allow but Objective-C does not. Whether that‚Äôs what you get depends on whether you allow nil entries, that is, whether your dictionary is able to hold optional values. Suppose you have this trivial JSON: { \"date\": \"2020-02-26T03:56:56Z\", \"thingThatMightBeNull\": null } Let‚Äôs try converting it with JSONSerialization in two slightly different ways. First, try allowing optional values: let json = try? JSONSerialization.jsonObject(with: jsonData, options: []) as? [String:Any?], Since nil values are allowed in the converted dictionary, the type of json[\"thingThatMightBeNull\"] is Optional\u003cOptional\u003cAny\u003e\u003e.Type, a doubly-wrapped optional. There are various ways to handle those. I prefer looking for what I expect by doing something like if let thing = json[\"thingThatMightBeNull\"] as? String { ... } You don‚Äôt have to allow optionals. If you don‚Äôt, the result is slightly different. If you do this: let json = try? JSONSerialization.jsonObject(with: jsonData, options: []) as? [String:Any] This doesn‚Äôt allow optionals, but the conversion still works. This time the type of json[\"thingThatMightBeNull\"] is Optional\u003cAny\u003e.Type. If you unwrap it, you‚Äôll get our old friend NSNull. That‚Äôs not nil, so it‚Äôs OK for a structure that can‚Äôt contain nil values. If you‚Äôre aiming for a property list though, it doesn‚Äôt matter which you use. Neither version is valid property list data, so the handy write(toFile:, atomically:) function will fail. üò≠ The Rise of Skywalker Codable Swift gives us a different approach, thanks to Codable. If you declare a type for your data‚Äì a struct or whatever‚Äì instead of using a dictionary directly, you can bypass the problem by using JSONDecoder to parse the JSON, followed by using PropertyListEncoder to create the property list. A JSON null ends up as a nil value for one of your struct properties. The property list leaves that property out. So both formats handle the missing value as expected even though they have different ideas about nil/null values. Using the JSON from above, you might define this structure: struct MyStruct: Codable { var date: String? var thingThatMightBeNull: String? } Parsing the JSON is straightforward with JSONDecoder. As expected, date contains a string and thingThatMightBeNull is nil. Converting that to a property list is nearly as simple: let plistEncoder = PropertyListEncoder() plistEncoder.outputFormat = .xml guard let encodedPlistData = try? plistEncoder.encode(myThing), let encodedPlistString = String(data:encodedPlistData, encoding: .utf8) else { return } At this point encodedPlistString looks like this. There‚Äôs no value for thingThatMightBeNull since that‚Äôs how nil values are usually handled with property lists. \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"\u003e \u003cplist version=\"1.0\"\u003e \u003cdict\u003e \u003ckey\u003edate\u003c/key\u003e \u003cstring\u003e2020-02-26T03:56:56Z\u003c/string\u003e \u003c/dict\u003e \u003c/plist\u003e Other data types Some of you will have noticed that the date property was declared as a String?. Why not Date? Why not indeed. JSONDecoder supports a some built-in data conversions, which can give you more meaningful data and‚Äì since it‚Äôs the topic of this post‚Äì lead to more meaningful property lists. If I redefine the struct above like this: struct MyStruct: Codable { var date: Date? var thingThatMightBeNull: String? } I can then decode the JSON above by setting the decoder‚Äôs dateDecodingStrategy to .iso8601. Converting to a property list uses exactly the same code but now the result looks like this: \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"\u003e \u003cplist version=\"1.0\"\u003e \u003cdict\u003e \u003ckey\u003edate\u003c/key\u003e \u003cdate\u003e2020-02-26T03:56:56Z\u003c/date\u003e \u003c/dict\u003e \u003c/plist\u003e It‚Äôs almost the same, but now the value is a \u003cdate\u003e element instead of a \u003cstring\u003e. Other converters are available for binary data and the ‚Äúnon conforming‚Äù floating point values mentioned above. The same conversions are available in the other direction. If you‚Äôre converting from a property list to JSON, it used to be that dates and binary data could require a bunch of extra work. With the built-in conversions though, the framework almost certainly has you covered. No really, why? If you‚Äôre working in Swift, as most iOS developers seem to be today, it‚Äôs a fair question of why you‚Äôd convert from JSON to a property list. With JSONEncoder you can easily convert Codable data structures to Data and keep them as JSON. You‚Äôre still likely to encounter property lists though, so it can be handy to know how to deal with them.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \u003cp\u003eIn a previous post I wrote about \u003ca href=\"https://atomicbird.com/blog/json-vs-plists/\"\u003eHow JSON compares to Apple property lists\u003c/a\u003e and the obstacles to converting data between them. That was a while ago but the post is still accurate, as far as it goes. But Swift changes the situation in some ways, so an update is in order.\u003c/p\u003e\n\u003ch3 id=\"recap-json-vs-property-lists\"\u003eRecap: JSON vs. Property Lists\u003c/h3\u003e\n\u003cp\u003eThe previous post was motivated by the problems some people encountered trying to download JSON from a server and then save it as a property list. Converting between JSON and property lists often works but can fail due to conflicts in data types.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJSON often includes \u003ccode\u003enull\u003c/code\u003e values for keys. These would be translated to \u003ccode\u003eNSNull\u003c/code\u003e when parsing JSON, which would mean the data wasn‚Äôt a valid property list.\u003c/li\u003e\n\u003cli\u003eProperty lists can include dates, base64-encoded data, and floating point numbers where the value is ¬±infinity or ‚Äúnot a number‚Äù. None of these can exist in JSON without converting the data somehow, only Foundation didn‚Äôt provide any built-in conversions.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"but-why\"\u003eBut, why?\u003c/h3\u003e\n\u003cp\u003eWhy convert JSON to a property list? It‚Äôs a good question, and more relevant now than when I wrote the original post. JSON support has drastically improved, as I‚Äôll discuss below. It‚Äôs reasonable to keep JSON data as JSON. But property lists are still ubiquitous in iOS and Mac development, so conversion still happens sometimes. I‚Äôm hoping that this post can help smooth out the bumps when converting is needed.\u003c/p\u003e\n\u003ch3 id=\"revisting-nsjsonserialization\"\u003eRevisting [NS]JSONSerialization\u003c/h3\u003e\n\u003cp\u003eIf you‚Äôre using Objective-C, \u003ccode\u003eNSJSONSerialization\u003c/code\u003e hasn‚Äôt changed. Go see my previous post if you‚Äôre having trouble converting to or from a property list.\u003c/p\u003e\n\u003cp\u003eIf you‚Äôre using Swift, then \u003ccode\u003eJSONSerialization\u003c/code\u003e includes a slight change in behavior, related to differences in how Swift dictionaries work compared to Objective-C. Depending on your code, a JSON \u003ccode\u003enull\u003c/code\u003e \u003cem\u003emight\u003c/em\u003e be represented by a doubly-wrapped \u003ccode\u003enil\u003c/code\u003e value in the resulting dictionary. That‚Äôs something Swift dictionaries allow but Objective-C does not.\u003c/p\u003e\n\u003cp\u003eWhether that‚Äôs what you get depends on whether you allow nil entries, that is, whether your dictionary is able to hold optional values. Suppose you have this trivial JSON:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"json\"\u003e\u003cspan\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e\u0026#34;date\u0026#34;\u003c/span\u003e: \u003cspan\u003e\u0026#34;2020-02-26T03:56:56Z\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e\u0026#34;thingThatMightBeNull\u0026#34;\u003c/span\u003e: \u003cspan\u003enull\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet‚Äôs try converting it with \u003ccode\u003eJSONSerialization\u003c/code\u003e in two slightly different ways.\u003c/p\u003e\n\u003cp\u003eFirst, try allowing optional values:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e json = \u003cspan\u003etry\u003c/span\u003e? JSONSerialization.jsonObject(with: jsonData, options: []) \u003cspan\u003eas\u003c/span\u003e? [String:Any?],\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSince nil values are allowed in the converted dictionary, the type of \u003ccode\u003ejson[\u0026#34;thingThatMightBeNull\u0026#34;]\u003c/code\u003e is \u003ccode\u003eOptional\u0026lt;Optional\u0026lt;Any\u0026gt;\u0026gt;.Type\u003c/code\u003e, a doubly-wrapped optional. There are various ways to handle those. I prefer looking for what I expect by doing something like\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e thing = json[\u003cspan\u003e\u0026#34;thingThatMightBeNull\u0026#34;\u003c/span\u003e] \u003cspan\u003eas\u003c/span\u003e? String { ... }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eYou don‚Äôt have to allow optionals. If you don‚Äôt, the result is slightly different. If you do this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e json = \u003cspan\u003etry\u003c/span\u003e? JSONSerialization.jsonObject(with: jsonData, options: []) \u003cspan\u003eas\u003c/span\u003e? [String:Any]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis doesn‚Äôt allow optionals, but the conversion still works. This time the type of \u003ccode\u003ejson[\u0026#34;thingThatMightBeNull\u0026#34;]\u003c/code\u003e is \u003ccode\u003eOptional\u0026lt;Any\u0026gt;.Type\u003c/code\u003e. If you unwrap it, you‚Äôll get our old friend \u003ccode\u003eNSNull\u003c/code\u003e. That‚Äôs not nil, so it‚Äôs OK for a structure that can‚Äôt contain nil values.\u003c/p\u003e\n\u003cp\u003eIf you‚Äôre aiming for a property list though, it doesn‚Äôt matter which you use. Neither version is valid property list data, so the handy \u003ccode\u003ewrite(toFile:, atomically:)\u003c/code\u003e function will fail. üò≠\u003c/p\u003e\n\u003ch3 id=\"the-rise-of-skywalker-codable\"\u003eThe Rise of \u003cdel\u003eSkywalker\u003c/del\u003e Codable\u003c/h3\u003e\n\u003cp\u003eSwift gives us a different approach, thanks to \u003ccode\u003eCodable\u003c/code\u003e. If you declare a type for your data‚Äì a \u003ccode\u003estruct\u003c/code\u003e or whatever‚Äì instead of using a dictionary directly, you can bypass the problem by using \u003ccode\u003eJSONDecoder\u003c/code\u003e to parse the JSON, followed by using \u003ccode\u003ePropertyListEncoder\u003c/code\u003e to create the property list. A JSON \u003ccode\u003enull\u003c/code\u003e ends up as a nil value for one of your struct properties. The property list leaves that property out. So both formats handle the missing value as expected even though they have different ideas about nil/null values.\u003c/p\u003e\n\u003cp\u003eUsing the JSON from above, you might define this structure:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eMyStruct\u003c/span\u003e: Codable {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e date: String?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e thingThatMightBeNull: String?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eParsing the JSON is straightforward with \u003ccode\u003eJSONDecoder\u003c/code\u003e. As expected, \u003ccode\u003edate\u003c/code\u003e contains a string and \u003ccode\u003ethingThatMightBeNull\u003c/code\u003e is nil. Converting that to a property list is nearly as simple:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e plistEncoder = PropertyListEncoder()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eplistEncoder.outputFormat = .xml\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e encodedPlistData = \u003cspan\u003etry\u003c/span\u003e? plistEncoder.encode(myThing),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e encodedPlistString = String(data:encodedPlistData, encoding: .utf8) \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAt this point \u003ccode\u003eencodedPlistString\u003c/code\u003e looks like this. There‚Äôs no value for \u003ccode\u003ethingThatMightBeNull\u003c/code\u003e since that‚Äôs how nil values are usually handled with property lists.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"xml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;plist\u003c/span\u003e \u003cspan\u003eversion=\u003c/span\u003e\u003cspan\u003e\u0026#34;1.0\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;dict\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e\u0026lt;key\u0026gt;\u003c/span\u003edate\u003cspan\u003e\u0026lt;/key\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e\u0026lt;string\u0026gt;\u003c/span\u003e2020-02-26T03:56:56Z\u003cspan\u003e\u0026lt;/string\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;/dict\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;/plist\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"other-data-types\"\u003eOther data types\u003c/h3\u003e\n\u003cp\u003eSome of you will have noticed that the \u003ccode\u003edate\u003c/code\u003e property was declared as a \u003ccode\u003eString?\u003c/code\u003e. Why not \u003ccode\u003eDate\u003c/code\u003e? Why not indeed. \u003ccode\u003eJSONDecoder\u003c/code\u003e supports a some built-in data conversions, which can give you more meaningful data and‚Äì since it‚Äôs the topic of this post‚Äì lead to more meaningful property lists. If I redefine the struct above like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eMyStruct\u003c/span\u003e: Codable {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e date: Date?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e thingThatMightBeNull: String?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI can then decode the JSON above by setting the decoder‚Äôs \u003ccode\u003edateDecodingStrategy\u003c/code\u003e to \u003ccode\u003e.iso8601\u003c/code\u003e. Converting to a property list uses exactly the same code but now the result looks like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"xml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;plist\u003c/span\u003e \u003cspan\u003eversion=\u003c/span\u003e\u003cspan\u003e\u0026#34;1.0\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;dict\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e\u0026lt;key\u0026gt;\u003c/span\u003edate\u003cspan\u003e\u0026lt;/key\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e\u0026lt;date\u0026gt;\u003c/span\u003e2020-02-26T03:56:56Z\u003cspan\u003e\u0026lt;/date\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;/dict\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;/plist\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIt‚Äôs almost the same, but now the value is a \u003ccode\u003e\u0026lt;date\u0026gt;\u003c/code\u003e element instead of a \u003ccode\u003e\u0026lt;string\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOther converters are available for binary data and the ‚Äúnon conforming‚Äù floating point values mentioned above.\u003c/p\u003e\n\u003cp\u003eThe same conversions are available in the other direction. If you‚Äôre converting from a property list to JSON, it used to be that dates and binary data could require a bunch of extra work. With the built-in conversions though, the framework almost certainly has you covered.\u003c/p\u003e\n\u003ch3 id=\"no-really-why\"\u003eNo really, why?\u003c/h3\u003e\n\u003cp\u003eIf you‚Äôre working in Swift, as most iOS developers seem to be today, it‚Äôs a fair question of why you‚Äôd convert from JSON to a property list. With \u003ccode\u003eJSONEncoder\u003c/code\u003e you can easily convert \u003ccode\u003eCodable\u003c/code\u003e data structures to \u003ccode\u003eData\u003c/code\u003e and keep them as JSON. You‚Äôre still likely to encounter property lists though, so it can be handy to know how to deal with them.\u003c/p\u003e\n\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2020-03-03T00:00:00Z",
  "modifiedTime": "2020-03-03T00:00:00Z"
}
