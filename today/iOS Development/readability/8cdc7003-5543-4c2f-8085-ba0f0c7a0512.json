{
  "id": "8cdc7003-5543-4c2f-8085-ba0f0c7a0512",
  "title": "Xcode 14.0 generates wrong concurrency code for macOS targets",
  "link": "https://oleb.net/2022/xcode-14-mac-concurrency-bugs/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2022-10-12T19:12:17Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann …",
  "length": 4361,
  "excerpt": "Mac apps built with Xcode 14.0 and 14.0.1 may contain concurrency bugs because the Swift 5.7 compiler can generate invalid code when targeting the macOS 12 SDK. If you distribute Mac apps, you should build them with Xcode 13.4.1 until Xcode 14.1 is released.",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "Mac apps built with Xcode 14.0 and 14.0.1 may contain concurrency bugs because the Swift 5.7 compiler can generate invalid code when targeting the macOS 12.3 SDK. If you distribute Mac apps, you should build them with Xcode 13.4.1 until Xcode 14.1 is released. Here’s what happened: Swift 5.7 implements SE-0338: Clarify the Execution of Non-Actor-Isolated Async Functions, which introduces new rules how async functions hop between executors. Because of SE-0338, when compiling concurrency code, the Swift 5.7 compiler places executor hops in different places than Swift 5.6. Some standard library functions need to opt out of the new rules. They are annotated with a new, unofficial attribute @_unsafeInheritExecutor, which was introduced for this purpose. When the Swift 5.7 compiler sees this attribute, it generates different executor hops. The attribute is only present in the Swift 5.7 standard library, i.e. in the iOS 16 and macOS 13 SDKs. This is fine for iOS because compiler version and the SDK’s standard library version match in Xcode 14.0. But for macOS targets, Xcode 14.0 uses the Swift 5.7 compiler with the standard library from Swift 5.6, which doesn’t contain the @_unsafeInheritExecutor attribute. This is what causes the bugs. Note that the issue is caused purely by the version mismatch at compile-time. The standard library version used by the compiled app at run-time (which depends on the OS version the app runs on) isn’t relevant. As soon as Xcode 14.1 gets released with the macOS 13 SDK, the version mismatch will go away, and Mac targets built with Xcode 14.1 won’t exhibit these bugs. Third-party developers had little chance of discovering the bug during the Xcode 14.0 beta phase because the betas ship with the new beta macOS SDK. The version mismatch occurs when the final Xcode release in September reverts back to the old macOS SDK to accommodate the different release schedules of iOS and macOS. Sources Breaking concurrency invariants is a serious issue, though I’m not sure how much of a problem this is in actual production apps. Here are all related bug reports that I know of: Concurrency is broken in Xcode 14 for macOS (2022-09-14) withUnsafeContinuation can break actor isolation (2022-10-07) And explanations of the cause from John McCall of the Swift team at Apple: John McCall (2022-10-07): This guarantee is unfortunately broken with Xcode 14 when compiling for macOS because it’s shipping with an old macOS SDK that doesn’t declare that withUnsafeContinuation inherits its caller’s execution context. And yes, there is a related actor-isolation issue because of this bug. That will be fixed by the release of the new macOS SDK. John McCall (2022-10-07): Now, there is a bug in Xcode 14 when compiling for the macOS SDK because it ships with an old SDK. That bug doesn’t actually break any of the ordering properties above. It does, however, break Swift’s data isolation guarantees because it causes withUnsafeContinuation, when called from an actor-isolated context, to send a non-Sendable function to a non-isolated executor and then call it, which is completely against the rules. And in fact, if you turn strict sendability checking on when compiling against that SDK, you will get a diagnostic about calling withUnsafeContinuation because it thinks that you’re violating the rules (because withUnsafeContinuation doesn’t properly inherit the execution context of its caller). Poor communication from Apple What bugs me most about the situation is Apple’s poor communication. When the official, current release of your programming language ships with a broken compiler for one of your most important platforms, the least I’d expect is a big red warning at the top of the release notes. I can’t find any mention of this issue in the Xcode 14.0 release notes or Xcode 14.0.1 release notes, however. Even better: the warning should be displayed prominently in Xcode, or Xcode 14.0 should outright refuse to build Mac apps. I’m sure the latter option isn’t practical for all sorts of reasons, although it sounds logical to me: if the only safe compiler/SDK combinations are either 5.6 with the macOS 12 SDK or 5.7 with the macOS 13 SDK, there shouldn’t be an official Xcode version that combines the 5.7 compiler with the macOS 12 SDK.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003eMac apps built with Xcode 14.0 and 14.0.1 may contain concurrency bugs because the Swift 5.7 compiler can generate invalid code when targeting the macOS 12.3 SDK. If you distribute Mac apps, you should build them with Xcode 13.4.1 until Xcode 14.1 is released.\u003c/p\u003e\n\n\u003cp\u003eHere’s what happened:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eSwift 5.7 implements \u003ca href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0338-clarify-execution-non-actor-async.md\"\u003eSE-0338: Clarify the Execution of Non-Actor-Isolated Async Functions\u003c/a\u003e, which introduces new rules how async functions hop between executors. Because of SE-0338, when compiling concurrency code, the Swift 5.7 compiler places executor hops in different places than Swift 5.6.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eSome standard library functions need to opt out of the new rules. They are annotated with a new, unofficial attribute \u003ca href=\"https://github.com/apple/swift/blob/d977dd101fa8da3a53c9b690e5232be8c5aafa28/docs/ReferenceGuides/UnderscoredAttributes.md#_unsafeinheritexecutor\"\u003e\u003ccode\u003e@_unsafeInheritExecutor\u003c/code\u003e\u003c/a\u003e, which was introduced for this purpose. When the Swift 5.7 compiler sees this attribute, it generates different executor hops.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eThe attribute is only present in the Swift 5.7 standard library, i.e. in the iOS 16 and macOS 13 SDKs. This is fine for iOS because compiler version and the SDK’s standard library version match in Xcode 14.0. But for macOS targets, Xcode 14.0 uses the Swift 5.7 compiler with the standard library from Swift 5.6, which doesn’t contain the \u003ccode\u003e@_unsafeInheritExecutor\u003c/code\u003e attribute. This is what causes the bugs.\u003c/p\u003e\n\n    \u003cp\u003eNote that the issue is caused purely by the version mismatch at compile-time. The standard library version used by the compiled app at run-time (which depends on the OS version the app runs on) isn’t relevant. As soon as Xcode 14.1 gets released with the macOS 13 SDK, the version mismatch will go away, and Mac targets built with Xcode 14.1 won’t exhibit these bugs.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eThird-party developers had little chance of discovering the bug during the Xcode 14.0 beta phase because the betas ship with the new beta macOS SDK. The version mismatch occurs when the final Xcode release in September reverts back to the old macOS SDK to accommodate the different release schedules of iOS and macOS.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"sources\"\u003eSources\u003c/h2\u003e\n\n\u003cp\u003eBreaking concurrency invariants is a serious issue, though I’m not sure how much of a problem this is in actual production apps. Here are all related bug reports that I know of:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://forums.swift.org/t/concurrency-is-broken-in-xcode-14-for-macos/60294\"\u003eConcurrency is broken in Xcode 14 for macOS (2022-09-14)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/apple/swift/issues/61485\"\u003e\u003ccode\u003ewithUnsafeContinuation\u003c/code\u003e can break actor isolation (2022-10-07)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAnd explanations of the cause from John McCall of the Swift team at Apple:\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/groue/Semaphore/discussions/2#discussioncomment-3826233\"\u003eJohn McCall (2022-10-07)\u003c/a\u003e:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eThis guarantee is unfortunately broken with Xcode 14 when compiling for macOS because it’s shipping with an old macOS SDK that doesn’t declare that \u003ccode\u003ewithUnsafeContinuation\u003c/code\u003e inherits its caller’s execution context. And yes, there is a related actor-isolation issue because of this bug. That will be fixed by the release of the new macOS SDK.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"https://forums.swift.org/t/clarification-needed-on-unsafecontinuation-documentation/57803/16\"\u003eJohn McCall (2022-10-07)\u003c/a\u003e:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eNow, there is a bug in Xcode 14 when compiling for the macOS SDK because it ships with an old SDK. That bug doesn’t actually break any of the ordering properties above. It does, however, break Swift’s data isolation guarantees because it causes \u003ccode\u003ewithUnsafeContinuation\u003c/code\u003e, when called from an actor-isolated context, to send a non-\u003ccode\u003eSendable\u003c/code\u003e function to a non-isolated executor and then call it, which is completely against the rules. And in fact, if you turn strict sendability checking on when compiling against that SDK, you will get a diagnostic about calling \u003ccode\u003ewithUnsafeContinuation\u003c/code\u003e because it thinks that you’re violating the rules (because \u003ccode\u003ewithUnsafeContinuation\u003c/code\u003e doesn’t properly inherit the execution context of its caller).\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"poor-communication-from-apple\"\u003ePoor communication from Apple\u003c/h2\u003e\n\n\u003cp\u003eWhat bugs me most about the situation is Apple’s poor communication. When the official, current release of your programming language ships with a broken compiler for one of your most important platforms, the least I’d expect is a big red warning at the top of the release notes. I can’t find any mention of this issue in the \u003ca href=\"https://developer.apple.com/documentation/xcode-release-notes/xcode-14-release-notes\"\u003eXcode 14.0 release notes\u003c/a\u003e or \u003ca href=\"https://developer.apple.com/documentation/xcode-release-notes/xcode-14_0_1-release-notes\"\u003eXcode 14.0.1 release notes\u003c/a\u003e, however.\u003c/p\u003e\n\n\u003cp\u003eEven better: the warning should be displayed prominently in Xcode, or Xcode 14.0 should outright refuse to build Mac apps. I’m sure the latter option isn’t practical for all sorts of reasons, although it sounds logical to me: if the only safe compiler/SDK combinations are either 5.6 with the macOS 12 SDK or 5.7 with the macOS 13 SDK, there shouldn’t be an official Xcode version that combines the 5.7 compiler with the macOS 12 SDK.\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2022-10-12T19:12:17Z",
  "modifiedTime": "2022-10-12T19:12:17Z"
}
