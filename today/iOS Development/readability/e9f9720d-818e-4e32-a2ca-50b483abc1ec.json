{
  "id": "e9f9720d-818e-4e32-a2ca-50b483abc1ec",
  "title": "Rendering SwiftUI views within UITableView or UICollectionView cells on iOS 16",
  "link": "https://www.swiftbysundell.com/articles/rendering-swiftui-views-within-uitableview-or-uicollectionview",
  "description": "Exploring how iOS 16’s new UIHostingConfiguration API enables us to inline SwiftUI views within our UITableView or UICollectionView cells.",
  "author": "",
  "published": "Tue, 7 Jun 2022 13:00:00 +0200",
  "source": "https://swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 11948,
  "excerpt": "Exploring how iOS 16’s new UIHostingConfiguration API enables us to inline SwiftUI views within our UITableView or UICollectionView cells.",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "Ever since its original introduction in 2019, SwiftUI has had really strong interoperability with UIKit. Both UIView and UIViewController instances can be wrapped to become fully SwiftUI-compatible, and UIHostingController lets us render any SwiftUI view within a UIKit-based view controller.However, even though macOS has had an NSHostingView for inlining SwiftUI views directly within any NSView (no view controller required) since the very beginning, there has never been a built-in way to do the same thing on iOS. Sure, we could always grab the underlying view from a UIHostingController instance, or add our hosting controller to a parent view controller in order to be able to use its view deeper within a UIView-based hierarchy — but neither of those solutions have ever felt entirely smooth.That brings us to iOS 16 (which is currently in beta at the time of writing). Although Apple haven’t introduced a fully general-purpose UIHostingView as part of this release, they have addressed one of the most common challenges that the lack of such a view presents us with — which is how to render a SwiftUI view within either a UITableViewCell or UICollectionViewCell.Just a quick note before we begin: All of this article’s code samples will be entirely UITableView-based, but the exact same techniques can also be used with UICollectionView as well.Say hello to UIHostingConfigurationIn iOS 14, Apple introduced a new way to configure cells that are being rendered as part of a UITableView or UICollectionView, which lets us use so-called content configurations to decouple the content that we’re rendering from the actual subviews that our cells contain. This API has now been extended with a new UIHostingConfiguration type, which lets us define a cell’s content using any SwiftUI view hierarchy.So wherever we’re configuring our cells — for example using the good-old-fashioned UITableViewDataSource dequeuing method — we can now opt to assign such a hosting configuration to a given cell’s contentConfiguration property, and UIKit will automatically render the SwiftUI views that we provide within that cell:class ListViewController: UIViewController, UITableViewDataSource { private var items: [Item] private let databaseController: DatabaseController private let cellReuseID = \"cell\" private lazy var tableView = UITableView() ... func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u003e UITableViewCell { let cell = tableView.dequeueReusableCell( withIdentifier: cellReuseID, for: indexPath ) let item = items[indexPath.row] cell.contentConfiguration = UIHostingConfiguration { HStack { Text(item.title) Spacer() Button(action: { [weak self] in if let indexPath = self?.tableView.indexPath(for: cell) { self?.toggleFavoriteStatusForItem(atIndexPath: indexPath) } }, label: { Image(systemName: \"star\" + (item.isFavorite ? \".fill\" : \"\")) .foregroundColor(item.isFavorite ? .yellow : .gray) }) } } return cell } private func toggleFavoriteStatusForItem(atIndexPath indexPath: IndexPath) { items[indexPath.row].isFavorite.toggle() databaseController.update(items[indexPath.row]) } }Neat! As the above code sample shows, we can easily send events back from our cell’s SwiftUI views to our view controller using closures, but there are a few things that are good to keep in mind when doing so.First, you might’ve noticed that we’re asking the table view for our cell’s current index path before passing it to our toggleFavoriteStatusForItem method. That’s because, if our table view supports operations such as moves and deletions, our cell might be at a different index path once our favorite button is tapped — so if we were to capture and use the indexPath parameter that was passed into our cell configuration method, then we might accidentally end up updating the wrong model.Second, we have to remember that we still very much remain in the world of UIKit, which means that we have to take memory management into account (at least, more so than when operating in the wonderful value type-based world of SwiftUI). Hence the above [weak self] closure capture, in order to avoid retain cycles between our view controller and its UITableView.Finally, there’s state management, and just like when bridging the gap between UIKit and SwiftUI using tools like UIHostingController or UIViewRepresentable, we probably need to write a little bit of custom code to ensure that our cell’s SwiftUI view hierarchy is rendering the latest version of our view controller’s data.Managing state updatesFor example, when the user taps our cell’s favorite button, our cell is not currently updated to reflect its Item model’s new state. That’s because we’re not actually using SwiftUI’s declarative state management system to drive those updates, so there’s no way for our nested SwiftUI view hierarchy to know that its data model was modified.One way to address that would be to use UIKit to react to those changes, rather than using SwiftUI’s view updating mechanisms. We could, for instance, call our table view’s reloadRows method whenever an item’s favorite status was changed — like this:class ListViewController: UIViewController, UITableViewDataSource { ... private func toggleFavoriteStatusForItem(atIndexPath indexPath: IndexPath) { items[indexPath.row].isFavorite.toggle() databaseController.update(items[indexPath.row]) tableView.reloadRows(at: [indexPath], with: .none) } }That works great, since it’ll make the table view call our data source cell configuration method, which’ll give us a chance to update the changed item’s cell and the SwiftUI views that are embedded within it.But let’s say that we instead wanted to use SwiftUI’s state management system to keep track of when our cell’s state was modified. One way to make that happen would be to introduce some form of ObservableObject that our view controller could then inject into each cell’s SwiftUI view hierarchy.A side-benefit of introducing such a type in this case is that it’ll also give us a neat place to encapsulate all view-related logic that’s tied to our Item model, such as the code that’s used to compute our favorite button’s title and foreground color. Let’s go ahead and introduce such a class, which we’ll call ItemViewModel:class ItemViewModel: ObservableObject { @Published private(set) var item: Item private let onItemChange: (Item) -\u003e Void init(item: Item, onItemChange: @escaping (Item) -\u003e Void) { self.item = item self.onItemChange = onItemChange } func toggleFavoriteStatus() { item.isFavorite.toggle() onItemChange(item) } } extension ItemViewModel { var favoriteButtonIconName: String { \"star\" + (item.isFavorite ? \".fill\" : \"\") } var favoriteButtonColor: Color { item.isFavorite ? .yellow : .gray } }Note that we’re enabling an onItemChange closure to be passed into our view model, which’ll let our view controller observe whenever the view model’s copy of the underlying Item model was modified. We could definitely have chosen to use Combine here instead, by having our view controller hook into the publisher that’s connected to the view model’s item property, but a simple closure will get the job done in this case.Next, let’s extract our cell-embedded SwiftUI code into a dedicated View type, which will let us make our view hierarchy observe our new view model as an ObservedObject:struct ItemView: View { @ObservedObject var viewModel: ItemViewModel var body: some View { HStack { Text(viewModel.item.title) Spacer() Button(action: viewModel.toggleFavoriteStatus) { Image(systemName: viewModel.favoriteButtonIconName) .foregroundColor(viewModel.favoriteButtonColor) } } } }Finally, all that remains is to update our view controller to use our newly introduced types, which will also let us remove the toggleFavoriteStatusForItem method that we were previously using to manage each item’s favorite status:class ListViewController: UIViewController, UITableViewDataSource { ... func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u003e UITableViewCell { let cell = tableView.dequeueReusableCell( withIdentifier: cellReuseID, for: indexPath ) let viewModel = ItemViewModel( item: items[indexPath.row], onItemChange: { [weak self] item in guard let indexPath = self?.tableView.indexPath(for: cell) else { return } self?.items[indexPath.row] = item self?.databaseController.update(item) } ) cell.contentConfiguration = UIHostingConfiguration { ItemView(viewModel: viewModel) } return cell } }Very nice! Of course, the above implementation only handles internal data model changes that are performed by our view controller and its nested SwiftUI views. If those models could also be modified elsewhere, then we’d have to notify our view controller whenever that happens, and reload our table view’s data accordingly. However, the fact that we’re using SwiftUI and the new UIHostingConfiguration API doesn’t really affect the way we’d do that, since any such external updates would lead to us re-configuring our cells anyway.Bridged swipe actionsAnother neat aspect of the new UIHostingConfiguration API and the way it bridges the gap between UIKit and SwiftUI is that it’ll automatically convert any SwiftUI swipeActions that our view hierarchy contains into UIKit-based swipe actions.So for example, if we wanted to add a delete swipe action to each of our item cells, then we could do that using a modifier placed right within our UIHostingConfiguration closure — like this:cell.contentConfiguration = UIHostingConfiguration { ItemView(viewModel: viewModel).swipeActions { Button(role: .destructive, action: { [weak self] in guard let indexPath = self?.tableView.indexPath(for: cell) else { return } self?.items.remove(at: indexPath.row) self?.databaseController.delete(viewModel.item) self?.tableView.deleteRows(at: [indexPath], with: .automatic) }, label: { Label(\"Delete\", systemImage: \"trash\") }) } }However, while the above is really neat, it’s important to point out that (at the time of writing) not every aspect of SwiftUI is automatically bridged that way. For example, if we were to place a NavigationLink within our UIHostingConfiguration, then that wouldn’t automatically be wired up to any UINavigationController that our view controller is embedded in (which does happen when using UIHostingController). Hopefully that’s something that’ll be addressed at a later time.ConclusionThe interoperability between SwiftUI and UIKit keeps getting more and more powerful, which in turn enables us to continue mixing the two UI frameworks within the apps that we build. The introduction of UIHostingConfiguration is especially welcome, since UITableView and UICollectionView (which supports this new hosting configuration API in the exact same way) still offer much more functionality than their SwiftUI counterparts — so being able to inline SwiftUI views within them should definitely prove to be very useful.If you have any questions, comments, or feedback, then feel free to reach out via either Twitter or email.Thanks for reading!",
  "image": "https://www.swiftbysundell.com/images/articles/rendering-swiftui-views-within-uitableview-or-uicollectionview.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eEver since its original introduction in 2019, SwiftUI has had really strong \u003ca href=\"https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-1\"\u003einteroperability with UIKit\u003c/a\u003e. Both \u003ccode\u003eUIView\u003c/code\u003e and \u003ccode\u003eUIViewController\u003c/code\u003e instances can be wrapped to become fully SwiftUI-compatible, and \u003ccode\u003eUIHostingController\u003c/code\u003e lets us render any SwiftUI view within a UIKit-based view controller.\u003c/p\u003e\u003cp\u003eHowever, even though macOS has had an \u003ccode\u003eNSHostingView\u003c/code\u003e for inlining SwiftUI views directly within any \u003ccode\u003eNSView\u003c/code\u003e (no view controller required) since the very beginning, there has never been a built-in way to do the same thing on iOS. Sure, we could always grab the underlying \u003ccode\u003eview\u003c/code\u003e from a \u003ccode\u003eUIHostingController\u003c/code\u003e instance, or add our hosting controller to a parent view controller in order to be able to use its view deeper within a \u003ccode\u003eUIView\u003c/code\u003e-based hierarchy — but neither of those solutions have ever felt entirely smooth.\u003c/p\u003e\u003cp\u003eThat brings us to iOS 16 (which is currently in beta at the time of writing). Although Apple haven’t introduced a fully general-purpose \u003ccode\u003eUIHostingView\u003c/code\u003e as part of this release, they \u003cem\u003ehave\u003c/em\u003e addressed one of the most common challenges that the lack of such a view presents us with — which is how to render a SwiftUI view within either a \u003ccode\u003eUITableViewCell\u003c/code\u003e or \u003ccode\u003eUICollectionViewCell\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eJust a quick note before we begin: All of this article’s code samples will be entirely \u003ccode\u003eUITableView\u003c/code\u003e-based, but the exact same techniques can also be used with \u003ccode\u003eUICollectionView\u003c/code\u003e as well.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"say-hello-to-uihostingconfiguration\" href=\"#say-hello-to-uihostingconfiguration\"\u003eSay hello to UIHostingConfiguration\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIn iOS 14, Apple introduced a new way to configure cells that are being rendered as part of a \u003ccode\u003eUITableView\u003c/code\u003e or \u003ccode\u003eUICollectionView\u003c/code\u003e, which lets us use so-called \u003cem\u003econtent configurations\u003c/em\u003e to decouple the content that we’re rendering from the actual subviews that our cells contain. This API has now been extended with a new \u003ccode\u003eUIHostingConfiguration\u003c/code\u003e type, which lets us define a cell’s content using any SwiftUI view hierarchy.\u003c/p\u003e\u003cp\u003eSo wherever we’re configuring our cells — for example using the good-old-fashioned \u003ccode\u003eUITableViewDataSource\u003c/code\u003e dequeuing method — we can now opt to assign such a hosting configuration to a given cell’s \u003ccode\u003econtentConfiguration\u003c/code\u003e property, and UIKit will automatically render the SwiftUI views that we provide within that cell:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e ListViewController: \u003cspan\u003eUIViewController\u003c/span\u003e, \u003cspan\u003eUITableViewDataSource\u003c/span\u003e {\n    \u003cspan\u003eprivate var\u003c/span\u003e items: [\u003cspan\u003eItem\u003c/span\u003e]\n    \u003cspan\u003eprivate let\u003c/span\u003e databaseController: \u003cspan\u003eDatabaseController\u003c/span\u003e\n    \u003cspan\u003eprivate let\u003c/span\u003e cellReuseID = \u003cspan\u003e\u0026#34;cell\u0026#34;\u003c/span\u003e\n    \u003cspan\u003eprivate lazy var\u003c/span\u003e tableView = \u003cspan\u003eUITableView\u003c/span\u003e()\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e tableView(\u003cspan\u003e_\u003c/span\u003e tableView: \u003cspan\u003eUITableView\u003c/span\u003e,\n                   cellForRowAt indexPath: \u003cspan\u003eIndexPath\u003c/span\u003e) -\u0026gt; \u003cspan\u003eUITableViewCell\u003c/span\u003e {\n        \u003cspan\u003elet\u003c/span\u003e cell = tableView.\u003cspan\u003edequeueReusableCell\u003c/span\u003e(\n            withIdentifier: cellReuseID,\n            for: indexPath\n        )\n\n        \u003cspan\u003elet\u003c/span\u003e item = items[indexPath.\u003cspan\u003erow\u003c/span\u003e]\n\n        \u003cspan\u003ecell.\u003cspan\u003econtentConfiguration\u003c/span\u003e = \u003cspan\u003eUIHostingConfiguration\u003c/span\u003e\u003c/span\u003e {\n            \u003cspan\u003eHStack\u003c/span\u003e {\n                \u003cspan\u003eText\u003c/span\u003e(item.\u003cspan\u003etitle\u003c/span\u003e)\n                \u003cspan\u003eSpacer\u003c/span\u003e()\n                \u003cspan\u003eButton\u003c/span\u003e(action: { [\u003cspan\u003eweak self\u003c/span\u003e] \u003cspan\u003ein\n                    if let\u003c/span\u003e indexPath = \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003etableView\u003c/span\u003e.\u003cspan\u003eindexPath\u003c/span\u003e(for: cell) {\n                        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003etoggleFavoriteStatusForItem\u003c/span\u003e(atIndexPath: indexPath)\n                    }\n                }, label: {\n                    \u003cspan\u003eImage\u003c/span\u003e(systemName: \u003cspan\u003e\u0026#34;star\u0026#34;\u003c/span\u003e + (item.\u003cspan\u003eisFavorite\u003c/span\u003e ? \u003cspan\u003e\u0026#34;.fill\u0026#34;\u003c/span\u003e : \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e))\n                        .\u003cspan\u003eforegroundColor\u003c/span\u003e(item.\u003cspan\u003eisFavorite\u003c/span\u003e ? .\u003cspan\u003eyellow\u003c/span\u003e : .\u003cspan\u003egray\u003c/span\u003e)\n                })\n            }\n        }\n\n        \u003cspan\u003ereturn\u003c/span\u003e cell\n    }\n\n    \u003cspan\u003eprivate func\u003c/span\u003e toggleFavoriteStatusForItem(atIndexPath indexPath: \u003cspan\u003eIndexPath\u003c/span\u003e) {\n        items[indexPath.\u003cspan\u003erow\u003c/span\u003e].isFavorite.\u003cspan\u003etoggle\u003c/span\u003e()\n        databaseController.\u003cspan\u003eupdate\u003c/span\u003e(items[indexPath.\u003cspan\u003erow\u003c/span\u003e])\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNeat! As the above code sample shows, we can easily send events back from our cell’s SwiftUI views to our view controller using closures, but there are a few things that are good to keep in mind when doing so.\u003c/p\u003e\u003cp\u003eFirst, you might’ve noticed that we’re asking the table view for our cell’s current index path before passing it to our \u003ccode\u003etoggleFavoriteStatusForItem\u003c/code\u003e method. That’s because, if our table view supports operations such as moves and deletions, our cell might be at a different index path once our favorite button is tapped — so if we were to capture and use the \u003ccode\u003eindexPath\u003c/code\u003e parameter that was passed into our cell configuration method, then we might accidentally end up updating the wrong model.\u003c/p\u003e\u003cp\u003eSecond, we have to remember that we still very much remain in the world of UIKit, which means that we have to take memory management into account (at least, more so than when operating in the wonderful value type-based world of SwiftUI). Hence the above \u003ccode\u003e[weak self]\u003c/code\u003e \u003ca href=\"https://www.swiftbysundell.com/questions/is-weak-self-always-required\"\u003eclosure capture\u003c/a\u003e, in order to avoid retain cycles between our view controller and its \u003ccode\u003eUITableView\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eFinally, there’s state management, and just like when bridging the gap between UIKit and SwiftUI using tools like \u003ccode\u003eUIHostingController\u003c/code\u003e or \u003ccode\u003eUIViewRepresentable\u003c/code\u003e, we probably need to write a little bit of custom code to ensure that our cell’s SwiftUI view hierarchy is rendering the latest version of our view controller’s data.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"managing-state-updates\" href=\"#managing-state-updates\"\u003eManaging state updates\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFor example, when the user taps our cell’s favorite button, our cell is not currently updated to reflect its \u003ccode\u003eItem\u003c/code\u003e model’s new state. That’s because we’re not actually using SwiftUI’s declarative \u003ca href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide\"\u003estate management system\u003c/a\u003e to drive those updates, so there’s no way for our nested SwiftUI view hierarchy to know that its data model was modified.\u003c/p\u003e\u003cp\u003eOne way to address that would be to use UIKit to react to those changes, rather than using SwiftUI’s view updating mechanisms. We could, for instance, call our table view’s \u003ccode\u003ereloadRows\u003c/code\u003e method whenever an item’s favorite status was changed — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e ListViewController: \u003cspan\u003eUIViewController\u003c/span\u003e, \u003cspan\u003eUITableViewDataSource\u003c/span\u003e {\n    ...\n\n    \u003cspan\u003eprivate func\u003c/span\u003e toggleFavoriteStatusForItem(atIndexPath indexPath: \u003cspan\u003eIndexPath\u003c/span\u003e) {\n        items[indexPath.\u003cspan\u003erow\u003c/span\u003e].isFavorite.\u003cspan\u003etoggle\u003c/span\u003e()\n        databaseController.\u003cspan\u003eupdate\u003c/span\u003e(items[indexPath.\u003cspan\u003erow\u003c/span\u003e])\n        \u003cspan\u003etableView.\u003cspan\u003ereloadRows\u003c/span\u003e(at: [indexPath], with: .\u003cspan\u003enone\u003c/span\u003e)\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat works great, since it’ll make the table view call our data source cell configuration method, which’ll give us a chance to update the changed item’s cell and the SwiftUI views that are embedded within it.\u003c/p\u003e\u003cp\u003eBut let’s say that we instead wanted to use SwiftUI’s state management system to keep track of when our cell’s state was modified. One way to make that happen would be to introduce some form of \u003ccode\u003eObservableObject\u003c/code\u003e that our view controller could then inject into each cell’s SwiftUI view hierarchy.\u003c/p\u003e\u003cp\u003eA side-benefit of introducing such a type in this case is that it’ll also give us a neat place to encapsulate all view-related logic that’s tied to our \u003ccode\u003eItem\u003c/code\u003e model, such as the code that’s used to compute our favorite button’s title and foreground color. Let’s go ahead and introduce such a class, which we’ll call \u003ccode\u003eItemViewModel\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e ItemViewModel: \u003cspan\u003eObservableObject\u003c/span\u003e {\n    \u003cspan\u003e@Published private(set) var\u003c/span\u003e item: \u003cspan\u003eItem\u003c/span\u003e\n    \u003cspan\u003eprivate let\u003c/span\u003e onItemChange: (\u003cspan\u003eItem\u003c/span\u003e) -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e\n\n    \u003cspan\u003einit\u003c/span\u003e(item: \u003cspan\u003eItem\u003c/span\u003e, onItemChange: \u003cspan\u003e@escaping\u003c/span\u003e (\u003cspan\u003eItem\u003c/span\u003e) -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e) {\n        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eitem\u003c/span\u003e = item\n        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eonItemChange\u003c/span\u003e = onItemChange\n    }\n\n    \u003cspan\u003efunc\u003c/span\u003e toggleFavoriteStatus() {\n        item.\u003cspan\u003eisFavorite\u003c/span\u003e.\u003cspan\u003etoggle\u003c/span\u003e()\n        \u003cspan\u003eonItemChange\u003c/span\u003e(item)\n    }\n}\n\n\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eItemViewModel\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e favoriteButtonIconName: \u003cspan\u003eString\u003c/span\u003e {\n        \u003cspan\u003e\u0026#34;star\u0026#34;\u003c/span\u003e + (item.\u003cspan\u003eisFavorite\u003c/span\u003e ? \u003cspan\u003e\u0026#34;.fill\u0026#34;\u003c/span\u003e : \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e)\n    }\n\n    \u003cspan\u003evar\u003c/span\u003e favoriteButtonColor: \u003cspan\u003eColor\u003c/span\u003e {\n        item.\u003cspan\u003eisFavorite\u003c/span\u003e ? .\u003cspan\u003eyellow\u003c/span\u003e : .\u003cspan\u003egray\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that we’re enabling an \u003ccode\u003eonItemChange\u003c/code\u003e closure to be passed into our view model, which’ll let our view controller observe whenever the view model’s copy of the underlying \u003ccode\u003eItem\u003c/code\u003e model was modified. We could definitely have chosen to use \u003ca href=\"https://www.swiftbysundell.com/discover/combine\"\u003eCombine\u003c/a\u003e here instead, by having our view controller hook into the publisher that’s connected to the view model’s \u003ccode\u003eitem\u003c/code\u003e property, but a simple closure will get the job done in this case.\u003c/p\u003e\u003cp\u003eNext, let’s extract our cell-embedded SwiftUI code into a dedicated \u003ccode\u003eView\u003c/code\u003e type, which will let us make our view hierarchy observe our new view model as an \u003ccode\u003eObservedObject\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e ItemView: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003e@ObservedObject var\u003c/span\u003e viewModel: \u003cspan\u003eItemViewModel\u003c/span\u003e\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eHStack\u003c/span\u003e {\n            \u003cspan\u003eText\u003c/span\u003e(viewModel.\u003cspan\u003eitem\u003c/span\u003e.\u003cspan\u003etitle\u003c/span\u003e)\n            \u003cspan\u003eSpacer\u003c/span\u003e()\n            \u003cspan\u003eButton\u003c/span\u003e(action: viewModel.\u003cspan\u003etoggleFavoriteStatus\u003c/span\u003e) {\n                \u003cspan\u003eImage\u003c/span\u003e(systemName: viewModel.\u003cspan\u003efavoriteButtonIconName\u003c/span\u003e)\n                    .\u003cspan\u003eforegroundColor\u003c/span\u003e(viewModel.\u003cspan\u003efavoriteButtonColor\u003c/span\u003e)\n            }\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFinally, all that remains is to update our view controller to use our newly introduced types, which will also let us remove the \u003ccode\u003etoggleFavoriteStatusForItem\u003c/code\u003e method that we were previously using to manage each item’s favorite status:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e ListViewController: \u003cspan\u003eUIViewController\u003c/span\u003e, \u003cspan\u003eUITableViewDataSource\u003c/span\u003e {\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e tableView(\u003cspan\u003e_\u003c/span\u003e tableView: \u003cspan\u003eUITableView\u003c/span\u003e,\n                   cellForRowAt indexPath: \u003cspan\u003eIndexPath\u003c/span\u003e) -\u0026gt; \u003cspan\u003eUITableViewCell\u003c/span\u003e {\n        \u003cspan\u003elet\u003c/span\u003e cell = tableView.\u003cspan\u003edequeueReusableCell\u003c/span\u003e(\n            withIdentifier: cellReuseID,\n            for: indexPath\n        )\n\n        \u003cspan\u003elet\u003c/span\u003e viewModel = \u003cspan\u003e\u003cspan\u003eItemViewModel\u003c/span\u003e\u003c/span\u003e(\n            item: items[indexPath.\u003cspan\u003erow\u003c/span\u003e],\n            onItemChange: { [\u003cspan\u003eweak self\u003c/span\u003e] item \u003cspan\u003ein\n                guard let\u003c/span\u003e indexPath = \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003etableView\u003c/span\u003e.\u003cspan\u003eindexPath\u003c/span\u003e(for: cell) \u003cspan\u003eelse\u003c/span\u003e {\n                    \u003cspan\u003ereturn\u003c/span\u003e\n                }\n            \n                \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003eitems\u003c/span\u003e[indexPath.\u003cspan\u003erow\u003c/span\u003e] = item\n                \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edatabaseController\u003c/span\u003e.\u003cspan\u003eupdate\u003c/span\u003e(item)\n            }\n        )\n\n        \u003cspan\u003ecell.\u003cspan\u003econtentConfiguration\u003c/span\u003e = \u003cspan\u003eUIHostingConfiguration\u003c/span\u003e {\n    \u003cspan\u003eItemView\u003c/span\u003e(viewModel: viewModel)\n}\u003c/span\u003e\n\n        \u003cspan\u003ereturn\u003c/span\u003e cell\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eVery nice! Of course, the above implementation only handles \u003cem\u003einternal\u003c/em\u003e data model changes that are performed by our view controller and its nested SwiftUI views. If those models could also be modified elsewhere, then we’d have to notify our view controller whenever that happens, and reload our table view’s data accordingly. However, the fact that we’re using SwiftUI and the new \u003ccode\u003eUIHostingConfiguration\u003c/code\u003e API doesn’t really affect the way we’d do that, since any such external updates would lead to us re-configuring our cells anyway.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"bridged-swipe-actions\" href=\"#bridged-swipe-actions\"\u003eBridged swipe actions\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAnother neat aspect of the new \u003ccode\u003eUIHostingConfiguration\u003c/code\u003e API and the way it bridges the gap between UIKit and SwiftUI is that it’ll automatically convert any SwiftUI \u003ccode\u003eswipeActions\u003c/code\u003e that our view hierarchy contains into UIKit-based swipe actions.\u003c/p\u003e\u003cp\u003eSo for example, if we wanted to add a delete swipe action to each of our item cells, then we could do that using a modifier placed right within our \u003ccode\u003eUIHostingConfiguration\u003c/code\u003e closure — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ecell.\u003cspan\u003econtentConfiguration\u003c/span\u003e = \u003cspan\u003eUIHostingConfiguration\u003c/span\u003e {\n    \u003cspan\u003eItemView\u003c/span\u003e(viewModel: viewModel).\u003cspan\u003eswipeActions\u003c/span\u003e {\n        \u003cspan\u003eButton\u003c/span\u003e(role: .\u003cspan\u003edestructive\u003c/span\u003e, action: { [\u003cspan\u003eweak self\u003c/span\u003e] \u003cspan\u003ein\n            guard let\u003c/span\u003e indexPath = \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003etableView\u003c/span\u003e.\u003cspan\u003eindexPath\u003c/span\u003e(for: cell) \u003cspan\u003eelse\u003c/span\u003e {\n                \u003cspan\u003ereturn\u003c/span\u003e\n            }\n\n            \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003eitems\u003c/span\u003e.\u003cspan\u003eremove\u003c/span\u003e(at: indexPath.\u003cspan\u003erow\u003c/span\u003e)\n            \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edatabaseController\u003c/span\u003e.\u003cspan\u003edelete\u003c/span\u003e(viewModel.\u003cspan\u003eitem\u003c/span\u003e)\n            \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003etableView\u003c/span\u003e.\u003cspan\u003edeleteRows\u003c/span\u003e(at: [indexPath], with: .\u003cspan\u003eautomatic\u003c/span\u003e)\n        }, label: {\n            \u003cspan\u003eLabel\u003c/span\u003e(\u003cspan\u003e\u0026#34;Delete\u0026#34;\u003c/span\u003e, systemImage: \u003cspan\u003e\u0026#34;trash\u0026#34;\u003c/span\u003e)\n        })\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, while the above is really neat, it’s important to point out that (at the time of writing) not \u003cem\u003eevery\u003c/em\u003e aspect of SwiftUI is automatically bridged that way. For example, if we were to place a \u003ccode\u003eNavigationLink\u003c/code\u003e within our \u003ccode\u003eUIHostingConfiguration\u003c/code\u003e, then that wouldn’t automatically be wired up to any \u003ccode\u003eUINavigationController\u003c/code\u003e that our view controller is embedded in (which \u003cem\u003edoes\u003c/em\u003e happen when using \u003ccode\u003eUIHostingController\u003c/code\u003e). Hopefully that’s something that’ll be addressed at a later time.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"conclusion\" href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThe interoperability between SwiftUI and UIKit keeps getting more and more powerful, which in turn enables us to continue mixing the two UI frameworks within the apps that we build. The introduction of \u003ccode\u003eUIHostingConfiguration\u003c/code\u003e is especially welcome, since \u003ccode\u003eUITableView\u003c/code\u003e and \u003ccode\u003eUICollectionView\u003c/code\u003e (which supports this new hosting configuration API in the exact same way) still offer much more functionality than their SwiftUI counterparts — so being able to inline SwiftUI views within them should definitely prove to be very useful.\u003c/p\u003e\u003cp\u003eIf you have any questions, comments, or feedback, then feel free to reach out via either \u003ca href=\"https://twitter.com/johnsundell\"\u003eTwitter\u003c/a\u003e or \u003ca href=\"https://www.swiftbysundell.com/contact\"\u003eemail\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": null,
  "modifiedTime": null
}
