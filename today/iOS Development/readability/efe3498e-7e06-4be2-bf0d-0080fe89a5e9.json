{
  "id": "efe3498e-7e06-4be2-bf0d-0080fe89a5e9",
  "title": "Deciding between ‘let’ and ‘var’ for Swift struct properties",
  "link": "https://www.swiftbysundell.com/articles/let-vs-var-for-swift-struct-properties",
  "description": "Does marking a given Swift struct property as either ‘let’ or ‘var’ simply determine its mutability, or is there more to it? Let’s explore!",
  "author": "",
  "published": "Wed, 23 Jul 2025 13:35:00 +0200",
  "source": "https://swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 11692,
  "excerpt": "Does marking a given Swift struct property as either ‘let’ or ‘var’ simply determine its mutability, or is there more to it? Let’s explore!",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "When declaring a Swift property, we use either the let or var keyword depending on whether we want our new property to be read-only once assigned through the enclosing type’s initializer, or whether we want to allow the property to be mutated and re-assigned multiple times.However, that’s not the only difference between using let versus var when working with Swift structs — as both approaches also influence the enclosing struct’s behaviors in various ways. Let’s explore!The side-effects of immutabilityLet’s say that we’ve declared a User struct within a project, which currently only contains constant let properties:struct User: Identifiable, Codable { let id: UUID let name: String let bio: String let imageURL: URL? }Besides the fact that neither of those properties can be directly modified when working with a mutable User value, marking imageURL specifically as a let actually influences how our struct’s initializer behaves.When an optional struct property is declared as a let, then we’re always required to pass a value for it when using the default compiler-generated, so-called member-wise initializer. That means that even in situations when a user’s imageURL should be nil, we have to explicitly specify that:let user = User( id: UUID(), name: \"John Appleseed\", bio: \"Famous person within the Apple Cinematic Universe\", imageURL: nil )If imageURL was declared as a var instead, then we could’ve simply omitted that parameter above.Whether that’s an advantage or disadvantage likely depends on the situation (and personal taste). Sometimes it’s great that we can’t forget to pass an imageURL, and sometimes the above just leads to unnecessary boilerplate.Another way that let properties differ from var-declared ones is when it comes to default values, since let properties treat such values as constant declarations. For example, let’s say that we wanted to add a default value for our User struct’s id property — to avoid having to manually pass UUID() every time we create a new user:struct User: Identifiable, Codable { let id = UUID() let name: String let bio: String let imageURL: URL? }If id was a var, then the above change would simply mean that our UUID() expression would be used unless we pass an explicit value for that parameter (either when directly initializing User, or when decoding a value from a data format, such as JSON). However, since it’s a let, it now means that we can’t actually pass a value for that property at all — the UUID() expression will always be used, and there’s no way to override that.Since our User type also conforms to Decodable (through the Codable type alias), that actually also means that no id value will ever be decoded, and any such value that’s present within the JSON (or other data format) that we’re decoding from will simply be ignored. In fact, the Swift compiler will even give us a warning when using the above pattern, since it’s likely not the decoding behavior we want our type to have.Manually declared initializersSo what if we wanted to change some of the behaviors that we explored above? One way to do that would be to manually declare our type’s initializer, rather than relying on the member-wise one that the compiler generates for us. For example, let’s say that we wanted to allow call sites to omit the imageURL property if it should simply be nil (without changing it to a var), and/or use a default UUID for the id property if no explicit value was passed. That could be done like this:struct User: Identifiable, Codable { let id: UUID let name: String let bio: String let imageURL: URL? init(id: UUID = UUID(), name: String, bio: String, imageURL: URL? = nil) { self.id = id self.name = name self.bio = bio self.imageURL = imageURL } }The above strikes a quite nice balance between maintaining immutability (if that’s something we want), while still enabling convenience features like default values — at the cost of having to manually write and maintain our own explicit initializer.A property wrapper alternativeAn alternative approach to the above, which may be something we want to consider if we want to deploy the constants-with-default-values pattern in many places across a larger code base, is to use a property wrapper to make var properties read-only.Since the mutability of a wrapped property depends on the wrapper itself, we could declare a Readonly wrapper type which marks its wrappedValue as a let — like this:@propertyWrapper struct Readonly\u003cValue\u003e { let wrappedValue: Value }Since we’re planning to use our Readonly wrapper within types that conform to Encodable and Decodable, then we also need to adopt those protocols for our wrapper as well — since all coding tasks are deferred to property wrappers when they’re used:extension Readonly: Encodable where Value: Encodable { func encode(to encoder: Encoder) throws { var container = encoder.singleValueContainer() try container.encode(wrappedValue) } } extension Readonly: Decodable where Value: Decodable { init(from decoder: Decoder) throws { let container = try decoder.singleValueContainer() wrappedValue = try container.decode(Value.self) } }Above we’re using Swift’s conditional conformances feature to not have to require that all Readonly.Value types always have to conform to Encodable and Decodable, which would limit our property wrapper’s versatility.With the above in place, we can now go ahead and update our User type to use Readonly-marked var declarations for the properties that we want to define a default value for:struct User: Identifiable, Codable { @Readonly var id = UUID() let name: String let bio: String @Readonly var imageURL: URL? }Note that, since we’re now using a var for our type’s imageURL property, it’s default value automatically becomes nil — there’s no need for us to declare that manually.The advantage of the above approach is that we now have a reusable solution that helps us avoid having to manually declare initializers when all we want is to be able to define default values for read-only properties. However, whenever we use a non-standard solution, like the one above, it’s important to consider whether the inherent additional complexity of such a custom solution is worth the benefits that we get from it.Is immutability always the answer?Another alternative approach to make our properties support default values is to simply declare them using var instead. While that does enable those properties to be mutated, perhaps that isn’t actually a problem, given that all structs are by default passed as immutable copies when calling a function or when initializing another type.In practice, that means that structs don’t have the same shared mutable state problem that classes often do (unless static mutable values are used), so the question is how problematic it would actually be to do something like this:struct User: Identifiable, Codable { var id = UUID() var name: String var bio: String var imageURL: URL? }One benefit of making our structs as mutable as possible is that doing so often makes it much easier to write unit tests — either when our structs are used as stub values, or when the structs themselves are the types being tested. For example, let’s say that we wanted to add a method for normalizing a given user’s name:extension User { mutating func normalizeName() { name = name .filter { char in char.isLetter || (char.isWhitespace \u0026\u0026 !char.isNewline) } .trimmingCharacters(in: .whitespaces) } }Since the name property is now a var, we could easily write a test that verifies various normalization scenarios, all while reusing the same User value — for example like this:struct UserTests { @Test func normalizingName() { var user = User(name: \"Name\", bio: \"Bio\") // Non-letter characters are removed: user.name = \"!1_First 2;Last_3?\" user.normalizeName() #expect(user.name == \"First Last\") // Leading and trailing whitespaces are removed: user.name = \" White Spaces \" user.normalizeName() #expect(user.name == \"White Spaces\") } }It’s also important to remember that just because we mark a given struct property as a let doesn’t mean that its value can never change, since the mutability of a given value is always determined by the top-level, enclosing value that the property is contained within.For example, let’s say that we wanted to make another attempt at striking a nice balance between mutability and consistency for our User type — this time by making all non-id properties variables, while keeping the id property a let (since that’s the one property we never expect to change throughout the lifetime of a User value):struct User: Identifiable, Codable { let id: UUID var name: String var bio: String var imageURL: URL? }Then, let’s say that we wanted to introduce an API for transforming a given User value in some way, for example by using the normalizeName method we defined earlier. Such an API could take the form of a UserTransformer protocol, which uses Swift’s inout parameter feature to enable each transformer to directly mutate the User value that was passed to it, without first having to make a mutable copy:protocol UserTransformer { func transformUser(_ user: inout User) } struct UserNameNormalizer: UserTransformer { func transformUser(_ user: inout User) { user.normalizeName() } }So the question is, with the above setup, do we have a guarantee that the id property of any User value that was passed to a UserTransformer implementation can never be changed? No, actually, we don’t. Because we have to remember, the User value itself is mutable, and it can be completely re-assigned with a brand new UUID if the implementation so desires — for example like this:struct UserIDTransformer: UserTransformer { func transformUser(_ user: inout User) { user = User( id: UUID(), name: user.name, bio: user.bio, imageURL: user.imageURL ) } }Admittedly, code like the above is quite likely to raise some eyebrows during code review (when working with a team), but it just illustrates how we have to think about value types — such as structs and enums — when working with them. They don’t have the same concept of identity and a lifecycle, like classes and actors do, which is important to remember when we design our types and their associated APIs.Swift by Sundell is brought to you by the Genius Scan SDK — Add a powerful document scanner to any mobile app, and turn scans into high-quality PDFs with one line of code. Try it today.ConclusionSo how do you decide between using let and var when declaring struct properties? My personal approach is to keep my struct properties mutable by default, since I feel like that really leans into the core concept of value types — that it’s the enclosing value, not individual properties, that actually determines the real mutability of a given value.That being said, marking properties that we never expect to be mutated (such as a type’s ID) as let is also usually a good practice — even though it doesn’t strictly guarantee that such values will never change, it at least signals to everyone on the team what the intended mutability of such a property is.What do you think? Let me know what your thoughts are on this topic — along with any questions or feedback you might have — on either Mastodon or Bluesky.Thanks for reading!",
  "image": "https://www.swiftbysundell.com/images/social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eWhen declaring a Swift property, we use either the \u003ccode\u003elet\u003c/code\u003e or \u003ccode\u003evar\u003c/code\u003e keyword depending on whether we want our new property to be read-only once assigned through the enclosing type’s initializer, or whether we want to allow the property to be mutated and re-assigned multiple times.\u003c/p\u003e\u003cp\u003eHowever, that’s not the only difference between using \u003ccode\u003elet\u003c/code\u003e versus \u003ccode\u003evar\u003c/code\u003e when working with Swift structs — as both approaches also influence the enclosing struct’s behaviors in various ways. Let’s explore!\u003c/p\u003e\u003ch2\u003e\u003ca id=\"the-side-effects-of-immutability\" href=\"#the-side-effects-of-immutability\"\u003eThe side-effects of immutability\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet’s say that we’ve declared a \u003ccode\u003eUser\u003c/code\u003e struct within a project, which currently only contains constant \u003ccode\u003elet\u003c/code\u003e properties:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e User: \u003cspan\u003eIdentifiable\u003c/span\u003e, \u003cspan\u003eCodable\u003c/span\u003e {\n    \u003cspan\u003elet\u003c/span\u003e id: \u003cspan\u003eUUID\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e name: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e bio: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e imageURL: \u003cspan\u003eURL\u003c/span\u003e?\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBesides the fact that neither of those properties can be directly modified when working with a mutable \u003ccode\u003eUser\u003c/code\u003e value, marking \u003ccode\u003eimageURL\u003c/code\u003e specifically as a \u003ccode\u003elet\u003c/code\u003e actually influences how our struct’s initializer behaves.\u003c/p\u003e\u003cp\u003eWhen an optional struct property is declared as a \u003ccode\u003elet\u003c/code\u003e, then we’re \u003cem\u003ealways required\u003c/em\u003e to pass a value for it when using the default compiler-generated, so-called \u003cem\u003emember-wise\u003c/em\u003e initializer. That means that even in situations when a user’s \u003ccode\u003eimageURL\u003c/code\u003e should be \u003ccode\u003enil\u003c/code\u003e, we have to explicitly specify that:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e user = \u003cspan\u003eUser\u003c/span\u003e(\n    id: \u003cspan\u003eUUID\u003c/span\u003e(),\n    name: \u003cspan\u003e\u0026#34;John Appleseed\u0026#34;\u003c/span\u003e,\n    bio: \u003cspan\u003e\u0026#34;Famous person within the Apple Cinematic Universe\u0026#34;\u003c/span\u003e,\n    \u003cspan\u003eimageURL: \u003cspan\u003enil\u003c/span\u003e\u003c/span\u003e\n)\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp\u003eIf \u003ccode\u003eimageURL\u003c/code\u003e was declared as a \u003ccode\u003evar\u003c/code\u003e instead, then we could’ve simply omitted that parameter above.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eWhether that’s an advantage or disadvantage likely depends on the situation (and personal taste). Sometimes it’s great that we can’t forget to pass an \u003ccode\u003eimageURL\u003c/code\u003e, and sometimes the above just leads to unnecessary boilerplate.\u003c/p\u003e\u003cp\u003eAnother way that \u003ccode\u003elet\u003c/code\u003e properties differ from \u003ccode\u003evar\u003c/code\u003e-declared ones is when it comes to \u003cem\u003edefault values\u003c/em\u003e, since \u003ccode\u003elet\u003c/code\u003e properties treat such values as \u003cem\u003econstant declarations\u003c/em\u003e. For example, let’s say that we wanted to add a default value for our \u003ccode\u003eUser\u003c/code\u003e struct’s \u003ccode\u003eid\u003c/code\u003e property — to avoid having to manually pass \u003ccode\u003eUUID()\u003c/code\u003e every time we create a new user:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e User: \u003cspan\u003eIdentifiable\u003c/span\u003e, \u003cspan\u003eCodable\u003c/span\u003e {\n    \u003cspan\u003elet\u003c/span\u003e id \u003cspan\u003e= \u003cspan\u003eUUID\u003c/span\u003e()\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e name: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e bio: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e imageURL: \u003cspan\u003eURL\u003c/span\u003e?\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf \u003ccode\u003eid\u003c/code\u003e was a \u003ccode\u003evar\u003c/code\u003e, then the above change would simply mean that our \u003ccode\u003eUUID()\u003c/code\u003e expression would be used \u003cem\u003eunless\u003c/em\u003e we pass an explicit value for that parameter (either when directly initializing \u003ccode\u003eUser\u003c/code\u003e, or when decoding a value from a data format, such as JSON). However, since it’s a \u003ccode\u003elet\u003c/code\u003e, it now means that we \u003cem\u003ecan’t\u003c/em\u003e actually pass a value for that property at all — the \u003ccode\u003eUUID()\u003c/code\u003e expression will always be used, and there’s no way to override that.\u003c/p\u003e\u003cp\u003eSince our \u003ccode\u003eUser\u003c/code\u003e type also conforms to \u003ccode\u003eDecodable\u003c/code\u003e (through the \u003ccode\u003eCodable\u003c/code\u003e type alias), that actually also means that no \u003ccode\u003eid\u003c/code\u003e value will ever be decoded, and any such value that’s present within the JSON (or other data format) that we’re decoding from will simply be ignored. In fact, the Swift compiler will even give us a warning when using the above pattern, since it’s likely not the decoding behavior we want our type to have.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"manually-declared-initializers\" href=\"#manually-declared-initializers\"\u003eManually declared initializers\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSo what if we wanted to change some of the behaviors that we explored above? One way to do that would be to manually declare our type’s initializer, rather than relying on the member-wise one that the compiler generates for us. For example, let’s say that we wanted to allow call sites to omit the \u003ccode\u003eimageURL\u003c/code\u003e property if it should simply be \u003ccode\u003enil\u003c/code\u003e (without changing it to a \u003ccode\u003evar\u003c/code\u003e), and/or use a default \u003ccode\u003eUUID\u003c/code\u003e for the \u003ccode\u003eid\u003c/code\u003e property if no explicit value was passed. That could be done like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e User: \u003cspan\u003eIdentifiable\u003c/span\u003e, \u003cspan\u003eCodable\u003c/span\u003e {\n    \u003cspan\u003elet\u003c/span\u003e id: \u003cspan\u003eUUID\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e name: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e bio: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e imageURL: \u003cspan\u003eURL\u003c/span\u003e?\n\n    \u003cspan\u003einit\u003c/span\u003e(id: \u003cspan\u003e\u003cspan\u003eUUID\u003c/span\u003e = \u003cspan\u003eUUID\u003c/span\u003e()\u003c/span\u003e,\n         name: \u003cspan\u003eString\u003c/span\u003e,\n         bio: \u003cspan\u003eString\u003c/span\u003e,\n         imageURL: \u003cspan\u003e\u003cspan\u003eURL\u003c/span\u003e? = \u003cspan\u003enil\u003c/span\u003e\u003c/span\u003e) {\n        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eid\u003c/span\u003e = id\n        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003ename\u003c/span\u003e = name\n        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003ebio\u003c/span\u003e = bio\n        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eimageURL\u003c/span\u003e = imageURL\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above strikes a quite nice balance between maintaining immutability (if that’s something we want), while still enabling convenience features like default values — at the cost of having to manually write and maintain our own explicit initializer.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"a-property-wrapper-alternative\" href=\"#a-property-wrapper-alternative\"\u003eA property wrapper alternative\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAn alternative approach to the above, which may be something we want to consider if we want to deploy the \u003cem\u003econstants-with-default-values\u003c/em\u003e pattern in many places across a larger code base, is to use a property wrapper to make \u003ccode\u003evar\u003c/code\u003e properties \u003cem\u003eread-only\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eSince the mutability of a wrapped property depends on the wrapper itself, we could declare a \u003ccode\u003eReadonly\u003c/code\u003e wrapper type which marks its \u003ccode\u003ewrappedValue\u003c/code\u003e as a \u003ccode\u003elet\u003c/code\u003e — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e@propertyWrapper struct\u003c/span\u003e Readonly\u0026lt;Value\u0026gt; {\n    \u003cspan\u003elet\u003c/span\u003e wrappedValue: \u003cspan\u003eValue\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSince we’re planning to use our \u003ccode\u003eReadonly\u003c/code\u003e wrapper within types that conform to \u003ccode\u003eEncodable\u003c/code\u003e and \u003ccode\u003eDecodable\u003c/code\u003e, then we also need to adopt those protocols for our wrapper as well — since all coding tasks are deferred to property wrappers when they’re used:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eReadonly\u003c/span\u003e: \u003cspan\u003eEncodable\u003c/span\u003e \u003cspan\u003ewhere\u003c/span\u003e \u003cspan\u003eValue\u003c/span\u003e: \u003cspan\u003eEncodable\u003c/span\u003e {\n    \u003cspan\u003efunc\u003c/span\u003e encode(to encoder: \u003cspan\u003eEncoder\u003c/span\u003e) \u003cspan\u003ethrows\u003c/span\u003e {\n        \u003cspan\u003evar\u003c/span\u003e container = encoder.\u003cspan\u003esingleValueContainer\u003c/span\u003e()\n        \u003cspan\u003etry\u003c/span\u003e container.\u003cspan\u003eencode\u003c/span\u003e(wrappedValue)\n    }\n}\n\n\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eReadonly\u003c/span\u003e: \u003cspan\u003eDecodable\u003c/span\u003e \u003cspan\u003ewhere\u003c/span\u003e \u003cspan\u003eValue\u003c/span\u003e: \u003cspan\u003eDecodable\u003c/span\u003e {\n    \u003cspan\u003einit\u003c/span\u003e(from decoder: \u003cspan\u003eDecoder\u003c/span\u003e) \u003cspan\u003ethrows\u003c/span\u003e {\n        \u003cspan\u003elet\u003c/span\u003e container = \u003cspan\u003etry\u003c/span\u003e decoder.\u003cspan\u003esingleValueContainer\u003c/span\u003e()\n        wrappedValue = \u003cspan\u003etry\u003c/span\u003e container.\u003cspan\u003edecode\u003c/span\u003e(\u003cspan\u003eValue\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp\u003eAbove we’re using Swift’s conditional conformances feature to not have to require that all \u003ccode\u003eReadonly.Value\u003c/code\u003e types always have to conform to \u003ccode\u003eEncodable\u003c/code\u003e and \u003ccode\u003eDecodable\u003c/code\u003e, which would limit our property wrapper’s versatility.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eWith the above in place, we can now go ahead and update our \u003ccode\u003eUser\u003c/code\u003e type to use \u003ccode\u003eReadonly\u003c/code\u003e-marked \u003ccode\u003evar\u003c/code\u003e declarations for the properties that we want to define a default value for:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e User: \u003cspan\u003eIdentifiable\u003c/span\u003e, \u003cspan\u003eCodable\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003e@Readonly var\u003c/span\u003e id = \u003cspan\u003eUUID\u003c/span\u003e()\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e name: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e bio: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003e@Readonly var\u003c/span\u003e imageURL: \u003cspan\u003eURL\u003c/span\u003e?\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp\u003eNote that, since we’re now using a \u003ccode\u003evar\u003c/code\u003e for our type’s \u003ccode\u003eimageURL\u003c/code\u003e property, it’s default value automatically becomes \u003ccode\u003enil\u003c/code\u003e — there’s no need for us to declare that manually.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eThe advantage of the above approach is that we now have a reusable solution that helps us avoid having to manually declare initializers when all we want is to be able to define default values for read-only properties. However, whenever we use a non-standard solution, like the one above, it’s important to consider whether the inherent additional complexity of such a custom solution is worth the benefits that we get from it.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"is-immutability-always-the-answer\" href=\"#is-immutability-always-the-answer\"\u003eIs immutability always the answer?\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAnother alternative approach to make our properties support default values is to simply declare them using \u003ccode\u003evar\u003c/code\u003e instead. While that \u003cem\u003edoes\u003c/em\u003e enable those properties to be mutated, perhaps that isn’t actually a problem, given that all structs are by default passed as immutable copies when calling a function or when initializing another type.\u003c/p\u003e\u003cp\u003eIn practice, that means that structs don’t have the same \u003cem\u003eshared mutable state\u003c/em\u003e problem that classes often do (unless static mutable values are used), so the question is how problematic it would actually be to do something like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e User: \u003cspan\u003eIdentifiable\u003c/span\u003e, \u003cspan\u003eCodable\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003evar\u003c/span\u003e\u003c/span\u003e id = \u003cspan\u003eUUID\u003c/span\u003e()\n    \u003cspan\u003e\u003cspan\u003evar\u003c/span\u003e\u003c/span\u003e name: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003evar\u003c/span\u003e\u003c/span\u003e bio: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003evar\u003c/span\u003e\u003c/span\u003e imageURL: \u003cspan\u003eURL\u003c/span\u003e?\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOne \u003cem\u003ebenefit\u003c/em\u003e of making our structs as mutable as possible is that doing so often makes it much easier to write unit tests — either when our structs are used as stub values, or when the structs themselves are the types being tested. For example, let’s say that we wanted to add a method for normalizing a given user’s name:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eUser\u003c/span\u003e {\n    \u003cspan\u003emutating func\u003c/span\u003e normalizeName() {\n        name = name\n            .\u003cspan\u003efilter\u003c/span\u003e { char \u003cspan\u003ein\u003c/span\u003e\n                char.\u003cspan\u003eisLetter\u003c/span\u003e || (char.\u003cspan\u003eisWhitespace\u003c/span\u003e \u0026amp;\u0026amp; !char.\u003cspan\u003eisNewline\u003c/span\u003e)\n            }\n            .\u003cspan\u003etrimmingCharacters\u003c/span\u003e(in: .\u003cspan\u003ewhitespaces\u003c/span\u003e)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSince the \u003ccode\u003ename\u003c/code\u003e property is now a \u003ccode\u003evar\u003c/code\u003e, we could easily write a test that verifies various normalization scenarios, all while reusing the same \u003ccode\u003eUser\u003c/code\u003e value — for example like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e UserTests {\n    \u003cspan\u003e@Test func\u003c/span\u003e normalizingName() {\n        \u003cspan\u003evar\u003c/span\u003e user = \u003cspan\u003eUser\u003c/span\u003e(name: \u003cspan\u003e\u0026#34;Name\u0026#34;\u003c/span\u003e, bio: \u003cspan\u003e\u0026#34;Bio\u0026#34;\u003c/span\u003e)\n\n        \u003cspan\u003e// Non-letter characters are removed:\u003c/span\u003e\n        user.\u003cspan\u003ename\u003c/span\u003e = \u003cspan\u003e\u0026#34;!1_First 2;Last_3?\u0026#34;\u003c/span\u003e\n        user.\u003cspan\u003enormalizeName\u003c/span\u003e()\n        \u003cspan\u003e#expect\u003c/span\u003e(user.\u003cspan\u003ename\u003c/span\u003e == \u003cspan\u003e\u0026#34;First Last\u0026#34;\u003c/span\u003e)\n\n        \u003cspan\u003e// Leading and trailing whitespaces are removed:\u003c/span\u003e\n        user.\u003cspan\u003ename\u003c/span\u003e = \u003cspan\u003e\u0026#34; White Spaces \u0026#34;\u003c/span\u003e\n        user.\u003cspan\u003enormalizeName\u003c/span\u003e()\n        \u003cspan\u003e#expect\u003c/span\u003e(user.\u003cspan\u003ename\u003c/span\u003e == \u003cspan\u003e\u0026#34;White Spaces\u0026#34;\u003c/span\u003e)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt’s also important to remember that just because we mark a given struct property as a \u003ccode\u003elet\u003c/code\u003e doesn’t mean that its value can \u003cem\u003enever change\u003c/em\u003e, since the mutability of a given value is always determined by the top-level, enclosing value that the property is contained within.\u003c/p\u003e\u003cp\u003eFor example, let’s say that we wanted to make another attempt at striking a nice balance between mutability and consistency for our \u003ccode\u003eUser\u003c/code\u003e type — this time by making all non-\u003ccode\u003eid\u003c/code\u003e properties variables, while keeping the \u003ccode\u003eid\u003c/code\u003e property a \u003ccode\u003elet\u003c/code\u003e (since that’s the one property we never expect to change throughout the lifetime of a \u003ccode\u003eUser\u003c/code\u003e value):\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e User: \u003cspan\u003eIdentifiable\u003c/span\u003e, \u003cspan\u003eCodable\u003c/span\u003e {\n    \u003cspan\u003elet\u003c/span\u003e id: \u003cspan\u003eUUID\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003evar\u003c/span\u003e name: \u003cspan\u003eString\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e bio: \u003cspan\u003eString\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e imageURL: \u003cspan\u003eURL\u003c/span\u003e?\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen, let’s say that we wanted to introduce an API for transforming a given \u003ccode\u003eUser\u003c/code\u003e value in some way, for example by using the \u003ccode\u003enormalizeName\u003c/code\u003e method we defined earlier. Such an API could take the form of a \u003ccode\u003eUserTransformer\u003c/code\u003e protocol, which uses Swift’s \u003ccode\u003einout\u003c/code\u003e parameter feature to enable each transformer to directly mutate the \u003ccode\u003eUser\u003c/code\u003e value that was passed to it, without first having to make a mutable copy:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprotocol\u003c/span\u003e UserTransformer {\n    \u003cspan\u003efunc\u003c/span\u003e transformUser(\u003cspan\u003e_\u003c/span\u003e user: \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003eUser\u003c/span\u003e)\n}\n\n\u003cspan\u003estruct\u003c/span\u003e UserNameNormalizer: \u003cspan\u003eUserTransformer\u003c/span\u003e {\n    \u003cspan\u003efunc\u003c/span\u003e transformUser(\u003cspan\u003e_\u003c/span\u003e user: \u003cspan\u003e\u003cspan\u003einout\u003c/span\u003e \u003cspan\u003eUser\u003c/span\u003e\u003c/span\u003e) {\n        user.\u003cspan\u003enormalizeName\u003c/span\u003e()\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo the question is, with the above setup, do we have a \u003cem\u003eguarantee\u003c/em\u003e that the \u003ccode\u003eid\u003c/code\u003e property of any \u003ccode\u003eUser\u003c/code\u003e value that was passed to a \u003ccode\u003eUserTransformer\u003c/code\u003e implementation can never be changed? No, actually, we don’t. Because we have to remember, the \u003ccode\u003eUser\u003c/code\u003e value \u003cem\u003eitself\u003c/em\u003e is mutable, and it can be completely re-assigned with a brand new \u003ccode\u003eUUID\u003c/code\u003e if the implementation so desires — for example like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e UserIDTransformer: \u003cspan\u003eUserTransformer\u003c/span\u003e {\n    \u003cspan\u003efunc\u003c/span\u003e transformUser(\u003cspan\u003e_\u003c/span\u003e user: \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003eUser\u003c/span\u003e) {\n        user = \u003cspan\u003eUser\u003c/span\u003e(\n            \u003cspan\u003eid: \u003cspan\u003eUUID\u003c/span\u003e()\u003c/span\u003e,\n            name: user.\u003cspan\u003ename\u003c/span\u003e,\n            bio: user.\u003cspan\u003ebio\u003c/span\u003e,\n            imageURL: user.\u003cspan\u003eimageURL\u003c/span\u003e\n        )\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAdmittedly, code like the above is quite likely to raise some eyebrows during code review (when working with a team), but it just illustrates how we have to think about value types — such as structs and enums — when working with them. They don’t have the same concept of \u003cem\u003eidentity\u003c/em\u003e and a \u003cem\u003elifecycle\u003c/em\u003e, like classes and actors do, which is important to remember when we design our types and their associated APIs.\u003c/p\u003e\u003ca href=\"https://geniusscansdk.com/swiftbysundell?utm_content=inline_ad\" rel=\"nofollow\" target=\"_blank\"\u003e\u003cimg src=\"https://www.swiftbysundell.com/images/supporters/geniusScan-image.png\" alt=\"Genius Scan SDK\"/\u003e\u003cp\u003eSwift by Sundell is brought to you by the \u003cstrong\u003eGenius Scan SDK\u003c/strong\u003e — Add a powerful document scanner to any mobile app, and turn scans into high-quality PDFs with one line of code. \u003cu\u003eTry it today\u003c/u\u003e.\u003c/p\u003e\u003c/a\u003e\u003ch2\u003e\u003ca id=\"conclusion\" href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSo how \u003cem\u003edo\u003c/em\u003e you decide between using \u003ccode\u003elet\u003c/code\u003e and \u003ccode\u003evar\u003c/code\u003e when declaring struct properties? My personal approach is to keep my struct properties \u003cem\u003emutable by default\u003c/em\u003e, since I feel like that really leans into the core concept of value types — that it’s the enclosing value, not individual properties, that actually determines the real mutability of a given value.\u003c/p\u003e\u003cp\u003eThat being said, marking properties that we never expect to be mutated (such as a type’s ID) as \u003ccode\u003elet\u003c/code\u003e is also usually a good practice — even though it doesn’t strictly guarantee that such values will never change, it at least signals to everyone on the team what the \u003cem\u003eintended\u003c/em\u003e mutability of such a property is.\u003c/p\u003e\u003cp\u003eWhat do you think? Let me know what your thoughts are on this topic — along with any questions or feedback you might have — on either \u003ca href=\"https://mastodon.social/@johnsundell\"\u003eMastodon\u003c/a\u003e or \u003ca href=\"https://bsky.app/profile/johnsundell.bsky.social\"\u003eBluesky\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": null,
  "modifiedTime": null
}
