{
  "id": "29e00ebc-c02d-4bc7-a98c-4a8a3cafecc4",
  "title": "AttributedString‚Äôs Codable format and what it has to do with Unicode",
  "link": "https://oleb.net/2022/attributedstring-codable/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2022-04-27T13:28:03Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann ‚Ä¶",
  "length": 4919,
  "excerpt": "Don‚Äôt store string indices or offsets if possible. They aren‚Äôt stable over time or across runtime environments.",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "Here‚Äôs a simple AttributedString with some formatting: import Foundation let str = try! AttributedString( markdown: \"Caf√© **Sol**\", options: .init(interpretedSyntax: .inlineOnly) ) AttributedString is Codable. If your task was to design the encoding format for an attributed string, what would you come up with? Something like this seems reasonable (in JSON with comments): { \"text\": \"Caf√© Sol\", \"runs\": [ { // start..\u003cend in Character offsets \"range\": [5, 8], \"attrs\": { \"strong\": true } } ] } This stores the text alongside an array of runs of formatting attributes. Each run consists of a character range and an attribute dictionary. Unicode is complicated But this format is bad and can break in various ways. The problem is that the character offsets that define the runs aren‚Äôt guaranteed to be stable. The definition of what constitutes a Character, i.e. a user-perceived character, or a Unicode grapheme cluster, can and does change in new Unicode versions. If we decoded an attributed string that had been serialized on a different OS version (before Swift 5.6, Swift used the OS‚Äôs Unicode library for determining character boundaries), or by code compiled with a different Swift version (since Swift 5.6, Swift uses its own grapheme breaking algorithm that will be updated alongside the Unicode standard)1, the character ranges might no longer represent the original intent, or even become invalid. Update April 11, 2024: See this Swift forum post I wrote for an example where the Unicode rules for grapheme cluster segmentation changed for flag emoji. This change caused a corresponding change in how Swift counts the Characters in a string containing consecutive flags, such as \"üá¶üá∑üáØüáµ\". Normalization forms So let‚Äôs use UTF-8 byte offsets for the ranges, I hear you say. This avoids the first issue but still isn‚Äôt safe, because some characters, such as the √© in the example string, have more than one representation in Unicode: it can be either the standalone character √© (Latin small letter e with acute) or the combination of e + ‚óåÃÅ (Combining acute accent). The Unicode standard calls these variants normalization forms.2 The first form needs 2 bytes in UTF-8, whereas the second uses 3 bytes, so subsequent ranges would be off by one if the string and the ranges used different normalization forms. Now in theory, the string itself and the ranges should use the same normalization form upon serialization, avoiding the problem. But this is almost impossible to guarantee if the serialized data passes through other systems that may (inadvertently or not) change the Unicode normalization of the strings that pass through them. A safer option would be to store the text not as a string but as a blob of UTF-8 bytes, because serialization/networking/storage layers generally don‚Äôt mess with binary data. But even then you‚Äôd have to be careful in the encoding and decoding code to apply the formatting attributes before any normalization takes place. Depending on how your programming language handles Unicode, this may not be so easy. Foundation‚Äôs solution The people on the Foundation team know all this, of course, and chose a better encoding format for Attributed String. Let‚Äôs take a look.3 let encoder = JSONEncoder() encoder.outputFormatting = [.prettyPrinted, .sortedKeys] let jsonData = try encoder.encode(str) let json = String(decoding: jsonData, as: UTF8.self) This is how our sample string is encoded: [ \"Caf√© \", { }, \"Sol\", { \"NSInlinePresentationIntent\" : 2 } ] This is an array of runs, where each run consists of a text segment and a dictionary of formatting attributes. The important point is that the formatting attributes are directly associated with the text segments they belong to, not indirectly via brittle byte or character offsets. (This encoding format is also more space-efficient and possibly better represents the in-memory layout of AttributedString, but that‚Äôs beside the point for this discussion.) There‚Äôs still a (smaller) potential problem here if the character boundary rules change for code points that span two adjacent text segments: the last character of run N and the first character of run N+1 might suddenly form a single character (grapheme cluster) in a new Unicode version. In that case, the decoding code will have to decide which formatting attributes to apply to this new character. But this is a much smaller issue because it only affects the characters in question. Unlike our original example, where an off-by-one error in run N would affect all subsequent runs, all other runs are untouched. Related forum discussion: Itai Ferber on why Character isn‚Äôt Codable. Storing string offsets is a bad idea We can extract a general lesson out of this: Don‚Äôt store string indices or offsets if possible. They aren‚Äôt stable over time or across runtime environments.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003carticle\u003e\n        \u003cheader\u003e\n          \n        \u003c/header\u003e\n\n        \n\n        \u003cdiv\u003e\n          \u003cp\u003eHere‚Äôs a simple \u003ca href=\"https://developer.apple.com/documentation/foundation/attributedstring\"\u003e\u003ccode\u003eAttributedString\u003c/code\u003e\u003c/a\u003e with some formatting:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eFoundation\u003c/span\u003e\n\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etry!\u003c/span\u003e \u003cspan\u003eAttributedString\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n  \u003cspan\u003emarkdown\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;Caf√© **Sol**\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n  \u003cspan\u003eoptions\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003einterpretedSyntax\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einlineOnly\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eAttributedString\u003c/code\u003e is \u003ca href=\"https://developer.apple.com/documentation/swift/codable\"\u003e\u003ccode\u003eCodable\u003c/code\u003e\u003c/a\u003e. If your task was to design the encoding format for an attributed string, what would you come up with? Something like this seems reasonable (in JSON with comments):\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e\n  \u003c/span\u003e\u003cspan\u003e\u0026#34;text\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;Caf√© Sol\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e\n  \u003c/span\u003e\u003cspan\u003e\u0026#34;runs\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\n    \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e\n      \u003c/span\u003e\u003cspan\u003e// start..\u0026lt;end in Character offsets\u003c/span\u003e\u003cspan\u003e\n      \u003c/span\u003e\u003cspan\u003e\u0026#34;range\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e\u003cspan\u003e\n      \u003c/span\u003e\u003cspan\u003e\u0026#34;attrs\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e\n        \u003c/span\u003e\u003cspan\u003e\u0026#34;strong\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e\n      \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e\n    \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e\n  \u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis stores the text alongside an array of runs of formatting attributes. Each run consists of a character range and an attribute dictionary.\u003c/p\u003e\n\n\u003ch2 id=\"unicode-is-complicated\"\u003eUnicode is complicated\u003c/h2\u003e\n\n\u003cp\u003eBut this format is bad and can break in various ways. The problem is that the character offsets that define the runs aren‚Äôt guaranteed to be stable. The definition of what constitutes a \u003ca href=\"https://developer.apple.com/documentation/swift/character\"\u003e\u003ccode\u003eCharacter\u003c/code\u003e\u003c/a\u003e, i.e. a user-perceived character, or a \u003ca href=\"https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\"\u003eUnicode grapheme cluster\u003c/a\u003e, can and does change in new Unicode versions. If we decoded an attributed string that had been serialized\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eon a different OS version (before Swift 5.6, Swift used the OS‚Äôs Unicode library for determining character boundaries),\u003c/li\u003e\n  \u003cli\u003eor by code compiled with a different Swift version (since Swift 5.6, \u003ca href=\"https://github.com/apple/swift/issues/52935\"\u003eSwift uses its own grapheme breaking algorithm\u003c/a\u003e that will be updated alongside the Unicode standard)\u003csup id=\"fnref:unicodeversion\" role=\"doc-noteref\"\u003e\u003ca href=\"#fn:unicodeversion\" rel=\"footnote\"\u003e1\u003c/a\u003e\u003c/sup\u003e, the character ranges might no longer represent the original intent, or even become invalid.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003eUpdate April 11, 2024:\u003c/strong\u003e See \u003ca href=\"https://forums.swift.org/t/will-swift-strings-understanding-of-characters-remain-stable/71164/3\"\u003ethis Swift forum post I wrote\u003c/a\u003e for an example where the Unicode rules for grapheme cluster segmentation changed for flag emoji. This change caused a corresponding change in how Swift counts the \u003ccode\u003eCharacter\u003c/code\u003es in a string containing consecutive flags, such as \u003ccode\u003e\u0026#34;üá¶üá∑üáØüáµ\u0026#34;\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"normalization-forms\"\u003eNormalization forms\u003c/h2\u003e\n\n\u003cp\u003eSo let‚Äôs use UTF-8 byte offsets for the ranges, I hear you say. This avoids the first issue but still isn‚Äôt safe, because some characters, such as the √© in the example string, have more than one representation in Unicode: it can be either the standalone character √© (\u003ca href=\"https://oleb.net/2022/attributedstring-codable/codepoints.net/U+00E9\"\u003eLatin small letter e with acute\u003c/a\u003e) or the combination of e + ‚óåÃÅ (\u003ca href=\"https://codepoints.net/U+0301\"\u003eCombining acute accent\u003c/a\u003e). The Unicode standard calls these variants \u003ca href=\"https://unicode.org/reports/tr15/\"\u003enormalization forms\u003c/a\u003e.\u003csup id=\"fnref:normalize\" role=\"doc-noteref\"\u003e\u003ca href=\"#fn:normalize\" rel=\"footnote\"\u003e2\u003c/a\u003e\u003c/sup\u003e The first form needs 2 bytes in UTF-8, whereas the second uses 3 bytes, so subsequent ranges would be off by one if the string and the ranges used different normalization forms.\u003c/p\u003e\n\n\u003cp\u003eNow in theory, the string itself and the ranges should use the same normalization form upon serialization, avoiding the problem. But this is almost impossible to guarantee if the serialized data passes through other systems that may (inadvertently or not) change the Unicode normalization of the strings that pass through them.\u003c/p\u003e\n\n\u003cp\u003eA safer option would be to store the text not as a string but as a blob of UTF-8 bytes, because serialization/networking/storage layers generally don‚Äôt mess with binary data. But even then you‚Äôd have to be careful in the encoding and decoding code to apply the formatting attributes before any normalization takes place. Depending on how your programming language handles Unicode, this may not be so easy.\u003c/p\u003e\n\n\u003ch2 id=\"foundations-solution\"\u003eFoundation‚Äôs solution\u003c/h2\u003e\n\n\u003cp\u003eThe people on the Foundation team know all this, of course, and chose a better encoding format for \u003ccode\u003eAttributed String\u003c/code\u003e. Let‚Äôs take a look.\u003csup id=\"fnref:decode\" role=\"doc-noteref\"\u003e\u003ca href=\"#fn:decode\" rel=\"footnote\"\u003e3\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eencoder\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eJSONEncoder\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003eencoder\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eoutputFormatting\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprettyPrinted\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esortedKeys\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ejsonData\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003eencoder\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eencode\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ejson\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edecoding\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ejsonData\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUTF8\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis is how our sample string is encoded:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\n  \u003c/span\u003e\u003cspan\u003e\u0026#34;Caf√© \u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e\n  \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e\n\n  \u003c/span\u003e\u003cspan\u003e},\u003c/span\u003e\u003cspan\u003e\n  \u003c/span\u003e\u003cspan\u003e\u0026#34;Sol\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e\n  \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e\n    \u003c/span\u003e\u003cspan\u003e\u0026#34;NSInlinePresentationIntent\u0026#34;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e\n  \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis is an array of runs, where each run consists of a text segment and a dictionary of formatting attributes. The important point is that the formatting attributes are directly associated with the text segments they belong to, not indirectly via brittle byte or character offsets. (This encoding format is also more space-efficient and possibly better represents the in-memory layout of \u003ccode\u003eAttributedString\u003c/code\u003e, but that‚Äôs beside the point for this discussion.)\u003c/p\u003e\n\n\u003cp\u003eThere‚Äôs still a (smaller) potential problem here if the \u003ca href=\"https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\"\u003echaracter boundary rules\u003c/a\u003e change for code points that span two adjacent text segments: the last character of run N and the first character of run N+1 might suddenly form a single character (grapheme cluster) in a new Unicode version. In that case, the decoding code will have to decide which formatting attributes to apply to this new character. But this is a much smaller issue because it only affects the characters in question. Unlike our original example, where an off-by-one error in run N would affect all subsequent runs, all other runs are untouched.\u003c/p\u003e\n\n\u003cp\u003eRelated forum discussion: \u003ca href=\"https://forums.swift.org/t/why-is-character-not-codable/56178/2\"\u003eItai Ferber on why \u003ccode\u003eCharacter\u003c/code\u003e isn‚Äôt \u003ccode\u003eCodable\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"storing-string-offsets-is-a-bad-idea\"\u003eStoring string offsets is a bad idea\u003c/h2\u003e\n\n\u003cp\u003eWe can extract a general lesson out of this: Don‚Äôt store string indices or offsets if possible. They aren‚Äôt stable over time or across runtime environments.\u003c/p\u003e\n\n\n        \u003c/div\u003e\n      \u003c/article\u003e\n      \n      \n      \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2022-04-27T13:28:03Z",
  "modifiedTime": "2024-04-11T11:29:01Z"
}
