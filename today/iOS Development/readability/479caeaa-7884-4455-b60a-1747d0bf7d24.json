{
  "id": "479caeaa-7884-4455-b60a-1747d0bf7d24",
  "title": "Weak self, a story about memory management and closure in Swift",
  "link": "https://benoitpasquier.com/weak-self-story-memory-management-closure-swift/",
  "description": "Memory management is a big topic in Swift and iOS development. If there are plenty of tutorials explaining when to use weak self with closure, here is a short story when memory leaks can still happen with it.",
  "author": "",
  "published": "Sat, 02 Apr 2022 01:00:00 +0000",
  "source": "https://benoitpasquier.com/index.xml",
  "categories": null,
  "byline": "Benoit Pasquier",
  "length": 10314,
  "excerpt": "Memory management is a big topic in Swift and iOS development. If there are plenty of tutorials explaining when to use weak self with closure, here is a short story when memory leaks can still happen with it.",
  "siteName": "Benoit Pasquier",
  "favicon": "https://benoitpasquier.com/favicon.png",
  "text": "Memory management is a big topic in Swift and iOS development. If there are plenty of tutorials explaining when to use weak self with closure, here is a short story when memory leaks can still happen with it. For the purpose of this blog post, let‚Äôs assume we have the following class with two functions. Each function execute something and finalize the execution with a closure executed. UPDATE - 9 April 2022: I have revisited the examples to highlight when the reference counter is increased and when it can cause memory leaks. class MyClass { func doSomething(_ completion: (() -\u003e Void)?) { // do something completion?() } func doSomethingElse(_ completion: (() -\u003e Void)?) { // do something else completion?() } } Now, here comes a new requirement, we want a new function doEverything that will execute both doSomething and doSomethingElse in this order. Along the way, we are changing the state of the class to follow the progression. var didSomething: Bool = false var didSomethingElse: Bool = false func doEverything() { self.doSomething { self.didSomething = true // \u003c- strong reference to self print(\"did something\") self.doSomethingElse { self.didSomethingElse = true // \u003c- strong reference to self print(\"did something else\") } } } Right off the bat, we can see self is strongly captured in the first and second closures: the closures keep a strong reference to self which internally increment the reference counter and can prevent to de-allocate the instance during the execution of doSomething. It means if those functions were asynchronous and we want to release the instance before it completes the execution, the system would still have to wait to complete it before releasing the memory. Of course, we know better and setup weak self for the closures: func doEverything() { self.doSomething { [weak self] in self?.didSomething = true print(\"did something\") self?.doSomethingElse { [weak self] in self?.didSomethingElse = true print(\"did something else\") } } } Wait, do we actually need both [weak self] for each closure? Actually, we don‚Äôt. When we have nested closures like here, we should always set weak self to the first one, the outer closure. The inner closure, the one nested in the outer can reuse the same weak self. func doEverything() { self.doSomething { [weak self] in self?.didSomething = true print(\"did something\") self?.doSomethingElse { in self?.didSomethingElse = true print(\"did something else\") } } } However, if we did the other way around, having weak self only in the nested closure, the outer closure would still capture self strongly and increment the reference counter. So be careful where you set this one up. func doEverything() { self.doSomething { in self.didSomething = true // \u003c- strong reference to self print(\"did something\") self.doSomethingElse { [weak self] in self?.didSomethingElse = true print(\"did something else\") } } } So far so good. Since we want to change other variables along the way, let‚Äôs clean the code with a guard let to make sure the instance is still available. func doEverything() { self.doSomething { [weak self] in guard let self = self else { return } self.didSomething = true print(\"did something\") self.doSomethingElse { in self.didSomethingElse = true // \u003c-- strong reference? print(\"did something else\") } } } But now, here comes the question: since we have a strong reference called self in the outer closure, does the inner closure strongly capture it? How can we verify this? This is the kind of questions that is worth diving into and Xcode Playground is perfect for this. I‚Äôll include few logs to keep track of the steps as well as logging the reference counter. For the first example, let‚Äôs keep it simple, so we can see how the reference counter is incremented along the way. class MyClass { func doSomething(_ completion: (() -\u003e Void)?) { // do something completion?() } func doSomethingElse(_ completion: (() -\u003e Void)?) { // do something else completion?() } var didSomething: Bool = false var didSomethingElse: Bool = false deinit { print(\"Deinit\") } func printCounter() { print(CFGetRetainCount(self)) } func doEverything() { print(\"start\") printCounter() self.doSomething { self.didSomething = true print(\"did something\") self.printCounter() self.doSomethingElse { self.didSomethingElse = true print(\"did something else\") self.printCounter() } } printCounter() } } do { let model = MyClass() model.doEverything() } Here is the output # output start 2 did something 4 did something else 6 2 Deinit With only strong references to self, we can see the counter going up to 6. However, as expected, once both functions are executed, the instance is de-allocated. Now let‚Äôs introduce weak self in the outer closure. func doEverything() { print(\"start\") printCounter() self.doSomething { [weak self] in self?.didSomething = true print(\"did something\") self?.printCounter() self?.doSomethingElse { self?.didSomethingElse = true print(\"did something else\") self?.printCounter() } } printCounter() } With the first weak self, the instance is still de-allocated, and the counter goes only up to 4. # output start 2 did something 3 did something else 4 2 Deinit So what happens with guard let self? func doEverything() { print(\"start\") printCounter() self.doSomething { [weak self] in guard let self = self else { return } self.didSomething = true print(\"did something\") self.printCounter() self.doSomethingElse { self.didSomethingElse = true print(\"did something else\") self.printCounter() } } printCounter() } Here is the output # output start 2 did something 3 did something else 5 2 Deinit If the instance is successfully de-initialized, we can see that the counter is actually increased from 4 to 5 when we execute doSomethingElse, which means the nester closure capture strongly our temporary self. It looks already suspicious, but let‚Äôs try with a different example. What if, instead of functions, doSomething and doSomethingElse are closure properties of the class. Let‚Äôs adapt the code for a similar execution. class MyClass { var doSomething: (() -\u003e Void)? var doSomethingElse: (() -\u003e Void)? var didSomething: Bool = false var didSomethingElse: Bool = false deinit { print(\"Deinit\") } func printCounter() { print(CFGetRetainCount(self)) } func doEverything() { print(\"start\") printCounter() doSomething = { [weak self] in guard let self = self else { return } self.didSomething = true print(\"did something\") self.printCounter() self.doSomethingElse = { self.didSomethingElse = true print(\"did something else\") self.printCounter() } self.doSomethingElse?() } doSomething?() printCounter() } } do { let model = MyClass() model.doEverything() } Here is the output # output start 2 did something 3 did something else 5 3 This time, the class is not even de-allocated ü§Ø. To fix it back, we have to keep a weak instance. func doEverything() { print(\"start\") printCounter() doSomething = { [weak self] in self?.didSomething = true print(\"did something\") self?.printCounter() self?.doSomethingElse = { self?.didSomethingElse = true print(\"did something else\") self?.printCounter() } self?.doSomethingElse?() } doSomething?() printCounter() } # output start 2 did something 3 did something else 3 2 Deinit Yay, the instance is properly de-allocated this time. It‚Äôs confirmed, the inner closure was making a strong reference to guard let self. So, what does it mean for my code? When we face a closure, we tend to write weak self followed by a guard let to quickly go around without thinking too much about the execution further down. This is where we still need to be careful. It‚Äôs easy to miss this kind of memory leaks, so here are few takeaways: First, regarding the format, I personally use guard let strongSelf in closure instead of guard let self. The reason is that during code review, it can be tricky to know which ‚Äúself‚Äù we are referring to further down in the code. Second, if there is nested closure, I would prefer keeping reference to the weak (and optional) self? and never point back to strongSelf, so I have the insurance to avoid any strong reference to it. func doEverything() { doSomething = { [weak self] in guard let strongSelf = self else { return } strongSelf.didSomething = true print(\"did something\") strongSelf.doSomethingElse = { self?.didSomethingElse = true print(\"did something else\") } strongSelf.doSomethingElse?() } doSomething?() } Last but not least, if we have too many closures to handles, the best is still to refactor it as a separate function, or use newer API to avoid those mistakes. I‚Äôm thinking about functional reactive programming like RxSwift or Combine, but also swift Async to get by. Of course, the code shared today might be a bit farfetched and might not reflect your daily usage of closures, but in my opinion, it‚Äôs still important to keep in mind the memory management and reference we make of our instances. Also, this question came right into the middle of a peer review, so we never too careful ;) Hope you enjoyed this post, happy coding!",
  "image": "https://benoitpasquier.com/images/2022/04/weak-self-memory-management-swift.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n              \u003cp\u003eMemory management is a big topic in Swift and iOS development. If there are plenty of tutorials explaining when to use \u003ccode\u003eweak self\u003c/code\u003e with closure, here is a short story when memory leaks can still happen with it.\u003c/p\u003e\n\u003cp\u003eFor the purpose of this blog post, let‚Äôs assume we have the following class with two functions. Each function execute \u003cem\u003esomething\u003c/em\u003e and finalize the execution with a closure executed.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUPDATE - 9 April 2022:\u003c/strong\u003e I have revisited the examples to highlight when the reference counter is increased and when it can cause memory leaks.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMyClass\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoSomething\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ecompletion\u003c/span\u003e: (() -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e)?) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// do something\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ecompletion\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoSomethingElse\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ecompletion\u003c/span\u003e: (() -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e)?) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// do something else\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ecompletion\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow, here comes a new requirement, we want a new function \u003ccode\u003edoEverything\u003c/code\u003e that will execute both \u003ccode\u003edoSomething\u003c/code\u003e and \u003ccode\u003edoSomethingElse\u003c/code\u003e in this order. Along the way, we are changing the state of the class to follow the progression.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edidSomething\u003c/span\u003e: \u003cspan\u003eBool\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edidSomethingElse\u003c/span\u003e: \u003cspan\u003eBool\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoEverything\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomething\u003c/span\u003e { \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edidSomething\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e \u003cspan\u003e// \u0026lt;- strong reference to self\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomethingElse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edidSomethingElse\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e \u003cspan\u003e// \u0026lt;- strong reference to self\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something else\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eRight off the bat, we can see \u003ccode\u003eself\u003c/code\u003e is strongly captured in the first and second closures: the closures keep a strong reference to \u003ccode\u003eself\u003c/code\u003e which internally increment the reference counter and can prevent to de-allocate the instance during the execution of \u003ccode\u003edoSomething\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIt means if those functions were asynchronous and we want to release the instance before it completes the execution, the system would still have to wait to complete it before releasing the memory.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eOf course\u003c/em\u003e, we know better and setup \u003ccode\u003eweak self\u003c/code\u003e for the closures:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoEverything\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomething\u003c/span\u003e { [\u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e] \u003cspan\u003ein\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edidSomething\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edoSomethingElse\u003c/span\u003e { [\u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e] \u003cspan\u003ein\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edidSomethingElse\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something else\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003eWait, do we actually need both \u003ccode\u003e[weak self]\u003c/code\u003e for each closure?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eActually, \u003cstrong\u003ewe don‚Äôt\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWhen we have nested closures like here, we should always set \u003ccode\u003eweak self\u003c/code\u003e to the first one, the \u003cem\u003eouter closure\u003c/em\u003e. The \u003cem\u003einner closure\u003c/em\u003e, the one nested in the \u003cem\u003eouter\u003c/em\u003e can reuse the same weak self.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoEverything\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomething\u003c/span\u003e { [\u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e] \u003cspan\u003ein\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edidSomething\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edoSomethingElse\u003c/span\u003e { \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edidSomethingElse\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something else\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHowever, if we did the other way around, having \u003ccode\u003eweak self\u003c/code\u003e only in the \u003cem\u003enested\u003c/em\u003e closure, the \u003cem\u003eouter\u003c/em\u003e closure would still capture \u003ccode\u003eself\u003c/code\u003e strongly and increment the reference counter. So be careful where you set this one up.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoEverything\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomething\u003c/span\u003e { \u003cspan\u003ein\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edidSomething\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e \u003cspan\u003e// \u0026lt;- strong reference to self\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomethingElse\u003c/span\u003e { [\u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e] \u003cspan\u003ein\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edidSomethingElse\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something else\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSo far so good.\u003c/p\u003e\n\u003cp\u003eSince we want to change other variables along the way, let‚Äôs clean the code with a \u003ccode\u003eguard let\u003c/code\u003e to make sure the instance is still available.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoEverything\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomething\u003c/span\u003e { [\u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e] \u003cspan\u003ein\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e = \u003cspan\u003eself\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e { \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ereturn\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edidSomething\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomethingElse\u003c/span\u003e { \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edidSomethingElse\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e \u003cspan\u003e// \u0026lt;-- strong reference?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something else\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBut now, here comes the question: since we have a strong reference called \u003ccode\u003eself\u003c/code\u003e in the \u003cem\u003eouter\u003c/em\u003e closure, does the \u003cem\u003einner\u003c/em\u003e closure strongly capture it? How can we verify this?\u003c/p\u003e\n\u003cp\u003eThis is the kind of questions that is worth diving into and Xcode Playground is perfect for this. I‚Äôll include few logs to keep track of the steps as well as logging the reference counter.\u003c/p\u003e\n\u003cp\u003eFor the first example, let‚Äôs keep it simple, so we can see how the reference counter is incremented along the way.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMyClass\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoSomething\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ecompletion\u003c/span\u003e: (() -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e)?) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// do something\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ecompletion\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoSomethingElse\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ecompletion\u003c/span\u003e: (() -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e)?) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// do something else\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ecompletion\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edidSomething\u003c/span\u003e: \u003cspan\u003eBool\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edidSomethingElse\u003c/span\u003e: \u003cspan\u003eBool\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003edeinit\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;Deinit\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eprintCounter\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003eCFGetRetainCount\u003c/span\u003e(\u003cspan\u003eself\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoEverything\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;start\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomething\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edidSomething\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomethingElse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edidSomethingElse\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something else\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003edo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emodel\u003c/span\u003e = \u003cspan\u003eMyClass\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003emodel\u003c/span\u003e.\u003cspan\u003edoEverything\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere is the output\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"sh\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e# output\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003estart\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edid something\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edid something \u003cspan\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e6\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eDeinit\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWith only strong references to \u003ccode\u003eself\u003c/code\u003e, we can see the counter going up to \u003ccode\u003e6\u003c/code\u003e. However, as expected, once both functions are executed, the instance is de-allocated.\u003c/p\u003e\n\u003cp\u003eNow let‚Äôs introduce \u003ccode\u003eweak self\u003c/code\u003e in the \u003cem\u003eouter\u003c/em\u003e closure.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoEverything\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;start\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomething\u003c/span\u003e { [\u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e] \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edidSomething\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edoSomethingElse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edidSomethingElse\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something else\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWith the first \u003ccode\u003eweak self\u003c/code\u003e, the instance is still de-allocated, and the counter goes only up to \u003ccode\u003e4\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"sh\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e# output\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003estart\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edid something\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edid something \u003cspan\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eDeinit\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSo what happens with \u003ccode\u003eguard let self\u003c/code\u003e?\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoEverything\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;start\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomething\u003c/span\u003e { [\u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e] \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e = \u003cspan\u003eself\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e { \u003cspan\u003ereturn\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edidSomething\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomethingElse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edidSomethingElse\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something else\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere is the output\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"sh\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e# output\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003estart\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edid something\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edid something \u003cspan\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eDeinit\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf the instance is successfully de-initialized, we can see that the counter is actually increased from \u003ccode\u003e4\u003c/code\u003e to \u003ccode\u003e5\u003c/code\u003e when we execute \u003ccode\u003edoSomethingElse\u003c/code\u003e, which means the nester closure capture \u003cstrong\u003estrongly\u003c/strong\u003e our temporary \u003ccode\u003eself\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIt looks already suspicious, but let‚Äôs try with a different example. What if, instead of functions, \u003ccode\u003edoSomething\u003c/code\u003e and \u003ccode\u003edoSomethingElse\u003c/code\u003e are closure properties of the class. Let‚Äôs adapt the code for a similar execution.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMyClass\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edoSomething\u003c/span\u003e: (() -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e)?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edoSomethingElse\u003c/span\u003e: (() -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e)?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edidSomething\u003c/span\u003e: \u003cspan\u003eBool\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edidSomethingElse\u003c/span\u003e: \u003cspan\u003eBool\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003edeinit\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;Deinit\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eprintCounter\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003eCFGetRetainCount\u003c/span\u003e(\u003cspan\u003eself\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoEverything\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;start\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003edoSomething\u003c/span\u003e = { [\u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e] \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e = \u003cspan\u003eself\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e { \u003cspan\u003ereturn\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edidSomething\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomethingElse\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edidSomethingElse\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something else\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003edoSomethingElse\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003edoSomething\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003edo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emodel\u003c/span\u003e = \u003cspan\u003eMyClass\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003emodel\u003c/span\u003e.\u003cspan\u003edoEverything\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere is the output\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"sh\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e# output\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003estart\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edid something\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edid something \u003cspan\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis time, the class is not even de-allocated ü§Ø. To fix it back, we have to keep a weak instance.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoEverything\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;start\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003edoSomething\u003c/span\u003e = { [\u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e] \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edidSomething\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edoSomethingElse\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edidSomethingElse\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something else\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edoSomethingElse\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003edoSomething\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprintCounter\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"sh\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e# output\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003estart\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edid something\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edid something \u003cspan\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eDeinit\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eYay, the instance is properly de-allocated this time. It‚Äôs confirmed, the \u003cem\u003einner\u003c/em\u003e closure was making a strong reference to \u003ccode\u003eguard let self\u003c/code\u003e.\u003c/p\u003e\n\u003chr/\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSo, what does it mean for my code?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWhen we face a closure, we tend to write \u003ccode\u003eweak self\u003c/code\u003e followed by a \u003ccode\u003eguard let\u003c/code\u003e to quickly go around without thinking too much about the execution further down. This is where we still need to be careful. It‚Äôs easy to miss this kind of memory leaks, so here are few takeaways:\u003c/p\u003e\n\u003cp\u003eFirst, regarding the format, I personally use \u003ccode\u003eguard let strongSelf\u003c/code\u003e in closure instead of \u003ccode\u003eguard let self\u003c/code\u003e. The reason is that during code review, it can be tricky to know which ‚Äúself‚Äù we are referring to further down in the code.\u003c/p\u003e\n\u003cp\u003eSecond, if there is nested closure, I would prefer keeping reference to the weak (and optional) \u003ccode\u003eself?\u003c/code\u003e and never point back to \u003ccode\u003estrongSelf\u003c/code\u003e, so I have the insurance to avoid any strong reference to it.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edoEverything\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003edoSomething\u003c/span\u003e = { [\u003cspan\u003eweak\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e] \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estrongSelf\u003c/span\u003e = \u003cspan\u003eself\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e { \u003cspan\u003ereturn\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003estrongSelf\u003c/span\u003e.\u003cspan\u003edidSomething\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003estrongSelf\u003c/span\u003e.\u003cspan\u003edoSomethingElse\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eself\u003c/span\u003e?.\u003cspan\u003edidSomethingElse\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;did something else\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003estrongSelf\u003c/span\u003e.\u003cspan\u003edoSomethingElse\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003edoSomething\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLast but not least, if we have too many closures to handles, the best is still to refactor it as a separate function, or use newer API to avoid those mistakes. I‚Äôm thinking about functional reactive programming like RxSwift or Combine, but also swift \u003ccode\u003eAsync\u003c/code\u003e to get by.\u003c/p\u003e\n\u003cp\u003eOf course, the code shared today might be a bit farfetched and might not reflect your daily usage of closures, but in my opinion, it‚Äôs still important to keep in mind the memory management and reference we make of our instances. Also, this question came right into the middle of a peer review, so we never too careful ;)\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eHope you enjoyed this post, happy coding!\u003c/em\u003e\u003c/p\u003e\n              \n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2022-04-02T01:00:00Z",
  "modifiedTime": "2022-04-02T01:00:00Z"
}
