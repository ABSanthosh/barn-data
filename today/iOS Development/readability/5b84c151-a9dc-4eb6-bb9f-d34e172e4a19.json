{
  "id": "5b84c151-a9dc-4eb6-bb9f-d34e172e4a19",
  "title": "Automatic Trait Tracking",
  "link": "https://useyourloaf.com/blog/automatic-trait-tracking/",
  "description": "In iOS 18, UIKit automatically tracks when you access a trait, removing the need to manually register for trait change notifications. Automatic Trait Tracking (iOS 18) In iOS 18, UIKit supports automatic trait tracking in layout update methods in views and view controllers. See the Apple documentation for the full list of supported methods. It includes UIView methods like layoutSubviews(), updatesConstraints(), and draw(CGRect). Supported UIViewController methods include viewWillLayoutSubviews(), updateViewConstraints(), and the updateConfiguration methods for buttons, collection and table view cells. Any time UIKit calls one of these methods it notes which traits you access in the method. Then when one of those traits changes it automatically invalidates the view using setNeedsLayout, setNeedsUpdateConstraints, setNeedsDisplay, or setNeedsUpdateConifguration, as appropriate. This removes the need to manually register for trait changes. For example, I have a UIView subclass that overrides draw(CGRect). My view draws a box, inside the view bounds. When the user chooses one of the accessibility sizes of dynamic type I want to increase the size of my box: final class SquareView: UIView { override func draw(_ rect: CGRect) { var scale = 0.3 if traitCollection.preferredContentSizeCategory.isAccessibilityCategory { scale = 0.6 } let width = bounds.width * scale let height = bounds.height * scale let startX = (bounds.width / 2) - (width / 2) let startY = (bounds.height / 2) - (height / 2) let path = UIBezierPath() path.move(to: CGPoint(x: startX, y: startY)) path.addLine(to: CGPoint(x: startX, y: startY + height)) path.addLine(to: CGPoint(x: startX + width, y: startY + height)) path.addLine(to: CGPoint(x: startX + width, y: startY)) path.addLine(to: CGPoint(x: startX, y: startY)) UIColor.blue.setStroke() UIColor.blue.setFill() path.stroke() path.fill() } } The draw(CGRect) method checks the preferredContentSizeCategory trait before drawning the box. Before iOS 18, I need to add the view initializers and register for content size category trait changes and then call setNeedsDisplay to trigger a new call to draw(CGRect): // pre-iOS 18 override init(frame: CGRect) { super.init(frame: frame) setupView() } required init?(coder: NSCoder) { super.init(coder: coder) setupView() } private func setupView() { registerForTraitChanges([ UITraitPreferredContentSizeCategory.self ], action: #selector(contentSizeChanged)) } @objc private func contentSizeChanged() { setNeedsDisplay() } In iOS 18, that’s no longer necessary. UIKit registers that I’m accessing the preferredContentSizeCategory trait in draw(CGRect) and automatically calls setNeedsDisplay anytime it changes. Learn More WWDC24 What’s new in UIKit Apple Documentation - Automatic trait tracking Registering For Trait Changes Automatic Trait Tracking was originally posted 11 Nov 2024 on useyourloaf.com. Want this direct to your inbox? Sign up and get my free WWDC viewing guide PDF.",
  "author": "",
  "published": "Mon, 11 Nov 2024 09:42:15 +0000",
  "source": "https://useyourloaf.com/blog/rss.xml",
  "categories": null,
  "byline": "",
  "length": 2976,
  "excerpt": "UIKit automatically tracks trait changes starting in iOS 18.",
  "siteName": "Use Your Loaf - iOS Development News \u0026 Tips",
  "favicon": "https://useyourloaf.com/apple-touch-icon.png",
  "text": "In iOS 18, UIKit automatically tracks when you access a trait, removing the need to manually register for trait change notifications. Automatic Trait Tracking (iOS 18) In iOS 18, UIKit supports automatic trait tracking in layout update methods in views and view controllers. See the Apple documentation for the full list of supported methods. It includes UIView methods like layoutSubviews(), updatesConstraints(), and draw(CGRect). Supported UIViewController methods include viewWillLayoutSubviews(), updateViewConstraints(), and the updateConfiguration methods for buttons, collection and table view cells. Any time UIKit calls one of these methods it notes which traits you access in the method. Then when one of those traits changes it automatically invalidates the view using setNeedsLayout, setNeedsUpdateConstraints, setNeedsDisplay, or setNeedsUpdateConifguration, as appropriate. This removes the need to manually register for trait changes. For example, I have a UIView subclass that overrides draw(CGRect). My view draws a box, inside the view bounds. When the user chooses one of the accessibility sizes of dynamic type I want to increase the size of my box: final class SquareView: UIView { override func draw(_ rect: CGRect) { var scale = 0.3 if traitCollection.preferredContentSizeCategory.isAccessibilityCategory { scale = 0.6 } let width = bounds.width * scale let height = bounds.height * scale let startX = (bounds.width / 2) - (width / 2) let startY = (bounds.height / 2) - (height / 2) let path = UIBezierPath() path.move(to: CGPoint(x: startX, y: startY)) path.addLine(to: CGPoint(x: startX, y: startY + height)) path.addLine(to: CGPoint(x: startX + width, y: startY + height)) path.addLine(to: CGPoint(x: startX + width, y: startY)) path.addLine(to: CGPoint(x: startX, y: startY)) UIColor.blue.setStroke() UIColor.blue.setFill() path.stroke() path.fill() } } The draw(CGRect) method checks the preferredContentSizeCategory trait before drawning the box. Before iOS 18, I need to add the view initializers and register for content size category trait changes and then call setNeedsDisplay to trigger a new call to draw(CGRect): // pre-iOS 18 override init(frame: CGRect) { super.init(frame: frame) setupView() } required init?(coder: NSCoder) { super.init(coder: coder) setupView() } private func setupView() { registerForTraitChanges([ UITraitPreferredContentSizeCategory.self ], action: #selector(contentSizeChanged)) } @objc private func contentSizeChanged() { setNeedsDisplay() } In iOS 18, that’s no longer necessary. UIKit registers that I’m accessing the preferredContentSizeCategory trait in draw(CGRect) and automatically calls setNeedsDisplay anytime it changes. Learn More WWDC24 What’s new in UIKit Apple Documentation - Automatic trait tracking Registering For Trait Changes",
  "image": "https://useyourloaf.com/blog/automatic-trait-tracking/cover.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eIn iOS 18, UIKit automatically tracks when you access a trait, removing the need to manually register for trait change notifications.\u003c/p\u003e\n\u003ch3 id=\"automatic-trait-tracking-ios-18\"\u003eAutomatic Trait Tracking (iOS 18)\u003c/h3\u003e\n\u003cp\u003eIn iOS 18, UIKit supports automatic trait tracking in layout update methods in views and view controllers. See the \u003ca href=\"https://developer.apple.com/documentation/uikit/app_and_environment/automatic_trait_tracking\"\u003eApple documentation\u003c/a\u003e for the full list of supported methods. It includes \u003ccode\u003eUIView\u003c/code\u003e methods like \u003ccode\u003elayoutSubviews()\u003c/code\u003e, \u003ccode\u003eupdatesConstraints()\u003c/code\u003e, and \u003ccode\u003edraw(CGRect)\u003c/code\u003e. Supported \u003ccode\u003eUIViewController\u003c/code\u003e methods include \u003ccode\u003eviewWillLayoutSubviews()\u003c/code\u003e, \u003ccode\u003eupdateViewConstraints()\u003c/code\u003e, and the \u003ccode\u003eupdateConfiguration\u003c/code\u003e methods for buttons, collection and table view cells.\u003c/p\u003e\n\u003cp\u003eAny time UIKit calls one of these methods it notes which traits you access in the method. Then when one of those traits changes it automatically invalidates the view using \u003ccode\u003esetNeedsLayout\u003c/code\u003e, \u003ccode\u003esetNeedsUpdateConstraints\u003c/code\u003e, \u003ccode\u003esetNeedsDisplay\u003c/code\u003e, or \u003ccode\u003esetNeedsUpdateConifguration\u003c/code\u003e, as appropriate. This removes the need to manually \u003ca href=\"https://useyourloaf.com/blog/registering-for-trait-changes/\"\u003eregister for trait changes\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFor example, I have a UIView subclass that overrides \u003ccode\u003edraw(CGRect)\u003c/code\u003e. My view draws a box, inside the view bounds. When the user chooses one of the accessibility sizes of dynamic type I want to increase the size of my box:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eSquareView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUIView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003edraw\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003escale\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0.3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003etraitCollection\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epreferredContentSizeCategory\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisAccessibilityCategory\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003escale\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0.6\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003escale\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003escale\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartX\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartY\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003epath\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eUIBezierPath\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emove\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartX\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartY\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartX\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartY\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartX\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartY\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartX\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartY\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartX\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartY\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eUIColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eblue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esetStroke\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eUIColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eblue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esetFill\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estroke\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efill\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe \u003ccode\u003edraw(CGRect)\u003c/code\u003e method checks the \u003ccode\u003epreferredContentSizeCategory\u003c/code\u003e trait before drawning the box. Before iOS 18, I need to add the view initializers and register for content size category trait changes and then call \u003ccode\u003esetNeedsDisplay\u003c/code\u003e to trigger a new call to \u003ccode\u003edraw(CGRect)\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// pre-iOS 18\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003esuper\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003esetupView\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003erequired\u003c/span\u003e \u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e?(\u003c/span\u003e\u003cspan\u003ecoder\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eNSCoder\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003esuper\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecoder\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecoder\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003esetupView\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esetupView\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eregisterForTraitChanges\u003c/span\u003e\u003cspan\u003e([\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eUITraitPreferredContentSizeCategory\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eaction\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e#selector\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtentSizeChanged\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e@objc\u003c/span\u003e \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003econtentSizeChanged\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003esetNeedsDisplay\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIn iOS 18, that’s no longer necessary. UIKit registers that I’m accessing the \u003ccode\u003epreferredContentSizeCategory\u003c/code\u003e trait in \u003ccode\u003edraw(CGRect)\u003c/code\u003e and automatically calls \u003ccode\u003esetNeedsDisplay\u003c/code\u003e anytime it changes.\u003c/p\u003e\n\u003ch3 id=\"learn-more\"\u003eLearn More\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.apple.com/videos/play/wwdc2024/10118?time=362\"\u003eWWDC24 What’s new in UIKit\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.apple.com/documentation/uikit/app_and_environment/automatic_trait_tracking\"\u003eApple Documentation - Automatic trait tracking\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://useyourloaf.com/blog/registering-for-trait-changes/\"\u003eRegistering For Trait Changes\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2024-11-11T09:42:15Z",
  "modifiedTime": "2024-11-11T15:10:41Z"
}
