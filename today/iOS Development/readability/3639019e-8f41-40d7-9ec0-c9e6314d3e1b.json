{
  "id": "3639019e-8f41-40d7-9ec0-c9e6314d3e1b",
  "title": "Cancellation can come in many forms",
  "link": "https://oleb.net/2022/cancellation-forms/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2022-01-31T18:20:07Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann …",
  "length": 1919,
  "excerpt": "By convention, functions should respond to cancellation by throwing a specfic error. But not all functions follow the convention.",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "In Swift’s concurrency model, cancellation is cooperative. To be a good concurrency citizen, code must periodically check if the current task has been cancelled, and react accordingly. You can check for cancellation by calling Task.isCancelled or with try Task.checkCancellation() — the latter will exit by throwing a CancellationError if the task has been cancelled. By convention, functions should react to cancellation by throwing a CancellationError. But this convention isn’t enforced, so callers must be aware that cancellation can manifest itself in other forms. Here are some other ways how functions might respond to cancellation: Throw a different error. For example, the async networking APIs in Foundation, such as URLSession.data(from: URL), throw a URLError with the code URLError.Code.cancelled on cancellation. It’d be nice if URLSession translated this error to CancellationError, but it doesn’t. Return a partial result. A function that has completed part of its work when cancellation occurs may choose to return a partial result rather than throwing the work away and aborting. In fact, this may be the best choice for a non-throwing function. But note that this behavior can be extremely surprising to callers, so be sure to document it clearly. Do nothing. Functions are supposed to react promptly to cancellation, but callers must assume the worst. Even if cancelled, a function might run to completion and finish normally. Or it might eventually respond to cancellation by aborting, but not promptly because it doesn’t perform its cancellation checks often enough. So as the caller of a function, you can’t really rely on specific cancellation behavior unless you know how the callee is implemented. Code that wants to know if its task has been cancelled should itself call Task.isCancelled, rather than counting on catching a CancellationError from a callee.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003eIn Swift’s concurrency model, \u003cstrong\u003ecancellation is cooperative\u003c/strong\u003e. To be a good concurrency citizen, code must periodically check if the current task has been cancelled, and react accordingly.\u003c/p\u003e\n\n\u003cp\u003eYou can check for cancellation by calling \u003ca href=\"https://developer.apple.com/documentation/swift/task/3814832-iscancelled\"\u003e\u003ccode\u003eTask.isCancelled\u003c/code\u003e\u003c/a\u003e or with \u003ca href=\"https://developer.apple.com/documentation/swift/task/3814826-checkcancellation\"\u003e\u003ccode\u003etry Task.checkCancellation()\u003c/code\u003e\u003c/a\u003e — the latter will exit by throwing a \u003ca href=\"https://developer.apple.com/documentation/swift/cancellationerror\"\u003e\u003ccode\u003eCancellationError\u003c/code\u003e\u003c/a\u003e if the task has been cancelled.\u003c/p\u003e\n\n\u003cp\u003eBy convention, \u003cstrong\u003efunctions should react to cancellation by throwing a \u003ccode\u003eCancellationError\u003c/code\u003e\u003c/strong\u003e. But this convention isn’t enforced, so callers must be aware that cancellation can manifest itself in other forms. Here are some other ways how functions might respond to cancellation:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eThrow a different error.\u003c/strong\u003e For example, the async networking APIs in Foundation, such as \u003ca href=\"https://developer.apple.com/documentation/foundation/urlsession/3767353-data\"\u003e\u003ccode\u003eURLSession.data(from: URL)\u003c/code\u003e\u003c/a\u003e, throw a \u003ca href=\"https://developer.apple.com/documentation/foundation/urlerror\"\u003e\u003ccode\u003eURLError\u003c/code\u003e\u003c/a\u003e with the code \u003ca href=\"https://developer.apple.com/documentation/foundation/urlerror/2293052-cancelled\"\u003e\u003ccode\u003eURLError.Code.cancelled\u003c/code\u003e\u003c/a\u003e on cancellation. It’d be nice if \u003ccode\u003eURLSession\u003c/code\u003e translated this error to \u003ccode\u003eCancellationError\u003c/code\u003e, but it doesn’t.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eReturn a partial result.\u003c/strong\u003e A function that has completed part of its work when cancellation occurs may choose to return a partial result rather than throwing the work away and aborting. In fact, this may be the best choice for a non-throwing function. But note that this behavior can be extremely surprising to callers, so be sure to document it clearly.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eDo nothing.\u003c/strong\u003e Functions are supposed to react promptly to cancellation, but callers must assume the worst. Even if cancelled, a function might run to completion and finish normally. Or it might eventually respond to cancellation by aborting, but not promptly because it doesn’t perform its cancellation checks often enough.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eSo as the caller of a function, you can’t really rely on specific cancellation behavior unless you know how the callee is implemented. Code that wants to know if its task has been cancelled should itself call \u003ccode\u003eTask.isCancelled\u003c/code\u003e, rather than counting on catching a \u003ccode\u003eCancellationError\u003c/code\u003e from a callee.\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2022-01-31T18:20:07Z",
  "modifiedTime": "2022-01-31T18:20:07Z"
}
