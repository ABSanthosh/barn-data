{
  "id": "27e424f5-f7d3-4f9b-8507-11a036f637ae",
  "title": "Working with percentages in SwiftUI layout",
  "link": "https://oleb.net/2023/swiftui-relative-size/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2023-03-23T22:31:11Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann …",
  "length": 9347,
  "excerpt": "A SwiftUI layout and view modifier for relative sizing. “Make this view 50 % of the width of its container”.",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "SwiftUI’s layout primitives generally don’t provide relative sizing options, e.g. “make this view 50 % of the width of its container”. Let’s build our own! Use case: chat bubbles Consider this chat conversation view as an example of what I want to build. The chat bubbles always remain 80 % as wide as their container as the view is resized: The chat bubbles should become 80 % as wide as their container. Download video Building a proportional sizing modifier 1. The Layout We can build our own relative sizing modifier on top of the Layout protocol. The layout multiplies its own proposed size (which it receives from its parent view) with the given factors for width and height. It then proposes this modified size to its only subview. Here’s the implementation (the full code, including the demo app, is on GitHub): /// A custom layout that proposes a percentage of its /// received proposed size to its subview. /// /// - Precondition: must contain exactly one subview. fileprivate struct RelativeSizeLayout: Layout { var relativeWidth: Double var relativeHeight: Double func sizeThatFits( proposal: ProposedViewSize, subviews: Subviews, cache: inout () ) -\u003e CGSize { assert(subviews.count == 1, \"expects a single subview\") let resizedProposal = ProposedViewSize( width: proposal.width.map { $0 * relativeWidth }, height: proposal.height.map { $0 * relativeHeight } ) return subviews[0].sizeThatFits(resizedProposal) } func placeSubviews( in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout () ) { assert(subviews.count == 1, \"expects a single subview\") let resizedProposal = ProposedViewSize( width: proposal.width.map { $0 * relativeWidth }, height: proposal.height.map { $0 * relativeHeight } ) subviews[0].place( at: CGPoint(x: bounds.midX, y: bounds.midY), anchor: .center, proposal: resizedProposal ) } } Notes: I made the type private because I want to control how it can be used. This is important for maintaining the assumption that the layout only ever has a single subview (which makes the math much simpler). Proposed sizes in SwiftUI can be nil or infinity in either dimension. Our layout passes these special values through unchanged (infinity times a percentage is still infinity). I’ll discuss below what implications this has for users of the layout. 2. The View extension Next, we’ll add an extension on View that uses the layout we just wrote. This becomes our public API: extension View { /// Proposes a percentage of its received proposed size to `self`. public func relativeProposed(width: Double = 1, height: Double = 1) -\u003e some View { RelativeSizeLayout(relativeWidth: width, relativeHeight: height) { // Wrap content view in a container to make sure the layout only // receives a single subview. Because views are lists! VStack { // alternatively: `_UnaryViewAdaptor(self)` self } } } } Notes: I decided to go with a verbose name, relativeProposed(width:height:), to make the semantics clear: we’re changing the proposed size for the subview, which won’t always result in a different actual size. More on this below. We’re wrapping the subview (self in the code above) in a VStack. This might seem redundant, but it’s necessary to make sure the layout only receives a single element in its subviews collection. See Chris Eidhof’s SwiftUI Views are Lists for an explanation. Usage The layout code for a single chat bubble in the demo video above looks like this: let alignment: Alignment = message.sender == .me ? .trailing : .leading chatBubble .relativeProposed(width: 0.8) .frame(maxWidth: .infinity, alignment: alignment) The outermost flexible frame with maxWidth: .infinity is responsible for positioning the chat bubble with leading or trailing alignment, depending on who’s speaking. You can even add another frame that limits the width to a maximum, say 400 points: let alignment: Alignment = message.sender == .me ? .trailing : .leading chatBubble .frame(maxWidth: 400) .relativeProposed(width: 0.8) .frame(maxWidth: .infinity, alignment: alignment) Here, our relative sizing modifier only has an effect as the bubbles become narrower than 400 points. In a wider window the width-limiting frame takes precedence. I like how composable this is! Download video 80 % won’t always result in 80 % If you watch the debugging guides I’m drawing in the video above, you’ll notice that the relative sizing modifier never reports a width greater than 400, even if the window is wide enough: The relative sizing modifier accepts the actual size of its subview as its own size. This is because our layout only adjusts the proposed size for its subview but then accepts the subview’s actual size as its own. Since SwiftUI views always choose their own size (which the parent can’t override), the subview is free to ignore our proposal. In this example, the layout’s subview is the frame(maxWidth: 400) view, which sets its own width to the proposed width or 400, whichever is smaller. Understanding the modifier’s behavior Proposed size ≠ actual size It’s important to internalize that the modifier works on the basis of proposed sizes. This means it depends on the cooperation of its subview to achieve its goal: views that ignore their proposed size will be unaffected by our modifier. I don’t find this particularly problematic because SwiftUI’s entire layout system works like this. Ultimately, SwiftUI views always determine their own size, so you can’t write a modifier that “does the right thing” (whatever that is) for an arbitrary subview hierarchy. nil and infinity I already mentioned another thing to be aware of: if the parent of the relative sizing modifier proposes nil or .infinity, the modifier will pass the proposal through unchanged. Again, I don’t think this is particularly bad, but it’s something to be aware of. Proposing nil is SwiftUI’s way of telling a view to become its ideal size (fixedSize does this). Would you ever want to tell a view to become, say, 50 % of its ideal width? I’m not sure. Maybe it’d make sense for resizable images and similar views. By the way, you could modify the layout to do something like this: If the proposal is nil or infinity, forward it to the subview unchanged. Take the reported size of the subview as the new basis and apply the scaling factors to that size (this still breaks down if the child returns infinity). Now propose the scaled size to the subview. The subview might respond with a different actual size. Return this latest reported size as your own size. This process of sending multiple proposals to child views is called probing. Lots of built-in containers views do this too, e.g. VStack and HStack. Nesting in other container views The relative sizing modifier interacts in an interesting way with stack views and other containers that distribute the available space among their children. I thought this was such an interesting topic that I wrote a separate article about it: How the relative size modifier interacts with stack views. The code The complete code is available in a Gist on GitHub. Digression: Proportional sizing in early SwiftUI betas The very first SwiftUI betas in 2019 did include proportional sizing modifiers, but they were taken out before the final release. Chris Eidhof preserved a copy of SwiftUI’s “header file” from that time that shows their API, including quite lengthy documentation. I don’t know why these modifiers didn’t survive the beta phase. The release notes from 2019 don’t give a reason: The relativeWidth(_:), relativeHeight(_:), and relativeSize(width:height:) modifiers are deprecated. Use other modifiers like frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:) instead. (51494692) I also don’t remember how these modifiers worked. They probably had somewhat similar semantics to my solution, but I can’t be sure. The doc comments linked above sound straightforward (“Sets the width of this view to the specified proportion of its parent’s width.”), but they don’t mention the intricacies of the layout algorithm (proposals and responses) at all. containerRelativeFrame Update May 1, 2024: Apple introduced the containerRelativeFrame modifier for its 2023 OSes (iOS 17/macOS 14). If your deployment target permits it, this can be a good, built-in alternative. Note that containerRelativeFrame behaves differently than my relativeProposed modifier as it computes the size relative to the nearest container view, whereas my modifier uses its proposed size as the reference. The SwiftUI documentation somewhat vaguely lists the views that count as a container for containerRelativeFrame. Notably, stack views don’t count! Check out Jordan Morgan’s article Modifier Monday: .containerRelativeFrame(_ axes:) (2022-06-26) to learn more about containerRelativeFrame.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003eSwiftUI’s layout primitives generally don’t provide \u003cem\u003erelative\u003c/em\u003e sizing options, e.g. “make this view 50 % of the width of its container”. Let’s build our own!\u003c/p\u003e\n\n\u003ch2 id=\"use-case-chat-bubbles\"\u003eUse case: chat bubbles\u003c/h2\u003e\n\n\u003cp\u003eConsider this chat conversation view as an example of what I want to build. The chat bubbles always remain 80 % as wide as their container as the view is resized:\u003c/p\u003e\n\n\u003cp\u003e\n\u003cfigure\u003e\n  \u003cvideo controls=\"\" width=\"844\"\u003e\n    \u003csource src=\"https://oleb.net/media/2023-03-23-SwiftUI-relativeWidth-demo-1.mp4\" type=\"video/mp4\"/\u003e\n  \u003c/video\u003e\n  \u003cfigcaption\u003e\n    The chat bubbles should become 80 % as wide as their container. \u003ca href=\"https://oleb.net/media/2023-03-23-SwiftUI-relativeWidth-demo-1.mp4\"\u003eDownload video\u003c/a\u003e\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/p\u003e\n\n\u003ch2 id=\"building-a-proportional-sizing-modifier\"\u003eBuilding a proportional sizing modifier\u003c/h2\u003e\n\n\u003ch3 id=\"the-layout\"\u003e1. The Layout\u003c/h3\u003e\n\n\u003cp\u003eWe can build our own relative sizing modifier on top of the \u003ca href=\"https://developer.apple.com/documentation/swiftui/layout\"\u003e\u003ccode\u003eLayout\u003c/code\u003e\u003c/a\u003e protocol. The layout multiplies its own proposed size (which it receives from its parent view) with the given factors for width and height. It then proposes this modified size to its only subview. Here’s the implementation (\u003ca href=\"https://gist.github.com/ole/7577deed8081ef6294f761704cff8a1d\"\u003ethe full code, including the demo app, is on GitHub\u003c/a\u003e):\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e/// A custom layout that proposes a percentage of its\u003c/span\u003e\n\u003cspan\u003e/// received proposed size to its subview.\u003c/span\u003e\n\u003cspan\u003e///\u003c/span\u003e\n\u003cspan\u003e/// - Precondition: must contain exactly one subview.\u003c/span\u003e\n\u003cspan\u003efileprivate\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eRelativeSizeLayout\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eLayout\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003erelativeWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003erelativeHeight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\n\n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esizeThatFits\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n        \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n        \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSubviews\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n        \u003cspan\u003ecache\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eassert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;expects a single subview\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eresizedProposal\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n            \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e$0\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003erelativeWidth\u003c/span\u003e \u003cspan\u003e},\u003c/span\u003e\n            \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e$0\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003erelativeHeight\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esizeThatFits\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eresizedProposal\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eplaceSubviews\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n        \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n        \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n        \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSubviews\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n        \u003cspan\u003ecache\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eassert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;expects a single subview\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eresizedProposal\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n            \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e$0\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003erelativeWidth\u003c/span\u003e \u003cspan\u003e},\u003c/span\u003e\n            \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e$0\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003erelativeHeight\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eplace\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n            \u003cspan\u003eat\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emidX\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emidY\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \n            \u003cspan\u003eanchor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n            \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eresizedProposal\u003c/span\u003e\n        \u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNotes:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eI made the type private because I want to control how it can be used. This is important for maintaining the assumption that the layout only ever has a single subview (which makes the math much simpler).\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ca href=\"https://developer.apple.com/documentation/swiftui/proposedviewsize\"\u003eProposed sizes\u003c/a\u003e in SwiftUI can be \u003ccode\u003enil\u003c/code\u003e or infinity in either dimension. Our layout passes these special values through unchanged (infinity times a percentage is still infinity). I’ll discuss below what implications this has for users of the layout.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"the-view-extension\"\u003e2. The View extension\u003c/h3\u003e\n\n\u003cp\u003eNext, we’ll add an extension on \u003ca href=\"https://developer.apple.com/documentation/swiftui/view\"\u003e\u003ccode\u003eView\u003c/code\u003e\u003c/a\u003e that uses the layout we just wrote. This becomes our public API:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e/// Proposes a percentage of its received proposed size to `self`.\u003c/span\u003e\n    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003erelativeProposed\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eRelativeSizeLayout\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erelativeWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erelativeHeight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003e// Wrap content view in a container to make sure the layout only\u003c/span\u003e\n            \u003cspan\u003e// receives a single subview. Because views are lists!\u003c/span\u003e\n            \u003cspan\u003eVStack\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e// alternatively: `_UnaryViewAdaptor(self)`\u003c/span\u003e\n                \u003cspan\u003eself\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNotes:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eI decided to go with a verbose name, \u003ccode\u003erelativeProposed(width:height:)\u003c/code\u003e, to make the semantics clear: we’re changing the \u003cem\u003eproposed\u003c/em\u003e size for the subview, which won’t always result in a different actual size. More on this below.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eWe’re wrapping the subview (\u003ccode\u003eself\u003c/code\u003e in the code above) in a \u003ca href=\"https://developer.apple.com/documentation/swiftui/vstack\"\u003e\u003ccode\u003eVStack\u003c/code\u003e\u003c/a\u003e. This might seem redundant, but it’s necessary to make sure the layout only receives a single element in its subviews collection. See Chris Eidhof’s \u003ca href=\"https://chris.eidhof.nl/post/swiftui-views-are-lists/\"\u003eSwiftUI Views are Lists\u003c/a\u003e for an explanation.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"usage\"\u003eUsage\u003c/h2\u003e\n\n\u003cp\u003eThe layout code for a single chat bubble in the demo video above looks like this:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ealignment\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAlignment\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esender\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eme\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etrailing\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eleading\u003c/span\u003e\n\u003cspan\u003echatBubble\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erelativeProposed\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0.8\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emaxWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einfinity\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ealignment\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ealignment\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe outermost flexible frame with \u003ccode\u003emaxWidth: .infinity\u003c/code\u003e is responsible for positioning the chat bubble with leading or trailing alignment, depending on who’s speaking.\u003c/p\u003e\n\n\u003cp\u003eYou can even add another frame that limits the width to a maximum, say 400 points:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ealignment\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAlignment\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esender\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eme\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etrailing\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eleading\u003c/span\u003e\n\u003cspan\u003echatBubble\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emaxWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e400\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erelativeProposed\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0.8\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emaxWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einfinity\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ealignment\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ealignment\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eHere, our relative sizing modifier only has an effect as the bubbles become narrower than 400 points. In a wider window the width-limiting frame takes precedence. I like how composable this is!\u003c/p\u003e\n\n\u003cp\u003e\n\u003cfigure\u003e\n  \u003cvideo controls=\"\" width=\"844\"\u003e\n    \u003csource src=\"https://oleb.net/media/2023-03-23-SwiftUI-relativeWidth-demo-2.mp4\" type=\"video/mp4\"/\u003e\n  \u003c/video\u003e\n  \u003cfigcaption\u003e\n    \u003ca href=\"https://oleb.net/media/2023-03-23-SwiftUI-relativeWidth-demo-2.mp4\"\u003eDownload video\u003c/a\u003e\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/p\u003e\n\n\u003ch3 id=\"wont-always-result-in-80\"\u003e80 % won’t always result in 80 %\u003c/h3\u003e\n\n\u003cp\u003eIf you watch the debugging guides I’m drawing in the video above, you’ll notice that the relative sizing modifier never reports a width greater than 400, even if the window is wide enough:\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cfigure\u003e\n    \u003ca href=\"https://oleb.net/media/2023-03-23-SwiftUI-relativeWidth-and-maxWidth-1688px.png\"\u003e\n    \u003cimg src=\"https://oleb.net/media/2023-03-23-SwiftUI-relativeWidth-and-maxWidth-1688px.png\" alt=\"A Mac window showing a mockup of a chat conversation with bubbles for the speakers. Overlaid on the chat bubbles are debugging views showing the widths of different components. The total container width is 753. The relW=80% debugging guide shows a width of 400.\"/\u003e\n    \u003c/a\u003e\n    \u003cfigcaption\u003e\n        The relative sizing modifier accepts the actual size of its subview as its own size.\n    \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003cp\u003eThis is because our layout only adjusts the \u003cem\u003eproposed\u003c/em\u003e size for its subview but then accepts the subview’s \u003cem\u003eactual\u003c/em\u003e size as its own. Since SwiftUI views always choose their own size (which the parent can’t override), the subview is free to ignore our proposal. In this example, the layout’s subview is the \u003ccode\u003eframe(maxWidth: 400)\u003c/code\u003e view, which sets its own width to the proposed width or 400, whichever is smaller.\u003c/p\u003e\n\n\u003ch2 id=\"understanding-the-modifiers-behavior\"\u003eUnderstanding the modifier’s behavior\u003c/h2\u003e\n\n\u003ch3 id=\"proposed-size--actual-size\"\u003eProposed size ≠ actual size\u003c/h3\u003e\n\n\u003cp\u003eIt’s important to internalize that the modifier works on the basis of proposed sizes. This means it depends on the cooperation of its subview to achieve its goal: views that ignore their proposed size will be unaffected by our modifier. I don’t find this particularly problematic because SwiftUI’s entire layout system works like this. Ultimately, SwiftUI views always determine their own size, so you can’t write a modifier that “does the right thing” (whatever that is) for an arbitrary subview hierarchy.\u003c/p\u003e\n\n\u003ch3 id=\"nil-and-infinity\"\u003e\u003ccode\u003enil\u003c/code\u003e and infinity\u003c/h3\u003e\n\n\u003cp\u003eI already mentioned another thing to be aware of: if the parent of the relative sizing modifier proposes \u003ccode\u003enil\u003c/code\u003e or \u003ccode\u003e.infinity\u003c/code\u003e, the modifier will pass the proposal through unchanged. Again, I don’t think this is particularly bad, but it’s something to be aware of.\u003c/p\u003e\n\n\u003cp\u003eProposing \u003ccode\u003enil\u003c/code\u003e is SwiftUI’s way of telling a view to become its ideal size (\u003ca href=\"https://developer.apple.com/documentation/swiftui/view/fixedsize(horizontal:vertical:)\"\u003e\u003ccode\u003efixedSize\u003c/code\u003e\u003c/a\u003e does this). Would you ever want to tell a view to become, say, 50 % of its ideal width? I’m not sure. Maybe it’d make sense for resizable images and similar views.\u003c/p\u003e\n\n\u003cp\u003eBy the way, you could modify the layout to do something like this:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eIf the proposal is \u003ccode\u003enil\u003c/code\u003e or infinity, forward it to the subview unchanged.\u003c/li\u003e\n  \u003cli\u003eTake the reported size of the subview as the new basis and apply the scaling factors to that size (this still breaks down if the child returns infinity).\u003c/li\u003e\n  \u003cli\u003eNow propose the scaled size to the subview. The subview might respond with a different actual size.\u003c/li\u003e\n  \u003cli\u003eReturn this latest reported size as your own size.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThis process of sending multiple proposals to child views is called \u003cem\u003eprobing\u003c/em\u003e. Lots of built-in containers views do this too, e.g. \u003ccode\u003eVStack\u003c/code\u003e and \u003ccode\u003eHStack\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3 id=\"nesting-in-other-container-views\"\u003eNesting in other container views\u003c/h3\u003e\n\n\u003cp\u003eThe relative sizing modifier interacts in an interesting way with stack views and other containers that distribute the available space among their children. I thought this was such an interesting topic that I wrote a separate article about it: \u003ca href=\"https://oleb.net/2023/swiftui-relative-size-in-stacks/\"\u003eHow the relative size modifier interacts with stack views\u003c/a\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cfigure\u003e\n    \u003ca href=\"https://oleb.net/media/2023-03-24-SwiftUI-relative-sizing-HStack-1-1294px.png\"\u003e\n    \u003cimg src=\"https://oleb.net/media/2023-03-24-SwiftUI-relative-sizing-HStack-1-1294px.png\" alt=\"A blue, a green, and a yellow rectangle in a horizontal line. The blue rectangle is 100 units wide, the other two 250 units each.\"/\u003e\n    \u003c/a\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"the-code\"\u003eThe code\u003c/h2\u003e\n\n\u003cp\u003eThe complete code is available \u003ca href=\"https://gist.github.com/ole/7577deed8081ef6294f761704cff8a1d\"\u003ein a Gist on GitHub\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"digression-proportional-sizing-in-early-swiftui-betas\"\u003eDigression: Proportional sizing in early SwiftUI betas\u003c/h2\u003e\n\n\u003cp\u003eThe very first SwiftUI betas in 2019 \u003cem\u003edid\u003c/em\u003e include proportional sizing modifiers, but they were taken out before the final release. \u003ca href=\"https://chris.eidhof.nl/\"\u003eChris Eidhof\u003c/a\u003e preserved \u003ca href=\"https://gist.github.com/chriseidhof/b770a50641e3c430112bc404ca430b82#file-swiftui-swift-L8257\"\u003ea copy of SwiftUI’s “header file” from that time\u003c/a\u003e that shows their API, including quite lengthy documentation.\u003c/p\u003e\n\n\u003cp\u003eI don’t know why these modifiers didn’t survive the beta phase. \u003ca href=\"https://developer.apple.com/documentation/ios-ipados-release-notes/ios-13-release-notes#SwiftUI\"\u003eThe release notes from 2019\u003c/a\u003e don’t give a reason:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eThe \u003ccode\u003erelativeWidth(_:)\u003c/code\u003e, \u003ccode\u003erelativeHeight(_:)\u003c/code\u003e, and \u003ccode\u003erelativeSize(width:height:)\u003c/code\u003e modifiers are deprecated. Use other modifiers like \u003ca href=\"https://developer.apple.com/documentation/SwiftUI/View/frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:)\"\u003e\u003ccode\u003eframe(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:)\u003c/code\u003e\u003c/a\u003e instead. (51494692)\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eI also don’t remember how these modifiers worked. They probably had somewhat similar semantics to my solution, but I can’t be sure. The doc comments linked above sound straightforward (“Sets the width of this view to the specified proportion of its parent’s width.”), but they don’t mention the intricacies of the layout algorithm (proposals and responses) at all.\u003c/p\u003e\n\n\u003ch2 id=\"containerrelativeframe\"\u003econtainerRelativeFrame\u003c/h2\u003e\n\n\u003cdiv id=\"update-containerRelativeFrame\"\u003e\n  \u003cp\u003e\u003cstrong\u003eUpdate May 1, 2024:\u003c/strong\u003e Apple introduced the \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/containerrelativeframe(_:alignment:_:)\"\u003e\u003ccode\u003econtainerRelativeFrame\u003c/code\u003e\u003c/a\u003e modifier for its 2023 OSes (iOS 17/macOS 14). If your deployment target permits it, this can be a good, built-in alternative.\u003c/p\u003e\n\n  \u003cp\u003eNote that \u003ccode\u003econtainerRelativeFrame\u003c/code\u003e behaves differently than my \u003ccode\u003erelativeProposed\u003c/code\u003e modifier as it computes the size relative to the nearest \u003cem\u003econtainer\u003c/em\u003e view, whereas my modifier uses its proposed size as the reference. The SwiftUI documentation somewhat vaguely lists the views that count as a container for \u003ccode\u003econtainerRelativeFrame\u003c/code\u003e. Notably, stack views don’t count!\u003c/p\u003e\n\n  \u003cp\u003eCheck out Jordan Morgan’s article \u003ca href=\"https://www.swiftjectivec.com/swiftui-modifier-monday-container-relative-frame/\"\u003eModifier Monday: .containerRelativeFrame(_ axes:)\u003c/a\u003e (2022-06-26) to learn more about \u003ccode\u003econtainerRelativeFrame\u003c/code\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2023-03-23T22:31:11Z",
  "modifiedTime": "2024-05-01T17:14:31Z"
}
