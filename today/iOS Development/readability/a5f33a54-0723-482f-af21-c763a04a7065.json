{
  "id": "a5f33a54-0723-482f-af21-c763a04a7065",
  "title": "Backing up Core Data Stores",
  "link": "https://atomicbird.com/blog/core-data-back-up-store/",
  "description": "Today we’re going to travel back in time a little with Core Data. Or at least find out how your app can do so. What if you want to make a backup copy of your app’s data? What if you want to restore from that backup later on? This won’t be mainly about data safety, because your app’s data will be getting backed up to the user’s iCloud account and, maybe, their Mac.",
  "author": "",
  "published": "Tue, 26 May 2020 00:00:00 +0000",
  "source": "https://atomicbird.com/index.xml",
  "categories": null,
  "byline": "",
  "length": 10569,
  "excerpt": "Today we’re going to travel back in time a little with Core Data. Or at least find out how your app can do so. What if you want to make a backup copy of your app’s data? What if you want to restore from that backup later on? This won’t be mainly about data safety, because your app’s data will be getting backed up to the user’s iCloud account and, maybe, their Mac.",
  "siteName": "Title",
  "favicon": "https://atomicbird.com/apple-touch-icon-144-precomposed.png",
  "text": "Today we’re going to travel back in time a little with Core Data. Or at least find out how your app can do so. What if you want to make a backup copy of your app’s data? What if you want to restore from that backup later on? This won’t be mainly about data safety, because your app’s data will be getting backed up to the user’s iCloud account and, maybe, their Mac. But you might have an app that, for whatever reason, needs to be able to revert to an older version of its data. It’s just files, right? Core Data is a file-based persistent store, so it might seem like a good idea to just copy files around. Head over to the FileManager documentation, figure out where the persistent store is located (hint: if you’re not sure, you can use the NSPersistentStoreDescription), and hey, you’re done. In a very simple case, that might work. But, hey, make sure you also copy the journal files. Both of them. And oh, did you turn on “allows external binary storage” anywhere in your data model? Better copy the external binary files too. Also, the location of those files is undocumented. If you figure it out, it probably won’t change, but you can’t be sure. There might be other extra things to think about in the next version of iOS, who knows? And of course, dont forget the possibility that not everything has been flushed from memory to the files when you copy them. It probably has been, of course. Probably. Fortunately Core Data has a built-in mechanism for this exact purpose. Rather than know every little detail of copying the files, you can ask Core Data to copy whatever’s needed. Migrate the Data Store! No, not that kind of migration. With Core Data, data migration usually refers to changing your data model and migrating a persistent store to the new model. That’s not what I’m talking about here, but the function naming is a little confusing. There’s a method on NSPersistentStoreCoordinator which unfortunately has a name that makes it sound like it’s related to model migration. The migratePersistentStore(_:to:options:withType:) method actually does something completely different. It’s been around approximately forever but doesn’t seem to be well understood, if discussions on Stack Overflow and in developer Slack teams is any indication. You can use this method to make a new copy of a persistent store at a new location, which is conveniently the exact thing you need to make a backup copy. (It also lets you change the type of persistent store, but I’ll ignore that since it’s not relevant here). The basic way to use it is Load a persistent store. Choose a new location for the store. Use this method to write a copy of the store at the new location. It’s almost that simple. Except for one warning included in the documentation: Important After invocation of this method, the specified store is removed from the coordinator thus store is no longer a useful reference. This is a little scary. Once you use this method, the persistent store you migrated is removed from the persistent store coordinator. It also adds the newly-migrated store to the coordinator. So now the store is using the new copy instead of the old one. That’s not good for a backup, since the new copy is the backup you just made that you want to leave alone. It’s also a potential app crasher, since any managed objects you already fetched came from a persistent store that’s no longer available. We can deal with that. But first, to clear up a point of confusion for some. The existing persistent store is removed only from the persistent store coordinator. The actual persistent store files don’t get removed, and all their data is intact. We can make a backup safely by modifying the steps above slightly. Load a persistent store. Create a secondary persistent store coordinator and load the store again. Choose a new location for the store. Use this function on the secondary coordinator to write a copy of the store at the new location. This leaves the existing Core Data stack intact, so the app keeps working with its existing persistent store. The secondary persistent store coordinator makes the backup copy. When the copy finishes, the backup copy is loaded in the secondary coordinator. But we won’t use that coordinator any more, so it doesn’t matter. One possible implementation of this can be found in the copyPersistentStores function at this Gist. The core of it is let temporaryPSC = NSPersistentStoreCoordinator(managedObjectModel: persistentStoreCoordinator.managedObjectModel) let destinationStoreURL = destinationURL.appendingPathComponent(storeURL.lastPathComponent) do { let newStore = try temporaryPSC.addPersistentStore(ofType: persistentStoreDescription.type, configurationName: persistentStoreDescription.configuration, at: persistentStoreDescription.url, options: persistentStoreDescription.options) let _ = try temporaryPSC.migratePersistentStore(newStore, to: destinationStoreURL, options: persistentStoreDescription.options, withType: persistentStoreDescription.type) } catch { // ... } This takes an existing, loaded persistent store, and creates a copy in a new directory with the same file name, options, and type. I wrote this as an extension on NSPersistentContainer since it’s where recent apps load their persistent stores. One extremely handy thing about this is that if the destination backup store already exists, it gets updated in place. It’s not necessary to remove the old backup first. Unless you want to offer multiple backups, you can back up to the same destination over and over and it’s fine. I Want My Data Back That’s good, but what about restoring from the backup? This can be a little tricky to get right. Restoring the persistent store isn’t hard. Restoring and not crashing your app can be harder, because now you’re replacing the data store for a live Core Data stack. You’re replacing the lowest level of the stack and trying to prevent the whole thing from falling over. If you restore a backup, you replace the loaded store. Your app has probably loaded some data from its persistent store. Any managed objects in memory are now the app equivalent of a land mine. If you don’t touch them, nothing bad happens, but if you do, well, bad things happen. We can use the same method to restore a persistent store as we did when backing it up. Migration can go either way, so restoring is a migration from the backup copy to the live copy. But remember what I said earlier about how the migration destination gets updated in place? That happens here too. If the primary store exists during restoration, you could end up duplicating data. That would be bad. The full series of steps to restore is Make sure you can avoid using any existing managed objects. Remove the persistent store from memory. (This is the part that causes in-memory land mines if you weren’t careful). Destroy the main persistent store. I’m saying “destroy” because the function is literally named destroyPersistentStore(at:ofType:options:). This removes current data, making room for the restore. Load the backup store at its current location. For the moment the app will be using that persistent store, but not for long. Migrate the backup store to the primary store location. This will remove the backup store from memory and add the newly migrated primary store. An implementation of this can be found in the restorePersistentStores function at that same Gist. One difference from the backup process is that a temporary persistent store coordinator isn’t necessary. For a restore, the migration destination is the one we want to use, so we don’t need to set up a separate coordinator. Step 1 can be the hardest part of the whole process, and the details depend completely on your app. Any managed objects that were fetched before restoring, or anything that has a reference to one of them, needs to be out of memory. You can then redo any fetches and update your UI. If your app is really simple, you might only need to do this after restoring: do { try self.fetchedResultsController.performFetch() } catch { print(\"Perform fetch error: \\(error)\") } tableView.reloadData() But most apps will need more, and what works for one app won’t be right for another. You might need to design the restore-from-backup UI to be completely separate from the rest of the app so that you can completely unload any existing in-memory data that might be a problem. Steps 2-5 above look something like this (see the gist for the full version): do { // Remove the existing persistent store first try persistentStoreCoordinator.remove(persistentStore) // Clear out the existing persistent store so that we'll have a // clean slate for restoring. try persistentStoreCoordinator.destroyPersistentStore(at: loadedStoreURL, ofType: persistentStore.type, options: persistentStore.options) // Add the backup store at its current location let backupStore = try persistentStoreCoordinator.addPersistentStore(ofType: persistentStore.type, configurationName: persistentStore.configurationName, at: backupStoreURL, options: persistentStore.options) // Migrate the backup store to the non-backup location. This leaves // the backup copy in place in case it's needed in the future, but // backupStore won't be useful anymore. let _ = try persistentStoreCoordinator.migratePersistentStore(backupStore, to: loadedStoreURL, options: persistentStore.options, withType: persistentStore.type) } catch { // ... } When this finishes, the main persistent store has been replaced by a copy of the backup store. The backup is still there, but the Core Data stack is using the restored copy. Other possibilities This all assumes you want just one backup which you might later restore. If you wanted multiple backups, you would need to add some way to separate the backups and tag them with whatever relevant details distinguish one from another. If it’s only the date, one way would be to use different backup destination URLs, and include a timestamp or date string in the name. An alternative would be to use metadata on each backup to include as much information as necessary. See the NSPersistentStoreCoordinator documentation for details. I’d be interested to hear what other approaches people use for Core Data backup and restore. You can find me at any of the social networking links in the sidebar, or else leave comments (pr revisions) on the Gist with the sample code.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \u003cp\u003eToday we’re going to travel back in time a little with Core Data. Or at least find out how your app can do so. What if you want to make a backup copy of your app’s data? What if you want to restore from that backup later on? This won’t be mainly about data safety, because your app’s data will be getting backed up to the user’s iCloud account and, maybe, their Mac. But you might have an app that, for whatever reason, needs to be able to revert to an older version of its data.\u003c/p\u003e\n\u003ch3 id=\"its-just-files-right\"\u003eIt’s just files, right?\u003c/h3\u003e\n\u003cp\u003eCore Data is a file-based persistent store, so it might seem like a good idea to just copy files around. Head over to the \u003ca href=\"https://developer.apple.com/documentation/foundation/filemanager\"\u003e\u003ccode\u003eFileManager\u003c/code\u003e\u003c/a\u003e documentation, figure out where the persistent store is located (hint: if you’re not sure, you can use the \u003ca href=\"https://developer.apple.com/documentation/coredata/nspersistentstoredescription\"\u003e\u003ccode\u003eNSPersistentStoreDescription\u003c/code\u003e\u003c/a\u003e), and hey, you’re done.\u003c/p\u003e\n\u003cp\u003eIn a very simple case, that might work. But, hey, make sure you also copy the journal files. Both of them. And oh, did you turn on “allows external binary storage” anywhere in your data model? Better copy the external binary files too. Also, the location of those files is undocumented. If you figure it out, it \u003cem\u003eprobably\u003c/em\u003e won’t change, but you can’t be sure. There might be other extra things to think about in the next version of iOS, who knows?\u003c/p\u003e\n\u003cp\u003eAnd of course, dont forget the possibility that not everything has been flushed from memory to the files when you copy them. It probably has been, of course. Probably.\u003c/p\u003e\n\u003cp\u003eFortunately Core Data has a built-in mechanism for this exact purpose. Rather than know every little detail of copying the files, you can ask Core Data to copy whatever’s needed.\u003c/p\u003e\n\u003ch3 id=\"migrate-the-data-store\"\u003eMigrate the Data Store!\u003c/h3\u003e\n\u003cp\u003eNo, not \u003ca href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreDataVersioning/Articles/Introduction.html\"\u003e\u003cstrong\u003ethat\u003c/strong\u003e\u003c/a\u003e kind of migration.\u003c/p\u003e\n\u003cp\u003eWith Core Data, data migration usually refers to changing your data model and migrating a persistent store to the new model. That’s not what I’m talking about here, but the function naming is a little confusing.\u003c/p\u003e\n\u003cp\u003eThere’s a method on \u003ccode\u003eNSPersistentStoreCoordinator\u003c/code\u003e which unfortunately has a name that makes it sound like it’s related to model migration. The \u003ccode\u003emigratePersistentStore(_:to:options:withType:)\u003c/code\u003e method actually does something completely different. It’s been around approximately forever but doesn’t seem to be well understood, if discussions on Stack Overflow and in developer Slack teams is any indication.\u003c/p\u003e\n\u003cp\u003eYou can use this method to make a new copy of a persistent store at a new location, which is conveniently the exact thing you need to make a backup copy. (It also lets you change the type of persistent store, but I’ll ignore that since it’s not relevant here). The basic way to use it is\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eLoad a persistent store.\u003c/li\u003e\n\u003cli\u003eChoose a new location for the store.\u003c/li\u003e\n\u003cli\u003eUse this method to write a copy of the store at the new location.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIt’s almost that simple. Except for one warning included in the documentation:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eImportant\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAfter invocation of this method, the specified store is removed from the coordinator thus store is no longer a useful reference.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis is a little scary. Once you use this method, the persistent store you migrated is removed from the persistent store coordinator. It also adds the newly-migrated store to the coordinator. So now the store is using the new copy instead of the old one. That’s not good for a backup, since the new copy is the backup you just made that you want to leave alone. It’s also a potential app crasher, since any managed objects you already fetched came from a persistent store that’s no longer available.\u003c/p\u003e\n\u003cp\u003eWe can deal with that. But first, to clear up a point of confusion for some. The existing persistent store is removed \u003cem\u003eonly from the persistent store coordinator\u003c/em\u003e. The actual persistent store files don’t get removed, and all their data is intact.\u003c/p\u003e\n\u003cp\u003eWe can make a backup safely by modifying the steps above slightly.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eLoad a persistent store.\u003c/li\u003e\n\u003cli\u003eCreate a secondary persistent store coordinator and load the store \u003cem\u003eagain\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eChoose a new location for the store.\u003c/li\u003e\n\u003cli\u003eUse this function \u003cem\u003eon the secondary coordinator\u003c/em\u003e to write a copy of the store at the new location.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis leaves the existing Core Data stack intact, so the app keeps working with its existing persistent store. The secondary persistent store coordinator makes the backup copy. When the copy finishes, the backup copy is loaded in the secondary coordinator. But we won’t use that coordinator any more, so it doesn’t matter.\u003c/p\u003e\n\u003cp\u003eOne possible implementation of this can be found in the \u003ccode\u003ecopyPersistentStores\u003c/code\u003e function at \u003ca href=\"https://gist.github.com/atomicbird/25fed73657be4b9d3642981a4892fea4\"\u003ethis Gist\u003c/a\u003e. The core of it is\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e temporaryPSC = NSPersistentStoreCoordinator(managedObjectModel: \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    persistentStoreCoordinator.managedObjectModel)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e destinationStoreURL = destinationURL.appendingPathComponent(storeURL.lastPathComponent)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003edo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e newStore = \u003cspan\u003etry\u003c/span\u003e temporaryPSC.addPersistentStore(ofType: persistentStoreDescription.type, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        configurationName: persistentStoreDescription.configuration, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        at: persistentStoreDescription.url,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        options: persistentStoreDescription.options)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e _ = \u003cspan\u003etry\u003c/span\u003e temporaryPSC.migratePersistentStore(newStore, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        to: destinationStoreURL, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        options: persistentStoreDescription.options, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        withType: persistentStoreDescription.type)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e} \u003cspan\u003ecatch\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis takes an existing, loaded persistent store, and creates a copy in a new directory with the same file name, options, and type. I wrote this as an extension on \u003ccode\u003eNSPersistentContainer\u003c/code\u003e since it’s where recent apps load their persistent stores.\u003c/p\u003e\n\u003cp\u003eOne extremely handy thing about this is that if the destination backup store already exists, \u003cstrong\u003eit gets updated in place\u003c/strong\u003e. It’s not necessary to remove the old backup first. Unless you want to offer multiple backups, you can back up to the same destination over and over and it’s fine.\u003c/p\u003e\n\u003ch3 id=\"i-want-my-data-back\"\u003eI Want My Data Back\u003c/h3\u003e\n\u003cp\u003eThat’s good, but what about restoring from the backup?\u003c/p\u003e\n\u003cp\u003eThis can be a little tricky to get right. Restoring the persistent store isn’t hard. Restoring and not crashing your app can be harder, because now you’re replacing the data store for a live Core Data stack. You’re replacing the lowest level of the stack and trying to prevent the whole thing from falling over. If you restore a backup, you replace the loaded store. Your app has probably loaded some data from its persistent store. Any managed objects in memory are now the app equivalent of a land mine. If you don’t touch them, nothing bad happens, but if you do, well, bad things happen.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://atomicbird.com/blog/core-data-back-up-store/42x64i.jpg#center75\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe can use the same method to restore a persistent store as we did when backing it up. Migration can go either way, so restoring is a migration from the backup copy to the live copy. But remember what I said earlier about how the migration destination gets updated in place? That happens here too. If the primary store exists during restoration, you could end up duplicating data. That would be bad.\u003c/p\u003e\n\u003cp\u003eThe full series of steps to restore is\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eMake sure you can avoid using any existing managed objects.\u003c/li\u003e\n\u003cli\u003eRemove the persistent store from memory. (This is the part that causes in-memory land mines if you weren’t careful).\u003c/li\u003e\n\u003cli\u003eDestroy the main persistent store. I’m saying “destroy” because the function is literally named \u003ccode\u003edestroyPersistentStore(at:ofType:options:)\u003c/code\u003e. This removes current data, making room for the restore.\u003c/li\u003e\n\u003cli\u003eLoad the backup store at its current location. For the moment the app will be using that persistent store, but not for long.\u003c/li\u003e\n\u003cli\u003eMigrate the backup store to the primary store location. This will remove the backup store from memory and add the newly migrated primary store.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAn implementation of this can be found in the \u003ccode\u003erestorePersistentStores\u003c/code\u003e function at \u003ca href=\"https://gist.github.com/atomicbird/25fed73657be4b9d3642981a4892fea4\"\u003ethat same Gist\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eOne difference from the backup process is that a temporary persistent store coordinator isn’t necessary. For a restore, the migration destination is the one we want to use, so we don’t need to set up a separate coordinator.\u003c/p\u003e\n\u003cp\u003eStep 1 can be the hardest part of the whole process, and the details depend completely on your app. Any managed objects that were fetched before restoring, or anything that has a reference to one of them, needs to be out of memory. You can then redo any fetches and update your UI. If your app is really simple, you might only need to do this after restoring:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003edo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e.fetchedResultsController.performFetch()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e} \u003cspan\u003ecatch\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    print(\u003cspan\u003e\u0026#34;Perform fetch error: \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003eerror\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003etableView.reloadData()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBut most apps will need more, and what works for one app won’t be right for another. You might need to design the restore-from-backup UI to be completely separate from the rest of the app so that you can completely unload any existing in-memory data that might be a problem.\u003c/p\u003e\n\u003cp\u003eSteps 2-5 above look something like this (see the gist for the full version):\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003edo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// Remove the existing persistent store first\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003etry\u003c/span\u003e persistentStoreCoordinator.remove(persistentStore)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// Clear out the existing persistent store so that we\u0026#39;ll have a \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// clean slate for restoring.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003etry\u003c/span\u003e persistentStoreCoordinator.destroyPersistentStore(at: loadedStoreURL, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        ofType: persistentStore.type, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        options: persistentStore.options)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// Add the backup store at its current location\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e backupStore = \u003cspan\u003etry\u003c/span\u003e persistentStoreCoordinator.addPersistentStore(ofType: persistentStore.type, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        configurationName: persistentStore.configurationName, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        at: backupStoreURL, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        options: persistentStore.options)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// Migrate the backup store to the non-backup location. This leaves\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// the backup copy in place in case it\u0026#39;s needed in the future, but \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// backupStore won\u0026#39;t be useful anymore.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e _ = \u003cspan\u003etry\u003c/span\u003e persistentStoreCoordinator.migratePersistentStore(backupStore, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        to: loadedStoreURL, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        options: persistentStore.options, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        withType: persistentStore.type)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e} \u003cspan\u003ecatch\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWhen this finishes, the main persistent store has been replaced by a copy of the backup store. The backup is still there, but the Core Data stack is using the restored copy.\u003c/p\u003e\n\u003ch2 id=\"other-possibilities\"\u003eOther possibilities\u003c/h2\u003e\n\u003cp\u003eThis all assumes you want just one backup which you might later restore. If you wanted multiple backups, you would need to add some way to separate the backups and tag them with whatever relevant details distinguish one from another. If it’s only the date, one way would be to use different backup destination URLs, and include a timestamp or date string in the name. An alternative would be to use metadata on each backup to include as much information as necessary. See the \u003ccode\u003eNSPersistentStoreCoordinator\u003c/code\u003e documentation for details.\u003c/p\u003e\n\u003cp\u003eI’d be interested to hear what other approaches people use for Core Data backup and restore. You can find me at any of the social networking links in the sidebar, or else leave comments (pr revisions) on the \u003ca href=\"https://gist.github.com/atomicbird/25fed73657be4b9d3642981a4892fea4\"\u003eGist\u003c/a\u003e with the sample code.\u003c/p\u003e\n\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2020-05-26T00:00:00Z",
  "modifiedTime": "2020-05-26T00:00:00Z"
}
