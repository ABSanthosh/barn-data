{
  "id": "8f5c427e-6373-469d-a37b-f07895b35296",
  "title": "Migrating an iOS app to SwiftUI - Navigation \u0026 Storyboards",
  "link": "https://benoitpasquier.com/migrating-ios-app-swiftui-part-1/",
  "description": "If SwiftUI is great for many things, migrating completely an existing app codebase to it can be really tricky. In a series of blog posts, I’ll share how to migrate an iOS app written in Swift with UIKit to SwiftUI. Today, let’s start with the navigation and the UI components with storyboards.",
  "author": "",
  "published": "Mon, 08 Feb 2021 08:00:00 +0000",
  "source": "https://benoitpasquier.com/index.xml",
  "categories": null,
  "byline": "Benoit Pasquier",
  "length": 10625,
  "excerpt": "If SwiftUI is great for many things, migrating completely an existing app codebase to it can be really tricky. In a series of blog posts, I’ll share how to migrate an iOS app written in Swift with UIKit to SwiftUI. Today, let’s start with the navigation and the UI components with storyboards.",
  "siteName": "Benoit Pasquier",
  "favicon": "https://benoitpasquier.com/favicon.png",
  "text": "February 8, 2021 in Swift If SwiftUI is great for many things, migrating completely an existing app codebase to it can be really tricky. In a series of blog posts, I’ll share how to migrate an iOS app written in Swift with UIKit to SwiftUI. Today, let’s start with the navigation and the UI components with storyboards. Almost two years ago, I’ve released an app to help people quit their bad habits. It contains a database, an onboarding journey and a dashboard. It’s a fairly simple app. The goal of this series of blog posts will be to fully migrate it to SwiftUI. This week I start with probably the most exciting part, the design and navigation. At the moment the app uses auto-layout across different storyboards for the UI. If it’s the first time the user launches the app, it goes through an onboarding journey to pick what habit to quit. Once defined, the next launch will go straight to its dashboard where the user can keep track of the time being sober and log new records. To tackle this migration, I’ll start first with the onboarding journey, then move toward the dashboard and logging screens. Onboarding The design of the onboarding is really simple, it includes different steps to introduce the app and its content. I create new SwiftUI View side by side to my previous UIViewController and .storyboard files to make sure I got the design right. First challenge is to use a custom font. Apple has great set of font and weight to automatically resize them but my previous version used a custom font, so does this new SwiftUI version. Text(\"Hello\") .font(.custom(AppFont.light.name, size: 27)) .foregroundColor(.white) To create a reusable style, I’ve implemented different variation of modifiers to be more handy. struct TitleModifier: ViewModifier { func body(content: Content) -\u003e some View { content .font(.custom(AppFont.bold.name, size: 51)) .foregroundColor(.white) } } Regarding the navigation, there is no more UINavigationController, it got replaced with NavigationView. So far, so good. One thing I was really surprised is how easy it is to prepare this transition. My app relies on an AppDelegate for the launch (amongst other things) but it only required to define an App with @main to define the new journey. //@UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u003e Bool { // prepare views and window } // ... } @main struct AppyApp: App { var body: some Scene { WindowGroup { NavigationView { OnboardingFirstView() } } } } If I want to launch against the UIKit version, I can comment @main from the app and uncomment @UIApplicationMain to fall back on the previous version. That makes the transition much safer for me to compare behaviors. Most of the design is straightforward and makes the code migration really enjoyable. Before the end of the onboarding, the mobile user can pick an activity he wants to quit or create its own. At the moment, I haven’t migrated the database structure to be identifiable through SwiftUI so I’ll come back to it later. Finally, if the user wants to add its own activity to quit, I’ll also need to add this into the database. This isn’t ready yet either, but I can user UserDefaults layer to mock the onboarding has been completed. Something I noticed through the implementation of the navigation between those screens is the usage of Button over NavigationLink. In my previous UIKit version, I tend to reuse components to sometimes present or push a new view. However, this is isn’t easily available in SwiftUI. I want to avoid having a condition to define a NavigationLink or a Button depending of the journey. It means that if small views should be reusable, I need to be careful of the reusability of the whole screen itself for a different journey. Alright, the on boarding is ready, we can dive into the dashboard side. Dashboard The dashboard is the main view of the app. This is where the user will land most of the time. Aside of huge timer, it’s set with two mains buttons, one to get more information, one to log the progress for your journey. Making those small time counter as separate view tidy up a lot of code and with some binding system, it’s going to be really easy to refresh it. SwiftUI and Combine looks really powerful for those implementation On the top right corner, the user can access the app information view. It’s also a very simple content. Like many other apps I’ve built, it’s aimed to help people, so I’m always available for feedback. At the bottom of the view, users can send open a mail to send me feedbacks of questions. This button navigation to the email become a much bigger challenge that I anticipated. In the UIKit version, I’ve used MFMailComposeViewController to open Mail client with an email pre-filled. However, this view isn’t available from SwiftUI. Straight from the top, MFMailComposeViewControllerDelegate is expecting to be an NSObjectProtocol where the SwiftUI view is a struct. No choice, I’ll have to bridge back to UIKit. First, I need a new class that will be the delegate of my view controller and handle when to dismiss it. import MessageUI import SwiftUI class MailControllerDelegate: NSObject, MFMailComposeViewControllerDelegate { @Binding var isPresented: Bool init(isPresented: Binding\u003cBool\u003e) { _isPresented = isPresented } func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) { isPresented = false } } I will also need a new view representation to bridge it back to SwiftUI world. struct MailView: UIViewControllerRepresentable { typealias Coordinator = MailControllerDelegate @Binding var isPresented: Bool func makeCoordinator() -\u003e MailControllerDelegate { MailControllerDelegate(isPresented: $isPresented) } func makeUIViewController(context: UIViewControllerRepresentableContext\u003cMailView\u003e) -\u003e MFMailComposeViewController { let viewController = MFMailComposeViewController() viewController.mailComposeDelegate = context.coordinator return viewController } func updateUIViewController(_ uiViewController: MFMailComposeViewController, context: UIViewControllerRepresentableContext\u003cMailView\u003e) { } } Finally, I can use it into my SwiftUI views with a specific condition to display it. struct InformationBottomView: View { @State private var isEmailPresented = false var body: some View { VStack(alignment: .center, spacing: 5) { if MFMailComposeViewController.canSendMail() { emailButton .sheet(isPresented: $isEmailPresented) { MailView(isPresented: $isEmailPresented) } } closeButton } } } Unfortunately, it’s not available on simulator but it works decently on physical device. The final part of the application is to be able to log the user daily progress. That will be the last step. Logging To add new record to the user progress, the app captures it through two views: If the user stayed sober How the user feel today. The flow is presented as a sheet but with a NavigationView at its root, to be able to go through those two views. Unfortunately, when the user finishes the flow, I cannot use presentationMode to dismiss the modal display and here is why. If you Google how to dismiss or pop a view, everything point to the presentationMode. However, to dismiss a modal navigation view from a detailed one is not that easy. presentationMode: A binding to the current presentation mode of the view associated with this environment. Reading the documentation, if I use this variable, I can only pop to the previous screen, I cannot dismiss the whole stack. In UIKit, we could get access to the navigation controller from a child view controller and turn things around, but not in SwiftUI. To work around this, I’ve came across this solution that explain how to create our own environment key, so that the detail view will get access to the sheet state. struct ShowingSheetKey: EnvironmentKey { static let defaultValue: Binding\u003cBool\u003e? = nil } extension EnvironmentValues { var showingSheet: Binding\u003cBool\u003e? { get { self[ShowingSheetKey.self] } set { self[ShowingSheetKey.self] = newValue } } } Now, I can bind the dashboard toggle to the presented view through the environment storage. struct DashboardView: View { @State private var isLoggerPresented = false var body: some View { VStack { // ... createButton .sheet(isPresented: $isLoggerPresented, content: { NavigationView { LogActivityView() } .environment(\\.showingSheet, $isLoggerPresented) }) } } } struct RatingView: View { @Environment(\\.showingSheet) var showingSheet var body: some View { ScrollView { LazyVStack { ForEach(data, id: \\.self) { RatingViewRow(rating: $0) .onTapGesture { // dismissing from detail view on tap showingSheet?.wrappedValue = false } } } } } Here is how it looks. Great, that’s exactly what we wanted! That’s it for the navigation and the design code migration. At the end, I got rid of the AppDelegate, view controllers and storyboards for a simpler set of SwiftUI views. If SwiftUI makes it really easy to prototype and get this new code ready, there are still some challenges regarding the navigation and older components. It almost always requires to bridge back to UIKit. It happened when using AVFoundation framework, it happened again today when using MessageUI framework. Those are pain points that you want to anticipate before starting a code migration at a bigger scale, but we managed to work around it today. Next step will be to tackle database and prepare the business logic to make the app work. See you next week",
  "image": "https://benoitpasquier.com/images/2019/08/appy-ios-app.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \n    \n  \n  \n  \u003cp\u003e\u003ctime itemprop=\"datePublished\" datetime=\"2021-02-08T08:00:00Z\"\u003e\n        \n  February 8, 2021\n\n      \u003c/time\u003e\n    \n    \n  \n  \n    \u003cspan\u003ein\u003c/span\u003e\n    \n      \u003ca href=\"https://benoitpasquier.com/categories/swift\"\u003eSwift\u003c/a\u003e\n    \n  \n\n  \u003c/p\u003e\n\n\u003c/div\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n              \u003cp\u003eIf SwiftUI is great for many things, migrating completely an existing app codebase to it can be really tricky. In a series of blog posts, I’ll share how to migrate an iOS app written in Swift with UIKit to SwiftUI. Today, let’s start with the navigation and the UI components with storyboards.\u003c/p\u003e\n\u003cp\u003eAlmost two years ago, I’ve released an app to help people \u003ca href=\"https://benoitpasquier.com/appy-ios-app-quit-bad-habits/\"\u003equit their bad habits\u003c/a\u003e. It contains a database, an onboarding journey and a dashboard. It’s a fairly simple app.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2019/08/appy-ios-app.png\" alt=\"appy-migration-swiftui\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe goal of this series of blog posts will be to fully migrate it to SwiftUI. This week I start with probably the most exciting part, the design and navigation.\u003c/p\u003e\n\u003cp\u003eAt the moment the app uses auto-layout across different storyboards for the UI. If it’s the first time the user launches the app, it goes through an onboarding journey to pick what habit to quit.\u003c/p\u003e\n\u003cp\u003eOnce defined, the next launch will go straight to its dashboard where the user can keep track of the time being sober and log new records.\u003c/p\u003e\n\u003cp\u003eTo tackle this migration, I’ll start first with the onboarding journey, then move toward the dashboard and logging screens.\u003c/p\u003e\n\u003ch2 id=\"onboarding\"\u003eOnboarding\u003c/h2\u003e\n\u003cp\u003eThe design of the onboarding is really simple, it includes different steps to introduce the app and its content. I create new SwiftUI \u003ccode\u003eView\u003c/code\u003e side by side to my previous \u003ccode\u003eUIViewController\u003c/code\u003e and \u003ccode\u003e.storyboard\u003c/code\u003e files to make sure I got the design right.\u003c/p\u003e\n\u003cp\u003eFirst challenge is to use a custom font. Apple has great set of font and weight to automatically resize them but my previous version used a custom font, so does this new SwiftUI version.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Hello\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    .\u003cspan\u003efont\u003c/span\u003e(.\u003cspan\u003ecustom\u003c/span\u003e(\u003cspan\u003eAppFont\u003c/span\u003e.\u003cspan\u003elight\u003c/span\u003e.\u003cspan\u003ename\u003c/span\u003e, \u003cspan\u003esize\u003c/span\u003e: \u003cspan\u003e27\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    .\u003cspan\u003eforegroundColor\u003c/span\u003e(.\u003cspan\u003ewhite\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTo create a reusable style, I’ve implemented different variation of modifiers to be more handy.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eTitleModifier\u003c/span\u003e: \u003cspan\u003eViewModifier\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e(\u003cspan\u003econtent\u003c/span\u003e: \u003cspan\u003eContent\u003c/span\u003e) -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003econtent\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            .\u003cspan\u003efont\u003c/span\u003e(.\u003cspan\u003ecustom\u003c/span\u003e(\u003cspan\u003eAppFont\u003c/span\u003e.\u003cspan\u003ebold\u003c/span\u003e.\u003cspan\u003ename\u003c/span\u003e, \u003cspan\u003esize\u003c/span\u003e: \u003cspan\u003e51\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            .\u003cspan\u003eforegroundColor\u003c/span\u003e(.\u003cspan\u003ewhite\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eRegarding the navigation, there is no more \u003ccode\u003eUINavigationController\u003c/code\u003e, it got replaced with \u003ccode\u003eNavigationView\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSo far, so good.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eOne thing I was really surprised is how easy it is to prepare this transition. My app relies on an \u003ccode\u003eAppDelegate\u003c/code\u003e for the launch (amongst other things) but it only required to define an \u003ccode\u003eApp\u003c/code\u003e with \u003ccode\u003e@main\u003c/code\u003e to define the new journey.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e//@UIApplicationMain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eAppDelegate\u003c/span\u003e: \u003cspan\u003eUIResponder\u003c/span\u003e, \u003cspan\u003eUIApplicationDelegate\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ewindow\u003c/span\u003e: \u003cspan\u003eUIWindow\u003c/span\u003e?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eapplication\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003eapplication\u003c/span\u003e: \u003cspan\u003eUIApplication\u003c/span\u003e, \u003cspan\u003edidFinishLaunchingWithOptions\u003c/span\u003e \u003cspan\u003elaunchOptions\u003c/span\u003e: [\u003cspan\u003eUIApplication\u003c/span\u003e.\u003cspan\u003eLaunchOptionsKey\u003c/span\u003e: \u003cspan\u003eAny\u003c/span\u003e]?) -\u0026gt; \u003cspan\u003eBool\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// prepare views and window\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e@\u003cspan\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eAppyApp\u003c/span\u003e: \u003cspan\u003eApp\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eScene\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eWindowGroup\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eNavigationView\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eOnboardingFirstView\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf I want to launch against the UIKit version, I can comment \u003ccode\u003e@main\u003c/code\u003e from the app and uncomment \u003ccode\u003e@UIApplicationMain\u003c/code\u003e to fall back on the previous version. That makes the transition much safer for me to compare behaviors.\u003c/p\u003e\n\u003cp\u003eMost of the design is straightforward and makes the code migration really enjoyable.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2021/02/uikit-to-swiftui.png\" alt=\"uikit-to-swiftui-migration\"/\u003e\u003c/p\u003e\n\u003cp\u003eBefore the end of the onboarding, the mobile user can pick an activity he wants to quit or create its own. At the moment, I haven’t migrated the database structure to be identifiable through SwiftUI so I’ll come back to it later.\u003c/p\u003e\n\u003cp\u003eFinally, if the user wants to add its own activity to quit, I’ll also need to add this into the database. This isn’t ready yet either, but I can user \u003ccode\u003eUserDefaults\u003c/code\u003e layer to mock the onboarding has been completed.\u003c/p\u003e\n\u003cp\u003eSomething I noticed through the implementation of the navigation between those screens is the usage of \u003ccode\u003eButton\u003c/code\u003e over \u003ccode\u003eNavigationLink\u003c/code\u003e. In my previous UIKit version, I tend to reuse components to sometimes \u003ccode\u003epresent\u003c/code\u003e or \u003ccode\u003epush\u003c/code\u003e a new view.\u003c/p\u003e\n\u003cp\u003eHowever, this is isn’t easily available in SwiftUI. I want to avoid having a condition to define a \u003ccode\u003eNavigationLink\u003c/code\u003e or a \u003ccode\u003eButton\u003c/code\u003e depending of the journey. It means that if small views should be reusable, I need to be careful of the reusability of the whole screen itself for a different journey.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eAlright\u003c/em\u003e, the on boarding is ready, we can dive into the dashboard side.\u003c/p\u003e\n\u003ch2 id=\"dashboard\"\u003eDashboard\u003c/h2\u003e\n\u003cp\u003eThe dashboard is the main view of the app. This is where the user will land most of the time. Aside of \u003cem\u003ehuge\u003c/em\u003e timer, it’s set with two mains buttons, one to get more information, one to log the progress for your journey.\u003c/p\u003e\n\u003cp\u003eMaking those small time counter as separate view tidy up a lot of code and with some binding system, it’s going to be really easy to refresh it. SwiftUI and Combine looks really powerful for those implementation\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2021/02/uikit-to-swiftui-2.png\" alt=\"uikit-to-swiftui-migration-2\"/\u003e\u003c/p\u003e\n\u003cp\u003eOn the top right corner, the user can access the app information view. It’s also a very simple content. Like many other apps I’ve built, it’s aimed to help people, so I’m always available for feedback. At the bottom of the view, users can send open a mail to send me feedbacks of questions.\u003c/p\u003e\n\u003cp\u003eThis button navigation to the email become a much bigger challenge that I anticipated. In the UIKit version, I’ve used \u003ccode\u003eMFMailComposeViewController\u003c/code\u003e to open Mail client with an email pre-filled. However, this view isn’t available from SwiftUI.\u003c/p\u003e\n\u003cp\u003eStraight from the top, \u003ccode\u003eMFMailComposeViewControllerDelegate\u003c/code\u003e is expecting to be an \u003ccode\u003eNSObjectProtocol\u003c/code\u003e where the SwiftUI view is a struct. No choice, I’ll have to bridge back to UIKit.\u003c/p\u003e\n\u003cp\u003eFirst, I need a new class that will be the delegate of my view controller and handle when to dismiss it.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eMessageUI\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eSwiftUI\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMailControllerDelegate\u003c/span\u003e: \u003cspan\u003eNSObject\u003c/span\u003e, \u003cspan\u003eMFMailComposeViewControllerDelegate\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    @\u003cspan\u003eBinding\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eisPresented\u003c/span\u003e: \u003cspan\u003eBool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003eisPresented\u003c/span\u003e: \u003cspan\u003eBinding\u003c/span\u003e\u0026lt;\u003cspan\u003eBool\u003c/span\u003e\u0026gt;) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e_isPresented\u003c/span\u003e = \u003cspan\u003eisPresented\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003emailComposeController\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003econtroller\u003c/span\u003e: \u003cspan\u003eMFMailComposeViewController\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                               \u003cspan\u003edidFinishWith\u003c/span\u003e \u003cspan\u003eresult\u003c/span\u003e: \u003cspan\u003eMFMailComposeResult\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                               \u003cspan\u003eerror\u003c/span\u003e: \u003cspan\u003eError\u003c/span\u003e?) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eisPresented\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI will also need a new view representation to bridge it back to SwiftUI world.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eMailView\u003c/span\u003e: \u003cspan\u003eUIViewControllerRepresentable\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003etypealias\u003c/span\u003e \u003cspan\u003eCoordinator\u003c/span\u003e = \u003cspan\u003eMailControllerDelegate\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    @\u003cspan\u003eBinding\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eisPresented\u003c/span\u003e: \u003cspan\u003eBool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003emakeCoordinator\u003c/span\u003e() -\u0026gt; \u003cspan\u003eMailControllerDelegate\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eMailControllerDelegate\u003c/span\u003e(\u003cspan\u003eisPresented\u003c/span\u003e: \u003cspan\u003e$\u003c/span\u003e\u003cspan\u003eisPresented\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003emakeUIViewController\u003c/span\u003e(\u003cspan\u003econtext\u003c/span\u003e: \u003cspan\u003eUIViewControllerRepresentableContext\u003c/span\u003e\u0026lt;\u003cspan\u003eMailView\u003c/span\u003e\u0026gt;) -\u0026gt; \u003cspan\u003eMFMailComposeViewController\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eviewController\u003c/span\u003e = \u003cspan\u003eMFMailComposeViewController\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eviewController\u003c/span\u003e.\u003cspan\u003emailComposeDelegate\u003c/span\u003e = \u003cspan\u003econtext\u003c/span\u003e.\u003cspan\u003ecoordinator\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eviewController\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eupdateUIViewController\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003euiViewController\u003c/span\u003e: \u003cspan\u003eMFMailComposeViewController\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                                \u003cspan\u003econtext\u003c/span\u003e: \u003cspan\u003eUIViewControllerRepresentableContext\u003c/span\u003e\u0026lt;\u003cspan\u003eMailView\u003c/span\u003e\u0026gt;) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFinally, I can use it into my SwiftUI views with a specific condition to display it.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eInformationBottomView\u003c/span\u003e: \u003cspan\u003eView\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    @\u003cspan\u003eState\u003c/span\u003e \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eisEmailPresented\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eVStack\u003c/span\u003e(\u003cspan\u003ealignment\u003c/span\u003e: .\u003cspan\u003ecenter\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003espacing\u003c/span\u003e: \u003cspan\u003e5\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003eMFMailComposeViewController\u003c/span\u003e.\u003cspan\u003ecanSendMail\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eemailButton\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    .\u003cspan\u003esheet\u003c/span\u003e(\u003cspan\u003eisPresented\u003c/span\u003e: \u003cspan\u003e$\u003c/span\u003e\u003cspan\u003eisEmailPresented\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                        \u003cspan\u003eMailView\u003c/span\u003e(\u003cspan\u003eisPresented\u003c/span\u003e: \u003cspan\u003e$\u003c/span\u003e\u003cspan\u003eisEmailPresented\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ecloseButton\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eUnfortunately, it’s not available on simulator but it works decently on physical device.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2021/02/uikit-to-swiftui-3.png\" alt=\"uikit-to-swiftui-migration-3\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe final part of the application is to be able to log the user daily progress. That will be the last step.\u003c/p\u003e\n\u003ch2 id=\"logging\"\u003eLogging\u003c/h2\u003e\n\u003cp\u003eTo add new record to the user progress, the app captures it through two views:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf the user stayed sober\u003c/li\u003e\n\u003cli\u003eHow the user feel today.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe flow is presented as a \u003ccode\u003esheet\u003c/code\u003e but with a \u003ccode\u003eNavigationView\u003c/code\u003e at its root, to be able to go through those two views.\u003c/p\u003e\n\u003cp\u003eUnfortunately, when the user finishes the flow, I cannot use \u003ccode\u003epresentationMode\u003c/code\u003e to dismiss the modal display and here is why.\u003c/p\u003e\n\u003cp\u003eIf you Google how to dismiss or pop a view, everything point to the \u003ccode\u003epresentationMode\u003c/code\u003e. However, to dismiss a modal navigation view from a detailed one is not that easy.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003epresentationMode\u003c/code\u003e: A binding to the current presentation mode of the view associated with this environment.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eReading the documentation, if I use this variable, I can only pop to the previous screen, I cannot dismiss the whole stack.\u003c/p\u003e\n\u003cp\u003eIn UIKit, we could get access to the navigation controller from a child view controller and turn things around, but not in SwiftUI.\u003c/p\u003e\n\u003cp\u003eTo work around this, I’ve came across this \u003ca href=\"https://stackoverflow.com/questions/60313431/swiftui-how-to-close-the-sheet-view-while-dismissing-that-view\"\u003esolution\u003c/a\u003e that explain how to create our own environment key, so that the detail view will get access to the sheet state.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eShowingSheetKey\u003c/span\u003e: \u003cspan\u003eEnvironmentKey\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003edefaultValue\u003c/span\u003e: \u003cspan\u003eBinding\u003c/span\u003e\u0026lt;\u003cspan\u003eBool\u003c/span\u003e\u0026gt;? = \u003cspan\u003enil\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eEnvironmentValues\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eshowingSheet\u003c/span\u003e: \u003cspan\u003eBinding\u003c/span\u003e\u0026lt;\u003cspan\u003eBool\u003c/span\u003e\u0026gt;? {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eget\u003c/span\u003e { \u003cspan\u003eself\u003c/span\u003e[\u003cspan\u003eShowingSheetKey\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e] }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eset\u003c/span\u003e { \u003cspan\u003eself\u003c/span\u003e[\u003cspan\u003eShowingSheetKey\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e] = \u003cspan\u003enewValue\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow, I can bind the dashboard toggle to the presented view through the environment storage.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eDashboardView\u003c/span\u003e: \u003cspan\u003eView\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    @\u003cspan\u003eState\u003c/span\u003e \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eisLoggerPresented\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eVStack\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ecreateButton\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                .\u003cspan\u003esheet\u003c/span\u003e(\u003cspan\u003eisPresented\u003c/span\u003e: \u003cspan\u003e$\u003c/span\u003e\u003cspan\u003eisLoggerPresented\u003c/span\u003e, \u003cspan\u003econtent\u003c/span\u003e: {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    \u003cspan\u003eNavigationView\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                        \u003cspan\u003eLogActivityView\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    .\u003cspan\u003eenvironment\u003c/span\u003e(\u003cspan\u003e\\\u003c/span\u003e.\u003cspan\u003eshowingSheet\u003c/span\u003e, \u003cspan\u003e$\u003c/span\u003e\u003cspan\u003eisLoggerPresented\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                })\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eRatingView\u003c/span\u003e: \u003cspan\u003eView\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    @\u003cspan\u003eEnvironment\u003c/span\u003e(\u003cspan\u003e\\\u003c/span\u003e.\u003cspan\u003eshowingSheet\u003c/span\u003e) \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eshowingSheet\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eScrollView\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eLazyVStack\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eForEach\u003c/span\u003e(\u003cspan\u003edata\u003c/span\u003e, \u003cspan\u003eid\u003c/span\u003e: \u003cspan\u003e\\\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    \u003cspan\u003eRatingViewRow\u003c/span\u003e(\u003cspan\u003erating\u003c/span\u003e: \u003cspan\u003e$0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    .\u003cspan\u003eonTapGesture\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                        \u003cspan\u003e// dismissing from detail view on tap\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                        \u003cspan\u003eshowingSheet\u003c/span\u003e?.\u003cspan\u003ewrappedValue\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere is how it looks.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2021/02/uikit-to-swiftui-4.gif\" alt=\"uikit-to-swiftui-migration-4\"/\u003e\u003c/p\u003e\n\u003cp\u003eGreat, that’s exactly what we wanted!\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eThat’s it for the navigation and the design code migration. At the end, I got rid of the \u003ccode\u003eAppDelegate\u003c/code\u003e, view controllers and storyboards for a simpler set of SwiftUI views.\u003c/p\u003e\n\u003cp\u003eIf SwiftUI makes it really easy to prototype and get this new code ready, there are still some challenges regarding the navigation and older components.\u003c/p\u003e\n\u003cp\u003eIt almost always requires to bridge back to UIKit. It happened when using \u003ca href=\"https://benoitpasquier.com/playing-video-avplayer-swiftui/\"\u003eAVFoundation\u003c/a\u003e framework, it happened again today when using \u003ccode\u003eMessageUI\u003c/code\u003e framework.\u003c/p\u003e\n\u003cp\u003eThose are pain points that you want to anticipate before starting a code migration at a bigger scale, but we managed to work around it today.\u003c/p\u003e\n\u003cp\u003eNext step will be to tackle database and prepare the business logic to make the app work.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSee you next week\u003c/em\u003e\u003c/p\u003e\n\u003chr/\u003e\n              \n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2021-02-08T08:00:00Z",
  "modifiedTime": "2021-02-08T08:00:00Z"
}
