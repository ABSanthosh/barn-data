{
  "id": "10fee781-b0df-41fa-b1ac-1792ddeb3298",
  "title": "Mastering transitions in SwiftUI",
  "link": "https://nerdyak.tech/development/2020/10/12/transitions-in-swiftui.html",
  "description": "Transitions play a vital role in the user experience of our apps. They are visual keys signalizing that the app or screen context is changing.",
  "author": "Pavel Zak",
  "published": "2020-10-12T00:00:00+00:00",
  "source": "https://nerdyak.tech/atom.xml",
  "categories": [
    "development",
    "SwiftUI",
    "Transition",
    "ViewModifier",
    "ConditionalView"
  ],
  "byline": "Pavel Zak",
  "length": 9570,
  "excerpt": "Transitions play a vital role in the user experience of our apps. They are visual keys signalizing that the app or screen context is changing.",
  "siteName": "Pavel Zak",
  "favicon": "",
  "text": "Transitions play a vital role in the user experience of our apps. They are visual keys signalizing that the app or screen context is changing. In this article, we will go through all important parts related to the implementation of transitions in SwiftUI - from the very basics to more advanced techniques. At the end of this article, you will be able to implement transitions like this: Triggering the transition Let us remind, what the transition is: Transition is an animation that might be triggered when some View is being added to or removed from the View hierarchy In practice, the change in the view hierarchy can usually come from the conditional statements, so let us have a look at the following example. struct BasicTransitionView: View { @State var showText = false var body: some View { VStack { if (self.showText) { Text(\"HELLO WORLD\") } Button(action: { withAnimation() { self.showText.toggle() } }) { Text(\"Change me\") } } } } There is a Text that is displayed only in the situation when showText is true. It is important to mention: The state change needs to be done withing withAnimation() block. If you explicitly state the animation here, it will affect the transition timing curve and duration. By default, the transition is fade in /fade out. We will see below, how to change it Note how layout changes and adapts to additional view causing the button itself to jump a bit lower. This behavior is completely valid for our situation with VStack, just keep in mind that inserted/removed view may affect surrounding views. A transition may be triggered also when changing .id() of a view. In such situation, SwiftUI removes the old View and creates a new one which may trigger transition on both old and new views. Basic transitions To change the default transition we can set up a new one using .transition view modifier. There are several types already available for basic view transformations .scale .move .offset .slide .opacity In our example, let me demonstrate the usage of move transition that shifts view being added/removed from/towards the leading edge of its frame. We just need to apply .transition(.move(edge: .leading)) to our text view. Feel free to experiment with the other types. Combining transitions The list of basic transitions is pretty short and most probably would not be sufficient, but luckily we can create more complex transitions with two powerful mechanisms transition combination transition created from any view modifier You can combine two transitions using .combine(with:) method that returns a new transition that is the result of both transitions being applied. The amount of transition combinations is not limited, so for example this combination of opacity, scale and move transition is perfectly fine: .transition( AnyTransition.move(edge: .leading).combined(with: AnyTransition.opacity).combined(with: .scale) ) Asymetric transitions In case you require to perform different transition on removal than on insertion, it is possible to create asymetric transition using the static function asymmetric(...), for example .transition( AnyTransition.asymmetric(insertion: .scale, removal: .opacity)) Asymetric transitions are especially handy in situations when the inserted view could overlap the removed view and thus produce unaesthetic animation. Custom transitions The creative part begins with the possibility to define your own transition based on view modifiers. Let me start with a very simple example to demonstrate the basics. Here is a custom view modifier that masks the view with a rounded rectangle shape. The value parameter is expected to have values between 0 and 1 when 0 clips the view entirely and 1 reveals the full view. struct ClipEffect: ViewModifier { var value: CGFloat func body(content: Content) -\u003e some View { content .clipShape(RoundedRectangle(cornerRadius: 100*(1-value)).scale(value)) } } Now, we can define custom transition that applies this effect as follows: .transition(AnyTransition.modifier(active: ClipEffect(value: 0), identity: ClipEffect(value: 1))) Note: To ease future re-usability, it may be beneficial to define your transitions as static members of AnyTransition: extension AnyTransition { static var clipTransition: AnyTransition { .modifier( active: ClipEffect(value: 0), identity: ClipEffect(value: 1) ) } } when used at our example .transition(.clipTransition), the result looks like this: Please note that: modifier transition depends on two states: active and identity. Identity is applied when the view is fully inserted in the view hierarchy and active when the view is gone. During the transition, SwiftUI interpolates between these two states, and thus the type of active and identity modifier needs to be the same! (XCode will complain otherwise) Mastering transitions So far we went through quite basic stuff so maybe, you have not realized how powerful all these things are. Making a transition from custom view modifiers allows you to unleash your creativity and with a little help of Geometry Effect, AnimatableModifier or blending modes you can create transitions that stand out. Let me showcase several examples: Counting up transition Handy for score or achievement screens, count up to the value of Text view using this simple AnimatableModifier: struct CountUpEffect: AnimatableModifier { var value: CGFloat var animatableData: CGFloat { get { return value } set { value = newValue } } func body(content: Content) -\u003e some View { Text(\"\\(self.value, specifier: \"%.1f\")\") .font(.title) .foregroundColor(self.value\u003c100 ? .primary : .red) } } In this case, we need to provide a parameter to the transition itself, so I have prepared simple extension that will provide us with the right transition: extension AnyTransition { static func countUpTransition(value: CGFloat)-\u003eAnyTransition { return AnyTransition.modifier(active: CountUpEffect(value: 0), identity: CountUpEffect(value: value)) } } And for the sake of excercise, we will combine it with the .scale transition when applied to the view: .transition(AnyTransition.countUpTransition(value: self.textValue).combined(with: .scale)) Taking content apart Combining several layers of content in the view modifier is my absolute favorite way to create unique transitions. The sliding door transition is a nice way how to demonstrate this approach Once again, let me start with the effect itself: struct SlidingDoorEffect: ViewModifier { let shift: CGFloat func body(content: Content) -\u003e some View { let c = content return ZStack { c.clipShape(HalfClipShape(left: false)).offset(x: -shift, y: 0) c.clipShape(HalfClipShape(left: true)).offset(x: shift, y: 0) } } } struct HalfClipShape: Shape { var left: Bool func path(in rect: CGRect) -\u003e Path { // shape covers lef or right part of rect return Path { path in let width = rect.width let height = rect.height let startx:CGFloat = left ? 0 : width/2 let shapeWidth:CGFloat = width/2 path.move(to: CGPoint(x: startx, y: 0)) path.addLines([ CGPoint(x: startx+shapeWidth, y: 0), CGPoint(x: startx+shapeWidth, y: height), CGPoint(x: startx, y: height), CGPoint(x: startx, y: 0) ]) } } } This effect duplicates the view content into ZStack and masks/clips only the left part of the bottom layer and right part of the top layer. Both copies of the content are later moved apart depending on the shift parameter. Text(\"HELLO WORLD\") .padding() .background(Color.orange) .transition(AnyTransition.modifier(active: SlidingDoorEffect(shift: 170), identity: SlidingDoorEffect(shift: 0))) You can go really crazy when mixing multiple occurrences of the content so please, bear in mind that mixing many (hundrets) content layers may lead to performance issues. The identity modifier remains applied even when the transition finished even though I refer to the content layers as copies they are different views of the same type! if the content is animated, it will remain live during the whole transition there might be some cuts visible even after the transition ends. If you encouter this situation, the solution may be to clip the sub-areas with slight (1-2px) overlap The transition shown in the previous blog post about onboarding screens was also done with this approach. The only difference is that the view is cut into quarters. The Task The best way to learn something new is to practice it. So for this topic, I have a challenge for you. Implement transition that explodes the view on removal. Example: How to do it? start with a Geometry Effect that animates a view along a curve prepare a masking shape for content sub-regions create an explosion effect that multiplies the content into many sub-regions, masking each one of them with relevant clipShape and offsetting using the effect from the first step wrap new effect into transition PROFIT",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\" aria-label=\"Content\"\u003e\n    \u003carticle\u003e\n      \u003cdiv\u003e\n        \u003cp\u003eTransitions play a vital role in the user experience of our apps. They are visual keys signalizing that the app or screen context is changing.\u003c/p\u003e\n\n\u003cp\u003eIn this article, we will go through all important parts related to the implementation of \u003ca href=\"https://developer.apple.com/documentation/swiftui/anytransition\"\u003etransitions\u003c/a\u003e in SwiftUI - from the very basics to more advanced techniques. At the end of this article, you will be able to implement transitions like this:\u003c/p\u003e\n\n\u003ccenter\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" controls=\"controls\"\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/12_video.mov\"/\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/12_video.webm\" type=\"video/webm\"/\u003e\n\u003c/video\u003e\n\u003c/center\u003e\n\n\u003ch2 id=\"triggering-the-transition\"\u003eTriggering the transition\u003c/h2\u003e\n\n\u003cp\u003eLet us remind, what the transition is:\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eTransition is an animation that might be triggered when some View is being added to or removed from the View hierarchy\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eIn practice, the change in the view hierarchy can usually come from the conditional statements, so let us have a look at the following example.\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eBasicTransitionView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e@State\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eshowText\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eVStack\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eshowText\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;HELLO WORLD\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003eButton\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eaction\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003ewithAnimation\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                    \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eshowText\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoggle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n                \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003e})\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Change me\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/12_transition1.gif\" alt=\"vid1\" title=\"Default transition\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eThere is a Text that is displayed only in the situation when \u003ccode\u003eshowText\u003c/code\u003e is true. It is important to mention:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eThe state change needs to be done withing \u003ccode\u003ewithAnimation()\u003c/code\u003e block. If you explicitly state the animation here, it will affect the transition timing curve and duration.\u003c/li\u003e\n  \u003cli\u003eBy default, the transition is fade in /fade out. We will see below, how to change it\u003c/li\u003e\n  \u003cli\u003eNote how layout changes and adapts to additional view causing the button itself to jump a bit lower. This behavior is completely valid for our situation with VStack, just keep in mind that inserted/removed view may affect surrounding views.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eA transition may be triggered also when changing \u003ccode\u003e.id()\u003c/code\u003e of a view. In such situation, SwiftUI removes the old View and creates a new one which may trigger transition on both old and new views.\u003c/p\u003e\n\n\u003ch2 id=\"basic-transitions\"\u003eBasic transitions\u003c/h2\u003e\n\n\u003cp\u003eTo change the default transition we can set up a new one using \u003ccode\u003e.transition\u003c/code\u003e view modifier. There are several types already available for basic view transformations\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e.scale\u003c/li\u003e\n  \u003cli\u003e.move\u003c/li\u003e\n  \u003cli\u003e.offset\u003c/li\u003e\n  \u003cli\u003e.slide\u003c/li\u003e\n  \u003cli\u003e.opacity\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eIn our example, let me demonstrate the usage of \u003ccode\u003emove\u003c/code\u003e transition that shifts view being added/removed from/towards the leading edge of \u003cstrong\u003eits\u003c/strong\u003e frame. We just need to apply \u003ccode\u003e.transition(.move(edge: .leading))\u003c/code\u003e to our text view.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/12_transition7.gif\" alt=\"vid8\" title=\"Move transition\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eFeel free to experiment with the other types.\u003c/p\u003e\n\n\u003ch2 id=\"combining-transitions\"\u003eCombining transitions\u003c/h2\u003e\n\n\u003cp\u003eThe list of basic transitions is pretty short and most probably would not be sufficient, but luckily we can create more complex transitions with two powerful mechanisms\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003etransition combination\u003c/li\u003e\n  \u003cli\u003etransition created from any view modifier\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eYou can combine two transitions using \u003ccode\u003e.combine(with:)\u003c/code\u003e method that returns a new transition that is the result of \u003cstrong\u003eboth transitions being applied\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe amount of transition combinations is not limited, so for example this combination of opacity, scale and move transition is perfectly fine:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etransition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e \u003cspan\u003eAnyTransition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emove\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eedge\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eleading\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecombined\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnyTransition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eopacity\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecombined\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escale\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/12_transition3.gif\" alt=\"vid3\" title=\"Transition combination\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"asymetric-transitions\"\u003eAsymetric transitions\u003c/h2\u003e\n\n\u003cp\u003eIn case you require to perform different transition on removal than on insertion, it is possible to create asymetric transition using the static function \u003ccode\u003easymmetric(...)\u003c/code\u003e, for example\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etransition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e \u003cspan\u003eAnyTransition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easymmetric\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003einsertion\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escale\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eremoval\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eopacity\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/12_transition4.gif\" alt=\"vid4\" title=\"Assymetric transition\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eAsymetric transitions are especially handy in situations when the inserted view could overlap the removed view and thus produce unaesthetic animation.\u003c/p\u003e\n\n\u003ch2 id=\"custom-transitions\"\u003eCustom transitions\u003c/h2\u003e\n\n\u003cp\u003eThe creative part begins with the possibility to define your own transition based on view modifiers. Let me start with a very simple example to demonstrate the basics.\u003c/p\u003e\n\n\u003cp\u003eHere is a custom view modifier that masks the view with a rounded rectangle shape. The value parameter is expected to have values between 0 and 1 when 0 clips the view entirely and 1 reveals the full view.\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eClipEffect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eViewModifier\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtent\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eContent\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003econtent\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eclipShape\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eRoundedRectangle\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e100*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escale\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eNow, we can define custom transition that applies this effect as follows:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etransition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eAnyTransition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emodifier\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eactive\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eClipEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003eidentity\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eClipEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)))\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eNote: To ease future re-usability, it may be beneficial to define your transitions as static members of AnyTransition:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eAnyTransition\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eclipTransition\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnyTransition\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emodifier\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n            \u003cspan\u003eactive\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eClipEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n            \u003cspan\u003eidentity\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eClipEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003ewhen used at our example \u003ccode\u003e.transition(.clipTransition)\u003c/code\u003e, the result looks like this:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/12_transition2.gif\" alt=\"vid2\" title=\"Transition from the effect\"/\u003e\u003c/p\u003e\n\n\u003cp\u003ePlease note that:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003emodifier transition depends on two states: \u003cstrong\u003eactive and identity\u003c/strong\u003e. Identity is applied when the view is fully inserted in the view hierarchy and active when the view is gone.\u003c/li\u003e\n  \u003cli\u003eDuring the transition, SwiftUI interpolates between these two states, and thus the type of active and identity modifier \u003cstrong\u003eneeds to be the same\u003c/strong\u003e! (XCode will complain otherwise)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"mastering-transitions\"\u003eMastering transitions\u003c/h2\u003e\n\n\u003cp\u003eSo far we went through quite basic stuff so maybe, you have not realized how powerful all these things are. Making a transition from custom view modifiers allows you to unleash your creativity and with a little help of \u003ca href=\"https://nerdyak.tech/development/2019/08/29/tweaking-animations-with-GeometryEffect.html\"\u003eGeometry Effect\u003c/a\u003e, \u003ca href=\"https://developer.apple.com/documentation/swiftui/animatablemodifier\"\u003eAnimatableModifier\u003c/a\u003e or blending modes you can create transitions that stand out. Let me showcase several examples:\u003c/p\u003e\n\n\u003ch3 id=\"counting-up-transition\"\u003eCounting up transition\u003c/h3\u003e\n\n\u003cp\u003eHandy for score or achievement screens, count up to the value of Text view using this simple AnimatableModifier:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eCountUpEffect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableModifier\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eanimatableData\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eget\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003eset\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enewValue\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtent\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eContent\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003especifier\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;%.1f\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efont\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforegroundColor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e100\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprimary\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ered\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eIn this case, we need to provide a parameter to the transition itself, so I have prepared simple extension that will provide us with the right transition:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eAnyTransition\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ecountUpTransition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003eAnyTransition\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eAnyTransition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emodifier\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eactive\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCountUpEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003eidentity\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCountUpEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eAnd for the sake of excercise, we will combine it with the \u003ccode\u003e.scale\u003c/code\u003e transition when applied to the view:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etransition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eAnyTransition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecountUpTransition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etextValue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecombined\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escale\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/12_transition5.gif\" alt=\"vid5\" title=\"Count up transition\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"taking-content-apart\"\u003eTaking content apart\u003c/h3\u003e\n\n\u003cp\u003eCombining several layers of content in the view modifier is my absolute favorite way to create unique transitions. The sliding door transition is a nice way how to demonstrate this approach\u003c/p\u003e\n\n\u003cp\u003eOnce again, let me start with the effect itself:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eSlidingDoorEffect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eViewModifier\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eshift\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtent\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eContent\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtent\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eZStack\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eclipShape\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eHalfClipShape\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eleft\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eoffset\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003eshift\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eclipShape\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eHalfClipShape\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eleft\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eoffset\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eshift\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eHalfClipShape\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eShape\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eleft\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBool\u003c/span\u003e\n        \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003ePath\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// shape covers lef or right part of rect\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ePath\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003epath\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\n            \n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartx\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eleft\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eshapeWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\n            \n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emove\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLines\u003c/span\u003e\u003cspan\u003e([\u003c/span\u003e\n                \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartx\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003eshapeWidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n                \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartx\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003eshapeWidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n                \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n                \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e])\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eThis effect duplicates the view content into ZStack and masks/clips only the left part of the bottom layer and right part of the top layer. Both \u003cem\u003ecopies\u003c/em\u003e of the content are later moved apart depending on the shift parameter.\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;HELLO WORLD\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\t\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebackground\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eorange\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etransition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eAnyTransition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emodifier\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eactive\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSlidingDoorEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eshift\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e170\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003eidentity\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSlidingDoorEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eshift\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)))\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/12_transition6.gif\" alt=\"vid6\" title=\"Sliding door transition\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eYou can go really crazy when mixing multiple occurrences of the content so please, bear in mind that\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003emixing many (hundrets) content layers may lead to performance issues. The identity modifier \u003cstrong\u003eremains applied\u003c/strong\u003e even when the transition finished\u003c/li\u003e\n  \u003cli\u003eeven though I refer to the content layers as \u003cem\u003ecopies\u003c/em\u003e they are \u003cstrong\u003edifferent views of the same type\u003c/strong\u003e!\u003c/li\u003e\n  \u003cli\u003eif the content is animated, it will remain live during the whole transition\u003c/li\u003e\n  \u003cli\u003ethere might be some \u003cem\u003ecuts\u003c/em\u003e visible even after the transition ends. If you encouter this situation, the solution may be to clip the sub-areas with \u003cem\u003eslight\u003c/em\u003e (1-2px) overlap\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe transition shown in the \u003ca href=\"https://nerdyak.tech/development/2020/07/17/creating-onboarding-screens-in-swiftui.html\"\u003eprevious blog post\u003c/a\u003e about onboarding screens was also done with this approach. The only difference is that the view is cut into quarters.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/11_vid4.gif\" alt=\"vid7\" title=\"Transition used on onboarding screens\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"the-task\"\u003eThe Task\u003c/h2\u003e\n\n\u003cp\u003eThe best way to learn something new is to practice it. So for this topic, I have a challenge for you.\u003c/p\u003e\n\n\u003cp\u003eImplement transition that \u003cem\u003eexplodes\u003c/em\u003e the view on removal. Example:\u003c/p\u003e\n\n\u003ccenter\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" controls=\"controls\"\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/12_explode.mov\"/\u003e\n\t\u003csource src=\"https://nerdyak.tech/assets/posts/12_explode.webm\" type=\"video/webm\"/\u003e\n\u003c/video\u003e\n\u003c/center\u003e\n\n\u003cp\u003eHow to do it?\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003estart with a \u003ca href=\"https://nerdyak.tech/development/2019/08/29/tweaking-animations-with-GeometryEffect.html\"\u003eGeometry Effect\u003c/a\u003e that animates a view along a curve\u003c/li\u003e\n  \u003cli\u003eprepare a masking shape for content sub-regions\u003c/li\u003e\n  \u003cli\u003ecreate an explosion effect that multiplies the content into many sub-regions, masking each one of them with relevant clipShape and offsetting using the effect from the first step\u003c/li\u003e\n  \u003cli\u003ewrap new effect into transition\u003c/li\u003e\n  \u003cli\u003ePROFIT\u003c/li\u003e\n\u003c/ol\u003e\n\n\n      \u003c/div\u003e\n      \n    \u003c/article\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2020-10-12T00:00:00Z",
  "modifiedTime": null
}
