{
  "id": "ef1b3def-38e7-40d6-886f-2becfcca5454",
  "title": "Type placeholders in Swift",
  "link": "https://www.swiftbysundell.com/articles/type-placeholders-in-swift",
  "description": "New in Swift 5.6: We can now use type placeholders to select what generic types that we want the compiler to infer. Let’s take a look at how those placeholders work, and what kinds of situations that they could be really useful in.",
  "author": "",
  "published": "Thu, 14 Apr 2022 12:55:00 +0200",
  "source": "https://swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 5841,
  "excerpt": "New in Swift 5.6: We can now use type placeholders to select what generic types that we want the compiler to infer. Let’s take a look at how those placeholders work, and what kinds of situations that they could be really useful in.",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "Swift’s type inference capabilities have been a very core part of the language since the very beginning, and heavily reduces the need for us to manually specify types when declaring variables and properties that have default values. For example, the expression var number = 7 doesn’t need to include any type annotations, since the compiler is able to infer that the value 7 is an Int and that our number variable should be typed accordingly.Swift 5.6, which was released as part of Xcode 13.3, continues to expand these type inference capabilities by introducing the concept of “type placeholders”, which can come very much in handy when working with collections and other generic types.For example, let’s say that we wanted to create an instance of Combine’s CurrentValueSubject with a default integer value. An initial idea on how to do just that might be to simply pass our default value to that subject’s initializer, and then store the result in a local let (just like when creating a plain Int value). However, doing so gives us the following compiler error:// Error: \"Generic parameter 'Failure' could not be inferred\" let counterSubject = CurrentValueSubject(0)That’s because CurrentValueSubject is a generic type that needs to be specialized with not just an Output type, but also with a Failure type — which is the type of error that the subject is capable of throwing.Since we don’t want our subject to throw any errors in this case, we’ll give it the failure type Never (which is a common convention when using both Combine and Swift concurrency). But in order to do that, prior to Swift 5.6, we would need to explicitly specify our Int output type as well — like this:let counterSubject = CurrentValueSubject\u003cInt, Never\u003e(0)Starting in Swift 5.6, though, that’s no longer the case — as we can now use a type placeholder for our subject’s output type, which lets us once again leverage the compiler to automatically infer that type for us, just like when declaring a plain Int value:let counterSubject = CurrentValueSubject\u003c_, Never\u003e(0)That’s nice, but it’s arguably not the biggest improvement in the world. After all, we’re only saving two characters by replacing Int with _, and it’s not like manually specifying a simple type like Int was something problematic to begin with.But let’s now take a look at how this feature scales to more complex types, which is where it really starts to shine. For example, let’s say that our project contains the following function that lets us load a user-annotated PDF file:func loadAnnotatedPDF(named: String) -\u003e Resource\u003cPDF\u003cUserAnnotations\u003e\u003e { ... }The above function uses a quite complex generic as its return type, which might be because we’re reusing our Resource type across multiple domains, and because we’ve opted to use phantom types to specify what kind of PDF that we’re currently dealing with.Now let’s take a look at what our CurrentValueSubject-based code from before would look like if we were to call the above function when creating our subject, rather than just using a simple integer:// Before Swift 5.6: let pdfSubject = CurrentValueSubject\u003cResource\u003cPDF\u003cUserAnnotations\u003e\u003e, Never\u003e( loadAnnotatedPDF(named: name) ) // Swift 5.6: let pdfSubject = CurrentValueSubject\u003c_, Never\u003e( loadAnnotatedPDF(named: name) )That’s quite a huge improvement! Not only does the Swift 5.6-based version save us some typing, but since the type of pdfSubject is now derived completely from the loadAnnotatedPDF function, that’ll likely make iterating on that function (and its related code) much easier — since there will be fewer manual type annotations that will need to be updated if we ever change that function’s return type.It’s worth pointing out, though, that there’s another way to leverage Swift’s type inference capabilities in situations like the one above — and that’s to use a type alias, rather than a type placeholder. For example, here’s how we could define an UnfailingValueSubject type alias, which we’ll be able to use to easily create subjects that aren’t capable of throwing any errors:typealias UnfailingValueSubject\u003cT\u003e = CurrentValueSubject\u003cT, Never\u003eWith the above in place, we’ll now be able to create our pdfSubject without any kind of generic type annotations at all — since the compiler is able to infer what type that T refers to, and since the failure type Never has been hard-coded into our new type alias:let pdfSubject = UnfailingValueSubject(loadAnnotatedPDF(named: name))That doesn’t mean that type aliases are universally better than type placeholders, though, since if we were to define new type aliases for each particular situation, then that could also make our code base much more complicated. Sometimes, specifying everything inline (like when using a type placeholder) is definitely the way to go, as that lets us define expressions that are completely self-contained.Before we wrap things up, let’s also take a look at how type placeholders can be used with collection literals — for example when creating a dictionary. Here, we’ve opted to manually specify our dictionary’s Key type (in order to be able to use dot-syntax to refer to an enum’s various cases), while using a type placeholder for that dictionary’s values:enum UserRole { case local case remote } let latestMessages: [UserRole: _] = [ .local: \"\", .remote: \"\" ]So that’s type placeholders — a new feature introduced in Swift 5.6, which will likely be really useful when dealing with slightly more complex generic types. It’s worth pointing out, though, that these placeholders can only be used at call sites, not when specifying the return types of either functions or computed properties.I hope you found this article useful, and feel free to let me know if you have any questions, comments, or feedback — either via Twitter or email.Thanks for reading!",
  "image": "https://www.swiftbysundell.com/images/articles/type-placeholders-in-swift.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eSwift’s type inference capabilities have been a very core part of the language since the very beginning, and heavily reduces the need for us to manually specify types when declaring variables and properties that have default values. For example, the expression \u003ccode\u003evar number = 7\u003c/code\u003e doesn’t need to include any type annotations, since the compiler is able to infer that the value \u003ccode\u003e7\u003c/code\u003e is an \u003ccode\u003eInt\u003c/code\u003e and that our \u003ccode\u003enumber\u003c/code\u003e variable should be typed accordingly.\u003c/p\u003e\u003cp\u003eSwift 5.6, which was released as part of Xcode 13.3, continues to expand these type inference capabilities by introducing the concept of “type placeholders”, which can come very much in handy when working with collections and other generic types.\u003c/p\u003e\u003cp\u003eFor example, let’s say that we wanted to create an instance of Combine’s \u003ca href=\"https://www.swiftbysundell.com/articles/using-combine-futures-and-subjects\"\u003e\u003ccode\u003eCurrentValueSubject\u003c/code\u003e\u003c/a\u003e with a default integer value. An initial idea on how to do just that might be to simply pass our default value to that subject’s initializer, and then store the result in a local \u003ccode\u003elet\u003c/code\u003e (just like when creating a plain \u003ccode\u003eInt\u003c/code\u003e value). However, doing so gives us the following compiler error:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Error: \u0026#34;Generic parameter \u0026#39;Failure\u0026#39; could not be inferred\u0026#34;\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e counterSubject = \u003cspan\u003eCurrentValueSubject\u003c/span\u003e(\u003cspan\u003e0\u003c/span\u003e)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat’s because \u003ccode\u003eCurrentValueSubject\u003c/code\u003e is a generic type that needs to be specialized with not just an \u003ccode\u003eOutput\u003c/code\u003e type, but also with a \u003ccode\u003eFailure\u003c/code\u003e type — which is the type of error that the subject is capable of throwing.\u003c/p\u003e\u003cp\u003eSince we don’t want our subject to throw any errors in this case, we’ll give it the failure type \u003ccode\u003eNever\u003c/code\u003e (which is a common convention when using both Combine and Swift concurrency). But in order to do that, prior to Swift 5.6, we would need to explicitly specify our \u003ccode\u003eInt\u003c/code\u003e output type as well — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e counterSubject = \u003cspan\u003eCurrentValueSubject\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003cspan\u003eInt\u003c/span\u003e, \u003cspan\u003eNever\u003c/span\u003e\u0026gt;\u003c/span\u003e(\u003cspan\u003e0\u003c/span\u003e)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eStarting in Swift 5.6, though, that’s no longer the case — as we can now use a \u003cem\u003etype placeholder\u003c/em\u003e for our subject’s output type, which lets us once again leverage the compiler to automatically infer that type for us, just like when declaring a plain \u003ccode\u003eInt\u003c/code\u003e value:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e counterSubject = \u003cspan\u003eCurrentValueSubject\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003cspan\u003e_\u003c/span\u003e, \u003cspan\u003eNever\u003c/span\u003e\u0026gt;\u003c/span\u003e(\u003cspan\u003e0\u003c/span\u003e)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat’s nice, but it’s arguably not the biggest improvement in the world. After all, we’re only saving two characters by replacing \u003ccode\u003eInt\u003c/code\u003e with \u003ccode\u003e_\u003c/code\u003e, and it’s not like manually specifying a simple type like \u003ccode\u003eInt\u003c/code\u003e was something problematic to begin with.\u003c/p\u003e\u003cp\u003eBut let’s now take a look at how this feature scales to more complex types, which is where it really starts to shine. For example, let’s say that our project contains the following function that lets us load a user-annotated PDF file:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efunc\u003c/span\u003e loadAnnotatedPDF(named: \u003cspan\u003eString\u003c/span\u003e) -\u0026gt; \u003cspan\u003eResource\u003c/span\u003e\u0026lt;\u003cspan\u003ePDF\u003c/span\u003e\u0026lt;\u003cspan\u003eUserAnnotations\u003c/span\u003e\u0026gt;\u0026gt; {\n    ...\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above function uses a quite complex generic as its return type, which might be because we’re reusing our \u003ccode\u003eResource\u003c/code\u003e type across multiple domains, and because we’ve opted to use \u003cem\u003e\u003ca href=\"https://www.swiftbysundell.com/articles/phantom-types-in-swift\"\u003ephantom types\u003c/a\u003e\u003c/em\u003e to specify what kind of PDF that we’re currently dealing with.\u003c/p\u003e\u003cp\u003eNow let’s take a look at what our \u003ccode\u003eCurrentValueSubject\u003c/code\u003e-based code from before would look like if we were to call the above function when creating our subject, rather than just using a simple integer:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Before Swift 5.6:\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e pdfSubject = \u003cspan\u003eCurrentValueSubject\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003cspan\u003eResource\u003c/span\u003e\u0026lt;\u003cspan\u003ePDF\u003c/span\u003e\u0026lt;\u003cspan\u003eUserAnnotations\u003c/span\u003e\u0026gt;\u0026gt;, \u003cspan\u003eNever\u003c/span\u003e\u0026gt;\u003c/span\u003e(\n    \u003cspan\u003eloadAnnotatedPDF\u003c/span\u003e(named: name)\n)\n\n\u003cspan\u003e// Swift 5.6:\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e pdfSubject = \u003cspan\u003eCurrentValueSubject\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003cspan\u003e_\u003c/span\u003e, \u003cspan\u003eNever\u003c/span\u003e\u0026gt;\u003c/span\u003e(\n    \u003cspan\u003eloadAnnotatedPDF\u003c/span\u003e(named: name)\n)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat’s quite a huge improvement! Not only does the Swift 5.6-based version save us some typing, but since the type of \u003ccode\u003epdfSubject\u003c/code\u003e is now derived completely from the \u003ccode\u003eloadAnnotatedPDF\u003c/code\u003e function, that’ll likely make iterating on that function (and its related code) much easier — since there will be fewer manual type annotations that will need to be updated if we ever change that function’s return type.\u003c/p\u003e\u003cp\u003eIt’s worth pointing out, though, that there’s another way to leverage Swift’s type inference capabilities in situations like the one above — and that’s to use a type alias, rather than a type placeholder. For example, here’s how we could define an \u003ccode\u003eUnfailingValueSubject\u003c/code\u003e type alias, which we’ll be able to use to easily create subjects that aren’t capable of throwing any errors:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003etypealias\u003c/span\u003e UnfailingValueSubject\u0026lt;T\u0026gt; = \u003cspan\u003eCurrentValueSubject\u003c/span\u003e\u0026lt;\u003cspan\u003eT\u003c/span\u003e, \u003cspan\u003eNever\u003c/span\u003e\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith the above in place, we’ll now be able to create our \u003ccode\u003epdfSubject\u003c/code\u003e without any kind of generic type annotations at all — since the compiler is able to infer what type that \u003ccode\u003eT\u003c/code\u003e refers to, and since the failure type \u003ccode\u003eNever\u003c/code\u003e has been hard-coded into our new type alias:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e pdfSubject = \u003cspan\u003e\u003cspan\u003eUnfailingValueSubject\u003c/span\u003e\u003c/span\u003e(\u003cspan\u003eloadAnnotatedPDF\u003c/span\u003e(named: name))\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat doesn’t mean that type aliases are universally better than type placeholders, though, since if we were to define new type aliases for each particular situation, then that could also make our code base much more complicated. Sometimes, specifying everything inline (like when using a type placeholder) is definitely the way to go, as that lets us define expressions that are completely self-contained.\u003c/p\u003e\u003cp\u003eBefore we wrap things up, let’s also take a look at how type placeholders can be used with collection literals — for example when creating a dictionary. Here, we’ve opted to manually specify our dictionary’s \u003ccode\u003eKey\u003c/code\u003e type (in order to be able to use dot-syntax to refer to an enum’s various cases), while using a type placeholder for that dictionary’s values:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eenum\u003c/span\u003e UserRole {\n    \u003cspan\u003ecase\u003c/span\u003e local\n    \u003cspan\u003ecase\u003c/span\u003e remote\n}\n\n\u003cspan\u003elet\u003c/span\u003e latestMessages: \u003cspan\u003e[\u003cspan\u003eUserRole\u003c/span\u003e: \u003cspan\u003e_\u003c/span\u003e]\u003c/span\u003e = [\n    .\u003cspan\u003elocal\u003c/span\u003e: \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e,\n    .\u003cspan\u003eremote\u003c/span\u003e: \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\n]\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo that’s type placeholders — a new feature introduced in Swift 5.6, which will likely be really useful when dealing with slightly more complex generic types. It’s worth pointing out, though, that these placeholders can \u003cem\u003eonly\u003c/em\u003e be used at call sites, not when specifying the return types of either functions or computed properties.\u003c/p\u003e\u003cp\u003eI hope you found this article useful, and feel free to let me know if you have any questions, comments, or feedback — either via \u003ca href=\"https://twitter.com/johnsundell\"\u003eTwitter\u003c/a\u003e or \u003ca href=\"https://www.swiftbysundell.com/contact\"\u003eemail\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
