{
  "id": "fa567b61-de36-44ad-87bd-36957e9765a1",
  "title": "Security Application Static Analysis applied to iOS and Gitlab CI",
  "link": "https://benoitpasquier.com/2022/07/security-application-static-analysis-applied-to-ios-and-gitlab-ci/",
  "description": "Security is a big topic in software engineering but how does it apply to mobile development? We care about user experience or mobile performance, security issues are rarely prioritized. This week, I’ll share how to integrate security tools into your CI pipeline to stay aware of your codebase health.",
  "author": "",
  "published": "Sun, 31 Jul 2022 06:00:00 +0000",
  "source": "https://benoitpasquier.com/index.xml",
  "categories": null,
  "byline": "Benoit Pasquier",
  "length": 8498,
  "excerpt": "Security is a big topic in software engineering but how does it apply to mobile development? We care about user experience or mobile performance, security issues are rarely prioritized. This week, I’ll share how to integrate security tools into your CI pipeline to stay aware of your codebase health.",
  "siteName": "Benoit Pasquier",
  "favicon": "https://benoitpasquier.com/favicon.png",
  "text": "Security is a big topic in software engineering but how does it apply to mobile development? We care about user experience or mobile performance, security issues are rarely prioritized. This week, I’ll share how to integrate security tools into your CI pipeline to stay aware of your codebase health. Disclaimer: I’m not a security expert, just security enthusiast engineer :) Security in mobile application It all started earlier this year when I was exploring different tools to detect security issues into one of my mobile apps, mostly by curiosity. Before diving into the technical aspect, we need to understand why security is a concern in mobile development. With more and more apps available to us, mobile application is one of the entry point to your system for malicious users to exploit it. The bigger your app or your business gets, the bigger target it becomes. From mobile app vulnerabilities can come data leaks, lost of money and reputations and so on. Thankfully, there are also “good guys” in the community that keep track of the vulnerabilities, sharing documentations and resources to educate engineers. OWASP Foundation is the main contributor and frequently share the top 10 most critical risks for web and mobile applications. In the Mobile top 10 report, we can find many risks like insecure authentication, insufficient cryptography, examples of exploits and to prevent them. Finally, they also published a Mobile Security Testing Guide for mobile engineers to not only understand the risk, but also detect them and make sure our mobile apps stays secured. So now, we know why security is important, we have access to guidelines and documentations to recognize vulnerabilities and how to test them. So how we detect those issues ahead, during development for instance? Application Security Testing One way to detects security issues includes Static Application Security Testing (SAST). It’s a testing methodology to analyze your source code and detect vulnerabilities based on code patterns. It’s pretty similar to any lint tools, like SwiftLint, but applied to security issues. One mobile security tool that is recommended by OWASP and free to use is MobSF. It includes whole suite of integration, including SAST for iOS and Android. It also includes DAST (Dynamic Application Security Testing) but we won’t look into it today. Part of that suite is a lightweight client mobsfscan, that’s the one we’ll integrate today. From a command line, it can run through your codebase, and create a report with all vulnerabilities found. It supports Swift and Kotlin but also Java and Objective-C. It can also generate different type of reports depending of what your CI needs. Here is the kind of output { 'results': { 'android_logging': { 'files': [{ 'file_path': 'tests/assets/src/java/java_vuln.java', 'match_position': (13, 73), 'match_lines': (19, 19), 'match_string': ' Log.d(\"htbridge\", \"getAllRecords(): \" + records.toString());' }], } } } We can also go further and add rules to ignore files or filter out severity. We can setup a .mobsf configuration file at the root of the directory to drive the security scanner. --- - ignore-filenames: - skip.java ignore-paths: - __MACOSX ignore-rules: - android_kotlin_logging severity-filter: - WARNING - ERROR So we got a tool to integrate and analyze codebase for iOS and Android, let’s dive into the integration. Integration with Gitlab Mobsfscan includes a section dedicated to CI/CD integration which, in most of cases, might work for you for cloud-based solution and docker image. For self-hosted runners, it’s a different story. In my case, with Gitlab CI runner, it gets a bit more complicated. First thing first, the tool has to be installed ahead on the machine. We don’t leverage any docker image as suggested in the default integration. Since my goal is to raise awareness of security issues on the project, I need a JSON format that will be attach to future pull request. stages: - security mobsfscan: stage: security script: - mobsfscan --json --output security-report.json . artifacts: reports: sast: security-report.json So far so good. Digging further, security reports aren’t displayed for all types of Gitlab account. So we cannot leverage the same type of widget. Thankfully, there are other ways to create reports, for instance creating Code Quality report in Gitlab. It’s not the best, but would allow me to transform the security report into a code quality one to still display it for future code changes. Since the generated security report is a JSON, I can use other tooling like Ruby and fastlane, both already available in my iOS project, to make it into the right format. I simplified the code a lot, so we focus on the essential part here. module Fastlane module Actions class MobsfscanTransformAction \u003c Action def self.run(params) require 'json' require 'securerandom' # Getting input file and output destination input_file = params[:input_file] output_file = params[:output_file] # Read input json into hash raw_data = File.read(input_file) json_data = JSON.parse(raw_data) results = json_data['results'] issues = Array.new # For each risk detected for key in results.keys do item = results[key] metadata = item['metadata'] # Create issue issue = { type: \"issue\", description: metadata['description'], categories: [\"Security\"] } # Map severity if metadata['severity'] == \"WARNING\" || metadata['severity'] == \"HIGH\" then issue[\"severity\"] = \"major\" else issue[\"severity\"] = \"info\" end # Add unique fingerprint issue[\"fingerprint\"] = SecureRandom.uuid issues.push(issue) end # Create new json as output File.write(output_file, JSON.dump(issues)) end end end end This would transform our security report into a CodeClimate one, the expected format supported by Gitlab. [ { \"description\": \"This app does not have Certificate Pinning implemented in code.\", \"fingerprint\": \"7815696ecbf1c96e6894b779456d330e\", \"severity\": \"major\", \"categories\": [\"Security\"], }, { ... } ] For production usage, I would add more validations, like checking the input and output format are valid, as well as attach files location for each issue found. From there, I can run this new action from fastlane. fastlane run mobsfscan_transform input_file:security-report.json output_file:security-code-report.json Now I can update the Gitlab configuration to include this new report. stages: - security mobsfscan: stage: security script: - mobsfscan --json --output security-report.json . - fastlane run mobsfscan_transform input_file:security-report.json output_file:security-code-report.json artifacts: reports: sast: security-report.json codequality: security-code-report.json Now, we have finally publish the security report part of the code quality of the merge request and can go around the account limitation. Moving forward, any new code change request will display more information and highlight new security issues (or issues resolved) to make sure new issues aren’t introduced anymore. Drawbacks SAST isn’t foolproof but it can play a part of a broader security strategy. It can complete other tools and initiatives like advocating and training engineers to security issues, but also DAST, to automatically analyze binaries. On the other hand, SAST is based on code pattern and security vulnerabilities keep involving over the years, so we need to keep track of new patterns to stay up to date. Conclusion Making sure mobile apps are safe and secure to use should definitely be a concern for mobile engineers. It can be easy to discard those concerns and blame it on lack of tools or knowledge, but there are still plenty of resources for us to get better at it. If some sound very complex to set up or automate, mobsfscan is a simple step forward that we can include in our continuous integration pipeline to create awareness and not ignore anymore those issues. Happy coding!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n              \u003cp\u003eSecurity is a big topic in software engineering but how does it apply to mobile development? We care about user experience or mobile performance, security issues are rarely prioritized. This week, I’ll share how to integrate security tools into your CI pipeline to stay aware of your codebase health.\u003c/p\u003e\n\u003cp\u003eDisclaimer: I’m not a security expert, just security enthusiast engineer :)\u003c/p\u003e\n\u003ch2 id=\"security-in-mobile-application\"\u003eSecurity in mobile application\u003c/h2\u003e\n\u003cp\u003eIt all started earlier this year when I was exploring different tools to detect security issues into one of my mobile apps, mostly by curiosity.\u003c/p\u003e\n\u003cp\u003eBefore diving into the technical aspect, we need to understand why security is a concern in mobile development. With more and more apps available to us, mobile application is one of the entry point to your system for malicious users to exploit it. The bigger your app or your business gets, the bigger target it becomes.\u003c/p\u003e\n\u003cp\u003eFrom mobile app vulnerabilities can come data leaks, lost of money and reputations and so on.\u003c/p\u003e\n\u003cp\u003eThankfully, there are also “good guys” in the community that keep track of the vulnerabilities, sharing documentations and resources to educate engineers. OWASP Foundation is the main contributor and frequently share the \u003ca href=\"https://owasp.org/www-project-top-ten/\"\u003etop 10\u003c/a\u003e most critical risks for web and mobile applications.\u003c/p\u003e\n\u003cp\u003eIn the \u003ca href=\"https://owasp.org/www-project-mobile-top-10/\"\u003eMobile top 10\u003c/a\u003e report, we can find many risks like insecure authentication, insufficient cryptography, examples of exploits and to prevent them.\u003c/p\u003e\n\u003cp\u003eFinally, they also published a \u003ca href=\"https://owasp.org/www-project-mobile-security-testing-guide/\"\u003eMobile Security Testing Guide\u003c/a\u003e for mobile engineers to not only understand the risk, but also detect them and make sure our mobile apps stays secured.\u003c/p\u003e\n\u003cp\u003eSo now, we know why security is important, we have access to guidelines and documentations to recognize vulnerabilities and how to test them. So how we detect those issues ahead, during development for instance?\u003c/p\u003e\n\u003ch2 id=\"application-security-testing\"\u003eApplication Security Testing\u003c/h2\u003e\n\u003cp\u003eOne way to detects security issues includes Static Application Security Testing (SAST). It’s a testing methodology to analyze your source code and detect vulnerabilities based on code patterns.\u003c/p\u003e\n\u003cp\u003eIt’s pretty similar to any lint tools, like SwiftLint, but applied to security issues.\u003c/p\u003e\n\u003cp\u003eOne mobile security tool that is recommended by OWASP and free to use is \u003ca href=\"https://github.com/MobSF/Mobile-Security-Framework-MobSF\"\u003eMobSF\u003c/a\u003e. It includes whole suite of integration, including SAST for iOS and Android. It also includes DAST (Dynamic Application Security Testing) but we won’t look into it today.\u003c/p\u003e\n\u003cp\u003ePart of that suite is a lightweight client \u003ca href=\"https://github.com/MobSF/mobsfscan\"\u003emobsfscan\u003c/a\u003e, that’s the one we’ll integrate today.\u003c/p\u003e\n\u003cp\u003eFrom a command line, it can run through your codebase, and create a report with all vulnerabilities found. It supports Swift and Kotlin but also Java and Objective-C. It can also generate different type of reports depending of what your CI needs.\u003c/p\u003e\n\u003cp\u003eHere is the kind of output\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e{\n    \u0026#39;results\u0026#39;: {\n        \u0026#39;android_logging\u0026#39;: {\n            \u0026#39;files\u0026#39;: [{\n                \u0026#39;file_path\u0026#39;: \u0026#39;tests/assets/src/java/java_vuln.java\u0026#39;,\n                \u0026#39;match_position\u0026#39;: (13, 73),\n                \u0026#39;match_lines\u0026#39;: (19, 19),\n                \u0026#39;match_string\u0026#39;: \u0026#39;            Log.d(\u0026#34;htbridge\u0026#34;, \u0026#34;getAllRecords(): \u0026#34; + records.toString());\u0026#39;\n            }],\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe can also go further and add rules to ignore files or filter out severity. We can setup a \u003ccode\u003e.mobsf\u003c/code\u003e configuration file at the root of the directory to drive the security scanner.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e---\n- ignore-filenames:\n  - skip.java\n\n  ignore-paths:\n  - __MACOSX\n\n  ignore-rules:\n  - android_kotlin_logging\n\n  severity-filter:\n  - WARNING\n  - ERROR\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo we got a tool to integrate and analyze codebase for iOS and Android, let’s dive into the integration.\u003c/p\u003e\n\u003ch2 id=\"integration-with-gitlab\"\u003eIntegration with Gitlab\u003c/h2\u003e\n\u003cp\u003eMobsfscan includes a section dedicated to \u003ca href=\"https://github.com/MobSF/mobsfscan#cicd-integrations\"\u003eCI/CD integration\u003c/a\u003e which, in most of cases, might work for you for cloud-based solution and docker image.\u003c/p\u003e\n\u003cp\u003eFor self-hosted runners, it’s a different story. In my case, with Gitlab CI runner, it gets a bit more complicated.\u003c/p\u003e\n\u003cp\u003eFirst thing first, the tool has to be installed ahead on the machine. We don’t leverage any docker image as suggested in the default integration.\u003c/p\u003e\n\u003cp\u003eSince my goal is to raise awareness of security issues on the project, I need a JSON format that will be attach to future pull request.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estages\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    - \u003cspan\u003esecurity\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emobsfscan\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estage\u003c/span\u003e: \u003cspan\u003esecurity\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003escript\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        - \u003cspan\u003emobsfscan --json --output security-report.json .\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eartifacts\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereports\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003esast\u003c/span\u003e: \u003cspan\u003esecurity-report.json\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cem\u003eSo far so good.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eDigging further, \u003ca href=\"https://docs.gitlab.com/ee/user/application_security/sast/index.html\"\u003esecurity reports\u003c/a\u003e aren’t displayed for all types of Gitlab account. So we cannot leverage the same type of widget.\u003c/p\u003e\n\u003cp\u003eThankfully, there are other ways to create reports, for instance creating \u003ca href=\"https://docs.gitlab.com/ee/user/application_security/sast/index.html\"\u003eCode Quality\u003c/a\u003e report in Gitlab. It’s not the best, but would allow me to \u003cem\u003etransform\u003c/em\u003e the security report into a code quality one to still display it for future code changes.\u003c/p\u003e\n\u003cp\u003eSince the generated security report is a JSON, I can use other tooling like Ruby and fastlane, both already available in my iOS project, to make it into the right format.\u003c/p\u003e\n\u003cp\u003eI simplified the code a lot, so we focus on the essential part here.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"ruby\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emodule\u003c/span\u003e \u003cspan\u003eFastlane\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003emodule\u003c/span\u003e \u003cspan\u003eActions\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMobsfscanTransformAction\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eAction\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erun\u003c/span\u003e(\u003cspan\u003eparams\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003erequire\u003c/span\u003e \u003cspan\u003e\u0026#39;json\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003erequire\u003c/span\u003e \u003cspan\u003e\u0026#39;securerandom\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e# Getting input file and output destination\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003einput_file\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eparams\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:input_file\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eoutput_file\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eparams\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:output_file\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e# Read input json into hash\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eraw_data\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eFile\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eread\u003c/span\u003e(\u003cspan\u003einput_file\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ejson_data\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eJSON\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eparse\u003c/span\u003e(\u003cspan\u003eraw_data\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eresults\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ejson_data\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;results\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eissues\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eArray\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e# For each risk detected\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003ekey\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eresults\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ekeys\u003c/span\u003e \u003cspan\u003edo\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eresults\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003emetadata\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;metadata\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003e# Create issue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eissue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003etype\u003c/span\u003e: \u003cspan\u003e\u0026#34;issue\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003edescription\u003c/span\u003e: \u003cspan\u003emetadata\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;description\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ecategories\u003c/span\u003e: \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#34;Security\u0026#34;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003e# Map severity\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003emetadata\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;severity\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;WARNING\u0026#34;\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003emetadata\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;severity\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;HIGH\u0026#34;\u003c/span\u003e \u003cspan\u003ethen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eissue\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#34;severity\u0026#34;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;major\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eelse\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eissue\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#34;severity\u0026#34;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;info\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003e# Add unique fingerprint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eissue\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#34;fingerprint\u0026#34;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eSecureRandom\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003euuid\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eissues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epush\u003c/span\u003e(\u003cspan\u003eissue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e# Create new json as output\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eFile\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewrite\u003c/span\u003e(\u003cspan\u003eoutput_file\u003c/span\u003e, \u003cspan\u003eJSON\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edump\u003c/span\u003e(\u003cspan\u003eissues\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis would transform our security report into a CodeClimate one, the expected format supported by \u003ca href=\"https://docs.gitlab.com/ee/ci/testing/code_quality.html#implementing-a-custom-tool\"\u003eGitlab\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"json\"\u003e\u003cspan\u003e\u003cspan\u003e[\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e\u0026#34;description\u0026#34;\u003c/span\u003e: \u003cspan\u003e\u0026#34;This app does not have Certificate Pinning implemented in code.\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e\u0026#34;fingerprint\u0026#34;\u003c/span\u003e: \u003cspan\u003e\u0026#34;7815696ecbf1c96e6894b779456d330e\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e\u0026#34;severity\u0026#34;\u003c/span\u003e: \u003cspan\u003e\u0026#34;major\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e\u0026#34;categories\u0026#34;\u003c/span\u003e: [\u003cspan\u003e\u0026#34;Security\u0026#34;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  },\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  { \u003cspan\u003e...\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFor production usage, I would add more validations, like checking the input and output format are valid, as well as attach files location for each issue found.\u003c/p\u003e\n\u003cp\u003eFrom there, I can run this new action from fastlane.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"sh\"\u003e\u003cspan\u003e\u003cspan\u003efastlane run mobsfscan_transform input_file:security-report.json output_file:security-code-report.json\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow I can update the Gitlab configuration to include this new report.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estages\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    - \u003cspan\u003esecurity\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emobsfscan\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estage\u003c/span\u003e: \u003cspan\u003esecurity\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003escript\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        - \u003cspan\u003emobsfscan --json --output security-report.json .\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        - \u003cspan\u003efastlane run mobsfscan_transform input_file:security-report.json output_file:security-code-report.json\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eartifacts\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereports\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003esast\u003c/span\u003e: \u003cspan\u003esecurity-report.json\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ecodequality\u003c/span\u003e: \u003cspan\u003esecurity-code-report.json\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow, we have finally publish the security report part of the code quality of the merge request and can go around the account limitation.\u003c/p\u003e\n\u003cp\u003eMoving forward, any new code change request will display more information and highlight new security issues (or issues resolved) to make sure new issues aren’t introduced anymore.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2022/07/mobsfscan-gitlab.png\" alt=\"mobsfscan-gitlab\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"drawbacks\"\u003eDrawbacks\u003c/h2\u003e\n\u003cp\u003eSAST isn’t foolproof but it can play a part of a broader security strategy. It can complete other tools and initiatives like advocating and training engineers to security issues, but also DAST, to automatically analyze binaries.\u003c/p\u003e\n\u003cp\u003eOn the other hand, SAST is based on code pattern and security vulnerabilities keep involving over the years, so we need to keep track of new patterns to stay up to date.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eMaking sure mobile apps are safe and secure to use should definitely be a concern for mobile engineers. It can be easy to discard those concerns and blame it on lack of tools or knowledge, but there are still plenty of resources for us to get better at it.\u003c/p\u003e\n\u003cp\u003eIf some sound very complex to set up or automate, mobsfscan is a simple step forward that we can include in our continuous integration pipeline to create awareness and not ignore anymore those issues.\u003c/p\u003e\n\u003cp\u003eHappy coding!\u003c/p\u003e\n              \n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2022-07-31T06:00:00Z",
  "modifiedTime": "2022-07-31T06:00:00Z"
}
