{
  "id": "ba9855c1-a48a-4156-b126-aff1eef9c530",
  "title": "Migrating XCTest to Swift Testing",
  "link": "https://useyourloaf.com/blog/migrating-xctest-to-swift-testing/",
  "description": "A quick guide to migrating XCTest unit tests to Swift Testing. What is Swift Testing? Swift Testing is an open-source testing framework designed for Swift. Apple introduced it at WWDC24 and shipped it with Xcode 16. Swift Testing uses modern features like concurrency and macros. It supports Windows and Linux as well as Apple’s platforms. Do I Need To Migrate? No. The XCTest framework is not deprecated, There’s no urgent reason to migrate your tests unless you want to. You cannot migrate UI Automation tests or performance (XCTMetric) tests as they are not supported by Swift Testing. I’m finding that I prefer writing tests with Swift Testing over XCTest (see below for some of the reasons). I started adding new tests with Swift Testing to XCTest unit test source files but at a certain point I want to migrate all the tests in a source file to Swift Testing. These are my notes on that process. Getting Started You can mix XCTest and Swift Testing unit tests in a test target. You can even mix both types of test in the same source file. That make it possible to add new tests with Swift Testing and migrate your XCTests over time. Do not mix testing frameworks within a test. Do not call XCTAssert from a Swift Testing test or a Swift Testing macro like #expect or #require from XCTests. Import Swift Testing To get started import the Swift Testing framework: import Testing Apple warns that you should only import the testing library into a test target. Importing into an application or library target is not supported. Grouping Tests You group Swift Testing unit tests by adding them to a type (struct or class). Xcode organises your tests based on your chosen grouping in the Test Navigator. Unlike XCTest which requires you subclass XCTestCase, Swift Testing can use a struct, class or actor. Apple recommends you start with a struct unless you need a deinit for cleanup (see below). // XCTest import XCTest class StoreXCTests: XCTestCase { } // Swift Testing import Testing struct StoreTests { } Swift Testing creates a new instance of the StoreTests type for each unit test it runs. You’re not forced to organise Swift Testing tests in a type. For example, Apple recommends you convert an XCTestCase subclass with a single test to a global function. Test Setup and Teardown Swift Testing uses the types init (and deinit for class) methods to setup and teardown tests. I find this a big improvement over the XCTest approach of overriding one of the many setUp and tearDown methods. The init can be async or throwing as needed: // XCTest import XCTest class StoreXCTests: XCTestCase { let store: DataStore! override func setupWithError() throws { store = try DataStore(inMemory: true) } } // Swift Testing import Testing struct StoreTests { let store: DataStore init() throws { store = try DataStore(inMemory: true) } } For convenience I was using a forced unwrapped optional for the stored property in my XCTest. Using the normal Swift init method for my test type removes the need for that. As I mentioned above if you need to cleanup after the test runs, use a class and add the cleanup code to the deinit: // Swift Testing import Testing class StoreTests { let store: DataStore init() throws { store = try DataStore(inMemory: true) } deinit { store.reset() } } Creating Tests A Swift Testing test is a normal Swift method. It can be a standalone global function or one of many methods organised into a Swift struct, class, or actor. A method becomes a unit test when you add the @Test macro: // XCTest func testStoreIsReady() { } // Swift Testing @Test func storeIsReady() { } As with XCTest, you can mark test methods with async or throws and isolate them to an actor as needed. Unlike with XCTest, you don’t need to prefix your test method name with “test”. The @Test attribute is a macro so you can expand it to see the implementation if you wish. XCTest uses multiple Simulator instances to run tests in parallel. It doesn’t support running tests in-parallel on device. Swift Testing runs tests in-process using Swift Concurrency so it can run tests in-parallel on physical devices. Asserting with #expect and #require. For me, the biggest improvement over XCTest is replacing the forty odd variations of XCTAssert with the #expect and #require macros. The #expect macro accepts a Swift expression that you expect to be true. When the expression is false the #expect macro logs the failed expectation and the test continues: @Test func storeIsReady() { #expect(store.isReady) #expect(store.error == nil) } The error messages are generally more informative than the equivalent XCTest failure: Clicking the red cross in the error message and then the Show button expands the values in the expression which I find is sometimes more readable: It took me a little while to get used to but I prefer the flexibility of being able to use any Swift expression for the #expect rather than trying to remember which version of XCTAssert I need: // XCTest XCTAssertTrue(store.isReady) XCTAssertFalse(store.isReady) XCTAssertNil(store.error) XCTAssertNotNil(store.error) XCTAssertEqual(items.count, 5) // Swift Testing #expect(store.isReady) #expect(!store.isReady) #expect(store.error == nil) #expect(store.error != nil) #expect(items.count == 5) Unwrapping with #require The second expectation macro is #require. This is throwing version of #expect that stops the test execution on error. A common usage is to replace XCTUnwrap when unwrapping an optional. If the optional is nil the test stops: // XCTest func testCreateItem() throws { // createItem returns an Item? let item = try XCTUnwrap(store.createItem()) XCTAssertEqual(item.title == \"New item\") } // Swift Testing @Test func createItem() throws { // createItem returns an Item? let item = try #require(store.createItem()) #expect(item.title == \"New item\") } Replacing XCTFail Sometimes you need to cause a test to fail without evaluating a condition. For example, when certain cases in a switch are test failures. The XCTest framework has XCTFail for this. The Swift Testing equivalent is Issue.record: // Swift Testing @Test func storeReady() { switch store.state { case .failed: Issue.record(\"Expected ready, got failed\") case .loading: Issue.record(\"Expected ready, got loading\") case .ready: #expect(store.error == nil) } } Wrapping Up There’s a lot more you can do to customize tests, control when and how they run, handle async code, and organize with tags and test suites. I’ll save those topics for future posts. In the meantime, I recommend browsing the Apple article linked below for more details on migrating from XCTest. Learn More WWDC24 Meet Swift Testing Apple Article: Migrating a test from XCTest Migrating XCTest to Swift Testing was originally posted 09 Dec 2024 on useyourloaf.com. Want this direct to your inbox? Sign up and get my free WWDC viewing guide PDF.",
  "author": "",
  "published": "Mon, 09 Dec 2024 10:59:14 +0000",
  "source": "https://useyourloaf.com/blog/rss.xml",
  "categories": null,
  "byline": "",
  "length": 6770,
  "excerpt": "A quick guide to migrating XCTest unit test to Swift Testing.",
  "siteName": "Use Your Loaf - iOS Development News \u0026 Tips",
  "favicon": "https://useyourloaf.com/apple-touch-icon.png",
  "text": "A quick guide to migrating XCTest unit tests to Swift Testing. What is Swift Testing? Swift Testing is an open-source testing framework designed for Swift. Apple introduced it at WWDC24 and shipped it with Xcode 16. Swift Testing uses modern features like concurrency and macros. It supports Windows and Linux as well as Apple’s platforms. Do I Need To Migrate? No. The XCTest framework is not deprecated, There’s no urgent reason to migrate your tests unless you want to. You cannot migrate UI Automation tests or performance (XCTMetric) tests as they are not supported by Swift Testing. I’m finding that I prefer writing tests with Swift Testing over XCTest (see below for some of the reasons). I started adding new tests with Swift Testing to XCTest unit test source files but at a certain point I want to migrate all the tests in a source file to Swift Testing. These are my notes on that process. Getting Started You can mix XCTest and Swift Testing unit tests in a test target. You can even mix both types of test in the same source file. That make it possible to add new tests with Swift Testing and migrate your XCTests over time. Do not mix testing frameworks within a test. Do not call XCTAssert from a Swift Testing test or a Swift Testing macro like #expect or #require from XCTests. Import Swift Testing To get started import the Swift Testing framework: Apple warns that you should only import the testing library into a test target. Importing into an application or library target is not supported. Grouping Tests You group Swift Testing unit tests by adding them to a type (struct or class). Xcode organises your tests based on your chosen grouping in the Test Navigator. Unlike XCTest which requires you subclass XCTestCase, Swift Testing can use a struct, class or actor. Apple recommends you start with a struct unless you need a deinit for cleanup (see below). // XCTest import XCTest class StoreXCTests: XCTestCase { } // Swift Testing import Testing struct StoreTests { } Swift Testing creates a new instance of the StoreTests type for each unit test it runs. You’re not forced to organise Swift Testing tests in a type. For example, Apple recommends you convert an XCTestCase subclass with a single test to a global function. Test Setup and Teardown Swift Testing uses the types init (and deinit for class) methods to setup and teardown tests. I find this a big improvement over the XCTest approach of overriding one of the many setUp and tearDown methods. The init can be async or throwing as needed: // XCTest import XCTest class StoreXCTests: XCTestCase { let store: DataStore! override func setupWithError() throws { store = try DataStore(inMemory: true) } } // Swift Testing import Testing struct StoreTests { let store: DataStore init() throws { store = try DataStore(inMemory: true) } } For convenience I was using a forced unwrapped optional for the stored property in my XCTest. Using the normal Swift init method for my test type removes the need for that. As I mentioned above if you need to cleanup after the test runs, use a class and add the cleanup code to the deinit: // Swift Testing import Testing class StoreTests { let store: DataStore init() throws { store = try DataStore(inMemory: true) } deinit { store.reset() } } Creating Tests A Swift Testing test is a normal Swift method. It can be a standalone global function or one of many methods organised into a Swift struct, class, or actor. A method becomes a unit test when you add the @Test macro: // XCTest func testStoreIsReady() { } // Swift Testing @Test func storeIsReady() { } As with XCTest, you can mark test methods with async or throws and isolate them to an actor as needed. Unlike with XCTest, you don’t need to prefix your test method name with “test”. The @Test attribute is a macro so you can expand it to see the implementation if you wish. XCTest uses multiple Simulator instances to run tests in parallel. It doesn’t support running tests in-parallel on device. Swift Testing runs tests in-process using Swift Concurrency so it can run tests in-parallel on physical devices. Asserting with #expect and #require. For me, the biggest improvement over XCTest is replacing the forty odd variations of XCTAssert with the #expect and #require macros. The #expect macro accepts a Swift expression that you expect to be true. When the expression is false the #expect macro logs the failed expectation and the test continues: @Test func storeIsReady() { #expect(store.isReady) #expect(store.error == nil) } The error messages are generally more informative than the equivalent XCTest failure: Clicking the red cross in the error message and then the Show button expands the values in the expression which I find is sometimes more readable: It took me a little while to get used to but I prefer the flexibility of being able to use any Swift expression for the #expect rather than trying to remember which version of XCTAssert I need: // XCTest XCTAssertTrue(store.isReady) XCTAssertFalse(store.isReady) XCTAssertNil(store.error) XCTAssertNotNil(store.error) XCTAssertEqual(items.count, 5) // Swift Testing #expect(store.isReady) #expect(!store.isReady) #expect(store.error == nil) #expect(store.error != nil) #expect(items.count == 5) Unwrapping with #require The second expectation macro is #require. This is throwing version of #expect that stops the test execution on error. A common usage is to replace XCTUnwrap when unwrapping an optional. If the optional is nil the test stops: // XCTest func testCreateItem() throws { // createItem returns an Item? let item = try XCTUnwrap(store.createItem()) XCTAssertEqual(item.title == \"New item\") } // Swift Testing @Test func createItem() throws { // createItem returns an Item? let item = try #require(store.createItem()) #expect(item.title == \"New item\") } Replacing XCTFail Sometimes you need to cause a test to fail without evaluating a condition. For example, when certain cases in a switch are test failures. The XCTest framework has XCTFail for this. The Swift Testing equivalent is Issue.record: // Swift Testing @Test func storeReady() { switch store.state { case .failed: Issue.record(\"Expected ready, got failed\") case .loading: Issue.record(\"Expected ready, got loading\") case .ready: #expect(store.error == nil) } } Wrapping Up There’s a lot more you can do to customize tests, control when and how they run, handle async code, and organize with tags and test suites. I’ll save those topics for future posts. In the meantime, I recommend browsing the Apple article linked below for more details on migrating from XCTest. Learn More WWDC24 Meet Swift Testing Apple Article: Migrating a test from XCTest",
  "image": "https://useyourloaf.com/blog/migrating-xctest-to-swift-testing/cover.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eA quick guide to migrating XCTest unit tests to Swift Testing.\u003c/p\u003e\n\u003ch3 id=\"what-is-swift-testing\"\u003eWhat is Swift Testing?\u003c/h3\u003e\n\u003cp\u003eSwift Testing is an \u003ca href=\"https://github.com/swiftlang/swift-testing\"\u003eopen-source\u003c/a\u003e testing framework designed for Swift. Apple introduced it at WWDC24 and shipped it with Xcode 16. Swift Testing uses modern features like concurrency and macros. It supports Windows and Linux as well as Apple’s platforms.\u003c/p\u003e\n\u003ch3 id=\"do-i-need-to-migrate\"\u003eDo I Need To Migrate?\u003c/h3\u003e\n\u003cp\u003eNo. The XCTest framework is \u003cstrong\u003enot\u003c/strong\u003e deprecated, There’s no urgent reason to migrate your tests unless you want to. \u003cstrong\u003eYou cannot migrate UI Automation tests or performance (XCTMetric) tests as they are not supported by Swift Testing\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eI’m finding that I prefer writing tests with Swift Testing over XCTest (see below for some of the reasons). I started adding new tests with Swift Testing to XCTest unit test source files but at a certain point I want to migrate all the tests in a source file to Swift Testing. These are my notes on that process.\u003c/p\u003e\n\u003ch3 id=\"getting-started\"\u003eGetting Started\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eYou can mix XCTest and Swift Testing unit tests in a test target.\u003c/strong\u003e You can even mix both types of test in the same source file. That make it possible to add new tests with Swift Testing and migrate your XCTests over time.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDo not mix testing frameworks within a test.\u003c/strong\u003e Do not call XCTAssert from a Swift Testing test or a Swift Testing macro like #expect or #require from XCTests.\u003c/p\u003e\n\u003ch3 id=\"import-swift-testing\"\u003eImport Swift Testing\u003c/h3\u003e\n\u003cp\u003eTo get started import the Swift Testing framework:\u003c/p\u003e\n\u003cp\u003eApple warns that you should only import the testing library into a test target. Importing into an application or library target is not supported.\u003c/p\u003e\n\u003ch3 id=\"grouping-tests\"\u003eGrouping Tests\u003c/h3\u003e\n\u003cp\u003eYou group Swift Testing unit tests by adding them to a type (struct or class). Xcode organises your tests based on your chosen grouping in the Test Navigator.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUnlike XCTest which requires you subclass XCTestCase, Swift Testing can use a struct, class or actor.\u003c/strong\u003e Apple recommends you start with a struct unless you need a deinit for cleanup (see below).\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// XCTest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eXCTest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eStoreXCTests\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eXCTestCase\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Swift Testing\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eTesting\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eStoreTests\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eSwift Testing creates a new instance of the StoreTests type for each unit test it runs.\u003c/strong\u003e You’re not forced to organise Swift Testing tests in a type. For example, Apple recommends you convert an XCTestCase subclass with a single test to a global function.\u003c/p\u003e\n\u003ch3 id=\"test-setup-and-teardown\"\u003eTest Setup and Teardown\u003c/h3\u003e\n\u003cp\u003eSwift Testing uses the types init (and deinit for class) methods to setup and teardown tests. I find this a big improvement over the XCTest approach of overriding one of the many \u003ca href=\"https://useyourloaf.com/blog/unit-test-setup-and-teardown/\"\u003esetUp and tearDown\u003c/a\u003e methods. The init can be async or throwing as needed:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// XCTest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eXCTest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eStoreXCTests\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eXCTestCase\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDataStore\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esetupWithError\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estore\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003eDataStore\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003einMemory\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Swift Testing\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eTesting\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eStoreTests\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDataStore\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estore\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003eDataStore\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003einMemory\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFor convenience I was using a forced unwrapped optional for the stored property in my XCTest. Using the normal Swift init method for my test type removes the need for that. As I mentioned above if you need to cleanup after the test runs, use a class and add the cleanup code to the deinit:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Swift Testing\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eTesting\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eStoreTests\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDataStore\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estore\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003eDataStore\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003einMemory\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003edeinit\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ereset\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"creating-tests\"\u003eCreating Tests\u003c/h3\u003e\n\u003cp\u003eA Swift Testing test is a normal Swift method. It can be a standalone global function or one of many methods organised into a Swift struct, class, or actor. \u003cstrong\u003eA method becomes a unit test when you add the @Test macro:\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// XCTest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etestStoreIsReady\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// Swift Testing\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eTest\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003estoreIsReady\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAs with XCTest, you can mark test methods with async or throws and isolate them to an actor as needed. \u003cstrong\u003eUnlike with XCTest, you don’t need to prefix your test method name with “test”.\u003c/strong\u003e The @Test attribute is a macro so you can expand it to see the implementation if you wish.\u003c/p\u003e\n\u003cp\u003eXCTest uses multiple Simulator instances to run tests in parallel. It doesn’t support running tests in-parallel on device. Swift Testing runs tests in-process using Swift Concurrency so it can \u003cstrong\u003erun tests in-parallel on physical devices\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"asserting-with-expect-and-require\"\u003eAsserting with #expect and #require.\u003c/h3\u003e\n\u003cp\u003eFor me, the biggest improvement over XCTest is \u003cstrong\u003ereplacing the forty odd variations of XCTAssert with the #expect and #require macros\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eThe #expect macro accepts a Swift expression that you expect to be true. When the expression is false the #expect macro logs the failed expectation and the test continues:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eTest\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003estoreIsReady\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisReady\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003enil\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe error messages are generally more informative than the equivalent XCTest failure:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/migrating-xctest-to-swift-testing/001.png\" alt=\"Expectation failed red error message\" width=\"600\" height=\"30\" srcset=\"https://useyourloaf.com/blog/migrating-xctest-to-swift-testing/001@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eClicking the red cross in the error message and then the Show button expands the values in the expression which I find is sometimes more readable:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/migrating-xctest-to-swift-testing/002.png\" alt=\"Expanded test result showing isReady is false\" width=\"393\" height=\"210\" srcset=\"https://useyourloaf.com/blog/migrating-xctest-to-swift-testing/002@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eIt took me a little while to get used to but I prefer the flexibility of being able to use any Swift expression for the #expect rather than trying to remember which version of XCTAssert I need:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// XCTest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eXCTAssertTrue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisReady\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eXCTAssertFalse\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisReady\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eXCTAssertNil\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eXCTAssertNotNil\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eXCTAssertEqual\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eitems\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Swift Testing\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisReady\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisReady\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003enil\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003enil\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eitems\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"unwrapping-with-require\"\u003eUnwrapping with #require\u003c/h3\u003e\n\u003cp\u003eThe second expectation macro is #require. This is throwing version of #expect that stops the test execution on error. A common usage is to \u003cstrong\u003ereplace XCTUnwrap when unwrapping an optional\u003c/strong\u003e. If the optional is nil the test stops:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// XCTest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etestCreateItem\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// createItem returns an Item?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003eXCTUnwrap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecreateItem\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eXCTAssertEqual\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;New item\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Swift Testing\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eTest\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ecreateItem\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// createItem returns an Item?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003erequire\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecreateItem\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;New item\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"replacing-xctfail\"\u003eReplacing XCTFail\u003c/h3\u003e\n\u003cp\u003eSometimes you need to cause a test to fail without evaluating a condition. For example, when certain cases in a switch are test failures. The XCTest framework has XCTFail for this. The Swift Testing equivalent is Issue.record:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Swift Testing\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eTest\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003estoreReady\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eswitch\u003c/span\u003e \u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estate\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efailed\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eIssue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erecord\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Expected ready, got failed\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eloading\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eIssue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erecord\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Expected ready, got loading\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eready\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003enil\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"wrapping-up\"\u003eWrapping Up\u003c/h3\u003e\n\u003cp\u003eThere’s a lot more you can do to customize tests, control when and how they run, handle async code, and organize with tags and test suites. I’ll save those topics for future posts. In the meantime, I recommend browsing the Apple article linked below for more details on migrating from XCTest.\u003c/p\u003e\n\u003ch3 id=\"learn-more\"\u003eLearn More\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.apple.com/videos/play/wwdc2024/10179\"\u003eWWDC24 Meet Swift Testing\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.apple.com/documentation/testing/migratingfromxctest\"\u003eApple Article: Migrating a test from XCTest\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-12-09T10:59:14Z",
  "modifiedTime": "2024-12-10T14:23:16Z"
}
