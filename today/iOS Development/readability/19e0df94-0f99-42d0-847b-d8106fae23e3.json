{
  "id": "19e0df94-0f99-42d0-847b-d8106fae23e3",
  "title": "Combining opaque return types with primary associated types",
  "link": "https://www.swiftbysundell.com/articles/opaque-return-types-primary-associated-types",
  "description": "How Swift’s opaque return types can be combined with primary associated types in order to create powerful abstractions without the need for any type erasure.",
  "author": "",
  "published": "Sat, 12 Nov 2022 13:50:00 +0100",
  "source": "https://www.swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 9146,
  "excerpt": "How Swift’s opaque return types can be combined with primary associated types in order to create powerful abstractions without the need for any type erasure.",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "Ever since Swift was first introduced, it’s been very common to need to use type erasure when working with generic protocols — ones that either reference Self within their requirements, or make use of associated types.For example, in earlier versions of Swift, when using Apple’s Combine framework for reactive programming, every time we wanted to return a Publisher from a function or computed property, we had to first type-erase it by wrapping it within an AnyPublisher — like this:struct UserLoader { var urlSession = URLSession.shared var decoder = JSONDecoder() func loadUser(withID id: User.ID) -\u003e AnyPublisher\u003cUser, Error\u003e { urlSession .dataTaskPublisher(for: urlForLoadingUser(withID: id)) .map(\\.data) .decode(type: User.self, decoder: decoder) .eraseToAnyPublisher() } private func urlForLoadingUser(withID id: User.ID) -\u003e URL { ... } }The reason type erasure had to be used in situations like that is because simply declaring that our method returns something that conforms to the Publisher protocol wouldn’t give the compiler any information as to what kind of output or errors that the publisher emits.Of course, an alternative to type erasure would be to declare the actual, concrete type that the above method returns. But when using frameworks that rely heavily on generics (such as Combine and SwiftUI), we very often end up with really complex nested types that would be very cumbersome to declare manually.This is a problem that was partially addressed in Swift 5.1, which introduced the some keyword and the concept of opaque return types, which are very often used when building views using SwiftUI — as they let us leverage the compiler to infer what concrete View-conforming type that’s returned from a given view’s body:struct ArticleView: View { var article: Article var body: some View { ScrollView { VStack(alignment: .leading) { Text(article.title).font(.title) Text(article.text) } .padding() } } }While the above way of using the some keyword works great in the context of SwiftUI, when we’re essentially just passing a given value into the framework itself (after all, we’re never expected to access the body property ourselves), it wouldn’t work that well when defining APIs for our own use.For example, replacing the AnyPublisher return type with some Publisher (and removing the call to eraseToAnyPublisher) within our UserLoader from before would technically work in isolation, but would also make each call site unaware of what type of output that our publisher produces — as we’d be dealing with a completely opaque Publisher type that can’t access any of the protocol’s associated types:struct UserLoader { ... func loadUser(withID id: User.ID) -\u003e some Publisher { urlSession .dataTaskPublisher(for: urlForLoadingUser(withID: id)) .map(\\.data) .decode(type: User.self, decoder: decoder) } ... } UserLoader() .loadUser(withID: userID) .sink(receiveCompletion: { completion in ... }, receiveValue: { output in // We have no way of getting a compile-time guarantee // that the output argument here is in fact a User // value, so we'd have to use force-casting to turn // that argument into the right type: let user = output as! User ... }) .store(in: \u0026cancellables)This is where Swift 5.7’s introduction of primary associated types comes in. If we take a look at the declaration of Combine’s Publisher protocol, we can see that it’s been updated to take advantage of this feature by declaring that its associated Output and Failure types are primary (by putting them in angle brackets right after the protocol’s name):protocol Publisher\u003cOutput, Failure\u003e { associatedtype Output associatedtype Failure: Error ... }That in turn enables us to use the some keyword in a brand new way — by declaring what exact types that our return value will use for each of the protocol’s primary associated types. So if we first update our UserLoader to use that new feature:struct UserLoader { ... func loadUser(withID id: User.ID) -\u003e some Publisher\u003cUser, Error\u003e { urlSession .dataTaskPublisher(for: urlForLoadingUser(withID: id)) .map(\\.data) .decode(type: User.self, decoder: decoder) } ... }Then we’ll no longer be required to use force-casting at each call site — all while also avoiding any kind of manual type erasure, as the compiler will now retain full type safety all the way from our loadUser method to each of its call sites:UserLoader() .loadUser(withID: userID) .sink(receiveCompletion: { completion in ... }, receiveValue: { user in // We're now getting a properly typed User // value passed into this closure. ... }) .store(in: \u0026cancellables)Of course, since primary associated types isn’t just a Combine-specific thing, but rather a proper Swift feature, we can also use the above pattern when working with our own generic protocols as well.For example, let’s say that we’ve defined a Loadable protocol that lets us abstract different ways of loading a given value behind a single, unified interface (this time using Swift concurrency):protocol Loadable\u003cValue\u003e { associatedtype Value func load() async throws -\u003e Value } struct NetworkLoadable\u003cValue: Decodable\u003e: Loadable { var url: URL func load() async throws -\u003e Value { // Load the value over the network ... } } struct DatabaseLoadable\u003cValue: Identifiable\u003e: Loadable { var id: Value.ID func load() async throws -\u003e Value { // Load the value from the app's local database ... } }A big benefit of using a pattern like that is that it enables us to very neatly separate concerns, as each call site doesn’t have to be aware of exactly how a given value is loaded — we can simply return some Loadable from a given function, and thanks to our primary associated type, we get full type safety without having to reveal what underlying type that’s used to perform the actual loading:func loadableForArticle(withID id: Article.ID) -\u003e some Loadable\u003cArticle\u003e { let url = urlForLoadingArticle(withID: id) return NetworkLoadable(url: url) }However, one important limitation of opaque return types is that the compiler requires all code paths within a scope that returns an opaque type to always return the exact same type. So, if we wanted to dynamically switch between two different Loadable implementations, then we’d get a compiler error if we tried to keep using the some keyword like we did above:// Error: Function declares an opaque return type 'some Loadable\u003cArticle\u003e', // but the return statements in its body do not have matching underlying types. func loadableForArticle(withID id: Article.ID) -\u003e some Loadable\u003cArticle\u003e { if useLocalData { return DatabaseLoadable(id: id) } let url = urlForLoadingArticle(withID: id) return NetworkLoadable(url: url) }One way to solve the above problem would be to use the good old fashioned approach of introducing a type-erasing AnyLoadable type, which we could use to wrap both of our underlying Loadable instances — but at this point, that does arguably feel like a step backwards, since we’d have to write that type-erased wrapper manually. Or do we?It turns out that we can, in fact, keep leveraging the compiler even in these kinds of more dynamic situations — all that we have to do is replace the some keyword with Swift’s new any keyword, and the compiler will actually perform all of the required type erasure on our behalf:func loadableForArticle(withID id: Article.ID) -\u003e any Loadable\u003cArticle\u003e { if useLocalData { return DatabaseLoadable(id: id) } let url = urlForLoadingArticle(withID: id) return NetworkLoadable(url: url) }Just like when using some in combination with primary associated types, using any retains full type-safety, and still enables us to use all available Loadable APIs, and maintain complete awareness that the returned instance loads Article values. Neat!It’s important to point out, though, that using the any keyword in the above kind of way turns our method’s return value into a so-called existential, which does come with a certain performance overhead, and might also prevent us from using certain generic APIs. For example, if we were to use the any keyword within the earlier Combine-based example, then we’d be locked out of applying any kind of operators (like map or flatMap) on the returned publisher. So, when possible, it’s definitely preferable to use the some keyword instead.I hope that you found this article useful. If you want to learn more about some and any, then check out my earlier article about those keywords, which focuses on how they can be used when declaring properties and parameter types. And if you have any questions, comments, or feedback, then feel free to reach out.Thanks for reading!",
  "image": "https://www.swiftbysundell.com/images/articles/opaque-return-types-primary-associated-types.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eEver since Swift was first introduced, it’s been very common to need to use \u003ca href=\"https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift\"\u003etype erasure\u003c/a\u003e when working with generic protocols — ones that either reference \u003ccode\u003eSelf\u003c/code\u003e within their requirements, or make use of associated types.\u003c/p\u003e\u003cp\u003eFor example, in earlier versions of Swift, when using Apple’s \u003ca href=\"https://www.swiftbysundell.com/discover/combine\"\u003eCombine framework\u003c/a\u003e for reactive programming, every time we wanted to return a \u003ccode\u003ePublisher\u003c/code\u003e from a function or computed property, we had to first type-erase it by wrapping it within an \u003ccode\u003eAnyPublisher\u003c/code\u003e — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e UserLoader {\n    \u003cspan\u003evar\u003c/span\u003e urlSession = \u003cspan\u003eURLSession\u003c/span\u003e.\u003cspan\u003eshared\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e decoder = \u003cspan\u003eJSONDecoder\u003c/span\u003e()\n\n    \u003cspan\u003efunc\u003c/span\u003e loadUser(withID id: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) -\u0026gt; \u003cspan\u003e\u003cspan\u003eAnyPublisher\u003c/span\u003e\u0026lt;\u003cspan\u003eUser\u003c/span\u003e, \u003cspan\u003eError\u003c/span\u003e\u0026gt;\u003c/span\u003e {\n        urlSession\n            .\u003cspan\u003edataTaskPublisher\u003c/span\u003e(for: \u003cspan\u003eurlForLoadingUser\u003c/span\u003e(withID: id))\n            .\u003cspan\u003emap\u003c/span\u003e(\\.\u003cspan\u003edata\u003c/span\u003e)\n            .\u003cspan\u003edecode\u003c/span\u003e(type: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e, decoder: decoder)\n            \u003cspan\u003e.\u003cspan\u003eeraseToAnyPublisher\u003c/span\u003e()\u003c/span\u003e\n    }\n\n    \u003cspan\u003eprivate func\u003c/span\u003e urlForLoadingUser(withID id: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) -\u0026gt; \u003cspan\u003eURL\u003c/span\u003e {\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe reason type erasure had to be used in situations like that is because simply declaring that our method returns something that conforms to the \u003ccode\u003ePublisher\u003c/code\u003e protocol wouldn’t give the compiler any information as to what kind of output or errors that the publisher emits.\u003c/p\u003e\u003cp\u003eOf course, an alternative to type erasure would be to declare the actual, concrete type that the above method returns. But when using frameworks that rely heavily on generics (such as Combine and SwiftUI), we very often end up with really complex nested types that would be very cumbersome to declare manually.\u003c/p\u003e\u003cp\u003eThis is a problem that was partially addressed in Swift 5.1, which introduced the \u003ccode\u003esome\u003c/code\u003e keyword and the concept of \u003cem\u003e\u003ca href=\"https://www.swiftbysundell.com/articles/opaque-return-types-in-swift\"\u003eopaque return types\u003c/a\u003e\u003c/em\u003e, which are very often used when building views using SwiftUI — as they let us leverage the compiler to infer what concrete \u003ccode\u003eView\u003c/code\u003e-conforming type that’s returned from a given view’s \u003ccode\u003ebody\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e ArticleView: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e article: \u003cspan\u003eArticle\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003e\u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e\u003c/span\u003e {\n        \u003cspan\u003eScrollView\u003c/span\u003e {\n            \u003cspan\u003eVStack\u003c/span\u003e(alignment: .\u003cspan\u003eleading\u003c/span\u003e) {\n                \u003cspan\u003eText\u003c/span\u003e(article.\u003cspan\u003etitle\u003c/span\u003e).\u003cspan\u003efont\u003c/span\u003e(.\u003cspan\u003etitle\u003c/span\u003e)\n                \u003cspan\u003eText\u003c/span\u003e(article.\u003cspan\u003etext\u003c/span\u003e)\n            }\n            .\u003cspan\u003epadding\u003c/span\u003e()\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhile the above way of using the \u003ccode\u003esome\u003c/code\u003e keyword works great in the context of SwiftUI, when we’re essentially just passing a given value into the framework itself (after all, we’re never expected to access the \u003ccode\u003ebody\u003c/code\u003e property ourselves), it wouldn’t work that well when defining APIs for our own use.\u003c/p\u003e\u003cp\u003eFor example, replacing the \u003ccode\u003eAnyPublisher\u003c/code\u003e return type with \u003ccode\u003esome Publisher\u003c/code\u003e (and removing the call to \u003ccode\u003eeraseToAnyPublisher\u003c/code\u003e) within our \u003ccode\u003eUserLoader\u003c/code\u003e from before would \u003cem\u003etechnically work\u003c/em\u003e in isolation, but would also make each call site unaware of what type of output that our publisher produces — as we’d be dealing with a completely opaque \u003ccode\u003ePublisher\u003c/code\u003e type that can’t access any of the protocol’s associated types:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e UserLoader {\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadUser(withID id: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) -\u0026gt; \u003cspan\u003e\u003cspan\u003esome\u003c/span\u003e \u003cspan\u003ePublisher\u003c/span\u003e\u003c/span\u003e {\n        urlSession\n            .\u003cspan\u003edataTaskPublisher\u003c/span\u003e(for: \u003cspan\u003eurlForLoadingUser\u003c/span\u003e(withID: id))\n            .\u003cspan\u003emap\u003c/span\u003e(\\.\u003cspan\u003edata\u003c/span\u003e)\n            .\u003cspan\u003edecode\u003c/span\u003e(type: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e, decoder: decoder)\n    }\n\n    ...\n}\n\n\u003cspan\u003eUserLoader\u003c/span\u003e()\n    .\u003cspan\u003eloadUser\u003c/span\u003e(withID: userID)\n    .\u003cspan\u003esink\u003c/span\u003e(receiveCompletion: { completion \u003cspan\u003ein\u003c/span\u003e\n        ...\n    }, receiveValue: { output \u003cspan\u003ein\u003c/span\u003e\n        \u003cspan\u003e// We have no way of getting a compile-time guarantee\n        // that the output argument here is in fact a User\n        // value, so we\u0026#39;d have to use force-casting to turn\n        // that argument into the right type:\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e user = \u003cspan\u003eoutput \u003cspan\u003eas\u003c/span\u003e! \u003cspan\u003eUser\u003c/span\u003e\u003c/span\u003e\n        ...\n    })\n    .\u003cspan\u003estore\u003c/span\u003e(in: \u0026amp;cancellables)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is where Swift 5.7’s introduction of \u003cem\u003eprimary associated types\u003c/em\u003e comes in. If we take a look at the declaration of Combine’s \u003ccode\u003ePublisher\u003c/code\u003e protocol, we can see that it’s been updated to take advantage of this feature by declaring that its associated \u003ccode\u003eOutput\u003c/code\u003e and \u003ccode\u003eFailure\u003c/code\u003e types are primary (by putting them in angle brackets right after the protocol’s name):\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprotocol\u003c/span\u003e Publisher\u003cspan\u003e\u0026lt;Output, Failure\u0026gt;\u003c/span\u003e {\n    \u003cspan\u003eassociatedtype\u003c/span\u003e Output\n    \u003cspan\u003eassociatedtype\u003c/span\u003e Failure: \u003cspan\u003eError\u003c/span\u003e\n    ...\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat in turn enables us to use the \u003ccode\u003esome\u003c/code\u003e keyword in a brand new way — by declaring what exact types that our return value will use for each of the protocol’s primary associated types. So if we first update our \u003ccode\u003eUserLoader\u003c/code\u003e to use that new feature:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e UserLoader {\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadUser(withID id: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) -\u0026gt; \u003cspan\u003e\u003cspan\u003esome\u003c/span\u003e \u003cspan\u003ePublisher\u003c/span\u003e\u0026lt;\u003cspan\u003eUser\u003c/span\u003e, \u003cspan\u003eError\u003c/span\u003e\u0026gt;\u003c/span\u003e {\n        urlSession\n            .\u003cspan\u003edataTaskPublisher\u003c/span\u003e(for: \u003cspan\u003eurlForLoadingUser\u003c/span\u003e(withID: id))\n            .\u003cspan\u003emap\u003c/span\u003e(\\.\u003cspan\u003edata\u003c/span\u003e)\n            .\u003cspan\u003edecode\u003c/span\u003e(type: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e, decoder: decoder)\n    }\n\n    ...\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we’ll no longer be required to use force-casting at each call site — all while also avoiding any kind of manual type erasure, as the compiler will now retain full type safety all the way from our \u003ccode\u003eloadUser\u003c/code\u003e method to each of its call sites:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eUserLoader\u003c/span\u003e()\n    .\u003cspan\u003eloadUser\u003c/span\u003e(withID: userID)\n    .\u003cspan\u003esink\u003c/span\u003e(receiveCompletion: { completion \u003cspan\u003ein\u003c/span\u003e\n        ...\n    }, receiveValue: { user \u003cspan\u003ein\u003c/span\u003e\n        \u003cspan\u003e// We\u0026#39;re now getting a properly typed User\n        // value passed into this closure.\u003c/span\u003e\n        ...\n    })\n    .\u003cspan\u003estore\u003c/span\u003e(in: \u0026amp;cancellables)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOf course, since primary associated types isn’t just a Combine-specific thing, but rather a proper Swift feature, we can also use the above pattern when working with our own generic protocols as well.\u003c/p\u003e\u003cp\u003eFor example, let’s say that we’ve defined a \u003ccode\u003eLoadable\u003c/code\u003e protocol that lets us abstract different ways of loading a given value behind a single, unified interface (this time using \u003ca href=\"https://www.swiftbysundell.com/discover/concurrency\"\u003eSwift concurrency\u003c/a\u003e):\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprotocol\u003c/span\u003e Loadable\u003cspan\u003e\u0026lt;Value\u0026gt;\u003c/span\u003e {\n    \u003cspan\u003eassociatedtype\u003c/span\u003e Value\n\n    \u003cspan\u003efunc\u003c/span\u003e load() \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; \u003cspan\u003eValue\u003c/span\u003e\n}\n\n\u003cspan\u003estruct\u003c/span\u003e NetworkLoadable\u0026lt;Value: \u003cspan\u003eDecodable\u003c/span\u003e\u0026gt;: \u003cspan\u003e\u003cspan\u003eLoadable\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e url: \u003cspan\u003eURL\u003c/span\u003e\n\n    \u003cspan\u003efunc\u003c/span\u003e load() \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; \u003cspan\u003eValue\u003c/span\u003e {\n        \u003cspan\u003e// Load the value over the network\u003c/span\u003e\n        ...\n    }\n}\n\n\u003cspan\u003estruct\u003c/span\u003e DatabaseLoadable\u0026lt;Value: \u003cspan\u003eIdentifiable\u003c/span\u003e\u0026gt;: \u003cspan\u003e\u003cspan\u003eLoadable\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e id: \u003cspan\u003eValue\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e\n\n    \u003cspan\u003efunc\u003c/span\u003e load() \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; \u003cspan\u003eValue\u003c/span\u003e {\n        \u003cspan\u003e// Load the value from the app\u0026#39;s local database\u003c/span\u003e\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eA big benefit of using a pattern like that is that it enables us to very neatly separate concerns, as each call site doesn’t have to be aware of exactly how a given value is loaded — we can simply return \u003ccode\u003esome Loadable\u003c/code\u003e from a given function, and thanks to our primary associated type, we get full type safety without having to reveal what underlying type that’s used to perform the actual loading:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efunc\u003c/span\u003e loadableForArticle(withID id: \u003cspan\u003eArticle\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) -\u0026gt; \u003cspan\u003e\u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eLoadable\u003c/span\u003e\u0026lt;\u003cspan\u003eArticle\u003c/span\u003e\u0026gt;\u003c/span\u003e {\n    \u003cspan\u003elet\u003c/span\u003e url = \u003cspan\u003eurlForLoadingArticle\u003c/span\u003e(withID: id)\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eNetworkLoadable\u003c/span\u003e(url: url)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, one important limitation of opaque return types is that the compiler requires all code paths within a scope that returns an opaque type to \u003cem\u003ealways return the exact same type\u003c/em\u003e. So, if we wanted to dynamically switch between two different \u003ccode\u003eLoadable\u003c/code\u003e implementations, then we’d get a compiler error if we tried to keep using the \u003ccode\u003esome\u003c/code\u003e keyword like we did above:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Error: Function declares an opaque return type \u0026#39;some Loadable\u0026lt;Article\u0026gt;\u0026#39;,\n// but the return statements in its body do not have matching underlying types.\u003c/span\u003e\n\u003cspan\u003efunc\u003c/span\u003e loadableForArticle(withID id: \u003cspan\u003eArticle\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eLoadable\u003c/span\u003e\u0026lt;\u003cspan\u003eArticle\u003c/span\u003e\u0026gt; {\n    \u003cspan\u003e\u003cspan\u003eif\u003c/span\u003e useLocalData {\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eDatabaseLoadable\u003c/span\u003e(id: id)\n}\u003c/span\u003e\n\n    \u003cspan\u003elet\u003c/span\u003e url = \u003cspan\u003eurlForLoadingArticle\u003c/span\u003e(withID: id)\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eNetworkLoadable\u003c/span\u003e(url: url)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOne way to solve the above problem would be to use the good old fashioned approach of introducing a type-erasing \u003ccode\u003eAnyLoadable\u003c/code\u003e type, which we could use to wrap both of our underlying \u003ccode\u003eLoadable\u003c/code\u003e instances — but at this point, that does arguably feel like a step backwards, since we’d have to write that type-erased wrapper manually. Or do we?\u003c/p\u003e\u003cp\u003eIt turns out that we can, in fact, keep leveraging the compiler even in these kinds of more dynamic situations — all that we have to do is replace the \u003ccode\u003esome\u003c/code\u003e keyword with Swift’s new \u003ccode\u003eany\u003c/code\u003e keyword, and the compiler will actually perform all of the required type erasure on our behalf:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efunc\u003c/span\u003e loadableForArticle(withID id: \u003cspan\u003eArticle\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) -\u0026gt; \u003cspan\u003e\u003cspan\u003eany\u003c/span\u003e\u003c/span\u003e \u003cspan\u003eLoadable\u003c/span\u003e\u0026lt;\u003cspan\u003eArticle\u003c/span\u003e\u0026gt; {\n    \u003cspan\u003eif\u003c/span\u003e useLocalData {\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eDatabaseLoadable\u003c/span\u003e(id: id)\n    }\n\n    \u003cspan\u003elet\u003c/span\u003e url = \u003cspan\u003eurlForLoadingArticle\u003c/span\u003e(withID: id)\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eNetworkLoadable\u003c/span\u003e(url: url)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eJust like when using \u003ccode\u003esome\u003c/code\u003e in combination with primary associated types, using \u003ccode\u003eany\u003c/code\u003e retains full type-safety, and still enables us to use all available \u003ccode\u003eLoadable\u003c/code\u003e APIs, and maintain complete awareness that the returned instance loads \u003ccode\u003eArticle\u003c/code\u003e values. Neat!\u003c/p\u003e\u003cp\u003eIt’s important to point out, though, that using the \u003ccode\u003eany\u003c/code\u003e keyword in the above kind of way turns our method’s return value into a so-called \u003cem\u003eexistential\u003c/em\u003e, which does come with a certain performance overhead, and might also prevent us from using certain generic APIs. For example, if we were to use the \u003ccode\u003eany\u003c/code\u003e keyword within the earlier Combine-based example, then we’d be locked out of applying any kind of operators (like \u003ccode\u003emap\u003c/code\u003e or \u003ccode\u003eflatMap\u003c/code\u003e) on the returned publisher. So, when possible, it’s definitely preferable to use the \u003ccode\u003esome\u003c/code\u003e keyword instead.\u003c/p\u003e\u003cp\u003eI hope that you found this article useful. If you want to learn more about \u003ccode\u003esome\u003c/code\u003e and \u003ccode\u003eany\u003c/code\u003e, then check out \u003ca href=\"https://www.swiftbysundell.com/articles/referencing-generic-protocols-with-some-and-any-keywords\"\u003emy earlier article about those keywords\u003c/a\u003e, which focuses on how they can be used when declaring properties and parameter types. And if you have any questions, comments, or feedback, then feel free to \u003ca href=\"https://www.swiftbysundell.com/contact\"\u003ereach out\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": null,
  "modifiedTime": null
}
