{
  "id": "37114edf-642a-44b8-8544-366ce6d44b76",
  "title": "Morphing shapes in SwiftUI",
  "link": "https://nerdyak.tech/development/2020/05/07/morphing-shapes-in-swiftui.html",
  "description": "Hello and welcome to another blog post about SwiftUI animations. In the previous post dedicated mainly to AnimatableData, we have constructed AnimatableVector that allowed us to create animatable charts. Today we will utilize the same class for morphing shapes.",
  "author": "Pavel Zak",
  "published": "2020-05-07T00:00:00+00:00",
  "source": "https://nerdyak.tech/atom.xml",
  "categories": [
    "development",
    "swiftUI",
    "shape",
    "animation",
    "animatableData",
    "animatablePair",
    "animatableVector",
    "path",
    "morphing",
    "transition"
  ],
  "byline": "Pavel Zak",
  "length": 7556,
  "excerpt": "Hello and welcome to another blog post about SwiftUI animations. In the previous post dedicated mainly to AnimatableData, we have constructed AnimatableVector that allowed us to create animatable charts. Today we will utilize the same class for morphing shapes.",
  "siteName": "Pavel Zak",
  "favicon": "",
  "text": "Hello and welcome to another blog post about SwiftUI animations. In the previous post dedicated mainly to AnimatableData, we have constructed AnimatableVector that allowed us to create animatable charts. Today we will utilize the same class for morphing shapes. Shape representation Shapes in SwiftUI can be constructed as a composition of vector paths and/or shape primitives. If we want to create morphing animation between two shapes, we need to find universal representation first. This can be done either ad-hoc for specific shapes - as we saw in the previous post about custom controls - but it is better to find a more generic one that will allow us to morph any shape to any shape without limitations. The most common approach is to describe the shape as an approximation of its outline using a finite set of line segments. This means, that we will distribute N points around the shape outline and when doing the morphing animation, we can easily move these outline points from the position given by shape A to the new position in the shape B. For better understanding, check the following illustration: Implementation of morphable shape in SwiftUI So how to implement all of this in SwiftUI? Let me start with a new shape representation based on multiple control points. This is quite easy, the only crucial part is that these control points are being represented using our AnimatableVector so it is capable to morph using animation. But hey - the shape points are two-dimensional (having x and y coordinate), while our AnimatableVector holds only an array of Doubles. What can be done about that? Well, there are two solutions: you can implement another custom vector holding array of CGPoints and let it conform to the AnimatableData protocol or use the same AnimatableVector and expect even indexed component to be x coordinate and odd-indexed components to by y coordinate. I choose this solution for the following MorphableShape implementation: struct MorphableShape: Shape { var controlPoints: AnimatableVector var animatableData: AnimatableVector { set { self.controlPoints = newValue } get { return self.controlPoints } } func point(x: Double, y: Double, rect: CGRect) -\u003e CGPoint { // vector values are expected to by in the range of 0...1 return CGPoint(x: Double(rect.width)*x, y: Double(rect.height)*y) } func path(in rect: CGRect) -\u003e Path { return Path { path in path.move(to: self.point(x: self.controlPoints.values[0], y: self.controlPoints.values[1], rect: rect)) var i = 2; while i \u003c self.controlPoints.values.count-1 { path.addLine(to: self.point(x: self.controlPoints.values[i], y: self.controlPoints.values[i+1], rect: rect)) i += 2; } path.addLine(to: self.point(x: self.controlPoints.values[0], y: self.controlPoints.values[1], rect: rect)) } } } Let‚Äôs check the implementation using several random points: // hepler func creating vector with random values func randomVector(count: Int)-\u003eAnimatableVector { let randomValues = Array(1...count).map{_ in Double.random(in: 0...1.0)} return AnimatableVector(with: randomValues) } // demo view for our proof of concept of morphable shapes struct DemoView: View { static let pointCount = 8 // number of control points // vector holds twice as many elements @State var controlPoints: AnimatableVector = randomVector(count: pointCount*2) var body: some View { VStack { MorphableShape(controlPoints: self.controlPoints) .fill(Color.orange) .frame(width: 256, height: 256) .overlay( // overlay the shape with the same shape to create outline MorphableShape(controlPoints: self.controlPoints) .stroke(Color.white, lineWidth: 3) ) Button (action: { withAnimation { // feel free to play with animation curves here // randomize points self.controlPoints = randomVector(count: DemoView.pointCount*2) } }){ Text(\"Randomize\") } } } } Converting standard shape to MorphableShape All the above code is enough to morph any shape to any shape, but getting the shape representation as a set of control points may be tricky. Well, it is definitively something you cannot put together ‚Äúby hand‚Äù. Luckily, there is a way how to generate them using SwiftUI Path API. We can sample the shape outline using the trimmedPath() method, so let me create a simple Path extension, that provides a vector of N control points along any Path: extension Path { // return point at the curve func point(at offset: CGFloat) -\u003e CGPoint { let limitedOffset = min(max(offset, 0), 1) guard limitedOffset \u003e 0 else { return cgPath.currentPoint } return trimmedPath(from: 0, to: limitedOffset).cgPath.currentPoint } // return control points along the path func controlPoints(count: Int) -\u003e AnimatableVector { var retPoints = [Double]() for index in 0..\u003ccount { let pathOffset = Double(index)/Double(count) let pathPoint = self.point(at: CGFloat(pathOffset)) retPoints.append(Double(pathPoint.x)) retPoints.append(Double(pathPoint.y)) } return AnimatableVector(with: retPoints) } } Now, it can be utilized like this: let N = 100 let shape = Circle() // or any other shape let shapeControlPoints: AnimatableVector = shape.path(in: CGRect(x: 0, y: 0, width: 1, height: 1)) .controlPoints(count: N) Please, note, that with setting the CGRect size to 1 we are assuring to have the control point coordinates in the range 0...1 which is exactly what our MorphableShape expects to get. And that‚Äôs it! Use cases If you are wondering, what is this all good for, I present here several ideas: morphing of icons (for multi-state buttons) custom transitions and morphing of clip masks creating a pointless music video in SwiftUI ü§™ Final notes Described algorithm works best for one-component/compact shapes. It works also for multi-component shapes, but the resulting animation may not be eye-pleasant. For large curved or complex shapes, the number of control points needs to be quite high (hundreds at least) to have a smooth result. The only tricky thing with this approach is that the shapes may differ in the origin and direction of how they are being constructed. If these parameters are different, the morphing animation would not work as expected and shape may ‚Äúflip‚Äù during interpolation. When creating my custom shapes, I usually start the path at the top-left corner and construct the shape in the clockwise direction to avoid these issues. Nevertheles, the control points could be programatically rearranged so the vector always start around the same orientation - but so far I have not implemented this part:) It would be awesome, if we could get Path from SFSymbols‚Ä¶.ü§û Did you like this article? What do you want me to focus on next? Feel free to comment or criticize so the next one is even better. Or share it with other SwiftUI adopters ;)",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\" aria-label=\"Content\"\u003e\n    \u003carticle\u003e\n      \u003cdiv\u003e\n        \u003cp\u003eHello and welcome to another blog post about \u003ca href=\"https://developer.apple.com/documentation/swiftui\"\u003eSwiftUI\u003c/a\u003e animations. In the \u003ca href=\"https://nerdyak.tech/development/2020/01/12/animating-complex-shapes-in-swiftui.html\"\u003eprevious post\u003c/a\u003e dedicated mainly to \u003ccode\u003eAnimatableData\u003c/code\u003e, we have constructed \u003ccode\u003eAnimatableVector\u003c/code\u003e that allowed us to create animatable charts. Today we will utilize the same class for morphing shapes.\u003c/p\u003e\n\n\u003ch2 id=\"shape-representation\"\u003eShape representation\u003c/h2\u003e\n\n\u003cp\u003eShapes in SwiftUI can be constructed as a composition of vector paths and/or shape primitives. If we want to create morphing animation between two shapes, we need to find universal representation first. This can be done either ad-hoc for specific shapes - as we saw in the previous post about \u003ca href=\"https://nerdyak.tech/development/2019/11/28/creating-custom-views-in-swiftui.html\"\u003ecustom controls\u003c/a\u003e - but it is better to find a more generic one that will allow us to morph any shape to any shape without limitations.\u003c/p\u003e\n\n\u003cp\u003eThe most common approach is to describe the shape as an approximation of its outline using a finite set of line segments. This means, that we will distribute \u003ccode\u003eN\u003c/code\u003e points around the shape outline and when doing the morphing animation, we can easily move these outline points from the position given by shape A to the new position in the shape B. For better understanding, check the following illustration:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/09_explanation.gif\" alt=\"morphExplanation\" title=\"Morphing using interpolation of control points\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"implementation-of-morphable-shape-in-swiftui\"\u003eImplementation of morphable shape in SwiftUI\u003c/h2\u003e\n\n\u003cp\u003eSo how to implement all of this in SwiftUI? Let me start with a new shape representation based on multiple control points. This is quite easy, the only crucial part is that these control points are being represented using our \u003ccode\u003eAnimatableVector\u003c/code\u003e so it is capable to morph using animation.\u003c/p\u003e\n\n\u003cp\u003eBut hey - the shape points are two-dimensional (having x and y coordinate), while our \u003ccode\u003eAnimatableVector\u003c/code\u003e holds only an array of Doubles. What can be done about that? Well, there are two solutions:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eyou can implement another custom vector holding array of \u003ccode\u003eCGPoints\u003c/code\u003e and let it conform to the \u003ccode\u003eAnimatableData\u003c/code\u003e protocol\u003c/li\u003e\n  \u003cli\u003eor use the same \u003ccode\u003eAnimatableVector\u003c/code\u003e and expect even indexed component to be x coordinate and odd-indexed components to by y coordinate. I choose this solution for the following \u003ccode\u003eMorphableShape\u003c/code\u003e implementation:\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eMorphableShape\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eShape\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eanimatableData\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eset\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enewValue\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003eget\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// vector values are expected to by in the range of 0...1\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003ePath\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ePath\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003epath\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n            \n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emove\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \n\t\t\t\t                     \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \n            \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n            \u003cspan\u003ewhile\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e  \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \n\t\t\t\t\t                         \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n                \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n            \n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e  \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \n\t\t\t\t                         \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eLet‚Äôs check the implementation using several random points:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/09_example.gif\" alt=\"morphExample\" title=\"Morphable shape ready to be animated\"/\u003e\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e// hepler func creating vector with random values\u003c/span\u003e\n\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003erandomVector\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003eAnimatableVector\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003erandomValues\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eArray\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erandom\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e1.0\u003c/span\u003e\u003cspan\u003e)}\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erandomValues\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003e// demo view for our proof of concept of morphable shapes\u003c/span\u003e\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eDemoView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003epointCount\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e \u003cspan\u003e// number of control points\u003c/span\u003e\n\t\u003cspan\u003e// vector holds twice as many elements\u003c/span\u003e\n    \u003cspan\u003e@State\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erandomVector\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003epointCount\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eVStack\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003eMorphableShape\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efill\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eorange\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e256\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e256\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eoverlay\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e \u003cspan\u003e// overlay the shape with the same shape to create outline\u003c/span\u003e\n                    \u003cspan\u003eMorphableShape\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estroke\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewhite\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003elineWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003e)\u003c/span\u003e\n            \n            \u003cspan\u003eButton\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eaction\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003ewithAnimation\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e// feel free to play with animation curves here\u003c/span\u003e\n                    \u003cspan\u003e// randomize points\u003c/span\u003e\n                    \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erandomVector\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDemoView\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epointCount\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003e}){\u003c/span\u003e\n                \u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Randomize\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"converting-standard-shape-to-morphableshape\"\u003eConverting standard shape to MorphableShape\u003c/h2\u003e\n\n\u003cp\u003eAll the above code is enough to morph any shape to any shape, but getting the shape representation as a set of control points may be tricky. Well, it is definitively something you cannot put together ‚Äúby hand‚Äù.\u003c/p\u003e\n\n\u003cp\u003eLuckily, there is a way how to generate them using SwiftUI \u003ca href=\"https://developer.apple.com/documentation/swiftui/path\"\u003ePath\u003c/a\u003e API. We can sample the shape outline using the \u003ccode\u003etrimmedPath()\u003c/code\u003e method, so let me create a simple Path extension, that provides a vector of N control points along any Path:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003ePath\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e// return point at the curve\u003c/span\u003e\n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eat\u003c/span\u003e \u003cspan\u003eoffset\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003elimitedOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003emin\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emax\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eoffset\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elimitedOffset\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ecgPath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecurrentPoint\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003etrimmedPath\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003elimitedOffset\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecgPath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecurrentPoint\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003e// return control points along the path\u003c/span\u003e\n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eretPoints\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e]()\u003c/span\u003e\n        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eindex\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003epathOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003epathPoint\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eat\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epathOffset\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \u003cspan\u003eretPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epathPoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \u003cspan\u003eretPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epathPoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eretPoints\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eNow, it can be utilized like this:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eN\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e100\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eshape\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eCircle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e// or any other shape\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eshapeControlPoints\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eshape\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n                                                \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eN\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003ePlease, note, that with setting the \u003ccode\u003eCGRect\u003c/code\u003e size to 1 we are assuring to have the control point coordinates in the range \u003ccode\u003e0...1\u003c/code\u003e which is exactly what our \u003ccode\u003eMorphableShape\u003c/code\u003e expects to get.\u003c/p\u003e\n\n\u003cp\u003eAnd that‚Äôs it!\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/07_shapes.gif\" alt=\"animatedShapes\" title=\"Demonstration of morphing of various shapes\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"use-cases\"\u003eUse cases\u003c/h2\u003e\n\n\u003cp\u003eIf you are wondering, what is this all good for, I present here several ideas:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003emorphing of icons (for multi-state buttons)\n\u003cimg src=\"https://nerdyak.tech/assets/posts/09_recording.gif\" alt=\"recording\" title=\"Example of morphing icon on payer view\"/\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ecustom transitions and morphing of clip masks\n\u003cimg src=\"https://nerdyak.tech/assets/posts/09_heart.gif\" alt=\"heart\" title=\"Example of morphing transition\"/\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ecreating a pointless music video in SwiftUI ü§™\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ccenter\u003e\n\u003ciframe width=\"400\" height=\"300\" src=\"https://www.youtube.com/embed/r_XorK0cjv8\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\"\u003e\u003c/iframe\u003e\n\u003c/center\u003e\n\n\u003ch2 id=\"final-notes\"\u003eFinal notes\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003eDescribed algorithm works best for one-component/compact shapes. It works also for multi-component shapes, but the resulting animation may not be eye-pleasant.\u003c/li\u003e\n  \u003cli\u003eFor large curved or complex shapes, the number of control points needs to be quite high (hundreds at least) to have a smooth result.\u003c/li\u003e\n  \u003cli\u003eThe only tricky thing with this approach is that the shapes may differ in the origin and direction of how they are being constructed. If these parameters are different, the morphing animation would not work as expected and shape may ‚Äúflip‚Äù during interpolation. When creating my custom shapes, I usually start the path at the top-left corner and construct the shape in the clockwise direction to avoid these issues. Nevertheles, the control points could be programatically rearranged so the vector always start around the same orientation - but so far I have not implemented this part:)\u003c/li\u003e\n  \u003cli\u003eIt would be awesome, if we could get Path from SFSymbols‚Ä¶.ü§û\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cem\u003eDid you like this article? What do you want me to focus on next?\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eFeel free to comment or criticize so the next one is even better. Or share it with other SwiftUI adopters ;)\u003c/em\u003e\u003c/p\u003e\n\n\n      \u003c/div\u003e\n      \n    \u003c/article\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2020-05-07T00:00:00Z",
  "modifiedTime": null
}
