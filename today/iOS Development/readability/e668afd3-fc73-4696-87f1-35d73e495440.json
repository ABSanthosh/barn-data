{
  "id": "e668afd3-fc73-4696-87f1-35d73e495440",
  "title": "Core Data Backups, Redux",
  "link": "https://atomicbird.com/blog/core-data-backups-redux/",
  "description": "This is the second of two posts following up on my earlier post about backing up and restoring Core Data. My past post covered the difficulty of learning how to use mostly-undocumented framework methods, specifically about a Core Data method called replacePersistentStore(...). Arnaud Joubay recently messaged me to ask why I used a different approach when backing up and restoring persistent stores. Now that I’ve had some time to look at that method and work out what I can about how to use it, let’s see how it works in practice.",
  "author": "",
  "published": "Mon, 29 Mar 2021 00:00:00 +0000",
  "source": "https://atomicbird.com/index.xml",
  "categories": null,
  "byline": "",
  "length": 6913,
  "excerpt": "This is the second of two posts following up on my earlier post about backing up and restoring Core Data. My past post covered the difficulty of learning how to use mostly-undocumented framework methods, specifically about a Core Data method called replacePersistentStore(...). Arnaud Joubay recently messaged me to ask why I used a different approach when backing up and restoring persistent stores. Now that I’ve had some time to look at that method and work out what I can about how to use it, let’s see how it works in practice.",
  "siteName": "Title",
  "favicon": "https://atomicbird.com/apple-touch-icon-144-precomposed.png",
  "text": "This is the second of two posts following up on my earlier post about backing up and restoring Core Data. My past post covered the difficulty of learning how to use mostly-undocumented framework methods, specifically about a Core Data method called replacePersistentStore(...). Arnaud Joubay recently messaged me to ask why I used a different approach when backing up and restoring persistent stores. Now that I’ve had some time to look at that method and work out what I can about how to use it, let’s see how it works in practice. Replacing, not Migrating Last time I used migratePersistentStore(...) for backups and restores. This time I’ll use replacePersistentStore(...). Superficially, at least, these methods seem nearly identical. Both take an existing persistent store and make a copy at a new location. They take approximately the same arguments, which specify persistent store options and store type. There’s no obvious reason to choose one or the other. Why update my post then? There’s this post on Apple’s dev forum site from last summer that says, in part: Additionally you should almost never use NSPersistentStoreCoordinator’s migratePersistentStore… method but instead use the newer replacePersistentStoreAtURL.. (you can replace emptiness to make a copy). The former loads the store into memory so you can do fairly radical things like write it out as a different store type. It pre-dates iOS. The latter will perform an APFS clone where possible. I don’t know if that counts as documentation, but it’s from an Apple engineer, so… maybe? In any case it suggests that replace should be preferred to migrate, and that doing so might be more efficient due to APFS cloning. An anonymous forum post five years after the function was introduced isn’t a very clear endorsement but I’ll go with it for now and see where it takes me. The demo app I’ve been using is now on GitHub. You can take a look here. Or go directly to the diff of replacing migrate with replace here. Backing Up The backup process is simpler than it used to be, because replace doesn’t have the same side-effect that migrate did of unloading the persistent store. I used a workaround of creating a secondary persistent store controller to deal with that, but it’s not necessary any more. Backing up is still a relatively straightforward process, since it doesn’t interfere with the app’s current Core Data stack. Anything that you’ve loaded from Core Data continues to be valid, but afterward you have a new copy of the underlying files. The guts of the backup code, somewhat simplified for this post, now look like this: for persistentStoreDescription in persistentStoreDescriptions { guard let storeURL = persistentStoreDescription.url else { continue } let destinationStoreURL = destinationURL.appendingPathComponent(storeURL.lastPathComponent) do { try persistentStoreCoordinator.replacePersistentStore(at: destinationStoreURL, destinationOptions: persistentStoreDescription.options, withPersistentStoreFrom: storeURL, sourceOptions: persistentStoreDescription.options, ofType: persistentStoreDescription.type) } catch { throw CopyPersistentStoreErrors.copyStoreError(\"\\(error.localizedDescription)\") } } In essence it loops through all current persistent stores and does a replace for each one, creating a backup copy with the same options and store type. It’s OK if the destination doesn’t already exist, that just means replace will create a new store at the location. If the destination does exist, well, we just said to replace it, and that’s what happens. There’s no return value, but the function will presumably throw to tell us if it didn’t succeed. Return to the Past Even though the migrate and replace methods seem pretty similar, the semantics are slightly different when the destination is a currently-loaded store. My new restore code reflects that. In the old approach it went like this: Get rid the persistent store you’re using with destroyPersistentStore. Load the backup copy in-place, that is, call addPersistentStore with the backup store URL. Tell the persistent store to migrate the store to the original URL. It would then use the original URL for new changes. With the newer method, the process is: Tell the persistent store to replace the current store’s URL with data from the backup URL. This has an undocumented side-effect that it unloads the current store! Because of that side effect, re-add the URL for the persistent store you’ve been using. These differences also mean that the new restore code works on the currently loaded persistent store descriptions, not the currently loaded persistent stores. The guts (again somewhat simiplified here) look like this: for persistentStoreDescription in persistentStoreDescriptions { guard let loadedStoreURL = persistentStoreDescription.url else { continue } let backupStoreURL = backupURL.appendingPathComponent(loadedStoreURL.lastPathComponent) do { let storeOptions = persistentStoreDescription.options let configurationName = persistentStoreDescription.configuration let storeType = persistentStoreDescription.type try persistentStoreCoordinator.replacePersistentStore(at: loadedStoreURL, destinationOptions: storeOptions, withPersistentStoreFrom: backupStoreURL, sourceOptions: storeOptions, ofType: storeType) try persistentStoreCoordinator.addPersistentStore(ofType: storeType, configurationName: configurationName, at: loadedStoreURL, options: storeOptions) } catch { throw CopyPersistentStoreErrors.copyStoreError(\"Could not restore: \\(error.localizedDescription)\") } } The core of that is just a replace call where the source is the backup store URL and the destination is the URL of the store we’re already using. Since that gets unloaded, the next step is to re-add it. As in my original post, restoring is a more delicate operation than backing up, because you’re changing the data that the app is using. And not in the sense of “normal” Core Data updates, but in the sense of yanking out the lowest level of the Core Data stack and replacing it, while the app is running. You still need to take precautions like making sure you don’t have any live Core Data-related objects, because they’ll all become invalid after restoring from backup. Replacing Stores FT…W? The new code works! Is it better? Well, probably. Documentation of why one way might be better than the other is sparse, at best. The only solid clues that this is better are an anonymous developer forums post and a somewhat cryptic comment in NSPersistentStoreCoordinator.h. It’s said to be preferred, and it might be more efficient, and it might or might not use APFS clones internally depending how you read things. If anyone from Apple sees this, please take a look at FB9054409, because some clear guidance would really help.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n            \n    \n\u003carticle\u003e\n  \u003cheader\u003e\n    \n    \n    \n\n\n\n  \u003c/header\u003e\n  \n  \n  \u003cdiv\u003e\n    \u003cp\u003eThis is the second of two posts following up on my earlier post about \u003ca href=\"https://atomicbird.com/blog/core-data-back-up-store/\"\u003ebacking up and restoring Core Data\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://atomicbird.com/blog/mostly-undocumented/\"\u003eMy past post\u003c/a\u003e covered the difficulty of learning how to use mostly-undocumented framework methods, specifically about a Core Data method called \u003ccode\u003ereplacePersistentStore(...)\u003c/code\u003e. \u003ca href=\"https://twitter.com/sowenjub\"\u003eArnaud Joubay\u003c/a\u003e recently messaged me to ask why I used a different approach when backing up and restoring persistent stores. Now that I’ve had some time to look at that method and work out what I can about how to use it, let’s see how it works in practice.\u003c/p\u003e\n\u003ch2 id=\"replacing-not-migrating\"\u003eReplacing, not Migrating\u003c/h2\u003e\n\u003cp\u003eLast time I used \u003ca href=\"https://developer.apple.com/documentation/coredata/nspersistentstorecoordinator/1468927-migratepersistentstore#\"\u003e\u003ccode\u003emigratePersistentStore(...)\u003c/code\u003e\u003c/a\u003e for backups and restores. This time I’ll use \u003ca href=\"https://developer.apple.com/documentation/coredata/nspersistentstorecoordinator/1468917-replacepersistentstore#\"\u003e\u003ccode\u003ereplacePersistentStore(...)\u003c/code\u003e\u003c/a\u003e. Superficially, at least, these methods seem nearly identical. Both take an existing persistent store and make a copy at a new location. They take approximately the same arguments, which specify persistent store options and store type. There’s no obvious reason to choose one or the other.\u003c/p\u003e\n\u003cp\u003eWhy update my post then? There’s this \u003ca href=\"https://developer.apple.com/forums/thread/651325\"\u003epost on Apple’s dev forum site\u003c/a\u003e from last summer that says, in part:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAdditionally you should almost never use NSPersistentStoreCoordinator’s migratePersistentStore… method but instead use the newer replacePersistentStoreAtURL.. (you can replace emptiness to make a copy). The former loads the store into memory so you can do fairly radical things like write it out as a different store type. It pre-dates iOS. The latter will perform an APFS clone where possible.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eI don’t know if that counts as documentation, but it’s from an Apple engineer, so… maybe? In any case it suggests that \u003ccode\u003ereplace\u003c/code\u003e should be preferred to \u003ccode\u003emigrate\u003c/code\u003e, and that doing so might be more efficient due to APFS cloning. An anonymous forum post five years after the function was introduced isn’t a very clear endorsement but I’ll go with it for now and see where it takes me.\u003c/p\u003e\n\u003cp\u003eThe demo app I’ve been using is now on GitHub. You can take a look \u003ca href=\"https://github.com/atomicbird/CDMoveDemo\"\u003ehere\u003c/a\u003e. Or go directly to the diff of replacing \u003ccode\u003emigrate\u003c/code\u003e with \u003ccode\u003ereplace\u003c/code\u003e \u003ca href=\"https://github.com/atomicbird/CDMoveDemo/commit/fd60b4ca11502dc66329af9f9337826514b52156#diff-6b98e02baf6f7418533b1d2df2671bd7df4b784ae2c9c0388e9d6a411aa65c97\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"backing-up\"\u003eBacking Up\u003c/h2\u003e\n\u003cp\u003eThe backup process is simpler than it used to be, because \u003ccode\u003ereplace\u003c/code\u003e doesn’t have the same side-effect that \u003ccode\u003emigrate\u003c/code\u003e did of unloading the persistent store. I used a workaround of creating a secondary persistent store controller to deal with that, but it’s not necessary any more.\u003c/p\u003e\n\u003cp\u003eBacking up is still a relatively straightforward process, since it doesn’t interfere with the app’s current Core Data stack. Anything that you’ve loaded from Core Data continues to be valid, but afterward you have a new copy of the underlying files.\u003c/p\u003e\n\u003cp\u003eThe guts of the backup code, somewhat simplified for this post, now look like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efor\u003c/span\u003e persistentStoreDescription \u003cspan\u003ein\u003c/span\u003e persistentStoreDescriptions {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e storeURL = persistentStoreDescription.url \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e destinationStoreURL = destinationURL.appendingPathComponent(storeURL.lastPathComponent)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003edo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003etry\u003c/span\u003e persistentStoreCoordinator.replacePersistentStore(at: destinationStoreURL, destinationOptions: persistentStoreDescription.options, withPersistentStoreFrom: storeURL, sourceOptions: persistentStoreDescription.options, ofType: persistentStoreDescription.type)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    } \u003cspan\u003ecatch\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ethrow\u003c/span\u003e CopyPersistentStoreErrors.copyStoreError(\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003eerror.localizedDescription\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIn essence it loops through all current persistent stores and does a \u003ccode\u003ereplace\u003c/code\u003e for each one, creating a backup copy with the same options and store type. It’s OK if the destination doesn’t already exist, that just means \u003ccode\u003ereplace\u003c/code\u003e will create a new store at the location. If the destination does exist, well, we just said to replace it, and that’s what happens. There’s no return value, but the function will presumably \u003ccode\u003ethrow\u003c/code\u003e to tell us if it didn’t succeed.\u003c/p\u003e\n\u003ch2 id=\"return-to-the-past\"\u003eReturn to the Past\u003c/h2\u003e\n\u003cp\u003eEven though the \u003ccode\u003emigrate\u003c/code\u003e and \u003ccode\u003ereplace\u003c/code\u003e methods seem pretty similar, the semantics are slightly different when the destination is a currently-loaded store. My new restore code reflects that.\u003c/p\u003e\n\u003cp\u003eIn the old approach it went like this:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eGet rid the persistent store you’re using with \u003ccode\u003edestroyPersistentStore\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eLoad the backup copy in-place, that is, call \u003ccode\u003eaddPersistentStore\u003c/code\u003e with the backup store URL.\u003c/li\u003e\n\u003cli\u003eTell the persistent store to migrate the store to the original URL. It would then use the original URL for new changes.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWith the newer method, the process is:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTell the persistent store to replace the current store’s URL with data from the backup URL. This has an undocumented side-effect that it unloads the current store!\u003c/li\u003e\n\u003cli\u003eBecause of that side effect, re-add the URL for the persistent store you’ve been using.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThese differences also mean that the new restore code works on the currently loaded persistent store \u003cem\u003edescriptions\u003c/em\u003e, not the currently loaded persistent stores. The guts (again somewhat simiplified here) look like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efor\u003c/span\u003e persistentStoreDescription \u003cspan\u003ein\u003c/span\u003e persistentStoreDescriptions {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e loadedStoreURL = persistentStoreDescription.url \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e backupStoreURL = backupURL.appendingPathComponent(loadedStoreURL.lastPathComponent)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003edo\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e storeOptions = persistentStoreDescription.options\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e configurationName = persistentStoreDescription.configuration\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e storeType = persistentStoreDescription.type\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003etry\u003c/span\u003e persistentStoreCoordinator.replacePersistentStore(at: loadedStoreURL, destinationOptions: storeOptions, withPersistentStoreFrom: backupStoreURL, sourceOptions: storeOptions, ofType: storeType)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003etry\u003c/span\u003e persistentStoreCoordinator.addPersistentStore(ofType: storeType, configurationName: configurationName, at: loadedStoreURL, options: storeOptions)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    } \u003cspan\u003ecatch\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ethrow\u003c/span\u003e CopyPersistentStoreErrors.copyStoreError(\u003cspan\u003e\u0026#34;Could not restore: \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003eerror.localizedDescription\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe core of that is just a \u003ccode\u003ereplace\u003c/code\u003e call where the source is the backup store URL and the destination is the URL of the store we’re already using. Since that gets unloaded, the next step is to re-add it.\u003c/p\u003e\n\u003cp\u003eAs in my original post, restoring is a more delicate operation than backing up, because you’re changing the data that the app is using. And not in the sense of “normal” Core Data updates, but in the sense of yanking out the lowest level of the Core Data stack and replacing it, while the app is running. You still need to take precautions like making sure you don’t have any live Core Data-related objects, because they’ll all become invalid after restoring from backup.\u003c/p\u003e\n\u003ch2 id=\"replacing-stores-ftw\"\u003eReplacing Stores FT…W?\u003c/h2\u003e\n\u003cp\u003eThe new code works! Is it better? Well, \u003cem\u003eprobably\u003c/em\u003e. Documentation of why one way might be better than the other is \u003ca href=\"https://atomicbird.com/blog/mostly-undocumented/\"\u003esparse, at best\u003c/a\u003e. The only solid clues that this is better are an anonymous developer forums post and a somewhat cryptic comment in \u003ccode\u003eNSPersistentStoreCoordinator.h\u003c/code\u003e. It’s said to be preferred, and it might be more efficient, and it might or might not use APFS clones internally depending how you read things. If anyone from Apple sees this, please take a look at FB9054409, because some clear guidance would really help.\u003c/p\u003e\n\n  \u003c/div\u003e\n  \n\n\n\n\n  \n\n  \n    \n\n\n\u003c/article\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2021-03-29T00:00:00Z",
  "modifiedTime": "2021-03-29T00:00:00Z"
}
