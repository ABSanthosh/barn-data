{
  "id": "7f6bd60d-907b-4eda-bbae-82609b7a3d4d",
  "title": "Thoughts on SwiftUI vs UIKit",
  "link": "https://swiftrocks.com/my-experience-with-swiftui",
  "description": "I had played with SwiftUI sporadically in the past, but it wasn't until now that I had built a complete App Store-ready app with it. When SwiftUI was first announced I was very concerned about certain quirks of the framework and how it was probably not suitable for professional iOS development, but with the framework evolving constantly over the past couple of years it became time to re-evaluate that statement. Through Burnout Buddy, I had the chance to develop a production app 100% with SwiftUI. Here are my thoughts on what works and what could be improved, and how I would fit SwiftUI and UIKit in my day-to-day work. Things that are great Previews / Hot Reloading I can't stress hard enough how awesome SwiftUI's previews are. The amount of time UIKit devs were wasting compiling and running code to make small iterative UI changes is unfathomable -- yes, there were LLDB tricks and tools like Reveal which could sort of let you make certain types of changes on the fly, but I don't know anyone who was actually able to flawlessly integrate these into their day-to-day work. The previews allow you to iterate on visual changes and sometimes even the app's logic itself extremely quickly, and its ability to bootstrap itself out of any arbitrary View pairs perfectly when building composable components. To be fair, the previews aren't perfect. I had a frequent bug where the preview refused to show up and was unable to do any form of debugging on the preview itself, and a lot of people reached out to say that the previews are painfully slow on their older Macbook models, but it generally works well and I'm very happy we finally have official hot-reloading support in iOS. I'm eager to see how it will be improved in the future. Development speed Another extremely notable SwiftUI benefit is how easy it is to build apps with it. You can quite literally build an app to start to finish in just a couple of minutes, something which would be unheard of in any professional-level UIKit app (meaning no Storyboards and similar features that are known for not being scalable). While Burnout Buddy took me a couple of weeks to build, the majority of that time was spent on the logic and architecture. The UI itself for the entire app was built in just a couple of minutes. It's important to mention that this is not always true. As we'll see down below there's an entire category of \"more complicated\" products where SwiftUI is actually extremely detrimental to development speed, but we should still appreciate that SwiftUI works amazingly well for the more straight-forward category of projects that the majority of developers deal with. It's also not too surprising that this is the case considering that they have been Apple's primary target audience for Xcode features since the dawn of iOS. It encourages great coding practices It's very easy to make a UIKit app that has everything shoved into one god object. You could theoretically do the same in SwiftUI, but you'd have a much harder doing so. The way views are setup and referenced between each other encourages you to break up your views into small independent pieces, which is an amazing habit to have when building apps of any size as it improves the quality of your project in multiple areas such as composability, scalability, testability and code readability. For developers who are not yet familiar with those concepts, SwiftUI is a great tool to learn and apply those practices. Things that are not so great Great for simple things, not so great for not-so-simple things It's generally easy to build state logic with UIKit. Because there are no constraints on what things should look like, you can build everything on the fly and achieve virtually anything you want at the cost of having to write a lot of annoying UI code. SwiftUI is the opposite on steroids. It's very, very easy to build UI with, and very, very hard to build any piece of real business logic that you wouldn't see in a simple Hello World tutorial. My first thought when SwiftUI was announced was that there's no way it works seamlessly for complex apps, and I imagine that anyone who ever had experience with React on the web front had the same thought. The reason for that is because data-drivenness, SwiftUI's main concept that some people already were experienced with due to React functioning roughly in the same way, doesn't scale very well. SwiftUI forces you to shape your model in a way so that the complete structure and state of all views are static and known well in advance, which while not an impossible task, can be insanely difficult for views that have lots of moving parts and conditions. The best example I can show of how data-drivenness can massively spike the complexity of an app is SwiftUI's ForEach API: ForEach(0..\u003c7) { i in MyObject(myStrings[i]) } If all you're doing is iterating a static list of elements, everything will work like in UIKit. You can build a loop that takes a fixed integer range and access the indexes without any additional trouble. Iterating the mutable state of your view is a bit trickier, but still doable. While in UIKit this doesn't incur any extra architectural cost on your behalf, SwiftUI forbids you from doing so unless the content conforms to Identifiable. This can be quite annoying given that almost nothing in Swift's Standard Library conforms to this protocol, but the requirement makes sense in the context of SwiftUI where the framework relies on the concept of model identity and uniqueness in order to determine when the UI should be re-drawn. ForEach(myStrings) { string in MyObject(string) } // Error: String does not conform to Identifiable // Solution: Replace \"myStrings\" with: struct MyModel: Identifiable { let id = ... // How this is implemented depends // on what the model represents in practice and how it should be updated let string: String } Try to do anything more complicated than that though and you'll face the wrath of data-drivenness. Consider the simple use-case of keeping track of the position of an item in a list while iterating it, something which is very common in iOS to implement features like alternating background colors in views: While this is trivial to pull off in UIKit, attempting to introduce dynamic behavior like this in SwiftUI can result in your view's entire architecture being body slammed! ForEach(contentList.enumerated()) { info in MyObject(info.element, info.offset) } // Error: Arbitrary sequences cannot be iterated in SwiftUI, only RandomAccessCollections ForEach(Array(strings.enumerated())) { info in MyObject(info.element, info.offset) } // Error: Tuples don't conform to Identifiable, the model must expose some form of unique id Because the concept of object identity is critical in SwiftUI, if the position of an item is relevant to the UI, we must architecture our view's state model around this fact and provide/predict it in advance alongside everything else that is relevant to the view: struct ListIndexable: Identifiable { let id = ... // How this is implemented depends // on what the model represents in practice and how it should be updated let index: Int let object: T } This means that trying to add new behavior to views can result in the entire architecture of that view needing to be refactored, which is a trade-off that developers creating complicated apps would want to avoid at all costs. But before we continue, we must mention something very important in this area. Astute readers that have used SwiftUI before might look at this example and point out that you don't really need to do any of these, because there's a variation of ForEach that allows you to manually provide the Hashable value that SwiftUI will use deep-down to enforce uniqueness. This allows you to skip the Identifiable requirement and solve the .enumerated() problem with zero extra code, and if you look up this problem in StackOverflow you can even find plug-and-play extensions for this exact use-case: private func ForEachEnumerated(_ arr: Binding\u003c[T]\u003e, @ViewBuilder content: @escaping (Int, Binding) -\u003e U) -\u003e some View { let arr = Array(arr.enumerated()) return ForEach(arr, id: \\.offset, content: content) } You need to be very careful when using snippets like this in SwiftUI, because trying to out-smart the framework is a very easy way to end up with cryptic and undebuggable rendering problems. In this case the problem with the snippet is that using the index itself as the definition of uniqueness has serious implications for how SwiftUI will draw updates to that particular list, which might not be what you're expecting for your particular use-case. This is the same reason why I've refrained from implementing let id in the examples above. When working with frameworks like SwiftUI and React, you should always avoid shortcuts and take the extra time to think how to architect your view's state in a static and predictable way. I've found that this forces you to put quite a lot of pre-thinking into what you want a certain view to do, because if you forget something down the line it can be very hard to recover from it. This won't be a big deal for simple products, but if you're developing a very complicated app, you might not be willing to make that trade-off. Rendering issues are impossible to debug Almost nothing you write in SwiftUI is \"real\" Swift code. With Property Wrappers and Function Builders at its core, almost everything you write will result in the compiler generating additional wiring code for you. The fact that SwiftUI relies heavily on generated code is not a problem by itself, because as long you know what that wiring code is, you can generally follow along and debug issues just as if that wasn't the case. When the wiring code leads to closed source code however, the story is different. Here's an example of how this can negatively affect your work. In Burnout Buddy, it's possible to shortcut your way into configuring time schedules for an entire week by setting just one of them and asking the tool to copy the values into the remaining days. In code, I attempted to achieve this by creating a custom Binding object that pastes Monday's schedule into the rest of the week: let weekdayBinding = Binding\u003c[TimeRange]\u003e { schedule.days[0] } set: { range, transaction in schedule.days[0] = range schedule.days[1] = range schedule.days[2] = range schedule.days[3] = range schedule.days[4] = range } The code above however did not work. To be very specific, it does quite literally nothing. While I could breakpoint the set closure and see that it was being called correctly with the right values, the view was not being updated accordingly. To make things worse, I was also seeing other completely unrelated things being updated as a result of this code that made no sense whatsoever! The reason it didn't work? I don't know, because Binding is closed source. It took me multiple hours to even realize that this particular piece of code was the source of the problem as there was no feedback from SwiftUI itself that there was something wrong, meaning the only thing I could do was re-write parts of the app aimlessly and hope for the best. I eventually managed to solve the problem by slightly re-shaping how the closure is executed. Instead of setting each array entry one by one, I chose to copy the entire structure, change it accordingly, and then apply it back to the original bound state object. Because I couldn't actually debug the problem, I can only speculate that the bug has something to do with State not being able to process more than one update in a single stack frame. let weekdayBinding = Binding\u003c[TimeRange]\u003e { schedule.days[0] } set: { range, transaction in var days = schedule.days days[0] = range days[1] = range days[2] = range days[3] = range days[4] = range schedule.days = days } This is not a problem with SwiftUI itself, but with Apple deciding to hide critical logic (in this case, what causes a view to re-render) from you. In contrast, you'd not see problems like this in UIKit because the important bits are always handled on your side of the field (e.g when to call addSubview, layoutIfNeeded, etc). The good news is that SwiftUI is already able to warn you when you make a rendering mistake in certain cases, so Apple is definitely aware of this problem and is working on ways to make it less disruptive. Should I learn SwiftUI? Ever since the dawn of software engineering, there have been people engaging in \"platform wars\". They'll evangelize for the \"best architecture\", \"best framework\", \"best OS\", \"best design pattern\", and claim that theirs is the only option and everything else is a mistake. This is no different for iOS development, and \"SwiftUI vs UIKit\" is, sure enough, the new \"conflict' of choice. As a software engineer, it's critical for you to realize that there is no such thing as \"best X\". Everything is a tool, and whether or not you should use them depends only on what you're trying to achieve. Even Objective-C still has its uses! (If you want more examples of that, I've written a full article about how there is no right or wrong in tech.) SwiftUI and UIKit do not cancel each other; they are both good and bad in different ways, and whether or not you should pick SwiftUI specifically will depend on the details of what you're trying to build. After building a SwiftUI app myself, these are the guidelines that I would personally follow for my next projects: Simple UI, Simple Logic: Would make it 100% with SwiftUI. Simple UI, Not-so-simple Logic: I'd start with a 100% SwiftUI app, but if it got too tough I'd fall back to using SwiftUI for the UI itself and UIKit for the more complex pieces of logic (via UIViewRepresentable). Not-so-simple UI, Simple Logic: Will greatly depend on what's being built. I find that more complex pieces of UI can be a lot harder to pull off with SwiftUI when compared to UIKit. Not-so-simple UI, Not-so-simple Logic: Probably best to go 100% UIKit to avoid issues in the long run. What should beginners learn first? I think the situation right now is very similar to when Swift was released. I started with iOS exactly when that happened, and the way I learned it was by first learning as much I could about Objective-C and then using that knowledge to seamlessly move over to Swift and making that my main tool of choice. As the years went by and everyone migrated to Swift, it became less and less necessary to strictly learn Objective-C to the point where nowadays you can defer learning it until you reach a point where you want/need to expand your knowledge of the platform itself. This is how I think beginners should approach SwiftUI vs UIKit. While people will always want to learn the shiny new thing, you should always learn both whilst focusing on what the majority of people use right now to maximize your hiring opportunities. I expect that as the years go the majority of UIKit projects will move over to SwiftUI, but it's still too early to tell if UIKit will completely go away given SwiftUI's current issues when used in more complicated projects.",
  "author": "Bruno Rocha",
  "published": "Thu, 20 Oct 2022 14:00:00 GMT+2",
  "source": "https://swiftrocks.com/rss.xml",
  "categories": null,
  "byline": "Bruno Rocha",
  "length": 15216,
  "excerpt": "I had played with SwiftUI before, but it wasn't until now that I had built a complete app with it. Here's my experience!",
  "siteName": "SwiftRocks",
  "favicon": "https://swiftrocks.com/images/favicon/iconsmall2.png",
  "text": "I had played with SwiftUI sporadically in the past, but it wasn't until now that I had built a complete App Store-ready app with it. When SwiftUI was first announced I was very concerned about certain quirks of the framework and how it was probably not suitable for professional iOS development, but with the framework evolving constantly over the past couple of years it became time to re-evaluate that statement. Through Burnout Buddy, I had the chance to develop a production app 100% with SwiftUI. Here are my thoughts on what works and what could be improved, and how I would fit SwiftUI and UIKit in my day-to-day work. Things that are great Previews / Hot Reloading I can't stress hard enough how awesome SwiftUI's previews are. The amount of time UIKit devs were wasting compiling and running code to make small iterative UI changes is unfathomable -- yes, there were LLDB tricks and tools like Reveal which could sort of let you make certain types of changes on the fly, but I don't know anyone who was actually able to flawlessly integrate these into their day-to-day work. The previews allow you to iterate on visual changes and sometimes even the app's logic itself extremely quickly, and its ability to bootstrap itself out of any arbitrary View pairs perfectly when building composable components. To be fair, the previews aren't perfect. I had a frequent bug where the preview refused to show up and was unable to do any form of debugging on the preview itself, and a lot of people reached out to say that the previews are painfully slow on their older Macbook models, but it generally works well and I'm very happy we finally have official hot-reloading support in iOS. I'm eager to see how it will be improved in the future. Development speed Another extremely notable SwiftUI benefit is how easy it is to build apps with it. You can quite literally build an app to start to finish in just a couple of minutes, something which would be unheard of in any professional-level UIKit app (meaning no Storyboards and similar features that are known for not being scalable). While Burnout Buddy took me a couple of weeks to build, the majority of that time was spent on the logic and architecture. The UI itself for the entire app was built in just a couple of minutes. It's important to mention that this is not always true. As we'll see down below there's an entire category of \"more complicated\" products where SwiftUI is actually extremely detrimental to development speed, but we should still appreciate that SwiftUI works amazingly well for the more straight-forward category of projects that the majority of developers deal with. It's also not too surprising that this is the case considering that they have been Apple's primary target audience for Xcode features since the dawn of iOS. It encourages great coding practices It's very easy to make a UIKit app that has everything shoved into one god object. You could theoretically do the same in SwiftUI, but you'd have a much harder doing so. The way views are setup and referenced between each other encourages you to break up your views into small independent pieces, which is an amazing habit to have when building apps of any size as it improves the quality of your project in multiple areas such as composability, scalability, testability and code readability. For developers who are not yet familiar with those concepts, SwiftUI is a great tool to learn and apply those practices. Things that are not so great Great for simple things, not so great for not-so-simple things It's generally easy to build state logic with UIKit. Because there are no constraints on what things should look like, you can build everything on the fly and achieve virtually anything you want at the cost of having to write a lot of annoying UI code. SwiftUI is the opposite on steroids. It's very, very easy to build UI with, and very, very hard to build any piece of real business logic that you wouldn't see in a simple Hello World tutorial. My first thought when SwiftUI was announced was that there's no way it works seamlessly for complex apps, and I imagine that anyone who ever had experience with React on the web front had the same thought. The reason for that is because data-drivenness, SwiftUI's main concept that some people already were experienced with due to React functioning roughly in the same way, doesn't scale very well. SwiftUI forces you to shape your model in a way so that the complete structure and state of all views are static and known well in advance, which while not an impossible task, can be insanely difficult for views that have lots of moving parts and conditions. The best example I can show of how data-drivenness can massively spike the complexity of an app is SwiftUI's ForEach API: ForEach(0..\u003c7) { i in MyObject(myStrings[i]) } If all you're doing is iterating a static list of elements, everything will work like in UIKit. You can build a loop that takes a fixed integer range and access the indexes without any additional trouble. Iterating the mutable state of your view is a bit trickier, but still doable. While in UIKit this doesn't incur any extra architectural cost on your behalf, SwiftUI forbids you from doing so unless the content conforms to Identifiable. This can be quite annoying given that almost nothing in Swift's Standard Library conforms to this protocol, but the requirement makes sense in the context of SwiftUI where the framework relies on the concept of model identity and uniqueness in order to determine when the UI should be re-drawn. ForEach(myStrings) { string in MyObject(string) } // Error: String does not conform to Identifiable // Solution: Replace \"myStrings\" with: struct MyModel: Identifiable { let id = ... // How this is implemented depends // on what the model represents in practice and how it should be updated let string: String } Try to do anything more complicated than that though and you'll face the wrath of data-drivenness. Consider the simple use-case of keeping track of the position of an item in a list while iterating it, something which is very common in iOS to implement features like alternating background colors in views: While this is trivial to pull off in UIKit, attempting to introduce dynamic behavior like this in SwiftUI can result in your view's entire architecture being body slammed! ForEach(contentList.enumerated()) { info in MyObject(info.element, info.offset) } // Error: Arbitrary sequences cannot be iterated in SwiftUI, only RandomAccessCollections ForEach(Array(strings.enumerated())) { info in MyObject(info.element, info.offset) } // Error: Tuples don't conform to Identifiable, the model must expose some form of unique id Because the concept of object identity is critical in SwiftUI, if the position of an item is relevant to the UI, we must architecture our view's state model around this fact and provide/predict it in advance alongside everything else that is relevant to the view: struct ListIndexable\u003cT\u003e: Identifiable { let id = ... // How this is implemented depends // on what the model represents in practice and how it should be updated let index: Int let object: T } This means that trying to add new behavior to views can result in the entire architecture of that view needing to be refactored, which is a trade-off that developers creating complicated apps would want to avoid at all costs. But before we continue, we must mention something very important in this area. Astute readers that have used SwiftUI before might look at this example and point out that you don't really need to do any of these, because there's a variation of ForEach that allows you to manually provide the Hashable value that SwiftUI will use deep-down to enforce uniqueness. This allows you to skip the Identifiable requirement and solve the .enumerated() problem with zero extra code, and if you look up this problem in StackOverflow you can even find plug-and-play extensions for this exact use-case: private func ForEachEnumerated\u003cT: Hashable, U: View\u003e(_ arr: Binding\u003c[T]\u003e, @ViewBuilder content: @escaping (Int, Binding\u003cT\u003e) -\u003e U) -\u003e some View { let arr = Array(arr.enumerated()) return ForEach(arr, id: \\.offset, content: content) } You need to be very careful when using snippets like this in SwiftUI, because trying to out-smart the framework is a very easy way to end up with cryptic and undebuggable rendering problems. In this case the problem with the snippet is that using the index itself as the definition of uniqueness has serious implications for how SwiftUI will draw updates to that particular list, which might not be what you're expecting for your particular use-case. This is the same reason why I've refrained from implementing let id in the examples above. When working with frameworks like SwiftUI and React, you should always avoid shortcuts and take the extra time to think how to architect your view's state in a static and predictable way. I've found that this forces you to put quite a lot of pre-thinking into what you want a certain view to do, because if you forget something down the line it can be very hard to recover from it. This won't be a big deal for simple products, but if you're developing a very complicated app, you might not be willing to make that trade-off. Rendering issues are impossible to debug Almost nothing you write in SwiftUI is \"real\" Swift code. With Property Wrappers and Function Builders at its core, almost everything you write will result in the compiler generating additional wiring code for you. The fact that SwiftUI relies heavily on generated code is not a problem by itself, because as long you know what that wiring code is, you can generally follow along and debug issues just as if that wasn't the case. When the wiring code leads to closed source code however, the story is different. Here's an example of how this can negatively affect your work. In Burnout Buddy, it's possible to shortcut your way into configuring time schedules for an entire week by setting just one of them and asking the tool to copy the values into the remaining days. In code, I attempted to achieve this by creating a custom Binding object that pastes Monday's schedule into the rest of the week: let weekdayBinding = Binding\u003c[TimeRange]\u003e { schedule.days[0] } set: { range, transaction in schedule.days[0] = range schedule.days[1] = range schedule.days[2] = range schedule.days[3] = range schedule.days[4] = range } The code above however did not work. To be very specific, it does quite literally nothing. While I could breakpoint the set closure and see that it was being called correctly with the right values, the view was not being updated accordingly. To make things worse, I was also seeing other completely unrelated things being updated as a result of this code that made no sense whatsoever! The reason it didn't work? I don't know, because Binding is closed source. It took me multiple hours to even realize that this particular piece of code was the source of the problem as there was no feedback from SwiftUI itself that there was something wrong, meaning the only thing I could do was re-write parts of the app aimlessly and hope for the best. I eventually managed to solve the problem by slightly re-shaping how the closure is executed. Instead of setting each array entry one by one, I chose to copy the entire structure, change it accordingly, and then apply it back to the original bound state object. Because I couldn't actually debug the problem, I can only speculate that the bug has something to do with State not being able to process more than one update in a single stack frame. let weekdayBinding = Binding\u003c[TimeRange]\u003e { schedule.days[0] } set: { range, transaction in var days = schedule.days days[0] = range days[1] = range days[2] = range days[3] = range days[4] = range schedule.days = days } This is not a problem with SwiftUI itself, but with Apple deciding to hide critical logic (in this case, what causes a view to re-render) from you. In contrast, you'd not see problems like this in UIKit because the important bits are always handled on your side of the field (e.g when to call addSubview, layoutIfNeeded, etc). The good news is that SwiftUI is already able to warn you when you make a rendering mistake in certain cases, so Apple is definitely aware of this problem and is working on ways to make it less disruptive. Should I learn SwiftUI? Ever since the dawn of software engineering, there have been people engaging in \"platform wars\". They'll evangelize for the \"best architecture\", \"best framework\", \"best OS\", \"best design pattern\", and claim that theirs is the only option and everything else is a mistake. This is no different for iOS development, and \"SwiftUI vs UIKit\" is, sure enough, the new \"conflict' of choice. As a software engineer, it's critical for you to realize that there is no such thing as \"best X\". Everything is a tool, and whether or not you should use them depends only on what you're trying to achieve. Even Objective-C still has its uses! (If you want more examples of that, I've written a full article about how there is no right or wrong in tech.) SwiftUI and UIKit do not cancel each other; they are both good and bad in different ways, and whether or not you should pick SwiftUI specifically will depend on the details of what you're trying to build. After building a SwiftUI app myself, these are the guidelines that I would personally follow for my next projects: Simple UI, Simple Logic: Would make it 100% with SwiftUI. Simple UI, Not-so-simple Logic: I'd start with a 100% SwiftUI app, but if it got too tough I'd fall back to using SwiftUI for the UI itself and UIKit for the more complex pieces of logic (via UIViewRepresentable). Not-so-simple UI, Simple Logic: Will greatly depend on what's being built. I find that more complex pieces of UI can be a lot harder to pull off with SwiftUI when compared to UIKit. Not-so-simple UI, Not-so-simple Logic: Probably best to go 100% UIKit to avoid issues in the long run. What should beginners learn first? I think the situation right now is very similar to when Swift was released. I started with iOS exactly when that happened, and the way I learned it was by first learning as much I could about Objective-C and then using that knowledge to seamlessly move over to Swift and making that my main tool of choice. As the years went by and everyone migrated to Swift, it became less and less necessary to strictly learn Objective-C to the point where nowadays you can defer learning it until you reach a point where you want/need to expand your knowledge of the platform itself. This is how I think beginners should approach SwiftUI vs UIKit. While people will always want to learn the shiny new thing, you should always learn both whilst focusing on what the majority of people use right now to maximize your hiring opportunities. I expect that as the years go the majority of UIKit projects will move over to SwiftUI, but it's still too early to tell if UIKit will completely go away given SwiftUI's current issues when used in more complicated projects.",
  "image": "https://swiftrocks.com/images/thumbs/thumb.jpg?4",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \n  \n\u003cp\u003eI had played with SwiftUI sporadically in the past, but it wasn\u0026#39;t until now that I had built a complete App Store-ready app with it. When SwiftUI was first announced I was very concerned about certain quirks of the framework and how it was probably not suitable for professional iOS development, but with the framework evolving constantly over the past couple of years it became time to re-evaluate that statement. Through \u003ca href=\"https://burnoutbuddy.io\"\u003eBurnout Buddy,\u003c/a\u003e I had the chance to develop a production app 100% with SwiftUI. Here are my thoughts on what works and what could be improved, and how I would fit SwiftUI and UIKit in my day-to-day work.\u003c/p\u003e\n\u003ch2\u003eThings that are great\u003c/h2\u003e\n\u003ch3\u003ePreviews / Hot Reloading\u003c/h3\u003e\n\u003cp\u003eI can\u0026#39;t stress hard enough how awesome SwiftUI\u0026#39;s previews are. The amount of time UIKit devs were wasting compiling and running code to make small iterative UI changes is unfathomable -- yes, there were LLDB tricks and tools like \u003ci\u003eReveal\u003c/i\u003e which could sort of let you make certain types of changes on the fly, but I don\u0026#39;t know anyone who was actually able to flawlessly integrate these into their day-to-day work. The previews allow you to iterate on visual changes and sometimes even the app\u0026#39;s logic itself extremely quickly, and its ability to bootstrap itself out of any arbitrary \u003ccode\u003eView\u003c/code\u003e pairs perfectly when building composable components.\u003c/p\u003e\n\n\u003cp\u003eTo be fair, the previews aren\u0026#39;t perfect. I had a frequent bug where the preview refused to show up and was unable to do any form of debugging on the preview itself, and a lot of people reached out to say that the previews are painfully slow on their older Macbook models, but it generally works well and I\u0026#39;m very happy we finally have official hot-reloading support in iOS. I\u0026#39;m eager to see how it will be improved in the future.\u003c/p\u003e\n\u003ch3\u003eDevelopment speed\u003c/h3\u003e\n\u003cp\u003eAnother extremely notable SwiftUI benefit is how easy it is to build apps with it. You can quite literally build an app to start to finish in just a couple of minutes, something which would be unheard of in any professional-level UIKit app (meaning no Storyboards and similar features that are known for not being scalable).\u003c/p\u003e\n\u003cp\u003eWhile Burnout Buddy took me a couple of weeks to build, the majority of that time was spent on the logic and architecture. The UI itself for the entire app was built in just a couple of minutes.\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s important to mention that this is not always true. As we\u0026#39;ll see down below there\u0026#39;s an entire category of \u0026#34;more complicated\u0026#34; products where SwiftUI is actually \u003ci\u003eextremely detrimental\u003c/i\u003e to development speed, but we should still appreciate that SwiftUI works amazingly well for the more straight-forward category of projects that the majority of developers deal with. It\u0026#39;s also not too surprising that this is the case considering that they have been Apple\u0026#39;s primary target audience for Xcode features since the dawn of iOS.\u003c/p\u003e\n\u003ch3\u003eIt encourages great coding practices\u003c/h3\u003e\n\u003cp\u003eIt\u0026#39;s very easy to make a UIKit app that has everything shoved into one god object. You could theoretically do the same in SwiftUI, but you\u0026#39;d have a much harder doing so. The way views are setup and referenced between each other encourages you to break up your views into small independent pieces, which is an amazing habit to have when building apps of any size as it improves the quality of your project in multiple areas such as composability, scalability, testability and code readability. For developers who are not yet familiar with those concepts, SwiftUI is a great tool to learn and apply those practices.\u003c/p\u003e\n\u003ch2\u003eThings that are not so great\u003c/h2\u003e\n\u003ch3\u003eGreat for simple things, not so great for not-so-simple things\u003c/h3\u003e\n\u003cp\u003eIt\u0026#39;s generally easy to build state logic with UIKit. Because there are no constraints on what things should look like, you can build everything on the fly and achieve virtually anything you want at the cost of having to write a lot of annoying UI code.\u003c/p\u003e\n\u003cp\u003eSwiftUI is the opposite on steroids. It\u0026#39;s \u003cb\u003every, very easy\u003c/b\u003e to build UI with, and \u003cb\u003every, very hard\u003c/b\u003e to build any piece of real business logic that you wouldn\u0026#39;t see in a simple Hello World tutorial.\u003c/p\u003e\n\u003cp\u003eMy first thought when SwiftUI was announced was that there\u0026#39;s \u003ci\u003eno way\u003c/i\u003e it works seamlessly for complex apps, and I imagine that anyone who ever had experience with React on the web front had the same thought. The reason for that is because data-drivenness, SwiftUI\u0026#39;s main concept that some people already were experienced with due to React functioning roughly in the same way, doesn\u0026#39;t scale very well. SwiftUI forces you to shape your model in a way so that the complete structure and state of all views are static and known well in advance, which while not an impossible task, can be insanely difficult for views that have lots of moving parts and conditions.\u003c/p\u003e\n\u003cp\u003eThe best example I can show of how data-drivenness can massively spike the complexity of an app is SwiftUI\u0026#39;s \u003ccode\u003eForEach\u003c/code\u003e API:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eForEach(0..\u0026lt;7) { i in\u003c/code\u003e\n\u003ccode\u003e    MyObject(myStrings[i])\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eIf all you\u0026#39;re doing is iterating a static list of elements, everything will work like in UIKit. You can build a loop that takes a fixed integer range and access the indexes without any additional trouble.\u003c/p\u003e \n\u003cp\u003eIterating the \u003cb\u003emutable state\u003c/b\u003e of your view is a bit trickier, but still doable. While in UIKit this doesn\u0026#39;t incur any extra architectural cost on your behalf, SwiftUI forbids you from doing so unless the content conforms to \u003ccode\u003eIdentifiable\u003c/code\u003e. This can be quite annoying given that almost nothing in Swift\u0026#39;s Standard Library conforms to this protocol, but the requirement makes sense in the context of SwiftUI where the framework relies on the concept of model identity and uniqueness in order to determine when the UI should be re-drawn.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eForEach(myStrings) { string in\u003c/code\u003e\n\u003ccode\u003e    MyObject(string)\u003c/code\u003e\n\u003ccode\u003e} // Error: String does not conform to Identifiable\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e// Solution: Replace \u0026#34;myStrings\u0026#34; with:\u003c/code\u003e\n\u003ccode\u003estruct MyModel: Identifiable {\u003c/code\u003e\n\u003ccode\u003e    let id = ... // How this is implemented depends\u003c/code\u003e\n\u003ccode\u003e    // on what the model represents in practice and how it should be updated\u003c/code\u003e\n\u003ccode\u003e    let string: String\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eTry to do anything more complicated than that though and you\u0026#39;ll face the wrath of data-drivenness. Consider the simple use-case of keeping track of the position of an item in a list while iterating it, something which is very common in iOS to implement features like alternating background colors in views: While this is trivial to pull off in UIKit, attempting to introduce dynamic behavior like this in SwiftUI can result in your view\u0026#39;s entire architecture being body slammed!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eForEach(contentList.enumerated()) { info in\u003c/code\u003e\n\u003ccode\u003e    MyObject(info.element, info.offset)\u003c/code\u003e\n\u003ccode\u003e} // Error: Arbitrary sequences cannot be iterated in SwiftUI, only RandomAccessCollections\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eForEach(Array(strings.enumerated())) { info in\u003c/code\u003e\n\u003ccode\u003e    MyObject(info.element, info.offset)\u003c/code\u003e\n\u003ccode\u003e} // Error: Tuples don\u0026#39;t conform to Identifiable, the model must expose some form of unique id\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eBecause the concept of object identity is critical in SwiftUI, if the position of an item is relevant to the UI, we must architecture our view\u0026#39;s state model around this fact and provide/predict it in advance alongside everything else that is relevant to the view:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estruct ListIndexable\u0026lt;T\u0026gt;: Identifiable {\u003c/code\u003e\n\u003ccode\u003e    let id = ... // How this is implemented depends\u003c/code\u003e\n\u003ccode\u003e    // on what the model represents in practice and how it should be updated\u003c/code\u003e\n\u003ccode\u003e    let index: Int\u003c/code\u003e\n\u003ccode\u003e    let object: T\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eThis means that trying to add new behavior to views can result in the \u003ci\u003eentire architecture\u003c/i\u003e of that view needing to be refactored, which is a trade-off that developers creating complicated apps would want to avoid at all costs.\u003c/p\u003e\n\u003cp\u003eBut before we continue, we must mention something very important in this area. Astute readers that have used SwiftUI before might look at this example and point out that you don\u0026#39;t really need to do any of these, because there\u0026#39;s a variation of \u003ccode\u003eForEach\u003c/code\u003e that allows you to manually provide the \u003ccode\u003eHashable\u003c/code\u003e value that SwiftUI will use deep-down to enforce uniqueness. This allows you to skip the \u003ccode\u003eIdentifiable\u003c/code\u003e requirement and solve the \u003ccode\u003e.enumerated()\u003c/code\u003e problem with zero extra code, and if you look up this problem in StackOverflow you can even find plug-and-play extensions for this exact use-case:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprivate func ForEachEnumerated\u0026lt;T: Hashable, U: View\u0026gt;(_ arr: Binding\u0026lt;[T]\u0026gt;, @ViewBuilder content: @escaping (Int, Binding\u0026lt;T\u0026gt;) -\u0026gt; U) -\u0026gt; some View {\u003c/code\u003e\n\u003ccode\u003e    let arr = Array(arr.enumerated())\u003c/code\u003e\n\u003ccode\u003e    return ForEach(arr, id: \\.offset, content: content)\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\u003cb\u003eYou need to be very careful when using snippets like this in SwiftUI\u003c/b\u003e, because trying to out-smart the framework is a very easy way to end up with cryptic and undebuggable rendering problems. In this case the problem with the snippet is that using the index itself as the definition of uniqueness has serious implications for how SwiftUI will draw updates to that particular list, which might not be what you\u0026#39;re expecting for your particular use-case. This is the same reason why I\u0026#39;ve refrained from implementing \u003ccode\u003elet id\u003c/code\u003e in the examples above.\u003c/p\u003e\n\u003cp\u003eWhen working with frameworks like SwiftUI and React, you should always avoid shortcuts and take the extra time to think how to architect your view\u0026#39;s state in a static and predictable way. I\u0026#39;ve found that this forces you to put quite a lot of pre-thinking into what you want a certain view to do, because if you forget something down the line it can be very hard to recover from it. This won\u0026#39;t be a big deal for simple products, but if you\u0026#39;re developing a very complicated app, you might not be willing to make that trade-off.\u003c/p\u003e\n\u003ch3\u003eRendering issues are impossible to debug\u003c/h3\u003e\n\u003cp\u003eAlmost nothing you write in SwiftUI is \u0026#34;real\u0026#34; Swift code. With \u003ca href=\"https://swiftrocks.com/inside-swiftui-compiler-magic\"\u003eProperty Wrappers and Function Builders\u003c/a\u003e at its core, almost everything you write will result in the compiler generating additional wiring code for you.\u003c/p\u003e\n\u003cp\u003eThe fact that SwiftUI relies heavily on generated code is not a problem by itself, because as long you know what that wiring code is, you can generally follow along and debug issues just as if that wasn\u0026#39;t the case. When the wiring code leads to closed source code however, the story is different.\u003c/p\u003e\n\u003cp\u003eHere\u0026#39;s an example of how this can negatively affect your work. In Burnout Buddy, it\u0026#39;s possible to shortcut your way into configuring time schedules for an entire week by setting just one of them and asking the tool to copy the values into the remaining days. In code, I attempted to achieve this by creating a custom \u003ccode\u003eBinding\u003c/code\u003e object that pastes Monday\u0026#39;s schedule into the rest of the week:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet weekdayBinding = Binding\u0026lt;[TimeRange]\u0026gt; {\u003c/code\u003e\n\u003ccode\u003e    schedule.days[0]\u003c/code\u003e\n\u003ccode\u003e} set: { range, transaction in\u003c/code\u003e\n\u003ccode\u003e    schedule.days[0] = range\u003c/code\u003e\n\u003ccode\u003e    schedule.days[1] = range\u003c/code\u003e\n\u003ccode\u003e    schedule.days[2] = range\u003c/code\u003e\n\u003ccode\u003e    schedule.days[3] = range\u003c/code\u003e\n\u003ccode\u003e    schedule.days[4] = range\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eThe code above however did not work. To be very specific, it does quite literally nothing. While I could breakpoint the \u003ccode\u003eset\u003c/code\u003e closure and see that it was being called correctly with the right values, the view was not being updated accordingly. To make things worse, I was also seeing other completely unrelated things being updated as a result of this code that made no sense whatsoever!\u003c/p\u003e\n\u003cp\u003eThe reason it didn\u0026#39;t work? I don\u0026#39;t know, because \u003ccode\u003eBinding\u003c/code\u003e is closed source. It took me multiple hours to even realize that this particular piece of code was the source of the problem as there was no feedback from SwiftUI itself that there was something wrong, meaning the only thing I could do was re-write parts of the app aimlessly and hope for the best.\u003c/p\u003e\n\u003cp\u003eI eventually managed to solve the problem by slightly re-shaping how the closure is executed. Instead of setting each array entry one by one, I chose to copy the entire structure, change it accordingly, and then apply it back to the original bound state object. Because I couldn\u0026#39;t actually debug the problem, I can only speculate that the bug has something to do with \u003ccode\u003eState\u003c/code\u003e not being able to process more than one update in a single stack frame.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet weekdayBinding = Binding\u0026lt;[TimeRange]\u0026gt; {\u003c/code\u003e\n\u003ccode\u003e    schedule.days[0]\u003c/code\u003e\n\u003ccode\u003e} set: { range, transaction in\u003c/code\u003e\n\u003ccode\u003e    var days = schedule.days\u003c/code\u003e\n\u003ccode\u003e    days[0] = range\u003c/code\u003e\n\u003ccode\u003e    days[1] = range\u003c/code\u003e\n\u003ccode\u003e    days[2] = range\u003c/code\u003e\n\u003ccode\u003e    days[3] = range\u003c/code\u003e\n\u003ccode\u003e    days[4] = range\u003c/code\u003e\n\u003ccode\u003e    schedule.days = days\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eThis is not a problem with SwiftUI itself, but with Apple deciding to hide critical logic (in this case, what causes a view to re-render) from you. In contrast, you\u0026#39;d not see problems like this in UIKit because the important bits are always handled on your side of the field (e.g when to call \u003ccode\u003eaddSubview\u003c/code\u003e, \u003ccode\u003elayoutIfNeeded\u003c/code\u003e, etc).\u003c/p\u003e\n\u003cp\u003eThe good news is that SwiftUI is already able to warn you when you make a rendering mistake in certain cases, so Apple is definitely aware of this problem and is working on ways to make it less disruptive.\u003c/p\u003e\n\u003ch2\u003eShould I learn SwiftUI?\u003c/h2\u003e\n\u003cp\u003eEver since the dawn of software engineering, there have been people engaging in \u0026#34;platform wars\u0026#34;. They\u0026#39;ll evangelize for the \u0026#34;best architecture\u0026#34;, \u0026#34;best framework\u0026#34;, \u0026#34;best OS\u0026#34;, \u0026#34;best design pattern\u0026#34;, and claim that theirs is the only option and everything else is a mistake. This is no different for iOS development, and \u0026#34;SwiftUI vs UIKit\u0026#34; is, sure enough, the new \u0026#34;conflict\u0026#39; of choice.\u003c/p\u003e\n\u003cp\u003eAs a software engineer, it\u0026#39;s critical for you to realize that there is no such thing as \u0026#34;best X\u0026#34;. Everything is a tool, and whether or not you should use them depends only on what you\u0026#39;re trying to achieve. Even Objective-C still has its uses! (If you want more examples of that, \u003ca href=\"https://swiftrocks.com/there-is-no-right-or-wrong-in-software-engineering\"\u003eI\u0026#39;ve written a full article about how there is no right or wrong in tech.\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003eSwiftUI and UIKit do not cancel each other; they are both good and bad in different ways, and whether or not you should pick SwiftUI specifically will depend on the details of what you\u0026#39;re trying to build.\u003c/p\u003e\n\u003cp\u003eAfter building a SwiftUI app myself, these are the guidelines that I would personally follow for my next projects:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cb\u003eSimple UI, Simple Logic:\u003c/b\u003e Would make it 100% with SwiftUI.\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eSimple UI, Not-so-simple Logic:\u003c/b\u003e I\u0026#39;d start with a 100% SwiftUI app, but if it got too tough I\u0026#39;d fall back to using SwiftUI for the UI itself and UIKit for the more complex pieces of logic (via \u003ccode\u003eUIViewRepresentable\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eNot-so-simple UI, Simple Logic:\u003c/b\u003e Will greatly depend on what\u0026#39;s being built. I find that more complex pieces of UI can be a lot harder to pull off with SwiftUI when compared to UIKit.\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eNot-so-simple UI, Not-so-simple Logic:\u003c/b\u003e Probably best to go 100% UIKit to avoid issues in the long run.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eWhat should beginners learn first?\u003c/h2\u003e\n\u003cp\u003eI think the situation right now is very similar to when Swift was released. I started with iOS exactly when that happened, and the way I learned it was by first learning as much I could about Objective-C and then using that knowledge to seamlessly move over to Swift and making that my main tool of choice. As the years went by and everyone migrated to Swift, it became less and less necessary to strictly learn Objective-C to the point where nowadays you can defer learning it until you reach a point where you want/need to expand your knowledge of the platform itself.\u003c/p\u003e\n\n\u003cp\u003eThis is how I think beginners should approach SwiftUI vs UIKit. While people will always want to learn the shiny new thing, you should always learn both whilst focusing on what the majority of people use right now to maximize your hiring opportunities. I expect that as the years go the majority of UIKit projects will move over to SwiftUI, but it\u0026#39;s still too early to tell if UIKit will completely go away given SwiftUI\u0026#39;s current issues when used in more complicated projects.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2022-10-20T14:00:00+02:00",
  "modifiedTime": null
}
