{
  "id": "ae398ce7-0554-40d9-87f2-9f37e40d0871",
  "title": "Creating onboarding screens in SwiftUI",
  "link": "https://nerdyak.tech/development/2020/07/17/creating-onboarding-screens-in-swiftui.html",
  "description": "In this post, I would like to discuss several ways how to create onboarding/introduction screens for your app. Let me keep aside the discussion if such screens are good UX pattern, but let me rather examine SwiftUI capabilities for such task instead.",
  "author": "Pavel Zak",
  "published": "2020-07-17T00:00:00+00:00",
  "source": "https://nerdyak.tech/atom.xml",
  "categories": [
    "development",
    "SwiftUI",
    "Transition",
    "ScrollView",
    "TabView",
    "PageTabViewStyle"
  ],
  "byline": "Pavel Zak",
  "length": 7466,
  "excerpt": "In this post, I would like to discuss several ways how to create onboarding/introduction screens for your app. Let me keep aside the discussion if such screens are good UX pattern, but let me rather examine SwiftUI capabilities for such task instead.",
  "siteName": "Pavel Zak",
  "favicon": "",
  "text": "In this post, I would like to discuss several ways how to create onboarding/introduction screens for your app. Let me keep aside the discussion if such screens are good UX pattern, but let me rather examine SwiftUI capabilities for such task instead. The task The task for todayâ€™s SwiftUI exercise is simple. We would like our app to have N onboarding pages which our user can browse through at the first app launch. Browsing can be made either with a swipe gesture or by pressing the next button. Something like this: IntroPageView We will start with the preparation of a single view that contains an illustration, the title, and description. It is a basic View, you can notice that I like to use a combination of stacks and Spacers for easy alignment of the subviews. struct IntroPage { let imageName: String let title: String let description: String } struct IntroPageView: View { let page: IntroPage var body: some View { VStack { Spacer() Image(self.page.imageName) .resizable() .aspectRatio(contentMode: .fit) Spacer() Group { HStack { Text(self.page.title) .font(.title) .foregroundColor(.purple) Spacer() } HStack { Text(self.page.description) Spacer() } } .padding() } } } Using TabView If you are familiar with UIKit, you would most probably look for a Scrollview with set property isPagingEnabled = true to start with. Unfortunately, SwiftUI does not have the exact counterpart, but that does not mean, there are no solutions for our case. Of course, one can use UIScrollView based component and wrap it using UIViewRepresentable to SwiftUI, but let me focus on pure SwiftUI solutions only. Since the recent SwiftUI update, often denoted as SwiftUI2, we can use TabView for our purpose. Even though TabView is mainly purposed for Views organized in Tabbar, applying .tabViewStyle(PageTabViewStyle()) creates exactly what we would expect from a paginated scroll view, it even creates a paging indicator at the bottom of the view! (To remove or customize paging indicator appearance, set .indexViewStyle(PageIndexViewStyle()) appropriately ;) struct ContentView: View { let pages: [IntroPage] @State private var currentPage = 0 var body: some View { VStack { TabView(selection: $currentPage) { ForEach (0 ..\u003c self.pages.count) { index in IntroPageView(page: self.pages[index]) .tag(index) .padding() } } .tabViewStyle(PageTabViewStyle()) // the important part // NEXT button HStack { Spacer() Button(action: { withAnimation (.easeInOut(duration: 1.0)) { self.currentPage = (self.currentPage + 1)%self.pages.count } }) { Image(systemName: \"arrow.right\") .font(.largeTitle) .foregroundColor(Color.white) .padding() .background(Circle().fill(Color.purple)) } } .padding() } } } Nice, clean, and easy. There is only one drawback - this works on iOS14 onlyâ€¦ So what if you want/need to support iOS13 as well? As already mentioned, the standard Scrollview in SwiftUI has very limited capabilities compared to UIScrollView. It is not possible to enable pagination and prior to SwiftUI2 it was also impossible to scroll to a specific subview. (Now you can use ScrollViewReader for that purpose, but again - supported on iOS14 only) A bit harder way but with plenty of freedom is to take HStack and implement the scrolling using gesture recognizers. With this approach, you had to work with stack offset and change it according to user actions. You can inspire and/or directly use the component SwiftUIPagingScrollview that I have prepared and is available on Github. The interface is far from ideal as it requires messing with GeometryReader, but for illustration: GeometryReader { geometry in PagingScrollView(activePageIndex: self.$currentPage, itemCount: self.pages.count, pageWidth: geometry.size.width, tileWidth: geometry.size.width, tilePadding: 0) { ForEach (0 ..\u003c self.pages.count) { index in IntroPageView(page: self.pages[index]) } } } This solution gives us great scrolling experience: Transitions and id modifier If you are not very strict about direct scrolling with your finger, an interesting approach is to use custom transitions that simulate the scrolling animation. The transitions are being triggered when views are being added or removed from the view hierarchy. You can create any fancy and asymmetric transition using composition of viewModifiers, but for now we will be OK just by combination of standard moving transition, like this: extension AnyTransition { static var pageTransition: AnyTransition { let insertion = AnyTransition.move(edge: .trailing) .combined(with: .opacity) let removal = AnyTransition.move(edge: .leading) .combined(with: .opacity) return .asymmetric(insertion: insertion, removal: removal) } } Please note that I have added there also opacity change just for the fun and demonstration of transition combinations. Now, to setup several pages with transitions one could write something like this: Group { if 0 == self.currentPage { IntroPageView(page: self.pages[0]) } if 1 == self.currentPage { IntroPageView(page: self.pages[1]) } if 2 == self.currentPage { IntroPageView(page: self.pages[2]) } if 3 == self.currentPage { IntroPageView(page: self.pages[3]) } }.transition(AnyTransition.pageTransition) As you see, that is not very nice and scaleable. (But note the usage of Group view that sets the transition to each of its subviews) Much nicer and more elegant solutuon is to use identity modifier id like so: IntroPageView(page: pages[self.currentPage]) .transition(AnyTransition.pageTransition) .id(self.currentPage) Nice, right? Whenever assigned identifier changes, the view is being replaced with the new one and thus transitions are triggered both for the old view (removal) and new view (insertion). Summary Today I have tried to present several ways of building up onboarding screens in SwiftUI. I have examined three approaches that can satisfy most of the use cases - at least I believe so. Let me review them once again: Use TabView âž– iOS14 only; low coolness factor (can be tweaked with parallax effects though); cannot set animation style to tab change âž• quick and easy Implement custom Scrollview based on HStack âž– non-trivial implementation; mixing with other scrollable components might lead to issues âž• ability to fine-tune everything; great scrolling feeling Use just transitions âž– no way to mimic true scrollview behavior (if you need it) âž• clean and easy; you can go crazy with custom transitions, like the one below. But that is for another story and my next blog post ðŸ˜‰.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\" aria-label=\"Content\"\u003e\n    \u003carticle\u003e\n      \u003cdiv\u003e\n        \u003cp\u003eIn this post, I would like to discuss several ways how to create onboarding/introduction screens for your app. Let me keep aside the discussion if such screens are good UX pattern, but let me rather examine SwiftUI capabilities for such task instead.\u003c/p\u003e\n\n\u003ch2 id=\"the-task\"\u003eThe task\u003c/h2\u003e\n\n\u003cp\u003eThe task for todayâ€™s SwiftUI exercise is simple. We would like our app to have \u003ccode\u003eN\u003c/code\u003e onboarding pages which our user can browse through at the first app launch. Browsing can be made either with a swipe gesture or by pressing the next button.\u003c/p\u003e\n\n\u003cp\u003eSomething like this:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/11_vid1.gif\" alt=\"vid1\" title=\"Demonstration of onboarding screen\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"intropageview\"\u003eIntroPageView\u003c/h2\u003e\n\n\u003cp\u003eWe will start with the preparation of a single view that contains an illustration, the title, and description. It is a basic View, you can notice that I like to use a combination of \u003ccode\u003estacks\u003c/code\u003e and \u003ccode\u003eSpacers\u003c/code\u003e for easy alignment of the subviews.\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eIntroPage\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eimageName\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003edescription\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eIntroPageView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003epage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eIntroPage\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eVStack\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003eSpacer\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n            \u003cspan\u003eImage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epage\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eimageName\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresizable\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n                \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easpectRatio\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtentMode\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efit\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003eSpacer\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n            \u003cspan\u003eGroup\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003eHStack\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                    \u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epage\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efont\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforegroundColor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epurple\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                    \u003cspan\u003eSpacer\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n                \u003cspan\u003e}\u003c/span\u003e\n                \u003cspan\u003eHStack\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                    \u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epage\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edescription\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                    \u003cspan\u003eSpacer\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n                \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"using-tabview\"\u003eUsing TabView\u003c/h2\u003e\n\n\u003cp\u003eIf you are familiar with UIKit, you would most probably look for a Scrollview with set property \u003ccode\u003eisPagingEnabled = true\u003c/code\u003e to start with. Unfortunately, SwiftUI does not have the exact counterpart, but that does not mean, there are no solutions for our case. Of course, one can use \u003ccode\u003eUIScrollView\u003c/code\u003e based component and wrap it using \u003ccode\u003eUIViewRepresentable\u003c/code\u003e to SwiftUI, but let me focus on pure SwiftUI solutions only.\u003c/p\u003e\n\n\u003cp\u003eSince the recent SwiftUI update, often denoted as SwiftUI2, we can use \u003ccode\u003eTabView\u003c/code\u003e for our purpose. Even though TabView is mainly purposed for Views organized in Tabbar, applying \u003ccode\u003e.tabViewStyle(PageTabViewStyle())\u003c/code\u003e creates exactly what we would expect from a paginated scroll view, it even creates a paging indicator at the bottom of the view!\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003e(To remove or customize paging indicator appearance, set \u003ccode\u003e.indexViewStyle(PageIndexViewStyle())\u003c/code\u003e appropriately ;)\u003c/em\u003e\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eContentView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eIntroPage\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n    \n    \u003cspan\u003e@State\u003c/span\u003e \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ecurrentPage\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eVStack\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \n            \u003cspan\u003eTabView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eselection\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e$\u003c/span\u003e\u003cspan\u003ecurrentPage\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003eForEach\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e..\u0026lt;\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eindex\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n                    \u003cspan\u003eIntroPageView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n                        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etag\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n                \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etabViewStyle\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ePageTabViewStyle\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e \u003cspan\u003e// the important part\u003c/span\u003e\n        \n\t\t\t\u003cspan\u003e// NEXT button\u003c/span\u003e\n            \u003cspan\u003eHStack\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003eSpacer\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n                \u003cspan\u003eButton\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eaction\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                    \u003cspan\u003ewithAnimation\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eeaseInOut\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eduration\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1.0\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecurrentPage\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecurrentPage\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\n                    \u003cspan\u003e}\u003c/span\u003e\n                \u003cspan\u003e})\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                    \u003cspan\u003eImage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esystemName\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;arrow.right\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efont\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elargeTitle\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforegroundColor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewhite\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n                        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebackground\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eCircle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efill\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epurple\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n                \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eNice, clean, and easy. There is only one drawback - this works on iOS14 onlyâ€¦ So what if you want/need to support iOS13 as well?\u003c/p\u003e\n\n\n\n\u003cp\u003eAs already mentioned, the standard Scrollview in SwiftUI has very limited capabilities compared to UIScrollView. It is not possible to enable pagination and prior to SwiftUI2 it was also impossible to scroll to a specific subview. (Now you can use \u003ccode\u003eScrollViewReader\u003c/code\u003e for that purpose, but again - supported on iOS14 only)\u003c/p\u003e\n\n\u003cp\u003eA bit harder way but with plenty of freedom is to take \u003ccode\u003eHStack\u003c/code\u003e and implement the scrolling using gesture recognizers. With this approach, you had to work with stack offset and change it according to user actions. You can inspire and/or directly use the component \u003ca href=\"https://github.com/izakpavel/SwiftUIPagingScrollView\"\u003eSwiftUIPagingScrollview\u003c/a\u003e that I have prepared and is available on Github. The interface is far from ideal as it requires messing with \u003ccode\u003eGeometryReader\u003c/code\u003e, but for illustration:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003eGeometryReader\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003egeometry\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\t\u003cspan\u003ePagingScrollView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eactivePageIndex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003ecurrentPage\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\t\t\t\t\t \u003cspan\u003eitemCount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\t\t\t\t\t \u003cspan\u003epageWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003egeometry\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\t\t\t\t\t \u003cspan\u003etileWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003egeometry\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\t\t\t\t\t \u003cspan\u003etilePadding\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \t\u003cspan\u003eForEach\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e..\u0026lt;\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eindex\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n        \t\u003cspan\u003eIntroPageView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n   \t\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eThis solution gives us great scrolling experience:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/11_vid2.gif\" alt=\"vid2\" title=\"Implementation using custom SwiftUIPagingScrollView\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"transitions-and-id-modifier\"\u003eTransitions and \u003ccode\u003eid\u003c/code\u003e modifier\u003c/h2\u003e\n\n\u003cp\u003eIf you are not very strict about direct scrolling with your finger, an interesting approach is to use custom transitions that simulate the scrolling animation. The transitions are being triggered when views are being added or removed from the view hierarchy. You can create any fancy and asymmetric transition using composition of viewModifiers, but for now we will be OK just by combination of standard moving transition, like this:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eAnyTransition\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003epageTransition\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnyTransition\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003einsertion\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eAnyTransition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emove\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eedge\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etrailing\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecombined\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eopacity\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eremoval\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eAnyTransition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emove\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eedge\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eleading\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecombined\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eopacity\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easymmetric\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003einsertion\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003einsertion\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eremoval\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eremoval\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003ePlease note that I have added there also opacity change just for the fun and demonstration of transition combinations.\u003c/p\u003e\n\n\u003cp\u003eNow, to setup several pages with transitions one could write something like this:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003eGroup\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecurrentPage\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \t\u003cspan\u003eIntroPageView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecurrentPage\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \t\u003cspan\u003eIntroPageView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecurrentPage\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \t\u003cspan\u003eIntroPageView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecurrentPage\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \t\u003cspan\u003eIntroPageView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n\t\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etransition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eAnyTransition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epageTransition\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eAs you see, that is not very nice and scaleable. (But note the usage of \u003ccode\u003eGroup\u003c/code\u003e view that sets the transition to each of its subviews)\u003c/p\u003e\n\n\u003cp\u003eMuch nicer and more elegant solutuon is to use identity modifier \u003ccode\u003eid\u003c/code\u003e like so:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003eIntroPageView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003epages\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecurrentPage\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n\t\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etransition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eAnyTransition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epageTransition\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\t\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecurrentPage\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/11_vid3.gif\" alt=\"vid3\" title=\"Implementation with custom transitions\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eNice, right? Whenever assigned identifier changes, the view is being replaced with the new one and thus transitions are triggered both for the old view (removal) and new view (insertion).\u003c/p\u003e\n\n\u003ch2 id=\"summary\"\u003eSummary\u003c/h2\u003e\n\n\u003cp\u003eToday I have tried to present several ways of building up onboarding screens in SwiftUI. I have examined three approaches that can satisfy most of the use cases - at least I believe so. Let me review them once again:\u003c/p\u003e\n\n\u003ch3 id=\"use-tabview\"\u003eUse TabView\u003c/h3\u003e\n\n\u003cp\u003eâž– iOS14 only; low \u003cem\u003ecoolness\u003c/em\u003e factor (can be tweaked with parallax effects though); cannot set animation style to tab change\u003c/p\u003e\n\n\u003cp\u003eâž• quick and easy\u003c/p\u003e\n\n\u003ch3 id=\"implement-custom-scrollview-based-on-hstack\"\u003eImplement custom Scrollview based on HStack\u003c/h3\u003e\n\n\u003cp\u003eâž– non-trivial implementation; mixing with other scrollable components might lead to issues\u003c/p\u003e\n\n\u003cp\u003eâž• ability to fine-tune everything; great scrolling feeling\u003c/p\u003e\n\n\u003ch3 id=\"use-just-transitions\"\u003eUse just transitions\u003c/h3\u003e\n\n\u003cp\u003eâž– no way to mimic true scrollview behavior (if you need it)\u003c/p\u003e\n\n\u003cp\u003eâž• clean and easy; you can go crazy with custom transitions, like the one below. But that is for another story and my \u003ca href=\"https://nerdyak.tech/development/2020/10/12/transitions-in-swiftui.html\"\u003enext blog post\u003c/a\u003e ðŸ˜‰.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/11_vid4.gif\" alt=\"vid4\" title=\"You can be very creative with transitions\"/\u003e\u003c/p\u003e\n\n\n      \u003c/div\u003e\n      \n    \u003c/article\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2020-07-17T00:00:00Z",
  "modifiedTime": null
}
