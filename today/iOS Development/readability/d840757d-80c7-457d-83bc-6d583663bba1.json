{
  "id": "d840757d-80c7-457d-83bc-6d583663bba1",
  "title": "Observing the content offset of a SwiftUI ScrollView",
  "link": "https://www.swiftbysundell.com/articles/observing-swiftui-scrollview-content-offset",
  "description": "How the content offset of a SwiftUI ScrollView can be observed without bridging to UIKit.",
  "author": "",
  "published": "Mon, 30 Jan 2023 12:50:00 +0100",
  "source": "https://www.swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 8139,
  "excerpt": "How the content offset of a SwiftUI ScrollView can be observed without bridging to UIKit.",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "When building various kinds of scrollable UIs, it’s very common to want to observe the current scroll position (or content offset, as UIScrollView calls it) in order to trigger layout changes, load additional data when needed, or to perform other kinds of actions depending on what content that the user is currently viewing.However, when it comes to SwiftUI’s ScrollView, there’s currently (at the time of writing) no built-in way to perform such scrolling observations. While embedding a ScrollViewReader within a scroll view does enable us to change the scroll position in code, it strangely (especially given its name) doesn’t let us read the current content offset in any way.One way to solve that problem would be to utilize the rich capabilities of UIKit’s UIScrollView, which — thanks to its delegate protocol and the scrollViewDidScroll method — provides an easy way to get notified whenever any kind of scrolling occurred. However, even though I’m normally a big fan of using UIViewRepresentable and the other SwiftUI/UIKit interoperability mechanisms, in this case, we’d have to write quite a bit of extra code to bridge the gap between the two frameworks.That’s mainly because — at least on iOS — we can only embed SwiftUI content within a UIHostingController, not within a self-managed UIView. So if we wanted to build a custom, observable version of ScrollView using UIScrollView, then we’d have to wrap that implementation in a view controller, and then manage the relationship between our UIHostingController and things like the keyboard, the scroll view’s content size, safe area insets, and so on. Not impossibly by any means, but still, a fair bit of additional work and complexity.So, let’s instead see if we can find a completely SwiftUI-native way to perform such content offset observations.Resolving frames using GeometryReaderOne thing that’s key to realize before we begin is that both UIScrollView and SwiftUI’s ScrollView perform their scrolling by offsetting a container that’s hosting our actual scrollable content. They then clip that container to their bounds to produce the illusion of the viewport moving. So if we can find a way to observe the frame of that container, then we’ll essentially have found a way to observe the scroll view’s content offset.That’s where our good old friend GeometryReader comes in (wouldn’t be a proper SwiftUI layout workaround without it, right?). While GeometryReader is mostly used to access the size of the view that it’s hosted in (or, more accurately, that view’s proposed size), it also has another neat trick up its sleeve — in that it can be asked to read the frame of the current view relative to a given coordinate system.To use that capability, let’s start by creating a PositionObservingView, which lets us bind a CGPoint value to the current position of that view relative to a CoordinateSpace that we’ll also pass in as an argument. Our new view will then embed a GeometryReader as a background (which will make that geometry reader take on the same size as the view itself) and will assign the resolved frame’s origin as our offset using a preference key — like this:struct PositionObservingView\u003cContent: View\u003e: View { var coordinateSpace: CoordinateSpace @Binding var position: CGPoint @ViewBuilder var content: () -\u003e Content var body: some View { content() .background(GeometryReader { geometry in Color.clear.preference( key: PreferenceKey.self, value: geometry.frame(in: coordinateSpace).origin ) }) .onPreferenceChange(PreferenceKey.self) { position in self.position = position } } }To learn more about how the @ViewBuilder attribute can be used when building custom SwiftUI container views, check out this article.The reason we use SwiftUI’s preference system above is because our GeometryReader will be invoked as part of the view updating process, and we’re not allowed to directly mutate our view’s state during that process. So, by using a preference instead, we can deliver our CGPoint values to our view in an asynchronous fashion, which then lets us assign those values to our position binding.Now all that we need to do is to implement the PreferenceKey type that’s used above, and we’ll be good to go:private extension PositionObservingView { struct PreferenceKey: SwiftUI.PreferenceKey { static var defaultValue: CGPoint { .zero } static func reduce(value: inout CGPoint, nextValue: () -\u003e CGPoint) { // No-op } } }We don’t actually need to implement any kind of reduce algorithm above, since we’ll only have a single view delivering values using that preference key within any given hierarchy (since our implementation is entirely contained within our PositionObservingView).Alright, so now we have a view that’s capable of reading and observing its own position within a given coordinate system. Let’s now use that view to build a ScrollView wrapper that’ll let us accomplish our original goal — to be able to read the current content offset within such a scroll view.From position to content offsetOur new ScrollView wrapper will essentially have two responsibilities — one, it’ll need to convert the position of our inner PositionObservingView into the current scroll position (or content offset), and two, it’ll also need to define a CoordinateSpace that the inner view can use to resolve its position. Besides that, it’ll simply forward its configuration parameters to its underlying ScrollView, so that we can decide what axes we want each scroll view to operate on, and so that we can decide whether or not to display any scrolling indicators.The good news is that converting our inner view’s position into content offset is as easy as negating both the x and y components of those CGPoint values. That’s because, as discussed earlier, a scroll view’s content offset is essentially just the distance that the container has been moved relative to the scroll view’s bounds.So let’s go ahead and implement our custom scroll view, which we’ll name OffsetObservingScrollView (spelling out ContentOffset does feel a bit too verbose in this case):struct OffsetObservingScrollView\u003cContent: View\u003e: View { var axes: Axis.Set = [.vertical] var showsIndicators = true @Binding var offset: CGPoint @ViewBuilder var content: () -\u003e Content // The name of our coordinate space doesn't have to be // stable between view updates (it just needs to be // consistent within this view), so we'll simply use a // plain UUID for it: private let coordinateSpaceName = UUID() var body: some View { ScrollView(axes, showsIndicators: showsIndicators) { PositionObservingView( coordinateSpace: .named(coordinateSpaceName), position: Binding( get: { offset }, set: { newOffset in offset = CGPoint( x: -newOffset.x, y: -newOffset.y ) } ), content: content ) } .coordinateSpace(name: coordinateSpaceName) } }Note how we’re able to create a completely custom Binding for our inner view’s position parameter, by defining a getter and setter using closures. That’s a great option in situations like the one above, when we want to transform a value before assigning it to another Binding.That’s it! We now have a drop-in replacement for SwiftUI’s built-in ScrollView which enables us to observe the current content offset — which we can then bind to any state property that we’d like, for example in order to change the layout of a header view, to report analytics events to our server, or to perform any other kind of scroll position-based operation. You can find a complete example that uses the above OffsetObservingScrollView in order to implement a collapsable header view right here.I hope that you found this article useful. If you have any questions, comments, or feedback, then feel free to contact me on Mastodon, or send me an email.Thanks for reading!",
  "image": "https://www.swiftbysundell.com/images/articles/observing-swiftui-scrollview-content-offset.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eWhen building various kinds of scrollable UIs, it’s very common to want to observe the current scroll position (or \u003cem\u003econtent offset\u003c/em\u003e, as \u003ccode\u003eUIScrollView\u003c/code\u003e calls it) in order to trigger layout changes, load additional data when needed, or to perform other kinds of actions depending on what content that the user is currently viewing.\u003c/p\u003e\u003cp\u003eHowever, when it comes to SwiftUI’s \u003ccode\u003eScrollView\u003c/code\u003e, there’s currently (at the time of writing) no built-in way to perform such scrolling observations. While embedding a \u003ccode\u003eScrollViewReader\u003c/code\u003e within a scroll view does enable us to \u003cem\u003echange\u003c/em\u003e the scroll position in code, it strangely (especially given its name) doesn’t let us \u003cem\u003eread\u003c/em\u003e the current content offset in any way.\u003c/p\u003e\u003cp\u003eOne way to solve that problem would be to utilize the rich capabilities of UIKit’s \u003ccode\u003eUIScrollView\u003c/code\u003e, which — thanks to its delegate protocol and the \u003ccode\u003escrollViewDidScroll\u003c/code\u003e method — provides an easy way to get notified whenever any kind of scrolling occurred. However, even though I’m normally a big fan of using \u003ccode\u003eUIViewRepresentable\u003c/code\u003e and the other \u003ca href=\"https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-1\"\u003eSwiftUI/UIKit interoperability mechanisms\u003c/a\u003e, in this case, we’d have to write quite a bit of extra code to bridge the gap between the two frameworks.\u003c/p\u003e\u003cp\u003eThat’s mainly because — at least on iOS — we can only embed SwiftUI content within a \u003ccode\u003eUIHostingController\u003c/code\u003e, not within a self-managed \u003ccode\u003eUIView\u003c/code\u003e. So if we wanted to build a custom, observable version of \u003ccode\u003eScrollView\u003c/code\u003e using \u003ccode\u003eUIScrollView\u003c/code\u003e, then we’d have to wrap that implementation in a view controller, and then manage the relationship between our \u003ccode\u003eUIHostingController\u003c/code\u003e and things like the keyboard, the scroll view’s content size, safe area insets, and so on. Not impossibly by any means, but still, a fair bit of additional work and complexity.\u003c/p\u003e\u003cp\u003eSo, let’s instead see if we can find a completely SwiftUI-native way to perform such content offset observations.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"resolving-frames-using-geometryreader\" href=\"#resolving-frames-using-geometryreader\"\u003eResolving frames using GeometryReader\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eOne thing that’s key to realize before we begin is that both \u003ccode\u003eUIScrollView\u003c/code\u003e and SwiftUI’s \u003ccode\u003eScrollView\u003c/code\u003e perform their scrolling by offsetting a container that’s hosting our actual scrollable content. They then clip that container to their bounds to produce the illusion of the viewport moving. So if we can find a way to observe the \u003cem\u003eframe of that container\u003c/em\u003e, then we’ll essentially have found a way to observe the scroll view’s content offset.\u003c/p\u003e\u003cp\u003eThat’s where our good old friend \u003ccode\u003eGeometryReader\u003c/code\u003e comes in (wouldn’t be a proper SwiftUI layout workaround without it, right?). While \u003ccode\u003eGeometryReader\u003c/code\u003e is mostly used to access the \u003ccode\u003esize\u003c/code\u003e of the view that it’s hosted in (or, more accurately, that view’s \u003cem\u003eproposed size\u003c/em\u003e), it also has another neat trick up its sleeve — in that it can be asked to read the \u003ccode\u003eframe\u003c/code\u003e of the current view relative to a given coordinate system.\u003c/p\u003e\u003cp\u003eTo use that capability, let’s start by creating a \u003ccode\u003ePositionObservingView\u003c/code\u003e, which lets us bind a \u003ccode\u003eCGPoint\u003c/code\u003e value to the current position of that view relative to a \u003ccode\u003eCoordinateSpace\u003c/code\u003e that we’ll also pass in as an argument. Our new view will then embed a \u003ccode\u003eGeometryReader\u003c/code\u003e as a background (which will make that geometry reader take on the same size as the view itself) and will assign the resolved frame’s \u003ccode\u003eorigin\u003c/code\u003e as our offset using a preference key — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e PositionObservingView\u0026lt;Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003evar\u003c/span\u003e coordinateSpace: \u003cspan\u003eCoordinateSpace\u003c/span\u003e\n\u003cspan\u003e@Binding var\u003c/span\u003e position: \u003cspan\u003eCGPoint\u003c/span\u003e\u003c/span\u003e\n    \u003cspan\u003e@ViewBuilder var\u003c/span\u003e content: () -\u0026gt; \u003cspan\u003eContent\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003econtent\u003c/span\u003e()\n            .\u003cspan\u003ebackground\u003c/span\u003e(\u003cspan\u003eGeometryReader\u003c/span\u003e { geometry \u003cspan\u003ein\u003c/span\u003e\n                \u003cspan\u003e\u003cspan\u003eColor\u003c/span\u003e.\u003cspan\u003eclear\u003c/span\u003e.\u003cspan\u003epreference\u003c/span\u003e(\n    key: \u003cspan\u003ePreferenceKey\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e,\n    value: geometry.\u003cspan\u003eframe\u003c/span\u003e(in: coordinateSpace).\u003cspan\u003eorigin\u003c/span\u003e\n)\u003c/span\u003e\n            })\n            .\u003cspan\u003eonPreferenceChange\u003c/span\u003e(\u003cspan\u003ePreferenceKey\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e) { position \u003cspan\u003ein\u003c/span\u003e\n                \u003cspan\u003e\u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eposition\u003c/span\u003e = position\u003c/span\u003e\n            }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo learn more about how the \u003ccode\u003e@ViewBuilder\u003c/code\u003e attribute can be used when building custom SwiftUI container views, \u003ca href=\"https://www.swiftbysundell.com/tips/annotating-properties-with-result-builder-attributes\"\u003echeck out this article\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe reason we use SwiftUI’s preference system above is because our \u003ccode\u003eGeometryReader\u003c/code\u003e will be invoked as part of the view updating process, and we’re not allowed to directly mutate our view’s state during that process. So, by using a preference instead, we can deliver our \u003ccode\u003eCGPoint\u003c/code\u003e values to our view in an asynchronous fashion, which then lets us assign those values to our \u003ccode\u003eposition\u003c/code\u003e binding.\u003c/p\u003e\u003cp\u003eNow all that we need to do is to implement the \u003ccode\u003ePreferenceKey\u003c/code\u003e type that’s used above, and we’ll be good to go:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprivate extension\u003c/span\u003e \u003cspan\u003ePositionObservingView\u003c/span\u003e {\n    \u003cspan\u003estruct\u003c/span\u003e PreferenceKey: \u003cspan\u003eSwiftUI\u003c/span\u003e.\u003cspan\u003ePreferenceKey\u003c/span\u003e {\n        \u003cspan\u003estatic var\u003c/span\u003e defaultValue: \u003cspan\u003eCGPoint\u003c/span\u003e { .\u003cspan\u003ezero\u003c/span\u003e }\n\n        \u003cspan\u003estatic func\u003c/span\u003e reduce(value: \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e, nextValue: () -\u0026gt; \u003cspan\u003eCGPoint\u003c/span\u003e) {\n            \u003cspan\u003e// No-op\u003c/span\u003e\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe don’t actually need to implement any kind of \u003ccode\u003ereduce\u003c/code\u003e algorithm above, since we’ll only have a single view delivering values using that preference key within any given hierarchy (since our implementation is entirely contained within our \u003ccode\u003ePositionObservingView\u003c/code\u003e).\u003c/p\u003e\u003cp\u003eAlright, so now we have a view that’s capable of reading and observing its own position within a given coordinate system. Let’s now use that view to build a \u003ccode\u003eScrollView\u003c/code\u003e wrapper that’ll let us accomplish our original goal — to be able to read the current content offset within such a scroll view.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"from-position-to-content-offset\" href=\"#from-position-to-content-offset\"\u003eFrom position to content offset\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eOur new \u003ccode\u003eScrollView\u003c/code\u003e wrapper will essentially have two responsibilities — one, it’ll need to convert the position of our inner \u003ccode\u003ePositionObservingView\u003c/code\u003e into the current scroll position (or content offset), and two, it’ll also need to define a \u003ccode\u003eCoordinateSpace\u003c/code\u003e that the inner view can use to resolve its position. Besides that, it’ll simply forward its configuration parameters to its underlying \u003ccode\u003eScrollView\u003c/code\u003e, so that we can decide what \u003ccode\u003eaxes\u003c/code\u003e we want each scroll view to operate on, and so that we can decide whether or not to display any scrolling indicators.\u003c/p\u003e\u003cp\u003eThe good news is that converting our inner view’s position into content offset is as easy as negating both the \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e components of those \u003ccode\u003eCGPoint\u003c/code\u003e values. That’s because, as discussed earlier, a scroll view’s content offset is essentially just the distance that the container has been moved relative to the scroll view’s bounds.\u003c/p\u003e\u003cp\u003eSo let’s go ahead and implement our custom scroll view, which we’ll name \u003ccode\u003eOffsetObservingScrollView\u003c/code\u003e (spelling out \u003ccode\u003eContentOffset\u003c/code\u003e does feel a bit too verbose in this case):\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e OffsetObservingScrollView\u0026lt;Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e axes: \u003cspan\u003eAxis\u003c/span\u003e.\u003cspan\u003eSet\u003c/span\u003e = [.\u003cspan\u003evertical\u003c/span\u003e]\n    \u003cspan\u003evar\u003c/span\u003e showsIndicators = \u003cspan\u003etrue\n    @Binding var\u003c/span\u003e offset: \u003cspan\u003eCGPoint\u003c/span\u003e\n    \u003cspan\u003e@ViewBuilder var\u003c/span\u003e content: () -\u0026gt; \u003cspan\u003eContent\u003c/span\u003e\n\n    \u003cspan\u003e// The name of our coordinate space doesn\u0026#39;t have to be\n    // stable between view updates (it just needs to be\n    // consistent within this view), so we\u0026#39;ll simply use a\n    // plain UUID for it:\u003c/span\u003e\n    \u003cspan\u003eprivate let\u003c/span\u003e \u003cspan\u003ecoordinateSpaceName = \u003cspan\u003eUUID\u003c/span\u003e()\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eScrollView\u003c/span\u003e(axes, showsIndicators: showsIndicators) {\n            \u003cspan\u003ePositionObservingView\u003c/span\u003e(\n                coordinateSpace: \u003cspan\u003e.\u003cspan\u003enamed\u003c/span\u003e(coordinateSpaceName)\u003c/span\u003e,\n                position: \u003cspan\u003eBinding\u003c/span\u003e(\n                    get: { offset },\n                    set: { newOffset \u003cspan\u003ein\u003c/span\u003e\n                        \u003cspan\u003eoffset = \u003cspan\u003eCGPoint\u003c/span\u003e(\n    x: -newOffset.\u003cspan\u003ex\u003c/span\u003e,\n    y: -newOffset.\u003cspan\u003ey\u003c/span\u003e\n)\u003c/span\u003e\n                    }\n                ),\n                content: content\n            )\n        }\n        \u003cspan\u003e.\u003cspan\u003ecoordinateSpace\u003c/span\u003e(name: coordinateSpaceName)\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote how we’re able to create a completely custom \u003ccode\u003eBinding\u003c/code\u003e for our inner view’s \u003ccode\u003eposition\u003c/code\u003e parameter, by defining a getter and setter using closures. That’s a great option in situations like the one above, when we want to transform a value before assigning it to another \u003ccode\u003eBinding\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThat’s it! We now have a drop-in replacement for SwiftUI’s built-in \u003ccode\u003eScrollView\u003c/code\u003e which enables us to observe the current content offset — which we can then bind to any state property that we’d like, for example in order to change the layout of a header view, to report analytics events to our server, or to perform any other kind of scroll position-based operation. You can find a complete example that uses the above \u003ccode\u003eOffsetObservingScrollView\u003c/code\u003e in order to implement a collapsable header view \u003ca href=\"https://gist.github.com/JohnSundell/341f5855f4ede71a7741e99881c74daf\"\u003eright here\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eI hope that you found this article useful. If you have any questions, comments, or feedback, then feel free to \u003ca href=\"https://mastodon.social/@johnsundell\"\u003econtact me on Mastodon\u003c/a\u003e, or \u003ca href=\"https://www.swiftbysundell.com/contact\"\u003esend me an email\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": null,
  "modifiedTime": null
}
