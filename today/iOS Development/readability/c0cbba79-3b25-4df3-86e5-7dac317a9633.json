{
  "id": "c0cbba79-3b25-4df3-86e5-7dac317a9633",
  "title": "SwiftUI Default Scroll Anchor",
  "link": "https://useyourloaf.com/blog/swiftui-default-scroll-anchor/",
  "description": "Changing the default behaviour of a scroll view to center content only when it’s smaller than the scroll view container. Adapting To Content Size Changes With A Scroll View I have a view that shows the state and progress of a database update process: struct ContentView: View { let state: UpdateState var body: some View { NavigationStack { UpdaterView(state: state) } } } Here’s how it looks at the default dynamic type size on an iPhone SE: My UpdaterView is a VStack containing a label, progress view and an error view. The error view is empty unless there is an error: private struct UpdaterView: View { let state: UpdateState var body: some View { VStack(alignment: .center) { Label(\"Database updates\", systemImage: \"gear\") .labelStyle(UpdaterLabelStyle()) .padding() ProgressView(value: state.value) { Text(state.title) .padding(.bottom) } .padding() ErrorView(error: state.error) .padding() } .multilineTextAlignment(.center) .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 12)) } } The vertical size of the view can change dramatically depending on the dynamic type size and the size of any error message. At the larger contents sizes it quickly becomes too big for some devices: This is familiar territory when adapting for dynamic type sizes. Embedding the whole view in a scroll view solves that problem. ScrollView { UpdaterView(state: state) } Here’s how that looks at the largest dynamic type sizes: Unfortunately, there’s a new problem. When the content height fits in the scroll view container I want it vertically centered in the screen. The default scroll view behaviour puts the content at the top of the screen. Default Scroll Anchor (iOS 17) Apple added the defaultScrollAnchor(_:) modifier to scroll views in iOS 17. The documentation suggests we use this to change how the scroll view initially positions the content: Use this modifier to specify an anchor to control both which part of the scroll view’s content should be visible initially and how the scroll view handles content size changes. The modifier takes an anchor point on the content (.top, .center, .bottom, etc.). So with a default anchor of .center our content starts in the center of the scroll views container: ScrollView { UpdaterView(state: state) } .defaultScrollAnchor(.center) That helps until our content grows larger than the scroll view container. The top of the content is now initially offscreen: We only want to center the content when it’s smaller than the scroll view container size. When the content is larger we want to start with the top of the content. There’s no obvious way to do that with the defaultScrollAnchor as provided by iOS 17. Scroll Anchor Role (iOS 18) In iOS 18, Apple gaves us a new scroll view modifier, defaultScrollAnchor(_:for:) with finer grained controls. This has a role parameter that allows us to customize the default behaviour for three different situations (roles): .initialOffset: Where a scroll view should initially position content. .sizeChanges: How to handle content or container size changes. .alignment: How to align content smaller than the container size. It’s the last role, .alignment, that fits our needs. Applying the modifier to center the content only for the alignment role without changing the default initial offset. ScrollView { UpdaterView(state: state) } .defaultScrollAnchor(.center, for: .alignment) Now when the content is larger than the scroll view container it starts at the top, but when it’s smaller it’s centered. I don’t need it but you can apply the two variants of the view modifier together to first change the default and then override the anchor for specific roles. For example, to default to using a bottom anchor but keep a center anchor for when the content is smaller than the container: ScrollView { UpdaterView(state: state) } .defaultScrollAnchor(.bottom) .defaultScrollAnchor(.center, for: .alignment) SwiftUI Default Scroll Anchor was originally posted 24 Mar 2025 on useyourloaf.com. Want this direct to your inbox? Sign up and get my free WWDC viewing guide PDF.",
  "author": "",
  "published": "Mon, 24 Mar 2025 10:11:01 +0000",
  "source": "https://useyourloaf.com/blog/rss.xml",
  "categories": null,
  "byline": "",
  "length": 4057,
  "excerpt": "Changing the default behaviour of a scroll view to center content only when it's smaller than the scroll view container.",
  "siteName": "Use Your Loaf - iOS Development News \u0026 Tips",
  "favicon": "https://useyourloaf.com/apple-touch-icon.png",
  "text": "Changing the default behaviour of a scroll view to center content only when it’s smaller than the scroll view container. Adapting To Content Size Changes With A Scroll View I have a view that shows the state and progress of a database update process: struct ContentView: View { let state: UpdateState var body: some View { NavigationStack { UpdaterView(state: state) } } } Here’s how it looks at the default dynamic type size on an iPhone SE: My UpdaterView is a VStack containing a label, progress view and an error view. The error view is empty unless there is an error: private struct UpdaterView: View { let state: UpdateState var body: some View { VStack(alignment: .center) { Label(\"Database updates\", systemImage: \"gear\") .labelStyle(UpdaterLabelStyle()) .padding() ProgressView(value: state.value) { Text(state.title) .padding(.bottom) } .padding() ErrorView(error: state.error) .padding() } .multilineTextAlignment(.center) .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 12)) } } The vertical size of the view can change dramatically depending on the dynamic type size and the size of any error message. At the larger contents sizes it quickly becomes too big for some devices: This is familiar territory when adapting for dynamic type sizes. Embedding the whole view in a scroll view solves that problem. ScrollView { UpdaterView(state: state) } Here’s how that looks at the largest dynamic type sizes: Unfortunately, there’s a new problem. When the content height fits in the scroll view container I want it vertically centered in the screen. The default scroll view behaviour puts the content at the top of the screen. Default Scroll Anchor (iOS 17) Apple added the defaultScrollAnchor(_:) modifier to scroll views in iOS 17. The documentation suggests we use this to change how the scroll view initially positions the content: Use this modifier to specify an anchor to control both which part of the scroll view’s content should be visible initially and how the scroll view handles content size changes. The modifier takes an anchor point on the content (.top, .center, .bottom, etc.). So with a default anchor of .center our content starts in the center of the scroll views container: ScrollView { UpdaterView(state: state) } .defaultScrollAnchor(.center) That helps until our content grows larger than the scroll view container. The top of the content is now initially offscreen: We only want to center the content when it’s smaller than the scroll view container size. When the content is larger we want to start with the top of the content. There’s no obvious way to do that with the defaultScrollAnchor as provided by iOS 17. Scroll Anchor Role (iOS 18) In iOS 18, Apple gaves us a new scroll view modifier, defaultScrollAnchor(_:for:) with finer grained controls. This has a role parameter that allows us to customize the default behaviour for three different situations (roles): .initialOffset: Where a scroll view should initially position content. .sizeChanges: How to handle content or container size changes. .alignment: How to align content smaller than the container size. It’s the last role, .alignment, that fits our needs. Applying the modifier to center the content only for the alignment role without changing the default initial offset. ScrollView { UpdaterView(state: state) } .defaultScrollAnchor(.center, for: .alignment) Now when the content is larger than the scroll view container it starts at the top, but when it’s smaller it’s centered. I don’t need it but you can apply the two variants of the view modifier together to first change the default and then override the anchor for specific roles. For example, to default to using a bottom anchor but keep a center anchor for when the content is smaller than the container: ScrollView { UpdaterView(state: state) } .defaultScrollAnchor(.bottom) .defaultScrollAnchor(.center, for: .alignment)",
  "image": "https://useyourloaf.com/blog/swiftui-default-scroll-anchor/cover.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eChanging the default behaviour of a scroll view to center content only when it’s smaller than the scroll view container.\u003c/p\u003e\n\u003ch3 id=\"adapting-to-content-size-changes-with-a-scroll-view\"\u003eAdapting To Content Size Changes With A Scroll View\u003c/h3\u003e\n\u003cp\u003eI have a view that shows the state and progress of a database update process:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eContentView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUpdateState\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eNavigationStack\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eUpdaterView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere’s how it looks at the default dynamic type size on an iPhone SE:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/001.png\" alt=\"Dialog titled database updates with a gear icon and progress bar at 50% labelled preparing updates centered in iPhone SE\" width=\"230\" height=\"480\" srcset=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/001@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eMy \u003ccode\u003eUpdaterView\u003c/code\u003e is a \u003ccode\u003eVStack\u003c/code\u003e containing a label, progress view and an error view. The error view is empty unless there is an error:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eUpdaterView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUpdateState\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eVStack\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ealignment\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eLabel\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Database updates\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esystemImage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;gear\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elabelStyle\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eUpdaterLabelStyle\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eProgressView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e              \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e(.\u003c/span\u003e\u003cspan\u003ebottom\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eErrorView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emultilineTextAlignment\u003c/span\u003e\u003cspan\u003e(.\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebackground\u003c/span\u003e\u003cspan\u003e(.\u003c/span\u003e\u003cspan\u003eregularMaterial\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ein\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eRoundedRectangle\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe vertical size of the view can change dramatically depending on the dynamic type size and the size of any error message. At the larger contents sizes it quickly becomes too big for some devices:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/002.png\" alt=\"View filling an iPhone SE screen with truncated title and error message\" width=\"230\" height=\"480\" srcset=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/002@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eThis is familiar territory when adapting for dynamic type sizes. Embedding the whole view in a scroll view solves that problem.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eScrollView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eUpdaterView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere’s how that looks at the largest dynamic type sizes:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/003.png\" alt=\"View scrolling off the bottom of screen without truncation\" width=\"230\" height=\"480\" srcset=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/003@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eUnfortunately, there’s a new problem. When the content height fits in the scroll view container I want it \u003cstrong\u003evertically centered\u003c/strong\u003e in the screen. The default scroll view behaviour puts the content at the \u003cstrong\u003etop\u003c/strong\u003e of the screen.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/004.png\" alt=\"View at normal text size positioned at top of screen\" width=\"230\" height=\"480\" srcset=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/004@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"default-scroll-anchor-ios-17\"\u003eDefault Scroll Anchor (iOS 17)\u003c/h3\u003e\n\u003cp\u003eApple added the \u003ccode\u003edefaultScrollAnchor(_:)\u003c/code\u003e modifier to scroll views in iOS 17. The documentation suggests we use this to change how the scroll view initially positions the content:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUse this modifier to specify an anchor to control both which part of the scroll view’s content should be visible initially and how the scroll view handles content size changes.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eThe modifier takes an anchor point on the content (\u003ccode\u003e.top\u003c/code\u003e, \u003ccode\u003e.center\u003c/code\u003e, \u003ccode\u003e.bottom\u003c/code\u003e, etc.). So with a default anchor of \u003ccode\u003e.center\u003c/code\u003e our content starts in the center of the scroll views container:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eScrollView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eUpdaterView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefaultScrollAnchor\u003c/span\u003e\u003cspan\u003e(.\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/005.png\" alt=\"View at normal text size in center of screen\" width=\"230\" height=\"480\" srcset=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/005@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eThat helps until our content grows larger than the scroll view container. The top of the content is now initially offscreen:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/006.png\" alt=\"View at accessibility text size overflowing top and bottom of screen\" width=\"230\" height=\"480\" srcset=\"https://useyourloaf.com/blog/swiftui-default-scroll-anchor/006@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe only want to center the content when it’s \u003cstrong\u003esmaller than the scroll view container size\u003c/strong\u003e. When the content is larger we want to start with the top of the content. There’s no obvious way to do that with the \u003ccode\u003edefaultScrollAnchor\u003c/code\u003e as provided by iOS 17.\u003c/p\u003e\n\u003ch3 id=\"scroll-anchor-role-ios-18\"\u003eScroll Anchor Role (iOS 18)\u003c/h3\u003e\n\u003cp\u003eIn iOS 18, Apple gaves us a new scroll view modifier, \u003ccode\u003edefaultScrollAnchor(_:for:)\u003c/code\u003e with finer grained controls. This has a role parameter that allows us to customize the default behaviour for three different situations (roles):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e.initialOffset:\u003c/strong\u003e Where a scroll view should initially position content.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e.sizeChanges:\u003c/strong\u003e How to handle content or container size changes.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e.alignment:\u003c/strong\u003e How to align content smaller than the container size.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt’s the last role, \u003ccode\u003e.alignment\u003c/code\u003e, that fits our needs. Applying the modifier to center the content only for the alignment role without changing the  default initial offset.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eScrollView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eUpdaterView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefaultScrollAnchor\u003c/span\u003e\u003cspan\u003e(.\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ealignment\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow when the content is larger than the scroll view container it starts at the top, but when it’s smaller it’s centered.\u003c/p\u003e\n\u003cp\u003eI don’t need it but you can apply the two variants of the view modifier together to first change the default and then override the anchor for specific roles. For example, to default to using a bottom anchor but keep a center anchor for when the content is smaller than the container:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eScrollView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eUpdaterView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefaultScrollAnchor\u003c/span\u003e\u003cspan\u003e(.\u003c/span\u003e\u003cspan\u003ebottom\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefaultScrollAnchor\u003c/span\u003e\u003cspan\u003e(.\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ealignment\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-03-24T10:11:01Z",
  "modifiedTime": "2025-03-24T10:21:22Z"
}
