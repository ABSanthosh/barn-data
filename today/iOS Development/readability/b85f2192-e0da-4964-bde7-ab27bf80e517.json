{
  "id": "b85f2192-e0da-4964-bde7-ab27bf80e517",
  "title": "Clash of the Optionals",
  "link": "https://atomicbird.com/blog/clash-of-the-optionals/",
  "description": "…or, how to accidentally break Swift initialization rules. Today I’m going to talk about optionals. Swift optionals. And also another kind of optional. And how you might break the ironclad rules of Swift without realizing it until it’s too late. What is an “optional” anyway? It depends who you ask. Swift will give you one answer, but Core Data has other ideas. So what happens when you bring them together?",
  "author": "",
  "published": "Fri, 21 Jan 2022 00:00:00 +0000",
  "source": "https://atomicbird.com/index.xml",
  "categories": null,
  "byline": "",
  "length": 6951,
  "excerpt": "…or, how to accidentally break Swift initialization rules. Today I’m going to talk about optionals. Swift optionals. And also another kind of optional. And how you might break the ironclad rules of Swift without realizing it until it’s too late. What is an “optional” anyway? It depends who you ask. Swift will give you one answer, but Core Data has other ideas. So what happens when you bring them together?",
  "siteName": "Title",
  "favicon": "https://atomicbird.com/apple-touch-icon-144-precomposed.png",
  "text": "…or, how to accidentally break Swift initialization rules. Today I’m going to talk about optionals. Swift optionals. And also another kind of optional. And how you might break the ironclad rules of Swift without realizing it until it’s too late. What is an “optional” anyway? It depends who you ask. Swift will give you one answer, but Core Data has other ideas. So what happens when you bring them together? Why are my properties optional? A common occurrence: A developer is working on a Core Data model. There’s a checkbox in the model editor that says “optional”, which can be on or off. Ah, the developer thinks, this property should never be nil, so I’ll turn off the “optional” setting. But then Xcode generates some code for them and the property looks like this: @NSManaged var timestamp: Date? Why is it optional? Didn’t you just uncheck the “optional” box? You did, but you unchecked optionality for Core Data. And the thing is, Core Data doesn’t know anything about Swift. It has something called an optional value but it’s unrelated to Swift optionals. In some ways they’re the same. For both, “optional” means you don’t have to have a value. You can have nil, indicating “no value”. Trouble starts with things that aren’t optional. What does non-optional mean? For Swift, “not optional” means the property must not be nil at any time after initialization. The compiler enforces this, so that it’s not even possible to check for nil values. For Core Data, “not optional” means the property must not be nil when you are saving changes in Core Data. At any other time, nil is fine. The compiler doesn’t know anything about it, but the framework enforces the rule when the app runs. Xcode uses optional values in generated code because it’s the safest way to deal with this difference. If the property is a Swift optional, it can handle Core Data’s looser restrictions safely. If it’s not optional? Read on. What if I change the code? It doesn’t have to be this way. But as often happens, if you decide to not use the safe approach, you need to be aware of the trouble you might be asking for. It’s pretty common to let Xcode generate Core Data classes but it’s not necessary. Since checking for nil all the time can be a pain when your property isn’t supposed to be optional, you might wonder about changing the declaration. You could write your own NSManagedObject subclass code and remove the ?: @NSManaged var timestamp: Date And… it works! Both Swift and Core Data are OK with this. Why? Swift and Core Data don’t know shit about each other, that’s why. Swift has no idea about the data model, so it has no way to know if the property declaration is correct. Core Data doesn’t know anything about your subclass declarations, so it also has no way to check for accuracy. When you see @NSManaged in the code, it’s a red flag that Swift rules may not apply here. An @NSManaged property doesn’t, well, exist when the code compiles. Instead, it’s a promise that Core Data will add the property dynamically when the app runs. Literally, Core Data will change the class definition in memory to add properties that match the data model, and you promise that the property is the same type. This kind of magic is built in to Objective-C, which probably means that Core Data will never be fully Swiftified without code-breaking changes. That’s why generated code is a good thing here. The data model and the code are separate, but they must declare the same data type. If not, your app will crash with an error saying something like Unacceptable type of value for attribute. But you said it works! It does work! In this case. Since Swift and Core Data aren’t on speaking terms, changing the declaration works as long as you only change optionality. Well, it works if you’re careful. But there’s a catch. Let’s say you create a new managed object and then forget to give timestamp a value. let newEvent = Event(context:myContext) // Oops! Forgot to assign a value to newEvent.timestamp! Guess what, you just broke Swift’s initializer rules! Specifically, you initialized an object but didn’t provide a values for all of its non-optional properties. Nobody stopped you because @NSManaged says the rules don’t apply. You’ve just built a bomb. Later on you try to use newEvent.timestamp. print(\"Date: \\(newEvent.timestamp)\") What do you think will happen? What value do you expect? Let’s think this through. Core Data initialized the object, but it doesn’t know Swift’s rules and it doesn’t care about nil values until you save changes. So the value is nil. Swift knows that initialization finished and there’s a non-optional property. It’s impossible for non-optional properties to be nil at this point, according to Swift. You can’t even check for nil values, that’s how definite this is. So it’s… not nil? There’s no built-in resolution for this conflict. When your code reaches the line above, it crashes with an error attempting to bridge Objective-C and Swift. The backtrack will end in something like Foundation.Date._unconditionallyBridgeFromObjectiveC(Swift.Optional\u003c__C.NSDate\u003e) -\u003e Foundation.Date + 48 Ouch. There is a way to check for nil first, but you have to pretty much forget that you’re using Swift first and fall back on key-value coding. Do something like this: if newEvent.value(forKey: \"timestamp\") != nil { print(\"Date: \\(newEvent.timestamp)\") } That checks for a nil value! Except that this is even uglier than just checking for Swift nil values everywhere. If you’re careful, none of this matters. Assign a value in your code, and you’re good. Don’t forget. Swift protects you from a lot of developer errors but it can’t help you here. Working around the workaround Or not! There’s another way. For simple properties, default values are useful. You can add them in the data model, if you always want the same default. Then you won’t have nil. Of course, you’ll always have the same date. Maybe that’s OK in your app? For a more dynamic default, implement awakeFromInsert in the class, to assign a calculated default value. public override func awakeFromInsert() { timestamp = Date() } That gets called when the new managed object first gets inserted into a managed object context. Add that and you don’t need to check for nil in other code anymore. Properties where you can’t predict the value are harder. You could add convenience initializers, but that only means you have to be careful in different ways. If you do that, don’t forget that creating instances like we did above with Event(context:myContext) won’t call your convenience initializer. Now you have to be careful to never do that, even though it’s valid and so easy to use. Maybe don’t do that? You can make managed object properties non-optional. Whether you should is up to you. It might simplify your code, but it also means you have to be extra careful about those properties to avoid problems Swift would normally prevent. Are you OK with that?",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \u003cp\u003e…or, how to accidentally break Swift initialization rules.\u003c/p\u003e\n\u003cp\u003eToday I’m going to talk about optionals. Swift optionals. And also another kind of optional. And how you might break the ironclad rules of Swift without realizing it until it’s too late.\u003c/p\u003e\n\u003cp\u003eWhat is an “optional” anyway? It depends who you ask. Swift will give you one answer, but Core Data has other ideas. So what happens when you bring them together?\u003c/p\u003e\n\u003ch2 id=\"why-are-my-properties-optional\"\u003eWhy are my properties optional?\u003c/h2\u003e\n\u003cp\u003eA common occurrence: A developer is working on a Core Data model. There’s a checkbox in the model editor that says “optional”, which can be on or off. Ah, the developer thinks, this property should never be nil, so I’ll turn off the “optional” setting.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://atomicbird.com/blog/clash-of-the-optionals/non-optional-attribute.png#center\" alt=\"Data model editor with the optional checkbox turned off\"/\u003e\u003c/p\u003e\n\u003cp\u003eBut then Xcode generates some code for them and the property looks like this:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e @NSManaged var timestamp: Date?\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhy is it optional? Didn’t you just uncheck the “optional” box? You did, but you unchecked optionality \u003cem\u003efor Core Data\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAnd the thing is, \u003cstrong\u003eCore Data doesn’t know anything about Swift\u003c/strong\u003e. It has something called an optional value but it’s unrelated to Swift optionals.\u003c/p\u003e\n\u003cp\u003eIn some ways they’re the same. For both, “optional” means you don’t have to have a value. You can have \u003ccode\u003enil\u003c/code\u003e, indicating “no value”. Trouble starts with things that aren’t optional. What does non-optional mean?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFor Swift, “not optional” means the property must not be nil \u003cem\u003eat any time after initialization\u003c/em\u003e. The compiler enforces this, so that it’s not even possible to check for nil values.\u003c/li\u003e\n\u003cli\u003eFor Core Data, “not optional” means the property must not be nil \u003cem\u003ewhen you are saving changes in Core Data\u003c/em\u003e. At any other time, nil is fine. The compiler doesn’t know anything about it, but the framework enforces the rule when the app runs.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eXcode uses optional values in generated code because it’s the safest way to deal with this difference. If the property is a Swift optional, it can handle Core Data’s looser restrictions safely. If it’s not optional? Read on.\u003c/p\u003e\n\u003ch2 id=\"what-if-i-change-the-code\"\u003eWhat if I change the code?\u003c/h2\u003e\n\u003cp\u003eIt doesn’t have to be this way. But as often happens, if you decide to not use the safe approach, you need to be aware of the trouble you might be asking for.\u003c/p\u003e\n\u003cp\u003eIt’s pretty common to let Xcode generate Core Data classes but it’s not necessary. Since checking for nil all the time can be a pain when your property isn’t supposed to be optional, you might wonder about changing the declaration. You could write your own \u003ccode\u003eNSManagedObject\u003c/code\u003e subclass code and remove the \u003ccode\u003e?\u003c/code\u003e:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e @NSManaged var timestamp: Date\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd… it works! Both Swift and Core Data are OK with this. Why?\u003c/p\u003e\n\u003cp\u003eSwift and Core Data don’t know shit about each other, that’s why.\u003c/p\u003e\n\u003cp\u003eSwift has no idea about the data model, so it has no way to know if the property declaration is correct. Core Data doesn’t know anything about your subclass declarations, so it also has no way to check for accuracy.\u003c/p\u003e\n\u003cp\u003eWhen you see \u003ccode\u003e@NSManaged\u003c/code\u003e in the code, it’s a red flag that Swift rules may not apply here. An \u003ccode\u003e@NSManaged\u003c/code\u003e property doesn’t, well, exist when the code compiles. Instead, it’s a promise that Core Data will add the property dynamically when the app runs. Literally, Core Data will change the class definition in memory to add properties that match the data model, and you \u003cem\u003epromise\u003c/em\u003e that the property is the same type. This kind of magic is built in to Objective-C, which probably means that Core Data will never be fully Swiftified without code-breaking changes.\u003c/p\u003e\n\u003cp\u003eThat’s why generated code is a good thing here. The data model and the code are separate, but they must declare the same data type. If not, your app will crash with an error saying something like \u003ccode\u003eUnacceptable type of value for attribute\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"but-you-said-it-works\"\u003eBut you said it works!\u003c/h2\u003e\n\u003cp\u003eIt does work! In this case. Since Swift and Core Data aren’t on speaking terms, changing the declaration works as long as you only change optionality.\u003c/p\u003e\n\u003cp\u003eWell, it works \u003cem\u003eif you’re careful\u003c/em\u003e. But there’s a catch. Let’s say you create a new managed object and then forget to give \u003ccode\u003etimestamp\u003c/code\u003e a value.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet newEvent = Event(context:myContext)\n// Oops! Forgot to assign a value to newEvent.timestamp!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGuess what, you just broke Swift’s initializer rules! Specifically, you initialized an object but didn’t provide a values for all of its non-optional properties. Nobody stopped you because \u003ccode\u003e@NSManaged\u003c/code\u003e says the rules don’t apply. You’ve just built a bomb.\u003c/p\u003e\n\u003cp\u003eLater on you try to use \u003ccode\u003enewEvent.timestamp\u003c/code\u003e.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eprint(\u0026#34;Date: \\(newEvent.timestamp)\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat do you think will happen? What value do you expect? Let’s think this through.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCore Data initialized the object, but it doesn’t know Swift’s rules and it doesn’t care about nil values until you save changes. So the value is nil.\u003c/li\u003e\n\u003cli\u003eSwift knows that initialization finished and there’s a non-optional property. It’s impossible for non-optional properties to be nil at this point, according to Swift. You can’t even check for nil values, that’s how definite this is. So it’s… not nil?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere’s no built-in resolution for this conflict. When your code reaches the line above, it crashes with an error attempting to bridge Objective-C and Swift. The backtrack will end in something like\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eFoundation.Date._unconditionallyBridgeFromObjectiveC(Swift.Optional\u0026lt;__C.NSDate\u0026gt;) -\u0026gt; Foundation.Date + 48\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOuch.\u003c/p\u003e\n\u003cp\u003eThere is a way to check for nil first, but you have to pretty much forget that you’re using Swift first and fall back on key-value coding. Do something like this:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eif newEvent.value(forKey: \u0026#34;timestamp\u0026#34;) != nil {\n\tprint(\u0026#34;Date: \\(newEvent.timestamp)\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat checks for a nil value! Except that this is even uglier than just checking for Swift nil values everywhere.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eIf you’re careful\u003c/em\u003e, none of this matters. Assign a value in your code, and you’re good. Don’t forget. Swift protects you from a lot of developer errors but it can’t help you here.\u003c/p\u003e\n\u003ch2 id=\"working-around-the-workaround\"\u003eWorking around the workaround\u003c/h2\u003e\n\u003cp\u003eOr not! There’s another way. For simple properties, default values are useful. You can add them in the data model, if you always want the same default. Then you won’t have nil.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://atomicbird.com/blog/clash-of-the-optionals/default-date-value.png#center\" alt=\"Data model editor with a default value for a date attribute\"/\u003e\u003c/p\u003e\n\u003cp\u003eOf course, you’ll always have the same date. Maybe that’s OK in your app? For a more dynamic default, implement \u003ccode\u003eawakeFromInsert\u003c/code\u003e in the class, to assign a calculated default value.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e public override func awakeFromInsert() {\n\t timestamp = Date()\n }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat gets called when the new managed object first gets inserted into a managed object context. Add that and you don’t need to check for nil in other code anymore.\u003c/p\u003e\n\u003cp\u003eProperties where you can’t predict the value are harder. You could add convenience initializers, but that only means you have to be careful in different ways. If you do that, don’t forget that creating instances like we did above with \u003ccode\u003eEvent(context:myContext)\u003c/code\u003e won’t call your convenience initializer. Now you have to be careful to never do that, even though it’s valid and so easy to use.\u003c/p\u003e\n\u003ch2 id=\"maybe-dont-do-that\"\u003eMaybe don’t do that?\u003c/h2\u003e\n\u003cp\u003eYou can make managed object properties non-optional. Whether you should is up to you. It might simplify your code, but it also means you have to be extra careful about those properties to avoid problems Swift would normally prevent. Are you OK with that?\u003c/p\u003e\n\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2022-01-21T00:00:00Z",
  "modifiedTime": "2022-01-21T00:00:00Z"
}
