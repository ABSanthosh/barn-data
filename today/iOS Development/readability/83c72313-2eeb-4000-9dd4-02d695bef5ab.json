{
  "id": "83c72313-2eeb-4000-9dd4-02d695bef5ab",
  "title": "There is no right or wrong in software engineering",
  "link": "https://swiftrocks.com/there-is-no-right-or-wrong-in-software-engineering",
  "description": "Have you ever seen \"preachings\" like these in the wild west of Twitter, Medium, and LinkedIn? \"If you're not using X in 2023 you're an idiot!\" \"XYZ architecture is the only way to go!\" \"Doing X in Swift? Stop immediately!\" Humans' obsession with dividing things into groups is not unknown to psychology. The ability to quickly classify information is a core contributor to humanity's evolution and is something we start doing as soon as we're born. But we need to be careful with the fact that sometimes this classification \"feature\" goes wrong. Instead of categorizing something as \"this or that\", we sometimes go for something more in terms of \"us vs them\", which not only leads to a lot of unnecessary conflict, but is also bad for our lives in general. As far as I understand, the exact reason why humans do this is not fully understood. You might have heard of the \"tribalism\" theory which defines that humans are hardcoded to divide themselves in this \"us vs them\" fashion; this is mentioned a lot in pop culture, but from my understanding, this theory is heavily critized by experts and should not be considered true. But explanations aside, we know that this happens and is something everyone needs to understand and overcome at one point. When it comes to software engineering, the reality is most things cannot be cleanly divided into \"right or wrong\" boxes like that. Yes, some things are concrete and indisputable. If an OS-level API states that you should never call it outside of the main thread, then that's what you should follow. But most things are the opposite of that. When we talk about general problems and best practices, it's extremely rare for them to have a clear right or wrong way to go. Instead, they depend on what you're trying to achieve, and everyone is trying to achieve something different. There is no right or wrong in these situations, only different approaches. To add another layer to the problem, a lot of stuff is also largely subjective! Many of our daily choices boil down to personal preference, making it even more senseless to attempt to categorize such things into clean \"right\" or \"wrong\" boxes. The industry even has a saying for this: there are no solutions, only trade-offs. One's ability to understand this concept is the greatest indicator of seniority in my personal opinion. It's so common for intermediate-level engineers to fail to understand the subjectivity of software engineering that I find that you can accurately gauge someone's experience level by simply observing how well they grasp this concept. Those who don't understand it overengineer things and tend to get bogged down on details that are either subjective or outright pointless, while those who do understand it keep things simple and display a much better ability to prioritize important work and ignore less important details. In this article, I'd like to shine a light on some of the topics that iOS developers tend to be divided on as a way to help developers who still haven't cleared that hurdle understand that these topics are not as straightforward as we might tend to think. Overcoming this barrier is part of the process of becoming a more experienced software engineer, and is something almost everyone goes through in their careers, so it's not something to be anxious about. I also had a period where I thought I had all the answers to the coding universe! Tool Wars (e.g SwiftUI vs UIKit, Hybrid vs Native, CLI vs GUI, programming languages) When a new framework, tool, or programming language is released, it's not uncommon for developers to divide themselves into groups and argue about which one of them is \"better\", claiming that theirs is the only option and everything else is a mistake. The problem with this line of thought is that it assumes that one tool was created to completely replace another, and while sometimes this may very well be the case, in most cases it's not. As a developer, it's important to understand that different tools solve different problems. While there may be some overlap between them, they were likely designed with different use cases in mind. The biggest example here as of writing is the SwiftUI vs UIKit discussion. Despite being largely different from each other, social media is full of content about how one is \"better\" than the other. Yes, SwiftUI and UIKit are both frameworks for building UI, but they solve different problems. As covered in my earlier \"Thoughts on SwiftUI vs UIKit\" article, SwiftUI is amazing for simple projects but quickly becomes inferior to UIKit as the project grows in complexity. Neither of these frameworks is better than the other, they are simply different tools for different jobs. Discussions about Hybrid vs Native development also fall into this category. Hybrid development has a bad reputation because it generally results in apps of very low quality, but it saves companies a lot of time and money. Most companies reject this trade-off as they determine that quality is more important than saving a few bucks, but that doesn't mean that nobody should do so. If you're starting a company but don't have a lot of time or money, hybrid development can be a good way to bootstrap your business. It's not fair to compare these two in a \"better/worse\" fashion because they don't target the same set of problems. I find that one example of how things can be subjective in this context is how a developer uses git. There is a lot of discussion about whether you should use it via the CLI or as a dedicated GUI app, but there isn't much to be discussed here because this is something that entirely boils down to your personal preference. There are pros and cons to each approach, and you will know which one is the right one for you because you will feel that it better suits your set of preferences. Neither approach is universally right or wrong. Best Practices Wars (e.g architecture, general advice) Architecture is usually the first thing that an iOS developer fights about. Every year we get a new architecture with some fancy acronym, that architecture gets a bunch of loyal followers, and then the groups start arguing about which architecture has the coolest name and solves the biggest number of problems. The first thing you learn is that MVC is terrible and should be avoided at all costs. One unfortunate consequence of these fights around architecture is that it leads developers to pick architectures that solve problems that they don't really have (and not solving the problems they actually have), which are guaranteed to make a project harder to maintain in the long run. It's important to understand that there is no architecture that solves all problems. Just like in the tools example, different architectures are meant to solve different problems, and the right architecture for your project is the one that solves your particular set of problems. MVC for example, which developers love to hate for some reason, can be a great choice for simple projects! Architecture is not something that you pick once and stick with forever, but rather something that you continuously adjust as your project evolves and you start having to deal with different sets of problems. I have been told that my talk about how Spotify's iOS app is architected is great at demonstrating this, so I'm mentioning it here in case you want to check it out! The same applies to general programming advice that you find on the web. We have a lot of content creators in our community, and I find that most of them present their content in the following format: \"here's a thing, here's how it works, and here's what you can do with it\". This is what I also strive to do when writing content for this blog, and I like this format because it doesn't claim that something is the best way of achieving something, it's simply showing you one possible way and leaving for you to decide whether or not that's the right solution for you. But every once in a while, the algorithm recommends me content that is more in line with \"here's a thing, and here's why you should always use it and abandon everything else\". It's not about learning something new, it's about saying that you're wrong about something. There's usually a spike of this type of content in the WWDC week when new APIs are released. The problem with content like this is that most best practices are highly subjective. Even if the content is referring to a very specific problem, it's hardly the case that the problem in question has one single viable solution. As we've already mentioned a couple of times in this article, personal preference plays a major role in this type of stuff. Something very helpful to you might be terrible for someone else, so they cannot be classified in a universal \"right or wrong\" fashion. Programming Fundamentals War (e.g LeetCode) Another common discussion point for iOS developers is whether or not you should learn computer science theory as part of your career. This is usually brought up whenever a company that run old-school programming puzzles (LeetCode) as part of their interview processes is mentioned. This topic however is complex enough that it deserves its own article, and convieniently enough, such an article already exists! You can find more information about this in my \"How necessary are the programming fundamentals?\" article, but as a quick summary, this is a very complicated topic that has no objective right or wrong. Conclusion I hope this was able to help you see that some things in software engineering are more complicated than they might seem at first glance. Realizing this is an important step in a software engineer's career, and while this article will certainly not stop those wars from popping up every once in a while, I do believe that as a community we can help others get through this phase faster.",
  "author": "Bruno Rocha",
  "published": "Thu, 28 Dec 2023 15:00:00 GMT+1",
  "source": "https://swiftrocks.com/rss.xml",
  "categories": null,
  "byline": "Bruno Rocha",
  "length": 9840,
  "excerpt": "Developers love to argue about which tools and languages are better. In this article, we'll see that things are not that straightforward in practice.",
  "siteName": "SwiftRocks",
  "favicon": "https://swiftrocks.com/images/favicon/iconsmall2.png",
  "text": "Have you ever seen \"preachings\" like these in the wild west of Twitter, Medium, and LinkedIn? \"If you're not using X in 2023 you're an idiot!\" \"XYZ architecture is the only way to go!\" \"Doing X in Swift? Stop immediately!\" Humans' obsession with dividing things into groups is not unknown to psychology. The ability to quickly classify information is a core contributor to humanity's evolution and is something we start doing as soon as we're born. But we need to be careful with the fact that sometimes this classification \"feature\" goes wrong. Instead of categorizing something as \"this or that\", we sometimes go for something more in terms of \"us vs them\", which not only leads to a lot of unnecessary conflict, but is also bad for our lives in general. As far as I understand, the exact reason why humans do this is not fully understood. You might have heard of the \"tribalism\" theory which defines that humans are hardcoded to divide themselves in this \"us vs them\" fashion; this is mentioned a lot in pop culture, but from my understanding, this theory is heavily critized by experts and should not be considered true. But explanations aside, we know that this happens and is something everyone needs to understand and overcome at one point. When it comes to software engineering, the reality is most things cannot be cleanly divided into \"right or wrong\" boxes like that. Yes, some things are concrete and indisputable. If an OS-level API states that you should never call it outside of the main thread, then that's what you should follow. But most things are the opposite of that. When we talk about general problems and best practices, it's extremely rare for them to have a clear right or wrong way to go. Instead, they depend on what you're trying to achieve, and everyone is trying to achieve something different. There is no right or wrong in these situations, only different approaches. To add another layer to the problem, a lot of stuff is also largely subjective! Many of our daily choices boil down to personal preference, making it even more senseless to attempt to categorize such things into clean \"right\" or \"wrong\" boxes. The industry even has a saying for this: there are no solutions, only trade-offs. One's ability to understand this concept is the greatest indicator of seniority in my personal opinion. It's so common for intermediate-level engineers to fail to understand the subjectivity of software engineering that I find that you can accurately gauge someone's experience level by simply observing how well they grasp this concept. Those who don't understand it overengineer things and tend to get bogged down on details that are either subjective or outright pointless, while those who do understand it keep things simple and display a much better ability to prioritize important work and ignore less important details. In this article, I'd like to shine a light on some of the topics that iOS developers tend to be divided on as a way to help developers who still haven't cleared that hurdle understand that these topics are not as straightforward as we might tend to think. Overcoming this barrier is part of the process of becoming a more experienced software engineer, and is something almost everyone goes through in their careers, so it's not something to be anxious about. I also had a period where I thought I had all the answers to the coding universe! Tool Wars (e.g SwiftUI vs UIKit, Hybrid vs Native, CLI vs GUI, programming languages) When a new framework, tool, or programming language is released, it's not uncommon for developers to divide themselves into groups and argue about which one of them is \"better\", claiming that theirs is the only option and everything else is a mistake. The problem with this line of thought is that it assumes that one tool was created to completely replace another, and while sometimes this may very well be the case, in most cases it's not. As a developer, it's important to understand that different tools solve different problems. While there may be some overlap between them, they were likely designed with different use cases in mind. The biggest example here as of writing is the SwiftUI vs UIKit discussion. Despite being largely different from each other, social media is full of content about how one is \"better\" than the other. Yes, SwiftUI and UIKit are both frameworks for building UI, but they solve different problems. As covered in my earlier \"Thoughts on SwiftUI vs UIKit\" article, SwiftUI is amazing for simple projects but quickly becomes inferior to UIKit as the project grows in complexity. Neither of these frameworks is better than the other, they are simply different tools for different jobs. Discussions about Hybrid vs Native development also fall into this category. Hybrid development has a bad reputation because it generally results in apps of very low quality, but it saves companies a lot of time and money. Most companies reject this trade-off as they determine that quality is more important than saving a few bucks, but that doesn't mean that nobody should do so. If you're starting a company but don't have a lot of time or money, hybrid development can be a good way to bootstrap your business. It's not fair to compare these two in a \"better/worse\" fashion because they don't target the same set of problems. I find that one example of how things can be subjective in this context is how a developer uses git. There is a lot of discussion about whether you should use it via the CLI or as a dedicated GUI app, but there isn't much to be discussed here because this is something that entirely boils down to your personal preference. There are pros and cons to each approach, and you will know which one is the right one for you because you will feel that it better suits your set of preferences. Neither approach is universally right or wrong. Best Practices Wars (e.g architecture, general advice) Architecture is usually the first thing that an iOS developer fights about. Every year we get a new architecture with some fancy acronym, that architecture gets a bunch of loyal followers, and then the groups start arguing about which architecture has the coolest name and solves the biggest number of problems. The first thing you learn is that MVC is terrible and should be avoided at all costs. One unfortunate consequence of these fights around architecture is that it leads developers to pick architectures that solve problems that they don't really have (and not solving the problems they actually have), which are guaranteed to make a project harder to maintain in the long run. It's important to understand that there is no architecture that solves all problems. Just like in the tools example, different architectures are meant to solve different problems, and the right architecture for your project is the one that solves your particular set of problems. MVC for example, which developers love to hate for some reason, can be a great choice for simple projects! Architecture is not something that you pick once and stick with forever, but rather something that you continuously adjust as your project evolves and you start having to deal with different sets of problems. I have been told that my talk about how Spotify's iOS app is architected is great at demonstrating this, so I'm mentioning it here in case you want to check it out! The same applies to general programming advice that you find on the web. We have a lot of content creators in our community, and I find that most of them present their content in the following format: \"here's a thing, here's how it works, and here's what you can do with it\". This is what I also strive to do when writing content for this blog, and I like this format because it doesn't claim that something is the best way of achieving something, it's simply showing you one possible way and leaving for you to decide whether or not that's the right solution for you. But every once in a while, the algorithm recommends me content that is more in line with \"here's a thing, and here's why you should always use it and abandon everything else\". It's not about learning something new, it's about saying that you're wrong about something. There's usually a spike of this type of content in the WWDC week when new APIs are released. The problem with content like this is that most best practices are highly subjective. Even if the content is referring to a very specific problem, it's hardly the case that the problem in question has one single viable solution. As we've already mentioned a couple of times in this article, personal preference plays a major role in this type of stuff. Something very helpful to you might be terrible for someone else, so they cannot be classified in a universal \"right or wrong\" fashion. Programming Fundamentals War (e.g LeetCode) Another common discussion point for iOS developers is whether or not you should learn computer science theory as part of your career. This is usually brought up whenever a company that run old-school programming puzzles (LeetCode) as part of their interview processes is mentioned. This topic however is complex enough that it deserves its own article, and convieniently enough, such an article already exists! You can find more information about this in my \"How necessary are the programming fundamentals?\" article, but as a quick summary, this is a very complicated topic that has no objective right or wrong. Conclusion I hope this was able to help you see that some things in software engineering are more complicated than they might seem at first glance. Realizing this is an important step in a software engineer's career, and while this article will certainly not stop those wars from popping up every once in a while, I do believe that as a community we can help others get through this phase faster.",
  "image": "https://swiftrocks.com/images/thumbs/thumb.jpg?4",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \n  \n\u003cp\u003eHave you ever seen \u0026#34;preachings\u0026#34; like these in the wild west of Twitter, Medium, and LinkedIn?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026#34;If you\u0026#39;re not using X in 2023 you\u0026#39;re an idiot!\u0026#34;\u003c/li\u003e\n\u003cli\u003e\u0026#34;XYZ architecture is the only way to go!\u0026#34;\u003c/li\u003e\n\u003cli\u003e\u0026#34;Doing X in Swift? Stop immediately!\u0026#34;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHumans\u0026#39; obsession with dividing things into groups is not unknown to psychology. The ability to quickly classify information is a core contributor to humanity\u0026#39;s evolution and is something we start doing as soon as we\u0026#39;re born.\u003c/p\u003e\n\u003cp\u003eBut we need to be careful with the fact that sometimes this classification \u0026#34;feature\u0026#34; goes wrong. Instead of categorizing something as \u0026#34;this or that\u0026#34;, we sometimes go for something more in terms of \u0026#34;us vs them\u0026#34;, which not only leads to a lot of unnecessary conflict, but is also bad for our lives in general.\u003c/p\u003e\n\u003cp\u003eAs far as I understand, the exact reason why humans do this is not fully understood. You might have heard of the \u0026#34;tribalism\u0026#34; theory which defines that humans are hardcoded to divide themselves in this \u0026#34;us vs them\u0026#34; fashion; this is mentioned a lot in pop culture, but from my understanding, this theory is heavily critized by experts and should not be considered true. But explanations aside, we know that this happens and is something everyone needs to understand and overcome at one point.\u003c/p\u003e\n\n\u003cp\u003eWhen it comes to software engineering, the reality is \u003cb\u003emost things cannot be cleanly divided into \u0026#34;right or wrong\u0026#34; boxes like that.\u003c/b\u003e Yes, some things are concrete and indisputable. If an OS-level API states that you should never call it outside of the main thread, then that\u0026#39;s what you should follow.\u003c/p\u003e\n\u003cp\u003eBut most things are the opposite of that. When we talk about general problems and best practices, it\u0026#39;s extremely rare for them to have a clear right or wrong way to go. Instead, \u003cb\u003ethey depend on what you\u0026#39;re trying to achieve, and everyone is trying to achieve something different.\u003c/b\u003e There is no right or wrong in these situations, only different approaches.\u003c/p\u003e\n\u003cp\u003eTo add another layer to the problem, \u003cb\u003ea lot of stuff is also largely subjective!\u003c/b\u003e Many of our daily choices boil down to personal preference, making it even more senseless to attempt to categorize such things into clean \u0026#34;right\u0026#34; or \u0026#34;wrong\u0026#34; boxes. The industry even has a saying for this: \u003cb\u003ethere are no solutions, only trade-offs\u003c/b\u003e.\u003c/p\u003e\n\u003cp\u003eOne\u0026#39;s ability to understand this concept is the \u003cb\u003egreatest indicator of seniority in my personal opinion.\u003c/b\u003e It\u0026#39;s so common for intermediate-level engineers to fail to understand the subjectivity of software engineering that I find that you can accurately gauge someone\u0026#39;s experience level by simply observing how well they grasp this concept. Those who don\u0026#39;t understand it overengineer things and tend to get bogged down on details that are either subjective or outright pointless, while those who \u003ci\u003edo\u003c/i\u003e understand it keep things simple and display a much better ability to prioritize important work and ignore less important details.\u003c/p\u003e\n\u003cp\u003eIn this article, I\u0026#39;d like to shine a light on some of the topics that iOS developers tend to be divided on as a way to help developers who still haven\u0026#39;t cleared that hurdle understand that these topics are not as straightforward as we might tend to think. Overcoming this barrier is part of the process of becoming a more experienced software engineer, and is something almost everyone goes through in their careers, so it\u0026#39;s not something to be anxious about. I also had a period where I thought I had all the answers to the coding universe!\u003c/p\u003e\n\u003ch2\u003eTool Wars (e.g SwiftUI vs UIKit, Hybrid vs Native, CLI vs GUI, programming languages)\u003c/h2\u003e\n\u003cp\u003eWhen a new framework, tool, or programming language is released, it\u0026#39;s not uncommon for developers to divide themselves into groups and argue about which one of them is \u0026#34;better\u0026#34;, claiming that theirs is the only option and everything else is a mistake.\u003c/p\u003e\n\u003cp\u003eThe problem with this line of thought is that it assumes that one tool was created to \u003ci\u003ecompletely\u003c/i\u003e replace another, and while sometimes this may very well be the case, in most cases it\u0026#39;s not.\u003c/p\u003e\n\u003cp\u003eAs a developer, it\u0026#39;s important to understand that \u003cb\u003edifferent tools solve different problems.\u003c/b\u003e While there may be some overlap between them, they were likely designed with different use cases in mind.\u003c/p\u003e\n\u003cp\u003eThe biggest example here as of writing is the SwiftUI vs UIKit discussion. Despite being largely different from each other, social media is full of content about how one is \u0026#34;better\u0026#34; than the other.\u003c/p\u003e\n\u003cp\u003eYes, SwiftUI and UIKit are both frameworks for building UI, \u003cb\u003ebut they solve different problems.\u003c/b\u003e As covered in my earlier \u003ca href=\"https://swiftrocks.com/my-experience-with-swiftui\"\u003e\u0026#34;Thoughts on SwiftUI vs UIKit\u0026#34;\u003c/a\u003e article, SwiftUI is amazing for simple projects but quickly becomes inferior to UIKit as the project grows in complexity. Neither of these frameworks is better than the other, they are simply different tools for different jobs.\u003c/p\u003e\n\u003cp\u003eDiscussions about Hybrid vs Native development also fall into this category. Hybrid development has a bad reputation because it generally results in apps of very low quality, but it saves companies a lot of time and money. Most companies reject this trade-off as they determine that quality is more important than saving a few bucks, but that doesn\u0026#39;t mean that \u003ci\u003enobody\u003c/i\u003e should do so. If you\u0026#39;re starting a company but don\u0026#39;t have a lot of time or money, hybrid development can be a good way to bootstrap your business. It\u0026#39;s not fair to compare these two in a \u0026#34;better/worse\u0026#34; fashion because \u003cb\u003ethey don\u0026#39;t target the same set of problems.\u003c/b\u003e\u003c/p\u003e\n\u003cp\u003eI find that one example of how things can be subjective in this context is how a developer uses \u003ccode\u003egit\u003c/code\u003e. There is a lot of discussion about whether you should use it via the CLI or as a dedicated GUI app, but there isn\u0026#39;t much to be discussed here because this is something that entirely boils down to your personal preference. There are pros and cons to each approach, and you will know which one is the right one for you because you will feel that it better suits your set of preferences. Neither approach is universally right or wrong.\u003c/p\u003e\n\u003ch2\u003eBest Practices Wars (e.g architecture, general advice)\u003c/h2\u003e\n\u003cp\u003eArchitecture is usually the first thing that an iOS developer fights about. Every year we get a new architecture with some fancy acronym, that architecture gets a bunch of loyal followers, and then the groups start arguing about which architecture has the coolest name and solves the biggest number of problems. The first thing you learn is that MVC is terrible and should be avoided at all costs.\u003c/p\u003e\n\u003cp\u003eOne unfortunate consequence of these fights around architecture is that it leads developers to pick architectures that solve problems that they don\u0026#39;t really have (and not solving the problems they actually have), which are guaranteed to make a project harder to maintain in the long run.\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s important to understand that \u003cb\u003ethere is no architecture that solves all problems.\u003c/b\u003e Just like in the tools example, different architectures are meant to solve different problems, and \u003cb\u003ethe right architecture for your project is the one that solves \u003ci\u003eyour\u003c/i\u003e particular set of problems.\u003c/b\u003e MVC for example, which developers love to hate for some reason, can be a great choice for simple projects!\u003c/p\u003e\n\u003cp\u003eArchitecture is not something that you pick once and stick with forever, but rather something that you \u003cb\u003econtinuously adjust as your project evolves\u003c/b\u003e and you start having to deal with different sets of problems. I have been told that my talk about \u003ca href=\"https://www.youtube.com/watch?v=sZuI6z8qSmc\"\u003ehow Spotify\u0026#39;s iOS app is architected\u003c/a\u003e is great at demonstrating this, so I\u0026#39;m mentioning it here in case you want to check it out!\u003c/p\u003e\n\u003cp\u003eThe same applies to general programming advice that you find on the web. We have a lot of content creators in our community, and I find that most of them present their content in the following format: \u0026#34;here\u0026#39;s a thing, here\u0026#39;s how it works, and here\u0026#39;s what you can do with it\u0026#34;. This is what I also strive to do when writing content for this blog, and I like this format because it doesn\u0026#39;t claim that something is the best way of achieving something, it\u0026#39;s simply showing you one possible way and leaving for you to decide whether or not that\u0026#39;s the right solution for you.\u003c/p\u003e\n\u003cp\u003eBut every once in a while, the algorithm recommends me content that is more in line with \u0026#34;here\u0026#39;s a thing, and here\u0026#39;s why you should always use it and abandon everything else\u0026#34;. It\u0026#39;s not about learning something new, it\u0026#39;s about saying that you\u0026#39;re wrong about something. There\u0026#39;s usually a spike of this type of content in the WWDC week when new APIs are released.\u003c/p\u003e\n\u003cp\u003eThe problem with content like this is that \u003cb\u003emost best practices are highly subjective.\u003c/b\u003e Even if the content is referring to a very specific problem, it\u0026#39;s hardly the case that the problem in question has one single viable solution. As we\u0026#39;ve already mentioned a couple of times in this article, personal preference plays a major role in this type of stuff. Something very helpful to you might be terrible for someone else, so they cannot be classified in a universal \u0026#34;right or wrong\u0026#34; fashion.\u003c/p\u003e\n\u003ch2\u003eProgramming Fundamentals War (e.g LeetCode)\u003c/h2\u003e\n\u003cp\u003eAnother common discussion point for iOS developers is whether or not you should learn computer science theory as part of your career. This is usually brought up whenever a company that run old-school programming puzzles (LeetCode) as part of their interview processes is mentioned.\u003c/p\u003e\n\n\u003cp\u003eThis topic however is complex enough that it deserves its own article, and convieniently enough, such an article already exists! You can find more information about this in my \u003ca href=\"https://swiftrocks.com/how-necessary-are-the-programming-fundamentals\"\u003e\u0026#34;How necessary are the programming fundamentals?\u0026#34;\u003c/a\u003e article, but as a quick summary, this is a very complicated topic that has no objective right or wrong.\u003c/p\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eI hope this was able to help you see that some things in software engineering are more complicated than they might seem at first glance. Realizing this is an important step in a software engineer\u0026#39;s career, and while this article will certainly not stop those wars from popping up every once in a while, I do believe that as a community we can help others get through this phase faster.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2023-12-28T16:00:00+02:00",
  "modifiedTime": null
}
