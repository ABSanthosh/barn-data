{
  "id": "a7b1ccd9-ae50-483a-b8a9-2a4b1a80c144",
  "title": "Lessons learned from handling JWT on mobile",
  "link": "https://albertodebortoli.com/2019/12/04/recommendations-on-handling-jwt-on-mobile/",
  "description": "Implementing Authorization on mobile can be tricky. Here are some recommendations to avoid common issues.Originally published on the Just Eat Engineering Blog. OverviewModern mobile apps are more complicated than they used to be back in the early days and developers have to face a variety of interesting problems.",
  "author": "Alberto De Bortoli",
  "published": "Wed, 04 Dec 2019 17:21:58 GMT",
  "source": "https://albertodebortoli.com/rss/",
  "categories": [
    "iOS",
    "Authorization",
    "JWT",
    "Token",
    "mobile"
  ],
  "byline": "Alberto De Bortoli",
  "length": 14688,
  "excerpt": "\u003e Implementing Authorization on mobile can be tricky. Here are some recommendations to avoid common issues. Originally published on the Just Eat Engineering Blog [https://tech.just-eat.com/2019/12/04/lessons-learned-from-handling-jwt-on-mobile/] . Overview Modern mobile apps are more complicated than they used to be back in the early days and developers have to face a variety of interesting problems. While we've put in our two cents on some of them in previous articles, this one is about autho",
  "siteName": "Alberto De Bortoli",
  "favicon": "",
  "text": "Implementing Authorization on mobile can be tricky. Here are some recommendations to avoid common issues.Originally published on the Just Eat Engineering Blog. OverviewModern mobile apps are more complicated than they used to be back in the early days and developers have to face a variety of interesting problems. While we've put in our two cents on some of them in previous articles, this one is about authorization and what we have learned by handling JWT on mobile at Just Eat.When it comes to authorization, it's standard practice to rely on OAuth 2.0 and the companion JWT (JSON Web Token). We found this important topic was rarely discussed online while much attention was given to new proposed implementations of network stacks, maybe using recent language features or frameworks such as Combine.We'll illustrate the problems we faced at Just Eat for JWT parsing, usage, and (most importantly) refreshing. You should be able to learn a few things on how to make your app more stable by reducing the chance of unauthorized requests allowing your users to virtually always stay logged in.What is JWTJWT stands for JSON Web Token and is an open industry standard used to represent claims transferred between two parties. A signed JWT is known as a JWS (JSON Web Signature). In fact, a JWT has either to be JWS or JWE (JSON Web Encryption). RFC 7515, RFC 7516, and RFC 7519 describe the various fields and claims in detail. What is relevant for mobile developers is the following:JWT is composed of 3 parts dot-separated: Header, Payload, Signature.The Payload is the only relevant part. The Header identifies which algorithm is used to generate the signature. There are reasons for not verifying the signature client-side making the Signature part irrelevant too.JWT has an expiration date. Expired tokens should be renewed/refreshed.JWT can contain any number of extra information specific to your service.It's common practice to store JWTs in the app keychain.Here is a valid and very short token example, courtesy of jwt.io/ which we recommend using to easily decode tokens for debugging purposes. It shows 3 fragments (base64 encoded) concatenated with a dot.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1Nzc3NTA0MDB9.7hgBhNK_ZpiteB3GtLh07KJ486Vfe3WAdS-XoDksJCQ The only field relevant to this document is exp (Expiration Time), part of Payload (the second fragment). This claim identifies the time after which the JWT must not be accepted. In order to accept a JWT, it's required that the current date/time must be before the expiration time listed in the exp claim. It's accepted practice for implementers to consider for some small leeway, usually no more than a few minutes, to account for clock skew.N.B. Some API calls might demand the user is logged in (user-authenticated calls), and others don't (non-user-authenticated calls). JWT can be used in both cases, marking a distinction between Client JWT and User JWT we will refer to later on.The token refresh problemBy far the most significant problem we had in the past was the renewal of the token. This seems to be something taken for granted by the mobile community, but in reality, we found it to be quite a fragile part of the authentication flow. If not done right, it can easily cause your customers to end up being logged out, with the consequent frustration we all have experienced as app users.The Just Eat app makes multiple API calls at startup: it fetches the order history to check for in-flight orders, fetches the most up-to-date consumer details, etc. If the token is expired when the user runs the app, a nasty race condition could cause the same refresh token to be used twice, causing the server to respond with a 401 and subsequently logging the user out on the app. This can also happen during normal execution when multiple API calls are performed very close to each other and the token expires prior to those.It gets trickier if the client and the server clocks are sensibly off sync: while the client might believe to be in possession of a valid token, it has already expired.The following diagram should clarify the scenario.Common misbehaviorI couldn't find a company (regardless of size) or indie developer who had implemented a reasonable token refresh mechanism. The common approach seems to be: to refresh the token whenever an API call fails with 401 Unauthorized. This is not only causing an extra call that could be avoided by locally checking if the token has expired, but it also opens the door for the race condition illustrated above.Avoid race conditions when refreshing the token ðŸš¦We'll explain the solution with some technical details and code snippets but what what's more important is that the reader understands the root problem we are solving and why it should be given the proper attention.The more we thought about it, we more we convinced ourselves that the best way to shield ourselves from race conditions is by using threading primitives when scheduling async requests to fetch a valid token. This means that all the calls would be regulated via a filter that would hold off subsequent calls to fire until a valid token is retrieved, either from local storage or, if a refresh is needed, from the remote OAuth server.We'll show examples for iOS, so we've chosen dispatch queues and semaphores (using GCD); fancier and more abstract ways of implementing the solution might exist - in particular by leveraging modern FRP techniques - but ultimately the same primitives are used.For simplicity, let's assume that only user-authenticated API requests need to provide a JWT, commonly put in the Authorization header:Authorization: Bearer \u003cjwt-token\u003eThe code below implements the \"Get valid JWT\" box from the following flowchart. The logic within this section is the one that must be implemented in mutual exclusion, in our solution, by using the combination of a serial queue and a semaphore.Here is just the minimum amount of code (Swift) needed to explain the solution.typealias Token = String typealias AuthorizationValue = String struct UserAuthenticationInfo { let bearerToken: Token // the JWT let refreshToken: Token let expiryDate: Date // computed on creation from 'exp' claim var isValid: Bool { return expiryDate.compare(Date()) == .orderedDescending } } protocol TokenRefreshing { func refreshAccessToken(_ refreshToken: Token, completion: @escaping (Result\u003cUserAuthenticationInfo, Error\u003e) -\u003e Void) } protocol AuthenticationInfoStorage { var userAuthenticationInfo: UserAuthenticationInfo? func persistUserAuthenticationInfo(_ authenticationInfo: UserAuthenticationInfo?) func wipeUserAuthenticationInfo() } class AuthorizationValueProvider { private let authenticationInfoStore: AuthenticationInfoStorage private let tokenRefreshAPI: TokenRefreshing private let queue = DispatchQueue(label: \u003c#label#\u003e, qos: .userInteractive) private let semaphore = DispatchSemaphore(value: 1) init(tokenRefreshAPI: TokenRefreshing, authenticationInfoStore: AuthenticationInfoStorage) { self.tokenRefreshAPI = tokenRefreshAPI self.authenticationInfoStore = authenticationInfoStore } func getValidUserAuthorization(completion: @escaping (Result\u003cAuthorizationValue, Error\u003e) -\u003e Void) { queue.async { self.getValidUserAuthorizationInMutualExclusion(completion: completion) } } } Before performing any user-authenticated request, the network client asks an AuthorizationValueProvider instance to provide a valid user Authorization value (the JWT). It does so via the async method getValidUserAuthorization which uses a serial queue to handle the requests. The chunky part is the getValidUserAuthorizationInMutualExclusion.private func getValidUserAuthorizationInMutualExclusion(completion: @escaping (Result\u003cAuthorizationValue, Error\u003e) -\u003e Void) { semaphore.wait() guard let authenticationInfo = authenticationInfoStore.userAuthenticationInfo else { semaphore.signal() let error = // forge an error for 'missing authorization' completion(.failure(error)) return } if authenticationInfo.isValid { semaphore.signal() completion(.success(authenticationInfo.bearerToken)) return } tokenRefreshAPI.refreshAccessToken(authenticationInfo.refreshToken) { result in switch result { case .success(let authenticationInfo): self.authenticationInfoStore.persistUserAuthenticationInfo(authenticationInfo) self.semaphore.signal() completion(.success(authenticationInfo.bearerToken)) case .failure(let error) where error.isClientError: self.authenticationInfoStore.wipeUserAuthenticationInfo() self.semaphore.signal() completion(.failure(error)) case .failure(let error): self.semaphore.signal() completion(.failure(error)) } } } The method could fire off an async call to refresh the token, and this makes the usage of the semaphore crucial. Without it, the next request to AuthorizationValueProvider would be popped from the queue and executed before the remote refresh completes.The semaphore is initialised with a value of 1, meaning that only one thread can access the critical section at a given time. We make sure to call wait at the beginning of the execution and to call signal only when we have a result and therefore ready to leave the critical section.If the token found in the local store is still valid, we simply return it, otherwise, it's time to request a new one. In the latter case, if all goes well, we persist the token locally and allow the next request to access the method, in the case of an error, we should be careful and wipe the token only if the error is a legit client error (2xx range). This includes also the usage of a refresh token that is not valid anymore, which could happen, for instance, if the user resets the password on another platform/device.It's critical to not delete the token from the local store in the case of any other error, such as 5xx or the common Foundation's NSURLErrorNotConnectedToInternet (-1009), or else the user would unexpectedly be logged out.It's also important to note that the same AuthorizationValueProvider instance must be used by all the calls: using different ones would mean using different queues making the entire solution ineffective.It seemed clear that the network client we developed in-house had to embrace JWT refresh logic at its core so that all the API calls, even new ones that will be added in the future would make use of the same authentication flow.General recommendationsHere are a couple more (minor) suggestions we thought are worth sharing since they might save you implementation time or influence the design of your solution.Correctly parse the PayloadAnother problem - even though quite trivial and that doesn't seem to be discussed much - is the parsing of the JWT, that can fail in some cases. In our case, this was related to the base64 encoding function and \"adjusting\" the base64 payload to be parsed correctly. In some implementations of base64, the padding character is not needed for decoding, since the number of missing bytes can be calculated but in Foundation's implementation it is mandatory. This caused us some head-scratching and this StackOverflow answer helped us.The solution is - more officially - stated in RFC 7515 - Appendix C and here is the corresponding Swift code:func base64String(_ input: String) -\u003e String { var base64 = input .replacingOccurrences(of: \"-\", with: \"+\") .replacingOccurrences(of: \"_\", with: \"/\") switch base64.count % 4 { case 2: base64 = base64.appending(\"==\") case 3: base64 = base64.appending(\"=\") default: break } return base64 } The majority of the developers rely on external libraries to ease the parsing of the token, but as we often do, we have implemented our solution from scratch, without relying on a third-party library. Nonetheless, we feel JSONWebToken by Kyle Fuller is a very good one and it seems to implement JWT faithfully to the RFC, clearly including the necessary base64 decode function.Handle multiple JWT for multiple app statesAs previously stated, when using JWT as an authentication method for non-user- authenticated calls, we need to cater for at least 3 states, shown in the following enum:enum AuthenticationStatus { case notAuthenticated case clientAuthenticated case userAuthenticated } On a fresh install, we can expect to be in the .notAuthenticated state, but as soon as the first API call is ready to be performed, a valid Client JWT has to be fetched and stored locally (at this stage, other authentication mechanisms are used, most likely Basic Auth), moving to the .clientAuthenticated state. Once the user completes the login or signup procedure, a User JWT is retrieved and stored locally (but separately to the Client JWT), entering the .userAuthenticated, so that in the case of a logout we are left with a (hopefully still valid) Client JWT.In this scenario, almost all transitions are possible:A couple of recommendations here:if the user is logged in is important to use the User JWT also for the non-user-authenticated calls as the server may personalise the response (e.g. the list of restaurants in the Just Eat app)store both Client and User JWT, so that if the user logs out, the app is left with the Client JWT ready to be used to perform non-user-authenticated requests, saving an unnecessary call to fetch a new tokenConclusionIn this article, we've shared some learnings from handling JWT on mobile that are not commonly discussed within the community. As a good practice, it's always best to hide complexity and implementation details. Baking the refresh logic described above within your API client is a great way to avoid developers having to deal with complex logic to provide authorization, and enables all the API calls to undergo the same authentication mechanism. Consumers of an API client, should not have the ability to gather the JWT as itâ€™s not their concern to use it or to fiddle with it.We hope this article helps to raise awareness on how to better handle the usage of JWT on mobile applications, in particular making sure we always do our best to avoid accidental logouts to provide a better user experience.",
  "image": "https://albertodebortoli.com/content/images/size/w1200/2024/02/joshua-fuller-N2q8hRVzEg8-unsplash.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cblockquote\u003eImplementing Authorization on mobile can be tricky. Here are some recommendations to avoid common issues.\u003c/blockquote\u003e\u003cp\u003e\u003cem\u003eOriginally published on the \u003ca href=\"https://tech.just-eat.com/2019/12/04/lessons-learned-from-handling-jwt-on-mobile/?ref=albertodebortoli.com\"\u003eJust Eat Engineering Blog\u003c/a\u003e. \u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\u003cp\u003eModern mobile apps are more complicated than they used to be back in the early days and developers have to face a variety of interesting problems. While we\u0026#39;ve put in our two cents on some of them in previous articles, this one is about authorization and what we have learned by handling JWT on mobile at Just Eat.\u003c/p\u003e\u003cp\u003eWhen it comes to authorization, it\u0026#39;s standard practice to rely on \u003ca href=\"https://oauth.net/2/?ref=albertodebortoli.com\"\u003eOAuth 2.0\u003c/a\u003e and the companion JWT (JSON Web Token). We found this important topic was rarely discussed online while much attention was given to new proposed implementations of network stacks, maybe using recent language features or frameworks such as Combine.\u003c/p\u003e\u003cp\u003eWe\u0026#39;ll illustrate the problems we faced at Just Eat for JWT parsing, usage, and (most importantly) refreshing. You should be able to learn a few things on how to make your app more stable by reducing the chance of unauthorized requests allowing your users to virtually always stay logged in.\u003c/p\u003e\u003ch2 id=\"what-is-jwt\"\u003eWhat is JWT\u003c/h2\u003e\u003cp\u003eJWT stands for JSON Web Token and is an open industry standard used to represent claims transferred between two parties. A signed JWT is known as a JWS (JSON Web Signature). In fact, a JWT has either to be JWS or JWE (JSON Web Encryption). \u003ca href=\"https://tools.ietf.org/html/rfc7515?ref=albertodebortoli.com\"\u003eRFC 7515\u003c/a\u003e, \u003ca href=\"https://tools.ietf.org/html/rfc7516?ref=albertodebortoli.com\"\u003eRFC 7516\u003c/a\u003e, and \u003ca href=\"https://tools.ietf.org/html/rfc7519?ref=albertodebortoli.com\"\u003eRFC 7519\u003c/a\u003e describe the various fields and claims in detail. What is relevant for mobile developers is the following:\u003c/p\u003e\u003cul\u003e\u003cli\u003eJWT is composed of 3 parts dot-separated: \u003cem\u003eHeader\u003c/em\u003e, \u003cem\u003ePayload\u003c/em\u003e, \u003cem\u003eSignature\u003c/em\u003e.\u003c/li\u003e\u003cli\u003eThe Payload is the only relevant part. The Header identifies which algorithm is used to generate the signature. There are reasons for \u003ca href=\"https://stackoverflow.com/a/46133159/3010877?ref=albertodebortoli.com\"\u003enot verifying the signature client-side\u003c/a\u003e making the Signature part irrelevant too.\u003c/li\u003e\u003cli\u003eJWT has an expiration date. Expired tokens should be renewed/refreshed.\u003c/li\u003e\u003cli\u003eJWT can contain any number of extra information specific to your service.\u003c/li\u003e\u003cli\u003eIt\u0026#39;s common practice to store JWTs in the app keychain.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eHere is a valid and very short token example, courtesy of \u003ca href=\"https://jwt.io/?ref=albertodebortoli.com\"\u003ejwt.io/\u003c/a\u003e which we recommend using to easily decode tokens for debugging purposes. It shows 3 fragments (base64 encoded) concatenated with a dot.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1Nzc3NTA0MDB9.7hgBhNK_ZpiteB3GtLh07KJ486Vfe3WAdS-XoDksJCQ\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe only field relevant to this document is \u003ccode\u003eexp\u003c/code\u003e (Expiration Time), part of Payload (the second fragment). This claim identifies the time after which the JWT must not be accepted. In order to accept a JWT, it\u0026#39;s required that the current date/time must be before the expiration time listed in the \u003ccode\u003eexp\u003c/code\u003e claim. It\u0026#39;s accepted practice for implementers to consider for some small leeway, usually no more than a few minutes, to account for clock skew.\u003c/p\u003e\u003cp\u003eN.B. Some API calls might demand the user is logged in (user-authenticated calls), and others don\u0026#39;t (non-user-authenticated calls). JWT can be used in both cases, marking a distinction between Client JWT and User JWT we will refer to later on.\u003c/p\u003e\u003ch2 id=\"the-token-refresh-problem\"\u003eThe token refresh problem\u003c/h2\u003e\u003cp\u003eBy far the most significant problem we had in the past was the renewal of the token. This seems to be something taken for granted by the mobile community, but in reality, we found it to be quite a fragile part of the authentication flow. If not done right, it can easily cause your \u003cem\u003ecustomers to end up being logged out\u003c/em\u003e, with the consequent frustration we all have experienced as app users.\u003c/p\u003e\u003cp\u003eThe Just Eat app makes multiple API calls at startup: it fetches the order history to check for in-flight orders, fetches the most up-to-date consumer details, etc. If the token is expired when the user runs the app, a nasty race condition could cause the same refresh token to be used twice, causing the server to respond with a 401 and subsequently logging the user out on the app. This can also happen during normal execution when multiple API calls are performed very close to each other and the token expires prior to those.\u003c/p\u003e\u003cp\u003eIt gets trickier if the client and the server clocks are sensibly off sync: while the client might believe to be in possession of a valid token, it has already expired.\u003c/p\u003e\u003cp\u003eThe following diagram should clarify the scenario.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/11/diagram.svg\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003ch3 id=\"common-misbehavior\"\u003eCommon misbehavior\u003c/h3\u003e\u003cp\u003eI couldn\u0026#39;t find a company (regardless of size) or indie developer who had implemented a reasonable token refresh mechanism. The common approach seems to be: to refresh the token whenever an API call fails with 401 Unauthorized. This is not only causing an extra call that could be avoided by locally checking if the token has expired, but it also opens the door for the race condition illustrated above.\u003c/p\u003e\u003ch2 id=\"avoid-race-conditions-when-refreshing-the-token-\"\u003eAvoid race conditions when refreshing the token ðŸš¦\u003c/h2\u003e\u003cp\u003eWe\u0026#39;ll explain the solution with some technical details and code snippets but what what\u0026#39;s more important is that the reader understands the root problem we are solving and why it should be given the proper attention.\u003c/p\u003e\u003cp\u003eThe more we thought about it, we more we convinced ourselves that the best way to shield ourselves from race conditions is by using threading primitives when scheduling async requests to fetch a valid token. This means that all the calls would be regulated via a filter that would hold off subsequent calls to fire until a valid token is retrieved, either from local storage or, if a refresh is needed, from the remote OAuth server.\u003c/p\u003e\u003cp\u003eWe\u0026#39;ll show examples for iOS, so we\u0026#39;ve chosen dispatch queues and semaphores (using \u003ca href=\"https://developer.apple.com/documentation/DISPATCH?ref=albertodebortoli.com\"\u003eGCD\u003c/a\u003e); fancier and more abstract ways of implementing the solution might exist - in particular by leveraging modern FRP techniques - but ultimately the same primitives are used.\u003c/p\u003e\u003cp\u003eFor simplicity, let\u0026#39;s assume that only user-authenticated API requests need to provide a JWT, commonly put in the \u003ccode\u003eAuthorization\u003c/code\u003e header:\u003c/p\u003e\u003cblockquote\u003e\u003cem\u003eAuthorization: Bearer \u0026lt;jwt-token\u0026gt;\u003c/em\u003e\u003c/blockquote\u003e\u003chr/\u003e\u003cp\u003eThe code below implements the \u0026#34;Get valid JWT\u0026#34; box from the following flowchart. The logic within this section is the one that must be implemented in mutual exclusion, in our solution, by using the combination of a serial queue and a semaphore.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/11/Perform-Request-flow.svg\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cp\u003eHere is just the minimum amount of code (Swift) needed to explain the solution.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etypealias Token = String\ntypealias AuthorizationValue = String\n\nstruct UserAuthenticationInfo {\n    let bearerToken: Token // the JWT\n    let refreshToken: Token\n    let expiryDate: Date // computed on creation from \u0026#39;exp\u0026#39; claim\n    var isValid: Bool {\n       return expiryDate.compare(Date()) == .orderedDescending\n    }\n}\n\nprotocol TokenRefreshing {\n    func refreshAccessToken(_ refreshToken: Token, completion: @escaping (Result\u0026lt;UserAuthenticationInfo, Error\u0026gt;) -\u0026gt; Void)\n}\n\nprotocol AuthenticationInfoStorage {\n    var userAuthenticationInfo: UserAuthenticationInfo?\n    func persistUserAuthenticationInfo(_ authenticationInfo: UserAuthenticationInfo?)\n    func wipeUserAuthenticationInfo()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eclass AuthorizationValueProvider {\n    \n    private let authenticationInfoStore: AuthenticationInfoStorage\n    private let tokenRefreshAPI: TokenRefreshing\n    \n    private let queue = DispatchQueue(label: \u0026lt;#label#\u0026gt;,\n                                      qos: .userInteractive)\n    private let semaphore = DispatchSemaphore(value: 1)\n    \n    init(tokenRefreshAPI: TokenRefreshing,\n         authenticationInfoStore: AuthenticationInfoStorage) {\n        self.tokenRefreshAPI = tokenRefreshAPI\n        self.authenticationInfoStore = authenticationInfoStore\n    }\n    \n    func getValidUserAuthorization(completion: @escaping (Result\u0026lt;AuthorizationValue, Error\u0026gt;) -\u0026gt; Void) {\n        queue.async {\n            self.getValidUserAuthorizationInMutualExclusion(completion: completion)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBefore performing any user-authenticated request, the network client asks an \u003ccode\u003eAuthorizationValueProvider\u003c/code\u003e instance to provide a valid user Authorization value (the JWT). It does so via the async method \u003ccode\u003egetValidUserAuthorization\u003c/code\u003e which uses a serial queue to handle the requests. The chunky part is the \u003ccode\u003egetValidUserAuthorizationInMutualExclusion\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eprivate func getValidUserAuthorizationInMutualExclusion(completion: @escaping (Result\u0026lt;AuthorizationValue, Error\u0026gt;) -\u0026gt; Void) {\n    semaphore.wait()\n        \n    guard let authenticationInfo = authenticationInfoStore.userAuthenticationInfo else {\n        semaphore.signal()\n        let error = // forge an error for \u0026#39;missing authorization\u0026#39;\n        completion(.failure(error))\n        return\n    }\n        \n    if authenticationInfo.isValid {\n        semaphore.signal()\n        completion(.success(authenticationInfo.bearerToken))\n        return\n    }\n        \n    tokenRefreshAPI.refreshAccessToken(authenticationInfo.refreshToken) { result in\n        switch result {\n        case .success(let authenticationInfo):\n            self.authenticationInfoStore.persistUserAuthenticationInfo(authenticationInfo)\n            self.semaphore.signal()\n            completion(.success(authenticationInfo.bearerToken))\n                \n        case .failure(let error) where error.isClientError:\n            self.authenticationInfoStore.wipeUserAuthenticationInfo()\n            self.semaphore.signal()\n            completion(.failure(error))\n                \n        case .failure(let error):\n            self.semaphore.signal()\n            completion(.failure(error))\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe method could fire off an async call to refresh the token, and this makes the usage of the semaphore crucial. Without it, the next request to \u003ccode\u003eAuthorizationValueProvider\u003c/code\u003e would be popped from the queue and executed before the remote refresh completes.\u003c/p\u003e\u003cp\u003eThe semaphore is initialised with a value of 1, meaning that only one thread can access the critical section at a given time. We make sure to call \u003ccode\u003ewait\u003c/code\u003e at the beginning of the execution and to call \u003ccode\u003esignal\u003c/code\u003e only when we have a result and therefore ready to leave the critical section.\u003c/p\u003e\u003cp\u003eIf the token found in the local store is still valid, we simply return it, otherwise, it\u0026#39;s time to request a new one. In the latter case, if all goes well, we persist the token locally and allow the next request to access the method, in the case of an error, we should be careful and wipe the token only if the error is a legit client error (2xx range). This includes also the usage of a refresh token that is not valid anymore, which could happen, for instance, if the user resets the password on another platform/device.\u003c/p\u003e\u003cp\u003eIt\u0026#39;s critical to \u003cstrong\u003enot \u003c/strong\u003edelete the token from the local store in the case of any other error, such as 5xx or the common Foundation\u0026#39;s \u003ccode\u003eNSURLErrorNotConnectedToInternet\u003c/code\u003e (-1009), or else the user would unexpectedly be logged out.\u003c/p\u003e\u003cp\u003eIt\u0026#39;s also important to note that the same \u003ccode\u003eAuthorizationValueProvider\u003c/code\u003e instance must be used by all the calls: using different ones would mean using different queues making the entire solution ineffective.\u003c/p\u003e\u003cp\u003eIt seemed clear that the network client we developed in-house had to embrace JWT refresh logic at its core so that all the API calls, even new ones that will be added in the future would make use of the same authentication flow.\u003c/p\u003e\u003ch2 id=\"general-recommendations\"\u003eGeneral recommendations\u003c/h2\u003e\u003cp\u003eHere are a couple more (minor) suggestions we thought are worth sharing since they might save you implementation time or influence the design of your solution.\u003c/p\u003e\u003ch3 id=\"correctly-parse-the-payload\"\u003eCorrectly parse the Payload\u003c/h3\u003e\u003cp\u003eAnother problem - even though quite trivial and that doesn\u0026#39;t seem to be discussed much - is the parsing of the JWT, that can fail in some cases. In our case, this was related to the base64 encoding function and \u0026#34;adjusting\u0026#34; the base64 payload to be parsed correctly. In some implementations of base64, the padding character is not needed for decoding, since the number of missing bytes can be calculated but in Foundation\u0026#39;s implementation it is mandatory. This caused us some head-scratching and this \u003ca href=\"https://stackoverflow.com/a/36366421/3010877?ref=albertodebortoli.com\"\u003eStackOverflow answer\u003c/a\u003e helped us.\u003c/p\u003e\u003cp\u003eThe solution is - more officially - stated in \u003ca href=\"https://tools.ietf.org/html/rfc7515?ref=albertodebortoli.com#appendix-C\"\u003eRFC 7515 - Appendix C\u003c/a\u003e and here is the corresponding Swift code:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc base64String(_ input: String) -\u0026gt; String {\n    var base64 = input\n        .replacingOccurrences(of: \u0026#34;-\u0026#34;, with: \u0026#34;+\u0026#34;)\n        .replacingOccurrences(of: \u0026#34;_\u0026#34;, with: \u0026#34;/\u0026#34;)\n        \n    switch base64.count % 4 {\n    case 2:\n        base64 = base64.appending(\u0026#34;==\u0026#34;)\n            \n    case 3:\n        base64 = base64.appending(\u0026#34;=\u0026#34;)\n            \n    default:\n        break\n    }\n        \n    return base64\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe majority of the developers rely on external libraries to ease the parsing of the token, but as we often do, we have implemented our solution from scratch, without relying on a third-party library. Nonetheless, we feel \u003ca href=\"https://github.com/kylef/JSONWebToken.swift?ref=albertodebortoli.com\"\u003eJSONWebToken\u003c/a\u003e by \u003ca href=\"https://twitter.com/kylefuller?ref=albertodebortoli.com\"\u003eKyle Fuller\u003c/a\u003e is a very good one and it seems to implement JWT faithfully to the RFC, clearly including the necessary \u003ca href=\"https://github.com/kylef/JSONWebToken.swift/blob/master/Sources/JWT/Base64.swift?ref=albertodebortoli.com\"\u003ebase64 decode function\u003c/a\u003e.\u003c/p\u003e\u003ch3 id=\"handle-multiple-jwt-for-multiple-app-states\"\u003eHandle multiple JWT for multiple app states\u003c/h3\u003e\u003cp\u003eAs previously stated, when using JWT as an authentication method for non-user- authenticated calls, we need to cater for at least 3 states, shown in the following enum:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eenum AuthenticationStatus {\n    case notAuthenticated\n    case clientAuthenticated\n    case userAuthenticated\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn a fresh install, we can expect to be in the \u003ccode\u003e.notAuthenticated\u003c/code\u003e state, but as soon as the first API call is ready to be performed, a valid Client JWT has to be fetched and stored locally (at this stage, other authentication mechanisms are used, most likely Basic Auth), moving to the \u003ccode\u003e.clientAuthenticated\u003c/code\u003e state. Once the user completes the login or signup procedure, a User JWT is retrieved and stored locally (but separately to the Client JWT), entering the \u003ccode\u003e.userAuthenticated\u003c/code\u003e, so that in the case of a logout we are left with a (hopefully still valid) Client JWT.\u003c/p\u003e\u003cp\u003eIn this scenario, almost all transitions are possible:\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/11/authorization_states.svg\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cp\u003eA couple of recommendations here:\u003c/p\u003e\u003cul\u003e\u003cli\u003eif the user is logged in is important to use the User JWT also for the non-user-authenticated calls as the server may personalise the response (e.g. the list of restaurants in the Just Eat app)\u003c/li\u003e\u003cli\u003estore both Client and User JWT, so that if the user logs out, the app is left with the Client JWT ready to be used to perform non-user-authenticated requests, saving an unnecessary call to fetch a new token\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eIn this article, we\u0026#39;ve shared some learnings from handling JWT on mobile that are not commonly discussed within the community. \u003c/p\u003e\u003cp\u003eAs a good practice, it\u0026#39;s always best to hide complexity and implementation details. Baking the refresh logic described above within your API client is a great way to avoid developers having to deal with complex logic to provide authorization, and enables all the API calls to undergo the same authentication mechanism. Consumers of an API client, should not have the ability to gather the JWT as itâ€™s not their concern to use it or to fiddle with it.\u003c/p\u003e\u003cp\u003eWe hope this article helps to raise awareness on how to better handle the usage of JWT on mobile applications, in particular making sure we always do our best to avoid accidental logouts to provide a better user experience.\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2019-12-04T17:21:58Z",
  "modifiedTime": "2019-12-04T17:21:58Z"
}
