{
  "id": "c60d6608-c479-4148-8e8a-c6f3d9dcca7d",
  "title": "Data Detection in Swift",
  "link": "https://atomicbird.com/blog/data-detection-in-swift/",
  "description": "I have a love/hate relationship with regular expressions. I love them because they’re great for examining text to find useful information and, often, to change the text in some way. I hate them because once you get beyond basic matching, they descend into bizarre write-only code that gives me flashbacks to my days writing Perl. In extreme cases they may well endanger the universe. And so we come to one of my recent coding issues: How can I find out if a string contains a valid email address?",
  "author": "",
  "published": "Wed, 25 Oct 2017 00:00:00 +0000",
  "source": "https://atomicbird.com/index.xml",
  "categories": null,
  "byline": "",
  "length": 7741,
  "excerpt": "I have a love/hate relationship with regular expressions. I love them because they’re great for examining text to find useful information and, often, to change the text in some way. I hate them because once you get beyond basic matching, they descend into bizarre write-only code that gives me flashbacks to my days writing Perl. In extreme cases they may well endanger the universe. And so we come to one of my recent coding issues: How can I find out if a string contains a valid email address?",
  "siteName": "Title",
  "favicon": "https://atomicbird.com/apple-touch-icon-144-precomposed.png",
  "text": "I have a love/hate relationship with regular expressions. I love them because they’re great for examining text to find useful information and, often, to change the text in some way. I hate them because once you get beyond basic matching, they descend into bizarre write-only code that gives me flashbacks to my days writing Perl. In extreme cases they may well endanger the universe. And so we come to one of my recent coding issues: How can I find out if a string contains a valid email address? Of course you can’t be completely sure an email address is valid without sending an email and then checking to see if anyone received it. That second half can’t be done reliably in code either– you may just need to ask someone. But addresses follow specific rules outlined in RFC 5322, so it should be possible to check the syntax to see if it could be valid. Enter regular expressions. Maybe. They certainly seem like the right tool for this job. So about that regex… If you hesitate before writing out the regex, you’re not alone. The rules are a little more subtle than they seem. Did yours allow, for example, for a + in the middle of the local-part (the stuff before the @)? It’s legal. So are a variety of other things that might not be immediately obvious. There’s no shortage of people with ideas on how to write this regex. None of them agree with each other. The highest-rated Stack Overflow answer presents this, along with a state diagram describing it: (?:[a-z0-9!#$%\u0026'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%\u0026'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\]) Maybe you can read that, and maybe I could if I had a week to spare, but I’d wager almost nobody even tries. In an iOS app I could just drop that into NSRegularExpression, and it would probably work. Maybe I’d need to add some backslashes to escape some characters. But you know what? I’m writing iOS apps, and Apple has a better solution. Data Detectors There’s a lot in Apple’s Foundation framework. It’s had literally decades to accumulate useful stuff. Several years ago, iOS 4 added a new class called NSDataDetector. Its purpose is to scan arbitrary text and find useful details. Sound like something we could use here? When NSDataDetector scans a string, you can tell it which types of information you want. The docs for NSTextCheckingResult.CheckingType list all kinds of useful options. Links, telephone numbers, dates, and addresses, to name a few. If you want to really get into it you can ask it to look for transit information (like flight details) or check grammar. Email addresses get wrapped up with the “link” type, which is what I’m interested in here. You create a data detector to match one or more data types: let detector = try? NSDataDetector(types: NSTextCheckingResult.CheckingType.link.rawValue) That gives us a data detector that looks only for links. The types argument is a little odd here. The CheckingType conforms to OptionSet, but I wasn’t able to get a more Swift-y version of the argument value to work. Now that we have a detector we can ask for every link match in a string: let myString = // some string we want to parse let matches = detector.matches(in: myString, options: [], range: NSMakeRange(0, myString.count)) This produces an array of NSTextCheckingResult, one per discovered data item. Matches have a variety of optional properties that may be set depending on what kind of match an instance represents. Here we only asked for .link matches, so every result will include a value for the url property, which will be an instance of URL. Other match types use other properties– phoneNumber, or addressComponents for example. We’re not done though, because .link will also match plain URLs found in text. We’ll need to run through the matches to find what we need. Email addresses are represented as mailto: URLs here (because they’re treated as links), so we’ll look for that. var addresses = [String]() for match in matches { if let matchURL = match.url, let matchURLComponents = URLComponents(url: matchURL, resolvingAgainstBaseURL: false), matchURLComponents.scheme == \"mailto\" { let address = matchURLComponents.path addresses.append(String(address)) } } This code loops over the matches. For each one, it checks to see if the URL uses mailto:. If so, it extracts the email address and adds it to an array. There’s one detail that might seem a little odd. I’m creating an instance of URLComponents to get the address, when it looks like the original URL would work on its own. Both classes have a path property, after all. Why the extra step? Well, remember what I said about Foundation having literally decades of history? That also means there’s some old cruft in places. URL parses URLs according to RFC 1808. That RFC was obsoleted by RFC 3986 back in 2005. URL still uses the older RFC, probably because changing it would break existing code. The upshot is that URL can’t extract the email address, but URLComponents can. But since NSTextCheckingResult still produces a URL, the code above needs to convert. Extending String This all comes together nicely in an extension to String. extension String { /** Get email addresses in a string, discard any other content. */ func emailAddresses() -\u003e [String] { var addresses = [String]() if let detector = try? NSDataDetector(types: NSTextCheckingResult.CheckingType.link.rawValue) { let matches = detector.matches(in: self, options: [], range: NSMakeRange(0, self.count)) for match in matches { if let matchURL = match.url, let matchURLComponents = URLComponents(url: matchURL, resolvingAgainstBaseURL: false), matchURLComponents.scheme == \"mailto\" { let address = matchURLComponents.path addresses.append(String(address)) } } } return addresses } } Using this, you can take any string, call emailAddresses() on it, and get an array of all addresses in the string. Any extra content is ignored. For example, \"foo@bar.com\".emailAddresses() // produces [\"foo@bar.com\"] \"my address is foo@bar.com\".emailAddresses() // also produces [\"foo@bar.com\"] \"foo@bar.com bar@foo.com\".emailAddresses() // produces [\"foo@bar.com\", \"bar@foo.com\"] \"Zip a dee doo dah\".emailAddresses() // produces an empty array This extension lends itself to a variety of UI rules. If only one email address is allowed, check that the address array has exactly one entry. If you also require that there must be no extraneous characters, add a check that the address length is the same as the original string length. The end result is probably more or less what we’d get using a regular expression. NSDataDetector is a subclass of NSRegularExpression, after all, so it very likely uses one or more regular expressions under the hood. Using this approach means that I get to write code that I can read, though, which is always a plus. It also means that I get to have Apple engineers writing my regular expressions instead of dropping in a long string of line noise-like characters that I can only pretend to understand. I’ll call it a win. Update: This post was featured in iOS Dev Weekly #325, which is just awesome to see. Update 2: This post was featured in Swift Weekly, which is another shot of awesome.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \u003cp\u003eI have a love/hate relationship with regular expressions. I \u003cstrong\u003elove\u003c/strong\u003e them because they’re great for examining text to find useful information and, often, to change the text in some way. I \u003cstrong\u003ehate\u003c/strong\u003e them because once you get beyond basic matching, they descend into bizarre \u003ca href=\"https://en.wikipedia.org/wiki/Write-only_language\"\u003ewrite-only code\u003c/a\u003e that gives me flashbacks to my days writing Perl. In extreme cases they may well \u003ca href=\"https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454\"\u003eendanger the universe\u003c/a\u003e. And so we come to one of my recent coding issues: How can I find out if a string contains a valid email address?\u003c/p\u003e\n\u003cp\u003eOf course you can’t be completely sure an email address is valid without sending an email and then checking to see if anyone received it. That second half can’t be done reliably in code either– you may just need to ask someone. But addresses follow \u003ca href=\"https://tools.ietf.org/html/rfc5322#section-3.4\"\u003especific rules outlined in RFC 5322\u003c/a\u003e, so it should be possible to check the syntax to see if it could be valid.\u003c/p\u003e\n\u003cp\u003eEnter regular expressions. Maybe. They certainly seem like the right tool for this job.\u003c/p\u003e\n\u003ch2 id=\"so-about-that-regex\"\u003eSo about that regex…\u003c/h2\u003e\n\u003cp\u003eIf you hesitate before writing out the regex, you’re not alone. The rules are a little more subtle than they seem. Did yours allow, for example, for a \u003ccode\u003e+\u003c/code\u003e in the middle of the \u003ccode\u003elocal-part\u003c/code\u003e (the stuff before the \u003ccode\u003e@\u003c/code\u003e)? It’s legal. So are a variety of other things that might not be immediately obvious.\u003c/p\u003e\n\u003cp\u003eThere’s \u003ca href=\"https://stackoverflow.com/search?q=email+address+regular+expression\"\u003eno shortage of people with ideas\u003c/a\u003e on how to write this regex. None of them agree with each other. The \u003ca href=\"https://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address\"\u003ehighest-rated Stack Overflow answer\u003c/a\u003e presents this, along with a state diagram describing it:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e(?:[a-z0-9!#$%\u0026amp;\u0026#39;*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%\u0026amp;\u0026#39;*+/=?^_`{|}~-]+)*|\u0026#34;(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\u0026#34;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMaybe you can read that, and maybe I could if I had a week to spare, but I’d wager almost nobody even tries.\u003c/p\u003e\n\u003cp\u003eIn an iOS app I could just drop that into \u003ccode\u003eNSRegularExpression\u003c/code\u003e, and it would probably work. Maybe I’d need to add some backslashes to escape some characters. But you know what? I’m writing iOS apps, and Apple has a better solution.\u003c/p\u003e\n\u003ch2 id=\"data-detectors\"\u003eData Detectors\u003c/h2\u003e\n\u003cp\u003eThere’s a lot in Apple’s Foundation framework. It’s had literally decades to accumulate useful stuff. Several years ago, iOS 4 added a new class called \u003ccode\u003eNSDataDetector\u003c/code\u003e. Its purpose is to scan arbitrary text and find useful details. Sound like something we could use here?\u003c/p\u003e\n\u003cp\u003eWhen \u003ccode\u003eNSDataDetector\u003c/code\u003e scans a string, you can tell it which types of information you want. The docs for \u003ca href=\"https://developer.apple.com/documentation/foundation/nstextcheckingresult.checkingtype\"\u003eNSTextCheckingResult.CheckingType\u003c/a\u003e list all kinds of useful options. Links, telephone numbers, dates, and addresses, to name a few. If you want to really get into it you can ask it to look for transit information (like flight details) or check grammar. Email addresses get wrapped up with the “link” type, which is what I’m interested in here.\u003c/p\u003e\n\u003cp\u003eYou create a data detector to match one or more data types:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e detector = \u003cspan\u003etry\u003c/span\u003e? NSDataDetector(types: \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    NSTextCheckingResult.CheckingType.link.rawValue)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThat gives us a data detector that looks only for links. The \u003ccode\u003etypes\u003c/code\u003e argument is a little odd here. The \u003ccode\u003eCheckingType\u003c/code\u003e conforms to \u003ccode\u003eOptionSet\u003c/code\u003e, but I wasn’t able to get a more Swift-y version of the argument value to work.\u003c/p\u003e\n\u003cp\u003eNow that we have a detector we can ask for every link match in a string:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e myString = \u003cspan\u003e// some string we want to parse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e matches = detector.matches(\u003cspan\u003ein\u003c/span\u003e: myString, options: [], range: NSMakeRange(\u003cspan\u003e0\u003c/span\u003e, myString.count))\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis produces an array of \u003ccode\u003eNSTextCheckingResult\u003c/code\u003e, one per discovered data item. Matches have a variety of optional properties that may be set depending on what kind of match an instance represents. Here we only asked for \u003ccode\u003e.link\u003c/code\u003e matches, so every result will include a value for the \u003ccode\u003eurl\u003c/code\u003e property, which will be an instance of \u003ccode\u003eURL\u003c/code\u003e. Other match types use other properties– \u003ccode\u003ephoneNumber\u003c/code\u003e, or \u003ccode\u003eaddressComponents\u003c/code\u003e for example.\u003c/p\u003e\n\u003cp\u003eWe’re not done though, because \u003ccode\u003e.link\u003c/code\u003e will also match plain URLs found in text. We’ll need to run through the matches to find what we need. Email addresses are represented as \u003ccode\u003emailto:\u003c/code\u003e URLs here (because they’re treated as links), so we’ll look for that.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evar\u003c/span\u003e addresses = [String]()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efor\u003c/span\u003e match \u003cspan\u003ein\u003c/span\u003e matches {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e matchURL = match.url,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e matchURLComponents = URLComponents(url: matchURL, resolvingAgainstBaseURL: \u003cspan\u003efalse\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        matchURLComponents.scheme == \u003cspan\u003e\u0026#34;mailto\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e address = matchURLComponents.path\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        addresses.append(String(address))\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis code loops over the matches. For each one, it checks to see if the URL uses \u003ccode\u003emailto:\u003c/code\u003e. If so, it extracts the email address and adds it to an array.\u003c/p\u003e\n\u003cp\u003eThere’s one detail that might seem a little odd. I’m creating an instance of \u003ccode\u003eURLComponents\u003c/code\u003e to get the address, when it looks like the original \u003ccode\u003eURL\u003c/code\u003e would work on its own. Both classes have a \u003ccode\u003epath\u003c/code\u003e property, after all. Why the extra step? Well, remember what I said about Foundation having literally decades of history? That also means there’s some old cruft in places. \u003ccode\u003eURL\u003c/code\u003e parses URLs according to RFC 1808. That RFC was obsoleted by RFC 3986 back in 2005. URL still uses the older RFC, probably because changing it would break existing code. The upshot is that URL can’t extract the email address, but \u003ccode\u003eURLComponents\u003c/code\u003e can. But since \u003ccode\u003eNSTextCheckingResult\u003c/code\u003e still produces a \u003ccode\u003eURL\u003c/code\u003e, the code above needs to convert.\u003c/p\u003e\n\u003ch2 id=\"extending-string\"\u003eExtending String\u003c/h2\u003e\n\u003cp\u003eThis all comes together nicely in an extension to String.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e/** Get email addresses in a string, discard any other content. */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eemailAddresses\u003c/span\u003e() -\u0026gt; [String] {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003evar\u003c/span\u003e addresses = [String]()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e detector = \u003cspan\u003etry\u003c/span\u003e? NSDataDetector(types: NSTextCheckingResult.CheckingType.link.rawValue) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003elet\u003c/span\u003e matches = detector.matches(\u003cspan\u003ein\u003c/span\u003e: \u003cspan\u003eself\u003c/span\u003e, options: [], range: NSMakeRange(\u003cspan\u003e0\u003c/span\u003e, \u003cspan\u003eself\u003c/span\u003e.count))\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003efor\u003c/span\u003e match \u003cspan\u003ein\u003c/span\u003e matches {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e matchURL = match.url,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    \u003cspan\u003elet\u003c/span\u003e matchURLComponents = URLComponents(url: matchURL, resolvingAgainstBaseURL: \u003cspan\u003efalse\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    matchURLComponents.scheme == \u003cspan\u003e\u0026#34;mailto\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    \u003cspan\u003elet\u003c/span\u003e address = matchURLComponents.path\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    addresses.append(String(address))\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e addresses\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eUsing this, you can take any string, call \u003ccode\u003eemailAddresses()\u003c/code\u003e on it, and get an array of all addresses in the string. Any extra content is ignored. For example,\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u0026#34;foo@bar.com\u0026#34;.emailAddresses() // produces [\u0026#34;foo@bar.com\u0026#34;]\n\u0026#34;my address is foo@bar.com\u0026#34;.emailAddresses() // also produces [\u0026#34;foo@bar.com\u0026#34;]\n\u0026#34;foo@bar.com bar@foo.com\u0026#34;.emailAddresses() // produces [\u0026#34;foo@bar.com\u0026#34;, \u0026#34;bar@foo.com\u0026#34;]\n\u0026#34;Zip a dee doo dah\u0026#34;.emailAddresses() // produces an empty array\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis extension lends itself to a variety of UI rules. If only one email address is allowed, check that the address array has exactly one entry. If you also require that there must be no extraneous characters, add a check that the address length is the same as the original string length.\u003c/p\u003e\n\u003cp\u003eThe end result is probably more or less what we’d get using a regular expression. \u003ccode\u003eNSDataDetector\u003c/code\u003e is a subclass of \u003ccode\u003eNSRegularExpression\u003c/code\u003e, after all, so it very likely uses one or more regular expressions under the hood. Using this approach means that I get to write code that I can read, though, which is always a plus. It also means that I get to have Apple engineers writing my regular expressions instead of dropping in a long string of line noise-like characters that I can only pretend to understand. I’ll call it a win.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUpdate:\u003c/strong\u003e This post was featured in \u003ca href=\"https://iosdevweekly.com/issues/325\"\u003eiOS Dev Weekly #325\u003c/a\u003e, which is just awesome to see.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUpdate 2:\u003c/strong\u003e This post was featured in \u003ca href=\"http://digest.swiftweekly.com/issues/swift-weekly-issue-95-79745\"\u003eSwift Weekly\u003c/a\u003e, which is another shot of awesome.\u003c/p\u003e\n\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2017-10-25T00:00:00Z",
  "modifiedTime": "2017-10-25T00:00:00Z"
}
