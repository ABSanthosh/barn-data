{
  "id": "35a08167-eb77-4d80-885c-281b3080ad14",
  "title": "Using Swift’s defer keyword within async and throwing contexts",
  "link": "https://www.swiftbysundell.com/articles/using-defer-within-async-and-throwing-contexts",
  "description": "How Swift’s defer keyword can be incredibly useful when working with code scopes that have multiple exit points, such as throwing or async functions.",
  "author": "",
  "published": "Tue, 15 Apr 2025 16:45:00 +0200",
  "source": "https://www.swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 8949,
  "excerpt": "How Swift’s defer keyword can be incredibly useful when working with code scopes that have multiple exit points, such as throwing or async functions.",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "Swift’s defer keyword allows us to delay the execution of a given block of code until the current scope is exited. While that might initially not seem that useful (after all, can’t we simply write that code at the end of the scope instead?), it turns out that when writing modern Swift code, we’re quite often dealing with multiple potential exit points within our functions and closures — especially when writing code that throws, or when utilizing async/await.Let’s take a look at the following SearchService type’s loadItems method as an example. It uses a Database API that requires a connection to be opened before any operations can be performed, and that connection then needs to be properly closed and cleaned up before new database requests can be accepted:actor SearchService { private let database: Database ... func loadItems(maching searchString: String) throws -\u003e [Item] { let connection = database.connect() do { let items: [Item] = try connection.runQuery(.entries( matching: searchString )) connection.close() return items } catch { connection.close() throw error } } }Note how we need to explicitly specify the type for our items above, since the runQuery method is generic, as it can return an array of any kind of database-compatible entry type that we’re looking to retrieve.Because our code has two separate branches (one for when our runQuery call succeeds, and one for when an error is thrown), we need to write separate calls to connection.close within each branch. That might initially not seem like a big deal, but just like most code duplication, it increases the chance that we’ll end up making a mistake, which could result in a quite major bug in this instance (as missing a close call would leave the database unable to accept additional requests).One way to solve the above problem would be to ensure that our code only has a single branch of execution. In the case of the above loadItems method, that could be done by using the closure-based Result initializer included in the standard library, which converts a throwing closure into a result, which can then be unwrapped once we’ve closed our database connection — like this:actor SearchService { private let database: Database ... func loadItems(maching searchString: String) throws -\u003e [Item] { let connection = database.connect() let result = Result\u003c[Item], Error\u003e { try connection.runQuery(.entries(matching: searchString)) } connection.close() return try result.get() } }While that’s certainly an improvement — let’s now take a look at how defer lets us solve the problem in an arguably much more elegant way, since it’ll let us define the closing of our database connection right next to where the connection is opened:actor SearchService { private let database: Database ... func loadItems(maching searchString: String) throws -\u003e [Item] { let connection = database.connect() defer { connection.close() } return try connection.runQuery(.entries(matching: searchString)) } }Nice! Not only are the calls to connect and close now right next to each other (which arguably makes it easier to reason about those two calls as a pair), but because we can now directly return the result of our runQuery call, we no longer have to manually specify any type information — the compiler can now automatically infer the return type of that call for us.Using defer does have somewhat of a downside, though, in that it sort of breaks the traditional control flow model that structured programming tends to follow — where instructions are always executed from top to bottom. Within our current loadItems implementation, for example, we now have three expressions: 1. Open the connection 2. Close the connection (deferred) 3. Run our query But those expressions won’t be executed in the order 1, 2, 3, but rather in the order 1, 3, 2, which might initially seem like a quite strange way of structuring our code. So, using defer might end up being somewhat of an acquired taste, and a tool that should probably not be over-used, but rather just used when there’s some specific cleanup work that we want to ensure gets performed no matter how the current scope is exited.Async contextsThe defer keyword is perhaps even more useful in the concurrent world of async/await, since one of the benefits of that way of writing async code is that it lets us “flatten” code that previously required nesting in the shape of closures or separate operations.For example, within the following ItemListService, we once again have to work with separate code branches (and thus, nesting) in order to ensure that an isLoading bool is set back to false whenever a loading operation was completed:actor ItemListService { private let networking: NetworkingService private var isLoading = false ... func loadItems(after lastItem: Item) async throws -\u003e [Item] { guard !isLoading else { throw Error.alreadyLoading } isLoading = true do { let request = requestForLoadingItems(after: lastItem) let response = try await networking.performRequest(request) let items: [Item] = try response.decoded() isLoading = false return items } catch { isLoading = false throw error } } }In this case, we can’t rely on the Result-based approach we took earlier to flatten our code into a single branch, since there’s no built-in way to convert an async closure into a Result (although that’s something we could add, using a custom extension). So this is a type of situation where defer really comes in handy, as it lets us ensure that our isLoading state is always assigned back to false whenever an operation either succeeded or failed:actor ItemListService { private let networking: NetworkingService private var isLoading = false ... func loadItems(after lastItem: Item) async throws -\u003e [Item] { guard !isLoading else { throw LoadingError.alreadyLoading } isLoading = true defer { isLoading = false } let request = requestForLoadingItems(after: lastItem) let response = try await networking.performRequest(request) return try response.decoded() } }The above type of approach can also be really useful when working with nested async tasks as well. For example, let’s say that we wanted to improve the above loadItems method so that it doesn’t throw an error if called while a loading operation is already underway. To do that, we could keep track of a dictionary of loading tasks (keyed by the ID of the lastItem for each task), and then use defer to ensure that a task is always removed from that dictionary when it was completed — like this:actor ItemListService { private let networking: NetworkingService private var activeTasksForLastItemID = [Item.ID: Task\u003c[Item], Error\u003e]() ... func loadItems(after lastItem: Item) async throws -\u003e [Item] { if let existingTask = activeTasksForLastItemID[lastItem.id] { return try await existingTask.value } let task = Task { defer { activeTasksForLastItemID[lastItem.id] = nil } let request = requestForLoadingItems(after: lastItem) let response = try await networking.performRequest(request) return try response.decoded() as [Item] } activeTasksForLastItemID[lastItem.id] = task return try await task.value } }In general, the above technique is a neat way of preventing duplicate async actor requests, since actors only protect against simultaneous calls while they’re busy performing synchronous work. Once an actor has started an async task using await, it’s free to accept new calls while that async task is being performed. By using a nested Task combined with the defer keyword, we can ensure that such duplicate requests are properly reused and discarded once finished, all in a predictable manner.Swift by Sundell is brought to you by the Genius Scan SDK — Add a powerful document scanner to any mobile app, and turn scans into high-quality PDFs with one line of code. Try it today.ConclusionSwift’s defer keyword might initially seem like a somewhat odd language tool, as it doesn’t strictly follow the top-to-bottom control flow order that structured programming tend to use. But when it comes to cleanup operations, state management, and other tasks that we want to ensure are run no matter how a given scope is exited, it can be a really great tool — especially when utilizing Swift concurrency and the language’s native error handling model.If you’ve got questions, comments, or feedback, then feel free to reach out via either Mastodon or Bluesky.Thanks for reading!",
  "image": "https://www.swiftbysundell.com/images/social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eSwift’s \u003ccode\u003edefer\u003c/code\u003e keyword allows us to delay the execution of a given block of code until the current scope is exited. While that might initially not seem \u003cem\u003ethat\u003c/em\u003e useful (after all, can’t we simply write that code at the end of the scope instead?), it turns out that when writing modern Swift code, we’re quite often dealing with multiple potential exit points within our functions and closures — especially when writing code that \u003ccode\u003ethrows\u003c/code\u003e, or when utilizing \u003ccode\u003easync/await\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eLet’s take a look at the following \u003ccode\u003eSearchService\u003c/code\u003e type’s \u003ccode\u003eloadItems\u003c/code\u003e method as an example. It uses a \u003ccode\u003eDatabase\u003c/code\u003e API that requires a connection to be opened before any operations can be performed, and that connection then needs to be properly closed and cleaned up before new database requests can be accepted:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eactor\u003c/span\u003e SearchService {\n    \u003cspan\u003eprivate let\u003c/span\u003e database: \u003cspan\u003eDatabase\u003c/span\u003e\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadItems(maching searchString: \u003cspan\u003eString\u003c/span\u003e) \u003cspan\u003ethrows\u003c/span\u003e -\u0026gt; [\u003cspan\u003eItem\u003c/span\u003e] {\n        \u003cspan\u003elet\u003c/span\u003e connection = \u003cspan\u003edatabase.\u003cspan\u003econnect\u003c/span\u003e()\u003c/span\u003e\n\n        \u003cspan\u003edo\u003c/span\u003e {\n            \u003cspan\u003elet\u003c/span\u003e items: [\u003cspan\u003eItem\u003c/span\u003e] = \u003cspan\u003etry\u003c/span\u003e connection.\u003cspan\u003erunQuery\u003c/span\u003e(.\u003cspan\u003eentries\u003c/span\u003e(\n                matching: searchString\n            ))\n\n            \u003cspan\u003econnection.\u003cspan\u003eclose\u003c/span\u003e()\u003c/span\u003e\n            \u003cspan\u003ereturn\u003c/span\u003e items\n        } \u003cspan\u003ecatch\u003c/span\u003e {\n            \u003cspan\u003econnection.\u003cspan\u003eclose\u003c/span\u003e()\u003c/span\u003e\n            \u003cspan\u003ethrow\u003c/span\u003e error\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp\u003eNote how we need to explicitly specify the type for our \u003ccode\u003eitems\u003c/code\u003e above, since the \u003ccode\u003erunQuery\u003c/code\u003e method is generic, as it can return an array of any kind of database-compatible entry type that we’re looking to retrieve.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eBecause our code has two separate branches (one for when our \u003ccode\u003erunQuery\u003c/code\u003e call succeeds, and one for when an error is thrown), we need to write separate calls to \u003ccode\u003econnection.close\u003c/code\u003e within each branch. That might initially not seem like a big deal, but just like most code duplication, it increases the chance that we’ll end up making a mistake, which could result in a quite major bug in this instance (as missing a \u003ccode\u003eclose\u003c/code\u003e call would leave the database unable to accept additional requests).\u003c/p\u003e\u003cp\u003eOne way to solve the above problem would be to ensure that our code only has a single branch of execution. In the case of the above \u003ccode\u003eloadItems\u003c/code\u003e method, that could be done by using the closure-based \u003ccode\u003eResult\u003c/code\u003e initializer included in the standard library, which converts a throwing closure into a result, which can then be unwrapped once we’ve closed our database connection — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eactor\u003c/span\u003e SearchService {\n    \u003cspan\u003eprivate let\u003c/span\u003e database: \u003cspan\u003eDatabase\u003c/span\u003e\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadItems(maching searchString: \u003cspan\u003eString\u003c/span\u003e) \u003cspan\u003ethrows\u003c/span\u003e -\u0026gt; [\u003cspan\u003eItem\u003c/span\u003e] {\n        \u003cspan\u003elet\u003c/span\u003e connection = database.\u003cspan\u003econnect\u003c/span\u003e()\n\n        \u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e result = \u003cspan\u003eResult\u003c/span\u003e\u0026lt;[\u003cspan\u003eItem\u003c/span\u003e], \u003cspan\u003eError\u003c/span\u003e\u0026gt;\u003c/span\u003e {\n            \u003cspan\u003etry\u003c/span\u003e connection.\u003cspan\u003erunQuery\u003c/span\u003e(.\u003cspan\u003eentries\u003c/span\u003e(matching: searchString))\n        }\n\n        connection.\u003cspan\u003eclose\u003c/span\u003e()\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u003cspan\u003etry\u003c/span\u003e result.\u003cspan\u003eget\u003c/span\u003e()\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhile that’s certainly an improvement — let’s now take a look at how \u003ccode\u003edefer\u003c/code\u003e lets us solve the problem in an arguably much more elegant way, since it’ll let us define the closing of our database connection right next to where the connection is opened:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eactor\u003c/span\u003e SearchService {\n    \u003cspan\u003eprivate let\u003c/span\u003e database: \u003cspan\u003eDatabase\u003c/span\u003e\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadItems(maching searchString: \u003cspan\u003eString\u003c/span\u003e) \u003cspan\u003ethrows\u003c/span\u003e -\u0026gt; [\u003cspan\u003eItem\u003c/span\u003e] {\n        \u003cspan\u003elet\u003c/span\u003e connection = database.\u003cspan\u003econnect\u003c/span\u003e()\n        \u003cspan\u003e\u003cspan\u003edefer\u003c/span\u003e { connection.\u003cspan\u003eclose\u003c/span\u003e() }\u003c/span\u003e\n\n        \u003cspan\u003ereturn try\u003c/span\u003e connection.\u003cspan\u003erunQuery\u003c/span\u003e(.\u003cspan\u003eentries\u003c/span\u003e(matching: searchString))\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNice! Not only are the calls to \u003ccode\u003econnect\u003c/code\u003e and \u003ccode\u003eclose\u003c/code\u003e now right next to each other (which arguably makes it easier to reason about those two calls as a pair), but because we can now directly return the result of our \u003ccode\u003erunQuery\u003c/code\u003e call, we no longer have to manually specify any type information — the compiler can now automatically infer the return type of that call for us.\u003c/p\u003e\u003cp\u003eUsing \u003ccode\u003edefer\u003c/code\u003e does have somewhat of a downside, though, in that it sort of breaks the traditional control flow model that structured programming tends to follow — where instructions are always executed from top to bottom. Within our current \u003ccode\u003eloadItems\u003c/code\u003e implementation, for example, we now have three expressions:\u003c/p\u003e\u003cul\u003e\n\u003cli\u003e1. Open the connection\u003c/li\u003e\n\u003cli\u003e2. Close the connection (deferred)\u003c/li\u003e\n\u003cli\u003e3. Run our query\u003c/li\u003e\n\u003c/ul\u003e\u003cp\u003eBut those expressions won’t be executed in the order \u003ccode\u003e1, 2, 3\u003c/code\u003e, but rather in the order \u003ccode\u003e1, 3, 2\u003c/code\u003e, which might initially seem like a quite strange way of structuring our code. So, using \u003ccode\u003edefer\u003c/code\u003e might end up being somewhat of an \u003cem\u003eacquired taste\u003c/em\u003e, and a tool that should probably not be over-used, but rather just used when there’s some specific cleanup work that we want to ensure gets performed no matter how the current scope is exited.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"async-contexts\" href=\"#async-contexts\"\u003eAsync contexts\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eThe \u003ccode\u003edefer\u003c/code\u003e keyword is perhaps even more useful in the concurrent world of \u003ccode\u003easync/await\u003c/code\u003e, since one of the benefits of that way of writing async code is that it lets us “flatten” code that previously required nesting in the shape of closures or separate operations.\u003c/p\u003e\u003cp\u003eFor example, within the following \u003ccode\u003eItemListService\u003c/code\u003e, we once again have to work with separate code branches (and thus, nesting) in order to ensure that an \u003ccode\u003eisLoading\u003c/code\u003e bool is set back to \u003ccode\u003efalse\u003c/code\u003e whenever a loading operation was completed:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eactor\u003c/span\u003e ItemListService {\n    \u003cspan\u003eprivate let\u003c/span\u003e networking: \u003cspan\u003eNetworkingService\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003eprivate var\u003c/span\u003e isLoading = \u003cspan\u003efalse\u003c/span\u003e\u003c/span\u003e\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadItems(after lastItem: \u003cspan\u003eItem\u003c/span\u003e) \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; [\u003cspan\u003eItem\u003c/span\u003e] {\n        \u003cspan\u003e\u003cspan\u003eguard\u003c/span\u003e !isLoading \u003cspan\u003eelse\u003c/span\u003e { \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003eError\u003c/span\u003e.\u003cspan\u003ealreadyLoading\u003c/span\u003e }\nisLoading = \u003cspan\u003etrue\u003c/span\u003e\u003c/span\u003e\n\n        \u003cspan\u003edo\u003c/span\u003e {\n            \u003cspan\u003elet\u003c/span\u003e request = \u003cspan\u003erequestForLoadingItems\u003c/span\u003e(after: lastItem)\n            \u003cspan\u003elet\u003c/span\u003e response = \u003cspan\u003etry await\u003c/span\u003e networking.\u003cspan\u003eperformRequest\u003c/span\u003e(request)\n            \u003cspan\u003elet\u003c/span\u003e items: [\u003cspan\u003eItem\u003c/span\u003e] = \u003cspan\u003etry\u003c/span\u003e response.\u003cspan\u003edecoded\u003c/span\u003e()\n            \n            \u003cspan\u003eisLoading = \u003cspan\u003efalse\u003c/span\u003e\u003c/span\u003e\n            \u003cspan\u003ereturn\u003c/span\u003e items\n        } \u003cspan\u003ecatch\u003c/span\u003e {\n            \u003cspan\u003eisLoading = \u003cspan\u003efalse\u003c/span\u003e\u003c/span\u003e\n            \u003cspan\u003ethrow\u003c/span\u003e error\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this case, we can’t rely on the \u003ccode\u003eResult\u003c/code\u003e-based approach we took earlier to flatten our code into a single branch, since there’s no built-in way to convert an \u003ccode\u003easync\u003c/code\u003e closure into a \u003ccode\u003eResult\u003c/code\u003e (although that’s something we \u003cem\u003ecould\u003c/em\u003e add, using a custom extension). So this is a type of situation where \u003ccode\u003edefer\u003c/code\u003e really comes in handy, as it lets us ensure that our \u003ccode\u003eisLoading\u003c/code\u003e state is always assigned back to \u003ccode\u003efalse\u003c/code\u003e whenever an operation either succeeded or failed:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eactor\u003c/span\u003e ItemListService {\n    \u003cspan\u003eprivate let\u003c/span\u003e networking: \u003cspan\u003eNetworkingService\u003c/span\u003e\n    \u003cspan\u003eprivate var\u003c/span\u003e isLoading = \u003cspan\u003efalse\u003c/span\u003e\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadItems(after lastItem: \u003cspan\u003eItem\u003c/span\u003e) \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; [\u003cspan\u003eItem\u003c/span\u003e] {\n        \u003cspan\u003eguard\u003c/span\u003e !isLoading \u003cspan\u003eelse\u003c/span\u003e { \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003eLoadingError\u003c/span\u003e.\u003cspan\u003ealreadyLoading\u003c/span\u003e }\n        isLoading = \u003cspan\u003etrue\u003c/span\u003e\n        \u003cspan\u003e\u003cspan\u003edefer\u003c/span\u003e { isLoading = \u003cspan\u003efalse\u003c/span\u003e }\u003c/span\u003e\n\n        \u003cspan\u003elet\u003c/span\u003e request = \u003cspan\u003erequestForLoadingItems\u003c/span\u003e(after: lastItem)\n        \u003cspan\u003elet\u003c/span\u003e response = \u003cspan\u003etry await\u003c/span\u003e networking.\u003cspan\u003eperformRequest\u003c/span\u003e(request)\n        \u003cspan\u003ereturn try\u003c/span\u003e response.\u003cspan\u003edecoded\u003c/span\u003e()\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above type of approach can also be really useful when working with nested async tasks as well. For example, let’s say that we wanted to improve the above \u003ccode\u003eloadItems\u003c/code\u003e method so that it doesn’t throw an error if called while a loading operation is already underway. To do that, we could keep track of a dictionary of loading tasks (keyed by the ID of the \u003ccode\u003elastItem\u003c/code\u003e for each task), and then use \u003ccode\u003edefer\u003c/code\u003e to ensure that a task is always removed from that dictionary when it was completed — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eactor\u003c/span\u003e ItemListService {\n    \u003cspan\u003eprivate let\u003c/span\u003e networking: \u003cspan\u003eNetworkingService\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003eprivate var\u003c/span\u003e activeTasksForLastItemID = [\u003cspan\u003eItem\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e: \u003cspan\u003eTask\u003c/span\u003e\u0026lt;[\u003cspan\u003eItem\u003c/span\u003e], \u003cspan\u003eError\u003c/span\u003e\u0026gt;]()\u003c/span\u003e\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadItems(after lastItem: \u003cspan\u003eItem\u003c/span\u003e) \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; [\u003cspan\u003eItem\u003c/span\u003e] {\n        \u003cspan\u003e\u003cspan\u003eif let\u003c/span\u003e existingTask = activeTasksForLastItemID[lastItem.\u003cspan\u003eid\u003c/span\u003e]\u003c/span\u003e {\n            \u003cspan\u003ereturn try await\u003c/span\u003e existingTask.\u003cspan\u003evalue\u003c/span\u003e\n        }\n\n        \u003cspan\u003elet\u003c/span\u003e task = \u003cspan\u003eTask\u003c/span\u003e {\n            \u003cspan\u003e\u003cspan\u003edefer\u003c/span\u003e { activeTasksForLastItemID[lastItem.\u003cspan\u003eid\u003c/span\u003e] = \u003cspan\u003enil\u003c/span\u003e }\u003c/span\u003e\n\n            \u003cspan\u003elet\u003c/span\u003e request = \u003cspan\u003erequestForLoadingItems\u003c/span\u003e(after: lastItem)\n            \u003cspan\u003elet\u003c/span\u003e response = \u003cspan\u003etry await\u003c/span\u003e networking.\u003cspan\u003eperformRequest\u003c/span\u003e(request)\n            \u003cspan\u003ereturn try\u003c/span\u003e response.\u003cspan\u003edecoded\u003c/span\u003e() \u003cspan\u003eas\u003c/span\u003e [\u003cspan\u003eItem\u003c/span\u003e]\n        }\n\n        \u003cspan\u003eactiveTasksForLastItemID[lastItem.\u003cspan\u003eid\u003c/span\u003e] = task\n\u003cspan\u003ereturn try await\u003c/span\u003e task.\u003cspan\u003evalue\u003c/span\u003e\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn general, the above technique is a neat way of preventing duplicate async actor requests, since actors only protect against simultaneous calls while they’re busy performing \u003cem\u003esynchronous\u003c/em\u003e work. Once an actor has started an async task using \u003ccode\u003eawait\u003c/code\u003e, it’s free to accept new calls while that async task is being performed. By using a nested \u003ccode\u003eTask\u003c/code\u003e combined with the \u003ccode\u003edefer\u003c/code\u003e keyword, we can ensure that such duplicate requests are properly reused and discarded once finished, all in a predictable manner.\u003c/p\u003e\u003ca href=\"https://geniusscansdk.com/swiftbysundell?utm_content=inline_ad\" rel=\"nofollow\" target=\"_blank\"\u003e\u003cimg src=\"https://www.swiftbysundell.com/images/supporters/geniusScan-image.png\" alt=\"Genius Scan SDK\"/\u003e\u003cp\u003eSwift by Sundell is brought to you by the \u003cstrong\u003eGenius Scan SDK\u003c/strong\u003e — Add a powerful document scanner to any mobile app, and turn scans into high-quality PDFs with one line of code. \u003cu\u003eTry it today\u003c/u\u003e.\u003c/p\u003e\u003c/a\u003e\u003ch2\u003e\u003ca id=\"conclusion\" href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSwift’s \u003ccode\u003edefer\u003c/code\u003e keyword might initially seem like a somewhat odd language tool, as it doesn’t strictly follow the top-to-bottom control flow order that structured programming tend to use. But when it comes to cleanup operations, state management, and other tasks that we want to ensure are run no matter how a given scope is exited, it can be a really great tool — especially when utilizing Swift concurrency and the language’s native error handling model.\u003c/p\u003e\u003cp\u003eIf you’ve got questions, comments, or feedback, then feel free to reach out via either \u003ca href=\"https://mastodon.social/@johnsundell\"\u003eMastodon\u003c/a\u003e or \u003ca href=\"https://bsky.app/profile/johnsundell.bsky.social\"\u003eBluesky\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": null,
  "modifiedTime": null
}
