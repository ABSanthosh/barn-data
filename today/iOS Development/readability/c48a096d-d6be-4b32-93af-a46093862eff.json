{
  "id": "c48a096d-d6be-4b32-93af-a46093862eff",
  "title": "The iOS internationalization basics I keep forgetting",
  "link": "https://albertodebortoli.com/2020/01/06/the-ios-internationalization-basics-i-keep-forgetting/",
  "description": "Localizations, locales, timezones, date and currency formatting... it's shocking how easy is to forget how they work and how to use them correctly. In this article, I try to summarize the bare minimum one needs to know to add internationalization support to an iOS app.",
  "author": "Alberto De Bortoli",
  "published": "Mon, 06 Jan 2020 13:59:01 GMT",
  "source": "https://albertodebortoli.com/rss/",
  "categories": [
    "iOS",
    "formatting",
    "date",
    "currency",
    "timezone",
    "locale",
    "language"
  ],
  "byline": "Alberto De Bortoli",
  "length": 14732,
  "excerpt": "Localizations, locales, timezones, date and currency formatting... it's shocking how easy is to forget how they work and how to use them correctly. In this article, I try to summarize the bare minimum one needs to know to add internationalization support to an iOS app.",
  "siteName": "Alberto De Bortoli",
  "favicon": "",
  "text": "In this article, I try to summarize the bare minimum one needs to know to add internationalization support to an iOS app. Localizations, locales, timezones, date and currency formatting... it's shocking how easy is to forget how they work and how to use them correctly.After years more than 10 years into iOS development, I decided to write down a few notes on the matter, with the hope that they will come handy again in the future, hopefully not only to me.TL;DRFrom Apple docs:Date: a specific point in time, independent of any calendar or time zone;TimeZone: information about standard time conventions associated with a specific geopolitical region;Locale: information about linguistic, cultural, and technological conventions for use in formatting data for presentation.Rule of thumb:All DateFormatters should use the locale and the timezone of the device;All NumberFormatter, in particular those with numberStyle set to .currency (for the sake of this article) should use a specific locale so that prices are not shown in the wrong currency.General notes on formattersLet's start by stating the obvious.Since iOS 10, Foundation (finally) provides ISO8601DateFormatter, which, alongside with DateFormatter and NumberFormatter, inherits from Formatter. Formatter locale property timeZone property ISO8601DateFormatter ‚ùå ‚úÖ DateFormatter ‚úÖ ‚úÖ NumberFormatter ‚úÖ ‚ùå In an app that only consumes data from an API, the main purpose of ISO8601DateFormatter is to convert strings to dates (String -\u003e Date) more than the inverse. DateFormatter is then used to format dates (Date -\u003e String) to ultimately show the values in the UI. NumberFormatter instead, converts numbers (prices in the vast majority of the cases) to strings (NSNumber/Decimal -\u003e String).Formatting dates üïó üïù üïüIt seems the following 4 are amongst the most common ISO 8601 formats, including the optional UTC offset.A: 2019-10-02T16:53:42B: 2019-10-02T16:53:42ZC: 2019-10-02T16:53:42-02:00D: 2019-10-02T16:53:42.974ZIn this article I'll stick to these formats.The 'Z' at the end of an ISO8601 date indicates that it is in UTC, not a local time zone.LocalesConverting strings to dates (String -\u003e Date) is done using ISO8601DateFormatter objects set up with various formatOptions.Once we have a Date object, we can deal with the formatting for the presentation. Here, the locale is important and things can get a bit tricky. Locales have nothing to do with timezones, locales are for applying a format using a language/region.Locale identifiers are in the form of \u003clanguage_identifier\u003e_\u003cregion_identifier\u003e (e.g. en_GB).We should use the user's locale when formatting dates (Date -\u003e String). Consider a British user moving to Italy, the apps should keep showing a UI localized in English, and the same applies to the dates that should be formatted using the en_GB locale. Using the it_IT locale would show \"2 ott 2019, 17:53\" instead of the correct \"2 Oct 2019 at 17:53\".Locale.current, shows the locale set (overridden) in the iOS simulator and setting the language and regions in the scheme's options comes handy for debugging. Some might think that it's acceptable to use Locale.preferredLanguages.first and create a Locale from it with let preferredLanguageLocale = Locale(identifier: Locale.preferredLanguages.first!) and set it on the formatters. I think that doing so is not great since we would display dates using the Italian format but we won't necessarily be using the Italian language for the other UI elements as the app might not have the IT localization, causing an inconsistent experience. In short: don't use preferredLanguages, best to use Locale.current.Apple strongly suggests using en_US_POSIX pretty much everywhere (1, 2). From Apple docs:[...] if you're working with fixed-format dates, you should first set the locale of the date formatter to something appropriate for your fixed format. In most cases the best locale to choose is \"en_US_POSIX\", a locale that's specifically designed to yield US English results regardless of both user and system preferences. \"en_US_POSIX\" is also invariant in time (if the US, at some point in the future, changes the way it formats dates, \"en_US\" will change to reflect the new behaviour, but \"en_US_POSIX\" will not), and between machines (\"en_US_POSIX\" works the same on iOS as it does on OS X, and as it it does on other platforms).Once you've set \"en_US_POSIX\" as the locale of the date formatter, you can then set the date format string and the date formatter will behave consistently for all users.I couldn't find a really valid reason for doing so and quite frankly using the device locale seems more appropriate for converting dates to strings.Here is the string representation for the same date using different locales:en_US_POSIX: May 2, 2019 at 3:53 PMen_GB: 2 May 2019 at 15:53it_IT: 2 mag 2019, 15:53The above should be enough to show that en_US_POSIX is not what we want to use in this case, but it has more to do with maintaining a standard for communication across machines. From this article:\"[...] Unless you specifically need month and/or weekday names to appear in the user's language, you should always use the special locale of en_US_POSIX. This will ensure your fixed format is actually fully honored and no user settings override your format. This also ensures month and weekday names appear in English. Without using this special locale, you may get 24-hour format even if you specify 12-hour (or visa-versa). And dates sent to a server almost always need to be in English.\"TimezonesStating the obvious one more time:Greenwich Mean Time (GMT) is a time zone while Coordinated Universal Time (UTC) is a time standard. There is no time difference between them.Timezones are fundamental to show the correct date/time in the final text shown to the user. The timezone value is taken from macOS and the iOS simulator inherits it, meaning that printing TimeZone.current, shows the timezone set in the macOS preferences (e.g. Europe/Berlin).Show me some codeNote that in the following example, we use GMT (Greenwich Mean Time) and CET (Central European Time), which is GMT+1. Mind that it's best to reuse formatters since the creation is expensive.class CustomDateFormatter { private let dateFormatter: DateFormatter = { let dateFormatter = DateFormatter() dateFormatter.dateStyle = .medium dateFormatter.timeStyle = .short return dateFormatter }() private let locale: Locale private let timeZone: TimeZone init(locale: Locale = .current, timeZone: TimeZone = .current) { self.locale = locale self.timeZone = timeZone } func string(from date: Date) -\u003e String { dateFormatter.locale = locale dateFormatter.timeZone = timeZone return dateFormatter.string(from: date) } }let stringA = \"2019-11-02T16:53:42\" let stringB = \"2019-11-02T16:53:42Z\" let stringC = \"2019-11-02T16:53:42-02:00\" let stringD = \"2019-11-02T16:53:42.974Z\" // The ISO8601DateFormatter's extension (redacted) // internally uses multiple formatters, each one set up with different // options (.withInternetDateTime, .withFractionalSeconds, withFullDate, .withTime, .withColonSeparatorInTime) // to be able to parse all the formats. // timeZone property is set to GMT. let dateA = ISO8601DateFormatter.date(from: stringA)! let dateB = ISO8601DateFormatter.date(from: stringB)! let dateC = ISO8601DateFormatter.date(from: stringC)! let dateD = ISO8601DateFormatter.date(from: stringD)! var dateFormatter = CustomDateFormatter(locale: Locale(identifier: \"en_GB\"), timeZone: TimeZone(identifier: \"GMT\")!) dateFormatter.string(from: dateA) // 2 Nov 2019 at 16:53 dateFormatter.string(from: dateB) // 2 Nov 2019 at 16:53 dateFormatter.string(from: dateC) // 2 Nov 2019 at 18:53 dateFormatter.string(from: dateD) // 2 Nov 2019 at 16:53 dateFormatter = CustomDateFormatter(locale: Locale(identifier: \"it_IT\"), timeZone: TimeZone(identifier: \"CET\")!) dateFormatter.string(from: dateA) // 2 nov 2019, 17:53 dateFormatter.string(from: dateB) // 2 nov 2019, 17:53 dateFormatter.string(from: dateC) // 2 nov 2019, 19:53 dateFormatter.string(from: dateD) // 2 nov 2019, 17:53Using the CET timezone also for ISO8601DateFormatter, the final string produced for dateA would respectively be \"15:53\" when formatted with GMT and \"16:53\" when formatted with CET. As long as the string passed to ISO8601DateFormatter is in UTC, it's irrelevant to set the timezone on the formatter.Apple suggests to set the timeZone property to UTC with TimeZone(secondsFromGMT: 0), but this is irrelevant if the string representing the date already includes the timezone. If your server returns a string representing a date that is not in UTC, it's probably because of one of the following 2 reasons:it's not meant to be in UTC (questionable design decision indeed) and therefore the timezone of the device should be used instead;the backend developers implemented it wrong and they should add the 'Z 'at the end of the string if what they intended is to have the date in UTC.In short: All DateFormatters should have timezone and locale set to .current and avoid handling non-UTC string if possible.Formatting currencies ‚Ç¨ $ ¬• ¬£The currency symbol and the formatting of a number should be defined via a Locale, and they shouldn't be set/changed on the NumberFormatter. Don't use the user's locale (Locale.current) because it could be set to a region not supported by the app.Let's consider the example of a user's locale to be en_US, and the app to be available only for the Italian market. We must set a locale Locale(identifier: \"it_IT\") on the formatter, so that:prices will be shown only in Euro (not American Dollar)the format used will be the one of the country language (for Italy, \"12,34 ‚Ç¨\", not any other variation such as \"‚Ç¨12.34\")class CurrencyFormatter { private let locale: Locale init(locale: Locale = .current) { self.locale = locale } func string(from decimal: Decimal, overriddenCurrencySymbol: String? = nil) -\u003e String { let formatter = NumberFormatter() formatter.numberStyle = .currency if let currencySymbol = overriddenCurrencySymbol { // no point in doing this on a NumberFormatter ‚ùå formatter.currencySymbol = currencySymbol } formatter.locale = locale return formatter.string(from: decimal as NSNumber)! } }let itCurrencyFormatter = CurrencyFormatter(locale: Locale(identifier: \"it_IT\")) let usCurrencyFormatter = CurrencyFormatter(locale: Locale(identifier: \"en_US\")) let price1 = itCurrencyFormatter.string(from: 12.34) // \"12,34¬†‚Ç¨\" ‚úÖ let price2 = usCurrencyFormatter.string(from: 12.34) // \"$12.34\" ‚úÖ let price3 = itCurrencyFormatter.string(from: 12.34, overriddenCurrencySymbol: \"‚Çø\") // \"12,34¬†‚Çø\" ‚ùå let price4 = usCurrencyFormatter.string(from: 12.34, overriddenCurrencySymbol: \"‚Çø\") // \"‚Çø¬†12.34\" ‚ùåIn short:All NumberFormatters should have the locale set to the one of the country targeted and no currencySymbol property overridden (it's inherited from the locale).Languages üá¨üáß üáÆüáπ üá≥üá±Stating the obvious one more time, but there are very rare occasions that justify forcing the language in the app:func setLanguage(_ language: String) { let userDefaults = UserDefaults.standard userDefaults.set([language], forKey: \"AppleLanguages\") }The above circumvents the Apple localization mechanism and needs an app restart, so don't do it and localize the app by the book:add localizations in Project -\u003e Localizations;create a Localizable.strings file and tap the localize button in the inspector;always use NSLocalizedString() in code.Let's consider this content of Localizable.strings (English):\"kHello\" = \"Hello\"; \"kFormatting\" = \"Some formatting 1. %@ 2. %d.\"; and this for another language (e.g. Italian) Localizable.strings (Italian):\"kHello\" = \"Ciao\"; \"kFormatting\" = \"Esempio di formattazione 1) %@ 2) %d.\";Simple localizationHere's the trivial example:let localizedString = NSLocalizedString(\"kHello\", comment: \"\")If Locale.current.languageCode is it, the value would be 'Ciao', and 'Hello' otherwise.Formatted localizationFor formatted strings, use the following:let stringWithFormats = NSLocalizedString(\"kFormatting\", comment: \"\") String.localizedStringWithFormat(stringWithFormats, \"some value\", 3)As before, if Locale.current.languageCode is it, value would be 'Esempio di formattazione 1) some value 2) 3.', and 'Some formatting 1) some value 2) 3.' otherwise.Plurals localizationFor plurals, create a Localizable.stringsdict file and tap the localize button in the inspector. Localizable.strings and Localizable.stringsdict are independent, so there are no cross-references (something that often tricked me).Here is a sample content:\u003cdict\u003e \u003ckey\u003ekPlurality\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSStringLocalizedFormatKey\u003c/key\u003e \u003cstring\u003eInterpolated string: %@, interpolated number: %d, interpolated variable: %#@COUNT@.\u003c/string\u003e \u003ckey\u003eCOUNT\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSStringFormatSpecTypeKey\u003c/key\u003e \u003cstring\u003eNSStringPluralRuleType\u003c/string\u003e \u003ckey\u003eNSStringFormatValueTypeKey\u003c/key\u003e \u003cstring\u003ed\u003c/string\u003e \u003ckey\u003ezero\u003c/key\u003e \u003cstring\u003enothing\u003c/string\u003e \u003ckey\u003eone\u003c/key\u003e \u003cstring\u003e%d object\u003c/string\u003e \u003ckey\u003etwo\u003c/key\u003e \u003cstring\u003e\u003c/string\u003e \u003ckey\u003efew\u003c/key\u003e \u003cstring\u003e\u003c/string\u003e \u003ckey\u003emany\u003c/key\u003e \u003cstring\u003e\u003c/string\u003e \u003ckey\u003eother\u003c/key\u003e \u003cstring\u003e%d objects\u003c/string\u003e \u003c/dict\u003e \u003c/dict\u003e \u003c/dict\u003eLocalizable.stringsdict undergo the same localization mechanism of its companion Localizable.strings. It's mandatory to only implement 'other', but an honest minimum includes 'zero', 'one', and 'other'. Given the above content, the following code should be self-explanatory:let localizedHello = NSLocalizedString(\"kHello\", comment: \"\") // from Localizable.strings let stringWithPlurals = NSLocalizedString(\"kPlurality\", comment: \"\") // from Localizable.stringsdict String.localizedStringWithFormat(stringWithPlurals, localizedHello, 42, 1)With the en language, the value would be 'Interpolated string: Hello, interpolated number: 42, interpolated variable: 1 object.'.Use the scheme's option to run with a specific Application Language (it will change the current locale language and therefore also the output of the DateFormatters).If the language we've set or the device language are not supported by the app, the system falls back to en.Referenceshttps://en.wikipedia.org/wiki/ISO_8601https://nsdateformatter.com/https://foragoodstrftime.com/https://epochconverter.com/So... that's all folks. üåç",
  "image": "https://albertodebortoli.com/content/images/size/w1200/2019/12/hand-1030552_1920.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cp\u003eIn this article, I try to summarize the bare minimum one needs to know to add internationalization support to an iOS app. \u003c/p\u003e\u003cblockquote\u003e\u003cu\u003eLocalizations\u003c/u\u003e, \u003cu\u003elocales\u003c/u\u003e, \u003cu\u003etimezones\u003c/u\u003e, \u003cu\u003edate\u003c/u\u003e and \u003cu\u003ecurrency formatting\u003c/u\u003e... it\u0026#39;s shocking how easy is to forget how they work and how to use them correctly.\u003c/blockquote\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/12/3kj59j.jpg\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cp\u003eAfter years more than 10 years into iOS development, I decided to write down a few notes on the matter, with the hope that they will come handy again in the future, hopefully not only to me.\u003c/p\u003e\u003ch2 id=\"tl-dr\"\u003eTL;DR\u003c/h2\u003e\u003cp\u003eFrom Apple docs:\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://developer.apple.com/documentation/foundation/date?ref=albertodebortoli.com\"\u003eDate\u003c/a\u003e: a specific point in time, independent of any calendar or time zone;\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://developer.apple.com/documentation/foundation/timezone?ref=albertodebortoli.com\"\u003eTimeZone\u003c/a\u003e: information about standard time conventions associated with a specific geopolitical region;\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://developer.apple.com/documentation/foundation/locale?ref=albertodebortoli.com\"\u003eLocale\u003c/a\u003e: information about linguistic, cultural, and technological conventions for use in formatting data for presentation.\u003c/p\u003e\u003cp\u003eRule of thumb:\u003c/p\u003e\u003cul\u003e\u003cli\u003eAll DateFormatters should use the locale and the timezone of the device;\u003c/li\u003e\u003cli\u003eAll NumberFormatter, in particular those with \u003ccode\u003enumberStyle\u003c/code\u003e set to \u003ccode\u003e.currency\u003c/code\u003e (for the sake of this article) should use a specific locale so that prices are not shown in the wrong currency.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"general-notes-on-formatters\"\u003eGeneral notes on formatters\u003c/h2\u003e\u003cp\u003eLet\u0026#39;s start by stating the obvious.\u003c/p\u003e\u003cp\u003eSince iOS 10, Foundation (finally) provides \u003ccode\u003e\u003ca href=\"https://developer.apple.com/documentation/foundation/iso8601dateformatter?ref=albertodebortoli.com\"\u003eISO8601DateFormatter\u003c/a\u003e\u003c/code\u003e, which, alongside with \u003ccode\u003e\u003ca href=\"https://developer.apple.com/documentation/foundation/DateFormatter?ref=albertodebortoli.com\"\u003eDateFormatter\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca href=\"https://developer.apple.com/documentation/foundation/NumberFormatter?ref=albertodebortoli.com\"\u003eNumberFormatter\u003c/a\u003e\u003c/code\u003e, inherits from \u003ccode\u003e\u003ca href=\"https://developer.apple.com/documentation/foundation/Formatter?ref=albertodebortoli.com\"\u003eFormatter\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eFormatter\u003c/th\u003e\n\u003cth\u003elocale property\u003c/th\u003e\n\u003cth\u003etimeZone property\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eISO8601DateFormatter\u003c/td\u003e\n\u003ctd\u003e‚ùå\u003c/td\u003e\n\u003ctd\u003e‚úÖ\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDateFormatter\u003c/td\u003e\n\u003ctd\u003e‚úÖ\u003c/td\u003e\n\u003ctd\u003e‚úÖ\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eNumberFormatter\u003c/td\u003e\n\u003ctd\u003e‚úÖ\u003c/td\u003e\n\u003ctd\u003e‚ùå\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eIn an app that only consumes data from an API, the main purpose of \u003ccode\u003eISO8601DateFormatter\u003c/code\u003e is to convert strings to dates (\u003ccode\u003eString\u003c/code\u003e -\u0026gt; \u003ccode\u003eDate\u003c/code\u003e) more than the inverse. \u003ccode\u003eDateFormatter\u003c/code\u003e is then used to format dates (\u003ccode\u003eDate\u003c/code\u003e -\u0026gt; \u003ccode\u003eString\u003c/code\u003e) to ultimately show the values in the UI. \u003ccode\u003eNumberFormatter\u003c/code\u003e instead, converts numbers (prices in the vast majority of the cases) to strings (\u003ccode\u003eNSNumber\u003c/code\u003e/\u003ccode\u003eDecimal\u003c/code\u003e -\u0026gt; \u003ccode\u003eString\u003c/code\u003e).\u003c/p\u003e\u003ch2 id=\"formatting-dates-\"\u003eFormatting dates üïó üïù üïü\u003c/h2\u003e\u003cp\u003eIt seems the following 4 are amongst the most common ISO 8601 formats, including the optional UTC offset.\u003c/p\u003e\u003cul\u003e\u003cli\u003eA: \u003ccode\u003e2019-10-02T16:53:42\u003c/code\u003e\u003c/li\u003e\u003cli\u003eB: \u003ccode\u003e2019-10-02T16:53:42Z\u003c/code\u003e\u003c/li\u003e\u003cli\u003eC: \u003ccode\u003e2019-10-02T16:53:42-02:00\u003c/code\u003e\u003c/li\u003e\u003cli\u003eD: \u003ccode\u003e2019-10-02T16:53:42.974Z\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIn this article I\u0026#39;ll stick to these formats.\u003c/p\u003e\u003cblockquote\u003eThe \u0026#39;Z\u0026#39; at the end of an ISO8601 date indicates that it is in UTC, not a local time zone.\u003c/blockquote\u003e\u003ch3 id=\"locales\"\u003eLocales\u003c/h3\u003e\u003cp\u003eConverting strings to dates (\u003ccode\u003eString\u003c/code\u003e -\u0026gt; \u003ccode\u003eDate\u003c/code\u003e) is done using \u003ccode\u003eISO8601DateFormatter\u003c/code\u003e objects set up with various \u003ccode\u003eformatOptions\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eOnce we have a \u003ccode\u003eDate\u003c/code\u003e object, we can deal with the formatting for the presentation. Here, the locale is important and things can get a bit tricky. Locales have nothing to do with timezones, locales are for applying a format using a language/region.\u003c/p\u003e\u003cblockquote\u003eLocale identifiers are in the form of \u003ccode\u003e\u0026lt;language_identifier\u0026gt;_\u0026lt;region_identifier\u0026gt;\u003c/code\u003e (e.g. \u003ccode\u003een_GB\u003c/code\u003e).\u003c/blockquote\u003e\u003cp\u003eWe should use the user\u0026#39;s locale when formatting dates (\u003ccode\u003eDate\u003c/code\u003e -\u0026gt; \u003ccode\u003eString\u003c/code\u003e). Consider a British user moving to Italy, the apps should keep showing a UI localized in English, and the same applies to the dates that should be formatted using the \u003ccode\u003een_GB\u003c/code\u003e locale. Using the \u003ccode\u003eit_IT\u003c/code\u003e locale would show \u0026#34;2 ott 2019, 17:53\u0026#34; instead of the correct \u0026#34;2 Oct 2019 at 17:53\u0026#34;.\u003c/p\u003e\u003cp\u003e\u003ccode\u003eLocale.current\u003c/code\u003e, shows the locale set (overridden) in the iOS simulator and setting the language and regions in the scheme\u0026#39;s options comes handy for debugging. \u003c/p\u003e\u003cp\u003eSome might think that it\u0026#39;s acceptable to use \u003ccode\u003eLocale.preferredLanguages.first\u003c/code\u003e and create a Locale from it with \u003ccode\u003elet preferredLanguageLocale = Locale(identifier: Locale.preferredLanguages.first!)\u003c/code\u003e and set it on the formatters. I think that doing so is not great since we would display dates using the Italian format but we won\u0026#39;t necessarily be using the Italian language for the other UI elements as the app might not have the IT localization, causing an inconsistent experience. In short: don\u0026#39;t use \u003ccode\u003epreferredLanguages\u003c/code\u003e, best to use \u003ccode\u003eLocale.current\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eApple strongly suggests using \u003ccode\u003een_US_POSIX\u003c/code\u003e pretty much everywhere (\u003ca href=\"https://developer.apple.com/library/archive/qa/qa1480/_index.html?ref=albertodebortoli.com\"\u003e1\u003c/a\u003e, \u003ca href=\"https://developer.apple.com/documentation/foundation/dateformatter?ref=albertodebortoli.com\"\u003e2\u003c/a\u003e). From Apple docs:\u003c/p\u003e\u003cblockquote\u003e[...] if you\u0026#39;re working with fixed-format dates, you should first set the locale of the date formatter to something appropriate for your fixed format. In most cases the best locale to choose is \u0026#34;en_US_POSIX\u0026#34;, a locale that\u0026#39;s specifically designed to yield US English results regardless of both user and system preferences. \u0026#34;en_US_POSIX\u0026#34; is also invariant in time (if the US, at some point in the future, changes the way it formats dates, \u0026#34;en_US\u0026#34; will change to reflect the new behaviour, but \u0026#34;en_US_POSIX\u0026#34; will not), and between machines (\u0026#34;en_US_POSIX\u0026#34; works the same on iOS as it does on OS X, and as it it does on other platforms).\u003cp\u003eOnce you\u0026#39;ve set \u0026#34;en_US_POSIX\u0026#34; as the locale of the date formatter, you can then set the date format string and the date formatter will behave consistently for all users.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eI couldn\u0026#39;t find a really \u003cem\u003evalid\u003c/em\u003e reason for doing so and quite frankly using the device locale seems more appropriate for converting dates to strings.\u003c/p\u003e\u003cp\u003eHere is the string representation for the same date using different locales:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003een_US_POSIX\u003c/code\u003e: May 2, 2019 at 3:53 PM\u003c/li\u003e\u003cli\u003e\u003ccode\u003een_GB\u003c/code\u003e: 2 May 2019 at 15:53\u003c/li\u003e\u003cli\u003e\u003ccode\u003eit_IT\u003c/code\u003e: 2 mag 2019, 15:53\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe above should be enough to show that \u003ccode\u003een_US_POSIX\u003c/code\u003e is not what we want to use in this case, but it has more to do with maintaining a standard for communication across machines. From this \u003ca href=\"https://www.maddysoft.com/articles/dates.html?ref=albertodebortoli.com\"\u003earticle\u003c/a\u003e:\u003c/p\u003e\u003cblockquote\u003e\u003cem\u003e\u0026#34;[...] Unless you specifically need month and/or weekday names to appear in the user\u0026#39;s language, you should always use the special locale of \u003ccode\u003een_US_POSIX\u003c/code\u003e. This will ensure your fixed format is actually fully honored and no user settings override your format. This also ensures month and weekday names appear in English. Without using this special locale, you may get 24-hour format even if you specify 12-hour (or visa-versa). And dates sent to a server almost always need to be in English.\u0026#34;\u003c/em\u003e\u003c/blockquote\u003e\u003ch3 id=\"timezones\"\u003eTimezones\u003c/h3\u003e\u003cp\u003eStating the obvious one more time:\u003c/p\u003e\u003cblockquote\u003eGreenwich Mean Time (GMT) is a time zone while Coordinated Universal Time (UTC) is a time standard. There is no time difference between them.\u003c/blockquote\u003e\u003cp\u003eTimezones are fundamental to show the correct date/time in the final text shown to the user. The timezone value is taken from macOS and the iOS simulator inherits it, meaning that printing \u003ccode\u003eTimeZone.current\u003c/code\u003e, shows the timezone set in the macOS preferences (e.g. Europe/Berlin).\u003c/p\u003e\u003ch3 id=\"show-me-some-code\"\u003eShow me some code\u003c/h3\u003e\u003cp\u003eNote that in the following example, we use GMT (Greenwich Mean Time) and CET (Central European Time), which is GMT+1. Mind that it\u0026#39;s best to reuse formatters since the creation is \u003ca href=\"http://www.chibicode.org/?p=41\u0026amp;ref=albertodebortoli.com\"\u003eexpensive\u003c/a\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass CustomDateFormatter {\n    \n    private let dateFormatter: DateFormatter = {\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateStyle = .medium\n        dateFormatter.timeStyle = .short\n        return dateFormatter\n    }()\n    \n    private let locale: Locale\n    private let timeZone: TimeZone\n    \n    init(locale: Locale = .current, timeZone: TimeZone = .current) {\n        self.locale = locale\n        self.timeZone = timeZone\n    }\n    \n    func string(from date: Date) -\u0026gt; String {\n        dateFormatter.locale = locale\n        dateFormatter.timeZone = timeZone\n        return dateFormatter.string(from: date)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003elet stringA = \u0026#34;2019-11-02T16:53:42\u0026#34;\nlet stringB = \u0026#34;2019-11-02T16:53:42Z\u0026#34;\nlet stringC = \u0026#34;2019-11-02T16:53:42-02:00\u0026#34;\nlet stringD = \u0026#34;2019-11-02T16:53:42.974Z\u0026#34;\n\n// The ISO8601DateFormatter\u0026#39;s extension (redacted)\n// internally uses multiple formatters, each one set up with different\n// options (.withInternetDateTime, .withFractionalSeconds, withFullDate, .withTime, .withColonSeparatorInTime)\n// to be able to parse all the formats.\n// timeZone property is set to GMT.\n\nlet dateA = ISO8601DateFormatter.date(from: stringA)!\nlet dateB = ISO8601DateFormatter.date(from: stringB)!\nlet dateC = ISO8601DateFormatter.date(from: stringC)!\nlet dateD = ISO8601DateFormatter.date(from: stringD)!\n\nvar dateFormatter = CustomDateFormatter(locale: Locale(identifier: \u0026#34;en_GB\u0026#34;), timeZone: TimeZone(identifier: \u0026#34;GMT\u0026#34;)!)\ndateFormatter.string(from: dateA) // 2 Nov 2019 at 16:53\ndateFormatter.string(from: dateB) // 2 Nov 2019 at 16:53\ndateFormatter.string(from: dateC) // 2 Nov 2019 at 18:53\ndateFormatter.string(from: dateD) // 2 Nov 2019 at 16:53\n\ndateFormatter = CustomDateFormatter(locale: Locale(identifier: \u0026#34;it_IT\u0026#34;), timeZone: TimeZone(identifier: \u0026#34;CET\u0026#34;)!)\ndateFormatter.string(from: dateA) // 2 nov 2019, 17:53\ndateFormatter.string(from: dateB) // 2 nov 2019, 17:53\ndateFormatter.string(from: dateC) // 2 nov 2019, 19:53\ndateFormatter.string(from: dateD) // 2 nov 2019, 17:53\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUsing the CET timezone also for \u003ccode\u003eISO8601DateFormatter\u003c/code\u003e, the final string produced for \u003ccode\u003edateA\u003c/code\u003e would respectively be \u0026#34;15:53\u0026#34; when formatted with GMT and \u0026#34;16:53\u0026#34; when formatted with CET. As long as the string passed to \u003ccode\u003eISO8601DateFormatter\u003c/code\u003e is in UTC, it\u0026#39;s irrelevant to set the timezone on the formatter.\u003c/p\u003e\u003cp\u003eApple \u003ca href=\"https://developer.apple.com/documentation/foundation/dateformatter?ref=albertodebortoli.com\"\u003esuggests\u003c/a\u003e to set the timeZone property to UTC with \u003ccode\u003eTimeZone(secondsFromGMT: 0)\u003c/code\u003e, but this is irrelevant if the string representing the date already includes the timezone. If your server returns a string representing a date that is not in UTC, it\u0026#39;s probably because of one of the following 2 reasons:\u003c/p\u003e\u003col\u003e\u003cli\u003eit\u0026#39;s not meant to be in UTC (questionable design decision indeed) and therefore the timezone of the device should be used instead;\u003c/li\u003e\u003cli\u003ethe backend developers implemented it wrong and they should add the \u0026#39;Z \u0026#39;at the end of the string if what they intended is to have the date in UTC.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eIn short: \u003c/p\u003e\u003cblockquote\u003eAll DateFormatters should have timezone and locale set to \u003ccode\u003e.current\u003c/code\u003e and avoid handling non-UTC string if possible.\u003c/blockquote\u003e\u003ch2 id=\"formatting-currencies-\"\u003eFormatting currencies ‚Ç¨ $ ¬• ¬£\u003c/h2\u003e\u003cp\u003eThe currency symbol and the formatting of a number should be defined via a \u003ccode\u003eLocale\u003c/code\u003e, and they shouldn\u0026#39;t be set/changed on the NumberFormatter. Don\u0026#39;t use the user\u0026#39;s locale (\u003ccode\u003eLocale.current\u003c/code\u003e) because it could be set to a region not supported by the app.\u003c/p\u003e\u003cp\u003eLet\u0026#39;s consider the example of a user\u0026#39;s locale to be \u003ccode\u003een_US\u003c/code\u003e, and the app to be available only for the Italian market. We must set a locale \u003ccode\u003eLocale(identifier: \u0026#34;it_IT\u0026#34;)\u003c/code\u003e on the formatter, so that:\u003c/p\u003e\u003cul\u003e\u003cli\u003eprices will be shown only in Euro (not American Dollar)\u003c/li\u003e\u003cli\u003ethe format used will be the one of the country language (for Italy, \u0026#34;12,34 ‚Ç¨\u0026#34;, not any other variation such as \u0026#34;‚Ç¨12.34\u0026#34;)\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003eclass CurrencyFormatter {\n    \n    private let locale: Locale\n    \n    init(locale: Locale = .current) {\n        self.locale = locale\n    }\n\n    func string(from decimal: Decimal,\n                overriddenCurrencySymbol: String? = nil) -\u0026gt; String {\n        let formatter = NumberFormatter()\n        formatter.numberStyle = .currency\n        if let currencySymbol = overriddenCurrencySymbol {\n            // no point in doing this on a NumberFormatter ‚ùå\n            formatter.currencySymbol = currencySymbol\n        }\n        formatter.locale = locale\n        return formatter.string(from: decimal as NSNumber)!\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003elet itCurrencyFormatter = CurrencyFormatter(locale: Locale(identifier: \u0026#34;it_IT\u0026#34;))\nlet usCurrencyFormatter = CurrencyFormatter(locale: Locale(identifier: \u0026#34;en_US\u0026#34;))\nlet price1 = itCurrencyFormatter.string(from: 12.34) // \u0026#34;12,34¬†‚Ç¨\u0026#34; ‚úÖ\nlet price2 = usCurrencyFormatter.string(from: 12.34) // \u0026#34;$12.34\u0026#34; ‚úÖ\n\nlet price3 = itCurrencyFormatter.string(from: 12.34, overriddenCurrencySymbol: \u0026#34;‚Çø\u0026#34;) // \u0026#34;12,34¬†‚Çø\u0026#34; ‚ùå\nlet price4 = usCurrencyFormatter.string(from: 12.34, overriddenCurrencySymbol: \u0026#34;‚Çø\u0026#34;) // \u0026#34;‚Çø¬†12.34\u0026#34; ‚ùå\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn short:\u003c/p\u003e\u003cblockquote\u003eAll NumberFormatters should have the locale set to the one of the country targeted and no \u003ccode\u003ecurrencySymbol\u003c/code\u003e property overridden (it\u0026#39;s inherited from the locale).\u003c/blockquote\u003e\u003ch2 id=\"languages-\"\u003eLanguages üá¨üáß üáÆüáπ üá≥üá±\u003c/h2\u003e\u003cp\u003eStating the obvious one more time, but there are very rare occasions that justify forcing the language in the app:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc setLanguage(_ language: String) {\n    let userDefaults = UserDefaults.standard\n    userDefaults.set([language], forKey: \u0026#34;AppleLanguages\u0026#34;)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above circumvents the Apple localization mechanism and needs an app restart, so don\u0026#39;t do it and localize the app by the book:\u003c/p\u003e\u003cul\u003e\u003cli\u003eadd localizations in Project -\u0026gt; Localizations;\u003c/li\u003e\u003cli\u003ecreate a \u003ccode\u003eLocalizable.strings\u003c/code\u003e file and tap the localize button in the inspector;\u003c/li\u003e\u003cli\u003ealways use \u003ccode\u003eNSLocalizedString()\u003c/code\u003e in code.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eLet\u0026#39;s consider this content of \u003ccode\u003eLocalizable.strings (English)\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026#34;kHello\u0026#34; = \u0026#34;Hello\u0026#34;;\n\u0026#34;kFormatting\u0026#34; = \u0026#34;Some formatting 1. %@ 2. %d.\u0026#34;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eand this for another language (e.g. Italian) \u003ccode\u003eLocalizable.strings (Italian)\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026#34;kHello\u0026#34; = \u0026#34;Ciao\u0026#34;;\n\u0026#34;kFormatting\u0026#34; = \u0026#34;Esempio di formattazione 1) %@ 2) %d.\u0026#34;;\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"simple-localization\"\u003eSimple localization\u003c/h3\u003e\u003cp\u003eHere\u0026#39;s the trivial example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003elet localizedString = NSLocalizedString(\u0026#34;kHello\u0026#34;, comment: \u0026#34;\u0026#34;)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf \u003ccode\u003eLocale.current.languageCode\u003c/code\u003e is \u003ccode\u003eit\u003c/code\u003e, the value would be \u0026#39;\u003cem\u003eCiao\u003c/em\u003e\u0026#39;, and \u0026#39;\u003cem\u003eHello\u003c/em\u003e\u0026#39; otherwise.\u003c/p\u003e\u003ch3 id=\"formatted-localization\"\u003eFormatted localization\u003c/h3\u003e\u003cp\u003eFor formatted strings, use the following:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003elet stringWithFormats = NSLocalizedString(\u0026#34;kFormatting\u0026#34;, comment: \u0026#34;\u0026#34;)\nString.localizedStringWithFormat(stringWithFormats, \u0026#34;some value\u0026#34;, 3)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs before, if \u003ccode\u003eLocale.current.languageCode\u003c/code\u003e is \u003ccode\u003eit\u003c/code\u003e, value would be \u0026#39;\u003cem\u003eEsempio di formattazione 1) some value 2) 3.\u003c/em\u003e\u0026#39;, and \u0026#39;\u003cem\u003eSome formatting 1) some value 2) 3.\u003c/em\u003e\u0026#39; otherwise.\u003c/p\u003e\u003ch3 id=\"plurals-localization\"\u003ePlurals localization\u003c/h3\u003e\u003cp\u003eFor plurals, create a \u003ccode\u003eLocalizable.stringsdict\u003c/code\u003e file and tap the localize button in the inspector. \u003ccode\u003eLocalizable.strings\u003c/code\u003e and \u003ccode\u003eLocalizable.stringsdict\u003c/code\u003e are independent, so there are no cross-references (something that often tricked me).\u003c/p\u003e\u003cp\u003eHere is a sample content:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;dict\u0026gt;\n    \u0026lt;key\u0026gt;kPlurality\u0026lt;/key\u0026gt;\n    \u0026lt;dict\u0026gt;\n        \u0026lt;key\u0026gt;NSStringLocalizedFormatKey\u0026lt;/key\u0026gt;\n        \u0026lt;string\u0026gt;Interpolated string: %@, interpolated number: %d, interpolated variable: %#@COUNT@.\u0026lt;/string\u0026gt;\n        \u0026lt;key\u0026gt;COUNT\u0026lt;/key\u0026gt;\n        \u0026lt;dict\u0026gt;\n            \u0026lt;key\u0026gt;NSStringFormatSpecTypeKey\u0026lt;/key\u0026gt;\n            \u0026lt;string\u0026gt;NSStringPluralRuleType\u0026lt;/string\u0026gt;\n            \u0026lt;key\u0026gt;NSStringFormatValueTypeKey\u0026lt;/key\u0026gt;\n            \u0026lt;string\u0026gt;d\u0026lt;/string\u0026gt;\n            \u0026lt;key\u0026gt;zero\u0026lt;/key\u0026gt;\n            \u0026lt;string\u0026gt;nothing\u0026lt;/string\u0026gt;\n            \u0026lt;key\u0026gt;one\u0026lt;/key\u0026gt;\n            \u0026lt;string\u0026gt;%d object\u0026lt;/string\u0026gt;\n            \u0026lt;key\u0026gt;two\u0026lt;/key\u0026gt;\n            \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt;\n            \u0026lt;key\u0026gt;few\u0026lt;/key\u0026gt;\n            \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt;\n            \u0026lt;key\u0026gt;many\u0026lt;/key\u0026gt;\n            \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt;\n            \u0026lt;key\u0026gt;other\u0026lt;/key\u0026gt;\n            \u0026lt;string\u0026gt;%d objects\u0026lt;/string\u0026gt;\n        \u0026lt;/dict\u0026gt;\n    \u0026lt;/dict\u0026gt;\n\u0026lt;/dict\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eLocalizable.stringsdict\u003c/code\u003e undergo the same localization mechanism of its companion \u003ccode\u003eLocalizable.strings\u003c/code\u003e. It\u0026#39;s mandatory to only implement \u0026#39;other\u0026#39;, but an honest minimum includes \u0026#39;zero\u0026#39;, \u0026#39;one\u0026#39;, and \u0026#39;other\u0026#39;. Given the above content, the following code should be self-explanatory:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003elet localizedHello = NSLocalizedString(\u0026#34;kHello\u0026#34;, comment: \u0026#34;\u0026#34;) // from Localizable.strings\nlet stringWithPlurals = NSLocalizedString(\u0026#34;kPlurality\u0026#34;, comment: \u0026#34;\u0026#34;) // from Localizable.stringsdict\nString.localizedStringWithFormat(stringWithPlurals, localizedHello, 42, 1)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith the \u003ccode\u003een\u003c/code\u003e language, the value would be \u0026#39;\u003cem\u003eInterpolated string: Hello, interpolated number: 42, interpolated variable: 1 object.\u003c/em\u003e\u0026#39;.\u003c/p\u003e\u003chr/\u003e\u003cp\u003eUse the scheme\u0026#39;s option to run with a specific Application Language (it will change the current locale language and therefore also the output of the DateFormatters).\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2019/12/Screenshot-2019-12-26-at-22.22.31.png\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cp\u003eIf the language we\u0026#39;ve set or the device language are not supported by the app, the system falls back to \u003ccode\u003een\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/ISO_8601?ref=albertodebortoli.com\"\u003ehttps://en.wikipedia.org/wiki/ISO_8601\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://nsdateformatter.com/?ref=albertodebortoli.com\"\u003ehttps://nsdateformatter.com/\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://foragoodstrftime.com/?ref=albertodebortoli.com\"\u003ehttps://foragoodstrftime.com/\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://epochconverter.com/?ref=albertodebortoli.com\"\u003ehttps://epochconverter.com/\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSo... that\u0026#39;s all folks. üåç\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2020-01-06T13:59:01Z",
  "modifiedTime": "2020-01-11T18:20:24Z"
}
