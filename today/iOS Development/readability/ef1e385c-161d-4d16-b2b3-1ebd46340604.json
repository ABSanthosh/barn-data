{
  "id": "ef1e385c-161d-4d16-b2b3-1ebd46340604",
  "title": "Synchronous functions can support cancellation too",
  "link": "https://oleb.net/2022/sync-functions-cancellation/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2022-02-01T22:59:43Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann …",
  "length": 4288,
  "excerpt": "Synchronous functions can perform the same cancellation checks as async code. Adding cancellation support can improve response times when async code calls long-running non-async code.",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "Cancellation is a Swift concurrency feature, but this doesn’t mean it’s only available in async functions. Synchronous functions can also support cancellation, and by doing so they’ll become better concurrency citizens when called from async code. Motivating example: JSONDecoder Supporting cancellation makes sense for functions that can block for significant amounts of time (say, more than a few milliseconds). Take JSON decoding as an example. Suppose we wrote an async function that performs a network request and decodes the downloaded JSON data: import Foundation func loadJSON\u003cT: Decodable\u003e(_ type: T.Type, from url: URL) async throws -\u003e T { let (data, _) = try await URLSession.shared.data(from: url) return try JSONDecoder().decode(type, from: data) } The JSONDecoder.decode call is synchronous: it will block its thread until it completes. And if the download is large, decoding may take hundreds of milliseconds or even longer. Avoid blocking if possible In general, async code should avoid calling blocking APIs if possible. Instead, async functions are expected to suspend regularly to give waiting tasks a chance to run. But JSONDecoder doesn’t have an async API (yet?), and I’m not even sure it can provide one that works with the existing Codable protocols, so let’s work with what we have. And if you think about it, it’s not totally unreasonable for JSONDecoder to block. After all, it is performing CPU-intensive work (assuming the data it’s working on doesn’t have to be paged in), and this work has to happen on some thread. Async/await works best for I/O-bound functions that spend most of their time waiting for the disk or the network. If an I/O-bound function suspends, the runtime can give the function’s thread to another task that can make more productive use of the CPU. Responding to cancellation Cancellation is a cooperative process. Canceling a task only sets a flag in the task’s metadata. It’s up to individual functions to periodically check for cancellation and abort if necessary. If a function doesn’t respond promptly to cancellation or outright ignores the cancellation flag, the program may appear to the user to be stalling. Now, if the task is canceled while JSONDecoder.decode is running, our loadJSON function can’t react properly because it can’t interrupt the decoding process. To fix this, the decode method would have to perform its own periodic cancellation checks, using the usual APIs, Task.isCancelled or Task.checkCancellation(). These can be called from anywhere, including synchronous code. Internals How does this work? How can synchronous code access task-specific metadata? Here’s the code for Task.isCancelled in the standard library: extension Task where Success == Never, Failure == Never { public static var isCancelled: Bool { withUnsafeCurrentTask { task in task?.isCancelled ?? false } } } This calls withUnsafeCurrentTask to get a handle to the current task. When the runtime schedules a task to run on a particular thread, it stores a pointer to the task object in that thread’s thread-local storage, where any code running on that thread – sync or async – can access it. If task == nil, there is no current task, i.e. we haven’t been called (directly or indirectly) from an async function. In this case, cancellation doesn’t apply, so we can return false. If we do have a task handle, we ask the task for its isCancelled flag and return that. Reading the flag is an atomic (thread-safe) operation because other threads may be writing to it concurrently. Conclusion I hope we’ll see cancellation support in the Foundation encoders and decoders in the future. If you have written synchronous functions that can potentially block their thread for a significant amount of time, consider adding periodic cancellation checks. It’s a quick way to make your code work better with the concurrency system, and you don’t even have to change your API to do it. Update February 2, 2022: Jordan Rose argues that cancellation support for synchronous functions should be opt-in because it introduces a failure mode that’s hard to reason about locally as the “source“ of the failure (the async context) may be several levels removed from the call site. Definitely something to consider!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003carticle\u003e\n        \u003cheader\u003e\n          \n        \u003c/header\u003e\n\n        \n\n        \u003cdiv\u003e\n          \u003cp\u003eCancellation is a Swift concurrency feature, but this doesn’t mean it’s only available in async functions. Synchronous functions can also support cancellation, and by doing so they’ll become better concurrency citizens when called from async code.\u003c/p\u003e\n\n\u003ch2 id=\"motivating-example-jsondecoder\"\u003eMotivating example: JSONDecoder\u003c/h2\u003e\n\n\u003cp\u003eSupporting cancellation makes sense for functions that can block for significant amounts of time (say, more than a few milliseconds). Take JSON decoding as an example. Suppose we wrote an async function that performs a network request and decodes the downloaded JSON data:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eFoundation\u003c/span\u003e\n\n\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eloadJSON\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDecodable\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003etype\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eType\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003efrom\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eURL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e_\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003eawait\u003c/span\u003e \u003cspan\u003eURLSession\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eshared\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eurl\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003eJSONDecoder\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edecode\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etype\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ca href=\"https://developer.apple.com/documentation/foundation/jsondecoder/2895189-decode\"\u003e\u003ccode\u003eJSONDecoder.decode\u003c/code\u003e\u003c/a\u003e call is synchronous: it will block its thread until it completes. And if the download is large, decoding may take hundreds of milliseconds or even longer.\u003c/p\u003e\n\n\u003ch2 id=\"avoid-blocking-if-possible\"\u003eAvoid blocking if possible\u003c/h2\u003e\n\n\u003cp\u003eIn general, async code should avoid calling blocking APIs if possible. Instead, async functions are expected to suspend regularly to give waiting tasks a chance to run. But \u003ccode\u003eJSONDecoder\u003c/code\u003e doesn’t have an async API (yet?), and I’m not even sure it can provide one that works with the existing Codable protocols, so let’s work with what we have. And if you think about it, it’s not totally unreasonable for \u003ccode\u003eJSONDecoder\u003c/code\u003e to block. After all, it is performing CPU-intensive work (assuming the data it’s working on doesn’t have to be paged in), and this work has to happen on \u003cem\u003esome\u003c/em\u003e thread.\u003c/p\u003e\n\n\u003cp\u003eAsync/await works best for I/O-bound functions that spend most of their time waiting for the disk or the network. If an I/O-bound function suspends, the runtime can give the function’s thread to another task that can make more productive use of the CPU.\u003c/p\u003e\n\n\u003ch2 id=\"responding-to-cancellation\"\u003eResponding to cancellation\u003c/h2\u003e\n\n\u003cp\u003eCancellation is a cooperative process. Canceling a task only sets a flag in the task’s metadata. It’s up to individual functions to periodically check for cancellation and abort if necessary. If a function doesn’t respond promptly to cancellation or outright ignores the cancellation flag, the program may appear to the user to be stalling.\u003c/p\u003e\n\n\u003cp\u003eNow, if the task is canceled while \u003ccode\u003eJSONDecoder.decode\u003c/code\u003e is running, our \u003ccode\u003eloadJSON\u003c/code\u003e function \u003cem\u003ecan’t\u003c/em\u003e react properly because it can’t interrupt the decoding process. To fix this, the \u003ccode\u003edecode\u003c/code\u003e method would have to perform its own periodic cancellation checks, using the usual APIs, \u003ca href=\"https://developer.apple.com/documentation/swift/task/3814832-iscancelled\"\u003e\u003ccode\u003eTask.isCancelled\u003c/code\u003e\u003c/a\u003e or \u003ca href=\"https://developer.apple.com/documentation/swift/task/3814826-checkcancellation\"\u003e\u003ccode\u003eTask.checkCancellation()\u003c/code\u003e\u003c/a\u003e. These can be called from anywhere, including synchronous code.\u003c/p\u003e\n\n\u003ch2 id=\"internals\"\u003eInternals\u003c/h2\u003e\n\n\u003cp\u003eHow does this work? How can synchronous code access task-specific metadata? Here’s \u003ca href=\"https://github.com/apple/swift/blob/a33eaf6f0d249c1a8ee5671718476c449e6037dc/stdlib/public/Concurrency/TaskCancellation.swift#L64-L68\"\u003ethe code for \u003ccode\u003eTask.isCancelled\u003c/code\u003e\u003c/a\u003e in the standard library:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eTask\u003c/span\u003e \u003cspan\u003ewhere\u003c/span\u003e \u003cspan\u003eSuccess\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eNever\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eFailure\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eNever\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eisCancelled\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBool\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003ewithUnsafeCurrentTask\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003etask\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n        \u003cspan\u003etask\u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisCancelled\u003c/span\u003e \u003cspan\u003e??\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\n      \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis calls \u003ca href=\"https://developer.apple.com/documentation/swift/3815003-withunsafecurrenttask\"\u003e\u003ccode\u003ewithUnsafeCurrentTask\u003c/code\u003e\u003c/a\u003e to get a handle to the current task. When the runtime schedules a task to run on a particular thread, it stores a pointer to the task object in that thread’s \u003ca href=\"https://en.wikipedia.org/wiki/Thread-local_storage\"\u003ethread-local storage\u003c/a\u003e, where any code running on that thread – sync or async – can access it.\u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode\u003etask == nil\u003c/code\u003e, there is no current task, i.e. we haven’t been called (directly or indirectly) from an async function. In this case, cancellation doesn’t apply, so we can return \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf we do have a task handle, we ask the task for its \u003ccode\u003eisCancelled\u003c/code\u003e flag and return that. Reading the flag is an atomic (thread-safe) operation because other threads may be writing to it concurrently.\u003c/p\u003e\n\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eI hope we’ll see cancellation support in the Foundation encoders and decoders in the future. If you have written synchronous functions that can potentially block their thread for a significant amount of time, consider adding periodic cancellation checks. It’s a quick way to make your code work better with the concurrency system, and you don’t even have to change your API to do it.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eUpdate February 2, 2022:\u003c/strong\u003e \u003ca href=\"https://twitter.com/UINT_MIN/status/1488659180802088962\"\u003eJordan Rose argues\u003c/a\u003e that cancellation support for synchronous functions should be opt-in because it introduces a failure mode that’s hard to reason about locally as the “source“ of the failure (the async context) may be several levels removed from the call site. Definitely something to consider!\u003c/p\u003e\n\n        \u003c/div\u003e\n      \u003c/article\u003e\n      \n      \n      \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2022-02-01T22:59:43Z",
  "modifiedTime": "2022-02-02T13:04:01Z"
}
