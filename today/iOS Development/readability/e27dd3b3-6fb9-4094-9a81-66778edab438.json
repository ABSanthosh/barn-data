{
  "id": "e27dd3b3-6fb9-4094-9a81-66778edab438",
  "title": "Core Data Using Only Code",
  "link": "https://atomicbird.com/blog/core-data-code-only/",
  "description": "If you know anything about Core Data, you’re probably aware of Xcode’s built-in model editor. If you’ve used Core Data, you’ve probably spent more time with it than you care to remember. It edits the data model, which then gets compiled to a binary form Core Data can use when your app runs. Conveniently it can also generate some code for you, subclasses of NSManagedObject for each entity in the model.",
  "author": "",
  "published": "Mon, 08 Nov 2021 00:00:00 +0000",
  "source": "https://atomicbird.com/index.xml",
  "categories": null,
  "byline": "",
  "length": 10642,
  "excerpt": "If you know anything about Core Data, you’re probably aware of Xcode’s built-in model editor. If you’ve used Core Data, you’ve probably spent more time with it than you care to remember. It edits the data model, which then gets compiled to a binary form Core Data can use when your app runs. Conveniently it can also generate some code for you, subclasses of NSManagedObject for each entity in the model.",
  "siteName": "Title",
  "favicon": "https://atomicbird.com/apple-touch-icon-144-precomposed.png",
  "text": "If you know anything about Core Data, you’re probably aware of Xcode’s built-in model editor. If you’ve used Core Data, you’ve probably spent more time with it than you care to remember. It edits the data model, which then gets compiled to a binary form Core Data can use when your app runs. Conveniently it can also generate some code for you, subclasses of NSManagedObject for each entity in the model. But what about the model itself? Where’s the code for that? There isn’t any. The model editor uses a similar approach as editing UI in storyboards. Xcode creates the objects in memory and uses NSCoding to write everything to a binary property list. When the app runs, the framework loads that property list, and like magic, all the same objects exist in your app. With user interface there’s long been a back and forth between people who prefer working graphically and those who want to do it all in code– often because there seems to be too much magic going on behind the scenes. What about Core Data? Can you skip the model editor and write the code yourself? You can! The model editor, like the storyboard editor, is a convenience but not a requirement. You can do it all in code. If you really want. If you look at the documentation for NSManagedObjectModel, you’ll see that the collection of entities in the model is declared as var entities: [NSEntityDescription] { get set } Likewise the docs for NSEntityDescription show that an entity’s properties are declared as var properties: [NSPropertyDescription] { get set } So what? So they both have set in the declaration. They can be changed. This is not an accident. You can create and configure your entity descriptions in code, and then instantiate an NSManagedObjectModel that uses them. From there, it’s Core Data as usual. A Simple Model Let’s give this a try. I’ll use a simple model with two entities, each with one attribute, and with a single relationship between them. If we were using the model editor it might look like this: Or if you prefer the graphical style, like this: First I’ll write the code for the custom classes I’ll be using. Two entities, one attribute each, with a relationship. @objc(Event) class Event: NSManagedObject { @NSManaged var timestamp: Date? @NSManaged var location: Location? } @objc(Location) class Location: NSManagedObject { @NSManaged var name: String? @NSManaged var events: NSSet? } Here I’m declaring attributes and relationships the same way that Xcode does when generating subclasses. That’s not absolutely necessary. But if you do things differently, be sure you understand the consequences, because Xcode doesn’t do it this way by accident. For example, I could declare the events relationship as Set\u003cEvent\u003e to be more Swifty, but that would affect how Core Data handles data faulting. Creating the Entity Descriptions This isn’t the model though, at least as far as Core Data is concerned. These subclasses are handy, but we have some work to do. First, here’s the Event entity and its timestamp attribute: let eventEntity = NSEntityDescription() eventEntity.name = \"Event\" eventEntity.managedObjectClassName = \"Event\" let timestampAttribute = NSAttributeDescription() timestampAttribute.name = \"timestamp\" timestampAttribute.type = .date eventEntity.properties.append(timestampAttribute) That’s right, you can create entitie descriptions and attribute descriptions in code. Then you can configure them with code that matches every checkbox and pop-up menu in the model editor. The managedObjectClassName property for NSEntityDescription controls the mapping from Core Data entity to NSManagedObject subclass. This is how Core Data will know that when I use the Event entity, it should use that class I created earlier. All this stuff and more can be done in code: The Location entity and its attribute is similar: let locationEntity = NSEntityDescription() locationEntity.name = \"Location\" locationEntity.managedObjectClassName = \"Location\" let nameAttribute = NSAttributeDescription() nameAttribute.name = \"name\" nameAttribute.type = .string locationEntity.properties.append(nameAttribute) Now for the relationships. Just like the model editor, you need to create the relationship on both sides and make them inverses. The Event-to-Location relationship is to-one, and looks like this: let eventToLocation = NSRelationshipDescription() eventToLocation.name = \"location\" eventToLocation.destinationEntity = locationEntity eventToLocation.maxCount = 1 eventEntity.properties.append(eventToLocation) As with the attribute description above, every setting from the model editor is available. The maxCount property is a little under-documented and works a little differently from the model editor. In Xcode there’s a pop-up menu to choose to-one or to-many. If you choose to-many, there are also text fields where you can set min and max counts for the relationship. In code it’s a little different. There’s a property on NSRelationshipDescription called isToMany that looks like the right thing, but it’s a read-only property. How do you configure the relationship, then? In code the rule is If maxCount is 0, it’s a to-many relationship with no upper bound. If maxCount is 1, it’s a to-one relationship. If maxCount \u003e 1, it’s to-many with whatever upper bound you choose. It’s like this because Core Data was written long before Swift, and has no way for maxCount to be an optional value. Strangely maxCount is unsigned, so negative values are permitted. Using negative numbers has the same effect as setting maxCount to 0. The Location-to-Event relationship is similar. Once it exists, I can make these two relationships inverses of each other: let locationToEvent = NSRelationshipDescription() locationToEvent.name = \"events\" locationToEvent.destinationEntity = eventEntity locationToEvent.maxCount = 0 // 0 is the default but this makes it clear locationEntity.properties.append(locationToEvent) eventToLocation.inverseRelationship = locationToEvent locationToEvent.inverseRelationship = eventToLocation As with the model editor, inverses need to be configured at both ends of the relationship. On to the Data Model Whew! OK that was all interesting, but now we need a data model to tie it all together. let model = NSManagedObjectModel() model.entities = [eventEntity, locationEntity] Oh wait, that was easy. Instantiate the model and give it some entities. Now we have a working data model! Let’s use it. Stop Me if You’ve Seen This Before From this point on it’s nearly the same as when you’re using the model editor. The only significant difference is creating a persistent container that uses the model I just created instead of looking for one in a file. let container = NSPersistentContainer(name: \"My Model\", managedObjectModel: model) From there, set whatever container options you need and call container.loadPersistentStores. And then it’s Core Data business as usual. About those Writeable Properties Don’t get too power-mad with code like this. There’s one major detail to be aware of. If you look at the docs for these writeable properties I’ve been using to build the model, you’ll see this message: Setting this property raises an exception if the receiver’s model has been used by an object graph manager. That means you can define the model in code, but you’re asking for trouble if you try changing it after you’ve used it for a Core Data stack. In the code above, they’re writeable right up to the point where I created the persistent container. After that, changing the model in any way will crash the app immediately. Model Migration What if you need to change your data model? I have good news! Probably. For most cases. If your model changes are compatible with automatic lightweight migration, just change the model and it’ll work. Let’s say I decide to add a new title attribute to Event. First I’ll change the class to this: @objc(Event) class Event: NSManagedObject { @NSManaged var timestamp: Date? @NSManaged var title: String? @NSManaged var location: Location? } And I’ll add a few lines to create the attribute: let titleAttribute = NSAttributeDescription() titleAttribute.name = \"title\" titleAttribute.type = .string eventEntity.properties.append(titleAttribute) Now what happens if I try to use the model with an existing data store? If shouldMigrateStoreAutomatically and shouldInferMappingModelAutomatically are both true, the migration is automatic and the new model works with the existing data. Both of those attributes are true by default, so unless you changed them, they’re already true. Automatic lightweight migration covers a bunch of common cases. Check out Apple’s documentation for a full list. If you can’t use automatic lightweight migration, well, you are in for a bit of work. If you didn’t use the data model editor, you can’t have Xcode set up a migration manager for you. But if you’re writing your model in code, you probably don’t want to, because that’s even deeper magic than the model editor. As with the model, you can do it all in code, but as with code, it means working in some rarely used corners of the Core Data framework. The details are more than I’m going to get into here, but whatever you do, keep the code for the old model because you’ll need both old and new data models to do the migration. Then, investigate NSMappingModel and NSMigrationManager to work out the details. Why (Not) Do This? I’ve never done this in a real app. But then, I’m also the kind of developer who uses interface builder for UI design whenever possible. There’s more than one way to do it, though. If you prefer to keep your UI in code, maybe you’d prefer to do Core Data that way as well, for more or less the same reason. I can see that version diffs would probably be easier to read when changing the model. It’s not for me, but that’s my preference. Maybe you’d like this way better. The biggest hurdle is probably if you ever need a model migration that can’t be done automatically. The model editor has a built-in convenience for keeping older models around and indicating which is current. You’d have to tackle that yourself by keeping code for old models around, on top of needing to write the migration as mentioned above. Additional Note Added Nov 10 After posting the above, Michael Tsai responed via Twitter: So there’s one more potential caveat: If you hear about a new Core Data feature you want to use in your model, it might not be immediately available in code. That would be a good reason to file an issue with Apple, but in the meantime you’re stuck either not using the new feature or resorting to undocumented API.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \u003cp\u003eIf you know anything about Core Data, you’re probably aware of Xcode’s built-in model editor. If you’ve used Core Data, you’ve probably spent more time with it than you care to remember. It edits the data model, which then gets compiled to a binary form Core Data can use when your app runs. Conveniently it can also generate some code for you, subclasses of \u003ccode\u003eNSManagedObject\u003c/code\u003e for each entity in the model.\u003c/p\u003e\n\u003cp\u003eBut what about the model itself? Where’s the code for that?\u003c/p\u003e\n\u003cp\u003eThere isn’t any. The model editor uses a similar approach as editing UI in storyboards. Xcode creates the objects in memory and uses \u003ccode\u003eNSCoding\u003c/code\u003e to write everything to a binary property list. When the app runs, the framework loads that property list, and like magic, all the same objects exist in your app.\u003c/p\u003e\n\u003cp\u003eWith user interface there’s long been a back and forth between people who prefer working graphically and those who want to do it all in code– often because there seems to be too much magic going on behind the scenes. What about Core Data? Can you skip the model editor and write the code yourself?\u003c/p\u003e\n\u003cp\u003eYou can! The model editor, like the storyboard editor, is a convenience but not a requirement. You \u003cem\u003ecan\u003c/em\u003e do it all in code. If you really want. If you look at the documentation for \u003ccode\u003eNSManagedObjectModel\u003c/code\u003e, you’ll see that the collection of entities in the model is declared as\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar entities: [NSEntityDescription] { get set }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLikewise the docs for \u003ccode\u003eNSEntityDescription\u003c/code\u003e show that an entity’s properties are declared as\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar properties: [NSPropertyDescription] { get set }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo what? So they both have \u003ccode\u003eset\u003c/code\u003e in the declaration. \u003cem\u003eThey can be changed.\u003c/em\u003e This is not an accident. You can create and configure your entity descriptions in code, and then instantiate an \u003ccode\u003eNSManagedObjectModel\u003c/code\u003e that uses them. From there, it’s Core Data as usual.\u003c/p\u003e\n\u003ch2 id=\"a-simple-model\"\u003eA Simple Model\u003c/h2\u003e\n\u003cp\u003eLet’s give this a try. I’ll use a simple model with two entities, each with one attribute, and with a single relationship between them. If we were using the model editor it might look like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://atomicbird.com/blog/core-data-code-only/model-editor-table-style.png#center\" alt=\"Core Data model editor showing two entities in table style\"/\u003e\u003c/p\u003e\n\u003cp\u003eOr if you prefer the graphical style, like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://atomicbird.com/blog/core-data-code-only/model-editor-graph-style.png#center\" alt=\"Core Data model editor showing two entities in graph style\"/\u003e\u003c/p\u003e\n\u003cp\u003eFirst I’ll write the code for the custom classes I’ll be using. Two entities, one attribute each, with a relationship.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e@objc(Event)\nclass Event: NSManagedObject {\n    @NSManaged var timestamp: Date?\n    @NSManaged var location: Location?\n}\n\n@objc(Location)\nclass Location: NSManagedObject {\n    @NSManaged var name: String?\n    @NSManaged var events: NSSet?\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere I’m declaring attributes and relationships the same way that Xcode does when generating subclasses. That’s not absolutely necessary. But if you do things differently, be sure you understand the consequences, because Xcode doesn’t do it this way by accident. For example, I could declare the \u003ccode\u003eevents\u003c/code\u003e relationship as \u003ccode\u003eSet\u0026lt;Event\u0026gt;\u003c/code\u003e to be more Swifty, but that would affect how Core Data handles data faulting.\u003c/p\u003e\n\u003ch2 id=\"creating-the-entity-descriptions\"\u003eCreating the Entity Descriptions\u003c/h2\u003e\n\u003cp\u003eThis isn’t the model though, at least as far as Core Data is concerned. These subclasses are handy, but we have some work to do. First, here’s the \u003ccode\u003eEvent\u003c/code\u003e entity and its \u003ccode\u003etimestamp\u003c/code\u003e attribute:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet eventEntity = NSEntityDescription()\neventEntity.name = \u0026#34;Event\u0026#34;\neventEntity.managedObjectClassName = \u0026#34;Event\u0026#34;\n\nlet timestampAttribute = NSAttributeDescription()\ntimestampAttribute.name = \u0026#34;timestamp\u0026#34;\ntimestampAttribute.type = .date\neventEntity.properties.append(timestampAttribute)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat’s right, you can create entitie descriptions and attribute descriptions in code. Then you can configure them with code that matches every checkbox and pop-up menu in the model editor.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003emanagedObjectClassName\u003c/code\u003e property for \u003ccode\u003eNSEntityDescription\u003c/code\u003e controls the mapping from Core Data entity to \u003ccode\u003eNSManagedObject\u003c/code\u003e subclass. This is how Core Data will know that when I use the \u003ccode\u003eEvent\u003c/code\u003e entity, it should use that class I created earlier.\u003c/p\u003e\n\u003cp\u003eAll this stuff and more can be done in code:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://atomicbird.com/blog/core-data-code-only/data-model-inspector.png#center\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eLocation\u003c/code\u003e entity and its attribute is similar:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet locationEntity = NSEntityDescription()\nlocationEntity.name = \u0026#34;Location\u0026#34;\nlocationEntity.managedObjectClassName = \u0026#34;Location\u0026#34;\n\nlet nameAttribute = NSAttributeDescription()\nnameAttribute.name = \u0026#34;name\u0026#34;\nnameAttribute.type = .string\nlocationEntity.properties.append(nameAttribute)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow for the relationships. Just like the model editor, you need to create the relationship on both sides and make them inverses. The \u003ccode\u003eEvent\u003c/code\u003e-to-\u003ccode\u003eLocation\u003c/code\u003e relationship is to-one, and looks like this:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet eventToLocation = NSRelationshipDescription()\neventToLocation.name = \u0026#34;location\u0026#34;\neventToLocation.destinationEntity = locationEntity\neventToLocation.maxCount = 1\neventEntity.properties.append(eventToLocation)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs with the attribute description above, every setting from the model editor is available.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003emaxCount\u003c/code\u003e property is a little under-documented and works a little differently from the model editor. In Xcode there’s a pop-up menu to choose to-one or to-many. If you choose to-many, there are also text fields where you can set min and max counts for the relationship.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://atomicbird.com/blog/core-data-code-only/to-many-relationship.png#center\" alt=\"To-many relationship detail from Xcode data model editor\"/\u003e\u003c/p\u003e\n\u003cp\u003eIn code it’s a little different. There’s a property on \u003ccode\u003eNSRelationshipDescription\u003c/code\u003e called \u003ccode\u003eisToMany\u003c/code\u003e that looks like the right thing, but it’s a read-only property. How do you configure the relationship, then? In code the rule is\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf \u003ccode\u003emaxCount\u003c/code\u003e is 0, it’s a to-many relationship with no upper bound.\u003c/li\u003e\n\u003cli\u003eIf \u003ccode\u003emaxCount\u003c/code\u003e is 1, it’s a to-one relationship.\u003c/li\u003e\n\u003cli\u003eIf \u003ccode\u003emaxCount\u003c/code\u003e \u0026gt; 1, it’s to-many with whatever upper bound you choose.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt’s like this because Core Data was written long before Swift, and has no way for \u003ccode\u003emaxCount\u003c/code\u003e to be an optional value. Strangely \u003ccode\u003emaxCount\u003c/code\u003e is unsigned, so negative values are permitted. Using negative numbers has the same effect as setting \u003ccode\u003emaxCount\u003c/code\u003e to 0.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eLocation\u003c/code\u003e-to-\u003ccode\u003eEvent\u003c/code\u003e relationship is similar. Once it exists, I can make these two relationships inverses of each other:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet locationToEvent = NSRelationshipDescription()\nlocationToEvent.name = \u0026#34;events\u0026#34;\nlocationToEvent.destinationEntity = eventEntity\nlocationToEvent.maxCount = 0 // 0 is the default but this makes it clear\nlocationEntity.properties.append(locationToEvent)\n\neventToLocation.inverseRelationship = locationToEvent\nlocationToEvent.inverseRelationship = eventToLocation\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs with the model editor, inverses need to be configured at both ends of the relationship.\u003c/p\u003e\n\u003ch2 id=\"on-to-the-data-model\"\u003eOn to the Data Model\u003c/h2\u003e\n\u003cp\u003eWhew! OK that was all interesting, but now we need a data model to tie it all together.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet model = NSManagedObjectModel()\nmodel.entities = [eventEntity, locationEntity]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOh wait, that was easy. Instantiate the model and give it some entities. Now we have a working data model! Let’s use it.\u003c/p\u003e\n\u003ch2 id=\"stop-me-if-youve-seen-this-before\"\u003eStop Me if You’ve Seen This Before\u003c/h2\u003e\n\u003cp\u003eFrom this point on it’s nearly the same as when you’re using the model editor. The only significant difference is creating a persistent container that uses the model I just created instead of looking for one in a file.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet container = NSPersistentContainer(name: \u0026#34;My Model\u0026#34;, managedObjectModel: model)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFrom there, set whatever container options you need and call \u003ccode\u003econtainer.loadPersistentStores\u003c/code\u003e. And then it’s Core Data business as usual.\u003c/p\u003e\n\u003ch2 id=\"about-those-writeable-properties\"\u003eAbout those Writeable Properties\u003c/h2\u003e\n\u003cp\u003eDon’t get too power-mad with code like this. There’s one major detail to be aware of. If you look at the docs for these writeable properties I’ve been using to build the model, you’ll see this message:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSetting this property raises an exception if the receiver’s model has been used by an object graph manager.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThat means you can define the model in code, but you’re asking for trouble if you try changing it after you’ve used it for a Core Data stack. In the code above, they’re writeable right up to the point where I created the persistent container. After that, changing the model in any way will crash the app immediately.\u003c/p\u003e\n\u003ch2 id=\"model-migration\"\u003eModel Migration\u003c/h2\u003e\n\u003cp\u003eWhat if you need to change your data model? I have good news! Probably. For most cases.\u003c/p\u003e\n\u003cp\u003eIf your model changes are compatible with automatic lightweight migration, \u003cem\u003ejust change the model\u003c/em\u003e and it’ll work. Let’s say I decide to add a new \u003ccode\u003etitle\u003c/code\u003e attribute to \u003ccode\u003eEvent\u003c/code\u003e. First I’ll change the class to this:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e@objc(Event)\nclass Event: NSManagedObject {\n    @NSManaged var timestamp: Date?\n    @NSManaged var title: String?\n    @NSManaged var location: Location?\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd I’ll add a few lines to create the attribute:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet titleAttribute = NSAttributeDescription()\ntitleAttribute.name = \u0026#34;title\u0026#34;\ntitleAttribute.type = .string\neventEntity.properties.append(titleAttribute)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow what happens if I try to use the model with an existing data store? If \u003ccode\u003eshouldMigrateStoreAutomatically\u003c/code\u003e and \u003ccode\u003eshouldInferMappingModelAutomatically\u003c/code\u003e are both \u003ccode\u003etrue\u003c/code\u003e, the migration is automatic and the new model works with the existing data. Both of those attributes are \u003ccode\u003etrue\u003c/code\u003e by default, so unless you changed them, they’re already true.\u003c/p\u003e\n\u003cp\u003eAutomatic lightweight migration covers a bunch of common cases. Check out \u003ca href=\"https://developer.apple.com/documentation/coredata/using_lightweight_migration\"\u003eApple’s documentation\u003c/a\u003e for a full list.\u003c/p\u003e\n\u003cp\u003eIf you can’t use automatic lightweight migration, well, you are in for a bit of work. If you didn’t use the data model editor, you can’t have Xcode set up a migration manager for you. But if you’re writing your model in code, you probably don’t want to, because that’s even deeper magic than the model editor.\u003c/p\u003e\n\u003cp\u003eAs with the model, you can do it all in code, but as with code, it means working in some rarely used corners of the Core Data framework. The details are more than I’m going to get into here, but whatever you do, \u003cstrong\u003ekeep the code for the old model\u003c/strong\u003e because you’ll need both old and new data models to do the migration. Then, investigate \u003ccode\u003eNSMappingModel\u003c/code\u003e and \u003ccode\u003eNSMigrationManager\u003c/code\u003e to work out the details.\u003c/p\u003e\n\u003ch2 id=\"why-not-do-this\"\u003eWhy (Not) Do This?\u003c/h2\u003e\n\u003cp\u003eI’ve never done this in a real app. But then, I’m also the kind of developer who uses interface builder for UI design whenever possible. There’s more than one way to do it, though. If you prefer to keep your UI in code, maybe you’d prefer to do Core Data that way as well, for more or less the same reason. I can see that version diffs would probably be easier to read when changing the model. It’s not for me, but that’s my preference. Maybe you’d like this way better.\u003c/p\u003e\n\u003cp\u003eThe biggest hurdle is probably if you ever need a model migration that can’t be done automatically. The model editor has a built-in convenience for keeping older models around and indicating which is current. You’d have to tackle that yourself by keeping code for old models around, on top of needing to write the migration as mentioned above.\u003c/p\u003e\n\u003ch2 id=\"additional-note\"\u003e\u003cstrong\u003eAdditional Note\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eAdded Nov 10\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eAfter posting the above, \u003ca href=\"https://mjtsai.com/blog/\"\u003eMichael Tsai\u003c/a\u003e responed via Twitter:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://twitter.com/mjtsai/status/1457884691076423682\"\u003e\u003cimg src=\"https://atomicbird.com/blog/core-data-code-only/mjtsai-tweet.png#center\" alt=\"I prefer to do it in code, but unfortunately the API usually seems to lag what you can do in the model editor. So at various times it’s been necessary to use private API to enable indexing, persistent history tracking, and other features that were new.\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eSo there’s one more potential caveat: If you hear about a new Core Data feature you want to use in your model, it might not be immediately available in code. That would be a good reason to \u003ca href=\"https://feedbackassistant.apple.com\"\u003efile an issue with Apple\u003c/a\u003e, but in the meantime you’re stuck either not using the new feature or resorting to undocumented API.\u003c/p\u003e\n\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2021-11-08T00:00:00Z",
  "modifiedTime": "2021-11-08T00:00:00Z"
}
