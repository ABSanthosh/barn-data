{
  "id": "e2d8d99a-8062-4d99-b222-63a75d263e15",
  "title": "Performance Trace Profiles in iOS: Debugging performance issues you can't reproduce",
  "link": "https://swiftrocks.com/debugging-ios-performance-issues-you-cant-reproduce-with-performance-trace-profiles",
  "description": "If you landed at this article then it's possible that you're dealing with one of the most annoying things you can face as a developer: having to investigate an issue reported by your users that nobody seems to be able to reproduce internally. The topic of investigating crashes you can't reproduce is something I've already talked about here at SwiftRocks in the \"How To Solve Any iOS Crash Ever\" article, but what I wanted to show you today refers to a different yet equally challenging category of issues: performance problems, like hangs/freezing UI, slow code, unnecessary threading/concurrency, CPU/memory exceptions, and so on. While some of the techniques mentioned in the crashes article can also be used to investigate performance-related problems, chances are you won't have to, because this category of issues has access to a debugging weapon so powerful that you don't even need to run the app yourself to find the exact source of the problem! Performance Trace Profiles Debugging Profiles are relatively unknown in the iOS community (possibly because the types of problems that require them are themselves quite rare to come across), but they are my current favorite way of debugging performance-related issues. The standard way of debugging performance problems is by hooking your device to Xcode's Instruments, but if you can't reproduce the issue yourself, then obviously you cannot do that. However, if you know anyone who can reproduce it (doesn't matter if it's a developer or a random user), you can still fully debug the problem by having them run a Performance Trace for you. Profiles are files you open in your iOS device to temporarily unlock features that the device wouldn't normally have access to, something you might've already experienced if you ever enrolled one of your devices to the beta OS program. What you might not know though is that there are many types of profiles out there that you can install, and some of them are oriented towards helping you debug issues in your apps! As the name implies, the Performance Trace profile gives your device performance-tracing capabilities. To be more specific, it allows the device that has it to run a system trace of everything that is currently running on the phone, generating a trace that you can later extract and open in Instruments. In other words, it's like if you were locally running a profile build of your app, except that it doesn't require the device to be plugged anywhere and works on any device and build of your product, even the App Store ones. Be careful though, because with this great power comes also great responsibility; the trace will capture everything that is happening on the user's phone, which includes a lot of personal/sensitive information about that particular device. If you're going to be asking strangers to do this process for you, make sure this is clear to them and that you're not violating any data protection laws from your country that may apply. Running a Performance Trace Follow these steps to enable performance tracing on your device: Open Apple's Profiles and Logs page. Find the Performance Trace entry in the list of profiles. Download the profile and install it on the device that can reproduce the issue. (You can, for example, use AirDrop to transfer the profile from a computer to the device). Restart the device if needed. Go to Settings \u003e Control Center \u003e Customize Controls, and then enable the Performance Trace control. To run a trace, follow these steps: Open Control Center and tap on the Performance Trace control to begin tracing. Open your app (if you haven't done it already), and reproduce the issue. Keep in mind that traces cannot be longer than 30 seconds. After reproducing the problem, either open Control Center and tap on the Performance Trace control again to stop tracing or wait for the 30 seconds time limit (after which the trace will automatically stop itself). Wait a while for your phone to process the trace. You will receive a notification when this is done containing the name of the generated file (usually trace_somethingsomething.tgz). Either tap the notification or go to Settings \u003e Privacy \u003e Analytics \u0026 Improvements \u003e Analytics Data Locate the trace in the list and send it to your Mac. Trace archives are usually a couple of hundred megabytes in size. (Optional) Find the profile in Settings \u003e VPN \u0026 Device Management and delete it. The profile will otherwise automatically delete itself after 7 days. From your Mac, uncompress the archive. The result will be an instruments report that you can open in Xcode. Analyzing the trace Once you open the trace you may find that Xcode will highlight the System Trace instrument for you, and that's exactly what you should open. Keep in mind that by default no symbols will be resolved since the trace was generated outside of Xcode, so you'll need access to the dSYMs for the build that was traced in hand in order to make sense of the report. Instruments should be able to automatically symbolicate the report if the dSYMs are in your machine, but if it doesn't do that (it almost never does for me), you can manually provide the path to the dSYMs at File -\u003e Symbols. If that also doesn't work, the Spotlight refreshing steps mentioned in this article should do the trick. I find that the best way to learn how to use this particular instrument is to watch Apple's WWDC session about it, but if you've watched it and still feel lost, the example below may help you. The System Trace instrument is basically the Time Profiler on steroids. While the latter (which I'm assuming you have prior experience with) allows you to analyze the CPU usage and memory footprint of an app, System Trace does that in addition to providing detailed information about the state of the different threads in the app, including what's causing them to not run code (if applicable). When facing performance issues, this additional threading information can usually point you to the exact source of the problem! Here's an example that shows how I usually approach performance issues. Consider this intentionally slow horrible piece of code: final class ViewController: UIViewController { let queue = DispatchQueue(label: \"slow-queue\") let waitSemaphore = DispatchSemaphore(value: 0) override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) queue.async { self.runVerySlowCode() self.waitSemaphore.signal() } waitSemaphore.wait() runVerySlowCode() } func runVerySlowCode() { var arr = Array(0...100_000) for i in (1.. for j in 0.. arr[j + 1] { arr.swapAt(j, j + 1) } } } } When displayed, this view controller will run some very expensive code in a background thread, block itself until that finishes (because why not?), and then proceed to run the same expensive code again because we really like it. This code, which results in the main thread hanging for several seconds, is obviously terrible, but pretend that somehow this slipped into production without your knowledge, your users are now complaining, and you had someone send you a performance trace. After opening the trace, you'll see something like this: The System Trace instrument tracks the state of all threads in the process, and here you can immediately see that something's wrong: the main thread is marked as Blocked by something for a really long time and then running non-stop for also a really long time. Each of these actions will result in the app hanging. Tips for debugging the blocked state What I really like about this instrument is that it's capable of telling you exactly why a thread is marked as blocked. If you change the bottom inspector to the Narrative mode and move the timeline to the beginning of the blocked section, the instrument will tell you that the main thread was blocked by a semaphore, which was later released by another thread: Many of the elements in this view are clickable and will provide more information when highlighted. In this case, by clicking the row that mentions the semaphore, you'll be able to see in the bottom right exactly which line triggered the event (which in this case is the semaphore in viewWillAppear). Another useful thing you can do is tap the name of the thread that eventually released it, which will take you to it in the timeline and reveal to you what exactly this thread was doing that caused the main thread to be blocked for so long (the next thing we'll look at). Tips for debugging the excessive work These traces will eventually lead you to a thread doing a lot of expensive work, and the process to debug those is no different than using the standard Time Profiler instrument; by highlighting the suspicious area and changing the bottom inspector to the Profile view, we can see what the app was doing at the time. I assume you already know how to use the Time Profiler so I'll skip explaining the many different ways in which you can read this data, but if you need a refresher, this WWDC session should cover what you need to know. We had two such cases (the work being done by the background thread that caused the main thread to be blocked and the work the main thread did on itself) in our example, and in any of them we can see that runVerySlowCode is the method to blame. What else can Performance Traces be used for? Performance Traces shine mostly in the very specific case we covered in the introduction: you are facing an issue that is connected to performance and for some reason you cannot reproduce it yourself. You could theoretically use it to gather data on more general logic/UI issues (assuming the data you're looking for would somehow materialize in the sampled stack traces), but for those cases, you'd probably find the steps defined in the article about crashes to be more effective. Despite being a rare situation to come by, these traces have saved by butt every time it happened and are now one of my favorite debugging techniques for this category of issues.",
  "author": "Bruno Rocha",
  "published": "Thu, 1 Jun 2023 13:30:00 GMT+2",
  "source": "https://swiftrocks.com/rss.xml",
  "categories": null,
  "byline": "Bruno Rocha",
  "length": 10157,
  "excerpt": "The Performance Trace profile allows you to debug performance issues without having to attach the device to Xcode. Let's see what we can use it for!",
  "siteName": "SwiftRocks",
  "favicon": "https://swiftrocks.com/images/favicon/iconsmall2.png",
  "text": "If you landed at this article then it's possible that you're dealing with one of the most annoying things you can face as a developer: having to investigate an issue reported by your users that nobody seems to be able to reproduce internally. The topic of investigating crashes you can't reproduce is something I've already talked about here at SwiftRocks in the \"How To Solve Any iOS Crash Ever\" article, but what I wanted to show you today refers to a different yet equally challenging category of issues: performance problems, like hangs/freezing UI, slow code, unnecessary threading/concurrency, CPU/memory exceptions, and so on. While some of the techniques mentioned in the crashes article can also be used to investigate performance-related problems, chances are you won't have to, because this category of issues has access to a debugging weapon so powerful that you don't even need to run the app yourself to find the exact source of the problem! Performance Trace Profiles Debugging Profiles are relatively unknown in the iOS community (possibly because the types of problems that require them are themselves quite rare to come across), but they are my current favorite way of debugging performance-related issues. The standard way of debugging performance problems is by hooking your device to Xcode's Instruments, but if you can't reproduce the issue yourself, then obviously you cannot do that. However, if you know anyone who can reproduce it (doesn't matter if it's a developer or a random user), you can still fully debug the problem by having them run a Performance Trace for you. Profiles are files you open in your iOS device to temporarily unlock features that the device wouldn't normally have access to, something you might've already experienced if you ever enrolled one of your devices to the beta OS program. What you might not know though is that there are many types of profiles out there that you can install, and some of them are oriented towards helping you debug issues in your apps! As the name implies, the Performance Trace profile gives your device performance-tracing capabilities. To be more specific, it allows the device that has it to run a system trace of everything that is currently running on the phone, generating a trace that you can later extract and open in Instruments. In other words, it's like if you were locally running a profile build of your app, except that it doesn't require the device to be plugged anywhere and works on any device and build of your product, even the App Store ones. Be careful though, because with this great power comes also great responsibility; the trace will capture everything that is happening on the user's phone, which includes a lot of personal/sensitive information about that particular device. If you're going to be asking strangers to do this process for you, make sure this is clear to them and that you're not violating any data protection laws from your country that may apply. Running a Performance Trace Follow these steps to enable performance tracing on your device: Open Apple's Profiles and Logs page. Find the Performance Trace entry in the list of profiles. Download the profile and install it on the device that can reproduce the issue. (You can, for example, use AirDrop to transfer the profile from a computer to the device). Restart the device if needed. Go to Settings \u003e Control Center \u003e Customize Controls, and then enable the Performance Trace control. To run a trace, follow these steps: Open Control Center and tap on the Performance Trace control to begin tracing. Open your app (if you haven't done it already), and reproduce the issue. Keep in mind that traces cannot be longer than 30 seconds. After reproducing the problem, either open Control Center and tap on the Performance Trace control again to stop tracing or wait for the 30 seconds time limit (after which the trace will automatically stop itself). Wait a while for your phone to process the trace. You will receive a notification when this is done containing the name of the generated file (usually trace_somethingsomething.tgz). Either tap the notification or go to Settings \u003e Privacy \u003e Analytics \u0026 Improvements \u003e Analytics Data Locate the trace in the list and send it to your Mac. Trace archives are usually a couple of hundred megabytes in size. (Optional) Find the profile in Settings \u003e VPN \u0026 Device Management and delete it. The profile will otherwise automatically delete itself after 7 days. From your Mac, uncompress the archive. The result will be an instruments report that you can open in Xcode. Analyzing the trace Once you open the trace you may find that Xcode will highlight the System Trace instrument for you, and that's exactly what you should open. Keep in mind that by default no symbols will be resolved since the trace was generated outside of Xcode, so you'll need access to the dSYMs for the build that was traced in hand in order to make sense of the report. Instruments should be able to automatically symbolicate the report if the dSYMs are in your machine, but if it doesn't do that (it almost never does for me), you can manually provide the path to the dSYMs at File -\u003e Symbols. If that also doesn't work, the Spotlight refreshing steps mentioned in this article should do the trick. I find that the best way to learn how to use this particular instrument is to watch Apple's WWDC session about it, but if you've watched it and still feel lost, the example below may help you. The System Trace instrument is basically the Time Profiler on steroids. While the latter (which I'm assuming you have prior experience with) allows you to analyze the CPU usage and memory footprint of an app, System Trace does that in addition to providing detailed information about the state of the different threads in the app, including what's causing them to not run code (if applicable). When facing performance issues, this additional threading information can usually point you to the exact source of the problem! Here's an example that shows how I usually approach performance issues. Consider this intentionally slow horrible piece of code: final class ViewController: UIViewController { let queue = DispatchQueue(label: \"slow-queue\") let waitSemaphore = DispatchSemaphore(value: 0) override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) queue.async { self.runVerySlowCode() self.waitSemaphore.signal() } waitSemaphore.wait() runVerySlowCode() } func runVerySlowCode() { var arr = Array(0...100_000) for i in (1..\u003carr.count).reversed() { for j in 0..\u003ci where arr[j] \u003e arr[j + 1] { arr.swapAt(j, j + 1) } } } } When displayed, this view controller will run some very expensive code in a background thread, block itself until that finishes (because why not?), and then proceed to run the same expensive code again because we really like it. This code, which results in the main thread hanging for several seconds, is obviously terrible, but pretend that somehow this slipped into production without your knowledge, your users are now complaining, and you had someone send you a performance trace. After opening the trace, you'll see something like this: The System Trace instrument tracks the state of all threads in the process, and here you can immediately see that something's wrong: the main thread is marked as Blocked by something for a really long time and then running non-stop for also a really long time. Each of these actions will result in the app hanging. Tips for debugging the blocked state What I really like about this instrument is that it's capable of telling you exactly why a thread is marked as blocked. If you change the bottom inspector to the Narrative mode and move the timeline to the beginning of the blocked section, the instrument will tell you that the main thread was blocked by a semaphore, which was later released by another thread: Many of the elements in this view are clickable and will provide more information when highlighted. In this case, by clicking the row that mentions the semaphore, you'll be able to see in the bottom right exactly which line triggered the event (which in this case is the semaphore in viewWillAppear). Another useful thing you can do is tap the name of the thread that eventually released it, which will take you to it in the timeline and reveal to you what exactly this thread was doing that caused the main thread to be blocked for so long (the next thing we'll look at). Tips for debugging the excessive work These traces will eventually lead you to a thread doing a lot of expensive work, and the process to debug those is no different than using the standard Time Profiler instrument; by highlighting the suspicious area and changing the bottom inspector to the Profile view, we can see what the app was doing at the time. I assume you already know how to use the Time Profiler so I'll skip explaining the many different ways in which you can read this data, but if you need a refresher, this WWDC session should cover what you need to know. We had two such cases (the work being done by the background thread that caused the main thread to be blocked and the work the main thread did on itself) in our example, and in any of them we can see that runVerySlowCode is the method to blame. What else can Performance Traces be used for? Performance Traces shine mostly in the very specific case we covered in the introduction: you are facing an issue that is connected to performance and for some reason you cannot reproduce it yourself. You could theoretically use it to gather data on more general logic/UI issues (assuming the data you're looking for would somehow materialize in the sampled stack traces), but for those cases, you'd probably find the steps defined in the article about crashes to be more effective. Despite being a rare situation to come by, these traces have saved by butt every time it happened and are now one of my favorite debugging techniques for this category of issues.",
  "image": "https://swiftrocks.com/images/thumbs/thumb.jpg?4",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \n  \n\u003cp\u003eIf you landed at this article then it\u0026#39;s possible that you\u0026#39;re dealing with one of the most annoying things you can face as a developer: having to investigate an issue reported by your users that \u003cb\u003enobody\u003c/b\u003e seems to be able to reproduce internally.\u003c/p\u003e\n\n\u003cp\u003eThe topic of investigating \u003ci\u003ecrashes\u003c/i\u003e you can\u0026#39;t reproduce is something I\u0026#39;ve already talked about here at SwiftRocks in the \u003ca href=\"https://swiftrocks.com/how-to-solve-any-ios-crash-ever\"\u003e\u0026#34;How To Solve Any iOS Crash Ever\u0026#34;\u003c/a\u003e article, but what I wanted to show you today refers to a different yet equally challenging category of issues: \u003cb\u003eperformance problems\u003c/b\u003e, like hangs/freezing UI, slow code, unnecessary threading/concurrency, CPU/memory exceptions, and so on.\u003c/p\u003e\n\u003cp\u003eWhile some of the techniques mentioned in the crashes article can also be used to investigate performance-related problems, chances are you won\u0026#39;t have to, because this category of issues has access to a debugging weapon so powerful that you don\u0026#39;t even need to run the app yourself to find the exact source of the problem!\u003c/p\u003e\n\u003ch2\u003ePerformance Trace Profiles\u003c/h2\u003e\n\u003cp\u003e\u003ci\u003eDebugging Profiles\u003c/i\u003e are relatively unknown in the iOS community (possibly because the types of problems that require them are themselves quite rare to come across), but they are my current favorite way of debugging performance-related issues.\u003c/p\u003e\n\u003cp\u003eThe standard way of debugging performance problems is by hooking your device to Xcode\u0026#39;s Instruments, but if you can\u0026#39;t reproduce the issue yourself, then obviously you cannot do that. However, if you know \u003ci\u003eanyone\u003c/i\u003e who can reproduce it (doesn\u0026#39;t matter if it\u0026#39;s a developer or a random user), you can still fully debug the problem by having them run a \u003cb\u003ePerformance Trace\u003c/b\u003e for you.\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eProfiles\u003c/b\u003e are files you open in your iOS device to temporarily unlock features that the device wouldn\u0026#39;t normally have access to, something you might\u0026#39;ve already experienced if you ever enrolled one of your devices to the beta OS program. What you might not know though is that there are \u003ci\u003emany\u003c/i\u003e types of profiles out there that you can install, and some of them are oriented towards helping you debug issues in your apps!\u003c/p\u003e\n\u003cp\u003eAs the name implies, the \u003cb\u003ePerformance Trace\u003c/b\u003e profile gives your device performance-tracing capabilities. To be more specific, it allows the device that has it to run a system trace of \u003cb\u003eeverything\u003c/b\u003e that is currently running on the phone, generating a trace that you can later extract and open in Instruments. In other words, it\u0026#39;s like if you were locally running a profile build of your app, except that it doesn\u0026#39;t require the device to be plugged anywhere and works on any device and build of your product, even the App Store ones.\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eBe careful though, because with this great power comes also great responsibility; the trace will capture everything that is happening on the user\u0026#39;s phone, which includes a lot of personal/sensitive information about that particular device.\u003c/b\u003e If you\u0026#39;re going to be asking strangers to do this process for you, make sure this is clear to them and that you\u0026#39;re not violating any data protection laws from your country that may apply.\u003c/p\u003e\n\u003ch2\u003eRunning a Performance Trace\u003c/h2\u003e\n\u003cp\u003eFollow these steps to enable performance tracing on your device:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eOpen Apple\u0026#39;s \u003ca href=\"https://developer.apple.com/bug-reporting/profiles-and-logs/\"\u003eProfiles and Logs\u003c/a\u003e page.\u003c/li\u003e\n\u003cli\u003eFind the \u003ci\u003ePerformance Trace\u003c/i\u003e entry in the list of profiles.\u003c/li\u003e\n\u003cli\u003eDownload the profile and install it on the device that can reproduce the issue. (You can, for example, use AirDrop to transfer the profile from a computer to the device).\u003c/li\u003e\n\u003cli\u003eRestart the device if needed.\u003c/li\u003e\n\u003cli\u003eGo to \u003ci\u003eSettings \u0026gt; Control Center \u0026gt; Customize Controls\u003c/i\u003e, and then enable the \u003ci\u003ePerformance Trace\u003c/i\u003e control.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eTo run a trace, follow these steps:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eOpen Control Center and tap on the Performance Trace control to begin tracing.\u003c/li\u003e\n\u003cli\u003eOpen your app (if you haven\u0026#39;t done it already), and reproduce the issue. Keep in mind that traces cannot be longer than 30 seconds.\u003c/li\u003e\n\u003cli\u003eAfter reproducing the problem, either open Control Center and tap on the Performance Trace control again to stop tracing or wait for the 30 seconds time limit (after which the trace will automatically stop itself).\u003c/li\u003e\n\u003cli\u003eWait a while for your phone to process the trace. You will receive a notification when this is done containing the name of the generated file (usually \u003ccode\u003etrace_somethingsomething.tgz\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003eEither tap the notification or go to \u003ci\u003eSettings \u0026gt; Privacy \u0026gt; Analytics \u0026amp; Improvements \u0026gt; Analytics Data\u003c/i\u003e\u003c/li\u003e\n\u003cli\u003eLocate the trace in the list and send it to your Mac. Trace archives are usually a couple of hundred megabytes in size.\u003c/li\u003e\n\u003cli\u003e(Optional) Find the profile in \u003ci\u003eSettings \u0026gt; VPN \u0026amp; Device Management\u003c/i\u003e and delete it. The profile will otherwise automatically delete itself after 7 days.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFrom your Mac, uncompress the archive. The result will be an instruments report that you can open in Xcode.\u003c/p\u003e\n\u003ch2\u003eAnalyzing the trace\u003c/h2\u003e\n\u003cp\u003eOnce you open the trace you may find that Xcode will highlight the \u003cb\u003eSystem Trace\u003c/b\u003e instrument for you, and that\u0026#39;s exactly what you should open. Keep in mind that by default no symbols will be resolved since the trace was generated outside of Xcode, so you\u0026#39;ll need access to the dSYMs for the build that was traced in hand in order to make sense of the report. Instruments should be able to automatically symbolicate the report if the dSYMs are in your machine, but if it doesn\u0026#39;t do that (it almost never does for me), you can manually provide the path to the dSYMs at File -\u0026gt; Symbols. If that also doesn\u0026#39;t work, the \u003ca href=\"https://swiftrocks.com/reverse-engineering-xcode-issue-crash-symbol\"\u003eSpotlight refreshing steps mentioned in this article\u003c/a\u003e should do the trick.\u003c/p\u003e\n\u003cp\u003eI find that the best way to learn how to use this particular instrument is to \u003ca href=\"https://developer.apple.com/videos/play/wwdc2016/411/\"\u003ewatch Apple\u0026#39;s WWDC session about it\u003c/a\u003e, but if you\u0026#39;ve watched it and still feel lost, the example below may help you.\u003c/p\u003e\n\u003cp\u003eThe System Trace instrument is basically the Time Profiler on steroids. While the latter (which I\u0026#39;m assuming you have prior experience with) allows you to analyze the CPU usage and memory footprint of an app, System Trace does that \u003cb\u003ein addition\u003c/b\u003e to providing detailed information about the state of the different threads in the app, including what\u0026#39;s causing them to not run code (if applicable). When facing performance issues, this additional threading information can usually point you to the exact source of the problem!\u003c/p\u003e\n\u003cp\u003eHere\u0026#39;s an example that shows how I usually approach performance issues. Consider this intentionally slow horrible piece of code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efinal class ViewController: UIViewController {\u003c/code\u003e\n\u003ccode\u003e    let queue = DispatchQueue(label: \u0026#34;slow-queue\u0026#34;)\u003c/code\u003e\n\u003ccode\u003e    let waitSemaphore = DispatchSemaphore(value: 0)\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e    override func viewWillAppear(_ animated: Bool) {\u003c/code\u003e\n\u003ccode\u003e        super.viewWillAppear(animated)\u003c/code\u003e\n\u003ccode\u003e        queue.async {\u003c/code\u003e\n\u003ccode\u003e            self.runVerySlowCode()\u003c/code\u003e\n\u003ccode\u003e            self.waitSemaphore.signal()\u003c/code\u003e\n\u003ccode\u003e        }\u003c/code\u003e\n\u003ccode\u003e        waitSemaphore.wait()\u003c/code\u003e\n\u003ccode\u003e        runVerySlowCode()\u003c/code\u003e\n\u003ccode\u003e    }\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e    func runVerySlowCode() {\u003c/code\u003e\n\u003ccode\u003e        var arr = Array(0...100_000)\u003c/code\u003e\n\u003ccode\u003e        for i in (1..\u0026lt;arr.count).reversed() {\u003c/code\u003e\n\u003ccode\u003e            for j in 0..\u0026lt;i where arr[j] \u0026gt; arr[j + 1] {\u003c/code\u003e\n\u003ccode\u003e                arr.swapAt(j, j + 1)\u003c/code\u003e\n\u003ccode\u003e            }\u003c/code\u003e\n\u003ccode\u003e        }\u003c/code\u003e\n\u003ccode\u003e    }\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eWhen displayed, this view controller will run some very expensive code in a background thread, \u003cb\u003eblock itself\u003c/b\u003e until that finishes (because why not?), and then proceed to run the same expensive code again because we really like it. This code, which results in the main thread hanging for several seconds, is obviously terrible, but pretend that somehow this slipped into production without your knowledge, your users are now complaining, and you had someone send you a performance trace. After opening the trace, you\u0026#39;ll see something like this:\u003c/p\u003e\n \u003cp\u003e\u003cimg src=\"https://i.imgur.com/NbmMGSM.png\" alt=\"\"/\u003e \n \u003c/p\u003e\n\u003cp\u003eThe System Trace instrument tracks the state of all threads in the process, and here you can immediately see that something\u0026#39;s wrong: the main thread is marked as \u003cb\u003eBlocked\u003c/b\u003e by something for a really long time and then running non-stop for also a really long time. Each of these actions will result in the app hanging.\u003c/p\u003e\n\u003ch2\u003eTips for debugging the blocked state\u003c/h2\u003e\n\u003cp\u003eWhat I really like about this instrument is that it\u0026#39;s capable of telling you exactly \u003ci\u003ewhy\u003c/i\u003e a thread is marked as blocked. If you change the bottom inspector to the \u003cb\u003eNarrative\u003c/b\u003e mode and move the timeline to the beginning of the blocked section, the instrument will tell you that the main thread was blocked by a semaphore, which was later released by another thread:\u003c/p\u003e\n \u003cp\u003e\u003cimg src=\"https://i.imgur.com/fvsiPfN.png\" alt=\"\"/\u003e \n \u003c/p\u003e\n\u003cp\u003eMany of the elements in this view are clickable and will provide more information when highlighted. In this case, by clicking the row that mentions the semaphore, you\u0026#39;ll be able to see in the bottom right exactly which line triggered the event (which in this case is the semaphore in \u003ccode\u003eviewWillAppear\u003c/code\u003e). Another useful thing you can do is tap the name of the thread that eventually released it, which will take you to it in the timeline and reveal to you what exactly this thread was doing that caused the main thread to be blocked for so long (the next thing we\u0026#39;ll look at).\u003c/p\u003e\n\u003ch2\u003eTips for debugging the excessive work\u003c/h2\u003e\n\u003cp\u003eThese traces will eventually lead you to a thread doing a lot of expensive work, and the process to debug those is no different than using the standard Time Profiler instrument; by highlighting the suspicious area and changing the bottom inspector to the \u003cb\u003eProfile\u003c/b\u003e view, we can see what the app was doing at the time.\u003c/p\u003e\n\u003cp\u003eI assume you already know how to use the Time Profiler so I\u0026#39;ll skip explaining the many different ways in which you can read this data, but if you need a refresher, \u003ca href=\"https://developer.apple.com/videos/play/wwdc2019\"\u003ethis WWDC session\u003c/a\u003e should cover what you need to know. We had two such cases (the work being done by the background thread that caused the main thread to be blocked and the work the main thread did on itself) in our example, and in any of them we can see that \u003ccode\u003erunVerySlowCode\u003c/code\u003e is the method to blame.\u003c/p\u003e\n \u003cp\u003e\u003cimg src=\"https://i.imgur.com/894bK1H.png\" alt=\"\"/\u003e\n \u003c/p\u003e\n\u003ch2\u003eWhat else can Performance Traces be used for?\u003c/h2\u003e\n\u003cp\u003ePerformance Traces shine mostly in the very specific case we covered in the introduction: you are facing an issue that is connected to performance and for some reason you cannot reproduce it yourself. You could theoretically use it to gather data on more general logic/UI issues (assuming the data you\u0026#39;re looking for would somehow materialize in the sampled stack traces), but for those cases, you\u0026#39;d probably find the steps defined in the \u003ca href=\"https://swiftrocks.com/how-to-solve-any-ios-crash-ever\"\u003earticle about crashes\u003c/a\u003e to be more effective.\u003c/p\u003e\n\n\u003cp\u003eDespite being a rare situation to come by, these traces have saved by butt every time it happened and are now one of my favorite debugging techniques for this category of issues.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2023-06-01T13:30:00+02:00",
  "modifiedTime": null
}
