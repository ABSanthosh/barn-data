{
  "id": "82104f3a-6fad-4cdb-85f7-ac01f3108416",
  "title": "Unit testing UIView action and gesture in Swift",
  "link": "https://benoitpasquier.com/unit-testing-uiview-action-gesture-swift/",
  "description": "A big part of the developer journey is make sure our code behaves as expected. It’s best practice to setup tests that allow us to test quickly and often that nothing is broken. If unit testing is common practice to check the business logic, we can also extend it to cover some specific UI behaviors. Let’s how to unit test views and gesture in UIKit.",
  "author": "",
  "published": "Fri, 20 Aug 2021 08:00:00 +0000",
  "source": "https://benoitpasquier.com/index.xml",
  "categories": null,
  "byline": "Benoit Pasquier",
  "length": 15229,
  "excerpt": "A big part of the developer journey is make sure our code behaves as expected. It’s best practice to setup tests that allow us to test quickly and often that nothing is broken. If unit testing is common practice to check the business logic, we can also extend it to cover some specific UI behaviors. Let’s how to unit test views and gesture in UIKit.",
  "siteName": "Benoit Pasquier",
  "favicon": "https://benoitpasquier.com/favicon.png",
  "text": "A big part of the developer journey is make sure our code behaves as expected. It’s best practice to setup tests that allow us to test quickly and often that nothing is broken. If unit testing is common practice to check the business logic, we can also extend it to cover some specific UI behaviors. Let’s how to unit test views and gesture in UIKit. For this article, I’ve build a very simple app with fruits to add or remove to my cart. Before diving into the code, let’s refresh some testing concepts. In computer science, we can have different layers of testing, each representing a safety-net for the team to make sure everything work as expected: Unit testing: a suite of test that covers a specific self-contained piece of code, a unit, like a file or a class. If it fails, your unit needs to be fixed. Integration testing: a suite of test that covers the interaction between two units. When failing, the interaction isn’t working as expected. Regression testing: this is the complete suite of test across your project. By running it, we’re making sure the last contribution didn’t break anything else. When failing, the app doesn’t behave as it use to be. Acceptance testing: It’s a higher level of test and most likely performed by the Quality Assurance team to check the new feature meet the requirement. It’s often based on the business / customer / stack-holder needs. It answers the question “did we build the right thing?” Functional testing / end-to-end testing: it describes the functionality itself and answers the question “did we build a working product?” . It covers more than the acceptance criteria, making sure error-handling and “it shouldn’t happen” scenario actually doesn’t happen. In my case, I want to make sure some gesture and tap on button are executing the right block. So it sits between unit testing / integration testing, depending of each view integration. I’ve used an MVVM architecture design pattern to make it easier to test each layer. That being said, I’ll stay focused on the View layer, that’s what interest me today. Let’s start with testing the buttons. Unit testing UIButton action Each cell includes a label and two buttons to add or remove to the cart. When tapping a button, it executes a closure matching that action. class CustomCell: UITableViewCell { private(set) lazy var addButton: UIButton = { let button = UIButton() button.setTitle(\"Add\", for: .normal) button.setTitleColor(.white, for: .normal) button.backgroundColor = .orange button.addTarget(self, action: #selector(tapAddButton), for: .touchUpInside) button.translatesAutoresizingMaskIntoConstraints = false return button }() private(set) lazy var removeButton: UIButton = { let button = UIButton() button.setTitle(\"Remove\", for: .normal) button.setTitleColor(.white, for: .normal) button.backgroundColor = .purple button.addTarget(self, action: #selector(tapRemoveButton), for: .touchUpInside) button.translatesAutoresizingMaskIntoConstraints = false return button }() // MARK: - Actions var didTapAdd: (() -\u003e Void)? @objc private func tapAddButton() { didTapAdd?() } var didTapRemove: (() -\u003e Void)? @objc private func tapRemoveButton() { didTapRemove?() } // ... more code ... For this case, I want to add a test that, when the button receive a touchUpInside, will execute the matching closure. Good thing is UIButton has a function that can send actions directly. So let’s use it to test the executed closure. import XCTest @testable import ViewSample class CustomCellTests: XCTestCase { func test_did_tap_add_succeed_when_touch_up_inside() { // Given: let tapAddExpectation = expectation(description: #function) let cell = CustomCell(style: .default, reuseIdentifier: \"id\") cell.didTapAdd = { tapAddExpectation.fulfill() } // When: cell.addButton.sendActions(for: .touchUpInside) // Then: wait(for: [tapAddExpectation], timeout: 0.1) } } For this test, I uses a XCTestExpectation that I pass in the closure to know when it’s executed. It also means that the test will have to wait for it to be completed. Asynchronous test isn’t ideal but the view actually never render, so it should be executed almost instantly. In worse case, when failing, it would be under 0.1 sec delay which is can reasonable time to fail. So far so good. What else can we test around this function? We could make sure another type of action doesn’t execute the closure. func test_did_tap_add_fail_when_touch_down() { // Given: let cell = CustomCell(style: .default, reuseIdentifier: \"id\") cell.didTapAdd = { XCTFail(\"unexpected trigger\") } // When: cell.addButton.sendActions(for: .touchUpInside) } When I execute this test, it first failed due to XCTFail. That’s expected, because the action sent is still touchUpInside, I just want to check that we don’t need to use wait(for: ...) to be failing. Now I know it would fail as expected for another action, then we can edit that action. func test_did_tap_add_fail_when_touch_down() { // Given: let cell = CustomCell(style: .default, reuseIdentifier: \"id\") cell.didTapAdd = { XCTFail(\"unexpected trigger\") } // When: cell.addButton.sendActions(for: .touchDown) } Alright, so we’ve managed to unit test UIButton action within our custom cell without too much trouble so far. Let’s see what other gestures we can cover. Unit testing UIView tap gesture In my ViewController, I have a UIView that user will have to tap to proceed to checkout. I could use a UIButton, but since we want to check other testing (and learn new things), let’s use UIView and UITapGestureRecognizer, just this time. So let’s focus on this area. class ViewController: UIViewController { var viewModel: ViewModelProtocol! init(viewModel: ViewModelProtocol) { super.init(nibName: nil, bundle: nil) self.viewModel = viewModel } lazy var checkoutView: UIView = { let label = UILabel() label.text = \"Checkout\" label.textColor = .white label.textAlignment = .center let view = UIView() view.backgroundColor = .blue view.addSubview(label) label.translatesAutoresizingMaskIntoConstraints = false view.translatesAutoresizingMaskIntoConstraints = false view.addGestureRecognizer(checkoutTapGesture) NSLayoutConstraint.activate([ label.centerYAnchor.constraint(equalTo: view.centerYAnchor), label.centerXAnchor.constraint(equalTo: view.centerXAnchor) ]) return view }() private lazy var checkoutTapGesture = UITapGestureRecognizer(target: self, action: #selector(tapCheckout)) @objc private func tapCheckout() { viewModel.checkout() } // ... more code } As mentioned earlier, I use MVVM design pattern with protocol oriented programming so we can inject our own ViewModelProtocol later on. When the user will tap on the checkoutView, it will execute viewModel.checkout. Let’s get to the testing. import XCTest @testable import ViewSample class ViewControllerTests: XCTestCase { // ... } fileprivate class MockViewModel: ViewModelProtocol { var addFruitCalled = 0 var didCallAddFruit: ((Int) -\u003e Void)? func addFruit(_ text: String) { addFruitCalled += 1 didCallAddFruit?(addFruitCalled) } var removeFruitCalled = 0 var didCallRemoveFruit: ((Int) -\u003e Void)? func removeFruit(_ text: String) { removeFruitCalled += 1 didCallRemoveFruit?(removeFruitCalled) } var checkoutCalled = 0 var didCallCheckout: ((Int) -\u003e Void)? func checkout() { checkoutCalled += 1 didCallCheckout?(checkoutCalled) } } The first part is to create a mock of our ViewModel so we can detect changes. In this case, I uses two properties, one to count how many call and one to get a callback when it’s executed. The second part is to use setUp and tearDown functions of our test class to prepare the testing environment. Finally, we can set our test. class ViewControllerTests: XCTestCase { private var sut: ViewController! fileprivate var viewModel: MockViewModel! override func setUpWithError() throws { try super.setUpWithError() viewModel = MockViewModel() sut = ViewController(viewModel: viewModel) } override func tearDownWithError() throws { viewModel = nil sut = nil try super.tearDownWithError() } func test_tap_checkout() { // Given: let tapCheckoutExpectation = expectation(description: #function) XCTAssertEqual(viewModel.checkoutCalled, 0) viewModel.didCallCheckout = { counter in XCTAssertEqual(counter, 1) tapCheckoutExpectation.fulfill() } let tapGestureRecognizer = sut.checkoutView.gestureRecognizers?.first as? UITapGestureRecognizer XCTAssertNotNil(tapGestureRecognizer, \"Missing tap gesture\") // When: tapGestureRecognizer?.state = .ended // Then: wait(for: [tapCheckoutExpectation], timeout: 0.1) } } Similar to the UIButton unit test, I access the gestures of the view and manually change the state. Passing the number of calls in the closure can also help to detect if there is more than one execution for the same event. Wait, why not just testing checkoutCalled instead of waiting for the expectation. Unfortunately, this doesn’t work. Gestures are still recognized asynchronous and executed on the next runloop. So the following doesn’t work: // Then: XCTAssertEqual(viewModel.checkoutCalled, 1) // 🚫 fail wait(for: [tapCheckoutExpectation], timeout: 0.1) Is there any other way other to keep it synchronous? Well, yes and no. One way could be to try access the private target of the gesture underneath via UIGestureRecognizerTarget. It would look something like this. extension UIGestureRecognizer { func forceTrigger() throws { let gestureRecognizerTarget: AnyClass? = NSClassFromString(\"UIGestureRecognizerTarget\") let targetIvar = class_getInstanceVariable(gestureRecognizerTarget, \"_target\") let actionIvar = class_getInstanceVariable(gestureRecognizerTarget, \"_action\") guard let targets = self.value(forKey: \"targets\") as? [Any] else { throw NSError(domain: \"\", code: 999, userInfo: [NSLocalizedDescriptionKey: \"Cannot access targets\"]) } for gestureTarget in targets { guard let targetIvar = targetIvar, let actionIvar = actionIvar else { continue } if let target = object_getIvar(gestureTarget, targetIvar) as? NSObject, let action = object_getIvar(gestureTarget, actionIvar) as? Selector { // 🚫 fail target.perform(action) return } } throw NSError(domain: \"\", code: 999, userInfo: [NSLocalizedDescriptionKey: \"Couldn't find target or action to execute\"]) } } This code gets access to the private property _action and _target on runtime and manually execute it. Unfortunately, if I can get to the target, the next line object_getIvar(gestureTarget, actionIvar) always crash. No luck. Similar to the ViewModel we could create a MockTapGestureRecognizer to keep track of the action and force the execution, similar to the following. class MockTapGestureRecognizer: UITapGestureRecognizer { var target: Any? var action: Selector? override func addTarget(_ target: Any, action: Selector) { self.target = target self.action = action } override var state: UIGestureRecognizer.State { didSet { forceTriggerAction() } } func forceTriggerAction() { guard let target = target as? NSObject, let action = action else { return } target.perform(action) } } IF that sound safer, this require to expose more properties and function outside of the ViewController. It also require more effort and feel going away of unit testing the gesture execution, but the ViewController construction. That feels wrong. Another solution could be to do some method swizzling but it goes away our goal too. I ideally want to test my code behavior, not alter the whole system to check how it’s executed. Same as before, it doesn’t seem the right approach. If we could find a synchronous solution, it goes against altering too much of our code. Based on the trade-off, it feels the asynchronous test of 0.1 sec does look more balanced solution than any others mentioned. You could make a different decision based on your own need. Unit testing UIView swipe gesture Well, once you got the concept, it’s actually the same aspect for any other gesture. That’s because we’re testing the action, not the actual gesture. So for a swipe, we’re not expected to change location of a CGPoint, we expect the gesture to successfully recognize it, and we check the outcome. // ViewController lazy var checkoutView: UIView = { let label = UILabel() label.text = \"Checkout\" label.textColor = .white label.textAlignment = .center let view = UIView() view.backgroundColor = .blue view.addSubview(label) label.translatesAutoresizingMaskIntoConstraints = false view.translatesAutoresizingMaskIntoConstraints = false view.addGestureRecognizer(checkoutSwipeGesture) NSLayoutConstraint.activate([ label.centerYAnchor.constraint(equalTo: view.centerYAnchor), label.centerXAnchor.constraint(equalTo: view.centerXAnchor) ]) return view }() private lazy var checkoutSwipeGesture: UISwipeGestureRecognizer = UISwipeGestureRecognizer(target: self, action: #selector(swipeCheckout)) // ViewControllerTests func test_swipe_checkout() { // Given: let swipeCheckoutExpectation = expectation(description: #function) XCTAssertEqual(viewModel.checkoutCalled, 0) viewModel.didCallCheckout = { counter in XCTAssertEqual(counter, 1) tapCheckoutExpectation.fulfill() } let swipeGestureRecognizer = sut.checkoutView.gestureRecognizers?.first as? UISwipeGestureRecognizer XCTAssertNotNil(swipeGestureRecognizer, \"Missing tap gesture\") // When: swipeGestureRecognizer?.state = .ended // Then: wait(for: [swipeCheckoutExpectation], timeout: 0.1) } – That’s it for today! We’ve managed to create unit test for different UI component, making sure user actions and gestures under the right condition would execute the right block. This tests make our project a bit safer to side effect and more reliable if we ever have to revisit this bit. This code is available on Github as ViewSample. Happy testing 🛠 Resources: Unit Testing with UIGestureRecognizer (Objective-C)",
  "image": "https://benoitpasquier.com/images/2021/08/unit-test-view-preview.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n              \u003cp\u003eA big part of the developer journey is make sure our code behaves as expected. It’s best practice to setup tests that allow us to test quickly and often that nothing is broken. If unit testing is common practice to check the business logic, we can also extend it to cover some specific UI behaviors. \u003cem\u003eLet’s how to unit test views and gesture in UIKit\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eFor this article, I’ve build a very simple app with fruits to add or remove to my cart.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://benoitpasquier.com/images/2021/08/unit-test-view-sample.png\" alt=\"uni-test-uiview-sample\"/\u003e\u003c/p\u003e\n\u003cp\u003eBefore diving into the code, let’s refresh some testing concepts. In computer science, we can have different layers of testing, each representing a safety-net for the team to make sure everything work as expected:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUnit testing\u003c/strong\u003e: a suite of test that covers a specific self-contained piece of code, a \u003cem\u003eunit\u003c/em\u003e, like a file or a class. If it fails, your unit needs to be fixed.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIntegration testing\u003c/strong\u003e: a suite of test that covers the interaction between two \u003cem\u003eunits\u003c/em\u003e. When failing, the interaction isn’t working as expected.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRegression testing\u003c/strong\u003e: this is the complete suite of test across your project. By running it, we’re making sure the last contribution didn’t break anything else. When failing, the app doesn’t behave as it use to be.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAcceptance testing\u003c/strong\u003e: It’s a higher level of test and most likely performed by the Quality Assurance team to check the new feature meet the requirement. It’s often based on the business / customer / stack-holder needs.  It answers the question \u003cem\u003e“did we build the right thing?”\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFunctional testing / end-to-end testing\u003c/strong\u003e: it describes the functionality itself and answers the question \u003cem\u003e“did we build a working product?”\u003c/em\u003e . It covers more than the acceptance criteria, making sure error-handling and “it shouldn’t happen” scenario actually doesn’t happen.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eIn my case, I want to make sure some gesture and tap on button are executing the right block. So it sits between unit testing / integration testing, depending of each view integration.\u003c/p\u003e\n\u003cp\u003eI’ve used an \u003ca href=\"https://benoitpasquier.com/ios-swift-mvvm-pattern/\"\u003eMVVM architecture design pattern\u003c/a\u003e to make it easier to test each layer. That being said, I’ll stay focused on the View layer, that’s what interest me today.\u003c/p\u003e\n\u003cp\u003eLet’s start with testing the buttons.\u003c/p\u003e\n\u003ch2 id=\"unit-testing-uibutton-action\"\u003eUnit testing UIButton action\u003c/h2\u003e\n\u003cp\u003eEach cell includes a label and two buttons to add or remove to the cart. When tapping a button, it executes a closure matching that action.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eCustomCell\u003c/span\u003e: \u003cspan\u003eUITableViewCell\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprivate\u003c/span\u003e(\u003cspan\u003eset\u003c/span\u003e) \u003cspan\u003elazy\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eaddButton\u003c/span\u003e: \u003cspan\u003eUIButton\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ebutton\u003c/span\u003e = \u003cspan\u003eUIButton\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ebutton\u003c/span\u003e.\u003cspan\u003esetTitle\u003c/span\u003e(\u003cspan\u003e\u0026#34;Add\u0026#34;\u003c/span\u003e, \u003cspan\u003efor\u003c/span\u003e: .\u003cspan\u003enormal\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ebutton\u003c/span\u003e.\u003cspan\u003esetTitleColor\u003c/span\u003e(.\u003cspan\u003ewhite\u003c/span\u003e, \u003cspan\u003efor\u003c/span\u003e: .\u003cspan\u003enormal\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ebutton\u003c/span\u003e.\u003cspan\u003ebackgroundColor\u003c/span\u003e = .\u003cspan\u003eorange\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ebutton\u003c/span\u003e.\u003cspan\u003eaddTarget\u003c/span\u003e(\u003cspan\u003eself\u003c/span\u003e, \u003cspan\u003eaction\u003c/span\u003e: \u003cspan\u003e#selector\u003c/span\u003e(\u003cspan\u003etapAddButton\u003c/span\u003e), \u003cspan\u003efor\u003c/span\u003e: .\u003cspan\u003etouchUpInside\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ebutton\u003c/span\u003e.\u003cspan\u003etranslatesAutoresizingMaskIntoConstraints\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ebutton\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprivate\u003c/span\u003e(\u003cspan\u003eset\u003c/span\u003e) \u003cspan\u003elazy\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eremoveButton\u003c/span\u003e: \u003cspan\u003eUIButton\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ebutton\u003c/span\u003e = \u003cspan\u003eUIButton\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ebutton\u003c/span\u003e.\u003cspan\u003esetTitle\u003c/span\u003e(\u003cspan\u003e\u0026#34;Remove\u0026#34;\u003c/span\u003e, \u003cspan\u003efor\u003c/span\u003e: .\u003cspan\u003enormal\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ebutton\u003c/span\u003e.\u003cspan\u003esetTitleColor\u003c/span\u003e(.\u003cspan\u003ewhite\u003c/span\u003e, \u003cspan\u003efor\u003c/span\u003e: .\u003cspan\u003enormal\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ebutton\u003c/span\u003e.\u003cspan\u003ebackgroundColor\u003c/span\u003e = .\u003cspan\u003epurple\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ebutton\u003c/span\u003e.\u003cspan\u003eaddTarget\u003c/span\u003e(\u003cspan\u003eself\u003c/span\u003e, \u003cspan\u003eaction\u003c/span\u003e: \u003cspan\u003e#selector\u003c/span\u003e(\u003cspan\u003etapRemoveButton\u003c/span\u003e), \u003cspan\u003efor\u003c/span\u003e: .\u003cspan\u003etouchUpInside\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ebutton\u003c/span\u003e.\u003cspan\u003etranslatesAutoresizingMaskIntoConstraints\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ebutton\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// \u003c/span\u003e\u003cspan\u003eMARK:\u003c/span\u003e\u003cspan\u003e - Actions\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edidTapAdd\u003c/span\u003e: (() -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e)?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e@objc\u003c/span\u003e \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etapAddButton\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003edidTapAdd\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edidTapRemove\u003c/span\u003e: (() -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e)?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e@objc\u003c/span\u003e \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etapRemoveButton\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003edidTapRemove\u003c/span\u003e?()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// ... more code ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFor this case, I want to add a test that, when the button receive a \u003ccode\u003etouchUpInside\u003c/code\u003e, will execute the matching closure.\u003c/p\u003e\n\u003cp\u003eGood thing is \u003ccode\u003eUIButton\u003c/code\u003e has a function that can send actions directly. So let’s use it to test the executed closure.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eXCTest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e@\u003cspan\u003etestable\u003c/span\u003e \u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eViewSample\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eCustomCellTests\u003c/span\u003e: \u003cspan\u003eXCTestCase\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etest_did_tap_add_succeed_when_touch_up_inside\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// Given:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etapAddExpectation\u003c/span\u003e = \u003cspan\u003eexpectation\u003c/span\u003e(\u003cspan\u003edescription\u003c/span\u003e: \u003cspan\u003e#function\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ecell\u003c/span\u003e = \u003cspan\u003eCustomCell\u003c/span\u003e(\u003cspan\u003estyle\u003c/span\u003e: .\u003cspan\u003edefault\u003c/span\u003e, \u003cspan\u003ereuseIdentifier\u003c/span\u003e: \u003cspan\u003e\u0026#34;id\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ecell\u003c/span\u003e.\u003cspan\u003edidTapAdd\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003etapAddExpectation\u003c/span\u003e.\u003cspan\u003efulfill\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// When:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ecell\u003c/span\u003e.\u003cspan\u003eaddButton\u003c/span\u003e.\u003cspan\u003esendActions\u003c/span\u003e(\u003cspan\u003efor\u003c/span\u003e: .\u003cspan\u003etouchUpInside\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// Then:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ewait\u003c/span\u003e(\u003cspan\u003efor\u003c/span\u003e: [\u003cspan\u003etapAddExpectation\u003c/span\u003e], \u003cspan\u003etimeout\u003c/span\u003e: \u003cspan\u003e0.1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFor this test, I uses a \u003ccode\u003eXCTestExpectation\u003c/code\u003e that I pass in the closure to know when it’s executed. It also means that the test will have to wait for it to be completed.\u003c/p\u003e\n\u003cp\u003eAsynchronous test isn’t ideal but the view actually never render, so it should be executed almost instantly. In worse case, when failing, it would be under \u003ccode\u003e0.1\u003c/code\u003e sec delay which is can reasonable time to fail.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSo far so good\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eWhat else can we test around this function? We could make sure another type of action doesn’t execute the closure.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etest_did_tap_add_fail_when_touch_down\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// Given:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ecell\u003c/span\u003e = \u003cspan\u003eCustomCell\u003c/span\u003e(\u003cspan\u003estyle\u003c/span\u003e: .\u003cspan\u003edefault\u003c/span\u003e, \u003cspan\u003ereuseIdentifier\u003c/span\u003e: \u003cspan\u003e\u0026#34;id\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecell\u003c/span\u003e.\u003cspan\u003edidTapAdd\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eXCTFail\u003c/span\u003e(\u003cspan\u003e\u0026#34;unexpected trigger\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// When:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecell\u003c/span\u003e.\u003cspan\u003eaddButton\u003c/span\u003e.\u003cspan\u003esendActions\u003c/span\u003e(\u003cspan\u003efor\u003c/span\u003e: .\u003cspan\u003etouchUpInside\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWhen I execute this test, it first failed due to \u003ccode\u003eXCTFail\u003c/code\u003e. \u003cem\u003eThat’s expected\u003c/em\u003e, because the action sent is still \u003ccode\u003etouchUpInside\u003c/code\u003e, I just want to check that we don’t need to use \u003ccode\u003ewait(for: ...)\u003c/code\u003e to be failing.\u003c/p\u003e\n\u003cp\u003eNow I know it would fail as expected for another action, then we can edit that action.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etest_did_tap_add_fail_when_touch_down\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// Given:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ecell\u003c/span\u003e = \u003cspan\u003eCustomCell\u003c/span\u003e(\u003cspan\u003estyle\u003c/span\u003e: .\u003cspan\u003edefault\u003c/span\u003e, \u003cspan\u003ereuseIdentifier\u003c/span\u003e: \u003cspan\u003e\u0026#34;id\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecell\u003c/span\u003e.\u003cspan\u003edidTapAdd\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eXCTFail\u003c/span\u003e(\u003cspan\u003e\u0026#34;unexpected trigger\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// When:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecell\u003c/span\u003e.\u003cspan\u003eaddButton\u003c/span\u003e.\u003cspan\u003esendActions\u003c/span\u003e(\u003cspan\u003efor\u003c/span\u003e: .\u003cspan\u003etouchDown\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAlright, so we’ve managed to unit test \u003ccode\u003eUIButton\u003c/code\u003e action within our custom cell without too much trouble so far. \u003cem\u003eLet’s see what other gestures we can cover.\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"unit-testing-uiview-tap-gesture\"\u003eUnit testing UIView tap gesture\u003c/h2\u003e\n\u003cp\u003eIn my \u003ccode\u003eViewController\u003c/code\u003e, I have a \u003ccode\u003eUIView\u003c/code\u003e that user will have to tap to proceed to checkout. I could use a UIButton, but since we want to check other testing (and learn new things), let’s use \u003ccode\u003eUIView\u003c/code\u003e and \u003ccode\u003eUITapGestureRecognizer\u003c/code\u003e, just this time. So let’s focus on this area.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eViewController\u003c/span\u003e: \u003cspan\u003eUIViewController\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eviewModel\u003c/span\u003e: \u003cspan\u003eViewModelProtocol\u003c/span\u003e!\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003eviewModel\u003c/span\u003e: \u003cspan\u003eViewModelProtocol\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003esuper\u003c/span\u003e.\u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003enibName\u003c/span\u003e: \u003cspan\u003enil\u003c/span\u003e, \u003cspan\u003ebundle\u003c/span\u003e: \u003cspan\u003enil\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eviewModel\u003c/span\u003e = \u003cspan\u003eviewModel\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elazy\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003echeckoutView\u003c/span\u003e: \u003cspan\u003eUIView\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003elabel\u003c/span\u003e = \u003cspan\u003eUILabel\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003etext\u003c/span\u003e = \u003cspan\u003e\u0026#34;Checkout\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003etextColor\u003c/span\u003e = .\u003cspan\u003ewhite\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003etextAlignment\u003c/span\u003e = .\u003cspan\u003ecenter\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eview\u003c/span\u003e = \u003cspan\u003eUIView\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003ebackgroundColor\u003c/span\u003e = .\u003cspan\u003eblue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eaddSubview\u003c/span\u003e(\u003cspan\u003elabel\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003etranslatesAutoresizingMaskIntoConstraints\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003etranslatesAutoresizingMaskIntoConstraints\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eaddGestureRecognizer\u003c/span\u003e(\u003cspan\u003echeckoutTapGesture\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eNSLayoutConstraint\u003c/span\u003e.\u003cspan\u003eactivate\u003c/span\u003e([\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003ecenterYAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalTo\u003c/span\u003e: \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003ecenterYAnchor\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003ecenterXAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalTo\u003c/span\u003e: \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003ecenterXAnchor\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        ])\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eview\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003elazy\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003echeckoutTapGesture\u003c/span\u003e = \u003cspan\u003eUITapGestureRecognizer\u003c/span\u003e(\u003cspan\u003etarget\u003c/span\u003e: \u003cspan\u003eself\u003c/span\u003e, \u003cspan\u003eaction\u003c/span\u003e: \u003cspan\u003e#selector\u003c/span\u003e(\u003cspan\u003etapCheckout\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e@objc\u003c/span\u003e \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etapCheckout\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eviewModel\u003c/span\u003e.\u003cspan\u003echeckout\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// ... more code\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAs mentioned earlier, I use MVVM design pattern with \u003ca href=\"https://benoitpasquier.com/introduction-protocol-oriented-programming-swift/\"\u003eprotocol oriented programming\u003c/a\u003e so we can inject our own \u003ccode\u003eViewModelProtocol\u003c/code\u003e later on. When the user will tap on the \u003ccode\u003echeckoutView\u003c/code\u003e, it will execute \u003ccode\u003eviewModel.checkout\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eLet’s get to the testing.\u003c/em\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eXCTest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e@\u003cspan\u003etestable\u003c/span\u003e \u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eViewSample\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eViewControllerTests\u003c/span\u003e: \u003cspan\u003eXCTestCase\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efileprivate\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMockViewModel\u003c/span\u003e: \u003cspan\u003eViewModelProtocol\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eaddFruitCalled\u003c/span\u003e = \u003cspan\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edidCallAddFruit\u003c/span\u003e: ((\u003cspan\u003eInt\u003c/span\u003e) -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e)?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eaddFruit\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003etext\u003c/span\u003e: \u003cspan\u003eString\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eaddFruitCalled\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003edidCallAddFruit\u003c/span\u003e?(\u003cspan\u003eaddFruitCalled\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eremoveFruitCalled\u003c/span\u003e = \u003cspan\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edidCallRemoveFruit\u003c/span\u003e: ((\u003cspan\u003eInt\u003c/span\u003e) -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e)?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eremoveFruit\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003etext\u003c/span\u003e: \u003cspan\u003eString\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eremoveFruitCalled\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003edidCallRemoveFruit\u003c/span\u003e?(\u003cspan\u003eremoveFruitCalled\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003echeckoutCalled\u003c/span\u003e = \u003cspan\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003edidCallCheckout\u003c/span\u003e: ((\u003cspan\u003eInt\u003c/span\u003e) -\u0026gt; \u003cspan\u003eVoid\u003c/span\u003e)?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003echeckout\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003echeckoutCalled\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003edidCallCheckout\u003c/span\u003e?(\u003cspan\u003echeckoutCalled\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe first part is to create a mock of our \u003ccode\u003eViewModel\u003c/code\u003e so we can detect changes. In this case, I uses two properties, one to count how many call and one to get a callback when it’s executed.\u003c/p\u003e\n\u003cp\u003eThe second part is to use \u003ccode\u003esetUp\u003c/code\u003e and \u003ccode\u003etearDown\u003c/code\u003e functions of our test class to prepare the testing environment.\u003c/p\u003e\n\u003cp\u003eFinally, we can set our test.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eViewControllerTests\u003c/span\u003e: \u003cspan\u003eXCTestCase\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003esut\u003c/span\u003e: \u003cspan\u003eViewController\u003c/span\u003e!\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efileprivate\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eviewModel\u003c/span\u003e: \u003cspan\u003eMockViewModel\u003c/span\u003e!\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esetUpWithError\u003c/span\u003e() \u003cspan\u003ethrows\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003esuper\u003c/span\u003e.\u003cspan\u003esetUpWithError\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eviewModel\u003c/span\u003e = \u003cspan\u003eMockViewModel\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003esut\u003c/span\u003e = \u003cspan\u003eViewController\u003c/span\u003e(\u003cspan\u003eviewModel\u003c/span\u003e: \u003cspan\u003eviewModel\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etearDownWithError\u003c/span\u003e() \u003cspan\u003ethrows\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eviewModel\u003c/span\u003e = \u003cspan\u003enil\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003esut\u003c/span\u003e = \u003cspan\u003enil\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003esuper\u003c/span\u003e.\u003cspan\u003etearDownWithError\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etest_tap_checkout\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// Given:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etapCheckoutExpectation\u003c/span\u003e = \u003cspan\u003eexpectation\u003c/span\u003e(\u003cspan\u003edescription\u003c/span\u003e: \u003cspan\u003e#function\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eXCTAssertEqual\u003c/span\u003e(\u003cspan\u003eviewModel\u003c/span\u003e.\u003cspan\u003echeckoutCalled\u003c/span\u003e, \u003cspan\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eviewModel\u003c/span\u003e.\u003cspan\u003edidCallCheckout\u003c/span\u003e = { \u003cspan\u003ecounter\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eXCTAssertEqual\u003c/span\u003e(\u003cspan\u003ecounter\u003c/span\u003e, \u003cspan\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003etapCheckoutExpectation\u003c/span\u003e.\u003cspan\u003efulfill\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etapGestureRecognizer\u003c/span\u003e = \u003cspan\u003esut\u003c/span\u003e.\u003cspan\u003echeckoutView\u003c/span\u003e.\u003cspan\u003egestureRecognizers\u003c/span\u003e?.\u003cspan\u003efirst\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e? \u003cspan\u003eUITapGestureRecognizer\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eXCTAssertNotNil\u003c/span\u003e(\u003cspan\u003etapGestureRecognizer\u003c/span\u003e, \u003cspan\u003e\u0026#34;Missing tap gesture\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// When:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003etapGestureRecognizer\u003c/span\u003e?.\u003cspan\u003estate\u003c/span\u003e = .\u003cspan\u003eended\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// Then:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ewait\u003c/span\u003e(\u003cspan\u003efor\u003c/span\u003e: [\u003cspan\u003etapCheckoutExpectation\u003c/span\u003e], \u003cspan\u003etimeout\u003c/span\u003e: \u003cspan\u003e0.1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSimilar to the \u003ccode\u003eUIButton\u003c/code\u003e unit test, I access the gestures of the view and manually change the state.\u003c/p\u003e\n\u003cp\u003ePassing the number of calls in the closure can also help to detect if there is more than one execution for the same event.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWait, why not just testing \u003ccode\u003echeckoutCalled\u003c/code\u003e instead of waiting for the expectation.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eUnfortunately, this doesn’t work. Gestures are still recognized asynchronous and executed on the next runloop. So the following doesn’t work:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Then:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eXCTAssertEqual\u003c/span\u003e(\u003cspan\u003eviewModel\u003c/span\u003e.\u003cspan\u003echeckoutCalled\u003c/span\u003e, \u003cspan\u003e1\u003c/span\u003e) \u003cspan\u003e// 🚫 fail\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ewait\u003c/span\u003e(\u003cspan\u003efor\u003c/span\u003e: [\u003cspan\u003etapCheckoutExpectation\u003c/span\u003e], \u003cspan\u003etimeout\u003c/span\u003e: \u003cspan\u003e0.1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003eIs there any other way other to keep it synchronous?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cem\u003eWell\u003c/em\u003e, yes and no.\u003c/p\u003e\n\u003cp\u003eOne way could be to try access the private target of the gesture underneath via \u003ccode\u003eUIGestureRecognizerTarget\u003c/code\u003e. It would look something like this.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eUIGestureRecognizer\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eforceTrigger\u003c/span\u003e() \u003cspan\u003ethrows\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003egestureRecognizerTarget\u003c/span\u003e: \u003cspan\u003eAnyClass\u003c/span\u003e? = \u003cspan\u003eNSClassFromString\u003c/span\u003e(\u003cspan\u003e\u0026#34;UIGestureRecognizerTarget\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etargetIvar\u003c/span\u003e = \u003cspan\u003eclass_getInstanceVariable\u003c/span\u003e(\u003cspan\u003egestureRecognizerTarget\u003c/span\u003e, \u003cspan\u003e\u0026#34;_target\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eactionIvar\u003c/span\u003e = \u003cspan\u003eclass_getInstanceVariable\u003c/span\u003e(\u003cspan\u003egestureRecognizerTarget\u003c/span\u003e, \u003cspan\u003e\u0026#34;_action\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etargets\u003c/span\u003e = \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003evalue\u003c/span\u003e(\u003cspan\u003eforKey\u003c/span\u003e: \u003cspan\u003e\u0026#34;targets\u0026#34;\u003c/span\u003e) \u003cspan\u003eas\u003c/span\u003e? [\u003cspan\u003eAny\u003c/span\u003e] \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003eNSError\u003c/span\u003e(\u003cspan\u003edomain\u003c/span\u003e: \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e, \u003cspan\u003ecode\u003c/span\u003e: \u003cspan\u003e999\u003c/span\u003e, \u003cspan\u003euserInfo\u003c/span\u003e: [\u003cspan\u003eNSLocalizedDescriptionKey\u003c/span\u003e: \u003cspan\u003e\u0026#34;Cannot access targets\u0026#34;\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003egestureTarget\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003etargets\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etargetIvar\u003c/span\u003e = \u003cspan\u003etargetIvar\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e               \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eactionIvar\u003c/span\u003e = \u003cspan\u003eactionIvar\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etarget\u003c/span\u003e = \u003cspan\u003eobject_getIvar\u003c/span\u003e(\u003cspan\u003egestureTarget\u003c/span\u003e, \u003cspan\u003etargetIvar\u003c/span\u003e) \u003cspan\u003eas\u003c/span\u003e? \u003cspan\u003eNSObject\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e               \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eaction\u003c/span\u003e = \u003cspan\u003eobject_getIvar\u003c/span\u003e(\u003cspan\u003egestureTarget\u003c/span\u003e, \u003cspan\u003eactionIvar\u003c/span\u003e) \u003cspan\u003eas\u003c/span\u003e? \u003cspan\u003eSelector\u003c/span\u003e { \u003cspan\u003e// 🚫 fail\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003etarget\u003c/span\u003e.\u003cspan\u003eperform\u003c/span\u003e(\u003cspan\u003eaction\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003eNSError\u003c/span\u003e(\u003cspan\u003edomain\u003c/span\u003e: \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e, \u003cspan\u003ecode\u003c/span\u003e: \u003cspan\u003e999\u003c/span\u003e, \u003cspan\u003euserInfo\u003c/span\u003e: [\u003cspan\u003eNSLocalizedDescriptionKey\u003c/span\u003e: \u003cspan\u003e\u0026#34;Couldn\u0026#39;t find target or action to execute\u0026#34;\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis code gets access to the private property \u003ccode\u003e_action\u003c/code\u003e and \u003ccode\u003e_target\u003c/code\u003e on runtime and manually execute it. Unfortunately, if I can get to the target, the next line \u003ccode\u003eobject_getIvar(gestureTarget, actionIvar)\u003c/code\u003e always crash. \u003cem\u003eNo luck.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eSimilar to the \u003ccode\u003eViewModel\u003c/code\u003e we could create a \u003ccode\u003eMockTapGestureRecognizer\u003c/code\u003e to keep track of the action and force the execution, similar to the following.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMockTapGestureRecognizer\u003c/span\u003e: \u003cspan\u003eUITapGestureRecognizer\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003etarget\u003c/span\u003e: \u003cspan\u003eAny\u003c/span\u003e?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eaction\u003c/span\u003e: \u003cspan\u003eSelector\u003c/span\u003e?\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eaddTarget\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003etarget\u003c/span\u003e: \u003cspan\u003eAny\u003c/span\u003e, \u003cspan\u003eaction\u003c/span\u003e: \u003cspan\u003eSelector\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003etarget\u003c/span\u003e = \u003cspan\u003etarget\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eaction\u003c/span\u003e = \u003cspan\u003eaction\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e: \u003cspan\u003eUIGestureRecognizer\u003c/span\u003e.\u003cspan\u003eState\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003edidSet\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eforceTriggerAction\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eforceTriggerAction\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003etarget\u003c/span\u003e = \u003cspan\u003etarget\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e? \u003cspan\u003eNSObject\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e              \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eaction\u003c/span\u003e = \u003cspan\u003eaction\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e { \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003etarget\u003c/span\u003e.\u003cspan\u003eperform\u003c/span\u003e(\u003cspan\u003eaction\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIF that sound safer, this require to expose more properties and function outside of the ViewController. It also require more effort and feel going away of unit testing the gesture execution, but the \u003ccode\u003eViewController\u003c/code\u003e construction. \u003cem\u003eThat feels wrong.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eAnother solution could be to do some \u003cem\u003emethod swizzling\u003c/em\u003e but it goes away our goal too. I ideally want to test my code behavior, not alter the whole system to check how it’s executed. Same as before, it doesn’t seem the right approach.\u003c/p\u003e\n\u003cp\u003eIf we could find a synchronous solution, it goes against altering too much of our code. Based on the trade-off, it feels the asynchronous test of \u003ccode\u003e0.1\u003c/code\u003e sec does look more balanced solution than any others mentioned. You could make a different decision based on your own need.\u003c/p\u003e\n\u003ch2 id=\"unit-testing-uiview-swipe-gesture\"\u003eUnit testing UIView swipe gesture\u003c/h2\u003e\n\u003cp\u003eWell, once you got the concept, it’s actually the same aspect for any other gesture. That’s because we’re testing the action, not the actual gesture.\u003c/p\u003e\n\u003cp\u003eSo for a swipe, we’re not expected to change location of a \u003ccode\u003eCGPoint\u003c/code\u003e, we expect the gesture to successfully recognize it, and we check the outcome.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// ViewController\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elazy\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003echeckoutView\u003c/span\u003e: \u003cspan\u003eUIView\u003c/span\u003e = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003elabel\u003c/span\u003e = \u003cspan\u003eUILabel\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003etext\u003c/span\u003e = \u003cspan\u003e\u0026#34;Checkout\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003etextColor\u003c/span\u003e = .\u003cspan\u003ewhite\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003etextAlignment\u003c/span\u003e = .\u003cspan\u003ecenter\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eview\u003c/span\u003e = \u003cspan\u003eUIView\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003ebackgroundColor\u003c/span\u003e = .\u003cspan\u003eblue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eaddSubview\u003c/span\u003e(\u003cspan\u003elabel\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003etranslatesAutoresizingMaskIntoConstraints\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003etranslatesAutoresizingMaskIntoConstraints\u003c/span\u003e = \u003cspan\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003eaddGestureRecognizer\u003c/span\u003e(\u003cspan\u003echeckoutSwipeGesture\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eNSLayoutConstraint\u003c/span\u003e.\u003cspan\u003eactivate\u003c/span\u003e([\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003ecenterYAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalTo\u003c/span\u003e: \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003ecenterYAnchor\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003elabel\u003c/span\u003e.\u003cspan\u003ecenterXAnchor\u003c/span\u003e.\u003cspan\u003econstraint\u003c/span\u003e(\u003cspan\u003eequalTo\u003c/span\u003e: \u003cspan\u003eview\u003c/span\u003e.\u003cspan\u003ecenterXAnchor\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    ])\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eview\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003elazy\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003echeckoutSwipeGesture\u003c/span\u003e: \u003cspan\u003eUISwipeGestureRecognizer\u003c/span\u003e = \u003cspan\u003eUISwipeGestureRecognizer\u003c/span\u003e(\u003cspan\u003etarget\u003c/span\u003e: \u003cspan\u003eself\u003c/span\u003e, \u003cspan\u003eaction\u003c/span\u003e: \u003cspan\u003e#selector\u003c/span\u003e(\u003cspan\u003eswipeCheckout\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// ViewControllerTests\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etest_swipe_checkout\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// Given:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eswipeCheckoutExpectation\u003c/span\u003e = \u003cspan\u003eexpectation\u003c/span\u003e(\u003cspan\u003edescription\u003c/span\u003e: \u003cspan\u003e#function\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eXCTAssertEqual\u003c/span\u003e(\u003cspan\u003eviewModel\u003c/span\u003e.\u003cspan\u003echeckoutCalled\u003c/span\u003e, \u003cspan\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eviewModel\u003c/span\u003e.\u003cspan\u003edidCallCheckout\u003c/span\u003e = { \u003cspan\u003ecounter\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eXCTAssertEqual\u003c/span\u003e(\u003cspan\u003ecounter\u003c/span\u003e, \u003cspan\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003etapCheckoutExpectation\u003c/span\u003e.\u003cspan\u003efulfill\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eswipeGestureRecognizer\u003c/span\u003e = \u003cspan\u003esut\u003c/span\u003e.\u003cspan\u003echeckoutView\u003c/span\u003e.\u003cspan\u003egestureRecognizers\u003c/span\u003e?.\u003cspan\u003efirst\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e? \u003cspan\u003eUISwipeGestureRecognizer\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eXCTAssertNotNil\u003c/span\u003e(\u003cspan\u003eswipeGestureRecognizer\u003c/span\u003e, \u003cspan\u003e\u0026#34;Missing tap gesture\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// When:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eswipeGestureRecognizer\u003c/span\u003e?.\u003cspan\u003estate\u003c/span\u003e = .\u003cspan\u003eended\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// Then:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ewait\u003c/span\u003e(\u003cspan\u003efor\u003c/span\u003e: [\u003cspan\u003eswipeCheckoutExpectation\u003c/span\u003e], \u003cspan\u003etimeout\u003c/span\u003e: \u003cspan\u003e0.1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e–\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThat’s it for today!\u003c/em\u003e We’ve managed to create unit test for different UI component, making sure user actions and gestures under the right condition would execute the right block. This tests make our project a bit safer to side effect and more reliable if we ever have to revisit this bit.\u003c/p\u003e\n\u003cp\u003eThis code is available on Github as \u003ca href=\"https://github.com/popei69/samples\"\u003eViewSample\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eHappy testing 🛠\u003c/em\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eResources:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://darjeelingsteve.medium.com/unit-testing-with-uigesturerecognizer-8342ae1a784e\"\u003eUnit Testing with UIGestureRecognizer (Objective-C)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n              \n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2021-08-20T08:00:00Z",
  "modifiedTime": "2021-08-20T08:00:00Z"
}
