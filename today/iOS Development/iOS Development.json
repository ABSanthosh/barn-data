[
  {
    "id": "fc2e7052-3a5d-42d8-ab0f-14bdbed17d07",
    "title": "Re: Music Year-End Lists",
    "link": "https://tyler.io/2024/12/re-music-year-end-lists/",
    "description": "What should have been an email is now this blog post listing my top music albums from 2024. I'm not sure what to make of them other than to notice it's a much louder collection of artists than in past years. Why louder? Well, _gestures wildly at the world_",
    "author": "Tyler",
    "published": "Thu, 19 Dec 2024 04:53:11 +0000",
    "image": "",
    "source": "https://tyler.io/feed/",
    "categories": [
      "Uncategorized"
    ]
  },
  {
    "id": "2e423ccf-fa5c-4d7c-9756-f58097520dc8",
    "title": "Steve",
    "link": "https://tyler.io/2024/12/steve/",
    "description": "An eighteen hour family road trip the week before Thanksgiving certainly gives your mind time to wander and the opportunity to play. So, let's play. Steve is a new, casual, puzzle game for your iPhone, iPad, Mac, and Vision Pro. The goal is simple. Fill the grid using the correct number of blocks. As my family and friends and (so far) five-hundred strangers will tell you, it's easy to learn. But annoyingly difficult to master.",
    "author": "Tyler",
    "published": "Tue, 17 Dec 2024 20:56:29 +0000",
    "image": "https://cdn.tyler.io/wp-content/uploads/2024/12/two-up-1-220x300.png",
    "source": "https://tyler.io/feed/",
    "categories": [
      "Uncategorized"
    ]
  },
  {
    "id": "0472a5e9-8a93-4f60-84d9-7b88362df311",
    "title": "Scalable Continuous Integration for iOS",
    "link": "https://albertodebortoli.com/2024/01/03/scalable-continuous-integration-for-ios/",
    "description": "How Just Eat Takeaway.com leverage AWS, Packer, Terraform and GitHub Actions to manage a CI stack of macOS runners.",
    "author": "Alberto De Bortoli",
    "published": "Wed, 03 Jan 2024 22:26:50 GMT",
    "image": "https://albertodebortoli.com/content/images/2024/01/1_SaGE67XSSeflkTKknVOHbg.webp",
    "source": "https://albertodebortoli.com/rss/",
    "categories": [
      "CI",
      "mobile",
      "iOS",
      "AWS",
      "macOS"
    ]
  },
  {
    "id": "d05381fc-b584-4f2e-8037-015093ffa490",
    "title": "The idea of a Fastlane replacement",
    "link": "https://albertodebortoli.com/2023/10/29/the-idea-of-a-fastlane-replacement/",
    "description": "PreludeFastlane is widely used by iOS teams all around the world. It became the standard de facto to automate common tasks such as building apps, running tests, and uploading builds to App Store Connect. Fastlane has been recently moved under the Mobile Native Foundation which is amazing as Google",
    "author": "Alberto De Bortoli",
    "published": "Sun, 29 Oct 2023 22:57:38 GMT",
    "image": "https://images.unsplash.com/photo-1647118762210-393b52e96fbc?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=M3wxMTc3M3wwfDF8c2VhcmNofDE4fHxzdGVsbGFyfGVufDB8fHx8MTY5ODYxODcwNXww\u0026ixlib=rb-4.0.3\u0026q=80\u0026w=2000",
    "source": "https://albertodebortoli.com/rss/",
    "categories": null
  },
  {
    "id": "0be29f82-2719-47de-86b6-875d9f679333",
    "title": "Swift 6 suitable notification observers in iOS",
    "link": "https://augmentedcode.io/2024/11/18/swift-6-friendlier-notification-observers/",
    "description": "The author discusses challenges managing side projects, specifically updating SignalPath to Swift 6. They encountered errors related to multiple notification observations but resolved them by shifting to publishers, avoiding sendable closure issues. Although the new approach risks background thread notifications, the compiler is satisfied with the adjustments made to the code.",
    "author": "Toomas Vahter",
    "published": "Mon, 18 Nov 2024 16:00:00 +0000",
    "image": "https://2.gravatar.com/avatar/e55a8cd331ba727a325fb2029717f9d584df498403c1462d032f2fa0be8e4777?s=96\u0026d=identicon\u0026r=G",
    "source": "https://augmentedcode.io/feed/",
    "categories": [
      "iOS",
      "Swift"
    ]
  },
  {
    "id": "f7bb45d1-979c-45bb-8959-41686aa76891",
    "title": "AnyClass protocol and Objective-C methods",
    "link": "https://augmentedcode.io/2024/11/04/anyclass-protocol-and-objective-c-methods/",
    "description": "AnyClass is a protocol all classes conform to and it comes with a feature I was not aware of. But first, how to I ended up with using AnyClass. While working on code using CoreData, I needed a way to enumerate all the CoreData entities and call a static function on them. If that function […]",
    "author": "Toomas Vahter",
    "published": "Mon, 04 Nov 2024 16:00:00 +0000",
    "image": "https://2.gravatar.com/avatar/e55a8cd331ba727a325fb2029717f9d584df498403c1462d032f2fa0be8e4777?s=96\u0026d=identicon\u0026r=G",
    "source": "https://augmentedcode.io/feed/",
    "categories": [
      "iOS",
      "Swift",
      "AnyClass"
    ]
  },
  {
    "id": "4a98eaa8-8ad3-479a-98cc-8a92fd7977c7",
    "title": "From Engineer to Manager: A Year of Growth and Transformation",
    "link": "https://benoitpasquier.com/2023/06/from-engineer-to-manager-a-year-of-growth-and-transformation/",
    "description": "It feels like it was yesterday when I became an engineering manager but it has been almost a year. I want to take this time to reflect on the challenges and learnings from this journey.",
    "author": "",
    "published": "Sun, 11 Jun 2023 06:00:00 +0000",
    "image": "",
    "source": "https://benoitpasquier.com/index.xml",
    "categories": null
  },
  {
    "id": "e68ae3d2-7643-4a33-981f-7240167c6cb8",
    "title": "Things to know before becoming an Engineering Manager",
    "link": "https://benoitpasquier.com/2023/02/things-to-know-before-becoming-an-engineering-manager/",
    "description": "The journey from individual contributor to engineering manager isn’t always straightforward. Today, I’ll share what it means to become an engineering manager from my point of view, and a few important points to be aware of before making this transition.",
    "author": "",
    "published": "Sun, 19 Feb 2023 06:00:00 +0000",
    "image": "",
    "source": "https://benoitpasquier.com/index.xml",
    "categories": null
  },
  {
    "id": "55b738d5-715a-4c1e-ac3b-4659587d34d6",
    "title": "iOS Accessibility Values",
    "link": "https://mobilea11y.com/blog/accessibility-values/",
    "description": "For iOS, Accessibility values are one of the building blocks of how Accessibility works on the platform, along with traits, labels, hints, and showing/hiding elements. If you’re familiar with WCAG or web accessibility, accessibility values are the value part of WCAG 4.1.2: Name, Role, Value. Values Not every element in your view will have a value - in fact, most won’t. Any element that ‘contains’ some data, data that is not included in the element’s label requires an accessibility value to be set.",
    "author": "",
    "published": "Sun, 19 Jun 2022 10:30:56 +0000",
    "image": "",
    "source": "https://mobilea11y.com/index.xml",
    "categories": null
  },
  {
    "id": "bff33d30-8828-4cfa-855a-c5c54df95c9f",
    "title": "iOS UIKit Accessibility traits",
    "link": "https://mobilea11y.com/blog/traits/",
    "description": "Accessibility traits on iOS is the system by which assistive technologies know how to present your interface to your users. The exact experience will vary between assistive technologies, in some cases they may change the intonation of what VoiceOver reads, or add additional options for navigation, sometimes they will disable that assistive technology from accessing the element, or change how the assistive tech functions. They are the ‘Role’ part of the fundamental rule of making something accessible to screen readers - WCAG’s 4.",
    "author": "",
    "published": "Fri, 13 Aug 2021 07:30:56 +0000",
    "image": "",
    "source": "https://mobilea11y.com/index.xml",
    "categories": null
  },
  {
    "id": "9929ada1-9d65-4033-b06c-7447bff53a95",
    "title": "Introducing Plinky: My Love Letter To Links",
    "link": "https://fabisevi.ch/2024/05/09/introducing-plinky/",
    "description": "The post below was written by me, originally featured on the Plinky blog. To celebrate the launch of Plinky you can get 50% off of a yearly subscription by redeeming this offer: plinky.app/offer/REDPANDA There are few words I've ever said more excitedly than these: I want to tell you about my latest app, Plinky. Plinky makes it incredibly easy to do something we do every day, save links for later. You may already have a way to save links, I know I've tried every method under the sun, to the point where I decided to build my own app. That app is Plinky, and today it's available to download on the App Store. Over the last 18 months people have been loving Plinky, because it fixes the same problems I ran into when I've tried to save links in the past.",
    "author": "Joe Fabisevich",
    "published": "Thu, 09 May 2024 00:00:00 GMT",
    "image": "/static/c3d9146a8edf380ee267c61558f3a91b/ec7ce/plinky-screenshots.jpg",
    "source": "https://www.fabisevi.ch/feed.xml",
    "categories": null
  },
  {
    "id": "dcd17bb8-1dfc-4cb5-94a0-d6969dcf2eb1",
    "title": "The Reasoning Computer",
    "link": "https://fabisevi.ch/2023/11/10/the-reasoning-computer/",
    "description": "The Turing test is dead, and we killed it. The Turing test is a test of a machine's ability to exhibit intelligent behavior equivalent to, or indistinguishable from, that of a human. From the 1940s 1 to the 2010s people programmed computers, and computers could only do what they were programmed to do in a rules-based deterministic manner. Sometimes a person would program the computer and it would do something unexpected, but 100 out of 100 times the computer was doing what it was programmed to do whether the person liked it or not. While there has been experimentation with what today we call AI since the 1950s, those machines were a long ways away from passing the Turing test. Why does using ChatGPT feel more like a conversation with the smartest person you know than a computer? It's because ChatGPT doesn't solve problems deterministically the way a programmed computer does, it solves them probabilistically. 2 ChatGPT demonstrates the ability to think about something in a logical, sensible way, the definition of reasoning. 3 We've created something completely new here, a reasoning computer. 4",
    "author": "Joe Fabisevich",
    "published": "Fri, 10 Nov 2023 00:00:00 GMT",
    "image": "",
    "source": "https://www.fabisevi.ch/feed.xml",
    "categories": null
  },
  {
    "id": "633b0f42-46c1-4c27-bf6c-e07598a2762e",
    "title": "Get ready with the latest beta releases",
    "link": "https://developer.apple.com/news/?id=rcvik60x",
    "description": "The beta versions of iOS 18.3, iPadOS 18.3, macOS 15.3, tvOS 18.3, visionOS 2.3, and watchOS 11.3 are now available. Get your apps ready by confirming they work as expected on these releases. And to take advantage of the advancements in the latest SDKs, make sure to build and test with Xcode 16.2.View downloads and release notes Learn about testing a beta OS Learn about sending feedback",
    "author": "",
    "published": "Mon, 16 Dec 2024 11:31:12 PST",
    "image": "",
    "source": "https://developer.apple.com/news/rss/news.rss",
    "categories": null
  },
  {
    "id": "7be55258-9ef9-4fe0-8200-b622e311e6d4",
    "title": "App Store Award winners announced",
    "link": "https://developer.apple.com/news/?id=t9ha5xqc",
    "description": "Join us in celebrating the outstanding work of these developers from around the world.Meet the winners",
    "author": "",
    "published": "Wed, 11 Dec 2024 09:00:25 PST",
    "image": "https://devimages-cdn.apple.com/wwdc-services/articles/images/572DF998-E42E-4EA8-A2E2-EE9F05DF58B6/2048.jpeg",
    "source": "https://developer.apple.com/news/rss/news.rss",
    "categories": null
  },
  {
    "id": "081b4d49-0a87-4693-91e0-840f706ba023",
    "title": "Building with nightly Swift toolchains on macOS",
    "link": "https://oleb.net/2024/swift-toolchains/",
    "description": "",
    "author": "Ole Begemann",
    "published": "2024-03-05T18:54:44Z",
    "image": "",
    "source": "https://oleb.net/blog/atom.xml",
    "categories": null
  },
  {
    "id": "e6981793-392a-483b-9bcc-6d7e585cf644",
    "title": "How the Swift compiler knows that DispatchQueue.main implies @MainActor",
    "link": "https://oleb.net/2024/dispatchqueue-mainactor/",
    "description": "",
    "author": "Ole Begemann",
    "published": "2024-02-29T18:54:47Z",
    "image": "",
    "source": "https://oleb.net/blog/atom.xml",
    "categories": null
  },
  {
    "id": "c5780f91-7ab2-41db-be94-48331c0d86f2",
    "title": "SwiftUI views versus modifiers",
    "link": "https://www.swiftbysundell.com/articles/swiftui-views-versus-modifiers",
    "description": "What’s really the difference between building a piece of UI as a view versus a modifier, and how to choose between those two solutions?",
    "author": "",
    "published": "Mon, 27 Feb 2023 11:05:00 +0100",
    "image": "",
    "source": "https://www.swiftbysundell.com/feed.rss",
    "categories": null
  },
  {
    "id": "cb12c575-130b-466b-88a1-6e5dbe9a7058",
    "title": "Observing the content offset of a SwiftUI ScrollView",
    "link": "https://www.swiftbysundell.com/articles/observing-swiftui-scrollview-content-offset",
    "description": "How the content offset of a SwiftUI ScrollView can be observed without bridging to UIKit.",
    "author": "",
    "published": "Mon, 30 Jan 2023 12:50:00 +0100",
    "image": "",
    "source": "https://www.swiftbysundell.com/feed.rss",
    "categories": null
  },
  {
    "id": "f8d590c7-f6ff-4551-951d-66c91f4c4bef",
    "title": "SwiftUI views versus modifiers",
    "link": "https://www.swiftbysundell.com/articles/swiftui-views-versus-modifiers",
    "description": "What’s really the difference between building a piece of UI as a view versus a modifier, and how to choose between those two solutions?",
    "author": "",
    "published": "Mon, 27 Feb 2023 11:05:00 +0100",
    "image": "",
    "source": "https://swiftbysundell.com/feed.rss",
    "categories": null
  },
  {
    "id": "f62d1387-9b90-4304-8e91-bc9015e0cf1b",
    "title": "Observing the content offset of a SwiftUI ScrollView",
    "link": "https://www.swiftbysundell.com/articles/observing-swiftui-scrollview-content-offset",
    "description": "How the content offset of a SwiftUI ScrollView can be observed without bridging to UIKit.",
    "author": "",
    "published": "Mon, 30 Jan 2023 12:50:00 +0100",
    "image": "",
    "source": "https://swiftbysundell.com/feed.rss",
    "categories": null
  },
  {
    "id": "0c1f0679-991b-43e1-b826-c135b41b20fc",
    "title": "Magical Particle Effects with SwiftUI Canvas",
    "link": "https://nerdyak.tech/development/2024/06/27/particle-effects-with-SwiftUI-Canvas.html",
    "description": "In one of the previous posts, I shared a simple way of Creating particle effects in SwiftUI. The approach is super easy and utilizes the power of viewModifiers, but I would not recommend it for production use as it is performance-greedy when having a bigger amount of particles in place (because each particle is a single view)",
    "author": "Pavel Zak",
    "published": "2024-06-27T00:00:00+00:00",
    "image": "",
    "source": "https://nerdyak.tech/atom.xml",
    "categories": [
      "development",
      "SwiftUI",
      "Canvas",
      "Particles",
      "BlendMode",
      "TimelineView"
    ]
  },
  {
    "id": "cb5582c9-da52-4bf6-ad1f-3f85ab83dbd4",
    "title": "SwiftUI transitions with distortion effect and Metal Shaders",
    "link": "https://nerdyak.tech/development/2023/06/16/distortionEffect-with-Metal-shaders-for-better-transitions.html",
    "description": "This year DubDub is over and I am very excited about the new developer treats that iOS17 will bring us that expand the animation possibilities of SwiftUI. I am talking mainly about the PhaseAnimator, KeyframeAnimator and the ability to utilize Metal shaders on SwiftUI views through modifiers .distortionEffect, .layerEffect, and .colorEffect (docs).",
    "author": "Pavel Zak",
    "published": "2023-06-16T00:00:00+00:00",
    "image": "",
    "source": "https://nerdyak.tech/atom.xml",
    "categories": [
      "development",
      "SwiftUI",
      "distortionEffect",
      "Metal",
      "Shaders",
      "transitions"
    ]
  },
  {
    "id": "51a98913-9f74-42bb-92ea-ba9a6dc01434",
    "title": "What happens when you move a file in git?",
    "link": "https://swiftrocks.com/what-happens-when-you-move-a-file-in-git",
    "description": "Recently at work we were considering renaming a folder that contains an enormous amount of files, and we wondered whether or not that would have notable negative consequences for our git repository. Would the repo become considerably larger? Would accessing git history become slower? Or would this be completely fine? After investigating this, I thought the answer was interesting enough that I felt like writing an article about it. To answer this question, we need to briefly explain how git works under the hood. There's also a TL;DR at the bottom if you'd like to skip the entire explanation. How does git handle files? It's somewhat commonly believed that git's commits are diffs, but this is not true. Commits are snapshots of your repository, meaning that when you make changes to a file, git will store a full copy of that file on your repository (there is an important exception, but let's keep it simple for now). This is why you can easily switch between commits and branches no matter how old they are; git doesn't need to \"replay\" thousands of diffs, it just needs to read and apply the snapshot for the commit you're trying to access. Under the hood, git will store all different versions of your files in the .git/objects folder, and this is something we can play with in order to find out what will happen regarding the main question we're trying to answer. Let's make a new git repo and add a file called swiftrocks.txt with the Hello World! contents, and commit it: git init echo 'Hello World!' \u003e swiftrocks.txt git add swiftrocks.txt git commit -m \"Add SwiftRocks\" If you now go to .git/objects, you'll see a bunch of folders with encoded files inside of them. The file we just added is there, but which one? When you add a file to git, git will do the following things: Compress the file with zlib Calculate a SHA1 hash based on the contents Place it in .git/objects/(first two hash characters)/(remaining hash characters) We can locate our file in the objects folder by reproducing this process, and luckily for us, we don't have to code anything to achieve this. We can find out what the resulting hash for a given file would be by running git hash-object: git hash-object swiftrocks.txt 980a0d5f19a64b4b30a87d4206aade58726b60e3 In my case, the hash of the file was 980a0d5f19a64b4b30a87d4206aade58726b60e3, meaning I can find the \"stored\" version of that file in .git/objects/98/0a0d5f19a64b4b30a87d4206aade58726b60e3. If you do this however, you'll notice that the file is unreadable because it's compressed. Similarly to the previous case, we don't have to code anything to de-compress this file! We just need to run git cat-file -p and git will do so automatically for us: git cat-file -p 980a0d5f19a64b4b30a87d4206aade58726b60e3 Hello World! There it is! Let's now make a change to this file and see what happens: echo 'Hello World (changed)!' \u003e swiftrocks.txt git add swiftrocks.txt git commit -m \"Change swiftrocks.txt\" git hash-object swiftrocks.txt cf15f0bb6b07a66f78f6de328e3cd6ea2747de6b git cat-file -p cf15f0bb6b07a66f78f6de328e3cd6ea2747de6b Hello World (changed)! Since we've made a change to the file, the SHA1 of the compressed contents changed, leading to a full copy of that file being added to the objects folder. As already mentioned above, this is because git works primarily in terms of snapshots rather than file diffs. You can even see that the \"original\" file is still there, which is what allows git to quickly switch between commits / branches. git cat-file -p 980a0d5f19a64b4b30a87d4206aade58726b60e3 Hello World! # The original file is still there! Now here's the relevant part: What happens if we change our file back to its original contents? echo 'Hello World!' \u003e swiftrocks.txt git add swiftrocks.txt git commit -m \"Change swiftrocks.txt back\" git hash-object swiftrocks.txt 980a0d5f19a64b4b30a87d4206aade58726b60e3 The hash is the same as before! Even though this is a new commit making a new change to the file, the hashing process allows git to determine that the file is exactly the same as the one we had in previous commits, meaning that there's no need to create a new copy. This will be the case even if you rename the file, because the hash is calculated based on the contents, not the file's name. This is a great finding, but it doesn't fully answer the original question. We now know that renaming files will not result in new copies of those files being added to the objects folder, but what about folders? And how are those files and folders attached to actual commits? How does git handle folders (and commits)? The most useful thing to know right off the bat is that commits are also objects in git. This is why you might have seen other folders / files in .git/objects when first inspecting it; the other files were related to the commits you made when adding the file. Since commits are also objects, we can read them with git cat-file just like with \"regular\" files. Let's do it with our latest commit (26d4302 in my case): git cat-file -p 26d4302 tree 350cef2a8054111568f82dc87bbd683ee14bb1a6 parent 2891fe1393c9e1bff116c1b58a30bcf85e0596a8 author Bruno Rocha 1733136171 +0100 committer Bruno Rocha 1733136223 +0100 Change swiftrocks.txt back As you can see, a \"commit\" is nothing more than a small text file containing the following bits of information: The author of the commit, and the commit message The hash of the parent commit The hash of the commit's \"tree\", containing information about the file system snapshot for that particular commit In this case, what we're interested in is the last point. Luckily for us, trees are also objects in git. Thus, if we want to see what the file system looks like for that particular commit, we just need to run git cat-file -p against the commit's tree hash: git cat-file -p 350cef2a8054111568f82dc87bbd683ee14bb1a6 100644 blob 980a0d5f19a64b4b30a87d4206aade58726b60e3 swiftrocks.txt Like with commits, tree objects are also very simple text files. In this case, the tree states that there's only one file (a blob) in the repository, which is a file called swiftrocks.txt with the 980a0d5f... hash. We've already uncovered that git prevents individual files from being duped, but let's see how this is reflected in the tree object: (made a commit adding some copies, and did cat-file -p on the new commit / tree) 100644 blob 980a0d5f19a64b4b30a87d4206aade58726b60e3 swiftrocks.txt 100644 blob 980a0d5f19a64b4b30a87d4206aade58726b60e3 swiftrocks2.txt 100644 blob 980a0d5f19a64b4b30a87d4206aade58726b60e3 swiftrocks3.txt The tree object references the new copies and their different names, but as expected, their hashes all point to the same underlying object under the hood. If we add folders to our repository, the tree object will include references to other tree objects (related to each of those folders), allowing you to recursively inspect each folder of that commit's snapshot. Here's an example: 100644 blob dd99cb611e0c77b2214392b253ed555fb838d8ee .DS_Store 040000 tree 350cef2a8054111568f82dc87bbd683ee14bb1a6 folder1 040000 tree 11ca8c2fe64b078be34824f071d32a560aba62a7 folder2 100644 blob 980a0d5f19a64b4b30a87d4206aade58726b60e3 swiftrocks.txt As you can see above, the output directly identifies what each hash is so that you know exactly what you're looking at. (An alternative is to run git cat-file -t, which returns the \"type\" for a given object hash.) So what happens if you rename / move an entire folder? The important bit to know here is that tree objects (and commits) are calculated and stored just like regular file (blob) objects, meaning they follow the same rules. This means that if the contents of two folders are exactly the same, git will not create a new tree object for those folders; it will simply reuse the hash it had already computed in the past, just like in the case of files: 040000 tree 350cef2a8054111568f82dc87bbd683ee14bb1a6 folder1 040000 tree 350cef2a8054111568f82dc87bbd683ee14bb1a6 folder1 (copy) However, since tree objects contain references to a folder / file's name, renaming something can result in new tree objects being created for that folder / file's parent tree in order to account for the name change, resulting in new hashes and tree objects recursively all the way up to the root of the repository. This will also be the case when moving files / folders. The above snippet is one example of this. Even though git was able to avoid duplicating the internal contents of folder1, git still needed to generate a new tree object for its parent in order to account for the fact that a new folder called folder1 (copy) exists. If there are more parents up the chain, they would also require new tree objects. Whether or not this would be a problem depends on where exactly the change is being made. If the change is too \"deep\" into the filesystem and / or the affected trees contain a massive number of files then you'd end up with lots of potentially large new tree objects. Still, as you can see, tree objects are quite simple, so you'd need a truly gargantuan repository and / or unfortunate folder setup for this to be an actual problem. If you do have a setup that is bad enough for this to be an issue, then the good thing is that there are ways to improve it. By understanding how tree objects are created and which files change / move more often in your repo, it's possible to optimize the structure of your repository to minimize the \"blast radius\" of any given change. For example, placing files that change very often closer to the root of the repo could reduce the number of trees that would have to be regenerated and their overall size. (Bonus) When are commits not snapshots? At the beginning of this article, I mentioned that there are cases where commits are not snapshots. While this is not particularly relevant for this article, I wanted to briefly cover this as it's an important aspect of how git works. We've seen that git will make copies of your files when you change them, but this introduces a massive problem: If a particular file happens to be really big, then duplicating it for every small change could be disastrous. When this is the case, git will pivot into calculating change deltas instead of making full copies of the file. This feature is called Packfiles, and is something that is automatically managed by git for you. I recommend reading this great write-up by Aditya Mukerjee if you'd like to know more about it. TL;DR Git works in terms of snapshots (for the most part) Git knows that two files are the same and can avoid duplicating them in its internal storage, even if they have different names Similarly, Git can also determine if two folders are the same, regardless of where they are or are named Thus, renaming files or folders will not have any impact on git's internal storage for those files and folders However, git may end up needing to duplicate information regarding parent folders, recursively, to account for naming changes and / or new files In theory this can be an issue if the change happens very \"deeply\" into the file system and / or the parent folders contain massive amounts of files, but you'd need a truly gargantuan repository and / or unfortunate folder setup for this to be an actual problem Understanding how git objects work under the hood allows you to optimize your repository's folders in ways that can prevent too many unnecessary objects from being created Sources / References Julia Evans's many articles on git Unpacking git packfiles Git from the inside out",
    "author": "Bruno Rocha",
    "published": "Mon, 2 Dec 2024 13:00:00 GMT+1",
    "image": "",
    "source": "https://swiftrocks.com/rss.xml",
    "categories": null
  },
  {
    "id": "bf43dcf2-b04a-4e90-be85-84c6ab038d2f",
    "title": "Focus not on the task, but on the problem behind the task",
    "link": "https://swiftrocks.com/focus-not-on-the-task-but-on-the-problem-behind-the-task",
    "description": "Consider the following situation: A team is asked by their Product Manager to implement features X, Y, and Z into an existing system. The team then organizes itself and executes the project. After a certain amount of time, they delivered exactly what was asked of them. But then, one of these things happens (choose at least one): The features work only for the happy path, failing miserably at any sort of edge-case The features work as expected, but were designed so badly they are immediately considered tech debt The features work as expected, but are considered useless by the users of the system and end up completely unused (they do not solve those users' problems) What do you think happened here? Is this the Product Manager's fault for giving wrong requests, or the engineering team's fault for not understanding what was asked of them? Some people will say this is the PM's fault, and in some cases it might be true. But the situation I want to cover here is the scenario where this is the engineers' fault, because it's something I've seen countless times throughout my career. The reason the scenario above happened (when the PM is not the one at fault) is because the engineers focused too much on the immediate task they were given, when what they should've done is focus on the problem behind the task, by asking themselves questions such as: What's the context behind this ask? Is this a larger project that includes other features and tasks? Who exactly is asking for this? (Does anyone actually need this?) What problem are these users facing that led to this ask? Did someone attempt to solve this problem before? What did they try to do? Who is going to benefit from this ask being executed? How would they use the solution? It's only after understanding this context that you can consider yourself ready to come up with a technical solution to it. But what happens a lot is that some engineers tend to immediately jump into problem-solving as soon as they are presented with a task, leading to solutions that despite being \"accurate\" when evaluating the task in isolation, completely miss the mark when looking at the bigger picture. In short, the issue was that the engineers in that situation had too much tunnel vision. Understanding the context behind tasks allows you to come up with a solution that fits the bigger picture, making it possible not only to solve your users' problems, but also to do so in a way that is clean, scalable, easy to maintain, and that benefits everyone (as opposed to being beneficial to you and your team, but a pain in the ass for everyone else in the company). In The Staff Engineer's Path, Tanya Reilly describes this as the Local vs Global Maxima problem, where the Local maxima means focusing on what's good for you or your team in an individual sense (the tunnel vision situation above), and the Global maxima means focusing on what's good for the company as a whole, regardless of whether or not it would be ideal for you as an individual (the big picture situation). In the book, she presents this idea to argue that this focus and ability to gather context about the bigger picture is a core ability of Staff+ level engineers and a minimum requirement for those aspiring to reach that level. Although I agree with her that only Staff+ engineers should be expected to be masters at this, I do also believe that this is something everyone should attempt to do, regardless of level. Doing so not only improves your knowledge of how your company works and is structured, but also teaches you how to better determine what does and doesn't matter when trying to solve a particular problem, enabling you to be more effective both at coding and at providing value for your company.",
    "author": "Bruno Rocha",
    "published": "Mon, 18 Nov 2024 13:00:00 GMT+1",
    "image": "https://i.imgur.com/BfKDQC5.png",
    "source": "https://swiftrocks.com/rss.xml",
    "categories": null
  },
  {
    "id": "cd86324b-a0ef-455c-93e3-e0fa03d4cd4d",
    "title": "Solar Powered Birdhouse",
    "link": "https://atomicbird.com/blog/birdhouse-solar-power/",
    "description": "In my last couple of posts I’ve talked about the hardware and software behind my birdhouse camera project. I haven’t previously covered how I’m giving it all enough power to operate, and therein lies a tale. No Power? No Problem If I had a power outlet located anywhere near the bird house, this would have been easy. Pretty much any micro-USB power adapter would plug into the Raspberry Pi, and I’d be set.",
    "author": "",
    "published": "Thu, 19 May 2022 00:00:00 +0000",
    "image": "",
    "source": "https://atomicbird.com/index.xml",
    "categories": null
  },
  {
    "id": "1b4e97f8-f349-4100-88c3-ebefb4c97068",
    "title": "Raspberry Pi Birdhouse Software",
    "link": "https://atomicbird.com/blog/birdhouse-software/",
    "description": "In my last post I went over the components of the bird house camera I set up this year to get a better look at the local black-capped chickadees. Today I’ll talk about the software that makes it work. Initial Setup Being relatively new to Raspberry Pi, I started off with a full install of Raspbian Deskop. It’s more than I need, since I won’t have anything like a desktop setup, but with a 64GB SD card I wasn’t concerned about the space.",
    "author": "",
    "published": "Mon, 09 May 2022 00:00:00 +0000",
    "image": "",
    "source": "https://atomicbird.com/index.xml",
    "categories": null
  },
  {
    "id": "6b05956e-7ad6-4975-b713-e1ec0de0e1bf",
    "title": "Migrating XCTest to Swift Testing",
    "link": "https://useyourloaf.com/blog/migrating-xctest-to-swift-testing/",
    "description": "A quick guide to migrating XCTest unit tests to Swift Testing. What is Swift Testing? Swift Testing is an open-source testing framework designed for Swift. Apple introduced it at WWDC24 and shipped it with Xcode 16. Swift Testing uses modern features like concurrency and macros. It supports Windows and Linux as well as Apple’s platforms. Do I Need To Migrate? No. The XCTest framework is not deprecated, There’s no urgent reason to migrate your tests unless you want to. You cannot migrate UI Automation tests or performance (XCTMetric) tests as they are not supported by Swift Testing. I’m finding that I prefer writing tests with Swift Testing over XCTest (see below for some of the reasons). I started adding new tests with Swift Testing to XCTest unit test source files but at a certain point I want to migrate all the tests in a source file to Swift Testing. These are my notes on that process. Getting Started You can mix XCTest and Swift Testing unit tests in a test target. You can even mix both types of test in the same source file. That make it possible to add new tests with Swift Testing and migrate your XCTests over time. Do not mix testing frameworks within a test. Do not call XCTAssert from a Swift Testing test or a Swift Testing macro like #expect or #require from XCTests. Import Swift Testing To get started import the Swift Testing framework: import Testing Apple warns that you should only import the testing library into a test target. Importing into an application or library target is not supported. Grouping Tests You group Swift Testing unit tests by adding them to a type (struct or class). Xcode organises your tests based on your chosen grouping in the Test Navigator. Unlike XCTest which requires you subclass XCTestCase, Swift Testing can use a struct, class or actor. Apple recommends you start with a struct unless you need a deinit for cleanup (see below). // XCTest import XCTest class StoreXCTests: XCTestCase { } // Swift Testing import Testing struct StoreTests { } Swift Testing creates a new instance of the StoreTests type for each unit test it runs. You’re not forced to organise Swift Testing tests in a type. For example, Apple recommends you convert an XCTestCase subclass with a single test to a global function. Test Setup and Teardown Swift Testing uses the types init (and deinit for class) methods to setup and teardown tests. I find this a big improvement over the XCTest approach of overriding one of the many setUp and tearDown methods. The init can be async or throwing as needed: // XCTest import XCTest class StoreXCTests: XCTestCase { let store: DataStore! override func setupWithError() throws { store = try DataStore(inMemory: true) } } // Swift Testing import Testing struct StoreTests { let store: DataStore init() throws { store = try DataStore(inMemory: true) } } For convenience I was using a forced unwrapped optional for the stored property in my XCTest. Using the normal Swift init method for my test type removes the need for that. As I mentioned above if you need to cleanup after the test runs, use a class and add the cleanup code to the deinit: // Swift Testing import Testing class StoreTests { let store: DataStore init() throws { store = try DataStore(inMemory: true) } deinit { store.reset() } } Creating Tests A Swift Testing test is a normal Swift method. It can be a standalone global function or one of many methods organised into a Swift struct, class, or actor. A method becomes a unit test when you add the @Test macro: // XCTest func testStoreIsReady() { } // Swift Testing @Test func storeIsReady() { } As with XCTest, you can mark test methods with async or throws and isolate them to an actor as needed. Unlike with XCTest, you don’t need to prefix your test method name with “test”. The @Test attribute is a macro so you can expand it to see the implementation if you wish. XCTest uses multiple Simulator instances to run tests in parallel. It doesn’t support running tests in-parallel on device. Swift Testing runs tests in-process using Swift Concurrency so it can run tests in-parallel on physical devices. Asserting with #expect and #require. For me, the biggest improvement over XCTest is replacing the forty odd variations of XCTAssert with the #expect and #require macros. The #expect macro accepts a Swift expression that you expect to be true. When the expression is false the #expect macro logs the failed expectation and the test continues: @Test func storeIsReady() { #expect(store.isReady) #expect(store.error == nil) } The error messages are generally more informative than the equivalent XCTest failure: Clicking the red cross in the error message and then the Show button expands the values in the expression which I find is sometimes more readable: It took me a little while to get used to but I prefer the flexibility of being able to use any Swift expression for the #expect rather than trying to remember which version of XCTAssert I need: // XCTest XCTAssertTrue(store.isReady) XCTAssertFalse(store.isReady) XCTAssertNil(store.error) XCTAssertNotNil(store.error) XCTAssertEqual(items.count, 5) // Swift Testing #expect(store.isReady) #expect(!store.isReady) #expect(store.error == nil) #expect(store.error != nil) #expect(items.count == 5) Unwrapping with #require The second expectation macro is #require. This is throwing version of #expect that stops the test execution on error. A common usage is to replace XCTUnwrap when unwrapping an optional. If the optional is nil the test stops: // XCTest func testCreateItem() throws { // createItem returns an Item? let item = try XCTUnwrap(store.createItem()) XCTAssertEqual(item.title == \"New item\") } // Swift Testing @Test func createItem() throws { // createItem returns an Item? let item = try #require(store.createItem()) #expect(item.title == \"New item\") } Replacing XCTFail Sometimes you need to cause a test to fail without evaluating a condition. For example, when certain cases in a switch are test failures. The XCTest framework has XCTFail for this. The Swift Testing equivalent is Issue.record: // Swift Testing @Test func storeReady() { switch store.state { case .failed: Issue.record(\"Expected ready, got failed\") case .loading: Issue.record(\"Expected ready, got loading\") case .ready: #expect(store.error == nil) } } Wrapping Up There’s a lot more you can do to customize tests, control when and how they run, handle async code, and organize with tags and test suites. I’ll save those topics for future posts. In the meantime, I recommend browsing the Apple article linked below for more details on migrating from XCTest. Learn More WWDC24 Meet Swift Testing Apple Article: Migrating a test from XCTest Migrating XCTest to Swift Testing was originally posted 09 Dec 2024 on useyourloaf.com. Want this direct to your inbox? Sign up and get my free WWDC viewing guide PDF.",
    "author": "",
    "published": "Mon, 09 Dec 2024 10:59:14 +0000",
    "image": "https://useyourloaf.com/blog/migrating-xctest-to-swift-testing/001.png",
    "source": "https://useyourloaf.com/blog/rss.xml",
    "categories": null
  },
  {
    "id": "afdc2769-5f4d-4e96-a28a-479862f77f99",
    "title": "SwiftUI Charts Plotting Functions",
    "link": "https://useyourloaf.com/blog/swiftui-charts-plotting-functions/",
    "description": "In iOS 18 Apple added function plotting to the SwiftUI Charts framework. Function Plotting Both the LinePlot and AreaPlot charts accept a function to graph. The function accepts a Double and returns a Double. For example: Chart { LinePlot(x: \"x\", y: \"y\") { x in x * x } } .chartYAxisLabel(\"y = x * x\") Another example, with a range applied to the x-axis (you can also apply the domain parameter directly to the LinePlot method): Chart { LinePlot(x: \"x\", y: \"y\") { sin($0) } } .chartXScale(domain: -15...15) .chartYAxisLabel(\"y = sin(x)\") Note: Apple’s documentation mentions that for x values where the function is undefined or infinity you should return Double.nan or Double.infinity: Chart { LinePlot(x: \"x\", y: \"y\", domain: -5...5) { x in guard x != 0 else { return .nan } return 1 / x } } .chartYAxisLabel(\"y = 1/x\") .clipped() An area plot of a single function fills the area between the function and zero: Chart { AreaPlot(x: \"x\", y: \"y\") { sin($0) } } .chartXScale(domain: -15...15) .chartYAxisLabel(\"y = sin(x)\") If you give an area plot two functions for the starting and ending y value, it fills the area between the two functions: Chart { AreaPlot(x: \"x\", yStart: \"x\", yEnd: \"sin(x)\") { x in (yStart: sin(x), yEnd: sin(x + .pi)) } } Where I think function plotting becomes useful is when we’re visualising data that we expect to approximate a function. Adding an area and line plot of the function we can highlight the comparison between this bar chart and the expected results: Chart { AreaPlot(x: \"x\", y: \"y\") { $0 * $0 } .foregroundStyle(.gray) .opacity(0.5) LinePlot(x: \"x\", y: \"y\") { $0 * $0 } ForEach(data) { item in BarMark( x: .value(\"Sample\", item.score), y: .value(\"Result\", item.count) ) } } Learn More WWDC24 Swift Charts: Vectorized and function plots SwiftUI Charts Plotting Functions was originally posted 24 Nov 2024 on useyourloaf.com. Want this direct to your inbox? Sign up and get my free WWDC viewing guide PDF.",
    "author": "",
    "published": "Sun, 24 Nov 2024 13:33:26 +0000",
    "image": "https://useyourloaf.com/blog/swiftui-charts-plotting-functions/001.png",
    "source": "https://useyourloaf.com/blog/rss.xml",
    "categories": null
  },
  {
    "id": "f8b7665b-fe8f-466a-a4ab-cab7d10eba70",
    "title": "308: What's In Our Toolbox: Simulators \u0026 Source Control",
    "link": "http://relay.fm/radar/308",
    "description": "In the second of a multi-part series sharing the apps that we use to develop software, we discuss the tools we use to enhance the iOS Simulator, make the most of on-device testing, and manage our code in source control.",
    "author": "Marco Arment and David Smith",
    "published": "Thu, 19 Dec 2024 11:15:00 GMT",
    "image": "https://www.podtrac.com/pts/redirect.mp3/traffic.libsyn.com/secure/radarrelay/undertheradar308.mp3",
    "source": "https://www.relay.fm/radar/feed",
    "categories": null
  },
  {
    "id": "f5645982-7279-47cf-a32c-fb75fa3dea77",
    "title": "307: What's In Our Toolbox: Code \u0026 Design",
    "link": "http://relay.fm/radar/307",
    "description": "In the first of a multi-part series sharing the apps that we use to develop software, we discuss the tools we use to write code and design visuals.",
    "author": "Marco Arment and David Smith",
    "published": "Thu, 05 Dec 2024 17:15:00 GMT",
    "image": "https://www.podtrac.com/pts/redirect.mp3/traffic.libsyn.com/secure/radarrelay/undertheradar307.mp3",
    "source": "https://www.relay.fm/radar/feed",
    "categories": null
  },
  {
    "id": "e4330ba3-66cc-4509-afec-2f0238a737ff",
    "title": "Harris for President",
    "link": "https://inessential.com/2024/10/31/harris_for_president.html",
    "description": "Donald Trump is a gross villain and a traitor to our country. He’s a convicted felon, adjudicated rapist, and head of a criminal organization; he works with criminals and he pardons criminals; he’s a narcissist and violent insurrectionist, racist and misogynist; he’s the master of lies and corruption and self-serving. He plans to rule as a fascist dictator, and this time has the backing to do so, for the benefit of him and his ultra-wealthy friends. Not for you. For everybody else, the various enemies within — everybody who isn’t a straight white male who goes along with the program — there will be concentration camps, deportation, prison, and rumors and threats of each. There will be more deaths in hospital parking lots. I have voted for Kamala Harris. I ask you to vote for her too. I happen to think Harris would be very good, possibly even great, as president. But it hardly matters! Voting for her is how we stop this. And we have to stop this.",
    "author": "",
    "published": "Thu, 31 Oct 2024 13:04:03 -0700",
    "image": "",
    "source": "https://inessential.com/xml/rss.xml",
    "categories": null
  },
  {
    "id": "679539cf-8697-42b9-b702-95190242f6f1",
    "title": "Seattle Xcoders 20th Anniversary Meetup",
    "link": "https://inessential.com/2024/10/16/seattle_xcoders_20th_anniversary_meetup.html",
    "description": "This Thursday, Oct. 17, 2024, is the 20th anniversary of the Seattle Xcoders! We’d love to see you there, at 7 pm at Bale Breaker and Yonder Cider taproom in Ballard. Everyone is welcome! It’s not just for people who write code — it’s for designers, testers, support folks, and everyone who helps make Apple-ecosystem apps. Even if you just like those kinds of apps and like talking about them, come join us! We’re usually outside by these propane fire things, but I’m not sure this time — we might have a room or some area or something. We should be easy to find, at any rate. It’s not actually a meeting with presentations — it’s just hanging out and talking. Which we do every first, third, and fifth Thursday (you can subscribe to our calendar). One of these days we’ll get back to presentations — but the social part is valuable, and so we keep it up. PS Looks like the food truck is Impeckable Chicken, which I’ve heard good things about. :) PPS I’m usually easy to spot: quite well into middle age, with nothing like the amount of hair I once had. Black jeans, usually a black sweatshirt. Glasses. Doc Martens. Not tall.",
    "author": "",
    "published": "Wed, 16 Oct 2024 19:13:25 -0700",
    "image": "",
    "source": "https://inessential.com/xml/rss.xml",
    "categories": null
  }
]
