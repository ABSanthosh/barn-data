{
  "id": "7d219b48-66e9-42c8-81a6-09db721097d0",
  "title": "Autogenerating Rust-JS bindings with UniFFI",
  "link": "https://hacks.mozilla.org/2023/08/autogenerating-rust-js-bindings-with-uniffi/",
  "description": "This blog post will walk through how we developed UniFFI: a Rust library for auto-generating foreign language bindings. We will walk through some of the issues that arose along the way and how we handled them. The post Autogenerating Rust-JS bindings with UniFFI appeared first on Mozilla Hacks - the Web developer blog.",
  "author": "Ben Dean-Kawamura",
  "published": "Tue, 08 Aug 2023 11:15:31 +0000",
  "source": "https://hacks.mozilla.org/feed/",
  "categories": [
    "Featured Article",
    "Firefox",
    "JavaScript",
    "Rust",
    "UniFFI",
    "Android",
    "firefox",
    "glean",
    "iOS",
    "mozilla",
    "rust"
  ],
  "byline": "By Ben Dean-Kawamura",
  "length": 6567,
  "excerpt": "This blog post will walk through how we developed UniFFI: a Rust library for auto-generating foreign language bindings.",
  "siteName": "Mozilla Hacks – the Web developer blog",
  "favicon": "",
  "text": "I work on the Firefox sync team at Mozilla. Four years ago, we wrote a blog post describing our strategy to ship cross-platform Rust components for syncing and storage on all our platforms. The vision was to consolidate the separate implementations of features like history, logins, and syncing that existed on Firefox Desktop, Android, and iOS. We would replace those implementations with a core written in Rust and a set of hand-written foreign language wrappers for each platform: JavaScript for Desktop, Kotlin for Android, and Swift for iOS. Since then, we’ve learned some lessons and had to modify our strategy. It turns out that creating hand-written wrappers in multiple languages is a huge time-sink. The wrappers required a significant amount of time to write, but more importantly, they were responsible for many serious bugs. These bugs were easy to miss, hard to debug, and often led to crashes. One of the largest benefits of Rust is memory safety, but these hand-written wrappers were negating much of that benefit. To solve this problem, we developed UniFFI: a Rust library for auto-generating foreign language bindings. UniFFI allowed us to create wrappers quickly and safely, but there was one issue: UniFFI supported Kotlin and Swift, but not JavaScript, which powers the Firefox Desktop front-end. UniFFI helped us ship shared components for Firefox Android and iOS, but Desktop remained out of reach. This changed with Firefox 105 when we added support for generating JavaScript bindings via UniFFI which enabled us to continue pushing forward on our single component vision. This project validated some core concepts that have been in UniFFI from the start but also required us to extend UniFFI in several ways. This blog post will walk through some of the issues that arose along the way and how we handled them. Prior Art This project has already been tried at least once before at Mozilla. The team was able to get some of the functionality supported, but some parts remained out of reach. One of the first things we realized was that the general approach the previous attempts took would probably not support the UniFFI features we were using in our components. Does this mean the previous work was a failure? Absolutely not. The team left behind a wonderful trove of design documents, discussions, and code that we made sure to study and steal from. In particular, there was an ADR that discussed different approaches which we studied, as well as a working C++/WebIDL code that we repurposed for our project. Calling the FFI functions UniFFI bindings live on top of an FFI layer using the C ABI that we call “the scaffolding.” Then the user API is defined on top of the scaffolding layer, in the foreign language. This allows the user API to support features not directly expressible in C and also allows the generated API to feel idiomatic and natural. However, JavaScript complicates this picture because it doesn’t have support for calling C functions. Privileged code in Firefox can use the Mozilla js-ctypes library, but its use is deprecated. The previous project solved this problem by using C++ to call into the scaffolding functions, then leveraged the Firefox WebIDL code generation tools to create the JavaScript API. That code generation tool is quite nice and allowed us to define the user API using a combination of WebIDL and C++ glue code. However, it was limited and did not support all UniFFI features. Our team decided to use the same WebIDL code generation tool, but to generate just the scaffolding layer instead of the entire user API. Then we used JavaScript to define the user API on top of that, just like for other languages. We were fairly confident that the code generation tool would no longer be a limiting factor, since the scaffolding layer is designed to be minimalistic and expressible in C. Async functions The threading model for UniFFI interfaces is not very flexible: all function and method calls are blocking. It’s the caller’s responsibility to ensure that calls don’t block the wrong thread. Typically this means executing UniFFI calls in a thread pool. The threading model for Firefox frontend JavaScript code is equally inflexible: you must never block the main thread. The main JavaScript thread is responsible for all UI updates and blocking it means an unresponsive browser. Furthermore, the only way to start another thread in JavaScript is using Web Workers, but those are not currently used by the frontend code. To resolve the unstoppable force vs. immovable object situation we found ourselves in, we simply reversed the UniFFI model and made all calls asynchronous. This means that all functions return a promise rather than their return value directly. The “all functions are async” model seems reasonable, at least for the first few projects we intend to use with UniFFI. However, not all functions really need to be async – some are quick enough that they aren’t blocking. Eventually, we plan to add a way for users to customize which functions are blocking and which are async. This will probably happen alongside some general work for async UniFFI, since we’ve found that async execution is an issue for many components using UniFFI. How has it been working? Since landing UniFFI support in Firefox 105, we’ve slowly started adding some UniFFI’ed Rust components to Firefox. In Firefox 108 we added the Rust remote tabs syncing engine, making it the first component shared by Firefox on all three of our platforms. The new tabs engine uses UniFFI to generate JS bindings on Desktop, Kotlin bindings on Android, and Swift bindings on iOS. We’ve also been continuing to advance our shared component strategy on Mobile. Firefox iOS has historically lagged behind Android in terms of shared component adoption, but the Firefox iOS 116 release will use our shared sync manager component. This means that both mobile browsers will be using all of the shared components we’ve written so far. We also use UniFFI to generate bindings for Glean, a Mozilla telemetry library, which was a bit of an unusual case. Glean doesn’t generate JS bindings; it only generates the scaffolding API, which ends up in the GeckoView library that powers Firefox Android. Firefox Android can then consume Glean via the generated Kotlin bindings which link to the scaffolding in Geckoview. If you’re interested in this project or UniFFI in general, please join us in #uniffi on the Mozilla Matrix chat. More articles by Ben Dean-Kawamura…",
  "image": "https://hacks.mozilla.org/wp-content/uploads/2023/08/image-2.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle role=\"article\"\u003e\n    \u003cp\u003e\u003cimg fetchpriority=\"high\" decoding=\"async\" src=\"https://hacks.mozilla.org/wp-content/uploads/2023/08/image-2.png\" alt=\"\" width=\"1260\" height=\"702\" srcset=\"https://hacks.mozilla.org/wp-content/uploads/2023/08/image-2.png 1260w, https://hacks.mozilla.org/wp-content/uploads/2023/08/image-2-250x139.png 250w, https://hacks.mozilla.org/wp-content/uploads/2023/08/image-2-500x279.png 500w, https://hacks.mozilla.org/wp-content/uploads/2023/08/image-2-768x428.png 768w\" sizes=\"(max-width: 1260px) 100vw, 1260px\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eI work on the Firefox sync team at Mozilla. Four years ago, we wrote a \u003c/span\u003e\u003ca href=\"https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/\"\u003e\u003cspan\u003eblog post describing our strategy to ship cross-platform Rust components\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e for syncing and storage on all our platforms. The vision was to consolidate the separate implementations of features like history, logins, and syncing that existed on Firefox Desktop, Android, and iOS. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe would replace those implementations with a core written in Rust and a set of hand-written foreign language wrappers for each platform: JavaScript for Desktop, Kotlin for Android, and Swift for iOS.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eSince then, we’ve learned some lessons and had to modify our strategy. It turns out that creating hand-written wrappers in multiple languages is a huge time-sink. The wrappers required a significant amount of time to write, but more importantly, they were responsible for many serious bugs. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThese bugs were easy to miss, hard to debug, and often led to crashes. One of the largest benefits of Rust is memory safety, but these hand-written wrappers were negating much of that benefit.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eTo solve this problem, we developed \u003c/span\u003e\u003ca href=\"https://mozilla.github.io/uniffi-rs/\"\u003e\u003cspan\u003eUniFFI\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e: a Rust library for auto-generating foreign language bindings. UniFFI allowed us to create wrappers quickly and safely, but there was one issue: UniFFI supported Kotlin and Swift, but not JavaScript, which powers the Firefox Desktop front-end\u003c/span\u003e\u003cspan\u003e. UniFFI helped us ship shared components for Firefox Android and iOS, but Desktop remained out of reach.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThis changed with Firefox 105 when we added support for generating JavaScript bindings via UniFFI which enabled us to continue pushing forward on our single component vision. This project validated some core concepts that have been in UniFFI from the start but also required us to extend UniFFI in several ways. This blog post will walk through some of the issues that arose along the way and how we handled them.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cstrong\u003ePrior Art\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eThis project has already been tried at least once before at Mozilla. The team was able to get some of the functionality supported, but some parts remained out of reach. One of the first things we realized was that the general approach the previous attempts took would probably not support the UniFFI features we were using in our components.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eDoes this mean the previous work was a failure? Absolutely not. The team left behind a wonderful trove of design documents, discussions, and code that we made sure to study and steal from. In particular, there was an \u003c/span\u003e\u003ca href=\"https://adr.github.io/\"\u003e\u003cspan\u003eADR\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e that discussed different approaches which we studied, as well as a \u003c/span\u003e\u003ca href=\"https://github.com/mozilla/uniffi-rs/pull/255\"\u003e\u003cspan\u003eworking C++/WebIDL code\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e that we repurposed for our project.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cstrong\u003eCalling the FFI functions\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eUniFFI bindings live on top of an \u003c/span\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Foreign_function_interface\"\u003e\u003cspan\u003eFFI\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e layer using the C ABI that we call “the scaffolding.” Then the user API is defined on top of the scaffolding layer, in the foreign language. This allows the user API to support features not directly expressible in C and also allows the generated API to feel idiomatic and natural. However, JavaScript complicates this picture because it doesn’t have support for calling C functions. Privileged code in Firefox can use the Mozilla \u003c/span\u003e\u003ca href=\"http://www.devdoc.net/web/developer.mozilla.org/en-US/docs/js-ctypes.html\"\u003e\u003cspan\u003ejs-ctypes\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e library, but its use is deprecated.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThe previous project solved this problem by using C++ to call into the scaffolding functions, then leveraged the \u003c/span\u003e\u003ca href=\"https://firefox-source-docs.mozilla.org/dom/webIdlBindings/index.html\"\u003e\u003cspan\u003eFirefox WebIDL code generation tools\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e to create the JavaScript API. That code generation tool is quite nice and allowed us to define the user API using a combination of \u003c/span\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/MDN/Contribute/Howto/Write_an_API_reference/Information_contained_in_a_WebIDL_file\"\u003e\u003cspan\u003eWebIDL\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e and C++ glue code. However, it was limited and did not support all UniFFI features.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eOur team decided to use the same WebIDL code generation tool, but to generate just the scaffolding layer instead of the entire user API. Then we used JavaScript to define the user API on top of that, just like for other languages. We were fairly confident that the code generation tool would no longer be a limiting factor, since the scaffolding layer is designed to be minimalistic and expressible in C.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cstrong\u003eAsync functions\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eThe threading model for UniFFI interfaces is not very flexible: all function and method calls are blocking. It’s the caller’s responsibility to ensure that calls don’t block the wrong thread. Typically this means executing UniFFI calls in a thread pool.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThe threading model for Firefox frontend JavaScript code is equally inflexible: you must never block the main thread. The main JavaScript thread is responsible for all UI updates and blocking it means an unresponsive browser. Furthermore, the only way to start another thread in JavaScript is using \u003c/span\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\"\u003e\u003cspan\u003eWeb Workers\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e, but those are not currently used by the frontend code.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eTo resolve the unstoppable force vs. immovable object situation we found ourselves in, we simply reversed the UniFFI model and made all calls asynchronous. This means that all functions return a \u003c/span\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"\u003e\u003cspan\u003epromise\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e rather than their return value directly.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThe “all functions are async” model seems reasonable, at least for the first few projects we intend to use with UniFFI. However, not all functions really need to be async – some are quick enough that they aren’t blocking. Eventually, we plan to add a way for users to customize which functions are blocking and which are async. This will probably happen alongside some general work for async UniFFI, since we’ve found that async execution is an issue for many components using UniFFI.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cstrong\u003eHow has it been working?\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eSince landing UniFFI support in Firefox 105, we’ve slowly started adding some UniFFI’ed Rust components to Firefox. In Firefox 108 we added the Rust remote tabs syncing engine, making it the first component shared by Firefox on all three of our platforms. The new tabs engine uses UniFFI to generate JS bindings on Desktop, Kotlin bindings on Android, and Swift bindings on iOS. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe’ve also been continuing to advance our shared component strategy on Mobile. Firefox iOS has historically lagged behind Android in terms of shared component adoption, but the Firefox iOS 116 release will use our shared sync manager component. This means that both mobile browsers will be using all of the shared components we’ve written so far.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe also use UniFFI to generate bindings for \u003c/span\u003e\u003ca href=\"https://mozilla.github.io/glean/dev/index.html\"\u003e\u003cspan\u003eGlean\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e, a Mozilla telemetry library, which was a bit of an unusual case. Glean doesn’t generate JS bindings; it only generates the scaffolding API, which ends up in the \u003c/span\u003e\u003ca href=\"https://mozilla.github.io/geckoview/\"\u003e\u003cspan\u003eGeckoView\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e library that powers Firefox Android. Firefox Android can then consume Glean via the generated Kotlin bindings which link to the scaffolding in Geckoview.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eIf you’re interested in this project or UniFFI in general, please join us in \u003c/span\u003e\u003ca href=\"https://matrix.to/#/#uniffi:mozilla.org\"\u003e\u003cspan\u003e#uniffi\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e on the Mozilla Matrix chat.\u003c/span\u003e\u003c/p\u003e\n    \u003csection\u003e\n                                \n                                \u003cp\u003e\u003ca href=\"https://hacks.mozilla.org/author/bdeankawamuramozilla-com/\"\u003eMore articles by Ben Dean-Kawamura…\u003c/a\u003e\u003c/p\u003e\n                  \u003c/section\u003e\n  \u003c/article\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
