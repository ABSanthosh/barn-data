{
  "id": "a8e96e88-7ec1-433d-9f95-cc3383d67794",
  "title": "What We Know (So Far) About CSS Reading Order",
  "link": "https://css-tricks.com/what-we-know-so-far-about-css-reading-order/",
  "description": "The reading-flow and reading-order proposed CSS properties are designed to specify the source order of HTML elements in the DOM tree, or in simpler terms, how accessibility tools deduce the order of elements. You’d use them to make the focus order of focusable elements match the visual order, as outlined in the Web Content Accessibility Guidelines (WCAG 2.2). What We Know (So Far) About CSS Reading Order originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Daniel Schwarz",
  "published": "Tue, 27 May 2025 13:02:32 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "accessibility",
    "css properties"
  ],
  "byline": "Daniel Schwarz",
  "length": 8133,
  "excerpt": "The reading-flow and reading-order proposed CSS properties are designed to specify the source order of HTML elements in the DOM tree, or in simpler terms, how accessibility tools deduce the order of elements. You’d use them to make the focus order of focusable elements match the visual order, as outlined in the Web Content Accessibility Guidelines (WCAG 2.2).",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "The reading-flow and reading-order proposed CSS properties are designed to specify the source order of HTML elements in the DOM tree, or in simpler terms, how accessibility tools deduce the order of elements. You’d use them to make the focus order of focusable elements match the visual order, as outlined in the Web Content Accessibility Guidelines (WCAG 2.2). To get a better idea, let’s just dive in! (Oh, and make sure that you’re using Chrome 137 or higher.) reading-flow reading-flow determines the source order of HTML elements in a flex, grid, or block layout. Again, this is basically to help accessibility tools provide the correct focus order to users. The default value is normal (so, reading-flow: normal). Other valid values include: flex-visual flex-flow grid-rows grid-columns grid-order source-order Let’s start with the flex-visual value. Imagine a flex row with five links. Assuming that the reading direction is left-to-right (by the way, you can change the reading direction with the direction CSS property), that’d look something like this: Now, if we apply flex-direction: row-reverse, the links are displayed 5-4-3-2-1. The problem though is that the focus order still starts from 1 (tab through them!), which is visually wrong for somebody that reads left-to-right. But if we also apply reading-flow: flex-visual, the focus order also becomes 5-4-3-2-1, matching the visual order (which is an accessibility requirement!): \u003cdiv\u003e \u003ca\u003e1\u003c/a\u003e \u003ca\u003e2\u003c/a\u003e \u003ca\u003e3\u003c/a\u003e \u003ca\u003e4\u003c/a\u003e \u003ca\u003e5\u003c/a\u003e \u003c/div\u003e div { display: flex; flex-direction: row-reverse; reading-flow: flex-visual; } To apply the default flex behavior, reading-flow: flex-flow is what you’re looking for. This is very akin to reading-flow: normal, except that the container remains a reading flow container, which is needed for reading-order (we’ll dive into this in a bit). For now, let’s take a look at the grid-y values. In the grid below, the grid items are all jumbled up, and so the focus order is all over the place. We can fix this in two ways. One way is that reading-flow: grid-rows will, as you’d expect, establish a row-by-row focus order: \u003cdiv\u003e \u003ca\u003e1\u003c/a\u003e \u003ca\u003e2\u003c/a\u003e \u003ca\u003e3\u003c/a\u003e \u003ca\u003e4\u003c/a\u003e \u003ca\u003e5\u003c/a\u003e \u003ca\u003e6\u003c/a\u003e \u003ca\u003e7\u003c/a\u003e \u003ca\u003e8\u003c/a\u003e \u003ca\u003e9\u003c/a\u003e \u003ca\u003e10\u003c/a\u003e \u003ca\u003e11\u003c/a\u003e \u003ca\u003e12\u003c/a\u003e \u003c/div\u003e div { display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: 100px; reading-flow: grid-rows; a:nth-child(2) { grid-row: 2 / 4; grid-column: 3; } a:nth-child(5) { grid-row: 1 / 3; grid-column: 1 / 3; } } Or, reading-flow: grid-columns will establish a column-by-column focus order: reading-flow: grid-order will give us the default grid behavior (i.e., the jumbled up version). This is also very akin to reading-flow: normal (except that, again, the container remains a reading flow container, which is needed for reading-order). There’s also reading-flow: source-order, which is for flex, grid, and block containers. It basically turns containers into reading flow containers, enabling us to use reading-order. To be frank, unless I’m missing something, this appears to make the flex-flow and grid-order values redundant? reading-order reading-order sort of does the same thing as reading-flow. The difference is that reading-order is for specific flex or grid items, or even elements in a simple block container. It works the same way as the order property, although I suppose we could also compare it to tabindex. Note: To use reading-order, the container must have the reading-flow property set to anything other than normal. I’ll demonstrate both reading-order and order at the same time. In the example below, we have another flex container where each flex item has the order property set to a different random number, making the order of the flex items random. Now, we’ve already established that we can use reading-flow to determine focus order regardless of visual order, but in the example below we’re using reading-order instead (in the exact same way as order): div { display: flex; reading-flow: source-order; /* Anything but normal */ /* Features at the end because of the higher values */ a:nth-child(1) { /* Visual order */ order: 567; /* Focus order */ reading-order: 567; } a:nth-child(2) { order: 456; reading-order: 456; } a:nth-child(3) { order: 345; reading-order: 345; } a:nth-child(4) { order: 234; reading-order: 234; } /* Features at the beginning because of the lower values */ a:nth-child(5) { order: -123; reading-order: -123; } } Yes, those are some rather odd numbers. I’ve done this to illustrate how the numbers don’t represent the position (e.g., order: 3 or reading-order: 3 doesn’t make it third in the order). Instead, elements with lower numbers are more towards the beginning of the order and elements with higher numbers are more towards the end. The default value is 0. Elements with the same value will be ordered by source order. In practical terms? Consider the following example: div { display: flex; reading-flow: source-order; a:nth-child(1) { order: 1; reading-order: 1; } a:nth-child(5) { order: -1; reading-order: -1; } } Of the five flex items, the first one is the one with order: -1 because it has the lowest order value. The last one is the one with order: 1 because it has the highest order value. The ones with no declaration default to having order: 0 and are thus ordered in source order, but otherwise fit in-between the order: -1 and order: 1 flex items. And it’s the same concept for reading-order, which in the example above mirrors order. However, when reversing the direction of flex items, keep in mind that order and reading-order work a little differently. For example, reading-order: -1 would, as expected, and pull a flex item to the beginning of the focus order. Meanwhile, order: -1 would pull it to the end of the visual order because the visual order is reversed (so we’d need to use order: 1 instead, even if that doesn’t seem right!): div { display: flex; flex-direction: row-reverse; reading-flow: source-order; a:nth-child(5) { /* Because of row-reverse, this actually makes it first */ order: 1; /* However, this behavior doesn’t apply to reading-order */ reading-order: -1; } } reading-order overrides reading-flow. If we, for example, apply reading-flow: flex-visual, reading-flow: grid-rows, or reading-flow: grid-columns (basically, any declaration that does in fact change the reading flow), reading-order overrides it. We could say that reading-order is applied after reading-flow. What if I don’t want to use flexbox or grid layout? Well, that obviously rules out all of the flex-y and grid-y reading-flow values; however, you can still set reading-flow: source-order on a block element and then manipulate the focus order with reading-order (as we did above). How does this relate to the tabindex HTML attribute? They’re not equivalent. Negative tabindex values make targets unfocusable and values other than 0 and -1 aren’t recommended, whereas a reading-order declaration can use any number as it’s only contextual to the reading flow container that contains it. For the sake of being complete though, I did test reading-order and tabindex together and reading-order appeared to override tabindex. Going forward, I’d only use tabindex (specifically, tabindex=\"-1\") to prevent certain targets from being focusable (the disabled attribute will be more appropriate for some targets though), and then reading-order for everything else. Closing thoughts Being able to define reading order is useful, or at least it means that the order property can finally be used as intended. Up until now (or rather when all web browsers support reading-flow and reading-order, because they only work in Chrome 137+ at the moment), order hasn’t been useful because we haven’t been able to make the focus order match the visual order.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/06/books-code.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eThe \u003ccode\u003ereading-flow\u003c/code\u003e and \u003ccode\u003ereading-order\u003c/code\u003e proposed CSS properties are designed to specify the source order of HTML elements in the DOM tree, or in simpler terms, how accessibility tools deduce the order of elements. You’d use them to make the focus order of focusable elements match the visual order, \u003ca href=\"https://www.w3.org/WAI/WCAG22/Understanding/focus-order\" rel=\"noopener\"\u003eas outlined in the Web Content Accessibility Guidelines\u003c/a\u003e (WCAG 2.2).\u003c/p\u003e\n\n\n\n\u003cp\u003eTo get a better idea, let’s just dive in!\u003c/p\u003e\n\n\n\n\u003cp\u003e(Oh, and make sure that you’re using Chrome 137 or higher.)\u003c/p\u003e\n\n\n\u003ch3 id=\"-reading-flow-\"\u003e\u003ccode\u003ereading-flow\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003e\u003ccode\u003ereading-flow\u003c/code\u003e determines the source order of HTML elements in a flex, grid, or block layout. Again, this is basically to help accessibility tools provide the correct focus order to users.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe default value is \u003ccode\u003enormal\u003c/code\u003e (so, \u003ccode\u003ereading-flow: normal\u003c/code\u003e). Other valid values include:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eflex-visual\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eflex-flow\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003egrid-rows\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003egrid-columns\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003egrid-order\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003esource-order\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eLet’s start with the \u003ccode\u003eflex-visual\u003c/code\u003e value. Imagine a flex row with five links. Assuming that the reading direction is left-to-right (by the way, you \u003cem\u003ecan\u003c/em\u003e change the reading direction with the \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/properties/d/direction/\"\u003edirection\u003c/a\u003e\u003c/code\u003e CSS property), that’d look something like this:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eNow, if we apply \u003ccode\u003eflex-direction: row-reverse\u003c/code\u003e, the links are displayed 5-4-3-2-1. The problem though is that the focus order still starts from 1 (tab through them!), which is visually wrong for somebody that reads left-to-right.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eBut if we also apply \u003ccode\u003ereading-flow: flex-visual\u003c/code\u003e, the focus order also becomes 5-4-3-2-1, matching the visual order (which is an accessibility requirement!):\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div\u0026gt;\n  \u0026lt;a\u0026gt;1\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;2\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;3\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;4\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;5\u0026lt;/a\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ediv {\n  display: flex;\n  flex-direction: row-reverse;\n  reading-flow: flex-visual;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eTo apply the default flex behavior, \u003ccode\u003ereading-flow: flex-flow\u003c/code\u003e is what you’re looking for. This is very akin to \u003ccode\u003ereading-flow: normal\u003c/code\u003e, except that the container remains a reading flow container, which is needed for \u003ccode\u003ereading-order\u003c/code\u003e (we’ll dive into this in a bit).\u003c/p\u003e\n\n\n\n\u003cp\u003eFor now, let’s take a look at the grid-y values. In the grid below, the grid items are all jumbled up, and so the focus order is all over the place.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWe can fix this in two ways. One way is that \u003ccode\u003ereading-flow: grid-rows\u003c/code\u003e will, as you’d expect, establish a row-by-row focus order:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div\u0026gt;\n  \u0026lt;a\u0026gt;1\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;2\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;3\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;4\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;5\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;6\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;7\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;8\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;9\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;10\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;11\u0026lt;/a\u0026gt;\n  \u0026lt;a\u0026gt;12\u0026lt;/a\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ediv {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  grid-auto-rows: 100px;\n  reading-flow: grid-rows;\n  \n  a:nth-child(2) {\n    grid-row: 2 / 4;\n    grid-column: 3;\n  }\n\n  a:nth-child(5) {\n    grid-row: 1 / 3;\n    grid-column: 1 / 3;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eOr, \u003ccode\u003ereading-flow: grid-columns\u003c/code\u003e will establish a column-by-column focus order:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003e\u003ccode\u003ereading-flow: grid-order\u003c/code\u003e will give us the default grid behavior (i.e., the jumbled up version). This is also very akin to \u003ccode\u003ereading-flow: normal\u003c/code\u003e (except that, again, the container remains a reading flow container, which is needed for \u003ccode\u003ereading-order\u003c/code\u003e).\u003c/p\u003e\n\n\n\n\u003cp\u003eThere’s also \u003ccode\u003ereading-flow: source-order\u003c/code\u003e, which is for flex, grid, \u003cem\u003eand\u003c/em\u003e block containers. It basically turns containers into reading flow containers, enabling us to use \u003ccode\u003ereading-order\u003c/code\u003e. To be frank, unless I’m missing something, this appears to make the \u003ccode\u003eflex-flow\u003c/code\u003e and \u003ccode\u003egrid-order\u003c/code\u003e values redundant?\u003c/p\u003e\n\n\n\u003ch3 id=\"-reading-order-\"\u003e\u003ccode\u003ereading-order\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003e\u003ccode\u003ereading-order\u003c/code\u003e sort of does the same thing as \u003ccode\u003ereading-flow\u003c/code\u003e. The difference is that \u003ccode\u003ereading-order\u003c/code\u003e is for \u003cem\u003especific\u003c/em\u003e flex or grid items, or even elements in a simple block container. It works the same way as the \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/properties/o/order/\"\u003eorder\u003c/a\u003e\u003c/code\u003e property, although I suppose we could also compare it to \u003ccode\u003e\u003ca href=\"https://css-tricks.com/focus-management-and-inert/\"\u003etabindex\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e To use \u003ccode\u003ereading-order\u003c/code\u003e, the container must have the \u003ccode\u003ereading-flow\u003c/code\u003e property set to anything other than \u003ccode\u003enormal\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eI’ll demonstrate both \u003ccode\u003ereading-order\u003c/code\u003e and \u003ccode\u003eorder\u003c/code\u003e at the same time. In the example below, we have another flex container where each flex item has the \u003ccode\u003eorder\u003c/code\u003e property set to a different random number, making the order of the flex items random. Now, we’ve already established that we can use \u003ccode\u003ereading-flow\u003c/code\u003e to determine focus order regardless of visual order, but in the example below we’re using \u003ccode\u003ereading-order\u003c/code\u003e instead (in the \u003cem\u003eexact\u003c/em\u003e same way as \u003ccode\u003eorder\u003c/code\u003e):\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ediv {\n  display: flex;\n  reading-flow: source-order; /* Anything but normal */\n\n  /* Features at the end because of the higher values */\n  a:nth-child(1) {\n    /* Visual order */\n    order: 567;\n    /* Focus order */\n    reading-order: 567;\n  }\n\n  a:nth-child(2) {\n    order: 456;\n    reading-order: 456;\n  }\n\n  a:nth-child(3) {\n    order: 345;\n    reading-order: 345;\n  }\n\n  a:nth-child(4) {\n    order: 234;\n    reading-order: 234;\n  }\n\n  /* Features at the beginning because of the lower values */\n  a:nth-child(5) {\n    order: -123;\n    reading-order: -123;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eYes, those are some rather odd numbers. I’ve done this to illustrate how the numbers don’t represent the position (e.g., \u003ccode\u003eorder: 3\u003c/code\u003e or \u003ccode\u003ereading-order: 3\u003c/code\u003e doesn’t make it third in the order). Instead, elements with lower numbers are more towards the beginning of the order and elements with higher numbers are more towards the end. The default value is \u003ccode\u003e0\u003c/code\u003e. Elements with the same value will be ordered by source order.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn practical terms? Consider the following example:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ediv {\n  display: flex;\n  reading-flow: source-order;\n\n  a:nth-child(1) {\n    order: 1;\n    reading-order: 1;\n  }\n\n  a:nth-child(5) {\n    order: -1;\n    reading-order: -1;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eOf the five flex items, the first one is the one with \u003ccode\u003eorder: -1\u003c/code\u003e because it has the lowest \u003ccode\u003eorder\u003c/code\u003e value. The last one is the one with \u003ccode\u003eorder: 1\u003c/code\u003e because it has the \u003cem\u003ehighest\u003c/em\u003e \u003ccode\u003eorder\u003c/code\u003e value. The ones with no declaration default to having \u003ccode\u003eorder: 0\u003c/code\u003e and are thus ordered in source order, but otherwise fit in-between the \u003ccode\u003eorder: -1\u003c/code\u003e and \u003ccode\u003eorder: 1\u003c/code\u003e flex items. And it’s the same concept for \u003ccode\u003ereading-order\u003c/code\u003e, which in the example above mirrors \u003ccode\u003eorder\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eHowever, when reversing the direction of flex items, keep in mind that \u003ccode\u003eorder\u003c/code\u003e and \u003ccode\u003ereading-order\u003c/code\u003e work a little differently. For example, \u003ccode\u003ereading-order: -1\u003c/code\u003e would, as expected, and pull a flex item to the beginning of the focus order. Meanwhile, \u003ccode\u003eorder: -1\u003c/code\u003e would pull it to the \u003cem\u003eend\u003c/em\u003e of the visual order because the visual order is reversed (so we’d need to use \u003ccode\u003eorder: 1\u003c/code\u003e instead, even if that doesn’t seem right!):\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ediv {\n  display: flex;\n  flex-direction: row-reverse;\n  reading-flow: source-order;\n\n  a:nth-child(5) {\n    /* Because of row-reverse, this actually makes it first */\n    order: 1;\n    /* However, this behavior doesn’t apply to reading-order */\n    reading-order: -1;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003e\u003ccode\u003ereading-order\u003c/code\u003e overrides \u003ccode\u003ereading-flow\u003c/code\u003e. If we, for example, apply \u003ccode\u003ereading-flow: flex-visual\u003c/code\u003e, \u003ccode\u003ereading-flow: grid-rows\u003c/code\u003e, or \u003ccode\u003ereading-flow: grid-columns\u003c/code\u003e (basically, any declaration that does in fact change the reading flow), \u003ccode\u003ereading-order\u003c/code\u003e overrides it. We could say that \u003ccode\u003ereading-order\u003c/code\u003e is applied after \u003ccode\u003ereading-flow\u003c/code\u003e.\u003c/p\u003e\n\n\n\u003ch3 id=\"what-if-i-don-t-want-to-use-flexbox-or-grid-layout-\"\u003eWhat if I don’t want to use flexbox or grid layout?\u003c/h3\u003e\n\n\n\u003cp\u003eWell, that obviously rules out all of the flex-y and grid-y \u003ccode\u003ereading-flow\u003c/code\u003e values; however, you can still set \u003ccode\u003ereading-flow: source-order\u003c/code\u003e on a block element and then manipulate the focus order with \u003ccode\u003ereading-order\u003c/code\u003e (as we did above).\u003c/p\u003e\n\n\n\u003ch3 id=\"how-does-this-relate-to-the-tabindex-html-attribute-\"\u003eHow does this relate to the \u003ccode\u003etabindex\u003c/code\u003e HTML attribute?\u003c/h3\u003e\n\n\n\u003cp\u003e\u003cstrong\u003eThey’re not equivalent.\u003c/strong\u003e Negative \u003ccode\u003etabindex\u003c/code\u003e values make targets unfocusable and values other than \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003e-1\u003c/code\u003e aren’t recommended, whereas a \u003ccode\u003ereading-order\u003c/code\u003e declaration can use any number as it’s only contextual to the reading flow container that contains it.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor the sake of being complete though, I did test \u003ccode\u003ereading-order\u003c/code\u003e and \u003ccode\u003etabindex\u003c/code\u003e together and \u003ccode\u003ereading-order\u003c/code\u003e appeared to override \u003ccode\u003etabindex\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eGoing forward, I’d only use \u003ccode\u003etabindex\u003c/code\u003e (specifically, \u003ccode\u003etabindex=\u0026#34;-1\u0026#34;\u003c/code\u003e) to prevent certain targets from being focusable (the \u003ccode\u003edisabled\u003c/code\u003e attribute will be more appropriate for some targets though), and then \u003ccode\u003ereading-order\u003c/code\u003e for everything else.\u003c/p\u003e\n\n\n\u003ch3 id=\"closing-thoughts\"\u003eClosing thoughts\u003c/h3\u003e\n\n\n\u003cp\u003eBeing able to define reading order is useful, or at least it means that the \u003ccode\u003eorder\u003c/code\u003e property can finally be used as intended. Up until now (or rather when all web browsers support \u003ccode\u003ereading-flow\u003c/code\u003e and \u003ccode\u003ereading-order\u003c/code\u003e, because they only work in Chrome 137+ at the moment), \u003ccode\u003eorder\u003c/code\u003e hasn’t been useful because we haven’t been able to make the focus order match the visual order.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-05-27T07:02:32-06:00",
  "modifiedTime": "2025-05-27T07:02:34-06:00"
}
