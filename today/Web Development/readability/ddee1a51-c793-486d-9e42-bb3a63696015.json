{
  "id": "ddee1a51-c793-486d-9e42-bb3a63696015",
  "title": "Slide Through Unlimited Dimensions With CSS Scroll Timelines",
  "link": "https://css-tricks.com/slide-through-unlimited-dimensions-with-css-scroll-timelines/",
  "description": "The creator of CSS has said he originally envisaged CSS as the main web technology to control behavior on web pages, with scripting as a fallback when things weren’t possible declaratively in CSS. The rationale for a CSS-first approach was … Slide Through Unlimited Dimensions With CSS Scroll Timelines originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Lee Meyer",
  "published": "Fri, 27 Sep 2024 18:39:23 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "Scroll Driven Animation"
  ],
  "byline": "Lee Meyer",
  "length": 6990,
  "excerpt": "The creator of CSS has said he originally envisaged CSS as the main web technology to control behavior on web pages, with scripting as a fallback when things",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "DigitalOcean provides cloud products for every stage of your journey. Get started with $200 in free credit! The creator of CSS has said he originally envisaged CSS as the main web technology to control behavior on web pages, with scripting as a fallback when things weren’t possible declaratively in CSS. The rationale for a CSS-first approach was that “scripting is programming and programming is hard.” Since introducing the :hover pseudo-class, CSS has been standardizing patterns developers create in JavaScript and “harvesting” them into CSS standards. When you think about it like that, it’s almost as if JavaScript is the hack and CSS is the official way. We can, therefore, feel less dirty implementing script-like behavior with CSS, and we shouldn’t be surprised that something like the new scroll-timeline feature has appeared with pretty good browser support. Too many developers implemented clever parallax scrolling websites, which has summoned the CSS feature genie we cannot put back in its bottle. If you don’t want janky main-thread animations for your next parallax-scrolling website, you must now come to the dark side of hacking CSS. Just kidding, there is also a new JavaScript API for scroll-linked animations if imperative programming better fits your use case. Migrating a JavaScript sample to CSS It was satisfyingly simple to fork Chris Coyier’s pre-scroll-timeline example of a scroll-linked animation by replacing the CSS Chris was using to control the animations with just one line of CSS and completely deleting the JavaScript! body, .progress, .cube { animation-timeline: scroll(); } Using the scroll() function without parameters sets up an “anonymous scroll progress timeline” meaning the browser will base the animation on the nearest ancestor that can scroll vertically if our writing mode is English. Unfortunately, it seems we can only choose to animate based on scrolling along the x or y-axis of a particular element but not both, which would be useful. Being a function, we can pass parameters to scroll(), which provides more control over how we want scrolling to run our animation. Experimenting with multiple dimensions Even better is the scroll-scope property. Applying that to a container element means we can animate properties on any chosen ancestor element based on any scrollable element that has the same assigned scope. That got me thinking… Since CSS Houdini lets us register animation-friendly, inheritable properties in CSS, we can combine animations on the same element based on multiple scrollable areas on the page. That opens the door for interesting instructional design possibilities such as my experiment below. Scrolling the horizontal narrative on the light green card rotates the 3D NES console horizontally and scrolling the vertical narrative on the dark green card rotates the NES console vertically. In my previous article, I noted that my past CSS hacks have always boiled down to hiding and showing finite possibilities using CSS. What interests me about this scroll-based experiment is the combinatorial explosion of combined vertical and horizontal rotations. Animation timelines provide an interactivity in pure CSS that hasn’t been possible in the past. The implementation details are less important than the timeline-scope usage and the custom properties. We register two custom angle properties: @property --my-y-angle { syntax: \"\u003cangle\u003e\"; inherits: true; initial-value: 0deg; } @property --my-x-angle { syntax: \"\u003cangle\u003e\"; inherits: true; initial-value: -35deg; } Then, we “borrow” the NES 3D model from the samples in Julian Garner’s amazing CSS 3D modeling app. We update the .scene class for the 3D to base the rotation on our new variables like this: .scene { transform: rotateY(var(--my-y-angle)) rotateX(var(--my-x-angle)); } Next, we give the \u003cbody\u003e element a timeline-scope with two custom-named scopes. body { timeline-scope: --myScroller,--myScroller2; } I haven’t seen anything officially documented about passing in multiple scopes, but it does work in Google Chrome and Edge. If it’s not a formally supported feature, I hope it will become part of the standard because it is ridiculously handy. Next, we define the named timelines for the two scrollable cards and the axes we want to trigger our animations. .card:first-child { scroll-timeline-axis: x; scroll-timeline-name: --myScroller; } .card:nth-child(2) { scroll-timeline-axis: y; scroll-timeline-name: --myScroller2; } And add the animations to the scene: .scene { animation: rotateHorizontal,rotateVertical; animation-timeline: --myScroller,--myScroller2; } @keyframes rotateHorizontal { to { --my-y-angle: 360deg; } } @keyframes rotateVertical { to { --my-x-angle: 360deg; } } Since the 3D model inherits the x and y angles from the document body, scrolling the cards now rotates the model in combinations of vertical and horizontal angle changes. User-controlled animations beyond scrollbars When you think about it, this behavior isn’t just useful for scroll-driven animations. In the above experiment, we are using the scrollable areas more like sliders that control the properties of our 3D model. After getting it working, I went for a walk and was daydreaming about how cool it would be if actual range inputs could control animation timelines. Then I found out they can! At least in Chrome. Pure CSS CMS anyone? While we’re commandeering 3D models from Julian Garner, let’s see if we can use range inputs to control his X-wing model. It’s mind-boggling that we can achieve this with just CSS, and we could do it with an arbitrary number of properties. It doesn’t go far enough for me. I would love to see other input controls that can manipulate animation timelines. Imagine text fields progressing animations as you fill them out, or buttons able to play or reverse animations. The latter can be somewhat achieved by combining the :active pseudo-class with the animation-play-state property. But in my experience when you try to use that to animate multiple custom properties, the browser can get confused. By contrast, animation timelines have been implemented with this use case in mind and therefore work smoothly and exactly as I expected. I’m not the only one who has noticed the potential for hacking this emergent CSS feature. Someone has already implemented this clever Doom clone by combining scroll-timeline with checkbox hacks. The problem I have is it still doesn’t go far enough. We have enough in Chrome to implement avatar builders using scrollbars and range inputs as game controls. I am excited to experiment with unpredictable, sophisticated experiences that are unprecedented in the era before the scroll-timeline feature. After all, if you had to explain the definition of a video game to an alien, wouldn’t you say it is just a hyper-interactive animation?",
  "image": "https://css-tricks.com/wp-json/social-image-generator/v1/image/381191",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cp\u003e\n\tDigitalOcean provides cloud products for every stage of your journey. Get started with \u003ca href=\"https://try.digitalocean.com/css-tricks/?utm_medium=content_acq\u0026amp;utm_source=css-tricks\u0026amp;utm_campaign=global_brand_ad_en\u0026amp;utm_content=conversion_prearticle_everystage\"\u003e$200 in free credit!\u003c/a\u003e\n\u003c/p\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eThe creator of CSS \u003ca href=\"https://www.youtube.com/watch?v=EEJBJGNmzkI\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ehas said\u003c/a\u003e he originally envisaged CSS as the main web technology to control behavior on web pages, with scripting as a fallback when things weren’t possible declaratively in CSS. The rationale for a CSS-first approach was that “scripting is programming and programming is hard.” Since introducing \u003ca href=\"https://css-tricks.com/almanac/pseudo-selectors/h/hover/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ethe \u003ccode\u003e:hover\u003c/code\u003e pseudo-class\u003c/a\u003e, CSS has been standardizing patterns developers create in JavaScript and “harvesting” them into CSS standards. When you think about it like that, it’s almost as if JavaScript is the hack and CSS is the official way.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can, therefore, feel less dirty implementing script-like behavior with CSS, and we shouldn’t be surprised that something like the new \u003ca href=\"https://caniuse.com/?search=css-scroll-timeline\" target=\"_blank\" rel=\"noreferrer noopener\"\u003e\u003ccode\u003escroll-timeline\u003c/code\u003e\u003c/a\u003e feature has appeared with pretty good browser support. Too many developers implemented \u003ca href=\"https://keithclark.co.uk/articles/pure-css-parallax-websites/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eclever parallax scrolling\u003c/a\u003e websites, which has summoned the CSS feature genie we cannot put back in its bottle. If you don’t want janky main-thread animations for your next parallax-scrolling website, you must now come to the dark side of hacking CSS. \u003cem\u003eJust kidding\u003c/em\u003e, there is also a new \u003ca href=\"https://developer.chrome.com/blog/scroll-animation-performance-case-study#new_scroll-driven_animations_javascript_api_versus_classic_javascript\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eJavaScript API\u003c/a\u003e for scroll-linked animations if imperative programming better fits your use case.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"migrating-a-javascript-sample-to-css\"\u003eMigrating a JavaScript sample to CSS\u003c/h3\u003e\n\n\n\u003cp\u003eIt was satisfyingly simple to fork \u003ca href=\"https://codepen.io/chriscoyier/pen/NWxpJVx\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eChris Coyier’s pre-\u003ccode\u003escroll-timeline\u003c/code\u003e example\u003c/a\u003e of a scroll-linked animation by replacing the CSS Chris was using to control the animations with just \u003cem\u003eone\u003c/em\u003e line of CSS and completely deleting the JavaScript!\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebody, .progress, .cube {\n  animation-timeline: scroll();\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eUsing the \u003ccode\u003escroll()\u003c/code\u003e function without parameters sets up an “anonymous scroll progress timeline” meaning the browser will base the animation on the nearest ancestor that can scroll vertically if our writing mode is English. Unfortunately, it seems we can only choose to animate based on scrolling along the x or y-axis of a particular element but not both, which would be useful. Being a function, we can \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timeline/scroll\" target=\"_blank\" rel=\"noreferrer noopener\"\u003epass parameters\u003c/a\u003e to \u003ccode\u003escroll()\u003c/code\u003e, which provides more control over how we want scrolling to run our animation.\u003c/p\u003e\n\n\n\u003ch3 id=\"experimenting-with-multiple-dimensions\"\u003eExperimenting with multiple dimensions\u003c/h3\u003e\n\n\n\u003cp\u003eEven better is the \u003ccode\u003escroll-scope\u003c/code\u003e property. Applying that to a container element means we can animate properties on any chosen ancestor element based on any scrollable element that has the same assigned scope. That got me thinking… Since \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Houdini\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCSS Houdini\u003c/a\u003e lets us register animation-friendly, inheritable properties in CSS, we can combine animations on the same element based on multiple scrollable areas on the page. That opens the door for interesting instructional design possibilities such as my experiment below.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eScrolling the horizontal narrative on the light green card rotates the 3D NES console horizontally and scrolling the vertical narrative on the dark green card rotates the NES console vertically. In my \u003ca href=\"https://css-tricks.com/time-travelling-css-with-target/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eprevious article\u003c/a\u003e, I noted that my past CSS hacks have always boiled down to hiding and showing finite possibilities using CSS. What interests me about this scroll-based experiment is the combinatorial explosion of combined vertical and horizontal rotations. Animation timelines provide an interactivity in pure CSS that hasn’t been possible in the past.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe implementation details are less important than the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/timeline-scope\" target=\"_blank\" rel=\"noreferrer noopener\"\u003e\u003ccode\u003etimeline-scope\u003c/code\u003e\u003c/a\u003e usage and the custom properties. We register two custom angle properties:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@property --my-y-angle {\n  syntax: \u0026#34;\u0026lt;angle\u0026gt;\u0026#34;;\n  inherits: true;\n  initial-value: 0deg;\n}\n\n@property --my-x-angle {\n  syntax: \u0026#34;\u0026lt;angle\u0026gt;\u0026#34;;\n  inherits: true;\n  initial-value: -35deg;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThen, we “borrow” the NES 3D model from the samples in Julian Garner’s amazing \u003ca href=\"https://tridiv.com/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCSS 3D modeling app\u003c/a\u003e. We update the \u003ccode\u003e.scene\u003c/code\u003e class for the 3D to base the rotation on our new variables like this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.scene {\n  transform: rotateY(var(--my-y-angle)) rotateX(var(--my-x-angle));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, we give the \u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e element a \u003ccode\u003etimeline-scope\u003c/code\u003e with two custom-named scopes.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebody {\n  timeline-scope: --myScroller,--myScroller2; \n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eI haven’t seen anything officially documented about passing in multiple scopes, but it does work in Google Chrome and Edge. If it’s not a formally supported feature, I hope it will become part of the standard because it is ridiculously handy.\u003c/p\u003e\n\n\n\n\u003cp\u003eNext, we define the named timelines for the two scrollable cards and the axes we want to trigger our animations.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.card:first-child {\n  scroll-timeline-axis: x;\n  scroll-timeline-name: --myScroller;\n}\n\n.card:nth-child(2) {\n  scroll-timeline-axis: y;\n  scroll-timeline-name: --myScroller2;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd add the animations to the scene:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.scene {\n  animation: rotateHorizontal,rotateVertical;\n  animation-timeline: --myScroller,--myScroller2;\n}\n\n@keyframes rotateHorizontal {\n  to {\n    --my-y-angle: 360deg;\n  }\n}\n\n@keyframes rotateVertical {\n  to {\n    --my-x-angle: 360deg;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSince the 3D model inherits the x and y angles from the document body, scrolling the cards now rotates the model in combinations of vertical and horizontal angle changes.\u003c/p\u003e\n\n\n\u003ch3 id=\"usercontrolled-animations-beyond-scrollbars\"\u003eUser-controlled animations beyond scrollbars\u003c/h3\u003e\n\n\n\u003cp\u003eWhen you think about it, this behavior isn’t just useful for scroll-driven animations. In the above experiment, we are using the scrollable areas more like sliders that control the properties of our 3D model. After getting it working, I went for a walk and was daydreaming about how cool it would be if actual range inputs could control animation timelines. Then I found out they can! At \u003ca target=\"_blank\" href=\"https://codepen.io/t_afif/pen/GRbawQm\" rel=\"noreferrer noopener\"\u003eleast in Chrome\u003c/a\u003e. Pure CSS CMS anyone?\u003c/p\u003e\n\n\n\n\u003cp\u003eWhile we’re commandeering 3D models from Julian Garner, let’s see if we can use range inputs to control his X-wing model.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eIt’s mind-boggling that we can achieve this with just CSS, and we could do it with an arbitrary number of properties. It doesn’t go far enough for me. I would love to see other input controls that can manipulate animation timelines. Imagine text fields progressing animations as you fill them out, or buttons able to play or reverse animations. The latter can be somewhat achieved by combining the \u003ccode\u003e:active\u003c/code\u003e pseudo-class with the \u003ccode\u003eanimation-play-state\u003c/code\u003e property. But in my experience when you try to use that to animate multiple custom properties, the browser can get confused. By contrast, animation timelines have been implemented with this use case in mind and therefore work smoothly and exactly as I expected.\u003c/p\u003e\n\n\n\n\u003cp\u003eI’m not the only one who has noticed the potential for hacking this emergent CSS feature. Someone has already implemented this \u003ca href=\"https://codepen.io/cobra_winfrey/pen/oNOMRav\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eclever Doom clone\u003c/a\u003e by combining scroll-timeline with \u003ca href=\"https://css-tricks.com/the-checkbox-hack/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003echeckbox hacks\u003c/a\u003e. The problem I have is it still doesn’t go far enough. We have enough in Chrome to implement avatar builders using scrollbars and range inputs as game controls. I am excited to experiment with unpredictable, sophisticated experiences that are unprecedented in the era before the scroll-timeline feature. After all, if you had to explain the definition of a video game to an alien, wouldn’t you say it is just a hyper-interactive animation?\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-09-27T12:39:23-06:00",
  "modifiedTime": "2024-09-27T12:39:26-06:00"
}
