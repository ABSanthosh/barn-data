{
  "id": "e5c90c13-7daf-4b7a-979a-8cc8c13cea5f",
  "title": "CSS Carousels",
  "link": "https://css-tricks.com/css-carousels/",
  "description": "Chrome has prototyped these features and released them in Chrome 135. Adam Argyle has a wonderful explainer over at the Chrome Developer blog. Kevin Powell has an equally wonderful video where he follows the explainer. This post is me taking notes from them. CSS Carousels originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Geoff Graham",
  "published": "Wed, 09 Apr 2025 13:00:24 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Notes",
    "carousel"
  ],
  "byline": "Geoff Graham",
  "length": 7351,
  "excerpt": "Chrome has prototyped these features and released them in Chrome 135. Adam Argyle has a wonderful explainer over at the Chrome Developer blog. Kevin Powell has an equally wonderful video where he follows the explainer. This post is me taking notes from them.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "The CSS Overflow Module Level 5 specification defines a couple of new features that are designed for creating carousel UI patterns: Scroll Buttons: Buttons that the browser provides, as in literal \u003cbutton\u003e elements, that scroll the carousel content 85% of the area when clicked. Scroll Markers: The little dots that act as anchored links, as in literal \u003ca\u003e elements that scroll to a specific carousel item when clicked. Chrome has prototyped these features and released them in Chrome 135. Adam Argyle has a wonderful explainer over at the Chrome Developer blog. Kevin Powell has an equally wonderful video where he follows the explainer. This post is me taking notes from them. First, some markup: \u003cul class=\"carousel\"\u003e \u003cli\u003e...\u003c/li\u003e \u003cli\u003e...\u003c/li\u003e \u003cli\u003e...\u003c/li\u003e \u003cli\u003e...\u003c/li\u003e \u003cli\u003e...\u003c/li\u003e \u003c/ul\u003e First, let’s set these up in a CSS auto grid that displays the list items in a single line: .carousel { display: grid; grid-auto-flow: column; } We can tailor this so that each list item takes up a specific amount of space, say 40%, and insert a gap between them: .carousel { display: grid; grid-auto-flow: column; grid-auto-columns: 40%; gap: 2rem; } This gives us a nice scrolling area to advance through the list items by moving left and right. We can use CSS Scroll Snapping to ensure that scrolling stops on each item in the center rather than scrolling right past them. .carousel { display: grid; grid-auto-flow: column; grid-auto-columns: 40%; gap: 2rem; scroll-snap-type: x mandatory; \u003e li { scroll-snap-align: center; } } Kevin adds a little more flourish to the .carousel so that it is easier to see what’s going on. Specifically, he adds a border to the entire thing as well as padding for internal spacing. So far, what we have is a super simple slider of sorts where we can either scroll through items horizontally or click the left and right arrows in the scroller. We can add scroll buttons to the mix. We get two buttons, one to navigate one direction and one to navigate the other direction, which in this case is left and right, respectively. As you might expect, we get two new pseudo-elements for enabling and styling those buttons: ::scroll-button(left) ::scroll-button(right) Interestingly enough, if you crack open DevTools and inspect the scroll buttons, they are actually exposed with logical terms instead, ::scroll-button(inline-start) and ::scroll-button(inline-end). And both of those support the CSS content property, which we use to insert a label into the buttons. Let’s keep things simple and stick with “Left” and “Right” as our labels for now: .carousel::scroll-button(left) { content: \"Left\"; } .carousel::scroll-button(right) { content: \"Right\"; } Now we have two buttons above the carousel. Clicking them either advances the carousel left or right by 85%. Why 85%? I don’t know. And neither does Kevin. That’s just what it says in the specification. I’m sure there’s a good reason for it and we’ll get more light shed on it at some point. But clicking the buttons in this specific example will advance the scroll only one list item at a time because we’ve set scroll snapping on it to stop at each item. So, even though the buttons want to advance by 85% of the scrolling area, we’re telling it to stop at each item. Remember, this is only supported in Chrome at the time of writing: We can select both buttons together in CSS, like this: .carousel::scroll-button(left), .carousel::scroll-button(right) { /* Styles */ } Or we can use the Universal Selector: .carousel::scroll-button(*) { /* Styles */ } And we can even use newer CSS Anchor Positioning to set the left button on the carousel’s left side and the right button on the carousel’s right side: .carousel { /* ... */ anchor-name: --carousel; /* define the anchor */ } .carousel::scroll-button(*) { position: fixed; /* set containment on the target */ position-anchor: --carousel; /* set the anchor */ } .carousel::scroll-button(left) { content: \"Left\"; position-area: center left; } .carousel::scroll-button(right) { content: \"Right\"; position-area: center right; } Notice what happens when navigating all the way to the left or right of the carousel. The buttons are disabled, indicating that you have reached the end of the scrolling area. Super neat! That’s something that is normally in JavaScript territory, but we’re getting it for free. Let’s work on the scroll markers, or those little dots that sit below the carousel’s content. Each one is an \u003ca\u003e element anchored to a specific list item in the carousel so that, when clicked, you get scrolled directly to that item. We get a new pseudo-element for the entire group of markers called ::scroll-marker-group that we can use to style and position the container. In this case, let’s set Flexbox on the group so that we can display them on a single line and place gaps between them in the center of the carousel’s inline size: .carousel::scroll-marker-group { display: flex; justify-content: center; gap: 1rem; } We also get a new scroll-marker-group property that lets us position the group either above (before) the carousel or below (after) it: .carousel { /* ... */ scroll-marker-group: after; /* displayed below the content */ } We can style the markers themselves with the new ::scroll-marker pseudo-element: .carousel { /* ... */ \u003e li::scroll-marker { content: \"\"; aspect-ratio: 1; border: 2px solid CanvasText; border-radius: 100%; width: 20px; } } When clicking on a marker, it becomes the “active” item of the bunch, and we get to select and style it with the :target-current pseudo-class: li::scroll-marker:target-current { background: CanvasText; } Take a moment to click around the markers. Then take a moment using your keyboard and appreciate that we can all of the benefits of focus states as well as the ability to cycle through the carousel items when reaching the end of the markers. It’s amazing what we’re getting for free in terms of user experience and accessibility. We can further style the markers when they are hovered or in focus: li::scroll-marker:hover, li::scroll-marker:focus-visible { background: LinkText; } And we can “animate” the scrolling effect by setting scroll-behavior: smooth on the scroll snapping. Adam smartly applies it when the user’s motion preferences allow it: .carousel { /* ... */ @media (prefers-reduced-motion: no-preference) { scroll-behavior: smooth; } } Buuuuut that seems to break scroll snapping a bit because the scroll buttons are attempting to slide things over by 85% of the scrolling space. Kevin had to fiddle with his grid-auto-columns sizing to get things just right, but showed how Adam’s example took a different sizing approach. It’s a matter of fussing with things to get them just right. This is just a super early look at CSS Carousels. Remember that this is only supported in Chrome 135+ at the time I’m writing this, and it’s purely experimental. So, play around with it, get familiar with the concepts, and then be open-minded to changes in the future as the CSS Overflow Level 5 specification is updated and other browsers begin building support.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2019/12/carousel-slides.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eThe \u003ca href=\"https://www.w3.org/TR/css-overflow-5/\" rel=\"noopener\"\u003eCSS Overflow Module Level 5 specification\u003c/a\u003e defines a couple of new features that are designed for creating carousel UI patterns:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://www.w3.org/TR/css-overflow-5/#scroll-buttons\" rel=\"noopener\"\u003eScroll Buttons\u003c/a\u003e:\u003c/strong\u003e Buttons that the browser provides, as in literal \u003ccode\u003e\u0026lt;button\u0026gt;\u003c/code\u003e elements, that scroll the carousel content 85% of the area when clicked.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://www.w3.org/TR/css-overflow-5/#scroll-markers\" rel=\"noopener\"\u003eScroll Markers\u003c/a\u003e:\u003c/strong\u003e The little dots that act as anchored links, as in literal \u003ccode\u003e\u0026lt;a\u0026gt;\u003c/code\u003e elements that scroll to a specific carousel item when clicked.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eChrome has prototyped these features and \u003ca href=\"https://developer.chrome.com/blog/new-in-chrome-135?hl=en\" rel=\"noopener\"\u003ereleased them in Chrome 135\u003c/a\u003e. Adam Argyle has a \u003ca href=\"https://drafts.csswg.org/css-overflow-5/\" rel=\"noopener\"\u003ewonderful explainer\u003c/a\u003e over at the Chrome Developer blog. Kevin Powell has an equally \u003ca href=\"https://www.youtube.com/watch?v=g03Yldh9Nkw\" rel=\"noopener\"\u003ewonderful video\u003c/a\u003e where he follows the explainer. This post is me taking notes from them.\u003c/p\u003e\n\n\n\n\u003cp\u003eFirst, some markup:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;ul class=\u0026#34;carousel\u0026#34;\u0026gt;\n  \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFirst, let’s set these up in a CSS auto grid that displays the list items in a single line:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.carousel {\n  display: grid;\n  grid-auto-flow: column;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe can tailor this so that each list item takes up a specific amount of space, say \u003ccode\u003e40%\u003c/code\u003e, and insert a \u003ccode\u003egap\u003c/code\u003e between them:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.carousel {\n  display: grid;\n  grid-auto-flow: column;\n  grid-auto-columns: 40%;\n  gap: 2rem;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis gives us a nice scrolling area to advance through the list items by moving left and right. We can use \u003ca href=\"https://css-tricks.com/practical-css-scroll-snapping/\"\u003eCSS Scroll Snapping\u003c/a\u003e to ensure that scrolling stops on each item in the center rather than scrolling right past them.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.carousel {\n  display: grid;\n  grid-auto-flow: column;\n  grid-auto-columns: 40%;\n  gap: 2rem;\n\n  scroll-snap-type: x mandatory;\n\n  \u0026gt; li {\n    scroll-snap-align: center;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eKevin adds a little more flourish to the \u003ccode\u003e.carousel\u003c/code\u003e so that it is easier to see what’s going on. Specifically, he adds a \u003ccode\u003eborder\u003c/code\u003e to the entire thing as well as \u003ccode\u003epadding\u003c/code\u003e for internal spacing.\u003c/p\u003e\n\n\n\n\u003cp\u003eSo far, what we have is a super simple slider of sorts where we can either scroll through items horizontally or click the left and right arrows in the scroller.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can add scroll buttons to the mix. We get two buttons, one to navigate one direction and one to navigate the other direction, which in this case is left and right, respectively. As you might expect, we get two new pseudo-elements for enabling and styling those buttons:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e::scroll-button(left)\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e::scroll-button(right)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eInterestingly enough, if you crack open DevTools and inspect the scroll buttons, they are actually exposed with logical terms instead, \u003ccode\u003e::scroll-button(inline-start)\u003c/code\u003e and \u003ccode\u003e::scroll-button(inline-end)\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"2062\" height=\"1456\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/04/css-carousels-scroll-button-devtools.png?resize=2062%2C1456\u0026amp;ssl=1\" alt=\"DevTools with an arrow pointing at the two scroll buttons in the HTML showing them with logical naming.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/04/css-carousels-scroll-button-devtools.png?w=2062\u0026amp;ssl=1 2062w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/04/css-carousels-scroll-button-devtools.png?resize=300%2C212\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/04/css-carousels-scroll-button-devtools.png?resize=1024%2C723\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/04/css-carousels-scroll-button-devtools.png?resize=768%2C542\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/04/css-carousels-scroll-button-devtools.png?resize=1536%2C1085\u0026amp;ssl=1 1536w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/04/css-carousels-scroll-button-devtools.png?resize=2048%2C1446\u0026amp;ssl=1 2048w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAnd both of those support the CSS \u003ccode\u003econtent\u003c/code\u003e property, which we use to insert a label into the buttons. Let’s keep things simple and stick with “Left” and “Right” as our labels for now:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.carousel::scroll-button(left) {\n  content: \u0026#34;Left\u0026#34;;\n}\n.carousel::scroll-button(right) {\n  content: \u0026#34;Right\u0026#34;;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow we have two buttons above the carousel. Clicking them either advances the carousel left or right by 85%. Why 85%? I don’t know. And neither does Kevin. That’s just what it says in the specification. I’m sure there’s a good reason for it and we’ll get more light shed on it at some point.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut clicking the buttons in this specific example will advance the scroll only one list item at a time because we’ve set scroll snapping on it to stop at each item. So, even though the buttons want to advance by 85% of the scrolling area, we’re telling it to stop at each item.\u003c/p\u003e\n\n\n\n\u003cp\u003eRemember, this is only supported in Chrome at the time of writing:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWe can select both buttons together in CSS, like this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.carousel::scroll-button(left),\n.carousel::scroll-button(right) {\n  /* Styles */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOr we can use the Universal Selector:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.carousel::scroll-button(*) {\n  /* Styles */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd we can even use newer \u003ca href=\"https://css-tricks.com/css-anchor-positioning-guide/\"\u003eCSS Anchor Positioning\u003c/a\u003e to set the left button on the carousel’s left side and the right button on the carousel’s right side:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.carousel {\n  /* ... */\n  anchor-name: --carousel; /* define the anchor */\n}\n\n.carousel::scroll-button(*) {\n  position: fixed; /* set containment on the target */\n  position-anchor: --carousel; /* set the anchor */\n}\n\n.carousel::scroll-button(left) {\n  content: \u0026#34;Left\u0026#34;;\n  position-area: center left;\n}\n.carousel::scroll-button(right) {\n  content: \u0026#34;Right\u0026#34;;\n  position-area: center right;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNotice what happens when navigating all the way to the left or right of the carousel. The buttons are disabled, indicating that you have reached the end of the scrolling area. Super neat! That’s something that is normally in JavaScript territory, but we’re getting it for free.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eLet’s work on the scroll markers, or those little dots that sit below the carousel’s content. Each one is an \u003ccode\u003e\u0026lt;a\u0026gt;\u003c/code\u003e element anchored to a specific list item in the carousel so that, when clicked, you get scrolled directly to that item.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe get a new pseudo-element for the entire group of markers called \u003ccode\u003e::scroll-marker-group\u003c/code\u003e that we can use to style and position the container. In this case, let’s set Flexbox on the group so that we can display them on a single line and place gaps between them in the center of the carousel’s inline size:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.carousel::scroll-marker-group {\n  display: flex;\n  justify-content: center;\n  gap: 1rem;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe also get a new \u003ccode\u003escroll-marker-group\u003c/code\u003e property that lets us position the group either above (\u003ccode\u003ebefore\u003c/code\u003e) the carousel or below (\u003ccode\u003eafter\u003c/code\u003e) it:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.carousel {\n  /* ... */\n  scroll-marker-group: after; /* displayed below the content */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe can style the markers themselves with the new \u003ccode\u003e::scroll-marker\u003c/code\u003e pseudo-element:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.carousel {\n  /* ... */\n\n  \u0026gt; li::scroll-marker {\n    content: \u0026#34;\u0026#34;;\n    aspect-ratio: 1;\n    border: 2px solid CanvasText;\n    border-radius: 100%;\n    width: 20px;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen clicking on a marker, it becomes the “active” item of the bunch, and we get to select and style it with the \u003ccode\u003e:target-current\u003c/code\u003e pseudo-class:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli::scroll-marker:target-current {\n  background: CanvasText;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTake a moment to click around the markers. Then take a moment using your keyboard and appreciate that we can all of the benefits of focus states as well as the ability to cycle through the carousel items when reaching the end of the markers. It’s amazing what we’re getting for free in terms of user experience and accessibility.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWe can further style the markers when they are hovered or in focus:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli::scroll-marker:hover,\nli::scroll-marker:focus-visible {\n  background: LinkText;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd we can “animate” the scrolling effect by setting \u003ccode\u003escroll-behavior: smooth\u003c/code\u003e on the scroll snapping. Adam smartly applies it when the user’s motion preferences allow it:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.carousel {\n  /* ... */\n\n  @media (prefers-reduced-motion: no-preference) {\n    scroll-behavior: smooth;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBuuuuut that seems to break scroll snapping a bit because the scroll buttons are attempting to slide things over by 85% of the scrolling space. Kevin had to fiddle with his \u003ccode\u003egrid-auto-columns\u003c/code\u003e sizing to get things just right, but showed how Adam’s example took a different sizing approach. It’s a matter of fussing with things to get them just right.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eThis is just a super early look at CSS Carousels. Remember that this is only supported in Chrome 135+ at the time I’m writing this, and it’s purely experimental. So, play around with it, get familiar with the concepts, and then be open-minded to changes in the future as the CSS Overflow Level 5 specification is updated and other browsers begin building support.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-04-09T07:00:24-06:00",
  "modifiedTime": "2025-04-09T07:00:27-06:00"
}
