{
  "id": "97ba0a65-6a8b-4dda-b865-181a1d1e79bd",
  "title": "Catch prediction in Chrome DevTools: Why it's hard and how to make it better",
  "link": "https://developer.chrome.com/blog/devtools-catch-prediction?hl=en",
  "description": "Learn how the DevTools debugger predicts whether an exception is caught.",
  "author": "",
  "published": "Wed, 02 Oct 2024 07:00:00 GMT",
  "source": "https://developer.chrome.com/static/blog/feed.xml",
  "categories": null,
  "byline": "GitHub",
  "length": 13624,
  "excerpt": "Learn how the DevTools debugger predicts whether an exception is caught.",
  "siteName": "Chrome for Developers",
  "favicon": "https://www.gstatic.com/devrel-devsite/prod/vb596299fc3b3ecd7c5d7aec475be1a412930b770a5f8d074630a8e7a09f63df6/chrome/images/favicon.png",
  "text": "Debugging exceptions in web applications seems simple: pause execution when something goes wrong and investigate. But the asynchronous nature of JavaScript makes this surprisingly complex. How can Chrome DevTools know when and where to pause when exceptions fly through promises and asynchronous functions? This post dives into the challenges of catch prediction – DevTools' ability to anticipate if an exception will be caught later in your code. We'll explore why it's so tricky and how recent improvements in V8 (the JavaScript engine powering Chrome) are making it more accurate, leading to a smoother debugging experience. Why catch prediction matters  In Chrome DevTools, you have an option to pause code execution only for uncaught exceptions, skipping over ones that are caught.  Behind the scenes, the debugger stops immediately when an exception occurs to preserve the context. It is a prediction because, at this moment, it's impossible to know for sure whether the exception will be caught or not later in the code, especially in asynchronous scenarios. This uncertainty stems from the inherent difficulty of predicting program behavior, similar to the Halting Problem. Consider the following example: where should the debugger pause? (Look for an answer in the next section.) async function inner() {   throw new Error(); // Should the debugger pause here? } async function outer() {   try {     const promise = inner();     // ...     await promise;   } catch (e) {     // ... or should the debugger pause here?   } } Pausing on exceptions in a debugger can be disruptive and lead to frequent interruptions and jumps to unfamiliar code. To mitigate this, you can choose to only debug uncaught exceptions, which are more likely to signal actual bugs. However, this relies on the accuracy of catch prediction. Incorrect predictions lead to frustration: False negatives (predicting \"uncaught\" when it will be caught). Unnecessary stops in the debugger. False positives (predicting \"caught\" when it will be uncaught). Missed opportunities to catch critical errors, potentially forcing you to debug all exceptions, including expected ones. Another method to reduce debugging interruptions is by using the ignore list, which prevents breaks on exceptions within specified third-party code.  However, accurate catch prediction is still crucial here. If an exception originating in third-party code escapes and affects your own code, you'll want to be able to debug it. How asynchronous code works Promises, async and await, and other asynchronous patterns can lead to scenarios in which an exception or rejection, before being handled, may take an execution path that is difficult to determine at the time an exception is thrown. This is because promises may not be awaited or have catch handlers added until after the exception has already occurred. Let's look at our previous example: async function inner() {   throw new Error(); } async function outer() {   try {     const promise = inner();     // ...     await promise;   } catch (e) {     // ...   } } In this example, outer() first calls inner() which immediately throws an exception. From this the debugger can conclude that inner() will return a rejected promise but currently nothing is awaiting or otherwise handling that promise. The debugger can guess that outer() will probably await it and guess that it will do so in its current try block and therefore handle it but the debugger can't be certain of this until after the rejected promise is returned and the await statement is eventually reached. The debugger can't offer any guarantees that catch predictions will be accurate but it uses a variety of heuristics for common coding patterns to predict correctly. To understand these patterns, it helps to learn how promises work. In V8, a JavaScript Promise is represented as an object that can be in one of three states: fulfilled, rejected, or pending. If a promise is in the fulfilled state and you call the .then() method, a new pending promise is created and a new promise reaction task is scheduled which will run the handler and then set the promise to fulfilled with the result of the handler or set it to rejected if the handler throws an exception. The same happens if you call the .catch() method on a rejected promise. On the contrary, calling .then() on a rejected promise or .catch() on a fulfilled promise will return a promise in the same state and not run the handler.  A pending promise contains a reaction list where each reaction object contains a fulfill handler or rejection handler (or both) and a reaction promise. So calling .then() on a pending promise will add a reaction with a fulfilled handler as well as a new pending promise for the reaction promise, which .then() will return. Calling .catch() will add a similar reaction but with a rejection handler. Calling .then() with two arguments creates a reaction with both handlers, and calling .finally() or awaiting the promise will add a reaction with two handlers that are built-in functions specific to implementing these features. When the pending promise is eventually fulfilled or rejected, reaction jobs will be scheduled for either all of its fulfilled handlers or all of its rejected handlers. The corresponding reaction promises will then be updated, potentially triggering their own reaction jobs. Examples Consider the following code: return new Promise(() =\u003e {throw new Error();})     .then(() =\u003e console.log('Never happened'))     .catch(() =\u003e console.log('Caught')); It may not be obvious that this code involves three distinct Promise objects. The above code is equivalent to the following code: const promise1 = new Promise(() =\u003e {throw new Error();}); const promise2 = promise1.then(() =\u003e console.log('Never happened')); const promise3 = promise2.catch(() =\u003e console.log('Caught')); return promise3; In this example, the following steps happen: The Promise constructor is called. A new pending Promise is created. The anonymous function is run. An exception is thrown. At this point, the debugger needs to decide whether to stop or not. The promise constructor catches this exception and then changes the state of its promise to rejected with its value set to the error that was thrown. It returns this promise, which is stored in promise1. .then() schedules no reaction job because promise1 is in the rejected state. Instead, a new promise (promise2) is returned, which is also in the rejected state with the same error. .catch() schedules a reaction job with the provided handler and a new pending reaction promise, which is returned as promise3. At this point the debugger knows the error will be handled. When the reaction task runs, the handler returns normally and the state of promise3 is changed to fulfilled. The next example has a similar structure but the execution is quite different: return Promise.resolve()     .then(() =\u003e {throw new Error();})     .then(() =\u003e console.log('Never happened'))     .catch(() =\u003e console.log('Caught')); This is equivalent to: const promise1 = Promise.resolve(); const promise2 = promise1.then(() =\u003e {throw new Error();}); const promise3 = promise2.then(() =\u003e console.log('Never happened')); const promise4 = promise3.catch(() =\u003e console.log('Caught')); return promise4; In this example, the following steps happen: A Promise is created in the fulfilled state and stored in promise1. A promise reaction task is scheduled with the first anonymous function and its (pending) reaction promise is returned as promise2. A reaction is added to promise2 with a fulfilled handler and its reaction promise, which is returned as promise3. A reaction is added to promise3 with a rejected handler and another reaction promise, which is returned as promise4. The reaction task scheduled in step 2 is run. The handler throws an exception. At this point the debugger needs to decide whether to stop or not. Currently the handler is your only running JavaScript code. Because the task ends with an exception, the associated reaction promise (promise2) is set to the rejected state with its value set to the error that was thrown. Because promise2 had one reaction, and that reaction had no rejected handler, its reaction promise (promise3) is also set to rejected with the same error. Because promise3 had one reaction, and that reaction did have a rejected handler, a promise reaction task is scheduled with that handler and its reaction promise (promise4). When that reaction task runs, the handler returns normally and the state of promise4 is changed to fulfilled. Methods for catch prediction There are two potential sources of information for catch prediction. One is the call stack. This is sound for synchronous exceptions: the debugger can walk the call stack in the same way the exception unwinding code will and stops if it finds a frame where it's in a try...catch block. For rejected promises or exceptions in promise constructors or in asynchronous functions that have never been suspended, the debugger also relies on the call stack but, in this case, its prediction can't be reliable in all cases. This is because instead of throwing an exception to the nearest handler, asynchronous code will return a rejected exception, and the debugger must make a few assumptions about what the caller will do with it. First, the debugger assumes that a function that receives a returned promise is likely to return that promise or a derived promise so that asynchronous functions further up the stack will have a chance to await it. Second, the debugger assumes that if a promise is returned to an asynchronous function, it will soon await it without first entering or leaving a try...catch block. Neither of these assumptions are guaranteed to be correct but they are sufficient to make the correct predictions for the most common coding patterns with asynchronous functions. In Chrome version 125, we added another heuristic: the debugger checks if a callee is about to call .catch() on the value that will be returned (or .then() with two arguments, or a chain of calls to .then() or .finally() followed by a .catch() or a two-argument .then()). In this case, the debugger assumes that these are the methods on the promise we are tracing or one related to it, so the rejection will be caught. The second source of information is the tree of promise reactions. The debugger starts with a root promise. Sometimes this is a promise for which its reject() method has just been called. More commonly, when an exception or rejection happens during a promise reaction job, and nothing on the call stack appears to catch it, the debugger traces from the promise associated with the reaction. The debugger looks at all reactions on the pending promise and sees if they have rejection handlers. If any reactions don't, it looks at the reaction promise and recursively traces from it. If all reactions ultimately lead to a rejection handler, the debugger considers the promise rejection to be caught. There are some special cases to cover, for example, not counting the built-in rejection handler for a .finally() call. The promise reaction tree provides a usually reliable source of information if the information is there. In some cases, like a call to Promise.reject() or in a Promise constructor or in an async function that hasn't awaited anything yet, there will be no reactions to trace and the debugger has to rely on the call stack alone. In other cases, the promise reaction tree usually does contain the handlers necessary to infer catch prediction but it is always possible that more handlers will be added later that will change the exception from caught to uncaught or vice versa. There are also promises like those created by Promise.all/any/race, where other promises in the group may affect how a rejection is treated. For these methods, the debugger assumes a promise rejection will be forwarded if the promise is still pending. Take a look at the following two examples: While these two examples of caught exceptions look similar, they require quite different catch prediction heuristics. In the first example, a resolved promise is created, then a reaction job for .then() is scheduled that will throw an exception, then .catch() is called to attach a rejection handler to the reaction promise. When the reaction task is run, the exception will be thrown, and the promise reaction tree will contain the catch handler, so it will be detected as caught. In the second example, the promise is immediately rejected before the code to add a catch handler is run, so there are no rejection handlers in the promise's reaction tree. The debugger must look at the call stack but there are no try...catch blocks either. To correctly predict this, the debugger scans ahead of the current location in the code to find the call to .catch(), and assumes on that basis that the rejection will ultimately be handled. Summary Hopefully, this explanation has shed light on how catch prediction works in Chrome DevTools, its strengths, and its limitations. If you encounter debugging issues due to incorrect predictions, consider these options: Change the coding pattern to something more straightforward to predict, like using async functions. Select to break on all exceptions if DevTools is failing to stop when it should. Use a \"Never pause here\" breakpoint or conditional breakpoint if the debugger is stopping somewhere you don't want it to. Acknowledgements Our deepest gratitude goes out to Sofia Emelianova and Jecelyn Yeen for their invaluable help editing this post!",
  "image": "https://developer.chrome.com/static/blog/devtools-catch-prediction/image/catch-prediction-thumb.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n  \n    \n\n\n\n\n\u003cdiv translate=\"no\"\u003e\n        \n          \u003cp\u003e\u003cimg alt=\"Eric Leese\" src=\"https://web.dev/images/authors/ericsl.jpg\" decoding=\"async\" height=\"64\" loading=\"lazy\" width=\"64\"/\u003e\u003c/p\u003e\n      \u003c/div\u003e\n\n\n\n\u003cp\u003eDebugging exceptions in web applications seems simple: pause execution when something goes wrong and investigate. But the asynchronous nature of JavaScript makes this surprisingly complex. How can Chrome DevTools know when and where to pause when exceptions fly through promises and asynchronous functions?\u003c/p\u003e\n\n\u003cp\u003eThis post dives into the challenges of \u003cem\u003ecatch prediction\u003c/em\u003e – DevTools\u0026#39; ability to anticipate if an exception will be caught later in your code. We\u0026#39;ll explore why it\u0026#39;s so tricky and how recent improvements in V8 (the JavaScript engine powering Chrome) are making it more accurate, leading to a smoother debugging experience.\u003c/p\u003e\n\n\u003ch2 id=\"why_catch_prediction_matters \" data-text=\"Why catch prediction matters \" tabindex=\"-1\"\u003eWhy catch prediction matters \u003c/h2\u003e\n\n\u003cp\u003eIn Chrome DevTools, you have an option to pause code execution only for uncaught exceptions, skipping over ones that are caught. \u003c/p\u003e\n\n\u003cp\u003e\u003cimg id=\"pause-on-uncaught\" src=\"https://developer.chrome.com/static/blog/devtools-catch-prediction/images/pause-on-uncaught.png\" alt=\"Chrome DevTools provides separate options for pausing on caught or uncaught exceptions\" width=\"234\" height=\"224\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eBehind the scenes, the debugger stops immediately when an exception occurs to preserve the context. It is a \u003cem\u003eprediction\u003c/em\u003e because, at this moment, it\u0026#39;s impossible to know for sure whether the exception will be caught or not later in the code, especially in asynchronous scenarios. This uncertainty stems from the inherent difficulty of predicting program behavior, similar to the \u003ca href=\"https://en.wikipedia.org/wiki/Halting_problem\"\u003eHalting Problem\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eConsider the following example: where should the debugger pause? (Look for an answer in the next section.)\u003c/p\u003e\n\u003cdevsite-code\u003e\u003cpre translate=\"no\" dir=\"ltr\" is-upgraded=\"\" syntax=\"JavaScript\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003einner\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003ethrow\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eError\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e// Should the debugger pause here?\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eouter\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003etry\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003einner\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// ...\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eawait\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ecatch\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// ... or should the debugger pause here?\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/devsite-code\u003e\n\u003cp\u003ePausing on exceptions in a debugger can be disruptive and lead to frequent interruptions and jumps to unfamiliar code. To mitigate this, you can choose to only debug uncaught exceptions, which are more likely to signal actual bugs. However, this relies on the accuracy of catch prediction.\u003c/p\u003e\n\n\u003cp\u003eIncorrect predictions lead to frustration:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFalse negatives (predicting \u0026#34;uncaught\u0026#34; when it will be caught)\u003c/strong\u003e. Unnecessary stops in the debugger.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFalse positives (predicting \u0026#34;caught\u0026#34; when it will be uncaught)\u003c/strong\u003e. Missed opportunities to catch critical errors, potentially forcing you to debug all exceptions, including expected ones.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAnother method to reduce debugging interruptions is by using the \u003ca href=\"https://goo.gle/ignore-list\"\u003eignore list\u003c/a\u003e, which prevents breaks on exceptions within specified third-party code.  However, accurate catch prediction is still crucial here. If an exception originating in third-party code escapes and affects your own code, you\u0026#39;ll want to be able to debug it.\u003c/p\u003e\n\n\u003ch2 id=\"how_asynchronous_code_works\" data-text=\"How asynchronous code works\" tabindex=\"-1\"\u003eHow asynchronous code works\u003c/h2\u003e\n\n\u003cp\u003ePromises, \u003ccode translate=\"no\" dir=\"ltr\"\u003easync\u003c/code\u003e and \u003ccode translate=\"no\" dir=\"ltr\"\u003eawait\u003c/code\u003e, and other asynchronous patterns can lead to scenarios in which an exception or rejection, before being handled, may take an execution path that is difficult to determine at the time an exception is thrown. This is because promises may not be awaited or have catch handlers added until after the exception has already occurred. Let\u0026#39;s look at our previous example:\u003c/p\u003e\n\u003cdevsite-code\u003e\u003cpre translate=\"no\" dir=\"ltr\" is-upgraded=\"\" syntax=\"JavaScript\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003einner\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003ethrow\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eError\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eouter\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003etry\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003einner\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// ...\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eawait\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ecatch\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// ...\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/devsite-code\u003e\n\u003cp\u003eIn this example, \u003ccode translate=\"no\" dir=\"ltr\"\u003eouter()\u003c/code\u003e first calls \u003ccode translate=\"no\" dir=\"ltr\"\u003einner()\u003c/code\u003e which immediately throws an exception. From this the debugger can conclude that \u003ccode translate=\"no\" dir=\"ltr\"\u003einner()\u003c/code\u003e will return a rejected promise but currently nothing is awaiting or otherwise handling that promise. The debugger can guess that \u003ccode translate=\"no\" dir=\"ltr\"\u003eouter()\u003c/code\u003e will probably await it and guess that it will do so in its current \u003ccode translate=\"no\" dir=\"ltr\"\u003etry\u003c/code\u003e block and therefore handle it but the debugger can\u0026#39;t be certain of this until after the rejected promise is returned and the \u003ccode translate=\"no\" dir=\"ltr\"\u003eawait\u003c/code\u003e statement is eventually reached.\u003c/p\u003e\n\n\u003cp\u003eThe debugger can\u0026#39;t offer any guarantees that catch predictions will be accurate but it uses a variety of heuristics for common coding patterns to predict correctly. To understand these patterns, it helps to learn how promises work.\u003c/p\u003e\n\n\u003cp\u003eIn V8, a JavaScript \u003ccode translate=\"no\" dir=\"ltr\"\u003ePromise\u003c/code\u003e is represented as an object that can be in one of three states: fulfilled, rejected, or pending. If a promise is in the fulfilled state and you call the \u003ccode translate=\"no\" dir=\"ltr\"\u003e.then()\u003c/code\u003e method, a new pending promise is created and a new promise reaction task is scheduled which will run the handler and then set the promise to fulfilled with the result of the handler or set it to rejected if the handler throws an exception. The same happens if you call the \u003ccode translate=\"no\" dir=\"ltr\"\u003e.catch()\u003c/code\u003e method on a rejected promise. On the contrary, calling \u003ccode translate=\"no\" dir=\"ltr\"\u003e.then()\u003c/code\u003e on a rejected promise or \u003ccode translate=\"no\" dir=\"ltr\"\u003e.catch()\u003c/code\u003e on a fulfilled promise will return a promise in the same state and not run the handler. \u003c/p\u003e\n\n\u003cp\u003eA pending promise contains a reaction list where each reaction object contains a fulfill handler or rejection handler (or both) and a reaction promise. So calling \u003ccode translate=\"no\" dir=\"ltr\"\u003e.then()\u003c/code\u003e on a pending promise will add a reaction with a fulfilled handler as well as a new pending promise for the reaction promise, which \u003ccode translate=\"no\" dir=\"ltr\"\u003e.then()\u003c/code\u003e will return. Calling \u003ccode translate=\"no\" dir=\"ltr\"\u003e.catch()\u003c/code\u003e will add a similar reaction but with a rejection handler. Calling \u003ccode translate=\"no\" dir=\"ltr\"\u003e.then()\u003c/code\u003e with two arguments creates a reaction with both handlers, and calling \u003ccode translate=\"no\" dir=\"ltr\"\u003e.finally()\u003c/code\u003e or awaiting the promise will add a reaction with two handlers that are built-in functions specific to implementing these features.\u003c/p\u003e\n\n\u003cp\u003eWhen the pending promise is eventually fulfilled or rejected, reaction jobs will be scheduled for either all of its fulfilled handlers or all of its rejected handlers. The corresponding reaction promises will then be updated, potentially triggering their own reaction jobs.\u003c/p\u003e\n\n\u003ch3 id=\"examples\" data-text=\"Examples\" tabindex=\"-1\"\u003eExamples\u003c/h3\u003e\n\n\u003cp\u003eConsider the following code:\u003c/p\u003e\n\u003cdevsite-code\u003e\u003cpre translate=\"no\" dir=\"ltr\" is-upgraded=\"\" syntax=\"JavaScript\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ePromise\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003ethrow\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eError\u003c/span\u003e\u003cspan\u003e();})\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Never happened\u0026#39;\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecatch\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Caught\u0026#39;\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/devsite-code\u003e\n\u003cp\u003eIt may not be obvious that this code involves three distinct \u003ccode translate=\"no\" dir=\"ltr\"\u003ePromise\u003c/code\u003e objects. The above code is equivalent to the following code:\u003c/p\u003e\n\u003cdevsite-code\u003e\u003cpre translate=\"no\" dir=\"ltr\" is-upgraded=\"\" syntax=\"JavaScript\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise1\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ePromise\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003ethrow\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eError\u003c/span\u003e\u003cspan\u003e();});\u003c/span\u003e\n\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise2\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise1\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Never happened\u0026#39;\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise3\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise2\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecatch\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Caught\u0026#39;\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise3\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/devsite-code\u003e\n\u003cp\u003eIn this example, the following steps happen:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eThe \u003ccode translate=\"no\" dir=\"ltr\"\u003ePromise\u003c/code\u003e constructor is called.\u003c/li\u003e\n\u003cli\u003eA new pending \u003ccode translate=\"no\" dir=\"ltr\"\u003ePromise\u003c/code\u003e is created.\u003c/li\u003e\n\u003cli\u003eThe anonymous function is run.\u003c/li\u003e\n\u003cli\u003eAn exception is thrown. At this point, the debugger needs to decide whether to stop or not.\u003c/li\u003e\n\u003cli\u003eThe promise constructor catches this exception and then changes the state of its promise to \u003ccode translate=\"no\" dir=\"ltr\"\u003erejected\u003c/code\u003e with its value set to the error that was thrown. It returns this promise, which is stored in \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise1\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e.then()\u003c/code\u003e schedules no reaction job because \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise1\u003c/code\u003e is in the \u003ccode translate=\"no\" dir=\"ltr\"\u003erejected\u003c/code\u003e state. Instead, a new promise (\u003ccode translate=\"no\" dir=\"ltr\"\u003epromise2\u003c/code\u003e) is returned, which is also in the rejected state with the same error.\u003c/li\u003e\n\u003cli\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e.catch()\u003c/code\u003e schedules a reaction job with the provided handler and a new pending reaction promise, which is returned as \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise3\u003c/code\u003e. At this point the debugger knows the error will be handled.\u003c/li\u003e\n\u003cli\u003eWhen the reaction task runs, the handler returns normally and the state of \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise3\u003c/code\u003e is changed to \u003ccode translate=\"no\" dir=\"ltr\"\u003efulfilled\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThe next example has a similar structure but the execution is quite different:\u003c/p\u003e\n\u003cdevsite-code\u003e\u003cpre translate=\"no\" dir=\"ltr\" is-upgraded=\"\" syntax=\"JavaScript\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ePromise\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresolve\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003ethrow\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eError\u003c/span\u003e\u003cspan\u003e();})\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Never happened\u0026#39;\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecatch\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Caught\u0026#39;\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/devsite-code\u003e\n\u003cp\u003eThis is equivalent to:\u003c/p\u003e\n\u003cdevsite-code\u003e\u003cpre translate=\"no\" dir=\"ltr\" is-upgraded=\"\" syntax=\"JavaScript\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise1\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ePromise\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresolve\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise2\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise1\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003ethrow\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eError\u003c/span\u003e\u003cspan\u003e();});\u003c/span\u003e\n\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise3\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise2\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Never happened\u0026#39;\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise4\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise3\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecatch\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u0026gt;\u003cspan\u003e \u003c/span\u003e\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Caught\u0026#39;\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epromise4\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/devsite-code\u003e\n\u003cp\u003eIn this example, the following steps happen:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eA \u003ccode translate=\"no\" dir=\"ltr\"\u003ePromise\u003c/code\u003e is created in the \u003ccode translate=\"no\" dir=\"ltr\"\u003efulfilled\u003c/code\u003e state and stored in \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise1\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eA promise reaction task is scheduled with the first anonymous function and its \u003ccode translate=\"no\" dir=\"ltr\"\u003e(pending)\u003c/code\u003e reaction promise is returned as \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise2\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eA reaction is added to \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise2\u003c/code\u003e with a fulfilled handler and its reaction promise, which is returned as \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise3\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eA reaction is added to \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise3\u003c/code\u003e with a rejected handler and another reaction promise, which is returned as \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise4\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eThe reaction task scheduled in step 2 is run.\u003c/li\u003e\n\u003cli\u003eThe handler throws an exception. At this point the debugger needs to decide whether to stop or not. Currently the handler is your only running JavaScript code.\u003c/li\u003e\n\u003cli\u003eBecause the task ends with an exception, the associated reaction promise (\u003ccode translate=\"no\" dir=\"ltr\"\u003epromise2\u003c/code\u003e) is set to the rejected state with its value set to the error that was thrown.\u003c/li\u003e\n\u003cli\u003eBecause \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise2\u003c/code\u003e had one reaction, and that reaction had no rejected handler, its reaction promise (\u003ccode translate=\"no\" dir=\"ltr\"\u003epromise3\u003c/code\u003e) is also set to \u003ccode translate=\"no\" dir=\"ltr\"\u003erejected\u003c/code\u003e with the same error.\u003c/li\u003e\n\u003cli\u003eBecause \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise3\u003c/code\u003e had one reaction, and that reaction did have a rejected handler, a promise reaction task is scheduled with that handler and its reaction promise (\u003ccode translate=\"no\" dir=\"ltr\"\u003epromise4\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003eWhen that reaction task runs, the handler returns normally and the state of \u003ccode translate=\"no\" dir=\"ltr\"\u003epromise4\u003c/code\u003e is changed to fulfilled.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"methods_for_catch_prediction\" data-text=\"Methods for catch prediction\" tabindex=\"-1\"\u003eMethods for catch prediction\u003c/h2\u003e\n\n\u003cp\u003eThere are two potential sources of information for catch prediction. One is the call stack. This is sound for synchronous exceptions: the debugger can walk the call stack in the same way the exception unwinding code will and stops if it finds a frame where it\u0026#39;s in a \u003ccode translate=\"no\" dir=\"ltr\"\u003etry...catch\u003c/code\u003e block. For rejected promises or exceptions in promise constructors or in asynchronous functions that have never been suspended, the debugger also relies on the call stack but, in this case, its prediction can\u0026#39;t be reliable in all cases. This is because instead of throwing an exception to the nearest handler, asynchronous code will return a rejected exception, and the debugger must make a few assumptions about what the caller will do with it.\u003c/p\u003e\n\n\u003cp\u003eFirst, the debugger assumes that a function that receives a returned promise is likely to return that promise or a derived promise so that asynchronous functions further up the stack will have a chance to await it. Second, the debugger assumes that if a promise is returned to an asynchronous function, it will soon await it without first entering or leaving a \u003ccode translate=\"no\" dir=\"ltr\"\u003etry...catch\u003c/code\u003e block. Neither of these assumptions are guaranteed to be correct but they are sufficient to make the correct predictions for the most common coding patterns with asynchronous functions. In Chrome version 125, we added another heuristic: the debugger checks if a callee is about to call \u003ccode translate=\"no\" dir=\"ltr\"\u003e.catch()\u003c/code\u003e on the value that will be returned (or \u003ccode translate=\"no\" dir=\"ltr\"\u003e.then()\u003c/code\u003e with two arguments, or a chain of calls to \u003ccode translate=\"no\" dir=\"ltr\"\u003e.then()\u003c/code\u003e or \u003ccode translate=\"no\" dir=\"ltr\"\u003e.finally()\u003c/code\u003e followed by a \u003ccode translate=\"no\" dir=\"ltr\"\u003e.catch()\u003c/code\u003e or a two-argument \u003ccode translate=\"no\" dir=\"ltr\"\u003e.then()\u003c/code\u003e). In this case, the debugger assumes that these are the methods on the promise we are tracing or one related to it, so the rejection will be caught.\u003c/p\u003e\n\n\u003cp\u003eThe second source of information is the tree of promise reactions. The debugger starts with a root promise. Sometimes this is a promise for which its \u003ccode translate=\"no\" dir=\"ltr\"\u003ereject()\u003c/code\u003e method has just been called. More commonly, when an exception or rejection happens during a promise reaction job, and nothing on the call stack appears to catch it, the debugger traces from the promise associated with the reaction. The debugger looks at all reactions on the pending promise and sees if they have rejection handlers. If any reactions don\u0026#39;t, it looks at the reaction promise and recursively traces from it. If all reactions ultimately lead to a rejection handler, the debugger considers the promise rejection to be caught. There are some special cases to cover, for example, not counting the built-in rejection handler for a \u003ccode translate=\"no\" dir=\"ltr\"\u003e.finally()\u003c/code\u003e call.\u003c/p\u003e\n\n\u003cp\u003eThe promise reaction tree provides a usually reliable source of information if the information is there. In some cases, like a call to \u003ccode translate=\"no\" dir=\"ltr\"\u003ePromise.reject()\u003c/code\u003e or in a \u003ccode translate=\"no\" dir=\"ltr\"\u003ePromise\u003c/code\u003e constructor or in an async function that hasn\u0026#39;t awaited anything yet, there will be no reactions to trace and the debugger has to rely on the call stack alone. In other cases, the promise reaction tree usually does contain the handlers necessary to infer catch prediction but it is always possible that more handlers will be added later that will change the exception from caught to uncaught or vice versa. There are also promises like those created by \u003ccode translate=\"no\" dir=\"ltr\"\u003ePromise.all/any/race\u003c/code\u003e, where other promises in the group may affect how a rejection is treated. For these methods, the debugger assumes a promise rejection will be forwarded if the promise is still pending.\u003c/p\u003e\n\n\u003cp\u003eTake a look at the following two examples:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg id=\"console-examples\" src=\"https://developer.chrome.com/static/blog/devtools-catch-prediction/images/example.png\" alt=\"Two examples for catch prediction\" width=\"778\" height=\"276\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eWhile these two examples of caught exceptions look similar, they require quite different catch prediction heuristics. In the first example, a resolved promise is created, then a reaction job for \u003ccode translate=\"no\" dir=\"ltr\"\u003e.then()\u003c/code\u003e is scheduled that will throw an exception, then \u003ccode translate=\"no\" dir=\"ltr\"\u003e.catch()\u003c/code\u003e is called to attach a rejection handler to the reaction promise. When the reaction task is run, the exception will be thrown, and the promise reaction tree will contain the catch handler, so it will be detected as caught. In the second example, the promise is immediately rejected before the code to add a catch handler is run, so there are no rejection handlers in the promise\u0026#39;s reaction tree. The debugger must look at the call stack but there are no \u003ccode translate=\"no\" dir=\"ltr\"\u003etry...catch\u003c/code\u003e blocks either. To correctly predict this, the debugger scans ahead of the current location in the code to find the call to \u003ccode translate=\"no\" dir=\"ltr\"\u003e.catch()\u003c/code\u003e, and assumes on that basis that the rejection will ultimately be handled.\u003c/p\u003e\n\n\u003ch2 id=\"summary\" data-text=\"Summary\" tabindex=\"-1\"\u003eSummary\u003c/h2\u003e\n\n\u003cp\u003eHopefully, this explanation has shed light on how catch prediction works in Chrome DevTools, its strengths, and its limitations. If you encounter debugging issues due to incorrect predictions, consider these options:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eChange the coding pattern to something more straightforward to predict, like using async functions.\u003c/li\u003e\n\u003cli\u003eSelect to break on all exceptions if DevTools is failing to stop when it should.\u003c/li\u003e\n\u003cli\u003eUse a \u0026#34;Never pause here\u0026#34; breakpoint or conditional breakpoint if the debugger is stopping somewhere you don\u0026#39;t want it to.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"acknowledgements\" data-text=\"Acknowledgements\" tabindex=\"-1\"\u003eAcknowledgements\u003c/h2\u003e\n\n\u003cp\u003eOur deepest gratitude goes out to Sofia Emelianova and Jecelyn Yeen for their invaluable help editing this post!\u003c/p\u003e\n\n  \n\n  \n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": null,
  "modifiedTime": null
}
