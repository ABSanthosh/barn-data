{
  "id": "a0e7d631-dedc-4923-83a1-3e89aee59ee3",
  "title": "Worlds Collide: Keyframe Collision Detection Using Style Queries",
  "link": "https://css-tricks.com/worlds-collide-keyframe-collision-detection-using-style-queries/",
  "description": "Interactive CSS animations with elements ricocheting off each other seem more plausible in 2025. While it’s unnecessary to implement Pong in CSS, the increasing flexibility and power of CSS reinforce Lee's suspicion that one day it will be a lifestyle choice whether to achieve any given effect with scripting or CSS. Worlds Collide: Keyframe Collision Detection Using Style Queries originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Lee Meyer",
  "published": "Mon, 31 Mar 2025 14:59:47 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "Scroll Driven Animation",
    "Style Queries"
  ],
  "byline": "Lee Meyer",
  "length": 13814,
  "excerpt": "Interactive CSS animations with elements ricocheting off each other seem more plausible in 2025. While it’s unnecessary to implement Pong in CSS, the increasing flexibility and power of CSS reinforce Lee's suspicion that one day it will be a lifestyle choice whether to achieve any given effect with scripting or CSS.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "A friend DMs Lee Meyer a CodePen by Manuel Schaller containing a pure CSS simulation of one of the world’s earliest arcade games, Pong, with both paddles participating automatically, in an endless loop. The demo reminds Lee of an arcade machine in attract mode awaiting a coin, and the iconic imagery awakens muscle memory from his misspent childhood, causing him to search his pocket in which he finds the token a spooky shopkeeper gave him last year at the CSS tricks stall in the haunted carnival. The token gleams like a power-up in the light of his laptop, which has a slot he never noticed. He feeds the token into the slot, and the CodePen reloads itself. A vertical range input and a life counter appear, allowing him to control the left paddle and play the game in Chrome using a cocktail of modern and experimental CSS features to implement collision detection in CSS animations. He recalls the spooky shopkeeper’s warning that playing with these features has driven some developers to madness, but the shopkeeper’s voice in Lee’s head whispers: “Too late, we are already playing.” CSS collision detection: Past and present So, maybe the experience of using modern CSS to add collision detection and interactivity to an animation wasn’t as much like a screenplay sponsored by CSS as I depicted in the intro above — but it did feel like magic compared to what Alex Walker had to go through in 2013 to achieve a similar effect. Hilariously, he describes his implementation as “a glittering city of hacks built on the banks of the ol’ Hack River. On the Planet Hack.“ Alex’s version of CSS Pong cleverly combines checkbox hacks, sibling selectors, and :hover, whereas the CodePen below uses style queries to detect collisions. I feel it’s a nice illustration of how far CSS has come, and a testament to increased power and expressiveness of CSS more than a decade later. It shows how much power we get when combining new CSS features — in this case, that includes style queries, animatable custom properties, and animation timelines. The future CSS features of inline conditionals and custom functions might be able to simplify this code more. Collision detection with style queries Interactive CSS animations with elements ricocheting off each other seems more plausible in 2025 and the code is somewhat sensible. While it’s unnecessary to implement Pong in CSS, and the CSS Working Group probably hasn’t been contemplating how to make that particular niche task easier, the increasing flexibility and power of CSS reinforce my suspicion that one day it will be a lifestyle choice whether to achieve any given effect with scripting or CSS. The demo is a similar number of lines of CSS to Alex’s 2013 implementation, but it didn’t feel much like a hack. It’s a demo of modern CSS features working together in the way I expected after reading the instruction booklet. Sometimes when reading introductory articles about the new features we are getting in CSS, it’s hard to appreciate how game-changing they are till you see several features working together. As often happens when pushing the boundaries of a technology, we are going to bump up against the current limitations of style queries and animations. But it’s all in good fun, and we’ll learn about these CSS features in more detail than if we had not attempted this crazy experiment. It does seem to work, and my 12-year-old and 7-year-old have both playtested it on my phone and laptop, so it gets the “works on Lee’s devices” seal of quality. Also, since Chrome now supports controlling animations using range inputs, we can make our game playable on mobile, unlike the 2013 version, which relied on :hover. Temani Afif provides a great explanation of how and why view progress timelines can be used to style anything based on the value of a range input. Using style queries to detect if the paddle hit the ball The ball follows a fixed path, and whether the player’s paddle intersects with the ball when it reaches our side is the only input we have into whether it continues its predetermined bouncy loop or the screen flashes red as the life counter goes down till we see the “Game Over” screen with the option to play again. This type of interactivity is what game designers call a quick time event. It’s still a game for sure, but five months ago, when I was young and naive, I mused in my article on animation timelines that the animation timeline feature could open the door for advanced games and interactive experiences in CSS. I wrote that a video game is just a “hyper-interactive animation.” Indeed, the above experiment shows that the new features in CSS allow us to respond to user input in sophisticated ways, but the demo also clarifies the difference between the kind of interactivity we can expect from the current incarnation of CSS versus scripting. The above experiment is more like if Pong were a game inside the old-school arcade game Dragon’s Lair, which was one giant quick time event. It only works because there are limited possible outcomes, but they are certainly less limited than what we used to be able to achieve in CSS. Since we know collision detection with the paddle is the only opportunity for the user to have a say in what happens next, let’s focus on that implementation. It will require more mental gymnastics than I would like, since container style queries only allow for name-value pairs with the same syntax as feature queries, meaning we can’t use “greater than” or “less than” operators when comparing numeric values like we do with container size queries which follow the same syntax as @media size queries. The workaround below allows us to create style queries based on the ball position being in or out of the range of the paddle. If the ball hits our side, then by default, the play field will flash red and temporarily unpause the animation that decrements the life counter (more on that later). But if the ball hits our side and is within range of the paddle, we leave the life-decrementing animation paused, and make the field background green while the ball hits the paddle. Since we don’t have “greater than” or “less than” operators in style queries, we (ab)use the min() function. If the result equals the first argument then that argument is less than or equal to the second; otherwise it’s greater than the second argument. It’s logical but made me wish for better comparison operators in style queries. Nevertheless, I was impressed that style queries allow the collision detection to be fairly readable, if a little more verbose than I would like. body { --int-ball-position-x: round(down, var(--ball-position-x)); --min-ball-position-y-and-top-of-paddle: min(var(--ball-position-y) + var(--ball-height), var(--ping-position)); --min-ball-position-y-and-bottom-of-paddle: min(var(--ball-position-y), var(--ping-position) + var(--paddle-height)); } @container style(--int-ball-position-x: var(--ball-left-boundary)) { .screen { --lives-decrement: running; .field { background: red; } } } @container style(--min-ball-position-y-and-top-of-paddle: var(--ping-position)) and style(--min-ball-position-y-and-bottom-of-paddle: var(--ball-position-y)) and style(--int-ball-position-x: var(--ball-left-boundary)) { .screen { --lives-decrement: paused; .field { background: green; } } } Responding to collisions Now that we can style our playing field based on whether the paddle hits the ball, we want to decrement the life counter if our paddle misses the ball, and display “Game Over” when we run out of lives. One way to achieve side effects in CSS is by pausing and unpausing keyframe animations that run forwards. These days, we can style things based on custom properties, which we can set in animations. Using this fact, we can take the power of paused animations to another level. body { animation: ball 8s infinite linear, lives 80ms forwards steps(4) var(--lives-decrement); --lives-decrement: paused; } .lives::after { content: var(--lives); } @keyframes lives { 0% { --lives: \"3\"; } 25% { --lives: \"2\"; } 75% { --lives: \"1\"; } 100% { --lives: \"0\"; } } @container style(--int-ball-position-x: var(--ball-left-boundary)) { .screen { --lives-decrement: running; .field { background: red; } } } @container style(--min-ball-position-y-and-top-of-paddle: var(--ping-position)) and style(--min-ball-position-y-and-bottom-of-paddle: var(--ball-position-y)) and style(--int-ball-position-x: 8) { .screen { --lives-decrement: paused; .field { background: green; } } } @container style(--lives: '0') { .field { display: none; } .game-over { display: flex; } } So when the ball hits the wall and isn’t in range of the paddle, the lives-decrementing animation is unpaused long enough to let it complete one step. Once it reaches zero we hide the play field and display the “Game Over” screen. What’s fascinating about this part of the experiment is that it shows that, using style queries, all properties become indirectly possible to control via animations, even when working with non-animatable properties. And this applies to properties that control whether other animations play. This article touches on why play state deliberately isn’t animatable and could be dangerous to animate, but we know what we are doing, right? Full disclosure: The play state approach did lead to hidden complexity in the choice of duration of the animations. I knew that if I chose too long a duration for the life-decrementing counter, it might not have time to proceed to the next step while the ball was hitting the wall, but if I chose too short a duration, missing the ball once might cause the player to lose more than one life. I made educated guesses of suitable durations for the ball bouncing and life decrementing, and I expected that when working with fixed-duration predictable animations, the life counter would either always work or always fail. I didn’t expect that my first attempt at the implementation intermittently failed to decrement the life counter at the same point in the animation loop. Setting the durations of both these related animations to multiples of eight seems to fix the problem, but why would predetermined animations exhibit unpredictable behavior? Forefeit the game before somebody else takes you out of the frame I have theories as to why the unpredictability of the collision detection seemed to be fixed by setting the ball animation to eight seconds and the lives animation to 80 milliseconds. Again, pushing CSS to its limits forces us to think deeper about how it’s working. CSS appears to suffer from timer drift, meaning if you set a keyframes animation to last for one second, it will sometimes take slightly under or over one second. When there is a different rate of change between the ball-bouncing and life-losing, it would make sense that the potential discrepancy between the two would be pronounced and lead to unpredictable collision detection. When the rate of change in both animations is the same, they would suffer about equally from timer drift, meaning the frames still synchronize predictably. Or at least I’m hoping the chance they don’t becomes negligible. Alex’s 2013 version of Pong uses translate3d() to move the ball even though it only moves in 2D. Alex recommends this whenever possible “for efficient animation rendering, offloading processing to the GPU for smoother visual effects.” Doing this may have been an alternative fix if it leads to more precise animation timing. There are tradeoffs so I wasn’t willing to go down that rabbit hole of trying to tune the animation performance in this article — but it could be an interesting focus for future research into CSS collision detection. Maybe style queries take a varying amount of time to kick in, leading to some form of a race condition. It is possible that making the ball-bouncing animation slower made this problem less likely. Maybe the bug remains lurking in the shadows somewhere. What did I expect from a hack I achieved using a magic token from a spooky shopkeeper? Haven’t I seen any eighties movie ever? Outro You finish reading the article, and feel sure that the author’s rationale for his supposed fix for the bug is hogwash. Clearly, Lee has been driven insane by the allure of overpowering new CSS features, whereas you respect the power of CSS, but you also respect its limitations. You sit down to spend a few minutes with the collision detection CodePen to prove it is still broken, but then find other flaws in the collision detection, and you commence work on a fork that will be superior. Hey, speaking of timer drift, how is it suddenly 1 a.m.? Only a crazy person would stay up that late playing with CSS when they have to work the next day. “Madness,” repeats the spooky shopkeeper inside your head, and his laughter echoes somewhere in the night. Roll the credits This looping Pong CSS animation by Manuel Schaller gave me an amazing basis for adding the collision detection. His twitching paddle animations help give the illusion of playing against a computer opponent, so forking his CodePen let me focus on implementing the collision detection rather than reinventing Pong. This author is grateful to the junior testing team, comprised of his seven-year-old and twelve-year-old, who declared the CSS Pong implementation “pretty cool.” They also suggested the green and red flashes to signal collisions and misses. The intro and outro for this article were sponsored by the spooky shopkeeper who sells dangerous CSS tricks. He also sells frozen yoghurt, which he calls froghurt.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/pong.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003e\u003cem\u003eA friend DMs Lee Meyer a \u003ca href=\"https://codepen.io/ultraschaller/pen/BjJNpG\" rel=\"noopener\"\u003eCodePen\u003c/a\u003e by \u003ca href=\"https://codepen.io/ultraschaller\" rel=\"noopener\"\u003eManuel Schaller\u003c/a\u003e containing a pure CSS simulation of one of the \u003ca href=\"https://en.wikipedia.org/wiki/Pong\" rel=\"noopener\"\u003eworld’s earliest arcade games\u003c/a\u003e, Pong, with both paddles participating automatically, in an endless loop. The demo reminds Lee of an arcade machine in \u003ca href=\"https://tvtropes.org/pmwiki/pmwiki.php/Main/AttractMode\" rel=\"noopener\"\u003eattract mode\u003c/a\u003e awaiting a coin, and the iconic imagery awakens muscle memory from his misspent childhood, causing him to search his pocket in which he finds the token a spooky shopkeeper gave him last year at the CSS tricks stall in the haunted carnival. The token gleams like a power-up in the light of his laptop, which has a slot he never noticed. He feeds the token into the slot, and the CodePen reloads itself. A vertical range input and a life counter appear, allowing him to control the left paddle and play the game in Chrome using a cocktail of modern and experimental CSS features to implement collision detection in CSS animations. He recalls the spooky shopkeeper’s warning that playing with these features has driven some developers to madness, but the shopkeeper’s voice in Lee’s head whispers: “Too late, we are already playing.”\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch3 id=\"css-collision-detection-past-and-present\"\u003eCSS collision detection: Past and present\u003c/h3\u003e\n\n\n\u003cp\u003eSo, maybe the experience of using modern CSS to add collision detection and interactivity to an animation wasn’t as much like a screenplay sponsored by CSS as I depicted in the intro above — but it did feel like magic compared to what \u003ca href=\"https://www.sitepoint.com/css3-pong-insane-things-to-do-with-css/\" rel=\"noopener\"\u003eAlex Walker had to go through\u003c/a\u003e in 2013 to achieve a similar effect. Hilariously, he describes his implementation as “a glittering city of hacks built on the banks of the ol’ Hack River. On the Planet Hack.“ \u003ca href=\"https://codepen.io/alexmwalker/pen/DzNPej\" rel=\"noopener\"\u003eAlex’s version of CSS Pong\u003c/a\u003e cleverly combines \u003ca href=\"https://css-tricks.com/the-checkbox-hack/\"\u003echeckbox hacks\u003c/a\u003e, \u003ca href=\"https://css-tricks.com/almanac/selectors/g/general-sibling/\"\u003esibling selectors\u003c/a\u003e, and \u003ca href=\"https://css-tricks.com/almanac/pseudo-selectors/h/hover/\"\u003e\u003ccode\u003e:hover\u003c/code\u003e\u003c/a\u003e, whereas the CodePen below uses style queries to detect collisions. I feel it’s a nice illustration of how far CSS has come, and a testament to increased power and expressiveness of CSS more than a decade later. It shows how much power we get when combining new CSS features — in this case, that includes \u003ca href=\"https://css-tricks.com/css-container-queries/\"\u003estyle queries\u003c/a\u003e, \u003ca href=\"https://css-tricks.com/exploring-property-and-its-animating-powers/\"\u003eanimatable custom properties\u003c/a\u003e, and \u003ca href=\"https://css-tricks.com/almanac/properties/a/animation-timeline/\"\u003eanimation timelines\u003c/a\u003e. The future CSS features of \u003ca href=\"https://css-tricks.com/if-css-gets-inline-conditionals/\"\u003einline conditionals\u003c/a\u003e and \u003ca href=\"https://css-tricks.com/functions-in-css/\"\u003ecustom functions\u003c/a\u003e might be able to simplify this code more.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"collision-detection-with-style-queries\"\u003eCollision detection with style queries\u003c/h3\u003e\n\n\n\u003cp\u003eInteractive CSS animations with elements ricocheting off each other seems more plausible in 2025 and the code is somewhat sensible. While it’s unnecessary to implement Pong in CSS, and the CSS Working Group probably hasn’t been contemplating how to make that particular niche task easier, the increasing flexibility and power of CSS reinforce my suspicion that one day it will be a lifestyle choice whether to achieve any given effect with scripting or CSS.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe demo is a similar number of lines of CSS to Alex’s 2013 implementation, but it didn’t feel much like a hack. It’s a demo of modern CSS features working together in the way I expected after reading the instruction booklet. Sometimes when reading introductory articles about the new features we are getting in CSS, it’s hard to appreciate how game-changing they are till you see several features working together. As often happens when pushing the boundaries of a technology, we are going to bump up against the current limitations of style queries and animations. But it’s all in good fun, and we’ll learn about these CSS features in more detail than if we had not attempted this crazy experiment.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt does seem to work, and my 12-year-old and 7-year-old have both playtested it on my phone and laptop, so it gets the “works on Lee’s devices” seal of quality. Also, since Chrome now supports controlling \u003ca href=\"https://codepen.io/t_afif/pen/GRbawQm\" rel=\"noopener\"\u003eanimations using range inputs\u003c/a\u003e, we can make our game playable on mobile, unlike the 2013 version, which relied on \u003ca href=\"https://css-tricks.com/almanac/pseudo-selectors/h/hover/\"\u003e\u003ccode\u003e:hover\u003c/code\u003e\u003c/a\u003e. Temani Afif provides a \u003ca href=\"https://css-tricks.com/a-css-only-star-rating-component-and-more-part-2/#aa-why-scroll-driven-animations\"\u003egreat explanation\u003c/a\u003e of how and why \u003ca href=\"https://css-tricks.com/almanac/properties/v/view-timeline-name/\"\u003eview progress timelines\u003c/a\u003e can be used to style anything based on the value of a range input.\u003c/p\u003e\n\n\n\u003ch2 id=\"using-style-queries-to-detect-if-the-paddle-hit-the-ball\"\u003eUsing style queries to detect if the paddle hit the ball\u003c/h2\u003e\n\n\n\u003cp\u003eThe ball follows a fixed path, and whether the player’s paddle intersects with the ball when it reaches our side is the only input we have into whether it continues its predetermined bouncy loop or the screen flashes red as the life counter goes down till we see the “Game Over” screen with the option to play again.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis type of interactivity is what game designers call a \u003ca href=\"https://en.wikipedia.org/wiki/Quick_time_event\" rel=\"noopener\"\u003equick time event\u003c/a\u003e. It’s still a game for sure, but five months ago, when I was young and naive, I mused in my article on \u003ca href=\"https://css-tricks.com/slide-through-unlimited-dimensions-with-css-scroll-timelines/\"\u003eanimation timelines\u003c/a\u003e that the animation timeline feature could open the door for advanced games and interactive experiences in CSS. I wrote that a video game is just a “hyper-interactive animation.” Indeed, the above experiment shows that the new features in CSS allow us to respond to user input in sophisticated ways, but the demo also clarifies the difference between the kind of interactivity we can expect from the current incarnation of CSS versus scripting. The above experiment is more like if Pong were a game inside the old-school arcade game \u003ca href=\"https://www.digitalspy.com/videogames/retro-gaming/a593480/dragons-lair-retrospective-how-the-quick-time-event-was-born/\" rel=\"noopener\"\u003eDragon’s Lair\u003c/a\u003e, which was one giant quick time event. It only works because there are limited possible outcomes, but they are certainly less limited than what we used to be able to achieve in CSS.\u003c/p\u003e\n\n\n\n\u003cp\u003eSince we know collision detection with the paddle is the only opportunity for the user to have a say in what happens next, let’s focus on that implementation. It will require more mental gymnastics than I would like, since container style queries only allow for \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Container_size_and_style_queries#container_style_queries\" rel=\"noopener\"\u003ename-value pairs\u003c/a\u003e with the same syntax as \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_conditional_rules/Using_feature_queries\" rel=\"noopener\"\u003efeature queries\u003c/a\u003e, meaning we can’t use “greater than” or “less than” operators when comparing numeric values like we do with \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Container_size_and_style_queries#container_size_queries\" rel=\"noopener\"\u003econtainer size queries\u003c/a\u003e which follow the same syntax as \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media\" rel=\"noopener\"\u003e\u003ccode\u003e@media\u003c/code\u003e size queries\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe workaround below allows us to create style queries based on the ball position being in or out of the range of the paddle. If the ball hits our side, then by default, the play field will flash red and temporarily unpause the animation that decrements the life counter (more on that later). But if the ball hits our side and is within range of the paddle, we leave the life-decrementing animation paused, and make the field background green while the ball hits the paddle. Since we don’t have “greater than” or “less than” operators in style queries, we (ab)use the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/min\" rel=\"noopener\"\u003e\u003ccode\u003emin()\u003c/code\u003e\u003c/a\u003e function. If the result equals the first argument then that argument is less than or equal to the second; otherwise it’s greater than the second argument. It’s logical but made me wish for better comparison operators in style queries. Nevertheless, I was impressed that style queries allow the collision detection to be fairly readable, if a little more verbose than I would like.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebody {\n  --int-ball-position-x: round(down, var(--ball-position-x));\n  --min-ball-position-y-and-top-of-paddle: min(var(--ball-position-y) + var(--ball-height), var(--ping-position));\n  --min-ball-position-y-and-bottom-of-paddle: min(var(--ball-position-y), var(--ping-position) + var(--paddle-height));\n}\n\n@container style(--int-ball-position-x: var(--ball-left-boundary)) {\n  .screen {\n    --lives-decrement: running;\n      \n    .field {\n      background: red;\n    }\n  }\n}\n\n@container style(--min-ball-position-y-and-top-of-paddle: var(--ping-position)) and style(--min-ball-position-y-and-bottom-of-paddle: var(--ball-position-y)) and style(--int-ball-position-x: var(--ball-left-boundary)) {\n  .screen {\n    --lives-decrement: paused;\n\n    .field {\n      background: green;\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"responding-to-collisions\"\u003eResponding to collisions\u003c/h3\u003e\n\n\n\u003cp\u003eNow that we can style our playing field based on whether the paddle hits the ball, we want to decrement the life counter if our paddle misses the ball, and display “Game Over” when we run out of lives. One way to achieve side effects in CSS is by pausing and unpausing keyframe animations that run forwards. These days, we can style things based on custom properties, which we can set in animations. Using this fact, we can take the power of paused animations to another level.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\nbody {\n  animation: ball 8s infinite linear, lives 80ms forwards steps(4) var(--lives-decrement);\n  --lives-decrement: paused;        \n}\n\n.lives::after {\n   content: var(--lives);\n}\n\n@keyframes lives {\n  0% {\n    --lives: \u0026#34;3\u0026#34;;\n  }\n  25% {\n    --lives: \u0026#34;2\u0026#34;;\n  }\n  75% {\n    --lives: \u0026#34;1\u0026#34;;\n  }\n  100% {\n    --lives: \u0026#34;0\u0026#34;;\n  }\n}\n\n@container style(--int-ball-position-x: var(--ball-left-boundary)) {\n  .screen {\n    --lives-decrement: running;\n      \n    .field {\n      background: red;\n    }\n  }\n}\n\n@container style(--min-ball-position-y-and-top-of-paddle: var(--ping-position)) and style(--min-ball-position-y-and-bottom-of-paddle: var(--ball-position-y)) and style(--int-ball-position-x: 8) {\n  .screen {\n    --lives-decrement: paused;\n    \n    .field {\n      background: green;\n    }\n  }\n}\n\n@container style(--lives: \u0026#39;0\u0026#39;) {\n  .field {\n     display: none;\n  }\n  \n  .game-over {\n     display: flex;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSo when the ball hits the wall and isn’t in range of the paddle, the lives-decrementing animation is unpaused long enough to let it complete one step. Once it reaches zero we hide the play field and display the “Game Over” screen. What’s fascinating about this part of the experiment is that it shows that, using style queries, all properties become indirectly possible to control via animations, even when working with non-animatable properties. And this applies to properties that control whether other animations play. This \u003ca href=\"https://dev.to/janeori/expert-css-the-cpu-hack-4ddj\" rel=\"noopener\"\u003earticle\u003c/a\u003e touches on why play state deliberately isn’t animatable and could be dangerous to animate, but we know what we are doing, right?\u003c/p\u003e\n\n\n\n\u003cp\u003eFull disclosure: The play state approach did lead to hidden complexity in the choice of duration of the animations. I knew that if I chose too long a duration for the life-decrementing counter, it might not have time to proceed to the next step while the ball was hitting the wall, but if I chose too short a duration, missing the ball once might cause the player to lose more than one life.\u003c/p\u003e\n\n\n\n\u003cp\u003eI made educated guesses of suitable durations for the ball bouncing and life decrementing, and I expected that when working with fixed-duration predictable animations, the life counter would either always work or always fail. I didn’t expect that my first attempt at the implementation intermittently failed to decrement the life counter at the same point in the animation loop. Setting the durations of both these related animations to multiples of eight seems to fix the problem, but why would predetermined animations exhibit unpredictable behavior?\u003c/p\u003e\n\n\n\u003ch3 id=\"forefeit-the-game-before-somebody-else-takes-you-out-of-the-frame\"\u003eForefeit the game before somebody else takes you out of the frame\u003c/h3\u003e\n\n\n\u003cp\u003eI have theories as to why the unpredictability of the collision detection seemed to be fixed by setting the ball animation to eight seconds and the lives animation to 80 milliseconds. Again, pushing CSS to its limits forces us to think deeper about how it’s working.\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eCSS appears to suffer from \u003ca href=\"https://stackoverflow.com/questions/8715088/do-css-animations-work-on-strict-time-basis\" rel=\"noopener\"\u003etimer drift\u003c/a\u003e, meaning if you set a keyframes animation to last for one second, it will \u003ca href=\"https://jsfiddle.net/DPWn7/\" rel=\"noopener\"\u003esometimes take slightly under or over one second\u003c/a\u003e. When there is a different rate of change between the ball-bouncing and life-losing, it would make sense that the potential discrepancy between the two would be pronounced and lead to unpredictable collision detection. When the rate of change in both animations is the same, they would suffer about equally from timer drift, meaning the frames still synchronize predictably. Or at least I’m hoping the chance they don’t becomes negligible.\u003c/li\u003e\n\n\n\n\u003cli\u003eAlex’s 2013 version of Pong uses \u003ccode\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d\" rel=\"noopener\"\u003etranslate3d()\u003c/a\u003e\u003c/code\u003e to move the ball even though it only moves in 2D. Alex recommends this whenever possible “for efficient animation rendering, offloading processing to the GPU for smoother visual effects.” Doing this may have been an alternative fix if it leads to more precise animation timing. There are \u003ca href=\"https://css-tricks.com/myth-busting-css-animations-vs-javascript/\"\u003etradeoffs\u003c/a\u003e so I wasn’t willing to go down that rabbit hole of trying to tune the animation performance in this article — but it could be an interesting focus for future research into CSS collision detection.\u003c/li\u003e\n\n\n\n\u003cli\u003eMaybe style queries take a varying amount of time to kick in, leading to some form of a \u003ca href=\"https://en.wikipedia.org/wiki/Race_condition\" rel=\"noopener\"\u003erace condition\u003c/a\u003e. It is possible that making the ball-bouncing animation slower made this problem less likely.\u003c/li\u003e\n\n\n\n\u003cli\u003eMaybe the bug remains lurking in the shadows somewhere. What did I expect from a hack I achieved using a magic token from a spooky shopkeeper? Haven’t I seen any eighties movie ever?\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\u003ch3 id=\"outro\"\u003eOutro\u003c/h3\u003e\n\n\n\u003cp\u003e\u003cem\u003eYou finish reading the article, and feel sure that the author’s rationale for his supposed fix for the bug is hogwash. Clearly, Lee has been driven insane by the allure of overpowering new CSS features, whereas you respect the power of CSS, but you also respect its limitations. You sit down to spend a few minutes with the collision detection CodePen to prove it is still broken, but then find other flaws in the collision detection, and you commence work on a fork that will be superior. Hey, speaking of timer drift, how is it suddenly 1 a.m.? Only a crazy person would stay up that late playing with CSS when they have to work the next day. “Madness,” repeats the spooky shopkeeper inside your head, and his laughter echoes somewhere in the night.\u003c/em\u003e\u003c/p\u003e\n\n\n\u003ch2 id=\"roll-the-credits\"\u003eRoll the credits\u003c/h2\u003e\n\n\n\u003cp\u003eThis looping \u003ca href=\"https://codepen.io/ultraschaller/pen/BjJNpG\" rel=\"noopener\"\u003ePong CSS animation\u003c/a\u003e by \u003ca href=\"https://codepen.io/ultraschaller\" rel=\"noopener\"\u003eManuel Schaller\u003c/a\u003e gave me an amazing basis for adding the collision detection. His twitching paddle animations help give the illusion of playing against a computer opponent, so forking his CodePen let me focus on implementing the collision detection rather than reinventing Pong.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis author is grateful to the junior testing team, comprised of his seven-year-old and twelve-year-old, who declared the CSS Pong implementation “pretty cool.” They also suggested the green and red flashes to signal collisions and misses.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe intro and outro for this article were sponsored by the spooky shopkeeper who sells dangerous CSS tricks. He also sells frozen yoghurt, which he calls \u003cem\u003efroghurt\u003c/em\u003e.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-03-31T08:59:47-06:00",
  "modifiedTime": "2025-03-31T08:59:49-06:00"
}
