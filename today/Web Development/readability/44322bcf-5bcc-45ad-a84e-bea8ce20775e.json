{
  "id": "44322bcf-5bcc-45ad-a84e-bea8ce20775e",
  "title": "Breaking Boundaries: Building a Tangram Puzzle With (S)CSS",
  "link": "https://css-tricks.com/breaking-boundaries-building-a-tangram-puzzle-with-scss/",
  "description": "We put it to the test and it turns out Sass can replace JavaScript, at least when it comes to low-level logic and puzzle behavior. With nothing but maps, mixins, functions, and a whole lot of math, we managed to bring our Tangram puzzle to life, no JavaScript required. Breaking Boundaries: Building a Tangram Puzzle With (S)CSS originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Sladjana Stojanovic",
  "published": "Thu, 12 Jun 2025 13:58:38 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "CSS games",
    "Sass"
  ],
  "byline": "Sladjana Stojanovic",
  "length": 23392,
  "excerpt": "We put it to the test and it turns out Sass can replace JavaScript, at least when it comes to low-level logic and puzzle behavior. With nothing but maps, mixins, functions, and a whole lot of math, we managed to bring our Tangram puzzle to life, no JavaScript required.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "For years, I believed that drag-and-drop games ‚Äî especially those involving rotation, spatial logic, and puzzle solving ‚Äî were the exclusive domain of JavaScript. Until one day, I asked AI: ‚ÄúIs it possible to build a fully interactive Tangram puzzle game using only CSS?‚Äù The answer:¬†‚ÄúNo ‚Äî not really. You‚Äôll need JavaScript.‚Äù That was all the motivation I needed to prove otherwise. But first, let‚Äôs ask the obvious question:¬†Why would anyone do this? Well‚Ä¶ To know how far CSS can be pushed in creating interactive UIs. To get better at my CSS skills. And it‚Äôs fun! Fair enough? Now, here‚Äôs the unsurprising truth: CSS isn‚Äôt exactly made for this. It‚Äôs not a logic language, and let‚Äôs be honest, it‚Äôs not particularly dynamic either. (Sure, we have CSS variables and some handy built-in functions now, hooray!) In JavaScript, we naturally think in terms of functions, loops, conditions, objects, comparisons. We write logic, abstract things into methods, and eventually ship a bundle that the browser understands. And once it‚Äôs shipped? We rarely look at that final JavaScript bundle ‚Äî we just focus on keeping it lean. Now ask yourself: isn‚Äôt that exactly what Sass does for CSS? Why should we hand-write endless lines of repetitive CSS when we can use mixins and functions to generate it ‚Äî cleanly, efficiently, and without caring how many lines it takes, as long as the output is optimized? So, we put it to the test and it turns out Sass can replace JavaScript, at least when it comes to low-level logic and puzzle behavior. With nothing but maps, mixins, functions, and a whole lot of math, we managed to bring our Tangram puzzle to life, no JavaScript required. Let the (CSS-only) games begin! üéâ The game The game consists of seven pieces: the classic Tangram set. Naturally, these pieces can be arranged into a perfect square (and many other shapes, too). But we need a bit more than just static pieces. So here‚Äôs what I am building: A puzzle goal, which is the target shape the player has to recreate. A start button that shuffles all the pieces into a staging area. Each piece is clickable and interactive. The puzzle should let the user know when they get a piece wrong and also celebrate when they finish the puzzle. The HTML structure I started by setting up the HTML structure, which is no small task, considering the number of elements involved. Each shape was given seven radio buttons. I chose radios over checkboxes to take advantage of their built-in exclusivity. Only one can be selected within the same group. This made it much easier to track which shape and state were currently active. The start button? Also a radio input. A checkbox could‚Äôve worked too, but for the sake of consistency, I stuck with radios across the board. The puzzle map itself is just a plain old¬†\u003cdiv\u003e, simple and effective. For rotation, we added eight radio buttons, each representing a 45-degree increment: 45¬∞, 90¬∞, 135¬∞, all the way to 360¬∞. These simulate rotation controls entirely in CSS. Every potential shadow position got its own radio button too. (Yes, it‚Äôs a lot, I know.) And to wrap it all up, I included a classic reset button inside a¬†\u003cform\u003e¬†using¬†\u003cbutton type=\"reset\"\u003e, so players can easily start over at any point. Given the sheer number of elements required, I used Pug to generate the HTML more efficiently. It was purely a convenience choice. It doesn‚Äôt affect the logic or behavior of the puzzle in any way. Below is a sample of the compiled HTML. It might look overwhelming at first glance (and this is just a portion of it!), but it illustrates the structural complexity involved. This section is collapsed to not nuke your screen, but it can be expanded if you‚Äôd like to explore it. Open HTML Code \u003cdiv class=\"wrapper\"\u003e \u003cdiv class=\"tanagram-box\"\u003e\u003c/div\u003e \u003cdiv class=\"tanagram-box\"\u003e\u003c/div\u003e \u003cform class=\"container\"\u003e \u003cinput class=\"hide_input start\" type=\"checkbox\" id=\"start\" autofocus /\u003e \u003cbutton class=\"start-button\" type=\"reset\" id=\"restart\"\u003eRestart\u003c/button\u003e \u003clabel class=\"start-button\" for=\"start\"\u003eStart \u003c/label\u003e \u003cdiv class=\"shadow\"\u003e \u003cinput class=\"hide_input\" type=\"radio\" id=\"blueTriangle-tan\" name=\"tan-active\" /\u003e \u003cinput class=\"hide_input\" type=\"radio\" id=\"yellowTriangle-tan\" name=\"tan-active\" /\u003e \u003c!-- Inputs for others tans --\u003e \u003cinput class=\"hide_input\" type=\"radio\" id=\"rotation-reset\" name=\"tan-active\" /\u003e \u003cinput class=\"hide_input\" type=\"radio\" id=\"rotation-45\" name=\"tan-rotation\" /\u003e \u003cinput class=\"hide_input\" type=\"radio\" id=\"rotation-90\" name=\"tan-rotation\" /\u003e \u003c!--radios for 90, 225, 315, 360 --\u003e \u003cinput class=\"hide_input\" type=\"checkbox\" id=\"yellowTriangle-tan-1-135\" name=\"tan-rotation\" /\u003e \u003cinput class=\"hide_input\" type=\"checkbox\" id=\"yellowTriangle-tan-1-225\" name=\"tan-rotation\" /\u003e \u003c!-- radio for every possible shape shadows--\u003e \u003clabel class=\"rotation rot\" for=\"rotation-45\" id=\"rot45\"\u003e‚ü≤\u003c/label\u003e \u003clabel class=\"rotation rot\" for=\"rotation-90\" id=\"rot90\"\u003e‚ü≤\u003c/label\u003e \u003c!--radios for 90, 225, 315, 360 --\u003e \u003clabel class=\"rotation\" for=\"rotation-reset\" id=\"rotReset\"\u003e‚úò\u003c/label\u003e \u003clabel class=\"blueTriangle tans\" for=\"blueTriangle-tan\" id=\"tanblueTrianglelab\"\u003e\u003c/label\u003e \u003cdiv class=\"tans tan_blocked\" id=\"tanblueTrianglelabRes\"\u003e\u003c/div\u003e \u003c!-- labels for every tan and disabled div --\u003e \u003clabel class=\"blueTriangle tans\" for=\"blueTriangle-tan-1-90\" id=\"tanblueTrianglelab-1-90\"\u003e\u003c/label\u003e \u003clabel class=\"blueTriangle tans\" for=\"blueTriangle-tan-1-225\" id=\"tanblueTrianglelab-1-225\"\u003e\u003c/label\u003e \u003c!-- labels radio for every possible shape shadows--\u003e \u003cdiv class=\"shape\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/form\u003e \u003cdiv class=\"tanagram-box\"\u003e\u003c/div\u003e \u003cdiv class=\"tanagram-box\"\u003e\u003c/div\u003e \u003cdiv class=\"tanagram-box\"\u003e\u003c/div\u003e \u003cdiv class=\"tanagram-box\"\u003e\u003c/div\u003e \u003cdiv class=\"tanagram-box\"\u003e\u003c/div\u003e \u003c/div\u003e Creating maps for shape data Now that HTML skeleton is ready, it‚Äôs time to inject it with some real power. That‚Äôs where our¬†Sass maps¬†come in, and here‚Äôs where the puzzle logic starts to shine. Note: Maps in Sass hold pairs of keys and values, and make it easy to look up a value by its corresponding key. Like objects in JavaScript, dictionaries in Python and, well, maps in C++. I‚Äôm mapping out all the core data needed to control each tangram piece (tan): its color, shape, position, and even interaction logic. These maps contain: the¬†background-color¬†for each tan, the¬†clip-path¬†coordinates that define their shapes, the initial position for each tan, the position of the blocking¬†div¬†(which disables interaction when a tan is selected), the shadow positions (coordinates for the tan‚Äôs silhouette displayed on the task board), the grid information, and the winning combinations ‚Äî the exact target coordinates for each tan, marking the correct solution. $colors: ( blue-color: #53a0e0, yellow-color: #f7db4f, /* Colors for each tan */ ); $nth-child-grid: ( 1: (2, 3, 1, 2, ), 2: ( 3, 4, 1, 2, ), 4: ( 1, 2, 2, 3, ), /* More entries to be added */); $bluePosiblePositions: ( 45: none, 90: ( (6.7, 11.2), ), 135: none, 180: none, /* Positions defined up to 360 degrees */); /* Other tans */ /* Data defined for each tan */ $tansShapes: ( blueTriangle: ( color: map.get($colors, blue-color), clip-path: ( 0 0, 50 50, 0 100, ), rot-btn-position: ( -20, -25, ), exit-mode-btn-position: ( -20, -33, ), tan-position: ( -6, -37, ), diable-lab-position: ( -12, -38, ), poss-positions: $bluePosiblePositions, correct-position: ((4.7, 13.5), (18.8, 13.3), ), transform-origin: ( 4.17, 12.5,), ), ); /* Remaining 7 combinations */ $winningCombinations: ( combo1: ( (blueTriangle, 1, 360), (yellowTriangle, 1, 225), (pinkTriangle, 1, 180), (redTriangle, 4, 360), (purpleTriangle, 2, 225), (square, 1, 90), (polygon, 4, 90), ), ); You can see this in action on CodePen, where these maps drive the actual look and behavior of each puzzle piece. At this point, there‚Äôs no visible change in the preview. We‚Äôve simply prepared and stored the data for later use. Using mixins to read from maps The main idea is to create reusable mixins that will read data from the maps and apply it to the corresponding CSS rules when needed. But before that, we‚Äôve elevated things to a higher level by making one key decision: We never hard-coded units directly inside the maps. Instead, we built a reusable utility function that dynamically adds the desired unit (e.g.,¬†vmin,¬†px, etc.) to any numeric value when it‚Äôs being used. This way, when can use our maps however we please. @function get-coordinates($data, $key, $separator, $unit) { $coordinates: null; // Check if the first argument is a map @if meta.type-of($data) == \"map\" { // If the map contains the specified key @if map.has-key($data, $key) { // Get the value associated with the key (expected to be a list of coordinates) $coordinates: map.get($data, $key); } // If the first argument is a list } @else if meta.type-of($data) == \"list\" { // Ensure the key is a valid index (1-based) within the list @if meta.type-of($key) == \"number\" and $key \u003e 0 and $key \u003c= list.length($data) { // Retrieve the item at the specified index $coordinates: list.nth($data, $key); } // If neither map nor list, throw an error } @else { @error \"Invalid input: First argument must be a map or a list.\"; } // If no valid coordinates were found, return null @if $coordinates == null { @return null; } // Extract x and y values from the list $x: list.nth($coordinates, 1); $y: list.nth($coordinates, -1); // -1 gets the last item (y) // Return the combined x and y values with units and separator @return #{$x}#{$unit}#{$separator}#{$y}#{$unit}; } Sure, nothing‚Äôs showing up in the preview yet, but the real magic starts now. Now we move on to writing mixins. I‚Äôll explain the approach in detail for the first mixin, and the rest will be described through comments. The first mixin dynamically applies¬†grid-column¬†and¬†grid-row¬†placement rules to child elements based on values stored in a map. Each entry in the map corresponds to an element index (1 through 8) and contains a list of four values:¬†[start-col, end-col, start-row, end-row]. @mixin tanagram-grid-positioning($nth-child-grid) { // Loop through numbers 1 to 8, corresponding to the tanam pieces @for $i from 1 through 8 { // Check if the map contains a key for the current piece (1-8) @if map.has-key($nth-child-grid, $i) { // Get the grid values for this piece: [start-column, end-column, start-row, end-row] $values: map.get($nth-child-grid, $i); // Target the nth child (piece) and set its grid positions \u0026:nth-child(#{$i}) { // Set grid-column: start and end values based on the first two items in the list grid-column: #{list.nth($values, 1)} / #{list.nth($values, 2)}; // Set grid-row: start and end values based on the last two items in the list grid-row: #{list.nth($values, 3)} / #{list.nth($values, 4)}; } } } } We can expect the following CSS to be generated: .tanagram-box:nth-child(1) { grid-column: 2 / 3; grid-row: 1 / 2; } .tanagram-box:nth-child(2) { grid-column: 3 / 4; grid-row: 1 / 2; } In this mixin, my goal was actually to create all the shapes (tans). I am using¬†clip-path. There were ideas to use fancy SVG images, but this test project is more about testing the logic rather than focusing on beautiful design. For this reason, the simplest solution was to cut the elements according to dimensions while they are still in the square (the initial position of all the tans). So, in this case, through a static calculation, the¬†$tansShapes¬†map was updated with the¬†clip-path¬†property: clip-path: (0 0, 50 50, 0 100); This contains the clip points for all the tans. In essence, this mixin shapes and colors each tan accordingly. @mixin set-tan-clip-path($tanName, $values) { // Initialize an empty list to hold the final clip-path points $clip-path-points: (); // Extract the 'clip-path' data from the map, which contains coordinate pairs $clip-path-key: map.get($values, clip-path); // Get the number of coordinate pairs to loop through $count: list.length($clip-path-key); // Loop through each coordinate point @for $i from 1 through $count { // Convert each pair of numbers into a formatted coordinate string with units $current-point: get-coordinates($clip-path-key, $i, \" \", \"%\"); // Add the formatted coordinate to the list, separating each point with a comma $clip-path-points: list.append($clip-path-points, #{$current-point}, comma); } // Style for the preview element (lab version), using the configured background color #tan#{$tanName}lab { background: map.get($values, color); clip-path: polygon(#{$clip-path-points}); // Apply the full list of clip-path points } // Apply the same clip-path to the actual tan element .#{$tanName} { clip-path: polygon(#{$clip-path-points}); } } and output in CSS should be: .blueTriangle { clip-path: polygon(0% 0%, 50% 50%, 0% 100%); } /* other tans */ Start logic Alright, now I‚Äôd like to clarify what should happen first when the game loads. First, with a click on the Start button, all the tans¬†‚Äúgo to their positions.‚Äù In reality, we assign them a¬†transform: translate()¬†with specific coordinates and a rotation. .start:checked ~ .shadow #tanblueTrianglelab { transform-origin: 4.17vmin 12.5vmin; transform: translate(-6vmin,-37vmin) rotate(360deg); cursor: pointer; } So, we still maintain this pattern. We use transform and simply change the positions or angles (in the maps) of both the tans and their shadows on the task board. When any tan is clicked, the rotation button appears. By clicking on it, the tan should rotate around its center, and this continues with each subsequent click. There are actually eight radio buttons, and with each click, one disappears and the next one appears. When we reach the last one, clicking it makes it disappear and the first one reappears. This way, we get the impression of clicking the same button (they are, of course, styled the same) and being able to click (rotate the tan) infinitely. This is exactly what the following mixin enables. @mixin set-tan-rotation-states($tanName, $values, $angles, $color) { // This mixin dynamically applies rotation UI styles based on a tan's configuration. // It controls the positioning and appearance of rotation buttons and visual feedback when a rotation state is active. @each $angle in $angles{ \u0026 ~ #rot#{$angle}{ transform: translate(get-coordinates($values,rot-btn-position,',',vmin )); background: $color;} \u0026 ~ #rotation-#{$angle}:checked{ @each $key in map.keys($tansShapes){ \u0026 ~ #tan#{$key}labRes{ visibility: visible; background:rgba(0,0,0,0.4); } \u0026 ~ #tan#{$key}lab{ opacity:.3; } \u0026 ~ #rotReset{ visibility: visible; } } } } } And the generated CSS should be: #blueTriangle-tan:checked ~ #rotation-45:checked ~ #tanblueTrianglelab { transform: translate(-6vmin,-37vmin) rotate(45deg); } #blueTriangle-tan:checked ~ #rotation-45:checked ~ #tanblueTrianglelabRes { visibility: hidden; } OK, the following mixins use the¬†set-clip-path¬†and¬†set-rotation¬†mixins. They contain all the information about the tans and their behavior in relation to which tan is clicked and which rotation is selected, as well as their positions (as defined in the second mixin). @mixin generate-tan-shapes-and-interactions($tansShapes) { // Applies styling logic and UI interactions for each individual tan shape from the $tansShapes map. @each $tanName, $values in $tansShapes{ $color: color.scale(map.get($values, color), $lightness: 10%); $angles: (45, 90, 135, 180, 225, 270, 315, 360); @include set-tan-clip-path($tanName, $values); ##{$tanName}-tan:checked{ \u0026 ~ #tan#{$tanName}Res{ visibility:hidden; } \u0026 ~ #tan#{$tanName}lab{opacity: 1 !important;background: #{$color};cursor:auto;} @each $key in map.keys($tansShapes){ \u0026 ~ #tan#{$tanName}Res:checked ~ #tan#{$key}labRes{visibility: visible;} } \u0026 ~ #rot45{display: flex;visibility: visible;} \u0026 ~ #rotReset{ transform: translate(get-coordinates($values, exit-mode-btn-position,',', vmin)); } @include set-tan-rotation-states($tanName, $values, $angles, $color); } } } @mixin set-initial-tan-position($tansShapes) { // This mixin sets the initial position and transformation for both the interactive (`lab`) and shadow (`labRes`) versions // of each tan shape, based on coordinates provided in the $tansShapes map. @each $tanName, $values in $tansShapes{ \u0026 ~ .shadow #tan#{$tanName}lab{ transform-origin: get-coordinates($values, transform-origin,' ' ,vmin); transform: translate( get-coordinates($values,tan-position,',', vmin)) rotate(360deg) ; cursor: pointer; } \u0026 ~ .shadow #tan#{$tanName}labRes{ visibility:hidden; transform: translate(get-coordinates($values,diable-lab-position,',',vmin)); } } } As mentioned earlier, when a tan is clicked, one of the things that becomes visible is its shadow ‚Äî a silhouette that appears on the task board. These shadow positions (coordinates) are currently defined statically. Each shadow has a specific place on the map, and a mixin reads this data and applies it to the shadow using¬†transform: translate(). When the clicked tan is rotated, the number of visible shadows on the task board can change, as well as their angles, which is expected. Of course, special care was taken with naming conventions. Each shadow element gets a unique ID, made from the name (inherited from its parent tan) and a number that represents its sequence position for the given angle. Pretty cool, right? That way, we avoid complicated naming patterns entirely! @mixin render-possible-tan-positions( $name, $angle, $possiblePositions, $visibility, $color, $id, $transformOrigin ) { // This mixin generates styles for possible positions of a tan shape based on its name, rotation angle, and configuration map. // It handles both squares and polygons, normalizing their rotation angles accordingly and applying transform styles if positions exist.} @if $name == 'square' { $angle: normalize-angle($angle); // Normalizujemo ugao ako je u pitanju square } @else if $name == 'polygon'{ $angle: normalize-polygon-angle($angle); } @if map.has-key($possiblePositions, $angle) { $values: map.get($possiblePositions, $angle); @if $values != none { $count: list.length($values); @for $i from 1 through $count { $position: get-coordinates($values, $i, ',', vmin); \u0026 ~ #tan#{$name}lab-#{$i}-#{$angle} { @if $visibility == visible { visibility: visible; background-color: $color; opacity: .2; z-index: 2; transform-origin: #{$transformOrigin}; transform: translate(#{$position}) rotate(#{$angle}deg); } @else if $visibility == hidden { visibility: hidden; } \u0026:hover{ opacity: 0.5; cursor: pointer; } } } } } } The generated CSS: #blueTriangle-tan:checked ~ #tanblueTrianglelab-1-360 { visibility: visible; background-color: #53a0e0; opacity: 0.2; z-index: 2; transform-origin: 4.17vmin 12.5vmin; transform: translate(4.7vmin,13.5vmin) rotate(360deg); } This next mixin is tied to the previous one and manages when and how the tan shadows appear while their parent tan is being rotated using the button. It listens for the current rotation angle and checks whether there are any shadow positions defined for that specific angle. If there are, it displays them; if not ‚Äî no shadows! @mixin render-possible-positions-by-rotation { // This mixin applies rotation to each tan shape. It loops through each tan, calculates its possible positions for each angle, and handles visibility and transformation. // It ensures that rotation is applied correctly, including handling the transitions between various tan positions and visibility states. @each $tanName, $values in $tansShapes{ $possiblePositions: map.get($values, poss-positions); $possibleTansColor: map.get($values, color); $validPosition: get-coordinates($values, correct-position,',' ,vmin); $transformOrigin: get-coordinates($values,transform-origin,' ' ,vmin); $rotResPosition: get-coordinates($values,exit-mode-btn-position ,',' ,vmin ); $angle: 0; @for $i from 1 through 8{ $angle: $i * 45; $nextAngle: if($angle + 45 \u003e 360, 45, $angle + 45); @include render-position-feedback-on-task($tanName,$angle, $possiblePositions,$possibleTansColor, #{$tanName}-tan, $validPosition,$transformOrigin, $rotResPosition); ##{$tanName}-tan{ @include render-possible-tan-positions($tanName,$angle, $possiblePositions,hidden, $possibleTansColor, #{$tanName}-tan,$transformOrigin) } ##{$tanName}-tan:checked{ @include render-possible-tan-positions($tanName,360, $possiblePositions,visible, $possibleTansColor, #{$tanName}-tan,$transformOrigin); \u0026 ~ #rotation-#{$angle}:checked { @include render-possible-tan-positions($tanName,360, $possiblePositions,hidden, $possibleTansColor, #{$tanName}-tan,$transformOrigin); \u0026 ~ #tan#{$tanName}lab{transform:translate( get-coordinates($values,tan-position,',', vmin)) rotate(#{$angle}deg) ;} \u0026 ~ #tan#{$tanName}labRes{ visibility: hidden; } \u0026 ~ #rot#{$angle}{ visibility: hidden; } \u0026 ~ #rot#{$nextAngle}{ visibility: visible } @include render-possible-tan-positions($tanName,$angle, $possiblePositions,visible, $possibleTansColor, #{$tanName}-tan,$transformOrigin); } } } } } When a tan‚Äôs shadow is clicked, the corresponding tan should move to that shadow‚Äôs position. The next mixin then checks whether this new position is the correct one for solving the puzzle. If it is correct, the tan gets a brief blinking effect and becomes unclickable, signaling it‚Äôs been placed correctly. If it‚Äôs not correct, the tan simply stays at the shadow‚Äôs location. There‚Äôs no effect and it remains draggable/clickable. Of course, there‚Äôs a list of all the correct positions for each tan. Since some tans share the same size ‚Äî and some can even combine to form larger, existing shapes ‚Äî we have multiple valid combinations. For this Camel task, all of them were taken into account. A dedicated map with these combinations was created, along with a mixin that reads and applies them. At the end of the game, when all tans are placed in their correct positions, we trigger a ‚Äúmerging‚Äù effect ‚Äî and the silhouette of the camel turns yellow. At that point, the only remaining action is to click the Restart button. Well, that was long, but that‚Äôs what you get when you pick the fun (albeit hard and lengthy) path. All as an ode to CSS-only magic!",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/tangram.webp",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eFor years, I believed that drag-and-drop games ‚Äî especially those involving rotation, spatial logic, and puzzle solving ‚Äî were the exclusive domain of JavaScript. Until one day, I asked AI:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e‚ÄúIs it possible to build a fully interactive Tangram puzzle game using only CSS?‚Äù\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eThe answer:¬†\u003cem\u003e‚ÄúNo ‚Äî not really. You‚Äôll need JavaScript.‚Äù\u003c/em\u003e That was all the motivation I needed to prove otherwise.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eBut first, let‚Äôs ask the obvious question:¬†\u003cem\u003eWhy would anyone do this?\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eWell‚Ä¶\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eTo know how far CSS can be pushed in creating interactive UIs.\u003c/li\u003e\n\n\n\n\u003cli\u003eTo get better at my CSS skills.\u003c/li\u003e\n\n\n\n\u003cli\u003eAnd it‚Äôs fun!\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eFair enough?\u003c/p\u003e\n\n\n\n\u003cp\u003eNow, here‚Äôs the unsurprising truth: CSS isn‚Äôt exactly made for this. It‚Äôs not a logic language, and let‚Äôs be honest, it‚Äôs not particularly dynamic either. (Sure, we have CSS variables and some handy built-in functions now, hooray!)\u003c/p\u003e\n\n\n\n\u003cp\u003eIn JavaScript, we naturally think in terms of functions, loops, conditions, objects, comparisons. We write logic, abstract things into methods, and eventually ship a bundle that the browser understands. And once it‚Äôs shipped? We rarely look at that final JavaScript bundle ‚Äî we just focus on keeping it lean.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow ask yourself: isn‚Äôt that exactly what Sass does for CSS?\u003c/p\u003e\n\n\n\n\u003cp\u003eWhy should we hand-write endless lines of repetitive CSS when we can use mixins and functions to generate it ‚Äî cleanly, efficiently, and without caring how many lines it takes, as long as the output is optimized?\u003c/p\u003e\n\n\n\n\u003cp\u003eSo, we put it to the test and it turns out Sass can replace JavaScript, at least when it comes to low-level logic and puzzle behavior. With nothing but maps, mixins, functions, and a whole lot of math, we managed to bring our Tangram puzzle to life, no JavaScript required.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet the (CSS-only) games begin! üéâ\u003c/p\u003e\n\n\n\u003ch3 id=\"the-game\"\u003eThe game\u003c/h3\u003e\n\n\n\u003cp\u003eThe game consists of seven pieces: the classic Tangram set. Naturally, these pieces can be arranged into a perfect square (and many other shapes, too). But we need a bit more than just static pieces.\u003c/p\u003e\n\n\n\n\u003cp\u003eSo here‚Äôs what I am building:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eA puzzle goal, which is the target shape the player has to recreate.\u003c/li\u003e\n\n\n\n\u003cli\u003eA start button that shuffles all the pieces into a staging area.\u003c/li\u003e\n\n\n\n\u003cli\u003eEach piece is clickable and interactive.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe puzzle should let the user know when they get a piece wrong and also celebrate when they finish the puzzle.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003ch3 id=\"step-1-html-structure\"\u003eThe HTML structure\u003c/h3\u003e\n\n\n\u003cp\u003eI started by setting up the HTML structure, which is no small task, considering the number of elements involved.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eEach shape was given seven radio buttons. I chose radios over checkboxes to take advantage of their built-in exclusivity. Only one can be selected within the same group. This made it much easier to track which shape and state were currently active.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe start button? Also a radio input. A checkbox could‚Äôve worked too, but for the sake of consistency, I stuck with radios across the board.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe puzzle map itself is just a plain old¬†\u003ccode\u003e\u0026lt;div\u0026gt;\u003c/code\u003e, simple and effective.\u003c/li\u003e\n\n\n\n\u003cli\u003eFor rotation, we added eight radio buttons, each representing a 45-degree increment: 45¬∞, 90¬∞, 135¬∞, all the way to 360¬∞. These simulate rotation controls entirely in CSS.\u003c/li\u003e\n\n\n\n\u003cli\u003eEvery potential shadow position got its own radio button too. (Yes, it‚Äôs a lot, I know.)\u003c/li\u003e\n\n\n\n\u003cli\u003eAnd to wrap it all up, I included a classic reset button inside a¬†\u003ccode\u003e\u0026lt;form\u0026gt;\u003c/code\u003e¬†using¬†\u003ccode\u003e\u0026lt;button type=\u0026#34;reset\u0026#34;\u0026gt;\u003c/code\u003e, so players can easily start over at any point.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eGiven the sheer number of elements required, I used Pug to generate the HTML more efficiently. It was purely a convenience choice. It doesn‚Äôt affect the logic or behavior of the puzzle in any way.\u003c/p\u003e\n\n\n\n\u003cp\u003eBelow is a sample of the compiled HTML. It might look overwhelming at first glance (and this is just a portion of it!), but it illustrates the structural complexity involved. This section is collapsed to not nuke your screen, but it can be expanded if you‚Äôd like to explore it.\u003c/p\u003e\n\n\n\n\u003cdetails\u003e\n  \u003csummary\u003e\n          Open HTML Code      \u003c/summary\u003e\n  \n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt;\n  \u0026lt;div class=\u0026#34;tanagram-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;tanagram-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;form class=\u0026#34;container\u0026#34;\u0026gt;\n    \u0026lt;input class=\u0026#34;hide_input start\u0026#34; type=\u0026#34;checkbox\u0026#34; id=\u0026#34;start\u0026#34; autofocus /\u0026gt;\n    \u0026lt;button class=\u0026#34;start-button\u0026#34; type=\u0026#34;reset\u0026#34; id=\u0026#34;restart\u0026#34;\u0026gt;Restart\u0026lt;/button\u0026gt;\n    \u0026lt;label class=\u0026#34;start-button\u0026#34; for=\u0026#34;start\u0026#34;\u0026gt;Start \u0026lt;/label\u0026gt;\n    \u0026lt;div class=\u0026#34;shadow\u0026#34;\u0026gt;\n      \u0026lt;input class=\u0026#34;hide_input\u0026#34; type=\u0026#34;radio\u0026#34; id=\u0026#34;blueTriangle-tan\u0026#34; name=\u0026#34;tan-active\u0026#34; /\u0026gt;\n      \u0026lt;input class=\u0026#34;hide_input\u0026#34; type=\u0026#34;radio\u0026#34; id=\u0026#34;yellowTriangle-tan\u0026#34; name=\u0026#34;tan-active\u0026#34; /\u0026gt;\n      \u0026lt;!-- Inputs for others tans --\u0026gt;\n      \u0026lt;input class=\u0026#34;hide_input\u0026#34; type=\u0026#34;radio\u0026#34; id=\u0026#34;rotation-reset\u0026#34; name=\u0026#34;tan-active\u0026#34; /\u0026gt;\n      \u0026lt;input class=\u0026#34;hide_input\u0026#34; type=\u0026#34;radio\u0026#34; id=\u0026#34;rotation-45\u0026#34; name=\u0026#34;tan-rotation\u0026#34; /\u0026gt;\n      \u0026lt;input class=\u0026#34;hide_input\u0026#34; type=\u0026#34;radio\u0026#34; id=\u0026#34;rotation-90\u0026#34; name=\u0026#34;tan-rotation\u0026#34; /\u0026gt;\n      \u0026lt;!--radios for 90, 225, 315, 360 --\u0026gt;\n\n      \u0026lt;input class=\u0026#34;hide_input\u0026#34; type=\u0026#34;checkbox\u0026#34; id=\u0026#34;yellowTriangle-tan-1-135\u0026#34; name=\u0026#34;tan-rotation\u0026#34; /\u0026gt;\n      \u0026lt;input class=\u0026#34;hide_input\u0026#34; type=\u0026#34;checkbox\u0026#34; id=\u0026#34;yellowTriangle-tan-1-225\u0026#34; name=\u0026#34;tan-rotation\u0026#34; /\u0026gt;\n      \u0026lt;!-- radio for every possible shape shadows--\u0026gt;\n\n      \u0026lt;label class=\u0026#34;rotation rot\u0026#34; for=\u0026#34;rotation-45\u0026#34; id=\u0026#34;rot45\u0026#34;\u0026gt;‚ü≤\u0026lt;/label\u0026gt;\n      \u0026lt;label class=\u0026#34;rotation rot\u0026#34; for=\u0026#34;rotation-90\u0026#34; id=\u0026#34;rot90\u0026#34;\u0026gt;‚ü≤\u0026lt;/label\u0026gt;\n      \u0026lt;!--radios for 90, 225, 315, 360 --\u0026gt;\n      \u0026lt;label class=\u0026#34;rotation\u0026#34; for=\u0026#34;rotation-reset\u0026#34; id=\u0026#34;rotReset\u0026#34;\u0026gt;‚úò\u0026lt;/label\u0026gt;\n\n      \u0026lt;label class=\u0026#34;blueTriangle tans\u0026#34; for=\u0026#34;blueTriangle-tan\u0026#34; id=\u0026#34;tanblueTrianglelab\u0026#34;\u0026gt;\u0026lt;/label\u0026gt;\n      \u0026lt;div class=\u0026#34;tans tan_blocked\u0026#34; id=\u0026#34;tanblueTrianglelabRes\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n      \u0026lt;!-- labels for every tan and disabled div --\u0026gt;\n\n      \u0026lt;label class=\u0026#34;blueTriangle tans\u0026#34; for=\u0026#34;blueTriangle-tan-1-90\u0026#34; id=\u0026#34;tanblueTrianglelab-1-90\u0026#34;\u0026gt;\u0026lt;/label\u0026gt;\n      \u0026lt;label class=\u0026#34;blueTriangle tans\u0026#34; for=\u0026#34;blueTriangle-tan-1-225\u0026#34; id=\u0026#34;tanblueTrianglelab-1-225\u0026#34;\u0026gt;\u0026lt;/label\u0026gt;\n      \u0026lt;!-- labels radio for every possible shape shadows--\u0026gt;\n      \u0026lt;div class=\u0026#34;shape\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n    \u0026lt;/div\u0026gt;\n  \u0026lt;/form\u0026gt;\n  \u0026lt;div class=\u0026#34;tanagram-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;tanagram-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;tanagram-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;tanagram-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;tanagram-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003c/details\u003e\n\n\u003ch3 id=\"step-2-creating-maps-for-shape-data\"\u003eCreating maps for shape data\u003c/h3\u003e\n\n\n\u003cp\u003eNow that HTML skeleton is ready, it‚Äôs time to inject it with some real power. That‚Äôs where our¬†\u003cstrong\u003eSass maps\u003c/strong\u003e¬†come in, and here‚Äôs where the puzzle logic starts to shine.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Maps in Sass hold pairs of keys and values, and make it easy to look up a value by its corresponding key. Like objects in JavaScript, dictionaries in Python and, well, maps in C++.\u003c/p\u003e\n\n\n\n\u003cp\u003eI‚Äôm mapping out all the core data needed to control each tangram piece (tan): its color, shape, position, and even interaction logic. These maps contain:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003ethe¬†\u003ccode\u003ebackground-color\u003c/code\u003e¬†for each tan,\u003c/li\u003e\n\n\n\n\u003cli\u003ethe¬†\u003ccode\u003eclip-path\u003c/code\u003e¬†coordinates that define their shapes,\u003c/li\u003e\n\n\n\n\u003cli\u003ethe initial position for each tan,\u003c/li\u003e\n\n\n\n\u003cli\u003ethe position of the blocking¬†\u003ccode\u003ediv\u003c/code\u003e¬†(which disables interaction when a tan is selected),\u003c/li\u003e\n\n\n\n\u003cli\u003ethe shadow positions (coordinates for the tan‚Äôs silhouette displayed on the task board),\u003c/li\u003e\n\n\n\n\u003cli\u003ethe grid information, and\u003c/li\u003e\n\n\n\n\u003cli\u003ethe winning combinations ‚Äî the exact target coordinates for each tan, marking the correct solution.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e$colors: ( blue-color: #53a0e0, yellow-color: #f7db4f, /* Colors for each tan */ );\n$nth-child-grid: ( 1: (2, 3, 1, 2, ), 2: ( 3, 4, 1, 2, ), 4: ( 1, 2, 2, 3, ), /* More entries to be added */);\n$bluePosiblePositions: ( 45: none, 90: ( (6.7, 11.2), ), 135: none, 180: none, /* Positions defined up to 360 degrees */);\n/* Other tans */\n\n/* Data defined for each tan */\n$tansShapes: (\n  blueTriangle: (\n    color: map.get($colors, blue-color),\n    clip-path: ( 0 0, 50 50, 0 100, ),\n    rot-btn-position: ( -20, -25, ),\n    exit-mode-btn-position: ( -20, -33, ),\n    tan-position: ( -6, -37, ),\n    diable-lab-position: ( -12, -38, ),\n    poss-positions: $bluePosiblePositions,\n    correct-position: ((4.7, 13.5), (18.8, 13.3), ),\n    transform-origin: ( 4.17, 12.5,),\n  ),\n);\n\n/* Remaining 7 combinations */\n$winningCombinations: (\n  combo1: (\n    (blueTriangle, 1, 360),\n    (yellowTriangle, 1, 225),\n    (pinkTriangle, 1, 180),\n    (redTriangle, 4, 360),\n    (purpleTriangle, 2, 225),\n    (square, 1, 90),\n    (polygon, 4, 90),\n  ),\n);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou can see this in action on CodePen, where these maps drive the actual look and behavior of each puzzle piece. At this point, there‚Äôs no visible change in the preview. We‚Äôve simply prepared and stored the data for later use.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"step-3-using-mixins-to-read-from-maps\"\u003eUsing mixins to read from maps\u003c/h3\u003e\n\n\n\u003cp\u003eThe main idea is to create reusable mixins that will read data from the maps and apply it to the corresponding CSS rules when needed.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut before that, we‚Äôve elevated things to a higher level by making one key decision: We never hard-coded units directly inside the maps. Instead, we built a reusable utility function that dynamically adds the desired unit (e.g.,¬†\u003ccode\u003evmin\u003c/code\u003e,¬†\u003ccode\u003epx\u003c/code\u003e, etc.) to any numeric value when it‚Äôs being used. This way, when can use our maps however we please.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@function get-coordinates($data, $key, $separator, $unit) {\n  $coordinates: null;\n\n  // Check if the first argument is a map\n  @if meta.type-of($data) == \u0026#34;map\u0026#34; {\n    // If the map contains the specified key\n    @if map.has-key($data, $key) {\n      // Get the value associated with the key (expected to be a list of coordinates)\n      $coordinates: map.get($data, $key);\n    }\n\n  //  If the first argument is a list\n  } @else if meta.type-of($data) == \u0026#34;list\u0026#34; {\n    // Ensure the key is a valid index (1-based) within the list\n    @if meta.type-of($key) == \u0026#34;number\u0026#34; and $key \u0026gt; 0 and $key \u0026lt;= list.length($data) {\n      // Retrieve the item at the specified index\n      $coordinates: list.nth($data, $key);\n    }\n\n  //  If neither map nor list, throw an error\n  } @else {\n    @error \u0026#34;Invalid input: First argument must be a map or a list.\u0026#34;;\n  }\n\n  // If no valid coordinates were found, return null\n  @if $coordinates == null {\n    @return null;\n  }\n\n  //  Extract x and y values from the list\n  $x: list.nth($coordinates, 1);\n  $y: list.nth($coordinates, -1); // -1 gets the last item (y)\n\n  //  Return the combined x and y values with units and separator\n  @return #{$x}#{$unit}#{$separator}#{$y}#{$unit};\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSure, nothing‚Äôs showing up in the preview yet, but the real magic starts now.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eNow we move on to writing mixins. I‚Äôll explain the approach in detail for the first mixin, and the rest will be described through comments.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe first mixin dynamically applies¬†\u003ccode\u003egrid-column\u003c/code\u003e¬†and¬†\u003ccode\u003egrid-row\u003c/code\u003e¬†placement rules to child elements based on values stored in a map. Each entry in the map corresponds to an element index (1 through 8) and contains a list of four values:¬†\u003ccode\u003e[start-col, end-col, start-row, end-row]\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@mixin tanagram-grid-positioning($nth-child-grid) {\n  // Loop through numbers 1 to 8, corresponding to the tanam pieces\n  @for $i from 1 through 8 {\n\n    // Check if the map contains a key for the current piece (1-8)\n    @if map.has-key($nth-child-grid, $i) {\n\n      // Get the grid values for this piece: [start-column, end-column, start-row, end-row]\n      $values: map.get($nth-child-grid, $i);\n\n      // Target the nth child (piece) and set its grid positions\n      \u0026amp;:nth-child(#{$i}) {\n        // Set grid-column: start and end values based on the first two items in the list\n        grid-column: #{list.nth($values, 1)} / #{list.nth($values, 2)};\n\n        // Set grid-row: start and end values based on the last two items in the list\n        grid-row: #{list.nth($values, 3)} / #{list.nth($values, 4)};\n      }\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe can expect the following CSS to be generated:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.tanagram-box:nth-child(1) {\n  grid-column: 2 / 3;\n  grid-row: 1 / 2;\n}\n\n.tanagram-box:nth-child(2) {\n  grid-column: 3 / 4;\n  grid-row: 1 / 2;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eIn this mixin, my goal was actually to create all the shapes (tans). I am using¬†\u003ccode\u003eclip-path\u003c/code\u003e. There were ideas to use fancy SVG images, but this test project is more about testing the logic rather than focusing on beautiful design. For this reason, the simplest solution was to cut the elements according to dimensions while they are still in the square (the initial position of all the tans).\u003c/p\u003e\n\n\n\n\u003cp\u003eSo, in this case, through a static calculation, the¬†\u003ccode\u003e$tansShapes\u003c/code\u003e¬†map was updated with the¬†\u003ccode\u003eclip-path\u003c/code\u003e¬†property:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclip-path: (0 0, 50 50, 0 100);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis contains the clip points for all the tans. In essence, this mixin shapes and colors each tan accordingly.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@mixin set-tan-clip-path($tanName, $values) {\n  //  Initialize an empty list to hold the final clip-path points\n  $clip-path-points: ();\n\n  // Extract the \u0026#39;clip-path\u0026#39; data from the map, which contains coordinate pairs\n  $clip-path-key: map.get($values, clip-path);\n\n  // Get the number of coordinate pairs to loop through\n  $count: list.length($clip-path-key);\n\n  //  Loop through each coordinate point\n  @for $i from 1 through $count {\n    //  Convert each pair of numbers into a formatted coordinate string with units\n    $current-point: get-coordinates($clip-path-key, $i, \u0026#34; \u0026#34;, \u0026#34;%\u0026#34;);\n\n    //  Add the formatted coordinate to the list, separating each point with a comma\n    $clip-path-points: list.append($clip-path-points, #{$current-point}, comma);\n  }\n\n  //  Style for the preview element (lab version), using the configured background color\n  #tan#{$tanName}lab {\n    background: map.get($values, color);\n    clip-path: polygon(#{$clip-path-points}); // Apply the full list of clip-path points\n  }\n\n  //  Apply the same clip-path to the actual tan element\n  .#{$tanName} {\n    clip-path: polygon(#{$clip-path-points});\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eand output in CSS should be:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.blueTriangle {\n  clip-path: polygon(0% 0%, 50% 50%, 0% 100%);\n}\n/* other tans */\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\u003ch3 id=\"start-logic\"\u003eStart logic\u003c/h3\u003e\n\n\n\u003cp\u003eAlright, now I‚Äôd like to clarify what should happen first when the game loads.\u003c/p\u003e\n\n\n\n\u003cp\u003eFirst, with a click on the Start button, all the tans¬†‚Äúgo to their positions.‚Äù In reality, we assign them a¬†\u003ccode\u003etransform: translate()\u003c/code\u003e¬†with specific coordinates and a rotation.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.start:checked ~ .shadow #tanblueTrianglelab {\n  transform-origin: 4.17vmin 12.5vmin;\n  transform: translate(-6vmin,-37vmin) rotate(360deg);\n  cursor: pointer;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eSo, we still maintain this pattern. We use transform and simply change the positions or angles (in the maps) of both the tans and their shadows on the task board.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen any tan is clicked, the rotation button appears. By clicking on it, the tan should rotate around its center, and this continues with each subsequent click. There are actually eight radio buttons, and with each click, one disappears and the next one appears. When we reach the last one, clicking it makes it disappear and the first one reappears. This way, we get the impression of clicking the same button (they are, of course, styled the same) and being able to click (rotate the tan) infinitely. This is exactly what the following mixin enables.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@mixin set-tan-rotation-states($tanName, $values, $angles, $color) {\n  // This mixin dynamically applies rotation UI styles based on a tan\u0026#39;s configuration.\n  // It controls the positioning and appearance of rotation buttons and visual feedback when a rotation state is active.\n  @each $angle in $angles{\n    \u0026amp; ~ #rot#{$angle}{ transform: translate(get-coordinates($values,rot-btn-position,\u0026#39;,\u0026#39;,vmin )); background: $color;}\n    \u0026amp; ~ #rotation-#{$angle}:checked{\n      @each $key in map.keys($tansShapes){\n        \u0026amp; ~ #tan#{$key}labRes{ visibility: visible; background:rgba(0,0,0,0.4); }\n        \u0026amp; ~ #tan#{$key}lab{ opacity:.3; }\n        \u0026amp; ~ #rotReset{ visibility: visible; }\n      } \n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd the generated CSS should be:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e#blueTriangle-tan:checked ~ #rotation-45:checked ~ #tanblueTrianglelab {\n  transform: translate(-6vmin,-37vmin) rotate(45deg);\n}\n\n#blueTriangle-tan:checked ~ #rotation-45:checked ~ #tanblueTrianglelabRes {\n  visibility: hidden;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOK, the following mixins use the¬†\u003ccode\u003eset-clip-path\u003c/code\u003e¬†and¬†\u003ccode\u003eset-rotation\u003c/code\u003e¬†mixins. They contain all the information about the tans and their behavior in relation to which tan is clicked and which rotation is selected, as well as their positions (as defined in the second mixin).\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@mixin generate-tan-shapes-and-interactions($tansShapes) {\n// Applies styling logic and UI interactions for each individual tan shape from the $tansShapes map.\n  @each $tanName, $values in $tansShapes{\n    $color: color.scale(map.get($values, color), $lightness: 10%); \n    $angles: (45, 90, 135, 180, 225, 270, 315, 360); \n    @include set-tan-clip-path($tanName, $values);\n\n    ##{$tanName}-tan:checked{\n      \u0026amp; ~ #tan#{$tanName}Res{ visibility:hidden; }\n      \u0026amp; ~ #tan#{$tanName}lab{opacity: 1 !important;background: #{$color};cursor:auto;}\n      @each $key in map.keys($tansShapes){\n          \u0026amp; ~ #tan#{$tanName}Res:checked ~ #tan#{$key}labRes{visibility: visible;}\n      }\n      \u0026amp; ~  #rot45{display: flex;visibility: visible;}\n      \u0026amp; ~ #rotReset{ transform: translate(get-coordinates($values, exit-mode-btn-position,\u0026#39;,\u0026#39;, vmin)); }\n      @include set-tan-rotation-states($tanName, $values, $angles, $color);\n    }  \n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@mixin set-initial-tan-position($tansShapes) {\n// This mixin sets the initial position and transformation for both the interactive (`lab`) and shadow (`labRes`) versions\n// of each tan shape, based on coordinates provided in the $tansShapes map.\n @each $tanName, $values in $tansShapes{\n    \u0026amp; ~ .shadow #tan#{$tanName}lab{\n      transform-origin: get-coordinates($values, transform-origin,\u0026#39; \u0026#39; ,vmin);\n      transform: translate( get-coordinates($values,tan-position,\u0026#39;,\u0026#39;, vmin)) rotate(360deg) ;\n      cursor: pointer;\n    }\n    \u0026amp; ~ .shadow #tan#{$tanName}labRes{\n      visibility:hidden;\n      transform: translate(get-coordinates($values,diable-lab-position,\u0026#39;,\u0026#39;,vmin)); \n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eAs mentioned earlier, when a tan is clicked, one of the things that becomes visible is its shadow ‚Äî a silhouette that appears on the task board.\u003c/p\u003e\n\n\n\n\u003cp\u003eThese shadow positions (coordinates) are currently defined statically. Each shadow has a specific place on the map, and a mixin reads this data and applies it to the shadow using¬†\u003ccode\u003etransform: translate()\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen the clicked tan is rotated, the number of visible shadows on the task board can change, as well as their angles, which is expected.\u003c/p\u003e\n\n\n\n\u003cp\u003eOf course, special care was taken with naming conventions. Each shadow element gets a unique ID, made from the name (inherited from its parent tan) and a number that represents its sequence position for the given angle.\u003c/p\u003e\n\n\n\n\u003cp\u003ePretty cool, right? That way, we avoid complicated naming patterns entirely!\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@mixin render-possible-tan-positions( $name, $angle, $possiblePositions, $visibility, $color, $id, $transformOrigin ) {\n    // This mixin generates styles for possible positions of a tan shape based on its name, rotation angle, and configuration map.\n    // It handles both squares and polygons, normalizing their rotation angles accordingly and applying transform styles if positions exist.}\n  @if $name == \u0026#39;square\u0026#39; {\n    $angle: normalize-angle($angle); // Normalizujemo ugao ako je u pitanju square\n  } @else if $name == \u0026#39;polygon\u0026#39;{\n    $angle: normalize-polygon-angle($angle);\n  }\n  @if map.has-key($possiblePositions, $angle) {\n    $values: map.get($possiblePositions, $angle);\n\n    @if $values != none {\n      $count: list.length($values);\n\n      @for $i from 1 through $count {\n        $position: get-coordinates($values, $i, \u0026#39;,\u0026#39;, vmin);\n        \u0026amp; ~ #tan#{$name}lab-#{$i}-#{$angle} { \n          @if $visibility == visible {\n            visibility: visible;\n            background-color: $color;\n            opacity: .2;\n            z-index: 2;\n            transform-origin: #{$transformOrigin};\n            transform: translate(#{$position}) rotate(#{$angle}deg);\n          } @else if $visibility == hidden { visibility: hidden; }\n          \u0026amp;:hover{ opacity: 0.5; cursor: pointer; }\n        }\n      }\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe generated CSS:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e#blueTriangle-tan:checked ~ #tanblueTrianglelab-1-360 {\n  visibility: visible;\n  background-color: #53a0e0;\n  opacity: 0.2;\n  z-index: 2;\n  transform-origin: 4.17vmin 12.5vmin;\n  transform: translate(4.7vmin,13.5vmin) rotate(360deg);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis next mixin is tied to the previous one and manages when and how the tan shadows appear while their parent tan is being rotated using the button. It listens for the current rotation angle and checks whether there are any shadow positions defined for that specific angle. If there are, it displays them; if not ‚Äî no shadows!\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@mixin render-possible-positions-by-rotation {\n   // This mixin applies rotation to each tan shape. It loops through each tan, calculates its possible positions for each angle, and handles visibility and transformation.\n   // It ensures that rotation is applied correctly, including handling the transitions between various tan positions and visibility states.\n @each $tanName, $values in $tansShapes{\n    $possiblePositions: map.get($values, poss-positions);\n    $possibleTansColor: map.get($values, color);\n    $validPosition: get-coordinates($values, correct-position,\u0026#39;,\u0026#39; ,vmin);\n    $transformOrigin: get-coordinates($values,transform-origin,\u0026#39; \u0026#39; ,vmin); \n    $rotResPosition: get-coordinates($values,exit-mode-btn-position ,\u0026#39;,\u0026#39; ,vmin );\n    $angle: 0;\n    @for $i from 1 through 8{\n      $angle: $i * 45;\n      $nextAngle: if($angle + 45 \u0026gt; 360, 45, $angle + 45);\n      @include render-position-feedback-on-task($tanName,$angle, $possiblePositions,$possibleTansColor, #{$tanName}-tan, $validPosition,$transformOrigin, $rotResPosition);   \n        ##{$tanName}-tan{\n        @include render-possible-tan-positions($tanName,$angle, $possiblePositions,hidden, $possibleTansColor, #{$tanName}-tan,$transformOrigin)\n      }\n        ##{$tanName}-tan:checked{\n          @include render-possible-tan-positions($tanName,360, $possiblePositions,visible, $possibleTansColor, #{$tanName}-tan,$transformOrigin);\n          \u0026amp; ~ #rotation-#{$angle}:checked {\n            @include render-possible-tan-positions($tanName,360, $possiblePositions,hidden, $possibleTansColor, #{$tanName}-tan,$transformOrigin);\n            \u0026amp; ~ #tan#{$tanName}lab{transform:translate( get-coordinates($values,tan-position,\u0026#39;,\u0026#39;, vmin))  rotate(#{$angle}deg) ;}\n            \u0026amp; ~ #tan#{$tanName}labRes{ visibility: hidden; }\n            \u0026amp; ~ #rot#{$angle}{ visibility: hidden; }\n            \u0026amp; ~ #rot#{$nextAngle}{ visibility: visible } \n            @include render-possible-tan-positions($tanName,$angle, $possiblePositions,visible, $possibleTansColor, #{$tanName}-tan,$transformOrigin);\n        }\n      }\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWhen a tan‚Äôs shadow is clicked, the corresponding tan should move to that shadow‚Äôs position. The next mixin then checks whether this new position is the correct one for solving the puzzle. If it is correct, the tan gets a brief blinking effect and becomes unclickable, signaling it‚Äôs been placed correctly. If it‚Äôs not correct, the tan simply stays at the shadow‚Äôs location. There‚Äôs no effect and it remains draggable/clickable.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eOf course, there‚Äôs a list of all the correct positions for each tan. Since some tans share the same size ‚Äî and some can even combine to form larger, existing shapes ‚Äî we have multiple valid combinations. For this Camel task, all of them were taken into account. A dedicated map with these combinations was created, along with a mixin that reads and applies them.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eAt the end of the game, when all tans are placed in their correct positions, we trigger a ‚Äúmerging‚Äù effect ‚Äî and the silhouette of the camel turns yellow. At that point, the only remaining action is to click the Restart button.\u003c/p\u003e\n\n\n\n\u003cp\u003eWell, that was long, but that‚Äôs what you get when you pick the fun (albeit hard and lengthy) path. All as an ode to CSS-only magic!\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "25 min read",
  "publishedTime": "2025-06-12T07:58:38-06:00",
  "modifiedTime": "2025-06-12T07:58:41-06:00"
}
