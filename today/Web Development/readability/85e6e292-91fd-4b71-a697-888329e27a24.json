{
  "id": "85e6e292-91fd-4b71-a697-888329e27a24",
  "title": "Fluid Superscripts and Subscripts",
  "link": "https://css-tricks.com/fluid-superscripts-and-subscripts/",
  "description": "How much attention do you pay to the alignments of your subscripts and superscripts? Lorenz Wöehr has you covered with a recipe for fluid scaling. Fluid Superscripts and Subscripts originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Lorenz Woehr",
  "published": "Wed, 11 Dec 2024 20:23:46 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "typography"
  ],
  "byline": "Lorenz Woehr",
  "length": 5298,
  "excerpt": "How much attention do you pay to the alignments of your subscripts and superscripts? Lorenz Wöehr has you covered with a recipe for fluid scaling.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "Superscripts and subscripts are essential elements in academic and scientific content — from citation references to chemical formulas and mathematical expressions. Yet browsers handle these elements with a static approach that can create significant problems: elements become either too small on mobile devices or disproportionately large on desktop displays. After years of wrestling with superscript and subscript scaling in CSS, I’m proposing a modern solution using fluid calculations. In this article, I’ll show you why the static approach falls short and how we can provide better typography across all viewports while maintaining accessibility. Best of all, this solution requires nothing but clean, pure CSS. The problem with static scaling The scaling issue is particularly evident when comparing professional typography with browser defaults. Take this example (adapted from Wikipedia), where the first “2” is professionally designed and included in the glyph set, while the second uses \u003csub\u003e (top) and \u003csup\u003e (bottom) elements: Browsers have historically used font-size: smaller for \u003csup\u003e and \u003csub\u003e elements, which translates to roughly 0.83x scaling. While this made sense in the early days of CSS for simple documents, it can create problems in modern responsive designs where font sizes can vary dramatically. This is especially true when using fluid typography, where text sizes can scale smoothly between extremes. Fluid scaling: A better solution I’ve developed a solution that scales more naturally across different sizes by combining fixed and proportional units. This approach ensures legibility at small sizes while maintaining proper proportions at larger sizes, eliminating the need for context-specific adjustments. Here’s how it works: sup, sub { font-size: calc(0.5em + 4px); vertical-align: baseline; position: relative; top: calc(-0.5 * 0.83 * 2 * (1em - 4px)); /* Simplified top: calc(-0.83em + 3.32px) */ } sub { top: calc(0.25 * 0.83 * 2 * (1em - 4px)); /* Simplified top: calc(0.42em - 1.66px) */ } Natural scaling: The degressive formula ensures that superscripts and subscripts remain proportional at all sizes Baseline alignment: By using vertical-align: baseline and relative positioning, we prevent the elements from affecting line height and it gives us better control over the offset to match your specific needs. You’re probably also wondering where the heck these values come from — I’ll explain in the following. Breaking down the math Let’s look at how this works, piece by piece: Calculating the font size (px) At small sizes, the fixed 4px component has more impact. At large sizes, the 0.5em proportion becomes dominant. The result is more natural scaling across all sizes. sup, sub { font-size: calc(0.5em + 4px); /* ... */ } sub { /* ... */ } Calculating the parent font size (em) Within the \u003csup\u003e and \u003csub\u003e elements, we can calculate the parent’s font-size: sup, sub { font-size: calc(0.5em + 4px); top: calc(2 * (1em - 4px)); } sub { top: calc(2 * (1em + 4px)); } The fluid font size is defined as calc(0.5em + 4px). To compensate for the 0.5em, we first need to solve 0.5em * x = 1em which gives us x = 2. The 1em here represents the font size of the \u003csup\u003e and \u003csub\u003e elements themselves. We subtract the 4px fixed component from our current em value before multiplying. The vertical offset For the vertical offset, we start with default CSS positioning values and adjust them to work with our fluid scaling: sup, sub { font-size: calc(0.5em + 4px); top: calc(-0.5 * 0.83 * 2 * (1em - 4px)); } sub { top: calc(0.25 * 0.83 * 2 * (1em - 4px)); } The formula is carefully calibrated to match standard browser positioning: 0.5em (super) and 0.25em (sub) are the default vertical offset values (e.g. used in frameworks like Tailwind CSS and Bootstrap). We multiply by 0.83 to account for the browser’s font-size: smaller scaling factor, which is used per default for superscript and subscript. This approach ensures that our superscripts and subscripts maintain familiar vertical positions while benefiting from improved fluid scaling. The result matches what users expect from traditional browser rendering but scales more naturally across different font sizes. Helpful tips The exact scaling factor font-size: (0.5em + 4px) is based on my analysis of superscript Unicode characters in common fonts. Feel free to adjust these values to match your specific design needs. Here are a few ways how you might want to customize this approach: For larger scaling: sup, sub { font-size: calc(0.6em + 3px); /* adjust offset calculations accordingly */ } For smaller scaling: sup, sub { font-size: calc(0.4em + 5px); /* adjust offset calculations accordingly */ } For backward compatibility, you might want to wrap all of it in a @supports block: @supports (font-size: calc(1em + 1px)) { sup, sub { ... } } Final demo I built this small interactive demo to show different fluid scaling options, compare them to the browser’s static scaling, and fine-tune the vertical positioning to see what works best for your use case: Give it a try in your next project and happy to hear your thoughts!",
  "image": "https://css-tricks.com/wp-json/social-image-generator/v1/image/382867",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eSuperscripts and subscripts are essential elements in academic and scientific content — from citation references to chemical formulas and mathematical expressions. Yet browsers handle these elements with a static approach that can create significant problems: elements become either too small on mobile devices or disproportionately large on desktop displays.\u003c/p\u003e\n\n\n\n\u003cp\u003eAfter years of wrestling with superscript and subscript scaling in CSS, I’m proposing a modern solution using fluid calculations. In this article, I’ll show you why the static approach falls short and how we can provide better typography across all viewports while maintaining accessibility. Best of all, this solution requires nothing but clean, pure CSS.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"the-problem-with-static-scaling\"\u003eThe problem with static scaling\u003c/h2\u003e\n\n\n\u003cp\u003eThe scaling issue is particularly evident when comparing professional typography with browser defaults. Take this example (\u003ca href=\"https://en.wikipedia.org/wiki/Subscript_and_superscript\" rel=\"noopener\"\u003eadapted from Wikipedia\u003c/a\u003e), where the first “2” is professionally designed and included in the glyph set, while the second uses \u003ccode\u003e\u0026lt;sub\u0026gt;\u003c/code\u003e (top) and \u003ccode\u003e\u0026lt;sup\u0026gt;\u003c/code\u003e (bottom) elements:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"1600\" height=\"821\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/fluid-super-subscripts-1.png?resize=1600%2C821\u0026amp;ssl=1\" alt=\"Diagramming the typographic parts and spacing of subscripts and superscripts.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/fluid-super-subscripts-1.png?w=1600\u0026amp;ssl=1 1600w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/fluid-super-subscripts-1.png?resize=300%2C154\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/fluid-super-subscripts-1.png?resize=1024%2C525\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/fluid-super-subscripts-1.png?resize=768%2C394\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/fluid-super-subscripts-1.png?resize=1536%2C788\u0026amp;ssl=1 1536w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eBrowsers have historically used \u003ccode\u003efont-size: smaller\u003c/code\u003e for \u003ccode\u003e\u0026lt;sup\u0026gt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;sub\u0026gt;\u003c/code\u003e elements, which translates to roughly 0.83x scaling. While this made sense in the early days of CSS for simple documents, it can create problems in modern responsive designs where font sizes can vary dramatically. This is especially true when using \u003ca href=\"https://css-tricks.com/snippets/css/fluid-typography/\"\u003efluid typography\u003c/a\u003e, where text sizes can scale smoothly between extremes.\u003c/p\u003e\n\n\n\u003ch2 id=\"fluid-scaling-a-better-solution\"\u003eFluid scaling: A better solution\u003c/h2\u003e\n\n\n\u003cp\u003eI’ve developed a solution that scales more naturally across different sizes by combining fixed and proportional units. This approach ensures legibility at small sizes while maintaining proper proportions at larger sizes, eliminating the need for context-specific adjustments.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eHere’s how it works:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003esup, sub {\n  font-size: calc(0.5em + 4px);\n  vertical-align: baseline;\n  position: relative; \n  top: calc(-0.5 * 0.83 * 2 * (1em - 4px)); \n  /* Simplified top: calc(-0.83em + 3.32px) */\n}\n\nsub {\n  top: calc(0.25 * 0.83 * 2 * (1em - 4px)); \n  /* Simplified top: calc(0.42em - 1.66px) */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNatural scaling\u003c/strong\u003e: The degressive formula ensures that superscripts and subscripts remain proportional at all sizes\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eBaseline alignment\u003c/strong\u003e: By using \u003ccode\u003evertical-align: baseline\u003c/code\u003e and relative positioning, \u003ca href=\"https://css-tricks.com/snippets/css/prevent-superscripts-and-subscripts-from-affecting-line-height/\"\u003ewe prevent the elements from affecting line height\u003c/a\u003e and it gives us better control over the offset to match your specific needs. You’re probably also wondering where the heck these values come from — I’ll explain in the following.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003ch2 id=\"breaking-down-the-math\"\u003eBreaking down the math\u003c/h2\u003e\n\n\n\u003cp\u003eLet’s look at how this works, piece by piece:\u003c/p\u003e\n\n\n\u003ch3 id=\"calculating-the-font-size-px-\"\u003eCalculating the font size (\u003ccode\u003epx\u003c/code\u003e)\u003c/h3\u003e\n\n\n\u003cp\u003eAt small sizes, the fixed \u003ccode\u003e4px\u003c/code\u003e component has more impact. At large sizes, the \u003ccode\u003e0.5em\u003c/code\u003e proportion becomes dominant. The result is more natural scaling across all sizes.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003esup, sub {\n  font-size: calc(0.5em + 4px);\n  /* ... */\n}\n\nsub { \n  /* ... */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"calculating-the-parent-font-size-em-\"\u003eCalculating the parent font size (\u003ccode\u003eem\u003c/code\u003e)\u003c/h3\u003e\n\n\n\u003cp\u003eWithin the \u003ccode\u003e\u0026lt;sup\u0026gt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;sub\u0026gt;\u003c/code\u003e elements, we can calculate the parent’s \u003ccode\u003efont-size\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003esup, sub {\n  font-size: calc(0.5em + 4px);\n  top: calc(2 * (1em - 4px));\n}\n\nsub { \n  top: calc(2 * (1em + 4px));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe fluid font size is defined as \u003ccode\u003ecalc(0.5em + 4px)\u003c/code\u003e. To compensate for the \u003ccode\u003e0.5em\u003c/code\u003e, we first need to solve \u003ccode\u003e0.5em * x = 1em\u003c/code\u003e which gives us \u003ccode\u003ex = 2\u003c/code\u003e. The \u003ccode\u003e1em\u003c/code\u003e here represents the font size of the \u003ccode\u003e\u0026lt;sup\u0026gt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;sub\u0026gt;\u003c/code\u003e elements themselves. We subtract the \u003ccode\u003e4px\u003c/code\u003e fixed component from our current \u003ccode\u003eem\u003c/code\u003e value before multiplying.\u003c/p\u003e\n\n\n\u003ch3 id=\"the-vertical-offset\"\u003eThe vertical offset\u003c/h3\u003e\n\n\n\u003cp\u003eFor the vertical offset, we start with default CSS positioning values and adjust them to work with our fluid scaling:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003esup, sub {\n  font-size: calc(0.5em + 4px);\n  top: calc(-0.5 * 0.83 * 2 * (1em - 4px));\n}\n\nsub { \n  top: calc(0.25 * 0.83 * 2 * (1em - 4px));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe formula is carefully calibrated to match standard browser positioning:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e0.5em\u003c/code\u003e (super) and \u003ccode\u003e0.25em\u003c/code\u003e (sub) are the default vertical offset values (e.g. used in frameworks like Tailwind CSS and Bootstrap).\u003c/li\u003e\n\n\n\n\u003cli\u003eWe multiply by \u003ccode\u003e0.83\u003c/code\u003e to account for the browser’s \u003ccode\u003efont-size: smaller\u003c/code\u003e scaling factor, which is used per default for superscript and subscript.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThis approach ensures that our superscripts and subscripts maintain familiar vertical positions while benefiting from improved fluid scaling. The result matches what users expect from traditional browser rendering but scales more naturally across different font sizes.\u003c/p\u003e\n\n\n\u003ch2 id=\"helpful-tips\"\u003eHelpful tips\u003c/h2\u003e\n\n\n\u003cp\u003eThe exact scaling factor \u003ccode\u003efont-size: (0.5em + 4px)\u003c/code\u003e is based on my analysis of superscript Unicode characters in common fonts. Feel free to adjust these values to match your specific design needs. Here are a few ways how you might want to customize this approach:\u003c/p\u003e\n\n\n\n\u003cp\u003eFor larger scaling:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003esup, sub {\n  font-size: calc(0.6em + 3px);\n  /* adjust offset calculations accordingly */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFor smaller scaling:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003esup, sub {\n  font-size: calc(0.4em + 5px);\n  /* adjust offset calculations accordingly */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eFor backward compatibility\u003c/strong\u003e, you might want to \u003ca href=\"https://css-tricks.com/how-supports-works/\"\u003ewrap all of it in a \u003ccode\u003e@supports\u003c/code\u003e block\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports (font-size: calc(1em + 1px)) {\n  sup, sub {\n    ...\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch2 id=\"final-demo\"\u003eFinal demo\u003c/h2\u003e\n\n\n\u003cp\u003eI built this small interactive demo to show different fluid scaling options, compare them to the browser’s static scaling, and fine-tune the vertical positioning to see what works best for your use case:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\u003cp\u003eGive it a try in your next project and happy to hear your thoughts!\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-12-11T13:23:46-07:00",
  "modifiedTime": "2024-12-12T08:27:01-07:00"
}
