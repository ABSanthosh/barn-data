{
  "id": "fe513b5e-557d-411f-83ae-f100c6e37667",
  "title": "A New “Web” Readiness Report",
  "link": "https://css-tricks.com/a-new-web-readiness-report/",
  "description": "HTML 5 Readiness was a site that showed through a rainbow of colors the browser support for several web features. What about a new version? A New “Web” Readiness Report originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Juan Diego Rodríguez",
  "published": "Fri, 04 Apr 2025 13:05:22 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "browser",
    "resource"
  ],
  "byline": "Juan Diego Rodríguez",
  "length": 7532,
  "excerpt": "HTML 5 Readiness was a site that showed through a rainbow of colors the browser support for several web features. What about a new version?",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "The beauty of research is finding yourself on a completely unrelated topic mere minutes from opening your browser. It happened to me while writing an Almanac entry on @namespace, an at-rule that we probably won’t ever use and is often regarded as a legacy piece of CSS. Maybe that’s why there wasn’t a lot of info about it until I found a 2010s post on @namespace by Divya Manian. The post was incredibly enlightening, but that’s beside the point; what’s important is that in Divya’s blog, there were arrows on the sides to read the previous and next posts: Don’t ask me why, but without noticing, I somehow clicked the left arrow twice, which led me to a post on “Notes from HTML5 Readiness Hacking.” What’s HTML 5 Readiness?! HTML 5 Readiness was a site created by Paul Irish and Divya Manian that showed the browser support for several web features through the lens of a rainbow of colors. The features were considered (at the time) state-of-the-art or bleeding-edge stuff, such as media queries, transitions, video and audio tags, etc. As each browser supported a feature, a section of the rainbow would be added. I think it worked from 2010 to 2013, although it showed browser support data from 2008. I can’t describe how nostalgic it made me feel; it reminded me of simpler times when even SVGs weren’t fully supported. What almost made me shed a tear was thinking that, if this tool was updated today, all of the features would be colored in a full rainbow. A new web readiness It got me thinking: there are so many new features coming to CSS (many that haven’t shipped to any browser) that there could be a new HTML5 Readiness with all of them. That’s why I set myself to do exactly that last weekend, a Web Readiness 2025 that holds each of the features coming to HTML and CSS I am most excited about. You can visit it at webreadiness.com! Right now, it looks kinda empty, but as time goes we will hopefully see how the rainbow grows: Even though it was a weekend project, I took the opportunity to dip my toes into a couple of things I wanted to learn. Below are also some snippets I think are worth sharing. The data is sourced from Baseline My first thought was to mod the \u003cbaseline-status\u003e web component made by the Chrome team because I have been wanting to use it since it came out. In short, it lets you embed the support data for a web feature directly into your blog. Not long ago, in fact, Geoff added it as a WordPress block in CSS-Tricks, which has been super useful while writing the Almanac: However, I immediately realized that using the \u003cbaseline-status\u003e would be needlessly laborious, so I instead pulled the data from the Web Features API — https://api.webstatus.dev/v1/features/ — and displayed it myself. You can find all the available features in the GitHub repo. Each ray is a web component Another feature I have been wanting to learn more about was Web Components, and since Geoff recently published his notes on Scott Jehl’s course Web Components Demystified, I thought it was the perfect chance. In this case, each ray would be a web component with a simple live cycle: Get instantiated. Read the feature ID from a data-feature attribute. Fetch its data from the Web Features API. Display its support as a list. Said and done! The simplified version of that code looks something like the following: class BaselineRay extends HTMLElement { constructor() { super(); } static get observedAttributes() { return [\"data-feature\"]; } attributeChangedCallback(property, oldValue, newValue) { if (oldValue !== newValue) { this[property] = newValue; } } async #fetchFeature(endpoint, featureID) { // Fetch Feature Function } async connectedCallback() { // Call fetchFeature and Output List } } customElements.define(\"baseline-ray\", BaselineRay); Animations with the Web Animation API I must admit, I am not too design-savvy (I hope it isn’t that obvious), so what I lacked in design, I made up with some animations. When the page initially loads, a welcome animation is easily achieved with a couple of timed keyframes. However, the animation between the rainbow and list layouts is a little more involved since it depends on the user’s input, so we have to trigger them with JavaScript. At first, I thought it would be easier to do them with Same-Document View Transitions, but I found myself battling with the browser’s default transitions and the lack of good documentation beyond Chrome’s posts. That’s why I decided on the Web Animation API, which lets you trigger transitions in a declarative manner. sibling-index() and sibling-count() A while ago, I wrote about the sibling-index() and sibling-count() functions. As their names imply, they return the current index of an element among its sibling, and the total amount of siblings, respectively. While Chrome announced its intent to ship both functions, I know it will be a while until they reach baseline support, but I still needed them to rotate and move each ray. In that same post, I talked about three options to polyfill each function. The first two were CSS-only, but this time I took the simplest JavaScript way which observes the number of rays and adds custom properties with its index and total count. Sure, it’s a bit overkill since the amount of rays doesn’t change, but pretty easy to implement: const elements = document.querySelector(\".rays\"); const updateCustomProperties = () =\u003e { let index = 0; for (let element of elements.children) { element.style.setProperty(\"--sibling-index\", index); index++; } elements.style.setProperty(\"--sibling-count\", elements.children.length - 1); }; updateCustomProperties(); const observer = new MutationObserver(updateCustomProperties); const config = {attributes: false, childList: true, subtree: false}; observer.observe(elements, config); With this, I could position each ray in a 180-degree range: baseline-ray ul{ --position: calc(180 / var(--sibling-count) * var(--sibling-index) - 90); --rotation: calc(var(--position) * 1deg); transform: translateX(-50%) rotate(var(--rotation)) translateY(var(--ray-separation)); transform-origin: bottom center; } The selection is JavaScript-less In the browser captions, if you hover over a specific browser, that browser’s color will pop out more in the rainbow while the rest becomes a little transparent. Since in my HTML, the caption element isn’t anyway near the rainbow (as a parent or a sibling), I thought I would need JavaScript for the task, but then I remembered I could simply use the :has() selector. It works by detecting whenever the closest parent of both elements (it could be \u003csection\u003e, \u003cmain\u003e, or the whole \u003cbody\u003e) has a .caption item with a :hover pseudo-class. Once detected, we increase the size of each ray section of the same browser, while decreasing the opacity of the rest of the ray sections. What’s next?! What’s left now is to wait! I hope people can visit the page from time to time and see how the rainbow grows. Like the original HTML 5 Readiness page, I also want to take a snapshot at the end of the year to see how it looks until each feature is fully supported. Hopefully, it won’t take long, especially seeing the browser’s effort to ship things faster and improve interoperability. Also, let me know if you think a feature is missing! I tried my best to pick exciting features without baseline support.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/A-New-HTML-5-Readiness.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eThe beauty of research is finding yourself on a completely unrelated topic mere minutes from opening your browser. It happened to me while \u003ca href=\"https://css-tricks.com/almanac/rules/n/namespace/\"\u003ewriting an Almanac entry on \u003ccode\u003e@namespace\u003c/code\u003e\u003c/a\u003e, an at-rule that we probably won’t ever use and is often regarded as a legacy piece of CSS. Maybe that’s why there wasn’t a lot of info about it until I found a 2010s \u003ca href=\"https://nimbupani.com/spacing-out-on-css-namespaces.html\" rel=\"noopener\"\u003epost on \u003ccode\u003e@namespace\u003c/code\u003e by Divya Manian\u003c/a\u003e. The post was incredibly enlightening, but that’s beside the point; what’s important is that in Divya’s blog, there were arrows on the sides to read the previous and next posts:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"1201\" height=\"455\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-7.png?resize=1201%2C455\u0026amp;ssl=1\" alt=\"\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-7.png?w=1201\u0026amp;ssl=1 1201w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-7.png?resize=300%2C114\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-7.png?resize=1024%2C388\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-7.png?resize=768%2C291\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eDon’t ask me why, but without noticing, I somehow clicked the left arrow twice, which led me to a post on \u003ca href=\"https://nimbupani.com/notes-from-html5-readiness-hacking.html\" rel=\"noopener\"\u003e“Notes from HTML5 Readiness Hacking.”\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"1169\" height=\"404\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-2.png?resize=1169%2C404\u0026amp;ssl=1\" alt=\"\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-2.png?w=1169\u0026amp;ssl=1 1169w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-2.png?resize=300%2C104\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-2.png?resize=1024%2C354\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-2.png?resize=768%2C265\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\u003ch3 id=\"whats-html-5-readiness\"\u003eWhat’s HTML 5 Readiness?!\u003c/h3\u003e\n\n\n\u003cp\u003e\u003ca href=\"https://html5readiness.com/\" rel=\"noopener\"\u003eHTML 5 Readiness\u003c/a\u003e was a site created by Paul Irish and Divya Manian that showed the browser support for several web features through the lens of a rainbow of colors. The features were considered (at the time) \u003cem\u003estate-of-the-art\u003c/em\u003e or \u003cem\u003ebleeding-edge\u003c/em\u003e stuff, such as media queries, transitions, video and audio tags, etc. As each browser supported a feature, a section of the rainbow would be added.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"1771\" height=\"890\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-3.png?resize=1771%2C890\u0026amp;ssl=1\" alt=\"\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-3.png?w=1771\u0026amp;ssl=1 1771w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-3.png?resize=300%2C151\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-3.png?resize=1024%2C515\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-3.png?resize=768%2C386\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-3.png?resize=1536%2C772\u0026amp;ssl=1 1536w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eI think it worked from 2010 to 2013, although it showed browser support data from 2008. I can’t describe how nostalgic it made me feel; it reminded me of simpler times when even SVGs weren’t fully supported. What almost made me shed a tear was thinking that, if this tool was updated today, all of the features would be colored in a full rainbow.\u003c/p\u003e\n\n\n\u003ch3 id=\"a-new-web-readiness\"\u003eA new web readiness\u003c/h3\u003e\n\n\n\u003cp\u003eIt got me thinking: there are so many new features coming to CSS (many that haven’t shipped to any browser) that there could be a new HTML5 Readiness with all of them. That’s why I set myself to do exactly that last weekend, a \u003cem\u003eWeb Readiness\u003c/em\u003e 2025 that holds each of the features coming to HTML and CSS I am most excited about.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eYou can visit it at \u003ca href=\"https://webreadiness.com/\" rel=\"noopener\"\u003ewebreadiness.com\u003c/a\u003e!\u003c/strong\u003e \u003c/p\u003e\n\n\n\n\u003cp\u003eRight now, it looks kinda empty, but as time goes we will hopefully see how the rainbow grows: \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1915\" height=\"936\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-6.png?resize=1915%2C936\u0026amp;ssl=1\" alt=\"\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-6.png?w=1915\u0026amp;ssl=1 1915w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-6.png?resize=300%2C147\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-6.png?resize=1024%2C501\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-6.png?resize=768%2C375\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image-6.png?resize=1536%2C751\u0026amp;ssl=1 1536w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eEven though it was a weekend project, I took the opportunity to dip my toes into a couple of things I wanted to learn. Below are also some snippets I think are worth sharing.\u003c/p\u003e\n\n\n\u003ch3 id=\"the-data-is-sourced-from-baseline\"\u003eThe data is sourced from Baseline\u003c/h3\u003e\n\n\n\u003cp\u003eMy first thought was to mod the \u003ccode\u003e\u003ca href=\"https://web.dev/blog/show-baseline-status\" rel=\"noopener\"\u003e\u0026lt;baseline-status\u0026gt;\u003c/a\u003e\u003c/code\u003e web component made by the Chrome team because I have been wanting to use it since it came out. In short, it lets you embed the support data for a web feature directly into your blog. Not long ago, in fact, \u003ca href=\"https://css-tricks.com/baseline-status-in-a-wordpress-block/\"\u003eGeoff added it as a WordPress block \u003c/a\u003ein CSS-Tricks, which has been super useful while writing the Almanac:\u003c/p\u003e\n\n\n\n\n\u003cbaseline-status featureid=\"anchor-positioning\"\u003e\u003c/baseline-status\u003e\n\n\n\n\u003cp\u003eHowever, I immediately realized that using the \u003ccode\u003e\u0026lt;baseline-status\u0026gt;\u003c/code\u003e would be needlessly laborious, so I instead pulled the data from the Web Features API — \u003ca href=\"https://api.webstatus.dev/v1/features/\" rel=\"noopener\"\u003e\u003ccode\u003ehttps://api.webstatus.dev/v1/features/\u003c/code\u003e\u003c/a\u003e — and displayed it myself. You can find all the available features in the \u003ca href=\"https://github.com/web-platform-dx/web-features/tree/main/features\" rel=\"noopener\"\u003eGitHub repo\u003c/a\u003e.\u003c/p\u003e\n\n\n\u003ch3 id=\"each-ray-is-a-web-component\"\u003eEach ray is a web component\u003c/h3\u003e\n\n\n\u003cp\u003eAnother feature I have been wanting to learn more about was Web Components, and since \u003ca href=\"https://css-tricks.com/web-components-demystified/\"\u003eGeoff recently published his notes \u003c/a\u003eon Scott Jehl’s course \u003cem\u003eWeb Components Demystified\u003c/em\u003e, I thought it was the perfect chance. In this case, each ray would be a web component with a simple live cycle:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eGet instantiated.\u003c/li\u003e\n\n\n\n\u003cli\u003eRead the feature ID from a \u003ccode\u003edata-feature\u003c/code\u003e attribute.\u003c/li\u003e\n\n\n\n\u003cli\u003eFetch its data from the Web Features API.\u003c/li\u003e\n\n\n\n\u003cli\u003eDisplay its support as a list.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eSaid and done! The simplified version of that code looks something like the following:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclass BaselineRay extends HTMLElement {\n  constructor() {\n    super();\n  }\n\n  static get observedAttributes() {\n    return [\u0026#34;data-feature\u0026#34;];\n  }\n\n  attributeChangedCallback(property, oldValue, newValue) {\n    if (oldValue !== newValue) {\n      this[property] = newValue;\n    }\n  }\n\n  async #fetchFeature(endpoint, featureID) {\n    // Fetch Feature Function\n  }\n\n  async connectedCallback() {\n    // Call fetchFeature and Output List\n  }\n}\n\ncustomElements.define(\u0026#34;baseline-ray\u0026#34;, BaselineRay);\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"animations-with-the-web-animation-api\"\u003eAnimations with the Web Animation API\u003c/h3\u003e\n\n\n\u003cp\u003eI must admit, I am not too design-savvy (I hope it isn’t that obvious), so what I lacked in design, I made up with some animations. When the page initially loads, a welcome animation is easily achieved with a couple of timed keyframes. However, the animation between the rainbow and list layouts is a little more involved since it depends on the user’s input, so we have to trigger them with JavaScript.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://css-tricks.com/wp-content/plugins/breeze/assets/images/placeholder.mp4\" data-breeze=\"https://css-tricks.com/wp-content/uploads/2025/03/juandivideo2.mp4\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAt first, I thought it would be easier to do them with \u003ca href=\"https://developer.chrome.com/docs/web-platform/view-transitions/same-document\" rel=\"noopener\"\u003eSame-Document View Transitions\u003c/a\u003e, but I found myself battling with the browser’s default transitions and the lack of good documentation beyond Chrome’s posts. That’s why I decided on the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API\" rel=\"noopener\"\u003eWeb Animation API\u003c/a\u003e, which lets you trigger transitions in a declarative manner.\u003c/p\u003e\n\n\n\u003ch3 id=\"siblingindex-and-siblingcount\"\u003e\u003ccode\u003esibling-index()\u003c/code\u003e and \u003ccode\u003esibling-count()\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003eA while ago, I wrote about the \u003ca href=\"https://css-tricks.com/how-to-wait-for-the-sibling-count-and-sibling-index-functions/\"\u003e\u003ccode\u003esibling-index()\u003c/code\u003e and \u003ccode\u003esibling-count()\u003c/code\u003e\u003c/a\u003e functions. As their names imply, they return the current index of an element among its sibling, and the total amount of siblings, respectively. While Chrome announced its intent to ship both functions, I know it will be a while until they reach baseline support, but I still needed them to rotate and move each ray.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn that same post, I talked about three options to polyfill each function. The first two were CSS-only, but this time I took the simplest JavaScript way which observes the number of rays and adds custom properties with its index and total count. Sure, it’s a bit overkill since the amount of rays doesn’t change, but pretty easy to implement:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst elements = document.querySelector(\u0026#34;.rays\u0026#34;);\n\nconst updateCustomProperties = () =\u0026gt; {\n  let index = 0;\n\n  for (let element of elements.children) {\n    element.style.setProperty(\u0026#34;--sibling-index\u0026#34;, index);\n    index++;\n  }\n\n  elements.style.setProperty(\u0026#34;--sibling-count\u0026#34;, elements.children.length - 1);\n};\n\nupdateCustomProperties();\n\nconst observer = new MutationObserver(updateCustomProperties);\nconst config = {attributes: false, childList: true, subtree: false};\nobserver.observe(elements, config);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith this, I could position each ray in a 180-degree range:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebaseline-ray ul{\n  --position: calc(180 / var(--sibling-count) * var(--sibling-index) - 90);\n  --rotation: calc(var(--position) * 1deg);\n     \n  transform: translateX(-50%) rotate(var(--rotation)) translateY(var(--ray-separation));\n  transform-origin: bottom center;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"the-selection-is-javascriptless\"\u003eThe selection is JavaScript-less\u003c/h3\u003e\n\n\n\u003cp\u003eIn the browser captions, if you hover over a specific browser, that browser’s color will pop out more in the rainbow while the rest becomes a little transparent. Since in my HTML, the caption element isn’t anyway near the rainbow (as a parent or a sibling), I thought I would need JavaScript for the task, but then I remembered I could simply use the \u003ccode\u003e:has()\u003c/code\u003e selector.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt works by detecting whenever the closest parent of both elements (it could be \u003ccode\u003e\u0026lt;section\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;main\u0026gt;\u003c/code\u003e, or the whole \u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e) has a .\u003ccode\u003ecaption\u003c/code\u003e item with a \u003ccode\u003e:hover\u003c/code\u003e pseudo-class. Once detected, we increase the size of each ray section of the same browser, while decreasing the opacity of the rest of the ray sections.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"whats-next\"\u003eWhat’s next?!\u003c/h3\u003e\n\n\n\u003cp\u003eWhat’s left now is to wait! I hope people can visit the page from time to time and see how the rainbow grows. Like the original HTML 5 Readiness page, I also want to take a snapshot at the end of the year to see how it looks until each feature is fully supported. Hopefully, it won’t take long, especially seeing the browser’s effort to ship things faster and \u003ca href=\"https://web.dev/blog/interop-2025\" rel=\"noopener\"\u003eimprove interoperability\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eAlso, let me know if you think a feature is missing! I tried my best to pick exciting features without baseline support.\u003c/p\u003e\n\n\n\n\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-04-04T07:05:22-06:00",
  "modifiedTime": "2025-04-04T07:05:35-06:00"
}
