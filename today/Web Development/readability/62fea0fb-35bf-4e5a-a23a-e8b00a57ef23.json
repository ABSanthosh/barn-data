{
  "id": "62fea0fb-35bf-4e5a-a23a-e8b00a57ef23",
  "title": "Recipes for Detecting Support for CSS At-Rules",
  "link": "https://css-tricks.com/recipes-for-detecting-support-for-css-at-rules/",
  "description": "The @supports at-rule has been extended several times since its initial release. Once only capable of checking support for property/value pairs, it can now check for a selector using the selector() wrapper function and different font formats and techs using … Recipes for Detecting Support for CSS At-Rules originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Juan Diego Rodríguez",
  "published": "Mon, 07 Oct 2024 19:46:07 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "accessibility",
    "at-rules"
  ],
  "byline": "Juan Diego Rodríguez",
  "length": 8039,
  "excerpt": "The @supports at-rule has been extended several times since its initial release. Once only capable of checking support for property/value pairs, it can now",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "DigitalOcean provides cloud products for every stage of your journey. Get started with $200 in free credit! The @supports at-rule has been extended several times since its initial release. Once only capable of checking support for property/value pairs, it can now check for a selector using the selector() wrapper function and different font formats and techs using font-format() and font-tech(), respectively. However, one feature the community still longs for is testing other at-rules support. @supports at-rule(@new-rule) { /* @new-rule is supported */ } The CSSWG decided in 2022 to add the prior at-rule() wrapper function. While this is welcome and wonderful news, here we are two years later and we don’t have a lot of updates on when it will be added to browsers. So, how can we check for support in the meantime? Funny coincidence: Just yesterday the Chrome team changed the status from “new” to “assigned” as if they knew I was thinking about it. Looking for an answer, I found this post by Bramus that offers a workaround: while we can’t check for a CSS at-rule in the @supports at-rule, we can test a property that was shipped with a particular at-rule as a substitute, the thinking being that if a related feature was released that we can test and it is supported, then the feature that we’re unable to test is likely to be supported as well… and vice versa. Bramus provides an example that checks support for the animation-timeline property to check if the @scroll-timeline at-rule (which has been discontinued) is supported since the two were shipped together. @supports (animation-timeline: works) { /* @scroll-timeline is supported*/ } /* Note: @scroll-timeline doesn't exist anymore */ Bramus calls these “telltale” properties, which is a fun way to think about this because it resembles a puzzle of deduction, where we have to find a related property to check if its at-rule is supported. I wanted to see how many of these puzzles I could solve, and in the process, know which at-rules we can reliably test today. So, I’ve identified a full list of supportable at-rules that I could find. I’ve excluded at-rules that offer no browser support, like @color-profile, @when, and @else, as well as deprecated at-rules, like @document. Similarly, I’m excluding older at-rules that have enjoyed wide browser support for years — like @page, @import, @media, @font-face, @namespace and @keyframes — since those are more obvious. @container size queries (baseline support) Testing support for size queries is fairly trivial since the module introduces several telltale properties, notably container-type, container-name and container. Choose your favorite because they should all evaluate the same. And if that property is supported, then @container should be supported, too, since it was introduced at the same time. @supports (container-type: size) { /* Size queries are supported! */ } You can combine both of them by nesting a @supports query inside a @container and vice versa. @supports (container-type: size) { @container (width \u003e 800px) { /* Styles */ } } @container style queries (partial support) Size queries give us a lot of telltale properties to work with, but the same can’t be said about style queries. Since each element has a style containment by default, there isn’t a property or value specific to them. We can work around that by forgetting about @supports and writing the styles inside a style query instead. Style queries work in supporting browsers but otherwise are ignored, so we’re able to write some base styles for older browsers that will be overridden by modern ones. .container { --supports-style-queries: true; } .container .child { /* Base styles */ } @container style(--supports-style-queries: true) { /* Container queries are supported! */ .child { /* We can override the base styles here */ } } @counter-style (partial support) The @counter-style at-rule allows us to make custom counters for lists. The styles are defined inside a @counter-style with custom name. @counter-style triangle { system: cyclic; symbols: ‣; suffix: \" \"; } ul { list-style: triangle; } We don’t have a telltale property to help us solve this puzzle, but rather a telltale value. The list-style-type property used to accept a few predefined keyword values, but now supports additional values since @counter-style was introduced. That means we should be able to check if the browser supports \u003ccustom-ident\u003e values for list-style-type. @supports (list-style: custom-ident) { /* @counter-style is supported! */ } @font-feature-values (baseline support) Some fonts include alternate glyphs in the font file that can be customized using the @font-feature-values at-rule. These custom glyphs can be displayed using the font-variant-alternatesl, so that’s our telltale property for checking support on this one: @supports (font-variant-alternates: swash(custom-ident)) { /* @font-feature-values is supported! */ } @font-palette-values (baseline support) The same concept can be applied to the @font-palette-values at-rule, which allows us to modify multicolor fonts using the font-palette property that we can use as its telltale property. @supports (font-palette: normal) { /* @font-palette-values is supported! */ } @position-try (partial support) The @position-try at-rule is used to create custom anchor fallback positions in anchor positioning. It’s probably the one at-rule in this list that needs more support since it is such a new feature. Fortunately, there are many telltale properties in the same module that we can reach for. Be careful, though, because some properties have been renamed since they were initially introduced. I recommend testing support for @position-try using anchor-name or position-try as telltale properties. @supports (position-try: flip-block) { /* @position-try is supported! */ } @scope (partial support) The @scope at-rule seems tricky to test at first, but it turns out can apply the same strategy we did with style queries. Create a base style for browsers that don’t support @scope and then override those styles inside a @scope block that will only be valid in supporting browsers. A progressive enhancement strategy if there ever was one! .foo .element { /* Base style */ } @scope (.foo) to (.bar) { :scope .element { /* @scope is supported, override base style */ } } @view-transition (partial support) The last at-rule in this list is @view-transition. It’s another feature making quick strides into browser implementations, but it’s still a little ways out from being considered baseline support. The easiest way would be to use its related view-transition-name property since they released close together: @supports (view-transition-name: custom-ident) { /* @view-transition is supported! */ } But we may as well use the selector() function to check for one of its many pseudo-elements support: @supports selector(::view-transition-group(transition-name)) { /* @view-transition is supported! */ } A little resource I put this list into a demo that uses @supports to style different at-rules based on the test recipes we covered: The unsolved ones Even though I feel like I put a solid list together, there are three at-rules that I couldn’t figure out how to test: @layer, @property, and @starting-style. Thankfully, each one is pretty decently supported in modern browsers. But that doesn’t mean we shouldn’t test for support. My hunch is that we can text @layer support similar to the approaches for testing support for style() queries with @container where we set a base style and use progressive enhancement where there’s support. The other two? I have no idea. But please do let me know how you’re checking support for @property and @starting-style — or how you’re checking support for any other feature differently than what I have here. This is a tricky puzzle!",
  "image": "https://css-tricks.com/wp-json/social-image-generator/v1/image/381674",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cp\u003e\n\tDigitalOcean provides cloud products for every stage of your journey. Get started with \u003ca href=\"https://try.digitalocean.com/css-tricks/?utm_medium=content_acq\u0026amp;utm_source=css-tricks\u0026amp;utm_campaign=global_brand_ad_en\u0026amp;utm_content=conversion_prearticle_everystage\"\u003e$200 in free credit!\u003c/a\u003e\n\u003c/p\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eThe \u003ca href=\"https://css-tricks.com/almanac/rules/s/supports/\"\u003e\u003ccode\u003e@supports\u003c/code\u003e\u003c/a\u003e at-rule has been extended several times since its initial release. Once only capable of checking support for property/value pairs, it can now check for a selector using the \u003ccode\u003eselector()\u003c/code\u003e wrapper function and different font formats and techs using \u003ccode\u003efont-format()\u003c/code\u003e and \u003ccode\u003efont-tech()\u003c/code\u003e, respectively. However, one feature the community still longs for is testing other at-rules support.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports at-rule(@new-rule) {\n  /* @new-rule is supported */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003ca href=\"https://github.com/w3c/csswg-drafts/issues/2463#issuecomment-1016720310\" rel=\"noopener\"\u003eCSSWG decided in 2022\u003c/a\u003e to add the prior \u003ccode\u003eat-rule()\u003c/code\u003e wrapper function. While this is welcome and wonderful news, here we are two years later and we don’t have a lot of updates on when it will be added to browsers. So, how can we check for support in the meantime?\u003c/p\u003e\n\n\n\n\u003cp\u003eFunny coincidence: Just yesterday the \u003ca href=\"https://x.com/bramus/status/1842161852916154425\"\u003eChrome team changed the status from “new” to “assigned”\u003c/a\u003e as if they \u003cem\u003eknew\u003c/em\u003e I was thinking about it.\u003c/p\u003e\n\n\n\n\u003cp\u003eLooking for an answer, I found \u003ca href=\"https://www.bram.us/2022/01/20/detect-at-rule-support-with-the-at-rule-function/\" rel=\"noopener\"\u003ethis post by Bramus\u003c/a\u003e that offers a workaround: while we can’t check for a CSS at-rule in the \u003ccode\u003e@supports\u003c/code\u003e at-rule, we can test a property that was shipped with a particular at-rule as a substitute, the thinking being that if a related feature was released that we \u003cem\u003ecan\u003c/em\u003e test and it is supported, then the feature that we’re unable to test is likely to be supported as well… and vice versa. Bramus provides an example that checks support for the \u003ccode\u003eanimation-timeline\u003c/code\u003e property to check if the \u003ccode\u003e@scroll-timeline\u003c/code\u003e at-rule (which has been discontinued) is supported since the two were shipped together.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports (animation-timeline: works) {\n  /* @scroll-timeline is supported*/\n}\n\n/* Note: @scroll-timeline doesn\u0026#39;t exist anymore */\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBramus calls these “telltale” properties, which is a fun way to think about this because it resembles a puzzle of deduction, where we have to find a related property to check if its at-rule is supported.\u003c/p\u003e\n\n\n\n\u003cp\u003eI wanted to see how many of these puzzles I could solve, and in the process, know which at-rules we can reliably test today. So, I’ve identified a full list of \u003cem\u003esupportable\u003c/em\u003e at-rules that I could find.\u003c/p\u003e\n\n\n\n\u003cp\u003eI’ve excluded at-rules that offer no browser support, like \u003ccode\u003e@color-profile\u003c/code\u003e, \u003ccode\u003e@when\u003c/code\u003e, and \u003ccode\u003e@else\u003c/code\u003e, as well as deprecated at-rules, like \u003ccode\u003e@document\u003c/code\u003e. Similarly, I’m excluding older at-rules that have enjoyed wide browser support for years — like \u003ccode\u003e@page\u003c/code\u003e, \u003ccode\u003e@import\u003c/code\u003e, \u003ccode\u003e@media\u003c/code\u003e, \u003ccode\u003e@font-face\u003c/code\u003e, \u003ccode\u003e@namespace\u003c/code\u003e and \u003ccode\u003e@keyframes\u003c/code\u003e — since those are more obvious.\u003c/p\u003e\n\n\n\u003ch3 id=\"-container-size-queries-baseline-support-https-caniuse-com-css-container-queries-\"\u003e\u003ccode\u003e@container\u003c/code\u003e size queries (\u003ca href=\"https://caniuse.com/css-container-queries\" rel=\"noopener\"\u003ebaseline support\u003c/a\u003e)\u003c/h3\u003e\n\n\n\u003cp\u003eTesting support for size queries is fairly trivial since the module introduces several telltale properties, notably \u003ccode\u003econtainer-type\u003c/code\u003e, \u003ccode\u003econtainer-name\u003c/code\u003e and \u003ccode\u003econtainer\u003c/code\u003e. Choose your favorite because they should all evaluate the same. And if that property is supported, then \u003ccode\u003e@container\u003c/code\u003e should be supported, too, since it was introduced at the same time.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports (container-type: size) {\n  /* Size queries are supported! */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou can combine both of them by nesting a \u003ccode\u003e@supports\u003c/code\u003e query inside a \u003ccode\u003e@container\u003c/code\u003e and vice versa.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports (container-type: size) {\n  @container (width \u0026gt; 800px) {\n    /* Styles */\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"-container-style-queries-partial-support-https-caniuse-com-mdn-css_at-rules_container_style_queries_for_custom_properties-\"\u003e\u003ccode\u003e@container\u003c/code\u003e style queries (\u003ca href=\"https://caniuse.com/mdn-css_at-rules_container_style_queries_for_custom_properties\" rel=\"noopener\"\u003epartial support\u003c/a\u003e)\u003c/h3\u003e\n\n\n\u003cp\u003eSize queries give us a lot of telltale properties to work with, but the same can’t be said about style queries. Since each element has a style containment by default, there isn’t a property or value specific to them. We can work around that by forgetting about \u003ccode\u003e@supports\u003c/code\u003e and writing the styles inside a style query instead. Style queries work in supporting browsers but otherwise are ignored, so we’re able to write some base styles for older browsers that will be overridden by modern ones.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.container {\n  --supports-style-queries: true;\n}\n\n.container .child {\n  /* Base styles */\n}\n\n@container style(--supports-style-queries: true) {\n  /* Container queries are supported! */\n  .child {\n    /* We can override the base styles here */\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"-counter-style-partial-support-https-caniuse-com-css-at-counter-style-\"\u003e\u003ccode\u003e@counter-style\u003c/code\u003e (\u003ca href=\"https://caniuse.com/css-at-counter-style\" rel=\"noopener\"\u003epartial support\u003c/a\u003e)\u003c/h3\u003e\n\n\n\u003cp\u003eThe \u003ccode\u003e@counter-style\u003c/code\u003e at-rule allows us to \u003ca href=\"https://css-tricks.com/css-counters-custom-list-number-styling/\"\u003emake custom counters\u003c/a\u003e for lists. The styles are defined inside a \u003ccode\u003e@counter-style\u003c/code\u003e with custom name.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@counter-style triangle {\n  system: cyclic;\n  symbols: ‣;\n  suffix: \u0026#34; \u0026#34;;\n}\n\nul {\n  list-style: triangle;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe don’t have a telltale property to help us solve this puzzle, but rather a telltale \u003cem\u003evalue\u003c/em\u003e. The \u003ccode\u003elist-style-type\u003c/code\u003e property used to accept a few predefined keyword values, but now supports additional values since \u003ccode\u003e@counter-style\u003c/code\u003e was introduced. That means we should be able to check if the browser supports \u003ccode\u003e\u0026lt;custom-ident\u0026gt;\u003c/code\u003e values for \u003ccode\u003elist-style-type\u003c/code\u003e. \u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports (list-style: custom-ident) {\n  /* @counter-style is supported! */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"-font-feature-values-baseline-support-https-caniuse-com-mdn-css_at-rules_font-feature-values-\"\u003e\u003ccode\u003e@font-feature-values\u003c/code\u003e (\u003ca href=\"https://caniuse.com/mdn-css_at-rules_font-feature-values\" rel=\"noopener\"\u003ebaseline support\u003c/a\u003e)\u003c/h3\u003e\n\n\n\u003cp\u003eSome fonts include alternate glyphs in the font file that can be customized using the \u003ccode\u003e@font-feature-values\u003c/code\u003e at-rule. These custom glyphs can be displayed using the \u003ccode\u003efont-variant-alternates\u003c/code\u003el, so that’s our telltale property for checking support on this one:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports (font-variant-alternates: swash(custom-ident)) {\n  /* @font-feature-values is supported! */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"-font-palette-values-baseline-support-https-caniuse-com-mdn-css_at-rules_font-palette-values-\"\u003e\u003ccode\u003e@font-palette-values\u003c/code\u003e (\u003ca href=\"https://caniuse.com/mdn-css_at-rules_font-palette-values\" rel=\"noopener\"\u003ebaseline support\u003c/a\u003e)\u003c/h3\u003e\n\n\n\u003cp\u003eThe same concept can be applied to the \u003ccode\u003e@font-palette-values\u003c/code\u003e at-rule, which allows us to modify \u003ca href=\"https://css-tricks.com/colrv1-and-css-font-palette-web-typography/\"\u003emulticolor fonts\u003c/a\u003e using the \u003ccode\u003efont-palette\u003c/code\u003e property that we can use as its telltale property.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports (font-palette: normal) {\n  /* @font-palette-values is supported! */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"-position-try-partial-support-https-caniuse-com-mdn-css_at-rules_position-try-\"\u003e\u003ccode\u003e@position-try\u003c/code\u003e (\u003ca href=\"https://caniuse.com/mdn-css_at-rules_position-try\" rel=\"noopener\"\u003epartial support\u003c/a\u003e)\u003c/h3\u003e\n\n\n\u003cp\u003eThe \u003ccode\u003e@position-try\u003c/code\u003e at-rule is used to create custom anchor fallback positions in \u003ca href=\"https://css-tricks.com/css-anchor-positioning-guide/\"\u003eanchor positioning\u003c/a\u003e. It’s probably the one at-rule in this list that needs more support since it is such a new feature. Fortunately, there are many telltale properties in the same module that we can reach for. Be careful, though, because \u003ca href=\"https://css-tricks.com/anchor-positioning-quirks/\"\u003esome properties have been renamed\u003c/a\u003e since they were initially introduced. I recommend testing support for \u003ccode\u003e@position-try\u003c/code\u003e using \u003ccode\u003eanchor-name\u003c/code\u003e or \u003ccode\u003eposition-try\u003c/code\u003e as telltale properties.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports (position-try: flip-block) {\n  /* @position-try is supported! */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"-scope-partial-support-https-caniuse-com-css-cascade-scope-\"\u003e\u003ccode\u003e@scope\u003c/code\u003e (\u003ca href=\"https://caniuse.com/css-cascade-scope\" rel=\"noopener\"\u003epartial support\u003c/a\u003e)\u003c/h3\u003e\n\n\n\u003cp\u003eThe \u003ccode\u003e@scope\u003c/code\u003e at-rule seems tricky to test at first, but it turns out can apply the same strategy we did with style queries. Create a base style for browsers that don’t support \u003ccode\u003e@scope\u003c/code\u003e and then override those styles inside a \u003ccode\u003e@scope\u003c/code\u003e block that will only be valid in supporting browsers. A progressive enhancement strategy if there ever was one!\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.foo .element {\n  /* Base style */\n}\n\n@scope (.foo) to (.bar) {\n  :scope .element {\n    /* @scope is supported, override base style */\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"-view-transition-partial-support-https-caniuse-com-mdn-css_at-rules_view-transition-\"\u003e\u003ccode\u003e@view-transition\u003c/code\u003e (\u003ca href=\"https://caniuse.com/mdn-css_at-rules_view-transition\" rel=\"noopener\"\u003epartial support\u003c/a\u003e)\u003c/h3\u003e\n\n\n\u003cp\u003eThe last at-rule in this list is \u003ccode\u003e@view-transition\u003c/code\u003e. It’s another feature making quick strides into browser implementations, but it’s still a little ways out from being considered \u003ca href=\"https://web.dev/baseline/\" rel=\"noopener\"\u003ebaseline support\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe easiest way would be to use its related \u003ccode\u003eview-transition-name\u003c/code\u003e property since they released close together:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports (view-transition-name: custom-ident) {\n  /* @view-transition is supported! */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBut we may as well use the \u003ccode\u003eselector()\u003c/code\u003e function to check for one of its many pseudo-elements support:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports selector(::view-transition-group(transition-name)) {\n  /* @view-transition is supported! */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"demo\"\u003eA little resource\u003c/h3\u003e\n\n\n\u003cp\u003eI put this list into a demo that uses \u003ccode\u003e@supports\u003c/code\u003e to style different at-rules based on the test recipes we covered:\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"the-unsolved-ones\"\u003eThe unsolved ones\u003c/h3\u003e\n\n\n\u003cp\u003eEven though I feel like I put a solid list together, there are three at-rules that I couldn’t figure out how to test: \u003ccode\u003e\u003ca href=\"https://caniuse.com/mdn-css_at-rules_layer\" rel=\"noopener\"\u003e@layer\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca href=\"https://caniuse.com/mdn-css_at-rules_property\" rel=\"noopener\"\u003e@property\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca href=\"https://caniuse.com/mdn-css_at-rules_starting-style\" rel=\"noopener\"\u003e@starting-style\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThankfully, each one is pretty decently supported in modern browsers. But that doesn’t mean we \u003cem\u003eshouldn’t\u003c/em\u003e test for support. My hunch is that we can text \u003ccode\u003e@layer\u003c/code\u003e support similar to the approaches for testing support for \u003ccode\u003estyle()\u003c/code\u003e queries with \u003ccode\u003e@container\u003c/code\u003e where we set a base style and use progressive enhancement where there’s support.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe other two? I have no idea. But please do let me know how you’re checking support for \u003ccode\u003e@property\u003c/code\u003e and \u003ccode\u003e@starting-style\u003c/code\u003e — or how you’re checking support for any other feature differently than what I have here. This is a tricky puzzle!\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2024-10-07T13:46:07-06:00",
  "modifiedTime": "2024-10-07T13:46:09-06:00"
}
