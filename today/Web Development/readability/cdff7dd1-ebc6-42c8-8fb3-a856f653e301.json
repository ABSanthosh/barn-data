{
  "id": "cdff7dd1-ebc6-42c8-8fb3-a856f653e301",
  "title": "CSS Blob Recipes",
  "link": "https://css-tricks.com/css-blob-recipes/",
  "description": "Blob, Blob, Blob. What's the most effective way to create blob shapes in CSS? Turns out, as always, there are many. Let's compare them together! CSS Blob Recipes originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Juan Diego Rodríguez",
  "published": "Fri, 27 Jun 2025 13:48:41 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "art",
    "blobs",
    "css shapes"
  ],
  "byline": "Juan Diego Rodríguez",
  "length": 13576,
  "excerpt": "Blob, Blob, Blob. What's the most effective way to create blob shapes in CSS? Turns out, as always, there are many. Let's compare them together!",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "Blob, Blob, Blob. You hate them. You love them. Personally, as a design illiterate, I like to overuse them… a lot. And when you repeat the same process over and over again, it’s only a question of how much you can optimize it, or in this case, what’s the easiest way to create blobs in CSS? Turns out, as always, there are many approaches. To know if our following blobs are worth using, we’ll need them to pass three tests: They can be with just a single element (and preferably without pseudos). They can be easily designed (ideally through an online tool). We can use gradient backgrounds, borders, shadows, and other CSS effects on them. Without further ado, let’s Blob, Blob, Blob right in. Just generate them online I know it’s disenchanting to click on an article about making blobs in CSS just for me to say you can generate them outside CSS. Still, it’s probably the most common way to create blobs on the web, so to be thorough, these are some online tools I’ve used before to create SVG blobs. Haikei. Probably the one I have used the most since, besides blobs, it can also generate lots of SVG backgrounds. Blobmaker. A dedicated tool for making blobs. It’s apparently part of Haikei now, so you can use both. Lastly, almost all graphic programs let you hand-draw blobs and export them as SVGs. For example, this is one I generated just now. Keep it around, as it will come in handy later. \u003csvg viewBox=\"0 0 200 200\" xmlns=\"http://www.w3.org/2000/svg\"\u003e \u003cpath fill=\"#FA4D56\" d=\"M65.4,-37.9C79.2,-13.9,81,17,68.1,38C55.2,59.1,27.6,70.5,1.5,69.6C-24.6,68.8,-49.3,55.7,-56,38.2C-62.6,20.7,-51.3,-1.2,-39,-24.4C-26.7,-47.6,-13.3,-72,6.2,-75.6C25.8,-79.2,51.6,-62,65.4,-37.9Z\" transform=\"translate(100 100)\" /\u003e \u003c/svg\u003e Using border-radius While counterintuitive, we can use the border-radius property to create blobs. This technique isn’t new by any means; it was first described by Nils Binder in 2018, but it is still fairly unknown. Even for those who use it, the inner workings are not entirely clear. To start, you may know the border-radius is a shorthand to each individual corner’s radius, going from the top left corner clockwise. For example, we can set each corner’s border-radius to get a bubbly square shape: \u003cdiv class=\"blob\"\u003e\u003c/div\u003e .blob { border-radius: 25% 50% 75% 100%; } However, what border-radius does — and also why it’s called “radius” — is to shape each corner following a circle of the given radius. For example, if we set the top left corner to 25%, it will follow a circle with a radius 25% the size of the shape. .blob { border-top-left-radius: 25%; } What’s less known is that each corner property is still a shortcut towards its horizontal and vertical radii. Normally, you set both radii to the same value, getting a circle, but you can set them individually to create an ellipse. For example, the following sets the horizontal radius to 25% of the element’s width and the vertical to 50% of its height: .blob { border-top-left-radius: 25% 50%; } We can now shape each corner like an ellipse, and it is the combination of all four ellipses that creates the illusion of a blob! Just take into consideration that to use the horizontal and vertical radii syntax through the border-radius property, we’ll need to separate the horizontal from the vertical radii using a forward slash (/). .blob { border-radius: /* horizontal */ 100% 30% 60% 70% / /* vertical */ 50% 40% 70% 70%; } The syntax isn’t too intuitive, so designing a blob from scratch will likely be a headache. Luckily, Nils Binder made a tool exactly for that! Blobbing blobs together This hack is awesome. We aren’t supposed to use border-radius like that, but we still do. Admittedly, we are limited to boring blobs. Due to the nature of border-radius, no matter how hard we try, we will only get convex shapes. Just going off border-radius, we can try to minimize it a little by sticking more than one blob together: However, I don’t want to spend too much time on this technique since it is too impractical to be worth it. To name a few drawbacks: We are using more than one element or, at the very least, an extra pseudo-element. Ideally, we want to keep it to one element. We don’t have a tool to prototype our blobby amalgamations, so making one is a process of trial and error. We can’t use borders, gradients, or box shadows since they would reveal the element’s outlines. Multiple backgrounds and SVG filters This one is an improvement in the Gooey Effect, described here by Lucas Bebber, although I don’t know who first came up with it. In the original effect, several elements can be morphed together like drops of liquid sticking to and flowing out of each other: It works by first blurring shapes nearby, creating some connected shadows. Then we crank up the contrast, forcing the blur out and smoothly connecting them in the process. Take, for example, this demo by Chris Coyer (It’s from 2014, so more than 10 years ago!): If you look at the code, you’ll notice Chris uses the filter property along the blur() and contrast() functions, which I’ve also seen in other blob demos. To be specific, it applies blur() on each individual circle and then contrast() on the parent element. So, if we have the following HTML: \u003cdiv class=\"blob\"\u003e \u003cdiv class=\"subblob\"\u003e\u003c/div\u003e \u003cdiv class=\"subblob\"\u003e\u003c/div\u003e \u003cdiv class=\"subblob\"\u003e\u003c/div\u003e \u003c/div\u003e …we would need to apply filters and background colors as such: .blob { filter: contrast(50); background: white; /* Solid colors are necessary */ } .subblob { filter: blur(15px); background: black; /* Solid colors are necessary */ } However, there is a good reason why those demos stick to white shapes and black backgrounds (or vice versa) since things get unpredictable once colors aren’t contrast-y enough. See it for yourself in the following demo by changing the color. Just be wary: shades get ugly. To solve this, we will use an SVG filter instead. I don’t want to get too technical on SVG (if you want to, read Luca’s post!). In a nutshell, we can apply blurring and contrast filters using SVGs, but now, we can also pick which color channel we apply the contrast to, unlike normal contrast(), which modifies all colors. Since we want to leave color channels (R, G and B) untouched, we will only crank the contrast up for the alpha channel. That translates to the next SVG filter, which can be embedded in the HTML: \u003csvg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" style=\"position: absolute;\"\u003e \u003cdefs\u003e \u003cfilter id=\"blob\"\u003e \u003cfeGaussianBlur in=\"SourceGraphic\" stdDeviation=\"12\" result=\"blur\" /\u003e \u003cfeColorMatrix in=\"blur\" mode=\"matrix\" values=\"1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 18 -6\" result=\"goo\" /\u003e \u003cfeBlend in=\"SourceGraphic\" in2=\"blob\" /\u003e \u003c/filter\u003e \u003c/defs\u003e \u003c/svg\u003e To apply it, we will use again filter, but this time we’ll set it to url(\"#blob\"), so that it pulls the SVG from the HTML. .blob { filter: url(\"#blob\"); } And now we can even use it with gradient backgrounds! That being said, this approach comes with two small, but important, changes to common CSS filters: The filter is applied to the parent element, not the individual shapes. The parent element must be transparent (which is a huge advantage). To change the background color, we can instead change the body or other ancestors’ background, and it will work with no issues. What’s left is to place the .subblob elements together such that they make a blobby enough shape, then apply the SVG filters to morph them: Making it one element This works well, but it has a similar issue to the blob we made by morphing several border-radius instances: too many elements for a simple blob. Luckily, we can take advantage of the background property to create multiple shapes and morph them together using SVG filters, all in a single element. Since we are keeping it to one element, we will go back to just one empty .blob div: \u003cdiv class=\"blob\"\u003e\u003c/div\u003e To recap, the background shorthand can set all background properties and also set multiple backgrounds at once. Of all the properties, we only care about the background-image, background-position and background-size. First, we will use background-image along with radial-gradient() to create a circle inside the element: body { background: radial-gradient(farthest-side, var(--blob-color) 100%, #0000); background-repeat: no-repeat; /* Important! */ } Here is what each parameter does: farthest-side: Confines the shape to the element’s box farthest from its center. This way, it is kept as a circle. var(--blob-color) 100%: Fills the background shape from 0 to 100% with the same color, so it ends up as a solid color. #0000: After the shape is done, it makes a full stop to transparency, so the color ends. The next part is moving and resizing the circle using the background-position and background-size properties. Luckily, both can be set on background after the gradient, separated from each other by a forward slash (/). body { background: radial-gradient(...) 20% 30% / 30% 40%; background-repeat: no-repeat; /* Important! */ } The first pair of percentages sets the shape’s horizontal and vertical position (taking as a reference the top-left corner), while the second pair sets the shape’s width and height (taking as a reference the element’s size). As I mentioned, we can stack up different backgrounds together, which means we can create as many circles/ellipses as we want! For example, we can create three ellipses on the same element: .blob { background: radial-gradient(farthest-side, var(--blob-color) 100%, #0000) 20% 30% / 30% 40%, radial-gradient(farthest-side, var(--blob-color) 100%, #0000) 80% 50% / 40% 60%, radial-gradient(farthest-side, var(--blob-color) 100%, #0000) 50% 70% / 50% 50%; background-repeat: no-repeat; } What’s even better is that SVG filters don’t care whether shapes are made of elements or backgrounds, so we can also morph them together using the last url(#blob) filter! While this method may be a little too much for blobs, it unlocks squishing, stretching, dividing, and merging blobs in seamless animations. Again, all these tricks are awesome, but not enough for what we want! We accomplished reducing the blob to a single element, but we still can’t use gradients, borders, or shadows on them, and also, they are tedious to design and model. Then, that brings us to the ultimate blob approach… Using the shape() function Fortunately, there is a new way to make blobs that just dropped to CSS: the shape() function! I’ll explain shape()‘s syntax briefly, but for an in-depth explanation, you’ll want to check out both this explainer from the CSS-Tricks Almanac as well as Temani Afif‘s three-part series on the shape() function, as well as his recent article about blobs. First off, the CSS shape() function is used alongside the clip-path property to cut elements into any shape we want. More specifically, it uses a verbal version of SVG’s path syntax. The syntax has lots of commands for lots of types of lines, but when blobbing with shape(), we’ll define curves using the curve command: .blob { clip-path: shape( from X0 Y0, curve to X1 Y1 with Xc1 Yc1, curve to X2 Y2 with Xc21 Yc21 / Xc22 Yc22 /* ... */ ); } Let’s break down each parameter: X0 Y0 defines the starting point of the shape. curve starts the curve where X1 Y1 is the next point of the shape, while Xc1 Yc1 defines a control point used in Bézier curves. The next parameter is similar, but we used Xc21 Yc21 / Xc22 Yc22 instead to define two control points on the Bézier curve. I honestly don’t understand Bézier curves and control points completely, but luckily, we don’t need them to use shape() and blobs! Again, shape() uses a verbal version of SVG’s path syntax, so it can draw any shape an SVG can, which means that we can translate the SVG blobs we generated earlier… and CSS-ify them. To do so, we’ll grab the d attribute (which defines the path) from our SVG and paste it into Temani’s SVG to shape() generator. This is the exact code the tool generated for me: .blob { aspect-ratio: 0.925; /* Generated too! */ clip-path: shape( from 91.52% 26.2%, curve to 93.52% 78.28% with 101.76% 42.67%/103.09% 63.87%, curve to 44.11% 99.97% with 83.95% 92.76%/63.47% 100.58%, curve to 1.45% 78.42% with 24.74% 99.42%/6.42% 90.43%, curve to 14.06% 35.46% with -3.45% 66.41%/4.93% 51.38%, curve to 47.59% 0.33% with 23.18% 19.54%/33.13% 2.8%, curve to 91.52% 26.2% with 62.14% -2.14%/81.28% 9.66% ); } As you might have guessed, it returns our beautiful blob: Let’s check if it passes our requirements: Yes, they can be made of a single element. Yes, they can also be created in a generator and then translated into CSS. Yes, we can use gradient backgrounds, but due to the nature of clip-path(), borders and shadows get cut out. Two out of three? Maybe two and a half of three? That’s a big improvement over the other approaches, even if it’s not perfect. Conclusion So, alas, we failed to find what I believe is the perfect CSS approach to blobs. I am, however, amazed how something so trivial designing blobs can teach us about so many tricks and new CSS features, many of which I didn’t know myself.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/06/blobs-cover.webp",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003e\u003cem\u003eBlob, Blob, Blob\u003c/em\u003e. You hate them. You love them. Personally, as a design illiterate, I like to overuse them… a lot. And when you repeat the same process over and over again, it’s only a question of how much you can optimize it, or in this case, what’s the easiest way to create blobs in CSS? Turns out, as always, there are many approaches.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo know if our following blobs are worth using, we’ll need them to pass three tests:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eThey can be with just a single element (and preferably without pseudos).\u003c/li\u003e\n\n\n\n\u003cli\u003eThey can be easily designed (ideally through an online tool).\u003c/li\u003e\n\n\n\n\u003cli\u003eWe can use gradient backgrounds, borders, shadows, and other CSS effects on them.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eWithout further ado, let’s \u003cem\u003eBlob, Blob, Blob\u003c/em\u003e right in.\u003c/p\u003e\n\n\n\u003ch3 id=\"just-generate-them-online\"\u003eJust generate them online\u003c/h3\u003e\n\n\n\u003cp\u003eI know it’s disenchanting to click on an article about making blobs in CSS just for me to say you can generate them outside CSS. Still, it’s probably the most common way to create blobs on the web, so to be thorough, these are some online tools I’ve used before to create \u003cstrong\u003eSVG\u003c/strong\u003e blobs.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://app.haikei.app/\" rel=\"noopener\"\u003eHaikei\u003c/a\u003e.\u003c/strong\u003e Probably the one I have used the most since, besides blobs, it can also generate lots of SVG backgrounds.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://www.blobmaker.app/\" rel=\"noopener\"\u003eBlobmaker\u003c/a\u003e.\u003c/strong\u003e A dedicated tool for making blobs. It’s apparently part of Haikei now, so you can use both.\u003c/li\u003e\n\n\n\n\u003cli\u003eLastly, almost all graphic programs let you hand-draw blobs and export them as SVGs.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eFor example, this is one I generated just now. Keep it around, as it will come in handy later.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"829\" height=\"766\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/06/image-3.png?resize=829%2C766\u0026amp;ssl=1\" alt=\"Randomly shaped blob in bright red.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/06/image-3.png?w=829\u0026amp;ssl=1 829w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/06/image-3.png?resize=300%2C277\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/06/image-3.png?resize=768%2C710\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;svg viewBox=\u0026#34;0 0 200 200\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt;\n  \u0026lt;path\n    fill=\u0026#34;#FA4D56\u0026#34;\n    d=\u0026#34;M65.4,-37.9C79.2,-13.9,81,17,68.1,38C55.2,59.1,27.6,70.5,1.5,69.6C-24.6,68.8,-49.3,55.7,-56,38.2C-62.6,20.7,-51.3,-1.2,-39,-24.4C-26.7,-47.6,-13.3,-72,6.2,-75.6C25.8,-79.2,51.6,-62,65.4,-37.9Z\u0026#34;\n    transform=\u0026#34;translate(100 100)\u0026#34;\n  /\u0026gt;\n\u0026lt;/svg\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"using-border-radius-\"\u003eUsing \u003ccode\u003eborder-radius\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003eWhile counterintuitive, we can use the \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/properties/b/border-radius/\"\u003eborder-radius\u003c/a\u003e\u003c/code\u003e property to create blobs. This technique isn’t new by any means; it was \u003ca href=\"https://9elements.com/blog/css-border-radius-can-do-that/\" rel=\"noopener\"\u003efirst described by Nils Binder\u003c/a\u003e in 2018, but it is still fairly unknown. Even for those who use it, the inner workings are not entirely clear.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo start, you may know the \u003ccode\u003eborder-radius\u003c/code\u003e is a shorthand to each individual corner’s radius, going from the top left corner clockwise. For example, we can set each corner’s \u003ccode\u003eborder-radius\u003c/code\u003e to get a bubbly square shape:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div class=\u0026#34;blob\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.blob {\n  border-radius: 25% 50% 75% 100%;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eHowever, what \u003ccode\u003eborder-radius\u003c/code\u003e does — and also why it’s called “radius” — is to shape each corner following a circle of the given radius. For example, if we set the top left corner to \u003ccode\u003e25%\u003c/code\u003e, it will follow a circle with a radius \u003ccode\u003e25%\u003c/code\u003e the size of the shape.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.blob {\n  border-top-left-radius: 25%;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWhat’s less known is that each corner property is still a \u003cem\u003eshortcut\u003c/em\u003e towards its horizontal and vertical radii. Normally, you set both radii to the same value, getting a circle, but you can set them individually to create an ellipse. For example, the following sets the horizontal radius to \u003ccode\u003e25%\u003c/code\u003e of the element’s width and the vertical to \u003ccode\u003e50%\u003c/code\u003e of its height:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.blob {\n  border-top-left-radius: 25% 50%;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWe can now shape each corner like an ellipse, and it is the combination of all four ellipses that creates the illusion of a blob! Just take into consideration that to use the horizontal and vertical radii syntax through the \u003ccode\u003eborder-radius\u003c/code\u003e property, we’ll need to separate the horizontal from the vertical radii using a forward slash (\u003ccode\u003e/\u003c/code\u003e).\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.blob {\n  border-radius:\n    /* horizontal */\n    100% 30% 60% 70% /\n    /* vertical */\n    50% 40% 70% 70%;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThe syntax isn’t too intuitive, so designing a blob from scratch will likely be a headache. Luckily, \u003ca href=\"https://9elements.github.io/fancy-border-radius/\" rel=\"noopener\"\u003eNils Binder made a tool\u003c/a\u003e exactly for that!\u003c/p\u003e\n\n\n\u003ch4 id=\"blobbing-blobs-together\"\u003eBlobbing blobs together\u003c/h4\u003e\n\n\n\u003cp\u003eThis hack is awesome. We aren’t supposed to use \u003ccode\u003eborder-radius\u003c/code\u003e like that, but we still do. Admittedly, we are limited to boring blobs. Due to the nature of \u003ccode\u003eborder-radius\u003c/code\u003e, no matter how hard we try, we will only get convex shapes.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1024\" height=\"576\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/06/convex_concave_i8a0vu.webp?resize=1024%2C576\" alt=\"Concave and convex shapes\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/06/convex_concave_i8a0vu.webp?resize=1024%2C576\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/06/convex_concave_i8a0vu.webp?resize=300%2C169\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/06/convex_concave_i8a0vu.webp?resize=768%2C432\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/06/convex_concave_i8a0vu.webp?resize=1536%2C864\u0026amp;ssl=1 1536w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/06/convex_concave_i8a0vu.webp?w=1920\u0026amp;ssl=1 1920w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eJust going off \u003ccode\u003eborder-radius\u003c/code\u003e, we can try to minimize it a little by sticking more than one blob together:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eHowever, I don’t want to spend too much time on this technique since it is too impractical to be worth it. To name a few drawbacks:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eWe are using more than one element or, at the very least, an extra pseudo-element. Ideally, we want to keep it to one element.\u003c/li\u003e\n\n\n\n\u003cli\u003eWe don’t have a tool to prototype our blobby amalgamations, so making one is a process of trial and error.\u003c/li\u003e\n\n\n\n\u003cli\u003eWe can’t use borders, gradients, or box shadows since they would reveal the element’s outlines.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\u003ch3 id=\"multiple-backgrounds-and-svg-filters\"\u003eMultiple backgrounds and SVG filters\u003c/h3\u003e\n\n\n\u003cp\u003eThis one is an improvement in the Gooey Effect, \u003ca href=\"https://css-tricks.com/gooey-effect/\"\u003edescribed here by Lucas Bebber\u003c/a\u003e, although I don’t know who first came up with it. In the original effect, several elements can be morphed together like drops of liquid sticking to and flowing out of each other:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eIt works by first blurring shapes nearby, creating some connected shadows. Then we crank up the contrast, forcing the blur out and smoothly connecting them in the process. Take, for example, this demo by Chris Coyer (It’s from 2014, so more than 10 years ago!):\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eIf you look at the code, you’ll notice Chris uses the \u003ca href=\"https://css-tricks.com/almanac/properties/f/filter/\"\u003e\u003ccode\u003efilter\u003c/code\u003e\u003c/a\u003e property along the \u003ccode\u003eblur()\u003c/code\u003e and \u003ccode\u003econtrast()\u003c/code\u003e functions, which I’ve also seen in other blob demos. To be specific, it applies \u003ccode\u003eblur()\u003c/code\u003e on each individual circle and then \u003ccode\u003econtrast()\u003c/code\u003e on the parent element. So, if we have the following HTML:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div class=\u0026#34;blob\u0026#34;\u0026gt;\n  \u0026lt;div class=\u0026#34;subblob\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;subblob\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;subblob\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e…we would need to apply filters and background colors as such:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.blob {\n  filter: contrast(50);\n  background: white; /* Solid colors are necessary */\n}\n\n.subblob {\n  filter: blur(15px);\n  background: black; /* Solid colors are necessary */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eHowever, there is a good reason why those demos stick to white shapes and black backgrounds (or vice versa) since things get unpredictable once colors aren’t contrast-y enough. See it for yourself in the following demo by changing the color. Just be wary: \u003cem\u003eshades get ugly\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eTo solve this, we will use an SVG filter instead. I don’t want to get too technical on SVG (if you want to, read Luca’s post!). In a nutshell, we can apply blurring and contrast filters using SVGs, but now, we can also pick which color channel we apply the contrast to, unlike normal \u003ccode\u003econtrast()\u003c/code\u003e, which modifies all colors. \u003c/p\u003e\n\n\n\n\u003cp\u003eSince we want to leave color channels (\u003ccode\u003eR\u003c/code\u003e, \u003ccode\u003eG\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e) untouched, we will only crank the contrast up for the alpha channel. That translates to the next SVG filter, which can be embedded in the HTML:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; version=\u0026#34;1.1\u0026#34; style=\u0026#34;position: absolute;\u0026#34;\u0026gt;\n  \u0026lt;defs\u0026gt;\n    \u0026lt;filter id=\u0026#34;blob\u0026#34;\u0026gt;\n      \u0026lt;feGaussianBlur in=\u0026#34;SourceGraphic\u0026#34; stdDeviation=\u0026#34;12\u0026#34; result=\u0026#34;blur\u0026#34; /\u0026gt;\n      \u0026lt;feColorMatrix in=\u0026#34;blur\u0026#34; mode=\u0026#34;matrix\u0026#34; values=\u0026#34;1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -6\u0026#34; result=\u0026#34;goo\u0026#34; /\u0026gt;\n      \u0026lt;feBlend in=\u0026#34;SourceGraphic\u0026#34; in2=\u0026#34;blob\u0026#34; /\u0026gt;\n    \u0026lt;/filter\u0026gt;\n  \u0026lt;/defs\u0026gt;\n\u0026lt;/svg\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTo apply it, we will use again \u003ccode\u003efilter\u003c/code\u003e, but this time we’ll set it to \u003ccode\u003eurl(\u0026#34;#blob\u0026#34;)\u003c/code\u003e, so that it pulls the SVG from the HTML.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.blob {\n  filter: url(\u0026#34;#blob\u0026#34;);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd now we can even use it with gradient backgrounds!\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThat being said, this approach comes with two small, but important, changes to common CSS filters:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eThe filter is applied to the parent element, not the individual shapes.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe parent element must be transparent (which is a huge advantage). To change the background color, we can instead change the body or other ancestors’ background, and it will work with no issues.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eWhat’s left is to place the \u003ccode\u003e.subblob\u003c/code\u003e elements together such that they make a blobby enough shape, then apply the SVG filters to morph them:\u003c/p\u003e\n\n\n\n\n\n\n\u003ch4 id=\"making-it-one-element\"\u003eMaking it one element\u003c/h4\u003e\n\n\n\u003cp\u003eThis works well, but it has a similar issue to the blob we made by morphing several \u003ccode\u003eborder-radius\u003c/code\u003e instances: too many elements for a simple blob. Luckily, we can take advantage of the \u003ca href=\"https://css-tricks.com/almanac/properties/b/background/\"\u003e\u003ccode\u003ebackground\u003c/code\u003e\u003c/a\u003e property to create multiple shapes and morph them together using SVG filters, all in a single element. Since we are keeping it to one element, we will go back to just one empty \u003ccode\u003e.blob\u003c/code\u003e div:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div class=\u0026#34;blob\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTo recap, the \u003ccode\u003ebackground\u003c/code\u003e shorthand can set all background properties and also set multiple backgrounds at once. Of all the properties, we only care about the \u003ca href=\"https://css-tricks.com/almanac/properties/b/background-image/\"\u003e\u003ccode\u003ebackground-image\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://css-tricks.com/almanac/properties/b/background-position/\"\u003e\u003ccode\u003ebackground-position\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://css-tricks.com/almanac/properties/b/background-size/\"\u003e\u003ccode\u003ebackground-size\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eFirst, we will use \u003ccode\u003ebackground-image\u003c/code\u003e along with \u003ccode\u003eradial-gradient()\u003c/code\u003e to create a circle inside the element:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebody {\n  background: radial-gradient(farthest-side, var(--blob-color) 100%, #0000);\n  background-repeat: no-repeat; /* Important! */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eHere is what each parameter does:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003efarthest-side\u003c/code\u003e:\u003c/strong\u003e Confines the shape to the element’s box farthest from its center. This way, it is kept as a circle.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003evar(--blob-color) 100%\u003c/code\u003e:\u003c/strong\u003e Fills the background shape from 0 to 100% with the same color, so it ends up as a solid color.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e#0000\u003c/code\u003e:\u003c/strong\u003e After the shape is done, it makes a full stop to transparency, so the color ends.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe next part is moving and resizing the circle using the \u003ccode\u003ebackground-position\u003c/code\u003e and \u003ccode\u003ebackground-size\u003c/code\u003e properties. Luckily, both can be set on \u003ccode\u003ebackground\u003c/code\u003e after the gradient, separated from each other by a forward slash (\u003ccode\u003e/\u003c/code\u003e).\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebody {\n  background: radial-gradient(...) 20% 30% / 30% 40%;\n  background-repeat: no-repeat; /* Important! */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThe first pair of percentages sets the shape’s horizontal and vertical position (taking as a reference the top-left corner), while the second pair sets the shape’s width and height (taking as a reference the element’s size).\u003c/p\u003e\n\n\n\n\u003cp\u003eAs I mentioned, we can stack up different backgrounds together, which means we can create as many circles/ellipses as we want! For example, we can create three ellipses on the same element:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.blob {\n  background:\n    radial-gradient(farthest-side, var(--blob-color) 100%, #0000) 20% 30% / 30% 40%, \n    radial-gradient(farthest-side, var(--blob-color) 100%, #0000) 80% 50% / 40% 60%, \n    radial-gradient(farthest-side, var(--blob-color) 100%, #0000) 50% 70% / 50% 50%;\n  background-repeat: no-repeat;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhat’s even better is that SVG filters don’t care whether shapes are made of elements or backgrounds, so we can also morph them together using the last \u003ccode\u003eurl(#blob)\u003c/code\u003e filter!\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWhile this method may be a little too much for blobs, it unlocks squishing, stretching, dividing, and merging blobs \u003ca href=\"https://css-tricks.com/gooey-effect/#aa-making-things-stick\"\u003ein seamless animations\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eAgain, all these tricks are awesome, but not enough for what we want! We accomplished reducing the blob to a single element, but we still can’t use gradients, borders, or shadows on them, and also, they are tedious to design and model. Then, that brings us to the ultimate blob approach…\u003c/p\u003e\n\n\n\u003ch3 id=\"using-the-new-shape-function\"\u003eUsing the \u003ccode\u003eshape()\u003c/code\u003e function\u003c/h3\u003e\n\n\n\u003cp\u003eFortunately, there is a new way to make blobs that just dropped to CSS: the \u003ccode\u003eshape()\u003c/code\u003e function!\u003c/p\u003e\n\n\n\n\u003cp\u003eI’ll explain \u003ccode\u003eshape()\u003c/code\u003e‘s syntax briefly, but for an in-depth explanation, you’ll want to check out both \u003ca href=\"https://css-tricks.com/almanac/functions/s/shape/\"\u003ethis explainer from the CSS-Tricks Almanac \u003c/a\u003eas well as \u003ca href=\"https://css-tricks.com/author/afiftemani/\"\u003eTemani Afif\u003c/a\u003e‘s three-part \u003ca href=\"https://css-tricks.com/better-css-shapes-using-shape-part-1-lines-and-arcs/\"\u003eseries on the \u003ccode\u003eshape()\u003c/code\u003e function\u003c/a\u003e, as well as \u003ca href=\"https://frontendmasters.com/blog/creating-blob-shapes-using-clip-path-shape/\" rel=\"noopener\"\u003ehis recent article about blobs\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eFirst off, the CSS \u003ccode\u003eshape()\u003c/code\u003e function is used alongside the \u003ca href=\"https://css-tricks.com/almanac/properties/c/clip-path/\"\u003e\u003ccode\u003eclip-path\u003c/code\u003e\u003c/a\u003e property to cut elements into any shape we want. More specifically, it uses a verbal version of SVG’s \u003ccode\u003epath\u003c/code\u003e syntax. The syntax has lots of commands for lots of types of lines, but when blobbing with \u003ccode\u003eshape()\u003c/code\u003e, we’ll define curves using the \u003ccode\u003ecurve\u003c/code\u003e command:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.blob {\n  clip-path: shape(\n    from X0 Y0, \n    curve to X1 Y1 with Xc1 Yc1, \n    curve to X2 Y2 with Xc21 Yc21 / Xc22 Yc22\n    /* ... */\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s break down each parameter:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eX0 Y0\u003c/code\u003e defines the starting point of the shape.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003ecurve\u003c/code\u003e starts the curve where \u003ccode\u003eX1 Y1\u003c/code\u003e is the next point of the shape, while \u003ccode\u003eXc1 Yc1\u003c/code\u003e defines a control point used in Bézier curves.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe next parameter is similar, but we used \u003ccode\u003eXc21 Yc21 / Xc22 Yc22\u003c/code\u003e instead to define two control points on the Bézier curve.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eI honestly don’t understand Bézier curves and control points completely, but luckily, we don’t need them to use \u003ccode\u003eshape()\u003c/code\u003e and blobs! Again, \u003ccode\u003eshape()\u003c/code\u003e uses a verbal version of SVG’s \u003ccode\u003epath\u003c/code\u003e syntax, so it can draw any shape an SVG can, which means that we can translate the SVG blobs we generated earlier… and CSS-ify them. To do so, we’ll grab the \u003ccode\u003ed\u003c/code\u003e attribute (which defines the \u003ccode\u003epath\u003c/code\u003e) from our SVG and paste it into Temani’s \u003ca href=\"https://css-generators.com/svg-to-css/\" rel=\"noopener\"\u003eSVG to \u003ccode\u003eshape()\u003c/code\u003e generator\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is the exact code the tool generated for me:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.blob {\n  aspect-ratio: 0.925; /* Generated too! */\n\n  clip-path: shape(\n    from 91.52% 26.2%,\n    curve to 93.52% 78.28% with 101.76% 42.67%/103.09% 63.87%,\n    curve to 44.11% 99.97% with 83.95% 92.76%/63.47% 100.58%,\n    curve to 1.45% 78.42% with 24.74% 99.42%/6.42% 90.43%,\n    curve to 14.06% 35.46% with -3.45% 66.41%/4.93% 51.38%,\n    curve to 47.59% 0.33% with 23.18% 19.54%/33.13% 2.8%,\n    curve to 91.52% 26.2% with 62.14% -2.14%/81.28% 9.66%\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAs you might have guessed, it returns our beautiful blob:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eLet’s check if it passes our requirements:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eYes, they can be made of a single element.\u003c/li\u003e\n\n\n\n\u003cli\u003eYes, they can also be created in a generator and then translated into CSS.\u003c/li\u003e\n\n\n\n\u003cli\u003eYes, we can use gradient backgrounds, but due to the nature of \u003ccode\u003eclip-path()\u003c/code\u003e, borders and shadows get cut out.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eTwo out of three? Maybe two and a half of three? That’s a big improvement over the other approaches, even if it’s not perfect.\u003c/p\u003e\n\n\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\n\n\u003cp\u003eSo, alas, we failed to find what I believe is the perfect CSS approach to blobs. I am, however, amazed how something so trivial designing blobs can teach us about so many tricks and new CSS features, many of which I didn’t know myself.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-06-27T07:48:41-06:00",
  "modifiedTime": "2025-06-27T07:48:43-06:00"
}
