{
  "id": "22c2aeaf-ba85-4edb-92ac-62adcd2353aa",
  "title": "A CSS-Only Star Rating Component and More! (Part 2)",
  "link": "https://css-tricks.com/a-css-only-star-rating-component-and-more-part-2/",
  "description": "In this second article of a two-part series, Temani Afif demonstrates an alternative approach to creating the star rating component from the first article using experimental scroll-driven animations rather than using the border-image property. A CSS-Only Star Rating Component and More! (Part 2) originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Temani Afif",
  "published": "Fri, 07 Mar 2025 13:14:12 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "forms",
    "Scroll Driven Animation"
  ],
  "byline": "Temani Afif",
  "length": 13310,
  "excerpt": "In this second article of a two-part series, Temani Afif demonstrates an alternative approach to creating the star rating component from the first article using experimental scroll-driven animations rather than using the border-image property.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "In the last article, we created a CSS-only star rating component using the CSS mask and border-image properties, as well as the newly enhanced attr() function. We ended with CSS code that we can easily adjust to create component variations, including a heart rating and volume control. This second article will study a different approach that gives us more flexibility. Instead of the border-image trick we used in the first article, we will rely on scroll-driven animations! Here is the same star rating component with the new implementation. And since we’re treading in experimental territory, you’ll want to view this in Chrome 115+ while we wait for Safari and Firefox support: Do you spot the difference between this and the final demo in the first article? This time, I am updating the color of the stars based on how many of them are selected — something we cannot do using the border-image trick! I highly recommend you read the first article before jumping into this second part if you missed it, as I will be referring to concepts and techniques that we explored over there. One more time: At the time of writing, only Chrome 115+ and Edge 115+ fully support the features we will be using in this article, so please use either one of those as you follow along. Why scroll-driven animations? You might be wondering why we’re talking about scroll-driven animation when there’s nothing to scroll to in the star rating component. Scrolling? Animation? It’s even more confusing when you read the MDN explainer for scroll-driven animations: It allows you to animate property values based on a progression along a scroll-based timeline instead of the default time-based document timeline. This means that you can animate an element by scrolling a scrollable element, rather than just by the passing of time. But if you keep reading you will see that we have two types of scroll-based timelines: scroll progress timelines and view progress timelines. In our case, we are going to use the second one; a view progress timeline, and here is how MDN describes it: You progress this timeline based on the change in visibility of an element (known as the subject) inside a scroller. The visibility of the subject inside the scroller is tracked as a percentage of progress — by default, the timeline is at 0% when the subject is first visible at one edge of the scroller, and 100% when it reaches the opposite edge. You can check out the CSS-Tricks almanac definition for view-timeline-name while you’re at it for another explanation. Things start to make more sense if we consider the thumb element as the subject and the input element as the scroller. After all, the thumb moves within the input area, so its visibility changes. We can track that movement as a percentage of progress and convert it to a value we can use to style the input element. We are essentially going to implement the equivalent of document.querySelector(\"input\").value in JavaScript but with vanilla CSS! The implementation Now that we have an idea of how this works, let’s see how everything translates into code. @property --val { syntax: \"\u003cnumber\u003e\"; inherits: true; initial-value: 0; } input[type=\"range\"] { --min: attr(min type(\u003cnumber\u003e)); --max: attr(max type(\u003cnumber\u003e)); timeline-scope: --val; animation: --val linear both; animation-timeline: --val; animation-range: entry 100% exit 0%; overflow: hidden; } @keyframes --val { 0% { --val: var(--max) } 100% { --val: var(--min) } } input[type=\"range\"]::thumb { view-timeline: --val inline; } I know, this is a lot of strange syntax! But we will dissect each line and you will see that it’s not all that complex at the end of the day. The subject and the scroller We start by defining the subject, i.e. the thumb element, and for this we use the view-timeline shorthand property. From the MDN page, we can read: The view-timeline CSS shorthand property is used to define a named view progress timeline, which is progressed through based on the change in visibility of an element (known as the subject) inside a scrollable element (scroller). view-timeline is set on the subject. I think it’s self-explanatory. The view timeline name is --val and the axis is inline since we’re working along the horizontal x-axis. Next, we define the scroller, i.e. the input element, and for this, we use overflow: hidden (or overflow: auto). This part is the easiest but also the one you will forget the most so let me insist on this: don’t forget to define overflow on the scroller! I insist on this because your code will work fine without defining overflow, but the values won’t be good. The reason is that the scroller exists but will be defined by the browser (depending on your page structure and your CSS) and most of the time it’s not the one you want. So let me repeat it another time: remember the overflow property! The animation Next up, we create an animation that animates the --val variable between the input’s min and max values. Like we did in the first article, we are using the newly-enhanced attr() function to get those values. See that? The “animation” part of the scroll-driven animation, an animation we link to the view timeline we defined on the subject using animation-timeline. And to be able to animate a variable we register it using @property. Note the use of timeline-scope which is another tricky feature that’s easy to overlook. By default, named view timelines are scoped to the element where they are defined and its descendant. In our case, the input is a parent element of the thumb so it cannot access the named view timeline. To overcome this, we increase the scope using timeline-scope. Again, from MDN: timeline-scope is given the name of a timeline defined on a descendant element; this causes the scope of the timeline to be increased to the element that timeline-scope is set on and any of its descendants. In other words, that element and any of its descendant elements can now be controlled using that timeline. Never forget about this! Sometimes everything is correctly defined but nothing is working because you forget about the scope. There’s something else you might be wondering: Why are the keyframes values inverted? Why is the min is set to 100% and the max set to 0%? To understand this, let’s first take the following example where you can scroll the container horizontally to reveal a red circle inside of it. Initially, the red circle is hidden on the right side. Once we start scrolling, it appears from the right side, then disappears to the left as you continue scrolling towards the right. We scroll from left to right but our actual movement is from right to left. In our case, we don’t have any scrolling since our subject (the thumb) will not overflow the scroller (the input) but the main logic is the same. The starting point is the right side and the ending point is the left side. In other words, the animation starts when the thumb is on the right side (the input’s max value) and will end when it’s on the left side (the input’s min value). The animation range The last piece of the puzzle is the following important line of code: animation-range: entry 100% exit 0%; By default, the animation starts when the subject starts to enter the scroller from the right and ends when the subject has completely exited the scroller from the left. This is not good because, as we said, the thumb will not overflow the scroller, so it will never reach the start and the end of the animation. To rectify this we use the animation-range property to make the start of the animation when the subject has completely entered the scroller from the right (entry 100%) and the end of the animation when the subject starts to exit the scroller from the left (exit 0%). To summarize, the thumb element will move within input’s area and that movement is used to control the progress of an animation that animates a variable between the input’s min and max attribute values. We have our replacement for document.querySelector(\"input\").value in JavaScript! What’s going on with all the --val instances everywhere? Is it the same thing each time? I am deliberately using the same --val everywhere to confuse you a little and push you to try to understand what is going on. We usually use the dashed ident (--) notation to define custom properties (also called CSS variables) that we later call with var(). This is still true but that same notation can be used to name other things as well. In our examples we have three different things named --val: The variable that is animated and registered using @property. It contains the selected value and is used to style the input. The named view timeline defined by view-timeline and used by animation-timeline. The keyframes named --val and called by animation. Here is the same code written with different names for more clarity: @property --val { syntax: \"\u003cnumber\u003e\"; inherits: true; initial-value: 0; } input[type=\"range\"] { --min: attr(min type(\u003cnumber\u003e)); --max: attr(max type(\u003cnumber\u003e)); timeline-scope: --timeline; animation: value_update linear both; animation-timeline: --timeline; animation-range: entry 100% exit 0%; overflow: hidden; } @keyframes value_update { 0% { --val: var(--max) } 100% { --val: var(--min) } } input[type=\"range\"]::thumb { view-timeline: --timeine inline; } The star rating component All that we have done up to now is get the selected value of the input range — which is honestly about 90% of the work we need to do. What remains is some basic styles and code taken from what we made in the first article. If we omit the code from the previous section and the code from the previous article here is what we are left with: input[type=\"range\"] { background: linear-gradient(90deg, hsl(calc(30 + 4 * var(--val)) 100% 56%) calc(var(--val) * 100% / var(--max)), #7b7b7b 0 ); } input[type=\"range\"]::thumb { opacity: 0; } We make the thumb invisible and we define a gradient on the main element to color in the stars. No surprise here, but the gradient uses the same --val variable that contains the selected value to inform how much is colored in. When, for example, you select three stars, the --val variable will equal 3 and the color stop of the first color will equal 3*100%/5 , or 60%, meaning three stars are colored in. That same color is also dynamic as I am using the hsl() function where the first argument (the hue) is a function of --val as well. Here is the full demo, which you will want to open in Chrome 115+ at the time I’m writing this: And guess what? This implementation works with half stars as well without the need to change the CSS. All you have to do is update the input’s attributes to work in half increments. \u003cinput type=\"range\" min=\".5\" step=\".5\" max=\"5\"\u003e That’s it! We have our rating star component that you can easily control by adjusting the attributes. So, should I use border-image or a scroll-driven animation? If we look past the browser support factor, I consider this version better than the border-image approach we used in the first article. The border-image version is simpler and does the job pretty well, but it’s limited in what it can do. While our goal is to create a star rating component, it’s good to be able to do more and be able to style an input range as you want. With scroll-driven animations, we have more flexibility since the idea is to first get the value of the input and then use it to style the element. I know it’s not easy to grasp but don’t worry about that. You will face scroll-driven animations more often in the future and it will become more familiar with time. This example will look easy to you in good time. Worth noting, that the code used to get the value is a generic code that you can easily reuse even if you are not going to style the input itself. Getting the value of the input is independent of styling it. Here is a demo where I am adding a tooltip to a range slider to show its value: Many techniques are involved to create that demo and one of them is using scroll-driven animations to get the input value and show it inside the tooltip! Here is another demo using the same technique where different range sliders are controlling different variables on the page. And why not a wavy range slider? This one is a bit crazy but it illustrates how far we go with styling an input range! So, even if your goal is not to create a star rating component, there are a lot of use cases where such a technique can be really useful. Conclusion I hope you enjoyed this brief two-part series. In addition to a star rating component made with minimal code, we have explored a lot of cool and modern features, including the attr() function, CSS mask, and scroll-driven animations. It’s still early to adopt all of these features in production because of browser support, but it’s a good time to explore them and see what can be done soon using only CSS. Article series A CSS-Only Star Rating Component and More! (Part 1) A CSS-Only Star Rating Component and More! (Part 2)",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2019/07/star-pattern.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003e\u003ca href=\"https://css-tricks.com/a-css-only-star-rating-component-and-more-part-1/\"\u003eIn the last article\u003c/a\u003e, we created a CSS-only star rating component using the CSS \u003ccode\u003emask\u003c/code\u003e and \u003ccode\u003eborder-image\u003c/code\u003e properties, as well as the newly enhanced \u003ccode\u003eattr()\u003c/code\u003e function. We ended with CSS code that we can easily adjust to create component variations, including a heart rating and volume control.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis second article will study a different approach that gives us more flexibility. Instead of the \u003ccode\u003eborder-image\u003c/code\u003e trick we used in the first article, we will rely on scroll-driven animations!\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is the same star rating component with the new implementation. And since we’re treading in experimental territory, you’ll want to view this in Chrome 115+ while we wait for Safari and Firefox support:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eDo you spot the difference between this and the final demo in the first article? This time, I am updating the color of the stars based on how many of them are selected — something we cannot do using the \u003ccode\u003eborder-image\u003c/code\u003e trick!\u003c/p\u003e\n\n\n\n\u003cp\u003eI highly recommend you read the first article before jumping into this second part if you missed it, as I will be referring to concepts and techniques that we explored over there.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eOne more time:\u003c/strong\u003e At the time of writing, only Chrome 115+ and Edge 115+ fully support the features we will be using in this article, so please use either one of those as you follow along.\u003c/p\u003e\n\n\n\n\n\u003cbaseline-status featureid=\"scroll-driven-animations\"\u003e\u003c/baseline-status\u003e\n\n\n\u003ch3 id=\"why-scroll-driven-animations-\"\u003eWhy scroll-driven animations?\u003c/h3\u003e\n\n\n\u003cp\u003eYou might be wondering why we’re talking about scroll-driven animation when there’s nothing to scroll to in the star rating component. Scrolling? Animation? It’s even more confusing when you read \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_scroll-driven_animations\" rel=\"noopener\"\u003ethe MDN explainer for scroll-driven animations\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eIt allows you to animate property values based on a progression along a scroll-based timeline instead of the default time-based document timeline. This means that you can animate an element by scrolling a scrollable element, rather than just by the passing of time.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eBut if you keep reading you will see that we have two types of scroll-based timelines: \u003cstrong\u003escroll progress timelines\u003c/strong\u003e and \u003cstrong\u003eview progress timelines\u003c/strong\u003e. In our case, we are going to use the second one; a view progress timeline, and here is how MDN describes it:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eYou progress this timeline based on the change in visibility of an element (known as the subject) inside a scroller. The visibility of the subject inside the scroller is tracked as a percentage of progress — by default, the timeline is at 0% when the subject is first visible at one edge of the scroller, and 100% when it reaches the opposite edge.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eYou can check out the \u003ca href=\"https://css-tricks.com/almanac/properties/v/view-timeline-name/\"\u003eCSS-Tricks almanac definition for\u003c/a\u003e \u003ca href=\"https://css-tricks.com/almanac/properties/v/view-timeline-name/\"\u003e\u003ccode\u003eview-timeline-name\u003c/code\u003e\u003c/a\u003e while you’re at it for another explanation.\u003c/p\u003e\n\n\n\n\u003cp\u003eThings start to make more sense if we consider the thumb element as \u003cstrong\u003ethe subject\u003c/strong\u003e and the input element as \u003cstrong\u003ethe scroller\u003c/strong\u003e. After all, the thumb moves within the input area, so its visibility changes. We can track that movement as a percentage of progress and convert it to a value we can use to style the input element. We are essentially going to implement the equivalent of \u003ccode\u003edocument.querySelector(\u0026#34;input\u0026#34;).value\u003c/code\u003e in JavaScript but with vanilla CSS!\u003c/p\u003e\n\n\n\u003ch3 id=\"the-implementation\"\u003eThe implementation\u003c/h3\u003e\n\n\n\u003cp\u003eNow that we have an idea of how this works, let’s see how everything translates into code.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@property --val {\n  syntax: \u0026#34;\u0026lt;number\u0026gt;\u0026#34;;\n  inherits: true;\n  initial-value: 0; \n}\n\ninput[type=\u0026#34;range\u0026#34;] {\n  --min: attr(min type(\u0026lt;number\u0026gt;));\n  --max: attr(max type(\u0026lt;number\u0026gt;));\n\n  timeline-scope: --val;\n  animation: --val linear both;\n  animation-timeline: --val;\n  animation-range: entry 100% exit 0%;\n  overflow: hidden;\n}\n\n@keyframes --val {\n  0%   { --val: var(--max) }\n  100% { --val: var(--min) }\n}\n\ninput[type=\u0026#34;range\u0026#34;]::thumb {\n  view-timeline: --val inline;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eI know, this is a lot of strange syntax! But we will dissect each line and you will see that it’s not all that complex at the end of the day.\u003c/p\u003e\n\n\n\u003ch4 id=\"the-subject-and-the-scroller\"\u003eThe subject and the scroller\u003c/h4\u003e\n\n\n\u003cp\u003eWe start by defining \u003cstrong\u003ethe subject,\u003c/strong\u003e i.e. the thumb element, and for this we use the \u003ccode\u003eview-timeline\u003c/code\u003e shorthand property. From \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/view-timeline\" rel=\"noopener\"\u003ethe MDN page\u003c/a\u003e, we can read:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eThe \u003ccode\u003eview-timeline\u003c/code\u003e \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS\" rel=\"noopener\"\u003eCSS\u003c/a\u003e \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Shorthand_properties\" rel=\"noopener\"\u003eshorthand property\u003c/a\u003e is used to define a named view progress timeline, which is progressed through based on the change in visibility of an element (known as the subject) inside a scrollable element (scroller). \u003ccode\u003eview-timeline\u003c/code\u003e is set on the subject.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eI think it’s self-explanatory. The view timeline name is \u003ccode\u003e--val\u003c/code\u003e and the axis is \u003ccode\u003einline\u003c/code\u003e since we’re working along the horizontal x-axis.\u003c/p\u003e\n\n\n\n\u003cp\u003eNext, we define \u003cstrong\u003ethe scroller\u003c/strong\u003e, i.e. the input element, and for this, we use \u003ccode\u003eoverflow: hidden\u003c/code\u003e (or \u003ccode\u003eoverflow: auto\u003c/code\u003e). This part is the easiest but also the one you will forget the most so let me insist on this: \u003cstrong\u003edon’t forget to define overflow on the scroller!\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eI insist on this because your code will work fine without defining overflow, but the values won’t be good. The reason is that the scroller exists but will be defined by the browser (depending on your page structure and your CSS) and most of the time it’s not the one you want. So let me repeat it another time: \u003cstrong\u003eremember the\u003c/strong\u003e \u003ccode\u003eoverflow\u003c/code\u003e \u003cstrong\u003eproperty!\u003c/strong\u003e\u003c/p\u003e\n\n\n\u003ch4 id=\"the-animation\"\u003eThe animation\u003c/h4\u003e\n\n\n\u003cp\u003eNext up, we create an animation that animates the \u003ccode\u003e--val\u003c/code\u003e variable between the input’s \u003ccode\u003emin\u003c/code\u003e and \u003ccode\u003emax\u003c/code\u003e values. Like we did in the first article, we are using the newly-enhanced \u003ccode\u003eattr()\u003c/code\u003e function to get those values. See that? The “animation” part of the scroll-driven animation, an animation we link to the view timeline we defined on the subject using \u003ccode\u003eanimation-timeline\u003c/code\u003e. And to be able to animate a variable we register it using \u003ccode\u003e@property\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eNote the use of \u003ccode\u003etimeline-scope\u003c/code\u003e which is another tricky feature that’s easy to overlook. By default, named view timelines are scoped to the element where they are defined and its descendant. In our case, the input is a parent element of the thumb so it cannot access the named view timeline. To overcome this, we increase the scope using \u003ccode\u003etimeline-scope\u003c/code\u003e. Again, from \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/timeline-scope\" rel=\"noopener\"\u003eMDN\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003etimeline-scope\u003c/code\u003e is given the name of a timeline defined on a descendant element; this causes the scope of the timeline to be increased to the element that \u003ccode\u003etimeline-scope\u003c/code\u003e is set on and any of its descendants. In other words, that element and any of its descendant elements can now be controlled using that timeline.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eNever forget about this! Sometimes everything is correctly defined but nothing is working because you forget about the scope.\u003c/p\u003e\n\n\n\n\u003cp\u003eThere’s something else you might be wondering:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eWhy are the keyframes values inverted? Why is the \u003ccode\u003emin\u003c/code\u003e is set to \u003ccode\u003e100%\u003c/code\u003e and the \u003ccode\u003emax\u003c/code\u003e set to \u003ccode\u003e0%\u003c/code\u003e?\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eTo understand this, let’s first take the following example where you can scroll the container horizontally to reveal a red circle inside of it.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eInitially, the red circle is hidden on the right side. Once we start scrolling, it appears from the right side, then disappears to the left as you continue scrolling towards the right. We scroll from left to right but our actual movement is from right to left.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn our case, we don’t have any scrolling since our subject (the thumb) will not overflow the scroller (the input) but the main logic is the same. The starting point is the right side and the ending point is the left side. In other words, the animation starts when the thumb is on the right side (the input’s \u003ccode\u003emax\u003c/code\u003e value) and will end when it’s on the left side (the input’s \u003ccode\u003emin\u003c/code\u003e value).\u003c/p\u003e\n\n\n\u003ch4 id=\"the-animation-range\"\u003eThe animation range\u003c/h4\u003e\n\n\n\u003cp\u003eThe last piece of the puzzle is the following \u003cem\u003eimportant\u003c/em\u003e line of code:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eanimation-range: entry 100% exit 0%;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBy default, the animation starts when the subject \u003cstrong\u003estarts to enter the scroller from the right\u003c/strong\u003e and ends when the subject \u003cstrong\u003ehas completely exited the scroller from the left\u003c/strong\u003e. This is not good because, as we said, the thumb will not overflow the scroller, so it will \u003cem\u003enever\u003c/em\u003e reach the start and the end of the animation.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"977\" height=\"254\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/DLxrh0pl.png?resize=977%2C254\u0026amp;ssl=1\" alt=\"Red circle representing the thumb element is at the far right of the container but not quite all the way there.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/DLxrh0pl.png?w=977\u0026amp;ssl=1 977w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/DLxrh0pl.png?resize=300%2C78\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/DLxrh0pl.png?resize=768%2C200\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eTo rectify this we use the \u003ccode\u003eanimation-range\u003c/code\u003e property to make the start of the animation when the subject \u003cstrong\u003ehas completely entered the scroller from the right\u003c/strong\u003e (\u003ccode\u003eentry 100%\u003c/code\u003e) and the end of the animation when the subject \u003cstrong\u003estarts to exit the scroller from the left\u003c/strong\u003e (\u003ccode\u003eexit 0%\u003c/code\u003e).\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"977\" height=\"254\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/s_3FEC3DE430682F2526F00121B6B9A21346D04C3B20F98BA491C64590EEBAAF65_1723632516189_image.png?resize=977%2C254\u0026amp;ssl=1\" alt=\"Red circle representing the thumb element displayed qt the far right of the container where the animation starts.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/s_3FEC3DE430682F2526F00121B6B9A21346D04C3B20F98BA491C64590EEBAAF65_1723632516189_image.png?w=977\u0026amp;ssl=1 977w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/s_3FEC3DE430682F2526F00121B6B9A21346D04C3B20F98BA491C64590EEBAAF65_1723632516189_image.png?resize=300%2C78\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/s_3FEC3DE430682F2526F00121B6B9A21346D04C3B20F98BA491C64590EEBAAF65_1723632516189_image.png?resize=768%2C200\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eTo summarize, the thumb element will move within input’s area and that movement is used to control the progress of an animation that animates a variable between the input’s \u003ccode\u003emin\u003c/code\u003e and \u003ccode\u003emax\u003c/code\u003e attribute values. We have our replacement for \u003ccode\u003edocument.querySelector(\u0026#34;input\u0026#34;).value\u003c/code\u003e in JavaScript!\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eWhat’s going on with all the \u003ccode\u003e--val\u003c/code\u003e instances everywhere? Is it the same thing each time?\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eI am deliberately using the same \u003ccode\u003e--val\u003c/code\u003e everywhere to confuse you a little and push you to try to understand what is going on. We usually use the dashed ident (\u003ccode\u003e--\u003c/code\u003e) notation to define custom properties (also called CSS variables) that we later call with \u003ccode\u003evar()\u003c/code\u003e. This is still true but that same notation can be used to name other things as well.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn our examples we have three different things named \u003ccode\u003e--val\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eThe \u003cstrong\u003evariable\u003c/strong\u003e that is animated and registered using \u003ccode\u003e@property\u003c/code\u003e. It contains the selected value and is used to style the input.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003cstrong\u003enamed view timeline\u003c/strong\u003e defined by \u003ccode\u003eview-timeline\u003c/code\u003e and used by \u003ccode\u003eanimation-timeline\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003cstrong\u003ekeyframes\u003c/strong\u003e named \u003ccode\u003e--val\u003c/code\u003e and called by \u003ccode\u003eanimation\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eHere is the same code written with different names for more clarity:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@property --val {\n  syntax: \u0026#34;\u0026lt;number\u0026gt;\u0026#34;;\n  inherits: true;\n  initial-value: 0; \n}\n\ninput[type=\u0026#34;range\u0026#34;] {\n  --min: attr(min type(\u0026lt;number\u0026gt;));\n  --max: attr(max type(\u0026lt;number\u0026gt;));\n\n  timeline-scope: --timeline;\n  animation: value_update linear both;\n  animation-timeline: --timeline;\n  animation-range: entry 100% exit 0%;\n  overflow: hidden;\n}\n\n@keyframes value_update {\n  0%   { --val: var(--max) }\n  100% { --val: var(--min) }\n}\n\ninput[type=\u0026#34;range\u0026#34;]::thumb {\n  view-timeline: --timeine inline;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"the-star-rating-component\"\u003eThe star rating component\u003c/h3\u003e\n\n\n\u003cp\u003eAll that we have done up to now is get the selected value of the input range — which is honestly about 90% of the work we need to do. What remains is some basic styles and code taken from what we made in the first article.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf we omit the code from the previous section and the code from the previous article here is what we are left with:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003einput[type=\u0026#34;range\u0026#34;] {\n  background: \n    linear-gradient(90deg,\n      hsl(calc(30 + 4 * var(--val)) 100% 56%) calc(var(--val) * 100% / var(--max)),\n      #7b7b7b 0\n    );\n}\ninput[type=\u0026#34;range\u0026#34;]::thumb {\n  opacity: 0;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe make the thumb invisible and we define a gradient on the main element to color in the stars. No surprise here, but the gradient uses the same \u003ccode\u003e--val\u003c/code\u003e variable that contains the selected value to inform how much is colored in.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen, for example, you select three stars, the \u003ccode\u003e--val\u003c/code\u003e variable will equal \u003ccode\u003e3\u003c/code\u003e and the color stop of the first color will equal \u003ccode\u003e3*100%/5\u003c/code\u003e , or \u003ccode\u003e60%\u003c/code\u003e, meaning three stars are colored in. That same color is also dynamic as I am using the \u003ccode\u003ehsl()\u003c/code\u003e function where the first argument (the hue) is a function of \u003ccode\u003e--val\u003c/code\u003e as well.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is the full demo, which you will want to open in Chrome 115+ at the time I’m writing this:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eAnd guess what? This implementation works with half stars as well without the need to change the CSS. All you have to do is update the input’s attributes to work in half increments. \u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;input type=\u0026#34;range\u0026#34; min=\u0026#34;.5\u0026#34; step=\u0026#34;.5\u0026#34; max=\u0026#34;5\u0026#34;\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThat’s it! We have our rating star component that you can easily control by adjusting the attributes.\u003c/p\u003e\n\n\n\u003ch3 id=\"so-should-i-use-border-image-or-a-scroll-driven-animation-\"\u003eSo, should I use \u003ccode\u003eborder-image\u003c/code\u003e or a scroll-driven animation?\u003c/h3\u003e\n\n\n\u003cp\u003eIf we look past the browser support factor, I consider this version better than the \u003ccode\u003eborder-image\u003c/code\u003e approach we used in the first article. The \u003ccode\u003eborder-image\u003c/code\u003e version is simpler and does the job pretty well, but it’s limited in what it can do. While our goal is to create a star rating component, it’s good to be able to do more and be able to style an input range as you want.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith scroll-driven animations, we have more flexibility since the idea is to first get the value of the input and then use it to style the element. I know it’s not easy to grasp but don’t worry about that. You will face scroll-driven animations more often in the future and it will become more familiar with time. This example will look easy to you in good time.\u003c/p\u003e\n\n\n\n\u003cp\u003eWorth noting, that the code used to get the value is a generic code that you can easily reuse even if you are not going to style the input itself. Getting the value of the input is independent of styling it.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is a demo where I am adding \u003ca href=\"https://css-tip.com/range-slider-tooltip/\" rel=\"noopener\"\u003ea tooltip to a range slider to show its value\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eMany techniques are involved to create that demo and one of them is using scroll-driven animations to get the input value and show it inside the tooltip!\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is another demo using the same technique where \u003ca href=\"https://css-tip.com/css-variables-range-slider/\" rel=\"noopener\"\u003edifferent range sliders are controlling different variables on the page\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eAnd why not a wavy range slider?\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThis one is a bit crazy but it illustrates how far we go with styling an input range! So, even if your goal is not to create a star rating component, there are a lot of use cases where such a technique can be really useful.\u003c/p\u003e\n\n\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\n\n\u003cp\u003eI hope you enjoyed this brief two-part series. In addition to a star rating component made with minimal code, we have explored a lot of cool and modern features, including the \u003ccode\u003eattr()\u003c/code\u003e function, CSS \u003ccode\u003emask\u003c/code\u003e, and scroll-driven animations. It’s still early to adopt all of these features in production because of browser support, but it’s a good time to explore them and see what can be done soon using only CSS.\u003c/p\u003e\n\n\n\u003ch4 id=\"article-series\"\u003eArticle series\u003c/h4\u003e\n\n\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://css-tricks.com/a-css-only-star-rating-component-and-more-part-1/\"\u003eA CSS-Only Star Rating Component and More! (Part 1)\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://css-tricks.com/a-css-only-star-rating-component-and-more-part-2/\"\u003eA CSS-Only Star Rating Component and More! (Part 2)\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-03-07T06:14:12-07:00",
  "modifiedTime": "2025-03-07T12:57:10-07:00"
}
