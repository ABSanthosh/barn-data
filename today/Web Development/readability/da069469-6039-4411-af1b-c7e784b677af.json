{
  "id": "da069469-6039-4411-af1b-c7e784b677af",
  "title": "Web Components Demystified",
  "link": "https://css-tricks.com/web-components-demystified/",
  "description": "Scott Jehl released a course called Web Components Demystified. This is my full set of notes from Scott's course. You'll still want to take the course on your own, and I encourage you to because Scott is an excellent teacher who makes all of this stuff extremely accessible, even to noobs like me. Web Components Demystified originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Geoff Graham",
  "published": "Fri, 14 Mar 2025 12:51:59 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Notes",
    "web components"
  ],
  "byline": "Geoff Graham",
  "length": 56550,
  "excerpt": "Scott Jehl released a course called Web Components Demystified. This is my full set of notes from Scott's course. You'll still want to take the course on your own, and I encourage you to because Scott is an excellent teacher who makes all of this stuff extremely accessible, even to noobs like me.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "Scott Jehl released a course called Web Components Demystified. I love that name because it says what the course is about right on the tin: you’re going to learn about web components and clear up any confusion you may already have about them. And there’s plenty of confusion to go around! “Components” is already a loaded term that’s come to mean everything from a piece of UI, like a search component, to an element you can drop in and reuse anywhere, such as a React component. The web is chock-full of components, tell you what. But what we’re talking about here is a set of standards where HTML, CSS, and JavaScript rally together so that we can create custom elements that behave exactly how we want them to. It’s how we can make an element called \u003ctasty-pizza\u003e and the browser knows what to do with it. This is my full set of notes from Scott’s course. I wouldn’t say they’re complete or even a direct one-to-one replacement for watching the course. You’ll still want to do that on your own, and I encourage you to because Scott is an excellent teacher who makes all of this stuff extremely accessible, even to noobs like me. Chapter 1: What Web Components Are… and Aren’t Web components are not built-in elements, even though that’s what they might look like at first glance. Rather, they are a set of technologies that allow us to instruct what the element is and how it behaves. Think of it the same way that “responsive web design” is not a thing but rather a set of strategies for adapting design to different web contexts. So, just as responsive web design is a set of ingredients — including media fluid grids, flexible images, and media queries — web components are a concoction involving: Custom elements These are HTML elements that are not built into the browser. We make them up. They include a letter and a dash. \u003cmy-fancy-heading\u003e Hey, I'm Fancy \u003c/my-fancy-heading\u003e We’ll go over these in greater detail in the next module. HTML templates Templates are bits of reusable markup that generate more markup. We can hide something until we make use of it. \u003ctemplate\u003e \u003cli class=\"user\"\u003e \u003ch2 class=\"name\"\u003e\u003c/h2\u003e \u003cp class=\"bio\"\u003e\u003c/p\u003e \u003c/li\u003e \u003c/template\u003e Much more on this in the third module. Shadow DOM The DOM is queryable. document.querySelector(\"h1\"); // \u003ch1\u003eHello, World\u003c/h1\u003e The Shadow DOM is a fragment of the DOM where markup, scripts, and styles are encapsulated from other DOM elements. We’ll cover this in the fourth module, including how to \u003cslot\u003e content. There used to be a fourth “ingredient” called HTML Imports, but those have been nixed. In short, web components might be called “components” but they aren’t really components more than technologies. In React, components sort of work like partials. It defines a snippet of HTML that you drop into your code and it outputs in the DOM. Web Components are built off of HTML Elements. They are not replaced when rendered the way they are in JavaScript component frameworks. Web components are quite literally HTML elements and have to obey HTML rules. For example: \u003c!-- Nope --\u003e \u003cul\u003e \u003cmy-list-item\u003e\u003c/my-list-item\u003e \u003c!-- etc. --\u003e \u003c/ul\u003e \u003c!-- Yep --\u003e \u003cul\u003e \u003cli\u003e \u003cmy-list-item\u003e\u003c/my-list-item\u003e \u003c/li\u003e \u003c/ul\u003e We’re generating meaningful HTML up-front rather than rendering it in the browser through the client after the fact. Provide the markup and enhance it! Web components have been around a while now, even if it seems we’re only starting to talk about them now. Chapter 2: Custom Elements First off, custom elements are not built-in HTML elements. We instruct what they are and how they behave. They are named with a dash and at must contain least one letter. All of the following are valid names for custom elements: \u003csuper-component\u003e \u003ca-\u003e \u003ca-4-\u003e \u003ccard-10.0.1\u003e \u003ccard-♠️\u003e Just remember that there are some reserved names for MathML and SVG elements, like \u003cfont-face\u003e. Also, they cannot be void elements, e.g. \u003cmy-element /\u003e, meaning they have to have a correspoonding closing tag. Since custom elements are not built-in elements, they are undefined by default — and being undefined can be a useful thing! That means we can use them as containers with default properties. For example, they are display: inline by default and inherit the current font-family, which can be useful to pass down to the contents. We can also use them as styling hooks since they can be selected in CSS. Or maybe they can be used for accessibility hints. The bottom line is that they do not require JavaScript in order to make them immediately useful. Working with JavaScript. If there is one \u003cmy-button\u003e on the page, we can query it and set a click handler on it with an event listener. But if we were to insert more instances on the page later, we would need to query it when it’s appended and re-run the function since it is not part of the original document rendering. Defining a custom element This defines and registers the custom element. It teaches the browser that this is an instance of the Custom Elements API and extends the same class that makes other HTML elements valid HTML elements: \u003cmy-element\u003eMy Element\u003c/my-element\u003e \u003cscript\u003e customElements.define(\"my-element\", class extends HTMLElement {}); \u003c/script\u003e Check out the methods we get immediate access to: Breaking down the syntax customElements .define( \"my-element\", class extends HTMLElement {} ); // Functionally the same as: class MyElement extends HTMLElement {} customElements.define(\"my-element\", MyElement); export default myElement // ...which makes it importable by other elements: import MyElement from './MyElement.js'; const myElement = new MyElement(); document.body.appendChild(myElement); // \u003cbody\u003e // \u003cmy-element\u003e\u003c/my-element\u003e // \u003c/body\u003e // Or simply pull it into a page // Don't need to `export default` but it doesn't hurt to leave it // \u003cmy-element\u003eMy Element\u003c/my-element\u003e // \u003cscript type=\"module\" src=\"my-element.js\"\u003e\u003c/script\u003e It’s possible to define a custom element by extending a specific HTML element. The specification documents this, but Scott is focusing on the primary way. class WordCount extends HTMLParagraphElement customElements.define(\"word-count\", WordCount, { extends: \"p\" }); // \u003cp is=\"word-count\"\u003eThis is a custom paragraph!\u003c/p\u003e Scott says do not use this because WebKit is not going to implement it. We would have to polyfill it forever, or as long as WebKit holds out. Consider it a dead end. The lifecycle A component has various moments in its “life” span: Constructed (constructor) Connected (connectedCallback) Adopted (adoptedCallback) Attribute Changed (attributeChangedCallback) Disconnected (disconnectedCallback) We can hook into these to define the element’s behavior. class myElement extends HTMLElement { constructor() {} connectedCallback() {} adoptedCallback() {} attributeChangedCallback() {} disconnectedCallback() {} } customElements.define(\"my-element\", MyElement); constructor() class myElement extends HTMLElement { constructor() { // provides us with the `this` keyword super() // add a property this.someProperty = \"Some value goes here\"; // add event listener this.addEventListener(\"click\", () =\u003e {}); } } customElements.define(\"my-element\", MyElement); “When the constructor is called, do this…” We don’t have to have a constructor when working with custom elements, but if we do, then we need to call super() because we’re extending another class and we’ll get all of those properties. Constructor is useful, but not for a lot of things. It’s useful for setting up initial state, registering default properties, adding event listeners, and even creating Shadow DOM (which Scott will get into in a later module). For example, we are unable to sniff out whether or not the custom element is in another element because we don’t know anything about its parent container yet (that’s where other lifecycle methods come into play) — we’ve merely defined it. connectedCallback() class myElement extends HTMLElement { // the constructor is unnecessary in this example but doesn't hurt. constructor() { super() } // let me know when my element has been found on the page. connectedCallback() { console.log(`${this.nodeName} was added to the page.`); } } customElements.define(\"my-element\", MyElement); Note that there is some strangeness when it comes to timing things. Sometimes isConnected returns true during the constructor. connectedCallback() is our best way to know when the component is found on the page. This is the moment it is connected to the DOM. Use it to attach event listeners. If the \u003cscript\u003e tag comes before the DOM is parsed, then it might not recognize childNodes. This is not an uncommon situation. But if we add type=\"module\" to the \u003cscript\u003e, then the script is deferred and we get the child nodes. Using setTimeout can also work, but it looks a little gross. disconnectedCallback class myElement extends HTMLElement { // let me know when my element has been found on the page. disconnectedCallback() { console.log(`${this.nodeName} was removed from the page.`); } } customElements.define(\"my-element\", MyElement); This is useful when the component needs to be cleaned up, perhaps like stopping an animation or preventing memory links. adoptedCallback() This is when the component is adopted by another document or page. Say you have some iframes on a page and move a custom element from the page into an iframe, then it would be adopted in that scenario. It would be created, then added, then removed, then adopted, then added again. That’s a full lifecycle! This callback is adopted automatically simply by picking it up and dragging it between documents in the DOM. Custom elements and attributes Unlike React, HTML attributes are strings (not props!). Global attributes work as you’d expect, though some global attributes are reflected as properties. You can make any attribute do that if you want, just be sure to use care and caution when naming because, well, we don’t want any conflicts. Avoid standard attributes on a custom element as well, as that can be confusing particularly when handing a component to another developer. Example: using type as an attribute which is also used by \u003cinput\u003e elements. We could say data-type instead. (Remember that Chris has a comprehensive guide on using data attributes.) Examples Here’s a quick example showing how to get a greeting attribute and set it on the custom element: class MyElement extends HTMLElement { get greeting() { return this.getAttribute('greeting'); // return this.hasAttribute('greeting'); } set greeting(val) { if(val) { this.setAttribute('greeting', val); // this setAttribute('greeting', ''); } else { this.removeAttribute('greeting'); } } } customElements.define(\"my-element\", MyElement); Another example, this time showing a callback for when the attribute has changed, which prints it in the element’s contents: \u003cmy-element greeting=\"hello\"\u003ehello\u003c/my-element\u003e \u003c!-- Change text greeting when attribite greeting changes --\u003e \u003cscript\u003e class MyElement extends HTMLElement { static observedAttributes = [\"greeting\"]; attributeChangedCallback(name, oldValue, newValue) { if (name === 'greeting' \u0026\u0026 oldValue \u0026\u0026 oldValue !== newValue) { console.log(name + \" changed\"); this.textContent = newValue; } } } customElements.define(\"my-element\", MyElement); \u003c/script\u003e A few more custom element methods: customElements.get('my-element'); // returns MyElement Class customElements.getName(MyElement); // returns 'my-element' customElements.whenDefined(\"my-element\"); // waits for custom element to be defined const el = document.createElement(\"spider-man\"); class SpiderMan extends HTMLElement { constructor() { super(); console.log(\"constructor!!\"); } } customElements.define(\"spider-man\", SpiderMan); customElements.upgrade(el); // returns \"constructor!!\" Custom methods and events: \u003cmy-element\u003e\u003cbutton\u003eMy Element\u003c/button\u003e\u003c/my-element\u003e \u003cscript\u003e customElements.define(\"my-element\", class extends HTMLElement { connectedCallback() { const btn = this.firstElementChild; btn.addEventListener(\"click\", this.handleClick) } handleClick() { console.log(this); } }); \u003c/script\u003e Bring your own base class, in the same way web components frameworks like Lit do: class BaseElement extends HTMLElement { $ = this.querySelector; } // extend the base, use its helper class myElement extends BaseElement { firstLi = this.$(\"li\"); } Practice prompt Create a custom HTML element called \u003csay-hi\u003e that displays the text “Hi, World!” when added to the page: Enhance the element to accept a name attribute, displaying \"Hi, [Name]!\" instead: Chapter 3: HTML Templates The \u003ctemplate\u003e element is not for users but developers. It is not exposed visibly by browsers. \u003ctemplate\u003eThe browser ignores everything in here.\u003c/template\u003e Templates are designed to hold HTML fragments: \u003ctemplate\u003e \u003cdiv class=\"user-profile\"\u003e \u003ch2 class=\"name\"\u003eScott\u003c/h2\u003e \u003cp class=\"bio\"\u003eAuthor\u003c/p\u003e \u003c/div\u003e \u003c/template\u003e A template is selectable in CSS; it just doesn’t render. It’s a document fragment. The inner document is a #document-fragment. Not sure why you’d do this, but it illustrates the point that templates are selectable: template { display: block; }` /* Nope */ template + div { height: 100px; width: 100px; } /* Works */ The content property No, not in CSS, but JavaScript. We can query the inner contents of a template and print them somewhere else. \u003ctemplate\u003e \u003cp\u003eHi\u003c/p\u003e \u003c/template\u003e \u003cscript\u003e const myTmpl = documenty.querySelector(\"template\").content; console.log(myTmpl); \u003c/script\u003e Using a Document Fragment without a \u003ctemplate\u003e const myFrag = document.createDocumentFragment(); myFrag.innerHTML = \"\u003cp\u003eTest\u003c/p\u003e\"; // Nope const myP = document.createElement(\"p\"); // Yep myP.textContent = \"Hi!\"; myFrag.append(myP); // use the fragment document.body.append(myFrag); Clone a node \u003ctemplate\u003e \u003cp\u003eHi\u003c/p\u003e \u003c/template\u003e \u003cscript\u003e const myTmpl = documenty.querySelector(\"template\").content; console.log(myTmpl); // Oops, only works one time! We need to clone it. \u003c/script\u003e Oops, the component only works one time! We need to clone it if we want multiple instances: \u003ctemplate\u003e \u003cp\u003eHi\u003c/p\u003e \u003c/template\u003e \u003cscript\u003e const myTmpl = document.querySelector(\"template\").content; document.body.append(myTmpl.cloneNode(true)); // true is necessary document.body.append(myTmpl.cloneNode(true)); document.body.append(myTmpl.cloneNode(true)); document.body.append(myTmpl.cloneNode(true)); \u003c/script\u003e A more practical example Let’s stub out a template for a list item and then insert them into an unordered list: \u003ctemplate id=\"tmpl-user\"\u003e\u003cli\u003e\u003cstrong\u003e\u003c/strong\u003e: \u003cspan\u003e\u003c/span\u003e\u003c/li\u003e\u003c/template\u003e \u003cul id=\"users\"\u003e\u003c/ul\u003e \u003cscript\u003e const usersElement = document.querySelector(\"#users\"); const userTmpl = document.querySelector(\"#tmpl-user\").content; const users = [{name: \"Bob\", title: \"Artist\"}, {name: \"Jane\", title: \"Doctor\"}]; users.forEach(user =\u003e { let thisLi = userTmpl.cloneNode(true); thisLi.querySelector(\"strong\").textContent = user.name; thisLi.querySelector(\"span\").textContent = user.title; usersElement.append(thisLi); }); \u003c/script\u003e The other way to use templates that we’ll get to in the next module: Shadow DOM \u003ctemplate shadowroot=open\u003e \u003cp\u003eHi, I'm in the Shadow DOM\u003c/p\u003e \u003c/template\u003e Chapter 4: Shadow DOM Here we go, this is a heady chapter! The Shadow DOM reminds me of playing bass in a band: it’s easy to understand but incredibly difficult to master. It’s easy to understand that there are these nodes in the DOM that are encapsulated from everything else. They’re there, we just can’t really touch them with regular CSS and JavaScript without some finagling. It’s the finagling that’s difficult to master. There are times when the Shadow DOM is going to be your best friend because it prevents outside styles and scripts from leaking in and mucking things up. Then again, you’re most certainly going go want to style or apply scripts to those nodes and you have to figure that part out. That’s where web components really shine. We get the benefits of an element that’s encapsulated from outside noise but we’re left with the responsibility of defining everything for it ourselves. Select elements are a great example of the Shadow DOM. Shadow roots! Slots! They’re all part of the puzzle. Using the Shadow DOM We covered the \u003ctemplate\u003e element in the last chapter and determined that it renders in the Shadow DOM without getting displayed on the page. \u003ctemplate shadowrootmode=\"closed\"\u003e \u003cp\u003eThis will render in the Shadow DOM.\u003c/p\u003e \u003c/template\u003e In this case, the \u003ctemplate\u003e is rendered as a #shadow-root without the \u003ctemplate\u003e element’s tags. It’s a fragment of code. So, while the paragraph inside the template is rendered, the \u003ctemplate\u003e itself is not. It effectively marks the Shadow DOM’s boundaries. If we were to omit the shadowrootmode attribute, then we simply get an unrendered template. Either way, though, the paragraph is there in the DOM and it is encapsulated from other styles and scripts on the page. These are all of the elements that can have a shadow. Breaching the shadow There are times you’re going to want to “pierce” the Shadow DOM to allow for some styling and scripts. The content is relatively protected but we can open the shadowrootmode and allow some access. \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cp\u003eThis will render in the Shadow DOM.\u003c/p\u003e \u003c/template\u003e \u003c/div\u003e Now we can query the div that contains the \u003ctemplate\u003e and select the #shadow-root: document.querySelector(\"div\").shadowRoot // #shadow-root (open) // \u003cp\u003eThis will render in the Shadow DOM.\u003c/p\u003e We need that \u003cdiv\u003e in there so we have something to query in the DOM to get to the paragraph. Remember, the \u003ctemplate\u003e is not actually rendered at all. Additional shadow attributes \u003c!-- should this root stay with a parent clone? --\u003e \u003ctemplate shadowrootcloneable\u003e \u003c!-- allow shadow to be serialized into a string object — can forget about this --\u003e \u003ctemplate shadowrootserializable\u003e \u003c!-- click in element focuses first focusable element --\u003e \u003ctemplate shadowrootdelegatesfocus\u003e Shadow DOM siblings When you add a shadow root, it becomes the only rendered root in that shadow host. Any elements after a shadow root node in the DOM simply don’t render. If a DOM element contains more than one shadow root node, the ones after the first just become template tags. It’s sort of like the Shadow DOM is a monster that eats the siblings. Slots bring those siblings back! \u003cdiv\u003e \u003ctemplate shadowroot=\"closed\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003cp\u003eI'm a sibling of a shadow root, and I am visible.\u003c/p\u003e \u003c/template\u003e \u003c/div\u003e All of the siblings go through the slots and are distributed that way. It’s sort of like slots allow us to open the monster’s mouth and see what’s inside. Declaring the Shadow DOM Using templates is the declarative way to define the Shadow DOM. We can also define the Shadow DOM imperatively using JavaScript. So, this is doing the exact same thing as the last code snippet, only it’s done programmatically in JavaScript: \u003cmy-element\u003e \u003ctemplate shadowroot=\"open\"\u003e \u003cp\u003eThis will render in the Shadow DOM.\u003c/p\u003e \u003c/template\u003e \u003c/my-element\u003e \u003cscript\u003e customElements.define('my-element', class extends HTMLElement { constructor() { super(); // attaches a shadow root node this.attachShadow({mode: \"open\"}); // inserts a slot into the template this.shadowRoot.innerHTML = '\u003cslot\u003e\u003c/slot\u003e'; } }); \u003c/script\u003e Another example: \u003cmy-status\u003eavailable\u003c/my-status\u003e \u003cscript\u003e customElements.define('my-status', class extends HTMLElement { constructor() { super(); this.attachShadow({mode: \"open\"}); this.shadowRoot.innerHTML = '\u003cp\u003eThis item is currently: \u003cslot\u003e\u003c/slot\u003e\u003c/p\u003e'; } }); \u003c/script\u003e So, is it better to be declarative or imperative? Like the weather where I live, it just depends. Both approaches have their benefits. We can set the shadow mode via Javascript as well: // open this.attachShadow({mode: open}); // closed this.attachShadow({mode: closed}); // cloneable this.attachShadow({cloneable: true}); // delegateFocus this.attachShadow({delegatesFocus: true}); // serialized this.attachShadow({serializable: true}); // Manually assign an element to a slot this.attachShadow({slotAssignment: \"manual\"}); About that last one, it says we have to manually insert the \u003cslot\u003e elements in JavaScript: \u003cmy-element\u003e \u003cp\u003eThis WILL render in shadow DOM but not automatically.\u003c/p\u003e \u003c/my-element\u003e \u003cscript\u003e customElements.define('my-element', class extends HTMLElement { constructor() { super(); this.attachShadow({ mode: \"open\", slotAssignment: \"manual\" }); this.shadowRoot.innerHTML = '\u003cslot\u003e\u003c/slot\u003e'; } connectedCallback(){ const slotElem = this.querySelector('p'); this.shadowRoot.querySelector('slot').assign(slotElem); } }); \u003c/script\u003e Examples Scott spent a great deal of time sharing examples that demonstrate different sorts of things you might want to do with the Shadow DOM when working with web components. I’ll rapid-fire those in here. Get an array of element nodes in a slot this.shadowRoot.querySelector('slot') .assignedElements(); // get an array of all nodes in a slot, text too this.shadowRoot.querySelector('slot') .assignedNodes(); When did a slot’s nodes change? let slot = document.querySelector('div') .shadowRoot.querySelector(\"slot\"); slot.addEventListener(\"slotchange\", (e) =\u003e { console.log(`Slot \"${slot.name}\" changed`); // \u003e Slot \"saying\" changed }) Combining imperative Shadow DOM with templates Back to this example: \u003cmy-status\u003eavailable\u003c/my-status\u003e \u003cscript\u003e customElements.define('my-status', class extends HTMLElement { constructor() { super(); this.attachShadow({mode: \"open\"}); this.shadowRoot.innerHTML = '\u003cp\u003eThis item is currently: \u003cslot\u003e\u003c/slot\u003e\u003c/p\u003e'; } }); \u003c/script\u003e Let’s get that string out of our JavaScript with reusable imperative shadow HTML: \u003cmy-status\u003eavailable\u003c/my-status\u003e \u003ctemplate id=\"my-status\"\u003e \u003cp\u003eThis item is currently: \u003cslot\u003e\u003c/slot\u003e \u003c/p\u003e \u003c/template\u003e \u003cscript\u003e customElements.define('my-status', class extends HTMLElement { constructor(){ super(); this.attachShadow({mode: 'open'}); const template = document.getElementById('my-status'); this.shadowRoot.append(template.content.cloneNode(true)); } }); \u003c/script\u003e Slightly better as it grabs the component’s name programmatically to prevent name collisions: \u003cmy-status\u003eavailable\u003c/my-status\u003e \u003ctemplate id=\"my-status\"\u003e \u003cp\u003eThis item is currently: \u003cslot\u003e\u003c/slot\u003e \u003c/p\u003e \u003c/template\u003e \u003cscript\u003e customElements.define('my-status', class extends HTMLElement { constructor(){ super(); this.attachShadow({mode: 'open'}); const template = document.getElementById( this.nodeName.toLowerCase() ); this.shadowRoot.append(template.content.cloneNode(true)); } }); \u003c/script\u003e Forms with Shadow DOM Long story, cut short: maybe don’t create custom form controls as web components. We get a lot of free features and functionalities — including accessibility — with native form controls that we have to recreate from scratch if we decide to roll our own. In the case of forms, one of the oddities of encapsulation is that form submissions are not automatically connected. Let’s look at a broken form that contains a web component for a custom input: \u003cform\u003e \u003cmy-input\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003clabel\u003e \u003cslot\u003e\u003c/slot\u003e \u003cinput type=\"text\" name=\"your-name\"\u003e \u003c/label\u003e \u003c/template\u003e Type your name! \u003c/my-input\u003e \u003clabel\u003e\u003cinput type=\"checkbox\" name=\"remember\"\u003eRemember Me\u003c/label\u003e \u003cbutton\u003eSubmit\u003c/button\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].addEventListener('input', function(){ let data = new FormData(this); console.log(new URLSearchParams(data).toString()); }); \u003c/script\u003e This input’s value won’t be in the submission! Also, form validation and states are not communicated in the Shadow DOM. Similar connectivity issues with accessibility, where the shadow boundary can interfere with ARIA. For example, IDs are local to the Shadow DOM. Consider how much you really need the Shadow DOM when working with forms. Element internals The moral of the last section is to tread carefully when creating your own web components for form controls. Scott suggests avoiding that altogether, but he continued to demonstrate how we could theoretically fix functional and accessibility issues using element internals. Let’s start with an input value that will be included in the form submission. \u003cform\u003e \u003cmy-input name=\"name\"\u003e\u003c/my-input\u003e \u003cbutton\u003eSubmit\u003c/button\u003e \u003c/form\u003e Now let’s slot this imperatively: \u003cscript\u003e customElements.define('my-input', class extends HTMLElement { constructor() { super(); this.attachShadow({mode: 'open'}); this.shadowRoot.innerHTML = '\u003clabel\u003e\u003cslot\u003e\u003c/slot\u003e\u003cinput type=\"text\"\u003e\u003c/label\u003e' } }); \u003c/script\u003e The value is not communicated yet. We’ll add a static formAssociated variable with internals attached: \u003cscript\u003e customElements.define('my-input', class extends HTMLElement { static formAssociated = true; constructor() { super(); this.attachShadow({mode: 'open'}); this.shadowRoot.innerHTML = '\u003clabel\u003e\u003cslot\u003e\u003c/slot\u003e\u003cinput type=\"text\"\u003e\u003c/label\u003e' this.internals = this.attachedInternals(); } }); \u003c/script\u003e Then we’ll set the form value as part of the internals when the input’s value changes: \u003cscript\u003e customElements.define('my-input', class extends HTMLElement { static formAssociated = true; constructor() { super(); this.attachShadow({mode: 'open'}); this.shadowRoot.innerHTML = '\u003clabel\u003e\u003cslot\u003e\u003c/slot\u003e\u003cinput type=\"text\"\u003e\u003c/label\u003e' this.internals = this.attachedInternals(); this.addEventListener('input', () =\u003e { this-internals.setFormValue(this.shadowRoot.querySelector('input').value); }); } }); \u003c/script\u003e Here’s how we set states with element internals: // add a checked state this.internals.states.add(\"checked\"); // remove a checked state this.internals.states.delete(\"checked\"); Let’s toggle a “add” or “delete” a boolean state: \u003cform\u003e \u003cmy-check name=\"remember\"\u003eRemember Me?\u003c/my-check\u003e \u003c/form\u003e \u003cscript\u003e customElements.define('my-check', class extends HTMLElement { static formAssociated = true; constructor(){ super(); this.attachShadow({mode: 'open'}); this.shadowRoot.innerHTML = '\u003cslot\u003e\u003c/slot\u003e'; this.internals = this.attachInternals(); let addDelete = false; this.addEventListener(\"click\", ()=\u003e { addDelete = !addDelete; this.internals.states[addDelete ? \"add\" : \"delete\"](\"checked\"); } ); } }); \u003c/script\u003e Let’s refactor this for ARIA improvements: \u003cform\u003e \u003cstyle\u003e my-check { display: inline-block; inline-size: 1em; block-size: 1em; background: #eee; } my-check:state(checked)::before { content: \"[x]\"; } \u003c/style\u003e \u003cmy-check name=\"remember\" id=\"remember\"\u003e\u003c/my-check\u003e\u003clabel for=\"remember\"\u003eRemember Me?\u003c/label\u003e \u003c/form\u003e \u003cscript\u003e customElements.define('my-check', class extends HTMLElement { static formAssociated = true; constructor(){ super(); this.attachShadow({mode: 'open'}); this.internals = this.attachInternals(); this.internals.role = 'checkbox'; this.setAttribute('tabindex', '0'); let addDelete = false; this.addEventListener(\"click\", ()=\u003e { addDelete = !addDelete; this.internals.states[addDelete ? \"add\" : \"delete\"](\"checked\"); this[addDelete ? \"setAttribute\" : \"removeAttribute\"](\"aria-checked\", true); }); } }); \u003c/script\u003e Phew, that’s a lot of work! And sure, this gets us a lot closer to a more functional and accessible custom form input, but there’s still a long way’s to go to achieve what we already get for free from using native form controls. Always question whether you can rely on a light DOM form instead. Chapter 5: Styling Web Components Styling web components comes in levels of complexity. For example, we don’t need any JavaScript at all to slap a few styles on a custom element. \u003cmy-element theme=\"suave\" class=\"priority\"\u003e \u003ch1\u003eI'm in the Light DOM!\u003c/h1\u003e \u003c/my-element\u003e \u003cstyle\u003e /* Element, class, attribute, and complex selectors all work. */ my-element { display: block; /* custom elements are inline by default */ } .my-element[theme=suave] { color: #fff; } .my-element.priority { background: purple; } .my-element h1 { font-size: 3rem; } \u003c/style\u003e This is not encapsulated! This is scoped off of a single element just light any other CSS in the Light DOM. Changing the Shadow DOM mode from closed to open doesn’t change CSS. It allows JavaScript to pierce the Shadow DOM but CSS isn’t affected. Let’s poke at it \u003cstyle\u003e p { color: red; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cp\u003eHi\u003c/p\u003e \u003c/template\u003e \u003c/div\u003e \u003cp\u003eHi\u003c/p\u003e This is three stacked paragraphs, the second of which is in the shadow root. The first and third paragraphs are red; the second is not styled because it is in a \u003ctemplate\u003e, even if the shadow root’s mode is set to open. Let’s poke at it from the other direction: \u003cstyle\u003e p { color: red; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e p { color: blue;} \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003c/template\u003e \u003c/div\u003e \u003cp\u003eHi\u003c/p\u003e The first and third paragraphs are still receiving the red color from the Light DOM’s CSS. The \u003cstyle\u003e declarations in the \u003ctemplate\u003e are encapsulated and do not leak out to the other paragraphs, even though it is declared later in the cascade. Same idea, but setting the color on the \u003cbody\u003e: \u003cstyle\u003e body { color: red; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cp\u003eHi\u003c/p\u003e \u003c/template\u003e \u003c/div\u003e \u003cp\u003eHi\u003c/p\u003e Everything is red! This isn’t a bug. Inheritable styles do pass through the Shadow DOM barrier. Inherited styles are those that are set by the computed values of their parent styles. Many properties are inheritable, including color. The \u003cbody\u003e is the parent and everything in it is a child that inherits these styles, including custom elements. Let’s fight with inheritance We can target the paragraph in the \u003ctemplate\u003e style block to override the styles set on the \u003cbody\u003e. Those won’t leak back to the other paragraphs. \u003cstyle\u003e body { color: red; font-family: fantasy; font-size: 2em; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e /* reset the light dom styles */ p { color: initial; font-family: initial; font-size: initial; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003c/template\u003e \u003c/div\u003e \u003cp\u003eHi\u003c/p\u003e This is protected, but the problem here is that it’s still possible for a new role or property to be introduced that passes along inherited styles that we haven’t thought to reset. Perhaps we could use all: initital as a defensive strategy against future inheritable styles. But what if we add more elements to the custom element? It’s a constant fight. Host styles! We can scope things to the shadow root’s :host selector to keep things protected. \u003cstyle\u003e body { color: red; font-family: fantasy; font-size: 2em; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e /* reset the light dom styles */ :host { all: initial; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003ca href=\"#\"\u003eClick me\u003c/a\u003e \u003c/template\u003e \u003c/div\u003e \u003cp\u003eHi\u003c/p\u003e New problem! What if the Light DOM styles are scoped to the universal selector instead? \u003cstyle\u003e * { color: red; font-family: fantasy; font-size: 2em; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e /* reset the light dom styles */ :host { all: initial; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003ca href=\"#\"\u003eClick me\u003c/a\u003e \u003c/template\u003e \u003c/div\u003e \u003cp\u003eHi\u003c/p\u003e This breaks the custom element’s styles. But that’s because Shadow DOM styles are applied before Light DOM styles. The styles scoped to the universal selector are simply applied after the :host styles, which overrides what we have in the shadow root. So, we’re still locked in a brutal fight over inheritance and need stronger specificity. According to Scott, !important is one of the only ways we have to apply brute force to protect our custom elements from outside styles leaking in. The keyword gets a bad rap — and rightfully so in the vast majority of cases — but this is a case where it works well and using it is an encouraged practice. It’s not like it has an impact on the styles outside the custom element, anyway. \u003cstyle\u003e * { color: red; font-family: fantasy; font-size: 2em; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e /* reset the light dom styles */ :host { all: initial; !important } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003ca href=\"#\"\u003eClick me\u003c/a\u003e \u003c/template\u003e \u003c/div\u003e \u003cp\u003eHi\u003c/p\u003e Special selectors There are some useful selectors we have to look at components from the outside, looking in. :host() We just looked at this! But note how it is a function in addition to being a pseudo-selector. It’s sort of a parent selector in the sense that we can pass in the \u003cdiv\u003e that contains the \u003ctemplate\u003e and that becomes the scoping context for the entire selector, meaning the !important keyword is no longer needed. \u003cstyle\u003e * { color: red; font-family: fantasy; font-size: 2em; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e /* reset the light dom styles */ :host(div) { all: initial; } \u003c/style\u003e \u003cp\u003eHi\u003c/p\u003e \u003ca href=\"#\"\u003eClick me\u003c/a\u003e \u003c/template\u003e \u003c/div\u003e \u003cp\u003eHi\u003c/p\u003e :host-context() \u003cheader\u003e \u003cmy-element\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e :host-context(header) { ... } /* matches the host! */ \u003c/style\u003e \u003c/template\u003e \u003c/my-element\u003e \u003c/header\u003e This targets the shadow host but only if the provided selector is a parent node anywhere up the tree. This is super helpful for styling custom elements where the layout context might change, say, from being contained in an \u003carticle\u003e versus being contained in a \u003cheader\u003e. :defined Defining an element occurs when it is created, and this pseudo-selector is how we can select the element in that initially-defined state. I imagine this is mostly useful for when a custom element is defined imperatively in JavaScript so that we can target the very moment that the element is constructed, and then set styles right then and there. \u003cstyle\u003e simple-custom:defined { display: block; background: green; color: #fff; } \u003c/style\u003e \u003csimple-custom\u003e\u003c/simple-custom\u003e \u003cscript\u003e customElements.define('simple-custom', class extends HTMLElement { constructor(){ super(); this.attachShadow({mode: 'open'}); this.shadowRoot.innerHTML = \"\u003cp\u003eDefined!\u003c/p\u003e\"; } }); \u003c/script\u003e Minor note about protecting against a flash of unstyled content (FOUC)… or unstyled element in this case. Some elements are effectively useless until JavsScript has interacted with it to generate content. For example, an empty custom element that only becomes meaningful once JavaScript runs and generates content. Here’s how we can prevent the inevitable flash that happens after the content is generated: \u003cstyle\u003e js-dependent-element:not(:defined) { visibility: hidden; } \u003c/style\u003e \u003cjs-dependent-element\u003e\u003c/js-dependent-element\u003e Warning zone! It’s best for elements that are empty and not yet defined. If you’re working with a meaningful element up-front, then it’s best to style as much as you can up-front. Styling slots This does not style the paragraph green as you might expect: \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e p { color: green; } \u003c/style\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/template\u003e \u003cp\u003eSlotted Element\u003c/p\u003e \u003c/div\u003e The Shadow DOM cannot style this content directly. The styles would apply to a paragraph in the \u003ctemplate\u003e that gets rendered in the Light DOM, but it cannot style it when it is slotted into the \u003ctemplate\u003e. Slots are part of the Light DOM. So, this works: \u003cstyle\u003e p { color: green; } \u003c/style\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/template\u003e \u003cp\u003eSlotted Element\u003c/p\u003e \u003c/div\u003e This means that slots are easier to target when it comes to piercing the shadow root with styles, making them a great method of progressive style enhancement. We have another special selected, the ::slotted() pseudo-element that’s also a function. We pass it an element or class and that allows us to select elements from within the shadow root. \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e ::slotted(p) { color: red; } \u003c/style\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/template\u003e \u003cp\u003eSlotted Element\u003c/p\u003e \u003c/div\u003e Unfortunately, ::slotted() is a weak selected when compared to global selectors. So, if we were to make this a little more complicated by introducing an outside inheritable style, then we’d be hosed again. \u003cstyle\u003e /* global paragraph style... */ p { color: green; } \u003c/style\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e /* ...overrides the slotted style */ ::slotted(p) { color: red; } \u003c/style\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/template\u003e \u003cp\u003eSlotted Element\u003c/p\u003e \u003c/div\u003e This is another place where !important could make sense. It even wins if the global style is also set to !important. We could get more defensive and pass the universal selector to ::slotted and set everything back to its initial value so that all slotted content is encapsulated from outside styles leaking in. \u003cstyle\u003e /* global paragraph style... */ p { color: green; } \u003c/style\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e /* ...can't override this important statement */ ::slotted(*) { all: initial !important; } \u003c/style\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/template\u003e \u003cp\u003eSlotted Element\u003c/p\u003e \u003c/div\u003e Styling :parts A part is a way of offering up Shadow DOM elements to the parent document for styling. Let’s add a part to a custom element: \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cp part=\"hi\"\u003eHi there, I'm a part!\u003c/p\u003e \u003c/template\u003e \u003c/div\u003e Without the part attribute, there is no way to write styles that reach the paragraph. But with it, the part is exposed as something that can be styled. \u003cstyle\u003e ::part(hi) { color: green; } ::part(hi) b { color: green; } /* nope! */ \u003c/style\u003e \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cp part=\"hi\"\u003eHi there, I'm a \u003cb\u003epart\u003c/b\u003e!\u003c/p\u003e \u003c/template\u003e \u003c/div\u003e We can use this to expose specific “parts” of the custom element that are open to outside styling, which is almost like establishing a styling API with specifications for what can and can’t be styled. Just note that ::part cannot be used as part of a complex selector, like a descendant selector: A bit in the weeds here, but we can export parts in the sense that we can nest elements within elements within elements, and so on. This way, we include parts within elements. \u003cmy-component\u003e \u003c!-- exposes three parts to the nested component --\u003e \u003cnested-component exportparts=\"part1, part2, part5\"\u003e\u003c/nested-component\u003e \u003c/my-component\u003e Styling states and validity We discussed this when going over element internals in the chapter about the Shadow DOM. But it’s worth revisiting that now that we’re specifically talking about styling. We have a :state pseudo-function that accepts our defined states. \u003cscript\u003e this.internals.states.add(\"checked\"); \u003c/script\u003e \u003cstyle\u003e my-checkbox:state(checked) { /* ... */ } \u003c/style\u003e We also have access to the :invalid pseudo-class. Cross-barrier custom properties \u003cstyle\u003e :root { --text-primary: navy; --bg-primary: #abe1e1; --padding: 1.5em 1em; } p { color: var(--text-primary); background: var(--bg-primary); padding: var(--padding); } \u003c/style\u003e Custom properties cross the Shadow DOM barrier! \u003cmy-elem\u003e\u003c/my-elem\u003e \u003cscript\u003e customElements.define('my-elem', class extends HTMLElement { constructor(){ super(); this.attachShadow({mode: 'open'}); this.shadowRoot.innerHTML = ` \u003cstyle\u003e p { color: var(--text-primary); background: var(--bg-primary); padding: var(--padding); } \u003c/style\u003e \u003cp\u003eHi there!\u003c/p\u003e`; } }) \u003c/script\u003e Adding stylesheets to custom elements There’s the classic ol’ external \u003clink\u003e way of going about it: \u003csimple-custom\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003clink rel=\"stylesheet\" href=\"../../assets/external.css\"\u003e \u003cp\u003eThis one's in the shadow Dom.\u003c/p\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/template\u003e \u003cp\u003eSlotted \u003cb\u003eElement\u003c/b\u003e\u003c/p\u003e \u003c/simple-custom\u003e It might seem like an anti-DRY approach to call the same external stylesheet at the top of all web components. To be clear, yes, it is repetitive — but only as far as writing it. Once the sheet has been downloaded once, it is available across the board without any additional requests, so we’re still technically dry in the sense of performance. CSS imports also work: \u003cstyle\u003e @import url(\"../../assets/external.css\"); \u003c/style\u003e \u003csimple-custom\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e @import url(\"../../assets/external.css\"); \u003c/style\u003e \u003cp\u003eThis one's in the shadow Dom.\u003c/p\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/template\u003e \u003cp\u003eSlotted \u003cb\u003eElement\u003c/b\u003e\u003c/p\u003e \u003c/simple-custom\u003e One more way using a JavaScript-based approach. It’s probably better to make CSS work without a JavaScript dependency, but it’s still a valid option. \u003cmy-elem\u003e\u003c/my-elem\u003e \u003cscript type=\"module\"\u003e import sheet from '../../assets/external.css' with { type: 'css' }; customElements.define('my-elem', class extends HTMLElement { constructor(){ super(); this.attachShadow({mode: 'open'}); this.shadowRoot.innerHTML = '\u003cp\u003eHi there\u003c/p\u003e'; this.shadowRoot.adoptedStyleSheets = [sheet]; } }) \u003c/script\u003e We have a JavaScript module and import CSS into a string that is then adopted by the shadow root using shadowRoort.adoptedStyleSheets . And since adopted stylesheets are dynamic, we can construct one, share it across multiple instances, and update styles via the CSSOM that ripple across the board to all components that adopt it. Container queries! Container queries are nice to pair with components, as custom elements and web components are containers and we can query them and adjust things as the container changes. \u003cdiv\u003e \u003ctemplate shadowrootmode=\"open\"\u003e \u003cstyle\u003e :host { container-type: inline-size; background-color: tan; display: block; padding: 2em; } ul { display: block; list-style: none; margin: 0; } li { padding: .5em; margin: .5em 0; background-color: #fff; } @container (min-width: 50em) { ul { display: flex; justify-content: space-between; gap: 1em; } li { flex: 1 1 auto; } } \u003c/style\u003e \u003cul\u003e \u003cli\u003eFirst Item\u003c/li\u003e \u003cli\u003eSecond Item\u003c/li\u003e \u003c/ul\u003e \u003c/template\u003e \u003c/div\u003e In this example, we’re setting styles on the :host() to define a new container, as well as some general styles that are protected and scoped to the shadow root. From there, we introduce a container query that updates the unordered list’s layout when the custom element is at least 50em wide. Next up… How web component features are used together! Chapter 6: HTML-First Patterns In this chapter, Scott focuses on how other people are using web components in the wild and highlights a few of the more interesting and smart patterns he’s seen. Let’s start with a typical counter It’s often the very first example used in React tutorials. \u003ccounter-element\u003e\u003c/counter-element\u003e \u003cscript type=\"module\"\u003e customElements.define('counter-element', class extends HTMLElement { #count = 0; connectedCallback() { this.innerHTML = `\u003cbutton id=\"dec\"\u003e-\u003c/button\u003e\u003cp id=\"count\"\u003e${this.#count}\u003c/p\u003e\u003cbutton id=\"inc\"\u003e+\u003c/button\u003e`; this.addEventListener('click', e =\u003e this.update(e) ); } update(e) { if( e.target.nodeName !== 'BUTTON' ) { return } this.#count = e.target.id === 'inc' ? this.#count + 1 : this.#count - 1; this.querySelector('#count').textContent = this.#count; } }); \u003c/script\u003e Reef Reef is a tiny library by Chris Ferdinandi that weighs just 2.6KB minified and zipped yet still provides DOM diffing for reactive state-based UIs like React, which weighs significantly more. An example of how it works in a standalone way: \u003cdiv id=\"greeting\"\u003e\u003c/div\u003e \u003cscript type=\"module\"\u003e import {signal, component} from '.../reef.es..min.js'; // Create a signal let data = signal({ greeting: 'Hello', name: 'World' }); component('#greeting', () =\u003e `\u003cp\u003e${data.greeting}, ${data.name}!\u003c/p\u003e`); \u003c/script\u003e This sets up a “signal” that is basically a live-update object, then calls the component() method to select where we want to make the update, and it injects a template literal in there that passes in the variables with the markup we want. So, for example, we can update those values on setTimeout: \u003cdiv id=\"greeting\"\u003e\u003c/div\u003e \u003cscript type=\"module\"\u003e import {signal, component} from '.../reef.es..min.js'; // Create a signal let data = signal({ greeting: 'Hello', name: 'World' }); component('#greeting', () =\u003e `\u003cp\u003e${data.greeting}, ${data.name}!\u003c/p\u003e`); setTimeout(() =\u003e { data.greeting = '¡Hola' data,name = 'Scott' }, 3000) \u003c/script\u003e We can combine this sort of library with a web component. Here, Scott imports Reef and constructs the data outside the component so that it’s like the application state: \u003cmy-greeting\u003e\u003c/my-greeting\u003e \u003cscript type=\"module\"\u003e import {signal, component} from 'https://cdn.jsdelivr.net/npm/reefjs@13/dist/reef.es.min.js'; window.data = signal({ greeting: 'Hi', name: 'Scott' }); customElements.define('my-greeting', class extends HTMLElement { connectedCallback(){ component(this, () =\u003e `\u003cp\u003e${data.greeting}, ${data.name}!\u003c/p\u003e` ); } }); \u003c/script\u003e It’s the virtual DOM in a web component! Another approach that is more reactive in the sense that it watches for changes in attributes and then updates the application state in response which, in turn, updates the greeting. \u003cmy-greeting greeting=\"Hi\" name=\"Scott\"\u003e\u003c/my-greeting\u003e \u003cscript type=\"module\"\u003e import {signal, component} from 'https://cdn.jsdelivr.net/npm/reefjs@13/dist/reef.es.min.js'; customElements.define('my-greeting', class extends HTMLElement { static observedAttributes = [\"name\", \"greeting\"]; constructor(){ super(); this.data = signal({ greeting: '', name: '' }); } attributeChangedCallback(name, oldValue, newValue) { this.data[name] = newValue; } connectedCallback(){ component(this, () =\u003e `\u003cp\u003e${this.data.greeting}, ${this.data.name}!\u003c/p\u003e` ); } }); \u003c/script\u003e If the attribute changes, it only changes that instance. The data is registered at the time the component is constructed and we’re only changing string attributes rather than objects with properties. HTML Web Components This describes web components that are not empty by default like this: \u003cmy-greeting\u003e\u003c/my-greeting\u003e This is a “React” mindset where all the functionality, content, and behavior comes from JavaScript. But Scott reminds us that web components are pretty useful right out of the box without JavaScript. So, “HTML web components” refers to web components that are packed with meaningful content right out of the gate and Scott points to Jeremy Keith’s 2023 article coining the term. […] we could call them “HTML web components.” If your custom element is empty, it’s not an HTML web component. But if you’re using a custom element to extend existing markup, that’s an HTML web component. Jeremy cites something Robin Rendle mused about the distinction: […] I’ve started to come around and see Web Components as filling in the blanks of what we can do with hypertext: they’re really just small, reusable chunks of code that extends the language of HTML. The “React” way: \u003cUserAvatar src=\"https://example.com/path/to/img.jpg\" alt=\"...\" /\u003e The props look like HTML but they’re not. Instead, the props provide information used to completely swap out the \u003cUserAvatar /\u003e tag with the JavaScript-based markup. Web components can do that, too: \u003cuser-avatar src=\"https://example.com/path/to/img.jpg\" alt=\"...\" \u003e\u003c/user-avatar\u003e Same deal, real HTML. Progressive enhancement is at the heart of an HTML web component mindset. Here’s how that web component might work: class UserAvatar extends HTMLElement { connectedCallback() { const src = this.getAttribute(\"src\"); const name = this.getAttribute(\"name\"); this.innerHTML = ` \u003cdiv\u003e \u003cimg src=\"${src}\" alt=\"Profile photo of ${name}\" width=\"32\" height=\"32\" /\u003e \u003c!-- Markup for the tooltip --\u003e \u003c/div\u003e `; } } customElements.define('user-avatar', UserAvatar); But a better starting point would be to include the \u003cimg\u003e directly in the component so that the markup is immediately available: \u003cuser-avatar\u003e \u003cimg src=\"https://example.com/path/to/img.jpg\" alt=\"...\" /\u003e \u003c/user-avatar\u003e This way, the image is downloaded and ready before JavaScript even loads on the page. Strive for augmentation over replacement! resizeasaurus This helps developers test responsive component layouts, particularly ones that use container queries. \u003cresize-asaurus\u003e Drop any HTML in here to test. \u003c/resize-asaurus\u003e \u003c!-- for example: --\u003e \u003cresize-asaurus\u003e \u003cdiv class=\"my-responsive-grid\"\u003e \u003cdiv\u003eCell 1\u003c/div\u003e \u003cdiv\u003eCell 2\u003c/div\u003e \u003cdiv\u003eCell 3\u003c/div\u003e \u003c!-- ... --\u003e \u003c/div\u003e \u003c/resize-asaurus\u003e lite-youtube-embed This is like embedding a YouTube video, but without bringing along all the baggage that YouTube packs into a typical embed snippet. \u003clite-youtube videoid=\"ogYfd705cRs\" style=\"background-image: url(...);\"\u003e \u003ca href=\"https://youtube.com/watch?v=ogYfd705cRs\" class=\"lyt-playbtn\" title=\"Play Video\"\u003e \u003cspan class=\"lyt-visually-hidden\"\u003ePlay Video: Keynote (Google I/O '18)\u003c/span\u003e \u003c/a\u003e \u003c/lite-youtube\u003e \u003clink rel=\"stylesheet\" href=\"./src.lite-yt-embed.css\" /\u003e \u003cscript src=\"./src.lite-yt-embed.js\" defer\u003e\u003c/script\u003e It starts with a link which is a nice fallback if the video fails to load for whatever reason. When the script runs, the HTML is augmented to include the video \u003ciframe\u003e. Chapter 7: Web Components Frameworks Tour Lit Lit extends the base class and then extends what that class provides, but you’re still working directly on top of web components. There are syntax shortcuts for common patterns and a more structured approach. The package includes all this in about 5-7KB: Fast templating Reactive properties Reactive update lifecycle Scoped styles \u003csimple-greeting name=\"Geoff\"\u003e\u003c/simple-greeting\u003e \u003cscript\u003e import {html, css, LitElement} from 'lit'; export class SimpleGreeting extends LitElement { state styles = css`p { color: blue }`; static properties = { name: {type = String}, }; constructor() { super(); this.name = 'Somebody'; } render() { return html`\u003cp\u003eHello, ${this.name}!\u003c/p\u003e`; } } customElements.define('simple-greeting', SimpleGreeting); \u003c/script\u003e ProsConsEcosystemNo official SSR story (but that is changing)CommunityFamiliar ergonomicsLightweightIndustry-proven webc This is part of the 11ty project. It allows you to define custom elements as files, writing everything as a single file component. \u003c!-- starting element / index.html --\u003e \u003cmy-element\u003e\u003c/my-element\u003e \u003c!-- ../components/my-element.webc --\u003e \u003cp\u003eThis is inside the element\u003c/p\u003e \u003cstyle\u003e /* etc. */ \u003c/style\u003e \u003cscript\u003e // etc. \u003c/script\u003e ProsConsCommunityGeared toward SSGSSG progressive enhancementStill in early stagesSingle file component syntaxZach Leatherman! Enhance This is Scott’s favorite! It renders web components on the server. Web components can render based on application state per request. It’s a way to use custom elements on the server side.  ProsConsErgonomicsStill in early stagesProgressive enhancementSingle file component syntaxFull-stack stateful, dynamic SSR components Chapter 8: Web Components Libraries Tour This is a super short module simply highlighting a few of the more notable libraries for web components that are offered by third parties. Scott is quick to note that all of them are closer in spirit to a React-based approach where custom elements are more like replaced elements with very little meaningful markup to display up-front. That’s not to throw shade at the libraries, but rather to call out that there’s a cost when we require JavaScript to render meaningful content. Spectrum \u003csp-button variant=\"accent\" href=\"components/button\"\u003e Use Spectrum Web Component buttons \u003c/sp-button\u003e This is Adobe’s design system. One of the more ambitious projects, as it supports other frameworks like React Open source Built on Lit Most components are not exactly HTML-first. The pattern is closer to replaced elements. There’s plenty of complexity, but that makes sense for a system that drives an application like Photoshop and is meant to drop into any project. But still, there is a cost when it comes to delivering meaningful content to users up-front. An all-or-nothing approach like this might be too stark for a small website project. FAST \u003cfast-checkbox\u003eCheckbox\u003c/fast-checkbox\u003e This is Microsoft’s system. It’s philosophically like Spectrum where there’s very little meaningful HTML up-front. Fluent is a library that extends the system for UI components. Microsoft Edge rebuilt the browser’s Chrome using these components. Shoelace \u003csl-button\u003eClick Me\u003c/sl-button\u003e Purely meant for third-party developers to use in their projects The name is a play on Bootstrap. 🙂 The markup is mostly a custom element with some text in it rather than a pure HTML-first approach. Acquired by Font Awesome and they are creating Web Awesome Components as a new era of Shoelace that is subscription-based Chapter 9: What’s Next With Web Components Scott covers what the future holds for web components as far as he is aware. Declarative custom elements Define an element in HTML alone that can be used time and again with a simpler syntax. There’s a GitHub issue that explains the idea, and Zach Leatherman has a great write-up as well. Cross-root ARIA Make it easier to pair custom elements with other elements in the Light DOM as well as other custom elements through ARIA. Container Queries How can we use container queries without needing an extra wrapper around the custom element? HTML Modules This was one of the web components’ core features but was removed at some point. They can define HTML in an external place that could be used over and over. External styling This is also known as “open styling.” DOM Parts This would be a templating feature that allows for JSX-string-literal-like syntax where variables inject data. \u003csection\u003e \u003ch1 id=\"name\"\u003e{name}\u003c/h1\u003e Email: \u003ca id=\"link\" href=\"mailto:{email}\"\u003e{email}\u003c/a\u003e \u003c/section\u003e And the application has produced a template with the following content: \u003ctemplate\u003e \u003csection\u003e \u003ch1 id=\"name\"\u003e{{}}\u003c/h1\u003e Email: \u003ca id=\"link\" href=\"{{}}\"\u003e{{}}\u003c/a\u003e \u003c/section\u003e \u003c/template\u003e Scoped element registries Using variations of the same web component without name collisions.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/web-components-demystified.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eScott Jehl released a course called \u003cem\u003e\u003ca href=\"https://scottjehl.com/learn/webcomponentsdemystified/\" rel=\"noopener\"\u003eWeb Components Demystified\u003c/a\u003e\u003c/em\u003e. I love that name because it says what the course is about right on the tin: you’re going to learn about web components and clear up any confusion you may already have about them.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnd there’s plenty of confusion to go around! “Components” is already a loaded term that’s come to mean everything from a piece of UI, like a search component, to an element you can drop in and reuse anywhere, such as a React component. The web is chock-full of components, tell you what.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut what we’re talking about here is a set of standards where HTML, CSS, and JavaScript rally together so that we can create custom elements that behave exactly how we want them to. It’s how we can make an element called \u003ccode\u003e\u0026lt;tasty-pizza\u0026gt;\u003c/code\u003e and the browser knows what to do with it.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is my full set of notes from Scott’s course. I wouldn’t say they’re complete or even a direct one-to-one replacement for watching the course. You’ll still want to do that on your own, and I encourage you to because Scott is an excellent teacher who makes all of this stuff extremely accessible, even to noobs like me.\u003c/p\u003e\n\n\n\n\u003cdetails\u003e\n  \u003csummary\u003e\n          \u003ch2\u003eChapter 1: What Web Components Are… and Aren’t\u003c/h2\u003e\n      \u003c/summary\u003e\n  \n\n\u003cp\u003eWeb components are not built-in elements, even though that’s what they might look like at first glance. Rather, they are a set of technologies that allow us to instruct what the element is and how it behaves. Think of it the same way that “responsive web design” is not a thing but rather a set of strategies for adapting design to different web contexts. So, just as \u003ca href=\"https://alistapart.com/article/responsive-web-design/#section7\" rel=\"noopener\"\u003eresponsive web design is a set of ingredients\u003c/a\u003e — including media fluid grids, flexible images, and media queries — web components are a concoction involving:\u003c/p\u003e\n\n\n\n\u003cdetails\u003e\u003csummary\u003eCustom elements\u003c/summary\u003e\n\u003cp\u003eThese are HTML elements that are not built into the browser. We make them up. They include a letter and a dash.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-fancy-heading\u0026gt;\n  Hey, I\u0026#39;m Fancy\n\u0026lt;/my-fancy-heading\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe’ll go over these in greater detail in the next module.\u003c/p\u003e\n\u003c/details\u003e\n\n\n\n\u003cdetails\u003e\u003csummary\u003eHTML templates\u003c/summary\u003e\n\u003cp\u003eTemplates are bits of reusable markup that generate more markup. We can hide something until we make use of it. \u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;template\u0026gt;\n  \u0026lt;li class=\u0026#34;user\u0026#34;\u0026gt;\n    \u0026lt;h2 class=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt;\n    \u0026lt;p class=\u0026#34;bio\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\n  \u0026lt;/li\u0026gt;\n\u0026lt;/template\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eMuch more on this in the third module.\u003c/p\u003e\n\u003c/details\u003e\n\n\n\n\u003cdetails\u003e\u003csummary\u003eShadow DOM\u003c/summary\u003e\n\u003cp\u003eThe DOM is queryable.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003edocument.querySelector(\u0026#34;h1\u0026#34;);\n// \u0026lt;h1\u0026gt;Hello, World\u0026lt;/h1\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe Shadow DOM is a fragment of the DOM where markup, scripts, and styles are encapsulated from other DOM elements. We’ll cover this in the fourth module, including how to \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e content.\u003c/p\u003e\n\u003c/details\u003e\n\n\n\n\u003cp\u003eThere used to be a fourth “ingredient” called HTML Imports, but those have been nixed.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn short, web components might be called “components” but they aren’t really components more than technologies. In React, components sort of work like partials. It defines a snippet of HTML that you drop into your code and it outputs in the DOM. Web Components are built off of HTML Elements. They are not replaced when rendered the way they are in JavaScript component frameworks. Web components are quite literally HTML elements and have to obey HTML rules. For example:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;!-- Nope --\u0026gt;\n\u0026lt;ul\u0026gt;\n  \u0026lt;my-list-item\u0026gt;\u0026lt;/my-list-item\u0026gt;\n  \u0026lt;!-- etc. --\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;!-- Yep --\u0026gt;\n\u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\n    \u0026lt;my-list-item\u0026gt;\u0026lt;/my-list-item\u0026gt;\n  \u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe’re generating meaningful HTML up-front rather than rendering it in the browser through the client after the fact. Provide the markup and enhance it! Web components have been around a while now, even if it seems we’re only starting to talk about them now.\u003c/p\u003e\n\n\n\u003c/details\u003e\n\n\n\u003cdetails\u003e\n  \u003csummary\u003e\n          \u003ch2\u003eChapter 2: Custom Elements\u003c/h2\u003e\n      \u003c/summary\u003e\n  \n\n\u003cp\u003eFirst off, custom elements are not built-in HTML elements. We instruct what they are and how they behave.  They are named with a dash and at must contain least one letter. All of the following are valid names for custom elements:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;super-component\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e\u0026lt;a-\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e\u0026lt;a-4-\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e\u0026lt;card-10.0.1\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e\u0026lt;card-♠️\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eJust remember that there are some reserved names for MathML and SVG elements, like \u003ccode\u003e\u0026lt;font-face\u0026gt;\u003c/code\u003e. Also, they cannot be void elements, e.g. \u003ccode\u003e\u0026lt;my-element /\u0026gt;\u003c/code\u003e, meaning they have to have a correspoonding closing tag.\u003c/p\u003e\n\n\n\n\u003cp\u003eSince custom elements are not built-in elements, they are undefined by default — and being undefined can be a useful thing! That means we can use them as containers with default properties. For example, they are \u003ccode\u003edisplay: inline\u003c/code\u003e by default and inherit the current \u003ccode\u003efont-family\u003c/code\u003e, which can be useful to pass down to the contents. We can also use them as styling hooks since they can be selected in CSS. Or maybe they can be used for accessibility hints. The bottom line is that they do not require JavaScript in order to make them immediately useful.\u003c/p\u003e\n\n\n\n\u003cp\u003eWorking with JavaScript. If there is one \u003ccode\u003e\u0026lt;my-button\u0026gt;\u003c/code\u003e on the page, we can query it and set a click handler on it with an event listener. But if we were to insert more instances on the page later, we would need to query it when it’s appended and re-run the function since it is not part of the original document rendering.\u003c/p\u003e\n\n\n\u003ch3 id=\"defining-a-custom-element\"\u003eDefining a custom element\u003c/h3\u003e\n\n\n\u003cp\u003eThis defines and registers the custom element. It teaches the browser that this is an instance of the Custom Elements API and extends the same class that makes other HTML elements valid HTML elements:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-element\u0026gt;My Element\u0026lt;/my-element\u0026gt;\n\n\u0026lt;script\u0026gt;\n  customElements.define(\u0026#34;my-element\u0026#34;, class extends HTMLElement {});\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eCheck out the methods we get immediate access to:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"2058\" height=\"912\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-13-at-11.22.04%E2%80%AFAM.png?resize=2058%2C912\u0026amp;ssl=1\" alt=\"Showing the prototype methods and properties of a custom element in DevTools, including define, get, getName, upgrade, and whenDefined.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-13-at-11.22.04%E2%80%AFAM.png?w=2058\u0026amp;ssl=1 2058w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-13-at-11.22.04%E2%80%AFAM.png?resize=300%2C133\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-13-at-11.22.04%E2%80%AFAM.png?resize=1024%2C454\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-13-at-11.22.04%E2%80%AFAM.png?resize=768%2C340\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-13-at-11.22.04%E2%80%AFAM.png?resize=1536%2C681\u0026amp;ssl=1 1536w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-13-at-11.22.04%E2%80%AFAM.png?resize=2048%2C908\u0026amp;ssl=1 2048w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\u003ch3 id=\"breaking-down-the-syntax\"\u003eBreaking down the syntax\u003c/h3\u003e\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ecustomElements\n  .define(\n    \u0026#34;my-element\u0026#34;,\n    class extends HTMLElement {}\n  );\n\t\n// Functionally the same as:\nclass MyElement extends HTMLElement {}\ncustomElements.define(\u0026#34;my-element\u0026#34;, MyElement);\nexport default myElement\n\n// ...which makes it importable by other elements:\nimport MyElement from \u0026#39;./MyElement.js\u0026#39;;\nconst myElement = new MyElement();\ndocument.body.appendChild(myElement);\n\n// \u0026lt;body\u0026gt;\n//   \u0026lt;my-element\u0026gt;\u0026lt;/my-element\u0026gt;\n// \u0026lt;/body\u0026gt;\n\n// Or simply pull it into a page\n// Don\u0026#39;t need to `export default` but it doesn\u0026#39;t hurt to leave it\n// \u0026lt;my-element\u0026gt;My Element\u0026lt;/my-element\u0026gt;\n// \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;my-element.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIt’s possible to define a custom element by extending a specific HTML element. The specification documents this, but Scott is focusing on the primary way.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclass WordCount extends HTMLParagraphElement\ncustomElements.define(\u0026#34;word-count\u0026#34;, WordCount, { extends: \u0026#34;p\u0026#34; });\n\n// \u0026lt;p is=\u0026#34;word-count\u0026#34;\u0026gt;This is a custom paragraph!\u0026lt;/p\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eScott says do not use this because WebKit is not going to implement it. We would have to polyfill it forever, or as long as WebKit holds out. Consider it a dead end.\u003c/p\u003e\n\n\n\u003ch3 id=\"the-lifecycle\"\u003eThe lifecycle\u003c/h3\u003e\n\n\n\u003cp\u003eA component has various moments in its “life” span:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eConstructed (\u003ccode\u003econstructor\u003c/code\u003e)\u003c/li\u003e\n\n\n\n\u003cli\u003eConnected (\u003ccode\u003econnectedCallback\u003c/code\u003e)\u003c/li\u003e\n\n\n\n\u003cli\u003eAdopted (\u003ccode\u003eadoptedCallback\u003c/code\u003e)\u003c/li\u003e\n\n\n\n\u003cli\u003eAttribute Changed (\u003ccode\u003eattributeChangedCallback\u003c/code\u003e)\u003c/li\u003e\n\n\n\n\u003cli\u003eDisconnected (\u003ccode\u003edisconnectedCallback\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWe can hook into these to define the element’s behavior.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclass myElement extends HTMLElement {\n  constructor() {}\n  connectedCallback() {}\n  adoptedCallback() {}\n  attributeChangedCallback() {}\n  disconnectedCallback() {}\n}\n\ncustomElements.define(\u0026#34;my-element\u0026#34;, MyElement);\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch4 id=\"constructor\"\u003e\u003ccode\u003econstructor()\u003c/code\u003e\u003c/h4\u003e\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclass myElement extends HTMLElement {\n  constructor() {\n    // provides us with the `this` keyword\n    super()\n    \n    // add a property\n    this.someProperty = \u0026#34;Some value goes here\u0026#34;;\n    // add event listener\n    this.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; {});\n  }\n}\n\ncustomElements.define(\u0026#34;my-element\u0026#34;, MyElement);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e“When the constructor is called, do this…” We don’t have to have a constructor when working with custom elements, but if we do, then we need to call \u003ccode\u003esuper()\u003c/code\u003e because we’re extending another class and we’ll get all of those properties.\u003c/p\u003e\n\n\n\n\u003cp\u003eConstructor is useful, but not for a lot of things. It’s useful for setting up initial state, registering default properties, adding event listeners, and even creating Shadow DOM (which Scott will get into in a later module). For example, we are unable to sniff out whether or not the custom element is in another element because we don’t know anything about its parent container yet (that’s where other lifecycle methods come into play) — we’ve merely defined it.\u003c/p\u003e\n\n\n\u003ch4 id=\"connectedcallback\"\u003e\u003ccode\u003econnectedCallback()\u003c/code\u003e\u003c/h4\u003e\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclass myElement extends HTMLElement {\n  // the constructor is unnecessary in this example but doesn\u0026#39;t hurt.\n  constructor() {\n    super()\n  }\n  // let me know when my element has been found on the page.\n  connectedCallback() {\n    console.log(`${this.nodeName} was added to the page.`);\n  }\n}\n\ncustomElements.define(\u0026#34;my-element\u0026#34;, MyElement);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNote that there is some strangeness when it comes to timing things. Sometimes \u003ccode\u003eisConnected\u003c/code\u003e returns \u003ccode\u003etrue\u003c/code\u003e during the constructor. \u003ccode\u003econnectedCallback()\u003c/code\u003e is our best way to know when the component is found on the page. This is the moment it is connected to the DOM. Use it to attach event listeners.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf the \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e tag comes before the DOM is parsed, then it might not recognize \u003ccode\u003echildNodes\u003c/code\u003e. This is not an uncommon situation. But if we add \u003ccode\u003etype=\u0026#34;module\u0026#34;\u003c/code\u003e to the \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e, then the script is deferred and we get the child nodes. Using \u003ccode\u003esetTimeout\u003c/code\u003e can also work, but it looks a little gross.\u003c/p\u003e\n\n\n\u003ch4 id=\"disconnectedcallback\"\u003e\u003ccode\u003edisconnectedCallback\u003c/code\u003e\u003c/h4\u003e\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclass myElement extends HTMLElement {\n  // let me know when my element has been found on the page.\n  disconnectedCallback() {\n    console.log(`${this.nodeName} was removed from the page.`);\n  }\n}\n\ncustomElements.define(\u0026#34;my-element\u0026#34;, MyElement);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is useful when the component needs to be cleaned up, perhaps like stopping an animation or preventing memory links.\u003c/p\u003e\n\n\n\u003ch4 id=\"adoptedcallback\"\u003e\u003ccode\u003eadoptedCallback()\u003c/code\u003e\u003c/h4\u003e\n\n\n\u003cp\u003eThis is when the component is adopted by another document or page. Say you have some iframes on a page and move a custom element from the page into an iframe, then it would be adopted in that scenario. It would be created, then added, then removed, then adopted, then added again. That’s a full lifecycle! This callback is adopted automatically simply by picking it up and dragging it between documents in the DOM.\u003c/p\u003e\n\n\n\u003ch3 id=\"custom-elements-and-attributes\"\u003eCustom elements and attributes\u003c/h3\u003e\n\n\n\u003cp\u003eUnlike React, HTML attributes are strings (not props!). Global attributes work as you’d expect, though some global attributes are reflected as properties. You can make any attribute do that if you want, just be sure to use care and caution when naming because, well, we don’t want any conflicts.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"1024\" height=\"485\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-23-at-9.02.01%E2%80%AFAM.png?resize=1024%2C485\u0026amp;ssl=1\" alt=\"A list od global property names, such as hidden, ID, and style.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-23-at-9.02.01%E2%80%AFAM.png?resize=1024%2C485\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-23-at-9.02.01%E2%80%AFAM.png?resize=300%2C142\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-23-at-9.02.01%E2%80%AFAM.png?resize=768%2C364\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-23-at-9.02.01%E2%80%AFAM.png?resize=1536%2C727\u0026amp;ssl=1 1536w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-23-at-9.02.01%E2%80%AFAM.png?w=2006\u0026amp;ssl=1 2006w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAvoid standard attributes on a custom element as well, as that can be confusing particularly when handing a component to another developer. Example: using type as an attribute which is also used by \u003ccode\u003e\u0026lt;input\u0026gt;\u003c/code\u003e elements. We could say \u003ccode\u003edata-type\u003c/code\u003e instead. (Remember that Chris has a \u003ca href=\"https://css-tricks.com/a-complete-guide-to-data-attributes/\"\u003ecomprehensive guide on using data attributes\u003c/a\u003e.)\u003c/p\u003e\n\n\n\u003ch3 id=\"examples\"\u003eExamples\u003c/h3\u003e\n\n\n\u003cp\u003eHere’s a quick example showing how to get a \u003ccode\u003egreeting\u003c/code\u003e attribute and set it on the custom element:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclass MyElement extends HTMLElement {\n  get greeting() {\n    return this.getAttribute(\u0026#39;greeting\u0026#39;);\n    // return this.hasAttribute(\u0026#39;greeting\u0026#39;);\n  }\n  set greeting(val) {\n    if(val) {\n      this.setAttribute(\u0026#39;greeting\u0026#39;, val);\n      // this setAttribute(\u0026#39;greeting\u0026#39;, \u0026#39;\u0026#39;);\n    } else {\n      this.removeAttribute(\u0026#39;greeting\u0026#39;);\n    }\n  }\n}\ncustomElements.define(\u0026#34;my-element\u0026#34;, MyElement);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnother example, this time showing a callback for when the attribute has changed, which prints it in the element’s contents:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-element greeting=\u0026#34;hello\u0026#34;\u0026gt;hello\u0026lt;/my-element\u0026gt;\n\n\u0026lt;!-- Change text greeting when attribite greeting changes  --\u0026gt;\n\u0026lt;script\u0026gt;\n  class MyElement extends HTMLElement {\n    static observedAttributes = [\u0026#34;greeting\u0026#34;];\n  \n    attributeChangedCallback(name, oldValue, newValue) {\n      if (name === \u0026#39;greeting\u0026#39; \u0026amp;\u0026amp; oldValue \u0026amp;\u0026amp; oldValue !== newValue) {\n        console.log(name + \u0026#34; changed\u0026#34;);\n        this.textContent = newValue;\n      }\n    }\n  }\n  \n  customElements.define(\u0026#34;my-element\u0026#34;, MyElement);\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eA few more custom element methods:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ecustomElements.get(\u0026#39;my-element\u0026#39;);\n// returns MyElement Class\n\ncustomElements.getName(MyElement);\n// returns \u0026#39;my-element\u0026#39;\n\ncustomElements.whenDefined(\u0026#34;my-element\u0026#34;);\n// waits for custom element to be defined\n\nconst el = document.createElement(\u0026#34;spider-man\u0026#34;);\nclass SpiderMan extends HTMLElement {\n  constructor() {\n    super();\n    console.log(\u0026#34;constructor!!\u0026#34;);\n  }\n}\ncustomElements.define(\u0026#34;spider-man\u0026#34;, SpiderMan);\n\ncustomElements.upgrade(el);\n// returns \u0026#34;constructor!!\u0026#34;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eCustom methods and events:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-element\u0026gt;\u0026lt;button\u0026gt;My Element\u0026lt;/button\u0026gt;\u0026lt;/my-element\u0026gt;\n\n\u0026lt;script\u0026gt;\n  customElements.define(\u0026#34;my-element\u0026#34;, class extends HTMLElement {\n    connectedCallback() {\n      const btn = this.firstElementChild;\n      btn.addEventListener(\u0026#34;click\u0026#34;, this.handleClick)\n    }\n    handleClick() {\n      console.log(this);\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBring your own base class, in the same way web components frameworks like Lit do:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclass BaseElement extends HTMLElement {\n  $ = this.querySelector;\n}\n// extend the base, use its helper\nclass myElement extends BaseElement {\n  firstLi = this.$(\u0026#34;li\u0026#34;);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"practice-prompt\"\u003ePractice prompt\u003c/h3\u003e\n\n\n\u003cp\u003eCreate a custom HTML element called \u003ccode\u003e\u0026lt;say-hi\u0026gt;\u003c/code\u003e that displays the text “Hi, World!” when added to the page:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eEnhance the element to accept a \u003ccode\u003ename\u003c/code\u003e attribute, displaying \u003ccode\u003e\u0026#34;Hi, [Name]!\u0026#34;\u003c/code\u003e instead:\u003c/p\u003e\n\n\n\n\n\n\n\u003c/details\u003e\n\n\n\u003cdetails\u003e\n  \u003csummary\u003e\n          \u003ch2\u003eChapter 3: HTML Templates\u003c/h2\u003e\n      \u003c/summary\u003e\n  \n\n\u003cp\u003eThe \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e element is not for users but developers. It is not exposed visibly by browsers.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;template\u0026gt;The browser ignores everything in here.\u0026lt;/template\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTemplates are designed to hold HTML fragments:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;template\u0026gt;\n  \u0026lt;div class=\u0026#34;user-profile\u0026#34;\u0026gt;\n    \u0026lt;h2 class=\u0026#34;name\u0026#34;\u0026gt;Scott\u0026lt;/h2\u0026gt;\n    \u0026lt;p class=\u0026#34;bio\u0026#34;\u0026gt;Author\u0026lt;/p\u0026gt;\n  \u0026lt;/div\u0026gt;\n\u0026lt;/template\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eA template is selectable in CSS; it just doesn’t render. It’s a document fragment. The inner document is a \u003ccode\u003e#document-fragment\u003c/code\u003e. Not sure why you’d do this, but it illustrates the point that templates are selectable:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003etemplate { display: block; }` /* Nope */\ntemplate + div { height: 100px; width: 100px; }  /* Works */\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"the-content-property\"\u003eThe \u003ccode\u003econtent\u003c/code\u003e property\u003c/h3\u003e\n\n\n\u003cp\u003eNo, not in CSS, but JavaScript. We can query the inner contents of a template and print them somewhere else.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;template\u0026gt;\n  \u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n\u0026lt;/template\u0026gt;\n\n\u0026lt;script\u0026gt;\n  const myTmpl = documenty.querySelector(\u0026#34;template\u0026#34;).content;\n  console.log(myTmpl);\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"using-a-document-fragment-without-anbsplttemplategt\"\u003eUsing a Document Fragment without a \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst myFrag = document.createDocumentFragment();\nmyFrag.innerHTML = \u0026#34;\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\u0026#34;; // Nope\n\nconst myP = document.createElement(\u0026#34;p\u0026#34;); // Yep\nmyP.textContent = \u0026#34;Hi!\u0026#34;;\nmyFrag.append(myP);\n\n// use the fragment\ndocument.body.append(myFrag);\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"clone-a-node\"\u003eClone a node\u003c/h3\u003e\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;template\u0026gt;\n  \u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n\u0026lt;/template\u0026gt;\n\n\u0026lt;script\u0026gt;\n  const myTmpl = documenty.querySelector(\u0026#34;template\u0026#34;).content;\n  console.log(myTmpl);\n  \n  // Oops, only works one time! We need to clone it.\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOops, the component only works one time! We need to clone it if we want multiple instances:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;template\u0026gt;\n  \u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n\u0026lt;/template\u0026gt;\n\n\u0026lt;script\u0026gt;\n  const myTmpl = document.querySelector(\u0026#34;template\u0026#34;).content;\n  document.body.append(myTmpl.cloneNode(true)); // true is necessary\n  document.body.append(myTmpl.cloneNode(true));\n  document.body.append(myTmpl.cloneNode(true));\n  document.body.append(myTmpl.cloneNode(true));\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"a-more-practical-example\"\u003eA more practical example\u003c/h3\u003e\n\n\n\u003cp\u003eLet’s stub out a template for a list item and then insert them into an unordered list:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;template id=\u0026#34;tmpl-user\u0026#34;\u0026gt;\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;/strong\u0026gt;: \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;/template\u0026gt;\n\n\u0026lt;ul id=\u0026#34;users\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt;\n\n\u0026lt;script\u0026gt;\n  const usersElement = document.querySelector(\u0026#34;#users\u0026#34;);\n  const userTmpl = document.querySelector(\u0026#34;#tmpl-user\u0026#34;).content;\n  const users = [{name: \u0026#34;Bob\u0026#34;, title: \u0026#34;Artist\u0026#34;}, {name: \u0026#34;Jane\u0026#34;, title: \u0026#34;Doctor\u0026#34;}];\n  users.forEach(user =\u0026gt; {\n    let thisLi = userTmpl.cloneNode(true);\n    thisLi.querySelector(\u0026#34;strong\u0026#34;).textContent = user.name;\n    thisLi.querySelector(\u0026#34;span\u0026#34;).textContent = user.title;\n    usersElement.append(thisLi);\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eThe other way to use templates that we’ll get to in the next module: \u003cstrong\u003eShadow DOM\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;template shadowroot=open\u0026gt;\n  \u0026lt;p\u0026gt;Hi, I\u0026#39;m in the Shadow DOM\u0026lt;/p\u0026gt;\n\u0026lt;/template\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003c/details\u003e\n\n\n\u003cdetails\u003e\n  \u003csummary\u003e\n          \u003ch2\u003eChapter 4: Shadow DOM\u003c/h2\u003e\n      \u003c/summary\u003e\n  \n\n\u003cp\u003eHere we go, this is a heady chapter! The Shadow DOM reminds me of playing bass in a band: it’s easy to understand but incredibly difficult to master. It’s easy to understand that there are these nodes in the DOM that are encapsulated from everything else. They’re there, we just can’t really touch them with regular CSS and JavaScript without some finagling. It’s the finagling that’s difficult to master. There are times when the Shadow DOM is going to be your best friend because it prevents outside styles and scripts from leaking in and mucking things up. Then again, you’re most certainly going go want to style or apply scripts to those nodes and you have to figure that part out.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat’s where web components really shine. We get the benefits of an element that’s encapsulated from outside noise but we’re left with the responsibility of defining everything for it ourselves.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"1740\" height=\"988\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.37.56%E2%80%AFPM.png?resize=1740%2C988\u0026amp;ssl=1\" alt=\"Inspecting a select element in DevTools, showing the Shadow DOM nodes in the inspector.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.37.56%E2%80%AFPM.png?w=1740\u0026amp;ssl=1 1740w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.37.56%E2%80%AFPM.png?resize=300%2C170\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.37.56%E2%80%AFPM.png?resize=1024%2C581\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.37.56%E2%80%AFPM.png?resize=768%2C436\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.37.56%E2%80%AFPM.png?resize=1536%2C872\u0026amp;ssl=1 1536w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003cfigcaption\u003eSelect elements are a great example of the Shadow DOM. Shadow roots! Slots! They’re all part of the puzzle.\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\u003ch3 id=\"using-the-shadow-dom\"\u003eUsing the Shadow DOM\u003c/h3\u003e\n\n\n\u003cp\u003eWe covered the \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e element in the last chapter and determined that it renders in the Shadow DOM without getting displayed on the page.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;template shadowrootmode=\u0026#34;closed\u0026#34;\u0026gt;\n  \u0026lt;p\u0026gt;This will render in the Shadow DOM.\u0026lt;/p\u0026gt;\n\u0026lt;/template\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1724\" height=\"828\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.41.24%E2%80%AFPM.png?resize=1724%2C828\u0026amp;ssl=1\" alt=\"A template revealed in the DevTools Elements inspector based on the last code example.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.41.24%E2%80%AFPM.png?w=1724\u0026amp;ssl=1 1724w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.41.24%E2%80%AFPM.png?resize=300%2C144\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.41.24%E2%80%AFPM.png?resize=1024%2C492\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.41.24%E2%80%AFPM.png?resize=768%2C369\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-28-at-12.41.24%E2%80%AFPM.png?resize=1536%2C738\u0026amp;ssl=1 1536w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn this case, the \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e is rendered as a \u003ccode\u003e#shadow-root\u003c/code\u003e without the \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e element’s tags. It’s a fragment of code. So, while the paragraph inside the template is rendered, the \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e itself is not. It effectively marks the Shadow DOM’s boundaries. If we were to omit the \u003ccode\u003eshadowrootmode\u003c/code\u003e attribute, then we simply get an unrendered template. Either way, though, the paragraph is there in the DOM and it is encapsulated from other styles and scripts on the page.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1204\" height=\"662\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-9.56.48%E2%80%AFAM.png?resize=1204%2C662\u0026amp;ssl=1\" alt=\"A two-column list of element tags indicating elements that support the Shadow DOM.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-9.56.48%E2%80%AFAM.png?w=1204\u0026amp;ssl=1 1204w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-9.56.48%E2%80%AFAM.png?resize=300%2C165\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-9.56.48%E2%80%AFAM.png?resize=1024%2C563\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-9.56.48%E2%80%AFAM.png?resize=768%2C422\u0026amp;ssl=1 768w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003cfigcaption\u003eThese are all of the elements that can have a shadow.\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\u003ch3 id=\"breaching-the-shadow\"\u003eBreaching the shadow\u003c/h3\u003e\n\n\n\u003cp\u003eThere are times you’re going to want to “pierce” the Shadow DOM to allow for some styling and scripts. The content is relatively protected but we can open the \u003ccode\u003eshadowrootmode\u003c/code\u003e and allow some access.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;p\u0026gt;This will render in the Shadow DOM.\u0026lt;/p\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow we can query the \u003ccode\u003ediv\u003c/code\u003e that contains the \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e and select the \u003ccode\u003e#shadow-root\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003edocument.querySelector(\u0026#34;div\u0026#34;).shadowRoot\n// #shadow-root (open)\n// \u0026lt;p\u0026gt;This will render in the Shadow DOM.\u0026lt;/p\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe need that \u003ccode\u003e\u0026lt;div\u0026gt;\u003c/code\u003e in there so we have something to query in the DOM to get to the paragraph. Remember, the \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e is not actually rendered at all.\u003c/p\u003e\n\n\n\u003ch4 id=\"additional-shadow-attributes\"\u003eAdditional shadow attributes\u003c/h4\u003e\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;!-- should this root stay with a parent clone? --\u0026gt;\n\u0026lt;template shadowrootcloneable\u0026gt;\n\u0026lt;!-- allow shadow to be serialized into a string object — can forget about this --\u0026gt;\n\u0026lt;template shadowrootserializable\u0026gt;\n\u0026lt;!-- click in element focuses first focusable element --\u0026gt;\n\u0026lt;template shadowrootdelegatesfocus\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch4 id=\"shadow-dom-siblings\"\u003eShadow DOM siblings\u003c/h4\u003e\n\n\n\u003cp\u003eWhen you add a shadow root, it becomes the only rendered root in that shadow host. Any elements after a shadow root node in the DOM simply don’t render. If a DOM element contains more than one shadow root node, the ones after the first just become template tags. It’s sort of like the Shadow DOM is a monster that eats the siblings.\u003c/p\u003e\n\n\n\n\u003cp\u003eSlots bring those siblings back! \u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div\u0026gt;\n  \u0026lt;template shadowroot=\u0026#34;closed\u0026#34;\u0026gt;\n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n    \u0026lt;p\u0026gt;I\u0026#39;m a sibling of a shadow root, and I am visible.\u0026lt;/p\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAll of the siblings go through the slots and are distributed that way. It’s sort of like slots allow us to open the monster’s mouth and see what’s inside.\u003c/p\u003e\n\n\n\u003ch3 id=\"declaring-the-shadow-dom\"\u003eDeclaring the Shadow DOM\u003c/h3\u003e\n\n\n\u003cp\u003eUsing templates is the declarative way to define the Shadow DOM. We can also define the Shadow DOM imperatively using JavaScript. So, this is doing the exact same thing as the last code snippet, only it’s done programmatically in JavaScript:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-element\u0026gt;\n  \u0026lt;template shadowroot=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;p\u0026gt;This will render in the Shadow DOM.\u0026lt;/p\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/my-element\u0026gt;\n\n\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-element\u0026#39;, class extends HTMLElement {\n    constructor() {\n      super();\n      // attaches a shadow root node\n      this.attachShadow({mode: \u0026#34;open\u0026#34;});\n      // inserts a slot into the template\n      this.shadowRoot.innerHTML = \u0026#39;\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\u0026#39;;\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnother example:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-status\u0026gt;available\u0026lt;/my-status\u0026gt;\n\n\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-status\u0026#39;, class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({mode: \u0026#34;open\u0026#34;});\n      this.shadowRoot.innerHTML = \u0026#39;\u0026lt;p\u0026gt;This item is currently: \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\u0026lt;/p\u0026gt;\u0026#39;;\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSo, is it better to be declarative or imperative? Like the weather where I live, it just depends.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1300\" height=\"616\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-10.24.26%E2%80%AFAM.png?resize=1300%2C616\u0026amp;ssl=1\" alt=\"Comparing imperative and declarative benefits to defining the shadow DOM.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-10.24.26%E2%80%AFAM.png?w=1300\u0026amp;ssl=1 1300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-10.24.26%E2%80%AFAM.png?resize=300%2C142\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-10.24.26%E2%80%AFAM.png?resize=1024%2C485\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-10.24.26%E2%80%AFAM.png?resize=768%2C364\u0026amp;ssl=1 768w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003cfigcaption\u003eBoth approaches have their benefits.\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWe can set the shadow mode via Javascript as well:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// open\nthis.attachShadow({mode: open});\n// closed\nthis.attachShadow({mode: closed});\n// cloneable\nthis.attachShadow({cloneable: true});\n// delegateFocus\nthis.attachShadow({delegatesFocus: true});\n// serialized\nthis.attachShadow({serializable: true});\n\n// Manually assign an element to a slot\nthis.attachShadow({slotAssignment: \u0026#34;manual\u0026#34;});\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAbout that last one, it says we have to manually insert the \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e elements in JavaScript:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-element\u0026gt;\n  \u0026lt;p\u0026gt;This WILL render in shadow DOM but not automatically.\u0026lt;/p\u0026gt;\n\u0026lt;/my-element\u0026gt;\n\n\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-element\u0026#39;, class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({\n        mode: \u0026#34;open\u0026#34;,\n        slotAssignment: \u0026#34;manual\u0026#34;\n      });\n      this.shadowRoot.innerHTML = \u0026#39;\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\u0026#39;;\n    }\n    connectedCallback(){\n      const slotElem = this.querySelector(\u0026#39;p\u0026#39;);\n      this.shadowRoot.querySelector(\u0026#39;slot\u0026#39;).assign(slotElem);\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"examples\"\u003eExamples\u003c/h3\u003e\n\n\n\u003cp\u003eScott spent a great deal of time sharing examples that demonstrate different sorts of things you might want to do with the Shadow DOM when working with web components. I’ll rapid-fire those in here.\u003c/p\u003e\n\n\n\u003ch4 id=\"get-an-array-of-element-nodes-in-a-slot\"\u003eGet an array of element nodes in a slot\u003c/h4\u003e\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ethis.shadowRoot.querySelector(\u0026#39;slot\u0026#39;)\n  .assignedElements();\n\n// get an array of all nodes in a slot, text too\nthis.shadowRoot.querySelector(\u0026#39;slot\u0026#39;)\n  .assignedNodes();\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch4 id=\"when-did-a-slots-nodes-change\"\u003eWhen did a slot’s nodes change?\u003c/h4\u003e\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003elet slot = document.querySelector(\u0026#39;div\u0026#39;)\n  .shadowRoot.querySelector(\u0026#34;slot\u0026#34;);\n  \n  slot.addEventListener(\u0026#34;slotchange\u0026#34;, (e) =\u0026gt; {\n    console.log(`Slot \u0026#34;${slot.name}\u0026#34; changed`);\n    // \u0026gt; Slot \u0026#34;saying\u0026#34; changed\n  })\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch4 id=\"combining-imperative-shadow-dom-with-templates\"\u003eCombining imperative Shadow DOM with templates\u003c/h4\u003e\n\n\n\u003cp\u003eBack to this example:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-status\u0026gt;available\u0026lt;/my-status\u0026gt;\n\n\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-status\u0026#39;, class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({mode: \u0026#34;open\u0026#34;});\n      this.shadowRoot.innerHTML = \u0026#39;\u0026lt;p\u0026gt;This item is currently: \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\u0026lt;/p\u0026gt;\u0026#39;;\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s get that string out of our JavaScript with reusable imperative shadow HTML:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-status\u0026gt;available\u0026lt;/my-status\u0026gt;\n\n\u0026lt;template id=\u0026#34;my-status\u0026#34;\u0026gt;\n  \u0026lt;p\u0026gt;This item is currently: \n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n  \u0026lt;/p\u0026gt;\n\u0026lt;/template\u0026gt;\n\n\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-status\u0026#39;, class extends HTMLElement {\n    constructor(){\n      super();\n      this.attachShadow({mode: \u0026#39;open\u0026#39;});\n      const template = document.getElementById(\u0026#39;my-status\u0026#39;);\n\t\t\n      this.shadowRoot.append(template.content.cloneNode(true));\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSlightly better as it grabs the component’s name programmatically to prevent name collisions:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-status\u0026gt;available\u0026lt;/my-status\u0026gt;\n\n\u0026lt;template id=\u0026#34;my-status\u0026#34;\u0026gt;\n  \u0026lt;p\u0026gt;This item is currently: \n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n  \u0026lt;/p\u0026gt;\n\u0026lt;/template\u0026gt;\n\n\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-status\u0026#39;, class extends HTMLElement {\n    constructor(){\n      super();\n      this.attachShadow({mode: \u0026#39;open\u0026#39;});\n      const template = document.getElementById( this.nodeName.toLowerCase() );\n\n      this.shadowRoot.append(template.content.cloneNode(true));\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch4 id=\"forms-with-shadow-dom\"\u003eForms with Shadow DOM\u003c/h4\u003e\n\n\n\u003cp\u003eLong story, cut short: maybe don’t create custom form controls as web components. We get a lot of free features and functionalities — including accessibility — with native form controls that we have to recreate from scratch if we decide to roll our own.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn the case of forms, one of the oddities of encapsulation is that form submissions are not automatically connected. Let’s look at a broken form that contains a web component for a custom input:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;form\u0026gt;\n  \u0026lt;my-input\u0026gt;\n    \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n      \u0026lt;label\u0026gt;\n        \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n        \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;your-name\u0026#34;\u0026gt;\n      \u0026lt;/label\u0026gt;\n    \u0026lt;/template\u0026gt;\n    Type your name!\n  \u0026lt;/my-input\u0026gt;\n  \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;remember\u0026#34;\u0026gt;Remember Me\u0026lt;/label\u0026gt;\n  \u0026lt;button\u0026gt;Submit\u0026lt;/button\u0026gt;\n\u0026lt;/form\u0026gt;\n\n\u0026lt;script\u0026gt;\ndocument.forms[0].addEventListener(\u0026#39;input\u0026#39;, function(){\n  let data = new FormData(this);\n  console.log(new URLSearchParams(data).toString());\n});\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis input’s value won’t be in the submission! Also, form validation and states are not communicated in the Shadow DOM. Similar connectivity issues with accessibility, where the shadow boundary can interfere with ARIA. For example, IDs are local to the Shadow DOM. Consider how much you really need the Shadow DOM when working with forms.\u003c/p\u003e\n\n\n\u003ch3 id=\"element-internals\"\u003eElement internals\u003c/h3\u003e\n\n\n\u003cp\u003eThe moral of the last section is to tread carefully when creating your own web components for form controls. Scott suggests avoiding that altogether, but he continued to demonstrate how we could theoretically fix functional and accessibility issues using \u003cstrong\u003eelement internals\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s start with an input value that will be included in the form submission.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;form\u0026gt;\n  \u0026lt;my-input name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/my-input\u0026gt;\n  \u0026lt;button\u0026gt;Submit\u0026lt;/button\u0026gt;\n\u0026lt;/form\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow let’s slot this imperatively:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-input\u0026#39;, class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({mode: \u0026#39;open\u0026#39;});\n      this.shadowRoot.innerHTML = \u0026#39;\u0026lt;label\u0026gt;\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/label\u0026gt;\u0026#39;\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe value is not communicated yet. We’ll add a static \u003ccode\u003eformAssociated\u003c/code\u003e variable with internals attached:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-input\u0026#39;, class extends HTMLElement {\n    static formAssociated = true;\n    constructor() {\n      super();\n      this.attachShadow({mode: \u0026#39;open\u0026#39;});\n      this.shadowRoot.innerHTML = \u0026#39;\u0026lt;label\u0026gt;\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/label\u0026gt;\u0026#39;\n      this.internals = this.attachedInternals();\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThen we’ll set the form value as part of the internals when the input’s value changes:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-input\u0026#39;, class extends HTMLElement {\n    static formAssociated = true;\n    constructor() {\n      super();\n      this.attachShadow({mode: \u0026#39;open\u0026#39;});\n      this.shadowRoot.innerHTML = \u0026#39;\u0026lt;label\u0026gt;\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/label\u0026gt;\u0026#39;\n      this.internals = this.attachedInternals();\n      \n      this.addEventListener(\u0026#39;input\u0026#39;, () =\u0026gt; {\n        this-internals.setFormValue(this.shadowRoot.querySelector(\u0026#39;input\u0026#39;).value);\n      });\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eHere’s how we set states with element internals:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// add a checked state\nthis.internals.states.add(\u0026#34;checked\u0026#34;);\n\n// remove a checked state\nthis.internals.states.delete(\u0026#34;checked\u0026#34;);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s toggle a “add” or “delete” a boolean state:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;form\u0026gt;\n  \u0026lt;my-check name=\u0026#34;remember\u0026#34;\u0026gt;Remember Me?\u0026lt;/my-check\u0026gt;\n\u0026lt;/form\u0026gt;\n\n\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-check\u0026#39;, class extends HTMLElement {\n    static formAssociated = true;\n    constructor(){\n      super();\n      this.attachShadow({mode: \u0026#39;open\u0026#39;});\n      this.shadowRoot.innerHTML = \u0026#39;\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\u0026#39;;\n      this.internals = this.attachInternals();\n      let addDelete = false;\n      this.addEventListener(\u0026#34;click\u0026#34;, ()=\u0026gt; {\n        addDelete = !addDelete;\n        this.internals.states[addDelete ? \u0026#34;add\u0026#34; : \u0026#34;delete\u0026#34;](\u0026#34;checked\u0026#34;);\n     } );\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s refactor this for ARIA improvements:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;form\u0026gt;\n  \u0026lt;style\u0026gt;\n    my-check { display: inline-block; inline-size: 1em; block-size: 1em; background: #eee; }\n    my-check:state(checked)::before { content: \u0026#34;[x]\u0026#34;; }\n  \u0026lt;/style\u0026gt;\n  \u0026lt;my-check name=\u0026#34;remember\u0026#34; id=\u0026#34;remember\u0026#34;\u0026gt;\u0026lt;/my-check\u0026gt;\u0026lt;label for=\u0026#34;remember\u0026#34;\u0026gt;Remember Me?\u0026lt;/label\u0026gt;\n\u0026lt;/form\u0026gt;\n\n\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-check\u0026#39;, class extends HTMLElement {\n    static formAssociated = true;\n    constructor(){\n      super();\n      this.attachShadow({mode: \u0026#39;open\u0026#39;});\n\n\n      this.internals = this.attachInternals();\n      this.internals.role = \u0026#39;checkbox\u0026#39;;\n      this.setAttribute(\u0026#39;tabindex\u0026#39;, \u0026#39;0\u0026#39;);\n      let addDelete = false;\n      this.addEventListener(\u0026#34;click\u0026#34;, ()=\u0026gt; {\n        addDelete = !addDelete;\n        this.internals.states[addDelete ? \u0026#34;add\u0026#34; : \u0026#34;delete\u0026#34;](\u0026#34;checked\u0026#34;);\n        this[addDelete ? \u0026#34;setAttribute\u0026#34; : \u0026#34;removeAttribute\u0026#34;](\u0026#34;aria-checked\u0026#34;, true);\n      });\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"463\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-11.16.58%E2%80%AFAM.png?resize=1024%2C463\u0026amp;ssl=1\" alt=\"Inspecting a web component for a custom form input in DevTools, revealing the ARIA roles and attributes that were programmatically added to the component.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-11.16.58%E2%80%AFAM.png?resize=1024%2C463\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-11.16.58%E2%80%AFAM.png?resize=300%2C136\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-11.16.58%E2%80%AFAM.png?resize=768%2C347\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-11.16.58%E2%80%AFAM.png?resize=1536%2C694\u0026amp;ssl=1 1536w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/Screenshot-2025-01-27-at-11.16.58%E2%80%AFAM.png?w=1576\u0026amp;ssl=1 1576w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003ePhew, that’s a lot of work! And sure, this gets us a lot closer to a more functional and accessible custom form input, but there’s still a long way’s to go to achieve what we already get for free from using native form controls. Always question whether you can rely on a light DOM form instead.\u003c/p\u003e\n\n\n\u003c/details\u003e\n\n\n\u003cdetails\u003e\n  \u003csummary\u003e\n          \u003ch2\u003eChapter 5: Styling Web Components\u003c/h2\u003e\n      \u003c/summary\u003e\n  \n\n\u003cp\u003eStyling web components comes in levels of complexity. For example, we don’t need any JavaScript at all to slap a few styles on a custom element.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-element theme=\u0026#34;suave\u0026#34; class=\u0026#34;priority\u0026#34;\u0026gt;\n  \u0026lt;h1\u0026gt;I\u0026#39;m in the Light DOM!\u0026lt;/h1\u0026gt;\n\u0026lt;/my-element\u0026gt;\n\n\u0026lt;style\u0026gt;\n  /* Element, class, attribute, and complex selectors all work. */\n  my-element {\n    display: block; /* custom elements are inline by default */\n  }\n  .my-element[theme=suave] {\n    color: #fff;\n  }\n  .my-element.priority {\n    background: purple;\n  }\n  .my-element h1 {\n    font-size: 3rem;\n  }\n\u0026lt;/style\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThis is not encapsulated! This is scoped off of a single element just light any other CSS in the Light DOM.\u003c/li\u003e\n\n\n\n\u003cli\u003eChanging the Shadow DOM mode from \u003ccode\u003eclosed\u003c/code\u003e to \u003ccode\u003eopen\u003c/code\u003e doesn’t change CSS. It allows JavaScript to pierce the Shadow DOM but CSS isn’t affected.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003ch3 id=\"lets-poke-at-it\"\u003eLet’s poke at it\u003c/h3\u003e\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\np { color: red; }\n\u0026lt;/style\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThis is three stacked paragraphs, the second of which is in the shadow root.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe first and third paragraphs are red; the second is not styled because it is in a \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e, even if the shadow root’s mode is set to \u003ccode\u003eopen\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eLet’s poke at it from the other direction:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\np { color: red; }\n\u0026lt;/style\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;style\u0026gt; p { color: blue;} \u0026lt;/style\u0026gt;\n    \u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThe first and third paragraphs are still receiving the red color from the Light DOM’s CSS.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003ccode\u003e\u0026lt;style\u0026gt;\u003c/code\u003e declarations in the \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e are encapsulated and do not leak out to the other paragraphs, even though it is declared later in the cascade.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eSame idea, but setting the color on the \u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\nbody { color: red; }\n\u0026lt;/style\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eEverything is red! This isn’t a bug. Inheritable styles do pass through the Shadow DOM barrier.\u003c/li\u003e\n\n\n\n\u003cli\u003eInherited styles are those that are set by the computed values of their parent styles. Many properties are inheritable, including \u003ccode\u003ecolor\u003c/code\u003e. The \u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e is the parent and everything in it is a child that inherits these styles, including custom elements.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1532\" height=\"928\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-29-at-8.12.45%E2%80%AFAM.png?resize=1532%2C928\u0026amp;ssl=1\" alt=\"A list of properties that inherit styles.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-29-at-8.12.45%E2%80%AFAM.png?w=1532\u0026amp;ssl=1 1532w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-29-at-8.12.45%E2%80%AFAM.png?resize=300%2C182\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-29-at-8.12.45%E2%80%AFAM.png?resize=1024%2C620\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-29-at-8.12.45%E2%80%AFAM.png?resize=768%2C465\u0026amp;ssl=1 768w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\u003ch3 id=\"lets-fight-with-inheritance\"\u003eLet’s fight with inheritance\u003c/h3\u003e\n\n\n\u003cp\u003eWe can target the paragraph in the \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e style block to override the styles set on the \u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e. Those won’t leak back to the other paragraphs.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  body {\n    color: red;\n    font-family: fantasy;\n    font-size: 2em;\n  }\n\u0026lt;/style\u0026gt;\n  \n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;style\u0026gt; \n      /* reset the light dom styles */\n      p {\n        color: initial; \n        font-family: initial; \n        font-size: initial;\n      }\n    \u0026lt;/style\u0026gt;\n    \u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\n  \n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThis is protected, but the problem here is that it’s still possible for a new role or property to be introduced that passes along inherited styles that we haven’t thought to reset.\u003c/li\u003e\n\n\n\n\u003cli\u003ePerhaps we could use \u003ccode\u003eall: initital\u003c/code\u003e as a defensive strategy against future inheritable styles. But what if we add more elements to the custom element? It’s a constant fight.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003ch3 id=\"host-styles\"\u003eHost styles!\u003c/h3\u003e\n\n\n\u003cp\u003eWe can scope things to the shadow root’s \u003ccode\u003e:host\u003c/code\u003e selector to keep things protected.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  body {\n    color: red;\n    font-family: fantasy;\n    font-size: 2em;\n  }\n\u0026lt;/style\u0026gt;\n  \n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;style\u0026gt; \n      /* reset the light dom styles */\n      :host { all: initial; }\n    \u0026lt;/style\u0026gt;\n    \u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n    \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Click me\u0026lt;/a\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\n  \n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNew problem! What if the Light DOM styles are scoped to the universal selector instead?\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  * {\n    color: red;\n    font-family: fantasy;\n    font-size: 2em;\n  }\n\u0026lt;/style\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;style\u0026gt; \n      /* reset the light dom styles */\n      :host { all: initial; }\n    \u0026lt;/style\u0026gt;\n    \u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n    \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Click me\u0026lt;/a\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis breaks the custom element’s styles. But that’s because Shadow DOM styles are applied \u003cem\u003ebefore\u003c/em\u003e Light DOM styles. The styles scoped to the universal selector are simply applied \u003cem\u003eafter\u003c/em\u003e the \u003ccode\u003e:host\u003c/code\u003e styles, which overrides what we have in the shadow root. So, we’re still locked in a brutal fight over inheritance and need stronger specificity.\u003c/p\u003e\n\n\n\n\u003cp\u003eAccording to Scott, \u003ccode\u003e!important\u003c/code\u003e is one of the only ways we have to apply brute force to protect our custom elements from outside styles leaking in. The keyword gets a bad rap — and rightfully so in the vast majority of cases — but this is a case where it works well and using it is an encouraged practice. It’s not like it has an impact on the styles \u003cem\u003eoutside\u003c/em\u003e the custom element, anyway.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  * {\n    color: red;\n    font-family: fantasy;\n    font-size: 2em;\n  }\n\u0026lt;/style\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;style\u0026gt; \n      /* reset the light dom styles */\n      :host { all: initial; !important }\n    \u0026lt;/style\u0026gt;\n    \u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n    \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Click me\u0026lt;/a\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"special-selectors\"\u003eSpecial selectors\u003c/h3\u003e\n\n\n\u003cp\u003eThere are some useful selectors we have to look at components from the outside, looking in.\u003c/p\u003e\n\n\n\u003ch4 id=\"host\"\u003e\u003ccode\u003e:host()\u003c/code\u003e\u003c/h4\u003e\n\n\n\u003cp\u003eWe just looked at this! But note how it is a function in addition to being a pseudo-selector. It’s sort of a parent selector in the sense that we can pass in the \u003ccode\u003e\u0026lt;div\u0026gt;\u003c/code\u003e that contains the \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e and that becomes the scoping context for the entire selector, meaning the \u003ccode\u003e!important\u003c/code\u003e keyword is no longer needed.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  * {\n    color: red;\n    font-family: fantasy;\n    font-size: 2em;\n  }\n\u0026lt;/style\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;style\u0026gt; \n      /* reset the light dom styles */\n      :host(div) { all: initial; }\n    \u0026lt;/style\u0026gt;\n    \u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\n    \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Click me\u0026lt;/a\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;Hi\u0026lt;/p\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch4 id=\"hostcontext\"\u003e\u003ccode\u003e:host-context()\u003c/code\u003e\u003c/h4\u003e\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;header\u0026gt;\n  \u0026lt;my-element\u0026gt;\n    \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n      \u0026lt;style\u0026gt;\n        :host-context(header) { ... } /* matches the host! */\n      \u0026lt;/style\u0026gt;\n    \u0026lt;/template\u0026gt;\n  \u0026lt;/my-element\u0026gt;\n\u0026lt;/header\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis targets the shadow host but only if the provided selector is a parent node anywhere up the tree. This is super helpful for styling custom elements where the layout context might change, say, from being contained in an \u003ccode\u003e\u0026lt;article\u0026gt;\u003c/code\u003e versus being contained in a \u003ccode\u003e\u0026lt;header\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\n\n\u003ch4 id=\"defined\"\u003e\u003ccode\u003e:defined\u003c/code\u003e\u003c/h4\u003e\n\n\n\u003cp\u003eDefining an element occurs when it is created, and this pseudo-selector is how we can select the element in that initially-defined state. I imagine this is mostly useful for when a custom element is defined imperatively in JavaScript so that we can target the very moment that the element is constructed, and then set styles right then and there.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  simple-custom:defined { display: block; background: green; color: #fff; }\n\u0026lt;/style\u0026gt;\n\u0026lt;simple-custom\u0026gt;\u0026lt;/simple-custom\u0026gt;\n\n\u0026lt;script\u0026gt;\ncustomElements.define(\u0026#39;simple-custom\u0026#39;, class extends HTMLElement {\n  constructor(){\n    super();\n    this.attachShadow({mode: \u0026#39;open\u0026#39;});\n    this.shadowRoot.innerHTML = \u0026#34;\u0026lt;p\u0026gt;Defined!\u0026lt;/p\u0026gt;\u0026#34;;\n  }\n});\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eMinor note about protecting against a flash of unstyled content (FOUC)… or unstyled \u003cem\u003eelement\u003c/em\u003e in this case. Some elements are effectively useless until JavsScript has interacted with it to generate content. For example, an empty custom element that only becomes meaningful once JavaScript runs and generates content. Here’s how we can prevent the inevitable flash that happens after the content is generated:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  js-dependent-element:not(:defined) {\n    visibility: hidden;\n  }\n\u0026lt;/style\u0026gt;\n\n\u0026lt;js-dependent-element\u0026gt;\u0026lt;/js-dependent-element\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWarning zone! It’s best for elements that are empty and not yet defined. If you’re working with a meaningful element up-front, then it’s best to style as much as you can up-front.\u003c/p\u003e\n\n\n\u003ch3 id=\"styling-slots\"\u003eStyling slots\u003c/h3\u003e\n\n\n\u003cp\u003eThis does \u003cem\u003enot\u003c/em\u003e style the paragraph \u003ccode\u003egreen\u003c/code\u003e as you might expect:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;style\u0026gt;\n      p { color: green; }\n    \u0026lt;/style\u0026gt;\n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n  \u0026lt;/template\u0026gt;\n  \n  \u0026lt;p\u0026gt;Slotted Element\u0026lt;/p\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe Shadow DOM cannot style this content directly. The styles would apply to a paragraph in the \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e that gets rendered in the Light DOM, but it cannot style it when it is slotted into the \u003ccode\u003e\u0026lt;template\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eSlots are part of the Light DOM. So, this works:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  p { color: green; }\n\u0026lt;/style\u0026gt;\n\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n  \u0026lt;/template\u0026gt;\n  \n  \u0026lt;p\u0026gt;Slotted Element\u0026lt;/p\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis means that slots are easier to target when it comes to piercing the shadow root with styles, making them a great method of progressive style enhancement.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe have another special selected, the \u003ccode\u003e::slotted()\u003c/code\u003e pseudo-element that’s also a function. We pass it an element or class and that allows us to select elements from within the shadow root.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;style\u0026gt; ::slotted(p) { color: red; } \u0026lt;/style\u0026gt;\n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n  \u0026lt;/template\u0026gt;\n  \n  \u0026lt;p\u0026gt;Slotted Element\u0026lt;/p\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eUnfortunately, \u003ccode\u003e::slotted()\u003c/code\u003e is a weak selected when compared to global selectors. So, if we were to make this a little more complicated by introducing an outside inheritable style, then we’d be hosed again.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  /* global paragraph style... */\n  p { color: green; }\n\u0026lt;/style\u0026gt;\n\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;style\u0026gt;\n      /* ...overrides the slotted style */\n      ::slotted(p) { color: red; }\n    \u0026lt;/style\u0026gt;\n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n  \u0026lt;/template\u0026gt;\n  \n  \u0026lt;p\u0026gt;Slotted Element\u0026lt;/p\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is another place where \u003ccode\u003e!important\u003c/code\u003e could make sense. It even wins if the global style is also set to \u003ccode\u003e!important\u003c/code\u003e. We could get more defensive and pass the universal selector to \u003ccode\u003e::slotted\u003c/code\u003e and set everything back to its initial value so that all slotted content is encapsulated from outside styles leaking in.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  /* global paragraph style... */\n  p { color: green; }\n\u0026lt;/style\u0026gt;\n\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;style\u0026gt;\n      /* ...can\u0026#39;t override this important statement */\n      ::slotted(*) { all: initial !important; }\n    \u0026lt;/style\u0026gt;\n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n  \u0026lt;/template\u0026gt;\n  \n  \u0026lt;p\u0026gt;Slotted Element\u0026lt;/p\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"stylingnbspparts\"\u003eStyling \u003ccode\u003e:parts\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003eA part is a way of offering up Shadow DOM elements to the parent document for styling. Let’s add a part to a custom element:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;p part=\u0026#34;hi\u0026#34;\u0026gt;Hi there, I\u0026#39;m a part!\u0026lt;/p\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWithout the \u003ccode\u003epart\u003c/code\u003e attribute, there is no way to write styles that reach the paragraph. But with it, the part is exposed as something that can be styled.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  ::part(hi) { color: green; }\n  ::part(hi) b { color: green; } /* nope! */\n\u0026lt;/style\u0026gt;\n\n\u0026lt;div\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;p part=\u0026#34;hi\u0026#34;\u0026gt;Hi there, I\u0026#39;m a \u0026lt;b\u0026gt;part\u0026lt;/b\u0026gt;!\u0026lt;/p\u0026gt;\n  \u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe can use this to expose specific “parts” of the custom element that are open to outside styling, which is almost like establishing a styling API with specifications for what can and can’t be styled. Just note that \u003ccode\u003e::part\u003c/code\u003e cannot be used as part of a complex selector, like a descendant selector:\u003c/p\u003e\n\n\n\n\u003cp\u003eA bit in the weeds here, but we can export parts in the sense that we can nest elements within elements within elements, and so on. This way, we include parts within elements.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-component\u0026gt;\n  \u0026lt;!-- exposes three parts to the nested component --\u0026gt;\n  \u0026lt;nested-component exportparts=\u0026#34;part1, part2, part5\u0026#34;\u0026gt;\u0026lt;/nested-component\u0026gt;\n\u0026lt;/my-component\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"styling-states-and-validity\"\u003eStyling states and validity\u003c/h3\u003e\n\n\n\u003cp\u003eWe discussed this when going over element internals in the chapter about the Shadow DOM. But it’s worth revisiting that now that we’re specifically talking about styling. We have a \u003ccode\u003e:state\u003c/code\u003e pseudo-function that accepts our defined states.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;script\u0026gt;\n  this.internals.states.add(\u0026#34;checked\u0026#34;);\n\u0026lt;/script\u0026gt;\n\n\u0026lt;style\u0026gt;\n  my-checkbox:state(checked) {\n    /* ... */\n  }\n\u0026lt;/style\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe also have access to the \u003ccode\u003e:invalid\u003c/code\u003e pseudo-class.\u003c/p\u003e\n\n\n\u003ch3 id=\"crossbarrier-custom-properties\"\u003eCross-barrier custom properties\u003c/h3\u003e\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n:root {\n  --text-primary: navy;\n  --bg-primary: #abe1e1;\n  --padding: 1.5em 1em;\n}\n\np {\n  color: var(--text-primary);\n  background: var(--bg-primary);\n  padding: var(--padding);\n}\n\u0026lt;/style\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eCustom properties cross the Shadow DOM barrier!\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-elem\u0026gt;\u0026lt;/my-elem\u0026gt;\n\n\u0026lt;script\u0026gt;\n  customElements.define(\u0026#39;my-elem\u0026#39;, class extends HTMLElement {\n    constructor(){\n      super();\n      this.attachShadow({mode: \u0026#39;open\u0026#39;});\n      this.shadowRoot.innerHTML = `\n      \u0026lt;style\u0026gt;\n        p {\n          color: var(--text-primary);\n          background: var(--bg-primary);\n          padding: var(--padding);\n        }\n      \u0026lt;/style\u0026gt;\n      \n      \u0026lt;p\u0026gt;Hi there!\u0026lt;/p\u0026gt;`;\n    }\n  })\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1710\" height=\"944\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-29-at-10.01.34%E2%80%AFAM.png?resize=1710%2C944\u0026amp;ssl=1\" alt=\"DevTools inspector showing the styled paragraph.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-29-at-10.01.34%E2%80%AFAM.png?w=1710\u0026amp;ssl=1 1710w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-29-at-10.01.34%E2%80%AFAM.png?resize=300%2C166\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-29-at-10.01.34%E2%80%AFAM.png?resize=1024%2C565\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-29-at-10.01.34%E2%80%AFAM.png?resize=768%2C424\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-29-at-10.01.34%E2%80%AFAM.png?resize=1536%2C848\u0026amp;ssl=1 1536w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\u003ch3 id=\"adding-stylesheets-to-custom-elements\"\u003eAdding stylesheets to custom elements\u003c/h3\u003e\n\n\n\u003cp\u003eThere’s the classic ol’ external \u003ccode\u003e\u0026lt;link\u0026gt;\u003c/code\u003e way of going about it:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;simple-custom\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;../../assets/external.css\u0026#34;\u0026gt;\n    \u0026lt;p\u0026gt;This one\u0026#39;s in the shadow Dom.\u0026lt;/p\u0026gt;\n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n  \u0026lt;/template\u0026gt;\n\n  \u0026lt;p\u0026gt;Slotted \u0026lt;b\u0026gt;Element\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;/simple-custom\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIt might seem like an anti-DRY approach to call the same external stylesheet at the top of all web components. To be clear, yes, it is repetitive — but only as far as writing it. Once the sheet has been downloaded once, it is available across the board without any additional requests, so we’re still technically dry in the sense of performance.\u003c/p\u003e\n\n\n\n\u003cp\u003eCSS imports also work:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;style\u0026gt;\n  @import url(\u0026#34;../../assets/external.css\u0026#34;);\n\u0026lt;/style\u0026gt;\n\n\u0026lt;simple-custom\u0026gt;\n  \u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n    \u0026lt;style\u0026gt;\n      @import url(\u0026#34;../../assets/external.css\u0026#34;);\n    \u0026lt;/style\u0026gt;\n    \u0026lt;p\u0026gt;This one\u0026#39;s in the shadow Dom.\u0026lt;/p\u0026gt;\n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n  \u0026lt;/template\u0026gt;\n\n  \u0026lt;p\u0026gt;Slotted \u0026lt;b\u0026gt;Element\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;/simple-custom\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOne more way using a JavaScript-based approach. It’s probably better to make CSS work without a JavaScript dependency, but it’s still a valid option.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-elem\u0026gt;\u0026lt;/my-elem\u0026gt;\n\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt;\n  import sheet from \u0026#39;../../assets/external.css\u0026#39; with { type: \u0026#39;css\u0026#39; };\n\n  customElements.define(\u0026#39;my-elem\u0026#39;, class extends HTMLElement {\n    constructor(){\n      super();\n      this.attachShadow({mode: \u0026#39;open\u0026#39;});\n      this.shadowRoot.innerHTML = \u0026#39;\u0026lt;p\u0026gt;Hi there\u0026lt;/p\u0026gt;\u0026#39;;\n      this.shadowRoot.adoptedStyleSheets = [sheet];\n    }\n  })\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe have a JavaScript module and import CSS into a string that is then adopted by the shadow root using \u003ccode\u003eshadowRoort.adoptedStyleSheets\u003c/code\u003e . And since adopted stylesheets are dynamic, we can construct one, share it across multiple instances, and update styles via the CSSOM that ripple across the board to all components that adopt it.\u003c/p\u003e\n\n\n\u003ch2 id=\"container-queries\"\u003eContainer queries!\u003c/h2\u003e\n\n\n\u003cp\u003eContainer queries are nice to pair with components, as custom elements and web components are containers and we can query them and adjust things as the container changes.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div\u0026gt;\n\u0026lt;template shadowrootmode=\u0026#34;open\u0026#34;\u0026gt;\n  \u0026lt;style\u0026gt;\n    :host {\n      container-type: inline-size;\n      background-color: tan;\n      display: block;\n      padding: 2em;\n    }\n    \n    ul {\n      display: block;\n      list-style: none;\n      margin: 0;\n    }\n    \n    li {\n      padding: .5em;\n      margin: .5em 0;\n      background-color: #fff;\n    }\n    \n    @container (min-width: 50em) {\n      ul {\n        display: flex;\n        justify-content: space-between;\n        gap: 1em;\n      }\n      li {\n        flex: 1 1 auto;\n      }\n    }\n  \u0026lt;/style\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n    \u0026lt;li\u0026gt;First Item\u0026lt;/li\u0026gt;\n    \u0026lt;li\u0026gt;Second Item\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n  \n\u0026lt;/template\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn this example, we’re setting styles on the \u003ccode\u003e:host()\u003c/code\u003e to define a new container, as well as some general styles that are protected and scoped to the shadow root. From there, we introduce a container query that updates the unordered list’s layout when the custom element is at least \u003ccode\u003e50em\u003c/code\u003e wide.\u003c/p\u003e\n\n\n\u003ch2 id=\"next-up\"\u003eNext up…\u003c/h2\u003e\n\n\n\u003cp\u003eHow web component features are used together!\u003c/p\u003e\n\n\n\u003c/details\u003e\n\n\n\u003cdetails\u003e\n  \u003csummary\u003e\n          \u003ch2\u003eChapter 6: HTML-First Patterns\u003c/h2\u003e\n      \u003c/summary\u003e\n  \n\n\u003cp\u003eIn this chapter, Scott focuses on how other people are using web components in the wild and highlights a few of the more interesting and smart patterns he’s seen.\u003c/p\u003e\n\n\n\u003ch3 id=\"lets-start-with-a-typical-counter\"\u003eLet’s start with a typical counter\u003c/h3\u003e\n\n\n\u003cp\u003eIt’s often the very first example used in React tutorials.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;counter-element\u0026gt;\u0026lt;/counter-element\u0026gt;\n\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt;\n  customElements.define(\u0026#39;counter-element\u0026#39;, class extends HTMLElement {\n    #count = 0;\n    connectedCallback() {\n      this.innerHTML = `\u0026lt;button id=\u0026#34;dec\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt;\u0026lt;p id=\u0026#34;count\u0026#34;\u0026gt;${this.#count}\u0026lt;/p\u0026gt;\u0026lt;button id=\u0026#34;inc\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt;`;\n      this.addEventListener(\u0026#39;click\u0026#39;, e =\u0026gt; this.update(e) );\n    }\n    update(e) {\n      if( e.target.nodeName !== \u0026#39;BUTTON\u0026#39; ) { return }\n      this.#count = e.target.id === \u0026#39;inc\u0026#39; ? this.#count + 1 : this.#count - 1;\n      this.querySelector(\u0026#39;#count\u0026#39;).textContent = this.#count;\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"reef\"\u003eReef\u003c/h3\u003e\n\n\n\u003cp\u003e\u003ca href=\"https://reefjs.com/\" rel=\"noopener\"\u003eReef\u003c/a\u003e is a tiny library by \u003ca href=\"https://gomakethings.com/\" rel=\"noopener\"\u003eChris Ferdinandi\u003c/a\u003e that weighs just 2.6KB minified and zipped yet still provides DOM diffing for reactive state-based UIs like React, which weighs significantly more. An example of how it works in a standalone way:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div id=\u0026#34;greeting\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt;\n  import {signal, component} from \u0026#39;.../reef.es..min.js\u0026#39;;\n  // Create a signal\n  let data = signal({\n    greeting: \u0026#39;Hello\u0026#39;,\n    name: \u0026#39;World\u0026#39;\n  });\n  component(\u0026#39;#greeting\u0026#39;, () =\u0026gt; `\u0026lt;p\u0026gt;${data.greeting}, ${data.name}!\u0026lt;/p\u0026gt;`);\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis sets up a “signal” that is basically a live-update object, then calls the \u003ccode\u003ecomponent()\u003c/code\u003e method to select where we want to make the update, and it injects a template literal in there that passes in the variables with the markup we want.\u003c/p\u003e\n\n\n\n\u003cp\u003eSo, for example, we can update those values on \u003ccode\u003esetTimeout\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div id=\u0026#34;greeting\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt;\n  import {signal, component} from \u0026#39;.../reef.es..min.js\u0026#39;;\n  // Create a signal\n  let data = signal({\n    greeting: \u0026#39;Hello\u0026#39;,\n    name: \u0026#39;World\u0026#39;\n  });\n  component(\u0026#39;#greeting\u0026#39;, () =\u0026gt; `\u0026lt;p\u0026gt;${data.greeting}, ${data.name}!\u0026lt;/p\u0026gt;`);\n  \n  setTimeout(() =\u0026gt; {\n    data.greeting = \u0026#39;¡Hola\u0026#39;\n    data,name = \u0026#39;Scott\u0026#39;\n  }, 3000)\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe can combine this sort of library with a web component. Here, Scott imports Reef and constructs the data outside the component so that it’s like the application state:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-greeting\u0026gt;\u0026lt;/my-greeting\u0026gt;\n\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt;\n    import {signal, component} from \u0026#39;https://cdn.jsdelivr.net/npm/reefjs@13/dist/reef.es.min.js\u0026#39;;\n    \n    window.data = signal({\n      greeting: \u0026#39;Hi\u0026#39;,\n      name: \u0026#39;Scott\u0026#39;\n    });\n    \n    customElements.define(\u0026#39;my-greeting\u0026#39;, class extends HTMLElement {\n      connectedCallback(){\n        component(this, () =\u0026gt; `\u0026lt;p\u0026gt;${data.greeting}, ${data.name}!\u0026lt;/p\u0026gt;` );\n      }\n    });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIt’s the virtual DOM in a web component! Another approach that is more reactive in the sense that it watches for changes in attributes and then updates the application state in response which, in turn, updates the greeting.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-greeting greeting=\u0026#34;Hi\u0026#34; name=\u0026#34;Scott\u0026#34;\u0026gt;\u0026lt;/my-greeting\u0026gt;\n\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt;\n  import {signal, component} from \u0026#39;https://cdn.jsdelivr.net/npm/reefjs@13/dist/reef.es.min.js\u0026#39;;\n  customElements.define(\u0026#39;my-greeting\u0026#39;, class extends HTMLElement {\n    static observedAttributes = [\u0026#34;name\u0026#34;, \u0026#34;greeting\u0026#34;];\n    constructor(){\n      super();\n      this.data = signal({\n        greeting: \u0026#39;\u0026#39;,\n        name: \u0026#39;\u0026#39;\n      });\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n      this.data[name] = newValue;\n    }\n    connectedCallback(){\n      component(this, () =\u0026gt; `\u0026lt;p\u0026gt;${this.data.greeting}, ${this.data.name}!\u0026lt;/p\u0026gt;` );\n    }\n  });\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf the attribute changes, it only changes that instance. The data is registered at the time the component is constructed and we’re only changing string attributes rather than objects with properties.\u003c/p\u003e\n\n\n\u003ch3 id=\"html-web-components\"\u003eHTML Web Components\u003c/h3\u003e\n\n\n\u003cp\u003eThis describes web components that are not empty by default like this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;my-greeting\u0026gt;\u0026lt;/my-greeting\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is a “React” mindset where all the functionality, content, and behavior comes from JavaScript. But Scott reminds us that web components are pretty useful right out of the box without JavaScript. So, “HTML web components” refers to web components that are packed with meaningful content right out of the gate and Scott points to \u003ca href=\"https://adactio.com/journal/20618\" rel=\"noopener\"\u003eJeremy Keith’s 2023 article coining the term\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e[…] we could call them “HTML web components.” If your custom element is empty, it’s not an HTML web component. But if you’re using a custom element to extend existing markup, that’s an HTML web component.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eJeremy cites something Robin Rendle mused about the distinction:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e[…] I’ve started to come around and see Web Components as filling in the blanks of what we can do with hypertext: they’re really just small, reusable chunks of code that extends the language of HTML.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eThe “React” way:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;UserAvatar\n  src=\u0026#34;https://example.com/path/to/img.jpg\u0026#34;\n  alt=\u0026#34;...\u0026#34;\n/\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe props look like HTML but they’re not. Instead, the props provide information used to completely swap out the \u003ccode\u003e\u0026lt;UserAvatar /\u0026gt;\u003c/code\u003e tag with the JavaScript-based markup.\u003c/p\u003e\n\n\n\n\u003cp\u003eWeb components can do that, too:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;user-avatar\n  src=\u0026#34;https://example.com/path/to/img.jpg\u0026#34;\n  alt=\u0026#34;...\u0026#34;\n\u0026gt;\u0026lt;/user-avatar\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSame deal, real HTML. Progressive enhancement is at the heart of an HTML web component mindset. Here’s how that web component might work:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclass UserAvatar extends HTMLElement {\n  connectedCallback() {\n    const src = this.getAttribute(\u0026#34;src\u0026#34;);\n    const name = this.getAttribute(\u0026#34;name\u0026#34;);\n    this.innerHTML = `\n      \u0026lt;div\u0026gt;\n        \u0026lt;img src=\u0026#34;${src}\u0026#34; alt=\u0026#34;Profile photo of ${name}\u0026#34; width=\u0026#34;32\u0026#34; height=\u0026#34;32\u0026#34; /\u0026gt;\n        \u0026lt;!-- Markup for the tooltip --\u0026gt;\n      \u0026lt;/div\u0026gt;\n    `;\n  }\n}\ncustomElements.define(\u0026#39;user-avatar\u0026#39;, UserAvatar);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBut a better starting point would be to include the \u003ccode\u003e\u0026lt;img\u0026gt;\u003c/code\u003e directly in the component so that the markup is immediately available:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;user-avatar\u0026gt;\n  \u0026lt;img src=\u0026#34;https://example.com/path/to/img.jpg\u0026#34; alt=\u0026#34;...\u0026#34; /\u0026gt;\n\u0026lt;/user-avatar\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis way, the image is downloaded and ready before JavaScript even loads on the page. Strive for augmentation over replacement!\u003c/p\u003e\n\n\n\u003ch3 id=\"resizeasaurus\"\u003e\u003ccode\u003eresizeasaurus\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003eThis helps developers test responsive component layouts, particularly ones that use container queries.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;resize-asaurus\u0026gt;\n  Drop any HTML in here to test.\n\u0026lt;/resize-asaurus\u0026gt;\n\n\u0026lt;!-- for example: --\u0026gt;\n\n\u0026lt;resize-asaurus\u0026gt;\n  \u0026lt;div class=\u0026#34;my-responsive-grid\u0026#34;\u0026gt;\n    \u0026lt;div\u0026gt;Cell 1\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;Cell 2\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;Cell 3\u0026lt;/div\u0026gt; \u0026lt;!-- ... --\u0026gt;\n  \u0026lt;/div\u0026gt;\n\u0026lt;/resize-asaurus\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1668\" height=\"846\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-30-at-2.26.38%E2%80%AFPM.png?resize=1668%2C846\u0026amp;ssl=1\" alt=\"Five examples of grids with cells where the grid shows how wide it is.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-30-at-2.26.38%E2%80%AFPM.png?w=1668\u0026amp;ssl=1 1668w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-30-at-2.26.38%E2%80%AFPM.png?resize=300%2C152\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-30-at-2.26.38%E2%80%AFPM.png?resize=1024%2C519\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-30-at-2.26.38%E2%80%AFPM.png?resize=768%2C390\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/Screenshot-2025-01-30-at-2.26.38%E2%80%AFPM.png?resize=1536%2C779\u0026amp;ssl=1 1536w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\u003ch3 id=\"liteyoutubeembed\"\u003e\u003ccode\u003elite-youtube-embed\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003eThis is like embedding a YouTube video, but without bringing along all the baggage that YouTube packs into a typical embed snippet.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;lite-youtube videoid=\u0026#34;ogYfd705cRs\u0026#34; style=\u0026#34;background-image: url(...);\u0026#34;\u0026gt;\n  \u0026lt;a href=\u0026#34;https://youtube.com/watch?v=ogYfd705cRs\u0026#34; class=\u0026#34;lyt-playbtn\u0026#34; title=\u0026#34;Play Video\u0026#34;\u0026gt;\n    \u0026lt;span class=\u0026#34;lyt-visually-hidden\u0026#34;\u0026gt;Play Video: Keynote (Google I/O \u0026#39;18)\u0026lt;/span\u0026gt;\n  \u0026lt;/a\u0026gt;\n\u0026lt;/lite-youtube\u0026gt;\n\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./src.lite-yt-embed.css\u0026#34; /\u0026gt;\n\u0026lt;script src=\u0026#34;./src.lite-yt-embed.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIt starts with a link which is a nice fallback if the video fails to load for whatever reason. When the script runs, the HTML is augmented to include the video \u003ccode\u003e\u0026lt;iframe\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\n\n\u003c/details\u003e\n\n\n\u003cdetails\u003e\n  \u003csummary\u003e\n          \u003ch2\u003eChapter 7: Web Components Frameworks Tour\u003c/h2\u003e\n      \u003c/summary\u003e\n  \n\u003ch3 id=\"lit\"\u003eLit\u003c/h3\u003e\n\n\n\u003cp\u003eLit extends the base class and then extends what that class provides, but you’re still working directly on top of web components. There are syntax shortcuts for common patterns and a more structured approach.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe package includes all this in about 5-7KB:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eFast templating\u003c/li\u003e\n\n\n\n\u003cli\u003eReactive properties\u003c/li\u003e\n\n\n\n\u003cli\u003eReactive update lifecycle\u003c/li\u003e\n\n\n\n\u003cli\u003eScoped styles\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;simple-greeting name=\u0026#34;Geoff\u0026#34;\u0026gt;\u0026lt;/simple-greeting\u0026gt;\n\n\u0026lt;script\u0026gt;\n  import {html, css, LitElement} from \u0026#39;lit\u0026#39;;\n  \n  export class SimpleGreeting extends LitElement {\n    state styles = css`p { color: blue }`;\n    static properties = {\n      name: {type = String},\n    };\n\t\t\n    constructor() {\n      super();\n      this.name = \u0026#39;Somebody\u0026#39;;\n    }\n\t\t\n    render() {\n      return html`\u0026lt;p\u0026gt;Hello, ${this.name}!\u0026lt;/p\u0026gt;`;\n    }\n  }\n\t\n  customElements.define(\u0026#39;simple-greeting\u0026#39;, SimpleGreeting);\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003ePros\u003c/th\u003e\u003cth\u003eCons\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eEcosystem\u003c/td\u003e\u003ctd\u003eNo official SSR story (but that is changing)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCommunity\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eFamiliar ergonomics\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eLightweight\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eIndustry-proven\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\n\u003ch3 id=\"webc\"\u003ewebc\u003c/h3\u003e\n\n\n\u003cp\u003eThis is part of the 11ty project. It allows you to define custom elements as files, writing everything as a single file component.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;!-- starting element / index.html --\u0026gt;\n\u0026lt;my-element\u0026gt;\u0026lt;/my-element\u0026gt;\n\n\u0026lt;!-- ../components/my-element.webc  --\u0026gt;\n\u0026lt;p\u0026gt;This is inside the element\u0026lt;/p\u0026gt;\n\n\u0026lt;style\u0026gt;\n  /* etc. */\n\u0026lt;/style\u0026gt;\n\n\u0026lt;script\u0026gt;\n  // etc.\n\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cp\u003e\n\u003ciframe data-video-id=\"p0wDUK0Z5Nw?feature=oembed\" data-breeze=\"https://www.youtube.com/embed/p0wDUK0Z5Nw?feature=oembed\" loading=\"lazy\" title=\"Interactive Progressively-enhanced Web Components with WebC\" width=\"500\" height=\"281\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen=\"\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003ePros\u003c/th\u003e\u003cth\u003eCons\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eCommunity\u003c/td\u003e\u003ctd\u003eGeared toward SSG\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSSG progressive enhancement\u003c/td\u003e\u003ctd\u003eStill in early stages\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSingle file component syntax\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eZach Leatherman!\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\n\u003ch3 id=\"enhance\"\u003eEnhance\u003c/h3\u003e\n\n\n\u003cp\u003eThis is Scott’s favorite! It renders web components on the server. Web components can render based on application state per request. It’s a way to use custom elements on the server side. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003ePros\u003c/th\u003e\u003cth\u003eCons\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eErgonomics\u003c/td\u003e\u003ctd\u003eStill in early stages\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eProgressive enhancement\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSingle file component syntax\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eFull-stack stateful, dynamic SSR components\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\n\u003c/details\u003e\n\n\n\u003cdetails\u003e\n  \u003csummary\u003e\n          \u003ch2\u003eChapter 8: Web Components Libraries Tour\u003c/h2\u003e\n      \u003c/summary\u003e\n  \n\n\u003cp\u003eThis is a super short module simply highlighting a few of the more notable libraries for web components that are offered by third parties. Scott is quick to note that all of them are closer in spirit to a React-based approach where custom elements are more like replaced elements with very little meaningful markup to display up-front. That’s not to throw shade at the libraries, but rather to call out that there’s a cost when we require JavaScript to render meaningful content.\u003c/p\u003e\n\n\n\u003ch3 id=\"spectrum\"\u003eSpectrum\u003c/h3\u003e\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;sp-button variant=\u0026#34;accent\u0026#34; href=\u0026#34;components/button\u0026#34;\u0026gt;\n  Use Spectrum Web Component buttons\n\u0026lt;/sp-button\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThis is \u003ca href=\"https://spectrum.adobe.com/\" rel=\"noopener\"\u003eAdobe’s design system\u003c/a\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eOne of the more ambitious projects, as it supports other frameworks like React\u003c/li\u003e\n\n\n\n\u003cli\u003eOpen source\u003c/li\u003e\n\n\n\n\u003cli\u003eBuilt on Lit\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eMost components are not exactly HTML-first. The pattern is closer to replaced elements. There’s plenty of complexity, but that makes sense for a system that drives an application like Photoshop and is meant to drop into any project. But still, there is a cost when it comes to delivering meaningful content to users up-front. An all-or-nothing approach like this might be too stark for a small website project.\u003c/p\u003e\n\n\n\u003ch3 id=\"fast\"\u003eFAST\u003c/h3\u003e\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;fast-checkbox\u0026gt;Checkbox\u0026lt;/fast-checkbox\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThis is Microsoft’s system.\u003c/li\u003e\n\n\n\n\u003cli\u003eIt’s philosophically like Spectrum where there’s very little meaningful HTML up-front.\u003c/li\u003e\n\n\n\n\u003cli\u003eFluent is a library that extends the system for UI components.\u003c/li\u003e\n\n\n\n\u003cli\u003eMicrosoft Edge rebuilt the browser’s Chrome using these components.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003ch3 id=\"shoelace\"\u003eShoelace\u003c/h3\u003e\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;sl-button\u0026gt;Click Me\u0026lt;/sl-button\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003ePurely meant for third-party developers to use in their projects\u003c/li\u003e\n\n\n\n\u003cli\u003eThe name is a play on Bootstrap. 🙂\u003c/li\u003e\n\n\n\n\u003cli\u003eThe markup is mostly a custom element with some text in it rather than a pure HTML-first approach.\u003c/li\u003e\n\n\n\n\u003cli\u003eAcquired by Font Awesome and they are creating Web Awesome Components as a new era of Shoelace that is subscription-based\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003c/details\u003e\n\n\n\u003cdetails\u003e\n  \u003csummary\u003e\n          \u003ch2\u003eChapter 9: What’s Next With Web Components\u003c/h2\u003e\n      \u003c/summary\u003e\n  \n\n\u003cp\u003eScott covers what the future holds for web components as far as he is aware.\u003c/p\u003e\n\n\n\u003ch3 id=\"declarative-custom-elements\"\u003eDeclarative custom elements\u003c/h3\u003e\n\n\n\u003cp\u003eDefine an element in HTML alone that can be used time and again with a simpler syntax. There’s a GitHub issue that explains the idea, and \u003ca href=\"https://www.zachleat.com/web/good-bad-web-components/#server-side-rendering\" rel=\"noopener\"\u003eZach Leatherman has a great write-up as well\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"crossroot-aria\"\u003eCross-root ARIA\u003c/h3\u003e\n\n\n\u003cp\u003eMake it easier to pair custom elements with other elements in the Light DOM as well as other custom elements through ARIA.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"container-queries\"\u003eContainer Queries\u003c/h3\u003e\n\n\n\u003cp\u003eHow can we use container queries without needing an extra wrapper around the custom element?\u003c/p\u003e\n\n\n\u003ch3 id=\"html-modules\"\u003eHTML Modules\u003c/h3\u003e\n\n\n\u003cp\u003eThis was one of the web components’ core features but was removed at some point. They can define HTML in an external place that could be used over and over.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"external-styling\"\u003eExternal styling\u003c/h3\u003e\n\n\n\u003cp\u003eThis is also known as “open styling.”\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"dom-parts\"\u003eDOM Parts\u003c/h3\u003e\n\n\n\u003cp\u003eThis would be a templating feature that allows for JSX-string-literal-like syntax where variables inject data.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;section\u0026gt;\n  \u0026lt;h1 id=\u0026#34;name\u0026#34;\u0026gt;{name}\u0026lt;/h1\u0026gt;\n  Email: \u0026lt;a id=\u0026#34;link\u0026#34; href=\u0026#34;mailto:{email}\u0026#34;\u0026gt;{email}\u0026lt;/a\u0026gt;\n\u0026lt;/section\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd the application has produced a template with the following content:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;template\u0026gt;\n  \u0026lt;section\u0026gt;\n    \u0026lt;h1 id=\u0026#34;name\u0026#34;\u0026gt;{{}}\u0026lt;/h1\u0026gt;\n    Email: \u0026lt;a id=\u0026#34;link\u0026#34; href=\u0026#34;{{}}\u0026#34;\u0026gt;{{}}\u0026lt;/a\u0026gt;\n  \u0026lt;/section\u0026gt;\n\u0026lt;/template\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\u003ch3 id=\"scoped-element-registries\"\u003eScoped element registries\u003c/h3\u003e\n\n\n\u003cp\u003eUsing variations of the same web component without name collisions.\u003c/p\u003e\n\n\n\n\n\n\n\u003c/details\u003e\n\n\n\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "59 min read",
  "publishedTime": "2025-03-14T06:51:59-06:00",
  "modifiedTime": "2025-03-14T06:52:02-06:00"
}
