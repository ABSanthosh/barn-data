{
  "id": "00ca75f2-088a-474c-bf98-916f2325aba3",
  "title": "Option Soup: the subtle pitfalls of combining compiler flags",
  "link": "https://hacks.mozilla.org/2024/01/option-soup-the-subtle-pitfalls-of-combining-compiler-flags/",
  "description": "During the Firefox 120 beta cycle, a new crash signature appeared on our radars with significant volume. Engineers working on Firefox, explore the subtle pitfalls of combining compiler flags. The post Option Soup: the subtle pitfalls of combining compiler flags appeared first on Mozilla Hacks - the Web developer blog.",
  "author": "Serge Guelton",
  "published": "Mon, 29 Jan 2024 18:18:33 +0000",
  "source": "https://hacks.mozilla.org/feed/",
  "categories": [
    "Featured Article",
    "Firefox",
    "compiler",
    "firefox",
    "firefox 120"
  ],
  "byline": "",
  "length": 12582,
  "excerpt": "During the Firefox 120 beta cycle, a new crash signature appeared on our radars. Engineers explored the pitfalls of combining compiler flags.",
  "siteName": "Mozilla Hacks – the Web developer blog",
  "favicon": "",
  "text": "Firefox development uncovers many cross-platform differences and unique features of its combination of dependencies. Engineers working on Firefox regularly overcome these challenges and while we can’t detail all of them, we think you’ll enjoy hearing about some so here’s a sample of a recent technical investigation. During the Firefox 120 beta cycle, a new crash signature appeared on our radars with significant volume. At that time, the distribution across operating systems revealed that more than 50% of the crash volume originates from Ubuntu 18.04 LTS users. The main process crashes in a CanvasRenderer thread, with the following call stack: 0  firefox  std::locale::operator=   1  firefox  std::ios_base::imbue   2  firefox  std::basic_ios\u003cchar, std::char_traits\u003cchar\u003e \u003e::imbue   3  libxul.so  sh::InitializeStream\u003cstd::__cxx11::basic_ostringstream\u003cchar, std::char_traits\u003cchar\u003e, std::allocator\u003cchar\u003e \u003e \u003e  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/gfx/angle/checkout/src/compiler/translator/Common.h:238 3  libxul.so  sh::TCompiler::setResourceString  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/gfx/angle/checkout/src/compiler/translator/Compiler.cpp:1294 4  libxul.so  sh::TCompiler::Init  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/gfx/angle/checkout/src/compiler/translator/Compiler.cpp:407 5  libxul.so  sh::ConstructCompiler  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/gfx/angle/checkout/src/compiler/translator/ShaderLang.cpp:368 6  libxul.so  mozilla::webgl::ShaderValidator::Create  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/dom/canvas/WebGLShaderValidator.cpp:215 6  libxul.so  mozilla::WebGLContext::CreateShaderValidator const  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/dom/canvas/WebGLShaderValidator.cpp:196 7  libxul.so  mozilla::WebGLShader::CompileShader  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/dom/canvas/WebGLShader.cpp:98 At first glance, we want to blame WebGL. The C++ standard library functions cannot be at fault, right? But when looking at the WebGL code, the crash occurs in the perfectly valid lines of C++ summarized below: std::ostringstream stream; stream.imbue(std::locale::classic()); This code should never crash, and yet it does. In fact, taking a closer look at the stack gives a first lead for investigation: Although we crash into functions that belong to the C++ standard library, these functions appear to live in the firefox binary. This is an unusual situation that never occurs with official builds of Firefox. It is however very common for distribution to change the configuration settings and apply downstream patches to an upstream source, no worries about that. Moreover, there is only a single build of Firefox Beta that is causing this crash. We know this thanks to a unique identifier associated with any ELF binary. Here, if we choose any specific version of Firefox 120 Beta (such as 120b9), the crashes all embed the same unique identifier for firefox. Now, how can we guess what build produces this weird binary? A useful user comment mentions that they regularly experience this crash since updating to 120.0~b2+build1-0ubuntu0.18.04.1. And by looking for this build identifier, we quickly reach the Firefox Beta PPA. Then indeed, we are able to reproduce the crash by installing it in a Ubuntu 18.04 LTS virtual machine: it occurs when loading any WebGL page! With the binary now at hand, running nm -D ./firefox confirms the presence of several symbols related to libstdc++ that live in the text section (T marker). Templated and inline symbols from libstdc++ usually appear as weak (W marker), so there is only one explanation for this situation: firefox has been statically linked with libstdc++, probably through -static-libstdc++. Fortunately, the build logs are available for all Ubuntu packages. After some digging, we find the logs for the 120b9 build, which indeed contain references to -static-libstdc++. But why? Again, everything is well documented, and thanks to well trained digging skills we reach a bug report that provides interesting insights. Firefox requires a modern C++ compiler, and hence a modern libstdc++, which is unavailable on old systems like Ubuntu 18.04 LTS. The build uses -static-libstdc++ to close this gap. This just explains the weird setup though. What about the crash? Since we can now reproduce it, we can launch Firefox in a debugger and continue our investigation. When inspecting the crash site, we seem to crash because std::locale::classic() is not properly initialized. Let’s take a peek at the implementation. const locale\u0026 locale::classic() { _S_initialize(); return *(const locale*)c_locale; } _S_initialize() is in charge of making sure that c_locale will be properly initialized before we return a reference to it. To achieve this, _S_initialize() calls another function, _S_initialize_once(). void locale::_S_initialize() { #ifdef __GTHREADS if (!__gnu_cxx::__is_single_threaded())    __gthread_once(\u0026_S_once, _S_initialize_once); #endif if (__builtin_expect(!_S_classic, 0))    _S_initialize_once(); } In _S_initialize(), we first go through a wrapper for pthread_once(): the first thread that reaches this code consumes _S_once and calls _S_initialize_once(), whereas other threads (if any) are stuck waiting for _S_initialize_once() to complete. This looks rather fail-proof, right? There is even an extra direct call to _S_initialize_once() if _S_classic is still uninitialized after that. Now, _S_initialize_once() itself is rather straightforward: it allocates _S_classic and puts it within c_locale. void locale::_S_initialize_once() throw() { // Need to check this because we could get called once from _S_initialize() // when the program is single-threaded, and then again (via __gthread_once) // when it's multi-threaded. if (_S_classic)    return; // 2 references. // One reference for _S_classic, one for _S_global _S_classic = new (\u0026c_locale_impl) _Impl(2); _S_global = _S_classic; new (\u0026c_locale) locale(_S_classic); } The crash looks as if we never went through _S_initialize_once(), so let’s put a breakpoint there and see what happens. And just by doing this, we already notice something suspicious. We do reach _S_initialize_once(), but not within the firefox binary: instead, we only ever reach the version exported by liblgpllibs.so. In fact, liblgpllibs.so is also statically linked with libstdc++, such that firefox and liblgpllibs.so both embed and export their own _S_initialize_once() function. By default, symbol interposition applies, and _S_initialize_once() should always be called through the procedure linkage table (PLT), so that every module ends up calling the same version of the function. If symbol interposition were happening here, we would expect that liblgpllibs.so would reach the version of _S_initialize_once() exported by firefox rather than its own, because firefox was loaded first. So maybe there is no symbol interposition. This can occur when using -fno-semantic-interposition. Each version of the standard library would live on its own, independent from the other versions. But neither the Firefox build system nor the Ubuntu maintainer seem to pass this flag to the compiler. However, by looking at the disassembly for _S_initialize() and _S_initialize_once(), we can see that the exported global variables (_S_once, _S_classic, _S_global) are subject to symbol interposition: These accesses all go through the global offset table (GOT), so that every module ends up accessing the same version of the variable. This seems strange given what we said earlier about _S_initialize_once(). Non-exported global variables (c_locale, c_locale_impl), however, are accessed directly without symbol interposition, as expected. We now have enough information to explain the crash. When we reach _S_initialize() in liblgpllibs.so, we actually consume the _S_once that lives in firefox, and initialize the _S_classic and _S_global that live in firefox. But we initialize them with pointers to well initialized variables c_locale_impl and c_locale that live in liblgpllibs.so! The variables c_locale_impl and c_locale that live in firefox, however, remain uninitialized. So if we later reach _S_initialize() in firefox, everything looks as if initialization has happened. But then we return a reference to the version of c_locale that lives in firefox, and this version has never been initialized. Boom! Now the main question is: why do we see interposition occur for _S_once but not for _S_initialize_once()? If we step back for a minute, there is a fundamental distinction between these symbols: one is a function symbol, the other is a variable symbol. And indeed, the Firefox build system uses the -Bsymbolic-function flag! The ld man page describes it as follows: -Bsymbolic-functions When creating a shared library, bind references to global function symbols to the definition within the shared library, if any.  This option is only meaningful on ELF platforms which support shared libraries. As opposed to: -Bsymbolic When creating a shared library, bind references to global symbols to the definition within the shared library, if any.  Normally, it is possible for a program linked against a shared library to override the definition within the shared library. This option is only meaningful on ELF platforms which support shared libraries. Nailed it! The crash occurs because this flag makes us use a weird variant of symbol interposition, where symbol interposition happens for variable symbols like _S_once and _S_classic but not for function symbols like _S_initialize_once(). This results in a mismatch regarding how we access global variables: exported global variables are unique thanks to interposition, whereas every non-interposed function will access its own version of any non-exported global variable. With all the knowledge that we have now gathered, it is easy to write a reproducer that does not involve any Firefox code: /* main.cc */ #include \u003ciostream\u003e extern void pain(); int main() { pain();    std::cout \u003c\u003c \"[main] \" \u003c\u003c std::locale::classic().name() \u003c\u003c\"\\n\";    return 0; } /* pain.cc */ #include \u003ciostream\u003e void pain() { std::cout \u003c\u003c \"[pain] \" \u003c\u003c std::locale::classic().name() \u003c\u003c\"\\n\"; } # Makefile all:    $(CXX) pain.cc -fPIC -shared -o libpain.so -static-libstdc++ -Wl,-Bsymbolic-functions    $(CXX) main.cc -fPIC -c -o main.o    $(CC) main.o -fPIC -o main /usr/lib/gcc/x86_64-redhat-linux/13/libstdc++.a -L. -Wl,-rpath=. -lpain -Wl,-Bsymbolic-functions    ./main clean:    $(RM) libpain.so main Understanding the bug is one step, and solving it is yet another story. Should it be considered a libstdc++ bug that the code for locales is not compatible with -static-stdlibc++ -Bsymbolic-functions? It feels like combining these flags is a very nice way to dig our own grave, and that seems to be the opinion of the libstdc++ maintainers indeed. Overall, perhaps the strangest part of this story is that this combination did not cause any trouble up until now. Therefore, we suggested to the maintainer of the package to stop using -static-libstdc++. There are other ways to use a different libstdc++ than available on the system, such as using dynamic linking and setting an RPATH to link with a bundled version. Doing that allowed them to successfully deploy a fixed version of the package. A few days after that, with the official release of Firefox 120, we noticed a very significant bump in volume for the same crash signature. Not again! This time the volume was coming exclusively from users of NixOS 23.05, and it was huge! After we shared the conclusions from our beta investigation with them, the maintainers of NixOS were able to quickly associate the crash with an issue that had not yet been backported for 23.05 and was causing the compiler to behave like -static-libstdc++. To avoid such mess in the future, we added detection for this particular setup in Firefox’s configure. We are grateful to the people who have helped fix this issue, in particular: Rico Tzschichholz (ricotz) who quickly fixed the Ubuntu 18.04 LTS package, and Amin Bandali (bandali) who provided help on the way; Martin Weinelt (hexa) and Artturin for their prompt fixes for the NixOS 23.05 package; Nicolas B. Pierron (nbp) for helping us get started with NixOS, which allowed us to quickly share useful information with the NixOS package maintainers. More articles by Serge Guelton… More articles by Yannis Juglaret…",
  "image": "https://hacks.mozilla.org/wp-content/uploads/2024/01/Screenshot-2024-01-29-at-18.17.51.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle role=\"article\"\u003e\n    \u003cp\u003e\u003ci\u003eFirefox development uncovers many cross-platform differences and unique features of its combination of dependencies. Engineers working on Firefox regularly overcome these challenges and while we can’t detail all of them, we think you’ll enjoy hearing about some so here’s a sample of a recent technical investigation.\u003c/i\u003e\u003c/p\u003e\n\u003cp\u003eDuring the Firefox 120 beta cycle, \u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1861365\"\u003ea new crash signature appeared on our radars with significant volume\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAt that time, the distribution across operating systems revealed that more than 50% of the crash volume originates from Ubuntu 18.04 LTS users.\u003c/p\u003e\n\u003cp\u003eThe main process crashes in a \u003ccode\u003eCanvasRenderer\u003c/code\u003e thread, with the following call stack:\u003c/p\u003e\n\u003cpre\u003e0  firefox  std::locale::operator=  \n1  firefox  std::ios_base::imbue  \n2  firefox  std::basic_ios\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt;::imbue  \n3  libxul.so  sh::InitializeStream\u0026lt;std::__cxx11::basic_ostringstream\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt; \u0026gt;  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/gfx/angle/checkout/src/compiler/translator/Common.h:238\n3  libxul.so  sh::TCompiler::setResourceString  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/gfx/angle/checkout/src/compiler/translator/Compiler.cpp:1294\n4  libxul.so  sh::TCompiler::Init  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/gfx/angle/checkout/src/compiler/translator/Compiler.cpp:407\n5  libxul.so  sh::ConstructCompiler  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/gfx/angle/checkout/src/compiler/translator/ShaderLang.cpp:368\n6  libxul.so  mozilla::webgl::ShaderValidator::Create  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/dom/canvas/WebGLShaderValidator.cpp:215\n6  libxul.so  mozilla::WebGLContext::CreateShaderValidator const  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/dom/canvas/WebGLShaderValidator.cpp:196\n7  libxul.so  mozilla::WebGLShader::CompileShader  /build/firefox-ZwAdKm/firefox-120.0~b2+build1/dom/canvas/WebGLShader.cpp:98\u003c/pre\u003e\n\u003cp\u003eAt first glance, we want to blame WebGL. The C++ standard library functions cannot be at fault, right?\u003c/p\u003e\n\u003cp\u003eBut when looking at the WebGL code, the crash occurs in the perfectly valid lines of C++ summarized below:\u003c/p\u003e\n\u003cpre\u003estd::ostringstream stream;\nstream.imbue(std::locale::classic());\u003c/pre\u003e\n\u003cp\u003eThis code should never crash, and yet it does. In fact, taking a closer look at the stack gives a first lead for investigation:\u003cbr/\u003e\nAlthough we crash into functions that belong to the C++ standard library, these functions appear to live in the firefox binary.\u003c/p\u003e\n\u003cp\u003eThis is an unusual situation that never occurs with official builds of Firefox.\u003cbr/\u003e\nIt is however very common for distribution to change the configuration settings and apply downstream patches to an upstream source, no worries about that.\u003cbr/\u003e\nMoreover, there is only a single build of Firefox Beta that is causing this crash.\u003c/p\u003e\n\u003cp\u003eWe know this thanks to a unique identifier associated with any ELF binary.\u003cbr/\u003e\nHere, if we choose any specific version of Firefox 120 Beta (such as 120b9), the crashes all embed the same unique identifier for firefox.\u003c/p\u003e\n\u003cp\u003eNow, how can we guess what build produces this weird binary?\u003c/p\u003e\n\u003cp\u003eA useful user comment mentions that they regularly experience this crash since updating to \u003cvar\u003e120.0~b2+build1-0ubuntu0.18.04.1\u003c/var\u003e.\u003cbr/\u003e\nAnd by looking for this build identifier, we quickly reach \u003ca href=\"https://launchpad.net/~mozillateam/+archive/ubuntu/firefox-next\"\u003ethe Firefox Beta PPA\u003c/a\u003e.\u003cbr/\u003e\nThen indeed, we are able to reproduce the crash by installing it in a Ubuntu 18.04 LTS virtual machine: it occurs when loading any WebGL page!\u003cbr/\u003e\nWith the binary now at hand, running \u003ccode\u003enm -D ./firefox\u003c/code\u003e confirms the presence of several symbols related to libstdc++ that live in the text section (\u003ccode\u003eT\u003c/code\u003e marker).\u003c/p\u003e\n\u003cp\u003eTemplated and inline symbols from libstdc++ usually appear as weak (\u003ccode\u003eW\u003c/code\u003e marker), so there is only one explanation for this situation: firefox has been statically linked with libstdc++, probably through \u003ccode\u003e-static-libstdc++\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFortunately, the build logs are available for all Ubuntu packages.\u003cbr/\u003e\nAfter some digging, we find \u003ca href=\"https://launchpadlibrarian.net/697121043/buildlog_ubuntu-bionic-amd64.firefox_120.0~b9+build1-0ubuntu0.18.04.1_BUILDING.txt.gz\"\u003ethe logs for the 120b9 build\u003c/a\u003e, which indeed contain references to \u003ccode\u003e-static-libstdc++\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBut why?\u003c/p\u003e\n\u003cp\u003eAgain, everything is well documented, and thanks to well trained digging skills we reach \u003ca href=\"https://bugs.launchpad.net/ubuntu/+source/firefox/+bug/1856861\"\u003ea bug report\u003c/a\u003e that provides interesting insights.\u003cbr/\u003e\nFirefox requires a modern C++ compiler, and hence a modern libstdc++, which is unavailable on old systems like Ubuntu 18.04 LTS.\u003cbr/\u003e\nThe build uses \u003ccode\u003e-static-libstdc++\u003c/code\u003e to close this gap.\u003cbr/\u003e\nThis just explains the weird setup though.\u003c/p\u003e\n\u003cp\u003eWhat about the crash?\u003c/p\u003e\n\u003cp\u003eSince we can now reproduce it, we can launch Firefox in a debugger and continue our investigation.\u003cbr/\u003e\nWhen inspecting the crash site, we seem to crash because \u003ccode\u003estd::locale::classic()\u003c/code\u003e is not properly initialized.\u003cbr/\u003e\nLet’s take a peek at the implementation.\u003c/p\u003e\n\u003cpre\u003econst locale\u0026amp; locale::classic()\n{\n  _S_initialize();\n  return *(const locale*)c_locale;\n}\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e_S_initialize()\u003c/code\u003e is in charge of making sure that \u003ccode\u003ec_locale\u003c/code\u003e will be properly initialized before we return a reference to it.\u003cbr/\u003e\nTo achieve this, \u003ccode\u003e_S_initialize()\u003c/code\u003e calls another function, \u003ccode\u003e_S_initialize_once()\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003evoid locale::_S_initialize()\n{\n#ifdef __GTHREADS\n  if (!__gnu_cxx::__is_single_threaded())\n    __gthread_once(\u0026amp;_S_once, _S_initialize_once);\n#endif\n\n  if (__builtin_expect(!_S_classic, 0))\n    _S_initialize_once();\n}\u003c/pre\u003e\n\u003cp\u003eIn \u003ccode\u003e_S_initialize()\u003c/code\u003e, we first go through a wrapper for \u003ccode\u003epthread_once()\u003c/code\u003e: the first thread that reaches this code consumes \u003ccode\u003e_S_once\u003c/code\u003e and calls \u003ccode\u003e_S_initialize_once()\u003c/code\u003e, whereas other threads (if any) are stuck waiting for \u003ccode\u003e_S_initialize_once()\u003c/code\u003e to complete.\u003c/p\u003e\n\u003cp\u003eThis looks rather fail-proof, right?\u003c/p\u003e\n\u003cp\u003eThere is even an extra direct call to \u003ccode\u003e_S_initialize_once()\u003c/code\u003e if \u003ccode\u003e_S_classic\u003c/code\u003e is still uninitialized after that.\u003cbr/\u003e\nNow, \u003ccode\u003e_S_initialize_once()\u003c/code\u003e itself is rather straightforward: it allocates \u003ccode\u003e_S_classic\u003c/code\u003e and puts it within \u003ccode\u003ec_locale\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003evoid\nlocale::_S_initialize_once() throw()\n{\n  // Need to check this because we could get called once from _S_initialize()\n  // when the program is single-threaded, and then again (via __gthread_once)\n  // when it\u0026#39;s multi-threaded.\n  if (_S_classic)\n    return;\n\n  // 2 references.\n  // One reference for _S_classic, one for _S_global\n  _S_classic = new (\u0026amp;c_locale_impl) _Impl(2);\n  _S_global = _S_classic;\n  new (\u0026amp;c_locale) locale(_S_classic);\n}\u003c/pre\u003e\n\u003cp\u003eThe crash looks as if we never went through \u003ccode\u003e_S_initialize_once()\u003c/code\u003e, so let’s put a breakpoint there and see what happens.\u003cbr/\u003e\nAnd just by doing this, we already notice something suspicious.\u003cbr/\u003e\nWe do reach \u003ccode\u003e_S_initialize_once()\u003c/code\u003e, but not within the firefox binary: instead, we only ever reach the version exported by liblgpllibs.so.\u003cbr/\u003e\nIn fact, liblgpllibs.so is also statically linked with libstdc++, such that firefox and liblgpllibs.so both embed and export their own \u003ccode\u003e_S_initialize_once()\u003c/code\u003e function.\u003c/p\u003e\n\u003cp\u003eBy default, \u003ci\u003esymbol interposition\u003c/i\u003e applies, and \u003ccode\u003e_S_initialize_once()\u003c/code\u003e should always be called through the procedure linkage table (PLT), so that every module ends up calling the same version of the function.\u003cbr/\u003e\nIf symbol interposition were happening here, we would expect that liblgpllibs.so would reach the version of _S_initialize_once() exported by firefox rather than its own, because firefox was loaded first.\u003c/p\u003e\n\u003cp\u003eSo maybe there is no symbol interposition.\u003c/p\u003e\n\u003cp\u003eThis can occur when using \u003ccode\u003e-fno-semantic-interposition\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eEach version of the standard library would live on its own, independent from the other versions.\u003cbr/\u003e\nBut neither the Firefox build system nor the Ubuntu maintainer seem to pass this flag to the compiler.\u003cbr/\u003e\nHowever, by looking at the disassembly for \u003ccode\u003e_S_initialize()\u003c/code\u003e and \u003ccode\u003e_S_initialize_once()\u003c/code\u003e, we can see that the exported global variables (\u003ccode\u003e_S_once\u003c/code\u003e, \u003ccode\u003e_S_classic\u003c/code\u003e, \u003ccode\u003e_S_global\u003c/code\u003e) \u003cb\u003eare\u003c/b\u003e subject to symbol interposition:\u003c/p\u003e\n\u003cp\u003eThese accesses all go through the global offset table (GOT), so that every module ends up accessing the same version of the variable.\u003cbr/\u003e\nThis seems strange given what we said earlier about \u003ccode\u003e_S_initialize_once()\u003c/code\u003e.\u003cbr/\u003e\nNon-exported global variables (\u003ccode\u003ec_locale\u003c/code\u003e, \u003ccode\u003ec_locale_impl\u003c/code\u003e), however, are accessed directly without symbol interposition, as expected.\u003c/p\u003e\n\u003cp\u003eWe now have enough information to explain the crash.\u003c/p\u003e\n\u003cp\u003eWhen we reach \u003ccode\u003e_S_initialize()\u003c/code\u003e in liblgpllibs.so, we actually consume the \u003ccode\u003e_S_once\u003c/code\u003e that lives in firefox, and initialize the \u003ccode\u003e_S_classic\u003c/code\u003e and \u003ccode\u003e_S_global\u003c/code\u003e that live in firefox.\u003cbr/\u003e\nBut we initialize them with pointers to well initialized variables \u003ccode\u003ec_locale_impl\u003c/code\u003e and \u003ccode\u003ec_locale\u003c/code\u003e that live in liblgpllibs.so!\u003cbr/\u003e\nThe variables \u003ccode\u003ec_locale_impl\u003c/code\u003e and \u003ccode\u003ec_locale\u003c/code\u003e that live in firefox, however, remain uninitialized.\u003c/p\u003e\n\u003cp\u003eSo if we later reach \u003ccode\u003e_S_initialize()\u003c/code\u003e in firefox, everything looks as if initialization has happened.\u003cbr/\u003e\nBut then we return a reference to the version of \u003ccode\u003ec_locale\u003c/code\u003e that lives in firefox, and this version has never been initialized.\u003c/p\u003e\n\u003cp\u003eBoom!\u003c/p\u003e\n\u003cp\u003eNow the main question is: why do we see interposition occur for \u003ccode\u003e_S_once\u003c/code\u003e but not for \u003ccode\u003e_S_initialize_once()\u003c/code\u003e?\u003cbr/\u003e\nIf we step back for a minute, there is a fundamental distinction between these symbols: one is a function symbol, the other is a variable symbol.\u003cbr/\u003e\nAnd indeed, the Firefox build system uses the \u003ccode\u003e-Bsymbolic-function\u003c/code\u003e flag!\u003c/p\u003e\n\u003cp\u003eThe ld man page describes it as follows:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cpre\u003e-Bsymbolic-functions\n\nWhen creating a shared library, bind references to global function symbols to the definition within the shared library, if any.  This option is only meaningful on ELF platforms which support shared libraries.\u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAs opposed to:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cpre\u003e-Bsymbolic\n\nWhen creating a shared library, bind references to global symbols to the definition within the shared library, if any.  Normally, it is possible for a program linked against a shared library to override the definition within the shared library. This option is only meaningful on ELF platforms which support shared libraries.\u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eNailed it!\u003c/p\u003e\n\u003cp\u003eThe crash occurs because this flag makes us use a weird variant of symbol interposition, where symbol interposition happens for variable symbols like \u003ccode\u003e_S_once\u003c/code\u003e and \u003ccode\u003e_S_classic\u003c/code\u003e but not for function symbols like \u003ccode\u003e_S_initialize_once()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis results in a mismatch regarding how we access global variables: exported global variables are unique thanks to interposition, whereas every non-interposed function will access its own version of any non-exported global variable.\u003c/p\u003e\n\u003cp\u003eWith all the knowledge that we have now gathered, it is easy to write a reproducer that does not involve any Firefox code:\u003c/p\u003e\n\u003cpre\u003e/* main.cc */\n#include \u0026lt;iostream\u0026gt;\nextern void pain();\nint main() {\npain();\n   std::cout \u0026lt;\u0026lt; \u0026#34;[main] \u0026#34; \u0026lt;\u0026lt; std::locale::classic().name() \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;\n   return 0;\n}\n\n/* pain.cc */\n\n#include \u0026lt;iostream\u0026gt;\nvoid pain() {\nstd::cout \u0026lt;\u0026lt; \u0026#34;[pain] \u0026#34; \u0026lt;\u0026lt; std::locale::classic().name() \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;\n}\n\n# Makefile\nall:\n   $(CXX) pain.cc -fPIC -shared -o libpain.so -static-libstdc++ -Wl,-Bsymbolic-functions\n   $(CXX) main.cc -fPIC -c -o main.o\n   $(CC) main.o -fPIC -o main /usr/lib/gcc/x86_64-redhat-linux/13/libstdc++.a -L. -Wl,-rpath=. -lpain -Wl,-Bsymbolic-functions\n   ./main\n\nclean:\n   $(RM) libpain.so main\n\u003c/pre\u003e\n\u003cp\u003eUnderstanding the bug is one step, and solving it is yet another story.\u003cbr/\u003e\nShould it be considered a libstdc++ bug that the code for locales is not compatible with \u003ccode\u003e-static-stdlibc++ -Bsymbolic-functions\u003c/code\u003e?\u003c/p\u003e\n\u003cp\u003eIt feels like combining these flags is a very nice way to dig our own grave, and \u003ca href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=112551\"\u003ethat seems to be the opinion of the libstdc++ maintainers indeed\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eOverall, perhaps the strangest part of this story is that this combination did not cause any trouble up until now.\u003cbr/\u003e\nTherefore, we suggested to the maintainer of the package to stop using \u003ccode\u003e-static-libstdc++\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThere are other ways to use a different libstdc++ than available on the system, such as using dynamic linking and setting an \u003ccode\u003eRPATH\u003c/code\u003e to link with a bundled version.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1861365#c11\"\u003eDoing that\u003c/a\u003e allowed them to successfully deploy a fixed version of the package.\u003cbr/\u003e\nA few days after that, with the official release of Firefox 120, we noticed a very significant bump in volume for the same crash signature. Not again!\u003c/p\u003e\n\u003cp\u003eThis time the volume was coming exclusively from users of NixOS 23.05, and it was huge!\u003c/p\u003e\n\u003cp\u003eAfter we shared the conclusions from our beta investigation with them, the maintainers of NixOS were able to \u003ca href=\"https://github.com/NixOS/nixpkgs/issues/269571#issuecomment-1825836670\"\u003equickly associate\u003c/a\u003e the crash with \u003ca href=\"https://github.com/NixOS/nixpkgs/pull/192459\"\u003ean issue that had not yet been backported \u003c/a\u003efor 23.05 and was causing the compiler to behave like \u003ccode\u003e-static-libstdc++\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTo avoid such mess in the future, \u003ca href=\"https://phabricator.services.mozilla.com/rMOZILLACENTRAL0930954b46bbc315ffcb92658bde0efc2945b04b\"\u003ewe added detection for this particular setup in Firefox’s configure\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWe are grateful to the people who have helped fix this issue, in particular:\u003c/p\u003e\n\u003cul\u003e\n\u003cli aria-level=\"1\"\u003eRico Tzschichholz (ricotz) who quickly fixed the Ubuntu 18.04 LTS package, and Amin Bandali (bandali) who provided help on the way;\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003eMartin Weinelt (hexa) and Artturin for their prompt fixes for the NixOS 23.05 package;\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003eNicolas B. Pierron (nbp) for helping us get started with NixOS, which allowed us to quickly share useful information with the NixOS package maintainers.\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003csection\u003e\n                                \n                                \u003cp\u003e\u003ca href=\"https://hacks.mozilla.org/author/sgueltonmozilla-com/\"\u003eMore articles by Serge Guelton…\u003c/a\u003e\u003c/p\u003e\n                  \n                                \u003cp\u003e\u003ca href=\"https://hacks.mozilla.org/author/yjuglaretmozilla-com/\"\u003eMore articles by Yannis Juglaret…\u003c/a\u003e\u003c/p\u003e\n                  \u003c/section\u003e\n  \u003c/article\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
