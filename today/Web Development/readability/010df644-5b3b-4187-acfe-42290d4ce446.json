{
  "id": "010df644-5b3b-4187-acfe-42290d4ce446",
  "title": "A Primer on Focus Trapping",
  "link": "https://css-tricks.com/a-primer-on-focus-trapping/",
  "description": "Focus trapping is about managing focus within an element, such that focus always stays within it. The whole process sounds simple in theory, but it can quite difficult to build in practice, mostly because of the numerous parts to you got to manage. A Primer on Focus Trapping originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Zell Liew",
  "published": "Mon, 21 Jul 2025 13:14:17 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "accessibility",
    "JavaScript"
  ],
  "byline": "Zell Liew",
  "length": 7706,
  "excerpt": "Focus trapping is about managing focus within an element, such that focus always stays within it. The whole process sounds simple in theory, but it can quite difficult to build in practice, mostly because of the numerous parts to you got to manage.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "Focus trapping is a term that refers to managing focus within an element, such that focus always stays within it: If a user tries to tab out from the last element, we return focus to the first one. If the user tries to Shift + Tab out of the first element, we return focus back to the last one. This whole focus trap thing is used to create accessible modal dialogs since it’s a whole ‘nother trouble to inert everything else — but you don’t need it anymore if you’re building modals with the dialog API (assuming you do it right). Anyway, back to focus trapping. The whole process sounds simple in theory, but it can quite difficult to build in practice, mostly because of the numerous parts to you got to manage. Simple and easy focus trapping with Splendid Labz If you are not averse to using code built by others, you might want to consider this snippet with the code I’ve created in Splendid Labz. The basic idea is: We detect all focusable elements within an element. We manage focus with a keydown event listener. import { getFocusableElements, trapFocus } from '@splendidlabz/utils/dom' const dialog = document.querySelector('dialog') // Get all focusable content const focusables = getFocusableElements(node) // Traps focus within the dialog dialog.addEventListener('keydown', event =\u003e { trapFocus({ event, focusables }) }) The above code snippet makes focus trapping extremely easy. But, since you’re reading this, I’m sure you wanna know the details that go within each of these functions. Perhaps you wanna build your own, or learn what’s going on. Either way, both are cool — so let’s dive into it. Selecting all focusable elements I did research when I wrote about this some time ago. It seems like you could only focus an a handful of elements: a button input textarea select details iframe embed object summary dialog audio[controls] video[controls] [contenteditable] [tabindex] So, the first step in getFocusableElements is to search for all focusable elements within a container: export function getFocusableElements(container = document.body ) { return { get all () { const elements = Array.from( container.querySelectorAll( `a, button, input, textarea, select, details, iframe, embed, object, summary, dialog, audio[controls], video[controls], [contenteditable], [tabindex] `, ), ) } } } Next, we want to filter away elements that are disabled, hidden or set with display: none, since they cannot be focused on. We can do this with a simple filter function. export function getFocusableElements(container = document.body ) { return { get all () { // ... return elements.filter(el =\u003e { if (el.hasAttribute('disabled')) return false if (el.hasAttribute('hidden')) return false if (window.getComputedStyle(el).display === 'none') return false return true }) } } } Next, since we want to trap keyboard focus, it’s only natural to retrieve a list of keyboard-only focusable elements. We can do that easily too. We only need to remove all tabindex values that are less than 0. export function getFocusableElements(container = document.body ) { return { get all () { /* ... */ }, get keyboardOnly() { return this.all.filter(el =\u003e el.tabIndex \u003e -1) } } } Now, remember that there are two things we need to do for focus trapping: If a user tries to tab out from the last element, we return focus to the first one. If the user tries to Shift + Tab out of the first element, we return focus back to the last one. This means we need to be able to find the first focusable item and the last focusable item. Luckily, we can add first and last getters to retrieve these elements easily inside getFocusableElements. In this case, since we’re dealing with keyboard elements, we can grab the first and last items from keyboardOnly: export function getFocusableElements(container = document.body ) { return { // ... get first() { return this.keyboardOnly[0] }, get last() { return this.keyboardOnly[0] }, } } We have everything we need — next is to implement the focus trapping functionality. How to trap focus First, we need to detect a keyboard event. We can do this easily with addEventListener: const container = document.querySelector('.some-element') container.addEventListener('keydown', event =\u003e {/* ... */}) We need to check if the user is: Pressing tab (without Shift) Pressing tab (with Shift) Splendid Labz has convenient functions to detect these as well: import { isTab, isShiftTab } from '@splendidlabz/utils/dom' // ... container.addEventListener('keydown', event =\u003e { if (isTab(event)) // Handle Tab if (isShiftTab(event)) // Handle Shift Tab /* ... */ }) Of course, in the spirit of learning, let’s figure out how to write the code from scratch: You can use event.key to detect whether the Tab key is being pressed. You can use event.shiftKey to detect if the Shift key is being pressed Combine these two, you will be able to write your own isTab and isShiftTab functions: export function isTab(event) { return !event.shiftKey \u0026\u0026 event.key === 'Tab' } export function isShiftTab(event) { return event.shiftKey \u0026\u0026 event.key === 'Tab' } Since we’re only handling the Tab key, we can use an early return statement to skip the handling of other keys. container.addEventListener('keydown', event =\u003e { if (event.key !== 'Tab') return if (isTab(event)) // Handle Tab if (isShiftTab(event)) // Handle Shift Tab /* ... */ }) We have almost everything we need now. The only thing is to know where the current focused element is at — so we can decide whether to trap focus or allow the default focus action to proceed. We can do this with document.activeElement. Going back to the steps: Shift focus if user Tab on the last item Shift focus if the user Shift + Tab on the first item Naturally, you can tell that we need to check whether document.activeElement is the first or last focusable item. container.addEventListener('keydown', event =\u003e { // ... const focusables = getFocusableElements(container) const first = focusables.first const last = focusables.last if (document.activeElement === last \u0026\u0026 isTab(event)) { // Shift focus to the first item } if (document.activeElement === first \u0026\u0026 isShiftTab(event)) { // Shift focus to the last item } }) The final step is to use focus to bring focus to the item. container.addEventListener('keydown', event =\u003e { // ... if (document.activeElement === last \u0026\u0026 isTab(event)) { first.focus() } if (document.activeElement === first \u0026\u0026 isShiftTab(event)) { last.focus() } }) That’s it! Pretty simple if you go through the sequence step-by-step, isn’t it? Final callout to Splendid Labz As I resolve myself to stop teaching (so much) and begin building applications, I find myself needing many common components, utilities, even styles. Since I have the capability to build things for myself, (plus the fact that I’m super particular when it comes to good DX), I’ve decided to gather these things I find or build into a couple of easy-to-use libraries. Just sharing these with you in hopes that they will help speed up your development workflow. Thanks for reading my shameless plug. All the best for whatever you decide to code!",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2019/04/tab-key.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eFocus trapping is a term that refers to managing focus within an element, such that focus always stays within it:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIf a user tries to tab out from the last element, we return focus to the first one.\u003c/li\u003e\n\n\n\n\u003cli\u003eIf the user tries to \u003ckbd\u003eShift\u003c/kbd\u003e + \u003ckbd\u003eTab\u003c/kbd\u003e out of the first element, we return focus back to the last one.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThis whole focus trap thing is used to create accessible modal dialogs since it’s a whole ‘nother trouble to \u003ccode\u003einert\u003c/code\u003e everything else — \u003ca href=\"https://css-tricks.com/clarifying-the-relationship-between-popovers-and-dialogs/\"\u003ebut you don’t need it anymore\u003c/a\u003e if you’re building modals with the \u003ccode\u003edialog\u003c/code\u003e API (assuming you do it right).\u003c/p\u003e\n\n\n\n\u003cp\u003eAnyway, back to focus trapping.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe whole process sounds simple in theory, but it can quite difficult to build in practice, mostly because of the numerous parts to you got to manage.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"simple-and-easy-focus-trapping-with-splendid-labz\"\u003eSimple and easy focus trapping with Splendid Labz\u003c/h3\u003e\n\n\n\u003cp\u003eIf you are not averse to using code built by others, you might want to consider this snippet with the code I’ve created in \u003ca href=\"https://splendidlabz.com/\" rel=\"noopener\"\u003eSplendid Labz\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe basic idea is:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eWe detect all focusable elements within an element.\u003c/li\u003e\n\n\n\n\u003cli\u003eWe manage focus with a keydown event listener.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eimport { getFocusableElements, trapFocus } from \u0026#39;@splendidlabz/utils/dom\u0026#39;\n\nconst dialog = document.querySelector(\u0026#39;dialog\u0026#39;)\n\n// Get all focusable content\nconst focusables = getFocusableElements(node)\n\n// Traps focus within the dialog\ndialog.addEventListener(\u0026#39;keydown\u0026#39;, event =\u0026gt; {\n  trapFocus({ event, focusables })\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe above code snippet makes focus trapping extremely easy.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut, since you’re reading this, I’m sure you wanna know the details that go within each of these functions. Perhaps you wanna build your own, or learn what’s going on. Either way, both are cool — so let’s dive into it.\u003c/p\u003e\n\n\n\u003ch3 id=\"selecting-all-focusable-elements\"\u003eSelecting all focusable elements\u003c/h3\u003e\n\n\n\u003cp\u003eI did research when I wrote about this \u003ca href=\"https://zellwk.com/blog/keyboard-focusable-elements/\" rel=\"noopener\"\u003esome time ago\u003c/a\u003e. It seems like you could only focus an a handful of elements:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ea\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003ebutton\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003einput\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003etextarea\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eselect\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003edetails\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eiframe\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eembed\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eobject\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003esummary\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003edialog\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eaudio[controls]\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003evideo[controls]\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e[contenteditable]\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e[tabindex]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eSo, the first step in \u003ccode\u003egetFocusableElements\u003c/code\u003e is to search for all focusable elements within a container:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eexport function getFocusableElements(container = document.body ) {\n\n  return {\n    get all () {\n      const elements = Array.from(\n        container.querySelectorAll(\n          `a,\n            button,\n            input,\n            textarea,\n            select,\n            details,\n            iframe,\n            embed,\n            object,\n            summary,\n            dialog,\n            audio[controls],\n            video[controls],\n            [contenteditable],\n            [tabindex]\n          `,\n        ),\n      )\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, we want to filter away elements that are \u003ccode\u003edisabled\u003c/code\u003e, \u003ccode\u003ehidden\u003c/code\u003e or set with \u003ccode\u003edisplay: none\u003c/code\u003e, since they cannot be focused on. We can do this with a simple \u003ccode\u003efilter\u003c/code\u003e function.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eexport function getFocusableElements(container = document.body ) {\n\n  return {\n    get all () {\n      // ...\n      return elements.filter(el =\u0026gt; {\n        if (el.hasAttribute(\u0026#39;disabled\u0026#39;)) return false\n        if (el.hasAttribute(\u0026#39;hidden\u0026#39;)) return false\n        if (window.getComputedStyle(el).display === \u0026#39;none\u0026#39;) return false\n        return true\n      })\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, since we want to trap keyboard focus, it’s only natural to retrieve a list of keyboard-only focusable elements. We can do that easily too. We only need to remove all \u003ccode\u003etabindex\u003c/code\u003e values that are less than \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eexport function getFocusableElements(container = document.body ) {\n  return {\n    get all () { /* ... */ },\n    get keyboardOnly() {\n      return this.all.filter(el =\u0026gt; el.tabIndex \u0026gt; -1)\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow, remember that there are two things we need to do for focus trapping:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIf a user tries to tab out from the last element, we return focus to the first one.\u003c/li\u003e\n\n\n\n\u003cli\u003eIf the user tries to \u003ckbd\u003eShift\u003c/kbd\u003e + \u003ckbd\u003eTab\u003c/kbd\u003e out of the first element, we return focus back to the last one.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThis means we need to be able to find the first focusable item and the last focusable item. Luckily, we can add \u003ccode\u003efirst\u003c/code\u003e and \u003ccode\u003elast\u003c/code\u003e getters to retrieve these elements easily inside \u003ccode\u003egetFocusableElements\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this case, since we’re dealing with keyboard elements, we can grab the first and last items from \u003ccode\u003ekeyboardOnly\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eexport function getFocusableElements(container = document.body ) {\n  return {\n    // ...\n    get first() { return this.keyboardOnly[0] },\n    get last() { return this.keyboardOnly[0] },\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe have everything we need — next is to implement the focus trapping functionality.\u003c/p\u003e\n\n\n\u003ch3 id=\"how-to-trap-focus\"\u003eHow to trap focus\u003c/h3\u003e\n\n\n\u003cp\u003eFirst, we need to detect a keyboard event. We can do this easily with \u003ccode\u003eaddEventListener\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst container = document.querySelector(\u0026#39;.some-element\u0026#39;)\ncontainer.addEventListener(\u0026#39;keydown\u0026#39;, event =\u0026gt; {/* ... */})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe need to check if the user is:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003ePressing tab (without \u003ckbd\u003eShift\u003c/kbd\u003e)\u003c/li\u003e\n\n\n\n\u003cli\u003ePressing tab (with \u003ckbd\u003eShift\u003c/kbd\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://splendidlabz.com/\" rel=\"noopener\"\u003eSplendid Labz\u003c/a\u003e has convenient functions to detect these as well:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eimport { isTab, isShiftTab } from \u0026#39;@splendidlabz/utils/dom\u0026#39;\n\n// ...\ncontainer.addEventListener(\u0026#39;keydown\u0026#39;, event =\u0026gt; {\n  if (isTab(event)) // Handle Tab\n  if (isShiftTab(event)) // Handle Shift Tab\n  /* ... */\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOf course, in the spirit of learning, let’s figure out how to write the code from scratch:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eYou can use \u003ccode\u003eevent.key\u003c/code\u003e to detect whether the \u003ckbd\u003eTab\u003c/kbd\u003e key is being pressed.\u003c/li\u003e\n\n\n\n\u003cli\u003eYou can use \u003ccode\u003eevent.shiftKey\u003c/code\u003e to detect if the \u003ckbd\u003eShift\u003c/kbd\u003e key is being pressed\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eCombine these two, you will be able to write your own \u003ccode\u003eisTab\u003c/code\u003e and \u003ccode\u003eisShiftTab\u003c/code\u003e functions:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eexport function isTab(event) {\n  return !event.shiftKey \u0026amp;\u0026amp; event.key === \u0026#39;Tab\u0026#39;\n}\n\nexport function isShiftTab(event) {\n  return event.shiftKey \u0026amp;\u0026amp; event.key === \u0026#39;Tab\u0026#39;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSince we’re only handling the \u003ckbd\u003eTab\u003c/kbd\u003e key, we can use an early return statement to skip the handling of other keys.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"2\"\u003e\u003ccode markup=\"tt\"\u003econtainer.addEventListener(\u0026#39;keydown\u0026#39;, event =\u0026gt; {\n  if (event.key !== \u0026#39;Tab\u0026#39;) return\n\n  if (isTab(event)) // Handle Tab\n  if (isShiftTab(event)) // Handle Shift Tab\n  /* ... */\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe have almost everything we need now. The only thing is to know where the current focused element is at — so we can decide whether to trap focus or allow the default focus action to proceed.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can do this with \u003ccode\u003edocument.activeElement\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eGoing back to the steps:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eShift focus if user \u003ckbd\u003eTab\u003c/kbd\u003e on the \u003cem\u003elast item\u003c/em\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eShift focus if the user \u003ckbd\u003eShift\u003c/kbd\u003e + \u003ckbd\u003eTab\u003c/kbd\u003e on the \u003cem\u003efirst\u003c/em\u003e item\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eNaturally, you can tell that we need to check whether \u003ccode\u003edocument.activeElement\u003c/code\u003e is the first or last focusable item.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econtainer.addEventListener(\u0026#39;keydown\u0026#39;, event =\u0026gt; {\n  // ...\n  const focusables = getFocusableElements(container)\n  const first = focusables.first\n  const last = focusables.last\n\n  if (document.activeElement === last \u0026amp;\u0026amp; isTab(event)) {\n    // Shift focus to the first item\n  }\n\n  if (document.activeElement === first \u0026amp;\u0026amp; isShiftTab(event)) {\n    // Shift focus to the last item\n  }\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe final step is to use \u003ccode\u003efocus\u003c/code\u003e to bring focus to the item.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econtainer.addEventListener(\u0026#39;keydown\u0026#39;, event =\u0026gt; {\n  // ...\n\n  if (document.activeElement === last \u0026amp;\u0026amp; isTab(event)) {\n    first.focus()\n  }\n\n  if (document.activeElement === first \u0026amp;\u0026amp; isShiftTab(event)) {\n    last.focus()\n  }\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThat’s it! Pretty simple if you go through the sequence step-by-step, isn’t it?\u003c/p\u003e\n\n\n\u003ch3 id=\"final-callout-to-splendid-labz\"\u003eFinal callout to Splendid Labz\u003c/h3\u003e\n\n\n\u003cp\u003eAs I resolve myself to stop teaching (so much) and begin building applications, I find myself needing many common \u003ca href=\"https://splendidlabz/docs/astro/\"\u003ecomponents\u003c/a\u003e, \u003ca href=\"https://splendidlabz/docs/utils/\"\u003eutilities\u003c/a\u003e, even \u003ca href=\"https://splendidlabz.com/docs/styles/\" rel=\"noopener\"\u003estyles\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eSince I have the capability to build things for myself, (plus the fact that I’m super particular when it comes to good DX), I’ve decided to gather these things I find or build into a couple of easy-to-use libraries.\u003c/p\u003e\n\n\n\n\u003cp\u003eJust sharing these with you in hopes that they will help speed up your development workflow.\u003c/p\u003e\n\n\n\n\u003cp\u003eThanks for reading my shameless plug. All the best for whatever you decide to code!\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-07-21T07:14:17-06:00",
  "modifiedTime": "2025-07-22T06:43:50-06:00"
}
