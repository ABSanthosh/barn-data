{
  "id": "66abc34c-5ed5-4817-9be7-c19db6dbd7fa",
  "title": "Porting a cross-platform GUI application to Rust",
  "link": "https://hacks.mozilla.org/2024/04/porting-a-cross-platform-gui-application-to-rust/",
  "description": "In this blog post, we delve into the motivations for choosing Rust for our crash reporter, outline the unique challenges of designing an application that operates when the main browser has failed, and discuss the new architecture we've implemented. We also share insights into the technical nuances of the implementation, demonstrating how Rust's features are leveraged to handle crashes more effectively and securely. The post Porting a cross-platform GUI application to Rust appeared first on Mozilla Hacks - the Web developer blog.",
  "author": "Alex Franchuk",
  "published": "Tue, 23 Apr 2024 19:08:08 +0000",
  "source": "https://hacks.mozilla.org/feed/",
  "categories": [
    "Crash Reporting",
    "Developer Tools",
    "Featured Article",
    "Firefox",
    "rust",
    "Rust",
    "crash reporting",
    "firefox",
    "window"
  ],
  "byline": "By Alex Franchuk",
  "length": 28130,
  "excerpt": "The Firefox crash reporter has been ported to Rust, with an architecture supporting native cross-platform GUI rendering.",
  "siteName": "Mozilla Hacks – the Web developer blog",
  "favicon": "",
  "text": "Firefox’s crash reporter is hopefully not something that most users experience often. However, it is still a very important component of Firefox, as it is integral in providing insight into the most visible bugs: those which crash the main process. These bugs offer the worst user experience (since the entire application must close), so fixing them is a very high priority. Other types of crashes, such as content (tab) crashes, can be handled by the browser and reported gracefully, sometimes without the user being aware that an issue occurred at all. But when the main browser process comes to a halt, we need another separate application to gather information about the crash and interact with the user. This post details the approach we have taken to rewrite the crash reporter in Rust. We discuss the reasoning behind this rewrite, what makes the crash reporter a unique application, the architecture we used, and some details of the implementation. Why Rewrite? Even though it is important to properly handle main process crashes, the crash reporter hasn’t received significant development in a while (aside from development to ensure that crash reports and telemetry continue to reliably be delivered)! It has long been stuck in a local maximum of “good enough” and “scary to maintain”: it features 3 individual GUI implementations (for Windows, GTK+ for Linux, and macOS), glue code abstracting a few things (mostly in C++, and Objective-C for macOS), a binary blob produced by obsoleted Apple development tools, and no test suite. Because of this, there is a backlog of features and improvements which haven’t been acted on. We’ve recently had a number of successful pushes to decrease crash rates (including both big leaps and many small bug fixes), and the crash reporter has functioned well enough for our needs during this time. However, we’ve reached an inflection point where improving the crash reporter would provide valuable insight to enable us to decrease the crash rate even further. For the reasons previously mentioned, improving the current codebase is difficult and error-prone, so we deemed it appropriate to rewrite the application so we can more easily act on the feature backlog and improve crash reports. Like many components of Firefox, we decided to use Rust for this rewrite to produce a more reliable and maintainable program. Besides the often-touted memory safety built into Rust, its type system and standard library make reasoning about code, handling errors, and developing cross-platform applications far more robust and comprehensive. Crash Reporting is an Edge Case There are a number of features of the crash reporter which make it quite unique, especially compared to other components which have been ported to Rust. For one thing, it is a standalone, individual program; basically no other components of Firefox are used in this way. Firefox itself launches many processes as a means of sandboxing and insulating against crashes, however these processes all talk to one another and have access to the same code base. The crash reporter has a very unique requirement: it must use as little as possible of the Firefox code base, ideally none! We don’t want it to rely on code which may be buggy and cause the reporter itself to crash. Using a completely independent implementation ensures that when a main process crash does occur, the cause of that crash won’t affect the reporter’s functionality as well. The crash reporter also necessarily has a GUI. This alone may not separate it from other Firefox components, but we can’t leverage any of the cross-platform rendering goodness that Firefox provides! So we need to implement a cross-platform GUI independent of Firefox as well. You might think we could reach for an existing cross-platform GUI crate, however we have a few reasons not to do so. We want to minimize the use of external code: to improve crash reporter reliability (which is paramount), we want it to be as simple and auditable as possible. Firefox vendors all dependencies in-tree, so we are hesitant to bring in large dependencies (GUI libraries are likely pretty sizable). There are only a few third-party crates that provide a native OS look and feel (or actually use native GUI APIs): it’s desirable for the crash reporter to have a native feel to be familiar to users and take advantage of accessibility features. So all of this is to say that third-party cross-platform GUI libraries aren’t a favorable option. These requirements significantly narrow the approach that can be used. Building a GUI View Abstraction In order to make the crash reporter more maintainable (and make it easier to add new features in the future), we want to have as minimal and generic platform-specific code as possible. We can achieve this by using a simple UI model that can be converted into native GUI code for each platform. Each UI implementation will need to provide two methods (over arbitrary platform-specific \u0026self data): /// Run a UI loop, displaying all windows of the application until it terminates. fn run_loop(\u0026self, app: model::Application) /// Invoke a function asynchronously on the UI loop thread. fn invoke(\u0026self, f: model::InvokeFn) The run_loop function is pretty self-explanatory: the UI implementation takes an Application model (which we’ll discuss shortly) and runs the application, blocking until the application is complete. Conveniently, our target platforms generally have similar assumptions around threading: the UI runs in a single thread and typically runs an event loop which blocks on new events until an event signaling the end of the application is received. There are some cases where we’ll need to run a function on the UI thread asynchronously (like displaying a window, updating a text field, etc). Since run_loop blocks, we need the invoke method to define how to do this. This threading model will make it easy to use the platform GUI frameworks: everything calling native functions will occur on a single thread (the main thread in fact) for the duration of the program. This is a good time to be a bit more specific about exactly what each UI implementation will look like. We’ll discuss pain points for each later on. There are 4 UI implementations: A Windows implementation using the Win32 API. A macOS implementation using Cocoa (AppKit and Foundation frameworks). A Linux implementation using GTK+ 3 (the “+” has since been dropped in GTK 4, so henceforth I’ll refer to it as “GTK”). Linux doesn’t provide its own GUI primitives, and we already ship GTK with Firefox on Linux to make a modern-feeling GUI, so we can use it for the crash reporter, too. Note that some platforms that aren’t directly supported by Mozilla (like BSDs) use the GTK implementation as well. A testing implementation which will allow tests to hook into a virtual UI and poke things (to simulate interactions and read state). One last detail before we dive in: the crash reporter (at least right now) has a pretty simple GUI. Because of this, an explicit non-goal of the development was to create a separate Rust GUI crate. We wanted to create just enough of an abstraction to cover the cases we needed in the crash reporter. If we need more controls in the future, we can add them to the abstraction, but we avoided spending extra cycles to fill out every GUI use case. Likewise, we tried to avoid unnecessary development by allowing some tolerance for hacks and built-in edge cases. For example, our model defines a Button as an element which contains an arbitrary element, but actually supporting that with Win32 or AppKit would have required a lot of custom code, so we special case on a Button containing a Label (which is all we need right now, and an easy primitive available to us). I’m happy to say there aren’t really many special cases like that at all, but we are comfortable with the few that were needed. The UI Model Our model is a declarative structuring of concepts mostly present in GTK. Since GTK is a mature library with proven high-level UI concepts, this made it appropriate for our abstraction and made the GTK implementation pretty simple. For instance, the simplest way that GTK does layout (using container GUI elements and per-element margins/alignments) is good enough for our GUI, so we use similar definitions in the model. Notably, this “simple” layout definition is actually somewhat high-level and complicates the macOS and Windows implementations a bit (but this tradeoff is worth the ease of creating UI models). The top-level type of our UI model is Application. This is pretty simple: we define an Application as a set of top-level Windows (though our application only has one) and whether the current locale is right-to-left. We inspect Firefox resources to use the same locale that Firefox would, so we don’t rely on the native GUI’s locale settings. As you might expect, each Window contains a single root element. The rest of the model is made up of a handful of typical container and primitive GUI elements: The crash reporter only needs 8 types of GUI elements! And really, Progress is used as a spinner rather than indicating any real progress as of right now, so it’s not strictly necessary (but nice to show). Rust does not explicitly support the object-oriented concept of inheritance, so you might be wondering how each GUI element “extends” Element. The relationship represented in the picture is somewhat abstract; the implemented Element looks like: pub struct Element { pub style: ElementStyle, pub element_type: ElementType } where ElementStyle contains all the common properties of elements (alignment, size, margin, visibility, and enabled state), and ElementType is an enum containing each of the specific GUI elements as variants. Building the Model The model elements are all intended to be consumed by the UI implementations; as such, almost all of the fields have public visibility. However, as a means of having a separate interface for building elements, we define an ElementBuilder\u003cT\u003e type. This type has methods that maintain assertions and provide convenience setters. For instance, many methods accept parameters that are impl Into\u003cMemberType\u003e, some methods like margin() set multiple values (but you can be more specific with margin_top()), etc. There is a general impl\u003cT\u003e ElementBuilder\u003cT\u003e which provides setters for the various ElementStyle properties, and then each specific element type can also provide their own impl ElementBuilder\u003cSpecificElement\u003e with additional properties unique to the element type. We combine ElementBuilder\u003cT\u003e with the final piece of the puzzle: a ui! macro. This macro allows us to write our UI in a declarative manner. For example, it allows us to write: let details_window = ui! { Window title(\"Crash Details\") visible(show_details) modal(true) hsize(600) vsize(400) halign(Alignment::Fill) valign(Alignment::Fill) { VBox margin(10) spacing(10) halign(Alignment::Fill) valign(Alignment::Fill) { Scroll halign(Alignment::Fill) valign(Alignment::Fill) { TextBox content(details) halign(Alignment::Fill) valign(Alignment::Fill) }, Button halign(Alignment::End) on_click(move || *show_details.borrow_mut() = false) { Label text(\"Ok\") } } } }; The implementation of ui! is fairly simple. The first identifier provides the element type and an ElementBuilder\u003cT\u003e is created. After that, the remaining method-call-like syntax forms are called on the builder (which is mutable). Optionally, a final set of curly braces indicate that the element has children. In that case, the macro is recursively called to create them, and add_child is called on the builder with the result (so we just need to make sure a builder has an add_child method). Ultimately the syntax transformation is pretty simple, but I believe that this macro is a little bit more than just syntax sugar: it makes reading and editing the UI a fair bit clearer, since the hierarchy of elements is represented in the syntax. Unfortunately a downside is that there’s no way to support automatic formatting of such macro DSLs, so developers will need to maintain a sane formatting. So now we have a model defined and a declarative way of building it. But we haven’t discussed any dynamic runtime behaviors here. In the above example, we see an on_click handler being set on a Button. We also see things like the Window’s visible property being set to a show_details value which is changed when on_click is pressed. We hook into this declarative UI to change or react to events at runtime using a set of simple data binding primitives with which UI implementations can interact. Many GUI frameworks nowadays (both for Rust and other languages) have been built with the “diffing element trees” architecture (think React), where your code is (at least mostly) functional and side-effect-free and produces the GUI view as a function of the current state. This approach has its tradeoffs: for instance, it makes complicated, stateful alterations of the layout very simple to write, understand, and maintain, and encourages a clean separation of model and view! However since we aren’t writing a framework, and our application is and will remain fairly simple, the benefits of such an architecture were not worth the additional development burden. Our implementation is more similar to the MVVM architecture: the model is, well, the model discussed here; the views are the various UI implementations; and the viewmodel is (loosely, if you squint) the collection of data bindings. Data Binding There are a few types which we use to declare dynamic (runtime-changeable) values. In our UI, we needed to support a few different behaviors: triggering events, i.e., what happens when a button is clicked, synchronized values which will mirror and notify of changes to all clones, and on-demand values which can be queried for the current value. On-demand values are used to get textbox contents rather than using a synchronized value, in an effort to avoid implementing debouncing in each UI. It may not be terribly difficult to do so, but it also wasn’t difficult to support the on-demand implementation. As a means of convenience, we created a Property type which encompasses the value-oriented fields as well. A Property\u003cT\u003e can be set to either a static value (T), a synchronized value (Synchronized\u003cT\u003e), or an on-demand value (OnDemand\u003cT\u003e). It supports an impl From for each of these, so that builder methods can look like fn my_method(\u0026mut self, value: impl Into\u003cProperty\u003cT\u003e\u003e) allowing any supported value to be passed in a UI declaration. We won’t discuss the implementation in depth (it’s what you’d expect), but it’s worth noting that these are all Clone to easily share the data bindings: they use Rc (we don’t need thread safety) and RefCell as necessary to access callbacks. In the example from the last section, show_details is a Synchronized\u003cbool\u003e value. When it changes, the UI implementations change the associated window visibility. The Button on_click callback sets the synchronized value to false, hiding the window (note that the details window used in this example is never closed, it is just shown and hidden). In a former iteration, data binding types had a lifetime parameter which specified the lifetime for which event callbacks were valid. While we were able to make this work, it greatly complicated the code, especially because there’s no way to communicate the correct covariance of the lifetime to the compiler, so there was additional unsafe code transmuting lifetimes (though it was contained as an implementation detail). These lifetimes were also infectious, requiring some of the complicated semantics regarding their safety to be propagated into the model types which stored Property fields. Much of this was to avoid cloning values into the callbacks, but changing these types to all be Clone and store static-lifetime callbacks was worth making the code far more maintainable. Threading and Thread Safety The careful reader might remember that we discussed how our threading model involves interacting with the UI implementations only on the main thread. This includes updating the data bindings, since the UI implementations might have registered callbacks on them! While we could run everything in the main thread, it’s generally a much better experience to do as much off of the UI thread as possible, even if we don’t do much that’s blocking (though we will be blocking when we send crash reports). We want our business logic to default to being off of the main thread so that the UI doesn’t ever freeze. We can guarantee this with some careful design. The simplest way to guarantee this behavior is to put all of the business logic in one (non-Clone, non-Sync) type (let’s call it Logic) and construct the UI and UI state (like Property values) in another type (let’s call it UI). We can then move the Logic value into a separate thread to guarantee that UI can’t interact with Logic directly, and vice versa. Of course we do need to communicate sometimes! But we want to ensure that this communication will always be delegated to the thread which owns the values (rather than the values directly interacting with each other). We can accomplish this by creating an enqueuing function for each type and storing that in the opposite type. Such a function will be passed boxed functions to run on the owning thread that get a reference to the owned type (e.g., Box\u003cdyn FnOnce(\u0026T) + Send + 'static\u003e). This is simple to create: for the UI thread, it is just the UI implementation’s invoke method which we briefly discussed previously. The Logic thread does nothing but run a loop which will get these functions and run them on the owned value (we just enqueue and pass them using an mpsc::channel). Now each type can asynchronously call methods on the other with the guarantee that they’ll be run on the correct thread. In a former iteration, a more complicated scheme was used with thread-local storage and a central type which was responsible for both creating threads and delegating the functions. But with such a basic use case as two threads delegating between each other, we were able to distill this to the essential aspects needed, greatly simplifying the code. Localization One nice benefit of this rewrite is that we could bring the localization of the crash reporter up to speed with our modern tooling. In almost every other part of Firefox, we use fluent to handle localization. Using fluent in the crash reporter makes the experience of localizers more uniform and predictable; they do not need to understand more than one localization system (the crash reporter was one of the last holdouts of the old system). It was very easy to use in the new code, with just a bit of extra code to extract the localization files from the Firefox installation when the crash reporter is run. In the worst case scenario where we can’t find or access these files, we have the en-US definitions directly bundled in the crash reporter binary. The UI Implementations We won’t go into much detail about the implementations, but it’s worth talking about each a bit. Linux (GTK) The GTK implementation is probably the most straightforward and succinct. We use bindgen to generate Rust bindings to the GTK functions we need (avoiding vendoring any external crates). Then we simply call all of the corresponding GTK functions to set up the GTK widgets as described in the model (remember, the model was made to mirror some of the GTK concepts). Since GTK is somewhat modern and meant to be written by humans (not automated tools like some of the other platforms), there weren’t really any pain points or unusual behaviors that needed to be addressed. We have a handful of nice features to improve memory safety and correctness. A set of traits makes it easy to attach owned data to GObjects (ensuring data remains valid and is properly dropped when the GObject is destroyed), and a few macros set up the glue code between GTK signals and our data binding types. Windows (Win32) The Windows implementation may have been the most difficult to write, since Win32 GUIs are very rarely written nowadays and the API shows its age. We use the windows-sys crate to access bindings to the API (which was already vendored in the codebase for many other Windows API uses). This crate is generated directly from Windows function metadata (by Microsoft), but otherwise its bindings aren’t terribly different from what bindgen might have produced (though they are likely a bit more accurate). There were a number of hurdles to overcome. For one thing, the Win32 API doesn’t provide any layout primitives, so the high-level layout concepts we use (which allow graceful resize/repositioning) had to be implemented manually. There’s also quite a few extra API calls just to get to a GUI that looks somewhat decent (correct window colors, font smoothing, high DPI handling, etc). Even the default font ends up being a terrible looking bitmapped font rather than the more modern system default; we needed to manually retrieve the system default and set it as the font to use, which was a bit surprising! We have a set of traits to facilitate creating custom window classes and managing associated window data of class instances. We also have wrapper types to properly manage the lifetimes of handles and perform type conversions (mainly String to null-terminated wide strings and back) as an extra layer of safety around the API. macOS (Cocoa/AppKit) The macOS implementation had its tricky parts, as overwhelmingly macOS GUIs are written with XCode and there’s a lot of automated and generated portions (such as nibs). We again use bindgen to generate Rust bindings, this time for the Objective-C APIs in macOS framework headers. Unlike Windows and GTK, you don’t get keyboard shortcuts like Cmd-C, Cmd-Q, etc, for free if creating a GUI without e.g. XCode (which generates it for you as part of a new project template). To have these typical shortcuts that users expect, we needed to manually implement the application main menu (which is what governs keyboard shortcuts). We also had to handle runtime setup like creating Objective-C autorelease pools, bringing the window and application (which are separate concepts) to the foreground, etc. Even implementing invoke to call a function on the main thread had its nuances, since modal windows use a nested event loop which would not call queued functions under the default NSRunLoop mode. We wrote some simple helper types and a macro to make it easy to implement, register, and create Objective-C classes from Rust code. We used this for creating delegate classes as well as subclassing some controls for the implementation (like NSButton); it made it easy to safely manage the memory of Rust values underlying the classes and correctly register class method selectors. The Test UI We’ll discuss testing in the next section. Our testing UI is very simple. It doesn’t create a GUI, but allows us to interact directly with the model. The ui! macro supports an extra piece of syntax when tests are enabled to optionally set a string identifier for each element. We use these strings in unit tests to access and interact with the UI. The data binding types also support a few additional methods in tests to easily manipulate values. This UI allows us to simulate button presses, field entry, etc, to ensure that other UI state changes as expected as well as simulating the system side effects. Mocking and Testing An important goal of our rewrite was to add tests to the crash reporter; our old code was sorely lacking them (in part because unit testing GUIs is notoriously difficult). Mocking Everything In the new code, we can mock the crash reporter regardless of whether we are running tests or not (though it is always mocked for tests). This is important because mocking allows us to (manually) run the GUI in various states to check that the GUI implementations are correct and render well. Our mocking not only mocks the inputs to the crash reporter (environment variables, command line parameters, etc), it also mocks all side-effectful std functions. We accomplish this by having a std module in the crate, and using crate::std throughout the rest of the code. When mocking is disabled, crate::std is simply the same as ::std. But when it is enabled, a bunch of functions that we have written are used instead. These mock the filesystem, environment, launching external commands, and other side effects. Importantly, only the minimal amount to mock the existing functions is implemented, so that if e.g. some new functions from std::fs, std::net, etc. are used, the crate will fail to compile with mocking enabled (so that we don’t miss any side effects). This might sound like a lot of effort, but you might be surprised at how little of std really needed to be mocked, and most implementations were pretty straightforward. Now that we have our code using different mocked functions, we need to have a way of injecting the desired mock data (both in tests and in our normal mocked operation). For example, we have the ability to return some data when a File is read, but we need to be able to set that data differently for tests. Without going into too much detail, we accomplish this using a thread-local store of mock data. This way, we don’t need to change any code to accommodate the mock data; we only need to make changes where we set and retrieve it. The programming language enthusiasts out there may recognize this as a form of dynamic scoping. The implementation allows our mock data to be set with code like mock::builder() .set( crate::std::env::MockCurrentExe, \"work_dir/crashreporter\".into(), ) .run(|| crash_reporter_main()) in tests, and pub fn current_exe() -\u003e std::io::Result { Ok(MockCurrentExe.get(|r| r.clone())) } in our crate::std::env implementation. Testing With our mocking setup and test UI, we are able to extensively test the behavior of the crash reporter. The “last mile” of this testing which we can’t automate easily is whether each UI implementation faithfully represents the UI model. We manually test this with a mocked GUI for each platform. Besides that, we are able to automatically test how arbitrary UI interactions cause the crash reporter to affect its own UI state and the environment (checking which programs are invoked and network connections are made, what happens if they fail, succeed, or timeout, etc). We also set up a mock filesystem and add assertions in various scenarios over the precise resulting filesystem state once the crash reporter completes. This greatly increases our confidence in the current behaviors and ensures that future changes will not alter them, which is of the utmost importance for such an essential component of our crash reporting pipeline. The End Product Of course we can’t get away with writing all of this without a picture of the crash reporter! This is what it looks like on Linux using GTK. The other GUI implementations look the same but styled with a native look and feel. Note that, for now, we wanted to keep it looking exactly the same as it previously did. So if you are unfortunate enough to see it, it shouldn’t appear as if anything has changed! With a new, cleaned up crash reporter, we can finally unblock a number of feature requests and bug reports, such as: detecting whether an installation is corrupt and telling the user to re-install Firefox, checking whether there is faulty memory hardware on the crashing system, and using the Firefox network stack for the first attempt at submitting crashes (which respects user network settings like proxies). We are excited to iterate and improve further on crash reporter functionality. But ultimately it’d be wonderful if you never see or use it, and we are constantly working toward that goal! More articles by Alex Franchuk…",
  "image": "https://hacks.mozilla.org/wp-content/uploads/2024/04/crashreporter.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle role=\"article\"\u003e\n    \u003cp\u003eFirefox’s crash reporter is hopefully not something that most users experience often. However, it is still a very important component of Firefox, as it is integral in providing insight into the most visible bugs: those which crash the main process. These bugs offer the worst user experience (since the entire application must close), so fixing them is a very high priority. Other types of crashes, such as content (tab) crashes, can be handled by the browser and reported gracefully, sometimes without the user being aware that an issue occurred at all. But when the main browser process comes to a halt, we need another separate application to gather information about the crash and interact with the user.\u003c/p\u003e\n\u003cp\u003eThis post details the approach we have taken to rewrite the crash reporter in Rust. We discuss the reasoning behind this rewrite, what makes the crash reporter a unique application, the architecture we used, and some details of the implementation.\u003c/p\u003e\n\u003ch2\u003eWhy Rewrite?\u003c/h2\u003e\n\u003cp\u003eEven though it is important to properly handle main process crashes, the crash reporter hasn’t received significant development in a while (aside from development to ensure that crash reports and telemetry continue to reliably be delivered)! It has long been stuck in a local maximum of “good enough” and “scary to maintain”: it features 3 individual GUI implementations (for Windows, GTK+ for Linux, and macOS), glue code abstracting a few things (mostly in C++, and Objective-C for macOS), a binary blob produced by obsoleted Apple development tools, and no test suite. Because of this, there is a backlog of features and improvements which haven’t been acted on.\u003c/p\u003e\n\u003cp\u003eWe’ve recently had a number of successful pushes to decrease crash rates (including both \u003ca href=\"https://hacks.mozilla.org/2022/11/improving-firefox-stability-with-this-one-weird-trick/\"\u003ebig leaps\u003c/a\u003e and many small bug fixes), and the crash reporter has functioned well enough for our needs during this time. However, we’ve reached an inflection point where improving the crash reporter would provide valuable insight to enable us to decrease the crash rate even further. For the reasons previously mentioned, improving the current codebase is difficult and error-prone, so we deemed it appropriate to rewrite the application so we can more easily act on the feature backlog and improve crash reports.\u003c/p\u003e\n\u003cp\u003eLike many components of Firefox, we decided to use Rust for this rewrite to produce a more reliable and maintainable program. Besides the often-touted memory safety built into Rust, its type system and standard library make reasoning about code, handling errors, and developing cross-platform applications far more robust and comprehensive.\u003c/p\u003e\n\u003ch2\u003eCrash Reporting is an Edge Case\u003c/h2\u003e\n\u003cp\u003eThere are a number of features of the crash reporter which make it quite unique, especially compared to other components which have been ported to Rust. For one thing, it is a standalone, individual program; basically no other components of Firefox are used in this way. Firefox itself launches many processes as a means of sandboxing and insulating against crashes, however these processes all talk to one another and have access to the same code base.\u003c/p\u003e\n\u003cp\u003eThe crash reporter has a very unique requirement: it must use as \u003ci\u003elittle as possible \u003c/i\u003eof the Firefox code base, ideally none! We don’t want it to rely on code which may be buggy and cause the reporter itself to crash. Using a completely independent implementation ensures that when a main process crash does occur, the cause of that crash won’t affect the reporter’s functionality as well.\u003c/p\u003e\n\u003cp\u003eThe crash reporter also necessarily has a GUI. This alone may not separate it from other Firefox components, but we can’t leverage any of the cross-platform rendering goodness that Firefox provides! So we need to implement a cross-platform GUI independent of Firefox as well. You might think we could reach for an existing cross-platform GUI crate, however we have a few reasons not to do so.\u003c/p\u003e\n\u003cul\u003e\n\u003cli aria-level=\"1\"\u003eWe want to minimize the use of external code: to improve crash reporter reliability (which is paramount), we want it to be as simple and auditable as possible.\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003eFirefox vendors all dependencies in-tree, so we are hesitant to bring in large dependencies (GUI libraries are likely pretty sizable).\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003eThere are only a few third-party crates that provide a native OS look and feel (or actually \u003ci\u003euse\u003c/i\u003e native GUI APIs): it’s desirable for the crash reporter to have a native feel to be familiar to users and take advantage of accessibility features.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo all of this is to say that third-party cross-platform GUI libraries aren’t a favorable option.\u003c/p\u003e\n\u003cp\u003eThese requirements significantly narrow the approach that can be used.\u003c/p\u003e\n\u003ch2\u003eBuilding a GUI View Abstraction\u003c/h2\u003e\n\u003cp\u003eIn order to make the crash reporter more maintainable (and make it easier to add new features in the future), we want to have as minimal and generic platform-specific code as possible. We can achieve this by using a simple UI model that can be converted into native GUI code for each platform. Each UI implementation will need to provide two methods (over arbitrary platform-specific \u003ctt\u003e\u0026amp;self\u003c/tt\u003e data):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/// Run a UI loop, displaying all windows of the application until it terminates.\nfn run_loop(\u0026amp;self, app: model::Application)\n\n/// Invoke a function asynchronously on the UI loop thread.\nfn invoke(\u0026amp;self, f: model::InvokeFn)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ctt\u003erun_loop\u003c/tt\u003e function is pretty self-explanatory: the UI implementation takes an \u003ctt\u003eApplication\u003c/tt\u003e model (which we’ll discuss shortly) and runs the application, \u003ci\u003eblocking\u003c/i\u003e until the application is complete. Conveniently, our target platforms generally have similar assumptions around threading: the UI runs in a single thread and typically runs an event loop which blocks on new events until an event signaling the end of the application is received.\u003c/p\u003e\n\u003cp\u003eThere are some cases where we’ll need to run a function on the UI thread asynchronously (like displaying a window, updating a text field, etc). Since \u003ctt\u003erun_loop\u003c/tt\u003e blocks, we need the \u003ctt\u003einvoke\u003c/tt\u003e method to define how to do this. This threading model will make it easy to use the platform GUI frameworks: everything calling native functions will occur on a single thread (the main thread in fact) for the duration of the program.\u003c/p\u003e\n\u003cp\u003eThis is a good time to be a bit more specific about exactly what each UI implementation will look like. We’ll discuss pain points for each later on. There are 4 UI implementations:\u003c/p\u003e\n\u003cul\u003e\n\u003cli aria-level=\"1\"\u003eA Windows implementation using the Win32 API.\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003eA macOS implementation using Cocoa (AppKit and Foundation frameworks).\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003eA Linux implementation using GTK+ 3 (the “+” has since been dropped in GTK 4, so henceforth I’ll refer to it as “GTK”). Linux doesn’t provide its own GUI primitives, and we already ship GTK with Firefox on Linux to make a modern-feeling GUI, so we can use it for the crash reporter, too. Note that some platforms that aren’t directly supported by Mozilla (like BSDs) use the GTK implementation as well.\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003eA testing implementation which will allow tests to hook into a virtual UI and poke things (to simulate interactions and read state).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOne last detail before we dive in: the crash reporter (at least right now) has a pretty simple GUI. Because of this, an explicit \u003cb\u003enon-goal\u003c/b\u003e of the development was to create a separate Rust GUI crate. We wanted to create just enough of an abstraction to cover the cases we needed in the crash reporter. If we need more controls in the future, we can add them to the abstraction, but we avoided spending extra cycles to fill out every GUI use case.\u003c/p\u003e\n\u003cp\u003eLikewise, we tried to avoid unnecessary development by allowing some tolerance for hacks and built-in edge cases. For example, our model defines a \u003ctt\u003eButton\u003c/tt\u003e as an element which contains an arbitrary element, but actually supporting that with Win32 or AppKit would have required a lot of custom code, so we special case on a \u003ctt\u003eButton\u003c/tt\u003e containing a \u003ctt\u003eLabel\u003c/tt\u003e (which is all we need right now, and an easy primitive available to us). I’m happy to say there aren’t really \u003ci\u003emany\u003c/i\u003e special cases like that at all, but we are comfortable with the few that were needed.\u003c/p\u003e\n\u003ch3\u003eThe UI Model\u003c/h3\u003e\n\u003cp\u003eOur model is a declarative structuring of concepts mostly present in GTK. Since GTK is a mature library with proven high-level UI concepts, this made it appropriate for our abstraction and made the GTK implementation pretty simple. For instance, the simplest way that GTK does layout (using container GUI elements and per-element margins/alignments) is good enough for our GUI, so we use similar definitions in the model. Notably, this “simple” layout definition is actually somewhat high-level and complicates the macOS and Windows implementations a bit (but this tradeoff is worth the ease of creating UI models).\u003c/p\u003e\n\u003cp\u003eThe top-level type of our UI model is \u003ctt\u003eApplication\u003c/tt\u003e. This is pretty simple: we define an \u003ctt\u003eApplication\u003c/tt\u003e as a set of top-level \u003ctt\u003eWindow\u003c/tt\u003es (though our application only has one) and whether the current locale is \u003ca href=\"https://en.wikipedia.org/wiki/Right-to-left_script\"\u003eright-to-left\u003c/a\u003e. We inspect Firefox resources to use the same locale that Firefox would, so we don’t rely on the native GUI’s locale settings.\u003c/p\u003e\n\u003cp\u003eAs you might expect, each \u003ctt\u003eWindow\u003c/tt\u003e contains a single root element. The rest of the model is made up of a handful of typical container and primitive GUI elements:\u003c/p\u003e\n\u003cp\u003e\u003cimg fetchpriority=\"high\" decoding=\"async\" src=\"https://hacks.mozilla.org/wp-content/uploads/2024/03/class_diagram.png\" alt=\"A class diagram showing the inheritance structure. An Application contains one or more Windows. A Window contains one Element. An Element is subclassed to Checkbox, Label, Progress, TextBox, Button, Scroll, HBox, and VBox types.\" width=\"389\" height=\"421\" srcset=\"https://hacks.mozilla.org/wp-content/uploads/2024/03/class_diagram.png 389w, https://hacks.mozilla.org/wp-content/uploads/2024/03/class_diagram-250x271.png 250w\" sizes=\"(max-width: 389px) 100vw, 389px\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe crash reporter only needs 8 types of GUI elements! And really, \u003ctt\u003eProgress\u003c/tt\u003e is used as a spinner rather than indicating any real progress as of right now, so it’s not strictly necessary (but nice to show).\u003c/p\u003e\n\u003cp\u003eRust does not explicitly support the object-oriented concept of inheritance, so you might be wondering how each GUI element “extends” \u003ctt\u003eElement\u003c/tt\u003e. The relationship represented in the picture is somewhat abstract; the implemented \u003ctt\u003eElement\u003c/tt\u003e looks like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epub struct Element {\n    pub style: ElementStyle,\n    pub element_type: ElementType\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere \u003ctt\u003eElementStyle\u003c/tt\u003e contains all the common properties of elements (alignment, size, margin, visibility, and enabled state), and \u003ctt\u003eElementType\u003c/tt\u003e is an \u003ctt\u003eenum\u003c/tt\u003e containing each of the specific GUI elements as variants.\u003c/p\u003e\n\u003ch4\u003eBuilding the Model\u003c/h4\u003e\n\u003cp\u003eThe model elements are all intended to be consumed by the UI implementations; as such, almost all of the fields have public visibility. However, as a means of having a separate interface for \u003ci\u003ebuilding\u003c/i\u003e elements, we define an \u003ctt\u003eElementBuilder\u0026lt;T\u0026gt;\u003c/tt\u003e type. This type has methods that maintain assertions and provide convenience setters. For instance, many methods accept parameters that are \u003ctt\u003eimpl Into\u0026lt;MemberType\u0026gt;\u003c/tt\u003e, some methods like \u003ctt\u003emargin()\u003c/tt\u003e set multiple values (but you can be more specific with \u003ctt\u003emargin_top()\u003c/tt\u003e), etc.\u003c/p\u003e\n\u003cp\u003eThere is a general \u003ctt\u003eimpl\u0026lt;T\u0026gt; ElementBuilder\u0026lt;T\u0026gt;\u003c/tt\u003e which provides setters for the various \u003ctt\u003eElementStyle\u003c/tt\u003e properties, and then each specific element type can also provide their own \u003ctt\u003eimpl ElementBuilder\u0026lt;SpecificElement\u0026gt;\u003c/tt\u003e with additional properties unique to the element type.\u003c/p\u003e\n\u003cp\u003eWe combine \u003ctt\u003eElementBuilder\u0026lt;T\u0026gt;\u003c/tt\u003e with the final piece of the puzzle: a \u003ctt\u003eui!\u003c/tt\u003e macro. This macro allows us to write our UI in a declarative manner. For example, it allows us to write:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet details_window = ui! {\n    Window title(\u0026#34;Crash Details\u0026#34;) visible(show_details) modal(true) hsize(600) vsize(400)\n         halign(Alignment::Fill) valign(Alignment::Fill)\n    {\n         VBox margin(10) spacing(10) halign(Alignment::Fill) valign(Alignment::Fill) {\n            \tScroll halign(Alignment::Fill) valign(Alignment::Fill) {\n                \tTextBox content(details) halign(Alignment::Fill) valign(Alignment::Fill)\n            \t},\n            \tButton halign(Alignment::End) on_click(move || *show_details.borrow_mut() = false)\n             {\n                 Label text(\u0026#34;Ok\u0026#34;)\n             }\n         }\n     }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe implementation of \u003ctt\u003eui!\u003c/tt\u003e is fairly simple. The first identifier provides the element type and an \u003ctt\u003eElementBuilder\u0026lt;T\u0026gt;\u003c/tt\u003e is created. After that, the remaining method-call-like syntax forms are called on the builder (which is mutable).\u003c/p\u003e\n\u003cp\u003eOptionally, a final set of curly braces indicate that the element has children. In that case, the macro is recursively called to create them, and \u003ctt\u003eadd_child\u003c/tt\u003e is called on the builder with the result (so we just need to make sure a builder has an \u003ctt\u003eadd_child\u003c/tt\u003e method). Ultimately the syntax transformation is pretty simple, but I believe that this macro is a little bit more than \u003ci\u003ejust\u003c/i\u003e syntax sugar: it makes reading and editing the UI a fair bit clearer, since the hierarchy of elements is represented in the syntax. Unfortunately a downside is that there’s no way to support automatic formatting of such macro DSLs, so developers will need to maintain a sane formatting.\u003c/p\u003e\n\u003cp\u003eSo now we have a model defined and a declarative way of building it. But we haven’t discussed any dynamic runtime behaviors here. In the above example, we see an \u003ctt\u003eon_click\u003c/tt\u003e handler being set on a \u003ctt\u003eButton\u003c/tt\u003e. We also see things like the \u003ctt\u003eWindow\u003c/tt\u003e’s \u003ctt\u003evisible\u003c/tt\u003e property being set to a \u003ctt\u003eshow_details\u003c/tt\u003e value which is changed when \u003ctt\u003eon_click\u003c/tt\u003e is pressed. We hook into this declarative UI to change or react to events at runtime using a set of simple data binding primitives with which UI implementations can interact.\u003c/p\u003e\n\u003cdiv\u003e\n\u003cp\u003e\u003ci\u003eMany\u003c/i\u003e GUI frameworks nowadays (both for Rust and other languages) have been built with the “diffing element trees” architecture (think \u003ca href=\"https://react.dev/\"\u003eReact\u003c/a\u003e), where your code is (at least mostly) functional and side-effect-free and produces the GUI view as a function of the current state. This approach has its tradeoffs: for instance, it makes complicated, stateful alterations of the layout very simple to write, understand, and maintain, and encourages a clean separation of model and view! However since we \u003ci\u003earen’t\u003c/i\u003e writing a framework, and our application is and will remain fairly simple, the benefits of such an architecture were not worth the additional development burden. Our implementation is more similar to the \u003ca href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel\"\u003eMVVM architecture\u003c/a\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli aria-level=\"1\"\u003ethe model is, well, the model discussed here;\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003ethe views are the various UI implementations; and\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003ethe viewmodel is (loosely, if you squint) the collection of data bindings.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003ch3\u003eData Binding\u003c/h3\u003e\n\u003cp\u003eThere are a few types which we use to declare dynamic (runtime-changeable) values. In our UI, we needed to support a few different behaviors:\u003c/p\u003e\n\u003cul\u003e\n\u003cli aria-level=\"1\"\u003etriggering \u003cb\u003eevents\u003c/b\u003e, i.e., what happens when a button is clicked,\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003cb\u003esynchronized\u003c/b\u003e values which will mirror and notify of changes to all clones, and\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003cb\u003eon-demand\u003c/b\u003e values which can be queried for the current value.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn-demand values are used to get textbox contents rather than using a synchronized value, in an effort to avoid implementing debouncing in each UI. It may not be terribly difficult to do so, but it also wasn’t difficult to support the on-demand implementation.\u003c/p\u003e\n\u003cp\u003eAs a means of convenience, we created a \u003ctt\u003eProperty\u003c/tt\u003e type which encompasses the value-oriented fields as well. A \u003ctt\u003eProperty\u0026lt;T\u0026gt;\u003c/tt\u003e can be set to either a static value (\u003ctt\u003eT\u003c/tt\u003e), a synchronized value (\u003ctt\u003eSynchronized\u0026lt;T\u0026gt;\u003c/tt\u003e), or an on-demand value (\u003ctt\u003eOnDemand\u0026lt;T\u0026gt;\u003c/tt\u003e). It supports an \u003ctt\u003eimpl From\u003c/tt\u003e for each of these, so that builder methods can look like \u003ctt\u003efn my_method(\u0026amp;mut self, value: impl Into\u0026lt;Property\u0026lt;T\u0026gt;\u0026gt;)\u003c/tt\u003e allowing any supported value to be passed in a UI declaration.\u003c/p\u003e\n\u003cp\u003eWe won’t discuss the implementation in depth (\u003ca href=\"https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/data.rs\"\u003eit’s what you’d expect\u003c/a\u003e), but it’s worth noting that these are all \u003ctt\u003eClone\u003c/tt\u003e to easily share the data bindings: they use \u003ctt\u003eRc\u003c/tt\u003e (we don’t need thread safety) and \u003ctt\u003eRefCell\u003c/tt\u003e as necessary to access callbacks.\u003c/p\u003e\n\u003cp\u003eIn the example from the last section, \u003ctt\u003eshow_details\u003c/tt\u003e is a \u003ctt\u003eSynchronized\u0026lt;bool\u0026gt;\u003c/tt\u003e value. When it changes, the UI implementations change the associated window visibility. The \u003ctt\u003eButton\u003c/tt\u003e \u003ctt\u003eon_click\u003c/tt\u003e callback sets the synchronized value to false, hiding the window (note that the details window used in this example is never closed, it is just shown and hidden).\u003c/p\u003e\n\u003cdiv\u003e\n\u003cp\u003eIn a former iteration, data binding types had a lifetime parameter which specified the lifetime for which event callbacks were valid. While we were able to make this work, it greatly complicated the code, especially because there’s no way to communicate the correct covariance of the lifetime to the compiler, so there was additional \u003ctt\u003eunsafe\u003c/tt\u003e code transmuting lifetimes (though it was contained as an implementation detail). These lifetimes were also infectious, requiring some of the complicated semantics regarding their safety to be propagated into the model types which stored \u003ctt\u003eProperty\u003c/tt\u003e fields.\u003c/p\u003e\n\u003cp\u003eMuch of this was to avoid cloning values into the callbacks, but changing these types to all be \u003ctt\u003eClone\u003c/tt\u003e and store static-lifetime callbacks was worth making the code far more maintainable.\u003c/p\u003e\n\u003c/div\u003e\n\u003ch4\u003eThreading and Thread Safety\u003c/h4\u003e\n\u003cp\u003eThe careful reader might remember that we discussed how our threading model involves interacting with the UI implementations \u003cem\u003eonly\u003c/em\u003e on the main thread. This includes updating the data bindings, since the UI implementations might have registered callbacks on them! While we \u003ci\u003ecould\u003c/i\u003e run everything in the main thread, it’s generally a much better experience to do as much off of the UI thread as possible, even if we don’t do much that’s blocking (though we will be blocking when we send crash reports). We want our business logic to default to being off of the main thread so that the UI doesn’t ever freeze. We can guarantee this with some careful design.\u003c/p\u003e\n\u003cp\u003eThe simplest way to guarantee this behavior is to put all of the business logic in one (non-\u003ctt\u003eClone\u003c/tt\u003e, non-\u003ctt\u003eSync\u003c/tt\u003e) type (let’s call it \u003ctt\u003eLogic\u003c/tt\u003e) and construct the UI and UI state (like \u003ctt\u003eProperty\u003c/tt\u003e values) in another type (let’s call it \u003ctt\u003eUI\u003c/tt\u003e). We can then \u003ci\u003emove\u003c/i\u003e the \u003ctt\u003eLogic\u003c/tt\u003e value into a separate thread to guarantee that \u003ctt\u003eUI\u003c/tt\u003e can’t interact with \u003ctt\u003eLogic\u003c/tt\u003e directly, and vice versa. Of course we do need to communicate sometimes! But we want to ensure that this communication will always be delegated to the thread which owns the values (rather than the values directly interacting with each other).\u003c/p\u003e\n\u003cp\u003eWe can accomplish this by creating an enqueuing function for each type and storing that in the opposite type. Such a function will be passed boxed functions to run on the owning thread that get a reference to the owned type (e.g., \u003ctt\u003eBox\u0026lt;dyn FnOnce(\u0026amp;T) + Send + \u0026#39;static\u0026gt;\u003c/tt\u003e). This is simple to create: for the \u003ctt\u003eUI\u003c/tt\u003e thread, it is just the \u003ctt\u003eUI\u003c/tt\u003e implementation’s \u003ctt\u003einvoke\u003c/tt\u003e method which we briefly discussed previously. The \u003ctt\u003eLogic\u003c/tt\u003e thread does nothing \u003ci\u003ebut\u003c/i\u003e run a loop which will get these functions and run them on the owned value (we just enqueue and pass them using an \u003ca href=\"https://doc.rust-lang.org/stable/std/sync/mpsc/fn.channel.html\"\u003e\u003ctt\u003empsc::channel\u003c/tt\u003e\u003c/a\u003e). Now each type can asynchronously call methods on the other with the guarantee that they’ll be run on the correct thread.\u003c/p\u003e\n\u003cp\u003eIn a former iteration, a more complicated scheme was used with thread-local storage and a central type which was responsible for both creating threads and delegating the functions. But with such a basic use case as two threads delegating between each other, we were able to distill this to the essential aspects needed, greatly simplifying the code.\u003c/p\u003e\n\u003ch3\u003eLocalization\u003c/h3\u003e\n\u003cp\u003eOne nice benefit of this rewrite is that we could bring the localization of the crash reporter up to speed with our modern tooling. In almost every other part of Firefox, we use \u003ca href=\"https://projectfluent.org/\"\u003e\u003ctt\u003efluent\u003c/tt\u003e\u003c/a\u003e to handle localization. Using \u003ctt\u003efluent\u003c/tt\u003e in the crash reporter makes the experience of localizers more uniform and predictable; they do not need to understand more than one localization system (the crash reporter was one of the last holdouts of the old system). It was very easy to use in the new code, with just a bit of extra code to extract the localization files from the Firefox installation when the crash reporter is run. In the worst case scenario where we can’t find or access these files, we have the \u003ctt\u003een-US\u003c/tt\u003e definitions directly bundled in the crash reporter binary.\u003c/p\u003e\n\u003ch2\u003eThe UI Implementations\u003c/h2\u003e\n\u003cp\u003eWe won’t go into much detail about the implementations, but it’s worth talking about each a bit.\u003c/p\u003e\n\u003ch3\u003eLinux (GTK)\u003c/h3\u003e\n\u003cp\u003eThe GTK implementation is probably the most straightforward and succinct. We use \u003ca href=\"https://github.com/rust-lang/rust-bindgen\"\u003e\u003ctt\u003ebindgen\u003c/tt\u003e\u003c/a\u003e to generate Rust bindings to the GTK functions we need (avoiding vendoring any external crates). Then we simply call all of the corresponding GTK functions to set up the GTK widgets as described in the model (remember, the model was made to mirror some of the GTK concepts).\u003c/p\u003e\n\u003cp\u003eSince GTK is somewhat modern and meant to be written by humans (not automated tools like some of the other platforms), there weren’t really any pain points or unusual behaviors that needed to be addressed.\u003c/p\u003e\n\u003cp\u003eWe have a handful of nice features to improve memory safety and correctness. \u003ca href=\"https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/gtk.rs#96,105\"\u003eA set of traits\u003c/a\u003e makes it easy to attach owned data to GObjects (ensuring data remains valid and is properly dropped when the GObject is destroyed), and \u003ca href=\"https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/gtk.rs#177,205,228\"\u003ea few macros\u003c/a\u003e set up the glue code between GTK signals and our data binding types.\u003c/p\u003e\n\u003ch3\u003eWindows (Win32)\u003c/h3\u003e\n\u003cp\u003eThe Windows implementation may have been the most difficult to write, since Win32 GUIs are very rarely written nowadays and the API shows its age. We use the \u003ca href=\"https://crates.io/crates/windows-sys\"\u003e\u003ctt\u003ewindows-sys\u003c/tt\u003e\u003c/a\u003e crate to access bindings to the API (which was already vendored in the codebase for many other Windows API uses). This crate is generated directly from Windows function metadata (by Microsoft), but otherwise its bindings aren’t terribly different from what \u003ctt\u003ebindgen\u003c/tt\u003e might have produced (though they are likely a bit more accurate).\u003c/p\u003e\n\u003cp\u003eThere were a number of hurdles to overcome. For one thing, the Win32 API doesn’t provide any layout primitives, so the high-level layout concepts we use (which allow graceful resize/repositioning) had to be \u003ca href=\"https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/windows/layout.rs\"\u003eimplemented manually\u003c/a\u003e. There’s also quite a few extra API calls just to get to a GUI that looks somewhat decent (correct window colors, font smoothing, high DPI handling, etc). Even the default font ends up being a terrible looking bitmapped font rather than the more modern system default; we needed to manually retrieve the system default and set it as the font to use, which was a bit surprising!\u003c/p\u003e\n\u003cp\u003eWe have \u003ca href=\"https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/windows/window.rs#16,40,120\"\u003ea set of traits\u003c/a\u003e to facilitate creating custom window classes and managing associated window data of class instances. We also \u003ca href=\"https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/windows/gdi.rs\"\u003ehave\u003c/a\u003e \u003ca href=\"https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/windows/font.rs\"\u003ewrapper\u003c/a\u003e \u003ca href=\"https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/windows/widestring.rs\"\u003etypes\u003c/a\u003e to properly manage the lifetimes of handles and perform type conversions (mainly \u003ctt\u003eString\u003c/tt\u003e to null-terminated wide strings and back) as an extra layer of safety around the API.\u003c/p\u003e\n\u003ch3\u003emacOS (Cocoa/AppKit)\u003c/h3\u003e\n\u003cp\u003eThe macOS implementation had its tricky parts, as overwhelmingly macOS GUIs are written with XCode and there’s a lot of automated and generated portions (such as nibs). We again use \u003ca href=\"https://github.com/rust-lang/rust-bindgen\"\u003e\u003ctt\u003ebindgen\u003c/tt\u003e\u003c/a\u003e to generate Rust bindings, this time for the Objective-C APIs in macOS framework headers.\u003c/p\u003e\n\u003cp\u003eUnlike Windows and GTK, you don’t get keyboard shortcuts like Cmd-C, Cmd-Q, etc, for free if creating a GUI without e.g. XCode (which generates it for you as part of a new project template). To have these typical shortcuts that users expect, we needed to manually implement the application main menu (which is what governs keyboard shortcuts). We also had to handle runtime setup like creating Objective-C autorelease pools, bringing the window \u003ci\u003eand application\u003c/i\u003e (which are separate concepts) to the foreground, etc. Even implementing \u003ctt\u003einvoke\u003c/tt\u003e to call a function on the main thread had its nuances, since modal windows use a nested event loop which would not call queued functions under the default \u003ctt\u003eNSRunLoop\u003c/tt\u003e mode.\u003c/p\u003e\n\u003cp\u003eWe wrote some \u003ca href=\"https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/macos/objc.rs\"\u003esimple helper types and a macro\u003c/a\u003e to make it easy to implement, register, and create Objective-C classes from Rust code. We used this for creating delegate classes as well as subclassing some controls for the implementation (like \u003ca href=\"https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/macos/mod.rs#365-386\"\u003e\u003ctt\u003eNSButton\u003c/tt\u003e\u003c/a\u003e); it made it easy to safely manage the memory of Rust values underlying the classes and correctly register class method selectors.\u003c/p\u003e\n\u003ch3\u003eThe Test UI\u003c/h3\u003e\n\u003cp\u003eWe’ll discuss testing in the next section. Our testing UI is very simple. It \u003ci\u003edoesn’t\u003c/i\u003e create a GUI, but allows us to interact directly with the model. The \u003ctt\u003eui!\u003c/tt\u003e macro supports an extra piece of syntax when tests are enabled to optionally set a string identifier for each element. We use these strings in unit tests to access and interact with the UI. The data binding types also support a few additional methods in tests to easily manipulate values. This UI allows us to simulate button presses, field entry, etc, to ensure that other UI state changes as expected as well as simulating the system side effects.\u003c/p\u003e\n\u003ch2\u003eMocking and Testing\u003c/h2\u003e\n\u003cp\u003eAn important goal of our rewrite was to add tests to the crash reporter; our old code was sorely lacking them (in part because unit testing GUIs is notoriously difficult).\u003c/p\u003e\n\u003ch3\u003eMocking Everything\u003c/h3\u003e\n\u003cp\u003eIn the new code, we can mock the crash reporter regardless of whether we are running tests or not (though it is always mocked for tests). This is important because mocking allows us to (manually) run the GUI in various states to check that the GUI implementations are correct and render well. Our mocking not only mocks the inputs to the crash reporter (environment variables, command line parameters, etc), it also mocks \u003ci\u003eall\u003c/i\u003e side-effectful std functions.\u003c/p\u003e\n\u003cp\u003eWe accomplish this by having a \u003ctt\u003estd\u003c/tt\u003e module in the crate, and using \u003ctt\u003ecrate::std\u003c/tt\u003e throughout the rest of the code. When mocking is disabled, \u003ctt\u003ecrate::std\u003c/tt\u003e is simply the same as \u003ctt\u003e::std\u003c/tt\u003e. But when it is enabled, a bunch of functions that we have written are used instead. These mock the filesystem, environment, launching external commands, and other side effects. Importantly, only the minimal amount to mock the existing functions is implemented, so that if e.g. some new functions from \u003ctt\u003estd::fs\u003c/tt\u003e, \u003ctt\u003estd::net\u003c/tt\u003e, etc. are used, the crate will fail to compile with mocking enabled (so that we don’t \u003ci\u003emiss\u003c/i\u003e any side effects). This might sound like a lot of effort, but you might be surprised at how little of \u003ctt\u003estd\u003c/tt\u003e really needed to be mocked, and most implementations were pretty straightforward.\u003c/p\u003e\n\u003cp\u003eNow that we have our code using different mocked functions, we need to have a way of injecting the desired mock data (both in tests and in our normal mocked operation). For example, we have the ability to return some data when a \u003ctt\u003eFile\u003c/tt\u003e is read, but we need to be able to set that data differently for tests. Without going into too much detail, we accomplish this using a thread-local store of mock data. This way, we don’t need to change any code to accommodate the mock data; we only need to make changes where we set and retrieve it. The programming language enthusiasts out there may recognize this as a form of \u003ca href=\"https://en.wikipedia.org/wiki/Scope_(computer_science)#Dynamic_scope\"\u003edynamic scoping\u003c/a\u003e. The \u003ca href=\"https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/std/mock.rs\"\u003eimplementation\u003c/a\u003e allows our mock data to be set with code like\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emock::builder()\n    .set(\n        crate::std::env::MockCurrentExe,\n        \u0026#34;work_dir/crashreporter\u0026#34;.into(),\n    )\n    .run(|| crash_reporter_main())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ein tests, and\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epub fn current_exe() -\u0026gt; std::io::Result {\n    Ok(MockCurrentExe.get(|r| r.clone()))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ein our \u003ctt\u003ecrate::std::env\u003c/tt\u003e implementation.\u003c/p\u003e\n\u003ch3\u003eTesting\u003c/h3\u003e\n\u003cp\u003eWith our mocking setup and test UI, we are able to extensively test the behavior of the crash reporter. The “last mile” of this testing which we can’t automate easily is whether each UI implementation faithfully represents the UI model. We manually test this with a mocked GUI for each platform.\u003c/p\u003e\n\u003cp\u003eBesides that, we are able to automatically test how arbitrary UI interactions cause the crash reporter to affect its own UI state and the environment (checking which programs are invoked and network connections are made, what happens if they fail, succeed, or timeout, etc). We also set up a mock filesystem and add assertions in various scenarios over the precise resulting filesystem state once the crash reporter completes. This greatly increases our confidence in the current behaviors and ensures that future changes will not alter them, which is of the utmost importance for such an essential component of our crash reporting pipeline.\u003c/p\u003e\n\u003ch2\u003eThe End Product\u003c/h2\u003e\n\u003cp\u003eOf course we can’t get away with writing all of this without a picture of the crash reporter! This is what it looks like on Linux using GTK. The other GUI implementations look the same but styled with a native look and feel.\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" src=\"https://hacks.mozilla.org/wp-content/uploads/2024/04/crashreporter-500x356.png\" alt=\"The crash reporter dialog on Linux.\" width=\"500\" height=\"356\" srcset=\"https://hacks.mozilla.org/wp-content/uploads/2024/04/crashreporter-500x356.png 500w, https://hacks.mozilla.org/wp-content/uploads/2024/04/crashreporter-250x178.png 250w, https://hacks.mozilla.org/wp-content/uploads/2024/04/crashreporter.png 610w\" sizes=\"(max-width: 500px) 100vw, 500px\"/\u003e\u003c/p\u003e\n\u003cp\u003eNote that, for now, we wanted to keep it looking exactly the same as it previously did. So if you are unfortunate enough to see it, it shouldn’t appear as if anything has changed!\u003c/p\u003e\n\u003cp\u003eWith a new, cleaned up crash reporter, we can finally unblock a number of feature requests and bug reports, such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli aria-level=\"1\"\u003e\u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1821414\"\u003edetecting whether an installation is corrupt and telling the user to re-install Firefox\u003c/a\u003e,\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1565033\"\u003echecking whether there is faulty memory hardware on the crashing system\u003c/a\u003e, and\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1866863\"\u003eusing the Firefox network stack for the first attempt at submitting crashes (which respects user network settings like proxies)\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe are excited to iterate and improve further on crash reporter functionality. But ultimately it’d be wonderful if you never see or use it, and we are constantly working toward that goal!\u003c/p\u003e\n    \u003csection\u003e\n                                \n                                \u003cp\u003e\u003ca href=\"https://hacks.mozilla.org/author/afranchukmozilla-com/\"\u003eMore articles by Alex Franchuk…\u003c/a\u003e\u003c/p\u003e\n                  \u003c/section\u003e\n  \u003c/article\u003e\u003c/div\u003e",
  "readingTime": "30 min read",
  "publishedTime": null,
  "modifiedTime": null
}
