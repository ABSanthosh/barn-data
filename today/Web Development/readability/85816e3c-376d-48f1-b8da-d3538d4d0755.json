{
  "id": "85816e3c-376d-48f1-b8da-d3538d4d0755",
  "title": "Use scheduler.yield() to break up long tasks",
  "link": "https://developer.chrome.com/blog/use-scheduler-yield?hl=en",
  "description": "scheduler.yield() is a new API for ergonomically splitting up long tasks and getting prioritized continuation of execution.",
  "author": "",
  "published": "Thu, 06 Mar 2025 08:00:00 GMT",
  "source": "https://developer.chrome.com/static/blog/feed.xml",
  "categories": null,
  "byline": "",
  "length": 8660,
  "excerpt": "scheduler.yield() is a new API for ergonomically splitting up long tasks and getting prioritized continuation of execution.",
  "siteName": "Chrome for Developers",
  "favicon": "https://www.gstatic.com/devrel-devsite/prod/v630f393d749cf7dff36a03367007d65915d987bf69b5409e6d70ed7311ba2c07/chrome/images/favicon.png",
  "text": "Stay organized with collections Save and categorize content based on your preferences. Published: March 6, 2025 A page feels sluggish and unresponsive when long tasks keep the main thread busy, preventing it from doing other important work, like responding to user input. As a result, even built-in form controls can appear broken to users—as if the page were frozen—never mind more complex custom components. scheduler.yield() is a way of yielding to the main thread—allowing the browser to run any pending high-priority work—then continuing execution where it left off. This keeps a page more responsive and, in turn, helps improve Interaction to Next Paint (INP). scheduler.yield offers an ergonomic API that does exactly what it says: execution of the function it's called in pauses at the await scheduler.yield() expression and yields to the main thread, breaking up the task. The execution of the rest of the function—called the continuation of the function—will be scheduled to run in a new event-loop task. async function respondToUserClick() { giveImmediateFeedback(); await scheduler.yield(); // Yield to the main thread. slowerComputation(); } The specific benefit of scheduler.yield is that the continuation after the yield is scheduled to run before running any other similar tasks that have been queued up by the page. It prioritizes the continuation of a task over starting new tasks. Functions like setTimeout or scheduler.postTask can also be used to break up tasks, but those continuations typically run after any already-queued new tasks, potentially risking long delays between yielding to the main thread and completing their work. Prioritized continuations after yielding scheduler.yield is part of the Prioritized Task Scheduling API. As web developers, we don't typically talk about the order in which the event loop runs tasks in terms of explicit priorities, but the relative priorities are always there, such as a requestIdleCallback callback running after any queued setTimeout callbacks, or a triggered input event listener usually running before a task queued up with setTimeout(callback, 0). Prioritized Task Scheduling just makes this more explicit, making it easier to figure out what task will run before another, and enables adjusting priorities to change that order of execution, if needed. As mentioned, the continued execution of a function after yielding with scheduler.yield() gets a priority higher than starting other tasks. The guiding concept is that the continuation of a task should run first, before moving on to other tasks. If the task is well-behaved code that periodically yields so that the browser can do other important things (like respond to user input), it shouldn't be punished for yielding by getting prioritized after other similar tasks. Here's an example: two functions, queued up to run in different tasks using setTimeout. setTimeout(myJob); setTimeout(someoneElsesJob); In this case, the two setTimeout calls are right next to each other, but in a real page, they could be called in completely different places, like a first-party script and a third-party script independently setting up work to run, or it could be two tasks from separate components being triggered deep in your framework's scheduler. Here's what that work could look like in DevTools: myJob is flagged as a long task, blocking the browser from doing anything else while it's running. Assuming it's from a first-party script, we can break it up: function myJob() { // Run part 1. myJobPart1(); // Yield with setTimeout() to break up long task, then run part2. setTimeout(myJobPart2, 0); } Because myJobPart2 was scheduled to run with setTimeout within myJob, but that scheduling runs after someoneElsesJob has already been scheduled, here's how execution will look: We've broken up the task with setTimeout so the browser can be responsive during the middle of myJob, but now the second part of myJob only runs after someoneElsesJob has finished. In some cases, that might be fine, but usually this isn't optimal. myJob was yielding to the main thread to make sure the page could stay responsive to user input, not to give up the main thread entirely. In cases where someoneElsesJob is especially slow, or many other jobs besides someoneElsesJob have also been scheduled, it could be a long time before the second half of myJob is run. That was probably not the intention of the developer when they added that setTimeout to myJob. Enter scheduler.yield(), which puts the continuation of any function invoking it in a slightly higher priority queue than starting any other similar tasks. If myJob is changed to use it: async function myJob() { // Run part 1. myJobPart1(); // Yield with scheduler.yield() to break up long task, then run part2. await scheduler.yield(); myJobPart2(); } Now the execution looks like: The browser still has the opportunity to be responsive, but now the continuation of the myJob task is prioritized over starting the new task someoneElsesJob, so myJob is complete before someoneElsesJob begins. This is much closer to the expectation of yielding to the main thread to maintain responsiveness, not giving up the main thread entirely. Priority inheritance As part of the larger Prioritized Task Scheduling API, scheduler.yield() composes well with the explicit priorities available in scheduler.postTask(). Without a priority explicitly set, a scheduler.yield() within a scheduler.postTask() callback will act basically the same as the previous example. However, if a priority is set, such as using a low 'background' priority: async function lowPriorityJob() { part1(); await scheduler.yield(); part2(); } scheduler.postTask(lowPriorityJob, {priority: 'background'}); The continuation will be scheduled with a priority that's higher than other 'background' tasks—getting the expected prioritized continuation before any pending 'background' work—but still a lower priority than other default or high-priority tasks; it remains 'background' work. This means that if you schedule low priority work with a 'background' scheduler.postTask() (or with requestIdleCallback), the continuation after a scheduler.yield() within will also wait until most other tasks are complete and the main thread is idle to run, which is exactly what you want from yielding in a low-priority job. How to use the API For now, scheduler.yield() is only available in Chromium-based browsers, so to use it you'll need to feature detect and fall back to a secondary way of yielding for other browsers. scheduler-polyfill is a small polyfill for scheduler.postTask and scheduler.yield that internally uses a combination of methods to emulate a lot of the power of the scheduling APIs in other browsers (though scheduler.yield() priority inheritance is not supported). For those looking to avoid a polyfill, one method is to yield using setTimeout() and accept the loss of a prioritized continuation, or even not yielding in unsupported browsers if that's not acceptable. See the scheduler.yield() documentation in Optimize long tasks for more. The wicg-task-scheduling types can also be used to get type checking and IDE support if you're feature detecting scheduler.yield() and adding a fallback yourself. Learn more For more information on the API and how it interacts with task priorities and scheduler.postTask(), check out the scheduler.yield() and Prioritized Task Scheduling docs on MDN. To learn more about long tasks, how they affect the user experience, and what to do about them, read about optimizing long tasks. Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates. Last updated 2025-03-06 UTC. [[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-03-06 UTC.\"],[],[]]",
  "image": "https://developer.chrome.com/static/blog/use-scheduler-yield/images/hero.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv role=\"main\" id=\"main-content\" has-sidebar=\"\"\u003e\n          \n          \n          \n          \u003cdevsite-content\u003e\n            \n              \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003carticle\u003e\n  \n  \n  \n  \n  \n\n  \n  \n    \n  \u003cdevsite-feature-tooltip ack-key=\"AckCollectionsBookmarkTooltipDismiss\" analytics-category=\"Site-Wide Custom Events\" analytics-action-show=\"Callout Profile displayed\" analytics-action-close=\"Callout Profile dismissed\" analytics-label=\"Create Collection Callout\" dismiss-button=\"true\" id=\"devsite-collections-dropdown\" dismiss-button-text=\"Dismiss\" close-button-text=\"Got it\"\u003e\n\n    \n    \u003cdevsite-bookmark\u003e\u003c/devsite-bookmark\u003e\n\n    \u003cspan slot=\"popout-heading\"\u003e\n      \n      Stay organized with collections\n    \u003c/span\u003e\n    \u003cspan slot=\"popout-contents\"\u003e\n      \n      Save and categorize content based on your preferences.\n    \u003c/span\u003e\n  \u003c/devsite-feature-tooltip\u003e\n  \n  \n\n  \u003cdevsite-toc depth=\"2\" devsite-toc-embedded=\"\"\u003e\n  \u003c/devsite-toc\u003e\n  \n    \n  \n\n  \n\n\n\n\n\n\n\u003cdiv\u003e\n\n  \n    \n\n\n\n\n\u003cdiv translate=\"no\"\u003e\n        \n          \u003cp\u003e\u003cimg alt=\"Brendan Kenny\" src=\"https://web.dev/images/authors/bckenny.jpg\" decoding=\"async\" height=\"64\" loading=\"lazy\" width=\"64\"/\u003e\u003c/p\u003e\n      \u003c/div\u003e\n\n\u003cp\u003e\n  Published: March 6, 2025\n\u003c/p\u003e\n\n\n\n    \n    \n    \n  \n\n\u003cp\u003eA page feels sluggish and unresponsive when \u003ca href=\"https://web.dev/articles/optimize-long-tasks\"\u003elong tasks\u003c/a\u003e keep the main thread busy, preventing it from doing other important work, like responding to user input. As a result, even built-in form controls can appear broken to users—as if the page were frozen—never mind more complex custom components.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/docs/Web/API/scheduler/yield\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield()\u003c/code\u003e\u003c/a\u003e is a way of yielding to the main thread—allowing the browser to run any pending high-priority work—then continuing execution where it left off. This keeps a page more responsive and, in turn, helps improve \u003ca href=\"https://web.dev/articles/inp\"\u003eInteraction to Next Paint (INP)\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield\u003c/code\u003e offers an ergonomic API that does exactly what it says: execution of the function it\u0026#39;s called in pauses at the \u003ccode translate=\"no\" dir=\"ltr\"\u003eawait scheduler.yield()\u003c/code\u003e expression and yields to the main thread, breaking up the task. The execution of the rest of the function—called the continuation of the function—will be scheduled to run in a new event-loop task.\u003c/p\u003e\n\u003cdevsite-code\u003e\u003cpre translate=\"no\" dir=\"ltr\" is-upgraded=\"\" syntax=\"JavaScript\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003erespondToUserClick\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003egiveImmediateFeedback\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eawait\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003escheduler\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eyield\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e// Yield to the main thread.\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eslowerComputation\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/devsite-code\u003e\n\u003cp\u003eThe specific benefit of \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield\u003c/code\u003e is that the continuation after the yield is scheduled to run \u003cem\u003ebefore\u003c/em\u003e running any other similar tasks that have been queued up by the page. It prioritizes the continuation of a task over starting new tasks.\u003c/p\u003e\n\n\u003cp\u003eFunctions like \u003ccode translate=\"no\" dir=\"ltr\"\u003esetTimeout\u003c/code\u003e or \u003ca href=\"https://developer.mozilla.org/docs/Web/API/Scheduler/postTask\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.postTask\u003c/code\u003e\u003c/a\u003e can also be used to break up tasks, but those continuations typically run \u003cem\u003eafter\u003c/em\u003e any already-queued new tasks, potentially risking long delays between yielding to the main thread and completing their work.\u003c/p\u003e\n\n\u003ch2 id=\"prioritized_continuations_after_yielding\" data-text=\"Prioritized continuations after yielding\" tabindex=\"-1\"\u003ePrioritized continuations after yielding\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield\u003c/code\u003e is part of the \u003ca href=\"https://developer.mozilla.org/docs/Web/API/Prioritized_Task_Scheduling_API\"\u003ePrioritized Task Scheduling API\u003c/a\u003e. As web developers, we don\u0026#39;t typically talk about the order in which the event loop runs tasks in terms of explicit priorities, \u003ca href=\"https://github.com/WICG/scheduling-apis/blob/main/explainers/prioritized-post-task.md#existing-priorities\"\u003ebut the relative priorities are always there\u003c/a\u003e, such as a \u003ccode translate=\"no\" dir=\"ltr\"\u003erequestIdleCallback\u003c/code\u003e callback running after any queued \u003ccode translate=\"no\" dir=\"ltr\"\u003esetTimeout\u003c/code\u003e callbacks, or a triggered input event listener usually running before a task queued up with \u003ccode translate=\"no\" dir=\"ltr\"\u003esetTimeout(callback, 0)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003ePrioritized Task Scheduling just makes this more explicit, making it easier to figure out what task will run before another, and enables adjusting priorities to change that order of execution, if needed.\u003c/p\u003e\n\n\u003cp\u003eAs mentioned, the continued execution of a function after yielding with \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield()\u003c/code\u003e gets a priority higher than starting other tasks. The guiding concept is that the continuation of a task should run first, before moving on to other tasks. If the task is well-behaved code that periodically yields so that the browser can do other important things (like respond to user input), it shouldn\u0026#39;t be punished for yielding by getting prioritized after other similar tasks.\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s an example: two functions, queued up to run in different tasks using \u003ccode translate=\"no\" dir=\"ltr\"\u003esetTimeout\u003c/code\u003e.\u003c/p\u003e\n\u003cdevsite-code\u003e\u003cpre translate=\"no\" dir=\"ltr\" is-upgraded=\"\" syntax=\"JavaScript\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e\u003cspan\u003esetTimeout\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emyJob\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003esetTimeout\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esomeoneElsesJob\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/devsite-code\u003e\n\u003cp\u003eIn this case, the two \u003ccode translate=\"no\" dir=\"ltr\"\u003esetTimeout\u003c/code\u003e calls are right next to each other, but in a real page, they could be called in completely different places, like a first-party script and a third-party script independently setting up work to run, or it could be two tasks from separate components being triggered deep in your framework\u0026#39;s scheduler.\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s what that work could look like in DevTools:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://developer.chrome.com/static/blog/use-scheduler-yield/images/jobs1.png\" alt=\"Two tasks shown in the Chrome DevTools performance panel. Both are indicated to be long tasks, with the function \u0026#39;myJob\u0026#39; taking up the entire execution of the first task, and \u0026#39;someoneElsesJob\u0026#39; taking up the entirety of the second task.\" width=\"700\" height=\"112\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003emyJob\u003c/code\u003e is flagged as a long task, blocking the browser from doing anything else while it\u0026#39;s running. Assuming it\u0026#39;s from a first-party script, we can break it up:\u003c/p\u003e\n\u003cdevsite-code\u003e\u003cpre translate=\"no\" dir=\"ltr\" is-upgraded=\"\" syntax=\"JavaScript\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emyJob\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e// Run part 1.\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003emyJobPart1\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e// Yield with setTimeout() to break up long task, then run part2.\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003esetTimeout\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emyJobPart2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/devsite-code\u003e\n\u003cp\u003eBecause \u003ccode translate=\"no\" dir=\"ltr\"\u003emyJobPart2\u003c/code\u003e was scheduled to run with \u003ccode translate=\"no\" dir=\"ltr\"\u003esetTimeout\u003c/code\u003e within \u003ccode translate=\"no\" dir=\"ltr\"\u003emyJob\u003c/code\u003e, but that scheduling runs \u003cem\u003eafter\u003c/em\u003e \u003ccode translate=\"no\" dir=\"ltr\"\u003esomeoneElsesJob\u003c/code\u003e has already been scheduled, here\u0026#39;s how execution will look:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://developer.chrome.com/static/blog/use-scheduler-yield/images/jobs2.png\" alt=\"Three tasks shown in the Chrome DevTools performance panel. The first is running the function \u0026#39;myJobPart1\u0026#39;, the second is a long task running \u0026#39;someoneElsesJob\u0026#39;, and finally the third task is running \u0026#39;myJobPart2\u0026#39;.\" width=\"700\" height=\"128\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eWe\u0026#39;ve broken up the task with \u003ccode translate=\"no\" dir=\"ltr\"\u003esetTimeout\u003c/code\u003e so the browser can be responsive during the middle of \u003ccode translate=\"no\" dir=\"ltr\"\u003emyJob\u003c/code\u003e, but now the second part of \u003ccode translate=\"no\" dir=\"ltr\"\u003emyJob\u003c/code\u003e only runs after \u003ccode translate=\"no\" dir=\"ltr\"\u003esomeoneElsesJob\u003c/code\u003e has finished.\u003c/p\u003e\n\n\u003cp\u003eIn some cases, that might be fine, but usually this isn\u0026#39;t optimal. \u003ccode translate=\"no\" dir=\"ltr\"\u003emyJob\u003c/code\u003e was yielding to the main thread to make sure the page could stay responsive to user input, \u003cem\u003enot\u003c/em\u003e to give up the main thread entirely. In cases where \u003ccode translate=\"no\" dir=\"ltr\"\u003esomeoneElsesJob\u003c/code\u003e is especially slow, or many other jobs besides \u003ccode translate=\"no\" dir=\"ltr\"\u003esomeoneElsesJob\u003c/code\u003e have also been scheduled, it could be a long time before the second half of \u003ccode translate=\"no\" dir=\"ltr\"\u003emyJob\u003c/code\u003e is run. That was probably not the intention of the developer when they added that \u003ccode translate=\"no\" dir=\"ltr\"\u003esetTimeout\u003c/code\u003e to \u003ccode translate=\"no\" dir=\"ltr\"\u003emyJob\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eEnter \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield()\u003c/code\u003e, which puts the continuation of any function invoking it in a slightly higher priority queue than starting any other similar tasks. If \u003ccode translate=\"no\" dir=\"ltr\"\u003emyJob\u003c/code\u003e is changed to use it:\u003c/p\u003e\n\u003cdevsite-code\u003e\u003cpre translate=\"no\" dir=\"ltr\" is-upgraded=\"\" syntax=\"JavaScript\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emyJob\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e// Run part 1.\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003emyJobPart1\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e// Yield with scheduler.yield() to break up long task, then run part2.\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eawait\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003escheduler\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eyield\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003emyJobPart2\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/devsite-code\u003e\n\u003cp\u003eNow the execution looks like:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://developer.chrome.com/static/blog/use-scheduler-yield/images/jobs3.png\" alt=\"Two tasks shown in the Chrome DevTools performance panel. Both are indicated to be long tasks, with the function \u0026#39;myJob\u0026#39; taking up the entire execution of the first task, and \u0026#39;someoneElsesJob\u0026#39; taking up the entirety of the second task.\" width=\"700\" height=\"112\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eThe browser still has the opportunity to be responsive, but now the continuation of the \u003ccode translate=\"no\" dir=\"ltr\"\u003emyJob\u003c/code\u003e task is prioritized over starting the new task \u003ccode translate=\"no\" dir=\"ltr\"\u003esomeoneElsesJob\u003c/code\u003e, so \u003ccode translate=\"no\" dir=\"ltr\"\u003emyJob\u003c/code\u003e is complete before \u003ccode translate=\"no\" dir=\"ltr\"\u003esomeoneElsesJob\u003c/code\u003e begins. This is much closer to the expectation of yielding to the main thread to maintain responsiveness, not giving up the main thread entirely.\u003c/p\u003e\n\n\u003ch2 id=\"priority_inheritance\" data-text=\"Priority inheritance\" tabindex=\"-1\"\u003ePriority inheritance\u003c/h2\u003e\n\n\u003cp\u003eAs part of the larger Prioritized Task Scheduling API, \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield()\u003c/code\u003e composes well with the explicit priorities available in \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.postTask()\u003c/code\u003e. Without a priority explicitly set, a \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield()\u003c/code\u003e within a \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.postTask()\u003c/code\u003e callback will act basically the same as the previous example.\u003c/p\u003e\n\n\u003cp\u003eHowever, if a priority is set, such as using a low \u003ccode translate=\"no\" dir=\"ltr\"\u003e\u0026#39;background\u0026#39;\u003c/code\u003e priority:\u003c/p\u003e\n\u003cdevsite-code\u003e\u003cpre translate=\"no\" dir=\"ltr\" is-upgraded=\"\" syntax=\"JavaScript\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003elowPriorityJob\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003epart1\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eawait\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003escheduler\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eyield\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003epart2\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003escheduler\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epostTask\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elowPriorityJob\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003epriority\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;background\u0026#39;\u003c/span\u003e\u003cspan\u003e});\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/devsite-code\u003e\n\u003cp\u003eThe continuation will be scheduled with a priority that\u0026#39;s higher than other \u003ccode translate=\"no\" dir=\"ltr\"\u003e\u0026#39;background\u0026#39;\u003c/code\u003e tasks—getting the expected prioritized continuation before any pending \u003ccode translate=\"no\" dir=\"ltr\"\u003e\u0026#39;background\u0026#39;\u003c/code\u003e work—but still a lower priority than other default or high-priority tasks; it remains \u003ccode translate=\"no\" dir=\"ltr\"\u003e\u0026#39;background\u0026#39;\u003c/code\u003e work.\u003c/p\u003e\n\n\u003cp\u003eThis means that if you schedule low priority work with a \u003ccode translate=\"no\" dir=\"ltr\"\u003e\u0026#39;background\u0026#39;\u003c/code\u003e \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.postTask()\u003c/code\u003e (or with \u003ccode translate=\"no\" dir=\"ltr\"\u003erequestIdleCallback\u003c/code\u003e), the continuation after a \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield()\u003c/code\u003e within will also wait until most other tasks are complete and the main thread is idle to run, which is exactly what you want from yielding in a low-priority job.\u003c/p\u003e\n\n\u003ch2 id=\"how_to_use_the_api\" data-text=\"How to use the API\" tabindex=\"-1\"\u003eHow to use the API\u003c/h2\u003e\n\n\u003cp\u003eFor now, \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield()\u003c/code\u003e is only available in Chromium-based browsers, so to use it you\u0026#39;ll need to feature detect and fall back to a secondary way of yielding for other browsers.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://www.npmjs.com/package/scheduler-polyfill\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler-polyfill\u003c/code\u003e\u003c/a\u003e is a small polyfill for \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.postTask\u003c/code\u003e and \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield\u003c/code\u003e that internally uses a combination of methods to emulate a lot of the power of the scheduling APIs in other browsers (though \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield()\u003c/code\u003e priority inheritance is not supported).\u003c/p\u003e\n\n\u003cp\u003eFor those looking to avoid a polyfill, one method is to yield using \u003ccode translate=\"no\" dir=\"ltr\"\u003esetTimeout()\u003c/code\u003e and accept the loss of a prioritized continuation, or even not yielding in unsupported browsers if that\u0026#39;s not acceptable. See the \u003ca href=\"https://web.dev/articles/optimize-long-tasks#cross-browser_support\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield()\u003c/code\u003e documentation in Optimize long tasks for more\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ca href=\"https://www.npmjs.com/package/@types/wicg-task-scheduling\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003ewicg-task-scheduling\u003c/code\u003e types\u003c/a\u003e can also be used to get type checking and IDE support if you\u0026#39;re feature detecting \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield()\u003c/code\u003e and adding a fallback yourself.\u003c/p\u003e\n\n\u003ch2 id=\"learn_more\" data-text=\"Learn more\" tabindex=\"-1\"\u003eLearn more\u003c/h2\u003e\n\n\u003cp\u003eFor more information on the API and how it interacts with task priorities and \u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.postTask()\u003c/code\u003e, check out the \u003ca href=\"https://developer.mozilla.org/docs/Web/API/scheduler/yield\"\u003e\u003ccode translate=\"no\" dir=\"ltr\"\u003escheduler.yield()\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://developer.mozilla.org/docs/Web/API/Prioritized_Task_Scheduling_API\"\u003ePrioritized Task Scheduling\u003c/a\u003e docs on MDN.\u003c/p\u003e\n\n\u003cp\u003eTo learn more about long tasks, how they affect the user experience, and what to do about them, read about \u003ca href=\"https://web.dev/articles/optimize-long-tasks\"\u003eoptimizing long tasks\u003c/a\u003e.\u003c/p\u003e\n\n  \n\n  \n\u003c/div\u003e\n\n  \n\n  \n    \n    \n      \n    \u003cdevsite-thumb-rating position=\"footer\"\u003e\n    \u003c/devsite-thumb-rating\u003e\n  \n       \n    \n    \n  \n\n  \n  \n\u003c/article\u003e\n\n\n\u003cdevsite-content-footer\u003e\n  \u003cp\u003eExcept as otherwise noted, the content of this page is licensed under the \u003ca href=\"https://creativecommons.org/licenses/by/4.0/\"\u003eCreative Commons Attribution 4.0 License\u003c/a\u003e, and code samples are licensed under the \u003ca href=\"https://www.apache.org/licenses/LICENSE-2.0\"\u003eApache 2.0 License\u003c/a\u003e. For details, see the \u003ca href=\"https://developers.google.com/site-policies\"\u003eGoogle Developers Site Policies\u003c/a\u003e. Java is a registered trademark of Oracle and/or its affiliates.\u003c/p\u003e\n  \u003cp\u003eLast updated 2025-03-06 UTC.\u003c/p\u003e\n\u003c/devsite-content-footer\u003e\n\n\n\u003cdevsite-notification\u003e\n\u003c/devsite-notification\u003e\n\n\n  \n\u003cp\u003e\n  \n  \n    \u003ctemplate\u003e\n      [[[\u0026#34;Easy to understand\u0026#34;,\u0026#34;easyToUnderstand\u0026#34;,\u0026#34;thumb-up\u0026#34;],[\u0026#34;Solved my problem\u0026#34;,\u0026#34;solvedMyProblem\u0026#34;,\u0026#34;thumb-up\u0026#34;],[\u0026#34;Other\u0026#34;,\u0026#34;otherUp\u0026#34;,\u0026#34;thumb-up\u0026#34;]],[[\u0026#34;Missing the information I need\u0026#34;,\u0026#34;missingTheInformationINeed\u0026#34;,\u0026#34;thumb-down\u0026#34;],[\u0026#34;Too complicated / too many steps\u0026#34;,\u0026#34;tooComplicatedTooManySteps\u0026#34;,\u0026#34;thumb-down\u0026#34;],[\u0026#34;Out of date\u0026#34;,\u0026#34;outOfDate\u0026#34;,\u0026#34;thumb-down\u0026#34;],[\u0026#34;Samples / code issue\u0026#34;,\u0026#34;samplesCodeIssue\u0026#34;,\u0026#34;thumb-down\u0026#34;],[\u0026#34;Other\u0026#34;,\u0026#34;otherDown\u0026#34;,\u0026#34;thumb-down\u0026#34;]],[\u0026#34;Last updated 2025-03-06 UTC.\u0026#34;],[],[]]\n    \u003c/template\u003e\n  \n\u003c/p\u003e\n            \n          \u003c/devsite-content\u003e\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": null,
  "modifiedTime": null
}
