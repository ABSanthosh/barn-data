{
  "id": "2b0d02df-81df-488b-8aff-caf2d9ba6f51",
  "title": "How to Make a “Scroll to Select” Form Control",
  "link": "https://css-tricks.com/how-to-make-a-scroll-to-select-form-control/",
  "description": "The  element is a fairly straightforward concept: focus on it to reveal a set of s that can be selected as the input’s value. That’s a great pattern and I’m not suggesting we change it. That said, I … How to Make a “Scroll to Select” Form Control originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Preethi",
  "published": "Wed, 25 Sep 2024 14:31:54 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "forms"
  ],
  "byline": "Preethi",
  "length": 10411,
  "excerpt": "The \u003cselect\u003e element is a fairly straightforward concept: focus on it to reveal a set of \u003coption\u003es that can be selected as the",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "DigitalOcean provides cloud products for every stage of your journey. Get started with $200 in free credit! The \u003cselect\u003e element is a fairly straightforward concept: focus on it to reveal a set of \u003coption\u003es that can be selected as the input’s value. That’s a great pattern and I’m not suggesting we change it. That said, I do enjoy poking at things and found an interesting way to turn a \u003cselect\u003e into a dial of sorts — where options are selected by scrolling them into position, not totally unlike a combination lock or iOS date pickers. Anyone who’s expanded a \u003cselect\u003e for selecting a country knows how painfully long lists can be and this could be one way to prevent that. Here’s what I’m talking about: It’s fairly common knowledge that styling \u003cselect\u003e in CSS is not the easiest thing in the world. But here’s the trick: we’re not working with \u003cselect\u003e at all. No, we’re not going to do anything like building our own \u003cselect\u003e by jamming a bunch of JavaScript into a \u003cdiv\u003e. We’re still working with semantic form controls, only it’s radio buttons. \u003csection class=scroll-container\u003e \u003clabel for=\"madrid\" class=\"scroll-item\"\u003e Madrid \u003cabbr\u003eMAD\u003c/abbr\u003e \u003cinput id=\"madrid\" type=\"radio\" name=\"items\"\u003e \u003c/label\u003e \u003clabel for=\"malta\" class=\"scroll-item\"\u003e Malta \u003cabbr\u003eMLA\u003c/abbr\u003e \u003cinput id=\"malta\" type=\"radio\" name=\"items\"\u003e \u003c/label\u003e \u003c!-- etc. --\u003e \u003c/section\u003e What we need is to style the list of selectable controls where we are capable of managing their sizes and spacing in CSS. I’ve gone with a group of labels with nested radio boxes as far as the markup goes. The exact styling is totally up to you, of course, but you can use these base styles I wrote up if you want a starting point. .scroll-container { /* SIZING \u0026 LAYOUT */ --itemHeight: 60px; --itemGap: 10px; --containerHeight: calc((var(--itemHeight) * 7) + (var(--itemGap) * 6)); width: 400px; height: var(--containerHeight); align-items: center; row-gap: var(--itemGap); border-radius: 4px; /* PAINT */ --topBit: calc((var(--containerHeight) - var(--itemHeight))/2); --footBit: calc((var(--containerHeight) + var(--itemHeight))/2); background: linear-gradient( rgb(254 251 240), rgb(254 251 240) var(--topBit), rgb(229 50 34 / .5) var(--topBit), rgb(229 50 34 / .5) var(--footBit), rgb(254 251 240) var(--footBit)); box-shadow: 0 0 10px #eee; } A couple of details on this: --itemHeight is the height of each item in the list. --itemGap is meant to be the space between two items. The --containerHeight variable is the .scroll-container’s height. It’s the sum of the item sizes and the gaps between them, ensuring that we display, at maximum, seven items at once. (An odd number of items gives us a nice balance where the selected item is directly in the vertical center of the list).  The background is a striped gradient that highlights the middle area, i.e., the location of the currently selected item.   The --topBit and –-footBit variables are color stops that visually paint in the middle area (which is orange in the demo) to represent the currently selected item. I’ll arrange the controls in a vertical column with flexbox declared on the .scroll-container: .scroll-container { display: flex; flex-direction: column; /* rest of styles */ } With layout work done, we can focus on the scrolling part of this. If you haven’t worked with CSS Scroll Snapping before, it’s a convenient way to direct a container’s scrolling behavior. For example, we can tell the .scroll-container that we want to enable scrolling in the vertical direction. That way, it’s possible to scroll to the rest of the items that are not in view. .scroll-container { overflow-y: scroll; /* rest of styles */ } Next, we reach for the scroll-snap-style property that can be used to tell the .scroll-container that we want scrolling to stop on an item — not near an item, but directly on it. .scroll-container { overflow-y: scroll; scroll-snap-type: y mandatory; /* rest of styles */ } Now items “snap” onto an item instead of allowing a scroll to end wherever it wants. One more little detail I like to include is overscroll-behavior, specifically along the y-axis as far as this demo goes: .scroll-container { overflow-y: scroll; scroll-snap-type: y mandatory; overscroll-behavior-y: none; /* rest of styles */ } overscroll-behavior-y: none isn’t required to make this work, but when someone scrolls through the .scroll-container (along the y-axis), scrolling stops once the boundary is reached, and any further continued scrolling action will not trigger scrolling in any nearby scroll containers. Just a form of defensive CSS. Time to move to the items inside the scroll container. But before we go there, here are some base styles for the items themselves that you can use as a starting point: .scroll-item { /* SIZING \u0026 LAYOUT */ width: 90%; box-sizing: border-box; padding-inline: 20px; border-radius: inherit; /* PAINT \u0026 FONT */ background: linear-gradient(to right, rgb(242 194 66), rgb(235 122 51)); box-shadow: 0 0 4px rgb(235 122 51); font: 16pt/var(--itemHeight) system-ui; color: #fff; input { appearance: none; } abbr { float: right; } /* The airport code */ } As I mentioned earlier, the --itemHeight variable is setting as the size of each item and we’re declaring it on the flex property — flex: 0 0 var(--itemHeight). Margin is added before and after the first and last items, respectively, so that every item can reach the middle of the container through scrolling.  The scroll-snap-align property is there to give the .scroll-container a snap point for the items. A center alignment, for instance, snaps an item’s center (vertical center, in this case) with the .scroll-container‘s center (vertical center as well). Since the items are meant to be selected through scrolling alone pointer-events: none is added to prevent selection from clicks. One last little styling detail is to set a new background on an item when it is in a :checked state: .scroll-item { /* Same styles as before */ /* If input=\"radio\" is :checked */ \u0026:has(:checked) { background: rgb(229 50 34); } } But wait! You’re probably wondering how in the world an item can be :checked when we’re removing pointer-events. Good question! We’re all finished with styling, so let’s move on to figuring some way to “select” an item purely through scrolling. In other words, whatever item scrolls into view and “snaps” into the container’s vertical center needs to behave like a typical form control selection. Yes, we’ll need JavaScript for that.  let observer = new IntersectionObserver(entries =\u003e { entries.forEach(entry =\u003e { with(entry) if(isIntersecting) target.children[1].checked = true; }); }, { root: document.querySelector(`.scroll-container`), rootMargin: `-51% 0px -49% 0px` }); document.querySelectorAll(`.scroll-item`).forEach(item =\u003e observer.observe(item)); The IntersectionObserver object is used to monitor (or “observe”) if and when an element (called a target) crosses through (or “intersects”) another element. That other element could be the viewport itself, but in this case, we’re observing the .scroll-container for when a .scroll-item intersects it. We’ve established the observed boundary with rootMargin:\"-51% 0px -49% 0px\".   A callback function is executed when that happens, and we can use that to apply changes to the target element, which is the currently selected .scroll-item. In our case, we want to select a .scroll-item that is at the halfway mark in the .scroll-container: target.children[1].checked = true. That completes the code. Now, as we scroll through the items, whichever one snaps into the center position is the selected item. Here’s a look at the final demo again: Let’s say that, instead of selecting an item that snaps into the .scroll-container‘s vertical center, the selection point we need to watch is the top of the container. No worries! All we do is update the scroll-snap-align property value from center to start in the CSS and remove the :first-of-type‘s top margin. From there, it’s only a matter of updating the scroll container’s background gradient so that the color stops highlight the top instead of the center. Like this: And if one of the items has to be pre-selected when the page loads, we can get its position in JavaScript (getBoundingClientRect()) and use the scrollTo() method to scroll the container to where that specific item’s position is at the point of selection (which we’ll say is the center in keeping with our original demo). We’ll append a .selected class on that .scroll-item.  \u003csection class=\"scroll-container\"\u003e \u003c!-- more items --\u003e \u003clabel class=\"scroll-items selected\"\u003e 2024 \u003cinput type=radio name=items /\u003e \u003c/label\u003e \u003c!-- more items --\u003e \u003c/section\u003e Let’s select the .selected class, get its dimensions, and automatically scroll to it on page load: let selected_item = (document.querySelector(\".selected\")).getBoundingClientRect(); let scroll_container = document.querySelector(\".scroll-container\"); scroll_container.scrollTo(0, selected_item.top - scroll_container.offsetHeight - selected_item.height); It’s a little tough to demo this in a typical CodePen embed, so here’s a live demo in a GitHub Page (source code). I’ll drop a video in as well: That’s it! You can build up this control or use it as a starting point to experiment with different layouts, styles, animations, and such. It’s important the UX clearly conveys to the users how the selection is done and which item is currently selected. And if I was doing this in a production environment, I’d want to make sure there’s a good fallback experience for when JavaScript might be unavailable and that my markup performs well on a screen reader. References and further reading A Few Functional Uses for Intersection Observer to Know When an Element is in View (Preethi Sam) An Explanation of How the Intersection Observer Watches (Travis Almand) Practical CSS Scroll Snapping (Max Kohler) The Current State of Styling Selects in 2019 (Chris Coyier) CSS Flexbox Layout Guide (CSS-Tricks) CSS flex property (CSS-Tricks) CSS Scroll Snap Properties (MDN) scrollTo() (MDN)",
  "image": "https://css-tricks.com/wp-json/social-image-generator/v1/image/381060",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cp\u003e\n\tDigitalOcean provides cloud products for every stage of your journey. Get started with \u003ca href=\"https://try.digitalocean.com/css-tricks/?utm_medium=content_acq\u0026amp;utm_source=css-tricks\u0026amp;utm_campaign=global_brand_ad_en\u0026amp;utm_content=conversion_prearticle_everystage\"\u003e$200 in free credit!\u003c/a\u003e\n\u003c/p\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eThe \u003ccode\u003e\u0026lt;select\u0026gt;\u003c/code\u003e element is a fairly straightforward concept: focus on it to reveal a set of \u003ccode\u003e\u0026lt;option\u0026gt;\u003c/code\u003es that can be selected as the input’s value. That’s a great pattern and I’m not suggesting we change it. That said, I do enjoy poking at things and found an interesting way to turn a \u003ccode\u003e\u0026lt;select\u0026gt;\u003c/code\u003e into a dial of sorts — where options are selected by scrolling them into position, not totally unlike a combination lock or iOS date pickers. Anyone who’s expanded a \u003ccode\u003e\u0026lt;select\u0026gt;\u003c/code\u003e for selecting a country knows how painfully long lists can be and this could be one way to prevent that.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere’s what I’m talking about:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eIt’s fairly common knowledge that styling \u003ccode\u003e\u0026lt;select\u0026gt;\u003c/code\u003e in CSS is not the easiest thing in the world. But here’s the trick: \u003cstrong\u003ewe’re not working with \u0026lt;select\u0026gt; at all.\u003c/strong\u003e No, we’re not going to do anything like building our own \u0026lt;select\u0026gt; by jamming a bunch of JavaScript into a \u003ccode\u003e\u0026lt;div\u0026gt;\u003c/code\u003e. We’re still working with semantic form controls, only it’s radio buttons.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;section class=scroll-container\u0026gt;\n  \u0026lt;label for=\u0026#34;madrid\u0026#34; class=\u0026#34;scroll-item\u0026#34;\u0026gt;\n      Madrid \n      \u0026lt;abbr\u0026gt;MAD\u0026lt;/abbr\u0026gt;\n      \u0026lt;input id=\u0026#34;madrid\u0026#34; type=\u0026#34;radio\u0026#34; name=\u0026#34;items\u0026#34;\u0026gt;\n  \u0026lt;/label\u0026gt;\n  \u0026lt;label for=\u0026#34;malta\u0026#34; class=\u0026#34;scroll-item\u0026#34;\u0026gt;\n      Malta \n      \u0026lt;abbr\u0026gt;MLA\u0026lt;/abbr\u0026gt;\n      \u0026lt;input id=\u0026#34;malta\u0026#34; type=\u0026#34;radio\u0026#34; name=\u0026#34;items\u0026#34;\u0026gt;\n  \u0026lt;/label\u0026gt;\n  \u0026lt;!-- etc. --\u0026gt;\n\u0026lt;/section\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhat we need is to style the list of selectable controls where we are capable of managing their sizes and spacing in CSS. I’ve gone with a group of labels with nested radio boxes as far as the markup goes. The exact styling is totally up to you, of course, but you can use these base styles I wrote up if you want a starting point.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.scroll-container {\n  /* SIZING \u0026amp; LAYOUT */\n  --itemHeight: 60px;\n  --itemGap: 10px;\n  --containerHeight: calc((var(--itemHeight) * 7) + (var(--itemGap) * 6));\n\n  width: 400px; \n  height: var(--containerHeight);\n  align-items: center;\n  row-gap: var(--itemGap);\n  border-radius: 4px;\n\n  /* PAINT */\n  --topBit: calc((var(--containerHeight) - var(--itemHeight))/2);\n  --footBit: calc((var(--containerHeight) + var(--itemHeight))/2);\n\n  background: linear-gradient(\n    rgb(254 251 240), \n    rgb(254 251 240) var(--topBit), \n    rgb(229 50 34 / .5) var(--topBit), \n    rgb(229 50 34 / .5) var(--footBit), \n    rgb(254 251 240) \n    var(--footBit));\n  box-shadow: 0 0 10px #eee;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eA couple of details on this:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e--itemHeight\u003c/code\u003e is the height of each item in the list.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e--itemGap\u003c/code\u003e is meant to be the space between two items.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003ccode\u003e--containerHeight\u003c/code\u003e variable is the .scroll-container’s height. It’s the sum of the item sizes and the gaps between them, ensuring that we display, at maximum, seven items at once. (An odd number of items gives us a nice balance where the selected item is directly in the vertical center of the list). \u003c/li\u003e\n\n\n\n\u003cli\u003eThe background is a striped gradient that highlights the middle area, i.e., the location of the currently selected item. \u003c/li\u003e\n\n\n\n\u003cli\u003e The \u003ccode\u003e--topBit\u003c/code\u003e and –\u003ccode\u003e-footBit\u003c/code\u003e variables are color stops that visually paint in the middle area (which is orange in the demo) to represent the currently selected item.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eI’ll arrange the controls in a vertical column with flexbox declared on the .scroll-container:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.scroll-container {\n  display: flex; \n  flex-direction: column;\n  /* rest of styles */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith layout work done, we can focus on the scrolling part of this. If you haven’t worked with \u003ca href=\"https://css-tricks.com/practical-css-scroll-snapping/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCSS Scroll Snapping\u003c/a\u003e before, it’s a convenient way to direct a container’s scrolling behavior. For example, we can tell the \u003ccode\u003e.scroll-container\u003c/code\u003e that we want to enable scrolling in the vertical direction. That way, it’s possible to scroll to the rest of the items that are not in view.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.scroll-container {\n  overflow-y: scroll;\n  /* rest of styles */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, we reach for the \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/properties/s/scroll-snap-type/\"\u003escroll-snap-style\u003c/a\u003e\u003c/code\u003e property that can be used to tell the \u003ccode\u003e.scroll-container\u003c/code\u003e that we want scrolling to stop on an item — not \u003cem\u003enear\u003c/em\u003e an item, but directly on it.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"3\"\u003e\u003ccode markup=\"tt\"\u003e.scroll-container {\n  overflow-y: scroll;\n  scroll-snap-type: y mandatory;\n  /* rest of styles */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow items “snap” onto an item instead of allowing a scroll to end wherever it wants. One more little detail I like to include is \u003ca href=\"https://css-tricks.com/almanac/properties/o/overscroll-behavior/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003e\u003ccode\u003eoverscroll-behavior\u003c/code\u003e\u003c/a\u003e, specifically along the y-axis as far as this demo goes:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"4\"\u003e\u003ccode markup=\"tt\"\u003e.scroll-container {\n  overflow-y: scroll;\n  scroll-snap-type: y mandatory;\n  overscroll-behavior-y: none;\n  /* rest of styles */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003eoverscroll-behavior-y: none\u003c/code\u003e isn’t required to make this work, but when someone scrolls through the \u003ccode\u003e.scroll-container\u003c/code\u003e (along the y-axis), scrolling stops once the boundary is reached, and any further continued scrolling action will not trigger scrolling in any nearby scroll containers. Just a form of defensive CSS.\u003c/p\u003e\n\n\n\n\u003cp\u003eTime to move to the items inside the scroll container. But before we go there, here are some base styles for the items themselves that you can use as a starting point:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.scroll-item {\n  /* SIZING \u0026amp; LAYOUT */\n  width: 90%;\n  box-sizing: border-box;\n  padding-inline: 20px;\n  border-radius: inherit; \n\n  /* PAINT \u0026amp; FONT */\n  background: linear-gradient(to right, rgb(242 194 66), rgb(235 122 51));\n  box-shadow: 0 0 4px rgb(235 122 51);\n  font: 16pt/var(--itemHeight) system-ui;\n  color: #fff;\n\n  input { appearance: none; } \n  abbr { float: right; } /* The airport code */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAs I mentioned earlier, the \u003ccode\u003e--itemHeight\u003c/code\u003e variable is setting as the size of each item and we’re declaring it on the \u003ccode\u003eflex\u003c/code\u003e property — \u003ccode\u003eflex: 0 0 var(--itemHeight)\u003c/code\u003e. Margin is added before and after the first and last items, respectively, so that every item can reach the middle of the container through scrolling. \u003c/p\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/properties/s/scroll-snap-align/\"\u003escroll-snap-align\u003c/a\u003e\u003c/code\u003e property is there to give the \u003ccode\u003e.scroll-container\u003c/code\u003e a snap point for the items. A center alignment, for instance, snaps an item’s center (vertical center, in this case) with the \u003ccode\u003e.scroll-container\u003c/code\u003e‘s center (vertical center as well). Since the items are meant to be selected through scrolling alone \u003ccode\u003epointer-events: none\u003c/code\u003e is added to prevent selection from clicks.\u003c/p\u003e\n\n\n\n\u003cp\u003eOne last little styling detail is to set a new background on an item when it is in a \u003ccode\u003e:checked\u003c/code\u003e state:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.scroll-item {\n  /* Same styles as before */\n\n  /* If input=\u0026#34;radio\u0026#34; is :checked */\n  \u0026amp;:has(:checked) {\n    background: rgb(229 50 34);\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eBut wait!\u003c/em\u003e You’re probably wondering how in the world an item can be \u003ccode\u003e:checked\u003c/code\u003e when we’re removing \u003ccode\u003epointer-events\u003c/code\u003e. Good question! We’re all finished with styling, so let’s move on to figuring some way to “select” an item purely through scrolling. In other words, whatever item scrolls into view and “snaps” into the container’s vertical center needs to behave like a typical form control selection. Yes, we’ll need JavaScript for that. \u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003elet observer = new IntersectionObserver(entries =\u0026gt; { \n  entries.forEach(entry =\u0026gt; {\n    with(entry) if(isIntersecting) target.children[1].checked = true;\n  });\n}, { \n  root: document.querySelector(`.scroll-container`), rootMargin: `-51% 0px -49% 0px`\n});\n\ndocument.querySelectorAll(`.scroll-item`).forEach(item =\u0026gt; observer.observe(item));\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe\u003ccode\u003e IntersectionObserver\u003c/code\u003e object is used to monitor (or “observe”) if and when an element (called a\u003ccode\u003e target\u003c/code\u003e) crosses through (or “intersects”) another element. That other element could be the viewport itself, but in this case, we’re observing the \u003ccode\u003e.scroll-container\u003c/code\u003e for when a \u003ccode\u003e.scroll-item\u003c/code\u003e intersects it. We’ve established the observed boundary with \u003ccode\u003erootMargin:\u0026#34;-51% 0px -49% 0px\u0026#34;\u003c/code\u003e.  \u003c/p\u003e\n\n\n\n\u003cp\u003eA callback function is executed when that happens, and we can use that to apply changes to the target element, which is the currently selected \u003ccode\u003e.scroll-item\u003c/code\u003e. In our case, we want to select a \u003ccode\u003e.scroll-item\u003c/code\u003e that is at the halfway mark in the \u003ccode\u003e.scroll-container\u003c/code\u003e: \u003ccode\u003etarget.children[1].checked = true\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat completes the code. Now, as we scroll through the items, whichever one snaps into the center position is the selected item. Here’s a look at the final demo again:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eLet’s say that, instead of selecting an item that snaps into the \u003ccode\u003e.scroll-container\u003c/code\u003e‘s vertical center, the selection point we need to watch is the top of the container. No worries! All we do is update the \u003ccode\u003escroll-snap-align\u003c/code\u003e property value from center to start in the CSS and remove the :\u003ccode\u003efirst-of-type\u003c/code\u003e‘s top margin. From there, it’s only a matter of updating the scroll container’s background gradient so that the color stops highlight the top instead of the center. Like this:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eAnd if one of the items has to be pre-selected when the page loads, we can get its position in JavaScript (\u003ccode\u003egetBoundingClientRect()\u003c/code\u003e) and use the \u003ccode\u003escrollTo()\u003c/code\u003e method to scroll the container to where that specific item’s position is at the point of selection (which we’ll say is the center in keeping with our original demo). We’ll append a \u003ccode\u003e.selecte\u003c/code\u003ed class on that \u003ccode\u003e.scroll-item\u003c/code\u003e. \u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;section class=\u0026#34;scroll-container\u0026#34;\u0026gt;\n  \u0026lt;!-- more items --\u0026gt;\n  \u0026lt;label class=\u0026#34;scroll-items selected\u0026#34;\u0026gt;\n    2024\n    \u0026lt;input type=radio name=items /\u0026gt;\n  \u0026lt;/label\u0026gt;\n\n  \u0026lt;!-- more items --\u0026gt;\n\u0026lt;/section\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s select the \u003ccode\u003e.selected\u003c/code\u003e class, get its dimensions, and automatically scroll to it on page load:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003elet selected_item = (document.querySelector(\u0026#34;.selected\u0026#34;)).getBoundingClientRect();\nlet scroll_container = document.querySelector(\u0026#34;.scroll-container\u0026#34;);\nscroll_container.scrollTo(0, selected_item.top - scroll_container.offsetHeight - selected_item.height);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIt’s a little tough to demo this in a typical CodePen embed, so here’s a live demo in a \u003ca target=\"_blank\" href=\"https://rpsthecoder.github.io/scroll-to-select/\" rel=\"noreferrer noopener\"\u003eGit\u003c/a\u003e\u003ca target=\"_blank\" href=\"https://rpsthecoder.github.io/scroll-to-select/\" rel=\"noreferrer noopener\"\u003eH\u003c/a\u003e\u003ca target=\"_blank\" href=\"https://rpsthecoder.github.io/scroll-to-select/\" rel=\"noreferrer noopener\"\u003eub Page\u003c/a\u003e (\u003ca target=\"_blank\" href=\"https://github.com/rpsthecoder/scroll-to-select/blob/main/index.html\" rel=\"noreferrer noopener\"\u003esource\u003c/a\u003e\u003ca target=\"_blank\" href=\"https://github.com/rpsthecoder/scroll-to-select/blob/main/index.html\" rel=\"noreferrer noopener\"\u003e code\u003c/a\u003e). I’ll drop a video in as well:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://css-tricks.com/wp-content/uploads/2024/09/scroll-to-select.mov\" playsinline=\"\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThat’s it! You can build up this control or use it as a starting point to experiment with different layouts, styles, animations, and such. It’s important the UX clearly conveys to the users how the selection is done and which item is currently selected. And if I was doing this in a production environment, I’d want to make sure there’s a good fallback experience for when JavaScript might be unavailable and that my markup performs well on a screen reader.\u003c/p\u003e\n\n\n\u003ch3 id=\"referencesnbspand-further-reading\"\u003eReferences and further reading\u003c/h3\u003e\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://css-tricks.com/a-few-functional-uses-for-intersection-observer-to-know-when-an-element-is-in-view/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eA Few Functional Uses for Intersection Observer to Know When an Element is in View\u003c/a\u003e (Preethi Sam)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://css-tricks.com/an-explanation-of-how-the-intersection-observer-watches/?ref=csslayout.news\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eAn Explanation of How the Intersection Observer Watches\u003c/a\u003e (Travis Almand)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://css-tricks.com/practical-css-scroll-snapping/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ePractical CSS Scroll Snapping\u003c/a\u003e (Max Kohler)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://css-tricks.com/the-current-state-of-styling-selects-in-2019/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eThe Current State of Styling Selects in 2019\u003c/a\u003e (Chris Coyier)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCSS Flexbox Layout Guide\u003c/a\u003e (CSS-Tricks)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://css-tricks.com/almanac/properties/f/flex/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCSS \u003c/a\u003e\u003ca href=\"https://css-tricks.com/almanac/properties/f/flex/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eflex\u003c/a\u003e\u003ca href=\"https://css-tricks.com/almanac/properties/f/flex/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003e property\u003c/a\u003e (CSS-Tricks)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_scroll_snap#reference\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCSS Scroll Snap Properties\u003c/a\u003e (MDN)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTo\" target=\"_blank\" rel=\"noreferrer noopener\"\u003escrollTo()\u003c/a\u003e (MDN)\u003c/li\u003e\n\u003c/ul\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2024-09-25T08:31:54-06:00",
  "modifiedTime": "2024-09-25T08:31:57-06:00"
}
