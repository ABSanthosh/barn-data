{
  "id": "513bd657-c6c2-4182-baf9-e25dce319880",
  "title": "Introducing Voice Boost 2: Remaster your podcasts",
  "link": "https://marco.org/2020/01/31/voiceboost2",
  "description": "The latest update to Overcast includes a feature that I‚Äôm especially proud of that took over a year to build. Voice Boost 2 is an all-new audio engine that includes professional-grade, mastering-quality loudness normalization. When I first introduced Overcast in 2014, Voice Boost was one of its headlining features: Voice Boost is a combination of dynamic compression and equalization that can make many shows more listenable and normalize volume across all shows. This makes amateur-produced podcasts (including many of my favorites) more listenable in loud environments, like cars, where you‚Äôd otherwise need to crank the volume so loudly to hear the quiet parts that you‚Äôd blow your ears out when the loudest person spoke. Voice Boost 2 achieves the same goal as the original Voice Boost, but with dramatically more sophisticated methods, leading to more consistent results and much better sound quality. Goals When I wrote the original Voice Boost with only a rudimentary understanding of audio processing, it was a single configuration of Apple‚Äôs AudioUnits that applied a fixed set of parameters to all podcasts, regardless of their audio characteristics. It was an effective but blunt tool, relying on aggressive level compression and a strong EQ to make the compression less noticeable. Since then, I‚Äôve edited over 500 podcasts, learned a lot more about how to master them properly, and developed a much better understanding of audio signal processing. I set out to develop a better, smarter, and more refined Voice Boost that took advantage of everything I‚Äôd learned, with these audio goals: The effect should be much more subtle: mostly just consistent volume, plus slightly smoother tone. It should analyze the input audio and apply just enough processing to achieve a consistent volume level, modifying already-good audio as little as possible. It should sound good, and consistent, regardless of the volume dynamics of its input. Quality should be so good that I can even play high-quality music through it1 and not notice any artifacts. And these technical goals: Like Smart Speed and the original Voice Boost, it had to work as a streaming process, easily toggled on and off at will, without needing to scan the entire file first or look very far ahead. The code had to be pure C, with highly optimized and vectorized code, so it wouldn‚Äôt be a major power drain on older phones and could potentially run on much lower-power devices as well. I had to write every component from scratch, without using AudioUnits, because I wanted to understand and control everything, ensure the highest performance and sound quality, and avoid Apple‚Äôs platform-specific API limits.2 It had to be modular and easily customizable, like a channel strip in an audio editor, so I could adjust the processing during development and testing, offer user customization down the road, and use the same engine to build myself a modular podcast-preproduction tool to save time in my weekly workflow (which I‚Äôve been using for over a year).3 Live LUFS normalization Since Voice Boost is mostly about high-quality volume analysis and loudness normalization, I went straight to the top, implementing the ITU BS.1770‚Äì4 standard that gives us the LUFS measurement seen in high-end audio editors. Overcast now measures and adjusts podcast levels using this broadcast-standard perceptual loudness algorithm, at full quality, with no preprocessing. Voice Boost 2 normalizes all podcasts to ‚Äì14¬†LUFS ‚Äî a level I chose because it closely matches the volume of Siri and most iOS turn-by-turn navigation voices, so when you‚Äôre listening to a podcast while driving, navigation interruptions are less jarring. Most professionally produced podcasts are already mastered to similar volume levels, so Voice Boost 2 won‚Äôt overcompress them with aggressive processing ‚Äî it‚Äôll only apply as much correction as necessary to make them all the same volume. A brief tutorial on clipping and distortion This is about to get nerdier, but bear with me. (Yes, nerdier than ITU broadcast-loudness standards.) Given a loudness measurement for the incoming audio, quieter podcasts need to be amplified to reach the target. But perceived loudness isn‚Äôt the peak of the incoming audio stream ‚Äî it‚Äôs more of an average. Quiet-sounding audio can still have brief moments of loud peaks. When increasing the volume of digital audio, the biggest challenge is not ‚Äúclipping‚Äù during the peaks ‚Äî not having any part of the signal pass above the volume ceiling of 0 dB. (It‚Äôs a negative scale. This is also why the LUFS value above, which is closely related to the decibel scale used here, is negative.) Here‚Äôs the highest the signal should go, showing the individual audio samples (green dots) that can be processed by a podcast app before the DAC transforms them into audio (smooth green line): It‚Äôll sound right as long as the audio doesn‚Äôt cross above that top line (0 dB). Increase the volume even slightly too far, and some of the samples just slam into it and stay there, losing the tops of their smooth curves: And that sounds terrible. But I can‚Äôt just cap all the samples right below the limit and call it a day ‚Äî that‚Äôs called a brickwall limiter ‚Äî because then the shape of the audio line will actually represent different frequencies, telling the DAC to add noise that wasn‚Äôt really there. Here, the bottom of each image shows the frequency breakdown: The unclipped signal (left) shows only its original frequency of about 2100 Hz, but a basic brickwall limiter (right) results in the unwanted introduction of a bunch of extra frequencies. That‚Äôs distortion. (If this is interesting to you, learn more about audio sampling theory here.) Lookahead limiter Avoiding audible distortion requires a lookahead limiter, which looks‚Ä¶ ahead (üòé) at the audio coming down the pipeline, and smoothly ramps the volume amplification down as a loud peak is approaching, then back up again afterward, just enough to avoid clipping and audible distortion, but so quickly that you don‚Äôt notice.4 After Voice Boost 2‚Äôs complete 32-bit audio processing pipeline, the last stage is a lookahead limiter, configured such that it can‚Äôt clip, no matter what audio comes through. This gives vast flexibility in volume processing without sacrificing quality. Voice Boost 2 also incorporates a dynamics compressor, but over time, I‚Äôve kept reducing its strength as I‚Äôve found it less necessary. Proper LUFS processing with a great lookahead limiter provides excellent volume normalization with almost no compression needed afterward. True-peak detection There‚Äôs one more way to introduce clipping that needs to be guarded against. Digital audio is represented by samples that represent a point in time (green dots, again) on a sound wave (green line). But the sampled points don‚Äôt always land at the exact peaks of those waves: The most common way to measure the peak of a waveform is to find the greatest absolute sample value. By this method, the top waveform peaks here would measure about ‚Äì6 dB and ‚Äì1.5 dB, respectively. But the actual peak amplitudes of these waves is ‚Äì1 dB! A simple limiter could still output clipped audio because it‚Äôs not seeing the true peaks. Voice Boost 2‚Äôs limiter performs true-peak detection, rather than simply measuring sample peaks, to avoid this type of clipping and further reduce distortion. Mastering-quality processing for everyone Voice Boost 2 is a mastering-quality audio-processing pipeline that applies broadcast-standard loudness normalization, light compression and EQ, and a true-peak lookahead limiter to your podcasts, in real time, without sacrificing quality or battery life. And it runs at less than 1% CPU usage on an iPhone¬†SE.5 I intend to expose some of its customizability to customers in future updates, but I wanted to develop and ship the best default settings first to keep the app simple and usable to everyone. Now that it‚Äôs available to everyone, I may still subtly tweak the defaults in response to feedback. But as I‚Äôve refined the settings during the beta period to be more universal, less customization has been necessary.6 Having achieved its goals of being more consistent and less aggressive, Voice Boost 2 is intentionally transparent. It‚Äôs not promoted more in the app or even labeled ‚ÄúVoice Boost 2‚Äù. It‚Äôs still Voice Boost ‚Äî just better now. If I did my job well, you‚Äôll hardly notice it at all. You‚Äôll have no idea that your podcasts are being remastered in your pocket. But I‚Äôll know. And the handful of you who really care will know. And that‚Äôs enough for me. Voice Boost 2 is in today‚Äôs update (2020.1), along with these new features: AirPlay 2: Overcast can now play to HomePods and other AirPlay 2 devices much more responsively, with full-blown Smart Speed and Voice Boost, on iOS 13.1 and above.7 Skip intros/outros: There‚Äôs a new per-podcast setting to skip a given number of seconds from the start and/or end of its episodes. Clip-sharing from private feeds. In retrospect, this restriction was unnecessary, so I lifted it. Restored iOS 12 compatibility. Going 13-only so soon was a mistake. Hear why on Under The Radar 181 and 183. As usual, all of this is free for everyone in Overcast. Those awesome Trey Anastasio acoustic shows are pretty quiet.¬†‚Ü©Ô∏é Apple doesn‚Äôt make all of their audio APIs available on all platforms: some are Mac-only and never came to iOS, and watchOS has an even smaller subset than iOS. The more I can accomplish in my own code, the less I depend on Apple‚Äôs choices for which APIs they make available to developers.¬†‚Ü©Ô∏é It‚Äôs just a command-line tool for now. You don‚Äôt want it. (But if you do‚Ä¶ someday, maybe.)¬†‚Ü©Ô∏é This all happens in milliseconds.¬†‚Ü©Ô∏é At 1X, with Smart Speed enabled. Smart Speed was actually entirely rewritten as part of Voice Boost 2, but it‚Äôs less interesting. It performs the same job as before, but much more efficiently, and taking advantage of the measured loudness when Voice Boost is also enabled.¬†‚Ü©Ô∏é For instance, I also built a de-esser into Voice Boost 2, but it slowly became unnecessary as I improved the other processing, so it‚Äôs not currently enabled.¬†‚Ü©Ô∏é Smart Speed is a big deal here, I think ‚Äî I‚Äôm not aware of any other podcast apps with silence-skipping over AirPlay 2. (Or LUFS normalization, or true-peak lookahead limiters.)¬†‚Ü©Ô∏é",
  "author": "",
  "published": "Fri, 31 Jan 2020 13:46:32 EST",
  "source": "https://marco.org/rss",
  "categories": null,
  "byline": "Marco Arment",
  "length": 9671,
  "excerpt": "January 31, 2020 ‚àûhttps://marco.org/2020/01/31/voiceboost2",
  "siteName": "",
  "favicon": "https://marco.org/apple-touch-icon.png",
  "text": "Introducing Voice Boost 2: Remaster your podcasts January 31, 2020 ‚àûhttps://marco.org/2020/01/31/voiceboost2 The latest update to Overcast includes a feature that I‚Äôm especially proud of that took over a year to build. Voice Boost 2 is an all-new audio engine that includes professional-grade, mastering-quality loudness normalization. When I first introduced Overcast in 2014, Voice Boost was one of its headlining features: Voice Boost is a combination of dynamic compression and equalization that can make many shows more listenable and normalize volume across all shows. This makes amateur-produced podcasts (including many of my favorites) more listenable in loud environments, like cars, where you‚Äôd otherwise need to crank the volume so loudly to hear the quiet parts that you‚Äôd blow your ears out when the loudest person spoke. Voice Boost 2 achieves the same goal as the original Voice Boost, but with dramatically more sophisticated methods, leading to more consistent results and much better sound quality. Goals When I wrote the original Voice Boost with only a rudimentary understanding of audio processing, it was a single configuration of Apple‚Äôs AudioUnits that applied a fixed set of parameters to all podcasts, regardless of their audio characteristics. It was an effective but blunt tool, relying on aggressive level compression and a strong EQ to make the compression less noticeable. Since then, I‚Äôve edited over 500 podcasts, learned a lot more about how to master them properly, and developed a much better understanding of audio signal processing. I set out to develop a better, smarter, and more refined Voice Boost that took advantage of everything I‚Äôd learned, with these audio goals: The effect should be much more subtle: mostly just consistent volume, plus slightly smoother tone. It should analyze the input audio and apply just enough processing to achieve a consistent volume level, modifying already-good audio as little as possible. It should sound good, and consistent, regardless of the volume dynamics of its input. Quality should be so good that I can even play high-quality music through it1 and not notice any artifacts. And these technical goals: Like Smart Speed and the original Voice Boost, it had to work as a streaming process, easily toggled on and off at will, without needing to scan the entire file first or look very far ahead. The code had to be pure C, with highly optimized and vectorized code, so it wouldn‚Äôt be a major power drain on older phones and could potentially run on much lower-power devices as well. I had to write every component from scratch, without using AudioUnits, because I wanted to understand and control everything, ensure the highest performance and sound quality, and avoid Apple‚Äôs platform-specific API limits.2 It had to be modular and easily customizable, like a channel strip in an audio editor, so I could adjust the processing during development and testing, offer user customization down the road, and use the same engine to build myself a modular podcast-preproduction tool to save time in my weekly workflow (which I‚Äôve been using for over a year).3 Live LUFS normalization Since Voice Boost is mostly about high-quality volume analysis and loudness normalization, I went straight to the top, implementing the ITU BS.1770‚Äì4 standard that gives us the LUFS measurement seen in high-end audio editors. Overcast now measures and adjusts podcast levels using this broadcast-standard perceptual loudness algorithm, at full quality, with no preprocessing. Voice Boost 2 normalizes all podcasts to ‚Äì14¬†LUFS ‚Äî a level I chose because it closely matches the volume of Siri and most iOS turn-by-turn navigation voices, so when you‚Äôre listening to a podcast while driving, navigation interruptions are less jarring. Most professionally produced podcasts are already mastered to similar volume levels, so Voice Boost 2 won‚Äôt overcompress them with aggressive processing ‚Äî it‚Äôll only apply as much correction as necessary to make them all the same volume. A brief tutorial on clipping and distortion This is about to get nerdier, but bear with me. (Yes, nerdier than ITU broadcast-loudness standards.) Given a loudness measurement for the incoming audio, quieter podcasts need to be amplified to reach the target. But perceived loudness isn‚Äôt the peak of the incoming audio stream ‚Äî it‚Äôs more of an average. Quiet-sounding audio can still have brief moments of loud peaks. When increasing the volume of digital audio, the biggest challenge is not ‚Äúclipping‚Äù during the peaks ‚Äî not having any part of the signal pass above the volume ceiling of 0 dB. (It‚Äôs a negative scale. This is also why the LUFS value above, which is closely related to the decibel scale used here, is negative.) Here‚Äôs the highest the signal should go, showing the individual audio samples (green dots) that can be processed by a podcast app before the DAC transforms them into audio (smooth green line): It‚Äôll sound right as long as the audio doesn‚Äôt cross above that top line (0 dB). Increase the volume even slightly too far, and some of the samples just slam into it and stay there, losing the tops of their smooth curves: And that sounds terrible. But I can‚Äôt just cap all the samples right below the limit and call it a day ‚Äî that‚Äôs called a brickwall limiter ‚Äî because then the shape of the audio line will actually represent different frequencies, telling the DAC to add noise that wasn‚Äôt really there. Here, the bottom of each image shows the frequency breakdown: The unclipped signal (left) shows only its original frequency of about 2100 Hz, but a basic brickwall limiter (right) results in the unwanted introduction of a bunch of extra frequencies. That‚Äôs distortion. (If this is interesting to you, learn more about audio sampling theory here.) Lookahead limiter Avoiding audible distortion requires a lookahead limiter, which looks‚Ä¶ ahead (üòé) at the audio coming down the pipeline, and smoothly ramps the volume amplification down as a loud peak is approaching, then back up again afterward, just enough to avoid clipping and audible distortion, but so quickly that you don‚Äôt notice.4 After Voice Boost 2‚Äôs complete 32-bit audio processing pipeline, the last stage is a lookahead limiter, configured such that it can‚Äôt clip, no matter what audio comes through. This gives vast flexibility in volume processing without sacrificing quality. Voice Boost 2 also incorporates a dynamics compressor, but over time, I‚Äôve kept reducing its strength as I‚Äôve found it less necessary. Proper LUFS processing with a great lookahead limiter provides excellent volume normalization with almost no compression needed afterward. True-peak detection There‚Äôs one more way to introduce clipping that needs to be guarded against. Digital audio is represented by samples that represent a point in time (green dots, again) on a sound wave (green line). But the sampled points don‚Äôt always land at the exact peaks of those waves: The most common way to measure the peak of a waveform is to find the greatest absolute sample value. By this method, the top waveform peaks here would measure about ‚Äì6 dB and ‚Äì1.5 dB, respectively. But the actual peak amplitudes of these waves is ‚Äì1 dB! A simple limiter could still output clipped audio because it‚Äôs not seeing the true peaks. Voice Boost 2‚Äôs limiter performs true-peak detection, rather than simply measuring sample peaks, to avoid this type of clipping and further reduce distortion. Mastering-quality processing for everyone Voice Boost 2 is a mastering-quality audio-processing pipeline that applies broadcast-standard loudness normalization, light compression and EQ, and a true-peak lookahead limiter to your podcasts, in real time, without sacrificing quality or battery life. And it runs at less than 1% CPU usage on an iPhone¬†SE.5 I intend to expose some of its customizability to customers in future updates, but I wanted to develop and ship the best default settings first to keep the app simple and usable to everyone. Now that it‚Äôs available to everyone, I may still subtly tweak the defaults in response to feedback. But as I‚Äôve refined the settings during the beta period to be more universal, less customization has been necessary.6 Having achieved its goals of being more consistent and less aggressive, Voice Boost 2 is intentionally transparent. It‚Äôs not promoted more in the app or even labeled ‚ÄúVoice Boost 2‚Äù. It‚Äôs still Voice Boost ‚Äî just better now. If I did my job well, you‚Äôll hardly notice it at all. You‚Äôll have no idea that your podcasts are being remastered in your pocket. But I‚Äôll know. And the handful of you who really care will know. And that‚Äôs enough for me. Voice Boost 2 is in today‚Äôs update (2020.1), along with these new features: AirPlay 2: Overcast can now play to HomePods and other AirPlay 2 devices much more responsively, with full-blown Smart Speed and Voice Boost, on iOS 13.1 and above.7 Skip intros/outros: There‚Äôs a new per-podcast setting to skip a given number of seconds from the start and/or end of its episodes. Clip-sharing from private feeds. In retrospect, this restriction was unnecessary, so I lifted it. Restored iOS 12 compatibility. Going 13-only so soon was a mistake. Hear why on Under The Radar 181 and 183. As usual, all of this is free for everyone in Overcast.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\n                        \u003cheader\u003e\n                                                            \u003ch2\u003e\n                                    \u003ca href=\"https://marco.org/2020/01/31/voiceboost2\"\u003eIntroducing Voice Boost 2: Remaster your podcasts\u003c/a\u003e\n                                                                    \u003c/h2\u003e\n                            \n                            \u003cp\u003e\n                                \u003ctime datetime=\"2020-01-31T13:46:32-05:00\" pubdate=\"pubdate\"\u003eJanuary 31, 2020\u003c/time\u003e\n                                \u003ca title=\"Permalink\" href=\"https://marco.org/2020/01/31/voiceboost2\"\u003e\u003cspan\u003e‚àû\u003c/span\u003e\u003cspan\u003ehttps://marco.org/2020/01/31/voiceboost2\u003c/span\u003e\u003c/a\u003e\n                            \u003c/p\u003e\n                        \u003c/header\u003e\n                    \n                        \u003cp\u003eThe latest update to \u003ca href=\"https://overcast.fm/\"\u003eOvercast\u003c/a\u003e includes a feature that I‚Äôm especially proud of that took over a year to build.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eVoice Boost 2\u003c/strong\u003e is an all-new audio engine that includes professional-grade, mastering-quality loudness normalization.\u003c/p\u003e\n\n\u003cp\u003eWhen I \u003ca href=\"https://marco.org/2014/07/16/overcast\"\u003efirst introduced Overcast in 2014\u003c/a\u003e, Voice Boost was one of its headlining features:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003cstrong\u003eVoice Boost\u003c/strong\u003e is a combination of dynamic compression and equalization that can make many shows more listenable and normalize volume across all shows. This makes amateur-produced podcasts (including many of my favorites) more listenable in loud environments, like cars, where you‚Äôd otherwise need to crank the volume so loudly to hear the quiet parts that you‚Äôd blow your ears out when the loudest person spoke.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eVoice Boost 2 achieves the same goal as the original Voice Boost, but with dramatically more sophisticated methods, leading to more consistent results and \u003cem\u003emuch\u003c/em\u003e better sound quality.\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003eGoals\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003eWhen I wrote the original Voice Boost with only a rudimentary understanding of audio processing, it was a single configuration of Apple‚Äôs AudioUnits that applied a fixed set of parameters to all podcasts, regardless of their audio characteristics. It was an effective but blunt tool, relying on aggressive \u003ca href=\"https://en.wikipedia.org/wiki/Dynamic_range_compression\"\u003elevel compression\u003c/a\u003e and a strong \u003ca href=\"https://en.wikipedia.org/wiki/Equalization_%28audio%29\"\u003eEQ\u003c/a\u003e to make the compression less noticeable.\u003c/p\u003e\n\n\u003cp\u003eSince then, I‚Äôve edited over 500 podcasts, learned a \u003cem\u003elot\u003c/em\u003e more about how to master them properly, and developed a much better understanding of \u003ca href=\"https://en.wikipedia.org/wiki/Audio_signal_processing\"\u003eaudio signal processing\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eI set out to develop a better, smarter, and more refined Voice Boost that took advantage of everything I‚Äôd learned, with these audio goals:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eThe effect should be much more subtle: mostly just consistent volume, plus \u003cem\u003eslightly\u003c/em\u003e smoother tone.\u003c/li\u003e\n\u003cli\u003eIt should analyze the input audio and apply \u003cem\u003ejust\u003c/em\u003e enough processing to achieve a consistent volume level, modifying already-good audio as little as possible.\u003c/li\u003e\n\u003cli\u003eIt should sound good, and consistent, regardless of the volume dynamics of its input.\u003c/li\u003e\n\u003cli\u003eQuality should be so good that I can even play high-quality \u003cem\u003emusic\u003c/em\u003e through it\u003csup id=\"fnref:pXIBPcnShtrey\"\u003e\u003ca href=\"#fn:pXIBPcnShtrey\" rel=\"footnote\"\u003e1\u003c/a\u003e\u003c/sup\u003e and not notice any artifacts.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAnd these technical goals:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eLike Smart Speed and the original Voice Boost, it had to work as a streaming process, easily toggled on and off at will, without needing to scan the entire file first or look very far ahead.\u003c/li\u003e\n\u003cli\u003eThe code had to be pure C, with highly optimized and vectorized code, so it wouldn‚Äôt be a major power drain on older phones and could potentially run on much lower-power devices as well.\u003c/li\u003e\n\u003cli\u003eI had to write every component from scratch, without using AudioUnits, because I wanted to understand and control everything, ensure the highest performance and sound quality, and avoid Apple‚Äôs platform-specific API limits.\u003csup id=\"fnref:pXIBPcnShpubapi\"\u003e\u003ca href=\"#fn:pXIBPcnShpubapi\" rel=\"footnote\"\u003e2\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003cli\u003eIt had to be modular and easily customizable, like a channel strip in an audio editor, so I could adjust the processing during development and testing, offer user customization down the road, and use the same engine to build myself a modular podcast-preproduction tool to save time in my weekly workflow (which I‚Äôve been using for over a year).\u003csup id=\"fnref:pXIBPcnShvb2tool\"\u003e\u003ca href=\"#fn:pXIBPcnShvb2tool\" rel=\"footnote\"\u003e3\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003e\u003cstrong\u003eLive LUFS normalization\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003eSince Voice Boost is mostly about high-quality volume analysis and loudness normalization, I went straight to the top, implementing \u003ca href=\"https://en.wikipedia.org/wiki/LKFS\"\u003ethe ITU BS.1770‚Äì4 standard\u003c/a\u003e that gives us the \u003cstrong\u003eLUFS\u003c/strong\u003e measurement seen in high-end audio editors.\u003c/p\u003e\n\n\u003cp\u003eOvercast now measures and adjusts podcast levels using this broadcast-standard perceptual loudness algorithm, at full quality, with no preprocessing.\u003c/p\u003e\n\n\u003cp\u003eVoice Boost 2 normalizes all podcasts to ‚Äì14¬†LUFS ‚Äî a level I chose because it closely matches the volume of Siri and most iOS turn-by-turn navigation voices, so when you‚Äôre listening to a podcast while driving, navigation interruptions are less jarring.\u003c/p\u003e\n\n\u003cp\u003eMost professionally produced podcasts are already mastered to similar volume levels, so Voice Boost 2 won‚Äôt overcompress them with aggressive processing ‚Äî it‚Äôll only apply as much correction as necessary to make them all the same volume.\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003eA brief tutorial on clipping and distortion\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003eThis is about to get nerdier, but bear with me. (Yes, nerdier than ITU broadcast-loudness standards.)\u003c/p\u003e\n\n\u003cp\u003eGiven a loudness measurement for the incoming audio, quieter podcasts need to be amplified to reach the target. But perceived loudness isn‚Äôt the peak of the incoming audio stream ‚Äî it‚Äôs more of an average. Quiet-sounding audio can still have brief moments of loud peaks.\u003c/p\u003e\n\n\u003cp\u003eWhen increasing the volume of digital audio, the biggest challenge is not ‚Äúclipping‚Äù during the peaks ‚Äî not having any part of the signal pass above the volume ceiling of 0 dB. (It‚Äôs a negative scale. This is also why the LUFS value above, which is closely related to the decibel scale used here, is negative.)\u003c/p\u003e\n\n\u003cp\u003eHere‚Äôs the highest the signal should go, showing the individual audio samples (green dots) that can be processed by a podcast app before the DAC transforms them into audio (smooth green line):\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://marco.org/media/2020/01/samples-unclipped.png\"\u003e\u003cimg src=\"https://marco.org/media/2020/01/samples-unclipped.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eIt‚Äôll sound right as long as the audio doesn‚Äôt cross above that top line (0 dB). Increase the volume even slightly too far, and some of the samples just slam into it and stay there, losing the tops of their smooth curves:\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://marco.org/media/2020/01/samples-clipped.png\"\u003e\u003cimg src=\"https://marco.org/media/2020/01/samples-clipped.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eAnd that sounds \u003cstrong\u003eterrible.\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eBut I can‚Äôt just cap all the samples right below the limit and call it a day ‚Äî that‚Äôs called a brickwall limiter ‚Äî because then the shape of the audio line will actually represent different frequencies, telling the DAC to add noise that wasn‚Äôt really there.\u003c/p\u003e\n\n\u003cp\u003eHere, the bottom of each image shows the frequency breakdown:\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://marco.org/media/2020/01/samples-distortion.png\"\u003e\u003cimg src=\"https://marco.org/media/2020/01/samples-distortion.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eThe unclipped signal (left) shows only its original frequency of about 2100 Hz, but a basic brickwall limiter (right) results in the unwanted introduction of a bunch of extra frequencies.\u003c/p\u003e\n\n\u003cp\u003eThat‚Äôs distortion. (If this is interesting to you, \u003ca href=\"https://people.xiph.org/~xiphmont/demo/neil-young.html\"\u003elearn more about audio sampling theory here\u003c/a\u003e.)\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003eLookahead limiter\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003eAvoiding audible distortion requires a lookahead limiter, which looks‚Ä¶ ahead (üòé) at the audio coming down the pipeline, and smoothly ramps the volume amplification down as a loud peak is approaching, then back up again afterward, \u003cem\u003ejust\u003c/em\u003e enough to avoid clipping and audible distortion, but so quickly that you don‚Äôt notice.\u003csup id=\"fnref:pXIBPcnShms\"\u003e\u003ca href=\"#fn:pXIBPcnShms\" rel=\"footnote\"\u003e4\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\n\u003cp\u003eAfter Voice Boost 2‚Äôs complete 32-bit audio processing pipeline, the last stage is a lookahead limiter, configured such that it \u003cem\u003ecan‚Äôt\u003c/em\u003e clip, no matter what audio comes through.\u003c/p\u003e\n\n\u003cp\u003eThis gives vast flexibility in volume processing without sacrificing quality.\u003c/p\u003e\n\n\u003cp\u003eVoice Boost 2 also incorporates a dynamics compressor, but over time, I‚Äôve kept reducing its strength as I‚Äôve found it less necessary. Proper LUFS processing with a great lookahead limiter provides excellent volume normalization with almost no compression needed afterward.\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003eTrue-peak detection\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003eThere‚Äôs one more way to introduce clipping that needs to be guarded against.\u003c/p\u003e\n\n\u003cp\u003eDigital audio is represented by samples that represent a point in time (green dots, again) on a sound wave (green line). But the sampled points don‚Äôt always land at the exact peaks of those waves:\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://marco.org/media/2020/01/samples-truepeak.png\"\u003e\u003cimg src=\"https://marco.org/media/2020/01/samples-truepeak.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eThe most common way to measure the peak of a waveform is to find the greatest absolute sample value. By this method, the top waveform peaks here would measure about ‚Äì6 dB and ‚Äì1.5 dB, respectively.\u003c/p\u003e\n\n\u003cp\u003eBut the actual peak amplitudes of these waves is ‚Äì1 dB! A simple limiter could still output clipped audio because it‚Äôs not seeing the true peaks.\u003c/p\u003e\n\n\u003cp\u003eVoice Boost 2‚Äôs limiter performs true-peak detection, rather than simply measuring sample peaks, to avoid this type of clipping and further reduce distortion.\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003eMastering-quality processing for everyone\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003eVoice Boost 2 is a mastering-quality audio-processing pipeline that applies broadcast-standard loudness normalization, light compression and EQ, and a true-peak lookahead limiter to your podcasts, in real time, without sacrificing quality or battery life.\u003c/p\u003e\n\n\u003cp\u003eAnd it runs at less than 1% CPU usage on an iPhone¬†SE.\u003csup id=\"fnref:pXIBPcnShbench\"\u003e\u003ca href=\"#fn:pXIBPcnShbench\" rel=\"footnote\"\u003e5\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\n\u003cp\u003eI intend to expose some of its customizability to customers in future updates, but I wanted to develop and ship the best default settings first to keep the app simple and usable to everyone. Now that it‚Äôs available to everyone, I may still subtly tweak the defaults in response to feedback. But as I‚Äôve refined the settings during the beta period to be more universal, less customization has been necessary.\u003csup id=\"fnref:pXIBPcnShdeess\"\u003e\u003ca href=\"#fn:pXIBPcnShdeess\" rel=\"footnote\"\u003e6\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\n\u003cp\u003eHaving achieved its goals of being more consistent and less aggressive, Voice Boost 2 is intentionally transparent. It‚Äôs not promoted more in the app or even labeled ‚ÄúVoice Boost 2‚Äù. It‚Äôs still Voice Boost ‚Äî just better now.\u003c/p\u003e\n\n\u003cp\u003eIf I did my job well, you‚Äôll hardly notice it at all. You‚Äôll have no idea that your podcasts are being remastered in your pocket.\u003c/p\u003e\n\n\u003cp\u003eBut I‚Äôll know. And the handful of you who \u003cem\u003ereally\u003c/em\u003e care will know. And that‚Äôs enough for me.\u003c/p\u003e\n\n\u003cp\u003eVoice Boost 2 is in today‚Äôs update (2020.1), along with these new features:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAirPlay 2:\u003c/strong\u003e Overcast can now play to HomePods and other AirPlay 2 devices much more responsively, with full-blown Smart Speed and Voice Boost, on iOS 13.1 and above.\u003csup id=\"fnref:pXIBPcnShap2\"\u003e\u003ca href=\"#fn:pXIBPcnShap2\" rel=\"footnote\"\u003e7\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSkip intros/outros:\u003c/strong\u003e There‚Äôs a new per-podcast setting to skip a given number of seconds from the start and/or end of its episodes.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eClip-sharing from private feeds.\u003c/strong\u003e In retrospect, this restriction was unnecessary, so I lifted it.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRestored iOS 12 compatibility.\u003c/strong\u003e Going 13-only so soon was a mistake. Hear why on \u003ca href=\"https://overcast.fm/+FgnaXsFSI\"\u003eUnder The Radar 181\u003c/a\u003e and \u003ca href=\"https://overcast.fm/+FgnZdP74w\"\u003e183\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAs usual, all of this is free for everyone in \u003ca href=\"https://overcast.fm/\"\u003eOvercast\u003c/a\u003e.\u003c/p\u003e\n\n\n                    \u003c/article\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": null,
  "modifiedTime": null
}
