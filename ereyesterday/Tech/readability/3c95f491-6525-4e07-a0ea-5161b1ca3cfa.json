{
  "id": "3c95f491-6525-4e07-a0ea-5161b1ca3cfa",
  "title": "A toy RTOS inside Super Mario Bros. using emulator save states",
  "link": "https://prettygoodblog.com/p/what-threads-are-part-2",
  "description": "Comments",
  "author": "",
  "published": "Wed, 28 May 2025 20:15:43 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Joshua",
  "length": 16846,
  "excerpt": "They're Mario Bros. for the NES, apparently.",
  "siteName": "Pretty Good Blog",
  "favicon": "https://substackcdn.com/icons/substack/apple-touch-icon.png",
  "text": "This is another post about programming, which I almost never write about.Click here to jump straight to trying this thing out for yourself.In my previous post on Threads, I made an offhand comparison1:Threads2 are just emulator3 save states4, coupled with a condition upon which they will be resumed.At the time, I thought this a pretty okay analogy — but I couldn’t stop thinking about it. I’ve been turning it around in my mind for a while. I think it has serious untapped potential as a pedagogical tool. So I added multithreading to Super Mario Bros. for the NES.No buried ledes here. I should explain myself. What you just watched happens to be a multithreaded NES emulation, with Super Mario Bros. as the threads.There are three “threads” running, each a distinct instance of the game. Every so often, the emulator switches “threads”, swapping to a different instance of the game. Each “thread” is assigned a different color palette, which we apply when we resume said thread. This is why the colors are constantly changing around in the video.When World 1-1 starts, the “multithreading” begins. Specifically, my script creates three save states, each representing the current state of the game5. Then I create three threads6, and give them their respective save state to hold on to.Then I start the thread scheduler.The thread scheduler’s job is simple:Every 160 frames, switch to a new threadThe next thread ideally, in a rotating fashion (1, 2, 3, 1, 2, 3, 1, …)Skip over threads which are KILLED, BLOCKED (unless they can be unblocked), or SLEEPING (unless it’s time to wake them)To switch to a new thread:First, update the current thread’s save state with the current game stateThen, load in the new thread’s save stateFinally, update the game color palette to reflect which thread we’re onThis covers what you see for the first bit of the video: each thread starts at the same time (the loading screen for World 1-1), with different “games” being swapped in every so often. Essentially, three different games of Mario Bros. are being played “at the same time”, but only one is actually active at any given time.This image shows the full World 1-1 map, with color-coded areas indicating various features explained below. I recommend clicking to expand this image.Time slicing is cool — we’re running three “concurrent” games of Mario! — but that’s far from the only threading concept demonstrated here.I’ve set up the game world in such a way that certain areas or features activate synchronization primitives (such as a mutex); you can physically interact with threading boundaries. I describe the synchronization primitives I’ve set up below, but the net effect is:If a Mario is standing on the three blocks at the start of the level, no other Mario’s game will run until he leaves (Disabled Interrupts)Only one Mario can be inside the Pipe Sub-level at a time (Mutex)If a Mario enters while another Mario is inside, his game will not resume until the other Mario leavesOnce a Mario touches the flagpole, his game pauses until all the other Marios have touched their flagpoles (Condition Variables)The red shaded area on the map denotes a section of the world where interrupts are disabled, and therefore, the thread scheduler cannot run.Whenever a Mario enters the red shaded area, his thread won’t lose control until he leaves the area, regardless of what other Marios are doing.The yellow shaded area (difficult to discern — it’s the fourth pipe from the left; the one you can go down) demonstrates a mutex: an area of the game world where only one Mario may exist at a time.When a Mario goes down the pipe, he tries to acquire the pipeMutex. If nothing else owns that mutex (i.e., no other thread is currently in the pipe sub-level), then he immediately gains ownership of the mutex and proceeds without issue.However, if another Mario owns the mutex (is presently in the pipe sub-level), then the Mario which is presently entering the pipe will be blocked until the mutex is released (the other Mario leaves the pipe sub-level).Marios outside of the pipe sub-level are not blocked, and are still allowed to run.The green shaded area (the flagpole at the end of the level) demonstrates a condition variable: when a Mario touches the flagpole, he increments numMariosTouchedFlagpole — a “condition variable” — by 1, and then blocks until that same condition variable is equal to the number of threads. In other words, he waits until all the other Marios have touched the flagpole before continuing.Whenever a Mario kills an enemy, his thread goes to sleep for 300 frames.It’s hard to tell in the video, but a thread that goes to sleep doesn’t necessarily come back on time; it has to wait until the thread scheduler next decides to run it.This actually is threads. We have taken a machine — cursed with an inability7 to do more than one thing at a time — and added concurrency to it, without modifying the core engine (or CPU) to have any notion of “threads”.We added threads to this emulator in the same way that we add threads to normal CPUs: we take clever advantage of a mechanism which allows us to A) save the current state of the machine and B) load it back up in the future if and when we choose. All without the emulator itself ever being designed for, or having any notion of, “threads”.And you can touch it. You interact with these bona fide threads not through a debugger, not by instantiating a Mutex, but by walking into a critical section and observing how the threading behavior changes in real time.It’s sick!Has anyone seen it? Do you know where it lives? What time does it tend to come home?I want more people to understand the things that “nobody understands.” Not because we will imminently need them; but because there is certain joy and immense value in conquering these things anyways.If you’re getting into software today, you are liable to be thrown right into the middle of the abstraction wilderness. One can spend decades in these lands: learning new frameworks; adopting new stacks; exploring endlessly in all directions but into the mysterious down. No need to go down there. Nobody knows what’s beyond that barrier.But the concrete has not cured8. We do not have the luxury of treating these layers as bedrock: don’t even bother trying to get in. Just trust that it’ll hold your house up. Oh, we’ve built the house — this trillion-dollar industry of a house — and sure, it’s standing. But when the foundation fails, what use is the house? When the foundation must evolve, how will we contribute to that process, knowing only how to build atop it? How could we accurately judge a new foundation, knowing nothing about how the old one was built?Threads are not very complicated, and I don’t think I’m particularly smart for knowing how they work. Simple circumstance forced me to work with them at a deep level, which one cannot do without gaining an understanding of the thing. Anyone who had to work with them in the same way I did would likely have the same level of understanding. Conversely, there are countless things I’ve never worked with — and thus do not understand — which I certainly should know more about.What is complicated is how to make threads work extremely efficiently and reliably. Switching contexts? Not too hard. Optimizing the hell out of them with data structures and algorithms? My intuition usually fails me on this front — I am no CS guru. But the core innovation of threads requires none of this.That’s the case for almost everything of this sort: these are all relatively simple ideas! Taking the time to understand them only requires understanding structure and logical flow; one does not need to dive into complex math or advanced algorithms in order to grasp the root idea. And once it’s been grasped, we can add it to our foundational understanding; a new bone in the ol’ conceptual skeleton; supercharging work way up the stack in ways we cannot predict.Learning frontend frameworks is useful. One can produce billions of dollars from such work! But nothing will give you an understanding of frontend frameworks as a concept like creating your own framework9. Once you’ve done that, the way you perceive and grok any other framework will be permanently enhanced.Before I built this, I would have struggled to talk about how to implement a mutex — I’ve never done it before! My implementation is certainly terrible; a naive, simplistic approach which works only because the stakes are so low. But that’s fine: I can see the next steps. The ways in which it could improve. Through working on this — even through identifying problems I want to avoid solving — my brain is building pathways and forging connections between concepts without my knowledge. I don’t know how the Linux kernel implements mutexes, or the best way to implement them in a battle-hardened system; it’d be silly to say that building this toy would grant me such expertise. But I now know how to evaluate what I’m looking at if I have to. “Damn, they built it way better than I did” is a far more instructive, useful experience than “damn, they built a thing I have no understanding of!”At first, I was going to find an open-source NES emulator and add all this directly into its source code. This was going to be quite cool and impressive of me. Then I found FCEUX, which exposes a Lua plugin system through which I can do everything I need. Jackpot.I do still want the credit for the original plan, though.A few hundred lines of Lua later, and we have a legitimate thread scheduler, with support for mutexes, condition variables, interrupt masking, sleep, and more. I highly encourage you to read the code for yourself, but I’ll walk through some of it here.Before we build a thread scheduler, we need to be comfortable in our environment. We’re writing a Lua plugin for an NES emulator… what can we do?Luckily, the documentation is quite helpful — already, we can see that we have the tools we need to:Create a save state (savestate.create() and savestate.save())This is how we’ll “save” a thread so we can resume it laterLoad a save state (savestate.load())This is how we’ll resume a thread we previously put to sleepRead memory from the game’s RAM (memory.readbyte())This is how we’ll figure out what level the player is on, their coordinates within the level, etc.We’ll use this helpful document to figure out where all the juicy bits live in the game’s RAMDraw text on the screen (gui.drawtext())This is how we’ll obscure the majority of the screen with irrelevant informationControl when frames get executed on the emulator (emu.frameadvance())Our lua code needs to call this function whenever a frame of the game should runThis lets us do anything we want in-between framesThis is everything we need!Let’s start with a basic “do-nothing” script, which is functionally identical to no script at all:while true do emu.advanceframe() endWe want to only kick in and start multithreading once the player has started the game.I don’t have the best solution here, but I decided to hook into the GAME_MODE (0x0770) and PRE_LEVEL_SCREEN_SHOWING (0x0757) memory addresses. When each has the value of 1, we know that the game is starting and is showing the “pre-level screen”, which is a good place to start in my opinion.This is what that looks like:function initiate() emu.frameadvance() if not emu.emulating() then return end local gameMode = memory.readbyte(0x0770) local preLevelScreen = memory.readbyte(0x0757) if gameMode ~= 1 or preLevelScreen ~= 1 then return end initiated = true end function loop() emu.frameadvance() end while true do if not initiated then initiate() else loop() end endThis works, but doesn’t do anything yet.Now that we can detect when the game has begun, we can start implementing threads.Remember: threads are just snapshots of state, combined with a condition upon which they should be resumed. For now, we’ll ignore the “condition to resume” part. We’ll focus solely on the time-slicing bits.So, we’ll need:A list of threadsEach of which has:An IDA save stateA notion of the “current thread”A way to switch from the “current thread” to some other threadA timer which tracks when we should switch threadsHere’s the full implementation for just time slicing:THREAD_SWITCH_FREQUENCY = 100 NUM_THREADS = 3 local threads = {} local curThreadIndex = nil local curFrame = 0 local lastSwitchedThreads = 0 local initiated = false function shouldRunScheduler() return (curFrame - lastSwitchedThreads) \u003e= THREAD_SWITCH_FREQUENCY end function threadScheduler() local newThreadIndex = curThreadIndex + 1 if newThreadIndex \u003e NUM_THREADS then newThreadIndex = 1 end local oldThread = threads[curThreadIndex] local newThread = threads[newThreadIndex] savestate.save(oldThread.saveState) savestate.load(newThread.saveState) curThreadIndex = newThreadIndex end function initiate() emu.frameadvance() if not emu.emulating() then return end local gameMode = memory.readbyte(0x0770) local preLevelScreen = memory.readbyte(0x0757) if gameMode ~= 1 or preLevelScreen ~= 1 then return end for i = 1, NUM_THREADS do local thread = {} thread.id = i thread.state = THREAD_STATE_PREEMPTED thread.saveState = savestate.create() savestate.save(thread.saveState) table.insert(threads, thread) end initiated = true curThreadIndex = 1 threadScheduler() end function loop() emu.frameadvance() if shouldRunScheduler() then threadScheduler() lastSwitchedThreads = curFrame end end while true do curFrame = curFrame + 1 if not initiated then initiate() else loop() end endThis works! Start World 1-1, and you’ll start switching between 3 threads, ruining the gameplay experience in its entirety.I think this is a good place to stop with the implementation details. Now that you have a function which can switch threads on demand, it’s not too hard to add:Thread prioritiesSleepingLocking on resources (mutexes, semaphores, etc.)Whatever your heart desires!I encourage you to try out the full code — linked above — for yourself!First, obtain a legal copy of a Super Mario Bros. ROM for the NES. I offer no assistance on this front.Second, download FCEUX10. Click that blog link and download that unsigned executable. Do it.Third, download the Lua script and save it somewhere you can find on your computer.Fourth, read the Lua script and ensure I didn’t just trick you into downloading malware.Fifth, open FCEUX. Click File → Load Lua Script. Click Browse, then find the Lua file you saved. Hit Load and then Start.Sixth, click File → Open ROM. Find the ROM file you downloaded.Seventh, play the game. You might want to configure controls in Options → Input Config.Eighth, realize that constantly switching between three instances of Super Mario Bros. isn’t pleasant, and you had no good reason to think it would be.I haven’t actually set up a situation in which a true deadlock (A holds X, B holds Y, A tries to get Y while B tries to get X) can occur, but it would be handled (in a primitive manner) by the thread scheduler.Whenever there is no thread that can be run (as would be the case in a deadlock, or if all threads are dead, or if all threads are asleep11), the thread scheduler will halt the game and show an error message.One deadlock-ish way this can happen is if every Mario is waiting on the mutex to enter the pipe, and then the Mario inside the pipe dies. This is really a dangling mutex, but let’s call it a deadlock.(It’s hard to tell in this video, because the ‘on death’ trigger occurs before the animation even plays, but the Mario inside the pipe dies and thus leaves a dangling mutex)What if the thread scheduler runs much more often?WARNING: I think this video could legitimately induce an epileptic seizure.I don’t like it.This is not a good thread scheduler.It does not support thread priorities; idle tasks; semaphores; fairness algorithms; dynamic thread spawning and joining; tracking mutex wait lists; making me any money. It is horribly inefficient, and very annoying to play with. But I love it.I love it because I was able to build something — which I at one time presumed to be magic — in roughly 300 lines of Lua. I had never done this before! But here it is: my very own thread scheduler, in the most ridiculous of environments. Maybe this will be my DOOM thing: turning every video game into threads. Probably not.It’s one of those projects that delights at every turn. How utterly wild it was to see it working the first time! Honestly, part of me didn’t expect that it would ever work.I hope this taught you about… threads, was it?",
  "image": "https://substackcdn.com/image/fetch/w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv dir=\"auto\"\u003e\u003cp\u003e\u003cem\u003eThis is another post about programming, which I almost never write about.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e\u003ca href=\"https://prettygoodblog.com/i/164506409/how-to-try-it\" rel=\"\"\u003eClick here\u003c/a\u003e\u003cspan\u003e to jump straight to trying this thing out for yourself.\u003c/span\u003e\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eIn my \u003c/span\u003e\u003ca href=\"https://prettygoodblog.com/p/what-threads-are-and-how-to-use-them\" rel=\"\"\u003eprevious post\u003c/a\u003e\u003cspan\u003e on Threads, I made an offhand comparison\u003c/span\u003e\u003cspan\u003e\u003ca data-component-name=\"FootnoteAnchorToDOM\" id=\"footnote-anchor-1-164506409\" href=\"https://prettygoodblog.com/p/what-threads-are-part-2#footnote-1-164506409\" target=\"_self\" rel=\"\"\u003e1\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003cspan\u003eThreads\u003c/span\u003e\u003cspan\u003e\u003ca data-component-name=\"FootnoteAnchorToDOM\" id=\"footnote-anchor-2-164506409\" href=\"https://prettygoodblog.com/p/what-threads-are-part-2#footnote-2-164506409\" target=\"_self\" rel=\"\"\u003e2\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e are just emulator\u003c/span\u003e\u003cspan\u003e\u003ca data-component-name=\"FootnoteAnchorToDOM\" id=\"footnote-anchor-3-164506409\" href=\"https://prettygoodblog.com/p/what-threads-are-part-2#footnote-3-164506409\" target=\"_self\" rel=\"\"\u003e3\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e save states\u003c/span\u003e\u003cspan\u003e\u003ca data-component-name=\"FootnoteAnchorToDOM\" id=\"footnote-anchor-4-164506409\" href=\"https://prettygoodblog.com/p/what-threads-are-part-2#footnote-4-164506409\" target=\"_self\" rel=\"\"\u003e4\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e, coupled with a condition upon which they will be resumed.\u003c/span\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cspan\u003eAt the  time, I thought this a \u003c/span\u003e\u003cem\u003epretty\u003c/em\u003e\u003cspan\u003e \u003c/span\u003e\u003cem\u003eokay\u003c/em\u003e\u003cspan\u003e analogy — but I couldn’t stop thinking about it. I’ve been turning it around in my mind for a while. I think it has serious untapped potential as a pedagogical tool. \u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eSo I added multithreading to \u003c/span\u003e\u003cem\u003eSuper Mario Bros.\u003c/em\u003e\u003cspan\u003e for the NES.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eNo buried ledes here. \u003c/p\u003e\u003cp\u003eI should explain myself. \u003c/p\u003e\u003cp\u003e\u003cspan\u003eWhat you just watched happens to be a multithreaded NES emulation, with \u003c/span\u003e\u003cem\u003eSuper Mario Bros.\u003c/em\u003e\u003cspan\u003e as the threads.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThere are three “threads” running, each a distinct instance of the game. Every so often, the emulator switches “threads”, swapping to a different instance of the game. \u003c/p\u003e\u003cp\u003eEach “thread” is assigned a different color palette, which we apply when we resume said thread. This is why the colors are constantly changing around in the video.\u003c/p\u003e\u003cp\u003e\u003cspan\u003eWhen World 1-1 starts, the “multithreading” begins. Specifically, my script creates three \u003c/span\u003e\u003cem\u003esave states\u003c/em\u003e\u003cspan\u003e, each representing the current state of the game\u003c/span\u003e\u003cspan\u003e\u003ca data-component-name=\"FootnoteAnchorToDOM\" id=\"footnote-anchor-5-164506409\" href=\"https://prettygoodblog.com/p/what-threads-are-part-2#footnote-5-164506409\" target=\"_self\" rel=\"\"\u003e5\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e. Then I create three \u003c/span\u003e\u003cem\u003ethreads\u003c/em\u003e\u003cspan\u003e\u003ca data-component-name=\"FootnoteAnchorToDOM\" id=\"footnote-anchor-6-164506409\" href=\"https://prettygoodblog.com/p/what-threads-are-part-2#footnote-6-164506409\" target=\"_self\" rel=\"\"\u003e6\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e, and give them their respective save state to hold on to.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThen I start the thread scheduler.\u003c/p\u003e\u003cp\u003eThe thread scheduler’s job is simple:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003eEvery 160 frames, switch to a new thread\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003eThe next thread ideally, in a rotating fashion (1, 2, 3, 1, 2, 3, 1, …)\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eSkip over threads which are \u003c/span\u003e\u003cem\u003eKILLED\u003c/em\u003e\u003cspan\u003e, \u003c/span\u003e\u003cem\u003eBLOCKED\u003c/em\u003e\u003cspan\u003e (unless they can be unblocked), or \u003c/span\u003e\u003cem\u003eSLEEPING\u003c/em\u003e\u003cspan\u003e (unless it’s time to wake them)\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eTo switch to a new thread:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eFirst, update the \u003c/span\u003e\u003cem\u003ecurrent\u003c/em\u003e\u003cspan\u003e thread’s save state with the current game state\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eThen, load in the \u003c/span\u003e\u003cem\u003enew\u003c/em\u003e\u003cspan\u003e thread’s save state\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eFinally, update the \u003c/span\u003e\u003cem\u003egame color palette\u003c/em\u003e\u003cspan\u003e to reflect which thread we’re on\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis covers what you see for the first bit of the video: each thread starts at the same time (the loading screen for World 1-1), with different “games” being swapped in every so often. \u003c/p\u003e\u003cp\u003e\u003cspan\u003eEssentially, \u003c/span\u003e\u003cem\u003ethree different games of Mario Bros.\u003c/em\u003e\u003cspan\u003e are being played “at the same time”, but only one is actually \u003c/span\u003e\u003cem\u003eactive\u003c/em\u003e\u003cspan\u003e at any given time.\u003c/span\u003e\u003c/p\u003e\u003cdiv\u003e\u003cfigure\u003e\u003ca target=\"_blank\" href=\"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png\" data-component-name=\"Image2ToDOM\" rel=\"\"\u003e\u003cdiv\u003e\u003cpicture\u003e\u003csource type=\"image/webp\" srcset=\"https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 1456w\" sizes=\"100vw\"/\u003e\u003cimg src=\"https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png\" width=\"1456\" height=\"98\" data-attrs=\"{\u0026#34;src\u0026#34;:\u0026#34;https://substack-post-media.s3.amazonaws.com/public/images/a90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png\u0026#34;,\u0026#34;srcNoWatermark\u0026#34;:null,\u0026#34;fullscreen\u0026#34;:null,\u0026#34;imageSize\u0026#34;:null,\u0026#34;height\u0026#34;:98,\u0026#34;width\u0026#34;:1456,\u0026#34;resizeWidth\u0026#34;:null,\u0026#34;bytes\u0026#34;:25155,\u0026#34;alt\u0026#34;:null,\u0026#34;title\u0026#34;:null,\u0026#34;type\u0026#34;:\u0026#34;image/png\u0026#34;,\u0026#34;href\u0026#34;:null,\u0026#34;belowTheFold\u0026#34;:true,\u0026#34;topImage\u0026#34;:false,\u0026#34;internalRedirect\u0026#34;:\u0026#34;https://prettygoodblog.com/i/164506409?img=https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png\u0026#34;,\u0026#34;isProcessing\u0026#34;:false,\u0026#34;align\u0026#34;:null}\" alt=\"\" srcset=\"https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 1456w\" sizes=\"100vw\" loading=\"lazy\"/\u003e\u003c/picture\u003e\u003c/div\u003e\u003c/a\u003e\u003cfigcaption\u003eThis image shows the full World 1-1 map, with color-coded areas indicating various features explained below. I recommend clicking to expand this image.\u003c/figcaption\u003e\u003c/figure\u003e\u003c/div\u003e\u003cp\u003eTime slicing is cool — we’re running three “concurrent” games of Mario! — but that’s far from the only threading concept demonstrated here.\u003c/p\u003e\u003cp\u003e\u003cspan\u003eI’ve set up the game world in such a way that certain areas or features activate synchronization primitives (such as a mutex); you can \u003c/span\u003e\u003cem\u003ephysically interact with threading boundaries\u003c/em\u003e\u003cspan\u003e. \u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eI describe the synchronization primitives I’ve set up below, but the \u003c/span\u003e\u003cem\u003enet effect\u003c/em\u003e\u003cspan\u003e is:\u003c/span\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eIf a Mario is standing on the three blocks at the start of the level, no other Mario’s game will run until he leaves (\u003c/span\u003e\u003cstrong\u003eDisabled Interrupts\u003c/strong\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eOnly one Mario can be inside the Pipe Sub-level at a time (\u003c/span\u003e\u003cstrong\u003eMutex\u003c/strong\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003eIf a Mario enters while another Mario is inside, his game will not resume until the other Mario leaves\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eOnce a Mario touches the flagpole, his game pauses until all the other Marios have touched their flagpoles (\u003c/span\u003e\u003cstrong\u003eCondition Variables\u003c/strong\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cspan\u003eThe red shaded area on the map denotes a section of the world where \u003c/span\u003e\u003cem\u003einterrupts are disabled\u003c/em\u003e\u003cspan\u003e, and therefore, the thread scheduler cannot run.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eWhenever a Mario enters the red shaded area, his thread won’t lose control until he leaves the area, regardless of what other Marios are doing.\u003c/p\u003e\u003cp\u003e\u003cspan\u003eThe yellow shaded area (difficult to discern — it’s the fourth pipe from the left; the one you can go down) demonstrates a \u003c/span\u003e\u003cem\u003emutex\u003c/em\u003e\u003cspan\u003e: an area of the game world where only one Mario may exist at a time.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eWhen a Mario goes down the pipe, he tries to acquire the \u003c/span\u003e\u003cem\u003epipeMutex\u003c/em\u003e\u003cspan\u003e. If nothing else owns that mutex (i.e., no other thread is currently in the pipe sub-level), then he immediately gains ownership of the mutex and proceeds without issue.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eHowever, if another Mario owns the mutex (is presently in the pipe sub-level), then the Mario which is presently entering the pipe will be \u003c/span\u003e\u003cem\u003eblocked\u003c/em\u003e\u003cspan\u003e until the mutex is released (the other Mario leaves the pipe sub-level).\u003c/span\u003e\u003c/p\u003e\u003cp\u003eMarios outside of the pipe sub-level are not blocked, and are still allowed to run.\u003c/p\u003e\u003cp\u003e\u003cspan\u003eThe green shaded area (the flagpole at the end of the level) demonstrates a \u003c/span\u003e\u003cem\u003econdition variable\u003c/em\u003e\u003cspan\u003e: when a Mario touches the flagpole, he increments \u003c/span\u003e\u003cem\u003enumMariosTouchedFlagpole\u003c/em\u003e\u003cspan\u003e — a “condition variable” — by 1, and then blocks until that same condition variable is equal to the number of threads. In other words, he waits until all the other Marios have touched the flagpole before continuing.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eWhenever a Mario kills an enemy, his thread goes to sleep for 300 frames.\u003c/p\u003e\u003cp\u003e\u003cspan\u003eIt’s hard to tell in the video, but a thread that goes to sleep \u003c/span\u003e\u003cem\u003edoesn’t necessarily come back on time\u003c/em\u003e\u003cspan\u003e; it has to wait until the thread scheduler next \u003c/span\u003e\u003cem\u003edecides\u003c/em\u003e\u003cspan\u003e to run it.\u003c/span\u003e\u003c/p\u003e\u003cdiv\u003e\u003cfigure\u003e\u003ca target=\"_blank\" href=\"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png\" data-component-name=\"Image2ToDOM\" rel=\"\"\u003e\u003cdiv\u003e\u003cpicture\u003e\u003csource type=\"image/webp\" srcset=\"https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 1456w\" sizes=\"100vw\"/\u003e\u003cimg src=\"https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png\" width=\"521\" height=\"217.2026098901099\" data-attrs=\"{\u0026#34;src\u0026#34;:\u0026#34;https://substack-post-media.s3.amazonaws.com/public/images/f8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png\u0026#34;,\u0026#34;srcNoWatermark\u0026#34;:null,\u0026#34;fullscreen\u0026#34;:null,\u0026#34;imageSize\u0026#34;:null,\u0026#34;height\u0026#34;:607,\u0026#34;width\u0026#34;:1456,\u0026#34;resizeWidth\u0026#34;:521,\u0026#34;bytes\u0026#34;:3039457,\u0026#34;alt\u0026#34;:null,\u0026#34;title\u0026#34;:null,\u0026#34;type\u0026#34;:\u0026#34;image/png\u0026#34;,\u0026#34;href\u0026#34;:null,\u0026#34;belowTheFold\u0026#34;:true,\u0026#34;topImage\u0026#34;:false,\u0026#34;internalRedirect\u0026#34;:\u0026#34;https://prettygoodblog.com/i/164506409?img=https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png\u0026#34;,\u0026#34;isProcessing\u0026#34;:false,\u0026#34;align\u0026#34;:null}\" alt=\"\" srcset=\"https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 1456w\" sizes=\"100vw\" loading=\"lazy\"/\u003e\u003c/picture\u003e\u003c/div\u003e\u003c/a\u003e\u003c/figure\u003e\u003c/div\u003e\u003cp\u003e\u003cspan\u003eThis actually \u003c/span\u003e\u003cem\u003eis\u003c/em\u003e\u003cspan\u003e threads\u003c/span\u003e\u003cem\u003e.\u003c/em\u003e\u003cspan\u003e We have taken a machine — cursed with an inability\u003c/span\u003e\u003cspan\u003e\u003ca data-component-name=\"FootnoteAnchorToDOM\" id=\"footnote-anchor-7-164506409\" href=\"https://prettygoodblog.com/p/what-threads-are-part-2#footnote-7-164506409\" target=\"_self\" rel=\"\"\u003e7\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e to do more than one thing at a time — and added concurrency to it, without modifying the \u003c/span\u003e\u003cem\u003ecore engine\u003c/em\u003e\u003cspan\u003e (or CPU) to have any notion of “threads”.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eWe added threads to this emulator \u003c/span\u003e\u003cem\u003ein the same way\u003c/em\u003e\u003cspan\u003e that we add threads to normal CPUs: we take clever advantage of a mechanism which allows us to A) save the current state of the machine and B) load it back up in the future if and when we choose. All without the emulator \u003c/span\u003e\u003cem\u003eitself\u003c/em\u003e\u003cspan\u003e ever being designed for, or having any notion of, “threads”.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eAnd \u003c/span\u003e\u003cem\u003eyou can touch it.\u003c/em\u003e\u003cspan\u003e You interact with these bona fide threads not through a debugger, not by instantiating a Mutex, but by \u003c/span\u003e\u003cem\u003ewalking into a critical section\u003c/em\u003e\u003cspan\u003e and observing how the threading behavior changes in real time.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eIt’s sick!\u003c/p\u003e\u003ch6\u003e\u003cem\u003eHas anyone seen it? Do you know where it lives? What time does it tend to come home?\u003c/em\u003e\u003c/h6\u003e\u003cp\u003e\u003cspan\u003eI want more people to understand the things that “nobody understands.” Not because we will imminently need them; but because \u003c/span\u003e\u003cem\u003ethere is certain joy and immense value in conquering these things anyways\u003c/em\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eIf you’re getting into software today, you are liable to be thrown right into the middle of the abstraction wilderness. One can spend \u003c/span\u003e\u003cem\u003edecades\u003c/em\u003e\u003cspan\u003e in these lands: learning new frameworks; adopting new stacks; exploring endlessly in all directions but into the mysterious \u003c/span\u003e\u003cem\u003edown.\u003c/em\u003e\u003cspan\u003e No need to go down there. Nobody knows what’s beyond that barrier.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eBut the concrete has not cured\u003c/span\u003e\u003cspan\u003e\u003ca data-component-name=\"FootnoteAnchorToDOM\" id=\"footnote-anchor-8-164506409\" href=\"https://prettygoodblog.com/p/what-threads-are-part-2#footnote-8-164506409\" target=\"_self\" rel=\"\"\u003e8\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e. We do not have the luxury of treating these layers as bedrock: \u003c/span\u003e\u003cem\u003edon’t even bother trying to get in. Just trust that it’ll hold your house up\u003c/em\u003e\u003cspan\u003e. Oh, we’ve built the house — this trillion-dollar industry of a house — and sure, it’s standing. But when the foundation fails, what use is the house? When the foundation must evolve, how will we contribute to that process, knowing only how to build atop it? How could we accurately judge a new foundation, knowing nothing about how the old one was built?\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eThreads are not very complicated, and I don’t think I’m particularly smart for knowing how they work. Simple circumstance forced me to work with them at a deep level, which one cannot do without gaining an understanding of the thing. Anyone who had to work with them in the same way I did would likely have the same level of understanding. Conversely, there are countless things I’ve never worked with — and thus do not understand — which I certainly \u003c/span\u003e\u003cem\u003eshould\u003c/em\u003e\u003cspan\u003e know more about.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eWhat \u003c/span\u003e\u003cem\u003eis\u003c/em\u003e\u003cspan\u003e complicated is how to make threads work \u003c/span\u003e\u003cem\u003eextremely efficiently\u003c/em\u003e\u003cspan\u003e \u003c/span\u003e\u003cem\u003eand reliably\u003c/em\u003e\u003cspan\u003e. Switching contexts? Not too hard. Optimizing the hell out of them with data structures and algorithms? My intuition usually fails me on this front — I am no CS guru. But the core innovation of threads requires none of this.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eThat’s the case for almost everything of this sort: these are all relatively simple ideas! Taking the time to understand them only requires understanding \u003c/span\u003e\u003cem\u003estructure\u003c/em\u003e\u003cspan\u003e and \u003c/span\u003e\u003cem\u003elogical flow\u003c/em\u003e\u003cspan\u003e; one does not need to dive into complex math or advanced algorithms in order to grasp the \u003c/span\u003e\u003cstrong\u003eroot idea\u003c/strong\u003e\u003cspan\u003e. And once it’s been grasped, we can add it to our foundational understanding; a new bone in the ol’ conceptual skeleton; supercharging work \u003c/span\u003e\u003cem\u003eway up the stack\u003c/em\u003e\u003cspan\u003e in ways we cannot predict.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eLearning frontend frameworks is useful. One can produce billions of dollars from such work! But nothing will give you an understanding of \u003c/span\u003e\u003cem\u003efrontend frameworks as a concept \u003c/em\u003e\u003cspan\u003elike creating your own framework\u003c/span\u003e\u003cspan\u003e\u003ca data-component-name=\"FootnoteAnchorToDOM\" id=\"footnote-anchor-9-164506409\" href=\"https://prettygoodblog.com/p/what-threads-are-part-2#footnote-9-164506409\" target=\"_self\" rel=\"\"\u003e9\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e. Once you’ve done that, the way you perceive and grok any other framework will be permanently enhanced.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eBefore I built this, I would have struggled to talk about how to implement a mutex — I’ve never done it before! My implementation is certainly terrible; a naive, simplistic approach which works only because the stakes are so low. But that’s fine: \u003c/span\u003e\u003cem\u003eI can see the next steps\u003c/em\u003e\u003cspan\u003e. The ways in which it could improve. Through working on this — even through \u003c/span\u003e\u003cem\u003eidentifying problems I want to avoid solving\u003c/em\u003e\u003cspan\u003e — my brain is building pathways and forging connections between concepts without my knowledge. \u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eI don’t know how the Linux kernel implements mutexes, or the best way to implement them in a battle-hardened system; it’d be silly to say that building this toy would grant me such expertise. But I now know how to evaluate what I’m looking at if I have to. “\u003c/span\u003e\u003cem\u003eDamn, they built it way better than I did\u003c/em\u003e\u003cspan\u003e” is a far more instructive, useful experience than “\u003c/span\u003e\u003cem\u003edamn, they built a thing I have no understanding of!”\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eAt first, I was going to find an open-source NES emulator and add all this directly into its source code. This was going to be quite cool and impressive of me. Then I found \u003c/span\u003e\u003ca href=\"https://fceux.com/web/home.html\" rel=\"\"\u003eFCEUX\u003c/a\u003e\u003cspan\u003e, which exposes a Lua plugin system through which I can do everything I need. Jackpot.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eI do still want the credit for the original plan, though.\u003c/p\u003e\u003cp\u003e\u003cspan\u003eA\u003c/span\u003e\u003ca href=\"https://pastebin.com/raw/vrDVjqHb\" rel=\"\"\u003e few hundred lines of Lua\u003c/a\u003e\u003cspan\u003e later, and we have a legitimate thread scheduler, with support for mutexes, condition variables, interrupt masking, sleep, and more. \u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eI highly encourage you to read the code for yourself\u003c/strong\u003e\u003cspan\u003e, but I’ll walk through some of it here.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eBefore we build a thread scheduler, we need to be comfortable in our environment. We’re writing a Lua plugin for an NES emulator… what can we do?\u003c/p\u003e\u003cp\u003e\u003cspan\u003eLuckily, the \u003c/span\u003e\u003ca href=\"https://fceux.com/web/help/LuaFunctionsList.html\" rel=\"\"\u003edocumentation\u003c/a\u003e\u003cspan\u003e is quite helpful — already, we can see that we have the tools we need to:\u003c/span\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eCreate a save state (\u003c/span\u003e\u003cem\u003esavestate.create() \u003c/em\u003e\u003cspan\u003eand \u003c/span\u003e\u003cem\u003esavestate.save()\u003c/em\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cp\u003eThis is how we’ll “save” a thread so we can resume it later\u003c/p\u003e\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eLoad a save state (\u003c/span\u003e\u003cem\u003esavestate.load())\u003c/em\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cp\u003eThis is how we’ll resume a thread we previously put to sleep\u003c/p\u003e\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eRead memory from the game’s RAM (\u003c/span\u003e\u003cem\u003ememory.readbyte()\u003c/em\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cp\u003eThis is how we’ll figure out what level the player is on, their coordinates within the level, etc.\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eWe’ll use \u003c/span\u003e\u003ca href=\"https://web.archive.org/web/20250401041042/https://datacrystal.tcrf.net/wiki/Super_Mario_Bros./RAM_map\" rel=\"\"\u003ethis helpful document\u003c/a\u003e\u003cspan\u003e to figure out where all the juicy bits live in the game’s RAM\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eDraw text on the screen (\u003c/span\u003e\u003cem\u003egui.drawtext()\u003c/em\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cp\u003eThis is how we’ll obscure the majority of the screen with irrelevant information\u003c/p\u003e\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eControl when frames get executed on the emulator (\u003c/span\u003e\u003cem\u003eemu.frameadvance()\u003c/em\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cp\u003eOur lua code needs to call this function whenever a frame of the game should run\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cp\u003e\u003cspan\u003eThis lets us do anything we want \u003c/span\u003e\u003cem\u003ein-between frames\u003c/em\u003e\u003c/p\u003e\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eThis is everything we need!\u003c/p\u003e\u003cp\u003eLet’s start with a basic “do-nothing” script, which is functionally identical to no script at all:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ccode\u003ewhile true do\n    emu.advanceframe()\nend\u003c/code\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe want to only kick in and start multithreading once the player has started the game.\u003c/p\u003e\u003cp\u003e\u003cspan\u003eI don’t have the best solution here, but I decided to hook into the \u003c/span\u003e\u003cem\u003eGAME_MODE \u003c/em\u003e\u003cspan\u003e(0x0770) and \u003c/span\u003e\u003cem\u003ePRE_LEVEL_SCREEN_SHOWING\u003c/em\u003e\u003cspan\u003e (0x0757) memory addresses. When each has the value of \u003c/span\u003e\u003cem\u003e1\u003c/em\u003e\u003cspan\u003e, we know that the game is starting and is showing the “pre-level screen”, which is a good place to start in my opinion.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThis is what that looks like:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ccode\u003efunction initiate()\n    emu.frameadvance()\n\n    if not emu.emulating() then\n        return\n    end\n\n    local gameMode = memory.readbyte(0x0770)\n    local preLevelScreen = memory.readbyte(0x0757)\n\n    if gameMode ~= 1 or preLevelScreen ~= 1 then\n        return\n    end\n\n    initiated = true\nend\n\nfunction loop()\n    emu.frameadvance()\nend\n\nwhile true do\n    if not initiated then\n        initiate()\n    else\n        loop()\n    end\nend\u003c/code\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cspan\u003eThis works, but doesn’t \u003c/span\u003e\u003cem\u003edo\u003c/em\u003e\u003cspan\u003e anything yet.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eNow that we can detect when the game has begun, we can start implementing threads.\u003c/p\u003e\u003cp\u003e\u003cspan\u003eRemember: \u003c/span\u003e\u003cem\u003ethreads are just snapshots of state, combined with a condition upon which they should be resumed.\u003c/em\u003e\u003cspan\u003e \u003c/span\u003e\u003c/p\u003e\u003cp\u003eFor now, we’ll ignore the “condition to resume” part. We’ll focus solely on the time-slicing bits.\u003c/p\u003e\u003cp\u003eSo, we’ll need:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003eA list of threads\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003eEach of which has:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003eAn ID\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eA save state\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eA notion of the “current thread”\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eA way to switch from the “current thread” to some other thread\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eA timer which tracks when we should switch threads\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eHere’s the full implementation for just time slicing:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ccode\u003eTHREAD_SWITCH_FREQUENCY = 100\nNUM_THREADS = 3\n\nlocal threads = {}\nlocal curThreadIndex = nil\nlocal curFrame = 0\nlocal lastSwitchedThreads = 0\n\nlocal initiated = false\n\nfunction shouldRunScheduler()\n    return (curFrame - lastSwitchedThreads) \u0026gt;= THREAD_SWITCH_FREQUENCY\nend\n\nfunction threadScheduler()\n    local newThreadIndex = curThreadIndex + 1\n\n    if newThreadIndex \u0026gt; NUM_THREADS then\n        newThreadIndex = 1\n    end\n\n    local oldThread = threads[curThreadIndex]\n    local newThread = threads[newThreadIndex]\n\n    savestate.save(oldThread.saveState)\n    savestate.load(newThread.saveState)\n\n    curThreadIndex = newThreadIndex\nend\n\nfunction initiate()\n    emu.frameadvance()\n\n    if not emu.emulating() then\n        return\n    end\n\n    local gameMode = memory.readbyte(0x0770)\n    local preLevelScreen = memory.readbyte(0x0757)\n\n    if gameMode ~= 1 or preLevelScreen ~= 1 then\n        return\n    end\n    \n    for i = 1, NUM_THREADS do\n        local thread = {}\n        thread.id = i\n        thread.state = THREAD_STATE_PREEMPTED\n        thread.saveState = savestate.create()\n\n        savestate.save(thread.saveState)\n        table.insert(threads, thread)\n    end\n\n    initiated = true\n    curThreadIndex = 1\n    threadScheduler()\nend\n\nfunction loop()\n    emu.frameadvance()\n\n    if shouldRunScheduler() then\n        threadScheduler()\n        lastSwitchedThreads = curFrame\n    end\nend\n\nwhile true do\n    curFrame = curFrame + 1\n\n    if not initiated then\n        initiate()\n    else\n        loop()\n    end\nend\u003c/code\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis works! Start World 1-1, and you’ll start switching between 3 threads, ruining the gameplay experience in its entirety.\u003c/p\u003e\u003cp\u003eI think this is a good place to stop with the implementation details. \u003c/p\u003e\u003cp\u003eNow that you have a function which can switch threads on demand, it’s not too hard to add:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003eThread priorities\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eSleeping\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eLocking on resources (mutexes, semaphores, etc.)\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eWhatever your heart desires!\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eI encourage you to try out the full code — linked above — for yourself!\u003c/p\u003e\u003cp\u003eFirst, obtain a legal copy of a Super Mario Bros. ROM for the NES. I offer no assistance on this front.\u003c/p\u003e\u003cp\u003e\u003cspan\u003eSecond, download \u003c/span\u003e\u003ca href=\"https://fceux.com/web/home.html\" rel=\"\"\u003eFCEUX\u003c/a\u003e\u003cspan\u003e\u003ca data-component-name=\"FootnoteAnchorToDOM\" id=\"footnote-anchor-10-164506409\" href=\"https://prettygoodblog.com/p/what-threads-are-part-2#footnote-10-164506409\" target=\"_self\" rel=\"\"\u003e10\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e. Click that blog link and download that unsigned executable. Do it.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eThird, download the \u003c/span\u003e\u003ca href=\"https://pastebin.com/raw/vrDVjqHb\" rel=\"\"\u003eLua script\u003c/a\u003e\u003cspan\u003e and save it somewhere you can find on your computer.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eFourth, \u003c/span\u003e\u003cstrong\u003eread the Lua script and ensure I didn’t just trick you into downloading malware.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eFifth, open FCEUX. Click \u003c/span\u003e\u003cem\u003eFile → Load Lua Script\u003c/em\u003e\u003cspan\u003e. Click \u003c/span\u003e\u003cem\u003eBrowse\u003c/em\u003e\u003cspan\u003e, then find the Lua file you saved. Hit \u003c/span\u003e\u003cem\u003eLoad\u003c/em\u003e\u003cspan\u003e and then \u003c/span\u003e\u003cem\u003eStart\u003c/em\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eSixth, click \u003c/span\u003e\u003cem\u003eFile → Open ROM\u003c/em\u003e\u003cspan\u003e. Find the ROM file you downloaded.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eSeventh, play the game. You might want to configure controls in \u003c/span\u003e\u003cem\u003eOptions → Input Config.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eEighth, realize that constantly switching between three instances of \u003c/span\u003e\u003cem\u003eSuper Mario Bros. \u003c/em\u003e\u003cspan\u003eisn’t pleasant, and you had no good reason to think it would be.\u003c/span\u003e\u003c/p\u003e\u003cp\u003eI haven’t actually set up a situation in which a true deadlock (A holds X, B holds Y, A tries to get Y while B tries to get X) can occur, but it would be handled (in a primitive manner) by the thread scheduler.\u003c/p\u003e\u003cp\u003e\u003cspan\u003eWhenever there is no thread that \u003c/span\u003e\u003cem\u003ecan\u003c/em\u003e\u003cspan\u003e be run (as would be the case in a deadlock, or if all threads are dead, or if all threads are asleep\u003c/span\u003e\u003cspan\u003e\u003ca data-component-name=\"FootnoteAnchorToDOM\" id=\"footnote-anchor-11-164506409\" href=\"https://prettygoodblog.com/p/what-threads-are-part-2#footnote-11-164506409\" target=\"_self\" rel=\"\"\u003e11\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e), the thread scheduler will halt the game and show an error message.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003eOne deadlock-ish way this can happen is if every Mario is waiting on the mutex to enter the pipe, and then the Mario \u003c/span\u003e\u003cem\u003einside\u003c/em\u003e\u003cspan\u003e the pipe dies. This is really a dangling mutex, but let’s call it a deadlock.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e(It’s hard to tell in this video, because the ‘on death’ trigger occurs before the animation even plays, but the Mario inside the pipe dies and thus leaves a dangling mutex)\u003c/em\u003e\u003c/p\u003e\u003cp\u003eWhat if the thread scheduler runs much more often?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWARNING: I think this video could legitimately induce an epileptic seizure.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI don’t like it.\u003c/p\u003e\u003cp\u003eThis is not a good thread scheduler.\u003c/p\u003e\u003cp\u003eIt does not support thread priorities; idle tasks; semaphores; fairness algorithms; dynamic thread spawning and joining; tracking mutex wait lists; making me any money. It is horribly inefficient, and very annoying to play with. But I love it.\u003c/p\u003e\u003cp\u003eI love it because I was able to build something — which I at one time presumed to be magic — in roughly 300 lines of Lua. I had never done this before! But here it is: my very own thread scheduler, in the most ridiculous of environments. Maybe this will be my DOOM thing: turning every video game into threads. Probably not.\u003c/p\u003e\u003cp\u003eIt’s one of those projects that delights at every turn. How utterly wild it was to see it working the first time! Honestly, part of me didn’t expect that it would ever work.\u003c/p\u003e\u003cp\u003eI hope this taught you about… threads, was it?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": "2025-05-27T05:11:47Z",
  "modifiedTime": null
}
