{
  "id": "8a7400aa-9e48-4b12-af3c-220d3ba42fc4",
  "title": "Undergraduate shows that searches within hash tables can be much faster",
  "link": "https://www.quantamagazine.org/undergraduate-upends-a-40-year-old-data-science-conjecture-20250210/",
  "description": "Comments",
  "author": "",
  "published": "Mon, 10 Feb 2025 17:05:09 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Steve Nadis",
  "length": 6990,
  "excerpt": "A young computer scientist and two colleagues show that searches within data structures called hash tables can be much faster than previously deemed possible.",
  "siteName": "Quanta Magazine",
  "favicon": "https://www.quantamagazine.org/wp-content/themes/quanta2024/frontend/images/favicon.png",
  "text": "A young computer scientist and two colleagues show that searches within data structures called hash tables can be much faster than previously deemed possible. Introduction Sometime in the fall of 2021, Andrew Krapivin, an undergraduate at Rutgers University, encountered a paper that would change his life. At the time, Krapivin didn’t give it much thought. But two years later, when he finally set aside time to go through the paper (“just for fun,” as he put it), his efforts would lead to a rethinking of a widely used tool in computer science. The paper’s title, “Tiny Pointers,” referred to arrowlike entities that can direct you to a piece of information, or element, in a computer’s memory. Krapivin soon came up with a potential way to further miniaturize the pointers so they consumed less memory. However, to achieve that, he needed a better way of organizing the data that the pointers would point to. He turned to a common approach for storing data known as a hash table. But in the midst of his tinkering, Krapivin realized that he had invented a new kind of hash table, one that worked faster than expected — taking less time and fewer steps to find specific elements. Martín Farach-Colton, a co-author of the “Tiny Pointers” paper and Krapivin’s former professor at Rutgers, was initially skeptical of Krapivin’s new design. Hash tables are among the most thoroughly studied data structures in all of computer science; the advance sounded too good to be true.  But just to be sure, he asked a frequent collaborator (and a “Tiny Pointers” co-author), William Kuszmaul of Carnegie Mellon University, to check out his student’s invention. Kuszmaul had a different reaction. “You didn’t just come up with a cool hash table,” he remembers telling Krapivin. “You’ve actually completely wiped out a 40-year-old conjecture!” Together, Krapivin (now a graduate student at the University of Cambridge), Farach-Colton (now at New York University) and Kuszmaul demonstrated in a January 2025 paper that this new hash table can indeed find elements faster than was considered possible. ln so doing, they had disproved a conjecture long held to be true. “It’s an important paper,” said Alex Conway of Cornell Tech in New York City. “Hash tables are among the oldest data structures we have. And they’re still one of the most efficient ways to store data.” Yet open questions remain about how they work, he said. “This paper answers a couple of them in surprising ways.” Hash tables have become ubiquitous in computing, partly because of their simplicity and ease of use. They’re designed to allow users to do exactly three things: “query” (search for) an element, delete an element, or insert one into an empty slot. The first hash tables date back to the early 1950s, and computer scientists have studied and used them ever since. Among other things, researchers wanted to figure out the speed limits for some of these operations. How fast, for example, could a new search or insertion possibly be? The answer generally depends on the amount of time it takes to find an empty spot in a hash table. This, in turn, typically depends on how full the hash table is. Fullness can be described in terms of an overall percentage — this table is 50% full, that one’s 90% — but researchers often deal with much fuller tables. So instead, they may use a whole number, denoted by x, to specify how close the hash table is to 100% full. If x is 100, then the table is 99% full. If x is 1,000, the table is 99.9% full. This measure of fullness offers a convenient way to evaluate how long it should take to perform actions like queries or insertions.  Researchers have long known that for certain common hash tables, the expected time required to make the worst possible insertion — putting an item into, say, the last remaining open spot — is proportional to x. “If your hash table is 99% full,” Kuszmaul said, “it makes sense that you would have to look at around 100 different positions to find a free slot.” In a 1985 paper, the computer scientist Andrew Yao, who would go on to win the A.M. Turing Award, asserted that among hash tables with a specific set of properties, the best way to find an individual element or an empty spot is to just go through potential spots randomly — an approach known as uniform probing. He also stated that, in the worst-case scenario, where you’re searching for the last remaining open spot, you can never do better than x. for 40 years, most computer scientists assumed that Yao’s conjecture was true. Krapivin was not held back by the conventional wisdom for the simple reason that he was unaware of it. “I did this without knowing about Yao’s conjecture,”  he said. His explorations with tiny pointers led to a new kind of hash table — one that did not rely on uniform probing. And for this new hash table, the time required for worst-case queries and insertions is proportional to (log x)2 — far faster than x. This result directly contradicted Yao’s conjecture. Farach-Colton and Kuszmaul helped Krapivin show that (log x)2 is the optimal, unbeatable bound for the popular class of hash tables Yao had written about. “This result is beautiful in that it addresses and solves such a classic problem,” said Guy Blelloch of Carnegie Mellon. “It’s not just that they disproved [Yao’s conjecture], they also found the best possible answer to his question,” said Sepehr Assadi of the University of Waterloo.  “We could have gone another 40 years before we knew the right answer.” In addition to refuting Yao’s conjecture, the new paper also contains what many consider an even more astonishing result. It pertains to a related, though slightly different, situation: In 1985, Yao looked not only at the worst-case times for queries, but also at the average time taken across all possible queries. He proved that hash tables with certain properties — including those that are labeled “greedy,” which means that new elements must be placed in the first available spot — could never achieve an average time better than log x. Farach-Colton, Krapivin and Kuszmaul wanted to see if that same limit also applied to non-greedy hash tables. They showed that it did not by providing a counterexample, a non-greedy hash table with an average query time that’s much, much better than log x. In fact, it doesn’t depend on x at all. “You get a number,” Farach-Colton said, “something that is just a constant and doesn’t depend on how full the hash table is.” The fact that you can achieve a constant average query time, regardless of the hash table’s fullness, was wholly unexpected — even to the authors themselves. The team’s results may not lead to any immediate applications, but that’s not all that matters, Conway said. “It’s important to understand these kinds of data structures better. You don’t know when a result like this will unlock something that lets you do better in practice.”",
  "image": "https://www.quantamagazine.org/wp-content/uploads/2025/02/Hash-Tables-Redux_cr_Nash-Weerasekera-Social.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n        \u003cp\u003e\n            A young computer scientist and two colleagues show that searches within data structures called hash tables can be much faster than previously deemed possible.        \u003c/p\u003e\n        \n    \u003c/div\u003e\u003cdiv\u003e\n            \u003ch2\u003eIntroduction\u003c/h2\u003e\n            \u003cdiv data-role=\"selectable\"\u003e\n    \u003cp\u003eSometime in the fall of 2021, Andrew Krapivin, an undergraduate at Rutgers University, encountered a paper that would change his life. At the time, Krapivin didn’t give it much thought. But two years later, when he finally set aside time to go through the paper (“just for fun,” as he put it), his efforts would lead to a rethinking of a widely used tool in computer science.\u003c/p\u003e\n\u003cp\u003eThe paper’s title, “\u003ca href=\"https://arxiv.org/abs/2111.12800\"\u003eTiny Pointers\u003c/a\u003e,” referred to arrowlike entities that can direct you to a piece of information, or element, in a computer’s memory. Krapivin soon came up with a potential way to further miniaturize the pointers so they consumed less memory. However, to achieve that, he needed a better way of organizing the data that the pointers would point to.\u003c/p\u003e\n\u003cp\u003eHe turned to a common approach for storing data known as a hash table. But in the midst of his tinkering, Krapivin realized that he had invented a new kind of hash table, one that worked faster than expected — taking less time and fewer steps to find specific elements.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://engineering.nyu.edu/faculty/martin-farach-colton\"\u003eMartín Farach-Colton\u003c/a\u003e, a co-author of the “Tiny Pointers” paper and Krapivin’s former professor at Rutgers, was initially skeptical of Krapivin’s new design. Hash tables are among the most thoroughly studied data structures in all of computer science; the advance sounded too good to be true.  But just to be sure, he asked a frequent collaborator (and a “Tiny Pointers” co-author), \u003ca href=\"https://csd.cmu.edu/people/faculty/william-kuszmaul\"\u003eWilliam Kuszmaul\u003c/a\u003e of Carnegie Mellon University, to check out his student’s invention. Kuszmaul had a different reaction. “You didn’t just come up with a cool hash table,” he remembers telling Krapivin. “You’ve actually completely wiped out a 40-year-old conjecture!”\u003c/p\u003e\n\u003c/div\u003e\n    \u003c/div\u003e\u003cdiv data-role=\"selectable\"\u003e\n    \u003cp\u003eTogether, Krapivin (now a graduate student at the University of Cambridge), Farach-Colton (now at New York University) and Kuszmaul demonstrated in a \u003ca href=\"https://arxiv.org/abs/2501.02305\"\u003eJanuary 2025 paper\u003c/a\u003e that this new hash table can indeed find elements faster than was considered possible. ln so doing, they had disproved a conjecture long held to be true.\u003c/p\u003e\n\u003cp\u003e“It’s an important paper,” said \u003ca href=\"https://ajhconway.com/\"\u003eAlex Conway\u003c/a\u003e of Cornell Tech in New York City. “Hash tables are among the oldest data structures we have. And they’re still one of the most efficient ways to store data.” Yet open questions remain about how they work, he said. “This paper answers a couple of them in surprising ways.”\u003c/p\u003e\n\u003cp\u003eHash tables have become ubiquitous in computing, partly because of their simplicity and ease of use. They’re designed to allow users to do exactly three things: “query” (search for) an element, delete an element, or insert one into an empty slot. The first hash tables date back to the early 1950s, and computer scientists have studied and used them ever since. Among other things, researchers wanted to figure out the speed limits for some of these operations. How fast, for example, could a new search or insertion possibly be?\u003c/p\u003e\n\n\u003cp\u003eThe answer generally depends on the amount of time it takes to find an empty spot in a hash table. This, in turn, typically depends on how full the hash table is. Fullness can be described in terms of an overall percentage — this table is 50% full, that one’s 90% — but researchers often deal with much fuller tables. So instead, they may use a whole number, denoted by \u003cem\u003ex\u003c/em\u003e, to specify how close the hash table is to 100% full. If \u003cem\u003ex\u003c/em\u003e is 100, then the table is 99% full. If \u003cem\u003ex\u003c/em\u003e is 1,000, the table is 99.9% full. This measure of fullness offers a convenient way to evaluate how long it should take to perform actions like queries or insertions.\u003cstrong\u003e \u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eResearchers have long known that for certain common hash tables, the expected time required to make the worst possible insertion — putting an item into, say, the last remaining open spot — is proportional to \u003cem\u003ex\u003c/em\u003e. “If your hash table is 99% full,” Kuszmaul said, “it makes sense that you would have to look at around 100 different positions to find a free slot.”\u003c/p\u003e\n\u003cp\u003eIn a \u003ca href=\"https://dl.acm.org/doi/10.1145/3828.3836\"\u003e1985 paper\u003c/a\u003e, the computer scientist \u003ca href=\"https://amturing.acm.org/award_winners/yao_1611524.cfm\"\u003eAndrew Yao\u003c/a\u003e, who would go on to win the A.M. Turing Award, asserted that among hash tables with a specific set of properties, the best way to find an individual element or an empty spot is to just go through potential spots randomly — an approach known as uniform probing. He also stated that, in the worst-case scenario, where you’re searching for the last remaining open spot, you can never do better than \u003cem\u003ex\u003c/em\u003e. for 40 years, most computer scientists assumed that Yao’s conjecture was true.\u003c/p\u003e\n\u003cp\u003eKrapivin was not held back by the conventional wisdom for the simple reason that he was unaware of it. “I did this without knowing about Yao’s conjecture,”  he said. His explorations with tiny pointers led to a new kind of hash table — one that did not rely on uniform probing. And for this new hash table, the time required for worst-case queries and insertions is proportional to (log \u003cem\u003ex\u003c/em\u003e)\u003csup\u003e2\u003c/sup\u003e — far faster than \u003cem\u003ex\u003c/em\u003e. This result directly contradicted Yao’s conjecture. Farach-Colton and Kuszmaul helped Krapivin show that (log \u003cem\u003ex\u003c/em\u003e)\u003csup\u003e2\u003c/sup\u003e is the optimal, unbeatable bound for the popular class of hash tables Yao had written about.\u003c/p\u003e\n\u003cp\u003e“This result is beautiful in that it addresses and solves such a classic problem,” said \u003ca href=\"http://www.cs.cmu.edu/~guyb/\"\u003eGuy Blelloch\u003c/a\u003e of Carnegie Mellon.\u003c/p\u003e\n\u003cp\u003e“It’s not just that they disproved [Yao’s conjecture], they also found the best possible answer to his question,” said \u003ca href=\"https://cs.uwaterloo.ca/about/people/sassadi\"\u003eSepehr Assadi\u003c/a\u003e of the University of Waterloo.  “We could have gone another 40 years before we knew the right answer.”\u003c/p\u003e\n\u003c/div\u003e\u003cdiv data-role=\"selectable\"\u003e\n    \u003cp\u003eIn addition to refuting Yao’s conjecture, the new paper also contains what many consider an even more astonishing result. It pertains to a related, though slightly different, situation: In 1985, Yao looked not only at the worst-case times for queries, but also at the average time taken across all possible queries. He proved that hash tables with certain properties — including those that are labeled “greedy,” which means that new elements must be placed in the first available spot — could never achieve an average time better than log \u003cem\u003ex\u003c/em\u003e.\u003c/p\u003e\n        \n        \n\u003cp\u003eFarach-Colton, Krapivin and Kuszmaul wanted to see if that same limit also applied to non-greedy hash tables. They showed that it did not by providing a counterexample, a non-greedy hash table with an average query time that’s much, much better than log \u003cem\u003ex\u003c/em\u003e. In fact, it doesn’t depend on \u003cem\u003ex\u003c/em\u003e at all. “You get a number,” Farach-Colton said, “something that is just a constant and doesn’t depend on how full the hash table is.” The fact that you can achieve a constant average query time, regardless of the hash table’s fullness, was wholly unexpected — even to the authors themselves.\u003c/p\u003e\n\u003cp\u003eThe team’s results may not lead to any immediate applications, but that’s not all that matters, Conway said. “It’s important to understand these kinds of data structures better. You don’t know when a result like this will unlock something that lets you do better in practice.”\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-02-10T15:17:37Z",
  "modifiedTime": "2025-02-10T17:02:30Z"
}
