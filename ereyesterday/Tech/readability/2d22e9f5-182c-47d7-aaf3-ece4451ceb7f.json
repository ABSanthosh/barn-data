{
  "id": "2d22e9f5-182c-47d7-aaf3-ece4451ceb7f",
  "title": "Sign in as anyone: Bypassing SAML SSO authentication with parser differentials",
  "link": "https://github.blog/security/sign-in-as-anyone-bypassing-saml-sso-authentication-with-parser-differentials/",
  "description": "Comments",
  "author": "",
  "published": "Sat, 15 Mar 2025 19:06:01 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Peter Stöckli",
  "length": 18625,
  "excerpt": "Critical authentication bypass vulnerabilities were discovered in ruby-saml up to version 1.17.0. See how they were uncovered.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "Critical authentication bypass vulnerabilities (CVE-2025-25291 + CVE-2025-25292) were discovered in ruby-saml up to version 1.17.0. Attackers who are in possession of a single valid signature that was created with the key used to validate SAML responses or assertions of the targeted organization can use it to construct SAML assertions themselves and are in turn able to log in as any user. In other words, it could be used for an account takeover attack. Users of ruby-saml should update to version 1.18.0. References to libraries making use of ruby-saml (such as omniauth-saml) need also be updated to a version that reference a fixed version of ruby-saml. In this blog post, we detail newly discovered authentication bypass vulnerabilities in the ruby-saml library used for single sign-on (SSO) via SAML on the service provider (application) side. GitHub doesn’t currently use ruby-saml for authentication, but began evaluating the use of the library with the intention of using an open source library for SAML authentication once more. This library is, however, used in other popular projects and products. We discovered an exploitable instance of this vulnerability in GitLab, and have notified their security team so they can take necessary actions to protect their users against potential attacks. GitHub previously used the ruby-saml library up to 2014, but moved to our own SAML implementation due to missing features in ruby-saml at that time. Following bug bounty reports around vulnerabilities in our own implementation (such as CVE-2024-9487, related to encrypted assertions), GitHub recently decided to explore the use of ruby-saml again. Then in October 2024, a blockbuster vulnerability dropped: an authentication bypass in ruby-saml (CVE-2024-45409) by ahacker1. With tangible evidence of exploitable attack surface, GitHub’s switch to ruby-saml had to be evaluated more thoroughly now. As such, GitHub started a private bug bounty engagement to evaluate the security of the ruby-saml library. We gave selected bug bounty researchers access to GitHub test environments using ruby-saml for SAML authentication. In tandem, the GitHub Security Lab also reviewed the attack surface of the ruby-saml library. As is not uncommon when multiple researchers are looking at the same code, both ahacker1, a participant in the GitHub bug bounty program, and I noticed the same thing during code review: ruby-saml was using two different XML parsers during the code path of signature verification. Namely, REXML and Nokogiri. While REXML is an XML parser implemented in pure Ruby, Nokogiri provides an easy-to-use wrapper API around different libraries like libxml2, libgumbo and Xerces (used for JRuby). Nokogiri supports parsing of XML and HTML. It looks like Nokogiri was added to ruby-saml to support canonicalization and potentially other things REXML didn’t support at that time. We both inspected the same code path in the validate_signature of xml_security.rb and found that the signature element to be verified is first read via REXML, and then also with Nokogiri’s XML parser. So, if REXML and Nokogiri could be tricked into retrieving different signature elements for the same XPath query it might be possible to trick ruby-saml into verifying the wrong signature. It looked like there could be a potential authentication bypass due to a parser differential! The reality was actually more complicated than this. Roughly speaking, four stages were involved in the discovery of this authentication bypass: Discovering that two different XML parsers are used during code review. Establishing if and how a parser differential could be exploited. Finding an actual parser differential for the parsers in use. Leveraging the parser differential to create a full-blown exploit. To prove the security impact of this vulnerability, it was necessary to complete all four stages and create a full-blown authentication bypass exploit. Quick recap: how SAML responses are validated Security assertion markup language (SAML) responses are used to transport information about a signed-in user from the identity provider (IdP) to the service provider (SP) in XML format. Often the only important information transported is a username or an email address. When the HTTP POST binding is used, the SAML response travels from the IdP to the SP via the browser of the end user. This makes it obvious why there has to be some sort of signature verification in play to prevent the user from tampering with the message. Let’s have a quick look at what a simplified SAML response looks like: Note: in the response above the XML namespaces were removed for better readability. As you might have noticed: the main part of a simple SAML response is its assertion element (A), whereas the main information contained in the assertion is the information contained in the Subject element (B) (here the NameID containing the username: admin). A real assertion typically contains more information (e.g. NotBefore and NotOnOrAfter dates as part of a Conditions element.) Normally, the Assertion (A) (without the whole Signature part) is canonicalized and then compared against the DigestValue (C) and the SignedInfo (D) is canonicalized and verified against the SignatureValue (E). In this sample, the assertion of the SAML response is signed, and in other cases the whole SAML response is signed. Searching for parser differentials We learned that ruby-saml used two different XML parsers (REXML and Nokogiri) for validating the SAML response. Now let’s have a look at the verification of the signature and the digest comparison. The focus of the following explanation lies on the validate_signature method inside of xml_security.rb. Inside that method, there’s a broad XPath query with REXML for the first signature element inside the SAML document: sig_element = REXML::XPath.first( @working_copy, \"//ds:Signature\", {\"ds\"=\u003eDSIG} ) Hint: When reading the code snippets, you can tell the difference between queries for REXML and Nokogiri by looking at how they are called. REXML methods are prefixed with REXML::, whereas Nokogiri methods are called on document. Later, the actual SignatureValue is read from this element: base64_signature = REXML::XPath.first( sig_element, \"./ds:SignatureValue\", {\"ds\" =\u003e DSIG} ) signature = Base64.decode64(OneLogin::RubySaml::Utils.element_text(base64_signature)) Note: the name of the Signature element might be a bit confusing. While it contains the actual signature in the SignatureValue node it also contains the part that is actually signed in the SignedInfo node. Most importantly the DigestValue element contains the digest (hash) of the assertion and information about the used key. So, an actual Signature element could look like this (removed namespace information for better readability): \u003cSignature\u003e \u003cSignedInfo\u003e \u003cCanonicalizationMethod Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\" /\u003e \u003cSignatureMethod Algorithm=\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\" /\u003e \u003cReference URI=\"#_SAMEID\"\u003e \u003cTransforms\u003e\u003cTransform Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\" /\u003e\u003c/Transforms\u003e \u003cDigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\" /\u003e \u003cDigestValue\u003eSu4v[..]\u003c/DigestValue\u003e \u003c/Reference\u003e \u003c/SignedInfo\u003e \u003cSignatureValue\u003eL8/i[..]\u003c/SignatureValue\u003e \u003cKeyInfo\u003e \u003cX509Data\u003e \u003cX509Certificate\u003eMIID[..]\u003c/X509Certificate\u003e \u003c/X509Data\u003e \u003c/KeyInfo\u003e \u003c/Signature\u003e Later in the same method (validate_signature) there’s again a query for the Signature(s)—but this time with Nokogiri. noko_sig_element = document.at_xpath('//ds:Signature', 'ds' =\u003e DSIG) Then the SignedInfo element is taken from that signature and canonicalized: noko_signed_info_element = noko_sig_element.at_xpath('./ds:SignedInfo', 'ds' =\u003e DSIG) canon_string = noko_signed_info_element.canonicalize(canon_algorithm) Let’s remember this canon_string contains the canonicalized SignedInfo element. The SignedInfo element is then also extracted with REXML: signed_info_element = REXML::XPath.first( sig_element, \"./ds:SignedInfo\", { \"ds\" =\u003e DSIG } ) From this SignedInfo element the Reference node is read: ref = REXML::XPath.first(signed_info_element, \"./ds:Reference\", {\"ds\"=\u003eDSIG}) Now the code queries for the referenced node by looking for nodes with the signed element id using Nokogiri: reference_nodes = document.xpath(\"//*[@ID=$id]\", nil, { 'id' =\u003e extract_signed_element_id }) The method extract_signed_element_id extracts the signed element id with help of REXML. From the previous authentication bypass (CVE-2024-45409), there’s now a check that only one element with the same ID can exist. The first of the reference_nodes is taken and canonicalized: hashed_element = reference_nodes[0][..]canon_hashed_element = hashed_element.canonicalize(canon_algorithm, inclusive_namespaces) The canon_hashed_element is then hashed: hash = digest_algorithm.digest(canon_hashed_element) The DigestValue to compare it against is then extracted with REXML: encoded_digest_value = REXML::XPath.first( ref, \"./ds:DigestValue\", { \"ds\" =\u003e DSIG } ) digest_value = Base64.decode64(OneLogin::RubySaml::Utils.element_text(encoded_digest_value)) Finally, the hash (built from the element extracted by Nokogiri) is compared against the digest_value (extracted with REXML): unless digests_match?(hash, digest_value) The canon_string extracted some lines ago (a result of an extraction with Nokogiri) is later verified against signature (extracted with REXML). unless cert.public_key.verify(signature_algorithm.new, signature, canon_string) In the end, we have the following constellation: The assertion is extracted and canonicalized with Nokogiri, and then hashed. In contrast, the hash against which it will be compared is extracted with REXML. The SignedInfo element is extracted and canonicalized with Nokogiri - it is then verified against the SignatureValue, which was extracted with REXML. Exploiting the parser differential The question is: is it possible to create an XML document where REXML sees one signature and Nokogiri sees another? It turns out, yes. Ahacker1, participating in the bug bounty, was faster to produce a working exploit using a parser differential. Among other things, ahacker1 was inspired by the XML roundtrips vulnerabilities published by Mattermost’s Juho Forsén in 2021. Not much later, I produced an exploit using a different parser differential with the help of Trail of Bits’ Ruby fuzzer called ruzzy. Both exploits result in an authentication bypass. Meaning that an attacker, who is in possession of a single valid signature that was created with the key used to validate SAML responses or assertions of the targeted organization, can use it to construct assertions for any users which will be accepted by ruby-saml. Such a signature can either come from a signed assertion or response from another (unprivileged) user or in certain cases, it can even come from signed metadata of a SAML identity provider (which can be publicly accessible). An exploit could look like this. Here, an additional Signature was added as part of the StatusDetail element that is only visible to Nokogiri: In summary: The SignedInfo element (A) from the signature that is visible to Nokogiri is canonicalized and verified against the SignatureValue (B) that was extracted from the signature seen by REXML. The assertion is retrieved via Nokogiri by looking for its ID. This assertion is then canonicalized and hashed (C). The hash is then compared to the hash contained in the DigestValue (D). This DigestValue was retrieved via REXML. This DigestValue has no corresponding signature. So, two things take place: A valid SignedInfo with DigestValue is verified against a valid signature. (which checks out) A fabricated canonicalized assertion is compared against its calculated digest. (which checks out as well) This allows an attacker, who is in possession of a valid signed assertion for any (unprivileged) user, to fabricate assertions and as such impersonate any other user. Check for errors when using Nokogiri Parts of the currently known, undisclosed exploits can be stopped by checking for Nokogiri parsing errors on SAML responses. Sadly, those errors do not result in exceptions, but need to be checked on the errors member of the parsed document: doc = Nokogiri::XML(xml) do |config| config.options = Nokogiri::XML::ParseOptions::STRICT | Nokogiri::XML::ParseOptions::NONET end raise \"XML errors when parsing: \" + doc.errors.to_s if doc.errors.any? While this is far from a perfect fix for the issues at hand, it renders at least one exploit infeasible. Indicators of compromise We are not aware of any reliable indicators of compromise. While we’ve found a potential indicator of compromise, it only works in debug-like environments and to publish it, we would have to reveal too many details about how to implement a working exploit so we’ve decided that it’s better not to publish it. Instead, our best recommendation is to look for suspicious logins via SAML on the service provider side from IP addresses that do not align with the user’s expected location. SAML and XML signatures:as confusing as it gets Some might say it’s hard to integrate systems with SAML. That might be true. However, it’s even harder to write implementations of SAML using XML signatures in a secure way. As others have stated before: it’s probably best to disregard the specifications, as following them doesn’t help build secure implementations. To rehash how the validation works if the SAML assertion is signed, let’s have a look at the graphic below, depicting a simplified SAML response. The assertion, which transports the protected information, contains a signature. Confusing, right? To complicate it even more: What is even signed here? The whole assertion? No! What’s signed is the SignedInfo element and the SignedInfo element contains a DigestValue. This DigestValue is the hash of the canonicalized assertion with the signature element removed before the canonicalization. This two-stage verification process can lead to implementations that have a disconnect between the verification of the hash and the verification of the signature. This is the case for these Ruby-SAML parser differentials: while the hash and the signature check out on their own, they have no connection. The hash is actually a hash of the assertion, but the signature is a signature of a different SignedInfo element containing another hash. What you actually want is a direct connection between the hashed content, the hash, and the signature. (And once the verification is done you only want to retrieve information from the exact part that was actually verified.) Or, alternatively, use a less complicated standard to transport a cryptographically signed username between two systems - but here we are. In this case, the library already extracted the SignedInfo and used it to verify the signature of its canonicalized string,canon_string. However, it did not use it to obtain the digest value. If the library had used the content of the already extracted SignedInfo to obtain the digest value, it would have been secure in this case even with two XML parsers in use. Conclusion As shown once again: relying on two different parsers in a security context can be tricky and error-prone. That being said: exploitability is not automatically guaranteed in such cases. As we have seen in this case, checking for Nokogiri errors could not have prevented the parser differential, but could have stopped at least one practical exploitation of it. The initial fix for the authentication bypasses does not remove one of the XML parsers to prevent API compatibility problems. As noted, the more fundamental issue was the disconnect between verification of the hash and verification of the signature, which was exploitable via parser differentials. The removal of one of the XML parsers was already planned for other reasons, and will likely come as part of a major release in combination with additional improvements to strengthen the library. If your company relies on open source software for business-critical functionality, consider sponsoring them to help fund their future development and bug fix releases. If you’re a user of ruby-saml library, make sure to update to the latest version, 1.18.0, containing fixes for CVE-2025-25291 and CVE-2025-25292. References to libraries making use of ruby-saml (such as omniauth-saml) need also be updated to a version that reference a fixed version of ruby-saml. We will publish a proof of concept exploit at a later date in the GitHub Security Lab repository. Acknowledgments Special thanks to Sixto Martín, maintainer of ruby-saml, and Jeff Guerra from the GitHub Bug Bounty program. Special thanks also to ahacker1 for giving inputs to this blog post. Timeline 2024-11-04: Bug bounty report demonstrating an authentication bypass was reported against a GitHub test environment evaluating ruby-saml for SAML authentication. 2024-11-04: Work started to identify and test potential mitigations. 2024-11-12: A second authentication bypass was found by Peter that renders the planned mitigations for the first useless. 2024-11-13: Initial contact with Sixto Martín, maintainer of ruby-saml. 2024-11-14: Both parser differentials are reported to ruby-saml, the maintainer responds immediately. 2024-11-14: The work on potential patches by the maintainer and ahacker1 begins. (One of the initial ideas was to remove one of the XML parsers, but this was not feasible without breaking backwards compatibility). 2025-02-04: ahacker1 proposes a non-backwards compatible fix. 2025-02-06: ahacker1 also proposes a backwards compatible fix. 2025-02-12: The 90 days deadline of GitHub Security Lab advisories ends. 2025-02-16: The maintainer starts working on a fix with the idea to be backwards-compatible and easier to understand. 2025-02-17: Initial contact with GitLab to coordinate a release of their on-prem product with the release of the ruby-saml library. 2025-03-12: A fixed version of ruby-saml was released. Tags: authentication GitHub Security Lab ruby SAML vulnerability Written by Security Researcher at GitHub Security Lab",
  "image": "https://github.blog/wp-content/uploads/2024/02/Security-DarkMode-2-2.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cblockquote\u003e\u003cp\u003eCritical authentication bypass vulnerabilities (CVE-2025-25291 + CVE-2025-25292) were discovered in ruby-saml up to version 1.17.0. Attackers who are in possession of a single valid signature that was created with the key used to validate SAML responses or assertions of the targeted organization can use it to construct SAML assertions themselves and are in turn able to log in as any user. In other words, it could be used for an account takeover attack. Users of ruby-saml should update to version 1.18.0. References to libraries making use of ruby-saml (such as omniauth-saml) need also be updated to a version that reference a fixed version of ruby-saml.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eIn this blog post, we detail newly discovered authentication bypass vulnerabilities in the \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml\"\u003eruby-saml\u003c/a\u003e library used for single sign-on (SSO) via SAML on the service provider (application) side. GitHub doesn’t currently use ruby-saml for authentication, but began evaluating the use of the library with the intention of using an open source library for SAML authentication once more. This library is, however, used in other popular projects and products. We discovered an exploitable instance of this vulnerability in GitLab, and have notified their security team so they can take necessary actions to protect their users against potential attacks.\u003c/p\u003e\n\u003cp\u003eGitHub previously used the ruby-saml library up to 2014, but moved to our own SAML implementation due to missing features in ruby-saml at that time. Following bug bounty reports around vulnerabilities in our own implementation (such as \u003ca href=\"https://docs.github.com/en/enterprise-server@3.13/admin/release-notes#3.13.5-security-fixes\"\u003eCVE-2024-9487\u003c/a\u003e, related to encrypted assertions), GitHub recently decided to explore the use of ruby-saml again. Then in October 2024, a blockbuster vulnerability dropped: an \u003ca href=\"https://github.com/advisories/GHSA-jw9c-mfg7-9rx2\"\u003eauthentication bypass\u003c/a\u003e in ruby-saml (CVE-2024-45409) by \u003ca href=\"https://hackerone.com/ahacker1\"\u003eahacker1\u003c/a\u003e. With tangible evidence of exploitable attack surface, GitHub’s switch to ruby-saml had to be evaluated more thoroughly now. As such, GitHub started a \u003ca href=\"https://hackerone.com/github\"\u003eprivate bug bounty engagement\u003c/a\u003e to evaluate the security of the ruby-saml library. We gave selected bug bounty researchers access to GitHub test environments using ruby-saml for SAML authentication. In tandem, the GitHub Security Lab also reviewed the attack surface of the ruby-saml library.\u003c/p\u003e\n\u003cp\u003eAs is not uncommon when multiple researchers are looking at the same code, both ahacker1, a participant in the \u003ca href=\"https://hackerone.com/github\"\u003eGitHub bug bounty program\u003c/a\u003e, and I noticed the same thing during code review: ruby-saml was using two different XML parsers during the code path of signature verification. Namely, REXML and Nokogiri. While REXML is an XML parser implemented in pure Ruby, Nokogiri provides an easy-to-use wrapper API around different libraries like libxml2, libgumbo and Xerces (used for JRuby). Nokogiri supports parsing of XML and HTML. It looks like Nokogiri was added to ruby-saml to support \u003ca href=\"https://en.wikipedia.org/wiki/Canonical_XML\"\u003ecanonicalization\u003c/a\u003e and potentially other things REXML didn’t support at that time.\u003c/p\u003e\n\u003cp\u003eWe both inspected the same code path in the \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L268\"\u003e\u003ccode\u003evalidate_signature\u003c/code\u003e\u003c/a\u003e of \u003ccode\u003exml_security.rb\u003c/code\u003e and found that the signature element to be verified is first read via REXML, and then also with Nokogiri’s XML parser. So, if REXML and Nokogiri could be tricked into retrieving different signature elements for the same XPath query it might be possible to trick ruby-saml into verifying the wrong signature. It looked like there could be a potential authentication bypass due to a \u003cstrong\u003eparser differential\u003c/strong\u003e!\u003c/p\u003e\n\u003cp\u003eThe reality was actually more complicated than this.\u003c/p\u003e\n\n\u003cp\u003eRoughly speaking, four stages were involved in the discovery of this authentication bypass:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDiscovering that two different XML parsers are used during code review.  \u003c/li\u003e\n\u003cli\u003eEstablishing if and how a parser differential could be exploited.  \u003c/li\u003e\n\u003cli\u003eFinding an actual parser differential for the parsers in use.  \u003c/li\u003e\n\u003cli\u003eLeveraging the parser differential to create a full-blown exploit.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eTo prove the security impact of this vulnerability, it was necessary to complete all four stages and create a full-blown authentication bypass exploit.\u003c/p\u003e\n\u003ch2 id=\"quick-recap-how-saml-responses-are-validated\" id=\"quick-recap-how-saml-responses-are-validated\"\u003eQuick recap: how SAML responses are validated\u003ca href=\"#quick-recap-how-saml-responses-are-validated\" aria-label=\"Quick recap: how SAML responses are validated\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSecurity assertion markup language (\u003ca href=\"https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language\"\u003eSAML\u003c/a\u003e) responses are used to transport information about a signed-in user from the identity provider (IdP) to the service provider (SP) in XML format. Often the only important information transported is a username or an email address. When the HTTP POST binding is used, the SAML response travels from the IdP to the SP via the browser of the end user. This makes it obvious why there has to be some sort of signature verification in play to prevent the user from tampering with the message.\u003c/p\u003e\n\u003cp\u003eLet’s have a quick look at what a simplified SAML response looks like:\u003cbr/\u003e\n\u003cimg data-recalc-dims=\"1\" decoding=\"async\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/03/goodassertion7_2.png?resize=1024%2C355\" alt=\"A diagram depicting a simplified SAML response on the left and the verification of the digest and the signature on the right.\" width=\"1024\" height=\"355\" srcset=\"https://github.blog/wp-content/uploads/2025/03/goodassertion7_2.png?w=2632 2632w, https://github.blog/wp-content/uploads/2025/03/goodassertion7_2.png?w=300 300w, https://github.blog/wp-content/uploads/2025/03/goodassertion7_2.png?w=768 768w, https://github.blog/wp-content/uploads/2025/03/goodassertion7_2.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/03/goodassertion7_2.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/03/goodassertion7_2.png?w=2048 2048w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNote: in the response above the XML namespaces were removed for better readability.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eAs you might have noticed: the main part of a simple SAML response is its assertion element (A), whereas the main information contained in the assertion is the information contained in the \u003ccode\u003eSubject\u003c/code\u003e element (B) (here the NameID containing the username: admin). A real assertion typically contains more information (e.g. \u003ccode\u003eNotBefore\u003c/code\u003e and \u003ccode\u003eNotOnOrAfter\u003c/code\u003e dates as part of a \u003ccode\u003eConditions\u003c/code\u003e element.)\u003c/p\u003e\n\u003cp\u003eNormally, the \u003ccode\u003eAssertion\u003c/code\u003e (A) (without the whole \u003ccode\u003eSignature\u003c/code\u003e part) is \u003ca href=\"https://en.wikipedia.org/wiki/Canonical_XML\"\u003ecanonicalized\u003c/a\u003e and then compared against the \u003ccode\u003eDigestValue\u003c/code\u003e (C) and the \u003ccode\u003eSignedInfo\u003c/code\u003e (D) is canonicalized and verified against the \u003ccode\u003eSignatureValue\u003c/code\u003e (E). In this sample, the assertion of the SAML response is signed, and in other cases the whole SAML response is signed.\u003c/p\u003e\n\u003ch2 id=\"searching-for-parser-differentials\" id=\"searching-for-parser-differentials\"\u003eSearching for parser differentials\u003ca href=\"#searching-for-parser-differentials\" aria-label=\"Searching for parser differentials\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe learned that ruby-saml used two different XML parsers (REXML and Nokogiri) for validating the SAML response. Now let’s have a look at the verification of the signature and the digest comparison.\u003cbr/\u003e\nThe focus of the following explanation lies on the \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L268\"\u003e\u003ccode\u003evalidate_signature\u003c/code\u003e\u003c/a\u003e method inside of \u003ccode\u003exml_security.rb\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eInside that method, there’s a broad XPath \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L278C1-L282C8\"\u003equery\u003c/a\u003e with REXML for the first signature element inside the SAML document:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esig_element = REXML::XPath.first(\n  @working_copy,\n  \u0026#34;//ds:Signature\u0026#34;,\n  {\u0026#34;ds\u0026#34;=\u0026gt;DSIG}\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eHint: When reading the code snippets, you can tell the difference between queries for REXML and Nokogiri by looking at how they are called. REXML methods are prefixed with \u003ccode\u003eREXML::\u003c/code\u003e, whereas Nokogiri methods are called on \u003ccode\u003edocument\u003c/code\u003e.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eLater, the actual \u003ccode\u003eSignatureValue\u003c/code\u003e is \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L293C1-L298C92\"\u003eread\u003c/a\u003e from this element:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebase64_signature = REXML::XPath.first(\n  sig_element,\n  \u0026#34;./ds:SignatureValue\u0026#34;,\n  {\u0026#34;ds\u0026#34; =\u0026gt; DSIG}\n)\nsignature = Base64.decode64(OneLogin::RubySaml::Utils.element_text(base64_signature))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote: the name of the \u003ccode\u003eSignature\u003c/code\u003e element might be a bit confusing. While it contains the actual signature in the \u003ccode\u003eSignatureValue\u003c/code\u003e node it also contains the part that is actually signed in the \u003ccode\u003eSignedInfo\u003c/code\u003e node. Most importantly the \u003ccode\u003eDigestValue\u003c/code\u003e element contains the digest (hash) of the assertion and information about the used key.\u003c/p\u003e\n\u003cp\u003eSo, an actual \u003ccode\u003eSignature\u003c/code\u003e element could look like this (removed namespace information for better readability):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;Signature\u0026gt;\n    \u0026lt;SignedInfo\u0026gt;\n        \u0026lt;CanonicalizationMethod Algorithm=\u0026#34;http://www.w3.org/2001/10/xml-exc-c14n#\u0026#34; /\u0026gt;\n        \u0026lt;SignatureMethod Algorithm=\u0026#34;http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\u0026#34; /\u0026gt;\n        \u0026lt;Reference URI=\u0026#34;#_SAMEID\u0026#34;\u0026gt;\n            \u0026lt;Transforms\u0026gt;\u0026lt;Transform Algorithm=\u0026#34;http://www.w3.org/2001/10/xml-exc-c14n#\u0026#34; /\u0026gt;\u0026lt;/Transforms\u0026gt;\n            \u0026lt;DigestMethod Algorithm=\u0026#34;http://www.w3.org/2001/04/xmlenc#sha256\u0026#34; /\u0026gt;\n            \u0026lt;DigestValue\u0026gt;Su4v[..]\u0026lt;/DigestValue\u0026gt;\n        \u0026lt;/Reference\u0026gt;\n    \u0026lt;/SignedInfo\u0026gt;\n    \u0026lt;SignatureValue\u0026gt;L8/i[..]\u0026lt;/SignatureValue\u0026gt;\n    \u0026lt;KeyInfo\u0026gt;\n        \u0026lt;X509Data\u0026gt;\n            \u0026lt;X509Certificate\u0026gt;MIID[..]\u0026lt;/X509Certificate\u0026gt;\n        \u0026lt;/X509Data\u0026gt;\n    \u0026lt;/KeyInfo\u0026gt;\n\u0026lt;/Signature\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLater in the same method (\u003ccode\u003evalidate_signature\u003c/code\u003e) there’s again a \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L307\"\u003equery for the Signature\u003c/a\u003e(s)—but this time with Nokogiri.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enoko_sig_element = document.at_xpath(\u0026#39;//ds:Signature\u0026#39;, \u0026#39;ds\u0026#39; =\u0026gt; DSIG)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen the \u003ccode\u003eSignedInfo\u003c/code\u003e element is taken from that signature and \u003ca href=\"https://en.wikipedia.org/wiki/Canonical_XML\"\u003ecanonicalized\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enoko_signed_info_element = noko_sig_element.at_xpath(\u0026#39;./ds:SignedInfo\u0026#39;, \u0026#39;ds\u0026#39; =\u0026gt; DSIG)\n\ncanon_string = noko_signed_info_element.canonicalize(canon_algorithm)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s remember this \u003ccode\u003ecanon_string\u003c/code\u003e contains the canonicalized \u003ccode\u003eSignedInfo\u003c/code\u003e element.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eSignedInfo\u003c/code\u003e element is then also \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L314C6-L318C8\"\u003eextracted\u003c/a\u003e with REXML:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e signed_info_element = REXML::XPath.first(\n        sig_element,\n        \u0026#34;./ds:SignedInfo\u0026#34;,\n        { \u0026#34;ds\u0026#34; =\u0026gt; DSIG }\n )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFrom this \u003ccode\u003eSignedInfo\u003c/code\u003e element the \u003ccode\u003eReference\u003c/code\u003e node is \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L324\"\u003eread\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eref = REXML::XPath.first(signed_info_element, \u0026#34;./ds:Reference\u0026#34;, {\u0026#34;ds\u0026#34;=\u0026gt;DSIG})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow the code \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L326C1-L327C1\"\u003equeries for the referenced node\u003c/a\u003e by looking for nodes with the signed element id using Nokogiri:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ereference_nodes = document.xpath(\u0026#34;//*[@ID=$id]\u0026#34;, nil, { \u0026#39;id\u0026#39; =\u0026gt; extract_signed_element_id })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe method \u003ccode\u003eextract_signed_element_id\u003c/code\u003e \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L406C9-L406C34\"\u003eextracts\u003c/a\u003e the signed element id with help of REXML. From the previous authentication bypass (CVE-2024-45409), there’s now a \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L328\"\u003echeck\u003c/a\u003e that only one element with the same ID can exist.\u003c/p\u003e\n\u003cp\u003eThe first of the \u003ccode\u003ereference_nodes\u003c/code\u003e is taken and canonicalized:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehashed_element = reference_nodes[0][..]canon_hashed_element = hashed_element.canonicalize(canon_algorithm, inclusive_namespaces)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ecanon_hashed_element\u003c/code\u003e is then \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L349C7-L349C59\"\u003ehashed\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehash = digest_algorithm.digest(canon_hashed_element)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eDigestValue\u003c/code\u003e to compare it against is then \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L350C7-L355C99\"\u003eextracted\u003c/a\u003e with REXML:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eencoded_digest_value = REXML::XPath.first(\n        ref,\n        \u0026#34;./ds:DigestValue\u0026#34;,\n        { \u0026#34;ds\u0026#34; =\u0026gt; DSIG }\n      )\ndigest_value = Base64.decode64(OneLogin::RubySaml::Utils.element_text(encoded_digest_value))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFinally, the \u003ccode\u003ehash\u003c/code\u003e (built from the element extracted by Nokogiri) is \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L357\"\u003ecompared\u003c/a\u003e against the \u003ccode\u003edigest_value\u003c/code\u003e (extracted with REXML):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eunless digests_match?(hash, digest_value)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ecanon_string\u003c/code\u003e extracted some lines ago (a result of an extraction with Nokogiri) is later \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/blob/21b676bdf55452750d8ee5facd2f6e3c51927315/lib/xml_security.rb#L366C7-L366C86\"\u003everified against\u003c/a\u003e \u003ccode\u003esignature\u003c/code\u003e (extracted with REXML).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eunless cert.public_key.verify(signature_algorithm.new, signature, canon_string)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the end, we have the following constellation:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe assertion is extracted and canonicalized with Nokogiri, and then hashed. In contrast, the hash against which it will be compared is extracted with REXML.  \u003c/li\u003e\n\u003cli\u003eThe SignedInfo element is extracted and canonicalized with Nokogiri - it is then verified against the SignatureValue, which was extracted with REXML.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"exploiting-the-parser-differential\" id=\"exploiting-the-parser-differential\"\u003eExploiting the parser differential\u003ca href=\"#exploiting-the-parser-differential\" aria-label=\"Exploiting the parser differential\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe question is: is it possible to create an XML document where REXML sees one signature and Nokogiri sees another?\u003c/p\u003e\n\u003cp\u003eIt turns out, yes.\u003c/p\u003e\n\u003cp\u003eAhacker1, participating in the bug bounty, was faster to produce a working exploit using a parser differential. Among other things, ahacker1 was inspired by the \u003ca href=\"https://mattermost.com/blog/securing-xml-implementations-across-the-web/\"\u003eXML roundtrips vulnerabilities\u003c/a\u003e published by Mattermost’s Juho Forsén in 2021.\u003c/p\u003e\n\u003cp\u003eNot much later, I produced an exploit using a different parser differential with the help of \u003ca href=\"https://blog.trailofbits.com/2024/03/29/introducing-ruzzy-a-coverage-guided-ruby-fuzzer/\"\u003eTrail of Bits’ Ruby fuzzer\u003c/a\u003e called ruzzy.\u003c/p\u003e\n\u003cp\u003eBoth exploits result in an authentication bypass. Meaning that an attacker, who is in possession of a single valid signature that was created with the key used to validate SAML responses or assertions of the targeted organization, can use it to construct assertions for any users which will be accepted by ruby-saml. Such a signature can either come from a signed assertion or response from another (unprivileged) user or in certain cases, it can even come from signed metadata of a SAML identity provider (which can be publicly accessible).\u003c/p\u003e\n\u003cp\u003eAn exploit could look like this. Here, an additional Signature was added as part of the \u003ccode\u003eStatusDetail\u003c/code\u003e element that is only visible to Nokogiri:\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/03/rubysaml-parser-diff-simplified8_2.png?resize=1024%2C400\" alt=\"A diagram depicting a simplified SAML response on the left and the verification of the digest and the signature on the right. For both the signature and the digest verification one part is extracted using Nokogiri and the other using REXML.\" width=\"1024\" height=\"400\" srcset=\"https://github.blog/wp-content/uploads/2025/03/rubysaml-parser-diff-simplified8_2.png?w=3496 3496w, https://github.blog/wp-content/uploads/2025/03/rubysaml-parser-diff-simplified8_2.png?w=300 300w, https://github.blog/wp-content/uploads/2025/03/rubysaml-parser-diff-simplified8_2.png?w=768 768w, https://github.blog/wp-content/uploads/2025/03/rubysaml-parser-diff-simplified8_2.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/03/rubysaml-parser-diff-simplified8_2.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/03/rubysaml-parser-diff-simplified8_2.png?w=2048 2048w, https://github.blog/wp-content/uploads/2025/03/rubysaml-parser-diff-simplified8_2.png?w=3000 3000w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eIn summary:\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eSignedInfo\u003c/code\u003e element (A) from the signature that is visible to Nokogiri is canonicalized and verified against the \u003ccode\u003eSignatureValue\u003c/code\u003e (B) that was extracted from the signature seen by REXML.\u003c/p\u003e\n\u003cp\u003eThe assertion is retrieved via Nokogiri by looking for its ID. This assertion is then canonicalized and hashed (C). The hash is then compared to the hash contained in the \u003ccode\u003eDigestValue\u003c/code\u003e (D). This DigestValue was retrieved via REXML. This DigestValue has no corresponding signature.\u003c/p\u003e\n\u003cp\u003eSo, two things take place:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA valid SignedInfo with DigestValue is verified against a valid signature. (which checks out)  \u003c/li\u003e\n\u003cli\u003eA fabricated canonicalized assertion is compared against its calculated digest. (which checks out as well)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis allows an attacker, who is in possession of a valid signed assertion for any (unprivileged) user, to fabricate assertions and as such impersonate any other user.\u003c/p\u003e\n\u003ch3 id=\"check-for-errors-when-using-nokogiri\" id=\"check-for-errors-when-using-nokogiri\"\u003eCheck for errors when using Nokogiri\u003ca href=\"#check-for-errors-when-using-nokogiri\" aria-label=\"Check for errors when using Nokogiri\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eParts of the currently known, undisclosed exploits can be stopped by checking for Nokogiri parsing errors on SAML responses. Sadly, those errors do not result in exceptions, but need to be checked on the \u003ca href=\"https://www.rubydoc.info/github/sparklemotion/nokogiri/Nokogiri%2FXML%2FDocument:errors\"\u003e\u003ccode\u003eerrors\u003c/code\u003e\u003c/a\u003e member of the parsed document:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edoc = Nokogiri::XML(xml) do |config|\n  config.options = Nokogiri::XML::ParseOptions::STRICT | Nokogiri::XML::ParseOptions::NONET\nend\n\nraise \u0026#34;XML errors when parsing: \u0026#34; + doc.errors.to_s if doc.errors.any?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhile this is far from a perfect fix for the issues at hand, it renders at least one exploit infeasible.\u003c/p\u003e\n\u003ch2 id=\"indicators-of-compromise\" id=\"indicators-of-compromise\"\u003eIndicators of compromise\u003ca href=\"#indicators-of-compromise\" aria-label=\"Indicators of compromise\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe are not aware of any reliable indicators of compromise. While we’ve found a potential indicator of compromise, it only works in debug-like environments and to publish it, we would have to reveal too many details about how to implement a working exploit so we’ve decided that it’s better not to publish it. Instead, our best recommendation is to look for suspicious logins via SAML on the service provider side from IP addresses that do not align with the user’s expected location.\u003c/p\u003e\n\u003ch2 id=\"saml-and-xml-signaturesas-confusing-as-it-gets\" id=\"saml-and-xml-signaturesas-confusing-as-it-gets\"\u003eSAML and XML signatures:as confusing as it gets\u003ca href=\"#saml-and-xml-signaturesas-confusing-as-it-gets\" aria-label=\"SAML and XML signatures:as confusing as it gets\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSome might say it’s hard to integrate systems with SAML. That might be true. However, it’s even harder to write implementations of SAML using XML signatures in a secure way. As others have stated before: it’s probably best to \u003ca href=\"https://ssoready.com/blog/engineering/ruby-saml-pwned-by-xml-signature-wrapping-attacks/#how-to-fix-this-disregard-the-spec\"\u003edisregard the specifications\u003c/a\u003e, as following them doesn’t help build secure implementations.\u003cbr/\u003e\nTo rehash how the validation works if the SAML assertion is signed, let’s have a look at the graphic below,  depicting a simplified SAML response. The assertion, which transports the protected information, contains a signature. Confusing, right?\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/03/conclusion-combined-saml.png?resize=1024%2C497\" alt=\"A diagram showing a SAML response and its parts: the Assertion containing the Signature and the Signature containing the SignedInfo of which the DigestValue is a part.\" width=\"1024\" height=\"497\" srcset=\"https://github.blog/wp-content/uploads/2025/03/conclusion-combined-saml.png?w=1768 1768w, https://github.blog/wp-content/uploads/2025/03/conclusion-combined-saml.png?w=300 300w, https://github.blog/wp-content/uploads/2025/03/conclusion-combined-saml.png?w=768 768w, https://github.blog/wp-content/uploads/2025/03/conclusion-combined-saml.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/03/conclusion-combined-saml.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eTo complicate it even more: What is even signed here? The whole assertion? No!\u003c/p\u003e\n\u003cp\u003eWhat’s signed is the \u003ccode\u003eSignedInfo\u003c/code\u003e element and the \u003ccode\u003eSignedInfo\u003c/code\u003e element contains a \u003ccode\u003eDigestValue\u003c/code\u003e. This \u003ccode\u003eDigestValue\u003c/code\u003e is the hash of the canonicalized assertion with the signature element removed before the canonicalization. This two-stage verification process can lead to implementations that have a disconnect between the verification of the hash and the verification of the signature. This is the case for these Ruby-SAML parser differentials: while the hash and the signature check out on their own, they have no connection. The hash is actually a hash of the assertion, but the signature is a signature of a different \u003ccode\u003eSignedInfo\u003c/code\u003e element containing another hash. What you actually want is a direct connection between the hashed content, the hash, and the signature. (And once the verification is done you only want to retrieve information from the exact part that was actually verified.) Or, alternatively, use a less complicated standard to transport a cryptographically signed username between two systems - but here we are.\u003c/p\u003e\n\u003cp\u003eIn this case, the library already extracted the \u003ccode\u003eSignedInfo\u003c/code\u003e and used it to verify the signature of its canonicalized string,\u003ccode\u003ecanon_string\u003c/code\u003e. However, it did not use it to obtain the digest value. If the library had used the content of the already extracted \u003ccode\u003eSignedInfo\u003c/code\u003e to obtain the digest value, it would have been secure in this case even with two XML parsers in use.\u003c/p\u003e\n\u003ch2 id=\"conclusion\" id=\"conclusion\"\u003eConclusion\u003ca href=\"#conclusion\" aria-label=\"Conclusion\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAs shown once again: relying on two different parsers in a security context can be tricky and error-prone. That being said: exploitability is not automatically guaranteed in such cases. As we have seen in this case, checking for Nokogiri errors could not have prevented the parser differential, but could have stopped at least one practical exploitation of it.\u003c/p\u003e\n\u003cp\u003eThe initial fix for the authentication bypasses does not remove one of the XML parsers to prevent API compatibility problems. As noted, the more fundamental issue was the disconnect between verification of the hash and verification of the signature, which was exploitable via parser differentials. The \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/pull/736\"\u003eremoval of one of the XML\u003c/a\u003e parsers was already planned for other reasons, and will likely come as part of a major release in combination with additional improvements to strengthen the library. If your company relies on open source software for business-critical functionality, consider \u003ca href=\"https://github.com/sponsors\"\u003esponsoring\u003c/a\u003e them to help fund their future development and bug fix releases.\u003c/p\u003e\n\u003cp\u003eIf you’re a user of ruby-saml library, make sure to update to the latest version, 1.18.0, containing fixes for \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/security/advisories/GHSA-4vc4-m8qh-g8jm\"\u003eCVE-2025-25291\u003c/a\u003e and \u003ca href=\"https://github.com/SAML-Toolkits/ruby-saml/security/advisories/GHSA-754f-8gm6-c4r2\"\u003eCVE-2025-25292\u003c/a\u003e. References to libraries making use of ruby-saml (such as \u003ca href=\"https://github.com/omniauth/omniauth-saml\"\u003eomniauth-saml\u003c/a\u003e) need also be updated to a version that reference a fixed version of ruby-saml. We will publish a proof of concept exploit at a later date in the \u003ca href=\"https://github.com/github/securitylab\"\u003eGitHub Security Lab repository\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"acknowledgments\" id=\"acknowledgments\"\u003eAcknowledgments\u003ca href=\"#acknowledgments\" aria-label=\"Acknowledgments\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSpecial thanks to Sixto Martín, maintainer of ruby-saml, and Jeff Guerra from the GitHub Bug Bounty program.\u003cbr/\u003e\nSpecial thanks also to ahacker1 for giving inputs to this blog post.\u003c/p\u003e\n\u003ch3 id=\"timeline\" id=\"timeline\"\u003eTimeline\u003ca href=\"#timeline\" aria-label=\"Timeline\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e2024-11-04: Bug bounty report demonstrating an authentication bypass was reported against a GitHub test environment evaluating ruby-saml for SAML authentication.  \u003c/li\u003e\n\u003cli\u003e2024-11-04: Work started to identify and test potential mitigations.  \u003c/li\u003e\n\u003cli\u003e2024-11-12: A second authentication bypass was found by Peter that renders the planned mitigations for the first useless.  \u003c/li\u003e\n\u003cli\u003e2024-11-13: Initial contact with Sixto Martín, maintainer of ruby-saml.  \u003c/li\u003e\n\u003cli\u003e2024-11-14: Both parser differentials are reported to ruby-saml, the maintainer responds immediately.  \u003c/li\u003e\n\u003cli\u003e2024-11-14: The work on potential patches by the maintainer and ahacker1 begins. (One of the initial ideas was to remove one of the XML parsers, but this was not feasible without breaking backwards compatibility).  \u003c/li\u003e\n\u003cli\u003e2025-02-04: ahacker1 proposes a non-backwards compatible fix.  \u003c/li\u003e\n\u003cli\u003e2025-02-06: ahacker1 also proposes a backwards compatible fix.  \u003c/li\u003e\n\u003cli\u003e2025-02-12: The 90 days deadline of GitHub Security Lab advisories ends.  \u003c/li\u003e\n\u003cli\u003e2025-02-16: The maintainer starts working on a fix with the idea to be backwards-compatible and easier to understand.  \u003c/li\u003e\n\u003cli\u003e2025-02-17: Initial contact with GitLab to coordinate a release of their on-prem product with the release of the ruby-saml library.  \u003c/li\u003e\n\u003cli\u003e2025-03-12: A fixed version of ruby-saml was released.\u003c/li\u003e\n\u003c/ul\u003e\n\n\t\n\u003csection\u003e\n\t\u003chr/\u003e\n\t\u003cdiv\u003e\n\t\t\u003ch2\u003eTags:\u003c/h2\u003e\n\t\t\u003cul\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/authentication/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tauthentication\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/github-security-lab/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tGitHub Security Lab\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/ruby/\" rel=\"tag\"\u003e\n\t\t\t\t\t\truby\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/saml/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tSAML\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/vulnerability/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tvulnerability\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\u003c/ul\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/176818?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/176818?v=4\u0026amp;s=200\" alt=\"Peter Stöckli\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eSecurity Researcher at GitHub Security Lab\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2025-03-12T21:07:18Z",
  "modifiedTime": "2025-03-12T21:13:08Z"
}
