{
  "id": "60f59986-3bff-45c3-9b55-bde760f4cf2e",
  "title": "Fun with uv and PEP 723",
  "link": "https://www.cottongeeks.com/articles/2025-06-24-fun-with-uv-and-pep-723",
  "description": "Comments",
  "author": "",
  "published": "Tue, 24 Jun 2025 18:41:26 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 4231,
  "excerpt": "How to use uv and the Python inline script metadata proposal PEP 723 to run scripts seamlessly.",
  "siteName": "Cottongeeks",
  "favicon": "https://www.cottongeeks.com/apple-touch-icon.png",
  "text": "Fun with uv and PEP 723 June 24, 2025 For the longest time, I have been frustrated with Python because I couldn’t use it for one-off scripts. I had to first ensure it was running in an environment where it could find the right Python version and the dependencies installed. That is now a thing of the past. If you are not a Pythonista (or one possibly living under a rock), uv is an extremely fast Python package and project manager, written in Rust. uv also provides this nifty tool called uvx (kinda like npx from the Node/NPM ecosystem for Javascript/Typescript packages) which can be used to invoke a Python tool inside a package. uvx takes care of creating a (cached) disposable virtual environment, setting up the right Python version and installing all the dependencies before running. For example $ uvx ruff --version Installed 1 package in 5ms ruff 0.12.0 PEP 723 is a Python Enhancement Proposal that specifies a metadata format that can be embedded in single-file Python scripts to assist launchers, IDEs and other external tools which may need to interact with such scripts. Here is the example directly lifted from the proposal: # /// script # requires-python = \"\u003e=3.11\" # dependencies = [ # \"requests\u003c3\", # \"rich\", # ] # /// import requests from rich.pretty import pprint resp = requests.get(\"https://peps.python.org/api/peps.json\") data = resp.json() pprint([(k, v[\"title\"]) for k, v in data.items()][:10]) Combining uv and the PEP-723 metadata inside a Python script, we can run the script in the previous section as follows: $ uv run pep.py Installed 9 packages in 24ms [ │ ('1', 'PEP Purpose and Guidelines'), │ ('2', 'Procedure for Adding New Modules'), │ ('3', 'Guidelines for Handling Bug Reports'), │ ('4', 'Deprecation of Standard Modules'), │ ('5', 'Guidelines for Language Evolution'), │ ('6', 'Bug Fix Releases'), │ ('7', 'Style Guide for C Code'), │ ('8', 'Style Guide for Python Code'), │ ('9', 'Sample Plaintext PEP Template'), │ ('10', 'Voting Guidelines') ] We can combine things we covered in the previous sections to create a simple executable script that can extract YouTube transcripts. First we create a Python script with a shebang and inline metadata. #!/usr/bin/env -S uv run --script # /// script # requires-python = \"\u003e=3.8\" # dependencies = [ # \"youtube-transcript-api\", # ] # /// import sys import re from youtube_transcript_api import YouTubeTranscriptApi from youtube_transcript_api.formatters import TextFormatter if len(sys.argv) \u003c 2: print('Usage: provide YouTube URL or video_id as argument', file=sys.stderr) sys.exit(1) url_or_id = sys.argv[1] # Extract video ID from URL if it's a full URL video_id_match = re.search(r'(?:v=|/)([a-zA-Z0-9_-]{11})', url_or_id) if video_id_match: video_id = video_id_match.group(1) else: # Assume it's already a video ID video_id = url_or_id try: ytt_api = YouTubeTranscriptApi() transcript = ytt_api.fetch(video_id) formatter = TextFormatter() print(formatter.format_transcript(transcript)) except Exception as e: print(f'Error: {e}', file=sys.stderr) sys.exit(1) Note the shebang line: #!/usr/bin/env -S uv run --script. It is important to specify uv run with the --script flag when used on the shebang line. We save this script as ytt and then make it executable with chmod +x ytt. We can now run the script like: $ ./ytt https://www.youtube.com/watch?v=zgSQr0d5EVg Installed 7 packages in 10ms hey it's Matt here and today I'm going to show you how to use UV not only to install packages in your python projects but to manage entire projects to create virtual environments and even how to manage entire versions of python with UV uh and hopefully you'll understand by any of this video UV is a dropin …\u003csnipped text\u003e… Fun times This opens up a lot of possibilities for running Python code more seamlessly. Before this I used to prefer Go for one-off scripts because it was easy to create a self-contained binary executable. But now that I could use uv, I coded up a quick MCP server in Python for extracting YouTube transcripts. Check it out on Github at cottongeeks/ytt-mcp. More resources Running scripts | uv Tools | uv Using uv as an installer | aider",
  "image": "https://www.cottongeeks.com/android-chrome-512x512.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e              \u003ch2\u003e Fun with uv and PEP 723 \u003ctime datetime=\"2025-06-24T00:00:00.000Z\"\u003e June 24, 2025 \u003c/time\u003e \u003c/h2\u003e  \u003cp\u003eFor the longest time, I have been frustrated with Python because I couldn’t use it for one-off scripts. I had to first ensure it was running in an environment where it could find the right Python version and the dependencies installed. That is now a thing of the past.\u003c/p\u003e\n\n\u003cp\u003eIf you are not a Pythonista (or one possibly living under a rock), \u003ca href=\"https://docs.astral.sh/uv/\"\u003euv\u003c/a\u003e is \u003cem\u003ean extremely fast Python package and project manager, written in Rust.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003euv also provides this nifty tool called \u003ccode\u003euvx\u003c/code\u003e (kinda like \u003ccode\u003enpx\u003c/code\u003e from the Node/NPM ecosystem for Javascript/Typescript packages) which can be used to invoke a Python tool inside a package. \u003ccode\u003euvx\u003c/code\u003e takes care of creating a (cached) disposable virtual environment, setting up the right Python version and installing all the dependencies before running.\u003c/p\u003e\n\u003cp\u003eFor example\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"plaintext\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ uvx ruff --version\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eInstalled 1 package in 5ms\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eruff 0.12.0\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://peps.python.org/pep-0723/\"\u003ePEP 723\u003c/a\u003e is a Python Enhancement Proposal that \u003cem\u003especifies a metadata format that can be embedded in single-file Python scripts to assist launchers, IDEs and other external tools which may need to interact with such scripts.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eHere is the example directly lifted from the proposal:\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"python\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e# /// script\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# requires-python = \u0026#34;\u0026gt;=3.11\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# dependencies = [\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#   \u0026#34;requests\u0026lt;3\u0026#34;,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#   \u0026#34;rich\u0026#34;,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# ]\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# ///\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e requests\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e rich.pretty \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e pprint\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eresp \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e requests.get(\u003c/span\u003e\u003cspan\u003e\u0026#34;https://peps.python.org/api/peps.json\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003edata \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e resp.json()\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003epprint([(k, v[\u003c/span\u003e\u003cspan\u003e\u0026#34;title\u0026#34;\u003c/span\u003e\u003cspan\u003e]) \u003c/span\u003e\u003cspan\u003efor\u003c/span\u003e\u003cspan\u003e k, v \u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e\u003cspan\u003e data.items()][:\u003c/span\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCombining uv and the PEP-723 metadata inside a Python script, we can run the script in the previous section as follows:\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"plaintext\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ uv run pep.py\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eInstalled 9 packages in 24ms\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e[\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e│   (\u0026#39;1\u0026#39;, \u0026#39;PEP Purpose and Guidelines\u0026#39;),\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e│   (\u0026#39;2\u0026#39;, \u0026#39;Procedure for Adding New Modules\u0026#39;),\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e│   (\u0026#39;3\u0026#39;, \u0026#39;Guidelines for Handling Bug Reports\u0026#39;),\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e│   (\u0026#39;4\u0026#39;, \u0026#39;Deprecation of Standard Modules\u0026#39;),\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e│   (\u0026#39;5\u0026#39;, \u0026#39;Guidelines for Language Evolution\u0026#39;),\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e│   (\u0026#39;6\u0026#39;, \u0026#39;Bug Fix Releases\u0026#39;),\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e│   (\u0026#39;7\u0026#39;, \u0026#39;Style Guide for C Code\u0026#39;),\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e│   (\u0026#39;8\u0026#39;, \u0026#39;Style Guide for Python Code\u0026#39;),\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e│   (\u0026#39;9\u0026#39;, \u0026#39;Sample Plaintext PEP Template\u0026#39;),\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e│   (\u0026#39;10\u0026#39;, \u0026#39;Voting Guidelines\u0026#39;)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e]\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can combine things we covered in the previous sections to create a simple executable script that can extract YouTube transcripts.\u003c/p\u003e\n\u003cp\u003eFirst we create a Python script with a shebang and inline metadata.\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"python\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e#!/usr/bin/env -S uv run --script\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# /// script\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# requires-python = \u0026#34;\u0026gt;=3.8\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# dependencies = [\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#     \u0026#34;youtube-transcript-api\u0026#34;,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# ]\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# ///\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e sys\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e re\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e youtube_transcript_api \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e YouTubeTranscriptApi\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e youtube_transcript_api.formatters \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e TextFormatter\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e len\u003c/span\u003e\u003cspan\u003e(sys.argv) \u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    print\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Usage: provide YouTube URL or video_id as argument\u0026#39;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003efile\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003esys.stderr)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    sys.exit(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eurl_or_id \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e sys.argv[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# Extract video ID from URL if it\u0026#39;s a full URL\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003evideo_id_match \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e re.search(\u003c/span\u003e\u003cspan\u003er\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e(?:\u003c/span\u003e\u003cspan\u003ev=\u003c/span\u003e\u003cspan\u003e|\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e)([a-zA-Z0-9_-]\u003c/span\u003e\u003cspan\u003e{11}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e, url_or_id)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e video_id_match:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    video_id \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e video_id_match.group(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    # Assume it\u0026#39;s already a video ID\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    video_id \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e url_or_id\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003etry\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    ytt_api \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e YouTubeTranscriptApi()\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    transcript \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e ytt_api.fetch(video_id)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    formatter \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e TextFormatter()\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    print\u003c/span\u003e\u003cspan\u003e(formatter.format_transcript(transcript))\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eexcept\u003c/span\u003e\u003cspan\u003e Exception\u003c/span\u003e\u003cspan\u003e as\u003c/span\u003e\u003cspan\u003e e:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    print\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e\u0026#39;Error: \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003efile\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003esys.stderr)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    sys.exit(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the shebang line: \u003ccode\u003e#!/usr/bin/env -S uv run --script\u003c/code\u003e. It is important to specify \u003ccode\u003euv run\u003c/code\u003e with the \u003ccode\u003e--script\u003c/code\u003e flag when used on the shebang line.\u003c/p\u003e\n\u003cp\u003eWe save this script as \u003ccode\u003eytt\u003c/code\u003e and then make it executable with \u003ccode\u003echmod +x ytt\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe can now run the script like:\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"plaintext\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ ./ytt https://www.youtube.com/watch?v=zgSQr0d5EVg\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eInstalled 7 packages in 10ms\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ehey it\u0026#39;s Matt here and today I\u0026#39;m going\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eto show you how to use UV not only to\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003einstall packages in your python projects\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ebut to manage entire projects to create\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003evirtual environments and even how to\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003emanage entire versions of python with UV\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003euh and hopefully you\u0026#39;ll understand by\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eany of this video UV is a dropin\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e…\u0026lt;snipped text\u0026gt;…\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"fun-times\"\u003eFun times\u003c/h2\u003e\n\u003cp\u003eThis opens up a lot of possibilities for running Python code more seamlessly. Before this I used to prefer \u003ca href=\"https://go.dev/\"\u003eGo\u003c/a\u003e for one-off scripts because it was easy to create a self-contained binary executable. But now that I could use uv, I coded up a quick MCP server in Python for extracting YouTube transcripts. Check it out on Github at \u003ca href=\"https://github.com/cottongeeks/ytt-mcp\"\u003ecottongeeks/ytt-mcp\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"more-resources\"\u003eMore resources\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.astral.sh/uv/guides/scripts/#using-a-shebang-to-create-an-executable-file\"\u003eRunning scripts | uv\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.astral.sh/uv/concepts/tools/\"\u003eTools | uv\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://aider.chat/2025/01/15/uv.html\"\u003eUsing uv as an installer | aider\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e   \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
