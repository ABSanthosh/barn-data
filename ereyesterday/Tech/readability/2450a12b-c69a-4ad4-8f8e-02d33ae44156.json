{
  "id": "2450a12b-c69a-4ad4-8f8e-02d33ae44156",
  "title": "Apple Exclaves",
  "link": "https://randomaugustine.medium.com/on-apple-exclaves-d683a2c37194",
  "description": "Comments",
  "author": "",
  "published": "Sun, 09 Mar 2025 22:38:57 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Random Augustine",
  "length": 28397,
  "excerpt": "Modern operating systems typically divide their operations into two main protection domains: the unprivileged domain (user mode) and the privileged domain (kernel mode). Software spends most of its…",
  "siteName": "Medium",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "The Issue with Monolithic Operating System KernelsModern operating systems typically divide their operations into two main protection domains: the unprivileged domain (user mode) and the privileged domain (kernel mode). Software spends most of its time running in user mode, where it is restricted from directly performing powerful operations such as accessing files or communicating on a network. To carry out these actions, software must temporarily elevate to kernel mode by making a system call, which is a request to the kernel to take over and perform the desired operation. For example, when a program wants to open a file, it makes a system call which switches the program to running kernel code in kernel mode. The kernel code verifies the program is allowed to access that file, and then returns a special handle representing the now opened file back to the program in user mode.Most operating systems use a monolithic kernel design, where the kernel has unrestricted access to the entire system — all hardware, memory, and user data. In an ideal world, where software is flawless and no one attempts to compromise security, this design may be satisfactory. However, software often contains bugs, and some of those bugs lead to security vulnerabilities. Given that monolithic kernels are large, they present more opportunities for these vulnerabilities to arise and be exploited. Once a vulnerability is successfully exploited, it can lead to a complete system compromise, as all the operating system’s functions are bundled together in the kernel’s single “basket of eggs”.An alternative kernel design, known as a microkernel, minimizes the functions within the kernel itself, pushing most operations into separate, unprivileged processes. This can improve security by isolating potential vulnerabilities. However, microkernels can suffer from performance issues, and push extra complexity onto the application software. As a result, monolithic kernels remain prevalent, and the vulnerabilities associated with them continue to be a problem.The kernel shared in common between iOS, macOS, tvOS, visionOS and watchOS — named XNU — is based on a microkernel called Mach. However, the way XNU has been implemented places all system functions within the same privileged scope and it effectively operates as a monolithic kernel. The XNU kernel, like all monolithic kernels, suffers from unfortunately common vulnerability discoveries.Isolation EffortsOver the years, a variety of software and hardware-based mitigations have been developed to isolate some parts systems from their more vulnerable monolithic kernels. Below are some notable non-Apple examples:Microsoft Virtualisation-based Security (VBS) used for Credential Guard in WindowsIntel Software Guard Extension (SGX) and VT-X2ARM TrustZone — Powers features like Samsung Knox, Samsung Pay, Android Verified Boot, Android secure PIN entryApple has also increasingly attempted to isolate data from the kernel and these are covered below.2013 — Apple Secure EnclaveIn 2013 Apple released the iPhone 5s, the first iPhone containing a Secure Enclave. The Secure Enclave is implemented on a dedicated, hardened CPU core running a microkernel-based OS called SepOS. The underlying kernel in SepOS is cL4, Apple’s custom version of the L4-embedded microkernel. The Secure Enclave is used to store and protect sensitive data like encryption keys and biometric information (e.g., Face ID). The Secure Enclave operates independently of the iOS kernel and only provides its services to iOS through controlled, secure interactions. Even if the iOS kernel is compromised, the Secure Enclave remains largely unaffected unless an additional exploit targets it.Do not confuse the Secure Enclave with the subject of this article, Secure Exclaves!2017 — Page Protection LayerWith the release of the iPhone 8 and iPhone X containing the A11 processor, Apple introduced a security feature known as the Page Protection Layer (PPL). This hardware+software feature isolated a small part of the kernel and gave it privileges to modify memory page tables — critical structures that manage memory access. The rest of the kernel lost the ability to directly modify these page tables. The PPL’s limited attack surface ensured that bypasses were infamously rare. While PPL added a layer of protection, it was only partly effective as the rest of the kernel still held most privileges required to compromise data without modifying page tables.2021–2023 — Secure Page Table MonitorFollowing PPL, the release of the iPhone 13 containing the A15 processor introduced new functionality utilised in iOS 17: the Secure Page Table Monitor (SPTM). This replaced and improved upon the PPL by securing additional memory functions and dividing them into subsystems, further isolating small kernel components. Validation of code signatures, confirming that all code had been signed by Apple was also isolated.Around this time, oblique references to exclaves began to surface in XNU source code. These exclaves were speculated to be the subsystems managed by SPTM. Then 2024 happened…2024 — Exclaves: A major addition to XNUWith the release of XNU source code supporting M4 and A18 based systems (such as the iPhone 16), the curtain was partly pulled back on exclaves. (Exclaves are not active on prior processors).It is now clear that exclaves are part of a much larger redesign of XNU’s security model.XNU ExclavesDisclaimer: This analysis will not be 100% correct — many parts of exclaves aren’t open sourced and their inner workings are only inferred or I am speculating.Conclave of 2005: White smoke indicates a new Pope has been elected; in this case Pope Benedictus XVIExclaves are a new set of features that represent a significant enhancement for XNU’s traditional monolithic kernel. Exclaves refer to resources that are isolated from XNU, protected even if the kernel is compromised. These resources are pre-defined when the OS is built, are identified by name or id, have different types, are initialised at boot time, and are organized into unique domains. SPTM protects exclave memory from XNU with new exclave-specific page types. Types of resources include:Shared memory buffers that can be accessed by both the kernel and the exclave, with the option to make them read-only or read-write to XNU.Audio buffers and sensors that are used for securing features like the camera and microphone access indicators.Conclaves that group multiple resources into their own secure domains and their corresponding Conclave ManagersServices that can execute code within the exclave space when called upon by threads in XNU.Threads change context between different privilege levels and worldsSecure Kernel — seL4?To allow for execution of exclave Services while isolated from XNU, Apple has introduced a new kernel called the Secure Kernel (SK). The SK image file contains a version string for “cL4”. While I have not attempted to disassemble SK, there are many indications that it is based on the seL4 kernel despite the “cL4” name. The IPC structures used by XNU to communicate with SK closely align with seL4 rather than L4-embedded used for the original SepOS cL4 kernel. Strings in SK frequently mention capabilities, frames, untyped memory, minting, and so on which are also more closely aligned with seL4.Perhaps it isn’t a coincidence that the seL4 Foundation publicly announced that Apple had joined in April 2024. Incidentally, the kernel for the C1 processor, Apple’s new baseband chip, is also based on some version of L4 so Apple is heavily invested in this space.Secure Worlds — ARM TrustZone?As previously mentioned, SepOS runs on a dedicated processor for maximum isolation. In contrast, SK runs on the same high speed application processors as XNU/iOS. To make this possible, additional processor privilege levels are required — likely supported by virtualization extensions, Apple specific additions to SPTM, or most likely via ARM’s TrustZone technology. The XNU source code contains several references regarding transitions to and from TrustZone’s concept of a secure world, and it would be the cleanest implementation method.TrustZone divides the system into two worlds: the Secure World and the Insecure World. ARM provides several design patterns for TrustZone, and Apple appear to have been influenced by these. XNU (and iOS) run in the insecure world while SK operates in the secure world. SK provides a limited operating environment for exclaves, resources and services, differing from the Trusted Applications design pattern suggested by ARM. Given the isolated nature of exclave services and the limited attack surface of the Secure Kernel, escaping from the secure world to compromise XNU is likely to be much more difficult than exploiting it directly from the insecure world.Apple may use SPTM to manage transitions between the secure and insecure worlds, though this is speculation on my part, as it is not open-sourced so disassembly of the binaries is required. The code refers to this transition as a RINGGATE.A Deeper DiveDomains and ResourcesXNU initialises a two-level kernel table structure to hold information on exclave resources discovered during boot. Each resource is exclusively of one resource type and holds information on a resource that exists in the secure world, or in both worlds.The root_table identifies domains by name, with each domain referencing a second level table holding all the resources for that domain. Domains and their resources discovered so far include:com.apple.kernel — this domain contains many resources used by the kernel including:com.apple.service.ConclaveLauncherControl — conclave launcher servicecom.apple.service.ConclaveLauncher_Debug — debug servicecom.apple.service.ExclaveIndicatorController — service for secure indicator lightscom.apple.service.LogServer_XNUProxy — service for loggingcom.apple.service.FrameMint — service used to boot ExclaveKitcom.apple.storage.backend — Shared memory buffer used by exclave services to do file IO from XNU space via upcalls (more details below)Conclave Manager x — One per conclave, used to control a conclaveConclave Manager y …com.apple.darwin — No open-source components use this domaincom.apple.conclave.name — There is one domain per conclave.service_xservice_yaudio buffershared memory bufferetccom.apple.driver.name — One domain per device driver — existence of these domains is based on comments, not actually seen in open-sourced code. I suspect these are just per-driver conclaves.ConclavesA conclave is a type of resource that itself can contain multiple resources. However, it is much more than just a container of resources. Conclaves allow a group of services and other resources to have shared access to each other, and Mach tasks are limited in what (if any) conclaves they can call upon.Each conclave has a Conclave Manager (another type of exclave resource), located in the kernel domain.Conclaves have a lifecycle, whereby their Conclave Manager is first attached to a Mach task, and are then launched. They can also be stopped and detached. States such as launching and stopping exist during transitions in the lifecycle.Conclaves — Spawning and AttachingThe XNU posix_spawn() function can call task_add_conclave() to attach a task and a conclave manager resource together. This is a 1:1 relationship — only one task can be attached to a conclave manager and vice versa. Only launchd and tasks with the com.apple.private.exclaves.conclave-spawn entitlement may spawn a conclave. The com.apple.private.exclaves.conclave-host entitlement is largely similar, but I believe only entitles a task to attach itself, rather than being able to spawn a new task for this purpose.The kernel looks up the associated conclave manager resource for the targeted conclave in the com.apple.kernel domain. It then saves a tightbeam endpoint to the conclave manager’s endpoint in the conclave’s resource struct. This endpoint is where all future control of the conclave is directed. Tightbeam appears to be an RPC framework for communication between exclave components.Note this attachment is to a task — not a thread. Execution of services will be covered later.Conclave manager tasks are not allowed to have kernel domain privileges.Conclaves — LaunchingOnce attached, a conclave may be launched. The launch attempt must be performed from the conclave manager task attached to the conclave. Attempts to launch conclaves also wait until exclaves have fully booted (into state EXCLAVES_BS_BOOTED_EXCLAVEKIT — more on this later).A new mach trap (ie system call) for exclave functionality has been added to XNU and ends up in the _exclaves_ctl_trap() function. This call is overloaded and can perform different operations passed in as parameters. The relevant operation to launch a conclave is EXCLAVES_CTL_OP_LAUNCH_CONCLAVE.The launch operation calls a redacted function, conclave_launcher_conclavecontrol_launch() and passes it the tightbeam connection to the conclave manager to perform the launch. I suspect this requests the initialisation of executable code and resources for the conclave within the secure world.In production, conclave hosts can be tainted when launched, and an exit() may then cause a kernel panic.A New Mach Trap / System CallAs mentioned, the _exclaves_ctl_trap() function handles a new Mach trap for exclave functionality. The call is overloaded, with its action dependent on an operation parameter, and it generally verifies entitlements to the operations called. The operations are:EXCLAVES_CTL_OP_BOOT — Called twice during the system boot process — firstly to start exclaves boot stage 2, and then to boot stage ExclaveKit. The caller must be launchd or have the com.apple.private.exclaves.boot entitlement.All operations below, at minimum, require the current task to have the com.apple.private.exclaves.kernel-domain entitlement, or be the relevant conclave manager taskEXCLAVES_CTL_OP_LAUNCH_CONCLAVE — launch a conclave, discussed earlierEXCLAVES_CTL_OP_LOOKUP_SERVICES — lookup an exclave service and copy its struct to a userspace buffer. First it looks in the exclave domain of the current task, if that fails it checks the Darwin domain followed by kernel domain — if it is entitled to do soEXCLAVES_CTL_OP_ENDPOINT_CALL — calls the endpoint for an exclave service in the current task’s domain — this will result in the current thread switching from kernel mode to the secure world and executing specific code thereEXCLAVES_CTL_OP_NAMED_BUFFER_CREATE — create a named buffer resourceEXCLAVES_CTL_OP_NAMED_BUFFER_COPYIN — copy data from a userspace buffer to a kernel buffer (that is shared with exclaves)EXCLAVES_CTL_OP_NAMED_BUFFER_COPYOUT — copy data from a kernel buffer (that is shared with exclaves) to a userspace bufferEXCLAVES_CTL_OP_AUDIO_BUFFER_CREATE — can an audio bufferEXCLAVES_CTL_OP_AUDIO_BUFFER_COPYOUT — copy data from audio buffer to userspace bufferEXCLAVES_CTL_OP_SENSOR_CREATE — create a sensor resource (eg. camera, microphone)EXCLAVES_CTL_OP_SENSOR_STARTEXCLAVES_CTL_OP_SENSOR_STOPEXCLAVES_CTL_OP_SENSOR_STATUSEXCLAVES_CTL_OP_NOTIFICATION_RESOURCE_LOOKUP — create a notification resource — TBD, but likely for coordination/schedulingDowncalls — running code in the secure worldDowncalls are calls to exclave Services’ endpoints in the secure world — this is where secure world code execution happens.There is a great deal of complexity in these calls, primarily around managing thread/IPC contexts and scheduling the current thread to execute code in the secure world.Downcalls switch the current thread into the secure world and start executing at an entry point in secure code, rather than asking some other thread to perform work on behalf of the current thread.Calling tasks must have kernel domain entitlements or be the conclave manager task attached to the service’s conclave.Conclaves have a maximum of 128 services that can be calledIt appears that threads are scheduled into the secure kernel (via the sk_enter() function) by XNU. XNU appears to handle the scheduling of all threads in the secure world, with SK potentially not having any independent threads of its own.A thread executing in the secure world can perform a temporary upcall to XNU, which returns the thread to kernel mode for the upcall, before a mandatory return back to the secure world context. More detail on upcalls will be provided further below.Threads executing in the secure world can do normal scheduler type things like yield, wait, be suspended, or be interrupted. When this happens, the thread leaves the secure world and returns to the XNU kernel context. From there it must be rescheduled back into the secure world by exclave scheduling code in XNU. The thread will continue to be rescheduled into the secure world as necessary until the downcall is completed.If a secure world thread is panic()ing on a CPU core (which will call on XNU to panic via SPTM), fresh tasks are no longer scheduled into the secure world on other cores and they wait for a timeout period. If everything goes correctly, the waiting threads will never finish their wait. However if the timeout expires, the waiting threads will then … panic() :)XNU appears to handle all interrupt processing, rather than SK. When XNU is finished handling an interrupt, the interrupted thread is returned to the secure world if it was executing there. Directing interrupts to either the insecure or secure kernel is an ARM TrustZone feature.IPC structures for the downcall are setup with request and response buffers before entering the secure world through the redacted sk_enter() call.Interrupts and pre-emption are disabled while finalising the IPC request structure and calling sk_enter(). This is because there is only one of these structures per core. I suspect the redacted path travelled after calling sk_enter() and entering the secure world copies the request from the per-cpu structure into secure world memory, and then re-enables interrupts and pre-emption on the core. The alterative would be ugly. A similar process happens in reverse for protecting the per-cpu response structure.Disconcertingly, the downcall response can come back via a different CPU’s per-core response buffer, as the downcall may have been interrupted, upcalled, or yielded and needed rescheduling.Coordination of a thread’s exclave status (to avoid SK re-entry etc) occurs via th_exclaves_state — a bitfield in the thread structure.Upcalls — Secure World calls to XNUA thread running in the secure world due to a downcall may need assistance from XNU and this can be achieved through an upcall to the exclaves upcall handler via the Tightbeam framework. Upcalls are limited to specific functions within XNU. A thread desiring an upcall returns to the insecure world where the specific upcall handler is called. While in this state, the thread cannot return to user mode (for obvious reasons) nor perform another downcall to the secure world, ie it is not allowed to “re-enter” exclaves. Instead the thread will be returned to the secure world at the point where it performed the upcall.Allowed upcalls discovered in the source end up inside the following functions:Memoryexclaves_memory_upcall_alloc(npages, kind, completion);exclaves_memory_upcall_free(pages, npages, kind, completion);File storageexclaves_storage_upcall_root(exclaveid, completion);exclaves_storage_upcall_open(fstag, rootid, name, completion);exclaves_storage_upcall_close(fstag, fileid, completion);exclaves_storage_upcall_create(fstag, rootid, name, completion);exclaves_storage_upcall_read(fstag, fileid, descriptor, completion);exclaves_storage_upcall_write(fstag, fileid, descriptor, completion);exclaves_storage_upcall_remove(fstag, rootid, name, completion);exclaves_storage_upcall_sync(fstag, op, fileid, completion);exclaves_storage_upcall_readdir(fstag, fileid, buf, length, completion);exclaves_storage_upcall_getsize(fstag, fileid, completion);exclaves_storage_upcall_sealstate(fstag, completion);DriverKitexclaves_driverkit_upcall_irq_register(id, index, completion);exclaves_driverkit_upcall_irq_remove(id, index, completion);exclaves_driverkit_upcall_irq_enable(id, index, completion);exclaves_driverkit_upcall_irq_disable(id, index, completion);exclaves_driverkit_upcall_timer_register(id, completion);exclaves_driverkit_upcall_timer_remove(id, timer_id, completion);exclaves_driverkit_upcall_timer_enable(id, timer_id, completion);exclaves_driverkit_upcall_timer_disable(id, timer_id, completion);exclaves_driverkit_upcall_timer_set_timeout(id, timer_id, duration,completion);exclaves_driverkit_upcall_timer_cancel_timeout(id, timer_id, completion);exclaves_driverkit_upcall_lock_wl(id, completion);exclaves_driverkit_upcall_unlock_wl(id, completion);exclaves_driverkit_upcall_async_notification_signal(id, notificationID, completion);exclaves_driverkit_upcall_mapper_activate(id,mapperIndex, completion);exclaves_driverkit_upcall_mapper_deactivate(id, mapperIndex, completion);exclaves_driverkit_upcall_notification_signal(id, mask, completion);DriverKit Apple Neural Engineexclaves_driverkit_upcall_ane_setpowerstate(id, desiredState, completion);exclaves_driverkit_upcall_ane_worksubmit(id, requestID, taskDescriptorCount, submitTimestamp, completion);exclaves_driverkit_upcall_ane_workbegin(id, requestID, beginTimestamp, completion);exclaves_driverkit_upcall_ane_workend(id, requestID, completion);Conclavesexclaves_conclave_upcall_suspend(flags, completion);exclaves_conclave_upcall_stop(flags, completion);exclaves_conclave_upcall_crash_info(shared_buf, length, completion);The XNUProxyReferences to XNUProxy abound, yet I haven’t been able to definitely pin down exactly what and where it is. Options I have considered include:It’s an exclave domain of its own, something like com.apple.xnuproxyIt’s an exclave service or bunch of services that runs in the com.apple.kernel domain, serving particular types of downcalls.It’s a subsystem in SPTM for making downcalls to the secure world…Comments in Exclaves_L4.h state that the XNU Proxy makes the following exclaves reachable (aside from testing ones, usually featuring the word “HELLO” in them):EXCLAVES_XNUPROXY_EXCLAVE_USERAPP/2/3 (templated user app…)EXCLAVES_XNUPROXY_EXCLAVE_AUDIODRIVEREXCLAVES_XNUPROXY_EXCLAVE_EXCLAVEDRIVERKITEXCLAVES_XNUPROXY_EXCLAVE_SECURERTBUDDY_AOP (RT Buddy for Always On Processor)EXCLAVES_XNUPROXY_EXCLAVE_SECURERTBUDDY_DCP (for Display Coprocessor)EXCLAVES_XNUPROXY_EXCLAVE_CONCLAVECONTROL (conclave launcher control)EXCLAVES_XNUPROXY_EXCLAVE_CONCLAVEDEBUGEXCLAVES_XNUPROXY_EXCLAVE_SECURERTBUDDY_AOP_EDK (ExclaveDriverKit connection for Always On Processor)EXCLAVES_XNUPROXY_EXCLAVE_SECURERTBUDDY_DCP_EDK (ExclaveDriverKit connection for Display CoProcessor)Note RTBuddys are for communicating with RTKit, yet another Apple Operating System, that runs on the Display Coprocessor, Apple Neural Engine, NVMe controller, SMC Controller, Smart Keyboards, Siri Remote, Apple Pencil, AirPods, AirTags… and I assume the AOP.Booting Stage 1Booting exclaves when the system is starting requires a delicately coordinated dance between the insecure and secure worlds. Anything going wrong usually ends up in a panic().Booting occurs in three stages. Stage one is not visible in the open-source, however is likely a secure boot process where SK is loaded into memory and its code signatures are verified before being made executable. At the end of a successful stage one boot, the boot status is EXCLAVES_BS_NOT_STARTED.Booting Stage 2Initialises upcall server by creating a tightbeam endpoint for upcallsEnters secure world with a special call to collect boot information from secure kernelEnters secure world again with normal endpoint call but not sure why… possibly to trigger the kernel domain to startInitialises the exclave schedulerInitialises the XrtHostedXNU kextInitialises callbacks (I think into the above kext)Boots the scheduler — sets up per-cpu request\u0026response for the boot CPU core only, and binds to the boot coreLoops, calling into the secure world to see if it needs memory allocations, until it responds that all exclaves are bootedInitialises multicore by setting up per-cpu request\u0026response memory for all coresInitialises XNU Proxy — creates a cache of buffers for IPC calls, creates some thread contexts, sets up a tightbeam endpoint for downcalls to the xnuproxyInitialises an exclaves panic kernel threadDiscovers all static exclave resources and builds the root_table of domains and resources.Creates tightbeam endpoints for all Conclave Manager resources and calls an initialisation process for each one.Populates a bitmap of valid conclave service ids (from 0 to 127) for each conclave.At kernel build time, a list of boot tasks was stored in the __DATA_CONST segment. These are now sorted by priority and each boot task function is called. I likely only have a very partial picture here, but these tasks include creating an endpoint for each of the exclave indicator controller service, the storage backend service, the logserver, and for stackshots.Boot status is now EXCLAVES_BS_BOOTED_STAGE_2Boot Stage 3 (Boot ExclaveKit)The stage makes multiple calls regarding “framemint”. This is suggestive of the SK being based on seL4.The “com.apple.service.FrameMint” service is looked up and a tightbeam endpoint is created for itA redacted function, framemint_framemint__init() is calledA redacted framemint_framemint_populate() function is called but I guess this will be triggering all sorts of exciting activity to happen in the secure worldBoot status is now EXCLAVES_BS_BOOTED_EXCLAVEKITSPTM memory typingSPTM “types” memory pages to control access to them via its different subsystems. Existing types included:XNU_USER_EXECXNU_USER_DEBUGXNU_USER_JITXNU_ROZONEXNU_KERNEL_RESTRICTED+Types for TXM, DART, etcExclaves have added:SK_DEFAULT (exclusive to SK — inaccessible to XNU)SK_IO (also exclusive to SK — inaccessible to XNU)SK_SHARED_RO (memory shared between SK and XNU (read only for XNU)SK_SHARED_RW (memory shared between SK and XNU (read+write for XNU)ConclusionsIn the face of continued exploitation by advanced threat actors, Apple’s implementation of Exclaves represents a large investment to add extra defence in depth to their operating systems. By isolating sensitive resources, Apple is shrinking their potential attack surface and reducing the impact of any single kernel compromise. Defending monolithic kernels is a Sisyphean task, and exclaves represent one method of dealing with the challenge — is it the right direction for the long term, or a temporary step? In my dreams, I imagine a future redesign using CHERI and a production implementation of ARM Morello 😊 Regardless, it’s a defensive effort on a larger scale than any other end user device manufacturer is currently attempting.Critically, this article has not directly examined what is being moved from the kernel into exclaves. Build images indicate they are being used for secure camera/microphone indicators, some Apple Neural Engine functionality, some device drivers, components that talk to the Secure Enclave and so on. There may be many components that will benefit from future migration to exclaves and the overall effectiveness of exclaves may depend on an ongoing effort to maximise their usage. Everything XNU outside of exclaves will still be fair game.I also suspect that exclaves may be used within Apple’s Private Cloud Compute infrastructure for cloud-based AI to provide a higher assurance of privacy in the face of external threats.I would particularly like to highlight the work of Dataflow Forensics and their much more advanced work dissecting SPTM without the benefit of source code. I enthusiastically await their promised blog post about exclaves and hope they will answer many of the remaining questions, provide gory disassembly explanations, and correct all my mistakes and assumptions!To do (by someone much smarter than me!)…ExclaveKit…ExclaveDriverKit…Where does the “XNUProxy” really fit in?Disassembly to determine how XNU switches to the secure world, and if this involves SPTM, and/or TrustZone…Almost everything about the Secure Kernel…Almost everything happening in the Secure World userspace…This analysis was based on Apple’s Open Source XNU build 11215.*AI was used to improve my poor writing skills in the introductory sections.",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*rdHSi6qkktm7TllSbRYQIA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://randomaugustine.medium.com/?source=post_page---byline--d683a2c37194---------------------------------------\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Random Augustine\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*JzVOzY_-CTbUeQaYyCEWqQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"37a1\"\u003eThe Issue with Monolithic Operating System Kernels\u003c/h2\u003e\u003cp id=\"294f\"\u003eModern operating systems typically divide their operations into two main protection domains: the \u003cem\u003eunprivileged domain\u003c/em\u003e (user mode) and the \u003cem\u003eprivileged domain\u003c/em\u003e (kernel mode). Software spends most of its time running in user mode, where it is restricted from directly performing powerful operations such as accessing files or communicating on a network. To carry out these actions, software must temporarily elevate to kernel mode by making a \u003cem\u003esystem call\u003c/em\u003e, which is a request to the kernel to take over and perform the desired operation. For example, when a program wants to open a file, it makes a system call which switches the program to running kernel code in kernel mode. The kernel code verifies the program is allowed to access that file, and then returns a special handle representing the now opened file back to the program in user mode.\u003c/p\u003e\u003cp id=\"ecd6\"\u003eMost operating systems use a \u003cem\u003emonolithic kernel\u003c/em\u003e design, where the kernel has unrestricted access to the entire system — all hardware, memory, and user data. In an ideal world, where software is flawless and no one attempts to compromise security, this design may be satisfactory. However, software often contains bugs, and some of those bugs lead to security vulnerabilities. Given that monolithic kernels are large, they present more opportunities for these vulnerabilities to arise and be exploited. Once a vulnerability is successfully exploited, it can lead to a complete system compromise, as all the operating system’s functions are bundled together in the kernel’s single “basket of eggs”.\u003c/p\u003e\u003cp id=\"3efb\"\u003eAn alternative kernel design, known as a \u003cem\u003emicrokernel\u003c/em\u003e, minimizes the functions within the kernel itself, pushing most operations into separate, unprivileged processes. This can improve security by isolating potential vulnerabilities. However, microkernels can suffer from performance issues, and push extra complexity onto the application software. As a result, monolithic kernels remain prevalent, and the vulnerabilities associated with them continue to be a problem.\u003c/p\u003e\u003cp id=\"3cab\"\u003eThe kernel shared in common between iOS, macOS, tvOS, visionOS and watchOS — named XNU — is based on a microkernel called Mach. However, the way XNU has been implemented places all system functions within the same privileged scope and it effectively operates as a monolithic kernel. The XNU kernel, like all monolithic kernels, suffers from unfortunately common vulnerability discoveries.\u003c/p\u003e\u003ch2 id=\"163d\"\u003eIsolation Efforts\u003c/h2\u003e\u003cp id=\"2632\"\u003eOver the years, a variety of software and hardware-based mitigations have been developed to isolate some parts systems from their more vulnerable monolithic kernels. Below are some notable non-Apple examples:\u003c/p\u003e\u003cul\u003e\u003cli id=\"321d\"\u003eMicrosoft Virtualisation-based Security (VBS) used for \u003cem\u003eCredential Guard \u003c/em\u003ein Windows\u003c/li\u003e\u003cli id=\"d52b\"\u003eIntel Software Guard Extension (SGX) and VT-X2\u003c/li\u003e\u003cli id=\"0d82\"\u003eARM TrustZone — Powers features like Samsung Knox, Samsung Pay, Android Verified Boot, Android secure PIN entry\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"364d\"\u003e\u003cem\u003eApple has also increasingly attempted to isolate data from the kernel and these are covered below.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"910e\"\u003e2013 — Apple Secure Enclave\u003c/h2\u003e\u003cp id=\"ebcc\"\u003eIn 2013 Apple released the iPhone 5s, the first iPhone containing a Secure Enclave. The Secure Enclave is implemented on a dedicated, hardened CPU core running a microkernel-based OS called \u003cem\u003eSepOS\u003c/em\u003e. The underlying kernel in SepOS is \u003cem\u003ecL4\u003c/em\u003e, Apple’s custom version of the L4-embedded microkernel. The Secure Enclave is used to store and protect sensitive data like encryption keys and biometric information (e.g., Face ID). The Secure Enclave operates independently of the iOS kernel and only provides its services to iOS through controlled, secure interactions. Even if the iOS kernel is compromised, the Secure Enclave remains largely unaffected unless an additional exploit targets it.\u003c/p\u003e\u003cp id=\"438a\"\u003eDo not confuse the Secure E\u003cstrong\u003en\u003c/strong\u003eclave with the subject of this article, Secure E\u003cstrong\u003ex\u003c/strong\u003eclaves!\u003c/p\u003e\u003ch2 id=\"ec46\"\u003e2017 — Page Protection Layer\u003c/h2\u003e\u003cp id=\"4afc\"\u003eWith the release of the iPhone 8 and iPhone X containing the A11 processor, Apple introduced a security feature known as the \u003cem\u003ePage Protection Layer (PPL)\u003c/em\u003e. This hardware+software feature isolated a small part of the kernel and gave it privileges to modify memory page tables — critical structures that manage memory access. The rest of the kernel lost the ability to directly modify these page tables. The PPL’s limited attack surface ensured that bypasses were infamously rare. While PPL added a layer of protection, it was only partly effective as the rest of the kernel still held most privileges required to compromise data without modifying page tables.\u003c/p\u003e\u003ch2 id=\"5b0b\"\u003e2021–2023 — Secure Page Table Monitor\u003c/h2\u003e\u003cp id=\"9c23\"\u003eFollowing PPL, the release of the iPhone 13 containing the A15 processor introduced new functionality utilised in iOS 17: the \u003cem\u003eSecure Page Table Monitor\u003c/em\u003e (SPTM). This replaced and improved upon the PPL by securing additional memory functions and dividing them into subsystems, further isolating small kernel components. Validation of code signatures, confirming that all code had been signed by Apple was also isolated.\u003c/p\u003e\u003cp id=\"861b\"\u003eAround this time, oblique references to \u003cem\u003eexclaves\u003c/em\u003e began to surface in XNU source code. These exclaves were speculated to be the subsystems managed by SPTM. Then 2024 happened…\u003c/p\u003e\u003ch2 id=\"1e82\"\u003e2024 — Exclaves: A major addition to XNU\u003c/h2\u003e\u003cp id=\"7a85\"\u003eWith the release of XNU source code supporting M4 and A18 based systems (such as the iPhone 16), the curtain was partly pulled back on exclaves. (Exclaves are \u003cem\u003enot\u003c/em\u003e active on prior processors).\u003c/p\u003e\u003cp id=\"9904\"\u003e\u003cem\u003eIt is now clear that exclaves are part of a much larger redesign of XNU’s security model.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5029\"\u003eXNU Exclaves\u003c/h2\u003e\u003cp id=\"6fc0\"\u003e\u003cem\u003eDisclaimer: This analysis will not be 100% correct — many parts of exclaves aren’t open sourced and their inner workings are only inferred or I am speculating.\u003c/em\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eConclave of 2005: White smoke indicates a new Pope has been elected; in this case Pope Benedictus XVI\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"fa62\"\u003eExclaves are a new set of features that represent a significant enhancement for XNU’s traditional monolithic kernel. Exclaves refer to resources that are isolated from XNU, protected even if the kernel is compromised. These resources are pre-defined when the OS is built, are identified by name or id, have different types, are initialised at boot time, and are organized into unique domains. SPTM protects exclave memory from XNU with new exclave-specific page types. Types of resources include:\u003c/p\u003e\u003cul\u003e\u003cli id=\"6a35\"\u003e\u003cem\u003eShared memory buffers \u003c/em\u003ethat can be accessed by both the kernel and the exclave, with the option to make them read-only or read-write to XNU.\u003c/li\u003e\u003cli id=\"b491\"\u003e\u003cem\u003eAudio buffers\u003c/em\u003e and \u003cem\u003esensors\u003c/em\u003e that are used for securing features like the camera and microphone access indicators.\u003c/li\u003e\u003cli id=\"fbc6\"\u003e\u003cem\u003eConclaves\u003c/em\u003e that group multiple resources into their own secure domains and their corresponding \u003cem\u003eConclave Managers\u003c/em\u003e\u003c/li\u003e\u003cli id=\"a21a\"\u003e\u003cem\u003eServices\u003c/em\u003e that can execute code within the exclave space when called upon by threads in XNU.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003eThreads change context between different privilege levels and worlds\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"b3dc\"\u003eSecure Kernel — seL4?\u003c/h2\u003e\u003cp id=\"0de0\"\u003eTo allow for execution of exclave Services while isolated from XNU, Apple has introduced a new kernel called the Secure Kernel (SK). The SK image file contains a version string for “cL4”. While I have not attempted to disassemble SK, there are many indications that it is based on the seL4 kernel despite the “cL4” name. The IPC structures used by XNU to communicate with SK closely align with seL4 rather than L4-embedded used for the original SepOS cL4 kernel. Strings in SK frequently mention capabilities, frames, untyped memory, minting, and so on which are also more closely aligned with seL4.\u003c/p\u003e\u003cp id=\"bfb2\"\u003ePerhaps it isn’t a coincidence that the seL4 Foundation publicly announced that Apple had joined in April 2024. Incidentally, the kernel for the C1 processor, Apple’s new baseband chip, is also based on some version of L4 so Apple is heavily invested in this space.\u003c/p\u003e\u003ch2 id=\"d6ec\"\u003eSecure Worlds — ARM TrustZone?\u003c/h2\u003e\u003cp id=\"1ac5\"\u003eAs previously mentioned, SepOS runs on a dedicated processor for maximum isolation. In contrast, SK runs on the same high speed application processors as XNU/iOS. To make this possible, additional processor privilege levels are required — likely supported by virtualization extensions, Apple specific additions to SPTM, or most likely via ARM’s \u003cem\u003eTrustZone\u003c/em\u003e technology. The XNU source code contains several references regarding transitions to and from TrustZone’s concept of a \u003cem\u003esecure world\u003c/em\u003e, and it would be the cleanest implementation method.\u003c/p\u003e\u003cp id=\"3892\"\u003eTrustZone divides the system into two worlds: the \u003cem\u003eSecure World\u003c/em\u003e and the \u003cem\u003eInsecure World\u003c/em\u003e. ARM provides several design patterns for TrustZone, and Apple appear to have been influenced by these. XNU (and iOS) run in the insecure world while SK operates in the secure world. SK provides a limited operating environment for exclaves, resources and services, differing from the Trusted Applications design pattern suggested by ARM. Given the isolated nature of exclave services and the limited attack surface of the Secure Kernel, escaping from the secure world to compromise XNU is likely to be much more difficult than exploiting it directly from the insecure world.\u003c/p\u003e\u003cp id=\"b718\"\u003eApple \u003cem\u003emay\u003c/em\u003e use SPTM to manage transitions between the secure and insecure worlds, though this is speculation on my part, as it is not open-sourced so disassembly of the binaries is required. The code refers to this transition as a \u003cem\u003eRINGGATE\u003c/em\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"6c7b\"\u003eA Deeper Dive\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"82fc\"\u003eDomains and Resources\u003c/h2\u003e\u003cp id=\"e4e9\"\u003eXNU initialises a two-level kernel table structure to hold information on exclave \u003cem\u003eresources \u003c/em\u003ediscovered during boot. Each resource is exclusively of one resource type and holds information on a resource that exists in the secure world, or in both worlds.\u003c/p\u003e\u003cp id=\"0856\"\u003eThe \u003cem\u003eroot_table\u003c/em\u003e identifies \u003cem\u003edomains\u003c/em\u003e by name, with each domain referencing a second level table holding all the \u003cem\u003eresources\u003c/em\u003e for that domain. Domains and their resources discovered so far include:\u003c/p\u003e\u003cp id=\"1da3\"\u003e\u003cstrong\u003ecom.apple.kernel \u003c/strong\u003e— this domain contains many resources used by the kernel including:\u003c/p\u003e\u003cul\u003e\u003cli id=\"329f\"\u003ecom.apple.service.ConclaveLauncherControl — conclave launcher service\u003c/li\u003e\u003cli id=\"7ba8\"\u003ecom.apple.service.ConclaveLauncher_Debug — debug service\u003c/li\u003e\u003cli id=\"4457\"\u003ecom.apple.service.ExclaveIndicatorController — service for secure indicator lights\u003c/li\u003e\u003cli id=\"e230\"\u003ecom.apple.service.LogServer_XNUProxy — service for logging\u003c/li\u003e\u003cli id=\"38ca\"\u003ecom.apple.service.FrameMint — service used to boot ExclaveKit\u003c/li\u003e\u003cli id=\"4245\"\u003ecom.apple.storage.backend — Shared memory buffer used by exclave services to do file IO from XNU space via upcalls (more details below)\u003c/li\u003e\u003cli id=\"95fc\"\u003eConclave Manager x — One per conclave, used to control a conclave\u003c/li\u003e\u003cli id=\"331b\"\u003eConclave Manager y …\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7718\"\u003e\u003cstrong\u003ecom.apple.darwin \u003c/strong\u003e— No open-source components use this domain\u003c/p\u003e\u003cp id=\"b5b9\"\u003e\u003cstrong\u003ecom.apple.conclave.name\u003c/strong\u003e — There is one domain per conclave.\u003c/p\u003e\u003cul\u003e\u003cli id=\"06da\"\u003eservice_x\u003c/li\u003e\u003cli id=\"e73c\"\u003eservice_y\u003c/li\u003e\u003cli id=\"d0fb\"\u003eaudio buffer\u003c/li\u003e\u003cli id=\"7502\"\u003eshared memory buffer\u003c/li\u003e\u003cli id=\"0c5d\"\u003eetc\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2f5a\"\u003e\u003cstrong\u003ecom.apple.driver.\u003cem\u003ename\u003c/em\u003e \u003c/strong\u003e— One domain per device driver — existence of these domains is based on comments, not actually seen in open-sourced code. I suspect these are just per-driver conclaves.\u003c/p\u003e\u003ch2 id=\"9a8b\"\u003eConclaves\u003c/h2\u003e\u003cp id=\"785f\"\u003eA conclave is a type of resource that itself can contain multiple resources. However, it is much more than just a container of resources. Conclaves allow a group of services and other resources to have shared access to each other, and Mach tasks are limited in what (if any) conclaves they can call upon.\u003c/p\u003e\u003cp id=\"a3d8\"\u003eEach conclave has a \u003cem\u003eConclave Manager\u003c/em\u003e (another type of exclave resource), located in the kernel domain.\u003c/p\u003e\u003cp id=\"eea9\"\u003eConclaves have a lifecycle, whereby their Conclave Manager is first \u003cem\u003eattached\u003c/em\u003e to a Mach task, and are then \u003cem\u003elaunched\u003c/em\u003e. They can also be stopped and detached. States such as \u003cem\u003elaunching\u003c/em\u003e and \u003cem\u003estopping\u003c/em\u003e exist during transitions in the lifecycle.\u003c/p\u003e\u003ch2 id=\"5805\"\u003e\u003cstrong\u003eConclaves — Spawning and Attaching\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"7581\"\u003eThe XNU posix_spawn() function can call task_add_conclave() to attach a task and a conclave manager resource together. This is a 1:1 relationship — only one task can be attached to a conclave manager and vice versa. Only launchd and tasks with the \u003cem\u003ecom.apple.private.exclaves.conclave-spawn\u003c/em\u003e entitlement may spawn a conclave. The \u003cem\u003ecom.apple.private.exclaves.conclave-host \u003c/em\u003eentitlement is largely similar, but I believe only entitles a task to attach itself, rather than being able to spawn a new task for this purpose.\u003c/p\u003e\u003cp id=\"6ac1\"\u003eThe kernel looks up the associated conclave manager resource for the targeted conclave in the \u003cem\u003ecom.apple.kernel\u003c/em\u003e domain. It then saves a \u003cem\u003etightbeam\u003c/em\u003e endpoint to the conclave manager’s endpoint in the conclave’s resource struct. This endpoint is where all future control of the conclave is directed. Tightbeam appears to be an RPC framework for communication between exclave components.\u003c/p\u003e\u003cp id=\"acb7\"\u003eNote this attachment is to a \u003cem\u003etask\u003c/em\u003e — not a \u003cem\u003ethread\u003c/em\u003e. Execution of services will be covered later.\u003c/p\u003e\u003cp id=\"65a9\"\u003eConclave manager tasks are \u003cem\u003enot\u003c/em\u003e allowed to have kernel domain privileges.\u003c/p\u003e\u003ch2 id=\"d948\"\u003e\u003cstrong\u003eConclaves — Launching\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"673f\"\u003eOnce attached, a conclave may be \u003cem\u003elaunched\u003c/em\u003e. The launch attempt must be performed from the conclave manager task attached to the conclave. Attempts to launch conclaves also wait until exclaves have fully booted (into state EXCLAVES_BS_BOOTED_EXCLAVEKIT — more on this later).\u003c/p\u003e\u003cp id=\"747d\"\u003eA new mach trap (ie system call) for exclave functionality has been added to XNU and ends up in the \u003cem\u003e_exclaves_ctl_trap() \u003c/em\u003efunction. This call is overloaded and can perform different \u003cem\u003eoperations\u003c/em\u003e passed in as parameters. The relevant operation to launch a conclave is EXCLAVES_CTL_OP_LAUNCH_CONCLAVE.\u003c/p\u003e\u003cp id=\"1ab0\"\u003eThe launch operation calls a redacted function, \u003cem\u003econclave_launcher_conclavecontrol_launch() \u003c/em\u003eand passes it the tightbeam connection to the conclave manager to perform the launch. I suspect this requests the initialisation of executable code and resources for the conclave within the secure world.\u003c/p\u003e\u003cp id=\"d027\"\u003eIn production, conclave hosts can be \u003cem\u003etainted\u003c/em\u003e when launched, and an exit() may then cause a kernel panic.\u003c/p\u003e\u003ch2 id=\"5d4d\"\u003eA New Mach Trap / System Call\u003c/h2\u003e\u003cp id=\"610a\"\u003eAs mentioned, the _exclaves_ctl_trap() function handles a new Mach trap for exclave functionality. The call is overloaded, with its action dependent on an operation parameter, and it generally verifies entitlements to the operations called. The operations are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7707\"\u003eEXCLAVES_CTL_OP_BOOT — Called twice during the system boot process — firstly to start exclaves boot stage 2, and then to boot stage ExclaveKit. The caller must be launchd or have the com.apple.private.exclaves.boot entitlement.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"33ff\"\u003e\u003cem\u003eAll operations below, at minimum, require the current task to have the com.apple.private.exclaves.kernel-domain entitlement, or be the relevant conclave manager task\u003c/em\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"07d0\"\u003eEXCLAVES_CTL_OP_LAUNCH_CONCLAVE — launch a conclave, discussed earlier\u003c/li\u003e\u003cli id=\"dea1\"\u003eEXCLAVES_CTL_OP_LOOKUP_SERVICES — lookup an exclave service and copy its struct to a userspace buffer. First it looks in the exclave domain of the current task, if that fails it checks the Darwin domain followed by kernel domain — if it is entitled to do so\u003c/li\u003e\u003cli id=\"5b78\"\u003e\u003cstrong\u003eEXCLAVES_CTL_OP_ENDPOINT_CALL\u003c/strong\u003e — calls the endpoint for an exclave service in the current task’s domain — this will result in the current thread switching from kernel mode to the secure world and executing specific code there\u003c/li\u003e\u003cli id=\"4b58\"\u003eEXCLAVES_CTL_OP_NAMED_BUFFER_CREATE — create a named buffer resource\u003c/li\u003e\u003cli id=\"343b\"\u003eEXCLAVES_CTL_OP_NAMED_BUFFER_COPYIN — copy data from a userspace buffer to a kernel buffer (that is shared with exclaves)\u003c/li\u003e\u003cli id=\"7e58\"\u003eEXCLAVES_CTL_OP_NAMED_BUFFER_COPYOUT — copy data from a kernel buffer (that is shared with exclaves) to a userspace buffer\u003c/li\u003e\u003cli id=\"ed65\"\u003eEXCLAVES_CTL_OP_AUDIO_BUFFER_CREATE — can an audio buffer\u003c/li\u003e\u003cli id=\"4258\"\u003eEXCLAVES_CTL_OP_AUDIO_BUFFER_COPYOUT — copy data from audio buffer to userspace buffer\u003c/li\u003e\u003cli id=\"3d7d\"\u003eEXCLAVES_CTL_OP_SENSOR_CREATE — create a sensor resource (eg. camera, microphone)\u003c/li\u003e\u003cli id=\"d56d\"\u003eEXCLAVES_CTL_OP_SENSOR_START\u003c/li\u003e\u003cli id=\"406f\"\u003eEXCLAVES_CTL_OP_SENSOR_STOP\u003c/li\u003e\u003cli id=\"3a23\"\u003eEXCLAVES_CTL_OP_SENSOR_STATUS\u003c/li\u003e\u003cli id=\"edf9\"\u003eEXCLAVES_CTL_OP_NOTIFICATION_RESOURCE_LOOKUP — create a notification resource — TBD, but likely for coordination/scheduling\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"88a8\"\u003eDowncalls — running code in the secure world\u003c/h2\u003e\u003cp id=\"c102\"\u003eDowncalls are calls to exclave \u003cem\u003eServices’ \u003c/em\u003eendpoints in the secure world — this is where secure world code execution happens.\u003c/p\u003e\u003cp id=\"8349\"\u003eThere is a great deal of complexity in these calls, primarily around managing thread/IPC contexts and scheduling the current thread to execute code in the secure world.\u003c/p\u003e\u003col\u003e\u003cli id=\"1347\"\u003eDowncalls switch the current thread into the secure world and start executing at an entry point in secure code, rather than asking some other thread to perform work on behalf of the current thread.\u003c/li\u003e\u003cli id=\"ca8a\"\u003eCalling tasks must have kernel domain entitlements or be the conclave manager task attached to the service’s conclave.\u003c/li\u003e\u003cli id=\"237b\"\u003eConclaves have a maximum of 128 services that can be called\u003c/li\u003e\u003cli id=\"ffd3\"\u003eIt appears that threads are scheduled into the secure kernel (via the sk_enter() function) by XNU. XNU appears to handle the scheduling of \u003cem\u003eall\u003c/em\u003e threads in the secure world, with SK potentially not having any independent threads of its own.\u003c/li\u003e\u003cli id=\"d4bf\"\u003eA thread executing in the secure world can perform a temporary \u003cem\u003eupcall\u003c/em\u003e to XNU, which returns the thread to kernel mode for the upcall, before a mandatory return \u003cem\u003eback\u003c/em\u003e to the secure world context. More detail on upcalls will be provided further below.\u003c/li\u003e\u003cli id=\"7c94\"\u003eThreads executing in the secure world can do normal scheduler type things like yield, wait, be suspended, or be interrupted. When this happens, the thread leaves the secure world and returns to the XNU kernel context. From there it must be rescheduled back into the secure world by exclave scheduling code in XNU. The thread will continue to be rescheduled into the secure world as necessary until the downcall is completed.\u003c/li\u003e\u003cli id=\"9e02\"\u003eIf a secure world thread is panic()ing on a CPU core (which will call on XNU to panic via SPTM), fresh tasks are no longer scheduled into the secure world on other cores and they wait for a timeout period. If everything goes correctly, the waiting threads will never finish their wait. However if the timeout expires, the waiting threads will then … panic() :)\u003c/li\u003e\u003cli id=\"de4a\"\u003eXNU appears to handle all interrupt processing, rather than SK. When XNU is finished handling an interrupt, the interrupted thread is returned to the secure world if it was executing there. Directing interrupts to either the insecure or secure kernel is an ARM TrustZone feature.\u003c/li\u003e\u003cli id=\"d706\"\u003eIPC structures for the downcall are setup with request and response buffers before entering the secure world through the redacted sk_enter() call.\u003c/li\u003e\u003cli id=\"c8da\"\u003eInterrupts and pre-emption are disabled while finalising the IPC request structure and calling sk_enter(). This is because there is only one of these structures \u003cem\u003eper core\u003c/em\u003e. I suspect the redacted path travelled after calling sk_enter() and entering the secure world copies the request from the per-cpu structure into secure world memory, and then re-enables interrupts and pre-emption on the core. The alterative would be ugly. A similar process happens in reverse for protecting the per-cpu response structure.\u003c/li\u003e\u003cli id=\"2e37\"\u003eDisconcertingly, the downcall response can come back via a different CPU’s per-core response buffer, as the downcall may have been interrupted, upcalled, or yielded and needed rescheduling.\u003c/li\u003e\u003cli id=\"1fdc\"\u003eCoordination of a thread’s exclave status (to avoid SK re-entry etc) occurs via \u003cem\u003eth_exclaves_state\u003c/em\u003e — a bitfield in the thread structure.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"3742\"\u003eUpcalls — Secure World calls to XNU\u003c/h2\u003e\u003cp id=\"102d\"\u003eA thread running in the secure world due to a downcall may need assistance from XNU and this can be achieved through an upcall to the exclaves upcall handler via the Tightbeam framework. Upcalls are limited to specific functions within XNU. A thread desiring an upcall returns to the insecure world where the specific upcall handler is called. While in this state, the thread cannot return to user mode (for obvious reasons) nor perform another downcall to the secure world, ie it is not allowed to “re-enter” exclaves. Instead the thread will be returned to the secure world at the point where it performed the upcall.\u003c/p\u003e\u003cp id=\"b346\"\u003eAllowed upcalls discovered in the source end up inside the following functions:\u003c/p\u003e\u003cp id=\"c245\"\u003e\u003cstrong\u003eMemory\u003cbr/\u003e\u003c/strong\u003eexclaves_memory_upcall_alloc(npages, kind, completion);\u003cbr/\u003eexclaves_memory_upcall_free(pages, npages, kind, completion);\u003c/p\u003e\u003cp id=\"e369\"\u003e\u003cstrong\u003eFile storage\u003cbr/\u003e\u003c/strong\u003eexclaves_storage_upcall_root(exclaveid, completion);\u003cbr/\u003eexclaves_storage_upcall_open(fstag, rootid, name, completion);\u003cbr/\u003eexclaves_storage_upcall_close(fstag, fileid, completion);\u003cbr/\u003eexclaves_storage_upcall_create(fstag, rootid, name, completion);\u003cbr/\u003eexclaves_storage_upcall_read(fstag, fileid, descriptor, completion);\u003cbr/\u003eexclaves_storage_upcall_write(fstag, fileid, descriptor, completion);\u003cbr/\u003eexclaves_storage_upcall_remove(fstag, rootid, name, completion);\u003cbr/\u003eexclaves_storage_upcall_sync(fstag, op, fileid, completion);\u003cbr/\u003eexclaves_storage_upcall_readdir(fstag, fileid, buf, length, completion);\u003cbr/\u003eexclaves_storage_upcall_getsize(fstag, fileid, completion);\u003cbr/\u003eexclaves_storage_upcall_sealstate(fstag, completion);\u003c/p\u003e\u003cp id=\"6b87\"\u003e\u003cstrong\u003eDriverKit\u003cbr/\u003e\u003c/strong\u003eexclaves_driverkit_upcall_irq_register(id, index, completion);\u003cbr/\u003eexclaves_driverkit_upcall_irq_remove(id, index, completion);\u003cbr/\u003eexclaves_driverkit_upcall_irq_enable(id, index, completion);\u003cbr/\u003eexclaves_driverkit_upcall_irq_disable(id, index, completion);\u003cbr/\u003eexclaves_driverkit_upcall_timer_register(id, completion);\u003cbr/\u003eexclaves_driverkit_upcall_timer_remove(id, timer_id, completion);\u003cbr/\u003eexclaves_driverkit_upcall_timer_enable(id, timer_id, completion);\u003cbr/\u003eexclaves_driverkit_upcall_timer_disable(id, timer_id, completion);\u003cbr/\u003eexclaves_driverkit_upcall_timer_set_timeout(id, timer_id, duration,completion);\u003cbr/\u003eexclaves_driverkit_upcall_timer_cancel_timeout(id, timer_id, completion);\u003cbr/\u003eexclaves_driverkit_upcall_lock_wl(id, completion);\u003cbr/\u003eexclaves_driverkit_upcall_unlock_wl(id, completion);\u003cbr/\u003eexclaves_driverkit_upcall_async_notification_signal(id, notificationID, completion);\u003cbr/\u003eexclaves_driverkit_upcall_mapper_activate(id,mapperIndex, completion);\u003cbr/\u003eexclaves_driverkit_upcall_mapper_deactivate(id, mapperIndex, completion);\u003cbr/\u003eexclaves_driverkit_upcall_notification_signal(id, mask, completion);\u003c/p\u003e\u003cp id=\"df95\"\u003e\u003cstrong\u003eDriverKit Apple Neural Engine\u003cbr/\u003e\u003c/strong\u003eexclaves_driverkit_upcall_ane_setpowerstate(id, desiredState, completion);\u003cbr/\u003eexclaves_driverkit_upcall_ane_worksubmit(id, requestID, taskDescriptorCount, submitTimestamp, completion);\u003cbr/\u003eexclaves_driverkit_upcall_ane_workbegin(id, requestID, beginTimestamp, completion);\u003cbr/\u003eexclaves_driverkit_upcall_ane_workend(id, requestID, completion);\u003c/p\u003e\u003cp id=\"bda7\"\u003e\u003cstrong\u003eConclaves\u003cbr/\u003e\u003c/strong\u003eexclaves_conclave_upcall_suspend(flags, completion);\u003cbr/\u003eexclaves_conclave_upcall_stop(flags, completion);\u003cbr/\u003eexclaves_conclave_upcall_crash_info(shared_buf, length, completion);\u003c/p\u003e\u003ch2 id=\"9a54\"\u003eThe XNUProxy\u003c/h2\u003e\u003cp id=\"83f9\"\u003eReferences to XNUProxy abound, yet I haven’t been able to definitely pin down exactly what and where it is. Options I have considered include:\u003c/p\u003e\u003cul\u003e\u003cli id=\"5dfd\"\u003eIt’s an exclave domain of its own, something like com.apple.xnuproxy\u003c/li\u003e\u003cli id=\"83f2\"\u003eIt’s an exclave service or bunch of services that runs in the com.apple.kernel domain, serving particular types of downcalls.\u003c/li\u003e\u003cli id=\"4bad\"\u003eIt’s a subsystem in SPTM for making downcalls to the secure world…\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"eadb\"\u003eComments in Exclaves_L4.h state that the XNU Proxy makes the following exclaves reachable (aside from testing ones, usually featuring the word “HELLO” in them):\u003c/p\u003e\u003cul\u003e\u003cli id=\"8b3b\"\u003eEXCLAVES_XNUPROXY_EXCLAVE_USERAPP/2/3 (templated user app…)\u003c/li\u003e\u003cli id=\"9bce\"\u003eEXCLAVES_XNUPROXY_EXCLAVE_AUDIODRIVER\u003c/li\u003e\u003cli id=\"3801\"\u003eEXCLAVES_XNUPROXY_EXCLAVE_EXCLAVEDRIVERKIT\u003c/li\u003e\u003cli id=\"0ddb\"\u003eEXCLAVES_XNUPROXY_EXCLAVE_SECURERTBUDDY_AOP (RT Buddy for Always On Processor)\u003c/li\u003e\u003cli id=\"0b1b\"\u003eEXCLAVES_XNUPROXY_EXCLAVE_SECURERTBUDDY_DCP (for Display Coprocessor)\u003c/li\u003e\u003cli id=\"382f\"\u003eEXCLAVES_XNUPROXY_EXCLAVE_CONCLAVECONTROL (conclave launcher control)\u003c/li\u003e\u003cli id=\"858a\"\u003eEXCLAVES_XNUPROXY_EXCLAVE_CONCLAVEDEBUG\u003c/li\u003e\u003cli id=\"9042\"\u003eEXCLAVES_XNUPROXY_EXCLAVE_SECURERTBUDDY_AOP_EDK (ExclaveDriverKit connection for Always On Processor)\u003c/li\u003e\u003cli id=\"4164\"\u003eEXCLAVES_XNUPROXY_EXCLAVE_SECURERTBUDDY_DCP_EDK (ExclaveDriverKit connection for Display CoProcessor)\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"569c\"\u003eNote RTBuddys are for communicating with RTKit, yet another Apple Operating System, that runs on the Display Coprocessor, Apple Neural Engine, NVMe controller, SMC Controller, Smart Keyboards, Siri Remote, Apple Pencil, AirPods, AirTags… and I assume the AOP.\u003c/p\u003e\u003ch2 id=\"f4d0\"\u003eBooting Stage 1\u003c/h2\u003e\u003cp id=\"16de\"\u003eBooting exclaves when the system is starting requires a delicately coordinated dance between the insecure and secure worlds. Anything going wrong usually ends up in a panic().\u003c/p\u003e\u003cp id=\"a86e\"\u003eBooting occurs in three stages. Stage one is not visible in the open-source, however is likely a secure boot process where SK is loaded into memory and its code signatures are verified before being made executable. At the end of a successful stage one boot, the boot status is EXCLAVES_BS_NOT_STARTED.\u003c/p\u003e\u003ch2 id=\"323e\"\u003eBooting Stage 2\u003c/h2\u003e\u003col\u003e\u003cli id=\"37a2\"\u003eInitialises upcall server by creating a tightbeam endpoint for upcalls\u003c/li\u003e\u003cli id=\"21cb\"\u003eEnters secure world with a special call to collect boot information from secure kernel\u003c/li\u003e\u003cli id=\"ba91\"\u003eEnters secure world again with normal endpoint call but not sure why… possibly to trigger the kernel domain to start\u003c/li\u003e\u003cli id=\"970c\"\u003eInitialises the exclave scheduler\u003c/li\u003e\u003cli id=\"03dc\"\u003eInitialises the XrtHostedXNU kext\u003c/li\u003e\u003cli id=\"e824\"\u003eInitialises callbacks (I think into the above kext)\u003c/li\u003e\u003cli id=\"e021\"\u003eBoots the scheduler — sets up per-cpu request\u0026amp;response for the boot CPU core only, and binds to the boot core\u003c/li\u003e\u003cli id=\"4bbd\"\u003eLoops, calling into the secure world to see if it needs memory allocations, until it responds that all exclaves are booted\u003c/li\u003e\u003cli id=\"e12b\"\u003eInitialises multicore by setting up per-cpu request\u0026amp;response memory for all cores\u003c/li\u003e\u003cli id=\"26e1\"\u003eInitialises XNU Proxy — creates a cache of buffers for IPC calls, creates some thread contexts, sets up a tightbeam endpoint for downcalls to the xnuproxy\u003c/li\u003e\u003cli id=\"5696\"\u003eInitialises an exclaves panic kernel thread\u003c/li\u003e\u003cli id=\"3fbb\"\u003eDiscovers all static exclave resources and builds the root_table of domains and resources.\u003c/li\u003e\u003cli id=\"8b15\"\u003eCreates tightbeam endpoints for all Conclave Manager resources and calls an initialisation process for each one.\u003c/li\u003e\u003cli id=\"6cfa\"\u003ePopulates a bitmap of valid conclave service ids (from 0 to 127) for each conclave.\u003c/li\u003e\u003cli id=\"218a\"\u003eAt kernel build time, a list of boot tasks was stored in the __DATA_CONST segment. These are now sorted by priority and each boot task function is called. I likely only have a very partial picture here, but these tasks include creating an endpoint for each of the exclave indicator controller service, the storage backend service, the logserver, and for stackshots.\u003c/li\u003e\u003cli id=\"653d\"\u003eBoot status is now EXCLAVES_BS_BOOTED_STAGE_2\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"f7a7\"\u003eBoot Stage 3 (Boot ExclaveKit)\u003c/h2\u003e\u003cp id=\"0ce5\"\u003eThe stage makes multiple calls regarding “framemint”. This is suggestive of the SK being based on seL4.\u003c/p\u003e\u003col\u003e\u003cli id=\"0a96\"\u003eThe “com.apple.service.FrameMint” service is looked up and a tightbeam endpoint is created for it\u003c/li\u003e\u003cli id=\"f232\"\u003eA redacted function, framemint_framemint__init() is called\u003c/li\u003e\u003cli id=\"fbf0\"\u003eA redacted framemint_framemint_populate() function is called but I guess this will be triggering all sorts of exciting activity to happen in the secure world\u003c/li\u003e\u003cli id=\"8be5\"\u003eBoot status is now EXCLAVES_BS_BOOTED_EXCLAVEKIT\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"52a1\"\u003eSPTM memory typing\u003c/h2\u003e\u003cp id=\"5f6e\"\u003eSPTM “types” memory pages to control access to them via its different subsystems. Existing types included:\u003c/p\u003e\u003cul\u003e\u003cli id=\"35d1\"\u003eXNU_USER_EXEC\u003c/li\u003e\u003cli id=\"32d2\"\u003eXNU_USER_DEBUG\u003c/li\u003e\u003cli id=\"67fb\"\u003eXNU_USER_JIT\u003c/li\u003e\u003cli id=\"af79\"\u003eXNU_ROZONE\u003c/li\u003e\u003cli id=\"e8c1\"\u003eXNU_KERNEL_RESTRICTED\u003c/li\u003e\u003cli id=\"34f9\"\u003e+Types for TXM, DART, etc\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"09b3\"\u003eExclaves have added:\u003c/p\u003e\u003cul\u003e\u003cli id=\"ecf2\"\u003eSK_DEFAULT (exclusive to SK — inaccessible to XNU)\u003c/li\u003e\u003cli id=\"03d7\"\u003eSK_IO (also exclusive to SK — inaccessible to XNU)\u003c/li\u003e\u003cli id=\"9983\"\u003eSK_SHARED_RO (memory shared between SK and XNU (read only for XNU)\u003c/li\u003e\u003cli id=\"63f8\"\u003eSK_SHARED_RW (memory shared between SK and XNU (read+write for XNU)\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"faf5\"\u003eConclusions\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"091f\"\u003eIn the face of continued exploitation by advanced threat actors, Apple’s implementation of Exclaves represents a large investment to add extra defence in depth to their operating systems. By isolating sensitive resources, Apple is shrinking their potential attack surface and reducing the impact of any single kernel compromise. Defending monolithic kernels is a Sisyphean task, and exclaves represent one method of dealing with the challenge — is it the right direction for the long term, or a temporary step? In my dreams, I imagine a future redesign using CHERI and a production implementation of ARM Morello 😊 Regardless, it’s a defensive effort on a larger scale than any other end user device manufacturer is currently attempting.\u003c/p\u003e\u003cp id=\"19f9\"\u003eCritically, this article has not directly examined \u003cem\u003ewhat\u003c/em\u003e is being moved from the kernel into exclaves. Build images indicate they are being used for secure camera/microphone indicators, some Apple Neural Engine functionality, some device drivers, components that talk to the Secure Enclave and so on. There may be many components that will benefit from future migration to exclaves and the overall effectiveness of exclaves may depend on an ongoing effort to maximise their usage. Everything XNU outside of exclaves will still be fair game.\u003c/p\u003e\u003cp id=\"1328\"\u003eI also suspect that exclaves may be used within Apple’s Private Cloud Compute infrastructure for cloud-based AI to provide a higher assurance of privacy in the face of external threats.\u003c/p\u003e\u003cp id=\"ee04\"\u003eI would particularly like to highlight the work of Dataflow Forensics and their much more advanced work dissecting SPTM without the benefit of source code. I enthusiastically await their promised blog post about exclaves and hope they will answer many of the remaining questions, provide gory disassembly explanations, and correct all my mistakes and assumptions!\u003c/p\u003e\u003ch2 id=\"5698\"\u003eTo do (by someone much smarter than me!)…\u003c/h2\u003e\u003cul\u003e\u003cli id=\"e1e2\"\u003eExclaveKit…\u003c/li\u003e\u003cli id=\"9aac\"\u003eExclaveDriverKit…\u003c/li\u003e\u003cli id=\"de31\"\u003eWhere does the “XNUProxy” really fit in?\u003c/li\u003e\u003cli id=\"38d5\"\u003eDisassembly to determine how XNU switches to the secure world, and if this involves SPTM, and/or TrustZone…\u003c/li\u003e\u003cli id=\"caa3\"\u003eAlmost everything about the Secure Kernel…\u003c/li\u003e\u003cli id=\"839a\"\u003eAlmost everything happening in the Secure World userspace…\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"786b\"\u003e\u003cem\u003eThis analysis was based on Apple’s Open Source XNU build 11215.*\u003c/em\u003e\u003c/p\u003e\u003cp id=\"6a6f\"\u003e\u003cem\u003eAI was used to improve my poor writing skills in the introductory sections.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "30 min read",
  "publishedTime": "2025-02-28T10:27:00.122Z",
  "modifiedTime": null
}
