{
  "id": "81b2cbab-9a0c-41ac-9359-9d3ee1b3fe1f",
  "title": "Bare metal printf – C standard library without OS",
  "link": "https://popovicu.com/posts/bare-metal-printf/",
  "description": "Comments",
  "author": "",
  "published": "Sat, 26 Apr 2025 21:32:37 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Uros Popovic",
  "length": 28485,
  "excerpt": "Guide to implementing a C standard library for bare metal hardware using Newlib, enabling powerful functions like printf and malloc without relying on an operating system. This step-by-step guide demonstrates how to configure and integrate Newlib on RISC-V architecture, showing you how to redirect standard I/O through UART for embedded systems development.",
  "siteName": "",
  "favicon": "https://popovicu.com/favicon.png",
  "text": "Follow @popovicu94 Today we’ll take a look at how we can leverage Newlib to create a compact C standard library for usage on a bare metal system. In a small example, we’ll implement a few UART primitives and pass them on to Newlib which uses them as the building blocks for a full-blown printf functionality. The target platform will be RISC-V, but the concepts should, as usual, be the same for other platforms as well. Table of contents Open Table of contents Software abstractions and C standard library C standard library on bare metal Newlib concept Cross-compilation toolchain Toolchain details Automated RISC-V toolchain build GitHub link Implementing the memory and UART building blocks Application example: input and output The ‘gotcha’ moment Running the app Conclusion Software abstractions and C standard library When running printf on a typical, fully operational, end-user system (e.g., a Mac or a Linux laptop), we invoke a pretty complex machinery. The application process calls the printf function, which is more often than not dynamically linked, and after a few layers of different C functions, a system call to the operating system kernel is typically invoked. The kernel will route the output through different subsystems: different terminal and pseudo-terminal primitives will be invoked, and at some point, you will also want to visually see the printf output on your screen. That also likely invokes a pretty thick stack of abstractions in order to render the characters on your screen. We won’t even talk about how printf formats the output strings based on the provided templates. On a bare metal system, however, most of these abstractions are not available at all and the stack is much thinner. If we’re working on bare metal, we don’t have anything below our C functions supporting us. In the full-blown example above, the process would hand over the output to the kernel through system calls, which are implemented through software interrupts. However, now we don’t have anything to hand over to, yet we want to have something like printf working, ideally outputting to a simple I/O device like UART. This is where Newlib jumps in. You’re probably familiar with different flavors of C standard library like GNU (glibc), musl and so on, but Newlib should definitely be on your radar if you’d like to enable C standard library on bare metal. More accurately, the way I think about Newlib is not as a C standard library, but rather as a kit to build a custom, compact C standard library. Newlib concept Rather than requiring you to implement the whole C standard library from scratch, Newlib boils down the implementation to a few very basic primitives with clean interfaces that can be implemented as separate functions, and then other more complex functions like printf and malloc will call these primitives. Just for intuition, we will be implementing primitives like _write which essentially writes a single character to the output stream, and Newlib builds printf on top of that in order to write more complex outputs. In addition to providing this simple set of primitives to implement, Newlib also gives reasonable pre-cooked implementations as well. In one of the configurations, you can even still target Linux as the underlying platform instead of bare metal, and the provided implementation will do system calls like glibc would do. Also, if you’re going for the absolutely minimal config, Newlib will provide all the primitives in a minimal form where they just return zeroes or raise an error (equivalent to something like raising an unimplemented exception in Python or Java). Either way, you will implement whatever building blocks you actually care about in your application and the rest would rely on the default implementation. Let’s switch gears here and talk about the cross-compilation toolchains. Cross-compilation happens when you compile from one platform to another. Intuitively, you can think of something like cross-compiling from an x86_64/Linux platform to ARM64/Mac. On platforms like Linux, though, things can get a lot more nuanced, as Linux platform doesn’t necessarily mean one flavor of C standard library, so I’d refer to these platforms more accurately as x86_64/Linux/glibc. When you look at platforms from that perspective, even compiling from a platform with one standard library to another on the same x86_64/Linux setup, but with a different C library, you are effectively still cross-compiling. A concrete example would be cross-compiling from x86_64/Linux/glibc to x86_64/Linux/musl. Furthermore, if you want to be extremely accurate and disciplined (as you should be if you want to build software that doesn’t break!), even building from one version of glibc for another is really cross-compiling. Again, as an example, building from x86_64/Linux/glibc_v1.0 for x86_64/Linux/glibc_v1.1 is cross-compilation. This can quickly get difficult, at least with the traditional way of building and using compilers (such as GCC, for example); however, those “ancient” ways are still stuck with us for the foreseeable future. I will soon write in more detail about this, and for now, we’ll use a shortcut described below. Toolchain details We want a toolchain that satisfies two requirements: it builds from our host platform to RISC-V, i.e. it generates RISC-V instructions it uses the Newlib library when C standard library functionality is invoked If you’re on a typical Linux distribution, you likely have something like GCC (or even clang) installed. When you simply run GCC on a C file without any fancy flags, what happens is that the compiler will simply build for the same platform it runs on. More accurately, the host and the target are the same, and I believe the formal term for this is native compilation. The reason why I bring this up is to ask ourselves what happens when we include something like stdio.h and call something like printf? Where is this .h file really pulled from and where is ultimately the printf implementation found so it can be linked against? This really depends on the way your compiler was built. When you build GCC from source, and you run ./configure, you can specify a ton of flags that will drive this behavior. As promised, I will write more about it in the future. For now, let’s keep in mind that most Linux distributions we use in daily lives follow the old UNIX philosophy when it comes to this. For example, my Debian installation has stdio.h in a standard directory at /usr/include. Furthermore, my standard C library (glibc) that can be dynamically linked is at /lib/x86_64-linux-gnu/libc.so (which really points to /lib/x86_64-linux-gnu/libc.so.6). Similarly, there is an .a file in there, but I will assume you know what .so and .a files are for. So, long story short, skipping a lot of details, your native compiler is set up to look for the C library in some of the standard spots, and when it builds for the same platform, it simply picks up the libraries from there. Therefore, we need to: get the compiler that can generate instructions for the desired platform (machine code) set up the C standard library for that particular platform somewhere ensure that the compiler for the target platform knows how to use the library from above From what I’ve seen, when it comes to cross-compilation, this is a fair amount of grungy work that needs to be done. The set up above takes a lot of building time and needs to be done in stages when done properly. A future article will go into details, but for now, as we mentioned before, we’ll go for a shortcut. Remember for now that we want the includes, .so/.a files at some path, and we want the cross-compiler to look there for the C standard library, not at the host’s include and lib directories. In this case since we want to build from something like x86_64 to RISC-V, it’s easy to spot errors, since if we use the host’s libraries, there is no way the wrong architecture would work, but when compiling for the same architecture and a different software platform, host contamination can be a real thing and can lead to very subtle and annoying problems! For example, we want the library code to be searched for at /usr/local/risc_v_stuff/lib instead of /usr/lib. Automated RISC-V toolchain build For this exercise, let’s simply use the RISC-V toolchain. This project will still build everything from source on our host machine, but the whole annoying orchestration mentioned above, including staging the compilers, will be scripted and automated for us. With a few commands, we’ll kick off the process that will effectively set up something like /usr/local/risc_v_stuff/lib, /usr/local/risc_v_stuff/include, /usr/local/risc_v_stuff/compiler and you’ll be able to invoke /usr/local/risc_v_stuff/compiler/gcc which will know to peek into the right directories for different files and will build the right machine code. Of course, the paths will ultimately be different, but this should be good enough as a concept. We can start by cloning the Git repository linked above. The instructions say that the --recursive flag is not necessary during cloning and things will be dynamically pulled later, but for whatever reason, this did not work on my system. I ended up running a clone with the --recursive flag to avoid issues. It took a lot of time and space though, pulling in gigabytes and gigabytes of source code. Once the endless clone is done, you can configure the build. This is how I configured it: ./configure --prefix=/opt/riscv-newlib --enable-multilib --disable-gdb --with-cmodel=medany I strongly encourage you to run ./configure --help to see what all the available options are and customize the build. For now, I will explain my parameters: prefix is simply where we’ll install the newly built artifacts, such as the cross-compiler, C standard library (Newlib in our case) and so on. enable-multilib will enable builds for different RISC-V setups. As a reminder, RISC-V has a ton of flavors, like RV32I, RV32IMA and so on. Please do note that enabling this flag will make your build super slow. If you don’t want to run the build with multilib, then check the help menu to figure out how to build exactly for the fine grained platform that you need. disable-gdb: for whatever reason, building GDB would always fail for me, so I just excluded it from the toolchain. Real engineers debug with printf anyway! with-cmodel: hold on to this one, I will reveal this in a ‘gotcha’ moment; for now, let’s just keep in mind I needed this in order to make the 64-bit RISC-V builds work. Now that your build is configured, you can fire off the build process and leave it cooking for quite some time. One thing that surprised me here is that they didn’t use separate make and make install steps. Everything is done through just make, both the compilation and installation of the artifacts. Note: I wanted to parallelize the build with -j16 as I normally do, but that also somehow broke my build, so I suggest running without this, and yes, I know it takes forever. I simply ran sudo make in order to place the final artifacts in the /opt directory. This whole process is very slow, so make sure you have something else to do while this is working. Also, you may wonder where Newlib comes in here, when I mentioned that this whole process will automate how we get Newlib available. The answer is that Newlib is simply the default option for building our toolchain here. You can check the GitHub documentation on how to set up your cross-compiler to target a RISC-V glibc or musl, but what I’ve listed above is good enough to get a cross-compiler with Newlib as the target. GitHub link I have prepared this repository to run our example. The code explanations are below (hopefully they’re not out of sync with the repo itself). Implementing the memory and UART building blocks Now that you have a working cross-toolchain targeting RISC-V + Newlib, most of the heavy lifting is done and we can start putting together the Newlib building blocks. Let’s begin with UART, and the first file is uart.h: #ifndef UART_H #define UART_H void uart_putc(char c); char uart_getc(void); #endif This is self-explanatory so far. Let’s see how these functions are implemented: #include \"uart.h\" // QEMU UART registers - these addresses are for QEMU's 16550A UART #define UART_BASE 0x10000000 #define UART_THR (*(volatile char *)(UART_BASE + 0x00)) // Transmit Holding Register #define UART_RBR (*(volatile char *)(UART_BASE + 0x00)) // Receive Buffer Register #define UART_LSR (*(volatile char *)(UART_BASE + 0x05)) // Line Status Register #define UART_LSR_TX_IDLE (1 \u003c\u003c 5) // Transmitter idle #define UART_LSR_RX_READY (1 \u003c\u003c 0) // Receiver ready void uart_putc(char c) { // Wait until transmitter is idle while ((UART_LSR \u0026 UART_LSR_TX_IDLE) == 0); UART_THR = c; // Special handling for newline (send CR+LF) if (c == '\\n') { while ((UART_LSR \u0026 UART_LSR_TX_IDLE) == 0); UART_THR = '\\r'; } } char uart_getc(void) { // Wait for data while ((UART_LSR \u0026 UART_LSR_RX_READY) == 0); return UART_RBR; } The code above was AI-generated, but it’s accurate. And this is it as far as our UART driver is concerned. How does that now work with Newlib? We switch to the file called syscalls.c. Here, we implement the functions that printf would rely on. We’ll also handle the input as well, just for fun. First, what happens here is we implement the primitives for writing to a file handle. The only file handles we’ll really support here are stdout and stderr. And to be perfectly accurate, there are no files here; we’re just intercepting the C standard library calls that otherwise work with these concepts. Moving further, we provide super minimal implementations for a few more building blocks. They’re extremely basic, like the _close function, which essentially never allows any file handle to be closed. The one building block that is very interesting here is _sbrk. This is what gets invoked when the routines for dynamic memory allocation like malloc (needed by the printf family of functions) need to ask the OS (when there is one) to provide more raw memory to the process, that can then be fragmented into smaller logical units by malloc. What happens here is we find the symbol _end defined by the linker, which marks the _end of the static sections (we’ll see how below) and we start using the memory past that address for heap allocations, all the way until we hit the stack. Once we hit the stack, we declare that an error as we have run out of memory. void* _sbrk(int incr) { extern char _end; // Defined by the linker - start of heap extern char _stack_bottom; // Defined in our linker script - bottom of stack area static char *heap_end = \u0026_end; char *prev_heap_end = heap_end; // Calculate safe stack limit - stack grows down from _stack_top towards _stack_bottom char *stack_limit = \u0026_stack_bottom; // Check if heap would grow too close to stack if (heap_end + incr \u003e stack_limit) { errno = ENOMEM; return (void*) -1; // Return error } heap_end += incr; return (void*) prev_heap_end; } Please note that the stack top and bottom here refer to the beginning and the end of the memory block allocated for the stack, not the logical top or bottom of the stack itself from the application perspective. Application example: input and output We’re now ready to put the actual bare metal application together. If you need a refresher on bare metal programming on RISC-V, check it out again. That article covers the key addresses and the basics of putting a bare-metal linker script together. The app code itself is very self explanatory: #include \u003cstdio.h\u003e int main(void) { printf(\"Hello from RISC-V UART!\\n\"); char buffer[100]; printf(\"Type something: \"); scanf(\"%s\", buffer); printf(\"You typed: %s\\n\", buffer); while (1) {} return 0; } Please note that when we’re inputting something to this app, we won’t see our key presses echoed. This is because we’re not operating inside some sort of shell environment. The implementation as it is will simply accept the key presses and store them in the internal memory structure. We’ll see what was typed when we hit the final printf. We now need to also put together a small C runtime. When we develop a binary for an everyday OS, we typically don’t have to think about this, and the compiler will inject the standard startup runtime which takes care of setting up the process for proper execution and passing the control on to the main function. Our minimalistic runtime will set up the stack pointer register, zero-fill the BSS section per C standard, and then call the main code. Just for good measure, we also leave an infinite loop at the end in case main returns. Again, with a proper OS below our code, a system call would be invoked to properly close the process, and it wouldn’t just loop infinitely. .section .text.init .global _start _start: la sp, _stack_top # Clear BSS section - using symbols defined in our linker script la t0, _bss_start la t1, _bss_end clear_bss: bgeu t0, t1, bss_done sb zero, 0(t0) addi t0, t0, 1 j clear_bss bss_done: # Jump to C code call main # In case main returns 1: j 1b One of the most important parts of our application now is the linker script: OUTPUT_FORMAT(\"elf64-littleriscv\") OUTPUT_ARCH(\"riscv\") ENTRY(_start) MEMORY { RAM (rwx) : ORIGIN = 0x80000000, LENGTH = 64M } SECTIONS { /* Code section */ .text : { *(.text.init) *(.text) } \u003e RAM /* Read-only data */ .rodata : { *(.rodata) } \u003e RAM /* Initialized data */ .data : { *(.data) } \u003e RAM /* Small initialized data */ .sdata : { *(.sdata) } \u003e RAM /* BSS section with explicit symbols */ .bss : { _bss_start = .; /* Define BSS start symbol */ *(.bss) *(COMMON) . = ALIGN(8); _bss_end = .; /* Define BSS end symbol */ } \u003e RAM /* Small BSS section */ .sbss : { _sbss_start = .; *(.sbss) *(.sbss.*) . = ALIGN(8); _sbss_end = .; } \u003e RAM /* End marker for heap start */ . = ALIGN(8); _end = .; /* Heap starts here and grows upwards */ /* Stack grows downward from the end of RAM */ _stack_size = 64K; _stack_top = ORIGIN(RAM) + LENGTH(RAM); _stack_bottom = _stack_top - _stack_size; /* Ensure we don't overlap with heap */ ASSERT(_end \u003c= _stack_bottom, \"Error: Heap collides with stack\") } Per our previous investigation of bare metal programming for the QEMU VM, we know that the user-provided code will begin executing from 0x80000000. Therefore, what we do is put the C runtime code that we previously wrote right there. In other words, our assembly code will be planted right at that memory address. Following our C runtime is the rest of the code, i.e. the text section. In this case, this is the C code we have written plus the C standard library we’re linking into our binary. After that, we place the other sections like rodata, data, bss, and so on. The linker script will capture the symbols for BSS start and end so it can be zero-filled by the C runtime, as seen above. There’s also a small BSS section, but the C runtime code doesn’t do anything about it, to stay compact, as it’s not used by the application. It probably should be zero-filled as well. Then, we capture where the small BSS section ends because that also marks the end of our static sections. Following that, we let the growing heap consume everything, up until the stack. The stack occupies the last 64K of memory (and we described RAM as being 64M at the top of the linker script). A few addition and subtraction operations are done to determine where this exactly is, and we do an assert check to make sure there is no collision between the heap and the stack. The concept is simple: we identify the “void” between the static sections and the stack, and we let the C standard library that we’re putting together via Newlib to maintain the growing heap in there. A real kernel like Linux would do its memory management magic here, handle the virtual addresses and so on, but here we really have one “process” and a simple memory extension operation sbrk is enough for what we want to achieve here. The ‘gotcha’ moment Now let’s reflect back on the fact that we configured the toolchain to be built with the --with-cmodel=medany flag. What does this flag really control, and why did we need it? If you read the top of the linker script carefully, we’re building for a 64-bit RISC-V machine. Per QEMU, our instructions will begin at 0x80000000, and we decided to simply lay the rest of the code after that. To handle these high values, we need to use the correct machine instructions to handle these high addresses. So our application code likely needs to use the memory address model which can handle any address, and so we build our logic with -mcmodel=medany. To be compatible, our C standard library also needs that. If we didn’t have the aforementioned flag, the Newlib library would be built with RISC-V instructions that cannot effectively use such high addresses. Remember, the C standard library is pre-built before our application. The build system will simply pick up the machine code from the relevant library directory and link it to your application code. If the addresses do not fit the value range that the instructions support, the linker is not able to make things work. As I understand, there is a concept of linker relaxation, where the linker itself can make the code modifications, but I don’t think it would help in this case. I don’t want to spend too much time on this, I hope the explanation above suffices, and if you would like to learn more about this problem, check out this link, where the reporter had linker errors and a solution was offered. Running the app I’ve included a Makefile in the GitHub repo. Check it out to see what exactly is going on there, especially how the cross-compiler is invoked (should be the first line of the file), as well as QEMU for emulation. I will highlight a few things here. One of the CFLAGS is -specs=nosys.specs. This will drive the toolchain to use the ‘nosys’ flavor of Newlib. This is the most minimal flavor where all the building blocks are just stubs by default that return zeroes or errors. Linker flags include -nostartfiles which means that we’ll be providing our own minimal C runtime, that we have described above. The rest of the Makefile should be fairly easy to follow. I strongly suggest using the debug target though. We’ll just go ahead and run: make debug The QEMU process starts, I punch in foo and hit enter, and after getting back my app’s output, I stop QEMU: $ make debug /opt/riscv-newlib/bin/riscv64-unknown-elf-gcc -march=rv64imac_zicsr -mabi=lp64 -mcmodel=medany -specs=nosys.specs -O2 -g -Wall -c main.c -o main.o /opt/riscv-newlib/bin/riscv64-unknown-elf-gcc -march=rv64imac_zicsr -mabi=lp64 -mcmodel=medany -specs=nosys.specs -O2 -g -Wall -c uart.c -o uart.o /opt/riscv-newlib/bin/riscv64-unknown-elf-gcc -march=rv64imac_zicsr -mabi=lp64 -mcmodel=medany -specs=nosys.specs -O2 -g -Wall -c syscalls.c -o syscalls.o /opt/riscv-newlib/bin/riscv64-unknown-elf-gcc -march=rv64imac_zicsr -mabi=lp64 -mcmodel=medany -specs=nosys.specs -O2 -g -Wall -c startup.S -o startup.o /opt/riscv-newlib/bin/riscv64-unknown-elf-gcc -march=rv64imac_zicsr -mabi=lp64 -mcmodel=medany -specs=nosys.specs -O2 -g -Wall -T link.ld -nostartfiles -o firmware.elf main.o uart.o syscalls.o startup.o /opt/riscv-newlib/lib/gcc/riscv64-unknown-elf/14.2.0/../../../../riscv64-unknown-elf/bin/ld: warning: firmware.elf has a LOAD segment with RWX permissions qemu-system-riscv64 -machine virt -m 256 -nographic -bios firmware.elf -d in_asm,cpu_reset -D qemu_debug.log Hello from RISC-V UART! Type something: You typed: foo The reason why I suggest using the debug target is because it drops a file called qemu_debug.log. That file is pretty cool as it shows you a complete trace of what your VM has been through. Naturally, you can inspect all the Newlib code if you want to figure out how exactly printf works, but I thought it’s still a pretty nice view of what the RISC-V core actually sees. Since we’re building an ELF file and passing it to QEMU, it’s even able to tell us which function we’re exactly in. It doesn’t have that for the first couple of instructions since we’re, as a reminder, executing the initial hardcoded bootloader, and then our initial C runtime, before jumping into the main function. If the first few instructions before 0x80000000 confuse you, please check out RISC-V boot process with SBI to understand what’s going on. Excerpt of my debug log is below: ---------------- IN: Priv: 3; Virt: 0 0x0000000000001000: 00000297 auipc t0,0 # 0x1000 0x0000000000001004: 02828613 addi a2,t0,40 0x0000000000001008: f1402573 csrrs a0,mhartid,zero ---------------- IN: Priv: 3; Virt: 0 0x000000000000100c: 0202b583 ld a1,32(t0) 0x0000000000001010: 0182b283 ld t0,24(t0) 0x0000000000001014: 00028067 jr t0 ---------------- IN: Priv: 3; Virt: 0 0x0000000080000000: 04000117 auipc sp,67108864 # 0x84000000 0x0000000080000004: 00010113 mv sp,sp 0x0000000080000008: 00015297 auipc t0,86016 # 0x80015008 0x000000008000000c: d5828293 addi t0,t0,-680 0x0000000080000010: 00015317 auipc t1,86016 # 0x80015010 0x0000000080000014: d5030313 addi t1,t1,-688 0x0000000080000018: 0062f663 bleu t1,t0,12 # 0x80000024 ---------------- IN: Priv: 3; Virt: 0 0x0000000080000024: 0be020ef jal ra,8382 # 0x800020e2 ---------------- IN: main Priv: 3; Virt: 0 0x00000000800020e2: 7119 addi sp,sp,-128 0x00000000800020e4: 00011517 auipc a0,69632 # 0x800130e4 0x00000000800020e8: db450513 addi a0,a0,-588 0x00000000800020ec: fc86 sd ra,120(sp) 0x00000000800020ee: 10e000ef jal ra,270 # 0x800021fc ---------------- IN: puts Priv: 3; Virt: 0 0x00000000800021fc: 85aa mv a1,a0 0x00000000800021fe: 00012517 auipc a0,73728 # 0x800141fe 0x0000000080002202: ffa53503 ld a0,-6(a0) 0x0000000080002206: b7bd j -146 # 0x80002174 Conclusion With this example, we have ported some of the very powerful features over to our bare-metal platform, and we somewhat retained the feeling of coding on top of a proper kernel. We could keep going and enable things like “file” access, memory management and so on. In fact, what is really interesting here is that the door is now open to use some powerful libraries in our bare-metal code, that are otherwise not necessarily expecting a bare metal environment. Some library could expect to open a file and if the only way it does it is through using the C standard library, we can essentially intercept that API call and without passing the request to the kernel, we can service it in our bare metal code. And the concept to do this was quite simple: depend on the building blocks that Newlib defines, provide your own implementation that takes precedence over the Newlib defaults, and use the defaults for whatever you don’t care about. Of course, in absolutely minimal environments, the size of the final software image can be a concern, as well as the amount of instructions we’re injecting, but looking at the ELF file that we build in our project, it’s at 220K which doesn’t really sound too bad. Ultimately, however, it is up to you to decide what abstractions you will use in your project. This should be one of the tools in your toolbox that can hopefully save you some time in your development. Good luck with your hacking! Please consider following on Twitter/X and LinkedIn to stay updated.",
  "image": "https://popovicu.com/Bare%20metal%20printf%20-%20C%20standard%20library%20without%20OS.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"article\" role=\"article\"\u003e\n      \u003cp\u003e\u003ca href=\"https://twitter.com/popovicu94?ref_src=twsrc%5Etfw\" data-show-count=\"false\"\u003eFollow @popovicu94\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eToday we’ll take a look at how we can leverage Newlib to create a compact C standard library for usage on a bare metal system. In a small example, we’ll implement a few UART primitives and pass them on to Newlib which uses them as the building blocks for a full-blown \u003ccode\u003eprintf\u003c/code\u003e functionality. The target platform will be RISC-V, but the concepts should, as usual, be the same for other platforms as well.\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003cdetails\u003e\u003csummary\u003eOpen Table of contents\u003c/summary\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#software-abstractions-and-c-standard-library\"\u003eSoftware abstractions and C standard library\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#c-standard-library-on-bare-metal\"\u003eC standard library on bare metal\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#newlib-concept\"\u003eNewlib concept\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#cross-compilation-toolchain\"\u003eCross-compilation toolchain\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#toolchain-details\"\u003eToolchain details\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#automated-risc-v-toolchain-build\"\u003eAutomated RISC-V toolchain build\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#github-link\"\u003eGitHub link\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#implementing-the-memory-and-uart-building-blocks\"\u003eImplementing the memory and UART building blocks\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#application-example-input-and-output\"\u003eApplication example: input and output\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#the-gotcha-moment\"\u003eThe ‘gotcha’ moment\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#running-the-app\"\u003eRunning the app\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/details\u003e\n\u003ch2 id=\"software-abstractions-and-c-standard-library\"\u003eSoftware abstractions and C standard library\u003c/h2\u003e\n\u003cp\u003eWhen running \u003ccode\u003eprintf\u003c/code\u003e on a typical, fully operational, end-user system (e.g., a Mac or a Linux laptop), we invoke a pretty complex machinery. The application process calls the \u003ccode\u003eprintf\u003c/code\u003e function, which is more often than not dynamically linked, and after a few layers of different C functions, a system call to the operating system kernel is typically invoked. The kernel will route the output through different subsystems: different terminal and pseudo-terminal primitives will be invoked, and at some point, you will also want to visually see the \u003ccode\u003eprintf\u003c/code\u003e output on your screen. That also likely invokes a pretty thick stack of abstractions in order to render the characters on your screen. We won’t even talk about how \u003ccode\u003eprintf\u003c/code\u003e formats the output strings based on the provided templates.\u003c/p\u003e\n\u003cp\u003eOn a bare metal system, however, most of these abstractions are not available at all and the stack is much thinner.\u003c/p\u003e\n\n\u003cp\u003eIf we’re working on bare metal, we don’t have anything below our C functions supporting us. In the full-blown example above, the process would hand over the output to the kernel through system calls, which are implemented through software interrupts. However, now we don’t have anything to hand over to, yet we want to have something like \u003ccode\u003eprintf\u003c/code\u003e working, ideally outputting to a simple I/O device like UART.\u003c/p\u003e\n\u003cp\u003eThis is where Newlib jumps in. You’re probably familiar with different flavors of C standard library like GNU (\u003ccode\u003eglibc\u003c/code\u003e), \u003ccode\u003emusl\u003c/code\u003e and so on, but Newlib should definitely be on your radar if you’d like to enable C standard library on bare metal.\u003c/p\u003e\n\u003cp\u003eMore accurately, the way I think about Newlib is not as a C standard library, but rather as \u003cstrong\u003ea kit to build a custom, compact C standard library\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"newlib-concept\"\u003eNewlib concept\u003c/h3\u003e\n\u003cp\u003eRather than requiring you to implement the whole C standard library from scratch, Newlib boils down the implementation to a few very basic primitives with clean interfaces that can be implemented as separate functions, and then other more complex functions like \u003ccode\u003eprintf\u003c/code\u003e and \u003ccode\u003emalloc\u003c/code\u003e will call these primitives. Just for intuition, we will be implementing primitives like \u003ccode\u003e_write\u003c/code\u003e which essentially writes a single character to the output stream, and Newlib builds \u003ccode\u003eprintf\u003c/code\u003e on top of that in order to write more complex outputs.\u003c/p\u003e\n\u003cp\u003eIn addition to providing this simple set of primitives to implement, Newlib also gives reasonable pre-cooked implementations as well. In one of the configurations, you can even still target Linux as the underlying platform instead of bare metal, and the provided implementation will do system calls like \u003ccode\u003eglibc\u003c/code\u003e would do. Also, if you’re going for the absolutely minimal config, Newlib will provide all the primitives in a minimal form where they just return zeroes or raise an error (equivalent to something like raising an unimplemented exception in Python or Java).\u003c/p\u003e\n\u003cp\u003eEither way, you will implement whatever building blocks you actually care about in your application and the rest would rely on the default implementation.\u003c/p\u003e\n\n\u003cp\u003eLet’s switch gears here and talk about the cross-compilation toolchains. Cross-compilation happens when you compile from one platform to another. Intuitively, you can think of something like cross-compiling from an x86_64/Linux platform to ARM64/Mac.\u003c/p\u003e\n\u003cp\u003eOn platforms like Linux, though, things can get a lot more nuanced, as Linux platform doesn’t necessarily mean one flavor of C standard library, so I’d refer to these platforms more accurately as x86_64/Linux/glibc. When you look at platforms from that perspective, even compiling from a platform with one standard library to another on the same x86_64/Linux setup, but with a different C library, you are effectively still cross-compiling. A concrete example would be cross-compiling from x86_64/Linux/glibc to x86_64/Linux/musl.\u003c/p\u003e\n\u003cp\u003eFurthermore, if you want to be extremely accurate and disciplined (as you should be if you want to build software that doesn’t break!), even building from one version of \u003ccode\u003eglibc\u003c/code\u003e for another is really cross-compiling. Again, as an example, building from x86_64/Linux/glibc_v1.0 for x86_64/Linux/glibc_v1.1 is cross-compilation.\u003c/p\u003e\n\u003cp\u003eThis can quickly get difficult, at least with the traditional way of building and using compilers (such as GCC, for example); however, those “ancient” ways are still stuck with us for the foreseeable future. I will soon write in more detail about this, and for now, we’ll use a shortcut described below.\u003c/p\u003e\n\u003ch3 id=\"toolchain-details\"\u003eToolchain details\u003c/h3\u003e\n\u003cp\u003eWe want a toolchain that satisfies two requirements:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eit builds from our host platform to RISC-V, i.e. it generates RISC-V instructions\u003c/li\u003e\n\u003cli\u003eit uses the Newlib library when C standard library functionality is invoked\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIf you’re on a typical Linux distribution, you likely have something like GCC (or even clang) installed. When you simply run GCC on a C file without any fancy flags, what happens is that the compiler will simply build for the same platform it runs on. More accurately, the host and the target are the same, and I believe the formal term for this is \u003cem\u003enative compilation\u003c/em\u003e. The reason why I bring this up is to ask ourselves what happens when we include something like \u003ccode\u003estdio.h\u003c/code\u003e and call something like \u003ccode\u003eprintf\u003c/code\u003e? Where is this \u003ccode\u003e.h\u003c/code\u003e file really pulled from and where is ultimately the \u003ccode\u003eprintf\u003c/code\u003e implementation found so it can be linked against?\u003c/p\u003e\n\u003cp\u003eThis really depends on \u003cstrong\u003ethe way your compiler was built\u003c/strong\u003e. When you build GCC from source, and you run \u003ccode\u003e./configure\u003c/code\u003e, you can specify a ton of flags that will drive this behavior. As promised, I will write more about it in the future. For now, let’s keep in mind that most Linux distributions we use in daily lives follow the old UNIX philosophy when it comes to this. For example, my Debian installation has \u003ccode\u003estdio.h\u003c/code\u003e in a standard directory at \u003ccode\u003e/usr/include\u003c/code\u003e. Furthermore, my standard C library (\u003ccode\u003eglibc\u003c/code\u003e) that can be dynamically linked is at \u003ccode\u003e/lib/x86_64-linux-gnu/libc.so\u003c/code\u003e (which really points to \u003ccode\u003e/lib/x86_64-linux-gnu/libc.so.6\u003c/code\u003e). Similarly, there is an \u003ccode\u003e.a\u003c/code\u003e file in there, but I will assume you know what \u003ccode\u003e.so\u003c/code\u003e and \u003ccode\u003e.a\u003c/code\u003e files are for. So, long story short, skipping a lot of details, your native compiler is set up to look for the C library in some of the standard spots, and when it builds for the same platform, it simply picks up the libraries from there.\u003c/p\u003e\n\u003cp\u003eTherefore, we need to:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eget the compiler that can generate instructions for the desired platform (machine code)\u003c/li\u003e\n\u003cli\u003eset up the C standard library for that particular platform somewhere\u003c/li\u003e\n\u003cli\u003eensure that the compiler for the target platform knows how to use the library from above\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFrom what I’ve seen, when it comes to cross-compilation, this is a fair amount of grungy work that needs to be done. The set up above takes a lot of building time and needs to be done in stages when done properly. A future article will go into details, but for now, as we mentioned before, we’ll go for a shortcut.\u003c/p\u003e\n\u003cp\u003eRemember for now that we want the includes, \u003ccode\u003e.so\u003c/code\u003e/\u003ccode\u003e.a\u003c/code\u003e files at some path, and we want the cross-compiler to look \u003cstrong\u003ethere\u003c/strong\u003e for the C standard library, not at the host’s \u003ccode\u003einclude\u003c/code\u003e and \u003ccode\u003elib\u003c/code\u003e directories. In this case since we want to build from something like x86_64 to RISC-V, it’s easy to spot errors, since if we use the host’s libraries, there is no way the wrong architecture would work, but when compiling for the same architecture and a different software platform, host contamination can be a real thing and can lead to very subtle and annoying problems! For example, we want the library code to be searched for at \u003ccode\u003e/usr/local/risc_v_stuff/lib\u003c/code\u003e instead of \u003ccode\u003e/usr/lib\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"automated-risc-v-toolchain-build\"\u003eAutomated RISC-V toolchain build\u003c/h3\u003e\n\u003cp\u003eFor this exercise, let’s simply use the \u003ca href=\"https://github.com/riscv-collab/riscv-gnu-toolchain/\"\u003eRISC-V toolchain\u003c/a\u003e. This project will still build everything from source on our host machine, but the whole annoying orchestration mentioned above, including staging the compilers, will be scripted and automated for us. With a few commands, we’ll kick off the process that will effectively set up something like \u003ccode\u003e/usr/local/risc_v_stuff/lib\u003c/code\u003e, \u003ccode\u003e/usr/local/risc_v_stuff/include\u003c/code\u003e, \u003ccode\u003e/usr/local/risc_v_stuff/compiler\u003c/code\u003e and you’ll be able to invoke \u003ccode\u003e/usr/local/risc_v_stuff/compiler/gcc\u003c/code\u003e which will know to peek into the right directories for different files and will build the right machine code. Of course, the paths will ultimately be different, but this should be good enough as a concept.\u003c/p\u003e\n\u003cp\u003eWe can start by cloning the Git repository linked above. The instructions say that the \u003ccode\u003e--recursive\u003c/code\u003e flag is not necessary during cloning and things will be dynamically pulled later, but for whatever reason, this \u003cstrong\u003edid not\u003c/strong\u003e work on my system. I ended up running a clone with the \u003ccode\u003e--recursive\u003c/code\u003e flag to avoid issues. It took a lot of time and space though, pulling in gigabytes and gigabytes of source code.\u003c/p\u003e\n\u003cp\u003eOnce the endless clone is done, you can configure the build. This is how I configured it:\u003c/p\u003e\n\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e./configure --prefix=/opt/riscv-newlib --enable-multilib --disable-gdb --with-cmodel=medany\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI strongly encourage you to run \u003ccode\u003e./configure --help\u003c/code\u003e to see what all the available options are and customize the build. For now, I will explain my parameters:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eprefix\u003c/code\u003e is simply where we’ll install the newly built artifacts, such as the cross-compiler, C standard library (Newlib in our case) and so on.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eenable-multilib\u003c/code\u003e will enable builds for different RISC-V setups. As a reminder, RISC-V has a ton of flavors, like \u003ccode\u003eRV32I\u003c/code\u003e, \u003ccode\u003eRV32IMA\u003c/code\u003e and so on. Please do note that enabling this flag will make your build \u003cstrong\u003esuper slow\u003c/strong\u003e. If you don’t want to run the build with multilib, then check the help menu to figure out how to build exactly for the fine grained platform that you need.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edisable-gdb\u003c/code\u003e: for whatever reason, building GDB would always fail for me, so I just excluded it from the toolchain. Real engineers debug with \u003ccode\u003eprintf\u003c/code\u003e anyway!\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewith-cmodel\u003c/code\u003e: hold on to this one, I will reveal this in a ‘gotcha’ moment; for now, let’s just keep in mind I needed this in order to make the 64-bit RISC-V builds work.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eNow that your build is configured, you can fire off the build process and leave it cooking for quite some time. One thing that surprised me here is that they didn’t use separate \u003ccode\u003emake\u003c/code\u003e and \u003ccode\u003emake install\u003c/code\u003e steps. Everything is done through just \u003ccode\u003emake\u003c/code\u003e, both the compilation and installation of the artifacts.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote: I wanted to parallelize the build with \u003ccode\u003e-j16\u003c/code\u003e as I normally do, but that also somehow broke my build, so I suggest running without this, and yes, I know it takes forever.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI simply ran\u003c/p\u003e\n\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003esudo make\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ein order to place the final artifacts in the \u003ccode\u003e/opt\u003c/code\u003e directory. This whole process is very slow, so make sure you have something else to do while this is working.\u003c/p\u003e\n\u003cp\u003eAlso, you may wonder where Newlib comes in here, when I mentioned that this whole process will automate how we get Newlib available. The answer is that Newlib is simply the default option for building our toolchain here. You can check the GitHub documentation on how to set up your cross-compiler to target a RISC-V \u003ccode\u003eglibc\u003c/code\u003e or \u003ccode\u003emusl\u003c/code\u003e, but what I’ve listed above is good enough to get a cross-compiler with Newlib as the target.\u003c/p\u003e\n\u003ch2 id=\"github-link\"\u003eGitHub link\u003c/h2\u003e\n\u003cp\u003eI have prepared \u003ca href=\"https://github.com/popovicu/bare-metal-cstdlib\"\u003ethis repository\u003c/a\u003e to run our example. The code explanations are below (hopefully they’re not out of sync with the repo itself).\u003c/p\u003e\n\u003ch2 id=\"implementing-the-memory-and-uart-building-blocks\"\u003eImplementing the memory and UART building blocks\u003c/h2\u003e\n\u003cp\u003eNow that you have a working cross-toolchain targeting RISC-V + Newlib, most of the heavy lifting is done and we can start putting together the Newlib building blocks. Let’s begin with UART, and the first file is \u003ccode\u003euart.h\u003c/code\u003e:\u003c/p\u003e\n\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e#ifndef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eUART_H\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#define\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eUART_H\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003euart_putc\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003euart_getc\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#endif\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is self-explanatory so far. Let’s see how these functions are implemented:\u003c/p\u003e\n\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e#include\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;uart.h\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// QEMU UART registers - these addresses are for QEMU\u0026#39;s 16550A UART\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#define\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eUART_BASE\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0x\u003c/span\u003e\u003cspan\u003e10000000\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#define\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eUART_THR\u003c/span\u003e\u003cspan\u003e  (\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evolatile\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(UART_BASE \u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0x\u003c/span\u003e\u003cspan\u003e00\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e // Transmit Holding Register\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#define\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eUART_RBR\u003c/span\u003e\u003cspan\u003e  (\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evolatile\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(UART_BASE \u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0x\u003c/span\u003e\u003cspan\u003e00\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e // Receive Buffer Register\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#define\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eUART_LSR\u003c/span\u003e\u003cspan\u003e  (\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evolatile\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(UART_BASE \u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0x\u003c/span\u003e\u003cspan\u003e05\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e // Line Status Register\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#define\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eUART_LSR_TX_IDLE\u003c/span\u003e\u003cspan\u003e  (\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e // Transmitter idle\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#define\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eUART_LSR_RX_READY\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e // Receiver ready\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003euart_putc\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e c)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Wait until transmitter is idle\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ewhile\u003c/span\u003e\u003cspan\u003e ((UART_LSR \u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e UART_LSR_TX_IDLE) \u003c/span\u003e\u003cspan\u003e==\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    UART_THR \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e c;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Special handling for newline (send CR+LF)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e (c \u003c/span\u003e\u003cspan\u003e==\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003ewhile\u003c/span\u003e\u003cspan\u003e ((UART_LSR \u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e UART_LSR_TX_IDLE) \u003c/span\u003e\u003cspan\u003e==\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        UART_THR \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e\\r\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003euart_getc\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Wait for data\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ewhile\u003c/span\u003e\u003cspan\u003e ((UART_LSR \u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e UART_LSR_RX_READY) \u003c/span\u003e\u003cspan\u003e==\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e UART_RBR;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe code above was AI-generated, but it’s accurate. And this is it as far as our UART driver is concerned. How does that now work with Newlib?\u003c/p\u003e\n\u003cp\u003eWe switch to the file called \u003ccode\u003esyscalls.c\u003c/code\u003e. Here, we implement the functions that \u003ccode\u003eprintf\u003c/code\u003e would rely on. We’ll also handle the input as well, just for fun. First, what happens here is we implement the primitives for writing to a file handle. The only file handles we’ll really support here are \u003ccode\u003estdout\u003c/code\u003e and \u003ccode\u003estderr\u003c/code\u003e. And to be perfectly accurate, there are no files here; we’re just intercepting the C standard library calls that otherwise work with these concepts.\u003c/p\u003e\n\u003cp\u003eMoving further, we provide super minimal implementations for a few more building blocks. They’re extremely basic, like the \u003ccode\u003e_close\u003c/code\u003e function, which essentially never allows any file handle to be closed.\u003c/p\u003e\n\u003cp\u003eThe one building block that is very interesting here is \u003ccode\u003e_sbrk\u003c/code\u003e. This is what gets invoked when the routines for dynamic memory allocation like \u003ccode\u003emalloc\u003c/code\u003e (needed by the \u003ccode\u003eprintf\u003c/code\u003e family of functions) need to ask the OS (when there is one) to provide more raw memory to the process, that can then be fragmented into smaller logical units by \u003ccode\u003emalloc\u003c/code\u003e. What happens here is we find the symbol \u003ccode\u003e_end\u003c/code\u003e defined by the linker, which marks the \u003ccode\u003e_end\u003c/code\u003e of the static sections (we’ll see how below) and we start using the memory past that address for heap allocations, all the way until we hit the stack. Once we hit the stack, we declare that an error as we have run out of memory.\u003c/p\u003e\n\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003evoid*\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e_sbrk\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eincr\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eextern\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e _end;\u003c/span\u003e\u003cspan\u003e         // Defined by the linker - start of heap\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eextern\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e _stack_bottom;\u003c/span\u003e\u003cspan\u003e // Defined in our linker script - bottom of stack area\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003estatic\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eheap_end \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e_end;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eprev_heap_end \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e heap_end;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Calculate safe stack limit - stack grows down from _stack_top towards _stack_bottom\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003estack_limit \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e_stack_bottom;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Check if heap would grow too close to stack\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e (heap_end \u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e incr \u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e stack_limit) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        errno \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e ENOMEM;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003evoid*\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003cspan\u003e // Return error\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    heap_end \u003c/span\u003e\u003cspan\u003e+=\u003c/span\u003e\u003cspan\u003e incr;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003evoid*\u003c/span\u003e\u003cspan\u003e) prev_heap_end;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePlease note that the stack top and bottom here refer to the beginning and the end of the memory block allocated for the stack, not the logical top or bottom of the stack itself from the application perspective.\u003c/p\u003e\n\u003ch2 id=\"application-example-input-and-output\"\u003eApplication example: input and output\u003c/h2\u003e\n\u003cp\u003eWe’re now ready to put the actual bare metal application together. If you need a refresher on \u003ca href=\"https://popovicu.com/posts/bare-metal-programming-risc-v\"\u003ebare metal programming on RISC-V\u003c/a\u003e, check it out again. That article covers the key addresses and the basics of putting a bare-metal linker script together.\u003c/p\u003e\n\u003cp\u003eThe app code itself is very self explanatory:\u003c/p\u003e\n\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e#include\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eprintf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello from RISC-V UART!\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ebuffer\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e100\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eprintf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Type something: \u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003escanf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e%s\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, buffer);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eprintf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;You typed: \u003c/span\u003e\u003cspan\u003e%s\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, buffer);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ewhile\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e) {}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePlease note that when we’re inputting something to this app, we won’t see our key presses echoed. This is because we’re not operating inside some sort of shell environment. The implementation as it is will simply accept the key presses and store them in the internal memory structure. We’ll see what was typed when we hit the final \u003ccode\u003eprintf\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe now need to also put together a small C runtime. When we develop a binary for an everyday OS, we typically don’t have to think about this, and the compiler will inject the standard startup runtime which takes care of setting up the process for proper execution and passing the control on to the \u003ccode\u003emain\u003c/code\u003e function.\u003c/p\u003e\n\u003cp\u003eOur minimalistic runtime will set up the stack pointer register, zero-fill the BSS section per C standard, and then call the \u003ccode\u003emain\u003c/code\u003e code. Just for good measure, we also leave an infinite loop at the end in case \u003ccode\u003emain\u003c/code\u003e returns. Again, with a proper OS below our code, a system call would be invoked to properly close the process, and it wouldn’t just loop infinitely.\u003c/p\u003e\n\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esection .text\u003c/span\u003e\u003cspan\u003e.init\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e.global _start\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e_start:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    la \u003c/span\u003e\u003cspan\u003esp\u003c/span\u003e\u003cspan\u003e, _stack_top\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   \u003c/span\u003e\u003cspan\u003e # Clear BSS section - using symbols defined in our linker script\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    la t0, _bss_start\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    la t1, _bss_end\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eclear_bss:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    bgeu t0, t1, bss_done\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    sb zero, \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e(t0)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    addi t0, t0, \u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    j clear_bss\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ebss_done:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   \u003c/span\u003e\u003cspan\u003e # Jump to C code\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ecall\u003c/span\u003e\u003cspan\u003e main\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   \u003c/span\u003e\u003cspan\u003e # In case main returns\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e:  j \u003c/span\u003e\u003cspan\u003e1b\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne of the most important parts of our application now is the linker script:\u003c/p\u003e\n\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eOUTPUT_FORMAT(\u0026#34;elf64-littleriscv\u0026#34;)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eOUTPUT_ARCH(\u0026#34;riscv\u0026#34;)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eENTRY(_start)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eMEMORY\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  RAM (rwx) : ORIGIN = 0x80000000, LENGTH = 64M\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eSECTIONS\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  /* Code section */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  .text : {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    *(.text.init)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    *(.text)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u0026gt; RAM\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  /* Read-only data */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  .rodata : {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    *(.rodata)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u0026gt; RAM\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  /* Initialized data */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  .data : {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    *(.data)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u0026gt; RAM\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  /* Small initialized data */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  .sdata : {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    *(.sdata)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u0026gt; RAM\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  /* BSS section with explicit symbols */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  .bss : {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    _bss_start = .;  /* Define BSS start symbol */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    *(.bss)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    *(COMMON)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    . = ALIGN(8);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    _bss_end = .;    /* Define BSS end symbol */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u0026gt; RAM\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  /* Small BSS section */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  .sbss : {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    _sbss_start = .;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    *(.sbss)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    *(.sbss.*)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    . = ALIGN(8);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    _sbss_end = .;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u0026gt; RAM\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  /* End marker for heap start */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  . = ALIGN(8);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  _end = .; /* Heap starts here and grows upwards */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  /* Stack grows downward from the end of RAM */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  _stack_size = 64K;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  _stack_top = ORIGIN(RAM) + LENGTH(RAM);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  _stack_bottom = _stack_top - _stack_size;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  /* Ensure we don\u0026#39;t overlap with heap */\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  ASSERT(_end \u0026lt;= _stack_bottom, \u0026#34;Error: Heap collides with stack\u0026#34;)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePer our previous investigation of bare metal programming for the QEMU VM, we know that the user-provided code will begin executing from \u003ccode\u003e0x80000000\u003c/code\u003e. Therefore, what we do is put the C runtime code that we previously wrote right there. In other words, our assembly code will be planted right at that memory address. Following our C runtime is the rest of the code, i.e. the \u003ccode\u003etext\u003c/code\u003e section. In this case, this is the C code we have written plus the C standard library we’re linking into our binary.\u003c/p\u003e\n\u003cp\u003eAfter that, we place the other sections like \u003ccode\u003erodata\u003c/code\u003e, \u003ccode\u003edata\u003c/code\u003e, \u003ccode\u003ebss\u003c/code\u003e, and so on. The linker script will capture the symbols for BSS start and end so it can be zero-filled by the C runtime, as seen above. There’s also a small BSS section, but the C runtime code doesn’t do anything about it, to stay compact, as it’s not used by the application. It probably should be zero-filled as well.\u003c/p\u003e\n\u003cp\u003eThen, we capture where the small BSS section ends because that also marks the end of our static sections. Following that, we let the growing heap consume everything, up until the stack. The stack occupies the last 64K of memory (and we described RAM as being 64M at the top of the linker script). A few addition and subtraction operations are done to determine where this exactly is, and we do an assert check to make sure there is no collision between the heap and the stack.\u003c/p\u003e\n\u003cp\u003eThe concept is simple: we identify the “void” between the static sections and the stack, and we let the C standard library that we’re putting together via Newlib to maintain the growing heap in there. A real kernel like Linux would do its memory management magic here, handle the virtual addresses and so on, but here we really have one “process” and a simple memory extension operation \u003ccode\u003esbrk\u003c/code\u003e is enough for what we want to achieve here.\u003c/p\u003e\n\u003ch3 id=\"the-gotcha-moment\"\u003eThe ‘gotcha’ moment\u003c/h3\u003e\n\u003cp\u003eNow let’s reflect back on the fact that we configured the toolchain to be built with the \u003ccode\u003e--with-cmodel=medany\u003c/code\u003e flag. What does this flag really control, and why did we need it?\u003c/p\u003e\n\u003cp\u003eIf you read the top of the linker script carefully, we’re building for a 64-bit RISC-V machine. Per QEMU, our instructions will begin at \u003ccode\u003e0x80000000\u003c/code\u003e, and we decided to simply lay the rest of the code after that. To handle these high values, we need to use the correct machine instructions to handle these high addresses. So our application code likely needs to use the memory address model which can handle any address, and so we build our logic with \u003ccode\u003e-mcmodel=medany\u003c/code\u003e. To be compatible, our C standard library also needs that.\u003c/p\u003e\n\u003cp\u003eIf we didn’t have the aforementioned flag, the Newlib library would be built with RISC-V instructions that cannot effectively use such high addresses. Remember, the C standard library is pre-built before our application. The build system will simply pick up the machine code from the relevant library directory and link it to your application code. If the addresses do not fit the value range that the instructions support, the linker is not able to make things work.\u003c/p\u003e\n\u003cp\u003eAs I understand, there is a concept of \u003cem\u003elinker relaxation\u003c/em\u003e, where the linker itself can make the code modifications, but I don’t think it would help in this case.\u003c/p\u003e\n\u003cp\u003eI don’t want to spend too much time on this, I hope the explanation above suffices, and if you would like to learn more about this problem, check out \u003ca href=\"https://github.com/riscvarchive/riscv-gcc/issues/153\"\u003ethis link\u003c/a\u003e, where the reporter had linker errors and a solution was offered.\u003c/p\u003e\n\u003ch2 id=\"running-the-app\"\u003eRunning the app\u003c/h2\u003e\n\u003cp\u003eI’ve included a \u003ccode\u003eMakefile\u003c/code\u003e in the GitHub repo. Check it out to see what exactly is going on there, especially how the cross-compiler is invoked (should be the first line of the file), as well as QEMU for emulation. I will highlight a few things here.\u003c/p\u003e\n\u003cp\u003eOne of the \u003ccode\u003eCFLAGS\u003c/code\u003e is \u003ccode\u003e-specs=nosys.specs\u003c/code\u003e. This will drive the toolchain to use the ‘nosys’ flavor of Newlib. This is the most minimal flavor where all the building blocks are just stubs by default that return zeroes or errors.\u003c/p\u003e\n\u003cp\u003eLinker flags include \u003ccode\u003e-nostartfiles\u003c/code\u003e which means that we’ll be providing our own minimal C runtime, that we have described above.\u003c/p\u003e\n\u003cp\u003eThe rest of the \u003ccode\u003eMakefile\u003c/code\u003e should be fairly easy to follow. I strongly suggest using the \u003ccode\u003edebug\u003c/code\u003e target though. We’ll just go ahead and run:\u003c/p\u003e\n\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003emake\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003edebug\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe QEMU process starts, I punch in \u003ccode\u003efoo\u003c/code\u003e and hit enter, and after getting back my app’s output, I stop QEMU:\u003c/p\u003e\n\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emake\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003edebug\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e/opt/riscv-newlib/bin/riscv64-unknown-elf-gcc\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-march=rv64imac_zicsr\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-mabi=lp64\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-mcmodel=medany\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-specs=nosys.specs\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-O2\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-g\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-Wall\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-c\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emain.c\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-o\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emain.o\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e/opt/riscv-newlib/bin/riscv64-unknown-elf-gcc\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-march=rv64imac_zicsr\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-mabi=lp64\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-mcmodel=medany\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-specs=nosys.specs\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-O2\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-g\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-Wall\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-c\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003euart.c\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-o\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003euart.o\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e/opt/riscv-newlib/bin/riscv64-unknown-elf-gcc\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-march=rv64imac_zicsr\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-mabi=lp64\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-mcmodel=medany\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-specs=nosys.specs\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-O2\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-g\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-Wall\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-c\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003esyscalls.c\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-o\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003esyscalls.o\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e/opt/riscv-newlib/bin/riscv64-unknown-elf-gcc\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-march=rv64imac_zicsr\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-mabi=lp64\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-mcmodel=medany\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-specs=nosys.specs\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-O2\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-g\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-Wall\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-c\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003estartup.S\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-o\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003estartup.o\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e/opt/riscv-newlib/bin/riscv64-unknown-elf-gcc\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-march=rv64imac_zicsr\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-mabi=lp64\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-mcmodel=medany\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-specs=nosys.specs\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-O2\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-g\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-Wall\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-T\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003elink.ld\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-nostartfiles\u003c/span\u003e\u003cspan\u003e   \u003c/span\u003e\u003cspan\u003e-o\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efirmware.elf\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emain.o\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003euart.o\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003esyscalls.o\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003estartup.o\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e/opt/riscv-newlib/lib/gcc/riscv64-unknown-elf/14.2.0/../../../../riscv64-unknown-elf/bin/ld:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ewarning:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efirmware.elf\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ehas\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ea\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eLOAD\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003esegment\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eRWX\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epermissions\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eqemu-system-riscv64\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-machine\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003evirt\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-m\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e256\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-nographic\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-bios\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efirmware.elf\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-d\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ein_asm,cpu_reset\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-D\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eqemu_debug.log\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eHello\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eRISC-V\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eUART!\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eType\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003esomething:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eYou\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003etyped:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efoo\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe reason why I suggest using the \u003ccode\u003edebug\u003c/code\u003e target is because it drops a file called \u003ccode\u003eqemu_debug.log\u003c/code\u003e. That file is pretty cool as it shows you a complete trace of what your VM has been through. Naturally, you can inspect all the Newlib code if you want to figure out how \u003cstrong\u003eexactly\u003c/strong\u003e \u003ccode\u003eprintf\u003c/code\u003e works, but I thought it’s still a pretty nice view of what the RISC-V core actually sees. Since we’re building an \u003ccode\u003eELF\u003c/code\u003e file and passing it to \u003ccode\u003eQEMU\u003c/code\u003e, it’s even able to tell us which function we’re exactly in. It doesn’t have that for the first couple of instructions since we’re, as a reminder, executing the initial hardcoded bootloader, and then our initial C runtime, before jumping into the \u003ccode\u003emain\u003c/code\u003e function. If the first few instructions before \u003ccode\u003e0x80000000\u003c/code\u003e confuse you, please check out \u003ca href=\"https://popovicu.com/posts/risc-v-sbi-and-full-boot-process\"\u003eRISC-V boot process with SBI\u003c/a\u003e to understand what’s going on. Excerpt of my debug log is below:\u003c/p\u003e\n\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e----------------\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eIN:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ePriv: 3; Virt: 0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000000001000:  00000297          auipc                   t0,0                    # 0x1000\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000000001004:  02828613          addi                    a2,t0,40\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000000001008:  f1402573          csrrs                   a0,mhartid,zero\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e----------------\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eIN:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ePriv: 3; Virt: 0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x000000000000100c:  0202b583          ld                      a1,32(t0)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000000001010:  0182b283          ld                      t0,24(t0)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000000001014:  00028067          jr                      t0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e----------------\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eIN:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ePriv: 3; Virt: 0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000080000000:  04000117          auipc                   sp,67108864             # 0x84000000\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000080000004:  00010113          mv                      sp,sp\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000080000008:  00015297          auipc                   t0,86016                # 0x80015008\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x000000008000000c:  d5828293          addi                    t0,t0,-680\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000080000010:  00015317          auipc                   t1,86016                # 0x80015010\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000080000014:  d5030313          addi                    t1,t1,-688\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000080000018:  0062f663          bleu                    t1,t0,12                # 0x80000024\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e----------------\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eIN:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ePriv: 3; Virt: 0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000080000024:  0be020ef          jal                     ra,8382                 # 0x800020e2\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e----------------\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eIN: main\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ePriv: 3; Virt: 0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x00000000800020e2:  7119              addi                    sp,sp,-128\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x00000000800020e4:  00011517          auipc                   a0,69632                # 0x800130e4\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x00000000800020e8:  db450513          addi                    a0,a0,-588\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x00000000800020ec:  fc86              sd                      ra,120(sp)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x00000000800020ee:  10e000ef          jal                     ra,270                  # 0x800021fc\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e----------------\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eIN: puts\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ePriv: 3; Virt: 0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x00000000800021fc:  85aa              mv                      a1,a0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x00000000800021fe:  00012517          auipc                   a0,73728                # 0x800141fe\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000080002202:  ffa53503          ld                      a0,-6(a0)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0x0000000080002206:  b7bd              j                       -146                    # 0x80002174\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eWith this example, we have ported some of the very powerful features over to our bare-metal platform, and we somewhat retained the feeling of coding on top of a proper kernel. We could keep going and enable things like “file” access, memory management and so on.\u003c/p\u003e\n\u003cp\u003eIn fact, what is really interesting here is that the door is now open to use some powerful libraries in our bare-metal code, that are otherwise not necessarily expecting a bare metal environment. Some library could expect to open a file and if the only way it does it is through using the C standard library, we can essentially intercept that API call and without passing the request to the kernel, we can service it in our bare metal code.\u003c/p\u003e\n\u003cp\u003eAnd the concept to do this was quite simple: depend on the building blocks that Newlib defines, provide your own implementation that takes precedence over the Newlib defaults, and use the defaults for whatever you don’t care about.\u003c/p\u003e\n\u003cp\u003eOf course, in absolutely minimal environments, the size of the final software image can be a concern, as well as the amount of instructions we’re injecting, but looking at the \u003ccode\u003eELF\u003c/code\u003e file that we build in our project, it’s at \u003ccode\u003e220K\u003c/code\u003e which doesn’t really sound too bad. Ultimately, however, it is up to you to decide what abstractions you will use in your project. This should be one of the tools in your toolbox that can hopefully save you some time in your development.\u003c/p\u003e\n\u003cp\u003eGood luck with your hacking!\u003c/p\u003e\n\u003cp\u003ePlease consider following on \u003ca href=\"https://twitter.com/popovicu94\"\u003eTwitter/X\u003c/a\u003e and \u003ca href=\"https://www.linkedin.com/in/upopovic/\"\u003eLinkedIn\u003c/a\u003e to stay updated.\u003c/p\u003e\n    \u003c/article\u003e\u003c/div\u003e",
  "readingTime": "30 min read",
  "publishedTime": null,
  "modifiedTime": null
}
