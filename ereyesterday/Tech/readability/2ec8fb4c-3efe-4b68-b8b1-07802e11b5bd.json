{
  "id": "2ec8fb4c-3efe-4b68-b8b1-07802e11b5bd",
  "title": "The atrocious state of binary compatibility on Linux and how to address it",
  "link": "https://jangafx.com/insights/linux-binary-compatibility",
  "description": "Comments",
  "author": "",
  "published": "Tue, 01 Apr 2025 22:22:46 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 31404,
  "excerpt": "The atrocious state of binary compatibility on Linux and how to address it",
  "siteName": "",
  "favicon": "https://jangafx.com/icon.png?13777d91f0eb8c85",
  "text": "The Atrocious State Of Binary Compatibility on Linux and How To Address It. By Dale Weiler GitHub Time To Read: ~30 Minutes Last Updated: Monday, March 17th 2025 Summary Linux binary compatibility is plagued by one thing that is often overlooked when evaluating shipping software on Linux. This article will deconstruct how to arrive to that conclusion, how to address it when shipping software today and what needs to be done to actually fix it. Table of contents Introduction Containers Versioning System Libraries Our Approach Fixing It Questioning It Introduction At JangaFX, we make several products that run natively on Linux. We love the flexibility and power that Linux offers our developers, but shipping software on it is a whole different challenge. Linux is an incredibly powerful platform, but when it comes to shipping software, it can feel like a minefield. Unlike other operating systems, Linux isn’t just one system—it’s a chaotic mix of different services, libraries, and even philosophies. Every distribution does things a little differently, and that means the same executable that works flawlessly on one system might completely break on another. This shouldn’t even be a problem. The Linux kernel itself has maintained relatively stable system calls. But everything built on top of it changes constantly in ways that break compatibility, making it incredibly frustrating to ship software that \"just works.\" If you’re developing for Linux, you’re not targeting a single platform—you’re navigating an ecosystem that has evolved without much concern for binary compatibility. Some of us, coming from the game industry before moving into VFX have dealt with this problem before. Shipping games on Linux has always been a nightmare, and the same issues persists regardless of industry. In this article, We're going to explain why we think containers are the wrong approach, how we build and ship Linux software in a way that actually works, what we think is responsible for Linux's binary compatibility problem and what needs to change to fix it. The latter part of this article will get deeply technical about what exactly the problem is and how it can be fixed. Containers Tools like Flatpak, AppImage, and similar solutions attempt to simplify shipping executables by creating \"containers\"—or as as we've recently taken to calling them, \"a Linux Environment inside a Linux\" Using Linux features like namespaces and chroots, these solutions package an entire Linux environment, complete with all required dependencies, into a single self-contained bundle. In extreme cases, this means shipping an entire Linux user-space just for one application. One of the major challenges with these containerized solutions is that they often don’t work well with applications that need to interact with the rest of the system. To access hardware-accelerated APIs like OpenGL, Vulkan, VDPAU or CUDA, an application must dynamically link against the system's graphics driver libraries. Since these libraries exist outside the container and cannot be shipped with the application, various \"pass-through\" techniques have been developed to work around this, some of which introduce runtime overhead (e.g., shimming libraries). Because containerized applications are isolated from the system, they often feel isolated too. This creates consistency issues, where the application may not recognize the user’s name, home directory, system settings, desktop environment preferences, or even have proper access to the filesystem. To work around these limitations, many containerized environments rely on the XDG Desktop Portal protocol, which introduces yet another layer of complexity. This system requires IPC (inter-process communication) through DBus just to grant applications access to basic system features like file selection, opening URLs, or reading system settings—problems that wouldn’t exist if the application weren’t artificially sandboxed in the first place. We don’t believe that piling on more layers is an acceptable solution. As engineers, we need to stop and ask ourselves: \"should we keep adding to this tower of Babel?\", or is it time to peel back some of these abstractions and reevaluate them? At some point, the right solution isn’t more complexity—it’s less. While containerized solutions can work under certain conditions, we believe that shipping lean, native executables—without containers—provides a more seamless and integrated experience that better aligns with user expectations. Versioning When you compile your application, it links against the specific library versions present on the build machine. This means that by default, the versions on a user's system may not match, causing compatibility issues. Let’s assume the user has all the necessary libraries installed, but the versions don’t match what your application was built against. This is where the real problem begins. Short of shipping the exact machine used to deploy your application, how do you ensure compatibility with the versions installed on a user’s system? We believe there are two ways to solve this problem, and we've given them our own names: Replication Approach – This means bundling all the libraries from the build machine and shipping them with your application. This is the philosophy behind Flatpak and AppImage. We do not use this approach at JangaFX. Relaxation Approach – Instead of relying on specific or newer library versions, you link against versions that are so old they’re almost guaranteed to be compatible everywhere. This minimizes the risk of incompatibility on a user’s system. The first approach works well in cases where the necessary libraries may not exist on a user’s machine, but it fails for libraries that cannot be shipped (we call these \"system libraries\") The second approach is particularly effective for system libraries and is the approach we use at JangaFX. System Libraries There are various libraries present on a Linux machine that cannot be shipped because they are system libraries. These are libraries tied to the system itself and cannot be provided in a container. Typically these include things like user-space drivers for the GPU, enterprise installed components for security, and of course, libc itself. If you’ve ever tried to distribute Linux binaries, you may have encountered an error message like this: /lib64/libc.so.6: version `GLIBC_2.18' not found For those unaware, glibc (GNU C Library) provides the C standard library, POSIX APIs, and the dynamic linker responsible for loading shared libraries, and itself. GLIBC is an example of a \"system library\" that cannot be bundled with your application because it includes the dynamic linker itself. This linker is responsible for loading other libraries, some of which may also depend on GLIBC—but not always. Complicating matters further, since GLIBC is a dynamic library, it must also load itself. This self-referential, chicken-and-egg problem highlights GLIBC’s complexity and monolithic design, as it attempts to fulfill multiple roles simultaneously. A large downside to this monolithic design is that upgrading GLIBC often requires upgrading the entire system. Later in this article, we will explain why this structure needs to change to truly solve Linux’s binary compatibility problem. Before you suggest statically linking GLIBC—that’s not an option. GLIBC relies on dynamic linking for features like NSS modules, which handle hostname resolution, user authentication, and network configuration, among other dynamically loaded components. Static linking breaks this because it does not include the dynamic linker, which is why GLIBC does not officially support it. Even if you managed to statically link GLIBC—or used an alternative like musl—your application would be unable to load any dynamic libraries at runtime. Static linking the dynamic linker itself is not possible, for reasons that will be explained later. In short, this would prevent your application from dynamically linking against any system libraries at all. Our Approach Since our application relies on many non-system libraries that may not be installed on the user’s system, we need a way to include them. The most straightforward approach is the Replication Approach, where we ship these libraries alongside our application. However, this negates the benefits of dynamic linking, such as shared memory usage and system-wide updates. In such cases, statically linking these libraries into the application is a better choice, as it eliminates dependency issues entirely. It also enables additional optimizations, such as LTO, and results in a smaller package by stripping unused components from the included libraries. Instead, we take a different approach: statically linking everything we can. When doing so, special care is needed if a dependency embeds another dependency within its static library. We've encountered static libraries that include object files from other static libraries (e.g., libcurl), but we still need to link them separately. This duplication is conveniently avoided with dynamic libraries, but with static libraries, you may need to extract all object files from the archive and remove the embedded ones manually. Similarly, compiler runtimes like libgcc default to dynamic linking. We recommend using -static-libgcc. Finally, when it comes to dealing with system libraries, we use the Relaxation Approach. Rather than requiring exact or newer versions of system libraries, we link against versions that are old enough to be nearly universally compatible. This increases the likelihood that the user’s system libraries will work with our application, reducing dependency issues without the need for containerization or bundling system components and shims. The method we suggest when linking against older system libraries is to obtain a corresponding older Linux environment. You don’t need to install an old Linux version on physical hardware or even set up a full virtual machine. Instead, a chroot provides a lightweight, isolated environment within an existing Linux installation, allowing you to build against an older system without the overhead of full virtualization. Ironically, this suggests that containers were the right solution all along—just not at runtime, but at build time. To achieve this, we use debootstrap, an excellent script that creates a minimal Debian installation from scratch. Debian is particularly suited for this approach due to its stability and long-term support for older releases, making it a great choice for ensuring compatibility with older system libraries. Of course, once you have an older Linux setup, you may find that its binary package toolchains are too outdated to build your software. To address this, we compile a modern LLVM toolchain from source and use it to build both our dependencies and our software. The details of this process are beyond the scope of this article. Finally, we automate the entire debootstrap process with a Python script, which we've included here for reference. #!/bin/env python3 import os, subprocess, shutil, multiprocessing PACKAGES = [ 'build-essential' ] DEBOOSTRAP = 'https://salsa.debian.org/installer-team/debootstrap.git' ARCHIVE = 'http://archive.debian.org/debian' VERSION = 'jessie' # Released in 2015 def chroot(pipe): try: os.chroot('chroot') os.chdir('/') # Setup an environment for the chroot env = { 'HOME': '/root', 'TERM': 'xterm', 'PATH': '/bin:/usr/bin:/sbin:/usr/sbin' } # The Debian is going to be quite old and so the keyring keys will likely be # expired. To work around this we will replace the sources.list to contain # '[trusted=yes]' with open('/etc/apt/sources.list', 'w') as fp: fp.write(f'deb [trusted=yes] http://archive.debian.org/debian {VERSION} main\\n') # Update and install packages subprocess.run(['apt', 'update'], env=env) subprocess.run(['apt', 'install', '-y', *PACKAGES], env=env) # # Script your Linux here, remember to pass `env=env` to subprocess.run. # # We suggest downloading GCC 7.4.0, compiling from source, and installing # it since it's the minimum version required to compile the latest LLVM from # source. We then suggest downloading, compiling from source, and installing # the latest LLVM, which as of time of writing is 20.1.0. # # You can then compile and install all other source packages your software # requires from source using this modern LLVM toolchain. # # You can also enter the chroot with an interactive shell from this script # by uncommenting the following and running this script as usual. # subprocess.run(['bash']) # # You can send messages to the parent with pipe.send() pipe.send('Done') # This one has special meaning in main except Exception as exception: pipe.send(exception) def main(): # We need to run as root to use 'mount', 'umount', and 'chroot' if os.geteuid() != 0: print('Script must be run as root') return False with multiprocessing.Manager() as manager: mounts = manager.list() pipe = multiprocessing.Pipe() def mount(parts): subprocess.run(['mount', *parts]) mounts.append(parts[-1]) # Ensure we have a fresh chroot and clone of debootstrap shutil.rmtree('chroot', ignore_errors=True) shutil.rmtree('debootstrap', ignore_errors=True) os.mkdir('chroot') # Clone debootstrap subprocess.run(['git', 'clone', DEBOOSTRAP]) subprocess.run(['debootstrap', '--arch', 'amd64', VERSION, '../chroot', ARCHIVE], env={**os.environ, 'DEBOOTSTRAP_DIR': '.'}, cwd='debootstrap') # Mount nodes needed for the chroot mount(['-t', 'proc', '/proc', 'chroot/proc']) mount(['--rbind', '/sys', 'chroot/sys']) mount(['--make-rslave', 'chroot/sys']) mount(['--rbind', '/dev', 'chroot/dev']) mount(['--make-rslave', 'chroot/dev']) # Setup the chroot in a separate process process = multiprocessing.Process(target=chroot, args=(pipe[1],)) process.start() try: while True: data = pipe[0].recv() if isinstance(data, Exception): raise data else: print(data) if data == 'Done': break finally: process.join() for umount in reversed(list(set(mounts))): subprocess.run(['umount', '-R', umount]) subprocess.run(['sync']) if __name__ == '__main__': try: main() except KeyboardInterrupt: print('Cancelled') Fixing it Generally, most applications do not link directly against system libraries, and instead load which ever is present on the user's machine already at runtime. So while these libraries are considered system components, they typically have few system dependencies beyond libc itself. This is what makes libc—specifically GLIBC—the real source of compatibility issues, it's essentially the only system component directly linked against. In just the past two years, our team has encountered three separate GLIBC-specific compatibility issues, each directly impacting our products: https://sourceware.org/bugzilla/show_bug.cgi?id=29456 https://sourceware.org/bugzilla/show_bug.cgi?id=32653 https://sourceware.org/bugzilla/show_bug.cgi?id=32786 From our perspective, the core issue with GLIBC is that it tries to do far too much. It’s a massive, monolithic system that handles everything—from system calls and memory management to threading and even the dynamic linker. This tight coupling is why upgrading GLIBC often means upgrading the entire system; everything is intertwined. If it were broken into smaller, more focused components, users could update only the parts that change, rather than dragging their whole system along with it. More importantly, separating the dynamic linker from the C library itself would allow multiple versions of libc to coexist, eliminating a major source of compatibility issues. This is exactly how Windows handles it, which is one of the reasons Windows maintains such strong binary compatibility. You can still run decades-old Windows software today because Microsoft doesn’t force everything to be tied to a single, ever-changing libc. Of course, this isn’t as simple as just splitting things apart. GLIBC has deep cross-cutting concerns, particularly with threading, TLS (Thread-Local Storage), and global memory management. For example, even if you managed to get two versions of GLIBC to coexist, returning allocated memory from one and attempting to free it in another would likely lead to serious issues. Their heaps would be unaware of each other, potentially using different allocation strategies, causing unpredictable failures. To avoid this, even the heap would likely need to be separated into its own dedicated libheap. We think a better approach would be breaking GLIBC into distinct libraries, something like this: libsyscall – Handles making system calls and nothing else. This is provided as a static library only. Used by libheap, libthread and libc to gain access to shared system call code. Since it's static it's embedded in all three. You can pretend this library otherwise does not exist. libdl (Dynamic Linker) – A standalone linker that loads shared libraries. Links only against libsyscall statically. Is a true, free-standing library, depending on nothing. Provided as both a static and dynamic library. When you link against it statically you can still load things with it dynamically. You just end up with a dynamic linker inside your executable. libheap - The single heap shared by all below. Links against libsyscall statically. Provided only as a dynamic library. Cannot ever be linked against statically. libthread – Deals with threading and TLS, links against libheap. Provided only as a dynamic library. Cannot ever be linked against statically. libc – Links against libthread, and thus libheap, and libdl transitively. Provided as both a static and dynamic library. When linking statically it links libdl statically. The linking of libthread and libheap is always done dynamically though through the included libdl if linked statically or through libdl program loader if linked dynamically. These libraries would be aware of each other and allow multiple versions to coexist in the same address space. That way, we don’t end up with this brittle mess where upgrading GLIBC can break everything. The actual structure would look something like This architecture is quite similar to Windows, where the equivalents of libsyscall, libdl, libheap, and libthread are all bundled within a single kernel32.dll. This DLL is pre-mapped and automatically loaded into the address space of every executable on Windows. Statically Linked libc Application statically links libc and libdl (it is not the program loader). Application starts execution and dynamically loads libheap and libthread using embedded libdl. [Application] │ ▼ [libc (static)] │ ▼ [libdl (static)] ├── [libheap (dynamic)] └── [libthread (dynamic)] └── [libheap (dynamic)] libc and libdl are embedded in the executable, meaning the application itself starts execution. The embedded libdl dynamically loads libthread and libheap. Dynamically Linked libc Application starts execution via the program interpreter (libdl). libdl (program loader) loads the application and resolves dependencies. Application dynamically links libc, libheap, and libthread. [Application (interpreter entry)] │ ▼ [libdl (program loader)] │ ▼ [libc (dynamic)] ├── [libheap (dynamic)] ├── [libthread (dynamic)] │ └── [libheap (dynamic)] ▼ [Application (regular entry)] Comparison Table Scenariolibdl (included by)libc (how it loads)libthread (via libdl)libheap (via libdl)Static libcStatic linkingStatic linkingLinked by libdlLinked by libdlDynamic libcProgram interpreterLinked by libdlLinked by libdlLinked by libdl This architecture effectively reduces the binary compatibility problem to two key system libraries: libheap and libthread. These cannot be statically linked because they manage shared resources critical to the entire system. The reason is straightforward—heap memory must be shared across all components, ensuring compatibility between allocations and deallocations. Similarly, TLS and threading require a unified system-wide approach, as they involve complex initialization and finalization logic, particularly for global constructors and destructors. However, these components are relatively small and stable, meaning they undergo fewer changes that would necessitate version updates. Questioning it This is, of course, a non-trivial amount of rearchitecting, which naturally raises the question: why is libc implemented the way it is instead of this alternative approach? Setting historical reasons aside, attempting to solve this problem quickly becomes difficult the moment you start writing any code using libc. Here is a trivial example of the issues that arise when trying to support multiple versions of libc. Suppose you have a dynamic library that contains the following C code. #include \u003cstdio.h\u003e FILE* open_thing() { return fopen(\"thing.bin\", \"r\"); } And your application links against this library and calls open_thing. Your application would be responsible for calling fclose on the returned FILE*. If your code links against a different version of libc from the version the library links against, then it would be calling the wrong implementation of fclose! Suppose though, that libc was written in such a way that the FILE* returned always required a version field or a pointer to a vtable containing the implementation of fclose (and other functions) and every version of libc agreed on this so that it could always call the correct one across this ABI boundary. This would solve this compatibility issue, but now lets say your code calls fflush. // Defined in header \u003cstdio.h\u003e int fflush(FILE *fp); Except it doesn't flush the file, and instead passes NULL. fflush(NULL); If you're not familiar with C's fflush function, passing NULL to it requires flushing all open files (every FILE*). However, in this scenario, it would only flush files seen by the libc version your application is linked against, not those opened by other libc versions (such as the one used by open_thing). To handle this correctly, each libc version would need a way to enumerate files across all other libc instances, including dynamically loaded ones, ensuring that every file is visited exactly once without forming cycles. This enumeration must also be thread-safe. Additionally, while enumeration is in progress, another libc could be dynamically loaded (e.g., via dlopen) on a separate thread, or a new file could be opened (e.g., a global constructor in a dynamically loaded library calling fopen). This global list of things owned by libc shows up in multiple places. Take for instance: // Defined in header \u003cstdlib.h\u003e int atexit(void (*func)(void)); Registers the function pointed to by func to be called on normal program termination (via exit() or returning from main()). The functions will be called in reverse order they were registered, i.e. the function registered last will be executed first. There is also another variant of this called at_quick_exit. This implies that somewhere within libc, there must be a list of functions registered via atexit that need to be executed in reverse order. For multiple libc implementations to coexist, any system handling atexit must not only enumerate and call all registered functions, but also establish a total order for how they were inserted across all instances of libc. Essentially, any resource owned by one libc would need to be sharable and accessible from any other version of libc. This turns out to be quite a lot of things. For the sake of our argument we've actually gone through all of the standard C (not POSIX) functions which produce or operate on a resource which has an opaque implementation where careful considerations would need to be made. HeaderFunctionResourceNotes\u003cfenv.h\u003eN/Afexcept_tFloat environment exceptions need to be stable across libc.\u003cfenv.h\u003e*fexcept_tAny functions using this type\u003cfenv.h\u003efegetenvfenv_tFloat environment needs to be stable across libc.\u003cfenv.h\u003e*fenv_tAny functions using this type\u003clocale.h\u003elocaleconvstruct lconvCommon initial sequence needs to be stable across libc.\u003cmath.h\u003eN/AintMath defines need to have a stable set of integer values across libc.\u003csetjmp.h\u003eN/Ajmp_bufUsually defined by compiler\u003csetjmp.h\u003e*jmp_bufUsually defined by compiler intrinsic\u003csignal.h\u003eN/AintSignal defines need to have a stable set of integer values across libc.\u003csignal.h\u003eN/Asig_atomic_tStable type across libc\u003cstdarg.h\u003eN/Ava_listUsually defined by compiler\u003cstdarg.h\u003eva_startva_listUsually defined by compiler intrinsic\u003cstdarg.h\u003e*va_listAny functions or macros using this type\u003cstdatomic.h\u003e*_Atomic TStable type across libc\u003cstdatomic.h\u003eN/AintAtomic defines need to have a stable set of integer values across libc.\u003cstdatomic.h\u003eN/AtypedefMany typedefs need to have a stable set of types across libc.\u003cstddef.h\u003eN/AtypedefMany typedefs need to have a stable set of types across libc.\u003cstdint.h\u003eN/AtypedefMany typedefs need to have a stable set of types across libc.\u003cstdint.h\u003eN/AintMany defines need to have a stable set of types across libc.\u003cstdio.h\u003e*FILEMany functions (any taking FILE* or returning FILE*)\u003cstdio.h\u003eN/AtypedefMany types need to have a stable set of types across libc.\u003cstdio.h\u003eN/AintMany defines need to have a stable set of integer values across libc.\u003cstdio.h\u003eN/AN/ALocale for string formatting needs to be shared across libc\u003cstdio.h\u003estderrN/ANeeds to be a macro that expands to a function call like __stdio(STDERR_FILENO)\u003cstdio.h\u003estdoutN/ANeeds to be a macro that expands to a function call like __stdio(STDOUT_FILENO)\u003cstdio.h\u003estdinN/ANeeds to be a macro that expands to a function call like __stdio(STDIO_FILENO)\u003cstdlib.h\u003eN/Adiv_t,Needs to have a stable definition across libc.\u003cstdlib.h\u003eN/Aldiv_t,Needs to have a stable definition across libc.\u003cstdlib.h\u003eN/Alldiv_tNeeds to have a stable definition across libc.\u003cstdlib.h\u003eN/AintMany defines need to have a stable set of integer values across libc.\u003cstdlib.h\u003ecall_onceonce_flagNeeds to be stable across libc and also libthread\u003cstdlib.h\u003erandN/AGlobal PRNG needs to be shared across libc.\u003cstdlib.h\u003esrandN/AGlobal PRNG needs to be shared across libc.\u003cstdlib.h\u003ealigned_allocvoid*Shared heap\u003cstdlib.h\u003ecallocvoid*Shared heap\u003cstdlib.h\u003efreevoid*Shared heap\u003cstdlib.h\u003efree_sizedvoid*Shared heap\u003cstdlib.h\u003efree_aligned_sizevoid*Shared heap\u003cstdlib.h\u003emallocvoid*Shared heap\u003cstdlib.h\u003ereallocvoid*Shared heap\u003cstdlib.h\u003eatexitN/AGlobal list needs to be shared across libc.\u003cstdlib.h\u003eat_quick_exitN/AGlobal list needs to be shared across libc.\u003cstring.h\u003estrcollN/ALC_COLLATE locale needs to be shared across libc\u003cthreads.h\u003eN/Acnd_tAny opaque method\u003cthreads.h\u003eN/Athrd_tAny opaque method\u003cthreads.h\u003eN/Atss_tAny opaque method\u003cthreads.h\u003eN/Amtx_tAny opaque method\u003cthreads.h\u003e*cnd_tMany functions using this type\u003cthreads.h\u003e*thrd_tMany functions using this type\u003cthreads.h\u003e*tss_tMany functions using this type\u003cthreads.h\u003e*mtx_tMany functions using this type\u003cthreads.h\u003e*typedefMany types need to have a stable set of types across libc.\u003cthreads.h\u003eN/AintMany defines need to have a stable set of integer values across libc.\u003cthreads.h\u003ecall_onceonce_flagSee \u003cstdlib.h\u003e above\u003ctime.h\u003eN/AtypedefMany types need to have a stable set of types across libc.\u003ctime.h\u003eN/Astruct tmCommon initial sequence needs to be stable across libc.\u003cuchar.h\u003eN/Achar8_tNeeds to be same across libc\u003cuchar.h\u003eN/Achar16_tNeeds to be same across libc\u003cuchar.h\u003eN/Achar32_tNeeds to be same across libc\u003cuchar.h\u003e*char8_tMany functions using this type\u003cuchar.h\u003e*char16_tMany functions using this type\u003cuchar.h\u003e*char32_tMany functions using this type\u003cuchar.h\u003eN/Ambstate_tAny opaque method\u003cuchar.h\u003e*mbstate_tMany functions using this type.\u003cwchar.h\u003e**Repeat of \u003cuchar.h\u003e essentially\u003cwctype.h\u003eN/Awctrans_tNeed to be same across libc\u003cwctype.h\u003eN/Awctype_tNeed to be same across libc\u003cwctype.h\u003e*wctrans_tMany functions using this type\u003cwctype.h\u003e*wctype_tMany functions using this type Most defines (of constants), ABI-exposed types (and typedefs) should just be stable across libc implementations for this to work reliably. Since these are baked into executables there's no real way to modify or change them without breaking stuff anyways. When discussing stuff that is opaque (listed as Any opaque method) we propose affixing a pointer to a vtable containing the implementation as the first value in the type, this way functions operating on it can always recover the correct implementation and dispatch it indirectly through the vtable. Other methods like using a version field can also work here too. Regardless, certain aspects of libc introduce complexity, particularly global and thread-local elements like errno and locale. However, with a well-designed architecture, these challenges can be effectively addressed. Memory allocation functions—calloc, malloc, aligned_alloc, realloc, and free—from \u003cstdlib.h\u003e pose another difficulty. Since they can return any pointer, tracking them is non-trivial. One possible approach is to store a pointer to a vtable in the allocation header, allowing each allocation to reference its implementation. However, this method incurs significant performance and memory overhead. Instead, we propose centralizing heap management in a dedicated libheap. This would also contain implementation of the POSIX extensions like posix_memalign. Things get even more interesting when moving from standard C to POSIX, which introduces unique challenges that require libc support. Some of these functionalities might be better split into separate libraries (for example, why is the DNS resolver in libc?). Among these challenges though, setxid stands out. For those unfamiliar, permissions in POSIX—such as the real, effective, and saved user/group IDs—apply at the process level. However, Linux treats threads as independent processes that share memory, meaning these permissions are managed per thread rather than per process. To comply with POSIX semantics, libc must interrupt every thread, forcing them to execute code that invokes the system call to modify their thread-local permissions. This must be done atomically, without failure, and while remaining async-signal safe. This is a nightmare to implement and has proven to be a major challenge. More importantly, getting it right is crucial for security. Ultimately, this means libc must track every thread and provide a way to synchronously execute code across all threads. To address this, we propose consolidating threading, TLS, and the necessary POSIX compliance mechanisms within a single libthread. There are many additional complexities we’ve glossed over and many alternative ways this can be implemented. The key takeaway is that these issues are solvable—they just require significant architectural changes. This necessitates reevaluating this aspect of the Linux userspace from the ground up with binary compatibility as a core design principle. GLIBC has never seriously attempted this. Until someone decides, \"enough is enough, let’s fix this,\" binary compatibility on Linux will remain an unsolved problem; we strongly believe this is a problem worth solving.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"linuxBinaryCompatibilityPage\"\u003e\u003ch2\u003eThe Atrocious State Of Binary Compatibility on Linux and How To Address It.\u003c/h2\u003e\n\u003cp\u003eBy Dale Weiler \u003ca href=\"https://github.com/graphitemaster/\"\u003eGitHub\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTime To Read: ~30 Minutes\u003c/li\u003e\n\u003cli\u003eLast Updated: Monday, March 17th 2025\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eSummary\u003c/h2\u003e\n\u003cp\u003eLinux binary compatibility is plagued by one thing that is often overlooked when evaluating shipping software on Linux. This article will deconstruct how to arrive to that conclusion, how to address it when shipping software today and what needs to be done to actually fix it.\u003c/p\u003e\n\u003cp\u003eTable of contents\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#containers\"\u003eContainers\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#versioning\"\u003eVersioning\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#system-libraries\"\u003eSystem Libraries\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#our-approach\"\u003eOur Approach\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#fixing-it\"\u003eFixing It\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#questioning-it\"\u003eQuestioning It\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eAt JangaFX, we make several products that run natively on Linux. We love the flexibility and power that Linux offers our developers, but shipping software on it is a whole different challenge.\u003c/p\u003e\n\u003cp\u003eLinux is an incredibly powerful platform, but when it comes to shipping software, it can feel like a minefield. Unlike other operating systems, Linux isn’t just one system—it’s a chaotic mix of different services, libraries, and even philosophies. Every distribution does things a little differently, and that means the same executable that works flawlessly on one system might completely break on another.\u003c/p\u003e\n\u003cp\u003eThis shouldn’t even be a problem. The Linux kernel itself has maintained relatively stable system calls. But everything built on top of it changes constantly in ways that break compatibility, making it incredibly frustrating to ship software that \u0026#34;just works.\u0026#34; If you’re developing for Linux, you’re not targeting a single platform—you’re navigating an ecosystem that has evolved without much concern for binary compatibility.\u003c/p\u003e\n\u003cp\u003eSome of us, coming from the game industry before moving into VFX have dealt with this problem before. Shipping games on Linux has always been a nightmare, and the same issues persists regardless of industry. In this article, We\u0026#39;re going to explain why we think containers are \u003cstrong\u003ethe wrong approach\u003c/strong\u003e, how we build and ship Linux software in a way that actually works, what we think is responsible for Linux\u0026#39;s binary compatibility problem and what needs to change to fix it.\u003c/p\u003e\n\u003ch4\u003eThe latter part of this article will get deeply technical about what exactly the problem is and how it can be fixed.\u003c/h4\u003e\n\u003ch2\u003eContainers\u003c/h2\u003e\n\u003cp\u003eTools like \u003ca href=\"https://flatpak.org/\"\u003eFlatpak\u003c/a\u003e, \u003ca href=\"https://appimage.org/\"\u003eAppImage\u003c/a\u003e, and similar solutions attempt to simplify shipping executables by creating \u0026#34;containers\u0026#34;—or as as we\u0026#39;ve recently taken to calling them, \u003cstrong\u003e\u0026#34;a Linux Environment inside a Linux\u0026#34;\u003c/strong\u003e Using Linux features like \u003ca href=\"https://en.wikipedia.org/wiki/Linux_namespaces\"\u003enamespaces\u003c/a\u003e and \u003ca href=\"https://en.wikipedia.org/wiki/Chroot\"\u003echroots\u003c/a\u003e, these solutions package an entire Linux environment, complete with all required dependencies, into a single self-contained bundle. In extreme cases, this means shipping an entire Linux user-space just for one application.\u003c/p\u003e\n\u003cp\u003eOne of the major challenges with these containerized solutions is that they\noften don’t work well with applications that need to interact with the rest of\nthe system. To access hardware-accelerated APIs like\n\u003ca href=\"https://en.wikipedia.org/wiki/OpenGL\"\u003eOpenGL\u003c/a\u003e,\n\u003ca href=\"https://en.wikipedia.org/wiki/Vulkan_(API)\"\u003eVulkan\u003c/a\u003e,\n\u003ca href=\"https://en.wikipedia.org/wiki/VDPAU\"\u003eVDPAU\u003c/a\u003e or\n\u003ca href=\"https://developer.nvidia.com/cuda-zone\"\u003eCUDA\u003c/a\u003e, an application must dynamically\nlink against the system\u0026#39;s graphics driver libraries. Since these libraries exist\noutside the container and cannot be shipped with the application, various\n\u0026#34;pass-through\u0026#34; techniques have been developed to work around this, some of which\nintroduce runtime overhead (e.g., shimming libraries). Because containerized applications are isolated from the system, they often \u003cstrong\u003efeel\u003c/strong\u003e isolated too. This creates consistency issues, where the application may not recognize the user’s name, home directory, system settings, desktop environment preferences, or even have proper access to the filesystem.\u003c/p\u003e\n\u003cp\u003eTo work around these limitations, many containerized environments rely on the\n\u003ca href=\"https://wiki.archlinux.org/title/XDG_Desktop_Portal\"\u003e\u003cstrong\u003eXDG Desktop Portal\u003c/strong\u003e\u003c/a\u003e\nprotocol, which introduces yet another layer of complexity. This system requires\nIPC (inter-process communication) through\n\u003ca href=\"https://en.wikipedia.org/wiki/D-Bus\"\u003e\u003cstrong\u003eDBus\u003c/strong\u003e\u003c/a\u003e just to grant applications\naccess to basic system features like file selection, opening URLs, or reading\nsystem settings—problems that wouldn’t exist if the application weren’t\nartificially sandboxed in the first place.\u003c/p\u003e\n\u003cp\u003eWe don’t believe that piling on more layers is an acceptable solution. As engineers, we need to stop and ask ourselves: \u0026#34;should we keep adding to this tower of Babel?\u0026#34;, or is it time to peel back some of these abstractions and reevaluate them? At some point, the right solution isn’t more complexity—it’s less.\u003c/p\u003e\n\u003cp\u003eWhile containerized solutions can work under certain conditions, we believe that shipping lean, native executables—without containers—provides a more seamless and integrated experience that better aligns with user expectations.\u003c/p\u003e\n\u003ch2\u003eVersioning\u003c/h2\u003e\n\u003cp\u003eWhen you compile your application, it links against the specific library versions present on the build machine. This means that by default, the versions on a user\u0026#39;s system may not match, causing compatibility issues. Let’s assume the user has all the necessary libraries installed, but the versions don’t match what your application was built against. This is where the real problem begins.\nShort of shipping the exact machine used to deploy your application, how do you ensure compatibility with the versions installed on a user’s system?\u003c/p\u003e\n\u003cp\u003eWe believe there are two ways to solve this problem, and we\u0026#39;ve given them our own names:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eReplication Approach\u003c/strong\u003e – This means bundling all the libraries from the build machine and shipping them with your application. This is the philosophy behind Flatpak and AppImage. We do \u003cstrong\u003enot\u003c/strong\u003e use this approach at JangaFX.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRelaxation Approach\u003c/strong\u003e – Instead of relying on specific or newer library versions, you link against versions that are so old they’re almost guaranteed to be compatible everywhere. This minimizes the risk of incompatibility on a user’s system.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe first approach works well in cases where the necessary libraries may not exist on a user’s machine, but it fails for libraries that cannot be shipped (we call these \u0026#34;system libraries\u0026#34;) The second approach is particularly effective for system libraries and is the approach we use at JangaFX.\u003c/p\u003e\n\u003ch2\u003eSystem Libraries\u003c/h2\u003e\n\u003cp\u003eThere are various libraries present on a Linux machine that cannot be shipped because they are system libraries. These are libraries tied to the system itself and cannot be provided in a container. Typically these include things like user-space drivers for the GPU, enterprise installed components for security, and of course, \u003ca href=\"https://en.wikipedia.org/wiki/C_standard_library\"\u003elibc\u003c/a\u003e itself.\u003c/p\u003e\n\u003cp\u003eIf you’ve ever tried to distribute Linux binaries, you may have encountered an error message like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/lib64/libc.so.6: version `GLIBC_2.18\u0026#39; not found\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFor those unaware, \u003cstrong\u003eglibc\u003c/strong\u003e (GNU C Library) provides the C standard library, POSIX APIs, and the dynamic linker responsible for loading shared libraries, and itself.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eGLIBC is an example of a \u0026#34;system library\u0026#34; that cannot be bundled with your\napplication because it includes the dynamic linker itself. This linker is\nresponsible for loading other libraries, some of which may also depend on\nGLIBC—but not always. Complicating matters further, since GLIBC is a dynamic\nlibrary, it must also load itself. This self-referential, chicken-and-egg\nproblem highlights GLIBC’s complexity and monolithic design, as it attempts to\nfulfill multiple roles simultaneously. A large downside to this monolithic\ndesign is that upgrading GLIBC often requires upgrading the entire system. Later in this article, we will\nexplain why this structure needs to change to truly solve Linux’s binary\ncompatibility problem.\u003c/p\u003e\n\u003cp\u003eBefore you suggest statically linking GLIBC—\u003cstrong\u003ethat’s not an option.\u003c/strong\u003e GLIBC relies on dynamic linking for features like \u003ca href=\"https://en.wikipedia.org/wiki/Name_Service_Switch\"\u003eNSS\u003c/a\u003e modules, which handle hostname resolution, user authentication, and network configuration, among other dynamically loaded components. Static linking breaks this because it does not include the dynamic linker, which is why GLIBC does not officially support it. Even if you managed to statically link GLIBC—or used an alternative like \u003ca href=\"https://musl.libc.org/\"\u003emusl\u003c/a\u003e—your application would be unable to load any dynamic libraries at runtime. Static linking the dynamic linker itself is not possible, for reasons that will be explained later. In short, this would prevent your application from dynamically linking against any system libraries at all.\u003c/p\u003e\n\u003ch2\u003eOur Approach\u003c/h2\u003e\n\u003cp\u003eSince our application relies on many non-system libraries that may not be installed on the user’s system, we need a way to include them. The most straightforward approach is the \u003cstrong\u003eReplication Approach\u003c/strong\u003e, where we ship these libraries alongside our application. However, this negates the benefits of dynamic linking, such as shared memory usage and system-wide updates. In such cases, statically linking these libraries into the application is a better choice, as it eliminates dependency issues entirely. It also enables additional optimizations, such as \u003ca href=\"https://en.wikipedia.org/wiki/Interprocedural_optimization\"\u003eLTO\u003c/a\u003e, and results in a smaller package by stripping unused components from the included libraries.\u003c/p\u003e\n\u003cp\u003eInstead, we take a different approach: \u003cstrong\u003estatically linking everything we can\u003c/strong\u003e. When doing so, special care is needed if a dependency embeds another dependency within its static library. We\u0026#39;ve encountered static libraries that include object files from other static libraries (e.g., libcurl), but we still need to link them separately. This duplication is conveniently avoided with dynamic libraries, but with static libraries, you may need to extract all object files from the archive and remove the embedded ones manually. Similarly, compiler runtimes like \u003ccode\u003elibgcc\u003c/code\u003e default to dynamic linking. We recommend using \u003ccode\u003e-static-libgcc\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFinally, when it comes to dealing with system libraries, we use the \u003cstrong\u003eRelaxation Approach\u003c/strong\u003e. Rather than requiring exact or newer versions of system libraries, we link against versions that are old enough to be nearly universally compatible. This increases the likelihood that the user’s system libraries will work with our application, reducing dependency issues without the need for containerization or bundling system components and shims.\u003c/p\u003e\n\u003cp\u003eThe method we suggest when linking against older system libraries is to obtain a corresponding older Linux environment. You don’t need to install an old Linux version on physical hardware or even set up a full virtual machine. Instead, a \u003cstrong\u003echroot\u003c/strong\u003e provides a lightweight, isolated environment within an existing Linux installation, allowing you to build against an older system without the overhead of full virtualization. Ironically, this suggests that containers were the right solution all along—just not at runtime, but at build time.\u003c/p\u003e\n\u003cp\u003eTo achieve this, we use \u003ca href=\"https://salsa.debian.org/installer-team/debootstrap\"\u003edebootstrap\u003c/a\u003e, an excellent script that creates a minimal Debian installation from scratch. Debian is particularly suited for this approach due to its stability and long-term support for older releases, making it a great choice for ensuring compatibility with older system libraries.\u003c/p\u003e\n\u003cp\u003eOf course, once you have an older Linux setup, you may find that its binary package toolchains are too outdated to build your software. To address this, we compile a modern LLVM toolchain from source and use it to build both our dependencies and our software. The details of this process are beyond the scope of this article.\u003c/p\u003e\n\u003cp\u003eFinally, we automate the entire debootstrap process with a Python script, which we\u0026#39;ve included here for reference.\u003c/p\u003e\n\u003cpre\u003e\u003cp\u003e\u003ccode\u003e\u003cspan\u003e#!/bin/env python3\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e os\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e subprocess\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e shutil\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e multiprocessing\n\u003c/span\u003e\n\u003cspan\u003ePACKAGES \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;build-essential\u0026#39;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003eDEBOOSTRAP \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;https://salsa.debian.org/installer-team/debootstrap.git\u0026#39;\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003eARCHIVE \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;http://archive.debian.org/debian\u0026#39;\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003eVERSION \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;jessie\u0026#39;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e# Released in 2015\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003echroot\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epipe\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003etry\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    os\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003echroot\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;chroot\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    os\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003echdir\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;/\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# Setup an environment for the chroot\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    env \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003e\u0026#39;HOME\u0026#39;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;/root\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003e\u0026#39;TERM\u0026#39;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;xterm\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003e\u0026#39;PATH\u0026#39;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;/bin:/usr/bin:/sbin:/usr/sbin\u0026#39;\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# The Debian is going to be quite old and so the keyring keys will likely be\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# expired. To work around this we will replace the sources.list to contain\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# \u0026#39;[trusted=yes]\u0026#39;\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eopen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;/etc/apt/sources.list\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;w\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eas\u003c/span\u003e\u003cspan\u003e fp\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e      fp\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewrite\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ef\u0026#39;deb [trusted=yes] http://archive.debian.org/debian \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003eVERSION\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e main\\n\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# Update and install packages\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    subprocess\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erun\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;apt\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;update\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e env\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eenv\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    subprocess\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erun\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;apt\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;install\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;-y\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ePACKAGES\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e env\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eenv\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# Script your Linux here, remember to pass `env=env` to subprocess.run.\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# We suggest downloading GCC 7.4.0, compiling from source, and installing\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# it since it\u0026#39;s the minimum version required to compile the latest LLVM from\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# source. We then suggest downloading, compiling from source, and installing\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# the latest LLVM, which as of time of writing is 20.1.0.\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# You can then compile and install all other source packages your software\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# requires from source using this modern LLVM toolchain.\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# You can also enter the chroot with an interactive shell from this script\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# by uncommenting the following and running this script as usual.\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e#  subprocess.run([\u0026#39;bash\u0026#39;])\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# You can send messages to the parent with pipe.send()\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    pipe\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Done\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e# This one has special meaning in main\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eexcept\u003c/span\u003e\u003cspan\u003e Exception \u003c/span\u003e\u003cspan\u003eas\u003c/span\u003e\u003cspan\u003e exception\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    pipe\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eexception\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e# We need to run as root to use \u0026#39;mount\u0026#39;, \u0026#39;umount\u0026#39;, and \u0026#39;chroot\u0026#39;\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e os\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egeteuid\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e!=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Script must be run as root\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eFalse\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e multiprocessing\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eManager\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eas\u003c/span\u003e\u003cspan\u003e manager\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    mounts \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e manager\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    pipe \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e multiprocessing\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ePipe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emount\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparts\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e      subprocess\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erun\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;mount\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eparts\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e      mounts\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparts\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# Ensure we have a fresh chroot and clone of debootstrap\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    shutil\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ermtree\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;chroot\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e ignore_errors\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eTrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    shutil\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ermtree\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;debootstrap\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e ignore_errors\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eTrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    os\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emkdir\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;chroot\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# Clone debootstrap\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    subprocess\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erun\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;git\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;clone\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e DEBOOSTRAP\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    subprocess\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erun\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;debootstrap\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;--arch\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;amd64\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e VERSION\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;../chroot\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e ARCHIVE\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e                    env\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003eos\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eenviron\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;DEBOOTSTRAP_DIR\u0026#39;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e                    cwd\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#39;debootstrap\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# Mount nodes needed for the chroot\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    mount\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;-t\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;proc\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;/proc\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;chroot/proc\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    mount\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;--rbind\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;/sys\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;chroot/sys\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    mount\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;--make-rslave\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;chroot/sys\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    mount\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;--rbind\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;/dev\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;chroot/dev\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    mount\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;--make-rslave\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;chroot/dev\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# Setup the chroot in a separate process\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    process \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e multiprocessing\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eProcess\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etarget\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003echroot\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e args\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epipe\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    process\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003etry\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003ewhile\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eTrue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        data \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e pipe\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erecv\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eisinstance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e Exception\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e          \u003c/span\u003e\u003cspan\u003eraise\u003c/span\u003e\u003cspan\u003e data\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e          \u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e          \u003c/span\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e data \u003c/span\u003e\u003cspan\u003e==\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;Done\u0026#39;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e            \u003c/span\u003e\u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003efinally\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e      process\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejoin\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003efor\u003c/span\u003e\u003cspan\u003e umount \u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ereversed\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eset\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emounts\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        subprocess\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erun\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;umount\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;-R\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e umount\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        subprocess\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erun\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#39;sync\u0026#39;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e __name__ \u003c/span\u003e\u003cspan\u003e==\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;__main__\u0026#39;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003etry\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    main\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eexcept\u003c/span\u003e\u003cspan\u003e KeyboardInterrupt\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Cancelled\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/p\u003e\u003c/pre\u003e\n\u003ch2\u003eFixing it\u003c/h2\u003e\n\u003cp\u003eGenerally, most applications do not link directly against system libraries, and instead load which ever is present on the user\u0026#39;s machine already at runtime. So while these libraries are considered system components, they typically have few system dependencies beyond libc itself. This is what makes libc—specifically \u003cstrong\u003eGLIBC\u003c/strong\u003e—the real source of compatibility issues, it\u0026#39;s essentially the only system component directly linked against.\u003c/p\u003e\n\u003cp\u003eIn just the past two years, our team has encountered three separate \u003cstrong\u003eGLIBC-specific\u003c/strong\u003e compatibility issues, each directly impacting our products:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://sourceware.org/bugzilla/show_bug.cgi?id=29456\"\u003ehttps://sourceware.org/bugzilla/show_bug.cgi?id=29456\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://sourceware.org/bugzilla/show_bug.cgi?id=32653\"\u003ehttps://sourceware.org/bugzilla/show_bug.cgi?id=32653\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://sourceware.org/bugzilla/show_bug.cgi?id=32786\"\u003ehttps://sourceware.org/bugzilla/show_bug.cgi?id=32786\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFrom our perspective, the core issue with \u003cstrong\u003eGLIBC\u003c/strong\u003e is that it tries to do far too much. It’s a massive, monolithic system that handles everything—from system calls and memory management to threading and even the dynamic linker. This tight coupling is why upgrading \u003cstrong\u003eGLIBC\u003c/strong\u003e often means upgrading the entire system; everything is intertwined. If it were broken into smaller, more focused components, users could update only the parts that change, rather than dragging their whole system along with it.\u003c/p\u003e\n\u003cp\u003eMore importantly, separating the dynamic linker from the \u003cstrong\u003eC library\u003c/strong\u003e itself would allow multiple versions of \u003cstrong\u003elibc\u003c/strong\u003e to coexist, eliminating a major source of compatibility issues. This is exactly how \u003cstrong\u003eWindows\u003c/strong\u003e handles it, which is one of the reasons Windows maintains such strong binary compatibility. You can still run decades-old Windows software today because Microsoft doesn’t force everything to be tied to a single, ever-changing libc.\u003c/p\u003e\n\u003cp\u003eOf course, this isn’t as simple as just splitting things apart. GLIBC has deep cross-cutting concerns, particularly with threading, TLS (Thread-Local Storage), and global memory management.\u003c/p\u003e\n\u003cp\u003eFor example, even if you managed to get two versions of GLIBC to coexist, returning allocated memory from one and attempting to free it in another would likely lead to serious issues. Their heaps would be unaware of each other, potentially using different allocation strategies, causing unpredictable failures. To avoid this, even the heap would likely need to be separated into its own dedicated \u003cstrong\u003elibheap\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWe think a better approach would be breaking GLIBC into distinct libraries, something like this:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003elibsyscall\u003c/strong\u003e – Handles making system calls and nothing else. This is\nprovided as a static library only. Used by \u003ccode\u003elibheap\u003c/code\u003e, \u003ccode\u003elibthread\u003c/code\u003e and \u003ccode\u003elibc\u003c/code\u003e to gain access to shared system call code. Since it\u0026#39;s static it\u0026#39;s embedded in all three. You can pretend this library otherwise does not exist.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003elibdl (Dynamic Linker)\u003c/strong\u003e – A standalone linker that loads shared libraries.\nLinks only against \u003ccode\u003elibsyscall\u003c/code\u003e statically. Is a true, free-standing library, depending on nothing. Provided as both a static and dynamic library. When you link against it statically you can still load things with it dynamically. You just end up with a dynamic linker inside your executable.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003elibheap\u003c/strong\u003e - The single heap shared by all below. Links against \u003ccode\u003elibsyscall\u003c/code\u003e\nstatically. Provided only as a dynamic library. Cannot ever be linked against statically.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003elibthread\u003c/strong\u003e – Deals with threading and TLS, links against\n\u003ccode\u003elibheap\u003c/code\u003e. Provided only as a dynamic library. Cannot ever be linked against statically.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003elibc\u003c/strong\u003e – Links against \u003ccode\u003elibthread\u003c/code\u003e, and thus \u003ccode\u003elibheap\u003c/code\u003e, and \u003ccode\u003elibdl\u003c/code\u003e transitively. Provided as both a static and dynamic library. When linking statically it links \u003ccode\u003elibdl\u003c/code\u003e statically. The linking of \u003ccode\u003elibthread\u003c/code\u003e and \u003ccode\u003elibheap\u003c/code\u003e is always done dynamically though through the included \u003ccode\u003elibdl\u003c/code\u003e if linked statically or through \u003ccode\u003elibdl\u003c/code\u003e program loader if linked dynamically.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese libraries would be aware of each other and allow multiple versions to\ncoexist in the same address space. That way, we don’t end up with this brittle\nmess where upgrading GLIBC can break everything. The actual structure would look\nsomething like\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis architecture is quite similar to Windows, where the equivalents of\n\u003ccode\u003elibsyscall\u003c/code\u003e, \u003ccode\u003elibdl\u003c/code\u003e, \u003ccode\u003elibheap\u003c/code\u003e, and \u003ccode\u003elibthread\u003c/code\u003e are all bundled within a single\n\u003ccode\u003ekernel32.dll\u003c/code\u003e. This DLL is pre-mapped and automatically loaded into the\naddress space of every executable on Windows.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e\u003cstrong\u003eStatically Linked \u003ccode\u003elibc\u003c/code\u003e\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eApplication statically links \u003ccode\u003elibc\u003c/code\u003e and \u003ccode\u003elibdl\u003c/code\u003e (it is not the program loader).\u003c/li\u003e\n\u003cli\u003eApplication starts execution and dynamically loads \u003ccode\u003elibheap\u003c/code\u003e and \u003ccode\u003elibthread\u003c/code\u003e using embedded \u003ccode\u003elibdl\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003e[Application]\n   │\n   ▼\n[libc (static)]\n   │\n   ▼\n[libdl (static)]\n   ├── [libheap (dynamic)]\n   └── [libthread (dynamic)]\n          └── [libheap (dynamic)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elibc\u003c/code\u003e and \u003ccode\u003elibdl\u003c/code\u003e are embedded in the executable, meaning the application itself starts execution.\u003c/li\u003e\n\u003cli\u003eThe embedded \u003ccode\u003elibdl\u003c/code\u003e dynamically loads \u003ccode\u003elibthread\u003c/code\u003e and \u003ccode\u003elibheap\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr/\u003e\n\u003ch3\u003e\u003cstrong\u003eDynamically Linked \u003ccode\u003elibc\u003c/code\u003e\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eApplication starts execution via the program interpreter (\u003ccode\u003elibdl\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elibdl\u003c/code\u003e (program loader) loads the application and resolves dependencies.\u003c/li\u003e\n\u003cli\u003eApplication dynamically links \u003ccode\u003elibc\u003c/code\u003e, \u003ccode\u003elibheap\u003c/code\u003e, and \u003ccode\u003elibthread\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003e[Application (interpreter entry)]\n   │\n   ▼\n[libdl (program loader)]\n   │\n   ▼\n[libc (dynamic)]\n   ├── [libheap (dynamic)]\n   ├── [libthread (dynamic)]\n   │      └── [libheap (dynamic)]\n   ▼\n[Application (regular entry)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003eComparison Table\u003c/strong\u003e\u003c/h3\u003e\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eScenario\u003c/th\u003e\u003cth\u003e\u003ccode\u003elibdl\u003c/code\u003e (included by)\u003c/th\u003e\u003cth\u003e\u003ccode\u003elibc\u003c/code\u003e (how it loads)\u003c/th\u003e\u003cth\u003e\u003ccode\u003elibthread\u003c/code\u003e (via \u003ccode\u003elibdl\u003c/code\u003e)\u003c/th\u003e\u003cth\u003e\u003ccode\u003elibheap\u003c/code\u003e (via \u003ccode\u003elibdl\u003c/code\u003e)\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eStatic \u003ccode\u003elibc\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eStatic linking\u003c/td\u003e\u003ctd\u003eStatic linking\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eLinked by \u003ccode\u003elibdl\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eLinked by \u003ccode\u003elibdl\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eDynamic \u003ccode\u003elibc\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eProgram interpreter\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eLinked by \u003ccode\u003elibdl\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eLinked by \u003ccode\u003elibdl\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eLinked by \u003ccode\u003elibdl\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eThis architecture effectively reduces the binary compatibility problem to two key \u003cstrong\u003esystem libraries\u003c/strong\u003e: \u003ccode\u003elibheap\u003c/code\u003e and \u003ccode\u003elibthread\u003c/code\u003e. These cannot be statically linked because they manage shared resources critical to the entire system.\u003c/p\u003e\n\u003cp\u003eThe reason is straightforward—heap memory must be shared across all components, ensuring compatibility between allocations and deallocations. Similarly, TLS and threading require a unified system-wide approach, as they involve complex initialization and finalization logic, particularly for global constructors and destructors. However, these components are relatively small and stable, meaning they undergo fewer changes that would necessitate version updates.\u003c/p\u003e\n\u003ch2\u003eQuestioning it\u003c/h2\u003e\n\u003cp\u003eThis is, of course, a non-trivial amount of rearchitecting, which naturally raises the question: why is libc implemented the way it is instead of this alternative approach?\u003c/p\u003e\n\u003cp\u003eSetting historical reasons aside, attempting to solve this problem quickly\nbecomes difficult the moment you start writing any code using libc. Here is a trivial example of the issues that arise when trying to support multiple\nversions of libc.\u003c/p\u003e\n\u003cp\u003eSuppose you have a dynamic library that contains the following C code.\u003c/p\u003e\n\u003cpre\u003e\u003cp\u003e\u003ccode\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003einclude\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003eFILE\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eopen_thing\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efopen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;thing.bin\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/p\u003e\u003c/pre\u003e\n\u003cp\u003eAnd your application links against this library and calls \u003ccode\u003eopen_thing\u003c/code\u003e. Your application would be responsible for calling \u003ccode\u003efclose\u003c/code\u003e on the returned \u003ccode\u003eFILE*\u003c/code\u003e. If your code links against a different version of libc from the version the library links against, then it would be calling the wrong implementation of \u003ccode\u003efclose\u003c/code\u003e!\u003c/p\u003e\n\u003cp\u003eSuppose though, that libc was written in such a way that the \u003ccode\u003eFILE*\u003c/code\u003e returned always required a version field or a pointer to a \u003ca href=\"https://en.wikipedia.org/wiki/Virtual_method_table\"\u003evtable\u003c/a\u003e containing the implementation of \u003ccode\u003efclose\u003c/code\u003e (and other functions) and every version of libc agreed on this so that it could always call the correct one across this ABI boundary. This would solve this compatibility issue, but now lets say your code calls \u003ccode\u003efflush\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003cp\u003e\u003ccode\u003e\u003cspan\u003e// Defined in header \u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efflush\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eFILE \u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003efp\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/code\u003e\u003c/p\u003e\u003c/pre\u003e\n\u003cp\u003eExcept it doesn\u0026#39;t flush the file, and instead passes \u003ccode\u003eNULL\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003cp\u003e\u003ccode\u003e\u003cspan\u003efflush\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNULL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/code\u003e\u003c/p\u003e\u003c/pre\u003e\n\u003cp\u003eIf you\u0026#39;re not familiar with C\u0026#39;s \u003ccode\u003efflush\u003c/code\u003e function, passing \u003ccode\u003eNULL\u003c/code\u003e to it requires flushing all open files (every \u003ccode\u003eFILE*\u003c/code\u003e). However, in this scenario, it would only flush files seen by the libc version your application is linked against, not those opened by other libc versions (such as the one used by \u003ccode\u003eopen_thing\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eTo handle this correctly, each libc version would need a way to enumerate files across all other libc instances, including dynamically loaded ones, ensuring that every file is visited exactly once without forming cycles. This enumeration must also be thread-safe. Additionally, while enumeration is in progress, another libc could be dynamically loaded (e.g., via \u003ccode\u003edlopen\u003c/code\u003e) on a separate thread, or a new file could be opened (e.g., a global constructor in a dynamically loaded library calling \u003ccode\u003efopen\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eThis global list of things owned by libc shows up in multiple places. Take for instance:\u003c/p\u003e\n\u003cpre\u003e\u003cp\u003e\u003ccode\u003e\u003cspan\u003e// Defined in header \u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eatexit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003efunc\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/code\u003e\u003c/p\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRegisters the function pointed to by \u003cem\u003efunc\u003c/em\u003e to be called on normal program termination (via \u003ccode\u003eexit()\u003c/code\u003e or returning from \u003ccode\u003emain()\u003c/code\u003e). The functions will be called in reverse order they were registered, i.e. the function registered last will be executed first.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThere is also another variant of this called \u003ccode\u003eat_quick_exit\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis implies that somewhere within libc, there must be a list of functions registered via \u003ccode\u003eatexit\u003c/code\u003e that need to be executed in reverse order. For multiple libc implementations to coexist, any system handling \u003ccode\u003eatexit\u003c/code\u003e must not only enumerate and call all registered functions, but also establish a total order for how they were inserted across all instances of libc.\u003c/p\u003e\n\u003cp\u003eEssentially, any resource owned by one libc would need to be sharable and accessible from any other version of libc. This turns out to be quite a lot of things. For the sake of our argument we\u0026#39;ve actually gone through all of the standard C (not POSIX) functions which produce or operate on a resource which has an opaque implementation where careful considerations would need to be made.\u003c/p\u003e\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eHeader\u003c/th\u003e\u003cth\u003eFunction\u003c/th\u003e\u003cth\u003eResource\u003c/th\u003e\u003cth\u003eNotes\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;fenv.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efexcept_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eFloat environment exceptions need to be stable across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;fenv.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efexcept_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eAny functions using this type\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;fenv.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efegetenv\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efenv_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eFloat environment needs to be stable across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;fenv.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efenv_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eAny functions using this type\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;locale.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003elocaleconv\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003estruct lconv\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eCommon initial sequence needs to be stable across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;math.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eint\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMath defines need to have a stable set of integer values across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;setjmp.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ejmp_buf\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eUsually defined by compiler\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;setjmp.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ejmp_buf\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eUsually defined by compiler intrinsic\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;signal.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eint\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eSignal defines need to have a stable set of integer values across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;signal.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003esig_atomic_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eStable type across libc\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdarg.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eva_list\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eUsually defined by compiler\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdarg.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eva_start\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eva_list\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eUsually defined by compiler intrinsic\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdarg.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eva_list\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eAny functions or macros using this type\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdatomic.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e_Atomic T\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eStable type across libc\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdatomic.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eint\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eAtomic defines need to have a stable set of integer values across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdatomic.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003etypedef\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany typedefs need to have a stable set of types across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stddef.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003etypedef\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany typedefs need to have a stable set of types across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdint.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003etypedef\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany typedefs need to have a stable set of types across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdint.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eint\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany defines need to have a stable set of types across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eFILE\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany functions (any taking \u003ccode\u003eFILE*\u003c/code\u003e or returning \u003ccode\u003eFILE*\u003c/code\u003e)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003etypedef\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany types need to have a stable set of types across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eint\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany defines need to have a stable set of integer values across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003eLocale for string formatting needs to be shared across libc\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003estderr\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003eNeeds to be a macro that expands to a function call like \u003ccode\u003e__stdio(STDERR_FILENO)\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003estdout\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003eNeeds to be a macro that expands to a function call like \u003ccode\u003e__stdio(STDOUT_FILENO)\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003estdin\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003eNeeds to be a macro that expands to a function call like \u003ccode\u003e__stdio(STDIO_FILENO)\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ediv_t\u003c/code\u003e,\u003c/td\u003e\u003ctd\u003eNeeds to have a stable definition across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eldiv_t\u003c/code\u003e,\u003c/td\u003e\u003ctd\u003eNeeds to have a stable definition across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003elldiv_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eNeeds to have a stable definition across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eint\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany defines need to have a stable set of integer values across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ecall_once\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eonce_flag\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eNeeds to be stable across libc and also libthread\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003erand\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003eGlobal PRNG needs to be shared across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003esrand\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003eGlobal PRNG needs to be shared across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ealigned_alloc\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003evoid*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eShared heap\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ecalloc\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003evoid*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eShared heap\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efree\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003evoid*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eShared heap\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efree_sized\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003evoid*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eShared heap\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efree_aligned_size\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003evoid*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eShared heap\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003emalloc\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003evoid*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eShared heap\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003erealloc\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003evoid*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eShared heap\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eatexit\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003eGlobal list needs to be shared across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eat_quick_exit\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003eGlobal list needs to be shared across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;string.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003estrcoll\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eLC_COLLATE\u003c/code\u003e locale needs to be shared across libc\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;threads.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ecnd_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eAny opaque method\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;threads.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ethrd_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eAny opaque method\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;threads.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003etss_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eAny opaque method\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;threads.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003emtx_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eAny opaque method\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;threads.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ecnd_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany functions using this type\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;threads.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ethrd_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany functions using this type\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;threads.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003etss_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany functions using this type\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;threads.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003emtx_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany functions using this type\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;threads.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003etypedef\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany types need to have a stable set of types across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;threads.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eint\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany defines need to have a stable set of integer values across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;threads.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ecall_once\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eonce_flag\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eSee \u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e above\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;time.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003etypedef\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany types need to have a stable set of types across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;time.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003estruct tm\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eCommon initial sequence needs to be stable across libc.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;uchar.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003echar8_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eNeeds to be same across libc\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;uchar.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003echar16_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eNeeds to be same across libc\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;uchar.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003echar32_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eNeeds to be same across libc\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;uchar.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003echar8_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany functions using this type\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;uchar.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003echar16_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany functions using this type\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;uchar.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003echar32_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany functions using this type\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;uchar.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003embstate_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eAny opaque method\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;uchar.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003embstate_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany functions using this type.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;wchar.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eRepeat of \u003ccode\u003e\u0026lt;uchar.h\u0026gt;\u003c/code\u003e essentially\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;wctype.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ewctrans_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eNeed to be same across libc\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;wctype.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eN/A\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ewctype_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eNeed to be same across libc\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;wctype.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ewctrans_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany functions using this type\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e\u0026lt;wctype.h\u0026gt;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ewctype_t\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eMany functions using this type\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eMost defines (of constants), ABI-exposed types (and typedefs) should just be stable across libc implementations for this to work reliably. Since these are baked into executables there\u0026#39;s no real way to modify or change them without breaking stuff anyways. When discussing stuff that is opaque (listed as \u003ccode\u003eAny opaque method\u003c/code\u003e) we propose affixing a pointer to a vtable containing the implementation as the first value in the type, this way functions operating on it can always recover the correct implementation and dispatch it indirectly through the vtable. Other methods like using a version field can also work here too.\u003c/p\u003e\n\u003cp\u003eRegardless, certain aspects of libc introduce complexity, particularly global and thread-local elements like \u003ca href=\"https://en.wikipedia.org/wiki/Errno.h\"\u003eerrno\u003c/a\u003e and \u003ca href=\"https://en.wikipedia.org/wiki/Locale_(computer_software)\"\u003elocale\u003c/a\u003e. However, with a well-designed architecture, these challenges can be effectively addressed.\u003c/p\u003e\n\u003cp\u003eMemory allocation functions—\u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003ealigned_alloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e, and \u003ccode\u003efree\u003c/code\u003e—from \u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e pose another difficulty. Since they can return any pointer, tracking them is non-trivial. One possible approach is to store a pointer to a vtable in the allocation header, allowing each allocation to reference its implementation. However, this method incurs significant performance and memory overhead. Instead, we propose centralizing heap management in a dedicated \u003ccode\u003elibheap\u003c/code\u003e. This would also contain implementation of the POSIX extensions like \u003ccode\u003eposix_memalign\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThings get even more interesting when moving from standard C to POSIX, which introduces unique challenges that require libc support. Some of these functionalities might be better split into separate libraries (for example, why is the DNS resolver in libc?). Among these challenges though, \u003ccode\u003esetxid\u003c/code\u003e stands out.\u003c/p\u003e\n\u003cp\u003eFor those unfamiliar, permissions in POSIX—such as the \u003ca href=\"https://en.wikipedia.org/wiki/User_identifier\"\u003ereal, effective, and saved user/group IDs\u003c/a\u003e—apply at the process level. However, Linux treats threads as independent processes that share memory, meaning these permissions are managed per thread rather than per process. To comply with POSIX semantics, libc must interrupt every thread, forcing them to execute code that invokes the system call to modify their thread-local permissions. This must be done atomically, without failure, and while remaining \u003ca href=\"https://man7.org/linux/man-pages/man7/signal-safety.7.html\"\u003easync-signal safe\u003c/a\u003e. This is a nightmare to implement and has proven to be \u003ca href=\"https://ewontfix.com/17/\"\u003ea major challenge\u003c/a\u003e. More importantly, getting it right is crucial for security.\u003c/p\u003e\n\u003cp\u003eUltimately, this means libc must track every thread and provide a way to synchronously execute code across all threads. To address this, we propose consolidating threading, TLS, and the necessary POSIX compliance mechanisms within a single \u003ccode\u003elibthread\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThere are many additional complexities we’ve glossed over and many alternative ways this can be implemented. The key takeaway is that these issues are solvable—they just require significant architectural changes. This necessitates reevaluating this aspect of the Linux userspace from the ground up with binary compatibility as a core design principle. GLIBC has never seriously attempted this. Until someone decides, \u0026#34;enough is enough, let’s fix this,\u0026#34; binary compatibility on Linux will remain an unsolved problem; we strongly believe this is a problem worth solving.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "33 min read",
  "publishedTime": null,
  "modifiedTime": null
}
