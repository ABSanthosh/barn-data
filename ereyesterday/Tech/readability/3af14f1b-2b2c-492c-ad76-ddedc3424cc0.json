{
  "id": "3af14f1b-2b2c-492c-ad76-ddedc3424cc0",
  "title": "Advent of Code 2024 in pure SQL",
  "link": "http://databasearchitects.blogspot.com/2024/12/advent-of-code-2024-in-pure-sql.html",
  "description": "Comments",
  "author": "",
  "published": "Thu, 02 Jan 2025 19:20:50 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 3751,
  "excerpt": "A blog by and for database architects.",
  "siteName": "",
  "favicon": "",
  "text": "On a whim I decided to do this years advent of code in pure SQL. That was an interesting experience that I can recommend to everybody because it forces you to think differently about the problems. And I can report that it was possible to solve every problem in pure SQL.In many cases SQL was actually surprisingly pleasant to use. The full solution for day 11 (including the puzzle input) is shown below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30with recursive aoc10_input(i) as (select ' 89010123 78121874 87430965 96549874 45678903 32019012 01329801 10456732 '), lines(y,line) as ( select 0, substr(i,1,position(E'\\n' in i)-1), substr(i,position(E'\\n' in i)+1) from aoc10_input union all select y+1,substr(r,1,position(E'\\n' in r)-1), substr(r,position(E'\\n' in r)+1) from lines l(y,l,r) where position(E'\\n' in r)\u003e0 ), field(x,y,v) as ( select x,y,ascii(substr(line,x::integer,1))-48 from (select * from lines l where line\u003c\u003e'') s, lateral generate_series(1,length(line)) g(x) ), paths(x,y,v,sx,sy) as ( select x,y,9,x,y from field where v = 9 union all select f.x,f.y,f.v,p.sx,p.sy from field f, paths p where f.v=p.v-1 and ((f.x=p.x and abs(f.y-p.y)=1) or (f.y=p.y and abs(f.x-p.x)=1)) and p.v\u003e0), results as (select * from paths where v=0), part1 as (select distinct * from results) select (select count(*) from part1) as part1, (select count(*) from results) as part2 Parsing the input is a bit painful in SQL, but it is not too bad. Lines 1-10 are simply the puzzle input, lines 11-17 split the input into individual lines, and lines 18-21 construct a 2D array from the input. The algorithm itself is pretty short, lines 22-27 perform a recursive traversal of the field, and lines 28-39 extract the puzzle answer from the traversal results. For this kind of small scale traversals SQL works just fine.Other days were more painful. Day 16 for example does conceptually a very similar traversal of a field, and it computes the minimal traversal distance for each visited. Expressing that in SQL in easy, but evaluation is wasteful. When replacing the reference input with a real puzzle input the field is quite large, and the recursive query generates and preserves a lot of state, even though we only care about the last iteration of the recursive query. As a consequence you need a machine with over 200GB memory to execute that query, even though most of the computed tuples are irrelevant. We could fix that excessive memory consumption by using iteration semantic during recursion, but that is not widely supported by DBMSes. Umbra could do it, but Postgres and DuckDB cannot, thus I have not used it in my solutions.And sometimes the programming model of recursive SQL clashes with what we want to do. On day 23 we had to find the maximum clique in sparse graph. This can be computed reasonably well with the Bron-Kerbosch algorithm, but expressing that in recursive SQL is quite convoluted because the algorithm wants to maintain multiple sets, but recursive SQL only passes a single set along. It can be done, but the result does not look pretty.This experiment has shown two things to me 1) it is possible to code quite complex algorithms in SQL, and often the SQL code is surprisingly pleasant, and 2) recursive SQL would be much more efficient and more pleasant to use if we had mechanisms to update state. There is ongoing work on supporting more complex control flow in recursion via a trampoline mechanisms, which is very useful, too, but we should definitively look into more complex state manipulation mechanisms. With just a bit extra functionality SQL would be quite a solid choice for running complex algorithms directly inside a database.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"post-body-7330506685859612652\" itemprop=\"articleBody\"\u003e\n\u003cp\u003e On a whim I decided to do this years \u003ca href=\"https://adventofcode.com/2024\"\u003eadvent of code\u003c/a\u003e in pure SQL. That was an interesting experience that I can recommend to everybody because it forces you to think differently about the problems. And I can report that \u003ca href=\"https://github.com/neumannt/aoc24\"\u003eit was possible to solve every problem in pure SQL\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIn many cases SQL was actually surprisingly pleasant to use. The full solution for day 11 (including the puzzle input) is shown below:\u003c/p\u003e\n\u003cdiv\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003ewith\u003c/span\u003e \u003cspan\u003erecursive\u003c/span\u003e aoc10_input(i) \u003cspan\u003eas\u003c/span\u003e (\u003cspan\u003eselect\u003c/span\u003e \u003cspan\u003e\u0026#39;\u003c/span\u003e\n\u003cspan\u003e89010123\u003c/span\u003e\n\u003cspan\u003e78121874\u003c/span\u003e\n\u003cspan\u003e87430965\u003c/span\u003e\n\u003cspan\u003e96549874\u003c/span\u003e\n\u003cspan\u003e45678903\u003c/span\u003e\n\u003cspan\u003e32019012\u003c/span\u003e\n\u003cspan\u003e01329801\u003c/span\u003e\n\u003cspan\u003e10456732\u003c/span\u003e\n\u003cspan\u003e\u0026#39;\u003c/span\u003e),\nlines(y,line) \u003cspan\u003eas\u003c/span\u003e (\n   \u003cspan\u003eselect\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e, substr(i,\u003cspan\u003e1\u003c/span\u003e,\u003cspan\u003eposition\u003c/span\u003e(E\u003cspan\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e i)\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e), substr(i,\u003cspan\u003eposition\u003c/span\u003e(E\u003cspan\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e i)\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e)\n   \u003cspan\u003efrom\u003c/span\u003e aoc10_input\n   \u003cspan\u003eunion\u003c/span\u003e \u003cspan\u003eall\u003c/span\u003e\n   \u003cspan\u003eselect\u003c/span\u003e y\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e,substr(r,\u003cspan\u003e1\u003c/span\u003e,\u003cspan\u003eposition\u003c/span\u003e(E\u003cspan\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e r)\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e), substr(r,\u003cspan\u003eposition\u003c/span\u003e(E\u003cspan\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e r)\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e)\n   \u003cspan\u003efrom\u003c/span\u003e lines l(y,l,r) \u003cspan\u003ewhere\u003c/span\u003e \u003cspan\u003eposition\u003c/span\u003e(E\u003cspan\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e r)\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\n),\nfield(x,y,v) \u003cspan\u003eas\u003c/span\u003e (\n   \u003cspan\u003eselect\u003c/span\u003e x,y,ascii(substr(line,x::\u003cspan\u003einteger\u003c/span\u003e,\u003cspan\u003e1\u003c/span\u003e))\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e48\u003c/span\u003e\n   \u003cspan\u003efrom\u003c/span\u003e (\u003cspan\u003eselect\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003efrom\u003c/span\u003e lines l \u003cspan\u003ewhere\u003c/span\u003e line\u003cspan\u003e\u0026lt;\u0026gt;\u003c/span\u003e\u003cspan\u003e\u0026#39;\u0026#39;\u003c/span\u003e) s, \u003cspan\u003elateral\u003c/span\u003e generate_series(\u003cspan\u003e1\u003c/span\u003e,\u003cspan\u003elength\u003c/span\u003e(line)) \u003cspan\u003eg\u003c/span\u003e(x)\n),\npaths(x,y,v,sx,sy) \u003cspan\u003eas\u003c/span\u003e (\n   \u003cspan\u003eselect\u003c/span\u003e x,y,\u003cspan\u003e9\u003c/span\u003e,x,y \u003cspan\u003efrom\u003c/span\u003e field \u003cspan\u003ewhere\u003c/span\u003e v \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e9\u003c/span\u003e\n   \u003cspan\u003eunion\u003c/span\u003e \u003cspan\u003eall\u003c/span\u003e\n   \u003cspan\u003eselect\u003c/span\u003e f.x,f.y,f.v,p.sx,p.sy\n   \u003cspan\u003efrom\u003c/span\u003e field f, paths p\n   \u003cspan\u003ewhere\u003c/span\u003e f.v\u003cspan\u003e=\u003c/span\u003ep.v\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e ((f.x\u003cspan\u003e=\u003c/span\u003ep.x \u003cspan\u003eand\u003c/span\u003e \u003cspan\u003eabs\u003c/span\u003e(f.y\u003cspan\u003e-\u003c/span\u003ep.y)\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e) \u003cspan\u003eor\u003c/span\u003e (f.y\u003cspan\u003e=\u003c/span\u003ep.y \u003cspan\u003eand\u003c/span\u003e \u003cspan\u003eabs\u003c/span\u003e(f.x\u003cspan\u003e-\u003c/span\u003ep.x)\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e)) \u003cspan\u003eand\u003c/span\u003e p.v\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e),\nresults \u003cspan\u003eas\u003c/span\u003e (\u003cspan\u003eselect\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003efrom\u003c/span\u003e paths \u003cspan\u003ewhere\u003c/span\u003e v\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e),\npart1 \u003cspan\u003eas\u003c/span\u003e (\u003cspan\u003eselect\u003c/span\u003e \u003cspan\u003edistinct\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003efrom\u003c/span\u003e results)\n\u003cspan\u003eselect\u003c/span\u003e (\u003cspan\u003eselect\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e(\u003cspan\u003e*\u003c/span\u003e) \u003cspan\u003efrom\u003c/span\u003e part1)  \u003cspan\u003eas\u003c/span\u003e part1, (\u003cspan\u003eselect\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e(\u003cspan\u003e*\u003c/span\u003e) \u003cspan\u003efrom\u003c/span\u003e results) \u003cspan\u003eas\u003c/span\u003e part2\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\n\n\n\u003cp\u003eParsing the input is a bit painful in SQL, but it is not too bad. Lines 1-10 are simply the puzzle input, lines 11-17 split the input into individual lines, and lines 18-21 construct a 2D array from the input. The algorithm itself is pretty short, lines 22-27 perform a recursive traversal of the field, and lines 28-39 extract the puzzle answer from the traversal results. For this kind of small scale traversals SQL works just fine.\u003c/p\u003e\u003cp\u003eOther days were more painful. \u003ca href=\"https://github.com/neumannt/aoc24/blob/master/day16.sql\"\u003eDay 16\u003c/a\u003e for example does conceptually a very similar traversal of a field, and it computes the minimal traversal distance for each visited. Expressing that in SQL in easy, but evaluation is wasteful. When replacing the reference input with a real puzzle input the field is quite large, and the recursive query generates and preserves a lot of state, even though we only care about the last iteration of the recursive query. As a consequence you need a machine with over 200GB memory to execute that query, even though most of the computed tuples are irrelevant. We could fix that excessive memory consumption by using \u003ca href=\"https://www.cidrdb.org/cidr2023/papers/p14-hirn.pdf\"\u003eiteration semantic\u003c/a\u003e during recursion, but that is not widely supported by DBMSes. Umbra could do it, but Postgres and DuckDB cannot, thus I have not used it in my solutions.\u003c/p\u003e\u003cp\u003eAnd sometimes the programming model of recursive SQL clashes with what we want to do. On \u003ca href=\"https://github.com/neumannt/aoc24/blob/master/day23.sql\"\u003eday 23\u003c/a\u003e we had to find the maximum clique in sparse graph. This can be computed reasonably well with the \u003ca href=\"https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\"\u003eBron-Kerbosch algorithm\u003c/a\u003e, but expressing that in recursive SQL is quite convoluted because the algorithm wants to maintain multiple sets, but recursive SQL only passes a single set along. It can be done, but the result \u003ca href=\"https://github.com/neumannt/aoc24/blob/218e93d12b477e694ab88e2c25c6070c28a6fbf4/day23.sql#L52\"\u003edoes not look pretty\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThis experiment has shown two things to me 1) it is possible to code quite complex algorithms in SQL, and often the SQL code is surprisingly pleasant, and 2) recursive SQL would be much more efficient and more pleasant to use if we had mechanisms to update state. There is \u003ca href=\"https://www.cidrdb.org/cidr2025/papers.html\"\u003eongoing work\u003c/a\u003e on supporting more complex control flow in recursion via a trampoline mechanisms, which is very useful, too, but we should definitively look into more complex state manipulation mechanisms. With just a bit extra functionality SQL would be quite a solid choice for running complex algorithms directly inside a database.\u003cbr/\u003e\u003c/p\u003e\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
