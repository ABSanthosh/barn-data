{
  "id": "c57e547f-66e8-45a6-9fc6-28a52ff60966",
  "title": "Elixir/Erlang Hot Swapping Code",
  "link": "https://kennyballou.com/blog/2016/12/elixir-hot-swapping/index.html",
  "description": "Comments",
  "author": "",
  "published": "Thu, 12 Dec 2024 23:16:20 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Kenny Ballou",
  "length": 18045,
  "excerpt": "Hot code reloading with Elixir and Erlang",
  "siteName": "",
  "favicon": "",
  "text": "Table of Contents Hot Code Swapping: Basics Example Example: iex Relups Erlang Applications Erlang Releases Appups and Relups Generating Releases and Upgrades with Elixir Summary One of the untold benefits of having a runtime is the ability for that runtime to enable loading and unloading code while the runtime is active. Since the runtime is itself, essentially, a virtual machine with its own operating system and process scheduling, it has the ability to start and stop, load and unload processes and code similar to how \"real\" operating systems do. Warning, there be black magic here. This enables some spectacular power in terms of creating deployments and rolling out those deployments. That is, if we can provide a particular artifact for the runtime to load and replace the running system with, we can instruct it to upgrade our system(s) without restarting them, without interrupting our services or affecting users of those systems. Furthermore, if we constrain the system and make a few particular assumptions, this can all happen nearly instantaneously. For example, Erlang releases happen in seconds because of the functional approach taken by the language, this compared to other systems like Docker and/or Kubernetes which may take several minutes or hours to transition a version because there is no safe assumptions to make about running code. This post will be a small tour through how Elixir and Erlang can perform code hot swapping, and how this can be useful for deployments. Hot Code Swapping: Basics There are several functions defined in the :sys and :code modules that are required for this first example. Namely, the following functions: :code.load_file/1 :sys.suspend/1 :sys.change_code/4 :sys.resume/1 The :sys.suspend/1 function takes a single parameter, the Process ID (PID) of the process to suspend, similarly, :sys.resume also takes a PID of the process to resume. The :code.load_file/1 function, unfortunately named, takes a single parameter: the module to load into memory. Finally, the :sys.change_code function takes four parameters: name, module, old_version, and extra. The name is the PID or the registered atom of the process. The extra argument is a reserved parameter for each process, it's the same extra that will be passed to the restarted process's code_change/3 function. Example Let's assume we have a particularly simple module, say KV, similar to the following: defmodule KV do use GenServer @vsn 0 def start_link() do GenServer.start_link(__MODULE__, [], name: __MODULE__) end def init(_) do {:ok, %{}} end def get(key, default \\\\ nil) do GenServer.call(__MODULE__, {:get, key, default}) end def put(key, value) do GenServer.call(__MODULE__, {:put, key, value}) end def handle_call({:get, key, default}, _caller, state) do {:reply, Map.get(state, key, default), state} end def handle_call({:put, key, value}, _caller, state) do {:reply, :ok, Map.put(state, key, value)} end end Save this into a file, say, kv.ex. Next we will compile it and load it into an iex session: % elixirc kv.ex % iex iex\u003e l KV {:module, KV} We can start the process and try it out: iex\u003e KV.start_link {:ok, #PID\u003c0.84.0\u003e} iex\u003e KV.get(:a) nil iex\u003e KV.put(:a, 42) :ok iex\u003e KV.get(:a) 42 Now, let's say we wish to add some logging to the handling of the :get and :put messages. We will apply a patch similar to the following: --- a/kv.ex +++ b/kv.ex @@ -1,7 +1,8 @@ defmodule KV do + require Logger use GenServer - @vsn 0 + @vsn 1 def start_link() do GenServer.start_link(__MODULE__, [], name: __MODULE__) @@ -20,10 +21,12 @@ defmodule KV do end def handle_call({:get, key, default}, _caller, state) do + Logger.info(\"#{__MODULE__}: Handling get request for #{key}\") {:reply, Map.get(state, key, default), state} end def handle_call({:put, key, value}, _caller, state) do + Logger.info(\"#{__MODULE__}: Handling put request for #{key}:#{value}\") {:reply, :ok, Map.put(state, key, value)} end Without closing the current iex session, apply the patch to the file and compile the module: % patch kv.ex kv.ex.patch % elixirc kv.ex You may see a warning about redefining an existing module, this warning can be safely ignored. Now, in the still open iex session, let's begin the black magic incantations: iex\u003e :code.load_file KV {:module, KV} iex\u003e :sys.suspend(KV) :ok iex\u003e :sys.change_code(KV, KV, 0, nil) :ok iex\u003e :sys.resume(KV) :ok Now, we should be able to test it again: iex\u003e KV.get(:a) 21:28:47.989 [info] Elixir.KV: Handling get request for a 42 iex\u003e KV.put(:b, 2) 21:28:53.729 [info] Elixir.KV: Handling put request for b:2 :ok Thus, we are able to hot-swap running code, without stopping, losing state, or effecting processes waiting for that data! But the above is merely an example of manually invoking the code reloading API, there are better ways to achieve the same result. Example: iex There are several functions available to us when using iex that essentially perform the above actions for us: c/1: compile file r/1: (recompile and) reload module The r/1 helper takes an atom of the module to reload, c/1 takes a binary of the path to the module to compile. Check the documentation for more information. Therefore, using these, we can simplify what we did in the previous example to simply a call to r/1: iex\u003e r KV warning: redefining module KV (current version loaded from Elixir.KV.beam) kv.ex:1 {:reloaded, KV, [KV]} iex\u003e KV.get(:a) 21:52:47.829 [info] Elixir.KV: Handling get request for a 42 In one function, we have done what previously took four functions. However, the story does not end here. This was only for a single module, one GenServer. What about when we want to upgrade more modules, or an entire application? Although c/1 and r/1 are great for development. They are not recommended for production use. Do not depend on them to perform deployments. Relups Fortunately, there is another set of tooling that allows us to more easily deploy releases, and more pointedly, perform upgrades: Relups. Before we dive straight into relups, let's discuss a few other related concepts. Erlang Applications As part of Erlang \"Applications\", there is a related file, the .app file. This resource file describes the application: other applications that should be started and other metadata about the application. Using Elixir, this file can be found in the _build/{Mix.env}/lib/{app_name}/ebin/ folder. Here's an example .app file from the octochat demo application: ± cat _build/dev/lib/octochat/ebin/octochat.app {application,octochat, [{registered,[]}, {description,\"Demo Application for How Swapping Code\"}, {vsn,\"0.3.3\"}, {modules,['Elixir.Octochat','Elixir.Octochat.Acceptor', 'Elixir.Octochat.Application','Elixir.Octochat.Echo', 'Elixir.Octochat.ServerSupervisor', 'Elixir.Octochat.Supervisor']}, {applications,[kernel,stdlib,elixir,logger]}, {mod,{'Elixir.Octochat.Application',[]}}]}. This is a pretty good sized triple (3-tuple). By the first element of the triple, we can tell it is an application, the application's name is octochat given by the second element, and everything in the list that follows is a keyword list that describes more about the octochat application. Notably, we have the usual metadata found in the mix.exs file, the modules that make up the application, and the other OTP applications this application requires to run. Erlang Releases An Erlang \"release\", similar to Erlang application, is an entire system: the Erlang VM, the dependent set of applications, and arguments for the Erlang VM. After building a release for the Octochat application with the distillery project, we get a .rel file similar to the following: ± cat rel/octochat/releases/0.3.3/octochat.rel {release,{\"octochat\",\"0.3.3\"}, {erts,\"8.1\"}, [{logger,\"1.3.4\"}, {compiler,\"7.0.2\"}, {elixir,\"1.3.4\"}, {stdlib,\"3.1\"}, {kernel,\"5.1\"}, {octochat,\"0.3.3\"}, {iex,\"1.3.4\"}, {sasl,\"3.0.1\"}]}. This is an Erlang 4-tuple; it's a release of the \"0.0.3\" version of octochat. It will use the \"8.1\" version of \"erts\" and it depends on the list of applications (and their versions) provided in the last element of the tuple. Appups and Relups As the naming might suggest, \"appups\" and \"relups\" are the \"upgrade\" versions of applications and releases, respectively. Appups describe how to take a single application and upgrade its modules, specifically, it will have instructions for upgrading modules that require \"extras\". or, if we are upgrading supervisors, for example, the Appup will have the correct instructions for adding and removing child processes. Before we examine some examples of these files, let's first look at the type specification for each. Here is the syntax structure for the appup resource file: {Vsn, [{UpFromVsn, Instructions}, ...], [{DownToVsn, Instructions}, ...]}. The first element of the triple is the version we are either upgrading to or downgrading from. The second element is a keyword list of upgrade instructions keyed by the version the application would be coming from. Similarly, the third element is a keyword list of downgrade instructions keyed by the version the application will downgrade to. For more information about the types themselves, see the SASL documentation. Now that we have seen the syntax, let's look at an example of the appup resource file for the octochat application generated using distillery: ± cat rel/octochat/lib/octochat-0.2.1/ebin/octochat.appup {\"0.2.1\", [{\"0.2.0\",[{load_module,'Elixir.Octochat.Echo',[]}]}], [{\"0.2.0\",[{load_module,'Elixir.Octochat.Echo',[]}]}]}. Comparing this to the syntax structure above, we see that we have a Vsn element of \"0.2.1\", we have a {UpFromVsn, Instructions} pair: [{\"0.2.0\",[{load_module,'Elixir.Octochat.Echo',[]}]}], and we have a single {DownToVsn, Instructions} pair: [{\"0.2.0\",[{load_module,'Elixir.Octochat.Echo',[]}]}]. The instructions themselves tell us what exactly is required to go from one version to the another. Specifically, in this example, to upgrade, we need to \"load\" the Octochat.Echo module into the VM. Similarly, the instructions to downgrade are the same. For a semantically versioned project, this is an understandably small change. It's worth noting the instructions found in the .appup files are usually high-level instructions, thus, load_module covers both the loading of object code into memory and the suspend, replace, resume process of upgrading applications. Next, let's look at the syntax structure of a relup resource file: {Vsn, [{UpFromVsn, Descr, Instructions}, ...], [{DownToVsn, Descr, Instructions}, ...]}. This should look familiar. It's essentially the exact same as the .appup file. However, there's an extra term, Descr. The Descr field can be used as part of the version identification, but is optional. Otherwise, the syntax of this file is the same as the .appup. Now, let's look at an example relup file for the same release of octochat: ± cat rel/octochat/releases/0.2.1/relup {\"0.2.1\", [{\"0.2.0\",[], [{load_object_code,{octochat,\"0.2.1\",['Elixir.Octochat.Echo']}}, point_of_no_return, {load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}}]}], [{\"0.2.0\",[], [{load_object_code,{octochat,\"0.2.0\",['Elixir.Octochat.Echo']}}, point_of_no_return, {load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}}]}]}. This file is a little more dense, but still adheres to the basic triple syntax we just examined. Let's take a closer look at the upgrade instructions: [{load_object_code,{octochat,\"0.2.1\",['Elixir.Octochat.Echo']}}, point_of_no_return, {load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}}] The first instruction, {load_object_code,{octochat,\"0.2.1\",['Elixir.Octochat.Echo']}}, tells the release handler to load into memory the new version of the \"Octochat.Echo\" module, specifically the one associated with version \"0.2.1\". But this instruction will not instruct the release handler to (re)start or replace the existing module yet. Next, point_of_no_return, tells the release handler that failure beyond this point is fatal, if the upgrade fails after this point, the system is restarted from the old release version (appup documentation). The final instruction, {load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}}, tells the release handler to replace the running version of the module and use the newly loaded version. For more information regarding burtal_purge, check out the \"PrePurge\" and \"PostPurge\" values in the appup documentation. Similar to the .appup file, the third element in the triple describes to the release handler how to downgrade the release as well. The version numbers in this case make this a bit more obvious as well, however, the steps are essentially the same. Generating Releases and Upgrades with Elixir Now that we have some basic understanding of releases and upgrades, let's see how we can generate them with Elixir. We will generate the releases with the distillery project, however, the commands should also work with the soon to be deprecated exrm project. This has been written for the 0.10.1 version of distillery. This is a fast moving project that is in beta, be prepared to update as necessary. Add the distillery application to your deps list: {:distillery, \"~\u003e 0.10\"} Perform the requisite dependency download: ± mix deps.get Then, to build your first production release, you can use the following: ± MIX_ENV=prod mix release --env prod For more information on why you must specify both environments, please read the FAQ of distillery. If the environments match, there's a small modification to the ./rel/config.exs that can be made so that specifying both is no longer necessary. After this process is complete, there should be a new folder under the ./rel folder that contains the new release of the project. Within this directory, there will be several directories, namely, bin, erts-{version}, lib, and releases. The bin directory will contain the top level Erlang entry scripts, the erts-{version} folder will contain the requisite files for the Erlang runtime, the lib folder will contain the compiled beam files for the required applications for the release, and finally, the releases folder will contain the versions of the releases. Each folder for each version will have its own rel file, generated boot scripts, as per the OTP releases guide, and a tarball of the release for deployment. Deploying the release is a little out of scope for this post and may be the subject of another. For more information about releases, see the System Principles guide. However, for Elixir, it may look similar to the following: Copy the release tarball to the target system: ± scp rel/octochat/releases/0.3.2/octochat.tar.gz target_system:/opt/apps/. On the target system, unpack the release: ± ssh target_system (ts)# cd /opt/apps (ts)# mkdir -p octochat (ts)# tar -zxf octochat.tar.gz -C octochat Start the system: (ts)# cd octochat (ts)# bin/octochat start This will bring up the Erlang VM and the application tree on the target system. Next, after making some applications changes and bumping the project version, we can generate an upgrade release using the following command: ± MIX_ENV=prod mix release --upgrade Note, This will also generate a regular release. Once this process finishes, checking the rel/{app_name}/releases folder, there should be a new folder for the new version, and a relup file for the upgrade: ± cat rel/octochat/releases/0.3.3/octochat.rel {release,{\"octochat\",\"0.3.3\"}, {erts,\"8.1\"}, [{logger,\"1.3.4\"}, {compiler,\"7.0.2\"}, {elixir,\"1.3.4\"}, {stdlib,\"3.1\"}, {kernel,\"5.1\"}, {octochat,\"0.3.3\"}, {iex,\"1.3.4\"}, {sasl,\"3.0.1\"}]}. ± cat rel/octochat/releases/0.3.3/relup {\"0.3.3\", [{\"0.3.2\",[], [{load_object_code,{octochat,\"0.3.3\",['Elixir.Octochat.Echo']}}, point_of_no_return, {suspend,['Elixir.Octochat.Echo']}, {load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}}, {code_change,up,[{'Elixir.Octochat.Echo',[]}]}, {resume,['Elixir.Octochat.Echo']}]}], [{\"0.3.2\",[], [{load_object_code,{octochat,\"0.3.1\",['Elixir.Octochat.Echo']}}, point_of_no_return, {suspend,['Elixir.Octochat.Echo']}, {code_change,down,[{'Elixir.Octochat.Echo',[]}]}, {load,{'Elixir.Octochat.Echo',brutal_purge,brutal_purge}}, {resume,['Elixir.Octochat.Echo']}]}]}. Similarly, to deploy this new upgrade, copy the tarball to the target system and unpack it into the same directory as before. After it's unpacked, upgrading the release can be done via a stop and start, or we can issue the upgrade command: (ts)# bin/octochat stop (ts)# bin/octochat start Or: (ts)# bin/octochat upgrade \"0.3.3\" When starting and stopping, the entry point script knows how to select the \"newest\" version. When upgrading, it is required to specify the desired version, this is necessary since the upgrade process may require more than simply jumping to the \"latest\" version. Summary Release management is a complex topic, upgrading without restarting seemingly even more so. However, the process can be understood, and knowing how the process works will allow us to make more informed decisions regarding when to use it. The tooling for performing hot upgrades has been around for a while, and while the tooling for Elixir is getting closer, we are not quite ready for prime time. But it won't remain this way for long. Soon, it will be common place for Elixir applications to be just as manageable as the Erlang counterparts.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n\n\u003cdiv id=\"table-of-contents\"\u003e\n\u003ch2\u003eTable of Contents\u003c/h2\u003e\n\u003cdiv id=\"text-table-of-contents\"\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#orgd86cf3e\"\u003eHot Code Swapping: Basics\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#orgd11065a\"\u003eExample\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#org10a7584\"\u003eExample: \u003ccode\u003eiex\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#orgb262cbe\"\u003eRelups\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#org37c6be6\"\u003eErlang Applications\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#org481451b\"\u003eErlang Releases\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#org99784cb\"\u003eAppups and Relups\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#generating-releases-and-upgrades-with-elixir\"\u003eGenerating Releases and Upgrades with Elixir\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#org0bb3963\"\u003eSummary\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nOne of the untold benefits of having a runtime is the ability for that runtime\nto enable loading and unloading code while the runtime is active.  Since the\nruntime is itself, essentially, a virtual machine with its own operating system\nand process scheduling, it has the ability to start and stop, load and unload\nprocesses and code similar to how \u0026#34;real\u0026#34; operating systems do.\n\u003c/p\u003e\n\n\u003cp\u003e\n\u003ciframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/xrIjfIjssLE?rel=0\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen=\"\"\u003e\u003c/iframe\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e\nWarning, there be black magic here.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nThis enables some spectacular power in terms of creating deployments and\nrolling out those deployments.  That is, if we can provide a particular\nartifact for the runtime to load and replace the running system with, we can\ninstruct it to upgrade our system(s) \u003ci\u003ewithout\u003c/i\u003e restarting them, without\ninterrupting our services or affecting users of those systems.  Furthermore, if\nwe constrain the system and make a few particular assumptions, this can all\nhappen nearly instantaneously.  For example, Erlang releases happen in seconds\nbecause of the functional approach taken by the language, this compared to\nother systems like \u003ca href=\"https://docker.com\"\u003eDocker\u003c/a\u003e and/or \u003ca href=\"http://kubernetes.io/\"\u003eKubernetes\u003c/a\u003e which\nmay take several minutes or hours to transition a version because there is no\nsafe assumptions to make about running code.\n\u003c/p\u003e\n\n\u003cp\u003e\nThis post will be a small tour through how Elixir and Erlang can perform code\nhot swapping, and how this can be useful for deployments.\n\u003c/p\u003e\n\n\u003cdiv id=\"outline-container-orgd86cf3e\"\u003e\n\u003ch2 id=\"orgd86cf3e\"\u003eHot Code Swapping: Basics\u003c/h2\u003e\n\u003cdiv id=\"text-orgd86cf3e\"\u003e\n\u003cp\u003e\nThere are several functions defined in the \u003ca href=\"http://erlang.org/doc/man/sys.html\"\u003e\u003ccode\u003e:sys\u003c/code\u003e\u003c/a\u003e and\n\u003ca href=\"http://erlang.org/doc/man/code.html\"\u003e\u003ccode\u003e:code\u003c/code\u003e\u003c/a\u003e modules that are required for this first example.\nNamely, the following functions:\n\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e:code.load_file/1\u003c/code\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003ccode\u003e:sys.suspend/1\u003c/code\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003ccode\u003e:sys.change_code/4\u003c/code\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003ccode\u003e:sys.resume/1\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\nThe \u003ccode\u003e:sys.suspend/1\u003c/code\u003e function takes a single parameter, the Process ID\n(PID) of the process to suspend, similarly, \u003ccode\u003e:sys.resume\u003c/code\u003e also takes a\nPID of the process to resume.  The \u003ccode\u003e:code.load_file/1\u003c/code\u003e function,\nunfortunately named, takes a single parameter: the \u003ci\u003emodule\u003c/i\u003e to load into\nmemory.  Finally, the \u003ccode\u003e:sys.change_code\u003c/code\u003e function takes four parameters:\n\u003ccode\u003ename\u003c/code\u003e, \u003ccode\u003emodule\u003c/code\u003e, \u003ccode\u003eold_version\u003c/code\u003e, and \u003ccode\u003eextra\u003c/code\u003e.  The \u003ccode\u003ename\u003c/code\u003e is the PID or\nthe registered atom of the process.  The \u003ccode\u003eextra\u003c/code\u003e argument is a reserved\nparameter for each process, it\u0026#39;s the same \u003ccode\u003eextra\u003c/code\u003e that will be passed to\nthe restarted process\u0026#39;s \u003ccode\u003ecode_change/3\u003c/code\u003e function.\n\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cdiv id=\"outline-container-orgd11065a\"\u003e\n\u003ch3 id=\"orgd11065a\"\u003eExample\u003c/h3\u003e\n\u003cdiv id=\"text-orgd11065a\"\u003e\n\u003cp\u003e\nLet\u0026#39;s assume we have a particularly simple module, say \u003ccode\u003eKV\u003c/code\u003e, similar to\nthe following:\n\u003c/p\u003e\n\n\u003cpre\u003edefmodule KV do\n  use GenServer\n\n  @vsn 0\n\n  def start_link() do\n    GenServer.start_link(__MODULE__, [], name: __MODULE__)\n  end\n\n  def init(_) do\n    {:ok, %{}}\n  end\n\n  def get(key, default \\\\ nil) do\n    GenServer.call(__MODULE__, {:get, key, default})\n  end\n\n  def put(key, value) do\n    GenServer.call(__MODULE__, {:put, key, value})\n  end\n\n  def handle_call({:get, key, default}, _caller, state) do\n    {:reply, Map.get(state, key, default), state}\n  end\n\n  def handle_call({:put, key, value}, _caller, state) do\n    {:reply, :ok, Map.put(state, key, value)}\n  end\n\nend\n\u003c/pre\u003e\n\n\u003cp\u003e\nSave this into a file, say, \u003ccode\u003ekv.ex\u003c/code\u003e.  Next we will compile it and load it\ninto an \u003ccode\u003eiex\u003c/code\u003e session:\n\u003c/p\u003e\n\n\u003cpre\u003e% elixirc kv.ex\n% iex\niex\u0026gt; l KV\n{:module, KV}\n\u003c/pre\u003e\n\n\u003cp\u003e\nWe can start the process and try it out:\n\u003c/p\u003e\n\n\u003cpre\u003eiex\u0026gt; KV.start_link\n{:ok, #PID\u0026lt;0.84.0\u0026gt;}\niex\u0026gt; KV.get(:a)\nnil\niex\u0026gt; KV.put(:a, 42)\n:ok\niex\u0026gt; KV.get(:a)\n42\n\u003c/pre\u003e\n\n\u003cp\u003e\nNow, let\u0026#39;s say we wish to add some logging to the handling of the \u003ccode\u003e:get\u003c/code\u003e\nand \u003ccode\u003e:put\u003c/code\u003e messages.  We will apply a patch similar to the following:\n\u003c/p\u003e\n\n\u003cpre\u003e--- a/kv.ex\n+++ b/kv.ex\n@@ -1,7 +1,8 @@\n defmodule KV do\n+  require Logger\n   use GenServer\n\n-  @vsn 0\n+  @vsn 1\n\n   def start_link() do\n     GenServer.start_link(__MODULE__, [], name: __MODULE__)\n@@ -20,10 +21,12 @@ defmodule KV do\n   end\n\n   def handle_call({:get, key, default}, _caller, state) do\n+    Logger.info(\u0026#34;#{__MODULE__}: Handling get request for #{key}\u0026#34;)\n     {:reply, Map.get(state, key, default), state}\n   end\n\n   def handle_call({:put, key, value}, _caller, state) do\n+    Logger.info(\u0026#34;#{__MODULE__}: Handling put request for #{key}:#{value}\u0026#34;)\n     {:reply, :ok, Map.put(state, key, value)}\n   end\n\u003c/pre\u003e\n\n\u003cp\u003e\nWithout closing the current \u003ccode\u003eiex\u003c/code\u003e session, apply the patch to the file\nand compile the module:\n\u003c/p\u003e\n\n\u003cpre\u003e% patch kv.ex kv.ex.patch\n% elixirc kv.ex\n\u003c/pre\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e\nYou may see a warning about redefining an existing module, this\nwarning can be safely ignored.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nNow, in the still open \u003ccode\u003eiex\u003c/code\u003e session, let\u0026#39;s begin the black magic\nincantations:\n\u003c/p\u003e\n\n\u003cpre\u003eiex\u0026gt; :code.load_file KV\n{:module, KV}\niex\u0026gt; :sys.suspend(KV)\n:ok\niex\u0026gt; :sys.change_code(KV, KV, 0, nil)\n:ok\niex\u0026gt; :sys.resume(KV)\n:ok\n\u003c/pre\u003e\n\n\u003cp\u003e\nNow, we should be able to test it again:\n\u003c/p\u003e\n\n\u003cpre\u003eiex\u0026gt; KV.get(:a)\n21:28:47.989 [info]  Elixir.KV: Handling get request for a\n42\niex\u0026gt; KV.put(:b, 2)\n21:28:53.729 [info]  Elixir.KV: Handling put request for b:2\n:ok\n\u003c/pre\u003e\n\n\u003cp\u003e\nThus, we are able to hot-swap running code, without stopping, losing\nstate, or effecting processes waiting for that data!\n\u003c/p\u003e\n\n\u003cp\u003e\nBut the above is merely an example of manually invoking the code\nreloading API, there are better ways to achieve the same result.\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv id=\"outline-container-org10a7584\"\u003e\n\u003ch3 id=\"org10a7584\"\u003eExample: \u003ccode\u003eiex\u003c/code\u003e\u003c/h3\u003e\n\u003cdiv id=\"text-org10a7584\"\u003e\n\u003cp\u003e\nThere are several functions available to us when using \u003ccode\u003eiex\u003c/code\u003e that\nessentially perform the above actions for us:\n\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ec/1\u003c/code\u003e: compile file\u003c/li\u003e\n\n\u003cli\u003e\u003ccode\u003er/1\u003c/code\u003e: (recompile and) reload module\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\nThe \u003ccode\u003er/1\u003c/code\u003e helper takes an atom of the module to reload, \u003ccode\u003ec/1\u003c/code\u003e takes a binary of\nthe path to the module to compile.  Check the\n\u003ca href=\"http://elixir-lang.org/docs/stable/iex/IEx.Helpers.html\"\u003edocumentation\u003c/a\u003e for more information.\n\u003c/p\u003e\n\n\u003cp\u003e\nTherefore, using these, we can simplify what we did in the previous example to\nsimply a call to \u003ccode\u003er/1\u003c/code\u003e:\n\u003c/p\u003e\n\n\u003cpre\u003eiex\u0026gt; r KV\nwarning: redefining module KV (current version loaded from Elixir.KV.beam)\n  kv.ex:1\n\n{:reloaded, KV, [KV]}\niex\u0026gt; KV.get(:a)\n\n21:52:47.829 [info]  Elixir.KV: Handling get request for a\n42\n\u003c/pre\u003e\n\n\u003cp\u003e\nIn one function, we have done what previously took four functions.  However,\nthe story does not end here.  This was only for a single module, one\n\u003ccode\u003eGenServer\u003c/code\u003e.  What about when we want to upgrade more modules, or an entire\napplication?\n\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e\nAlthough \u003ccode\u003ec/1\u003c/code\u003e and \u003ccode\u003er/1\u003c/code\u003e are great for development.  They are \u003ci\u003enot\u003c/i\u003e\nrecommended for production use.  Do not depend on them to perform\ndeployments.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv id=\"outline-container-orgb262cbe\"\u003e\n\u003ch2 id=\"orgb262cbe\"\u003eRelups\u003c/h2\u003e\n\u003cp\u003e\nFortunately, there is another set of tooling that allows us to more\neasily deploy releases, and more pointedly, perform upgrades: Relups.\nBefore we dive straight into relups, let\u0026#39;s discuss a few other related\nconcepts.\n\u003c/p\u003e\n\n\u003cdiv id=\"outline-container-org37c6be6\"\u003e\n\u003ch3 id=\"org37c6be6\"\u003eErlang Applications\u003c/h3\u003e\n\u003cdiv id=\"text-org37c6be6\"\u003e\n\u003cp\u003e\nAs part of Erlang \u0026#34;Applications\u0026#34;, there is a related file, the\n\u003ca href=\"http://erlang.org/doc/man/app.html\"\u003e\u003ccode\u003e.app\u003c/code\u003e\u003c/a\u003e file.  This resource file describes the application:\nother applications that should be started and other metadata about the\napplication.  Using Elixir, this file can be found in the\n\u003ccode\u003e_build/{Mix.env}/lib/{app_name}/ebin/\u003c/code\u003e folder.\n\u003c/p\u003e\n\n\u003cp\u003e\nHere\u0026#39;s an example \u003ccode\u003e.app\u003c/code\u003e file from the \u003ca href=\"https://git.devnulllabs.io/demos/octochat.git\"\u003eoctochat\u003c/a\u003e demo\napplication:\n\u003c/p\u003e\n\n\u003cpre\u003e± cat _build/dev/lib/octochat/ebin/octochat.app\n{application,octochat,\n         [{registered,[]},\n          {description,\u0026#34;Demo Application for How Swapping Code\u0026#34;},\n          {vsn,\u0026#34;0.3.3\u0026#34;},\n          {modules,[\u0026#39;Elixir.Octochat\u0026#39;,\u0026#39;Elixir.Octochat.Acceptor\u0026#39;,\n                    \u0026#39;Elixir.Octochat.Application\u0026#39;,\u0026#39;Elixir.Octochat.Echo\u0026#39;,\n                    \u0026#39;Elixir.Octochat.ServerSupervisor\u0026#39;,\n                    \u0026#39;Elixir.Octochat.Supervisor\u0026#39;]},\n          {applications,[kernel,stdlib,elixir,logger]},\n          {mod,{\u0026#39;Elixir.Octochat.Application\u0026#39;,[]}}]}.\n\u003c/pre\u003e\n\n\u003cp\u003e\nThis is a pretty good sized triple (3-tuple).  By the first element of the\ntriple, we can tell it is an \u003ccode\u003eapplication\u003c/code\u003e, the application\u0026#39;s name is\n\u003ccode\u003eoctochat\u003c/code\u003e given by the second element, and everything in the list that follows\nis a keyword list that describes more about the \u003ccode\u003eoctochat\u003c/code\u003e\napplication.  Notably, we have the usual metadata found in the \u003ccode\u003emix.exs\u003c/code\u003e file,\nthe \u003ccode\u003emodules\u003c/code\u003e that make up the application, and the other OTP applications this\napplication requires to run.\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv id=\"outline-container-org481451b\"\u003e\n\u003ch3 id=\"org481451b\"\u003eErlang Releases\u003c/h3\u003e\n\u003cdiv id=\"text-org481451b\"\u003e\n\u003cp\u003e\nAn Erlang \u0026#34;release\u0026#34;, similar to Erlang application, is an entire system: the\nErlang VM, the dependent set of applications, and arguments for the Erlang VM.\n\u003c/p\u003e\n\n\u003cp\u003e\nAfter building a release for the Octochat application with the\n\u003ca href=\"https://github.com/bitwalker/distillery\"\u003e\u003ccode\u003edistillery\u003c/code\u003e\u003c/a\u003e project, we get a \u003ccode\u003e.rel\u003c/code\u003e file similar to the\nfollowing:\n\u003c/p\u003e\n\n\u003cpre\u003e± cat rel/octochat/releases/0.3.3/octochat.rel\n{release,{\u0026#34;octochat\u0026#34;,\u0026#34;0.3.3\u0026#34;},\n     {erts,\u0026#34;8.1\u0026#34;},\n     [{logger,\u0026#34;1.3.4\u0026#34;},\n      {compiler,\u0026#34;7.0.2\u0026#34;},\n      {elixir,\u0026#34;1.3.4\u0026#34;},\n      {stdlib,\u0026#34;3.1\u0026#34;},\n      {kernel,\u0026#34;5.1\u0026#34;},\n      {octochat,\u0026#34;0.3.3\u0026#34;},\n      {iex,\u0026#34;1.3.4\u0026#34;},\n      {sasl,\u0026#34;3.0.1\u0026#34;}]}.\n\u003c/pre\u003e\n\n\u003cp\u003e\nThis is an Erlang 4-tuple; it\u0026#39;s a \u003ccode\u003erelease\u003c/code\u003e of the \u003ccode\u003e\u0026#34;0.0.3\u0026#34;\u003c/code\u003e version of\n\u003ccode\u003eoctochat\u003c/code\u003e.  It will use the \u003ccode\u003e\u0026#34;8.1\u0026#34;\u003c/code\u003e version of \u0026#34;erts\u0026#34; and it depends on the\nlist of applications (and their versions) provided in the last element of the\ntuple.\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv id=\"outline-container-org99784cb\"\u003e\n\u003ch3 id=\"org99784cb\"\u003eAppups and Relups\u003c/h3\u003e\n\u003cdiv id=\"text-org99784cb\"\u003e\n\u003cp\u003e\nAs the naming might suggest, \u0026#34;appups\u0026#34; and \u0026#34;relups\u0026#34; are the \u0026#34;upgrade\u0026#34;\nversions of applications and releases, respectively.  Appups describe how\nto take a single application and upgrade its modules, specifically, it\nwill have instructions for upgrading modules that require \u0026#34;extras\u0026#34;. or,\nif we are upgrading supervisors, for example, the Appup will have the\ncorrect instructions for adding and removing child processes.\n\u003c/p\u003e\n\n\u003cp\u003e\nBefore we examine some examples of these files, let\u0026#39;s first look at the\ntype specification for each.\n\u003c/p\u003e\n\n\u003cp\u003e\nHere is the syntax structure for the \u003ccode\u003eappup\u003c/code\u003e resource file:\n\u003c/p\u003e\n\n\u003cpre\u003e{Vsn,\n  [{UpFromVsn, Instructions}, ...],\n  [{DownToVsn, Instructions}, ...]}.\n\u003c/pre\u003e\n\n\u003cp\u003e\nThe first element of the triple is the version we are either upgrading to or\ndowngrading from.  The second element is a keyword list of upgrade instructions\nkeyed by the version the application would be coming \u003ci\u003efrom\u003c/i\u003e.  Similarly, the\nthird element is a keyword list of downgrade instructions keyed by the version\nthe application will downgrade \u003ci\u003eto\u003c/i\u003e.  For more information about the types\nthemselves, see the \u003ca href=\"http://erlang.org/doc/man/appup.html\"\u003eSASL documentation\u003c/a\u003e.\n\u003c/p\u003e\n\n\u003cp\u003e\nNow that we have seen the syntax, let\u0026#39;s look at an example of the appup\nresource file for the octochat application generated using\n\u003ca href=\"https://github.com/bitwalker/distillery\"\u003edistillery\u003c/a\u003e:\n\u003c/p\u003e\n\n\u003cpre\u003e± cat rel/octochat/lib/octochat-0.2.1/ebin/octochat.appup\n{\u0026#34;0.2.1\u0026#34;,\n [{\u0026#34;0.2.0\u0026#34;,[{load_module,\u0026#39;Elixir.Octochat.Echo\u0026#39;,[]}]}],\n [{\u0026#34;0.2.0\u0026#34;,[{load_module,\u0026#39;Elixir.Octochat.Echo\u0026#39;,[]}]}]}.\n\u003c/pre\u003e\n\n\u003cp\u003e\nComparing this to the syntax structure above, we see that we have a \u003ccode\u003eVsn\u003c/code\u003e\nelement of \u003ccode\u003e\u0026#34;0.2.1\u0026#34;\u003c/code\u003e, we have a \u003ccode\u003e{UpFromVsn, Instructions}\u003c/code\u003e pair:\n\u003ccode\u003e[{\u0026#34;0.2.0\u0026#34;,[{load_module,\u0026#39;Elixir.Octochat.Echo\u0026#39;,[]}]}]\u003c/code\u003e, and we have a single\n\u003ccode\u003e{DownToVsn, Instructions}\u003c/code\u003e pair:\n\u003ccode\u003e[{\u0026#34;0.2.0\u0026#34;,[{load_module,\u0026#39;Elixir.Octochat.Echo\u0026#39;,[]}]}]\u003c/code\u003e.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe instructions themselves tell us what exactly is required to go from one\nversion to the another.  Specifically, in this example, to upgrade, we need to\n\u0026#34;load\u0026#34; the \u003ccode\u003eOctochat.Echo\u003c/code\u003e module into the VM.  Similarly, the instructions to\ndowngrade are the same.  For a \u003ca href=\"http://semver.org\"\u003esemantically versioned\u003c/a\u003e\nproject, this is an understandably small change.\n\u003c/p\u003e\n\n\u003cp\u003e\nIt\u0026#39;s worth noting the instructions found in the \u003ccode\u003e.appup\u003c/code\u003e files are\nusually high-level instructions, thus, \u003ccode\u003eload_module\u003c/code\u003e covers both the\nloading of object code into memory and the suspend, replace, resume\nprocess of upgrading applications.\n\u003c/p\u003e\n\n\u003cp\u003e\nNext, let\u0026#39;s look at the syntax structure of a \u003ccode\u003erelup\u003c/code\u003e resource file:\n\u003c/p\u003e\n\n\u003cpre\u003e{Vsn,\n [{UpFromVsn, Descr, Instructions}, ...],\n [{DownToVsn, Descr, Instructions}, ...]}.\n\u003c/pre\u003e\n\n\u003cp\u003e\nThis should look familiar.  It\u0026#39;s essentially the exact same as the\n\u003ccode\u003e.appup\u003c/code\u003e file.  However, there\u0026#39;s an extra term, \u003ccode\u003eDescr\u003c/code\u003e.  The \u003ccode\u003eDescr\u003c/code\u003e\nfield can be used as part of the version identification, but is\noptional.  Otherwise, the syntax of this file is the same as the\n\u003ccode\u003e.appup\u003c/code\u003e.\n\u003c/p\u003e\n\n\u003cp\u003e\nNow, let\u0026#39;s look at an example \u003ccode\u003erelup\u003c/code\u003e file for the same release of\noctochat:\n\u003c/p\u003e\n\n\u003cpre\u003e± cat rel/octochat/releases/0.2.1/relup\n{\u0026#34;0.2.1\u0026#34;,\n [{\u0026#34;0.2.0\u0026#34;,[],\n   [{load_object_code,{octochat,\u0026#34;0.2.1\u0026#34;,[\u0026#39;Elixir.Octochat.Echo\u0026#39;]}},\n    point_of_no_return,\n    {load,{\u0026#39;Elixir.Octochat.Echo\u0026#39;,brutal_purge,brutal_purge}}]}],\n [{\u0026#34;0.2.0\u0026#34;,[],\n   [{load_object_code,{octochat,\u0026#34;0.2.0\u0026#34;,[\u0026#39;Elixir.Octochat.Echo\u0026#39;]}},\n    point_of_no_return,\n    {load,{\u0026#39;Elixir.Octochat.Echo\u0026#39;,brutal_purge,brutal_purge}}]}]}.\n\u003c/pre\u003e\n\n\u003cp\u003e\nThis file is a little more dense, but still adheres to the basic triple syntax\nwe just examined.  Let\u0026#39;s take a closer look at the upgrade instructions:\n\u003c/p\u003e\n\n\u003cpre\u003e[{load_object_code,{octochat,\u0026#34;0.2.1\u0026#34;,[\u0026#39;Elixir.Octochat.Echo\u0026#39;]}},\n point_of_no_return,\n {load,{\u0026#39;Elixir.Octochat.Echo\u0026#39;,brutal_purge,brutal_purge}}]\n\u003c/pre\u003e\n\n\u003cp\u003e\nThe first instruction,\n\u003ccode\u003e{load_object_code,{octochat,\u0026#34;0.2.1\u0026#34;,[\u0026#39;Elixir.Octochat.Echo\u0026#39;]}}\u003c/code\u003e, tells the\n\u003ca href=\"http://erlang.org/doc/man/release_handler.html\"\u003erelease handler\u003c/a\u003e to load into memory the new\nversion of the \u0026#34;Octochat.Echo\u0026#34; module, specifically the one associated with\nversion \u0026#34;0.2.1\u0026#34;.  But this instruction will not instruct the release handler to\n(re)start or replace the existing module yet.  Next, \u003ccode\u003epoint_of_no_return\u003c/code\u003e, tells\nthe release handler that failure beyond this point is fatal, if the upgrade\nfails after this point, the system is restarted from the old release version\n(\u003ca href=\"http://erlang.org/doc/man/appup.html\"\u003eappup documentation\u003c/a\u003e).  The final instruction,\n\u003ccode\u003e{load,{\u0026#39;Elixir.Octochat.Echo\u0026#39;,brutal_purge,brutal_purge}}\u003c/code\u003e, tells the release\nhandler to replace the running version of the module and use the newly loaded\nversion.\n\u003c/p\u003e\n\n\u003cp\u003e\nFor more information regarding \u003ccode\u003eburtal_purge\u003c/code\u003e, check out the \u0026#34;PrePurge\u0026#34; and\n\u0026#34;PostPurge\u0026#34; values in the \u003ca href=\"http://erlang.org/doc/man/appup.html\"\u003eappup documentation\u003c/a\u003e.\n\u003c/p\u003e\n\n\u003cp\u003e\nSimilar to the \u003ccode\u003e.appup\u003c/code\u003e file, the third element in the triple describes to the\nrelease handler how to downgrade the release as well.  The version numbers in\nthis case make this a bit more obvious as well, however, the steps are\nessentially the same.\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv id=\"outline-container-org2b423cb\"\u003e\n\u003ch3 id=\"generating-releases-and-upgrades-with-elixir\"\u003eGenerating Releases and Upgrades with Elixir\u003c/h3\u003e\n\u003cdiv id=\"text-generating-releases-and-upgrades-with-elixir\"\u003e\n\u003cp\u003e\nNow that we have some basic understanding of releases and upgrades, let\u0026#39;s see\nhow we can generate them with Elixir.  We will generate the releases with the\n\u003ca href=\"https://github.com/bitwalker/distillery\"\u003edistillery\u003c/a\u003e project, however, the commands should also work with\nthe soon to be deprecated \u003ca href=\"https://github.com/bitwalker/exrm\"\u003eexrm\u003c/a\u003e project.\n\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e\nThis has been written for the \u003ccode\u003e0.10.1\u003c/code\u003e version of\n\u003ca href=\"https://github.com/bitwalker/distillery\"\u003edistillery\u003c/a\u003e.  This is a\nfast moving project that is in beta, be prepared to update as\nnecessary.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nAdd the \u003ca href=\"https://github.com/bitwalker/distillery\"\u003edistillery\u003c/a\u003e application to your \u003ccode\u003edeps\u003c/code\u003e list:\n\u003c/p\u003e\n\n\u003cpre\u003e{:distillery, \u0026#34;~\u0026gt; 0.10\u0026#34;}\n\u003c/pre\u003e\n\n\u003cp\u003e\nPerform the requisite dependency download:\n\u003c/p\u003e\n\n\u003cpre\u003e± mix deps.get\n\u003c/pre\u003e\n\n\u003cp\u003e\nThen, to build your first production release, you can use the following:\n\u003c/p\u003e\n\n\u003cpre\u003e± MIX_ENV=prod mix release --env prod\n\u003c/pre\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e\nFor more information on why you must specify both environments, please read\nthe \u003ca href=\"https://hexdocs.pm/distillery/common-issues.html#why-do-i-have-to-set-both-mix_env-and-env\"\u003eFAQ\u003c/a\u003e of distillery.  If the environments match,\nthere\u0026#39;s a small modification to the \u003ccode\u003e./rel/config.exs\u003c/code\u003e that can be made so\nthat specifying both is no longer necessary.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nAfter this process is complete, there should be a new folder under the \u003ccode\u003e./rel\u003c/code\u003e\nfolder that contains the new release of the project.  Within this directory,\nthere will be several directories, namely, \u003ccode\u003ebin\u003c/code\u003e, \u003ccode\u003eerts-{version}\u003c/code\u003e, \u003ccode\u003elib\u003c/code\u003e, and\n\u003ccode\u003ereleases\u003c/code\u003e.  The \u003ccode\u003ebin\u003c/code\u003e directory will contain the top level Erlang entry\nscripts, the \u003ccode\u003eerts-{version}\u003c/code\u003e folder will contain the requisite files for the\nErlang runtime, the \u003ccode\u003elib\u003c/code\u003e folder will contain the compiled beam files for the\nrequired applications for the release, and finally, the \u003ccode\u003ereleases\u003c/code\u003e folder will\ncontain the versions of the releases.  Each folder for each version will have\nits own \u003ccode\u003erel\u003c/code\u003e file, generated boot scripts, as per the\n\u003ca href=\"http://erlang.org/doc/design_principles/release_structure.html\"\u003eOTP releases guide\u003c/a\u003e, and a tarball of the release\nfor deployment.\n\u003c/p\u003e\n\n\u003cp\u003e\nDeploying the release is a little out of scope for this post and may be the\nsubject of another.  For more information about releases, see the\n\u003ca href=\"http://erlang.org/doc/system_principles/create_target.html\"\u003eSystem Principles\u003c/a\u003e guide.  However, for\nElixir, it may look similar to the following:\n\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\nCopy the release tarball to the target system:\n\u003c/p\u003e\n\n\u003cpre\u003e± scp rel/octochat/releases/0.3.2/octochat.tar.gz target_system:/opt/apps/.\n\u003c/pre\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003e\nOn the target system, unpack the release:\n\u003c/p\u003e\n\n\u003cpre\u003e± ssh target_system\n(ts)# cd /opt/apps\n(ts)# mkdir -p octochat\n(ts)# tar -zxf octochat.tar.gz -C octochat\n\u003c/pre\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003e\nStart the system:\n\u003c/p\u003e\n\n\u003cpre\u003e(ts)# cd octochat\n(ts)# bin/octochat start\n\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\nThis will bring up the Erlang VM and the application tree on the target system.\n\u003c/p\u003e\n\n\u003cp\u003e\nNext, after making some applications changes and bumping the project version,\nwe can generate an upgrade release using the following command:\n\u003c/p\u003e\n\n\u003cpre\u003e± MIX_ENV=prod mix release --upgrade\n\u003c/pre\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e\nNote, This will \u003ci\u003ealso\u003c/i\u003e generate a regular release.\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\nOnce this process finishes, checking the \u003ccode\u003erel/{app_name}/releases\u003c/code\u003e folder,\nthere should be a new folder for the new version, and a \u003ccode\u003erelup\u003c/code\u003e file for the\nupgrade:\n\u003c/p\u003e\n\n\u003cpre\u003e± cat rel/octochat/releases/0.3.3/octochat.rel\n{release,{\u0026#34;octochat\u0026#34;,\u0026#34;0.3.3\u0026#34;},\n     {erts,\u0026#34;8.1\u0026#34;},\n     [{logger,\u0026#34;1.3.4\u0026#34;},\n      {compiler,\u0026#34;7.0.2\u0026#34;},\n      {elixir,\u0026#34;1.3.4\u0026#34;},\n      {stdlib,\u0026#34;3.1\u0026#34;},\n      {kernel,\u0026#34;5.1\u0026#34;},\n      {octochat,\u0026#34;0.3.3\u0026#34;},\n      {iex,\u0026#34;1.3.4\u0026#34;},\n      {sasl,\u0026#34;3.0.1\u0026#34;}]}.\n\n± cat rel/octochat/releases/0.3.3/relup\n{\u0026#34;0.3.3\u0026#34;,\n [{\u0026#34;0.3.2\u0026#34;,[],\n   [{load_object_code,{octochat,\u0026#34;0.3.3\u0026#34;,[\u0026#39;Elixir.Octochat.Echo\u0026#39;]}},\n    point_of_no_return,\n    {suspend,[\u0026#39;Elixir.Octochat.Echo\u0026#39;]},\n    {load,{\u0026#39;Elixir.Octochat.Echo\u0026#39;,brutal_purge,brutal_purge}},\n    {code_change,up,[{\u0026#39;Elixir.Octochat.Echo\u0026#39;,[]}]},\n    {resume,[\u0026#39;Elixir.Octochat.Echo\u0026#39;]}]}],\n [{\u0026#34;0.3.2\u0026#34;,[],\n   [{load_object_code,{octochat,\u0026#34;0.3.1\u0026#34;,[\u0026#39;Elixir.Octochat.Echo\u0026#39;]}},\n    point_of_no_return,\n    {suspend,[\u0026#39;Elixir.Octochat.Echo\u0026#39;]},\n    {code_change,down,[{\u0026#39;Elixir.Octochat.Echo\u0026#39;,[]}]},\n    {load,{\u0026#39;Elixir.Octochat.Echo\u0026#39;,brutal_purge,brutal_purge}},\n    {resume,[\u0026#39;Elixir.Octochat.Echo\u0026#39;]}]}]}.\n\u003c/pre\u003e\n\n\u003cp\u003e\nSimilarly, to deploy this new upgrade, copy the tarball to the target system\nand unpack it into the same directory as before.\n\u003c/p\u003e\n\n\u003cp\u003e\nAfter it\u0026#39;s unpacked, upgrading the release can be done via a stop and start, or\nwe can issue the \u003ccode\u003eupgrade\u003c/code\u003e command:\n\u003c/p\u003e\n\n\u003cpre\u003e(ts)# bin/octochat stop\n(ts)# bin/octochat start\n\u003c/pre\u003e\n\n\u003cp\u003e\nOr:\n\u003c/p\u003e\n\n\u003cpre\u003e(ts)# bin/octochat upgrade \u0026#34;0.3.3\u0026#34;\n\u003c/pre\u003e\n\n\u003cp\u003e\nWhen starting and stopping, the entry point script knows how to select the\n\u0026#34;newest\u0026#34; version.\n\u003c/p\u003e\n\n\u003cp\u003e\nWhen upgrading, it is required to specify the desired version, this is\nnecessary since the upgrade process may require more than simply jumping to the\n\u0026#34;latest\u0026#34; version.\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv id=\"outline-container-org0bb3963\"\u003e\n\u003ch2 id=\"org0bb3963\"\u003eSummary\u003c/h2\u003e\n\u003cdiv id=\"text-org0bb3963\"\u003e\n\u003cp\u003e\nRelease management is a complex topic, upgrading without restarting seemingly\neven more so.  However, the process \u003ci\u003ecan\u003c/i\u003e be understood, and knowing how the\nprocess works will allow us to make more informed decisions regarding when to\nuse it.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe tooling for performing hot upgrades has been around for a while, and while\nthe tooling for Elixir is getting closer, we are not quite ready for prime\ntime.  But it won\u0026#39;t remain this way for long.  Soon, it will be common place\nfor Elixir applications to be just as manageable as the Erlang counterparts.\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "19 min read",
  "publishedTime": null,
  "modifiedTime": null
}
