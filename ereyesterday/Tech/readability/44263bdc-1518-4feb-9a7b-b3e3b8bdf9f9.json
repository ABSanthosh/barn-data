{
  "id": "44263bdc-1518-4feb-9a7b-b3e3b8bdf9f9",
  "title": "\"The closer to the train station, the worse the kebab\" â€“ a \"study\"",
  "link": "https://www.jmspae.se/write-ups/kebabs-train-stations/",
  "description": "Comments",
  "author": "",
  "published": "Mon, 24 Feb 2025 21:25:15 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 17317,
  "excerpt": "2025-02-14",
  "siteName": "",
  "favicon": "",
  "text": "2025-02-14 Introduction Method Network Data Restaurant Data Routing and Distance Results Discussion This write-up was originally posted on reddit, though I've cleaned things up specifically for this post. Due to reasons discussed towards the end of this post, I'm not entirely happy with the results and intend to take another shot at it in the near future. IntroductionðŸ”— I came across this post sharing a hypothesis from a French subreddit; The closer to the train station, the worse the kebab. The original French post gained a decent amount of traction compared to the subreddit's relatively small size, indicating a certain amount of agreement among its members. There were some detractors in the comments, however, sharing experiences which ran contrary to the stated hypothesis. Thus, I figured I had nothing better to do, being a burned-out, unemployed drop-out with a newly-obtained autism diagnosis, so I figured I'd sacrifice my time for a worthy cause and perform this informal \"study\". I'll be expecting my Nobel peace prize in the postbox and several job offers in my DMs within the next 3 working days. MethodðŸ”— I assumed the best study area to be Paris, France since; The original post was French I haven't personally heard of this hypothesis in my home country (Sweden, also home to many a kebab-serving restaurant) so I figured I'd assume this to be a French phenomenon for the purpose of this informal \"Study\". Density The inner city is dense with dozens of train/metro stations and god knows how many kebab shops. I knew early on that this would make my life pretty miserable, but at least it'd provide plenty of sample data. Network DataðŸ”— I used OSMnx to download and save a navigation network. Given the public transit-centric nature of the French subreddit, I though it'd make sense to stick to walking distance (eg. footpaths, side-walks) thus i set the OSMnx network_type to \"walk\". Given the location (and that OSMnx used this CRS automatically when none was provided), all data was projected to EPSG:32631 (UTM zone 31N). import osmnx as ox from geopandas import GeoDataFrame #EPSG PROJECTION = 32631 graph = ox.graph_from_place('Paris, FR', network_type=\"walk\") graph = ox.project_graph(graph, to_crs=PROJECTION) ox.save_graphml(graph, filepath=\"network.graphml\") Figure 1: The study area and network Next up is the various train/metro stations. Given the nature of the original French sub, I figured it'd make sense to include both the long-distance central stations along with the countless metro stations. This was also rather trivial with OSMnx, filtering by railway=subway_entrance or railway=train_station_entrance. stations: GeoDataFrame = ox.features_from_place('Paris, FR', tags = { \"railway\": [\"subway_entrance\", \"train_station_entrance\"] }) # Filter results to points station_nodes: GeoDataFrame = stations.loc[stations.geom_type==\"Point\"] station_nodes = station_nodes.to_crs(epsg=PROJECTION) station_nodes.to_file(\"train_station_entrances.gpkg\") I saved outputs religiously so I could easily inspect them in QGIS. I did attempt to get python notebooks working with my NeoVIM setup, but it was all for naught. Figure 2: Rail/metro entrances... Please ignore the airport iconography. ... And there we have the first half of the data, now for the restaurants. Restaurant DataðŸ”— The Google Places API (and their respective reviews) seemed like a reasonable choice. Google reviews are naturally far from perfect and subject to their fair share of botting and the like, but it's the best I could think of at the time. There are alternatives such as Yelp, but their API is horrifically expensive for poor old me, and I was not in the mood to build a web scraper (it has the same soul-sucking effect on me as prompting an LLM). The $200 of free credit was also enticing. However, as I started exploring the API... I realised that the Places API doesn't seem to have any way to search within a polygon, only within a point radius. Thank you, Mr. publicly owned mega-corporation. How Fun. It also didn't help that autocomplete for the googlemaps library wasn't working. Python's a fine language, but its tooling does like to test my patience a little too often. And whilst I'm still complaining... The Google Cloud dashboard is likely the slowest \"website\" I've ever had the displeasure of interacting with. So... This meant I'd have to perform some sort of grid search of the whole of Paris, crossing my fingers that I wouldn't bust my free usage. This, along with a couple interesting questions; What is... A kebab? When I search for \"kebab\" (no further context necessary)... How does Google decide what restaurant serves kebab? After some perusing, it didn't seem to be as deep as I thought. Plenty of restaurants simply had \"kebab\" in the name, some were designated as \"Mediterranean\" (Kebab has its origins in Turkey, Persia, middle east in general) and others had a fair few reviews simply mentioning \"kebab.\" Good enough for me. Trouble in query-land It turns out that when you query for places within a given radius, it's only a \"bias.\" It's not a hard cut-off that'll help narrow-down our data harvesting and reduce unnecessary requests. It was becoming increasingly clear that google isn't really a fan of people doing this. Now with all of that preamble out of the way, I needed to prepare my search. Figure 3. Original admin boundaries Paris' administrative boundary contains a couple of large green spaces. To the west, a park and to the east, some sort of sports institute. After perusing these rather large spaces in Google maps, they seemed to contain a distinct lack of kebab-serving establishments. Thus, they were a burden on our API budget and needed to go. Figure 4. Adjusted admin boundaries w/ network I figured keeping the network and stations wouldn't do any harm, so they went unmodified. Figure 5. Sampling points, later projected to WGS84 for harvesting purposes To maximise data-harvesting, I decided to go with a hex layout with a vertical spacing of 1 km. This should give us a search radius of 500m * âˆš3 ~= 866 meters. Plenty of overlap, sure, but we shouldn't be getting any holes anywhere. I'm not sure why I was spending this much time ensuring \"data integrity\" when that might just have flown the window courtesy of Google, but it's the illusion of control that counts. This give us 99 sample points which... Should be enough? Regardless, here's how my 3AM python turned out: # Already projected to WGS84 sample_points: GeoDataFrame = GeoDataFrame.from_file(\"samples.gpkg\") gmaps: googlemaps.Client = googlemaps.Client(key='get-your-own') output = {} for point in sample_points.geometry: lat, lon = point.y, point.x next_page_token = None num_fetches = 3 while num_fetches \u003e 0: result = {} if next_page_token == None: result = gmaps.places( \"kebab\", location=(lat, lon), radius=866, ) else: result = gmaps.places( page_token=next_page_token ) next_page_token = result.get(\"next_page_token\") print(result[\"status\"], next_page_token) for p in result[\"results\"]: output[p[\"place_id\"]] = p if next_page_token == None: break num_fetches -= 1 sleep(2) json_out = json.dumps(output) with open(\"output.json\", \"w\") as file: file.write(json_out) This worked quite well. Initially I skipped paging, resulting in 322 results. However, I noticed that a few establishments were missing in the results compared to my explorations in Google Maps. After implementing paging and re-running, this gave us a grand total of 400 kebab-serving establishments. I was likely over-zealous with the paging considering how few additional results were retrieved. That, and that the API doesn't cap the search radius (again, it's only a bias) likely led to a fair few redundant API calls. The raw Google Places API-output also needed to be clipped to the study area, projected to the local UTM zone as well as converted to a geospatial format; import pandas as pd with open(\"output.json\", \"r\") as file: data = json.load(file) file.close() for id in data: place = data[id] point = place[\"geometry\"][\"location\"] data[id][\"lng\"] = point[\"lng\"] data[id][\"lat\"] = point[\"lat\"] del data[id][\"geometry\"] data = pd.DataFrame.from_dict(data).T data.rating = pd.to_numeric(data.rating) data.user_ratings_total = pd.to_numeric(data.user_ratings_total) data = data[data[\"user_ratings_total\"] \u003e 0] # Cleanup was added after the screenshot below was taken data = data.drop(columns=[ \"icon\", \"icon_background_color\", \"icon_mask_base_uri\", \"plus_code\", \"reference\", \"photos\", \"opening_hours\" ]) gdata = GeoDataFrame( data, geometry=geopandas.points_from_xy(data.lng, data.lat), crs=4326 ) gdata: GeoDataFrame = gdata.to_crs(PROJECTION) # Modified boundaries from Figure 4. paris = GeoDataFrame.from_file(\"mod_bounary.gpkg\"); gdata: GeoDataFrame = gdata.clip(paris) gdata.to_file(\"establishments.gpkg\") Figure 6. We're in f###ing business Routing and DistanceðŸ”— Finally, the fun part. I need to get the distance to the nearest station entrance for each establishment. I could've absolutely just routed to every single entrance for every single restaurant to get the nearest... But that would've taken several decades. I needed to build some sort of spatial index and route to the nearest ~3 or something along those lines. Since Paris is so dense with plenty of routing options, I figured I wouldn't need to perform too many routing operations. After some googling and dredging through API docs, however, it seemed GeoPandas was nice enough to do that for us with sindex. Although it didn't have the same \"return nearest N\" like my beloved r-tree rust library I was all too used to, it did allow me to search within a certain radius (1 km was large enough) and go from there. The query results weren't sorted, so I had to sort the indexes by distance and cut it down to size. The network analysis was relatively straight-forward thanks to NetworkX, and after a couple of hours I managed to cobble together the following; import networkx as nx import shapely as shp establishments: GeoDataFrame = GeoDataFrame.from_file(\"establishments.gpkg\") entrances: GeoDataFrame = GeoDataFrame.from_file(\"entrances.gpkg\") graph = ox.load_graphml(\"network.graphml\") graph = ox.project_graph(graph, to_crs = PROJECTION) # Ensure the same CRS if (establishments.crs != entrances.crs != PROJECTION): exit(100) # Helper function to get the distance between a graph node and establishment geometry def node_geom_dist(node_id: int, geom: shp.Point): node = graph.nodes[node_id] return math.sqrt((geom.x - node['x']) ** 2 + (geom.y - node['y']) ** 2) distances: list[float] = [] for (id, establishment) in establishments.iterrows(): establishment_geom: shp.Point = establishment.geometry establishment_node: int = ox.nearest_nodes(graph, establishment_geom.x, establishment_geom.y) establishment_dist_to_node: float = node_geom_dist(establishment_node, establishment_geom) # Spatial index for rail entrances index: shp.STRtree = entrances.sindex nearest_q = index.query(establishment_geom, predicate=\"dwithin\", distance = 1000) nearest_entrances: list[tuple[int, float]] = [] for i in nearest_q: ent = entrances.iloc[i] ent_geom: shp.Point = ent.geometry dist = ent_geom.distance(establishment.geometry) nearest_entrances.append((i, dist)) nearest_entrances = sorted(nearest_entrances, key = lambda e: e[1])[:3] entrance_geom: list[shp.Point] = [entrances.iloc[i].geometry for (i, _) in nearest_entrances] entrance_nodes: list[int] = [ox.nearest_nodes(graph, point.x, point.y) for point in entrance_geom] entrance_geom_dist_to_node: list[float] = [node_geom_dist(entrance_nodes[i], entrance_geom[i]) for i in range(len(nearest_entrances))] result_paths = [nx.shortest_path(graph, establishment_node, dest_node, weight=\"length\") for dest_node in entrance_nodes] result_lengths: list[float] = [nx.path_weight(graph, path, \"length\") + entrance_geom_dist_to_node[i] + establishment_dist_to_node for (i, path) in enumerate(result_paths)] distances.append(min(result_lengths)) establishments[\"distance\"] = distances establishments.to_file(\"establishment_results.gpkg\") Not exactly my finest work. The sheer amount of list comprehension is perhaps a little terrifying, but it works. After some prodding around in QGIS with the resulting data and networks (and many print() statements), I was confident in the accuracy of the results. ResultsðŸ”— Now with all of this data, it is time to settle the question of whether or not the kebabs are less tasty the closer they are to a train/metro station... Figure 7. Hmmmmm.... With a mighty Pearson's correlation of 0.091, the data indicates that this could be true! If you ignore the fact that the correlation is so weak that calling it 'statistically insignificant' would be quite generous. Outliers can have an outsized impact on a Pearson's correlation, so after ridding the dataset of some outliers via IQR fencing... Figure 8. Removed outliers ... This increased the coefficient to a whopping 0.098. This was a bit of a bummer (though hardly surprising) and figuring I had nothing to lose from messing around a little, I tried filtering out metro stations in case my original assumption of the metro being included in the original hypothesis was incorrect. *Figure 9. Not much better, eh? Correction: \"... Nearest train station entrance.\" With an even worse coefficient of 0.001, I think It's time to hang up the towel. Whilst there are some minor indications that the hypothesis could be correct (eg. Many of the absolute worst restaurants being some of the closest) the correlation is simply too weak. DiscussionðŸ”— - Are Google reviews an objective measurement of how tasty the kebabs are? Absolutely the f### not. This was a rather subjective observation from the very beginning and Google reviews aren't exactly a good measure of \"is the food good?\" There are many aspects of the dining experience that could hypothetically impact a review score. The staff, cleanliness, the surrounding environment, etc. Not to mention online skulduggery and review manipulation. - Can tourism have an impact? It absolutely could. I don't want to make any definitive assumptions, but I can absolutely imagine the local regulars being harsher than the massive tourist population, or even vice-versa. - Were the Google results accurate? To an extent, yes. From what I could gather, every location from the query seemed to serve kebab in some form. There were a few weird outliers and nuances, such as Pizza Hut which likely only serves kebab pizza rather than the multitude of different forms in which kebab could possibly be consumed. - Why not restaurants in general? Because the initial hypothesis was too comically hyper-specific for me to give up on. - What about review count? This could very well have an effect, though I was not entirely certain how to properly implement this metric into the analysis at the time. - Gib Data I'm not quite comfortable in doing so, mostly due to potential breaches of Google's TOS. I don't think they would care about me harvesting some 400 POIs for this little experiment, I'm not quite willing to gamble sharing the data with others. Besides, I gave you the code. Go burn some of your own credits. - Are you Ok? ... I guess? Are you? In conclusion, this was actually quite fun. I wrote this as the project went on (otherwise I would likely never have found the motivation) and I would encourage others to do other silly explorations like this, even if the results end up slightly depressing. ... However, after some additional discussion, I decided I wasn't quite done. As stated earlier, there were a few detracting comments on the original French post. Interestingly, many of the provided examples of good kebab restaurants next to train stations just so happened to be in Paris. The user who originally posted the French post for the sub in English provided some examples which seem to strengthen the hypothesis. It could very well be that whatever conditions affect Paris restaurants (whether it be higher rent, wages, tourism, population density...) had a larger impact than I initially suspected. Stay tuned for part 2... Whenever I get around to doing it!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\n\n\u003cp\u003e\u003cstrong\u003e2025-02-14\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n    \n        \u003cli\u003e\n            \u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/#introduction\"\u003eIntroduction\u003c/a\u003e\n            \n        \u003c/li\u003e\n    \n        \u003cli\u003e\n            \u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/#method\"\u003eMethod\u003c/a\u003e\n            \n                \u003cul\u003e\n                    \n                        \u003cli\u003e\n                            \u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/#network-data\"\u003eNetwork Data\u003c/a\u003e\n                        \u003c/li\u003e\n                    \n                        \u003cli\u003e\n                            \u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/#restaurant-data\"\u003eRestaurant Data\u003c/a\u003e\n                        \u003c/li\u003e\n                    \n                        \u003cli\u003e\n                            \u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/#routing-and-distance\"\u003eRouting and Distance\u003c/a\u003e\n                        \u003c/li\u003e\n                    \n                \u003c/ul\u003e\n            \n        \u003c/li\u003e\n    \n        \u003cli\u003e\n            \u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/#results\"\u003eResults\u003c/a\u003e\n            \n        \u003c/li\u003e\n    \n        \u003cli\u003e\n            \u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/#discussion\"\u003eDiscussion\u003c/a\u003e\n            \n        \u003c/li\u003e\n    \n    \u003c/ul\u003e\n\n\u003cp\u003e\u003cem\u003eThis write-up was originally posted \u003ca href=\"https://www.reddit.com/r/gis/comments/1iph0yy/the_closer_to_the_railway_station_the_less_tasty/\"\u003eon reddit\u003c/a\u003e, though I\u0026#39;ve cleaned things up specifically for this post. Due to reasons discussed towards the end of this post, I\u0026#39;m not entirely happy with the results and intend to take another shot at it in the near future.\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003ca href=\"#introduction\" aria-label=\"Anchor link for: introduction\"\u003eðŸ”—\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eI came across \u003ca href=\"https://www.reddit.com/r/gis/comments/1iopp56/anyone_motivated_to_prove_that_the_closer_from/\"\u003ethis post\u003c/a\u003e sharing a hypothesis from a French subreddit;\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe closer to the train station, the worse the kebab.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe original French post gained a decent amount of traction compared to the subreddit\u0026#39;s relatively small size, indicating a certain amount of agreement among its members. There were some detractors in the comments, however, sharing experiences which ran contrary to the stated hypothesis.\u003c/p\u003e\n\u003cp\u003eThus, I figured I had nothing better to do, being a burned-out, unemployed drop-out with a newly-obtained autism diagnosis, so I figured I\u0026#39;d sacrifice my time for a worthy cause and perform this informal \u003cem\u003e\u0026#34;study\u0026#34;\u003c/em\u003e. I\u0026#39;ll be expecting my Nobel peace prize in the postbox and several job offers in my DMs within the next 3 working days.\u003c/p\u003e\n\u003ch2 id=\"method\"\u003eMethod\u003ca href=\"#method\" aria-label=\"Anchor link for: method\"\u003eðŸ”—\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eI assumed the best study area to be Paris, France since;\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe original post was French\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eI haven\u0026#39;t personally heard of this hypothesis in my home country (Sweden, also home to many a kebab-serving restaurant) so I figured I\u0026#39;d assume this to be a French phenomenon for the purpose of this informal \u0026#34;Study\u0026#34;.\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eDensity\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe inner city is \u003cem\u003e\u003cstrong\u003edense\u003c/strong\u003e\u003c/em\u003e with dozens of train/metro stations and god knows how many kebab shops. I knew early on that this would make my life pretty miserable, but at least it\u0026#39;d provide plenty of sample data.\u003c/p\u003e\n\u003ch2 id=\"network-data\"\u003eNetwork Data\u003ca href=\"#network-data\" aria-label=\"Anchor link for: network-data\"\u003eðŸ”—\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eI used OSMnx to download and save a navigation network. Given the public transit-centric nature of the French subreddit, I though it\u0026#39;d make sense to stick to walking distance (eg. footpaths, side-walks) thus i set the OSMnx \u003ccode\u003enetwork_type\u003c/code\u003e to \u003ccode\u003e\u0026#34;walk\u0026#34;\u003c/code\u003e. Given the location (and that OSMnx used this CRS automatically when none was provided), all data was projected to EPSG:32631 (UTM zone 31N).\u003c/p\u003e\n\u003cpre data-lang=\"py\"\u003e\u003ccode data-lang=\"py\"\u003e\u003cspan\u003eimport \u003c/span\u003e\u003cspan\u003eosmnx \u003c/span\u003e\u003cspan\u003eas \u003c/span\u003e\u003cspan\u003eox\n\u003c/span\u003e\u003cspan\u003efrom \u003c/span\u003e\u003cspan\u003egeopandas \u003c/span\u003e\u003cspan\u003eimport \u003c/span\u003e\u003cspan\u003eGeoDataFrame\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e#EPSG\n\u003c/span\u003e\u003cspan\u003ePROJECTION \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e32631\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003egraph \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eox.\u003c/span\u003e\u003cspan\u003egraph_from_place\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Paris, FR\u0026#39;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003enetwork_type\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;walk\u0026#34;\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003egraph \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eox.\u003c/span\u003e\u003cspan\u003eproject_graph\u003c/span\u003e\u003cspan\u003e(graph, \u003c/span\u003e\u003cspan\u003eto_crs\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003ePROJECTION\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003eox.\u003c/span\u003e\u003cspan\u003esave_graphml\u003c/span\u003e\u003cspan\u003e(graph, \u003c/span\u003e\u003cspan\u003efilepath\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;network.graphml\u0026#34;\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n\u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/fig-1.webp\" target=\"_blank\"\u003e\u003cimg src=\"https://jmspae.se/processed_images/fig-1.c53f23b9b1fd351c.jpg\"/\u003e\u003c/a\u003e\n\n\u003cem\u003eFigure 1: The study area and network\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eNext up is the various train/metro stations. Given the nature of the original French sub, I figured it\u0026#39;d make sense to include both the long-distance central stations along with the countless metro stations. This was also rather trivial with OSMnx, filtering by \u003ccode\u003erailway=subway_entrance\u003c/code\u003e or \u003ccode\u003erailway=train_station_entrance.\u003c/code\u003e\u003c/p\u003e\n\u003cpre data-lang=\"py\"\u003e\u003ccode data-lang=\"py\"\u003e\u003cspan\u003estations: GeoDataFrame \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eox.\u003c/span\u003e\u003cspan\u003efeatures_from_place\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;Paris, FR\u0026#39;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003etags \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e\u0026#34;railway\u0026#34;\u003c/span\u003e\u003cspan\u003e: [\u003c/span\u003e\u003cspan\u003e\u0026#34;subway_entrance\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e\u0026#34;train_station_entrance\u0026#34;\u003c/span\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003cspan\u003e})\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e# Filter results to points\n\u003c/span\u003e\u003cspan\u003estation_nodes: GeoDataFrame \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003estations.loc[stations.geom_type\u003c/span\u003e\u003cspan\u003e==\u003c/span\u003e\u003cspan\u003e\u0026#34;Point\u0026#34;\u003c/span\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003cspan\u003estation_nodes \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003estation_nodes.\u003c/span\u003e\u003cspan\u003eto_crs\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eepsg\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003ePROJECTION\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003estation_nodes.\u003c/span\u003e\u003cspan\u003eto_file\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;train_station_entrances.gpkg\u0026#34;\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI saved outputs religiously so I could easily inspect them in QGIS. I did attempt to get python notebooks working with my NeoVIM setup, but it was all for naught.\u003c/p\u003e\n\u003cp\u003e\n\u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/fig-2.webp\" target=\"_blank\"\u003e\u003cimg src=\"https://jmspae.se/processed_images/fig-2.51f0e47dcd63c0a8.jpg\"/\u003e\u003c/a\u003e\n\n\u003cem\u003eFigure 2: Rail/metro entrances... Please ignore the airport iconography.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e... And there we have the first half of the data, now for the restaurants.\u003c/p\u003e\n\u003ch2 id=\"restaurant-data\"\u003eRestaurant Data\u003ca href=\"#restaurant-data\" aria-label=\"Anchor link for: restaurant-data\"\u003eðŸ”—\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe Google Places API (and their respective reviews) seemed like a reasonable choice. Google reviews are naturally far from perfect and subject to their fair share of botting and the like, but it\u0026#39;s the best I could think of at the time. There are alternatives such as Yelp, but their API is horrifically expensive for poor old me, and I was not in the mood to build a web scraper (it has the same soul-sucking effect on me as prompting an LLM). The $200 of free credit was also enticing.\u003c/p\u003e\n\u003cp\u003eHowever, as I started exploring the API... I realised that the Places API doesn\u0026#39;t seem to have any way to search within a polygon, only within a point radius. Thank you, Mr. publicly owned mega-corporation. How Fun.\u003c/p\u003e\n\u003cp\u003eIt also didn\u0026#39;t help that autocomplete for the \u003ccode\u003egooglemaps\u003c/code\u003e library wasn\u0026#39;t working. Python\u0026#39;s a fine language, but its tooling does like to test my patience a little too often. And whilst I\u0026#39;m still complaining... The Google Cloud dashboard is likely the slowest \u0026#34;website\u0026#34; I\u0026#39;ve ever had the displeasure of interacting with.\u003c/p\u003e\n\u003cp\u003eSo... This meant I\u0026#39;d have to perform some sort of grid search of the whole of Paris, crossing my fingers that I wouldn\u0026#39;t bust my free usage. This, along with a couple interesting questions;\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWhat is... \u003cem\u003eA kebab?\u003c/em\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWhen I search for \u0026#34;kebab\u0026#34; (no further context necessary)... How does Google decide what restaurant serves kebab?\u003c/p\u003e\n\u003cp\u003eAfter some perusing, it didn\u0026#39;t seem to be as deep as I thought. Plenty of restaurants simply had \u0026#34;kebab\u0026#34; in the name, some were designated as \u0026#34;Mediterranean\u0026#34; (Kebab has its origins in Turkey, Persia, middle east in general) and others had a fair few reviews simply mentioning \u0026#34;kebab.\u0026#34; Good enough for me.\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eTrouble in query-land\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIt turns out that when you query for places within a given radius, it\u0026#39;s only a \u0026#34;bias.\u0026#34; It\u0026#39;s not a hard cut-off that\u0026#39;ll help narrow-down our data harvesting and reduce unnecessary requests. It was becoming increasingly clear that google isn\u0026#39;t really a fan of people doing this.\u003c/p\u003e\n\u003cp\u003eNow with all of that preamble out of the way, I needed to prepare my search.\u003c/p\u003e\n\u003cp\u003e\n\u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/fig-3.webp\" target=\"_blank\"\u003e\u003cimg src=\"https://jmspae.se/processed_images/fig-3.605c84ffddad8323.jpg\"/\u003e\u003c/a\u003e\n\n\u003cem\u003eFigure 3. Original admin boundaries\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eParis\u0026#39; administrative boundary contains a couple of large green spaces. To the west, a park and to the east, some sort of sports institute.\u003c/p\u003e\n\u003cp\u003eAfter perusing these rather large spaces in Google maps, they seemed to contain a distinct lack of kebab-serving establishments. Thus, they were a burden on our API budget and needed to go.\u003c/p\u003e\n\u003cp\u003e\n\u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/fig-4.webp\" target=\"_blank\"\u003e\u003cimg src=\"https://jmspae.se/processed_images/fig-4.b360881962350eea.jpg\"/\u003e\u003c/a\u003e\n\n\u003cem\u003eFigure 4. Adjusted admin boundaries w/ network\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eI figured keeping the network and stations wouldn\u0026#39;t do any harm, so they went unmodified.\u003c/p\u003e\n\u003cp\u003e\n\u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/fig-5.webp\" target=\"_blank\"\u003e\u003cimg src=\"https://jmspae.se/processed_images/fig-5.eedb86cb4c85e12c.jpg\"/\u003e\u003c/a\u003e\n\n\u003cem\u003eFigure 5. Sampling points, later projected to WGS84 for harvesting purposes\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eTo maximise data-harvesting, I decided to go with a hex layout with a vertical spacing of 1 km. This should give us a search radius of 500m * âˆš3 ~= 866 meters. Plenty of overlap, sure, but we shouldn\u0026#39;t be getting any holes anywhere. I\u0026#39;m not sure why I was spending this much time ensuring \u0026#34;data integrity\u0026#34; when that might just have flown the window courtesy of Google, but it\u0026#39;s the illusion of control that counts.\u003c/p\u003e\n\u003cp\u003eThis give us 99 sample points which... Should be enough?\u003c/p\u003e\n\u003cp\u003eRegardless, here\u0026#39;s how my 3AM python turned out:\u003c/p\u003e\n\u003cpre data-lang=\"py\"\u003e\u003ccode data-lang=\"py\"\u003e\u003cspan\u003e# Already projected to WGS84\n\u003c/span\u003e\u003cspan\u003esample_points: GeoDataFrame \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eGeoDataFrame.\u003c/span\u003e\u003cspan\u003efrom_file\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;samples.gpkg\u0026#34;\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003egmaps: googlemaps.Client \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003egooglemaps.\u003c/span\u003e\u003cspan\u003eClient\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#39;get-your-own\u0026#39;\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003eoutput \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e{}\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003epoint \u003c/span\u003e\u003cspan\u003ein \u003c/span\u003e\u003cspan\u003esample_points.geometry:\n\u003c/span\u003e\u003cspan\u003e    lat, lon \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003epoint.y, point.x\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    next_page_token \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eNone\n\u003c/span\u003e\u003cspan\u003e    num_fetches \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e3\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ewhile \u003c/span\u003e\u003cspan\u003enum_fetches \u003c/span\u003e\u003cspan\u003e\u0026gt; \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e:\n\u003c/span\u003e\u003cspan\u003e        result \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e{}\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003eif \u003c/span\u003e\u003cspan\u003enext_page_token \u003c/span\u003e\u003cspan\u003e== \u003c/span\u003e\u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\n\u003c/span\u003e\u003cspan\u003e            result \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003egmaps.\u003c/span\u003e\u003cspan\u003eplaces\u003c/span\u003e\u003cspan\u003e(\n\u003c/span\u003e\u003cspan\u003e                \u003c/span\u003e\u003cspan\u003e\u0026#34;kebab\u0026#34;\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e                \u003c/span\u003e\u003cspan\u003elocation\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e(lat, lon),\n\u003c/span\u003e\u003cspan\u003e                \u003c/span\u003e\u003cspan\u003eradius\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e866\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e            )\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e:\n\u003c/span\u003e\u003cspan\u003e            result \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003egmaps.\u003c/span\u003e\u003cspan\u003eplaces\u003c/span\u003e\u003cspan\u003e(\n\u003c/span\u003e\u003cspan\u003e                \u003c/span\u003e\u003cspan\u003epage_token\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003enext_page_token\n\u003c/span\u003e\u003cspan\u003e            )\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        next_page_token \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eresult.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;next_page_token\u0026#34;\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(result[\u003c/span\u003e\u003cspan\u003e\u0026#34;status\u0026#34;\u003c/span\u003e\u003cspan\u003e], next_page_token)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003ep \u003c/span\u003e\u003cspan\u003ein \u003c/span\u003e\u003cspan\u003eresult[\u003c/span\u003e\u003cspan\u003e\u0026#34;results\u0026#34;\u003c/span\u003e\u003cspan\u003e]:\n\u003c/span\u003e\u003cspan\u003e            output[p[\u003c/span\u003e\u003cspan\u003e\u0026#34;place_id\u0026#34;\u003c/span\u003e\u003cspan\u003e]] \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003ep\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003eif \u003c/span\u003e\u003cspan\u003enext_page_token \u003c/span\u003e\u003cspan\u003e== \u003c/span\u003e\u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\n\u003c/span\u003e\u003cspan\u003e            \u003c/span\u003e\u003cspan\u003ebreak\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        num_fetches \u003c/span\u003e\u003cspan\u003e-= \u003c/span\u003e\u003cspan\u003e1\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003esleep\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003ejson_out \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003ejson.\u003c/span\u003e\u003cspan\u003edumps\u003c/span\u003e\u003cspan\u003e(output)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003ewith \u003c/span\u003e\u003cspan\u003eopen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;output.json\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e\u0026#34;w\u0026#34;\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003eas \u003c/span\u003e\u003cspan\u003efile:\n\u003c/span\u003e\u003cspan\u003e    file.\u003c/span\u003e\u003cspan\u003ewrite\u003c/span\u003e\u003cspan\u003e(json_out)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis worked quite well. Initially I skipped paging, resulting in 322 results. However, I noticed that a few establishments were missing in the results compared to my explorations in Google Maps.\u003c/p\u003e\n\u003cp\u003eAfter implementing paging and re-running, this gave us a grand total of 400 kebab-serving establishments. I was likely over-zealous with the paging considering how few additional results were retrieved. That, and that the API doesn\u0026#39;t cap the search radius (again, it\u0026#39;s only a bias) likely led to a fair few redundant API calls.\u003c/p\u003e\n\u003cp\u003eThe raw Google Places API-output also needed to be clipped to the study area, projected to the local UTM zone as well as converted to a geospatial format;\u003c/p\u003e\n\u003cpre data-lang=\"py\"\u003e\u003ccode data-lang=\"py\"\u003e\u003cspan\u003eimport \u003c/span\u003e\u003cspan\u003epandas \u003c/span\u003e\u003cspan\u003eas \u003c/span\u003e\u003cspan\u003epd\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003ewith \u003c/span\u003e\u003cspan\u003eopen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;output.json\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003eas \u003c/span\u003e\u003cspan\u003efile:\n\u003c/span\u003e\u003cspan\u003e    data \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003ejson.\u003c/span\u003e\u003cspan\u003eload\u003c/span\u003e\u003cspan\u003e(file)\n\u003c/span\u003e\u003cspan\u003e    file.\u003c/span\u003e\u003cspan\u003eclose\u003c/span\u003e\u003cspan\u003e()\n\u003c/span\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003eid \u003c/span\u003e\u003cspan\u003ein \u003c/span\u003e\u003cspan\u003edata:\n\u003c/span\u003e\u003cspan\u003e        place \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003edata[\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003cspan\u003e        point \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eplace[\u003c/span\u003e\u003cspan\u003e\u0026#34;geometry\u0026#34;\u003c/span\u003e\u003cspan\u003e][\u003c/span\u003e\u003cspan\u003e\u0026#34;location\u0026#34;\u003c/span\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003cspan\u003e        data[\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e][\u003c/span\u003e\u003cspan\u003e\u0026#34;lng\u0026#34;\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003epoint[\u003c/span\u003e\u003cspan\u003e\u0026#34;lng\u0026#34;\u003c/span\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003cspan\u003e        data[\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e][\u003c/span\u003e\u003cspan\u003e\u0026#34;lat\u0026#34;\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003epoint[\u003c/span\u003e\u003cspan\u003e\u0026#34;lat\u0026#34;\u003c/span\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003edel \u003c/span\u003e\u003cspan\u003edata[\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e][\u003c/span\u003e\u003cspan\u003e\u0026#34;geometry\u0026#34;\u003c/span\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    data \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003epd.DataFrame.\u003c/span\u003e\u003cspan\u003efrom_dict\u003c/span\u003e\u003cspan\u003e(data).T\n\u003c/span\u003e\u003cspan\u003e    data.rating \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003epd.\u003c/span\u003e\u003cspan\u003eto_numeric\u003c/span\u003e\u003cspan\u003e(data.rating)\n\u003c/span\u003e\u003cspan\u003e    data.user_ratings_total \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003epd.\u003c/span\u003e\u003cspan\u003eto_numeric\u003c/span\u003e\u003cspan\u003e(data.user_ratings_total)\n\u003c/span\u003e\u003cspan\u003e    data \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003edata[data[\u003c/span\u003e\u003cspan\u003e\u0026#34;user_ratings_total\u0026#34;\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e\u0026gt; \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# Cleanup was added after the screenshot below was taken\n\u003c/span\u003e\u003cspan\u003e    data \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003edata.\u003c/span\u003e\u003cspan\u003edrop\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecolumns\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e[\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;icon\u0026#34;\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;icon_background_color\u0026#34;\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;icon_mask_base_uri\u0026#34;\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;plus_code\u0026#34;\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;reference\u0026#34;\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;photos\u0026#34;\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;opening_hours\u0026#34;\n\u003c/span\u003e\u003cspan\u003e    ])\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    gdata \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eGeoDataFrame\u003c/span\u003e\u003cspan\u003e(\n\u003c/span\u003e\u003cspan\u003e        data, \u003c/span\u003e\u003cspan\u003egeometry\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003egeopandas.\u003c/span\u003e\u003cspan\u003epoints_from_xy\u003c/span\u003e\u003cspan\u003e(data.lng, data.lat),\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003ecrs\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e4326\n\u003c/span\u003e\u003cspan\u003e    )\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    gdata: GeoDataFrame \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003egdata.\u003c/span\u003e\u003cspan\u003eto_crs\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ePROJECTION\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# Modified boundaries from Figure 4.\n\u003c/span\u003e\u003cspan\u003e    paris \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eGeoDataFrame.\u003c/span\u003e\u003cspan\u003efrom_file\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;mod_bounary.gpkg\u0026#34;\u003c/span\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    gdata: GeoDataFrame \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003egdata.\u003c/span\u003e\u003cspan\u003eclip\u003c/span\u003e\u003cspan\u003e(paris)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    gdata.\u003c/span\u003e\u003cspan\u003eto_file\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;establishments.gpkg\u0026#34;\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n\u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/fig-6.webp\" target=\"_blank\"\u003e\u003cimg src=\"https://jmspae.se/processed_images/fig-6.1eab106a30493ee2.jpg\"/\u003e\u003c/a\u003e\n\n\u003cem\u003eFigure 6. We\u0026#39;re in f###ing business\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"routing-and-distance\"\u003eRouting and Distance\u003ca href=\"#routing-and-distance\" aria-label=\"Anchor link for: routing-and-distance\"\u003eðŸ”—\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFinally, the fun part. I need to get the distance to the nearest station entrance for each establishment.\u003c/p\u003e\n\u003cp\u003eI could\u0026#39;ve absolutely just routed to every single entrance for every single restaurant to get the nearest... But that would\u0026#39;ve taken several decades. I needed to build some sort of spatial index and route to the nearest ~3 or something along those lines. Since Paris is so dense with plenty of routing options, I figured I wouldn\u0026#39;t need to perform too many routing operations.\u003c/p\u003e\n\u003cp\u003eAfter some googling and dredging through API docs, however, it seemed GeoPandas was nice enough to do that for us with \u003ccode\u003esindex\u003c/code\u003e. Although it didn\u0026#39;t have the same \u0026#34;return nearest N\u0026#34; like my beloved r-tree rust library I was all too used to, it did allow me to search within a certain radius (1 km was large enough) and go from there. The query results weren\u0026#39;t sorted, so I had to sort the indexes by distance and cut it down to size.\u003c/p\u003e\n\u003cp\u003eThe network analysis was relatively straight-forward thanks to NetworkX, and after a couple of hours I managed to cobble together the following;\u003c/p\u003e\n\u003cpre data-lang=\"py\"\u003e\u003ccode data-lang=\"py\"\u003e\u003cspan\u003eimport \u003c/span\u003e\u003cspan\u003enetworkx \u003c/span\u003e\u003cspan\u003eas \u003c/span\u003e\u003cspan\u003enx\n\u003c/span\u003e\u003cspan\u003eimport \u003c/span\u003e\u003cspan\u003eshapely \u003c/span\u003e\u003cspan\u003eas \u003c/span\u003e\u003cspan\u003eshp\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003eestablishments: GeoDataFrame \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eGeoDataFrame.\u003c/span\u003e\u003cspan\u003efrom_file\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;establishments.gpkg\u0026#34;\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003eentrances: GeoDataFrame \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eGeoDataFrame.\u003c/span\u003e\u003cspan\u003efrom_file\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;entrances.gpkg\u0026#34;\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003egraph \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eox.\u003c/span\u003e\u003cspan\u003eload_graphml\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;network.graphml\u0026#34;\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003egraph \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eox.\u003c/span\u003e\u003cspan\u003eproject_graph\u003c/span\u003e\u003cspan\u003e(graph, \u003c/span\u003e\u003cspan\u003eto_crs \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003ePROJECTION\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e# Ensure the same CRS\n\u003c/span\u003e\u003cspan\u003eif \u003c/span\u003e\u003cspan\u003e(establishments.crs \u003c/span\u003e\u003cspan\u003e!= \u003c/span\u003e\u003cspan\u003eentrances.crs \u003c/span\u003e\u003cspan\u003e!= \u003c/span\u003e\u003cspan\u003ePROJECTION\u003c/span\u003e\u003cspan\u003e):\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eexit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e100\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e# Helper function to get the distance between a graph node and establishment geometry\n\u003c/span\u003e\u003cspan\u003edef \u003c/span\u003e\u003cspan\u003enode_geom_dist\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enode_id\u003c/span\u003e\u003cspan\u003e: int, \u003c/span\u003e\u003cspan\u003egeom\u003c/span\u003e\u003cspan\u003e: shp.Point):\n\u003c/span\u003e\u003cspan\u003e    node \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003egraph.nodes[node_id]\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn \u003c/span\u003e\u003cspan\u003emath.\u003c/span\u003e\u003cspan\u003esqrt\u003c/span\u003e\u003cspan\u003e((geom.x \u003c/span\u003e\u003cspan\u003e- \u003c/span\u003e\u003cspan\u003enode[\u003c/span\u003e\u003cspan\u003e\u0026#39;x\u0026#39;\u003c/span\u003e\u003cspan\u003e]) \u003c/span\u003e\u003cspan\u003e** \u003c/span\u003e\u003cspan\u003e2 \u003c/span\u003e\u003cspan\u003e+ \u003c/span\u003e\u003cspan\u003e(geom.y \u003c/span\u003e\u003cspan\u003e- \u003c/span\u003e\u003cspan\u003enode[\u003c/span\u003e\u003cspan\u003e\u0026#39;y\u0026#39;\u003c/span\u003e\u003cspan\u003e]) \u003c/span\u003e\u003cspan\u003e** \u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003edistances: list[float] \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e[]\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e, establishment) \u003c/span\u003e\u003cspan\u003ein \u003c/span\u003e\u003cspan\u003eestablishments.\u003c/span\u003e\u003cspan\u003eiterrows\u003c/span\u003e\u003cspan\u003e():\n\u003c/span\u003e\u003cspan\u003e    establishment_geom: shp.Point \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eestablishment.geometry\n\u003c/span\u003e\u003cspan\u003e    establishment_node: int \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eox.\u003c/span\u003e\u003cspan\u003enearest_nodes\u003c/span\u003e\u003cspan\u003e(graph, establishment_geom.x, establishment_geom.y)\n\u003c/span\u003e\u003cspan\u003e    establishment_dist_to_node: float \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003enode_geom_dist\u003c/span\u003e\u003cspan\u003e(establishment_node, establishment_geom)\n\u003c/span\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# Spatial index for rail entrances\n\u003c/span\u003e\u003cspan\u003e    index: shp.STRtree \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eentrances.sindex\n\u003c/span\u003e\u003cspan\u003e    nearest_q \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eindex.\u003c/span\u003e\u003cspan\u003equery\u003c/span\u003e\u003cspan\u003e(establishment_geom, \u003c/span\u003e\u003cspan\u003epredicate\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;dwithin\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003edistance \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e1000\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e    nearest_entrances: list[tuple[int, float]] \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e[]\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003ei \u003c/span\u003e\u003cspan\u003ein \u003c/span\u003e\u003cspan\u003enearest_q:\n\u003c/span\u003e\u003cspan\u003e        ent \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eentrances.iloc[i]\n\u003c/span\u003e\u003cspan\u003e        ent_geom: shp.Point \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eent.geometry\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        dist \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eent_geom.\u003c/span\u003e\u003cspan\u003edistance\u003c/span\u003e\u003cspan\u003e(establishment.geometry)\n\u003c/span\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003cspan\u003e        nearest_entrances.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e((i, dist))\n\u003c/span\u003e\u003cspan\u003e     \n\u003c/span\u003e\u003cspan\u003e    nearest_entrances \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003esorted\u003c/span\u003e\u003cspan\u003e(nearest_entrances, \u003c/span\u003e\u003cspan\u003ekey \u003c/span\u003e\u003cspan\u003e= lambda \u003c/span\u003e\u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e: e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e])[:\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003cspan\u003e    entrance_geom: list[shp.Point] \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e[entrances.iloc[i].geometry \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003e(i, \u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003ein \u003c/span\u003e\u003cspan\u003enearest_entrances]\n\u003c/span\u003e\u003cspan\u003e    entrance_nodes: list[int] \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e[ox.\u003c/span\u003e\u003cspan\u003enearest_nodes\u003c/span\u003e\u003cspan\u003e(graph, point.x, point.y) \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003epoint \u003c/span\u003e\u003cspan\u003ein \u003c/span\u003e\u003cspan\u003eentrance_geom]\n\u003c/span\u003e\u003cspan\u003e    entrance_geom_dist_to_node: list[float] \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003enode_geom_dist\u003c/span\u003e\u003cspan\u003e(entrance_nodes[i], entrance_geom[i]) \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003ei \u003c/span\u003e\u003cspan\u003ein \u003c/span\u003e\u003cspan\u003erange\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elen\u003c/span\u003e\u003cspan\u003e(nearest_entrances))]\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    result_paths \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e[nx.\u003c/span\u003e\u003cspan\u003eshortest_path\u003c/span\u003e\u003cspan\u003e(graph, establishment_node, dest_node, \u003c/span\u003e\u003cspan\u003eweight\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;length\u0026#34;\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003edest_node \u003c/span\u003e\u003cspan\u003ein \u003c/span\u003e\u003cspan\u003eentrance_nodes]\n\u003c/span\u003e\u003cspan\u003e    result_lengths: list[float] \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e[nx.\u003c/span\u003e\u003cspan\u003epath_weight\u003c/span\u003e\u003cspan\u003e(graph, path, \u003c/span\u003e\u003cspan\u003e\u0026#34;length\u0026#34;\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e+ \u003c/span\u003e\u003cspan\u003eentrance_geom_dist_to_node[i] \u003c/span\u003e\u003cspan\u003e+ \u003c/span\u003e\u003cspan\u003eestablishment_dist_to_node \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003e(i, path) \u003c/span\u003e\u003cspan\u003ein \u003c/span\u003e\u003cspan\u003eenumerate\u003c/span\u003e\u003cspan\u003e(result_paths)]\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    distances.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emin\u003c/span\u003e\u003cspan\u003e(result_lengths))\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003eestablishments[\u003c/span\u003e\u003cspan\u003e\u0026#34;distance\u0026#34;\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003edistances \n\u003c/span\u003e\u003cspan\u003eestablishments.\u003c/span\u003e\u003cspan\u003eto_file\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;establishment_results.gpkg\u0026#34;\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNot exactly my finest work. The sheer amount of list comprehension is perhaps a little terrifying, but it works.\u003c/p\u003e\n\u003cp\u003eAfter some prodding around in QGIS with the resulting data and networks (and many print() statements), I was confident in the accuracy of the results.\u003c/p\u003e\n\u003ch2 id=\"results\"\u003eResults\u003ca href=\"#results\" aria-label=\"Anchor link for: results\"\u003eðŸ”—\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eNow with all of this data, it is time to settle the question of whether or not the kebabs are less tasty the closer they are to a train/metro station...\u003c/p\u003e\n\u003cp\u003e\n\u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/fig-7.webp\" target=\"_blank\"\u003e\u003cimg src=\"https://jmspae.se/processed_images/fig-7.1ff7f2b316a90f62.jpg\"/\u003e\u003c/a\u003e\n\n\u003cem\u003eFigure 7. Hmmmmm....\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eWith a mighty Pearson\u0026#39;s correlation of 0.091, the data indicates that this could be true! If you ignore the fact that the correlation is so weak that calling it \u0026#39;statistically insignificant\u0026#39; would be quite generous.\u003c/p\u003e\n\u003cp\u003eOutliers can have an outsized impact on a Pearson\u0026#39;s correlation, so after ridding the dataset of some outliers via IQR fencing...\u003c/p\u003e\n\u003cp\u003e\n\u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/fig-8.webp\" target=\"_blank\"\u003e\u003cimg src=\"https://jmspae.se/processed_images/fig-8.af2b5c5cacb7b32d.jpg\"/\u003e\u003c/a\u003e\n\n\u003cem\u003eFigure 8. Removed outliers\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e... This increased the coefficient to a whopping 0.098.\u003c/p\u003e\n\u003cp\u003eThis was a bit of a bummer (though hardly surprising) and figuring I had nothing to lose from messing around a little, I tried filtering out metro stations in case my original assumption of the metro being included in the original hypothesis was incorrect.\u003c/p\u003e\n\u003cp\u003e\n\u003ca href=\"https://jmspae.se/write-ups/kebabs-train-stations/fig-9.webp\" target=\"_blank\"\u003e\u003cimg src=\"https://jmspae.se/processed_images/fig-9.3427bdea5242e0b1.jpg\"/\u003e\u003c/a\u003e\n\n*Figure 9. Not much better, eh? Correction: \u0026#34;... Nearest train station entrance.\u0026#34;\u003c/p\u003e\n\u003cp\u003eWith an even worse coefficient of 0.001, I think It\u0026#39;s time to hang up the towel.\u003c/p\u003e\n\u003cp\u003eWhilst there are some minor indications that the hypothesis \u003cem\u003ecould\u003c/em\u003e be correct (eg. Many of the absolute worst restaurants being some of the closest) the correlation is simply too weak.\u003c/p\u003e\n\u003ch2 id=\"discussion\"\u003eDiscussion\u003ca href=\"#discussion\" aria-label=\"Anchor link for: discussion\"\u003eðŸ”—\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e- Are Google reviews an objective measurement of how tasty the kebabs are?\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eAbsolutely the f### not. This was a rather subjective observation from the very beginning and Google reviews aren\u0026#39;t exactly a good measure of \u0026#34;is the food good?\u0026#34; There are many aspects of the dining experience that could hypothetically impact a review score. The staff, cleanliness, the surrounding environment, etc. Not to mention online skulduggery and review manipulation.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e- Can tourism have an impact?\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eIt absolutely could. I don\u0026#39;t want to make any definitive assumptions, but I can absolutely imagine the local regulars being harsher than the massive tourist population, or even vice-versa.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e- Were the Google results accurate?\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eTo an extent, yes. From what I could gather, every location from the query seemed to serve kebab in some form. There were a few weird outliers and nuances, such as Pizza Hut which likely only serves kebab pizza rather than the multitude of different forms in which kebab could possibly be consumed.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e- Why not restaurants in general?\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eBecause the initial hypothesis was too comically hyper-specific for me to give up on.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e- What about review count?\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThis could very well have an effect, though I was not entirely certain how to properly implement this metric into the analysis at the time.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e- Gib Data\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eI\u0026#39;m not quite comfortable in doing so, mostly due to potential breaches of Google\u0026#39;s TOS. I don\u0026#39;t think they would care about me harvesting some 400 POIs for this little experiment, I\u0026#39;m not quite willing to gamble sharing the data with others.\u003c/p\u003e\n\u003cp\u003eBesides, I gave you the code. Go burn some of your own credits.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e- Are you Ok?\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e... I guess? Are you?\u003c/p\u003e\n\u003cp\u003eIn conclusion, this was actually quite fun. I wrote this as the project went on (otherwise I would likely never have found the motivation) and I would encourage others to do other silly explorations like this, even if the results end up slightly depressing.\u003c/p\u003e\n\u003cp\u003e... \u003cem\u003eHowever\u003c/em\u003e, after some additional discussion, I decided I wasn\u0026#39;t quite done.\u003c/p\u003e\n\u003cp\u003eAs stated earlier, there were a few detracting comments on the original French post. Interestingly, many of the provided examples of good kebab restaurants next to train stations just so happened to be in Paris.\u003c/p\u003e\n\u003cp\u003eThe user who originally posted the French post for the sub in English provided some \u003ca href=\"https://imgur.com/gallery/kebab-railway-stations-wuYG9D2\"\u003eexamples\u003c/a\u003e which seem to strengthen the hypothesis. It could very well be that whatever conditions affect Paris restaurants (whether it be higher rent, wages, tourism, population density...) had a larger impact than I initially suspected.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eStay tuned for part 2... Whenever I get around to doing it!\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\n\n\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": null,
  "modifiedTime": null
}
