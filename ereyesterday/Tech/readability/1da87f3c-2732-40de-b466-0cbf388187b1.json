{
  "id": "1da87f3c-2732-40de-b466-0cbf388187b1",
  "title": "Litdb – type safe SQL for JavaScript/TS",
  "link": "https://litdb.dev/",
  "description": "Comments",
  "author": "",
  "published": "Fri, 06 Dec 2024 00:10:21 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 4248,
  "excerpt": "To use litdb with your favorite ORM, no driver is required. Just use the litdb package directly:",
  "siteName": "",
  "favicon": "https://litdb.dev/img/favicon.png",
  "text": "To use litdb with your favorite ORM, no driver is required. Just use the litdb package directly: litdb is also available as a module, where it can be used directly in the browser: \u003cscript type=\"module\"\u003e import { sqlite as $ } from \"https://unpkg.com/litdb/dist/index.min.js\" const { sql, params } = $.from(Contact).select(c =\u003e $`${c.name}`).build() \u003c/script\u003e To get the most out of litdb we recommend using text editors that supports TypeScript definitions (e.g. VS Code, JetBrains IDEs, neovim, etc.) LitDB Drivers​ Lightweight drivers with native support for its typed SQL Builders and parameterized SQL Expressions are also available for the popular databases: Bun SQLite​ Use with Bun's native SQLite3 driver (requires Bun): bun install @litdb/bun-sqlite See litdb Bun SQLite Docs Node better-sqlite​ Use with better-sqlite3 (requires Node.js): npm install @litdb/better-sqlite See litdb better-sqlite3 Docs PostgreSQL​ Use with the postgres.js client: npm install @litdb/postgres See litdb postgres Docs MySQL​ Use with the mysql2 client: npm install @litdb/mysql2 See litdb mysql2 Docs Request a Driver​ If you'd like to see a driver for a specific client, please open or vote for a feature request on litdb's GitHub Discussions. Driver Usage​ The litdb Drivers provide a unified interface for executing custom parameterized SQL, SQL Builders and SQL Fragments for their respective RDBMS. They're lightweight data adapters providing convenience APIs for executing SQL with named and positional parameters. They can be used without litdb SQL Builders, but offer the most value when used together. The same APIs are available across all drivers, so you can easily switch between them. They include both sync APIs recommended for SQLite libraries that use SQLite's native blocking APIs, whilst async APIs should be used for all other remote databases, e.g. PostgreSQL and MySQL. Example of using the Bun SQLite driver: db.ts import { connect } from \"@litdb/bun-sqlite\" export const connection = connect(\"app.db\") // WAL enabled by default export const { $, sync:db, async, native } = connection app.ts import { $, db } from \"./db\" import { Contact } from \"./models\" db.dropTable(Contact) db.createTable(Contact) db.insertAll([ new Contact({ name:\"John Doe\", email:\"[email protected]\" }), new Contact({ name:\"Jane Doe\", email:\"[email protected]\" }), ]) const janeEmail = '[email protected]' const jane = db.one\u003cContact\u003e($.from(Contact).where(c =\u003e $`${c.email} = ${janeEmail}`))! // Insert examples const { lastInsertRowid: bobId } = db.insert(new Contact({ name:\"Bob\", email:\"[email protected]\" })) const { lastInsertRowid } = db.exec`INSERT INTO Contact(name,email) VALUES ('Jo','[email protected]')` const name = 'Alice', email = '[email protected]' db.exec`INSERT INTO Contact(name,email) VALUES (${name}, ${email})` // Typed SQL fragment with named param example const hasId = \u003cTable extends { id:number }\u003e(id:number|bigint) =\u003e (x:Table) =\u003e $.sql($`${x.id} = $id`, { id }) const contacts = db.all($.from(Contact).into(Contact)) // =\u003e Contact[] const bob = db.one($.from(Contact).where(hasId(bobId)).into(Contact)) // =\u003e Contact const contactsCount = db.value($.from(Contact).select`COUNT(*)`) // =\u003e number const emails = db.column($.from(Contact).select(c =\u003e $`${c.email}`)) // =\u003e string[] const contactsArray = db.arrays($.from(Contact)) // =\u003e any[][] const bobArray = db.array($.from(Contact).where(hasId(bobId))) // =\u003e any[] // Update examples jane.email = '[email protected]' db.update(jane) // Update all properties db.update(jane, { onlyProps:['email'] }) // Update only email db.exec($.update(Contact).set({ email:jane.email }).where(hasId(jane.id))) // query builder // Delete examples db.delete(jane) db.exec($.deleteFrom(Contact).where(hasId(jane.id))) // query builder Same source is compatible with other sync drivers, e.g. can replace @litdb/bun-sqlite with @litdb/better-sqlite to use with better-sqlite. See also async usage docs for postgres and mysql2.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n                    \n\u003cp\u003eTo use litdb with your favorite ORM, no driver is required. Just use the \u003ccode\u003elitdb\u003c/code\u003e package directly:\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003elitdb\u003c/code\u003e is also available as a module, where it can be used directly in the browser:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt;\nimport { sqlite as $ } from \u0026#34;https://unpkg.com/litdb/dist/index.min.js\u0026#34;\nconst { sql, params } = $.from(Contact).select(c =\u0026gt; $`${c.name}`).build()\n\u0026lt;/script\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo get the most out of \u003ccode\u003elitdb\u003c/code\u003e we recommend using text editors that supports TypeScript definitions\n(e.g. VS Code, JetBrains IDEs, neovim, etc.)\u003c/p\u003e\n\u003ch2 id=\"litdb-drivers\"\u003eLitDB Drivers​\u003c/h2\u003e\n\u003cp\u003eLightweight drivers with native support for its typed SQL Builders and parameterized SQL Expressions\nare also available for the popular databases:\u003c/p\u003e\n\u003ch3 id=\"bun-sqlite\"\u003eBun SQLite​\u003c/h3\u003e\n\u003cp\u003eUse with \u003ca href=\"https://bun.sh/docs/api/sqlite\"\u003eBun\u0026#39;s native SQLite3 driver\u003c/a\u003e (requires Bun):\u003c/p\u003e\n\u003cdiv onclick=\"copy(this)\"\u003e\n                    \u003cp\u003ebun install @litdb/bun-sqlite\u003c/p\u003e\n                    \u003c/div\u003e\n\u003cp\u003eSee \u003ca href=\"https://litdb.dev/bun-sqlite\"\u003elitdb Bun SQLite Docs\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"node-better-sqlite\"\u003eNode better-sqlite​\u003c/h3\u003e\n\u003cp\u003eUse with \u003ca href=\"https://github.com/WiseLibs/better-sqlite3\"\u003ebetter-sqlite3\u003c/a\u003e (requires Node.js):\u003c/p\u003e\n\u003cdiv onclick=\"copy(this)\"\u003e\n                    \u003cp\u003enpm install @litdb/better-sqlite\u003c/p\u003e\n                    \u003c/div\u003e\n\u003cp\u003eSee \u003ca href=\"https://litdb.dev/better-sqlite\"\u003elitdb better-sqlite3 Docs\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"postgresql\"\u003ePostgreSQL​\u003c/h3\u003e\n\u003cp\u003eUse with the \u003ca href=\"https://github.com/porsager/postgres\"\u003epostgres.js\u003c/a\u003e client:\u003c/p\u003e\n\u003cdiv onclick=\"copy(this)\"\u003e\n                    \u003cp\u003enpm install @litdb/postgres\u003c/p\u003e\n                    \u003c/div\u003e\n\u003cp\u003eSee \u003ca href=\"https://litdb.dev/postgres\"\u003elitdb postgres Docs\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"mysql\"\u003eMySQL​\u003c/h3\u003e\n\u003cp\u003eUse with the \u003ca href=\"https://github.com/sidorares/node-mysql2\"\u003emysql2\u003c/a\u003e client:\u003c/p\u003e\n\u003cdiv onclick=\"copy(this)\"\u003e\n                    \u003cp\u003enpm install @litdb/mysql2\u003c/p\u003e\n                    \u003c/div\u003e\n\u003cp\u003eSee \u003ca href=\"https://litdb.dev/mysql2\"\u003elitdb mysql2 Docs\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"request-a-driver\"\u003eRequest a Driver​\u003c/h3\u003e\n\u003cp\u003eIf you\u0026#39;d like to see a driver for a specific client, please open or vote for a feature request on litdb\u0026#39;s\n\u003ca href=\"https://github.com/litdb/litdb/discussions/categories/ideas\"\u003eGitHub Discussions\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"driver-usage\"\u003eDriver Usage​\u003c/h2\u003e\n\u003cp\u003eThe litdb Drivers provide a unified interface for executing custom parameterized SQL, SQL Builders and SQL Fragments\nfor their respective RDBMS. They\u0026#39;re lightweight data adapters providing convenience APIs for executing SQL with named\nand positional parameters. They can be used without litdb SQL Builders, but offer the most value when used together.\u003c/p\u003e\n\u003cp\u003eThe same APIs are available across all drivers, so you can easily switch between them. They include both \u003cstrong\u003esync\u003c/strong\u003e APIs\nrecommended for SQLite libraries that use SQLite\u0026#39;s native blocking APIs, whilst \u003cstrong\u003easync\u003c/strong\u003e APIs should be used for\nall other remote databases, e.g. PostgreSQL and MySQL.\u003c/p\u003e\n\u003cp\u003eExample of using the \u003ca href=\"https://bun.sh/docs/api/sqlite\"\u003eBun SQLite\u003c/a\u003e driver:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003edb.ts\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport { connect } from \u0026#34;@litdb/bun-sqlite\u0026#34;\n\nexport const connection = connect(\u0026#34;app.db\u0026#34;) // WAL enabled by default\nexport const { $, sync:db, async, native } = connection\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eapp.ts\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport { $, db } from \u0026#34;./db\u0026#34;\nimport { Contact } from \u0026#34;./models\u0026#34;\n\ndb.dropTable(Contact)\ndb.createTable(Contact)\ndb.insertAll([\n    new Contact({ name:\u0026#34;John Doe\u0026#34;, email:\u0026#34;\u003ca href=\"https://litdb.dev/cdn-cgi/l/email-protection\" data-cfemail=\"5c363334321c313d353072332e3b\"\u003e[email protected]\u003c/a\u003e\u0026#34; }),\n    new Contact({ name:\u0026#34;Jane Doe\u0026#34;, email:\u0026#34;\u003ca href=\"https://litdb.dev/cdn-cgi/l/email-protection\" data-cfemail=\"84eee5eae1c4e9e5ede8aaebf6e3\"\u003e[email protected]\u003c/a\u003e\u0026#34; }),\n])\n\nconst janeEmail = \u0026#39;\u003ca href=\"https://litdb.dev/cdn-cgi/l/email-protection\" data-cfemail=\"5d373c33381d303c343173322f3a\"\u003e[email protected]\u003c/a\u003e\u0026#39;\nconst jane = db.one\u0026lt;Contact\u0026gt;($.from(Contact).where(c =\u0026gt; $`${c.email} = ${janeEmail}`))!\n\n// Insert examples\nconst { lastInsertRowid: bobId } = db.insert(new Contact({ name:\u0026#34;Bob\u0026#34;, email:\u0026#34;\u003ca href=\"https://litdb.dev/cdn-cgi/l/email-protection\" data-cfemail=\"1f7d707d5f727e767331706d78\"\u003e[email protected]\u003c/a\u003e\u0026#34; }))\nconst { lastInsertRowid } = db.exec`INSERT INTO Contact(name,email) VALUES (\u0026#39;Jo\u0026#39;,\u0026#39;\u003ca href=\"https://litdb.dev/cdn-cgi/l/email-protection\" data-cfemail=\"ef8580af8b808ac1809d88\"\u003e[email protected]\u003c/a\u003e\u0026#39;)`\nconst name = \u0026#39;Alice\u0026#39;, email = \u0026#39;\u003ca href=\"https://litdb.dev/cdn-cgi/l/email-protection\" data-cfemail=\"61000d080204210c00080d4f0e1306\"\u003e[email protected]\u003c/a\u003e\u0026#39;\ndb.exec`INSERT INTO Contact(name,email) VALUES (${name}, ${email})`\n\n// Typed SQL fragment with named param example\nconst hasId = \u0026lt;Table extends { id:number }\u0026gt;(id:number|bigint) =\u0026gt;\n    (x:Table) =\u0026gt; $.sql($`${x.id} = $id`, { id })\n\nconst contacts = db.all($.from(Contact).into(Contact))                // =\u0026gt; Contact[]\nconst bob = db.one($.from(Contact).where(hasId(bobId)).into(Contact)) // =\u0026gt; Contact    \nconst contactsCount = db.value($.from(Contact).select`COUNT(*)`)      // =\u0026gt; number\nconst emails = db.column($.from(Contact).select(c =\u0026gt; $`${c.email}`))  // =\u0026gt; string[]\nconst contactsArray = db.arrays($.from(Contact))                      // =\u0026gt; any[][]\nconst bobArray = db.array($.from(Contact).where(hasId(bobId)))        // =\u0026gt; any[]\n\n// Update examples\njane.email = \u0026#39;\u003ca href=\"https://litdb.dev/cdn-cgi/l/email-protection\" data-cfemail=\"781219161d381c171d56170a1f\"\u003e[email protected]\u003c/a\u003e\u0026#39;\ndb.update(jane)                           // Update all properties\ndb.update(jane, { onlyProps:[\u0026#39;email\u0026#39;] })  // Update only email\ndb.exec($.update(Contact).set({ email:jane.email }).where(hasId(jane.id))) // query builder\n\n// Delete examples\ndb.delete(jane)\ndb.exec($.deleteFrom(Contact).where(hasId(jane.id))) // query builder\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSame source is compatible with other sync drivers, e.g. can replace \u003ccode\u003e@litdb/bun-sqlite\u003c/code\u003e with \u003ccode\u003e@litdb/better-sqlite\u003c/code\u003e to use\nwith \u003ca href=\"https://litdb.dev/better-sqlite#usage\"\u003ebetter-sqlite\u003c/a\u003e. See also async usage docs for \u003ca href=\"https://litdb.dev/postgres#usage\"\u003epostgres\u003c/a\u003e and \u003ca href=\"https://litdb.dev/mysql2#usage\"\u003emysql2\u003c/a\u003e.\u003c/p\u003e\n\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
