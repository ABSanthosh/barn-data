{
  "id": "a4911825-9d97-4c71-9598-875acd9145e5",
  "title": "Reverse Engineering iOS 18 Inactivity Reboot",
  "link": "https://naehrdine.blogspot.com/2024/11/reverse-engineering-ios-18-inactivity.html",
  "description": "Comments",
  "author": "",
  "published": "Sun, 17 Nov 2024 21:50:26 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "jiska",
  "length": 17045,
  "excerpt": "Reverse Engineering iOS 18 Inactivity Reboot iOS 18 introduced a new inactivity reboot security feature. What does it protect from and how d...",
  "siteName": "Blogger",
  "favicon": "",
  "text": "iOS 18 introduced a new inactivity reboot security feature. What does it protect from and how does it work? This blog post covers all the details down to a kernel extension and the Secure Enclave Processor.Security Before First Unlock / After First UnlockDid you know that entering your passcode for the first time after your phone starts is something very different then entering it later on to unlock your phone?When initially entering your passcode, this unlocks a key store in the Secure Enclave Processor (SEP) that encrypts your data on an iPhone.The state before entering your passcode for the first time is also called Before First Unlock (BFU). Due to the encrypted user data, your iPhone behaves slightly differently to later unlocks. You'll see that Face ID and Touch ID won't work and that the passcode is required. But there's more subtle things you might notice: Since Wi-Fi passwords are encrypted, your iPhone won't connect to Wi-Fi networks. If your SIM is not PIN-protected, your iPhone will still connect to cellular networks. That means, technically, you can still receive phone calls. Yet, if you receive a call, even if that number is in your contacts, the contact name won't be shown, as the contacts haven't been decrypted yet. Similarly, when you receive notifications about new messages, you'll see that you got messages, but you won't see any message previews. You can easily try this yourself!In the After First Unlock (AFU) state, user data is decrypted. You can imagine this like a key safe that is kept open while iOS is running. Even when you see a lock screen, certain keys remain available to the operating system. This way, you stay connected to Wi-Fi networks and receive message notification previews, even when your iPhone is locked.While it's more convenient, the AFU state is more susceptible to attacks. An attacker who can somehow bypass the lock screen can get access to decrypted data on the iPhone. To bypass the lock screen, an attacker does not necessarily need to know the passcode. Security vulnerabilities within iOS can allow attackers to get code execution and extract from an iPhone, even while it appears to be \"locked\".Attackers with physical access to an iPhone have more security vulnerabilities to choose from. The attack surface is larger, as such attackers can exploit vulnerabilities in the USB stack or within wireless protocols, such as Wi-Fi, Bluetooth, or cellular, or even more invasive hardware attacks that involve opening the device. This larger attack surface tends to make exploits for these vulnerabilities cheaper on the gray market, as there's potentially more supply. Another factor that makes attacks cheaper is time â€“ vulnerabilities that are publicly known by the vendor and patched in more recent software versions won't unlock new iPhones, but can unlock iPhones that were kept in AFU state for a long time that didn't get any software updates.Rumors about Rebooting iPhonesIn law enforcement scenarios, a lot of the forensically relevant data is available in the AFU state. Law enforcement takes advantage of this and often keeps seized iPhones powered on, but isolated from the Internet, until they can extract data. This time might be necessary to wait for an exploit to be available or for legal reasons, such as getting a warrant.However, thieves and other criminals are also interested in getting this kind of access after stealing a device. It gives them access to bank accounts and other valuable information, by far exceeding what the iPhone itself would be worth, or which might be used for blackmail. People reuse their passwords often, and getting access to the iCloud account may allow a thief to reset activation lock for the device, increasing the resale value.A recentÂ news article by 404 mediaÂ (while paywalled, the most important information is also contained in the relatedÂ Tweet)Â reported on a law enforcement document about suspicious iPhone reboots. This document makes two interesting claims:iPhones on iOS 18 will reboot, even when completely isolated from wireless networks.iPhones on iOS 18 will tell other iPhones on lower iOS versions to reboot â€“ wirelessly!Especially the second claim would be huge if true. If anyone figured out how this works, they could build a large TV-Be-Gone for iPhones, forcing reboots over the air on hundreds of iPhones simultaneously. Would Apple really build such a feature into an iPhone?Knowing a thing or two about the Apple wireless ecosystem, my interest was piqued, and I had to go down the rabbit hole!Discovery of Inactivity RebootWhen Apple adds new features, they usually don't hide this very well. Apple software contains a lot of debug strings, which hint at new functionality. Blacktop maintains a git repository of strings found in iOS, which keeps a nice version history. I decided to do the most low-effort thing I could think of: just search for \"reboot\".Bingo, that third hit looks good: \"inactivity_reboot\". The fact that it's in keybagd is interesting: this daemon is related to the key store that is unlocked on the first unlock.A second search for only inactivity reboot shows the string starts occurring in iOS 18.1 and iOS 18.2. In iOS 18.2, the string changed from \"inactivity_reboot\" to \"inactivity_reboot_enabled\", hinting towards more potential changes in the latest iOS 18.2 betas.Something that was still unclear to me at that point is: How long does it take for inactivity reboot to be triggered? A newÂ article by 404 mediaÂ claimed that it was 3-4 days. So I updated my SRD to the latest beta and made a time lapse.Turns out, the inactivity reboot triggers exactly after 3 days (72 hours). The iPhone would do so despite being connected to Wi-Fi. This confirms my suspicion that this feature had nothing to do with wireless connectivity.Reverse Engineering Inactivity RebootLet's reverse engineer what's changed! Which security guarantees does it provide?Here is a high-level overview of what I found:The Secure Enclave Processor (SEP) keeps track on when your phone was last unlocked. If that last unlock time exceeds 3 days, the SEP tells the AppleSEPKeyStore kernel module that the time was exceeded.The AppleSEPKeyStore kernel module informs user space to initiate a reboot. SpringBoard will then gracefully terminate all user-space processes. This prevents potential data loss upon reboot.If the AppleSEPKeyStore kernel module finds the iPhone to still be powered on after it should have rebooted, the kernel will panic. This case should never happen, unless someone tries to tamper with inactivity reboot.The AppleSEPKeyStore kernel module writes an NVRAM variable aks-inactivity. After the iPhone rebooted, keybagd reads this variable and, if set, sends an analytics event to Apple including how long the iPhone was not unlocked.The remainder of this post shows how I figured this out and what security implications the underlying design has.Indicators in SysdiagnoseFrom my search in ipsw-diffs, I knew there were some log messages that are printed on reboot. At the same time as I started looking them statically, I knew I had to see them actually logged for myself.After my phone rebooted after three days, I took a sysdiagnose and searched for these messages. When doing this yourself, make sure that you unlocked the device before making the sysdiagnose. Otherwise, events from before the reboot will be missing.In theÂ AppleSEPKeyStoreÂ messages, there are the following entries around the inactivity reboot:default 2024-11-17 01:35:14.341697 +0100 kernel \"AppleSEPKeyStore\":3846:0: notifying user space of inactivity rebootdefault 2024-11-17 01:35:14.341766 +0100 kernel \"AppleSEPKeyStore\":12598:31: operation failed (sel: 35 ret: e00002f0)default 2024-11-17 01:35:14.342053 +0100 kernel \"AppleSEPKeyStore\":12598:31: operation failed (sel: 35 ret: e00002f0)default 2024-11-17 01:35:34.958218[reboot occurs]+0100 kernel \"AppleSEPKeyStore\":331:0: starting (BUILT: Oct 26 2024 08:16:35) (\"normal\" variant ðŸŒ½ , 1827.60.43)default 2024-11-17 01:35:34.958381 +0100 kernel \"AppleSEPKeyStore\":476:0: _sep_enabled = 1For more context, these are the unfiltered log messages before the reboot is initiated:Reverse Engineering the SEPKeyStore Kernel ExtensionThe latest iOS kernel can be downloaded using the following ipsw command:ipsw download appledb --device iPhone17,3 --os iOS --version '18.2 beta 2' --kernelThis will download and decompress the kernel. For further analysis, I loaded the whole kernel cache into Binary Ninja. ipsw also supports splitting the kernel into its modules (called \"extensions\" on iOS). The latest version of Ghidra also has decent support for the iOS kernel. So there's a lot of tools to choose from for this analysis.I also downloaded an older kernel where Apple accidentally included symbols and manually diffed these versions with a focus on the code related to inactivity reboot. The kernel has three strings relating to the feature:\"notifying user space of inactivity reboot\" is the string we already know from the sysdiagnose. It belongs to the function AppleKeyStore::handle_events, which polls for SEP events in the background. The following screenshot shows it in more context after reverse engineering and some renaming of functions.The first string, \"max inactivity window expired, failed to reboot the device\", is the kernel panic in case that the iPhone failed to reboot.For more context, the panic is called by the functionÂ AppleKeyStore::handle_device_state_return. There are multiple paths that invoke this handler through many layers of abstraction, which have to do with the UserClient but also SEP states.With the calltree plugin, we can see all the incoming calls to this function.Now to the last string, \"aks-inactivity\". We can see that this is a property that is set in the IORegistry.Its counterpart is in keybagd in user space. When keybagd is initialized, it checks for this variable, issues an analytics event, and then deletes it. This analytics event probably helps Apple optimize the time window, but we can ignore it for the core functionality.Something that I couldn't find in the kernel, even with the knowledge that it was 72 hours, was this particular time window. I couldn't find any numbers that matched 72 hours. So how does the phone know when to reboot?While there are some references to time-related functionality in the SEPKeyStore kernel extension, none of these compare a value to 72 hours. These references were quite simple to find and did not differ much from the older kernel version without inactivity reboot, so it doesn't seem like the functionality was added here.However, the SEPKeyStore communicates with the SEP co-processor. In the functions I identified, reboots are related to some SEP states. Could it be the SEP itself that checks the time?Reverse Engineering the Secure Enclave ProcessorThe SEP is one of Apple's most protected secrets. In contrast to most other firmware on the iPhone, the firmware for the SEP is encrypted.Luckily for us, @nyan_satan recently leaked SEP firmware encryption keys for iOS 18.1 beta 6, just eta wen Apple introduced inactivity reboot. (Thank you!! ðŸŽ‰ And Apple, if you're reading this, why not ship the SEP unencrypted?) Using ipsw, we can download the SEP firmware as follows:ipsw download appledb --device iPhone16,1 --os iOS --version '18.1 beta 6' --pattern \"sep-firmware.d83.RELEASE.im4p\"With the leaked keys, we can decrypt the firmware:pyimg4 im4p extract --iv 6705fb216080e19667dbcf71f532ae73 --key 4ea9db4c2e63a316a6854c83e2f5c81fd102ad40160b8998b5f9b16838b7116e -i sep-firmware.d83.RELEASE.im4p -o sep-firmware.d83.RELEASE.im4p.eLoading this into Binary Ninja is a bit tricky. We can guess that the architecture is 64-bit ARM little endian. But there's no metadata where the firmware has to be loaded to. Being lazy and not wanting to spend time on writing a firmware loader, I used Binary Ninja's Triage feature to auto-detect the most likely address. Note that the firmware seems to have multiple fragments and there's multiple potential load addresses. I pickedÂ 0x80090000ffc80000, which worked well for me.Â There's only little known about the SEP. The best information I could come up with is a presentation dating back to 2016 â€“ but that's better than nothing! What's good to know is that the SEP firmware is structured into apps, so I'm guessing the other base addresses the triage found may correspond to the other apps' address spaces. The app that communicates with the SEPKeyStore is called sks (see slide 86 of the presentation). Not a lot of information, but enough to start reverse engineering!Looking at strings, it looks like the architecture of apps running inside the SEP hasn't changed much since 2016. The SEPKeyStore-related app is still called sks:The SEP has almost no debug strings, making it tougher to reverse engineer. Here is what the initialization function for the SEPKeyStore looks like after some manual annotations (\"sth\" stands for \"something\" â€“ I didn't go too deep into understanding the specifics here):Within its main function, we can find multiple other functions executed before a service workloop starts. However, there's plenty of code. How do we focus on things that are related to the inactivity reboot?Let's recall that we're looking for something that resembles 72 hours. In the kernel, times are usually measured in seconds or in microseconds. For example 72 hours areÂ 259200 seconds (0x3f480). But looking for this value (or for 259200000000, in microseconds, or any other sensible units) in the binary won't return any matches.Using the compiler explorer, we can see why: Optimizations...Rather than looking the full time in bytes in reverse byte order, we're looking for assembly instructions that load parts of the timespan into a register.Binary Ninja knows how to reverse this optimization, and allows us to search in its intermediate representations, instead of looking for raw bytes. In our case, we know that we're looking for a constant.Â We find only two matches:And here it is â€“ a function that compares various times, including 3 days, which is related to the sks application's main function. The result of this time comparison is used to create a message, which is likely sent to the SEPKeyStore kernel extension. Creating a new enum makes it more readable:enum times : uint32_t{ _3_days = 0x3f480, _2_days = 0x2a301, _1_days = 0x15181, `_2.5h` = 0xe11};This function is used in a context to initialize a struct, which is likely a message being sent from the SEP to the kernel extension.I didn't end up reverse engineering much more of the SEP, but this seems to confirm that it's really the SEP that keeps track of how long the phone hasn't been unlocked. This design makes sense to me, since the SEP is involved in every unlock, and is also hardened against tampering, even if an exploit against the main kernel is used, so it's a good place to anchor a mitigation like this.A Mitigation Only Against Cops?While the media coverage so far framed this mitigation as primarily targeting law enforcement, it also a huge security improvement against theft. Outdated law enforcement equipment often finds its way to eBay and other similar platforms for rather cheap price tags. However, thieves won't have the financial and legal means to obtain up-to-date exploits to unlock iPhones within 3 days of getting them. That's another reason why it's important to keep your device updated!On the other hand, law enforcement can and will have to adjust their process, and act faster than before. The first forensic tooling companies already announced that they're able to coordinate these steps within 24 hours! (Note that this also indicates that they only have exploits for AFU state... ðŸ¤¡)Key TakeawaysThis feature is not at all related to wireless activity. The law enforcement document's conclusion that the reboot is due to phones wirelessly communicating with each other is implausible. The older iPhones before iOS 18 likely rebooted due to another reason, such as a software bug.The time measurement and triggering of the reboot is in the SEP, which communicates with the SEPKeyStore kernel extension to perform the reboot. It is likely that using an external time source provided over the Internet or cellular networks to tamper with timekeeping will not influence the 3-day timer.Security-wise, this is a very powerful mitigation. An attacker must have kernel code execution to prevent an inactivity reboot. This means that a forensic analyst might be able to delay the reboot for the actual data extraction, but the initial exploit must be run within the first three days.Inactivity reboot will change the threat landscape for both thieves and forensic analysts, but asymmetrically so: while law enforcement is under more time pressure, it likely completely locks out criminals from accessing your data to get into your bank accounts and other valuable information stored on your iPhone.Interested in reverse engineering? Follow me on YouTube and BlueSky for updates.",
  "image": "https://blogger.googleusercontent.com/img/a/AVvXsEihQqOut8zLHRxuz_g8ornTF1A-X69IoWpX8lZPnZBisvc1t80zBRGebsCj4x4Vz_6C_i_ImG5AszaaQ-rXnFEJeB1-Dfaj4bSBwajxyKLYoKQNdJ8dZZtaqhexYUc1rZL7w_6yXkMj5APTe30fHOMRlg3da55UCxSZhmTFRLWmBEh_iWVgPSyKuVCEQ_48=w1200-h630-p-k-no-nu",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"post-body-3312850032502776883\"\u003e\n\u003cp\u003eiOS 18 introduced a new inactivity reboot security feature. What does it protect from and how does it work? This blog post covers all the details down to a kernel extension and the Secure Enclave Processor.\u003c/p\u003e\u003ch2\u003eSecurity Before First Unlock / After First Unlock\u003c/h2\u003e\u003cp\u003eDid you know that entering your passcode for the first time after your phone starts is something very different then entering it later on to unlock your phone?\u003c/p\u003e\u003cp\u003eWhen initially entering your passcode, this unlocks a key store in the Secure Enclave Processor (SEP) that encrypts your data on an iPhone.\u003c/p\u003e\u003cp\u003eThe state before entering your passcode for the first time is also called \u003cb\u003eBefore First Unlock\u003c/b\u003e (BFU). Due to the encrypted user data, your iPhone behaves slightly differently to later unlocks. You\u0026#39;ll see that Face ID and Touch ID won\u0026#39;t work and that the passcode is required. But there\u0026#39;s more subtle things you might notice: Since Wi-Fi passwords are encrypted, your iPhone won\u0026#39;t connect to Wi-Fi networks. If your SIM is not PIN-protected, your iPhone will still connect to cellular networks. That means, technically, you can still receive phone calls. Yet, if you receive a call, even if that number is in your contacts, the contact name won\u0026#39;t be shown, as the contacts haven\u0026#39;t been decrypted yet. Similarly, when you receive notifications about new messages, you\u0026#39;ll see that you got messages, but you won\u0026#39;t see any message previews. You can easily try this yourself!\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEihQqOut8zLHRxuz_g8ornTF1A-X69IoWpX8lZPnZBisvc1t80zBRGebsCj4x4Vz_6C_i_ImG5AszaaQ-rXnFEJeB1-Dfaj4bSBwajxyKLYoKQNdJ8dZZtaqhexYUc1rZL7w_6yXkMj5APTe30fHOMRlg3da55UCxSZhmTFRLWmBEh_iWVgPSyKuVCEQ_48\"\u003e\u003cimg alt=\"\" data-original-height=\"3936\" data-original-width=\"7142\" height=\"352\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEihQqOut8zLHRxuz_g8ornTF1A-X69IoWpX8lZPnZBisvc1t80zBRGebsCj4x4Vz_6C_i_ImG5AszaaQ-rXnFEJeB1-Dfaj4bSBwajxyKLYoKQNdJ8dZZtaqhexYUc1rZL7w_6yXkMj5APTe30fHOMRlg3da55UCxSZhmTFRLWmBEh_iWVgPSyKuVCEQ_48=w640-h352\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIn the \u003cb\u003eAfter First Unlock\u003c/b\u003e (AFU) state, user data is decrypted. You can imagine this like a key safe that is kept open while iOS is running. Even when you see a lock screen, certain keys remain available to the operating system. This way, you stay connected to Wi-Fi networks and receive message notification previews, even when your iPhone is locked.\u003c/p\u003e\u003cp\u003eWhile it\u0026#39;s more convenient, the AFU state is more susceptible to attacks. An attacker who can somehow bypass the lock screen can get access to decrypted data on the iPhone. To bypass the lock screen, an attacker does not necessarily need to know the passcode. Security vulnerabilities within iOS can allow attackers to get code execution and extract from an iPhone, even while it appears to be \u0026#34;locked\u0026#34;.\u003c/p\u003e\u003cp\u003eAttackers with physical access to an iPhone have more security vulnerabilities to choose from. The attack surface is larger, as such attackers can exploit vulnerabilities in the USB stack or within wireless protocols, such as Wi-Fi, Bluetooth, or cellular, or even more invasive hardware attacks that involve opening the device. This larger attack surface tends to make exploits for these vulnerabilities cheaper on the gray market, as there\u0026#39;s potentially more supply. Another factor that makes attacks cheaper is time â€“ vulnerabilities that are publicly known by the vendor and patched in more recent software versions won\u0026#39;t unlock new iPhones, but can unlock iPhones that were kept in AFU state for a long time that didn\u0026#39;t get any software updates.\u003c/p\u003e\u003ch2\u003eRumors about Rebooting iPhones\u003c/h2\u003e\u003cp\u003eIn law enforcement scenarios, a lot of the forensically relevant data is available in the AFU state. Law enforcement takes advantage of this and often keeps seized iPhones powered on, but isolated from the Internet, until they can extract data. This time might be necessary to wait for an exploit to be available or for legal reasons, such as getting a warrant.\u003c/p\u003e\u003cp\u003eHowever, thieves and other criminals are also interested in getting this kind of access after stealing a device. It gives them access to bank accounts and other valuable information, by far exceeding what the iPhone itself would be worth, or which might be used for blackmail. People reuse their passwords often, and getting access to the iCloud account may allow a thief to reset activation lock for the device, increasing the resale value.\u003c/p\u003e\u003cp\u003eA recentÂ \u003ca href=\"https://www.404media.co/police-freak-out-at-iphones-mysteriously-rebooting-themselves-locking-cops-out/\"\u003enews article by 404 media\u003c/a\u003eÂ (while paywalled, the most important information is also contained in the relatedÂ \u003ca href=\"https://x.com/josephfcox/status/1854615490087551327\"\u003eTweet\u003c/a\u003e)Â reported on a law enforcement document about suspicious iPhone reboots. This document makes two interesting claims:\u003c/p\u003e\u003col\u003e\u003cli\u003eiPhones on iOS 18 will reboot, even when completely isolated from wireless networks.\u003c/li\u003e\u003cli\u003eiPhones on iOS 18 will tell other iPhones on lower iOS versions to reboot â€“ wirelessly!\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eEspecially the second claim would be huge if true. If anyone figured out how this works, they could build a large TV-Be-Gone for iPhones, forcing reboots over the air on hundreds of iPhones simultaneously. Would Apple really build such a feature into an iPhone?\u003c/p\u003e\u003cp\u003eKnowing a thing or two about the Apple wireless ecosystem, my interest was piqued, and I had to go down the rabbit hole!\u003c/p\u003e\u003ch2\u003eDiscovery of Inactivity Reboot\u003c/h2\u003e\u003cp\u003eWhen Apple adds new features, they usually don\u0026#39;t hide this very well. Apple software contains a lot of debug strings, which hint at new functionality. Blacktop maintains a \u003ca href=\"https://github.com/blacktop/ipsw-diffs\"\u003egit repository\u003c/a\u003e of strings found in iOS, which keeps a nice version history. I decided to do the most low-effort thing I could think of: just search for \u0026#34;reboot\u0026#34;.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEi4XBZbJShDJ9GPps2OujHTkV_KZn-KcijaJX34M5GsyKk_TMRsUrYkxkft2LiAMa8V62VKXagqP5Q2lQntBlRo9lobsf-7qo39M-DzpWwGgfOioKq8LQs8xAnKIRNrC0b9RlA4FZWYQg4Q1yvcILbr_Lp_Nm0ULdRG9l13_sSB1R5JIP7eYJzYwy9QAwU2\"\u003e\u003cimg alt=\"\" data-original-height=\"1544\" data-original-width=\"3000\" height=\"330\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEi4XBZbJShDJ9GPps2OujHTkV_KZn-KcijaJX34M5GsyKk_TMRsUrYkxkft2LiAMa8V62VKXagqP5Q2lQntBlRo9lobsf-7qo39M-DzpWwGgfOioKq8LQs8xAnKIRNrC0b9RlA4FZWYQg4Q1yvcILbr_Lp_Nm0ULdRG9l13_sSB1R5JIP7eYJzYwy9QAwU2=w640-h330\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cbr/\u003e\u003c/div\u003e\u003cp\u003eBingo, that third hit looks good: \u0026#34;inactivity_reboot\u0026#34;. The fact that it\u0026#39;s in \u003cspan\u003ekeybagd\u003c/span\u003e is interesting: this daemon is related to the key store that is unlocked on the first unlock.\u003c/p\u003e\u003cp\u003eA second search for only inactivity reboot shows the string starts occurring in iOS 18.1 and iOS 18.2. In iOS 18.2, the string changed from \u0026#34;inactivity_reboot\u0026#34; to \u0026#34;inactivity_reboot_enabled\u0026#34;, hinting towards more potential changes in the latest iOS 18.2 betas.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEgBjM82vk9aCJNzlk-9gbRKwc9y83Z9g9WZsPDUQXxB4oYXsuA-QntGrp4pMalJFUPFqETW0fxy3IfCrlziX946r_ymJ8G0a-mtIkFEzp1DoXPRcq9RUi1KOOtjgK8XfRJJcghzLLgNsM7JfvByjxqfWz2JqHPGEEkXpttCbMvdoCW7FPrfDU-psLHbdgD-\"\u003e\u003cimg alt=\"\" data-original-height=\"1194\" data-original-width=\"2334\" height=\"328\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEgBjM82vk9aCJNzlk-9gbRKwc9y83Z9g9WZsPDUQXxB4oYXsuA-QntGrp4pMalJFUPFqETW0fxy3IfCrlziX946r_ymJ8G0a-mtIkFEzp1DoXPRcq9RUi1KOOtjgK8XfRJJcghzLLgNsM7JfvByjxqfWz2JqHPGEEkXpttCbMvdoCW7FPrfDU-psLHbdgD-=w640-h328\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSomething that was still unclear to me at that point is: How long does it take for inactivity reboot to be triggered? A newÂ \u003ca href=\"https://www.404media.co/apple-quietly-introduced-iphone-reboot-code-which-is-locking-out-cops/\"\u003earticle by 404 media\u003c/a\u003eÂ claimed that it was 3-4 days. So I updated my SRD to the latest beta and made a time lapse.\u003c/p\u003e\u003cp\u003e\u003ciframe allowfullscreen=\"\" height=\"266\" src=\"https://www.youtube.com/embed/QOe2rDKOWMk\" width=\"320\" youtube-src-id=\"QOe2rDKOWMk\"\u003e\u003c/iframe\u003e\u003c/p\u003e\u003cp\u003eTurns out, the inactivity reboot triggers exactly after 3 days (72 hours). The iPhone would do so despite being connected to Wi-Fi. This confirms my suspicion that this feature had nothing to do with wireless connectivity.\u003c/p\u003e\u003ch2\u003eReverse Engineering Inactivity Reboot\u003c/h2\u003e\u003cp\u003eLet\u0026#39;s reverse engineer what\u0026#39;s changed! Which security guarantees does it provide?\u003c/p\u003e\u003cp\u003eHere is a high-level overview of what I found:\u003c/p\u003e\u003cul\u003e\u003cli\u003eThe Secure Enclave Processor (SEP) keeps track on when your phone was last unlocked. If that last unlock time exceeds 3 days, the SEP tells the \u003cspan\u003eAppleSEPKeyStore\u003c/span\u003e kernel module that the time was exceeded.\u003c/li\u003e\u003cli\u003eThe \u003cspan\u003eAppleSEPKeyStore\u003c/span\u003e kernel module informs user space to initiate a reboot. \u003cspan\u003eSpringBoard\u003c/span\u003e will then gracefully terminate all user-space processes. This prevents potential data loss upon reboot.\u003c/li\u003e\u003cli\u003eIf the \u003cspan\u003eAppleSEPKeyStore\u003c/span\u003e kernel module finds the iPhone to still be powered on after it should have rebooted, the kernel will panic. This case should never happen, unless someone tries to tamper with inactivity reboot.\u003c/li\u003e\u003cli\u003eThe \u003cspan\u003eAppleSEPKeyStore\u003c/span\u003e kernel module writes an NVRAM variable \u003cspan\u003eaks-inactivity\u003c/span\u003e. After the iPhone rebooted, \u003cspan\u003ekeybagd\u003c/span\u003e reads this variable and, if set, sends an analytics event to Apple including how long the iPhone was not unlocked.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe remainder of this post shows how I figured this out and what security implications the underlying design has.\u003c/p\u003e\u003ch2\u003eIndicators in Sysdiagnose\u003c/h2\u003e\u003cp\u003eFrom my search in ipsw-diffs, I knew there were some log messages that are printed on reboot. At the same time as I started looking them statically, I knew I had to see them actually logged for myself.\u003c/p\u003e\u003cp\u003eAfter my phone rebooted after three days, I took a sysdiagnose and searched for these messages. When doing this yourself, make sure that you unlocked the device before making the sysdiagnose. Otherwise, events from before the reboot will be missing.\u003c/p\u003e\u003cp\u003eIn theÂ \u003cspan\u003eAppleSEPKeyStore\u003c/span\u003eÂ messages, there are the following entries around the inactivity reboot:\u003c/p\u003e\u003cp\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003e2024-11-17 01:35:14.341697 +0100\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003ekernel\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003e\u0026#34;AppleSEPKeyStore\u0026#34;:3846:0: \u003cspan\u003enotifying user space of inactivity reboot\u003c/span\u003e\u003cbr/\u003e\u003c/span\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003e2024-11-17 01:35:14.341766 +0100\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003ekernel\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003e\u0026#34;AppleSEPKeyStore\u0026#34;:12598:31: operation failed (sel: 35 ret: e00002f0)\u003cbr/\u003e\u003c/span\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003e2024-11-17 01:35:14.342053 +0100\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003ekernel\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003e\u0026#34;AppleSEPKeyStore\u0026#34;:12598:31: operation failed (sel: 35 ret: e00002f0)\u003cbr/\u003e\u003c/span\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003e2024-11-17 01:35:34.958218\u003cbr/\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e[reboot occurs]\u003c/span\u003e\u003cbr/\u003e+0100\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003ekernel\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003e\u0026#34;AppleSEPKeyStore\u0026#34;:331:0: starting (BUILT: Oct 26 2024 08:16:35) (\u0026#34;normal\u0026#34; variant ðŸŒ½ , 1827.60.43)\u003cbr/\u003e\u003c/span\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003e2024-11-17 01:35:34.958381 +0100\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003ekernel\u003c/span\u003e\u003cspan\u003e\t\u003c/span\u003e\u003cspan\u003e\u0026#34;AppleSEPKeyStore\u0026#34;:476:0: _sep_enabled = 1\u003c/span\u003e\u003c/p\u003e\u003cp\u003eFor more context, these are the unfiltered log messages before the reboot is initiated:\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEjh3CycIuHLRgh46JB32Vr3WAFbEPzGzusiH_hWUUO248aoq27ntRBvDJuUhwVzF2O1p3BIYYhHoYam1IssPyBeI581bGm7frA4yFzIFA8gWerWJyuHfxDhRstUeo9eUcjG0xHcYoFeFi0S67dtuFRezYoJsz3ZMuhL5nce9o6jE7pH_Qb7tSedUNY0TxDn\"\u003e\u003cimg alt=\"\" data-original-height=\"1848\" data-original-width=\"2518\" height=\"470\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEjh3CycIuHLRgh46JB32Vr3WAFbEPzGzusiH_hWUUO248aoq27ntRBvDJuUhwVzF2O1p3BIYYhHoYam1IssPyBeI581bGm7frA4yFzIFA8gWerWJyuHfxDhRstUeo9eUcjG0xHcYoFeFi0S67dtuFRezYoJsz3ZMuhL5nce9o6jE7pH_Qb7tSedUNY0TxDn=w640-h470\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003ch2\u003eReverse Engineering the \u003cspan\u003eSEPKeyStore\u003c/span\u003e Kernel Extension\u003c/h2\u003e\u003cp\u003eThe latest iOS kernel can be downloaded using the following \u003ca href=\"https://github.com/blacktop/ipsw\"\u003e\u003cspan\u003eipsw\u003c/span\u003e\u003c/a\u003e command:\u003c/p\u003e\u003cp\u003e\u003cspan\u003eipsw download appledb --device iPhone17,3 --os iOS --version \u0026#39;18.2 beta 2\u0026#39; --kernel\u003c/span\u003e\u003c/p\u003e\u003cp\u003eThis will download and decompress the kernel. For further analysis, I loaded the whole kernel cache into Binary Ninja. \u003cspan\u003eipsw\u003c/span\u003e also supports splitting the kernel into its modules (called \u0026#34;extensions\u0026#34; on iOS). The latest version of Ghidra also has decent support for the iOS kernel. So there\u0026#39;s a lot of tools to choose from for this analysis.\u003c/p\u003e\u003cp\u003eI also downloaded an older kernel where Apple accidentally included symbols and manually diffed these versions with a focus on the code related to inactivity reboot. The kernel has three strings relating to the feature:\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEh0ZxgYUnJU1elCjWJXqzi-qkQEehkAKd3dkIH4UAUmxk6dwL3iiZ2LFlo3IvYug9d_qFuuiV6AnibEN8o8cEN-76IfazheZdPhIkm88ZYS59KADrKHJcup3X1mwGQ-9BCkdOJt7L83mSLBSAiayIIxM4AXVjMtAKRHwYaccHqKMeYAejLtvi9TGxkrY0Xl\"\u003e\u003cimg data-original-height=\"356\" data-original-width=\"1386\" height=\"164\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEh0ZxgYUnJU1elCjWJXqzi-qkQEehkAKd3dkIH4UAUmxk6dwL3iiZ2LFlo3IvYug9d_qFuuiV6AnibEN8o8cEN-76IfazheZdPhIkm88ZYS59KADrKHJcup3X1mwGQ-9BCkdOJt7L83mSLBSAiayIIxM4AXVjMtAKRHwYaccHqKMeYAejLtvi9TGxkrY0Xl=w640-h164\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u0026#34;notifying user space of inactivity reboot\u0026#34; is the string we already know from the sysdiagnose. It belongs to the function \u003cspan\u003eAppleKeyStore::handle_events\u003c/span\u003e, which polls for SEP events in the background. The following screenshot shows it in more context after reverse engineering and some renaming of functions.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEhqa9iNrqdm95LKnxB9k2Nbw9Pp2lDkiYg6NVgZW3PFiO_0DntNVYm6QRwV-0Er5puxU_Y7m3kS1zEbuxcU1IGOOTU8ZKwZsfmLEPiZy_XJb1KWi1_dQAI7_iaV7pmymZS0NtE2CLVTfH0Km5pfKeETc27gLtKDgPXAgKmwZEQESfk0No_7H-CEqVZ5U33e\"\u003e\u003cimg alt=\"\" data-original-height=\"1936\" data-original-width=\"3024\" height=\"410\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEhqa9iNrqdm95LKnxB9k2Nbw9Pp2lDkiYg6NVgZW3PFiO_0DntNVYm6QRwV-0Er5puxU_Y7m3kS1zEbuxcU1IGOOTU8ZKwZsfmLEPiZy_XJb1KWi1_dQAI7_iaV7pmymZS0NtE2CLVTfH0Km5pfKeETc27gLtKDgPXAgKmwZEQESfk0No_7H-CEqVZ5U33e=w640-h410\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe first string, \u0026#34;max inactivity window expired, failed to reboot the device\u0026#34;, is the kernel panic in case that the iPhone failed to reboot.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEgKeMPdV7mTxwu4QbCAEk4DnF6wdxUtpApFTkmHV7aYJjkkyVz4BdCN5tuFIJ5FsfvYqhjbDtdGic19Rt5cHbdoZ6S5Jl_lCTd7JhkuG8IzWCyg5h0WgXNKYa3xuaqlTOwuoG7SoATovv-m6nXthdMMaIpWeQ90xCh1IrqfzQorVcuFuH7TPuop6A6ysjBS\"\u003e\u003cimg alt=\"\" data-original-height=\"166\" data-original-width=\"1338\" height=\"80\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEgKeMPdV7mTxwu4QbCAEk4DnF6wdxUtpApFTkmHV7aYJjkkyVz4BdCN5tuFIJ5FsfvYqhjbDtdGic19Rt5cHbdoZ6S5Jl_lCTd7JhkuG8IzWCyg5h0WgXNKYa3xuaqlTOwuoG7SoATovv-m6nXthdMMaIpWeQ90xCh1IrqfzQorVcuFuH7TPuop6A6ysjBS=w640-h80\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eFor more context, the panic is called by the functionÂ \u003cspan\u003eAppleKeyStore::handle_device_state_return\u003c/span\u003e. There are multiple paths that invoke this handler through many layers of abstraction, which have to do with the UserClient but also SEP states.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEgi_v0P9i541Jg-d9THXz-ka-CvldLwbzLqWkCDFt6rEuKszDs8BQFtfhbYU2sXAqeOkMKkCrG47wShd3bzw-PurLLi766x86d1d3K_7T6oP_7R6y6bhBmCfAnKPnyuQLRVqlxjOaiJPkXl1UW0Yg5asqovDlzSJVqJdsks2pfF0oDKTw55nKSZ6EAq90yO\"\u003e\u003cimg alt=\"\" data-original-height=\"1584\" data-original-width=\"1886\" height=\"537\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEgi_v0P9i541Jg-d9THXz-ka-CvldLwbzLqWkCDFt6rEuKszDs8BQFtfhbYU2sXAqeOkMKkCrG47wShd3bzw-PurLLi766x86d1d3K_7T6oP_7R6y6bhBmCfAnKPnyuQLRVqlxjOaiJPkXl1UW0Yg5asqovDlzSJVqJdsks2pfF0oDKTw55nKSZ6EAq90yO=w640-h537\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWith the \u003ca href=\"https://github.com/elbiazo/calltree\"\u003ecalltree plugin\u003c/a\u003e, we can see all the incoming calls to this function.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEjfKMpgWgr5MpdI1gKiXgnP860eGS0w4h7DqW8nWfOX5D2I8WiUPGHIGjfFeDOwJ_zKqjjv59fIAdeZQNQ-OPCzdNTM08N12sMg2Cg4M042iaWFkkgYlYeUsfk7njj6QwChF61fnDebQbbbDx1u6QKj33-cJnAqNBLo4f8LL68GNiodwTMwEfuptfnsadrL\"\u003e\u003cimg alt=\"\" data-original-height=\"660\" data-original-width=\"1054\" height=\"400\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEjfKMpgWgr5MpdI1gKiXgnP860eGS0w4h7DqW8nWfOX5D2I8WiUPGHIGjfFeDOwJ_zKqjjv59fIAdeZQNQ-OPCzdNTM08N12sMg2Cg4M042iaWFkkgYlYeUsfk7njj6QwChF61fnDebQbbbDx1u6QKj33-cJnAqNBLo4f8LL68GNiodwTMwEfuptfnsadrL=w640-h400\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNow to the last string, \u0026#34;aks-inactivity\u0026#34;. We can see that this is a property that is set in the IORegistry.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEh3-JpRsuVcoQvKveSUKY47zOeJl3FVm3VAvtmG17u_f_wdfYYvQaS3JXA7kIAequNfdiQ9s-tSHQrOAtlRdVoPmJD1lJ2K5RZExe5vNgHNMZsv_JPgY5k-RflZTVqnC1-_FdZCmn6EZnE_fPiIWTIYPMKPh_oN_EkQP5YEk9eE1i-x-Wy-_YCEC9GvNus5\"\u003e\u003cimg alt=\"\" data-original-height=\"1000\" data-original-width=\"2948\" height=\"218\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEh3-JpRsuVcoQvKveSUKY47zOeJl3FVm3VAvtmG17u_f_wdfYYvQaS3JXA7kIAequNfdiQ9s-tSHQrOAtlRdVoPmJD1lJ2K5RZExe5vNgHNMZsv_JPgY5k-RflZTVqnC1-_FdZCmn6EZnE_fPiIWTIYPMKPh_oN_EkQP5YEk9eE1i-x-Wy-_YCEC9GvNus5=w640-h218\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eIts counterpart is in \u003cspan\u003ekeybagd\u003c/span\u003e in user space. When \u003cspan\u003ekeybagd\u003c/span\u003e is initialized, it checks for this variable, issues an analytics event, and then deletes it. This analytics event probably helps Apple optimize the time window, but we can ignore it for the core functionality.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEiDi2dNE_vIsKY6UD2LhnRy31qXgNMeBdWA-Bk52lQV7aK6VWZqxudXe0wJRPDHV4rPDxi44CUOyKQpm7-Yks93eATITRqqbSkOME6xM9o7W7N1NYKsBBP65yS97cKtq6TLP6ChFQxF1gFg-NK84_q0lCXOubU1ZNr9-XIxdEKjE9dc3QwXRKe31KJ9j5oH\"\u003e\u003cimg alt=\"\" data-original-height=\"804\" data-original-width=\"1692\" height=\"304\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEiDi2dNE_vIsKY6UD2LhnRy31qXgNMeBdWA-Bk52lQV7aK6VWZqxudXe0wJRPDHV4rPDxi44CUOyKQpm7-Yks93eATITRqqbSkOME6xM9o7W7N1NYKsBBP65yS97cKtq6TLP6ChFQxF1gFg-NK84_q0lCXOubU1ZNr9-XIxdEKjE9dc3QwXRKe31KJ9j5oH=w640-h304\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSomething that I couldn\u0026#39;t find in the kernel, even with the knowledge that it was 72 hours, was this particular time window. I couldn\u0026#39;t find any numbers that matched 72 hours. So how does the phone know when to reboot?\u003c/p\u003e\u003cp\u003eWhile there are some references to time-related functionality in the \u003cspan\u003eSEPKeyStore\u003c/span\u003e kernel extension, none of these compare a value to 72 hours. These references were quite simple to find and did not differ much from the older kernel version without inactivity reboot, so it doesn\u0026#39;t seem like the functionality was added here.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEitDjU-0SbfmaNcNosZlWHx0dTUnfmIjSVxTW_xA1bgEVwSmgp_uob_P62GyCveo8CdmN7MwQ8rX_J1qI1U4KMTPxgUigfGwgRYlWzvkmhoqepnpr-KkBDhQ2WakbMxs_YGsuiOIMVoXq19cu4TEzqBHHxwQEMJrR1xAVTF0LRk6_2-W9L_m4k7LvDJw9Bb\"\u003e\u003cimg alt=\"\" data-original-height=\"936\" data-original-width=\"1610\" height=\"372\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEitDjU-0SbfmaNcNosZlWHx0dTUnfmIjSVxTW_xA1bgEVwSmgp_uob_P62GyCveo8CdmN7MwQ8rX_J1qI1U4KMTPxgUigfGwgRYlWzvkmhoqepnpr-KkBDhQ2WakbMxs_YGsuiOIMVoXq19cu4TEzqBHHxwQEMJrR1xAVTF0LRk6_2-W9L_m4k7LvDJw9Bb=w640-h372\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eHowever, the \u003cspan\u003eSEPKeyStore\u003c/span\u003e communicates with the SEP co-processor. In the functions I identified, reboots are related to some SEP states. Could it be the SEP itself that checks the time?\u003c/p\u003e\u003ch2\u003eReverse Engineering the Secure Enclave Processor\u003c/h2\u003e\u003cp\u003eThe SEP is one of Apple\u0026#39;s most protected secrets. In contrast to most other firmware on the iPhone, the firmware for the SEP is encrypted.\u003c/p\u003e\u003cp\u003eLuckily for us, \u003ca href=\"https://twitter.com/nyan_satan\"\u003e@nyan_satan\u003c/a\u003e recently leaked \u003ca href=\"https://theapplewiki.com/wiki/Keys:CrystalBSeed_22B5069a_(iPhone16,1)\"\u003eSEP firmware encryption keys for iOS 18.1 beta 6\u003c/a\u003e, just eta wen Apple introduced inactivity reboot. (Thank you!! ðŸŽ‰ And Apple, if you\u0026#39;re reading this, why not ship the SEP unencrypted?) Using \u003cspan\u003eipsw\u003c/span\u003e, we can download the SEP firmware as follows:\u003c/p\u003e\u003cp\u003e\u003cspan\u003eipsw download appledb --device iPhone16,1 --os iOS --version \u0026#39;18.1 beta 6\u0026#39; --pattern \u0026#34;sep-firmware.d83.RELEASE.im4p\u0026#34;\u003c/span\u003e\u003c/p\u003e\u003cp\u003eWith the leaked keys, we can decrypt the firmware:\u003c/p\u003e\u003cp\u003e\u003cspan\u003epyimg4 im4p extract --iv 6705fb216080e19667dbcf71f532ae73 --key 4ea9db4c2e63a316a6854c83e2f5c81fd102ad40160b8998b5f9b16838b7116e -i sep-firmware.d83.RELEASE.im4p -o sep-firmware.d83.RELEASE.im4p.e\u003c/span\u003e\u003c/p\u003e\u003cp\u003eLoading this into Binary Ninja is a bit tricky. We can guess that the architecture is 64-bit ARM little endian. But there\u0026#39;s no metadata where the firmware has to be loaded to. Being lazy and not wanting to spend time on writing a firmware loader, I used Binary Ninja\u0026#39;s Triage feature to auto-detect the most likely address. Note that the firmware seems to have multiple fragments and there\u0026#39;s multiple potential load addresses. I pickedÂ 0x80090000ffc80000, which worked well for me.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEguwmjRE1k8u5npWzXhq5cs8lRMkyQqgECTzTuq_zaLuWDr5J8AyZtKkN64XixVpkczXFfSsQknPPclpjICoz7GrfRWBINwETutIXB-RF45-vlem8PavZPTyOTK4k6BmjTyY2l7xcTbmC1g6gooiaAe9DtqaiGavX0ajfnofIghAADa8xtmsLPe7bMNN-cW\"\u003e\u003cimg alt=\"\" data-original-height=\"580\" data-original-width=\"514\" height=\"400\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEguwmjRE1k8u5npWzXhq5cs8lRMkyQqgECTzTuq_zaLuWDr5J8AyZtKkN64XixVpkczXFfSsQknPPclpjICoz7GrfRWBINwETutIXB-RF45-vlem8PavZPTyOTK4k6BmjTyY2l7xcTbmC1g6gooiaAe9DtqaiGavX0ajfnofIghAADa8xtmsLPe7bMNN-cW=w355-h400\" width=\"355\"/\u003e\u003c/a\u003e\u003cspan\u003eÂ \u003c/span\u003e\u003c/p\u003e\u003cp\u003eThere\u0026#39;s only little known about the SEP. The best information I could come up with is a \u003ca href=\"https://www.blackhat.com/docs/us-16/materials/us-16-Mandt-Demystifying-The-Secure-Enclave-Processor.pdf\"\u003epresentation dating back to 2016\u003c/a\u003e â€“ but that\u0026#39;s better than nothing! What\u0026#39;s good to know is that the SEP firmware is structured into apps, so I\u0026#39;m guessing the other base addresses the triage found may correspond to the other apps\u0026#39; address spaces. The app that communicates with the SEPKeyStore is called \u003cspan\u003esks\u003c/span\u003e (see slide 86 of the presentation). Not a lot of information, but enough to start reverse engineering!\u003c/p\u003e\u003cp\u003eLooking at strings, it looks like the architecture of apps running inside the SEP hasn\u0026#39;t changed much since 2016. The \u003cspan\u003eSEPKeyStore\u003c/span\u003e-related app is still called \u003cspan\u003esks\u003c/span\u003e:\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEhfPY-EilBBTqlkWuLpWvFXx3bok5syhn8KZO15LWApKKMIN2wgcAMK-znjMMpk5Kv3xq0uVQOBI8UK4Ld8QpEmDQGCOpEq4shM1Td8ywQ3xHmdjl8Fi7lrCYg7iWTsGxY5fA-GcTTk-3z6Z4qb4FCGZ7AE1Lbcxy_KHPQ9-blxMVrSjLRtSUNdZxk8iluZ\"\u003e\u003cimg alt=\"\" data-original-height=\"436\" data-original-width=\"1248\" height=\"224\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEhfPY-EilBBTqlkWuLpWvFXx3bok5syhn8KZO15LWApKKMIN2wgcAMK-znjMMpk5Kv3xq0uVQOBI8UK4Ld8QpEmDQGCOpEq4shM1Td8ywQ3xHmdjl8Fi7lrCYg7iWTsGxY5fA-GcTTk-3z6Z4qb4FCGZ7AE1Lbcxy_KHPQ9-blxMVrSjLRtSUNdZxk8iluZ=w640-h224\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe SEP has almost no debug strings, making it tougher to reverse engineer. Here is what the initialization function for the \u003cspan\u003eSEPKeyStore\u003c/span\u003e looks like after some manual annotations (\u0026#34;sth\u0026#34; stands for \u0026#34;something\u0026#34; â€“ I didn\u0026#39;t go too deep into understanding the specifics here):\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEhPrpu1jil4mrXVyRP1LvrLjsTVNQ2jC3QHXLJGZaSZ8oAFgGC97jZf0T00HGkzTiANO1MlZA6KSoUmiDzhEkx0Zk0GQcYD6MCAa1RuX9cJnQNBFWblQ_k5j0ZqBUltQ1B2Wfks6vmIcHu6MsDrJmmtw270W3SQ9bBTTcXai7Sc4g3Y6Uj-3PJQP71Z9zbE\"\u003e\u003cimg alt=\"\" data-original-height=\"458\" data-original-width=\"1614\" height=\"182\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEhPrpu1jil4mrXVyRP1LvrLjsTVNQ2jC3QHXLJGZaSZ8oAFgGC97jZf0T00HGkzTiANO1MlZA6KSoUmiDzhEkx0Zk0GQcYD6MCAa1RuX9cJnQNBFWblQ_k5j0ZqBUltQ1B2Wfks6vmIcHu6MsDrJmmtw270W3SQ9bBTTcXai7Sc4g3Y6Uj-3PJQP71Z9zbE=w640-h182\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWithin its main function, we can find multiple other functions executed before a service workloop starts. However, there\u0026#39;s plenty of code. How do we focus on things that are related to the inactivity reboot?\u003c/p\u003e\u003cp\u003eLet\u0026#39;s recall that we\u0026#39;re looking for something that resembles 72 hours. In the kernel, times are usually measured in seconds or in microseconds. For example 72 hours areÂ 259200 seconds (0x3f480). But looking for this value (or for 259200000000, in microseconds, or any other sensible units) in the binary won\u0026#39;t return any matches.\u003c/p\u003e\u003cp\u003eUsing the \u003ca href=\"https://godbolt.org/\"\u003ecompiler explorer\u003c/a\u003e, we can see why: Optimizations...\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEjiVp3eTE2aXqnNiZMIJu7uRjTEpEahpDlVxzexq0iVsFmD01Ux8xTq8OUcNECXwZ099DnhfdpBvb_ztjNnzHlQ6XV9nbIOOYmabejFVA-D3Iq-cAt_nK2IktXQ7I0XF-6xONp4MgNgcjsCa1_mRTAiJ0WgeKRiac-QQpo8SBthBPDV3aK2UrLwNS7nUtRk\"\u003e\u003cimg alt=\"\" data-original-height=\"1062\" data-original-width=\"3024\" height=\"225\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEjiVp3eTE2aXqnNiZMIJu7uRjTEpEahpDlVxzexq0iVsFmD01Ux8xTq8OUcNECXwZ099DnhfdpBvb_ztjNnzHlQ6XV9nbIOOYmabejFVA-D3Iq-cAt_nK2IktXQ7I0XF-6xONp4MgNgcjsCa1_mRTAiJ0WgeKRiac-QQpo8SBthBPDV3aK2UrLwNS7nUtRk\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eRather than looking the full time in bytes in reverse byte order, we\u0026#39;re looking for assembly instructions that load parts of the timespan into a register.\u003c/p\u003e\u003cp\u003eBinary Ninja knows how to reverse this optimization, and allows us to search in its intermediate representations, instead of looking for raw bytes. In our case, we know that we\u0026#39;re looking for a constant.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEiAksVrxNBr5xGLwoRNEbxzVIMoOMMapRcHKVGaB_R_O3AWmrvNcMwINtPo1zaXnlNxbv0tV8EWXAg0jnHgskU22-Ui71tPAFkaoXud_POuCAdbcoAwPg8HNbjfeo6qYKmsaM9IlQR6muWihOSzBzauHF4PitCFVl-DfjRt6RUUZrBEPLU3Gu2WEusxU8hE\"\u003e\u003cimg alt=\"\" data-original-height=\"808\" data-original-width=\"1100\" height=\"294\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEiAksVrxNBr5xGLwoRNEbxzVIMoOMMapRcHKVGaB_R_O3AWmrvNcMwINtPo1zaXnlNxbv0tV8EWXAg0jnHgskU22-Ui71tPAFkaoXud_POuCAdbcoAwPg8HNbjfeo6qYKmsaM9IlQR6muWihOSzBzauHF4PitCFVl-DfjRt6RUUZrBEPLU3Gu2WEusxU8hE=w400-h294\" width=\"400\"/\u003e\u003c/a\u003eÂ \u003c/p\u003e\u003c/div\u003e\u003cp\u003eWe find only two matches:\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEhJwjCy5EDHg2kK4t-h4GW_KqEKu7X_1d-jfbjm1LeYIMKF_YEA4oAZaWK20ZujWctbqOhXaseMbH1DvWp6H-O4flgmN419gJorpk653jeG90Jr540JGOV92Up4e7jyUq9CW1X2VPhFEncwOT-qWzB0ZFm6BN3vLcA01fZVH6WR9jJ5ywFRevYjyFVX4g5c\"\u003e\u003cimg alt=\"\" data-original-height=\"250\" data-original-width=\"1632\" height=\"98\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEhJwjCy5EDHg2kK4t-h4GW_KqEKu7X_1d-jfbjm1LeYIMKF_YEA4oAZaWK20ZujWctbqOhXaseMbH1DvWp6H-O4flgmN419gJorpk653jeG90Jr540JGOV92Up4e7jyUq9CW1X2VPhFEncwOT-qWzB0ZFm6BN3vLcA01fZVH6WR9jJ5ywFRevYjyFVX4g5c=w640-h98\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAnd here it is â€“ a function that compares various times, including 3 days, which is related to the \u003cspan\u003esks\u003c/span\u003e application\u0026#39;s main function. The result of this time comparison is used to create a message, which is likely sent to the \u003cspan\u003eSEPKeyStore\u003c/span\u003e kernel extension. Creating a new enum makes it more readable:\u003c/p\u003e\u003cp\u003e\u003cspan\u003eenum times : uint32_t\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003e    _3_days = 0x3f480,\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003e    _2_days = 0x2a301,\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003e    _1_days = 0x15181,\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003e    `_2.5h` = 0xe11\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003e};\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEg0JC9kKOelUjXI7AmxnIJf4160QuVQ6JibF1gYvk_QIc3d-0mDP29IvKaxuYQS9Hou8u3gfcpJHf11qznWDYY2QQKSZhDWcGusssdg_kxo4fH9aJbveSJxRdo5OpLS7az18e9wfpKxsjTZqKeQdA6eB45tfr4y0offM4mmbADozT7PH3H71ypvq_83cql6\"\u003e\u003cimg alt=\"\" data-original-height=\"1114\" data-original-width=\"1330\" height=\"535\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEg0JC9kKOelUjXI7AmxnIJf4160QuVQ6JibF1gYvk_QIc3d-0mDP29IvKaxuYQS9Hou8u3gfcpJHf11qznWDYY2QQKSZhDWcGusssdg_kxo4fH9aJbveSJxRdo5OpLS7az18e9wfpKxsjTZqKeQdA6eB45tfr4y0offM4mmbADozT7PH3H71ypvq_83cql6=w640-h535\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis function is used in a context to initialize a struct, which is likely a message being sent from the SEP to the kernel extension.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/a/AVvXsEhIi1ytOnwIHz3FfehB3gzVzc4s2L1oOKyB_huAhQ_tMDIPvTFs3ffHMb8sICRwqbc8_dDY3r340BZpYdyjx9n1hRnMUcHIxRUEhcoPrBiiTA4tevJ3E_X8rxujzB1hq2Ncm0mLX3nzlHc41BfoAMsJcqZZWcaEg0_ElGxbhQS86UZeo9TXH4PdrzeFqIza\"\u003e\u003cimg alt=\"\" data-original-height=\"1626\" data-original-width=\"1780\" height=\"584\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEhIi1ytOnwIHz3FfehB3gzVzc4s2L1oOKyB_huAhQ_tMDIPvTFs3ffHMb8sICRwqbc8_dDY3r340BZpYdyjx9n1hRnMUcHIxRUEhcoPrBiiTA4tevJ3E_X8rxujzB1hq2Ncm0mLX3nzlHc41BfoAMsJcqZZWcaEg0_ElGxbhQS86UZeo9TXH4PdrzeFqIza=w640-h584\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI didn\u0026#39;t end up reverse engineering much more of the SEP, but this seems to confirm that it\u0026#39;s really the SEP that keeps track of how long the phone hasn\u0026#39;t been unlocked. This design makes sense to me, since the SEP is involved in every unlock, and is also hardened against tampering, even if an exploit against the main kernel is used, so it\u0026#39;s a good place to anchor a mitigation like this.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2\u003eA Mitigation Only Against Cops?\u003c/h2\u003e\u003ch2\u003e\u003cp\u003eWhile the media coverage so far framed this mitigation as primarily targeting law enforcement, it also a huge security improvement against theft. Outdated law enforcement equipment often finds its way to eBay and other similar platforms for rather cheap price tags. However, thieves won\u0026#39;t have the financial and legal means to obtain up-to-date exploits to unlock iPhones within 3 days of getting them. That\u0026#39;s another reason why it\u0026#39;s important to keep your device updated!\u003c/p\u003e\u003cp\u003eOn the other hand, law enforcement can and will have to adjust their process, and act faster than before. The first forensic tooling companies already announced that they\u0026#39;re able to coordinate these steps within 24 hours! (Note that this also indicates that they only have exploits for AFU state... ðŸ¤¡)\u003c/p\u003e\u003c/h2\u003e\u003ch2\u003eKey Takeaways\u003c/h2\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003eThis feature is not at all related to wireless activity. The law enforcement document\u0026#39;s conclusion that the reboot is due to phones wirelessly communicating with each other is implausible. The older iPhones before iOS 18 likely rebooted due to another reason, such as a software bug.\u003c/p\u003e\u003cp\u003eThe time measurement and triggering of the reboot is in the SEP, which communicates with the \u003cspan\u003eSEPKeyStore\u003c/span\u003e kernel extension to perform the reboot. It is likely that using an external time source provided over the Internet or cellular networks to tamper with timekeeping will not influence the 3-day timer.\u003c/p\u003e\u003cp\u003eSecurity-wise, this is a very powerful mitigation. An attacker must have kernel code execution to prevent an inactivity reboot. This means that a forensic analyst might be able to delay the reboot for the actual data extraction, but the initial exploit must be run within the first three days.\u003c/p\u003e\u003cp\u003eInactivity reboot will change the threat landscape for both thieves and forensic analysts, but asymmetrically so: while law enforcement is under more time pressure, it likely completely locks out criminals from accessing your data to get into your bank accounts and other valuable information stored on your iPhone.\u003c/p\u003e\u003cp\u003eInterested in reverse engineering? Follow me on \u003ca href=\"https://www.youtube.com/@jiskac\"\u003eYouTube\u003c/a\u003e and \u003ca href=\"https://bsky.app/profile/naehrdine.bsky.social\"\u003eBlueSky\u003c/a\u003e for updates.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": "2024-11-17T13:27:00-08:00",
  "modifiedTime": null
}
