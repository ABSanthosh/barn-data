{
  "id": "c08d0d47-7fd1-4fba-880d-53085d16505c",
  "title": "Things Zig comptime won't do",
  "link": "https://matklad.github.io/2025/04/19/things-zig-comptime-wont-do.html",
  "description": "Comments",
  "author": "",
  "published": "Sun, 20 Apr 2025 15:57:37 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 16659,
  "excerpt": "Es el disco de Odín. Tiene un solo lado. En la tierra no hay otra cosa que tenga un solo lado.",
  "siteName": "",
  "favicon": "https://matklad.github.io/favicon.png",
  "text": "Things Zig comptime Won’t Do Apr 19, 2025 Es el disco de Odín. Tiene un solo lado. En la tierra no hay otra cosa que tenga un solo lado. Zig’s comptime feature is most famous for what it can do: generics!, conditional compilation!, subtyping!, serialization!, ORM! That’s fascinating, but, to be fair, there’s a bunch of languages with quite powerful compile time evaluation capabilities that can do equivalent things. What I find more interesting is that Zig comptime is actually quite restrictive, by design, and won’t do many things! It manages to be very expressive despite being pretty limited. Let’s see! No Host Leakage When you execute code at compile time, on which machine does it execute? The natural answer is “on your machine”, but it is wrong! The code might not run on your machine, it can be cross compiled! For overall development sanity, it is important that comptime code observes the same behavior as the runtime code, and doesn’t leak details about the host on which the code is compiled. Zig doesn’t give comptime code access to host architecture (host — machine on which you compile code). Consider this Zig program: const std = @import(\"std\"); comptime { const x: usize = 0xbeef; const xs: []const u8 = std.mem.asBytes(\u0026x); for (xs) |byte| { @compileLog(byte); } } I get the following output when compiling normally, on my computer for my computer: λ ~/zig-0.14/zig build-lib main.zig @as(u8, 239) @as(u8, 190) @as(u8, 0) @as(u8, 0) @as(u8, 0) @as(u8, 0) @as(u8, 0) @as(u8, 0) But if I cross compile to a 32 bit big-endian architecture, comptime observes correct usize: λ ~/zig-0.14/zig build-lib -target thumbeb-freestanding-none main.zig @as(u8, 0) @as(u8, 0) @as(u8, 190) @as(u8, 239) My understanding is that Jai, for example, doesn’t do this, and runs comptime code on the host. Rust’s declarative macros and const-fn don’t observe host architecture, but procedural macros do. No #eval Many powerful compile-time meta programming systems work by allowing you to inject arbitrary strings into compilation, sort of like #include whose argument is a shell-script that generates the text to include dynamically. For example, D mixins work that way: https://dlang.org/articles/mixin.html And Rust macros, while technically producing a token-tree rather than a string, are more or less the same. In contrast, there’s absolutely no facility for dynamic source code generation in Zig. You just can’t do that, the feature isn’t! Zig has a completely different feature, partial evaluation/specialization, which, none the less, is enough to cover most of use-cases for dynamic code generation. Let’s see an artificial example: fn f(x: u32, y: u32) u32 { if (x == 0) return y + 1; if (x == 1) return y * 2; return y; } This is a normal function that dispatches on the first argument to select an operation to apply to the second argument. Nothing fancy! Now, the single feature that Zig has is marking the first argument with comptime fn f(comptime x: u32, y: u32) u32 { if (x == 0) return y + 1; if (x == 1) return y * 2; return y; } The restriction here is that now, of course, when you call f, the first argument must be comptime-known. You can f(92, user_input()), but you can’t f(user_input(), 92). The carrot you’ll get in exchange is a guarantee that, for each specific call with a particular value of x, the compiler will partially evaluate f, so only one branch will be left. Zig is an imperative language. Not everything is a function, there’s also control flow expressions, and they include partially-evaluated variations. For example, for(xs) is a normal runtime for loop over a slice, comptime for(xs) evaluates the entire loop at compile time, requiring that xs is comptime-known, and inline for(xs) requires that just the length of xs is known at comptime. Let’s apply specialization to the classic problem solved by code-generation — printing. You can imagine a proc-macro style solution that prints a struct by reflecting on which fields it has and emitting the code to print each field. In Zig, the same is achieved by specializing a recursive print function on the value of type: const S = struct { int: u32, string: []const u8, nested: struct { int: u32, }, }; pub fn main() void { const s: S = .{ .int = 1, .string = \"hello\", .nested = .{ .int = 2 }, }; print(S, s); } fn print(comptime T: type, value: T) void { if (T == u32) return print_u32(value); if (T == []const u8) return print_string(value); switch (@typeInfo(T)) { .@\"struct\" =\u003e |info| { print_literal(\"{\"); var space: []const u8 = \"\"; inline for (info.fields) |field| { print_literal(space); space = \", \"; print_literal(field.name); print_literal(\" = \"); const field_value = @field(value, field.name); print(field.type, field_value); } print_literal(\"}\"); }, else =\u003e comptime unreachable, } } fn print_u32(value: u32) void { std.debug.print(\"{d}\", .{value}); } fn print_string(value: []const u8) void { std.debug.print(\"\\\"{s}\\\"\", .{value}); } fn print_literal(literal: []const u8) void { std.debug.print(\"{s}\", .{literal}); } Our print is set up exactly as our f before — the first argument is a comptime-known dispatch parameter. If T is an int or a string, the compiler calls print_u32 or print_string directly. The third case is more complicated. First, we use @typeInfo to get a comptime value describing our type, and, in particular, the list of fields it has. Then, we iterate this list and recursively print each field. Note that although the list of fields is known in its entirety, we can’t comptime for it, we need inline for. This is because the body of our loop depends on the runtime value, and can’t be fully evaluated at compile time. This might be easier to see if you think in terms of functions. The for loop is essentially a map: map :: [a] -\u003e (a -\u003e b) -\u003e [b] map xs f = ... If both xs and f are comptime-known, you can evaluate the entire loop at compile time. But in our case f actually closes over a runtime value, so we can’t evaluate everything. Still, we can specialize on the first argument, which is known at compile time. This is precisely the difference between comptime and inline for. No DSLs Many meta programming systems, like macros in Lisp or Rust, not only produce arbitrary code, but also take arbitrary custom syntax as input, as long as parentheses are matched: use inline_python::python; let who = \"world\"; let n = 5; python! { for i in range('n): print(i, \"Hello\", 'who) print(\"Goodbye\") } Zig doesn’t have any extension points for custom syntax. Indeed, you can’t pass Zig syntax (code) to comptime functions at all! Everything operates on Zig values. That being said, Zig is very lightweight when it comes to describing free-form data, so this isn’t much of a hindrance. And in any case, you can always pass your custom syntax as a comptime string. This is exactly how “printf” works: pub fn print(comptime fmt: []const u8, args: anytype) void Here, fmt is an embedded DSL, which is checked at compile time to match the arguments. No RTTI Zig printing code looks suspiciously close to how you’d do this sort of thing in a dynamic language like Python. In fact, it is precisely that same code, except that it is specialized over runtime type information Python has to enable this sort of thing. Furthermore, Zig actually requires that all type meta programming is specialized away. Types as values only exist at compile time. Still, looking at our print, we might be concerned over code size — we are effectively generating a fresh copy of print for any data structure. Our code will be smaller, and will compile faster if there’s just a single print that takes an opaque pointer and runtime parameter describing the type of the value (its fields and offsets). So let’s roll our own runtime type information. For our example, we support ints, strings, and structs with fields. For fields, our RTTI should include their names and offsets: const RTTI = union(enum) { u32, string, @\"struct\": []const Field, const Field = struct { name: []const u8, offset: u32, rtti: RTTI, }; }; The printing itself is not particularly illuminating, we just need to cast an opaque pointer according to RTTI: fn print_dyn(T: RTTI, value: *const anyopaque) void { switch (T) { .u32 =\u003e { const value_u32: *const u32 = @alignCast(@ptrCast(value)); print_u32(value_u32.*); }, .string =\u003e { const value_string: *const []const u8 = @alignCast(@ptrCast(value)); print_string(value_string.*); }, .@\"struct\" =\u003e |info| { print_literal(\"{\"); var space: []const u8 = \"\"; for (info) |field| { print_literal(space); space = \", \"; print_literal(field.name); print_literal(\" = \"); const field_ptr: *const anyopaque = @as([*]const u8, @ptrCast(value)) + field.offset; print_dyn(field.rtti, field_ptr); } print_literal(\"}\"); }, } } Finally, we need to compute RTTI, which amounts to taking comptime-only Zig type info and extracting important bits into an RTTI struct which is computed at compile time, but can exist at runtime as well: fn reflect(comptime T: type) RTTI { comptime { if (T == u32) return .u32; if (T == []const u8) return .string; switch (@typeInfo(T)) { .@\"struct\" =\u003e |info| { var fields: [info.fields.len]Field = undefined; for (\u0026fields, info.fields) |*slot, field| { slot.* = .{ .name = field.name, .offset = @offsetOf(T, field.name), .rtti = reflect(field.type), }; } const fields_frozen = fields; return .{ .@\"struct\" = \u0026fields_frozen }; }, else =\u003e unreachable, } } } The call site is illustrative: we need comptime to compute the type information, but then we reify it as some real bytes in the binary, and use it as runtime value when calling print_dyn. pub fn main() void { const s: S = .{ .int = 1, .string = \"hello\", .nested = .{ .int = 2 }, }; print_dyn(comptime RTTI.reflect(S), \u0026s); } No New API You can use Zig comptime to create new types. That’s how a Zig ORM can work. However, it is impossible to add methods to generated types, they must be inert bundles of fields. In Rust, when you use a derive macro, it can arbitrarily extend type’s public API, and you need to read proc macro docs (or look at the generated code) to figure out what’s available. In Zig, types’s API is always hand written, but it can use comptime reflection internally. So, if you are building a JSON serialization library in Zig, you can’t add .to_json method to user-types. You’ll necessarily have to supply a normal top-level function like fn to_json(comptime T: type, value: T, writer: Writer) !void { ... } If you want to make sure that types explicitly opt-in JSON serialization, you need to ask the user to mark types specially: const Person = struct { first_name: []const u8, last_name: []const u8, pub const JSONOptions = .{ .style = .camelCase, }; } With this setup, to_json can only allow primitives and types with JSONOptions. No IO Last but not least, Zig comptime does not allow any kind of input output. There isn’t even any kind of sandbox, as there are no IO facilities in the first place. So, while compiling the code, you can’t talk to your database to generate the schema. In exchange, compile time evaluation is hermetic, reproducible, safe, and cacheable. If you do need to talk to the database at build time, you can still do that, just through the build system! Zig’s build.zig is a general purpose build system, which easily supports the use-case of running an arbitrary Zig program to generate arbitrary Zig code which can then be normally @imported. El Disco Any abstraction has two sides. Powerful abstractions are useful because they are more expressive. But the flip-side is that abstraction-using code becomes harder to reason about, because the space of what it can possibly do is so vast. This dependency is not zero sum. A good abstraction can be simultaneously more powerful and easier to reason about than a bad one. Meta programming is one of the more powerful abstractions. It is very capable in Zig, and comes at a significant cost — Zig doesn’t have declaration-site type checking of comptime code. That being said, I personally find Zig’s approach to be uniquely tidy, elegant, and neat! It does much less than alternative systems, but ends extremely ergonomic in practice, and relatively easy to wrap ones head around.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003carticle\u003e\n        \u003ch2\u003e\n          Things Zig comptime Won’t Do \u003ctime datetime=\"2025-04-19\"\u003eApr 19, 2025\u003c/time\u003e\n        \u003c/h2\u003e\n\n        \u003cfigure\u003e\n          \u003cblockquote\u003e\n            \u003cp\u003e\n              Es el disco de Odín. Tiene un solo lado. En la tierra no hay otra\n              cosa que tenga un solo lado.\n            \u003c/p\u003e\n          \u003c/blockquote\u003e\n        \u003c/figure\u003e\n        \u003cp\u003e\n          Zig’s comptime feature is most famous for what it can do: generics!,\n          \u003ca href=\"https://mitchellh.com/writing/zig-comptime-conditional-disable\"\u003econditional compilation\u003c/a\u003e!,\n          \u003ca href=\"https://mitchellh.com/writing/zig-comptime-tagged-union-subset\"\u003esubtyping\u003c/a\u003e!, serialization!,\n          \u003ca href=\"https://matklad.github.io/2025/03/19/comptime-zig-orm.html\"\u003eORM\u003c/a\u003e! That’s fascinating, but, to be fair, there’s a bunch of\n          languages with quite powerful compile time evaluation capabilities\n          that can do equivalent things. What I find more interesting is that\n          Zig comptime is actually quite restrictive, by design, and won’t do\n          many things! It manages to be very expressive \u003cem\u003edespite\u003c/em\u003e being\n          pretty limited. Let’s see!\n        \u003c/p\u003e\n        \u003csection id=\"No-Host-Leakage\"\u003e\n          \u003ch2\u003e\n            \u003ca href=\"#No-Host-Leakage\"\u003eNo Host Leakage \u003c/a\u003e\n          \u003c/h2\u003e\n          \u003cp\u003e\n            When you execute code at compile time, on which machine does it\n            execute? The natural answer is “on your machine”, but it is wrong!\n            The code might not run on your machine, it can be cross compiled!\n            For overall development sanity, it is important that \u003ccode\u003ecomptime\u003c/code\u003e code observes the same behavior as the runtime\n            code, and doesn’t leak details about the host on which the code is\n            compiled. Zig doesn’t give comptime code access to host architecture\n            (host — machine on which you compile code). Consider this Zig\n            program:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e std = \u003cspan\u003e@import\u003c/span\u003e(\u003cspan\u003e\u0026#34;std\u0026#34;\u003c/span\u003e);\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ecomptime\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003econst\u003c/span\u003e x: \u003cspan\u003eusize\u003c/span\u003e = \u003cspan\u003e0xbeef\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003econst\u003c/span\u003e xs: []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e = std.mem.asBytes(\u003cspan\u003e\u0026amp;\u003c/span\u003ex);\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003efor\u003c/span\u003e (xs) \u003cspan\u003e|\u003c/span\u003ebyte\u003cspan\u003e|\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e        \u003cspan\u003e@compileLog\u003c/span\u003e(byte);\u003c/span\u003e\n\u003cspan\u003e    }\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            I get the following output when compiling normally, on my computer\n            for my computer:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003eλ ~/zig-0.14/zig build-lib main.zig\u003c/span\u003e\n\u003cspan\u003e@as(u8, 239)\u003c/span\u003e\n\u003cspan\u003e@as(u8, 190)\u003c/span\u003e\n\u003cspan\u003e@as(u8, 0)\u003c/span\u003e\n\u003cspan\u003e@as(u8, 0)\u003c/span\u003e\n\u003cspan\u003e@as(u8, 0)\u003c/span\u003e\n\u003cspan\u003e@as(u8, 0)\u003c/span\u003e\n\u003cspan\u003e@as(u8, 0)\u003c/span\u003e\n\u003cspan\u003e@as(u8, 0)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            But if I cross compile to a 32 bit big-endian architecture, comptime\n            observes correct \u003ccode\u003eusize\u003c/code\u003e:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003eλ ~/zig-0.14/zig build-lib -target thumbeb-freestanding-none main.zig\u003c/span\u003e\n\u003cspan\u003e@as(u8, 0)\u003c/span\u003e\n\u003cspan\u003e@as(u8, 0)\u003c/span\u003e\n\u003cspan\u003e@as(u8, 190)\u003c/span\u003e\n\u003cspan\u003e@as(u8, 239)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            My understanding is that Jai, for example, doesn’t do this, and runs\n            comptime code on the host.\n          \u003c/p\u003e\n          \u003cp\u003e\n            Rust’s declarative macros and const-fn don’t observe host\n            architecture, but procedural macros do.\n          \u003c/p\u003e\n        \u003c/section\u003e\n        \u003csection id=\"No-eval\"\u003e\n          \u003ch2\u003e\n            \u003ca href=\"#No-eval\"\u003eNo #eval \u003c/a\u003e\n          \u003c/h2\u003e\n          \u003cp\u003e\n            Many powerful compile-time meta programming systems work by allowing\n            you to inject arbitrary strings into compilation, sort of like \u003ccode\u003e#include\u003c/code\u003e whose argument is a shell-script that generates the\n            text to include dynamically. For example, D mixins work that way:\n            \u003ca href=\"https://dlang.org/articles/mixin.html\"\u003ehttps://dlang.org/articles/mixin.html\u003c/a\u003e\n          \u003c/p\u003e\n          \u003cp\u003e\n            And Rust macros, while technically producing a token-tree rather\n            than a string, are more or less the same. In contrast, there’s\n            absolutely no facility for dynamic source code generation in Zig.\n            You just can’t do that, the feature isn’t!\n          \u003c/p\u003e\n          \u003cp\u003e\n            Zig has a completely different feature, partial\n            evaluation/specialization, which, none the less, is enough to cover\n            most of use-cases for dynamic code generation. Let’s see an\n            artificial example:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e f\u003c/span\u003e(x: \u003cspan\u003eu32\u003c/span\u003e, y: \u003cspan\u003eu32\u003c/span\u003e) \u003cspan\u003eu32\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e (x \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e) \u003cspan\u003ereturn\u003c/span\u003e y \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e (x \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e) \u003cspan\u003ereturn\u003c/span\u003e y \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e y;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            This is a normal function that dispatches on the first argument to\n            select an operation to apply to the second argument. Nothing fancy!\n            Now, the single feature that Zig has is marking the first argument\n            with \u003ccode\u003ecomptime\u003c/code\u003e\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e f\u003c/span\u003e(\u003cspan\u003ecomptime\u003c/span\u003e x: \u003cspan\u003eu32\u003c/span\u003e, y: \u003cspan\u003eu32\u003c/span\u003e) \u003cspan\u003eu32\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e (x \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e) \u003cspan\u003ereturn\u003c/span\u003e y \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e (x \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e) \u003cspan\u003ereturn\u003c/span\u003e y \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e y;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            The restriction here is that now, of course, when you call \u003ccode\u003ef\u003c/code\u003e, the first argument must be comptime-known. You can \u003cspan\u003e\u003ccode\u003ef(92, user_input())\u003c/code\u003e,\u003c/span\u003e but you can’t\n            \u003cspan\u003e\u003ccode\u003ef(user_input(), 92)\u003c/code\u003e.\u003c/span\u003e\n          \u003c/p\u003e\n          \u003cp\u003e\n            The carrot you’ll get in exchange is a guarantee that, for each\n            specific call with a particular value of \u003ccode\u003ex\u003c/code\u003e, the\n            compiler will partially evaluate \u003ccode\u003ef\u003c/code\u003e, so only one branch\n            will be left.\n          \u003c/p\u003e\n          \u003cp\u003e\n            Zig is an imperative language. Not everything is a function, there’s\n            also control flow expressions, and they include partially-evaluated\n            variations. For example, \u003ccode\u003efor(xs)\u003c/code\u003e is a normal runtime\n            for loop over a slice, \u003ccode\u003ecomptime for(xs)\u003c/code\u003e evaluates the\n            entire loop at compile time, requiring that \u003ccode\u003exs\u003c/code\u003e is\n            comptime-known, and \u003ccode\u003einline for(xs)\u003c/code\u003e requires that just\n            the length of \u003ccode\u003exs\u003c/code\u003e is known at comptime.\n          \u003c/p\u003e\n          \u003cp\u003e\n            Let’s apply specialization to the classic problem solved by\n            code-generation — printing. You can imagine a proc-macro style\n            solution that prints a struct by reflecting on which fields it has\n            and emitting the code to print each field.\n          \u003c/p\u003e\n          \u003cp\u003e\n            In Zig, the same is achieved by specializing a recursive \u003ccode\u003eprint\u003c/code\u003e function on the value of type:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e S = \u003cspan\u003estruct\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    int: \u003cspan\u003eu32\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e    string: []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e    nested: \u003cspan\u003estruct\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e        int: \u003cspan\u003eu32\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e    },\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e main\u003c/span\u003e() \u003cspan\u003evoid\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003econst\u003c/span\u003e s: S = .{\u003c/span\u003e\n\u003cspan\u003e        .int = \u003cspan\u003e1\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e        .string = \u003cspan\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e        .nested = .{ .int = \u003cspan\u003e2\u003c/span\u003e },\u003c/span\u003e\n\u003cspan\u003e    };\u003c/span\u003e\n\u003cspan\u003e    print(S, s);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e print\u003c/span\u003e(\u003cspan\u003ecomptime\u003c/span\u003e T: \u003cspan\u003etype\u003c/span\u003e, value: T) \u003cspan\u003evoid\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e (T \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eu32\u003c/span\u003e) \u003cspan\u003ereturn\u003c/span\u003e print_u32(value);\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e (T \u003cspan\u003e==\u003c/span\u003e []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e) \u003cspan\u003ereturn\u003c/span\u003e print_string(value);\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003eswitch\u003c/span\u003e (\u003cspan\u003e@typeInfo\u003c/span\u003e(T)) {\u003c/span\u003e\n\u003cspan\u003e        .@\u003cspan\u003e\u0026#34;struct\u0026#34;\u003c/span\u003e =\u0026gt; \u003cspan\u003e|\u003c/span\u003einfo\u003cspan\u003e|\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e            print_literal(\u003cspan\u003e\u0026#34;{\u0026#34;\u003c/span\u003e);\u003c/span\u003e\n\u003cspan\u003e            \u003cspan\u003evar\u003c/span\u003e space: []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e = \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e            \u003cspan\u003einline\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e (info.fields) \u003cspan\u003e|\u003c/span\u003efield\u003cspan\u003e|\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e                print_literal(space);\u003c/span\u003e\n\u003cspan\u003e                space = \u003cspan\u003e\u0026#34;, \u0026#34;\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e                print_literal(field.name);\u003c/span\u003e\n\u003cspan\u003e                print_literal(\u003cspan\u003e\u0026#34; = \u0026#34;\u003c/span\u003e);\u003c/span\u003e\n\u003cspan\u003e                \u003cspan\u003econst\u003c/span\u003e field_value = \u003cspan\u003e@field\u003c/span\u003e(value, field.name);\u003c/span\u003e\n\u003cspan\u003e                print(field.\u003cspan\u003etype\u003c/span\u003e, field_value);\u003c/span\u003e\n\u003cspan\u003e            }\u003c/span\u003e\n\u003cspan\u003e            print_literal(\u003cspan\u003e\u0026#34;}\u0026#34;\u003c/span\u003e);\u003c/span\u003e\n\u003cspan\u003e        },\u003c/span\u003e\n\u003cspan\u003e        \u003cspan\u003eelse\u003c/span\u003e =\u0026gt; \u003cspan\u003ecomptime\u003c/span\u003e \u003cspan\u003eunreachable\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e    }\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e print_u32\u003c/span\u003e(value: \u003cspan\u003eu32\u003c/span\u003e) \u003cspan\u003evoid\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    std.debug.print(\u003cspan\u003e\u0026#34;{d}\u0026#34;\u003c/span\u003e, .{value});\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e print_string\u003c/span\u003e(value: []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e) \u003cspan\u003evoid\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    std.debug.print(\u003cspan\u003e\u0026#34;\u003cspan\u003e\\\u0026#34;\u003c/span\u003e{s}\u003cspan\u003e\\\u0026#34;\u003c/span\u003e\u0026#34;\u003c/span\u003e, .{value});\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e print_literal\u003c/span\u003e(literal: []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e) \u003cspan\u003evoid\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    std.debug.print(\u003cspan\u003e\u0026#34;{s}\u0026#34;\u003c/span\u003e, .{literal});\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            Our \u003ccode\u003eprint\u003c/code\u003e is set up exactly as our \u003ccode\u003ef\u003c/code\u003e\n            before — the first argument is a comptime-known dispatch parameter.\n            If \u003ccode\u003eT\u003c/code\u003e is an int or a string, the compiler calls \u003ccode\u003eprint_u32\u003c/code\u003e or \u003ccode\u003eprint_string\u003c/code\u003e directly.\n          \u003c/p\u003e\n          \u003cp\u003e\n            The third case is more complicated. First, we use \u003ccode\u003e@typeInfo\u003c/code\u003e to get a comptime value describing our type, and,\n            in particular, the list of fields it has. Then, we iterate this list\n            and recursively print each field. Note that although the list of\n            fields is known in its entirety, we can’t \u003ccode\u003ecomptime for\u003c/code\u003e\n            it, we need \u003ccode\u003einline for\u003c/code\u003e. This is because the \u003cem\u003ebody\u003c/em\u003e of our loop depends on the runtime\n            \u003ccode\u003evalue\u003c/code\u003e, and can’t be fully evaluated at compile time.\n            This might be easier to see if you think in terms of functions. The\n            \u003ccode\u003efor\u003c/code\u003e loop is essentially a map:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003emap :: [a] -\u0026gt; (a -\u0026gt; b) -\u0026gt; [b]\u003c/span\u003e\n\u003cspan\u003emap xs f = ...\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            If both \u003ccode\u003exs\u003c/code\u003e and \u003ccode\u003ef\u003c/code\u003e are comptime-known, you\n            can evaluate the entire loop at compile time. But in our case \u003ccode\u003ef\u003c/code\u003e actually closes over a runtime value, so we can’t evaluate\n            everything. Still, we can specialize on the first argument, which\n            \u003cem\u003eis\u003c/em\u003e known at compile time. This is precisely the difference\n            between \u003ccode\u003ecomptime\u003c/code\u003e and \u003ccode\u003einline\u003c/code\u003e\n            \u003ccode\u003efor\u003c/code\u003e.\n          \u003c/p\u003e\n        \u003c/section\u003e\n        \u003csection id=\"No-DSLs\"\u003e\n          \u003ch2\u003e\n            \u003ca href=\"#No-DSLs\"\u003eNo DSLs \u003c/a\u003e\n          \u003c/h2\u003e\n          \u003cp\u003e\n            Many meta programming systems, like macros in Lisp or Rust, not only\n            \u003cem\u003eproduce\u003c/em\u003e arbitrary code, but also take arbitrary custom\n            syntax as input, as long as parentheses are matched:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003euse\u003c/span\u003e inline_python::python;\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ewho\u003c/span\u003e = \u003cspan\u003e\u0026#34;world\u0026#34;\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003en\u003c/span\u003e = \u003cspan\u003e5\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003epython! {\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003erange\u003c/span\u003e(\u003cspan\u003e\u0026#39;n\u003c/span\u003e):\u003c/span\u003e\n\u003cspan\u003e        \u003cspan\u003eprint\u003c/span\u003e(i, \u003cspan\u003e\u0026#34;Hello\u0026#34;\u003c/span\u003e, \u003cspan\u003e\u0026#39;who\u003c/span\u003e)\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;Goodbye\u0026#34;\u003c/span\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            Zig doesn’t have any extension points for custom syntax. Indeed, you\n            can’t pass Zig \u003cem\u003esyntax\u003c/em\u003e (code) to comptime functions at all!\n            Everything operates on Zig values. That being said, Zig is very\n            lightweight when it comes to describing free-form data, so this\n            isn’t much of a hindrance. \u003cem\u003eAnd\u003c/em\u003e\n            in any case, you can always pass your custom syntax as a comptime\n            string. This is exactly how “printf” works:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e print\u003c/span\u003e(\u003cspan\u003ecomptime\u003c/span\u003e fmt: []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e, args: \u003cspan\u003eanytype\u003c/span\u003e) \u003cspan\u003evoid\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            Here, \u003ccode\u003efmt\u003c/code\u003e is an embedded DSL, which is checked at\n            compile time to match the arguments.\n          \u003c/p\u003e\n        \u003c/section\u003e\n        \u003csection id=\"No-RTTI\"\u003e\n          \u003ch2\u003e\n            \u003ca href=\"#No-RTTI\"\u003eNo RTTI \u003c/a\u003e\n          \u003c/h2\u003e\n          \u003cp\u003e\n            Zig printing code looks suspiciously close to how you’d do this sort\n            of thing in a dynamic language like Python. In fact, it is \u003cem\u003eprecisely\u003c/em\u003e that same code, except that it is specialized over\n            runtime type information Python has to enable this sort of thing.\n            Furthermore, Zig actually \u003cem\u003erequires\u003c/em\u003e that all type meta\n            programming is specialized away. Types as values \u003cem\u003eonly\u003c/em\u003e exist\n            at compile time. Still, looking at our print, we might be concerned\n            over code size — we are effectively generating a fresh copy of \u003ccode\u003eprint\u003c/code\u003e for any data structure. Our code will be smaller, and\n            will compile faster if there’s just a single \u003ccode\u003eprint\u003c/code\u003e that\n            takes an opaque pointer and runtime parameter describing the type of\n            the value (its fields and offsets). So let’s roll our own runtime\n            type information. For our example, we support ints, strings, and\n            structs with fields. For fields, our RTTI should include their names\n            and offsets:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e RTTI = \u003cspan\u003eunion\u003c/span\u003e(\u003cspan\u003eenum\u003c/span\u003e) {\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003eu32\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e    string,\u003c/span\u003e\n\u003cspan\u003e    @\u003cspan\u003e\u0026#34;struct\u0026#34;\u003c/span\u003e: []\u003cspan\u003econst\u003c/span\u003e Field,\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003econst\u003c/span\u003e Field = \u003cspan\u003estruct\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e        name: []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e        offset: \u003cspan\u003eu32\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e        rtti: RTTI,\u003c/span\u003e\n\u003cspan\u003e    };\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            The printing itself is not particularly illuminating, we just need\n            to cast an opaque pointer according to RTTI:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e print_dyn\u003c/span\u003e(T: RTTI, value: \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e anyopaque) \u003cspan\u003evoid\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003eswitch\u003c/span\u003e (T) {\u003c/span\u003e\n\u003cspan\u003e        .\u003cspan\u003eu32\u003c/span\u003e =\u0026gt; {\u003c/span\u003e\n\u003cspan\u003e            \u003cspan\u003econst\u003c/span\u003e value_u32: \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu32\u003c/span\u003e =\u003c/span\u003e\n\u003cspan\u003e                \u003cspan\u003e@alignCast\u003c/span\u003e(\u003cspan\u003e@ptrCast\u003c/span\u003e(value));\u003c/span\u003e\n\u003cspan\u003e            print_u32(value_u32.\u003cspan\u003e*\u003c/span\u003e);\u003c/span\u003e\n\u003cspan\u003e        },\u003c/span\u003e\n\u003cspan\u003e        .string =\u0026gt; {\u003c/span\u003e\n\u003cspan\u003e            \u003cspan\u003econst\u003c/span\u003e value_string: \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e =\u003c/span\u003e\n\u003cspan\u003e                \u003cspan\u003e@alignCast\u003c/span\u003e(\u003cspan\u003e@ptrCast\u003c/span\u003e(value));\u003c/span\u003e\n\u003cspan\u003e            print_string(value_string.\u003cspan\u003e*\u003c/span\u003e);\u003c/span\u003e\n\u003cspan\u003e        },\u003c/span\u003e\n\u003cspan\u003e        .@\u003cspan\u003e\u0026#34;struct\u0026#34;\u003c/span\u003e =\u0026gt; \u003cspan\u003e|\u003c/span\u003einfo\u003cspan\u003e|\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e            print_literal(\u003cspan\u003e\u0026#34;{\u0026#34;\u003c/span\u003e);\u003c/span\u003e\n\u003cspan\u003e            \u003cspan\u003evar\u003c/span\u003e space: []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e = \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e            \u003cspan\u003efor\u003c/span\u003e (info) \u003cspan\u003e|\u003c/span\u003efield\u003cspan\u003e|\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e                print_literal(space);\u003c/span\u003e\n\u003cspan\u003e                space = \u003cspan\u003e\u0026#34;, \u0026#34;\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e                print_literal(field.name);\u003c/span\u003e\n\u003cspan\u003e                print_literal(\u003cspan\u003e\u0026#34; = \u0026#34;\u003c/span\u003e);\u003c/span\u003e\n\u003cspan\u003e                \u003cspan\u003econst\u003c/span\u003e field_ptr: \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e anyopaque =\u003c/span\u003e\n\u003cspan\u003e                    \u003cspan\u003e@as\u003c/span\u003e([\u003cspan\u003e*\u003c/span\u003e]\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e, \u003cspan\u003e@ptrCast\u003c/span\u003e(value)) \u003cspan\u003e+\u003c/span\u003e field.offset;\u003c/span\u003e\n\u003cspan\u003e                print_dyn(field.rtti, field_ptr);\u003c/span\u003e\n\u003cspan\u003e            }\u003c/span\u003e\n\u003cspan\u003e            print_literal(\u003cspan\u003e\u0026#34;}\u0026#34;\u003c/span\u003e);\u003c/span\u003e\n\u003cspan\u003e        },\u003c/span\u003e\n\u003cspan\u003e    }\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            Finally, we need to compute \u003ccode\u003eRTTI\u003c/code\u003e, which amounts to\n            taking comptime-only Zig type info and extracting important bits\n            into an \u003ccode\u003eRTTI\u003c/code\u003e struct which is computed at compile time,\n            but can exist at runtime as well:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e reflect\u003c/span\u003e(\u003cspan\u003ecomptime\u003c/span\u003e T: \u003cspan\u003etype\u003c/span\u003e) RTTI {\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003ecomptime\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e (T \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eu32\u003c/span\u003e) \u003cspan\u003ereturn\u003c/span\u003e .\u003cspan\u003eu32\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e (T \u003cspan\u003e==\u003c/span\u003e []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e) \u003cspan\u003ereturn\u003c/span\u003e .string;\u003c/span\u003e\n\u003cspan\u003e        \u003cspan\u003eswitch\u003c/span\u003e (\u003cspan\u003e@typeInfo\u003c/span\u003e(T)) {\u003c/span\u003e\n\u003cspan\u003e            .@\u003cspan\u003e\u0026#34;struct\u0026#34;\u003c/span\u003e =\u0026gt; \u003cspan\u003e|\u003c/span\u003einfo\u003cspan\u003e|\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e                \u003cspan\u003evar\u003c/span\u003e fields: [info.fields.len]Field = \u003cspan\u003eundefined\u003c/span\u003e;\u003c/span\u003e\n\u003cspan\u003e                \u003cspan\u003efor\u003c/span\u003e (\u003cspan\u003e\u0026amp;\u003c/span\u003efields, info.fields) \u003cspan\u003e|\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003eslot, field\u003cspan\u003e|\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e                    slot.\u003cspan\u003e*\u003c/span\u003e = .{\u003c/span\u003e\n\u003cspan\u003e                        .name = field.name,\u003c/span\u003e\n\u003cspan\u003e                        .offset = \u003cspan\u003e@offsetOf\u003c/span\u003e(T, field.name),\u003c/span\u003e\n\u003cspan\u003e                        .rtti = reflect(field.\u003cspan\u003etype\u003c/span\u003e),\u003c/span\u003e\n\u003cspan\u003e                    };\u003c/span\u003e\n\u003cspan\u003e                }\u003c/span\u003e\n\u003cspan\u003e                \u003cspan\u003econst\u003c/span\u003e fields_frozen = fields;\u003c/span\u003e\n\u003cspan\u003e                \u003cspan\u003ereturn\u003c/span\u003e .{ .@\u003cspan\u003e\u0026#34;struct\u0026#34;\u003c/span\u003e = \u003cspan\u003e\u0026amp;\u003c/span\u003efields_frozen };\u003c/span\u003e\n\u003cspan\u003e            },\u003c/span\u003e\n\u003cspan\u003e            \u003cspan\u003eelse\u003c/span\u003e =\u0026gt; \u003cspan\u003eunreachable\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e        }\u003c/span\u003e\n\u003cspan\u003e    }\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            The call site is illustrative: we need \u003ccode\u003ecomptime\u003c/code\u003e to \u003cem\u003ecompute\u003c/em\u003e the type information, but then we reify it as some\n            real bytes in the binary, and use it as runtime value when calling\n            \u003ccode\u003eprint_dyn\u003c/code\u003e.\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e main\u003c/span\u003e() \u003cspan\u003evoid\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003econst\u003c/span\u003e s: S = .{\u003c/span\u003e\n\u003cspan\u003e        .int = \u003cspan\u003e1\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e        .string = \u003cspan\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e        .nested = .{ .int = \u003cspan\u003e2\u003c/span\u003e },\u003c/span\u003e\n\u003cspan\u003e    };\u003c/span\u003e\n\u003cspan\u003e    print_dyn(\u003cspan\u003ecomptime\u003c/span\u003e RTTI.reflect(S), \u003cspan\u003e\u0026amp;\u003c/span\u003es);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n        \u003c/section\u003e\n        \u003csection id=\"No-New-API\"\u003e\n          \u003ch2\u003e\n            \u003ca href=\"#No-New-API\"\u003eNo New API \u003c/a\u003e\n          \u003c/h2\u003e\n          \u003cp\u003e\n            You can use Zig comptime to create new types. That’s how a \u003ca href=\"https://matklad.github.io/2025/03/19/comptime-zig-orm.html\"\u003eZig ORM\u003c/a\u003e can work. However, it is impossible to add methods to\n            generated types, they must be inert bundles of fields. In Rust, when\n            you use a derive macro, it can arbitrarily extend type’s public API,\n            and you need to read proc macro docs (or look at the generated code)\n            to figure out what’s available. In Zig, types’s API is always hand\n            written, but it can use comptime reflection internally.\n          \u003c/p\u003e\n          \u003cp\u003e\n            So, if you are building a JSON serialization library in Zig, you\n            can’t add \u003ccode\u003e.to_json\u003c/code\u003e method to user-types. You’ll\n            necessarily have to supply a normal top-level function like\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003efn\u003c/span\u003e\u003cspan\u003e to_json\u003c/span\u003e(\u003cspan\u003ecomptime\u003c/span\u003e T: \u003cspan\u003etype\u003c/span\u003e, value: T, writer: Writer) \u003cspan\u003e!\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    ...\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            If you want to make sure that types explicitly opt-in JSON\n            serialization, you need to ask the user to mark types specially:\n          \u003c/p\u003e\n\n          \u003cfigure\u003e\n            \u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e Person = \u003cspan\u003estruct\u003c/span\u003e {\u003c/span\u003e\n\u003cspan\u003e    first_name: []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e    last_name: []\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eu8\u003c/span\u003e,\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e    \u003cspan\u003epub\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e JSONOptions = .{\u003c/span\u003e\n\u003cspan\u003e        .style = .camelCase,\u003c/span\u003e\n\u003cspan\u003e    };\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n          \u003c/figure\u003e\n          \u003cp\u003e\n            With this setup, \u003ccode\u003eto_json\u003c/code\u003e can only allow primitives and\n            types with \u003ccode\u003eJSONOptions\u003c/code\u003e.\n          \u003c/p\u003e\n        \u003c/section\u003e\n        \u003csection id=\"No-IO\"\u003e\n          \u003ch2\u003e\n            \u003ca href=\"#No-IO\"\u003eNo IO \u003c/a\u003e\n          \u003c/h2\u003e\n          \u003cp\u003e\n            Last but not least, Zig comptime does not allow any kind of input\n            output. There isn’t even any kind of sandbox, as there are no IO\n            facilities in the first place. So, while compiling the code, you\n            can’t talk to your database to generate the schema. In exchange,\n            compile time evaluation is hermetic, reproducible, safe, and\n            cacheable.\n          \u003c/p\u003e\n          \u003cp\u003e\n            If you do need to talk to the database at build time, you can still\n            do that, just through the build system! Zig’s \u003ccode\u003ebuild.zig\u003c/code\u003e\n            is a general purpose build system, which easily supports the\n            use-case of running an arbitrary Zig program to generate arbitrary\n            Zig code which can then be normally\n            \u003ccode\u003e@import\u003c/code\u003eed.\n          \u003c/p\u003e\n        \u003c/section\u003e\n        \u003csection id=\"El-Disco\"\u003e\n          \u003ch2\u003e\n            \u003ca href=\"#El-Disco\"\u003eEl Disco \u003c/a\u003e\n          \u003c/h2\u003e\n          \u003cp\u003e\n            \u003ca href=\"https://www.tedinski.com/2018/01/30/the-one-ring-problem-abstraction-and-power.html\"\u003eAny abstraction has two sides\u003c/a\u003e. Powerful abstractions are useful\n            because they are more expressive. But the flip-side is that\n            abstraction-using code becomes harder to reason about, because the\n            space of what it can possibly do is so vast. This dependency is not\n            zero sum. A good abstraction can be simultaneously more powerful and\n            easier to reason about than a bad one.\n          \u003c/p\u003e\n          \u003cp\u003e\n            Meta programming is one of the more powerful abstractions. It is\n            very capable in Zig, and comes at a significant cost — Zig doesn’t\n            have declaration-site type checking of comptime code. That being\n            said, I personally find Zig’s approach to be uniquely tidy, elegant,\n            and neat! It does much less than alternative systems, but ends\n            extremely ergonomic in practice, and \u003cem\u003erelatively\u003c/em\u003e easy to\n            wrap ones head around.\n          \u003c/p\u003e\n        \u003c/section\u003e\n      \u003c/article\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": null,
  "modifiedTime": null
}
