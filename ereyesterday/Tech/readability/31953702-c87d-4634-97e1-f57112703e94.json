{
  "id": "31953702-c87d-4634-97e1-f57112703e94",
  "title": "C Plus Prolog",
  "link": "https://github.com/needleful/c_plus_prolog",
  "description": "Comments",
  "author": "",
  "published": "Thu, 13 Mar 2025 22:48:45 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "needleful",
  "length": 10117,
  "excerpt": "C plus Prolog. Contribute to needleful/c_plus_prolog development by creating an account on GitHub.",
  "siteName": "GitHub",
  "favicon": "https://github.com/fluidicon.png",
  "text": "C Plus Prolog Prolog is the only good programming language. I should know, my website is written in Prolog. Unfortunately, C is the only useful programming language. Scientists have been trying to find an answer to this problem for nearly 50 years. Some make their C more like Prolog. Others make their Prolog more like C. I offer a new solution: simply add Prolog and C together. I call it, “C Plus Prolog”, or “C+P” for short. :- include(stdio). int func main { puts(\"Hello, world!\"); return 0 }. If you're familiar with C, you'll notice this is some sort of weird, bad C. You're mistaken, however. This is valid Prolog, using some non-standard features of SWI-Prolog for the curly braces. This Prolog is read as a list of terms, and converted to valid C code. So this: int func main(int var argc, char:ptr:array var argv) Translates to this: int main(int argc, char*( argv[])) Beyond some obvious changes like var and func operators, which make the syntax expressible as Prolog, there are some unexpected quirks: Symbols starting with capital letters or underscores are for use with Prolog, and won't translate to C unless wrapped in single quotes: int:ptr var string = 'NULL'; '_Bool' var v = true; As a result of the above, character literals start with #: char var c = #c; % quotes not required for lowercase letters char var c2 = #'C'; char var nl = #'\\n'; Operator precedence was maintained for existing Prolog operators. For example, = and comparison operators like ==, \u003c, and \u003e have the same precedence, so you'll need parentheses where you wouldn't in C: This is also why the arrow operator -\u003e was replaced with @, since it's used in a completely different way in Prolog and has a completely different precedence. C+P: C: Complex type declarations are different. C-style declarations are perfectly expressible in Prolog, I just don't like them. Becomes It may also help you remember the difference between const char * and char const *: const(char):ptr, char:const(ptr) The examples provide a more complete picture of the syntax. In the end, it's C but more verbose and particular about semicolons. Not exactly a silver bullet. Let's introduce the *=\u003e operator. The *=\u003e Operator Take this snippet from example 04: max(A, B) *=\u003e A \u003e B then A else B. I said C+P does no processing beyond translating terms to C, but it does one small step. The compiler will gather all the terms defined with *=\u003e, and then substitute the left-hand for the right-hand in the rest of the code until no more rules apply. Because this operates on Prolog terms, not text, we don't need any extra parentheses in our max(A, B) macro to prevent mishaps with operator precedence. It's inserted into code as a single term, and looks exactly like a function call in use: float var f = max(12.3, 0) + 20; printf(\"Should be 32.3: %f\\n\", f);` It's converted to the following C: float f=(((12.3\u003e0) ? 12.3 : 0)+20); printf(\"Should be 32.3: %f\\n\", f); Also, I'm tired of adding \\n at the end of all my printf statements. Let's defined another macro, println: PrintLn *=\u003e PrintF :- PrintLn =.. [println,Format| Args], string_concat(Format, \"\\n\", Format2), PrintF =.. [printf,Format2| Args]. We have full access to Prolog at compile time using :-, allowing us to do just about anything. This macro gets any instance of println(Format, Args...) with a string literal Format, and converts it to printf with a newline appended to Format. Simple enough. Let's implement poor man's generics. Poor Man's Generics in C Plus Prolog Example 05 defines a generic type, list[T], using the following syntax: list[T] { struct list[T] { T:ptr:ptr var items }; % Let's also define syntax for type-specific functions, in this case “list[T]:capacity” size_t:ptr func list[T]:capacity(list[T] var this) { ... }; ... }. This will work similarly to C++ templates. For simplicity of implementation, we'll require the user to instantiate the template. declare(list[int]). declare(list[const(char):ptr]). We could probably do this automatically by scanning the code for any usage of list[T] and instantiating the template right above it, but I'll leave that as an exercise for the reader. We also have some syntax to get a function name with list[T]:Method: int func main { list[int] var my_ints = list[int]:new(17); size_t var size = *(list[int]:capacity(my_ints)); for(int var i = 0; i \u003c size; i += 1) { list[int]:append(my_ints, i*i) }; for(int var i = 0; i \u003c size; i+= 1) { printf(\"%d squared = %d.\\n\", i, list[int]:get(my_ints, i)) }; return 0 }. Not exactly C++, but it keeps the namespaces clear. Let's read the macro. It matches on our template as you might have expected: Name[T] {Body} *=\u003e Comment :- \\+ground(T), atom(Name), atom_concat('//Defined template type: ', Name, Comment), We have a template with a name Name, type parameterss T, and the body Body. The macro removes this code and inserts a comment. Everything else is handled in the Prolog world. assertz( declare(Name[Z]) *=\u003e NewBody By God. Our macro asserts another macro, declare(Name[Z]). It also has conditions: :- ( ground(Z), T=Z, Body=NewBody, Those three lines are the bulk of the macro. It unifies the template type T with the real (ground) type Z, then returns the body of the template. This is what turns declare(list[int]) into the code for the type. But that's not all it does, the macro we're asserting itself asserts more macros: ('*mangled_name'(Name[Z]) *=\u003e ZName), assertz(Name[Z] *=\u003e ZName), assertz((ZName:Method *=\u003e ZMethod :- % Crudely hacking some shorthand for method names Method \\= ptr, Method \\= array, ( atom(Method) -\u003e MName = Method, ZArgs = [] ; Method =.. [MName|ZArgs] ), ('*mangled_name'(ZName:MName) *=\u003e MZ_Name), ZMethod =.. [MZ_Name|ZArgs] )) )). This generates the C names for things like list[int] and list[int]:function. '*mangled_name' is just another macro, but this example is long enough and it's all in example 05. The * and single quotes are nothing special, they just prevent this macro from accidentally colliding with a user-defined mangled_name function. C+P provides no type information we could use for method syntax, to do something like my_list.append(...), instead of list[int]:append(my_list, ...). We could, of course, use macros to gather the types of every variable in a function body and swap out method calls for the appropriate function, but at a certain point I'm just writing a full-on XLang-to-C compiler in the macro system, which is an interesting idea, but I'm employed. I've provided several other examples of the wonders of C Plus Prolog: Example 06 overloads the struct keyword to add compile-time reflection. Example 08a compiles different code if the target file ends in .h or .c, to declare a typical header and implementation in a single file. I find it strangely compelling to write in C+P, adding features that sound impossible. It's like a puzzle game, which is why I reach for Prolog so frequently. Installation and Usage C Plus Prolog is easy to install. All you need is a C compiler, SWI-Prolog, and this repository. You can figure it out. Then you can run cpp.pl from this repository with the following syntax: swipl -s cpp.pl -- \u003cinput file\u003e \u003coutput file\u003e By convention, C Plus Prolog files end in the extension .c+p. Check test.sh and test.ps1 for more example usage, plus a fast way to run all the tests (which are probably not rootkits). What is the point of this? C Plus Prolog is a half-serious exploration of macros in a systems programming language. In the process of making this, it became clear I prefer the compile-time evaluation and reflection offered by languages like D and Zig over syntactic macros. Sure, with enough work you can do everything and more with the macro system, but what does it actually add over a separate code generator, or a DSL? A nicer interface, maybe. In Common Lisp, you have the full codebase at compile time, but the real value is recompiling code at runtime, not manipulating a list of lists that sort of looks like code, if you squint through all the backquotes and commas. Rust's procedural macros save maybe 40 lines of code, since you don't have to write your own tokenizer, but everything else is up to you and whatever libraries you want to bring in. Most of my metaprogramming wants involve reflecting on information the compiler already knows, like the types and annotations in the code, not the raw syntax tree. For a language-within-a-language, which syntactic macros are best at, I'd usually rather go the extra mile and make an entirely separate DSL with a purpose-built syntax, rather than contort the problem to, say, S expressions or Prolog terms. Despite that, C+P is dangerously close to being useful. The biggest advantage it has is the fact it generates plain C by default, allowing for performant cross-platform builds where less popular languages don't have support, or have to generate much more complicated C due to different abstractions. Prolog's been around for 50 years, as well. If the SWI-Prolog extensions were removed, swapping func F {Body} with func F =\u003e Body, for example, it could be built on a huge swath of hardware. But I wouldn't want to use it. There's absolutely no validation or error messaging, so any mistakes lead to broken C or silent failures. I thought using var as an operator would be nice, but it's a lot of visual noise. And if you thought C's semicolons were annoying, in C Plus Prolog, semicolons are operators. Having two in a row breaks things. Having one at the start breaks things. Having one at the end breaks things. If someone wanted to use C+P, there are many better alternatives. The Nim and Haxe languages can compile to C and/or C++, and they offer a good user experience out of the box, though I can't say how directly their code translates to C. cmacro offers a similar level of syntax manipulation to C+P in a nicer format, powered by Common Lisp. The D language Has compilers backed by GCC and LLVM, so it should work in most places C will. I don't know what the conclusion is.",
  "image": "https://opengraph.githubassets.com/c23df378a66d17cabaadc6a711cfa84fff44d8996c01e660cc27e25eccec7ad2/needleful/c_plus_prolog",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-hpc=\"true\"\u003e\u003carticle itemprop=\"text\"\u003e\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eC Plus Prolog\u003c/h2\u003e\u003ca id=\"user-content-c-plus-prolog\" aria-label=\"Permalink: C Plus Prolog\" href=\"#c-plus-prolog\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eProlog is the only good programming language. I should know, \u003ca href=\"https://needleful.net\" rel=\"nofollow\"\u003emy website\u003c/a\u003e is \u003ca href=\"https://github.com/needleful/nng\"\u003ewritten in Prolog\u003c/a\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eUnfortunately, C is the only useful programming language.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eScientists have been trying to find an answer to this problem for nearly 50 years. Some make their \u003ca href=\"https://doc.rust-lang.org/book/ch19-06-macros.html\" rel=\"nofollow\"\u003eC more like Prolog\u003c/a\u003e. Others make their \u003ca href=\"https://prescheme.org/\" rel=\"nofollow\"\u003eProlog more like C\u003c/a\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eI offer a new solution: simply add Prolog and C together. I call it, “C Plus Prolog”, or “C+P” for short.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\":- include(stdio).\n\nint func main\n{ \n\tputs(\u0026#34;Hello, world!\u0026#34;);\n\treturn 0\n}.\"\u003e\u003cpre\u003e:- include(\u003cspan\u003estdio\u003c/span\u003e)\u003cspan\u003e.\u003c/span\u003e\n\n\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\n{ \n\tputs(\u003cspan\u003e\u0026#34;Hello, world!\u0026#34;\u003c/span\u003e);\n\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\n}\u003cspan\u003e.\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eIf you\u0026#39;re familiar with C, you\u0026#39;ll notice this is some sort of weird, bad C. You\u0026#39;re mistaken, however. This is valid Prolog, using some \u003ca href=\"https://www.swi-prolog.org/pldoc/man?section=ext-blockop\" rel=\"nofollow\"\u003enon-standard features of SWI-Prolog\u003c/a\u003e for the curly braces.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThis Prolog is read as a list of terms, and converted to valid C code. So this:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"int func main(int var argc, char:ptr:array var argv)\"\u003e\u003cpre\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e main(\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eargc\u003c/span\u003e, \u003cspan\u003echar\u003c/span\u003e:\u003cspan\u003eptr\u003c/span\u003e:\u003cspan\u003earray\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eargv\u003c/span\u003e)\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eTranslates to this:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"int main(int argc, char*( argv[]))\"\u003e\u003cpre\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e(\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003eargc\u003c/span\u003e, \u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e( \u003cspan\u003eargv\u003c/span\u003e[]))\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eBeyond some obvious changes like \u003ccode\u003evar\u003c/code\u003e and \u003ccode\u003efunc\u003c/code\u003e operators, which make the syntax expressible as Prolog, there are some unexpected quirks:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eSymbols starting with capital letters or underscores are for use with Prolog, and won\u0026#39;t translate to C unless wrapped in single quotes:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"int:ptr var string = \u0026#39;NULL\u0026#39;;\n\u0026#39;_Bool\u0026#39; var v = true;\"\u003e\u003cpre\u003e\u003cspan\u003eint\u003c/span\u003e:\u003cspan\u003eptr\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003estring\u003c/span\u003e = \u003cspan\u003e\u0026#39;NULL\u0026#39;\u003c/span\u003e;\n\u003cspan\u003e\u0026#39;_Bool\u0026#39;\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ev\u003c/span\u003e = \u003cspan\u003etrue\u003c/span\u003e;\u003c/pre\u003e\u003c/div\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eAs a result of the above, character literals start with \u003ccode\u003e#\u003c/code\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"char var c = #c;    % quotes not required for lowercase letters\nchar var c2 = #\u0026#39;C\u0026#39;; \nchar var nl = #\u0026#39;\\n\u0026#39;;\"\u003e\u003cpre\u003e\u003cspan\u003echar\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e = #\u003cspan\u003ec\u003c/span\u003e;    % \u003cspan\u003equotes\u003c/span\u003e \u003cspan\u003enot\u003c/span\u003e \u003cspan\u003erequired\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003elowercase\u003c/span\u003e \u003cspan\u003eletters\u003c/span\u003e\n\u003cspan\u003echar\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ec2\u003c/span\u003e = #\u003cspan\u003e\u0026#39;C\u0026#39;\u003c/span\u003e; \n\u003cspan\u003echar\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003enl\u003c/span\u003e = #\u003cspan\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e;\u003c/pre\u003e\u003c/div\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eOperator precedence was maintained for existing Prolog operators. For example, \u003ccode\u003e=\u003c/code\u003e and comparison operators like \u003ccode\u003e==\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003c/code\u003e, and \u003ccode\u003e\u0026gt;\u003c/code\u003e have the same precedence, so you\u0026#39;ll need parentheses where you wouldn\u0026#39;t in C:\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp dir=\"auto\"\u003eThis is also why the arrow operator \u003ccode\u003e-\u0026gt;\u003c/code\u003e was replaced with \u003ccode\u003e@\u003c/code\u003e, since it\u0026#39;s used in a completely different way in Prolog and has a completely different precedence.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eC+P:\u003c/p\u003e\n\n\u003cp dir=\"auto\"\u003eC:\u003c/p\u003e\n\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eComplex type declarations are different. C-style declarations are perfectly expressible in Prolog, I just don\u0026#39;t like them.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp dir=\"auto\"\u003eBecomes\u003c/p\u003e\n\n\u003cp dir=\"auto\"\u003eIt may also help you remember the difference between \u003ccode\u003econst char *\u003c/code\u003e and \u003ccode\u003echar const *\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"const(char):ptr,\nchar:const(ptr)\"\u003e\u003cpre\u003e\u003cspan\u003econst\u003c/span\u003e(\u003cspan\u003echar\u003c/span\u003e):\u003cspan\u003eptr\u003c/span\u003e,\n\u003cspan\u003echar\u003c/span\u003e:const(\u003cspan\u003eptr\u003c/span\u003e)\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eThe examples provide a more complete picture of the syntax.\nIn the end, it\u0026#39;s C but more verbose and particular about semicolons. Not exactly a silver bullet.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eLet\u0026#39;s introduce the \u003ccode\u003e*=\u0026gt;\u003c/code\u003e operator.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eThe \u003ccode\u003e*=\u0026gt;\u003c/code\u003e Operator\u003c/h2\u003e\u003ca id=\"user-content-the--operator\" aria-label=\"Permalink: The *=\u0026gt; Operator\" href=\"#the--operator\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eTake this snippet from example 04:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"max(A, B) *=\u0026gt; A \u0026gt; B then A else B.\"\u003e\u003cpre\u003e\u003cspan\u003emax\u003c/span\u003e(\u003cspan\u003eA\u003c/span\u003e, \u003cspan\u003eB\u003c/span\u003e) *=\u0026gt; \u003cspan\u003eA\u003c/span\u003e \u0026gt; \u003cspan\u003eB\u003c/span\u003e \u003cspan\u003ethen\u003c/span\u003e \u003cspan\u003eA\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eB\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eI said C+P does no processing beyond translating terms to C, but it does one small step. The compiler will gather all the terms defined with \u003ccode\u003e*=\u0026gt;\u003c/code\u003e, and then substitute the left-hand for the right-hand in the rest of the code until no more rules apply.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eBecause this operates on Prolog terms, not text, we don\u0026#39;t need any extra parentheses in our \u003ccode\u003emax(A, B)\u003c/code\u003e macro to prevent mishaps with operator precedence. It\u0026#39;s inserted into code as a single term, and looks exactly like a function call in use:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"float var f = max(12.3, 0) + 20;\nprintf(\u0026#34;Should be 32.3: %f\\n\u0026#34;, f);`\"\u003e\u003cpre\u003e\u003cspan\u003efloat\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ef\u003c/span\u003e = max(\u003cspan\u003e12\u003c/span\u003e.\u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e0\u003c/span\u003e) + \u003cspan\u003e20\u003c/span\u003e;\nprintf(\u003cspan\u003e\u0026#34;Should be 32.3: %f\\n\u0026#34;\u003c/span\u003e, \u003cspan\u003ef\u003c/span\u003e);`\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eIt\u0026#39;s converted to the following C:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"float f=(((12.3\u0026gt;0) ? 12.3 : 0)+20);\nprintf(\u0026#34;Should be 32.3: %f\\n\u0026#34;, f);\"\u003e\u003cpre\u003e\u003cspan\u003efloat\u003c/span\u003e \u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e(((\u003cspan\u003e12.3\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e) ? \u003cspan\u003e12.3\u003c/span\u003e : \u003cspan\u003e0\u003c/span\u003e)\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e20\u003c/span\u003e);\n\u003cspan\u003eprintf\u003c/span\u003e(\u003cspan\u003e\u0026#34;Should be 32.3: %f\\n\u0026#34;\u003c/span\u003e, \u003cspan\u003ef\u003c/span\u003e);\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eAlso, I\u0026#39;m tired of adding \u003ccode\u003e\\n\u003c/code\u003e at the end of all my \u003ccode\u003eprintf\u003c/code\u003e statements. Let\u0026#39;s defined another macro, \u003ccode\u003eprintln\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"PrintLn *=\u0026gt; PrintF :-\n\tPrintLn =.. [println,Format| Args],\n\tstring_concat(Format, \u0026#34;\\n\u0026#34;, Format2),\n\tPrintF =.. [printf,Format2| Args].\"\u003e\u003cpre\u003ePrintLn *=\u0026gt; PrintF :-\n\t\u003cspan\u003ePrintLn\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e. [println,Format| Args],\n\t\u003cspan\u003estring_concat\u003c/span\u003e(\u003cspan\u003eFormat\u003c/span\u003e, \u003cspan\u003e\u0026#34;\\n\u0026#34;\u003c/span\u003e, \u003cspan\u003eFormat2\u003c/span\u003e),\n\t\u003cspan\u003ePrintF\u003c/span\u003e =\u003cspan\u003e.\u003c/span\u003e. [printf,Format2| Args].\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eWe have full access to Prolog at compile time using \u003ccode\u003e:-\u003c/code\u003e, allowing us to do just about anything.\nThis macro gets any instance of \u003ccode\u003eprintln(Format, Args...)\u003c/code\u003e with a string literal \u003ccode\u003eFormat\u003c/code\u003e, and converts it to \u003ccode\u003eprintf\u003c/code\u003e with a newline appended to \u003ccode\u003eFormat\u003c/code\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eSimple enough. Let\u0026#39;s implement poor man\u0026#39;s generics.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003ePoor Man\u0026#39;s Generics in C Plus Prolog\u003c/h2\u003e\u003ca id=\"user-content-poor-mans-generics-in-c-plus-prolog\" aria-label=\"Permalink: Poor Man\u0026#39;s Generics in C Plus Prolog\" href=\"#poor-mans-generics-in-c-plus-prolog\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eExample 05 defines a generic type, \u003ccode\u003elist[T]\u003c/code\u003e, using the following syntax:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"list[T]\n{\n\tstruct list[T] {\n\t\tT:ptr:ptr var items\n\t};\n\n\t% Let\u0026#39;s also define syntax for type-specific functions, in this case “list[T]:capacity”\n\tsize_t:ptr func list[T]:capacity(list[T] var this)\n\t{\n\t\t...\n\t};\n\t...\n}.\"\u003e\u003cpre\u003e\u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eT\u003c/span\u003e]\n{\n\t\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eT\u003c/span\u003e] {\n\t\t\u003cspan\u003eT\u003c/span\u003e:\u003cspan\u003eptr\u003c/span\u003e:\u003cspan\u003eptr\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eitems\u003c/span\u003e\n\t};\n\n\t% \u003cspan\u003eLet\u003c/span\u003e\u0026#39;\u003cspan\u003es\u003c/span\u003e \u003cspan\u003ealso\u003c/span\u003e \u003cspan\u003edefine\u003c/span\u003e \u003cspan\u003esyntax\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003etype\u003c/span\u003e-\u003cspan\u003especific\u003c/span\u003e \u003cspan\u003efunctions\u003c/span\u003e, \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e \u003cspan\u003ecase\u003c/span\u003e “\u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eT\u003c/span\u003e]:\u003cspan\u003ecapacity\u003c/span\u003e”\n\t\u003cspan\u003esize_t\u003c/span\u003e:\u003cspan\u003eptr\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eT\u003c/span\u003e]:capacity(\u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eT\u003c/span\u003e] \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e)\n\t{\n\t\t\u003cspan\u003e.\u003c/span\u003e..\n\t};\n\t...\n}.\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eThis will work similarly to C++ templates.\nFor simplicity of implementation, we\u0026#39;ll require the user to instantiate the template.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"declare(list[int]).\ndeclare(list[const(char):ptr]).\"\u003e\u003cpre\u003e\u003cspan\u003edeclare\u003c/span\u003e(\u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eint\u003c/span\u003e])\u003cspan\u003e.\u003c/span\u003e\n\u003cspan\u003edeclare\u003c/span\u003e(\u003cspan\u003elist\u003c/span\u003e[const(\u003cspan\u003echar\u003c/span\u003e):\u003cspan\u003eptr\u003c/span\u003e])\u003cspan\u003e.\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eWe could probably do this automatically by scanning the code for any usage of \u003ccode\u003elist[T]\u003c/code\u003e and instantiating the template right above it, but I\u0026#39;ll leave that as an exercise for the reader.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWe also have some syntax to get a function name with \u003ccode\u003elist[T]:Method\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"int func main {\n\tlist[int] var my_ints = list[int]:new(17);\n\n\tsize_t var size = *(list[int]:capacity(my_ints));\n\tfor(int var i = 0; i \u0026lt; size; i += 1)\n\t{\n\t\tlist[int]:append(my_ints, i*i)\n\t};\n\tfor(int var i = 0; i \u0026lt; size; i+= 1)\n\t{\n\t\tprintf(\u0026#34;%d squared = %d.\\n\u0026#34;, i, list[int]:get(my_ints, i))\n\t};\n\treturn 0\n}.\"\u003e\u003cpre\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e {\n\t\u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eint\u003c/span\u003e] \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003emy_ints\u003c/span\u003e = \u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eint\u003c/span\u003e]:new(\u003cspan\u003e17\u003c/span\u003e);\n\n\t\u003cspan\u003esize_t\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e = *(\u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eint\u003c/span\u003e]:capacity(\u003cspan\u003emy_ints\u003c/span\u003e));\n\tfor(\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e = \u003cspan\u003e0\u003c/span\u003e; \u003cspan\u003ei\u003c/span\u003e \u0026lt; \u003cspan\u003esize\u003c/span\u003e; \u003cspan\u003ei\u003c/span\u003e += \u003cspan\u003e1\u003c/span\u003e)\n\t{\n\t\t\u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eint\u003c/span\u003e]:append(\u003cspan\u003emy_ints\u003c/span\u003e, \u003cspan\u003ei\u003c/span\u003e*\u003cspan\u003ei\u003c/span\u003e)\n\t};\n\tfor(\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e = \u003cspan\u003e0\u003c/span\u003e; \u003cspan\u003ei\u003c/span\u003e \u0026lt; \u003cspan\u003esize\u003c/span\u003e; \u003cspan\u003ei\u003c/span\u003e+= \u003cspan\u003e1\u003c/span\u003e)\n\t{\n\t\tprintf(\u003cspan\u003e\u0026#34;%d squared = %d.\\n\u0026#34;\u003c/span\u003e, \u003cspan\u003ei\u003c/span\u003e, \u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eint\u003c/span\u003e]:get(\u003cspan\u003emy_ints\u003c/span\u003e, \u003cspan\u003ei\u003c/span\u003e))\n\t};\n\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\n}\u003cspan\u003e.\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eNot exactly C++, but it keeps the namespaces clear.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eLet\u0026#39;s read the macro.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eIt matches on our template as you might have expected:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"Name[T] {Body} *=\u0026gt; Comment :-\n\t\\+ground(T), atom(Name),\n\tatom_concat(\u0026#39;//Defined template type: \u0026#39;, Name, Comment),\"\u003e\u003cpre\u003eName[T] {Body} *=\u0026gt; Comment :-\n\t\u003cspan\u003e\\+\u003c/span\u003eground(\u003cspan\u003eT\u003c/span\u003e), atom(\u003cspan\u003eName\u003c/span\u003e),\n\tatom_concat(\u003cspan\u003e\u0026#39;//Defined template type: \u0026#39;\u003c/span\u003e, \u003cspan\u003eName\u003c/span\u003e, \u003cspan\u003eComment\u003c/span\u003e),\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eWe have a template with a name \u003ccode\u003eName\u003c/code\u003e, type parameterss \u003ccode\u003eT\u003c/code\u003e, and the body \u003ccode\u003eBody\u003c/code\u003e.\nThe macro removes this code and inserts a comment. Everything else is handled in the Prolog world.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"\tassertz(\n\t\tdeclare(Name[Z]) *=\u0026gt; NewBody\"\u003e\u003cpre\u003e\t\u003cspan\u003eassertz\u003c/span\u003e(\n\t\tdeclare(\u003cspan\u003eName\u003c/span\u003e[\u003cspan\u003eZ\u003c/span\u003e]) *=\u0026gt; \u003cspan\u003eNewBody\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eBy God. Our macro \u003ccode\u003eassert\u003c/code\u003es another macro, \u003ccode\u003edeclare(Name[Z])\u003c/code\u003e. It also has conditions:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"\t\t:- (\n\t\t\tground(Z),\n\t\t\tT=Z,\n\t\t\tBody=NewBody,\"\u003e\u003cpre\u003e\t\t:- (\n\t\t\tground(\u003cspan\u003eZ\u003c/span\u003e),\n\t\t\t\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eZ\u003c/span\u003e,\n\t\t\t\u003cspan\u003eBody\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eNewBody\u003c/span\u003e,\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eThose three lines are the bulk of the macro. It unifies the template type \u003ccode\u003eT\u003c/code\u003e with the real (ground) type \u003ccode\u003eZ\u003c/code\u003e, then returns the body of the template. This is what turns \u003ccode\u003edeclare(list[int])\u003c/code\u003e into the code for the type.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eBut that\u0026#39;s not all it does, the macro we\u0026#39;re asserting itself asserts more macros:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"\t\t\t(\u0026#39;*mangled_name\u0026#39;(Name[Z]) *=\u0026gt; ZName),\n\t\t\tassertz(Name[Z] *=\u0026gt; ZName),\n\t\t\tassertz((ZName:Method *=\u0026gt; ZMethod :-\n\t\t\t\t% Crudely hacking some shorthand for method names\n\t\t\t\tMethod \\= ptr, Method \\= array,\n\t\t\t\t(\tatom(Method)\n\t\t\t\t-\u0026gt;\tMName = Method,\n\t\t\t\t\tZArgs = []\n\t\t\t\t;\tMethod =.. [MName|ZArgs]\n\t\t\t\t),\n\t\t\t\t(\u0026#39;*mangled_name\u0026#39;(ZName:MName) *=\u0026gt; MZ_Name),\n\t\t\t\tZMethod =.. [MZ_Name|ZArgs]\n\t\t\t))\n\t\t)).\"\u003e\u003cpre\u003e\t\t\t(\u0026#39;*mangled_name\u0026#39;(Name[Z]) *=\u0026gt; ZName),\n\t\t\t\u003cspan\u003eassertz\u003c/span\u003e(\u003cspan\u003eName\u003c/span\u003e[\u003cspan\u003eZ\u003c/span\u003e] *=\u0026gt; \u003cspan\u003eZName\u003c/span\u003e),\n\t\t\tassertz((\u003cspan\u003eZName\u003c/span\u003e:\u003cspan\u003eMethod\u003c/span\u003e *=\u0026gt; \u003cspan\u003eZMethod\u003c/span\u003e :-\n\t\t\t\t% \u003cspan\u003eCrudely\u003c/span\u003e \u003cspan\u003ehacking\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eshorthand\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003emethod\u003c/span\u003e \u003cspan\u003enames\u003c/span\u003e\n\t\t\t\t\u003cspan\u003eMethod\u003c/span\u003e \\= \u003cspan\u003eptr\u003c/span\u003e, \u003cspan\u003eMethod\u003c/span\u003e \\= \u003cspan\u003earray\u003c/span\u003e,\n\t\t\t\t(\tatom(\u003cspan\u003eMethod\u003c/span\u003e)\n\t\t\t\t-\u0026gt;\t\u003cspan\u003eMName\u003c/span\u003e = \u003cspan\u003eMethod\u003c/span\u003e,\n\t\t\t\t\t\u003cspan\u003eZArgs\u003c/span\u003e = \u003cspan\u003e[]\u003c/span\u003e\n\t\t\t\t;\t\u003cspan\u003eMethod\u003c/span\u003e =\u003cspan\u003e.\u003c/span\u003e. [MName|ZArgs]\n\t\t\t\t),\n\t\t\t\t(\u0026#39;*mangled_name\u0026#39;(ZName:MName) *=\u0026gt; MZ_Name),\n\t\t\t\t\u003cspan\u003eZMethod\u003c/span\u003e =\u003cspan\u003e.\u003c/span\u003e. [MZ_Name|ZArgs]\n\t\t\t))\n\t\t)).\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eThis generates the C names for things like \u003ccode\u003elist[int]\u003c/code\u003e and \u003ccode\u003elist[int]:function\u003c/code\u003e. \u003ccode\u003e\u0026#39;*mangled_name\u0026#39;\u003c/code\u003e is just another macro, but this example is long enough and it\u0026#39;s all in example 05. The \u003ccode\u003e*\u003c/code\u003e and single quotes are nothing special, they just prevent this macro from accidentally colliding with a user-defined \u003ccode\u003emangled_name\u003c/code\u003e function.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eC+P provides no type information we could use for method syntax, to do something like \u003ccode\u003emy_list.append(...)\u003c/code\u003e, instead of \u003ccode\u003elist[int]:append(my_list, ...)\u003c/code\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWe could, of course, use macros to gather the types of every variable in a function body and swap out method calls for the appropriate function, but at a certain point I\u0026#39;m just writing a full-on XLang-to-C compiler in the macro system, which is an interesting idea, but I\u0026#39;m employed.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eI\u0026#39;ve provided several other examples of the wonders of C Plus Prolog:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eExample 06 overloads the \u003ccode\u003estruct\u003c/code\u003e keyword to add compile-time reflection.\u003c/li\u003e\n\u003cli\u003eExample 08a compiles different code if the target file ends in \u003ccode\u003e.h\u003c/code\u003e or \u003ccode\u003e.c\u003c/code\u003e, to declare a typical header and implementation in a single file.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003eI find it strangely compelling to write in C+P, adding features that sound impossible. It\u0026#39;s like a puzzle game, which is why I reach for Prolog so frequently.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eInstallation and Usage\u003c/h2\u003e\u003ca id=\"user-content-installation-and-usage\" aria-label=\"Permalink: Installation and Usage\" href=\"#installation-and-usage\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eC Plus Prolog is easy to install. All you need is a C compiler, SWI-Prolog, and this repository. You can figure it out.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThen you can run \u003ccode\u003ecpp.pl\u003c/code\u003e from this repository with the following syntax:\n\u003ccode\u003eswipl -s cpp.pl -- \u0026lt;input file\u0026gt; \u0026lt;output file\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eBy convention, C Plus Prolog files end in the extension \u003ccode\u003e.c+p\u003c/code\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eCheck \u003ccode\u003etest.sh\u003c/code\u003e and \u003ccode\u003etest.ps1\u003c/code\u003e for more example usage, plus a fast way to run all the tests (which are probably not rootkits).\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eWhat is the point of this?\u003c/h2\u003e\u003ca id=\"user-content-what-is-the-point-of-this\" aria-label=\"Permalink: What is the point of this?\" href=\"#what-is-the-point-of-this\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eC Plus Prolog is a half-serious exploration of macros in a systems programming language.\nIn the process of making this, it became clear I prefer the compile-time evaluation and reflection offered by languages like D and Zig over syntactic macros.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eSure, with enough work you can do everything and more with the macro system, but what does it actually \u003cem\u003eadd\u003c/em\u003e over a separate code generator, or a DSL? A nicer interface, maybe.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eIn Common Lisp, you have the full codebase at compile time, but the real value is recompiling code at runtime, not manipulating a list of lists that sort of looks like code, if you squint through all the backquotes and commas.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eRust\u0026#39;s procedural macros save maybe 40 lines of code, since you don\u0026#39;t have to write your own tokenizer, but everything else is up to you and whatever libraries you want to bring in.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eMost of my metaprogramming wants involve reflecting on information the compiler already knows, like the types and annotations in the code, not the raw syntax tree.  For a language-within-a-language, which syntactic macros are best at, I\u0026#39;d usually rather go the extra mile and make an entirely separate DSL with a purpose-built syntax, rather than contort the problem to, say, S expressions or Prolog terms.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eDespite that, C+P is dangerously close to being useful.\nThe biggest advantage it has is the fact it generates plain C by default, allowing for performant cross-platform builds where less popular languages don\u0026#39;t have support, or have to generate much more complicated C due to different abstractions.\nProlog\u0026#39;s been around for 50 years, as well. If the SWI-Prolog extensions were removed, swapping \u003ccode\u003efunc F {Body}\u003c/code\u003e with \u003ccode\u003efunc F =\u0026gt; Body\u003c/code\u003e, for example, it could be built on a huge swath of hardware.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eBut I wouldn\u0026#39;t want to use it. There\u0026#39;s absolutely no validation or error messaging, so any mistakes lead to broken C or silent failures. I thought using \u003ccode\u003evar\u003c/code\u003e as an operator would be nice, but it\u0026#39;s a lot of visual noise.  And if you thought C\u0026#39;s semicolons were annoying, in C Plus Prolog, semicolons are operators. Having two in a row breaks things. Having one at the start breaks things. Having one at the \u003cem\u003eend\u003c/em\u003e breaks things.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eIf someone wanted to use C+P, there are many better alternatives.\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eThe \u003ca href=\"https://nim-lang.org/\" rel=\"nofollow\"\u003eNim\u003c/a\u003e and \u003ca href=\"https://haxe.org/\" rel=\"nofollow\"\u003eHaxe\u003c/a\u003e languages can compile to C and/or C++, and they offer a good user experience out of the box, though I can\u0026#39;t say how directly their code translates to C.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/eudoxia0/cmacro\"\u003ecmacro\u003c/a\u003e offers a similar level of syntax manipulation to C+P in a nicer format, powered by Common Lisp.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dlang.org/\" rel=\"nofollow\"\u003eThe D language\u003c/a\u003e Has compilers backed by GCC and LLVM, so it should work in most places C will.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003eI don\u0026#39;t know what the conclusion is.\u003c/p\u003e\n\u003c/article\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": null,
  "modifiedTime": null
}
