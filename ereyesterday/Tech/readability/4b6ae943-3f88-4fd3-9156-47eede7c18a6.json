{
  "id": "4b6ae943-3f88-4fd3-9156-47eede7c18a6",
  "title": "F-Droid Fake Signer PoC",
  "link": "https://github.com/obfusk/fdroid-fakesigner-poc",
  "description": "Comments",
  "author": "",
  "published": "Fri, 03 Jan 2025 22:47:11 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "obfusk",
  "length": 16033,
  "excerpt": "F-Droid Fake Signer PoC. Contribute to obfusk/fdroid-fakesigner-poc development by creating an account on GitHub.",
  "siteName": "GitHub",
  "favicon": "https://github.com/fluidicon.png",
  "text": "F-Droid Fake Signer PoC PoC for fdroidserver AllowedAPKSigningKeys certificate pinning bypass. Published: 2024-04-08; updated: 2024-04-14, 2024-04-20, 2024-12-30. oss-security https://www.openwall.com/lists/oss-security/2024/04/08/8 https://www.openwall.com/lists/oss-security/2024/04/20/3 https://www.openwall.com/lists/oss-security/2025/01/03/1 Background We started looking into Android APK Signing Block oddities at the request of F-Droid [1] on 2021-08-25; we opened F-Droid issue \"APK Signing Block considerations\" [2] on 2022-10-19. No action was taken as a result. We published the \"Android APK Signing Block Payload PoC\" [3] to the Reproducible Builds mailing list [4] on 2023-01-31. But the Android APK Signature Scheme v2/v3 actually allows embedding arbitrary data (or code) in the signing block, meaning that two APKs with the exact same valid signature -- though not a bit-by-bit identical signing block -- can behave differently. Jason Donenfeld reported \"Potential security hazard: apk_signer_fingerprint() looks at certs in reverse order that Android checks them\" [5] on 2023-05-05; no action was taken to fix this bug. However, there's a discrepancy between how these certificates are extracted and how Android actually implements signature checks. [...] Notice how [the google flowchart [6]] checks v3, then v2, and then v1. Yet the [F-Droid] code above looks at v1, then v2, and then v3, in reverse order. So v1 could have a bogus signer that some versions of Android never even look at, yet fdroid makes a security decision based on it. Yikes! Also, it's worth noting that apk_signer_fingerprint() also does not bother validating that the signatures are correct. Andreas Itzchak Rehberg (IzzyOnDroid) reported about \"BLOBs in APK signing blocks\" in \"Ramping up security: additional APK checks are in place with the IzzyOnDroid repo\" [7] on 2024-03-25. The accompanying German article \"Android-Apps auf dem Seziertisch: Eine vertiefte Betrachtung\" [8] points out that we noticed that apksigner and androguard handle duplicate signing blocks rather differently: the former only sees the first, the latter only the last, which allows all kinds of shenanigans. Observations We observed that embedding a v1 (JAR) signature file in an APK with minSdk \u003e= 24 will be ignored by Android/apksigner, which only checks v2/v3 in that case. However, since fdroidserver checks v1 first, regardless of minSdk, and does not verify the signature, it will accept a \"fake\" certificate and see an incorrect certificate fingerprint. We also realised that the above mentioned discrepancy between apksigner and androguard (which fdroidserver uses to extract the v2/v3 certificates) can be abused here as well. Simply copying the v2/v3 signature from a different APK and appending it to the APK Signing Block will not affect apksigner's verification, but androguard, and thus also fdroidserver, will see only the second block. Again, the signature is not verified, a \"fake\" certificate accepted, and an incorrect fingerprint seen. As a result, it is trivial to bypass the AllowedAPKSigningKeys certificate pinning, as we can make fdroidserver see whatever certificate we want instead of the one Android/apksigner does. Note that we don't need a valid signature for the APK (we really only need a copy of the DER certificate, though having another APK signed with the certificate we want to use makes things easy). Update (2024-04-14) Having been asked about multiple certificates in APK signatures [5], we realised that, like v2/v3 signatures, v1 signatures can indeed also contain multiple certificates (e.g. a certificate chain, though neither jarsigner nor apksigner seem to enforce any relationships between certificates). However, unlike v2/v3 -- which guarantee that the certificate used for the signature is always the first in the sequence -- v1 does not define an ordering: the signature block file is a PKCS#7 DER-encoded ASN.1 data structure (per RFC 2315) and uses a SET for the list of certificates. Android/apksigner will find and use the first certificate that matches the relevant SignerInfo, ignoring any other certificates, but fdroidserver always returns the first certificate it finds in the signature block file. Thus we can once again trick it into seeing any certificate we want -- as long as it only checks the v1 certificate (e.g. when the fdroidserver.patch has not been applied or the APK only has a v1 signature). NB: apps with targetSdk \u003e= 30 are required to have a v2/v3 signature. NB: Android \u003c N will only check the first SignerInfo, later versions pick the first one that verifies if there are multiple. Update (2024-04-20) Despite repeated warnings [5] that using the last certificate instead of the first one does not in any way fix the vulnerability described in the 2024-04-14 update (PoC #3), the proposed patches for fdroidserver [10] and androguard [11] do exactly this. With that patch, version A (which inserts the fake certificate first) of the PoC now fails, but version B (which inserts it last) now works. Update (2024-12-30 #1) Instead of adopting the fixes we proposed, F-Droid wrote and merged their own patch [10], ignoring repeated warnings it had significant flaws (including an incorrect implementation of v1 signature verification and making it impossible to have APKs with rotated keys in a repository). As a result it is possible to construct a valid v1 signature that fdroidserver matches to the wrong certificate. We do this by simply creating and prepending a second SignerInfo using our own certificate, which has the same serial number and an almost identical issuer -- e.g. a common name with a space (0x20) replaced by a tab (0x09) or a DEL (0x7f) appended -- to exploit an implementation that will match the SignerInfo against the wrong certificate through incorrect canonicalisation. Luckily, the impact is lower than that of the other vulnerabilities as it does require a valid signature from the certificate one wishes to spoof. Update (2024-12-30 #2) Unfortunately, we found another more severe vulnerability as well, caused by a regex incorrectly handling newlines in filenames. This allows another trivial bypass of certificate pinning, as we can once again make fdroidserver see whatever certificate we want instead of the one Android/apksigner does (as long as we have a valid v1 signature for some other APK). The regex in question, ^META-INF/.*\\.(DSA|EC|RSA)$, is supposed to match all filenames that start with META-INF/ and end with .DSA, .EC, or .RSA. Unfortunately, the .* does not match newlines, and the $ matches not just the end of the string but \"the end of the string or just before the newline at the end of the string\". As a result we can use a newline in the filename of the real signature files (before the extension), which Android/apksigner see but fdroidserver does not, and a newline after the .RSA extension for the spoofed signature files, which fdroidserver will see but Android/apksigner will not. NB: androguard seems to use a similarly incorrect regex. We can do almost the exact same thing with NUL bytes instead of newlines, independently of the flawed regex, because Python's ZipInfo.filename is sanitised by removing any NUL byte and everything after it. This will have the same result for fdroidserver and apksigner (which happily accepts NUL bytes in filenames) as above, but luckily Android rejects APKs with NUL bytes in filenames, and such an APK will thus fail to install. NB: in light of all of the above we reiterate that we strongly recommend using the official apksig library (used by apksigner) to both verify APK signatures and return the first signer's certificate to avoid these kind of implementation mistakes and inconsistencies and thus further vulnerabilities. Handling common cases correctly is fairly easy, but handling edge cases correctly is hard; rolling your own implementation without the required expertise and care to get it right is irresponsible. PoC NB: you currently need the signing branch of apksigtool [9]. NB: the \"fake\" signer shown here is from the official F-Droid client (its APK has a v1+v2+v3 signature), the one apksigner sees is randomly generated by make-key.sh; the app.apk used for testing had minSdk 26 and a v2 signature only. Using APKs with other signature scheme combinations is certainly possible, but might require adjusting the PoC code accordingly. $ ./make-key.sh # generates a dummy key $ python3 make-poc-v1.py # uses app.apk (needs minSdk \u003e= 24) as base, adds fake.apk .RSA $ python3 fdroid.py # verifies and has fake.apk as signer according to F-Droid True 43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab $ python3 make-poc-v2.py # uses app.apk as base, adds signing block from fake.apk $ python3 fdroid.py # verifies and has fake.apk as signer according to F-Droid True 43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab $ apksigner verify -v --print-certs poc.apk | grep -E '^Verified using|Signer #1 certificate (DN|SHA-256)' Verified using v1 scheme (JAR signing): false Verified using v2 scheme (APK Signature Scheme v2): true Verified using v3 scheme (APK Signature Scheme v3): true Verified using v4 scheme (APK Signature Scheme v4): false Signer #1 certificate DN: CN=oops Signer #1 certificate SHA-256 digest: 029df1354735e81eb97c9bbef2185c8ead3bc78ae874c03a6e96e1e1435ac519 $ mkdir fakesigner $ cd fakesigner $ fdroid init -d oops --repo-keyalias fakesigner $ mkdir metadata $ printf 'Name: MyApp\\nAllowedAPKSigningKeys: 43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\\n' \u003e metadata/some.app.id.yml $ cp /path/to/poc.apk repo/ $ fdroid update $ jq '.packages[].versions[].manifest.signer.sha256' \u003c repo/index-v2.json [ \"43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\" ] Update (2024-04-14) NB: version A, for fdroidserver using the first v1 certificate. $ python3 make-poc-v3a.py # uses app2.apk (needs targetSdk \u003c 30) as base, adds fake.apk .RSA cert $ python3 fdroid.py # verifies and has fake.apk as signer according to F-Droid True 43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab Update (2024-04-20) NB: version B, for fdroidserver using the last v1 certificate. $ python3 make-poc-v3b.py # uses app2.apk (needs targetSdk \u003c 30) as base, adds fake.apk .RSA cert $ python3 fdroid.py # verifies and has fake.apk as signer according to F-Droid True 43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab Update (2024-12-30 #1) NB: for convenience we generate our own key for the spoofed certificate as well; for a real exploit we'd have a v1-signed APK to use here instead of signing one ourselves. $ ./make-key-v4.sh # generates a dummy key $ sha256sum cert-rsa-fake.der cert-rsa-orig.der 29c6fc6cfa20c2726721944a659a4293c5ac7e8090ab5faa8e26f64ba007bea4 cert-rsa-fake.der 1e8a45fa677f82755b63edee209fee92081ba822d4f425c3792a1980bfa3fca9 cert-rsa-orig.der $ python3 make-poc-v4.py # uses app3.apk (needs minSdk \u003e= 24 \u0026 targetSdk \u003c 30) $ python3 fdroid.py # verifies and has the wrong signer according to F-Droid True ERROR:root:\"Signature is invalid\", skipping: 1e8a45fa677f82755b63edee209fee92081ba822d4f425c3792a1980bfa3fca9 Common Name: Foo Bar 1e8a45fa677f82755b63edee209fee92081ba822d4f425c3792a1980bfa3fca9 $ apksigner verify -v --print-certs poc.apk | grep -E '^Verified using|Signer #1 certificate (DN|SHA-256)' Verified using v1 scheme (JAR signing): true Verified using v2 scheme (APK Signature Scheme v2): false Verified using v3 scheme (APK Signature Scheme v3): false Verified using v4 scheme (APK Signature Scheme v4): false Signer #1 certificate DN: CN=Foo Bar Signer #1 certificate SHA-256 digest: 29c6fc6cfa20c2726721944a659a4293c5ac7e8090ab5faa8e26f64ba007bea4 Update (2024-12-30 #2) NB: version A uses newlines, version B NUL bytes (which makes it fail to actually install on Android devices despite verifying with apksigner). $ python3 make-poc-v5a.py # uses app3.apk (needs targetSdk \u003c 30) as base, adds fake.apk .RSA $ python3 fdroid.py # verifies and has fake.apk as signer according to F-Droid True 43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab $ python3 make-poc-v5b.py # uses app3.apk (needs targetSdk \u003c 30) as base, adds fake.apk .RSA $ python3 fdroid.py # verifies and has fake.apk as signer according to F-Droid True 43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab Patch The fdroidserver.patch changes the order so it matches Android's v3 before v2 before v1, and monkey-patches androguard to see the first block instead of the last one if there are duplicates. This is still likely to be incomplete, but prevents the known bypasses described here. Update (2024-04-14) The fdroidserver-multicert.patch simply rejects any v1 signatures with multiple certificates. This may reject some valid APKs, but handling those properly is nontrivial and there should be few APKs with multiple certificates and no v2/v3 signatures in the wild (e.g. the IzzyOnDroid repository found none in its catalog). We recommend using the official apksig library (used by apksigner) to both verify APK signatures and return the first signer's certificate to avoid these kind of implementation inconsistencies and thus further vulnerabilities like this one. Update (2024-12-30) The fdroidserver-regex.patch fixes the regex to correctly handle newlines. The fdroidserver-null-v1.patch (for fdroidserver before the changes we recommended against) and fdroidserver-null-v2.patch (for current fdroidserver) use ZipInfo.orig_filename to handle NUL bytes properly (and avoid other potential issues). Scanner (2024-04-15, 2024-04-20) The scan.py script can check APKs for possible signature issues: it will flag APKs that are not clearly signed with a single unambiguous certificate, which could result in the kind of accidental misidentification of the signer -- despite successful verification by apksigner -- that we've demonstrated here. Unfortunately, such misidentification can easily happen as even the official documentation of the various signature schemes does not completely cover how Android/apksigner handles such cases. NB: this will flag some valid APKs too, e.g. those with certificate chains, those having used key rotation, or those with multiple signers; as the IzzyOnDroid repository found none in its catalog, these cases luckily seem to be relatively rare. $ python3 scan.py poc*.apk 'poc1.apk': Mismatch between v1 and v2/v3 certificates 'poc2.apk': Duplicate block IDs 'poc3a.apk': Multiple certificates in signature block file 'poc3b.apk': Multiple certificates in signature block file Update (2024-12-30) The scan.py script has been updated to check for APK Signature Scheme v3.1 blocks (which will likely give false positives needing manual inspection as those are expected to differ with key rotation) as well as NUL/LF/CR in filenames and to use ZipInfo.orig_filename. NB: currently, neither fdroidserver nor androguard will see APK Signature Scheme v3.1 blocks. $ python3 scan.py poc[45]*.apk 'poc4.apk': Multiple certificates in signature block file 'poc5a.apk': NUL, LF, or CR in filename 'poc5b.apk': NUL, LF, or CR in filename References [1] https://salsa.debian.org/reproducible-builds/diffoscope/-/issues/246 [2] https://gitlab.com/fdroid/fdroidserver/-/issues/1056 [3] https://github.com/obfusk/sigblock-code-poc [4] https://lists.reproducible-builds.org/pipermail/rb-general/2023-January/002825.html [5] https://gitlab.com/fdroid/fdroidserver/-/issues/1128 [6] https://source.android.com/docs/security/features/apksigning/v3 [7] https://android.izzysoft.de/articles/named/iod-scan-apkchecks [8] https://www.kuketz-blog.de/android-apps-auf-dem-seziertisch-eine-vertiefte-betrachtung/ [9] https://github.com/obfusk/apksigtool [10] https://gitlab.com/fdroid/fdroidserver/-/merge_requests/1466 [11] androguard/androguard#1038 Links https://github.com/obfusk/apksigcopier",
  "image": "https://opengraph.githubassets.com/fec9aacad76c6008e52f660d3769ceafa5cef4020f8a78c315fbd7a4a25391b4/obfusk/fdroid-fakesigner-poc",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-hpc=\"true\"\u003e\u003carticle itemprop=\"text\"\u003e\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eF-Droid Fake Signer PoC\u003c/h2\u003e\u003ca id=\"user-content-f-droid-fake-signer-poc\" aria-label=\"Permalink: F-Droid Fake Signer PoC\" href=\"#f-droid-fake-signer-poc\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003ePoC for \u003ccode\u003efdroidserver\u003c/code\u003e \u003ccode\u003eAllowedAPKSigningKeys\u003c/code\u003e certificate pinning bypass.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003ePublished: 2024-04-08; updated: 2024-04-14, 2024-04-20, 2024-12-30.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eoss-security\u003c/h2\u003e\u003ca id=\"user-content-oss-security\" aria-label=\"Permalink: oss-security\" href=\"#oss-security\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e\u003ca href=\"https://www.openwall.com/lists/oss-security/2024/04/08/8\" rel=\"nofollow\"\u003ehttps://www.openwall.com/lists/oss-security/2024/04/08/8\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.openwall.com/lists/oss-security/2024/04/20/3\" rel=\"nofollow\"\u003ehttps://www.openwall.com/lists/oss-security/2024/04/20/3\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.openwall.com/lists/oss-security/2025/01/03/1\" rel=\"nofollow\"\u003ehttps://www.openwall.com/lists/oss-security/2025/01/03/1\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eBackground\u003c/h2\u003e\u003ca id=\"user-content-background\" aria-label=\"Permalink: Background\" href=\"#background\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWe started looking into Android APK Signing Block oddities at the request of\nF-Droid [1] on 2021-08-25; we opened F-Droid issue \u0026#34;APK Signing Block\nconsiderations\u0026#34; [2] on 2022-10-19.  No action was taken as a result.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWe published the \u0026#34;Android APK Signing Block Payload PoC\u0026#34; [3] to the Reproducible\nBuilds mailing list [4] on 2023-01-31.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003eBut the Android APK Signature Scheme v2/v3 actually allows embedding arbitrary\ndata (or code) in the signing block, meaning that two APKs with the exact same\nvalid signature -- though not a bit-by-bit identical signing block -- can\nbehave differently.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp dir=\"auto\"\u003eJason Donenfeld reported \u0026#34;Potential security hazard: \u003ccode\u003eapk_signer_fingerprint()\u003c/code\u003e\nlooks at certs in reverse order that Android checks them\u0026#34; [5] on 2023-05-05; no\naction was taken to fix this bug.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp dir=\"auto\"\u003eHowever, there\u0026#39;s a discrepancy between how these certificates are extracted\nand how Android actually implements signature checks. [...] Notice how [the\ngoogle flowchart [6]] checks v3, then v2, and then v1. Yet the [F-Droid] code\nabove looks at v1, then v2, and then v3, in reverse order. So v1 could have a\nbogus signer that some versions of Android never even look at, yet fdroid\nmakes a security decision based on it. Yikes! Also, it\u0026#39;s worth noting that\napk_signer_fingerprint() also does not bother validating that the signatures\nare correct.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp dir=\"auto\"\u003eAndreas Itzchak Rehberg (IzzyOnDroid) reported about \u0026#34;BLOBs in APK signing\nblocks\u0026#34; in \u0026#34;Ramping up security: additional APK checks are in place with the\nIzzyOnDroid repo\u0026#34; [7] on 2024-03-25.  The accompanying German article\n\u0026#34;Android-Apps auf dem Seziertisch: Eine vertiefte Betrachtung\u0026#34; [8] points out\nthat we noticed that \u003ccode\u003eapksigner\u003c/code\u003e and \u003ccode\u003eandroguard\u003c/code\u003e handle duplicate signing\nblocks rather differently: the former only sees the first, the latter only the\nlast, which allows all kinds of shenanigans.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eObservations\u003c/h2\u003e\u003ca id=\"user-content-observations\" aria-label=\"Permalink: Observations\" href=\"#observations\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWe observed that embedding a v1 (JAR) signature file in an APK with \u003ccode\u003eminSdk \u0026gt;= 24\u003c/code\u003e will be ignored by Android/\u003ccode\u003eapksigner\u003c/code\u003e, which only checks v2/v3 in that\ncase.  However, since \u003ccode\u003efdroidserver\u003c/code\u003e checks v1 first, regardless of \u003ccode\u003eminSdk\u003c/code\u003e,\nand does not verify the signature, it will accept a \u0026#34;fake\u0026#34; certificate and see\nan incorrect certificate fingerprint.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWe also realised that the above mentioned discrepancy between \u003ccode\u003eapksigner\u003c/code\u003e and\n\u003ccode\u003eandroguard\u003c/code\u003e (which \u003ccode\u003efdroidserver\u003c/code\u003e uses to extract the v2/v3 certificates) can\nbe abused here as well.  Simply copying the v2/v3 signature from a different APK\nand appending it to the APK Signing Block will not affect \u003ccode\u003eapksigner\u003c/code\u003e\u0026#39;s\nverification, but \u003ccode\u003eandroguard\u003c/code\u003e, and thus also \u003ccode\u003efdroidserver\u003c/code\u003e, will see only the\nsecond block.  Again, the signature is not verified, a \u0026#34;fake\u0026#34; certificate\naccepted, and an incorrect fingerprint seen.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eAs a result, it is trivial to bypass the \u003ccode\u003eAllowedAPKSigningKeys\u003c/code\u003e certificate\npinning, as we can make \u003ccode\u003efdroidserver\u003c/code\u003e see whatever certificate we want instead\nof the one Android/\u003ccode\u003eapksigner\u003c/code\u003e does.  Note that we don\u0026#39;t need a valid signature\nfor the APK (we really only need a copy of the DER certificate, though having\nanother APK signed with the certificate we want to use makes things easy).\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUpdate (2024-04-14)\u003c/h3\u003e\u003ca id=\"user-content-update-2024-04-14\" aria-label=\"Permalink: Update (2024-04-14)\" href=\"#update-2024-04-14\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eHaving been asked about multiple certificates in APK signatures [5], we realised\nthat, like v2/v3 signatures, v1 signatures can indeed also contain multiple\ncertificates (e.g. a certificate chain, though neither \u003ccode\u003ejarsigner\u003c/code\u003e nor\n\u003ccode\u003eapksigner\u003c/code\u003e seem to enforce any relationships between certificates).  However,\nunlike v2/v3 -- which guarantee that the certificate used for the signature is\nalways the first in the sequence -- v1 does not define an ordering: the\nsignature block file is a PKCS#7 DER-encoded ASN.1 data structure (per RFC 2315)\nand uses a SET for the list of certificates.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eAndroid/\u003ccode\u003eapksigner\u003c/code\u003e will find and use the first certificate that matches the\nrelevant \u003ccode\u003eSignerInfo\u003c/code\u003e, ignoring any other certificates, but \u003ccode\u003efdroidserver\u003c/code\u003e\nalways returns the first certificate it finds in the signature block file.  Thus\nwe can once again trick it into seeing any certificate we want -- as long as it\nonly checks the v1 certificate (e.g. when the \u003ccode\u003efdroidserver.patch\u003c/code\u003e has not been\napplied or the APK only has a v1 signature).\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: apps with \u003ccode\u003etargetSdk \u0026gt;= 30\u003c/code\u003e are required to have a v2/v3 signature.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: Android \u0026lt; N will only check the first \u003ccode\u003eSignerInfo\u003c/code\u003e, later versions pick the\nfirst one that verifies if there are multiple.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUpdate (2024-04-20)\u003c/h3\u003e\u003ca id=\"user-content-update-2024-04-20\" aria-label=\"Permalink: Update (2024-04-20)\" href=\"#update-2024-04-20\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eDespite repeated warnings [5] that using the last certificate instead of the\nfirst one does not in any way fix the vulnerability described in the 2024-04-14\nupdate (PoC #3), the proposed patches for \u003ccode\u003efdroidserver\u003c/code\u003e [10] and \u003ccode\u003eandroguard\u003c/code\u003e\n[11] do exactly this.  With that patch, version A (which inserts the fake\ncertificate first) of the PoC now fails, but version B (which inserts it last)\nnow works.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUpdate (2024-12-30 #1)\u003c/h3\u003e\u003ca id=\"user-content-update-2024-12-30-1\" aria-label=\"Permalink: Update (2024-12-30 #1)\" href=\"#update-2024-12-30-1\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eInstead of adopting the fixes we proposed, F-Droid wrote and merged their own\npatch [10], ignoring repeated warnings it had significant flaws (including an\nincorrect implementation of v1 signature verification and making it impossible\nto have APKs with rotated keys in a repository).  As a result it is possible to\nconstruct a valid v1 signature that \u003ccode\u003efdroidserver\u003c/code\u003e matches to the wrong\ncertificate.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWe do this by simply creating and prepending a second SignerInfo using our own\ncertificate, which has the same serial number and an almost identical issuer --\ne.g. a common name with a space (0x20) replaced by a tab (0x09) or a DEL (0x7f)\nappended -- to exploit an implementation that will match the SignerInfo against\nthe wrong certificate through incorrect canonicalisation.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eLuckily, the impact is lower than that of the other vulnerabilities as it does\nrequire a valid signature from the certificate one wishes to spoof.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUpdate (2024-12-30 #2)\u003c/h3\u003e\u003ca id=\"user-content-update-2024-12-30-2\" aria-label=\"Permalink: Update (2024-12-30 #2)\" href=\"#update-2024-12-30-2\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eUnfortunately, we found another more severe vulnerability as well, caused by a\nregex incorrectly handling newlines in filenames.  This allows another trivial\nbypass of certificate pinning, as we can once again make \u003ccode\u003efdroidserver\u003c/code\u003e see\nwhatever certificate we want instead of the one Android/\u003ccode\u003eapksigner\u003c/code\u003e does (as\nlong as we have a valid v1 signature for some other APK).\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe regex in question, \u003ccode\u003e^META-INF/.*\\.(DSA|EC|RSA)$\u003c/code\u003e, is supposed to match all\nfilenames that start with \u003ccode\u003eMETA-INF/\u003c/code\u003e and end with \u003ccode\u003e.DSA\u003c/code\u003e, \u003ccode\u003e.EC,\u003c/code\u003e or \u003ccode\u003e.RSA\u003c/code\u003e.\nUnfortunately, the \u003ccode\u003e.*\u003c/code\u003e does not match newlines, and the \u003ccode\u003e$\u003c/code\u003e matches not just\nthe end of the string but \u0026#34;the end of the string or just before the newline at\nthe end of the string\u0026#34;.  As a result we can use a newline in the filename of the\nreal signature files (before the extension), which Android/\u003ccode\u003eapksigner\u003c/code\u003e see but\n\u003ccode\u003efdroidserver\u003c/code\u003e does not, and a newline after the \u003ccode\u003e.RSA\u003c/code\u003e extension for the\nspoofed signature files, which \u003ccode\u003efdroidserver\u003c/code\u003e will see but Android/\u003ccode\u003eapksigner\u003c/code\u003e\nwill not.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: \u003ccode\u003eandroguard\u003c/code\u003e seems to use a similarly incorrect regex.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWe can do almost the exact same thing with NUL bytes instead of newlines,\nindependently of the flawed regex, because Python\u0026#39;s \u003ccode\u003eZipInfo.filename\u003c/code\u003e is\nsanitised by removing any NUL byte and everything after it.  This will have the\nsame result for \u003ccode\u003efdroidserver\u003c/code\u003e and \u003ccode\u003eapksigner\u003c/code\u003e (which happily accepts NUL bytes\nin filenames) as above, but luckily Android rejects APKs with NUL bytes in\nfilenames, and such an APK will thus fail to install.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: in light of all of the above we reiterate that we strongly recommend using\nthe official \u003ccode\u003eapksig\u003c/code\u003e library (used by \u003ccode\u003eapksigner\u003c/code\u003e) to both verify APK\nsignatures and return the first signer\u0026#39;s certificate to avoid these kind of\nimplementation mistakes and inconsistencies and thus further vulnerabilities.\nHandling common cases correctly is fairly easy, but handling edge cases\ncorrectly is hard; rolling your own implementation without the required\nexpertise and care to get it right is irresponsible.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003ePoC\u003c/h2\u003e\u003ca id=\"user-content-poc\" aria-label=\"Permalink: PoC\" href=\"#poc\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: you currently need the \u003ccode\u003esigning\u003c/code\u003e branch of \u003ccode\u003eapksigtool\u003c/code\u003e [9].\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: the \u0026#34;fake\u0026#34; signer shown here is from the official F-Droid client (its APK\nhas a v1+v2+v3 signature), the one \u003ccode\u003eapksigner\u003c/code\u003e sees is randomly generated by\n\u003ccode\u003emake-key.sh\u003c/code\u003e; the \u003ccode\u003eapp.apk\u003c/code\u003e used for testing had \u003ccode\u003eminSdk 26\u003c/code\u003e and a v2 signature\nonly.  Using APKs with other signature scheme combinations is certainly\npossible, but might require adjusting the PoC code accordingly.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"$ ./make-key.sh             # generates a dummy key\n$ python3 make-poc-v1.py    # uses app.apk (needs minSdk \u0026gt;= 24) as base, adds fake.apk .RSA\n$ python3 fdroid.py         # verifies and has fake.apk as signer according to F-Droid\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\n$ python3 make-poc-v2.py    # uses app.apk as base, adds signing block from fake.apk\n$ python3 fdroid.py         # verifies and has fake.apk as signer according to F-Droid\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\n$ apksigner verify -v --print-certs poc.apk | grep -E \u0026#39;^Verified using|Signer #1 certificate (DN|SHA-256)\u0026#39;\nVerified using v1 scheme (JAR signing): false\nVerified using v2 scheme (APK Signature Scheme v2): true\nVerified using v3 scheme (APK Signature Scheme v3): true\nVerified using v4 scheme (APK Signature Scheme v4): false\nSigner #1 certificate DN: CN=oops\nSigner #1 certificate SHA-256 digest: 029df1354735e81eb97c9bbef2185c8ead3bc78ae874c03a6e96e1e1435ac519\"\u003e\u003cpre\u003e$ ./make-key.sh             \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e generates a dummy key\u003c/span\u003e\n$ python3 make-poc-v1.py    \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e uses app.apk (needs minSdk \u0026gt;= 24) as base, adds fake.apk .RSA\u003c/span\u003e\n$ python3 fdroid.py         \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e verifies and has fake.apk as signer according to F-Droid\u003c/span\u003e\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\n$ python3 make-poc-v2.py    \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e uses app.apk as base, adds signing block from fake.apk\u003c/span\u003e\n$ python3 fdroid.py         \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e verifies and has fake.apk as signer according to F-Droid\u003c/span\u003e\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\n$ apksigner verify -v --print-certs poc.apk \u003cspan\u003e|\u003c/span\u003e grep -E \u003cspan\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e^Verified using|Signer #1 certificate (DN|SHA-256)\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e\nVerified using v1 scheme (JAR signing): \u003cspan\u003efalse\u003c/span\u003e\nVerified using v2 scheme (APK Signature Scheme v2): \u003cspan\u003etrue\u003c/span\u003e\nVerified using v3 scheme (APK Signature Scheme v3): \u003cspan\u003etrue\u003c/span\u003e\nVerified using v4 scheme (APK Signature Scheme v4): \u003cspan\u003efalse\u003c/span\u003e\nSigner \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e1 certificate DN: CN=oops\u003c/span\u003e\nSigner \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e1 certificate SHA-256 digest: 029df1354735e81eb97c9bbef2185c8ead3bc78ae874c03a6e96e1e1435ac519\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"$ mkdir fakesigner\n$ cd fakesigner\n$ fdroid init -d oops --repo-keyalias fakesigner\n$ mkdir metadata\n$ printf \u0026#39;Name: MyApp\\nAllowedAPKSigningKeys: 43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\\n\u0026#39; \u0026gt; metadata/some.app.id.yml\n$ cp /path/to/poc.apk repo/\n$ fdroid update\n$ jq \u0026#39;.packages[].versions[].manifest.signer.sha256\u0026#39; \u0026lt; repo/index-v2.json\n[\n  \u0026#34;43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\u0026#34;\n]\"\u003e\u003cpre\u003e$ mkdir fakesigner\n$ \u003cspan\u003ecd\u003c/span\u003e fakesigner\n$ fdroid init -d oops --repo-keyalias fakesigner\n$ mkdir metadata\n$ \u003cspan\u003eprintf\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003eName: MyApp\\nAllowedAPKSigningKeys: 43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\\n\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e metadata/some.app.id.yml\n$ cp /path/to/poc.apk repo/\n$ fdroid update\n$ jq \u003cspan\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e.packages[].versions[].manifest.signer.sha256\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e repo/index-v2.json\n[\n  \u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e\n]\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUpdate (2024-04-14)\u003c/h3\u003e\u003ca id=\"user-content-update-2024-04-14-1\" aria-label=\"Permalink: Update (2024-04-14)\" href=\"#update-2024-04-14-1\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: version A, for \u003ccode\u003efdroidserver\u003c/code\u003e using the first v1 certificate.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"$ python3 make-poc-v3a.py   # uses app2.apk (needs targetSdk \u0026lt; 30) as base, adds fake.apk .RSA cert\n$ python3 fdroid.py         # verifies and has fake.apk as signer according to F-Droid\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\"\u003e\u003cpre\u003e$ python3 make-poc-v3a.py   \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e uses app2.apk (needs targetSdk \u0026lt; 30) as base, adds fake.apk .RSA cert\u003c/span\u003e\n$ python3 fdroid.py         \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e verifies and has fake.apk as signer according to F-Droid\u003c/span\u003e\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUpdate (2024-04-20)\u003c/h3\u003e\u003ca id=\"user-content-update-2024-04-20-1\" aria-label=\"Permalink: Update (2024-04-20)\" href=\"#update-2024-04-20-1\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: version B, for \u003ccode\u003efdroidserver\u003c/code\u003e using the last v1 certificate.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"$ python3 make-poc-v3b.py   # uses app2.apk (needs targetSdk \u0026lt; 30) as base, adds fake.apk .RSA cert\n$ python3 fdroid.py         # verifies and has fake.apk as signer according to F-Droid\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\"\u003e\u003cpre\u003e$ python3 make-poc-v3b.py   \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e uses app2.apk (needs targetSdk \u0026lt; 30) as base, adds fake.apk .RSA cert\u003c/span\u003e\n$ python3 fdroid.py         \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e verifies and has fake.apk as signer according to F-Droid\u003c/span\u003e\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUpdate (2024-12-30 #1)\u003c/h3\u003e\u003ca id=\"user-content-update-2024-12-30-1-1\" aria-label=\"Permalink: Update (2024-12-30 #1)\" href=\"#update-2024-12-30-1-1\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: for convenience we generate our own key for the spoofed certificate as well;\nfor a real exploit we\u0026#39;d have a v1-signed APK to use here instead of signing one\nourselves.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"$ ./make-key-v4.sh          # generates a dummy key\n$ sha256sum cert-rsa-fake.der cert-rsa-orig.der\n29c6fc6cfa20c2726721944a659a4293c5ac7e8090ab5faa8e26f64ba007bea4  cert-rsa-fake.der\n1e8a45fa677f82755b63edee209fee92081ba822d4f425c3792a1980bfa3fca9  cert-rsa-orig.der\n$ python3 make-poc-v4.py    # uses app3.apk (needs minSdk \u0026gt;= 24 \u0026amp; targetSdk \u0026lt; 30)\n$ python3 fdroid.py         # verifies and has the wrong signer according to F-Droid\nTrue\nERROR:root:\u0026#34;Signature is invalid\u0026#34;, skipping:\n  1e8a45fa677f82755b63edee209fee92081ba822d4f425c3792a1980bfa3fca9\n  Common Name: Foo Bar\n1e8a45fa677f82755b63edee209fee92081ba822d4f425c3792a1980bfa3fca9\n$ apksigner verify -v --print-certs poc.apk | grep -E \u0026#39;^Verified using|Signer #1 certificate (DN|SHA-256)\u0026#39;\nVerified using v1 scheme (JAR signing): true\nVerified using v2 scheme (APK Signature Scheme v2): false\nVerified using v3 scheme (APK Signature Scheme v3): false\nVerified using v4 scheme (APK Signature Scheme v4): false\nSigner #1 certificate DN: CN=Foo        Bar\nSigner #1 certificate SHA-256 digest: 29c6fc6cfa20c2726721944a659a4293c5ac7e8090ab5faa8e26f64ba007bea4\"\u003e\u003cpre\u003e$ ./make-key-v4.sh          \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e generates a dummy key\u003c/span\u003e\n$ sha256sum cert-rsa-fake.der cert-rsa-orig.der\n29c6fc6cfa20c2726721944a659a4293c5ac7e8090ab5faa8e26f64ba007bea4  cert-rsa-fake.der\n1e8a45fa677f82755b63edee209fee92081ba822d4f425c3792a1980bfa3fca9  cert-rsa-orig.der\n$ python3 make-poc-v4.py    \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e uses app3.apk (needs minSdk \u0026gt;= 24 \u0026amp; targetSdk \u0026lt; 30)\u003c/span\u003e\n$ python3 fdroid.py         \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e verifies and has the wrong signer according to F-Droid\u003c/span\u003e\nTrue\nERROR:root:\u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eSignature is invalid\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e, skipping:\n  1e8a45fa677f82755b63edee209fee92081ba822d4f425c3792a1980bfa3fca9\n  Common Name: Foo Bar\n1e8a45fa677f82755b63edee209fee92081ba822d4f425c3792a1980bfa3fca9\n$ apksigner verify -v --print-certs poc.apk \u003cspan\u003e|\u003c/span\u003e grep -E \u003cspan\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e^Verified using|Signer #1 certificate (DN|SHA-256)\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e\nVerified using v1 scheme (JAR signing): \u003cspan\u003etrue\u003c/span\u003e\nVerified using v2 scheme (APK Signature Scheme v2): \u003cspan\u003efalse\u003c/span\u003e\nVerified using v3 scheme (APK Signature Scheme v3): \u003cspan\u003efalse\u003c/span\u003e\nVerified using v4 scheme (APK Signature Scheme v4): \u003cspan\u003efalse\u003c/span\u003e\nSigner \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e1 certificate DN: CN=Foo        Bar\u003c/span\u003e\nSigner \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e1 certificate SHA-256 digest: 29c6fc6cfa20c2726721944a659a4293c5ac7e8090ab5faa8e26f64ba007bea4\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUpdate (2024-12-30 #2)\u003c/h3\u003e\u003ca id=\"user-content-update-2024-12-30-2-1\" aria-label=\"Permalink: Update (2024-12-30 #2)\" href=\"#update-2024-12-30-2-1\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: version A uses newlines, version B NUL bytes (which makes it fail to\nactually install on Android devices despite verifying with \u003ccode\u003eapksigner\u003c/code\u003e).\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"$ python3 make-poc-v5a.py   # uses app3.apk (needs targetSdk \u0026lt; 30) as base, adds fake.apk .RSA\n$ python3 fdroid.py         # verifies and has fake.apk as signer according to F-Droid\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\"\u003e\u003cpre\u003e$ python3 make-poc-v5a.py   \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e uses app3.apk (needs targetSdk \u0026lt; 30) as base, adds fake.apk .RSA\u003c/span\u003e\n$ python3 fdroid.py         \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e verifies and has fake.apk as signer according to F-Droid\u003c/span\u003e\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"$ python3 make-poc-v5b.py   # uses app3.apk (needs targetSdk \u0026lt; 30) as base, adds fake.apk .RSA\n$ python3 fdroid.py         # verifies and has fake.apk as signer according to F-Droid\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\"\u003e\u003cpre\u003e$ python3 make-poc-v5b.py   \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e uses app3.apk (needs targetSdk \u0026lt; 30) as base, adds fake.apk .RSA\u003c/span\u003e\n$ python3 fdroid.py         \u003cspan\u003e\u003cspan\u003e#\u003c/span\u003e verifies and has fake.apk as signer according to F-Droid\u003c/span\u003e\nTrue\n43238d512c1e5eb2d6569f4a3afbf5523418b82e0a3ed1552770abb9a9c9ccab\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003ePatch\u003c/h2\u003e\u003ca id=\"user-content-patch\" aria-label=\"Permalink: Patch\" href=\"#patch\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe \u003ccode\u003efdroidserver.patch\u003c/code\u003e changes the order so it matches Android\u0026#39;s v3 before v2\nbefore v1, and monkey-patches \u003ccode\u003eandroguard\u003c/code\u003e to see the first block instead of the\nlast one if there are duplicates.  This is still likely to be incomplete, but\nprevents the known bypasses described here.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUpdate (2024-04-14)\u003c/h3\u003e\u003ca id=\"user-content-update-2024-04-14-2\" aria-label=\"Permalink: Update (2024-04-14)\" href=\"#update-2024-04-14-2\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe \u003ccode\u003efdroidserver-multicert.patch\u003c/code\u003e simply rejects any v1 signatures with\nmultiple certificates.  This may reject some valid APKs, but handling those\nproperly is nontrivial and there should be few APKs with multiple certificates\nand no v2/v3 signatures in the wild (e.g. the IzzyOnDroid repository found none\nin its catalog).  We recommend using the official \u003ccode\u003eapksig\u003c/code\u003e library (used by\n\u003ccode\u003eapksigner\u003c/code\u003e) to both verify APK signatures and return the first signer\u0026#39;s\ncertificate to avoid these kind of implementation inconsistencies and thus\nfurther vulnerabilities like this one.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUpdate (2024-12-30)\u003c/h3\u003e\u003ca id=\"user-content-update-2024-12-30\" aria-label=\"Permalink: Update (2024-12-30)\" href=\"#update-2024-12-30\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe \u003ccode\u003efdroidserver-regex.patch\u003c/code\u003e fixes the regex to correctly handle newlines.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe \u003ccode\u003efdroidserver-null-v1.patch\u003c/code\u003e (for \u003ccode\u003efdroidserver\u003c/code\u003e before the changes we\nrecommended against) and \u003ccode\u003efdroidserver-null-v2.patch\u003c/code\u003e (for current\n\u003ccode\u003efdroidserver\u003c/code\u003e) use \u003ccode\u003eZipInfo.orig_filename\u003c/code\u003e to handle NUL bytes properly (and\navoid other potential issues).\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eScanner (2024-04-15, 2024-04-20)\u003c/h2\u003e\u003ca id=\"user-content-scanner-2024-04-15-2024-04-20\" aria-label=\"Permalink: Scanner (2024-04-15, 2024-04-20)\" href=\"#scanner-2024-04-15-2024-04-20\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe \u003ccode\u003escan.py\u003c/code\u003e script can check APKs for \u003cem\u003epossible\u003c/em\u003e signature issues: it will\nflag APKs that are not clearly signed with a single unambiguous certificate,\nwhich \u003cem\u003ecould\u003c/em\u003e result in the kind of accidental misidentification of the signer\n-- despite successful verification by \u003ccode\u003eapksigner\u003c/code\u003e -- that we\u0026#39;ve demonstrated\nhere.  Unfortunately, such misidentification can easily happen as even the\nofficial documentation of the various signature schemes does not completely\ncover how Android/\u003ccode\u003eapksigner\u003c/code\u003e handles such cases.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: this will flag some valid APKs too, e.g. those with certificate chains,\nthose having used key rotation, or those with multiple signers; as the\nIzzyOnDroid repository found none in its catalog, these cases luckily seem to be\nrelatively rare.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"$ python3 scan.py poc*.apk\n\u0026#39;poc1.apk\u0026#39;: Mismatch between v1 and v2/v3 certificates\n\u0026#39;poc2.apk\u0026#39;: Duplicate block IDs\n\u0026#39;poc3a.apk\u0026#39;: Multiple certificates in signature block file\n\u0026#39;poc3b.apk\u0026#39;: Multiple certificates in signature block file\"\u003e\u003cpre\u003e$ python3 scan.py poc\u003cspan\u003e*\u003c/span\u003e.apk\n\u003cspan\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003epoc1.apk\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e: Mismatch between v1 and v2/v3 certificates\n\u003cspan\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003epoc2.apk\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e: Duplicate block IDs\n\u003cspan\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003epoc3a.apk\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e: Multiple certificates \u003cspan\u003ein\u003c/span\u003e signature block file\n\u003cspan\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003epoc3b.apk\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e: Multiple certificates \u003cspan\u003ein\u003c/span\u003e signature block file\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUpdate (2024-12-30)\u003c/h3\u003e\u003ca id=\"user-content-update-2024-12-30-3\" aria-label=\"Permalink: Update (2024-12-30)\" href=\"#update-2024-12-30-3\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe \u003ccode\u003escan.py\u003c/code\u003e script has been updated to check for APK Signature Scheme v3.1\nblocks (which will likely give false positives needing manual inspection as\nthose are expected to differ with key rotation) as well as NUL/LF/CR in\nfilenames and to use \u003ccode\u003eZipInfo.orig_filename\u003c/code\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNB: currently, neither \u003ccode\u003efdroidserver\u003c/code\u003e nor \u003ccode\u003eandroguard\u003c/code\u003e will see APK Signature\nScheme v3.1 blocks.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"$ python3 scan.py poc[45]*.apk\n\u0026#39;poc4.apk\u0026#39;: Multiple certificates in signature block file\n\u0026#39;poc5a.apk\u0026#39;: NUL, LF, or CR in filename\n\u0026#39;poc5b.apk\u0026#39;: NUL, LF, or CR in filename\"\u003e\u003cpre\u003e$ python3 scan.py poc[45]\u003cspan\u003e*\u003c/span\u003e.apk\n\u003cspan\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003epoc4.apk\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e: Multiple certificates \u003cspan\u003ein\u003c/span\u003e signature block file\n\u003cspan\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003epoc5a.apk\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e: NUL, LF, or CR \u003cspan\u003ein\u003c/span\u003e filename\n\u003cspan\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003epoc5b.apk\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e: NUL, LF, or CR \u003cspan\u003ein\u003c/span\u003e filename\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eReferences\u003c/h2\u003e\u003ca id=\"user-content-references\" aria-label=\"Permalink: References\" href=\"#references\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e[1] \u003ca href=\"https://salsa.debian.org/reproducible-builds/diffoscope/-/issues/246\" rel=\"nofollow\"\u003ehttps://salsa.debian.org/reproducible-builds/diffoscope/-/issues/246\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[2] \u003ca href=\"https://gitlab.com/fdroid/fdroidserver/-/issues/1056\" rel=\"nofollow\"\u003ehttps://gitlab.com/fdroid/fdroidserver/-/issues/1056\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[3] \u003ca href=\"https://github.com/obfusk/sigblock-code-poc\"\u003ehttps://github.com/obfusk/sigblock-code-poc\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[4] \u003ca href=\"https://lists.reproducible-builds.org/pipermail/rb-general/2023-January/002825.html\" rel=\"nofollow\"\u003ehttps://lists.reproducible-builds.org/pipermail/rb-general/2023-January/002825.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[5] \u003ca href=\"https://gitlab.com/fdroid/fdroidserver/-/issues/1128\" rel=\"nofollow\"\u003ehttps://gitlab.com/fdroid/fdroidserver/-/issues/1128\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[6] \u003ca href=\"https://source.android.com/docs/security/features/apksigning/v3\" rel=\"nofollow\"\u003ehttps://source.android.com/docs/security/features/apksigning/v3\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[7] \u003ca href=\"https://android.izzysoft.de/articles/named/iod-scan-apkchecks\" rel=\"nofollow\"\u003ehttps://android.izzysoft.de/articles/named/iod-scan-apkchecks\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[8] \u003ca href=\"https://www.kuketz-blog.de/android-apps-auf-dem-seziertisch-eine-vertiefte-betrachtung/\" rel=\"nofollow\"\u003ehttps://www.kuketz-blog.de/android-apps-auf-dem-seziertisch-eine-vertiefte-betrachtung/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[9] \u003ca href=\"https://github.com/obfusk/apksigtool\"\u003ehttps://github.com/obfusk/apksigtool\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[10] \u003ca href=\"https://gitlab.com/fdroid/fdroidserver/-/merge_requests/1466\" rel=\"nofollow\"\u003ehttps://gitlab.com/fdroid/fdroidserver/-/merge_requests/1466\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[11] \u003ca data-error-text=\"Failed to load title\" data-id=\"2253271942\" data-permission-text=\"Title is private\" data-url=\"https://github.com/androguard/androguard/issues/1038\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/androguard/androguard/pull/1038/hovercard\" href=\"https://github.com/androguard/androguard/pull/1038\"\u003eandroguard/androguard#1038\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eLinks\u003c/h2\u003e\u003ca id=\"user-content-links\" aria-label=\"Permalink: Links\" href=\"#links\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/obfusk/apksigcopier\"\u003ehttps://github.com/obfusk/apksigcopier\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/article\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": null,
  "modifiedTime": null
}
