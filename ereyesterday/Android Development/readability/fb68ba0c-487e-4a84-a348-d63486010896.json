{
  "id": "fb68ba0c-487e-4a84-a348-d63486010896",
  "title": "Handling UI Actions the Right Way in Kotlin ViewModels",
  "link": "https://proandroiddev.com/handling-ui-actions-the-right-way-in-kotlin-viewmodels-119a06bb43ef?source=rss----c72404660798---4",
  "description": "",
  "author": "Vaibhav Jaiswal",
  "published": "Tue, 22 Apr 2025 19:55:33 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "androiddev",
    "android-app-development",
    "android",
    "jetpack-compose"
  ],
  "byline": "Vaibhav Jaiswal",
  "length": 16517,
  "excerpt": "Learn how to reuse UI interaction logic across multiple Kotlin ViewModels using clean, scalable patterns that simplify code and boost maintainability.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Handling UI Actions the Right Way in Kotlin ViewModelsEver needed to use the same UI Component across multiple screens, each with its own ViewModel, leading to repetitive UI Interaction Handling? Well, then this blog is for you.IntroductionAs Android developers, we often encounter situations where the same UI functionality needs to be implemented across multiple ViewModels. For example, we have multiple screens with similar features like displaying posts, writing comments, or handling user interactions. Handling these UI interactions separately in each ViewModel can quickly become messy, leading to significant code duplication. As your app grows and the number of screens increases, this issue becomes more challenging, resulting in a harder-to-maintain codebase and scalability problems.This code duplication problem has several well-known solutions that we Android Developers commonly use:An extra helper class approachThe ‚ÄúInheritance‚Äù or ‚ÄúComposition using Delegates‚Äù approachIn the following sections, we‚Äôll explore these solutions in detail, seeing how each approach solves the problem of code duplication and highlighting the limitations each has. Then, we will dive into my solution, which builds upon these ideas and resolves their limitations for more efficient UI interaction management.This solution is something I‚Äôve already used in the Medial‚Äôs App codebase ‚Äî turning UI Interaction handling Code into a near plug-and-play experience.‚ö°Ô∏è TL;DR: Handling Shared UI Interactions in ViewModelsWhen displaying the same UI Components across multiple screens, handling their interactions in each ViewModel leads to repetition and cluttered logic. We explored three approaches to solve this:Helper Class Approach‚ûñ Simple, but no possibility of overriding any behaviour‚ûñ Not a direct functionality of the ViewModelComposition via Kotlin Delegates‚úÖ Better design, supports overriding behaviour.‚ûñ Cannot access viewModelScope or other ViewModel functionalities.‚ûñ Cannot access anything from any other inherited class.üí° My Solution ‚Äî Interface with Default Functions‚úÖ Clean, reusable, supports overriding behaviour.‚úÖ Full access to ViewModel functionalities or from any other inherited class.‚úÖ Easy to plug into any ViewModel by just implementing from the InterfaceAll the solutions in this blog are implemented in this sample project:üèóÔ∏è SetupLet‚Äôs assume we have a post-UI Element, which has some UI interactions represented in a sealed interface, like MVI suggests.sealed interface PostAction { data class Clicked(val id: String) : PostAction data class LikeClicked(val id: String) : PostAction data class ShareClicked(val id: String) : PostAction}And we also have a BaseViewModel class, which we use to keep common functionality needed in every ViewModelabstract class BaseViewModel : ViewModel() { var showShackBar by mutableStateOf(\"\") var showBottomSheet by mutableStateOf(\"\") fun navigate() { //Implementation } fun showSnackbar(message: String) { showSnackBar = message }}An Extra Helper Class ApproachIn this approach, we create a separate helper class that encapsulates the handling of UI interactions. We keep this class as a property in our ViewModel.First, we define a helper class PostActionHandlerwhich handles the interactions.class PostActionHandler(private val viewModel: BaseViewModel) { fun handleAction(action: PostAction) = when (action) { is PostAction.Clicked -\u003e viewModel.navigate() is PostAction.LikeClicked -\u003e viewModel.showSnackBar(\"Liked\") is PostAction.ShareClicked -\u003e { /*Implementation */ } }}Now, in the PostScreenViewModelWe create an instance of PostActionHandlerclass PostScreenViewModel : BaseViewModel() { val actionHandler = PostActionHandler(this)}@Composablefun PostScreen(viewModel: PostScreenViewModel) { PostItem(onAction = viewModel.actionHandler::handleAction)}@Composablefun PostItem(onAction: (PostAction) -\u003e Unit) { }While this approach does solve the problem of duplicating code across multiple ViewModels, it has some major drawbacks:These drawbacks are:üö´ Limited Customisation: Since PostActionHandler is an encapsulated class, we cannot override any behaviour.üö´ Access via Property: Rather than adding the functionality to the ViewModel itself, we‚Äôre just adding it as a property of the ViewModel.No possibility of overriding behaviour is the main reason why this approach is not suggested for UI Interaction Handling.üß¨ Composition Using Kotlin Delegates (The Elegant but Limited Solution)This is the standard and the most suggested approach to this problem all over the internet. This solution is inheritance-based, but instead of inheriting from a class that in turn prevents us from extending any more classes. In this, we use Kotlin Delegates to delegate the Implementation to a different class, hence freeing us from extending a class and killing further inheritance.This is how we implement this solutioninterface PostActionHandler { suspend fun handleAction(action: PostAction)}class PostActionHandlerImpl : PostActionHandler { override fun handleAction(action: PostAction) = when (action) { is PostAction.Clicked -\u003e handlePostClick(action.id) is PostAction.LikeClicked -\u003e handleLikeClick(action.id) is PostAction.ShareClicked -\u003e handleShareClick(action.id) } private fun handlePostClick(id: String) { } private fun handleLikeClick(id: String) { } private fun handleShareClick(id: String) { }}And this is how we use itclass PostViewModel : BaseViewModel(), PostActionHandler by PostActionHandlerImpl() {}@Composablefun PostScreen(viewModel: PostViewModel) { PostItem(onAction = viewModel::handleAction)}@Composablefun PostItem(onAction: (PostAction) -\u003e Unit) {}This approach resolves all the issues present in the Extra Helper class approach.‚úÖ Overriding Behaviours: By using interfaces and delegation, we can easily override any behaviour.‚úÖ Cleaner Design: The functionality becomes a direct part of the ViewModel, allowing us to call these functions as if they were native ViewModel methods.However, this approach has One Major Drawbacks that make it incomplete for handling UI interactions and UI logic.Accessing Functionality Inherited from Other ClassesOne major challenge with this pattern is that we cannot access functionality inherited from another class, because we cannot pass the reference.Let's see what challenges this limitation brings:No Access to ViewModel Functionality: We cannot access any ViewModel functionality from our implementation class. This is because we are not able to pass the current class reference in the Implementation class.Inability to Use viewModelScope: A major red flag that arises from this limitation is that we cannot use viewModelScope hence we cannot launch coroutines directly. We would have to create wrapper functions in our viewModel, which then kills the reusability, as now composables call our viewModel function instead.When we attempt to pass this as a constructor parameter, Android Studio raises an error:Kotlin Compiler showing error when passing ‚Äúthis‚Äùüß© My Solution: Composition Using Interface Default FunctionsWhile implementing the Composition using Delegates solution myself, I faced the challenge of passing the current ViewModel reference to access the viewModelScope and my BaseViewModel functionalities. Then I remembered Kotlin's Default Functions in Interfaces, and when I tried this approach, it solved the problem perfectly.With this approach, I could:üí° Support Overriding functionalityüîó Get full access to my BaseViewModel and ViewModel functionalities, like viewModelScope, etc or functionalities from any other class.‚ùå Skip the need for a separate implementation classIn our app‚Äôs production code at Medial, I have integrated this solution to simplify how ViewModels handle UI Interactions. The result? Every new screen just implements the Interface and Voil√†, it got the functionality ‚Äî cleanly and perfectlyLet‚Äôs explore how this solution addresses our problemsDesigning the ActionHandler Interfaceinterface PostActionHandler { val viewModel: BaseViewModel fun handleAction(action: PostAction) = viewModel.viewModelScope.launch { when (action) { is PostAction.Clicked -\u003e handlePostClick(action.id) is PostAction.LikeClicked -\u003e handleLikeClick(action.id) is PostAction.ShareClicked -\u003e handleShareClick(action.id) } } suspend fun handlePostClick(id: String) { viewModel.navigate() } suspend fun handleLikeClick(id: String) { viewModel.showToast(\"Liked\") } suspend fun handleShareClick(id: String) { //Implementation }}Making our ViewModel implement this interfaceclass PostViewModel : BaseViewModel(), PostActionHandler { //passing current baseViewModel reference override val viewModel = this override fun handleShareClick(id: String) { //Add your override implementation }}This is how it is used in a Composable@Composableprivate fun PostScreen(viewModel: PostViewModel) { PostItem(onAction = viewModel::handleAction)}@Composableprivate fun PostItem( onAction: (PostAction) -\u003e Unit) {}So, as you can see, all we need to do here is just define the viewModel variable and we‚Äôre done, we can now use all the functionality of our viewModel and our BaseViewModelprovidesNotice how we solved the major drawbacks that Composition using Delegates had:By keeping the viewModel reference as an interface property, we can easily define it within our ViewModel. This gives us direct access to all the functionalities provided by our BaseViewModel or any other ViewModel.We‚Äôve simplified the use of viewModelScope. Now, launching coroutines, collecting flows, and performing other tasks are simple, with no complex workarounds or hacks needed. This is the elegance and simplicity this solution brings.There is just 1 small downside of this approach, and that isWe have to define all the interface properties in our ViewModel, this is okay in most scenarios, as we would mostly have references to our Repository or Domain Layer class and a few mutableState If any.This problem is much smaller than the drawback we overcome in this solution, which makes this the best solution to handle any shared UI Interactions or any shared UI Business Logic.Well, this section is much simpler than the previous ones. No complex issues to dig into here ‚Äî just a straightforward solution that actually does what it‚Äôs supposed to, and solves all our problems.ü•∑üèª Let‚Äôs see this Solution in action in a real-world use caseAssume we have a HomeScreen that displays various UI elements in a list, like a Feed with items such as Posts and News. Each of these elements comes with a set of user interactions, such as liking a post, sharing a news article, or navigating to detailed views. Our solution helps us efficiently handle these interactions across different ViewModels, ensuring that the common functionality is handled in a scalable way.Designing our UI Interactions for each UI ComponentUsing Kotlin‚Äôs Sealed interfaces, we then design our UI Interactions like we do in a typical MVI Architecture:sealed interface PostAction { data class Clicked(val post: Post) : PostAction data class LikeClicked(val post: Post) : PostAction data class ShareClicked(val post: Post) : PostAction}sealed interface NewsAction { data class Clicked(val news: News) : NewsAction data class LikeClicked(val news: News) : NewsAction data class BookmarkClicked(val news: News) : NewsAction}Creating Our Action Handler Interfacesinterface PostActionHandler { val viewModel: BaseViewModel val postRepo: PostRepository fun handleAction(action: PostAction) = viewModel.viewModelScope.launch { when (action) { is PostAction.Clicked -\u003e handlePostClick(action.id) is PostAction.LikeClicked -\u003e handleLikeClick(action.id) } } suspend fun handlePostClick(id: String) { viewModel.navigate(......) } suspend fun handleLikeClick(id: String) { postRepo.like(id) viewModel.showSnackbar(\"Post Liked\") }}interface NewsActionHandler { val viewModel: BaseViewModel val newsRepo: NewsRepository fun handleAction(action: NewsAction) = when (action) { is NewsAction.Clicked -\u003e handleNewsClick(action.id) is NewsAction.Bookmark -\u003e handleNewsBookmark(action.id) } fun handleNewsClick(id: String) { viewModel.navigate(.....) } fun handleNewsBookmark(id: String) { newsRepo.bookmark(id) viewModel.showSnackBar(\"News Bookmarked\") }}As you can see above, we created an Action Handler Interface for each of our Data Models.What we did here was follow the interface design as shown in the section above.We have 2 properties, which we need the ViewModel and the Repository class.We have functions that handle each action separately. Well, this is optional. I kept it this way so that it's simple to override any specific behaviour, and we have a function that calls respective action-handling functions for each action type.Creating our ViewModelLet's build our ViewModel which implements both these Interfaces to inherit their functionalityclass HomeViewModel : BaseViewModel(), PostActionHandler, NewsActionHandler { override val viewModel = this override val postRepo = PostRepository() override val newsRepo = NewsRepository() /** Rest of your ViewModel code **/ }We then define the necessary properties (viewModel, postRepo, and newsRepo) in the ViewModel, which are used by both interfaces.This design eliminates redundancy and keeps the code simple, as we only need to set properties once, and both interfaces interact with it seamlessly as long as the property name is the same. This approach keeps the ViewModel central while allowing easy handling of UI interactions and business logic for different components.ü™ùHooking It All Up: Connecting Actions to the UI@Composablefun HomeScreen(viewModel: HomeViewModel) { LazyColumn { items(viewModel.items) { when(it) { is News -\u003e NewsCard(it, onAction = viewModel::handleAction) is Post -\u003e PostCard(it, onAction = viewModel::handleAction) } } }}@Composableprivate fun NewsCard( news: News, onAction: (NewsAction) -\u003e Unit) { }@Composableprivate fun PostCard( post: Post, onAction: (PostAction) -\u003e Unit) { }In our UI components, we can just use these as the functions of ViewModel themselves, and we‚Äôre done adding the Interaction Handling to our Screen.Now, suppose we have another screen that displays only news. All we need to do is implement the NewsActionHandler interface in our ViewModel‚Äîand that's it, we're good to go.We can seamlessly call any function from our BaseViewModel or ViewModel, enabling us to implement the entire end-to-end functionality in a single, centralised location. This is very beneficial if we display the same Data Model in Multiple Places.üì¶ Wrapping It All TogetherIn this blog, we went through one of the most overlooked Issue in scaling Android UIs, basically any UI, and that is duplicated UI interaction logic across ViewModels. We explored three different approaches to solve this:Helper Class ‚Äî A quick fix, but comes with rigid limitations.Composition using Delegation ‚Äî A more modern, inheritance-driven solution, but it struggles with accessing functionalities from outside itself.Interface with Default Functions (My Solution) ‚Äî A practical, elegant, and flexible method that overcomes all the limitations of the previous two.By leveraging Kotlin‚Äôs interface default methods and keeping the ViewModel as a property inside the interface, we unlocked full extensibility and access to extended functionality from other inherited classes/interfaces.Now, let‚Äôs compare each solution in the form of a table:You can explore all the solutions mentioned in this blog in a dedicated GitHub repo. Feel free to clone, fork, or play around with it.‚úåÔ∏è FarewellAs we wrap up, I hope this blog helped unlock some powerful tricks to level up your Kotlin and UI Handling knowledge. With Kotlin‚Äôs Interface Default Functions in your toolbelt, you‚Äôre building cleaner, faster, and with long-term scalability in mind.If you enjoyed this read and want to stay in the loop:Check out my LinkedIn and GitHub to see what I‚Äôm working on.Want more Kotlin magic? Read my previous blog for another technique that‚Äôll make your codebase leaner and smarter.Thanks for reading, and I hope you liked it! üöÄ",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*MLROq8NAKOSnutBMj3WivQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"87d5\" data-testid=\"storyTitle\"\u003eHandling UI Actions the Right Way in Kotlin ViewModels\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"79ea\"\u003eEver needed to use the same UI Component across multiple screens, each with its own ViewModel, leading to repetitive UI Interaction Handling? Well, then this blog is for you.\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://vaibhav3011.medium.com/?source=post_page---byline--119a06bb43ef---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Vaibhav Jaiswal\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*3IeQSB0vTEfCag3Ev0jf5A.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--119a06bb43ef---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"1cc0\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"3497\"\u003eAs Android developers, we often encounter situations where the same UI functionality needs to be implemented across multiple ViewModels. \u003cbr/\u003eFor example, we have multiple screens with similar features like displaying posts, writing comments, or handling user interactions. \u003cbr/\u003eHandling these UI interactions separately in each ViewModel can quickly become messy, leading to significant code duplication. As your app grows and the number of screens increases, this issue becomes more challenging, resulting in a harder-to-maintain codebase and scalability problems.\u003c/p\u003e\u003cp id=\"6900\"\u003eThis code duplication problem has several well-known solutions that we Android Developers commonly use:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0ce7\"\u003eAn extra helper class approach\u003c/li\u003e\u003cli id=\"a072\"\u003eThe ‚ÄúInheritance‚Äù or ‚ÄúComposition using Delegates‚Äù approach\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"aa0e\"\u003eIn the following sections, we‚Äôll explore these solutions in detail, seeing how each approach solves the problem of code duplication and highlighting the limitations each has. Then, we will dive into my solution, which builds upon these ideas and resolves their limitations for more efficient UI interaction management.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"1a13\"\u003eThis solution is something I‚Äôve already used in the \u003ca href=\"https://medial.app/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMedial\u003c/a\u003e‚Äôs App codebase ‚Äî turning UI Interaction handling Code into a near plug-and-play experience.\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"68c3\"\u003e‚ö°Ô∏è TL;DR: Handling Shared UI Interactions in ViewModels\u003c/h2\u003e\u003cp id=\"1e74\"\u003eWhen displaying the same UI Components across multiple screens, handling their interactions in each ViewModel leads to \u003cstrong\u003erepetition\u003c/strong\u003e and \u003cstrong\u003ecluttered logic\u003c/strong\u003e. We explored three approaches to solve this:\u003c/p\u003e\u003col\u003e\u003cli id=\"4ec4\"\u003eHelper Class Approach\u003cbr/\u003e‚ûñ Simple, but no possibility of overriding any behaviour\u003cbr/\u003e‚ûñ Not a direct functionality of the ViewModel\u003c/li\u003e\u003cli id=\"52ac\"\u003eComposition via Kotlin Delegates\u003cbr/\u003e‚úÖ Better design, supports overriding behaviour.\u003cbr/\u003e‚ûñ Cannot access \u003ccode\u003eviewModelScope\u003c/code\u003e or other ViewModel functionalities.\u003cbr/\u003e‚ûñ Cannot access anything from any other inherited class.\u003c/li\u003e\u003cli id=\"f39d\"\u003eüí° My Solution ‚Äî Interface with Default Functions\u003cbr/\u003e‚úÖ Clean, reusable, supports overriding behaviour.\u003cbr/\u003e‚úÖ Full access to ViewModel functionalities or from any other inherited class.\u003cbr/\u003e‚úÖ Easy to plug into any ViewModel by just implementing from the Interface\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"d91a\"\u003eAll the solutions in this blog are implemented in this sample \u003ca href=\"https://github.com/Vaibhav2002/Ui-Intreraction-Handler-Sample\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eproject\u003c/a\u003e:\u003c/p\u003e\u003ch2 id=\"edfb\"\u003eüèóÔ∏è Setup\u003c/h2\u003e\u003cp id=\"c8de\"\u003eLet‚Äôs assume we have a post-UI Element, which has some UI interactions represented in a sealed interface, like MVI suggests.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0d6e\"\u003esealed interface PostAction {\u003cbr/\u003e    data class Clicked(val id: String) : PostAction\u003cbr/\u003e    data class LikeClicked(val id: String) : PostAction\u003cbr/\u003e    data class ShareClicked(val id: String) : PostAction\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cb8f\"\u003eAnd we also have a BaseViewModel class, which we use to keep common functionality needed in every ViewModel\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"549b\"\u003eabstract class BaseViewModel : ViewModel() {\u003cp\u003e    var showShackBar by mutableStateOf(\u0026#34;\u0026#34;)\u003cbr/\u003e    var showBottomSheet by mutableStateOf(\u0026#34;\u0026#34;)\u003c/p\u003e\u003cp\u003e        fun navigate() { \u003cbr/\u003e      //Implementation \u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun showSnackbar(message: String) { \u003cbr/\u003e      showSnackBar = message\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"2fcd\"\u003eAn Extra Helper Class Approach\u003c/h2\u003e\u003cp id=\"2bfb\"\u003eIn this approach, we create a separate helper class that encapsulates the handling of UI interactions. We keep this class as a property in our ViewModel.\u003cbr/\u003eFirst, we define a helper class \u003ccode\u003ePostActionHandler\u003c/code\u003ewhich handles the interactions.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fe30\"\u003eclass PostActionHandler(private val viewModel: BaseViewModel) {\u003cp\u003e    fun handleAction(action: PostAction) = when (action) {\u003cbr/\u003e        is PostAction.Clicked -\u0026gt; viewModel.navigate()\u003cbr/\u003e        is PostAction.LikeClicked -\u0026gt; viewModel.showSnackBar(\u0026#34;Liked\u0026#34;)\u003cbr/\u003e        is PostAction.ShareClicked -\u0026gt; { /*Implementation */ }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e109\"\u003eNow, in the \u003ccode\u003ePostScreenViewModel\u003c/code\u003eWe create an instance of \u003ccode\u003ePostActionHandler\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6530\"\u003eclass PostScreenViewModel : BaseViewModel() {\u003cbr/\u003e    val actionHandler = PostActionHandler(this)\u003cbr/\u003e}\u003cp\u003e@Composable\u003cbr/\u003efun PostScreen(viewModel: PostScreenViewModel) {\u003cbr/\u003e    PostItem(onAction = viewModel.actionHandler::handleAction)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun PostItem(onAction: (PostAction) -\u0026gt; Unit) {  \u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9a00\"\u003eWhile this approach does solve the problem of duplicating code across multiple ViewModels, it has some major drawbacks:\u003c/p\u003e\u003cp id=\"2f41\"\u003eThese drawbacks are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"91e7\"\u003e\u003cstrong\u003eüö´ Limited Customisation: \u003c/strong\u003eSince \u003ccode\u003ePostActionHandler\u003c/code\u003e is an encapsulated class, we cannot override any behaviour.\u003c/li\u003e\u003cli id=\"cc3d\"\u003e\u003cstrong\u003eüö´ Access via Property: \u003c/strong\u003eRather than adding the functionality to the ViewModel itself, we‚Äôre just adding it as a property of the ViewModel.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ff06\"\u003e\u003cstrong\u003eNo possibility of overriding behaviour is the main reason why this approach is not suggested for UI Interaction Handling.\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"27dd\"\u003eüß¨ \u003cstrong\u003eComposition Using Kotlin Delegates (The Elegant but Limited Solution)\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"5fc1\"\u003eThis is the \u003cstrong\u003estandard\u003c/strong\u003e and the \u003cstrong\u003emost suggested approach\u003c/strong\u003e to this problem all over the internet. This solution is inheritance-based, but instead of inheriting from a class that in turn prevents us from extending any more classes. In this, we use Kotlin Delegates to delegate the Implementation to a different class, hence freeing us from extending a class and killing further inheritance.\u003c/p\u003e\u003cp id=\"0618\"\u003eThis is how we implement this solution\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4537\"\u003einterface PostActionHandler {\u003cbr/\u003e    suspend fun handleAction(action: PostAction)\u003cbr/\u003e}\u003cp\u003eclass PostActionHandlerImpl : PostActionHandler {\u003c/p\u003e\u003cp\u003e    override fun handleAction(action: PostAction) = when (action) {\u003cbr/\u003e        is PostAction.Clicked -\u0026gt; handlePostClick(action.id)\u003cbr/\u003e        is PostAction.LikeClicked -\u0026gt; handleLikeClick(action.id)\u003cbr/\u003e        is PostAction.ShareClicked -\u0026gt; handleShareClick(action.id)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun handlePostClick(id: String) { }\u003c/p\u003e\u003cp\u003e    private fun handleLikeClick(id: String) { }\u003c/p\u003e\u003cp\u003e    private fun handleShareClick(id: String) { }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c6ce\"\u003eAnd this is how we use it\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"554e\"\u003eclass PostViewModel : BaseViewModel(), PostActionHandler by PostActionHandlerImpl() {\u003cp\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun PostScreen(viewModel: PostViewModel) {\u003cbr/\u003e    PostItem(onAction = viewModel::handleAction)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun PostItem(onAction: (PostAction) -\u0026gt; Unit) {\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e552\"\u003eThis approach resolves all the issues present in the Extra Helper class approach.\u003c/p\u003e\u003cul\u003e\u003cli id=\"1a3d\"\u003e\u003cstrong\u003e‚úÖ Overriding Behaviours: \u003c/strong\u003eBy using interfaces and delegation, we can easily override any behaviour.\u003c/li\u003e\u003cli id=\"fe2d\"\u003e\u003cstrong\u003e‚úÖ Cleaner Design: \u003c/strong\u003eThe functionality becomes a direct part of the ViewModel, allowing us to call these functions as if they were native \u003ccode\u003eViewModel\u003c/code\u003e methods.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c060\"\u003eHowever, this approach has \u003cstrong\u003eOne Major Drawbacks\u003c/strong\u003e that make it incomplete for handling UI interactions and UI logic.\u003c/p\u003e\u003ch2 id=\"229e\"\u003e\u003cstrong\u003eAccessing Functionality Inherited from Other Classes\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"c468\"\u003eOne major challenge with this pattern is that we cannot access functionality inherited from another class, because we cannot pass the reference.\u003cbr/\u003eLet\u0026#39;s see what challenges this limitation brings:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0b9d\"\u003e\u003cstrong\u003eNo Access to ViewModel Functionality\u003c/strong\u003e: We cannot access any \u003ccode\u003eViewModel\u003c/code\u003e functionality from our implementation class. This is because we are not able to pass the current class reference in the Implementation class.\u003c/li\u003e\u003cli id=\"ff1a\"\u003e\u003cstrong\u003eInability to Use \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eviewModelScope\u003c/strong\u003e\u003c/code\u003e: A major red flag that arises from this limitation is that we cannot use \u003ccode\u003eviewModelScope \u003c/code\u003ehence we cannot launch coroutines directly. We would have to create wrapper functions in our viewModel, which then kills the reusability, as now composables call our viewModel function instead.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b990\"\u003eWhen we attempt to pass \u003ccode\u003ethis\u003c/code\u003e as a constructor parameter, Android Studio raises an error:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eKotlin Compiler showing error when passing ‚Äúthis‚Äù\u003c/figcaption\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"af4e\"\u003eüß© My Solution: Composition Using Interface Default Functions\u003c/h2\u003e\u003cp id=\"41d8\"\u003eWhile implementing the \u003cstrong\u003eComposition using Delegates\u003c/strong\u003e solution myself, I faced the challenge of passing the current \u003ccode\u003eViewModel\u003c/code\u003e reference to access the \u003ccode\u003eviewModelScope\u003c/code\u003e and my BaseViewModel functionalities. Then I remembered \u003cstrong\u003eKotlin\u0026#39;s Default Functions in Interfaces, \u003c/strong\u003eand when I tried this approach, it solved the problem perfectly.\u003c/p\u003e\u003cp id=\"230a\"\u003eWith this approach, I could:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b278\"\u003eüí° Support O\u003cstrong\u003everriding functionality\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"e523\"\u003eüîó Get \u003cstrong\u003efull access to my \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eBaseViewModel\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e and \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eViewModel\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e functionalities\u003c/strong\u003e, like \u003ccode\u003eviewModelScope\u003c/code\u003e, etc or functionalities from any other class.\u003c/li\u003e\u003cli id=\"58d7\"\u003e‚ùå Skip the need for a separate implementation class\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"98d2\"\u003eIn our app‚Äôs production code at \u003ca href=\"https://medial.app/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMedial\u003c/a\u003e, I have integrated this solution to simplify how ViewModels handle UI Interactions. The result? Every new screen just implements the Interface and Voil√†, it got the functionality ‚Äî cleanly and perfectly\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"02d6\"\u003eLet‚Äôs explore how this solution addresses our problems\u003c/p\u003e\u003ch2 id=\"589a\"\u003eDesigning the ActionHandler Interface\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"43e1\"\u003einterface PostActionHandler {\u003cp\u003e    val viewModel: BaseViewModel\u003c/p\u003e\u003cp\u003e    fun handleAction(action: PostAction) = viewModel.viewModelScope.launch {\u003cbr/\u003e        when (action) {\u003cbr/\u003e            is PostAction.Clicked -\u0026gt; handlePostClick(action.id)\u003cbr/\u003e            is PostAction.LikeClicked -\u0026gt; handleLikeClick(action.id)\u003cbr/\u003e            is PostAction.ShareClicked -\u0026gt; handleShareClick(action.id)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun handlePostClick(id: String) {\u003cbr/\u003e        viewModel.navigate()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun handleLikeClick(id: String) {\u003cbr/\u003e        viewModel.showToast(\u0026#34;Liked\u0026#34;)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun handleShareClick(id: String) {\u003cbr/\u003e        //Implementation\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"9b45\"\u003eMaking our ViewModel implement this interface\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"f645\"\u003eclass PostViewModel : BaseViewModel(), PostActionHandler {\u003cp\u003e    //passing current baseViewModel reference\u003cbr/\u003e    override val viewModel = this\u003c/p\u003e\u003cp\u003e    override fun handleShareClick(id: String) {\u003cbr/\u003e        //Add your override implementation\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"82d6\"\u003eThis is how it is used in a Composable\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"9e06\"\u003e@Composable\u003cbr/\u003eprivate fun PostScreen(viewModel: PostViewModel) {\u003cbr/\u003e    PostItem(onAction = viewModel::handleAction)\u003cbr/\u003e}\u003cp\u003e@Composable\u003cbr/\u003eprivate fun PostItem(\u003cbr/\u003e    onAction: (PostAction) -\u0026gt; Unit\u003cbr/\u003e) {\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"35f8\"\u003eSo, as you can see, all we need to do here is just define the \u003ccode\u003eviewModel\u003c/code\u003e variable and we‚Äôre done, we can now use all the functionality of our viewModel and our \u003ccode\u003eBaseViewModel\u003c/code\u003eprovides\u003c/p\u003e\u003cp id=\"4c2c\"\u003eNotice how we solved the major drawbacks that \u003cstrong\u003eComposition using Delegates\u003c/strong\u003e had:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1b97\"\u003eBy keeping the \u003ccode\u003eviewModel\u003c/code\u003e reference as an interface property, we can easily define it within our \u003ccode\u003eViewModel\u003c/code\u003e. This gives us direct access to all the functionalities provided by our \u003ccode\u003eBaseViewModel\u003c/code\u003e or any other \u003ccode\u003eViewModel\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"bf20\"\u003eWe‚Äôve simplified the use of \u003ccode\u003eviewModelScope\u003c/code\u003e. Now, launching coroutines, collecting flows, and performing other tasks are simple, with no complex workarounds or hacks needed. This is the elegance and simplicity this solution brings.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"132b\"\u003eThere is just 1 small downside of this approach, and that is\u003c/p\u003e\u003cul\u003e\u003cli id=\"7784\"\u003eWe have to define all the interface properties in our \u003ccode\u003eViewModel\u003c/code\u003e, this is okay in most scenarios, as we would mostly have references to our Repository or Domain Layer class and a few \u003ccode\u003emutableState\u003c/code\u003e If any.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"50a7\"\u003eThis problem is much smaller than the drawback we overcome in this solution, which makes this the best solution to handle any shared UI Interactions or any shared UI Business Logic.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"9835\"\u003eWell, this section is much simpler than the previous ones. No complex issues to dig into here ‚Äî just a straightforward solution that actually does what it‚Äôs supposed to, and solves all our problems.\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"50b7\"\u003eü•∑üèª Let‚Äôs see this Solution in action in a real-world use case\u003c/h2\u003e\u003cp id=\"33af\"\u003eAssume we have a HomeScreen that displays various UI elements in a list, like a Feed with items such as Posts and News. Each of these elements comes with a set of user interactions, such as liking a post, sharing a news article, or navigating to detailed views. Our solution helps us efficiently handle these interactions across different ViewModels, ensuring that the common functionality is handled in a scalable way.\u003c/p\u003e\u003ch2 id=\"aa22\"\u003eDesigning our UI Interactions for each UI Component\u003c/h2\u003e\u003cp id=\"0dc4\"\u003eUsing Kotlin‚Äôs Sealed interfaces, we then design our UI Interactions like we do in a typical MVI Architecture:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"19c0\"\u003esealed interface PostAction {\u003cp\u003e    data class Clicked(val post: Post) : PostAction\u003cbr/\u003e    data class LikeClicked(val post: Post) : PostAction\u003cbr/\u003e    data class ShareClicked(val post: Post) : PostAction\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"628e\"\u003esealed interface NewsAction {\u003cp\u003e    data class Clicked(val news: News) : NewsAction\u003cbr/\u003e    data class LikeClicked(val news: News) : NewsAction\u003cbr/\u003e    data class BookmarkClicked(val news: News) : NewsAction\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"6533\"\u003eCreating Our Action Handler Interfaces\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"8497\"\u003einterface PostActionHandler {\u003cp\u003e    val viewModel: BaseViewModel\u003cbr/\u003e    val postRepo: PostRepository\u003c/p\u003e\u003cp\u003e    fun handleAction(action: PostAction) = viewModel.viewModelScope.launch {\u003cbr/\u003e      when (action) {\u003cbr/\u003e          is PostAction.Clicked -\u0026gt; handlePostClick(action.id)\u003cbr/\u003e          is PostAction.LikeClicked -\u0026gt; handleLikeClick(action.id)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun handlePostClick(id: String) { \u003cbr/\u003e      viewModel.navigate(......)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun handleLikeClick(id: String) { \u003cbr/\u003e      postRepo.like(id)\u003cbr/\u003e      viewModel.showSnackbar(\u0026#34;Post Liked\u0026#34;)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"2435\"\u003einterface NewsActionHandler {\u003cp\u003e    val viewModel: BaseViewModel\u003cbr/\u003e    val newsRepo: NewsRepository\u003c/p\u003e\u003cp\u003e      fun handleAction(action: NewsAction) = when (action) {\u003cbr/\u003e        is NewsAction.Clicked -\u0026gt; handleNewsClick(action.id)\u003cbr/\u003e        is NewsAction.Bookmark -\u0026gt; handleNewsBookmark(action.id)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun handleNewsClick(id: String) { \u003cbr/\u003e      viewModel.navigate(.....)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun handleNewsBookmark(id: String) { \u003cbr/\u003e      newsRepo.bookmark(id)\u003cbr/\u003e      viewModel.showSnackBar(\u0026#34;News Bookmarked\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4df4\"\u003eAs you can see above, we created an Action Handler Interface for each of our Data Models.\u003cbr/\u003eWhat we did here was follow the interface design as shown in the section above.\u003c/p\u003e\u003cul\u003e\u003cli id=\"236d\"\u003eWe have 2 properties, which we need the \u003ccode\u003eViewModel\u003c/code\u003e and the \u003ccode\u003eRepository\u003c/code\u003e class.\u003c/li\u003e\u003cli id=\"c1f9\"\u003eWe have functions that handle each action separately. Well, this is optional. I kept it this way so that it\u0026#39;s simple to override any specific behaviour, and we have a function that calls respective action-handling functions for each action type.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"ff2e\"\u003eCreating our ViewModel\u003c/h2\u003e\u003cp id=\"e213\"\u003eLet\u0026#39;s build our \u003ccode\u003eViewModel\u003c/code\u003e which implements both these Interfaces to inherit their functionality\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aa75\"\u003eclass HomeViewModel : BaseViewModel(), PostActionHandler, NewsActionHandler {\u003cp\u003e    override val viewModel = this\u003cbr/\u003e    override val postRepo = PostRepository()\u003cbr/\u003e    override val newsRepo = NewsRepository()\u003c/p\u003e\u003cp\u003e       /**\u003cbr/\u003e      Rest of your ViewModel code\u003cbr/\u003e    **/\u003c/p\u003e\u003cp\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2aeb\"\u003eWe then define the necessary properties (\u003ccode\u003eviewModel\u003c/code\u003e, \u003ccode\u003epostRepo\u003c/code\u003e, and \u003ccode\u003enewsRepo\u003c/code\u003e) in the ViewModel, which are used by both interfaces.\u003c/p\u003e\u003cp id=\"c9bf\"\u003eThis design eliminates redundancy and keeps the code simple, as we only need to set properties once, and both interfaces interact with it seamlessly as long as the property name is the same. \u003cbr/\u003eThis approach keeps the ViewModel central while allowing easy handling of UI interactions and business logic for different components.\u003c/p\u003e\u003ch2 id=\"f28c\"\u003eü™ùHooking It All Up: Connecting Actions to the UI\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"091e\"\u003e@Composable\u003cbr/\u003efun HomeScreen(viewModel: HomeViewModel) {\u003cbr/\u003e    LazyColumn {\u003cbr/\u003e        items(viewModel.items) {\u003cbr/\u003e            when(it) {\u003cbr/\u003e                is News -\u0026gt; NewsCard(it, onAction = viewModel::handleAction)\u003cbr/\u003e                is Post -\u0026gt; PostCard(it, onAction = viewModel::handleAction)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e@Composable\u003cbr/\u003eprivate fun NewsCard(\u003cbr/\u003e  news: News,\u003cbr/\u003e  onAction: (NewsAction) -\u0026gt; Unit\u003cbr/\u003e) { \u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003eprivate fun PostCard(\u003cbr/\u003e  post: Post,\u003cbr/\u003e  onAction: (PostAction) -\u0026gt; Unit\u003cbr/\u003e) { \u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3fed\"\u003eIn our UI components, we can just use these as the functions of \u003ccode\u003eViewModel\u003c/code\u003e themselves, and we‚Äôre done adding the Interaction Handling to our Screen.\u003c/p\u003e\u003cul\u003e\u003cli id=\"fb07\"\u003eNow, suppose we have another screen that displays only news. All we need to do is implement the \u003ccode\u003eNewsActionHandler\u003c/code\u003e interface in our ViewModel‚Äîand that\u0026#39;s it, we\u0026#39;re good to go.\u003c/li\u003e\u003cli id=\"f636\"\u003eWe can seamlessly call any function from our \u003ccode\u003eBaseViewModel\u003c/code\u003e or \u003ccode\u003eViewModel\u003c/code\u003e, enabling us to implement the entire end-to-end functionality in a single, centralised location. This is very beneficial if we display the same Data Model in Multiple Places.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"e2ec\"\u003eüì¶ Wrapping It All Together\u003c/h2\u003e\u003cp id=\"ab8e\"\u003eIn this blog, we went through one of the most overlooked Issue in scaling Android UIs, basically any UI, and that is \u003cstrong\u003eduplicated UI interaction logic across ViewModels\u003c/strong\u003e. \u003cbr/\u003eWe explored three different approaches to solve this:\u003c/p\u003e\u003col\u003e\u003cli id=\"1cf1\"\u003e\u003cstrong\u003eHelper Class\u003c/strong\u003e ‚Äî A quick fix, but comes with rigid limitations.\u003c/li\u003e\u003cli id=\"8b65\"\u003e\u003cstrong\u003eComposition using Delegation\u003c/strong\u003e ‚Äî A more modern, inheritance-driven solution, but it struggles with accessing functionalities from outside itself.\u003c/li\u003e\u003cli id=\"09af\"\u003e\u003cstrong\u003eInterface with Default Functions (My Solution)\u003c/strong\u003e ‚Äî A practical, elegant, and flexible method that overcomes all the limitations of the previous two.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"89bb\"\u003eBy leveraging Kotlin‚Äôs interface default methods and keeping the ViewModel as a property inside the interface, we unlocked full extensibility and access to extended functionality from other inherited classes/interfaces.\u003c/p\u003e\u003cp id=\"b1fb\"\u003eNow, let‚Äôs compare each solution in the form of a table:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"ee19\"\u003eYou can explore all the solutions mentioned in this blog in a dedicated GitHub repo. Feel free to clone, fork, or play around with it.\u003c/h2\u003e\u003ch2 id=\"0144\"\u003e‚úåÔ∏è Farewell\u003c/h2\u003e\u003cp id=\"cab7\"\u003eAs we wrap up, I hope this blog helped unlock some powerful tricks to level up your \u003cstrong\u003eKotlin and UI Handling \u003c/strong\u003eknowledge. With \u003cstrong\u003eKotlin‚Äôs Interface Default Functions \u003c/strong\u003ein your toolbelt, you‚Äôre building cleaner, faster, and with long-term scalability in mind.\u003c/p\u003e\u003cp id=\"8f12\"\u003eIf you enjoyed this read and want to stay in the loop:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e48c\"\u003eCheck out my \u003ca href=\"https://www.linkedin.com/in/vaibhav-jaiswal-8612621b7/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLinkedIn\u003c/strong\u003e\u003c/a\u003e and \u003ca href=\"https://github.com/Vaibhav2002\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eGitHub\u003c/strong\u003e\u003c/a\u003e to see what I‚Äôm working on.\u003c/li\u003e\u003cli id=\"718d\"\u003eWant more Kotlin magic? Read my \u003ca href=\"https://vaibhav3011.medium.com/effortless-multimodule-configuration-for-kotlin-multiplatform-projects-with-gradle-convention-8e6593dff1d9\" rel=\"noopener\"\u003e\u003cstrong\u003eprevious blog\u003c/strong\u003e\u003c/a\u003e for another technique that‚Äôll make your codebase leaner and smarter.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9952\"\u003eThanks for reading, and I hope you liked it! üöÄ\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": "2025-04-16T15:07:37.654Z",
  "modifiedTime": null
}
