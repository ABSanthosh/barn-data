{
  "id": "abfbd5dc-5ae8-4c04-9516-656ca4c0d0b6",
  "title": "Integrate Kotlin-Inject-Anvil To Tv Maniac",
  "link": "https://proandroiddev.com/integrate-kotlin-inject-anvil-to-tv-maniac-e1330c9cb566?source=rss----c72404660798---4",
  "description": "",
  "author": "Thomas Kioko‚Ñ¢",
  "published": "Sun, 08 Dec 2024 04:16:36 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": null,
  "byline": "Thomas Kioko‚Ñ¢",
  "length": 9733,
  "excerpt": "If you‚Äôve used Anvil before, you know it takes away a lot of the boilerplate code and makes DI seamless. If Anvil is new to you, it basically allows you to contribute dagger modules and component‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Photo by Albert Stoynov on UnsplashIntroIf you‚Äôve used Anvil before, you know it takes away a lot of the boilerplate code and makes DI seamless. If Anvil is new to you, it basically allows you to contribute dagger modules and component interfaces to your DI graph, merge all the contributions, and add them to your component during compilation. Ralf Wonderatschek and Gabriel Peal gave an in-depth talk about this. Dagger + Anvil: Learning to Love Dependency Injection. You should check it out.I have been using kotlin-inject on my pet project for a while now, and I have had a good time with it, coming from using Dagger in other projects. One thing I missed was using Anvil. This was not available until recently, when kotlin-inject-anvil joined the chat.This is a blog of an ongoing series on my journey with Kotlin Multiplatform. This article will focus on my experience and journey integrating/migrating to kotlin-inject-anvil into the project.Going Modular ‚Äî The Kotlin Multiplatform WayKMM Preferences DatastoreKMP Environment Variables (Part 1)Intercepting Ktor Network Responses in Kotlin MultiplatformNavigating the Waters of Kotlin Multiplatform: Exploring Navigation SolutionsEnhancing iOS UI Previews: Swift UI Packages \u0026 Kotlin Multiplatform Mobile.Integrate Kotlin-Inject-Anvil To Tv Maniac ‚Äî You are here. üëàIf you want to see the code, here‚Äôs the pull request.Koltlin-Inject-Anvil IntegrationBefore integrating kotlin-inject-anvil, one thing that bothered me was how to approach the integration/migration. I thought the process would be a pain as I already have multiple modules in my project. Do I rip the bandaid off and do it all at once? Is it possible to do it gradually? Spoiler alert: it is possible to do it gradually. This approach might not work for your project, depending on the size of the team. There are multiple ways of doing this, but this worked for me. This approach made it easier to determine if I broke the current implementation or introduced new errors.Here‚Äôs a quick overview of how I approached the migration.Add dependenciesApply@ContributesTo annotationApply @ContributesBinding annotationAdd ksp kotlin-inject-anvil compiler dependencies.Delete component interfaces.Replace @Component with @MergeComponent and create a subcomponent.Let‚Äôs take a quick look at how each step is implemented.Add kotin-inject-anvil Dependencies.This is pretty straightforward. We need to add the dependencies to our project.kotlinInject-anvil-compiler = { group = \"software.amazon.lastmile.kotlin.inject.anvil\", name = \"compiler\", version.ref = \"kotlin-inject-anvil\" }kotlinInject-anvil-runtime = { group = \"software.amazon.lastmile.kotlin.inject.anvil\", name = \"runtime\", version.ref = \"kotlin-inject-anvil\" }kotlinInject-anvil-runtime-optional = { group = \"software.amazon.lastmile.kotlin.inject.anvil\", name = \"runtime-optional\", version.ref = \"kotlin-inject-anvil\" }kotlinInject-anvil-runtime-optional is optional, and your project would work without it. I added it so I can get rid of my custom scope and use kotlin-inject-anvil‚Äôs scopes to keep everything consistent.To make things easier, I created a bundle with kotlin-inject dependencies, and I use that instead.[bundles]kotlinInject = [ \"kotlinInject-runtime\", \"kotlinInject-anvil-runtime\", \"kotlinInject-anvil-runtime-optional\"]We can then add it to our module like so. implementation(libs.bundles.kotlinInject)Add @ContributesTo AnnotationWe can now annotate our interface components with @ContributesTo. I also replaced my custom scope with kotlin-inject-anvil scope: @ApplicationScope -\u003e @SingleIn(AppScope::class). As mentioned, this is optional and will work with your custom scopes. Here‚Äôs how the component looks.Beforeinterface CastComponent { @Provides @ApplicationScope fun provideCastDao(bind: DefaultCastDao): CastDao = bind @Provides @ApplicationScope fun provideCastRepository(bind: DefaultCastRepository): CastRepository = bind}After@ContributesTo(AppScope::class)interface CastComponent { @Provides @SingleIn(AppScope::class) fun provideCastDao(bind: DefaultCastDao): CastDao = bind @Provides @SingleIn(AppScope::class) fun provideCastRepository(bind: DefaultCastRepository): CastRepository = bind}One small thing I did later was move the @SingleIn annotation to the class instead of having it in the binding functions.Add @ContributesBinding AnnotationThe next thing we can do is annotate all classes that have interface implementations with @ContributesBinding. Once we‚Äôve plugged everything in, Anvil will provide the bindings for us, and we can get rid of the component above with the manual binding.Before@Injectclass DefaultCastRepository( private val dao: CastDao,) : CastRepository { ...}After@Inject@SingleIn(AppScope::class)@ContributesBinding(AppScope::class)class DefaultCastRepository( private val dao: CastDao,) : CastRepository { ...}Add KSP Dependencies.To check if the changes we‚Äôve made work as intended, we can add the Kotlin inject Anvil compiler dependency and generate the component classes. addKspDependencyForAllTargets(libs.kotlinInject.anvil.compiler). addKspDependencyForAllTargets is an extension function that creates KSP configurations for each target. e.g kspAndroid kspIosArm64We can build our app and take a look at the generated code.Anvil will generate the bindings for us similarly to what we had above. This will be generated for all our classes annotated with @ContributesBinding(AppScope::class).@Origin(value = DefaultCastRepository::class)public interface ComThomaskiokoTvmaniacDataCastImplementationDefaultCastRepository { @Provides public fun provideDefaultCastRepositoryCastRepository(defaultCastRepository: DefaultCastRepository): CastRepository = defaultCastRepository}Delete Manual Bindings.Now that our bindings and components are being generated, we can delete our component interfaces with provider functions.In my previous implementation, each module was responsible for creating its own DI component. The shared module then added all these SuperType Components to the parent/final component for each platform component. This is a bit painful and can easily get out of hand as your project grows. üòÆ‚Äçüí®Thanks to kotlin-inject-anvil, we can get rid of these as they are now generated for us once we add the merge annotation. ü•≥Final Boss: @MergeComponent Annotation@ContributesSubcomponent AnnotationSince we can only have one component annotated with @MergeComponent, we need to annotate ActivityComponent to @ContributesSubcomponent, create a factory that our parent scope will implement.Before@SingleIn(ActivityScope::class)@Componentabstract class ActivityComponent( @get:Provides val activity: ComponentActivity, @get:Provides val componentContext: ComponentContext = activity.defaultComponentContext(), @Component val applicationComponent: ApplicationComponent = ApplicationComponent.create(activity.application),) : NavigatorComponent, TraktAuthAndroidComponent { abstract val traktAuthManager: TraktAuthManager abstract val rootPresenter: RootPresenter companion object}AfterYou should note that we converted our abstract class to an interface, as only interfaces can be annotated with contributed @ContributesSubcomponent. For more details on annotation usage and behavior, see the documentation.@ContributesSubcomponent(ActivityScope::class)@SingleIn(ActivityScope::class)interface ActivityComponent { @Provides fun provideComponentContext( activity: ComponentActivity ): ComponentContext = activity.defaultComponentContext() val traktAuthManager: TraktAuthManager val rootPresenter: RootPresenter @ContributesSubcomponent.Factory(AppScope::class) interface Factory { fun createComponent( activity: ComponentActivity ): ActivityComponent }}@MergeComponent AnnotationTo create our graph and our components to our graph, we need to replace kotlin-injects @Component with kotlin-inject-anvil @MergeComponent and get rid of the SharedComponent.Before@Component@SingleIn(AppScope::class)abstract class ApplicationComponent( @get:Provides val application: Application,) : SharedComponent() { abstract val initializers: AppInitializers companion object}AfterI added annotation, removed the supertype from the application component, and added ActivityComponent.Factory.@MergeComponent(AppScope::class)@SingleIn(AppScope::class)abstract class ApplicationComponent( @get:Provides val application: Application,) : ActivityComponent.Factory { abstract val initializers: AppInitializers abstract val activityComponentFactory: ActivityComponent.Factory}Now, if we look at the generated code, we can see that Anvil adds all the generated components to our graph when we compile the app.If you forget to delete any provide functions, you will get the following error at compile time.e: [ksp] Cannot provide: com.thomaskioko.tvmaniac.data.cast.api.CastDaoe: [ksp] as it is already providedThis is expected; you can track down the duplicate provide method and delete it.ConclusionWith this in place, we have now gotten rid of manual bindings, replacing them with @ContributesTo and @ContributesBinding. We also deleted our god component class and got rid of a lot of boilerplate, thanks to Anvil.@Ralf and all the contributors have done a fantastic job with kotlin-inject-anvil. The integration was smooth. I‚Äôm looking forward to how these libraries evolve. (Maybe it should be renamed to KiAnvil. Get it? You know, like Keanu, because of how lethal it feels? No? üòÇ Don‚Äôt worry, I will see myself out.)Thanks, @Ralf, for reviewing the article. Until we meet again, folks. Happy coding! ‚úåÔ∏èReferencesDagger + Anvil: Learning to Love Dependency Injection..KSP with Kotlin MultiplatformKotlin Inject Anvil README",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*Q0gZACq7a3T4cYeD",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@_thomaskioko?source=post_page---byline--e1330c9cb566--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Thomas Kioko‚Ñ¢\" src=\"https://miro.medium.com/v2/resize:fill:88:88/0*x2yG4wwtgcyYVtw9.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--e1330c9cb566--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@albertstoynov?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAlbert Stoynov\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"1ebe\"\u003eIntro\u003c/h2\u003e\u003cp id=\"2a67\"\u003eIf you‚Äôve used Anvil before, you know it takes away a lot of the boilerplate code and makes DI seamless. If Anvil is new to you, it basically allows you to contribute dagger modules and component interfaces to your DI graph, merge all the contributions, and add them to your component during compilation. Ralf Wonderatschek and Gabriel Peal gave an in-depth talk about this. \u003ca href=\"https://www.droidcon.com/2022/06/28/dagger-anvil-learning-to-love-dependency-injection/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDagger + Anvil: Learning to Love Dependency Injection.\u003c/a\u003e You should check it out.\u003c/p\u003e\u003cp id=\"3fc9\"\u003eI have been using \u003ca href=\"https://github.com/evant/kotlin-inject\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlin-inject\u003c/a\u003e on \u003ca href=\"https://github.com/thomaskioko/tv-maniac\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003emy pet project\u003c/a\u003e for a while now, and I have had a good time with it, coming from using Dagger in other projects. One thing I missed was using Anvil. This was not available until recently, when \u003ca href=\"https://github.com/amzn/kotlin-inject-anvil?tab=readme-ov-file\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlin-inject-anvil\u003c/a\u003e joined the chat.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"b0cd\"\u003eThis is a blog of an ongoing series on my journey with Kotlin Multiplatform. This article will focus on my experience and journey integrating/migrating to kotlin-inject-anvil into the project.\u003c/p\u003e\u003cul\u003e\u003cli id=\"aadc\"\u003e\u003ca href=\"https://betterprogramming.pub/going-modular-the-kotlin-multiplatform-way-132c3dee6c95\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eGoing Modular ‚Äî The Kotlin Multiplatform Way\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\u003cli id=\"1267\"\u003e\u003ca href=\"https://medium.com/@_thomaskioko/kmm-preferences-datastore-674382443262\" rel=\"noopener\"\u003e\u003cstrong\u003eKMM Preferences Datastore\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\u003cli id=\"6089\"\u003e\u003ca href=\"https://medium.com/@_thomaskioko/kmm-environment-variables-part-1-877091c2d5b4\" rel=\"noopener\"\u003e\u003cstrong\u003eKMP Environment Variables (Part 1)\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\u003cli id=\"3816\"\u003e\u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/intercepting-ktor-network-responses-in-kotlin-multiplatform-32946b7d4d65\"\u003e\u003cstrong\u003eIntercepting Ktor Network Responses in Kotlin Multiplatform\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\u003cli id=\"6aef\"\u003e\u003ca href=\"https://medium.com/proandroiddev/navigating-the-waters-of-kotlin-multiplatform-exploring-navigation-solutions-eef81aaa1a61\" rel=\"noopener\"\u003e\u003cstrong\u003eNavigating the Waters of Kotlin Multiplatform: Exploring Navigation Solutions\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\u003cli id=\"9b59\"\u003e\u003ca href=\"https://medium.com/@_thomaskioko/enhancing-ios-development-with-swift-ui-packages-kmm-fa31901fa146\" rel=\"noopener\"\u003e\u003cstrong\u003eEnhancing iOS UI Previews: Swift UI Packages \u0026amp; Kotlin Multiplatform Mobile\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"16f6\"\u003e\u003cstrong\u003eIntegrate Kotlin-Inject-Anvil To Tv Maniac ‚Äî \u003c/strong\u003eYou are her\u003cstrong\u003ee.\u003c/strong\u003e üëà\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8762\"\u003eIf you want to see the code, here‚Äôs the \u003ca href=\"https://github.com/thomaskioko/tv-maniac/pull/363\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003epull request\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"9695\"\u003eKoltlin-Inject-Anvil Integration\u003c/h2\u003e\u003cp id=\"8a15\"\u003eBefore integrating \u003ca href=\"https://github.com/amzn/kotlin-inject-anvil?tab=readme-ov-file\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlin-inject-anvil\u003c/a\u003e, one thing that bothered me was how to approach the integration/migration. I thought the process would be a pain as I already have multiple modules in my project. Do I rip the bandaid off and do it all at once? Is it possible to do it gradually? Spoiler alert: it is possible to do it gradually. This approach might not work for your project, depending on the size of the team. There are multiple ways of doing this, but this worked for me. This approach made it easier to determine if I broke the current implementation or introduced new errors.\u003c/p\u003e\u003cp id=\"2bff\"\u003eHere‚Äôs a quick overview of how I approached the migration.\u003c/p\u003e\u003cul\u003e\u003cli id=\"0d36\"\u003eAdd dependencies\u003c/li\u003e\u003cli id=\"8627\"\u003eApply\u003ccode\u003e@ContributesTo\u003c/code\u003e annotation\u003c/li\u003e\u003cli id=\"3e8b\"\u003eApply \u003ccode\u003e@ContributesBinding\u003c/code\u003e annotation\u003c/li\u003e\u003cli id=\"17da\"\u003eAdd ksp kotlin-inject-anvil compiler dependencies.\u003c/li\u003e\u003cli id=\"7d6c\"\u003eDelete component interfaces.\u003c/li\u003e\u003cli id=\"7233\"\u003eReplace \u003ccode\u003e@Component\u003c/code\u003e with \u003ccode\u003e@MergeComponent\u003c/code\u003e and create a subcomponent.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f9f3\"\u003eLet‚Äôs take a quick look at how each step is implemented.\u003c/p\u003e\u003ch2 id=\"62d0\"\u003eAdd kotin-inject-anvil Dependencies.\u003c/h2\u003e\u003cp id=\"42ad\"\u003eThis is pretty straightforward. We need to add the dependencies to our project.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c2af\"\u003ekotlinInject-anvil-compiler = { group = \u0026#34;software.amazon.lastmile.kotlin.inject.anvil\u0026#34;, name = \u0026#34;compiler\u0026#34;, version.ref = \u0026#34;kotlin-inject-anvil\u0026#34; }\u003cbr/\u003ekotlinInject-anvil-runtime = { group = \u0026#34;software.amazon.lastmile.kotlin.inject.anvil\u0026#34;, name = \u0026#34;runtime\u0026#34;, version.ref = \u0026#34;kotlin-inject-anvil\u0026#34; }\u003cbr/\u003ekotlinInject-anvil-runtime-optional = { group = \u0026#34;software.amazon.lastmile.kotlin.inject.anvil\u0026#34;, name = \u0026#34;runtime-optional\u0026#34;, version.ref = \u0026#34;kotlin-inject-anvil\u0026#34; }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"38ca\"\u003e\u003ccode\u003ekotlinInject-anvil-runtime-optional\u003c/code\u003e is optional, and your project would work without it. I added it so I can get rid of my custom scope and use kotlin-inject-anvil‚Äôs scopes to keep everything consistent.\u003c/p\u003e\u003cp id=\"0d9a\"\u003eTo make things easier, I created a bundle with kotlin-inject dependencies, and I use that instead.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"81e8\"\u003e[bundles]\u003cbr/\u003ekotlinInject = [\u003cbr/\u003e  \u0026#34;kotlinInject-runtime\u0026#34;,\u003cbr/\u003e  \u0026#34;kotlinInject-anvil-runtime\u0026#34;,\u003cbr/\u003e  \u0026#34;kotlinInject-anvil-runtime-optional\u0026#34;\u003cbr/\u003e]\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dbc1\"\u003eWe can then add it to our module like so. \u003ccode\u003eimplementation(libs.bundles.kotlinInject)\u003c/code\u003e\u003c/p\u003e\u003ch2 id=\"f2b4\"\u003eAdd \u003ccode\u003e@ContributesTo\u003c/code\u003e Annotation\u003c/h2\u003e\u003cp id=\"e9c8\"\u003eWe can now annotate our interface components with \u003ccode\u003e@ContributesTo\u003c/code\u003e. I also replaced my custom scope with kotlin-inject-anvil scope: \u003ccode\u003e@ApplicationScope\u003c/code\u003e -\u0026gt; \u003ccode\u003e@SingleIn(AppScope::class)\u003c/code\u003e. As mentioned, this is optional and will work with your custom scopes. Here‚Äôs how the component looks.\u003c/p\u003e\u003cp id=\"39c1\"\u003e\u003cstrong\u003eBefore\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4d8e\"\u003einterface CastComponent {\u003cp\u003e    @Provides\u003cbr/\u003e  @ApplicationScope  \u003cbr/\u003e  fun provideCastDao(bind: DefaultCastDao): CastDao = bind\u003c/p\u003e\u003cp\u003e    @Provides\u003cbr/\u003e  @ApplicationScope\u003cbr/\u003e  fun provideCastRepository(bind: DefaultCastRepository): CastRepository = bind\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0020\"\u003e\u003cstrong\u003eAfter\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"268e\"\u003e@ContributesTo(AppScope::class)\u003cbr/\u003einterface CastComponent {\u003cp\u003e    @Provides\u003cbr/\u003e  @SingleIn(AppScope::class)\u003cbr/\u003e  fun provideCastDao(bind: DefaultCastDao): CastDao = bind\u003c/p\u003e\u003cp\u003e    @Provides\u003cbr/\u003e  @SingleIn(AppScope::class)\u003cbr/\u003e  fun provideCastRepository(bind: DefaultCastRepository): CastRepository = bind\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7ccf\"\u003eOne small thing I did later was move the \u003ccode\u003e@SingleIn\u003c/code\u003e annotation to the class instead of having it in the binding functions.\u003c/p\u003e\u003ch2 id=\"e0a1\"\u003eAdd \u003ccode\u003e@ContributesBinding\u003c/code\u003e Annotation\u003c/h2\u003e\u003cp id=\"b770\"\u003eThe next thing we can do is annotate all classes that have interface implementations with \u003ccode\u003e@ContributesBinding\u003c/code\u003e. Once we‚Äôve plugged everything in, Anvil will provide the bindings for us, and we can get rid of the component above with the manual binding.\u003c/p\u003e\u003cp id=\"1925\"\u003e\u003cstrong\u003eBefore\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"78cb\"\u003e@Inject\u003cbr/\u003eclass DefaultCastRepository(\u003cbr/\u003e  private val dao: CastDao,\u003cbr/\u003e) : CastRepository {\u003cbr/\u003e    ...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"aeb1\"\u003e\u003cstrong\u003eAfter\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a7b8\"\u003e@Inject\u003cbr/\u003e@SingleIn(AppScope::class)\u003cbr/\u003e@ContributesBinding(AppScope::class)\u003cbr/\u003eclass DefaultCastRepository(\u003cbr/\u003e  private val dao: CastDao,\u003cbr/\u003e) : CastRepository {\u003cbr/\u003e    ...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"6174\"\u003eAdd KSP Dependencies.\u003c/h2\u003e\u003cp id=\"a9f9\"\u003eTo check if the changes we‚Äôve made work as intended, we can add the Kotlin inject Anvil compiler dependency and generate the component classes. \u003ccode\u003eaddKspDependencyForAllTargets(libs.kotlinInject.anvil.compiler)\u003c/code\u003e. \u003ccode\u003eaddKspDependencyForAllTargets\u003c/code\u003e is an extension function that creates KSP configurations for each target. e.g \u003ccode\u003ekspAndroid\u003c/code\u003e \u003ccode\u003ekspIosArm64\u003c/code\u003e\u003c/p\u003e\u003cp id=\"7a39\"\u003eWe can build our app and take a look at the generated code.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"af12\"\u003eAnvil will generate the bindings for us similarly to what we had above. This will be generated for all our classes annotated with \u003ccode\u003e@ContributesBinding(AppScope::class)\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5b4c\"\u003e@Origin(value = DefaultCastRepository::class)\u003cbr/\u003epublic interface ComThomaskiokoTvmaniacDataCastImplementationDefaultCastRepository {\u003cp\u003e    @Provides\u003cbr/\u003e  public\u003cbr/\u003e      fun provideDefaultCastRepositoryCastRepository(defaultCastRepository: DefaultCastRepository):\u003cbr/\u003e      CastRepository = defaultCastRepository\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"edb3\"\u003eDelete Manual Bindings.\u003c/h2\u003e\u003cp id=\"5a4a\"\u003eNow that our bindings and components are being generated, we can delete our component interfaces with provider functions.\u003c/p\u003e\u003cp id=\"50bb\"\u003eIn my previous implementation, each module was responsible for creating its own DI component. The shared module then added all these SuperType Components to the parent/final component for each platform component. This is a bit painful and can easily get out of hand as your project grows. üòÆ‚Äçüí®\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"49d3\"\u003eThanks to kotlin-inject-anvil, we can get rid of these as they are now generated for us once we add the merge annotation. ü•≥\u003c/p\u003e\u003ch2 id=\"6745\"\u003eFinal Boss: \u003ccode\u003e@MergeComponent\u003c/code\u003e Annotation\u003c/h2\u003e\u003ch2 id=\"c960\"\u003e\u003ccode\u003e@ContributesSubcomponent\u003c/code\u003e Annotation\u003c/h2\u003e\u003cp id=\"f789\"\u003eSince we can only have one component annotated with \u003ccode\u003e@MergeComponent\u003c/code\u003e, we need to annotate \u003ccode\u003eActivityComponent\u003c/code\u003e to \u003ccode\u003e@ContributesSubcomponent\u003c/code\u003e, create a factory that our parent scope will implement.\u003c/p\u003e\u003cp id=\"2068\"\u003e\u003cstrong\u003eBefore\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0f60\"\u003e@SingleIn(ActivityScope::class)\u003cbr/\u003e@Component\u003cbr/\u003eabstract class ActivityComponent(\u003cbr/\u003e  @get:Provides val activity: ComponentActivity,\u003cbr/\u003e  @get:Provides val componentContext: ComponentContext = activity.defaultComponentContext(),\u003cbr/\u003e  @Component\u003cbr/\u003e  val applicationComponent: ApplicationComponent =\u003cbr/\u003e    ApplicationComponent.create(activity.application),\u003cbr/\u003e) : NavigatorComponent, TraktAuthAndroidComponent {\u003cbr/\u003e  abstract val traktAuthManager: TraktAuthManager\u003cbr/\u003e  abstract val rootPresenter: RootPresenter\u003cp\u003e  companion object\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5a9e\"\u003e\u003cstrong\u003eAfter\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"5540\"\u003eYou should note that we converted our abstract class to an interface, as only interfaces can be annotated with contributed \u003ccode\u003e@ContributesSubcomponent\u003c/code\u003e. For more details on annotation usage and behavior, \u003ca href=\"https://github.com/amzn/kotlin-inject-anvil/blob/main/runtime/src/commonMain/kotlin/software/amazon/lastmile/kotlin/inject/anvil/ContributesSubcomponent.kt\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esee the documentation.\u003c/a\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6b7d\"\u003e@ContributesSubcomponent(ActivityScope::class)\u003cbr/\u003e@SingleIn(ActivityScope::class)\u003cbr/\u003einterface ActivityComponent {\u003cp\u003e  @Provides\u003cbr/\u003e  fun provideComponentContext(\u003cbr/\u003e    activity: ComponentActivity\u003cbr/\u003e  ): ComponentContext = activity.defaultComponentContext()\u003c/p\u003e\u003cp\u003e  val traktAuthManager: TraktAuthManager\u003cbr/\u003e  val rootPresenter: RootPresenter\u003c/p\u003e\u003cp\u003e  @ContributesSubcomponent.Factory(AppScope::class)\u003cbr/\u003e  interface Factory {\u003cbr/\u003e    fun createComponent(\u003cbr/\u003e      activity: ComponentActivity\u003cbr/\u003e    ): ActivityComponent\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e410\"\u003e\u003ccode\u003e@MergeComponent\u003c/code\u003e Annotation\u003c/h2\u003e\u003cp id=\"834a\"\u003eTo create our graph and our components to our graph, we need to replace \u003ccode\u003ekotlin-injects\u003c/code\u003e \u003ccode\u003e@Component\u003c/code\u003e with \u003ccode\u003ekotlin-inject-anvil\u003c/code\u003e \u003ccode\u003e@MergeComponent\u003c/code\u003e and get rid of the \u003ccode\u003eSharedComponent\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"486d\"\u003e\u003cstrong\u003eBefore\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3c61\"\u003e@Component\u003cbr/\u003e@SingleIn(AppScope::class)\u003cbr/\u003eabstract class ApplicationComponent(\u003cbr/\u003e  @get:Provides val application: Application,\u003cbr/\u003e) : SharedComponent() {\u003cbr/\u003e  abstract val initializers: AppInitializers\u003cbr/\u003e  companion object\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"df60\"\u003e\u003cstrong\u003eAfter\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"a7c5\"\u003eI added annotation, removed the supertype from the application component, and added \u003ccode\u003eActivityComponent.Factory\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0a05\"\u003e@MergeComponent(AppScope::class)\u003cbr/\u003e@SingleIn(AppScope::class)\u003cbr/\u003eabstract class ApplicationComponent(\u003cbr/\u003e  @get:Provides val application: Application,\u003cbr/\u003e) : ActivityComponent.Factory {\u003cbr/\u003e  abstract val initializers: AppInitializers\u003cbr/\u003e  abstract val activityComponentFactory: ActivityComponent.Factory\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0dc4\"\u003eNow, if we look at the generated code, we can see that Anvil adds all the generated components to our graph when we compile the app.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3c72\"\u003eIf you forget to delete any provide functions, you will get the following error at compile time.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bab0\"\u003ee: [ksp] Cannot provide: com.thomaskioko.tvmaniac.data.cast.api.CastDao\u003cbr/\u003ee: [ksp] as it is already provided\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ea9a\"\u003eThis is expected; you can track down the duplicate provide method and delete it.\u003c/p\u003e\u003ch2 id=\"7824\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"5024\"\u003eWith this in place, we have now gotten rid of manual bindings, replacing them with \u003ccode\u003e@ContributesTo\u003c/code\u003e and \u003ccode\u003e@ContributesBinding\u003c/code\u003e. We also deleted our god component class and got rid of a lot of boilerplate, thanks to Anvil.\u003c/p\u003e\u003cp id=\"9eec\"\u003e\u003ca href=\"https://x.com/vRallev\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@Ralf\u003c/a\u003e and all the contributors have done a fantastic job with \u003ca href=\"https://github.com/amzn/kotlin-inject-anvil\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlin-inject-anvil\u003c/a\u003e. The integration was smooth. I‚Äôm looking forward to how these libraries evolve. (Maybe it should be renamed to KiAnvil. Get it? You know, like Keanu, because of how lethal it feels? No? üòÇ Don‚Äôt worry, I will see myself out.)\u003c/p\u003e\u003cp id=\"dfab\"\u003eThanks, \u003ca href=\"https://x.com/vRallev\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@Ralf\u003c/a\u003e, for reviewing the article. Until we meet again, folks. Happy coding! ‚úåÔ∏è\u003c/p\u003e\u003ch2 id=\"ffa9\"\u003eReferences\u003c/h2\u003e\u003cul\u003e\u003cli id=\"591b\"\u003e\u003ca href=\"https://www.droidcon.com/2022/06/28/dagger-anvil-learning-to-love-dependency-injection/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDagger + Anvil: Learning to Love Dependency Injection.\u003c/a\u003e.\u003c/li\u003e\u003cli id=\"f390\"\u003e\u003ca href=\"https://kotlinlang.org/docs/ksp-multiplatform.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKSP with Kotlin Multiplatform\u003c/a\u003e\u003c/li\u003e\u003cli id=\"c391\"\u003e\u003ca href=\"https://github.com/amzn/kotlin-inject-anvil\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Inject Anvil README\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2024-12-07T12:08:02.095Z",
  "modifiedTime": null
}
