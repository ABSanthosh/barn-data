{
  "id": "94a7f988-6648-44c7-9090-faaeac61e609",
  "title": "Screenshot testing in Jetpack Compose",
  "link": "https://proandroiddev.com/screenshot-testing-in-jetpack-compose-bbed440ea19a?source=rss----c72404660798---4",
  "description": "",
  "author": "Oliver Vicente",
  "published": "Mon, 02 Dec 2024 21:06:56 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "jetpack-compose",
    "screenshot-testing",
    "android",
    "jetpack-compose-preview",
    "testing"
  ],
  "byline": "Oliver Vicente",
  "length": 11633,
  "excerpt": "In this article, I’ll introduce a useful tool for screenshot testing in Jetpack Compose. This tool was officially announced at the last Google I/O as part of a new library. Although it’s still in the…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Designed by FreepikIn this article, I’ll introduce a useful tool for screenshot testing in Jetpack Compose. This tool was officially announced at the last Google I/O as part of a new library. Although it’s still in the early stages (version 0.0.1-alpha08), it can already be integrated into your projects with minimal configuration and code, allowing you to start testing your UI efficiently.What is Screenshot Testing?Screenshot testing involves comparing a reference image (a baseline) with the current state of your UI to detect visual discrepancies. Screenshots are taken with specific configurations such as:Screen sizeDark or light themeFont scalingThis approach allows developers to validate UI designs with stakeholders (e.g., designers) by taking screenshots, reviewing them, and then using these validated screenshots as a safeguard to ensure future changes don’t “break” the approved UI. If intentional UI changes occur, new reference images must replace the outdated ones.The best part? The process is automated — only new reference screenshots need manual validation.Why Use This Tool?1. Backed by GoogleHaving Google’s developer team maintaining and evolving this tool ensures it follows best practices and integrates seamlessly with the Jetpack ecosystem.2. Integration with Compose PreviewsOne standout feature is its ability to leverage Compose Preview annotations. If you’re familiar with previews in Jetpack Compose, you know how useful they are for quickly visualizing UI components. With this screenshot testing tool, you can use custom preview annotations to define multiple configurations and test them effortlessly.For example, you can create a single annotation to generate previews for:Four screen sizes in both light and dark themes, orTwo screen sizes with five different font scales.If you want to learn more about optimizing your previews, check out my post, where I share tips like creating your own preview annotations.3. Dedicated Source Set for Screenshot TestsAll screenshot tests are stored in a special source set called screenshotTest. This structure keeps screenshot tests separate from other unit and integration tests, maintaining a clean and organized codebase.4. Future EnhancementsAt London Droidcon, Jose Alcérreca and Adarsh Fernando (in their talk on testing strategies, around the 19-minute mark) mentioned an upcoming feature: the ability to use screenshot tests as previews in the files where your composables are defined. This would eliminate the need to duplicate code — one function for the preview and another for the screenshot test. While this feature isn’t available in version 0.0.1-alpha08, it’s a promising addition to look forward to!Let’s Get StartedEnough talk — let’s set up this tool in your project!Follow along as we configure the tool step-by-step, so you can start testing and validating your Jetpack Compose UIs with screenshot tests.Setting Up the PluginTo get started with screenshot testing in Jetpack Compose, you’ll need to ensure your project meets the following prerequisites:Kotlin Version: At least 1.9.20 (or newer). For this guide, I’ll be using a more recent version for improved compatibility.Android Gradle Plugin: Version 8.5.0-beta01 or higher.[versions]agp = \"8.6.1\"kotlin = \"2.0.21\"composeScreenshot = \"0.0.1-alpha08\"[plugins]compose-screenshot = { id = \"com.android.compose.screenshot\", version.ref = \"composeScreenshot\"}Step 1: Add the PluginInclude the screenshot testing plugin in your module-level build.gradle.kts file:plugins { ... alias(libs.plugins.compose.screenshot) ...}Step 2: Enable Experimental PropertiesIn your project’s gradle.properties file, enable the necessary experimental properties:android.experimental.enableScreenshotTest=trueYou’ll also need to set the experimental flag in your module-level build.gradle.kts file:android{ ... experimentalProperties[\"android.experimental.enableScreenshotTest\"] = true ...}Step 3: Check the ui-tooling DependencyEnsure the ui-tooling dependency is included in your version catalog (if you're using one) and in your module-level build.gradle.kts file. This dependency is essential for rendering and testing Compose UI elements. If you’re using the Compose BOM (Bill of Materials), the version should be managed automatically:[libraries]...# composeandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }androidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }...dependencies { ... // Compose screenshotTestImplementation(platform(libs.androidx.compose.bom) screenshotTestImplementation(libs.androidx.ui.tooling) ...}Creating Screenshot TestsIn the previous section, I mentioned an exciting upcoming feature: the ability to use preview functions from screenshot testing classes to preview composables directly within the file where they are developed. While this feature isn’t available yet, there’s a workaround to avoid duplicating code in the meantime.Step 1: Mark Previews as InternalFor composables that already have preview functions, start by marking these preview functions as internal. This ensures they remain accessible within your testing source set while keeping them encapsulated.Step 2: Reference Preview Functions in Testing ClassesNext, create a dedicated testing class for each composable within the screenshotTest source set. In these classes, reference the existing preview function instead of creating a duplicate.Generating Reference ImagesTo generate reference images for your screenshot tests, use the following Gradle commands based on your operating system:Linux and macOS: ./gradlew updateDebugScreenshotTest (./gradlew {:module:}update{Variant}ScreenshotTest)Windows: gradlew updateDebugScreenshotTest (gradlew {:module:}update{Variant}ScreenshotTest)In my case, I’m running macOS and have a single module named app. Therefore, I use the following command:./gradlew :app:updateDebugScreenshotTestOutput LocationAfter running the command, the reference images are generated and stored in the following directory:/app/src/debug/screenshotTest/reference/com/example/obook/ui/component/scaffold/Inside this folder, I find a subfolder named after the testing class, OBookScaffoldScreenshots. This folder contains five reference image files.Why Five Files?This is because I used the @PreviewScreenSizes annotation in my test class, which generates previews for five different screen sizes.Preview ExampleFor instance, if I open the file corresponding to the portrait phone screen size, I can see the captured screenshot representing the composable for that specific configuration.This setup provides a straightforward way to validate UI designs across multiple configurations efficiently.Validating the Test ReportWith reference images generated, you can now validate your screenshot tests and inspect the results through a detailed report.Command to Validate Screenshot TestsDepending on your operating system, run the following commands:Linux and macOS: ./gradlew validateDebugScreenshotTest (./gradlew {:module:}validate{Variant}ScreenshotTest)Windows: gradlew validateDebugScreenshotTest (gradlew {:module:}validate{Variant}ScreenshotTest)Example UsageIn my case, since I have a single module named app, the command is:./gradlew :app:validateDebugScreenshotTestReport LocationThe test report is generated at the following path:app/build/reports/screenshotTest/preview/debug/index.html # General format: {module}/build/reports/screenshotTest/preview/{variant}/index.htmlSuccessful Test ReportTesting Changes and Understanding ErrorsTo simulate a failure, I made a change to the text in the component and ran the validation command again. This resulted in an error.Test Report With ErrorsBy inspecting the report, I could analyze the issue:Left Panel: Displays the reference screenshot image.Middle Panel: Shows the current image (with the changes applied).Right Panel: Highlights the differences between the reference and the current image.In the case of a real error, you have two options:Verify that the issue is an actual error, fix it, and re-run the validation to ensure the test passes successfully.Confirm that the new image is correct due to an intentional design update, update the reference image to reflect the change, and then re-validate to ensure consistency.Use Git LFS (Large File Storage)Git LFS is a tool to avoid having large files that are not code files in our repository. In our case the reference images.Follow official documentation to install Git LFS. In my case, I will install it using Homebrew:brew install git-lfsthen track screenshot images with Git LFSgit lfs track \"app/src/debug/**/*.png\"Add .gitattributes to the repositorygit add .gitattributesCommit the changesgit commit -m \"Track PNG files in app/src/debug/* subfolders with Git LFS\"Configuring CI/CDTo streamline the development team’s workflow with screenshot tests, we need to automate the process by creating a CI/CD workflow.Steps to ConfigureInstall LFS and Pull FilesConfigure the workflow to install Git LFS (Large File Storage) and pull the required files. This ensures that the reference images are accessible when running the tests.- name: Install Git LFS run: | sudo apt-get install git-lfs git lfs install- name: Pull LFS files run: git lfs pullSet Read PermissionsGrant the necessary read permissions to the workflow so it can access the required resources, including reference images and other test-related files.permissions: contents: read pull-requests: readRun Tests, Generate Reports, and Host ArtifactsThe workflow should automate the following steps:Execute the screenshot tests.Generate the test report.Store the report as an artifact, making it accessible for review.- name: Run screenshot tests run: ./gradlew :app:validateDebugScreenshotTest- name: Upload screenshot test report if: always() uses: actions/upload-artifact@v4 with: name: screenshot-test-report path: app/build/reports/screenshotTest/Image Difference ThresholdWhen running the validation in GitHub Actions, an error might occur because the images are not identical. However, the root cause isn’t a significant issue but rather a minor discrepancy in how colors are rendered on different platforms. For example, your local machine (Mac) and the GitHub Actions runner (Ubuntu server) may generate slightly different color values, leading to false positives in the comparison.Screenshot DifferenceTo address the issue of minor image differences, we can adjust the Image Difference Threshold. To configure this, add the following to your module-level build.gradle.kts file:android { ... testOptions { screenshotTests { imageDifferenceThreshold = 0.002f // 0.2% } } ...}Now, when you run the pipeline again, the job will succeed without errors.In a real project scenario, it’s generally better to generate reference images on the server itself. This ensures that both the updates and validations occur on the same machine, eliminating the need for adjustments to the Image Difference Threshold configuration. This approach helps maintain consistency across environments and simplifies the testing process.ClosingIf you found this article helpful or interesting, please give it a clap and consider subscribing for more content! I’d love to hear your thoughts! Your feedback and insights are always welcome, as I’m eager to learn, collaborate, and grow with other developers in the community.Have any questions? Feel free to reach out!You can also follow me on Medium or LinkedIn for more insightful articles and updates. Let’s stay connected!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*V1-JTPCSJ2rYG-En0wxasQ.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@olivervicente?source=post_page---byline--bbed440ea19a--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Oliver Vicente\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*fUvkbyOC17on7SEGlLq6sQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--bbed440ea19a--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"http://www.freepik.com\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDesigned by Freepik\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"72fa\"\u003eIn this article, I’ll introduce a useful tool for screenshot testing in Jetpack Compose. This tool was officially announced at the last Google I/O as part of a new library. Although it’s still in the early stages (version \u003ccode\u003e0.0.1-alpha08\u003c/code\u003e), it can already be integrated into your projects with minimal configuration and code, allowing you to start testing your UI efficiently.\u003c/p\u003e\u003ch2 id=\"ecb5\"\u003eWhat is Screenshot Testing?\u003c/h2\u003e\u003cp id=\"e6c4\"\u003eScreenshot testing involves comparing a \u003cstrong\u003ereference image\u003c/strong\u003e (a baseline) with the \u003cstrong\u003ecurrent state\u003c/strong\u003e of your UI to detect visual discrepancies. Screenshots are taken with specific configurations such as:\u003c/p\u003e\u003cul\u003e\u003cli id=\"d6f3\"\u003e\u003cstrong\u003eScreen size\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"c185\"\u003e\u003cstrong\u003eDark or light theme\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"1ad9\"\u003e\u003cstrong\u003eFont scaling\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5480\"\u003eThis approach allows developers to validate UI designs with stakeholders (e.g., designers) by taking screenshots, reviewing them, and then using these validated screenshots as a safeguard to ensure future changes don’t “break” the approved UI. If intentional UI changes occur, new reference images must replace the outdated ones.\u003c/p\u003e\u003cp id=\"b549\"\u003e\u003cstrong\u003eThe best part?\u003c/strong\u003e The process is automated — only new reference screenshots need manual validation.\u003c/p\u003e\u003ch2 id=\"f7f1\"\u003eWhy Use This Tool?\u003c/h2\u003e\u003ch2 id=\"246f\"\u003e1. Backed by Google\u003c/h2\u003e\u003cp id=\"7e96\"\u003eHaving Google’s developer team maintaining and evolving this tool ensures it follows best practices and integrates seamlessly with the Jetpack ecosystem.\u003c/p\u003e\u003ch2 id=\"5094\"\u003e2. Integration with Compose Previews\u003c/h2\u003e\u003cp id=\"aa5d\"\u003eOne standout feature is its ability to leverage \u003cstrong\u003eCompose Preview annotations\u003c/strong\u003e. If you’re familiar with previews in Jetpack Compose, you know how useful they are for quickly visualizing UI components. With this screenshot testing tool, you can use custom preview annotations to define multiple configurations and test them effortlessly.\u003c/p\u003e\u003cp id=\"5b31\"\u003eFor example, you can create a single annotation to generate previews for:\u003c/p\u003e\u003cul\u003e\u003cli id=\"ea0b\"\u003e\u003cstrong\u003eFour screen sizes\u003c/strong\u003e in both \u003cstrong\u003elight and dark themes\u003c/strong\u003e, or\u003c/li\u003e\u003cli id=\"d743\"\u003e\u003cstrong\u003eTwo screen sizes\u003c/strong\u003e with \u003cstrong\u003efive different font scales\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c3ed\"\u003eIf you want to learn more about optimizing your previews, check out \u003ca href=\"https://medium.com/@olivervicente/9-tips-to-improve-your-jetpack-compose-previews-a4e00831bacc\" rel=\"noopener\"\u003emy post\u003c/a\u003e, where I share tips like creating your own preview annotations.\u003c/p\u003e\u003ch2 id=\"0df3\"\u003e3. Dedicated Source Set for Screenshot Tests\u003c/h2\u003e\u003cp id=\"6fd3\"\u003eAll screenshot tests are stored in a special source set called \u003ccode\u003escreenshotTest\u003c/code\u003e. This structure keeps screenshot tests separate from other unit and integration tests, maintaining a clean and organized codebase.\u003c/p\u003e\u003ch2 id=\"ad94\"\u003e4. Future Enhancements\u003c/h2\u003e\u003cp id=\"61aa\"\u003eAt \u003cstrong\u003eLondon Droidcon\u003c/strong\u003e, \u003cspan\u003e\u003cspan aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/u/e0a4c9469bb5?source=post_page---user_mention--bbed440ea19a--------------------------------\" rel=\"noopener\" target=\"_blank\"\u003eJose Alcérreca\u003c/a\u003e\u003c/span\u003e\u003c/span\u003e and \u003cspan\u003e\u003cspan aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/u/d0f719b3e5e9?source=post_page---user_mention--bbed440ea19a--------------------------------\" rel=\"noopener\" target=\"_blank\"\u003eAdarsh Fernando\u003c/a\u003e\u003c/span\u003e\u003c/span\u003e (in their talk on \u003ca href=\"https://www.droidcon.com/2024/11/22/scalable-testing-strategies/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003etesting strategies\u003c/a\u003e, around the 19-minute mark) mentioned an upcoming feature: the ability to use screenshot tests as \u003cstrong\u003epreviews\u003c/strong\u003e in the files where your composables are defined. This would eliminate the need to duplicate code — one function for the preview and another for the screenshot test. While this feature isn’t available in version \u003ccode\u003e0.0.1-alpha08\u003c/code\u003e, it’s a promising addition to look forward to!\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"13b3\"\u003eLet’s Get Started\u003c/h2\u003e\u003cp id=\"2c26\"\u003eEnough talk — let’s set up this tool in your project!\u003cbr/\u003eFollow along as we configure the tool step-by-step, so you can start testing and validating your Jetpack Compose UIs with screenshot tests.\u003c/p\u003e\u003ch2 id=\"4361\"\u003eSetting Up the Plugin\u003c/h2\u003e\u003cp id=\"6ad1\"\u003eTo get started with screenshot testing in Jetpack Compose, you’ll need to ensure your project meets the following prerequisites:\u003c/p\u003e\u003cul\u003e\u003cli id=\"26b8\"\u003e\u003cstrong\u003eKotlin Version\u003c/strong\u003e: At least \u003ccode\u003e1.9.20\u003c/code\u003e (or newer). For this guide, I’ll be using a more recent version for improved compatibility.\u003c/li\u003e\u003cli id=\"8914\"\u003e\u003cstrong\u003eAndroid Gradle Plugin\u003c/strong\u003e: Version \u003ccode\u003e8.5.0-beta01\u003c/code\u003e or higher.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"1104\"\u003e[versions]\u003cp\u003eagp = \u0026#34;8.6.1\u0026#34;\u003cbr/\u003ekotlin = \u0026#34;2.0.21\u0026#34;\u003cbr/\u003ecomposeScreenshot = \u0026#34;0.0.1-alpha08\u0026#34;\u003c/p\u003e\u003cp\u003e[plugins]\u003cbr/\u003ecompose-screenshot = { id = \u0026#34;com.android.compose.screenshot\u0026#34;, version.ref = \u0026#34;composeScreenshot\u0026#34;}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"b39d\"\u003eStep 1: Add the Plugin\u003c/h2\u003e\u003cp id=\"ca7f\"\u003eInclude the screenshot testing plugin in your \u003cstrong\u003emodule-level \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ebuild.gradle.kts\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e file\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5366\"\u003eplugins {\u003cbr/\u003e    ...\u003cbr/\u003e    alias(libs.plugins.compose.screenshot)\u003cbr/\u003e    ...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"9fe5\"\u003eStep 2: Enable Experimental Properties\u003c/h2\u003e\u003cp id=\"386c\"\u003eIn your \u003cstrong\u003eproject’s \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003egradle.properties\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e file\u003c/strong\u003e, enable the necessary experimental properties:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6a6f\"\u003eandroid.experimental.enableScreenshotTest=true\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b780\"\u003eYou’ll also need to set the experimental flag in your \u003cstrong\u003emodule-level \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ebuild.gradle.kts\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e file\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ed14\"\u003eandroid{\u003cbr/\u003e  ...\u003cbr/\u003e  experimentalProperties[\u0026#34;android.experimental.enableScreenshotTest\u0026#34;] = true\u003cbr/\u003e  ...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e42d\"\u003eStep 3: Check the \u003ccode\u003eui-tooling\u003c/code\u003e Dependency\u003c/h2\u003e\u003cp id=\"49f6\"\u003eEnsure the \u003ccode\u003eui-tooling\u003c/code\u003e dependency is included in your \u003cstrong\u003eversion catalog\u003c/strong\u003e (if you\u0026#39;re using one) and in your \u003cstrong\u003emodule-level \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ebuild.gradle.kts\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e file\u003c/strong\u003e. This dependency is essential for rendering and testing Compose UI elements. If you’re using the \u003cstrong\u003eCompose BOM (Bill of Materials)\u003c/strong\u003e, the version should be managed automatically:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2ab3\"\u003e[libraries]\u003cbr/\u003e...\u003cbr/\u003e# compose\u003cbr/\u003eandroidx-compose-bom = { group = \u0026#34;androidx.compose\u0026#34;, name = \u0026#34;compose-bom\u0026#34;, version.ref = \u0026#34;composeBom\u0026#34; }\u003cbr/\u003eandroidx-ui-tooling = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-tooling\u0026#34; }\u003cbr/\u003e...\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"3b2c\"\u003edependencies {\u003cbr/\u003e    ...\u003cbr/\u003e    // Compose\u003cbr/\u003e    screenshotTestImplementation(platform(libs.androidx.compose.bom)\u003cbr/\u003e    screenshotTestImplementation(libs.androidx.ui.tooling)\u003cbr/\u003e    ...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"bfff\"\u003eCreating Screenshot Tests\u003c/h2\u003e\u003cp id=\"3722\"\u003eIn the previous section, I mentioned an exciting upcoming feature: the ability to use preview functions from screenshot testing classes to preview composables directly within the file where they are developed. While this feature isn’t available yet, there’s a workaround to avoid duplicating code in the meantime.\u003c/p\u003e\u003ch2 id=\"37be\"\u003eStep 1: Mark Previews as Internal\u003c/h2\u003e\u003cp id=\"3710\"\u003eFor composables that already have preview functions, start by marking these preview functions as \u003ccode\u003einternal\u003c/code\u003e. This ensures they remain accessible within your testing source set while keeping them encapsulated.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"696a\"\u003eStep 2: Reference Preview Functions in Testing Classes\u003c/h2\u003e\u003cp id=\"acb6\"\u003eNext, create a dedicated testing class for each composable within the \u003ccode\u003escreenshotTest\u003c/code\u003e source set. In these classes, reference the existing preview function instead of creating a duplicate.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"fe90\"\u003eGenerating Reference Images\u003c/h2\u003e\u003cp id=\"e693\"\u003eTo generate reference images for your screenshot tests, use the following Gradle commands based on your operating system:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3ab9\"\u003eLinux and macOS: \u003ccode\u003e./gradlew updateDebugScreenshotTest\u003c/code\u003e (\u003ccode\u003e./gradlew {:module:}update{Variant}ScreenshotTest\u003c/code\u003e)\u003c/li\u003e\u003cli id=\"f146\"\u003eWindows: \u003ccode\u003egradlew updateDebugScreenshotTest\u003c/code\u003e (\u003ccode\u003egradlew {:module:}update{Variant}ScreenshotTest\u003c/code\u003e)\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"976f\"\u003eIn my case, I’m running macOS and have a single module named \u003ccode\u003eapp\u003c/code\u003e. Therefore, I use the following command:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"86c3\"\u003e./gradlew :app:updateDebugScreenshotTest\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3aa9\"\u003eOutput Location\u003c/h2\u003e\u003cp id=\"aa03\"\u003eAfter running the command, the reference images are generated and stored in the following directory:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"49c6\"\u003e/app/src/debug/screenshotTest/reference/com/example/obook/ui/component/scaffold/\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3bcf\"\u003eInside this folder, I find a subfolder named after the testing class, \u003ccode\u003eOBookScaffoldScreenshots\u003c/code\u003e. This folder contains five reference image files.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"4b68\"\u003eWhy Five Files?\u003c/h2\u003e\u003cp id=\"a913\"\u003eThis is because I used the \u003ccode\u003e@PreviewScreenSizes\u003c/code\u003e annotation in my test class, which generates previews for \u003cstrong\u003efive different screen sizes\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"6da5\"\u003ePreview Example\u003c/h2\u003e\u003cp id=\"18e3\"\u003eFor instance, if I open the file corresponding to the portrait phone screen size, I can see the captured screenshot representing the composable for that specific configuration.\u003c/p\u003e\u003cp id=\"8960\"\u003eThis setup provides a straightforward way to validate UI designs across multiple configurations efficiently.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"b01f\"\u003eValidating the Test Report\u003c/h2\u003e\u003cp id=\"d541\"\u003eWith reference images generated, you can now validate your screenshot tests and inspect the results through a detailed report.\u003c/p\u003e\u003ch2 id=\"8ffd\"\u003eCommand to Validate Screenshot Tests\u003c/h2\u003e\u003cp id=\"ec35\"\u003eDepending on your operating system, run the following commands:\u003c/p\u003e\u003cul\u003e\u003cli id=\"5d64\"\u003eLinux and macOS: \u003ccode\u003e./gradlew validateDebugScreenshotTest\u003c/code\u003e (\u003ccode\u003e./gradlew {:module:}validate{Variant}ScreenshotTest\u003c/code\u003e)\u003c/li\u003e\u003cli id=\"9a28\"\u003eWindows: \u003ccode\u003egradlew validateDebugScreenshotTest\u003c/code\u003e (\u003ccode\u003egradlew {:module:}validate{Variant}ScreenshotTest\u003c/code\u003e)\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"b30c\"\u003eExample Usage\u003c/h2\u003e\u003cp id=\"cc77\"\u003eIn my case, since I have a single module named \u003ccode\u003eapp\u003c/code\u003e, the command is:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4b38\"\u003e./gradlew :app:validateDebugScreenshotTest\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"d8cc\"\u003eReport Location\u003c/h2\u003e\u003cp id=\"00f2\"\u003eThe test report is generated at the following path:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7286\"\u003eapp/build/reports/screenshotTest/preview/debug/index.html  \u003cbr/\u003e# General format: {module}/build/reports/screenshotTest/preview/{variant}/index.html\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003cfigcaption\u003eSuccessful Test Report\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"be0e\"\u003eTesting Changes and Understanding Errors\u003c/h2\u003e\u003cp id=\"47cf\"\u003eTo simulate a failure, I made a change to the text in the component and ran the validation command again. This resulted in an error.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eTest Report With Errors\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"1af7\"\u003eBy inspecting the report, I could analyze the issue:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1e01\"\u003e\u003cstrong\u003eLeft Panel\u003c/strong\u003e: Displays the reference screenshot image.\u003c/li\u003e\u003cli id=\"6e15\"\u003e\u003cstrong\u003eMiddle Panel\u003c/strong\u003e: Shows the current image (with the changes applied).\u003c/li\u003e\u003cli id=\"074d\"\u003e\u003cstrong\u003eRight Panel\u003c/strong\u003e: Highlights the differences between the reference and the current image.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"bf9d\"\u003eIn the case of a real error, you have two options:\u003c/p\u003e\u003col\u003e\u003cli id=\"66f7\"\u003eVerify that the issue is an actual error, fix it, and re-run the validation to ensure the test passes successfully.\u003c/li\u003e\u003cli id=\"1338\"\u003eConfirm that the new image is correct due to an intentional design update, update the reference image to reflect the change, and then re-validate to ensure consistency.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"8156\"\u003eUse Git LFS (Large File Storage)\u003c/h2\u003e\u003cp id=\"59c5\"\u003eGit LFS is a tool to avoid having large files that are not code files in our repository. In our case the reference images.\u003c/p\u003e\u003cp id=\"d5fd\"\u003eFollow \u003ca href=\"https://docs.github.com/es/enterprise-cloud@latest/repositories/working-with-files/managing-large-files/installing-git-large-file-storage\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eofficial documentation\u003c/a\u003e to install Git LFS. In my case, I will install it using Homebrew:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d1fa\"\u003ebrew install git-lfs\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7d7e\"\u003ethen track screenshot images with Git LFS\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1107\"\u003egit lfs track \u0026#34;app/src/debug/**/*.png\u0026#34;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"862f\"\u003eAdd .gitattributes to the repository\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f255\"\u003egit add .gitattributes\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bef2\"\u003eCommit the changes\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aa24\"\u003egit commit -m \u0026#34;Track PNG files in app/src/debug/* subfolders with Git LFS\u0026#34;\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e25d\"\u003eConfiguring CI/CD\u003c/h2\u003e\u003cp id=\"0719\"\u003eTo streamline the development team’s workflow with screenshot tests, we need to automate the process by creating a CI/CD workflow.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"c215\"\u003eSteps to Configure\u003c/h2\u003e\u003cp id=\"623a\"\u003e\u003cstrong\u003eInstall LFS and Pull Files\u003c/strong\u003e\u003cbr/\u003eConfigure the workflow to install Git LFS (Large File Storage) and pull the required files. This ensures that the reference images are accessible when running the tests.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"abab\"\u003e- name: Install Git LFS\u003cbr/\u003e  run: |\u003cbr/\u003e    sudo apt-get install git-lfs\u003cbr/\u003e    git lfs install\u003cp\u003e- name: Pull LFS files\u003cbr/\u003e  run: git lfs pull\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3d4d\"\u003e\u003cstrong\u003eSet Read Permissions\u003c/strong\u003e\u003cbr/\u003eGrant the necessary read permissions to the workflow so it can access the required resources, including reference images and other test-related files.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9a95\"\u003epermissions:\u003cbr/\u003e  contents: read\u003cbr/\u003e  pull-requests: read\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a91b\"\u003e\u003cstrong\u003eRun Tests, Generate Reports, and Host Artifacts\u003c/strong\u003e\u003cbr/\u003eThe workflow should automate the following steps:\u003c/p\u003e\u003cul\u003e\u003cli id=\"761e\"\u003eExecute the screenshot tests.\u003c/li\u003e\u003cli id=\"c232\"\u003eGenerate the test report.\u003c/li\u003e\u003cli id=\"ee63\"\u003eStore the report as an artifact, making it accessible for review.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"d507\"\u003e- name: Run screenshot tests\u003cbr/\u003e  run: ./gradlew :app:validateDebugScreenshotTest\u003cp\u003e- name: Upload screenshot test report\u003cbr/\u003e  if: always()\u003cbr/\u003e  uses: actions/upload-artifact@v4\u003cbr/\u003e  with:\u003cbr/\u003e    name: screenshot-test-report\u003cbr/\u003e    path: app/build/reports/screenshotTest/\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"ccfa\"\u003eImage Difference Threshold\u003c/h2\u003e\u003cp id=\"1a0a\"\u003eWhen running the validation in GitHub Actions, an error might occur because the images are not identical. However, the root cause isn’t a significant issue but rather a minor discrepancy in how colors are rendered on different platforms. For example, your local machine (Mac) and the GitHub Actions runner (Ubuntu server) may generate slightly different color values, leading to false positives in the comparison.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eScreenshot Difference\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"6706\"\u003eTo address the issue of minor image differences, we can adjust the \u003cstrong\u003eImage Difference Threshold\u003c/strong\u003e. To configure this, add the following to your \u003cstrong\u003emodule-level \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ebuild.gradle.kts\u003c/strong\u003e\u003c/code\u003e file:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"abc8\"\u003eandroid {\u003cbr/\u003e  ...\u003cbr/\u003e  testOptions {\u003cbr/\u003e        screenshotTests {\u003cbr/\u003e            imageDifferenceThreshold = 0.002f // 0.2%\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e  ...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d740\"\u003eNow, when you run the pipeline again, the job will succeed without errors.\u003c/p\u003e\u003cp id=\"1b7a\"\u003eIn a real project scenario, it’s generally better to generate reference images on the server itself. This ensures that both the updates and validations occur on the same machine, eliminating the need for adjustments to the \u003cstrong\u003eImage Difference Threshold\u003c/strong\u003e configuration. This approach helps maintain consistency across environments and simplifies the testing process.\u003c/p\u003e\u003ch2 id=\"eff9\"\u003eClosing\u003c/h2\u003e\u003cp id=\"a348\"\u003eIf you found this article helpful or interesting, please give it a clap and consider subscribing for more content! I’d love to hear your thoughts! Your feedback and insights are always welcome, as I’m eager to learn, collaborate, and grow with other developers in the community.\u003c/p\u003e\u003cp id=\"9873\"\u003eHave any questions? Feel free to reach out!\u003c/p\u003e\u003cp id=\"679f\"\u003eYou can also follow me on \u003ca href=\"https://medium.com/@olivervicente\" rel=\"noopener\"\u003eMedium\u003c/a\u003e or \u003ca href=\"https://www.linkedin.com/in/olivervicentealfonso/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e for more insightful articles and updates. Let’s stay connected!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2024-12-02T01:25:12.76Z",
  "modifiedTime": null
}
