{
  "id": "66994b71-74e7-4652-a9b1-a18b2cfb91ae",
  "title": "Managing Persistent State in Jetpack Compose",
  "link": "https://proandroiddev.com/managing-persistent-state-in-jetpack-compose-55ffc1ec6ea4?source=rss----c72404660798---4",
  "description": "",
  "author": "Mohitsoni",
  "published": "Sat, 01 Mar 2025 12:35:45 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "android",
    "jetpack-compose",
    "ui"
  ],
  "byline": "Mohitsoni",
  "length": 3641,
  "excerpt": "State management in Jetpack Compose becomes challenging when dealing with persistent data. Traditionally, developers rely on Android’s DataStore, but integrating it seamlessly with Compose can…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "State management in Jetpack Compose becomes challenging when dealing with persistent data. Traditionally, developers rely on Android’s DataStore, but integrating it seamlessly with Compose can require excessive boilerplate. Let’s explore how to simplify this by building our own PreferenceState class to read and write data to dataStore just as you would read and update data from a state.If you want to skip the implementation, you can check out the PreferenceState library that I developed. It provides the same functionality without the need to write boilerplate code. You can find it here: PreferenceState Library, or continue reading to understand how it works step by step.Problem StatementWhen you need to store data in DataStore and update the UI state based on it, the typical approach involves multiple layers: a ViewModel, a repository, and then collecting DataStore values to update the state. This results in excessive boilerplate code, making the implementation unnecessarily complex.How We Solve This ProblemTo simplify state persistence in Jetpack Compose, we will create a PreferenceState class that directly interacts with DataStore while behaving like a MutableState. This eliminates the need for a ViewModel or repository, reducing boilerplate code while keeping the logic concise and reusable.Step-by-Step Implementation of PreferenceStateStep 1: Creating the PreferenceState Classabstract class PreferenceState\u003cT\u003e( private val key: Preferences.Key\u003cT\u003e, private val defaultValue: T, private val dataStore: DataStore\u003cPreferences\u003e) : MutableState\u003cT\u003e { private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob()) private val _state = mutableStateOf(defaultValue) override var value: T get() = _state.value set(value) { _state.value = value scope.launch { dataStore.edit { it[key] = value } } } init { scope.launch { dataStore.data.map { it[key] ?: defaultValue } .collect { newValue -\u003e withContext(Dispatchers.Main) { _state.value = newValue } } } } override fun component1(): T = value override fun component2(): (T) -\u003e Unit = { value = it }}Step 2: Creating a Custom Preference State Classclass UsernamePreferenceState: PreferenceState\u003cString\u003e( key = stringPreferencesKey(\"username\"), defaultValue = \"Guest\", dataStore = createDataStore())Since creating a DataStore instance is straightforward, we are skipping that part.Step 3: Creating a Remember Function for Compose@Composablefun rememberUsernamePreferenceState(): MarketViewSwitchState = remember { UsernamePreferenceState()}Using PreferenceState in a Real-Life ScenarioLet’s say we want to persist a username input field across app restarts. We can use PreferenceState like this:@Composablefun UserProfileScreen(modifier: Modifier = Modifier) { var username by rememberUsernamePreferenceState() Column { TextField( value = username, onValueChange = { username = it }, label = { Text(\"Username\") } ) }}This allows username to persist even when the app is restarted, without manually handling Flow collections or LaunchedEffect calls.ConclusionBuilding a PreferenceState class from scratch helps in understanding how DataStore integrates with Compose. However, for convenience, the PreferenceState library provides a ready-to-use implementation, making persistent state management easier in Jetpack Compose applications. You can find the library here: PreferenceState Library.",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*fQKE1-CTcZphpLGOpD5new.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@mohitsoni48?source=post_page---byline--55ffc1ec6ea4---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Mohitsoni\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*cKUZ_6AdsBzq38G33Fs9TA.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--55ffc1ec6ea4---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"bd51\"\u003eState management in Jetpack Compose becomes challenging when dealing with persistent data. Traditionally, developers rely on Android’s DataStore, but integrating it seamlessly with Compose can require excessive boilerplate. Let’s explore how to simplify this by building our own \u003cstrong\u003ePreferenceState\u003c/strong\u003e class to read and write data to dataStore just as you would read and update data from a state.\u003c/p\u003e\u003cp id=\"7328\"\u003eIf you want to skip the implementation, you can check out the \u003cstrong\u003ePreferenceState\u003c/strong\u003e library that I developed. It provides the same functionality without the need to write boilerplate code. You can find it here: \u003ca href=\"https://github.com/mohitsoni48/PreferenceState\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePreferenceState Library\u003c/a\u003e, or continue reading to understand how it works step by step.\u003c/p\u003e\u003ch2 id=\"52eb\"\u003eProblem Statement\u003c/h2\u003e\u003cp id=\"c227\"\u003eWhen you need to store data in DataStore and update the UI state based on it, the typical approach involves multiple layers: a ViewModel, a repository, and then collecting DataStore values to update the state. This results in excessive boilerplate code, making the implementation unnecessarily complex.\u003c/p\u003e\u003ch2 id=\"168b\"\u003eHow We Solve This Problem\u003c/h2\u003e\u003cp id=\"8db6\"\u003eTo simplify state persistence in Jetpack Compose, we will create a \u003ccode\u003ePreferenceState\u003c/code\u003e class that directly interacts with DataStore while behaving like a \u003ccode\u003eMutableState\u003c/code\u003e. This eliminates the need for a ViewModel or repository, reducing boilerplate code while keeping the logic concise and reusable.\u003c/p\u003e\u003ch2 id=\"3b2f\"\u003eStep-by-Step Implementation of PreferenceState\u003c/h2\u003e\u003ch2 id=\"36eb\"\u003eStep 1: Creating the PreferenceState Class\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"1d8d\"\u003eabstract class PreferenceState\u0026lt;T\u0026gt;(\u003cbr/\u003e    private val key: Preferences.Key\u0026lt;T\u0026gt;,\u003cbr/\u003e    private val defaultValue: T,\u003cbr/\u003e    private val dataStore: DataStore\u0026lt;Preferences\u0026gt;\u003cbr/\u003e) : MutableState\u0026lt;T\u0026gt; {\u003cbr/\u003e    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())\u003cp\u003e    private val _state = mutableStateOf(defaultValue)\u003c/p\u003e\u003cp\u003e    override var value: T\u003cbr/\u003e        get() = _state.value\u003cbr/\u003e        set(value) {\u003cbr/\u003e            _state.value = value\u003cbr/\u003e            scope.launch {\u003cbr/\u003e                dataStore.edit { it[key] = value }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e    init {\u003cbr/\u003e        scope.launch {\u003cbr/\u003e            dataStore.data.map { it[key] ?: defaultValue }\u003cbr/\u003e                .collect { newValue -\u0026gt;\u003cbr/\u003e                    withContext(Dispatchers.Main) {\u003cbr/\u003e                        _state.value = newValue\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun component1(): T = value\u003cbr/\u003e    override fun component2(): (T) -\u0026gt; Unit = { value = it }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3846\"\u003eStep 2: Creating a Custom Preference State Class\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"f63b\"\u003eclass UsernamePreferenceState: PreferenceState\u0026lt;String\u0026gt;(\u003cbr/\u003e    key = stringPreferencesKey(\u0026#34;username\u0026#34;),\u003cbr/\u003e    defaultValue = \u0026#34;Guest\u0026#34;,\u003cbr/\u003e    dataStore = createDataStore()\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"eaf4\"\u003eSince creating a DataStore instance is straightforward, we are skipping that part.\u003c/p\u003e\u003ch2 id=\"40e6\"\u003eStep 3: Creating a Remember Function for Compose\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"26ba\"\u003e@Composable\u003cbr/\u003efun rememberUsernamePreferenceState(): MarketViewSwitchState = remember {\u003cbr/\u003e    UsernamePreferenceState()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"6c17\"\u003eUsing PreferenceState in a Real-Life Scenario\u003c/h2\u003e\u003cp id=\"535f\"\u003eLet’s say we want to persist a \u003cstrong\u003eusername\u003c/strong\u003e input field across app restarts. We can use \u003ccode\u003ePreferenceState\u003c/code\u003e like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3a32\"\u003e@Composable\u003cbr/\u003efun UserProfileScreen(modifier: Modifier = Modifier) {\u003cbr/\u003e    var username by rememberUsernamePreferenceState()\u003cp\u003e    Column {\u003cbr/\u003e        TextField(\u003cbr/\u003e            value = username,\u003cbr/\u003e            onValueChange = { username = it },\u003cbr/\u003e            label = { Text(\u0026#34;Username\u0026#34;) }\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5ac0\"\u003eThis allows \u003ccode\u003eusername\u003c/code\u003e to persist even when the app is restarted, without manually handling \u003ccode\u003eFlow\u003c/code\u003e collections or \u003ccode\u003eLaunchedEffect\u003c/code\u003e calls.\u003c/p\u003e\u003ch2 id=\"3071\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"e193\"\u003eBuilding a \u003ccode\u003ePreferenceState\u003c/code\u003e class from scratch helps in understanding how DataStore integrates with Compose. However, for convenience, the \u003cstrong\u003ePreferenceState\u003c/strong\u003e library provides a ready-to-use implementation, making persistent state management easier in Jetpack Compose applications. You can find the library here: \u003ca href=\"https://github.com/mohitsoni48/PreferenceState\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePreferenceState Library\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-02-28T05:51:46.518Z",
  "modifiedTime": null
}
