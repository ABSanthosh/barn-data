{
  "id": "baf73731-4273-4397-81e8-3825a7bfd154",
  "title": "Mocking Suspend Functions and Flows with MockK Part 4 of 5",
  "link": "https://proandroiddev.com/mocking-suspend-functions-and-flows-with-mockk-part-4-of-5-49a266eeca1d?source=rss----c72404660798---4",
  "description": "",
  "author": "Sandeep Kella",
  "published": "Thu, 19 Dec 2024 14:12:40 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "android-testing",
    "kotlin-mockk",
    "mockk",
    "kotlin"
  ],
  "byline": "Sandeep Kella",
  "length": 5915,
  "excerpt": "Hey there! In this article, weâ€™re going to explore how to handle asynchronous code in your unit tests using MockK. Weâ€™ll cover: Suspend functions are at the heart of coroutine-based asynchronousâ€¦",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Hey there! In this article, weâ€™re going to explore how to handle asynchronous code in your unit tests using MockK. Weâ€™ll cover:How to mock suspend functionsHow to mock FlowsUsing coEvery {} and coVerify {}Best practices and common pitfallsLetâ€™s jump right in!Mocking Suspend FunctionsWhy Mock Suspend Functions?Suspend functions are at the heart of coroutine-based asynchronous programming in Kotlin. When your code depends on suspend functions, you need to mock these dependencies to test your logic in isolation.Basic Example of Mocking Suspend FunctionsImagine you have a UserRepository with a suspend function:class UserRepository { suspend fun getUser(id: Int): String { delay(1000) // Simulate a network call return \"John Doe\" }}Now, letâ€™s write a test for a ViewModel that calls this function:class UserViewModel(private val userRepository: UserRepository) : ViewModel() { val userName = MutableLiveData\u003cString\u003e() fun loadUser(userId: Int) { viewModelScope.launch { val name = userRepository.getUser(userId) userName.value = name } }}Mocking with coEvery {} and coVerify {}Hereâ€™s how you can mock the suspend function in your test:import androidx.arch.core.executor.testing.InstantTaskExecutorRuleimport io.mockk.coEveryimport io.mockk.coVerifyimport io.mockk.mockkimport kotlinx.coroutines.test.runTestimport org.junit.Assert.assertEqualsimport org.junit.Ruleimport org.junit.Testclass UserViewModelTest { @get:Rule val rule = InstantTaskExecutorRule() @Test fun `loadUser updates userName LiveData`() = runTest { // Arrange val mockRepository = mockk\u003cUserRepository\u003e() val viewModel = UserViewModel(mockRepository) // Stub the suspend function coEvery { mockRepository.getUser(1) } returns \"John Doe\" // Act viewModel.loadUser(1) // Assert coVerify { mockRepository.getUser(1) } assertEquals(\"John Doe\", viewModel.userName.value) }}Key Points:coEvery {}: Used to mock suspend functions.coVerify {}: Verifies that the suspend function was called.runTest: Allows you to test coroutine code synchronously.Mocking FlowsWhy Mock Flows?Flows are a powerful way to handle streams of data asynchronously. Testing code that relies on Flows ensures that your data streams behave as expected.Example of a Repository Returning a FlowLetâ€™s say you have a UserRepository that returns a Flow of user names:class UserRepository { fun getUserFlow(): Flow\u003cString\u003e = flow { emit(\"John Doe\") delay(1000) emit(\"Jane Doe\") }}Mocking a Flow with flowOfHereâ€™s how to mock the Flow in a test:import io.mockk.coEveryimport io.mockk.mockkimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.test.runTestimport kotlinx.coroutines.flow.toListimport org.junit.Assert.assertEqualsimport org.junit.Testclass UserRepositoryTest { @Test fun `getUserFlow emits correct values`() = runTest { // Arrange val mockRepository = mockk\u003cUserRepository\u003e() coEvery { mockRepository.getUserFlow() } returns flowOf(\"John Doe\", \"Jane Doe\") // Act val result = mockRepository.getUserFlow().toList() // Assert assertEquals(listOf(\"John Doe\", \"Jane Doe\"), result) }}Key Points:Use flowOf to create simple Flow mocks.toList() collects all the emissions of the Flow for easy assertions.Using coEvery {} and coVerify {}When to Use coEvery and coVerifycoEvery {} is for stubbing suspend functions and Flow-returning functions.coVerify {} checks if suspend functions were called during the test.Example: Combining Suspend Functions and FlowsImagine you have a repository with a suspend function and a Flow:class UserRepository { suspend fun getUser(id: Int): String = \"John Doe\" fun getUserFlow(): Flow\u003cString\u003e = flowOf(\"John Doe\", \"Jane Doe\")}Hereâ€™s a combined test:import io.mockk.coEveryimport io.mockk.coVerifyimport io.mockk.mockkimport kotlinx.coroutines.flow.flowOfimport kotlinx.coroutines.test.runTestimport org.junit.Assert.assertEqualsimport org.junit.Testclass UserRepositoryCombinedTest { @Test fun `test both suspend function and Flow`() = runTest { // Mock repository val mockRepository = mockk\u003cUserRepository\u003e() // Stub suspend function coEvery { mockRepository.getUser(1) } returns \"John Doe\" // Stub Flow coEvery { mockRepository.getUserFlow() } returns flowOf(\"Jane Doe\") // Test suspend function val userName = mockRepository.getUser(1) assertEquals(\"John Doe\", userName) // Test Flow val flowResult = mockRepository.getUserFlow().toList() assertEquals(listOf(\"Jane Doe\"), flowResult) // Verify the calls coVerify { mockRepository.getUser(1) } coVerify { mockRepository.getUserFlow() } }}Best Practices and Common PitfallsBest PracticesUse runTest for coroutine-based tests to avoid flakiness.Keep mocks simple: Avoid overcomplicating your stubs with too much logic.Verify interactions: Use coVerify to ensure your suspending functions are called as expected.Mocking Flows: Use flowOf for simple scenarios and flow for more complex ones.Common PitfallsNot using InstantTaskExecutorRule: This can cause LiveData tests to fail due to threading issues.Forgetting coVerify: Without verification, you might miss if a suspend function was never called.Blocking the Main Thread: Ensure that youâ€™re using runTest to handle coroutines properly.Unmocked Dependencies: Always ensure your dependencies are mocked to isolate the unit under test.ConclusionIn this article, we covered:How to mock suspend functions with coEvery {} and coVerify {}.How to test Flows using flowOf and toList().Best practices and common pitfalls for handling asynchronous code in tests.Mastering these techniques will help you write reliable and maintainable tests for your coroutine-based code. Happy mocking! ðŸš€",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1024/0*2dLllHRhKybJCTaw",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@sandeepkella23?source=post_page---byline--49a266eeca1d--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Sandeep Kella\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*m4ij-Lr2ZViGgYmypjtQ9A.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--49a266eeca1d--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"3d2d\"\u003eHey there! In this article, weâ€™re going to explore how to handle asynchronous code in your unit tests using MockK. Weâ€™ll cover:\u003c/p\u003e\u003col\u003e\u003cli id=\"6df0\"\u003e\u003cstrong\u003eHow to mock suspend functions\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"22bd\"\u003e\u003cstrong\u003eHow to mock Flows\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"ae88\"\u003e\u003cstrong\u003eUsing \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecoEvery {}\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e and \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecoVerify {}\u003c/strong\u003e\u003c/code\u003e\u003c/li\u003e\u003cli id=\"9237\"\u003e\u003cstrong\u003eBest practices and common pitfalls\u003c/strong\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"f02b\"\u003eLetâ€™s jump right in!\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"8810\"\u003eMocking Suspend Functions\u003c/h2\u003e\u003ch2 id=\"5e37\"\u003eWhy Mock Suspend Functions?\u003c/h2\u003e\u003cp id=\"bae2\"\u003eSuspend functions are at the heart of coroutine-based asynchronous programming in Kotlin. When your code depends on suspend functions, you need to mock these dependencies to test your logic in isolation.\u003c/p\u003e\u003ch2 id=\"20e4\"\u003eBasic Example of Mocking Suspend Functions\u003c/h2\u003e\u003cp id=\"7b0d\"\u003eImagine you have a \u003ccode\u003eUserRepository\u003c/code\u003e with a suspend function:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5b96\"\u003eclass UserRepository {\u003cbr/\u003e    suspend fun getUser(id: Int): String {\u003cbr/\u003e        delay(1000) // Simulate a network call\u003cbr/\u003e        return \u0026#34;John Doe\u0026#34;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5198\"\u003eNow, letâ€™s write a test for a ViewModel that calls this function:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0f70\"\u003eclass UserViewModel(private val userRepository: UserRepository) : ViewModel() {\u003cbr/\u003e    val userName = MutableLiveData\u0026lt;String\u0026gt;()\u003cbr/\u003e    fun loadUser(userId: Int) {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            val name = userRepository.getUser(userId)\u003cbr/\u003e            userName.value = name\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e9e7\"\u003eMocking with \u003ccode\u003ecoEvery {}\u003c/code\u003e and \u003ccode\u003ecoVerify {}\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"2ede\"\u003eHereâ€™s how you can mock the suspend function in your test:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d801\"\u003eimport androidx.arch.core.executor.testing.InstantTaskExecutorRule\u003cbr/\u003eimport io.mockk.coEvery\u003cbr/\u003eimport io.mockk.coVerify\u003cbr/\u003eimport io.mockk.mockk\u003cbr/\u003eimport kotlinx.coroutines.test.runTest\u003cbr/\u003eimport org.junit.Assert.assertEquals\u003cbr/\u003eimport org.junit.Rule\u003cbr/\u003eimport org.junit.Test\u003cbr/\u003eclass UserViewModelTest {\u003cbr/\u003e    @get:Rule\u003cbr/\u003e    val rule = InstantTaskExecutorRule()\u003cbr/\u003e    @Test\u003cbr/\u003e    fun `loadUser updates userName LiveData`() = runTest {\u003cbr/\u003e        // Arrange\u003cbr/\u003e        val mockRepository = mockk\u0026lt;UserRepository\u0026gt;()\u003cbr/\u003e        val viewModel = UserViewModel(mockRepository)\u003cbr/\u003e        // Stub the suspend function\u003cbr/\u003e        coEvery { mockRepository.getUser(1) } returns \u0026#34;John Doe\u0026#34;\u003cbr/\u003e        // Act\u003cbr/\u003e        viewModel.loadUser(1)\u003cbr/\u003e        // Assert\u003cbr/\u003e        coVerify { mockRepository.getUser(1) }\u003cbr/\u003e        assertEquals(\u0026#34;John Doe\u0026#34;, viewModel.userName.value)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"cfa3\"\u003eKey Points:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"c89b\"\u003e\u003ccode\u003e\u003cstrong\u003ecoEvery {}\u003c/strong\u003e\u003c/code\u003e: Used to mock suspend functions.\u003c/li\u003e\u003cli id=\"5df5\"\u003e\u003ccode\u003e\u003cstrong\u003ecoVerify {}\u003c/strong\u003e\u003c/code\u003e: Verifies that the suspend function was called.\u003c/li\u003e\u003cli id=\"603c\"\u003e\u003ccode\u003e\u003cstrong\u003erunTest\u003c/strong\u003e\u003c/code\u003e: Allows you to test coroutine code synchronously.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"1e0e\"\u003eMocking Flows\u003c/h2\u003e\u003ch2 id=\"79c8\"\u003eWhy Mock Flows?\u003c/h2\u003e\u003cp id=\"bd0d\"\u003eFlows are a powerful way to handle streams of data asynchronously. Testing code that relies on Flows ensures that your data streams behave as expected.\u003c/p\u003e\u003ch2 id=\"c0e2\"\u003eExample of a Repository Returning a Flow\u003c/h2\u003e\u003cp id=\"a410\"\u003eLetâ€™s say you have a \u003ccode\u003eUserRepository\u003c/code\u003e that returns a \u003ccode\u003eFlow\u003c/code\u003e of user names:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6e42\"\u003eclass UserRepository {\u003cbr/\u003e    fun getUserFlow(): Flow\u0026lt;String\u0026gt; = flow {\u003cbr/\u003e        emit(\u0026#34;John Doe\u0026#34;)\u003cbr/\u003e        delay(1000)\u003cbr/\u003e        emit(\u0026#34;Jane Doe\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"7a44\"\u003eMocking a Flow with \u003ccode\u003eflowOf\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"a3e4\"\u003eHereâ€™s how to mock the Flow in a test:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"63dc\"\u003eimport io.mockk.coEvery\u003cbr/\u003eimport io.mockk.mockk\u003cbr/\u003eimport kotlinx.coroutines.flow.flowOf\u003cbr/\u003eimport kotlinx.coroutines.test.runTest\u003cbr/\u003eimport kotlinx.coroutines.flow.toList\u003cbr/\u003eimport org.junit.Assert.assertEquals\u003cbr/\u003eimport org.junit.Test\u003cbr/\u003eclass UserRepositoryTest {\u003cbr/\u003e    @Test\u003cbr/\u003e    fun `getUserFlow emits correct values`() = runTest {\u003cbr/\u003e        // Arrange\u003cbr/\u003e        val mockRepository = mockk\u0026lt;UserRepository\u0026gt;()\u003cbr/\u003e        coEvery { mockRepository.getUserFlow() } returns flowOf(\u0026#34;John Doe\u0026#34;, \u0026#34;Jane Doe\u0026#34;)\u003cbr/\u003e        // Act\u003cbr/\u003e        val result = mockRepository.getUserFlow().toList()\u003cbr/\u003e        // Assert\u003cbr/\u003e        assertEquals(listOf(\u0026#34;John Doe\u0026#34;, \u0026#34;Jane Doe\u0026#34;), result)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"da04\"\u003eKey Points:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"4264\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eflowOf\u003c/strong\u003e\u003c/code\u003e to create simple Flow mocks.\u003c/li\u003e\u003cli id=\"a117\"\u003e\u003ccode\u003e\u003cstrong\u003etoList()\u003c/strong\u003e\u003c/code\u003e collects all the emissions of the Flow for easy assertions.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"c5c7\"\u003eUsing \u003ccode\u003ecoEvery {}\u003c/code\u003e and \u003ccode\u003ecoVerify {}\u003c/code\u003e\u003c/h2\u003e\u003ch2 id=\"bc6c\"\u003eWhen to Use \u003ccode\u003ecoEvery\u003c/code\u003e and \u003ccode\u003ecoVerify\u003c/code\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"bec1\"\u003e\u003ccode\u003e\u003cstrong\u003ecoEvery {}\u003c/strong\u003e\u003c/code\u003e is for stubbing suspend functions and Flow-returning functions.\u003c/li\u003e\u003cli id=\"5736\"\u003e\u003ccode\u003e\u003cstrong\u003ecoVerify {}\u003c/strong\u003e\u003c/code\u003e checks if suspend functions were called during the test.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"29ea\"\u003eExample: Combining Suspend Functions and Flows\u003c/h2\u003e\u003cp id=\"64d1\"\u003eImagine you have a repository with a suspend function and a Flow:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8f54\"\u003eclass UserRepository {\u003cbr/\u003e    suspend fun getUser(id: Int): String = \u0026#34;John Doe\u0026#34;\u003cbr/\u003e    fun getUserFlow(): Flow\u0026lt;String\u0026gt; = flowOf(\u0026#34;John Doe\u0026#34;, \u0026#34;Jane Doe\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1c84\"\u003eHereâ€™s a combined test:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"afb3\"\u003eimport io.mockk.coEvery\u003cbr/\u003eimport io.mockk.coVerify\u003cbr/\u003eimport io.mockk.mockk\u003cbr/\u003eimport kotlinx.coroutines.flow.flowOf\u003cbr/\u003eimport kotlinx.coroutines.test.runTest\u003cbr/\u003eimport org.junit.Assert.assertEquals\u003cbr/\u003eimport org.junit.Test\u003cp\u003eclass UserRepositoryCombinedTest {\u003cbr/\u003e    @Test\u003cbr/\u003e    fun `test both suspend function and Flow`() = runTest {\u003cbr/\u003e        // Mock repository\u003cbr/\u003e        val mockRepository = mockk\u0026lt;UserRepository\u0026gt;()\u003cbr/\u003e        // Stub suspend function\u003cbr/\u003e        coEvery { mockRepository.getUser(1) } returns \u0026#34;John Doe\u0026#34;\u003cbr/\u003e        // Stub Flow\u003cbr/\u003e        coEvery { mockRepository.getUserFlow() } returns flowOf(\u0026#34;Jane Doe\u0026#34;)\u003cbr/\u003e        // Test suspend function\u003cbr/\u003e        val userName = mockRepository.getUser(1)\u003cbr/\u003e        assertEquals(\u0026#34;John Doe\u0026#34;, userName)\u003cbr/\u003e        // Test Flow\u003cbr/\u003e        val flowResult = mockRepository.getUserFlow().toList()\u003cbr/\u003e        assertEquals(listOf(\u0026#34;Jane Doe\u0026#34;), flowResult)\u003cbr/\u003e        // Verify the calls\u003cbr/\u003e        coVerify { mockRepository.getUser(1) }\u003cbr/\u003e        coVerify { mockRepository.getUserFlow() }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"1307\"\u003eBest Practices and Common Pitfalls\u003c/h2\u003e\u003ch2 id=\"afb4\"\u003eBest Practices\u003c/h2\u003e\u003col\u003e\u003cli id=\"8ecc\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003erunTest\u003c/strong\u003e\u003c/code\u003e for coroutine-based tests to avoid flakiness.\u003c/li\u003e\u003cli id=\"6c98\"\u003e\u003cstrong\u003eKeep mocks simple\u003c/strong\u003e: Avoid overcomplicating your stubs with too much logic.\u003c/li\u003e\u003cli id=\"8a61\"\u003e\u003cstrong\u003eVerify interactions\u003c/strong\u003e: Use \u003ccode\u003ecoVerify\u003c/code\u003e to ensure your suspending functions are called as expected.\u003c/li\u003e\u003cli id=\"9701\"\u003e\u003cstrong\u003eMocking Flows\u003c/strong\u003e: Use \u003ccode\u003eflowOf\u003c/code\u003e for simple scenarios and \u003ccode\u003eflow\u003c/code\u003e for more complex ones.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"0a2f\"\u003eCommon Pitfalls\u003c/h2\u003e\u003col\u003e\u003cli id=\"4cff\"\u003e\u003cstrong\u003eNot using \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eInstantTaskExecutorRule\u003c/strong\u003e\u003c/code\u003e: This can cause LiveData tests to fail due to threading issues.\u003c/li\u003e\u003cli id=\"9550\"\u003e\u003cstrong\u003eForgetting \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecoVerify\u003c/strong\u003e\u003c/code\u003e: Without verification, you might miss if a suspend function was never called.\u003c/li\u003e\u003cli id=\"9bfd\"\u003e\u003cstrong\u003eBlocking the Main Thread\u003c/strong\u003e: Ensure that youâ€™re using \u003ccode\u003erunTest\u003c/code\u003e to handle coroutines properly.\u003c/li\u003e\u003cli id=\"2912\"\u003e\u003cstrong\u003eUnmocked Dependencies\u003c/strong\u003e: Always ensure your dependencies are mocked to isolate the unit under test.\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"40c2\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"3597\"\u003eIn this article, we covered:\u003c/p\u003e\u003cul\u003e\u003cli id=\"4457\"\u003eHow to mock suspend functions with \u003ccode\u003ecoEvery {}\u003c/code\u003e and \u003ccode\u003ecoVerify {}\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"e6af\"\u003eHow to test Flows using \u003ccode\u003eflowOf\u003c/code\u003e and \u003ccode\u003etoList()\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"3f20\"\u003eBest practices and common pitfalls for handling asynchronous code in tests.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"de4c\"\u003eMastering these techniques will help you write reliable and maintainable tests for your coroutine-based code. Happy mocking! ðŸš€\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2024-12-19T04:51:48.501Z",
  "modifiedTime": null
}
