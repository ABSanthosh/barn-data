{
  "id": "0a3d7b14-3978-40a6-92ae-7cf7afa90432",
  "title": "Securing Android: Behind a few seconds of payment transaction …",
  "link": "https://proandroiddev.com/securing-android-behind-a-few-seconds-of-payment-transaction-630b65905b9a?source=rss----c72404660798---4",
  "description": "",
  "author": "Sofien Rahmouni",
  "published": "Mon, 14 Apr 2025 14:14:16 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "mobile-app-development",
    "tap-to-pay-uae",
    "android",
    "security",
    "finance"
  ],
  "byline": "Sofien Rahmouni",
  "length": 48918,
  "excerpt": "Over the past few months, I’ve been deeply involved in the development of an Android payment application, where security has been a fundamental pillar of the entire process. Working on this project…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Secure Payment Transaction TapToPay AndroidOver the past few months, I’ve been deeply involved in the development of an Android payment application, where security has been a fundamental pillar of the entire process.Working on this project has given me invaluable insights into the intricate world of securing Android applications.The protection levels on this Android Payment App, can be devided in Compilation Layer, Runtime Layer.For free complete read access, please continue with this link : https://medium.com/@sofienrahmouni/securing-android-behind-a-few-seconds-of-payment-transaction-bf6817119d51?source=friends_link\u0026sk=0117880616ac48dde2590f0b8138d7661. Protecting Your App from Reverse Engineering \u0026 DebuggingAnti-Developer-Options: Developer options activation can be the first door for an attacker to start so we should check it :fun isDeveloperOptionsEnabled(context: Context): Boolean { return try { Settings.Global.getInt( context.contentResolver, Settings.Global.DEVELOPMENT_SETTINGS_ENABLED ) == 1 } catch (e: Exception) { Log.e(\"DeveloperOptions\", \"Error checking Developer Options\", e) false } }Anti-Debugging: Detect debuggers at runtime using isDebuggerConnected() :Here is snippet code used to detect if the application was build on debug mode and when the debbuger attached:// Check debbugable flagval isDebuggable =(context.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0// Check debugger is connected at runtimeimport android.os.Debug.isDebuggerConnectedval isDebuggerConnected= isDebuggerConnected()The debug check also can be done at the system level using native methodptrace() :bool = ptrace(PTRACE_TRACEME, 0, 0, 0) == -1;Anti-Root Detection: As known in the Android world, the key to every attack vector starts with obtaining privileged access as an admin or root user. Therefore, we must protect our application by implementing root detection :object RootDetectionUtil { fun isRooted(): Boolean { // Check known binary root file paths val paths = listOf( \"/data/local\", \"/data/local/bin\", \"/data/local/xbin\", \"/sbin\", \"/su/bin\", \"/system\", \"/system/app\", \"/system/bin\", \"/system/bin/.ext\", \"/system/bin/failsafe\", \"/system/sd/xbin\", \"/system/usr/we-need-root\", \"/system/xbin\" ) val binaries = listOf( \"magisk\", \"su\", \"su2\", \"superuser.apk\", \"Superuser.apk\", \"su-backup\", \".su\", \"busybox\", \"busybox.apk\" ) for (path in paths) { for (bin in binaries) { val filePath = File(\"$path/$bin\") if (filePath.exists()) { Log.e(\"RootDetection\", \"Smartphone rooted ($filePath)\") return true } } } // Check for the existence of the \"su\" binary try { if (Runtime.getRuntime().exec(arrayOf(\"/system/xbin/which\", \"su\")) .inputStream.bufferedReader().readLine() != null ) { return true } } catch (e: Exception) { e.printStackTrace() } // Check if AOSP ROM was signed with release keys else means isRooted if (android.os.Build.TAGS?.contains(\"test-keys\") == true) { return true } Log.d(\"RootDetection\", \"Smartphone not rooted\") return false }}Obfuscation: To make the reverse engineering process more difficult, Android offers open-source obfuscation tools such as ProGuard and R8, as well as more advanced paid options like DexGuard, to make decompilation harder.Anti-Tampering: On the other hand, Google offers an interesting solution to verify app integrity using the Google Play Integrity API. It is based on a verdict attestation service, making it a more reliable solution compared to local environment checks. However, this solution is subject to limitations, as Google provides only 10,000 free tokens per day.Here is an example of decoded response play integrity verdict (The real world response is encrypted \u0026 encoded) :{ \"requestDetails\": { \"requestPackageName\": \"com.payment.app\", \"nonce\": \"b64_encoded_nonce\", \"timestampMillis\": 1710000000000 }, \"appIntegrity\": { \"appRecognitionVerdict\": \"PLAY_RECOGNIZED\", \"packageName\": \"com.payment.app\", \"certificateSha256Digest\": [\"b64_encoded_cert_hash\"] }, \"deviceIntegrity\": { \"deviceRecognitionVerdict\": [\"MEETS_DEVICE_INTEGRITY\"] }, \"accountDetails\": { \"appLicensingVerdict\": \"LICENSED\" }}Continuing with Anti-tampering protection, we should also implement APK signature verification. It is recommended to perform this check on a remote server by sending the current certificate signature and comparing it on the server side.Here is below an example showing the mechanism to get signature application certificate :object SignatureUtil { private val TAG = SignatureUtil::class.java.simpleName /** ** Get application signature to be used later in the check anti-tampering ** on Server side, in case have is different than setted in the BE means ** the application was changed/tampered. **/ fun getApkSigners(context: Context): List\u003cSignature\u003e? { return try { if (context .packageManager .getPackageInfo(context.packageName, PackageManager.GET_SIGNING_CERTIFICATES) .signingInfo?.hasMultipleSigners() == true ) { context .packageManager .getPackageInfo(context.packageName, PackageManager.GET_SIGNING_CERTIFICATES) .signingInfo?.apkContentsSigners ?.toList() } else { context .packageManager .getPackageInfo(context.packageName, PackageManager.GET_SIGNING_CERTIFICATES) .signingInfo?.signingCertificateHistory ?.toList() } } catch (e: PackageManager.NameNotFoundException) { Log.e(TAG, \"Cannot read APK content signers\", e) null } }}And finally, here is new anti-tampering protection addition was added in Android 10, the useEmbeddedDex flag which is really simple to be used.Here is an example how to use :In manifest xml file, it should putted on it like this :\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.payement.app\" xmlns:tools=\"http://schemas.android.com/tools\"\u003e \u003capplication android:useEmbeddedDex=\"true\" tools:targetApi=\"Q\"\u003e .... \u003c/application\u003e\u003c/manifest\u003eIn the build gradle :packagingOptions { dex { useLegacyPackaging = false } } // In case, bad behavior when genarting signed aab, we can use this aaptOptions // aaptOptions { // noCompress 'dex' // }2. Securing Execution EnvironmentAnti-Emulation: We should detect virtual environments VM detection Here is below method which check the multiple layers emulation environnements :object EmulatorDetection { private val QEMU_DRIVERS = arrayOf(\"goldfish\") private val GENY_FILES = arrayOf( \"/dev/socket/genyd\", \"/dev/socket/baseband_genyd\" ) private val PIPES = arrayOf( \"/dev/socket/qemud\", \"/dev/qemu_pipe\" ) private val X86_FILES = arrayOf( \"ueventd.android_x86.rc\", \"x86.prop\", \"ueventd.ttVM_x86.rc\", \"init.ttVM_x86.rc\", \"fstab.ttVM_x86\", \"fstab.vbox86\", \"init.vbox86.rc\", \"ueventd.vbox86.rc\" ) private val ANDY_FILES = arrayOf( \"fstab.andy\", \"ueventd.andy.rc\" ) private val NOX_FILES = arrayOf( \"fstab.nox\", \"init.nox.rc\", \"ueventd.nox.rc\" ) fun isRunningInEmulator(context: Context): Boolean { return when { checkBasic() -\u003e true checkAdvanced() -\u003e true checkPackageName(context) -\u003e true else -\u003e false } } private fun checkBasic(): Boolean { var rating = 0 if (Build.PRODUCT == \"sdk_x86_64\" || Build.PRODUCT == \"sdk_google_phone_x86\" || Build.PRODUCT == \"sdk_google_phone_x86_64\" || Build.PRODUCT == \"sdk_google_phone_arm64\" || Build.PRODUCT == \"vbox86p\") { rating++ } if (Build.MANUFACTURER == \"unknown\") { rating++ } if (Build.BRAND == \"generic\" || Build.BRAND.equals(\"android\", ignoreCase = true) || Build.BRAND == \"generic_arm64\" || Build.BRAND == \"generic_x86\" || Build.BRAND == \"generic_x86_64\" ) { rating++ } if (Build.DEVICE == \"generic\" || Build.DEVICE == \"generic_arm64\" || Build.DEVICE == \"generic_x86\" || Build.DEVICE == \"generic_x86_64\" || Build.DEVICE == \"vbox86p\") { rating++ } if (Build.MODEL == \"sdk\" || Build.MODEL == \"Android SDK built for arm64\" || Build.MODEL == \"Android SDK built for armv7\" || Build.MODEL == \"Android SDK built for x86\" || Build.MODEL == \"Android SDK built for x86_64\") { rating++ } if (Build.HARDWARE == \"ranchu\") { rating++ } if (Build.FINGERPRINT.contains(\"sdk_google_phone_arm64\") || Build.FINGERPRINT.contains(\"sdk_google_phone_armv7\") ) { rating++ } var result = (Build.FINGERPRINT.startsWith(\"generic\") || Build.MODEL.contains(\"google_sdk\") || Build.MODEL.lowercase().contains(\"droid4x\") || Build.MODEL.contains(\"Emulator\") || Build.MODEL.contains(\"Android SDK built for x86\") || Build.MANUFACTURER.contains(\"Genymotion\") || Build.HARDWARE == \"goldfish\" || Build.HARDWARE == \"vbox86\" || Build.PRODUCT == \"sdk\" || Build.PRODUCT.startsWith( \"google_sdk\") || Build.PRODUCT == \"sdk_x86\" || Build.PRODUCT == \"vbox86p\" || Build.BOARD.lowercase() .contains(\"nox\") || Build.BOOTLOADER.lowercase().contains(\"nox\") || Build.HARDWARE.lowercase().contains(\"nox\") || Build.PRODUCT.lowercase().contains(\"nox\") || Build.SERIAL.lowercase().contains(\"nox\") || Build.HOST.contains(\"Droid4x-BuildStation\") || Build.MANUFACTURER.startsWith(\"iToolsAVM\") || Build.DEVICE.startsWith(\"iToolsAVM\") || Build.MODEL.startsWith(\"iToolsAVM\") || Build.BRAND.startsWith(\"generic\") || Build.HARDWARE.startsWith(\"vbox86\")) if (result) return true result = result or (Build.BRAND.startsWith(\"generic\") \u0026\u0026 Build.DEVICE.startsWith(\"generic\")) if (result) return true result = result or (\"google_sdk\" == Build.PRODUCT) return if (result) true else rating \u003e= 2 } private fun checkQEmuDrivers(): Boolean { for (drivers_file in arrayOf(File(\"/proc/tty/drivers\"), File(\"/proc/cpuinfo\"))) { if (drivers_file.exists() \u0026\u0026 drivers_file.canRead()) { val data = ByteArray(1024) try { val `is`: InputStream = FileInputStream(drivers_file) `is`.read(data) `is`.close() } catch (exception: Exception) { exception.printStackTrace() } val driverData = String(data) for (known_qemu_driver in QEMU_DRIVERS) { if (driverData.contains(known_qemu_driver)) { return true } } } } return false } private fun checkAdvanced(): Boolean { return (checkFiles(GENY_FILES) || checkFiles(ANDY_FILES) || checkFiles(NOX_FILES) || checkQEmuDrivers() || checkFiles(PIPES) || checkFiles(X86_FILES)) } private fun checkFiles(targets: Array\u003cString\u003e): Boolean { for (pipe in targets) { val qemuFile = File(pipe) if (qemuFile.exists()) { return true } } return false } fun checkPackageName(context: Context): Boolean { val packageManager = context.packageManager val intent = Intent(Intent.ACTION_MAIN, null) intent.addCategory(Intent.CATEGORY_LAUNCHER) val availableActivities = packageManager.queryIntentActivities(intent, 0) for (resolveInfo in availableActivities) { if (resolveInfo.activityInfo.packageName.startsWith(\"com.bluestacks.\")) { return true } } val packages = packageManager .getInstalledApplications(PackageManager.GET_META_DATA) for (packageInfo in packages) { val packageName = packageInfo.packageName if (packageName.startsWith(\"com.vphone.\")) { return true } else if (packageName.startsWith(\"com.bignox.\")) { return true } else if (packageName.startsWith(\"com.nox.mopen.app\")) { return true } else if (packageName.startsWith(\"me.haima.\")) { return true } else if (packageName.startsWith(\"com.bluestacks.\")) { return true } else if (packageName.startsWith(\"cn.itools.\") \u0026\u0026 Build.PRODUCT.startsWith(\"iToolsAVM\")) { return true } else if (packageName.startsWith(\"com.kop.\")) { return true } else if (packageName.startsWith(\"com.kaopu.\")) { return true } else if (packageName.startsWith(\"com.microvirt.\")) { return true } else if (packageName == \"com.google.android.launcher.layouts.genymotion\") { return true } } val manager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager val runningServices = manager.getRunningServices(30) for (serviceInfo in runningServices) { val serviceName = serviceInfo.service.className if (serviceName.startsWith(\"com.bluestacks.\")) { return true } } return false }}Check Runtime Environment: During runtime, it is essential to validate environment variables, such as running processes, file access, and installed applications, as well as system properties, to detect any anomalies. This check should be performed outside the Android environment, on the backend side. Therefore, before executing any transaction-related actions, the current environment information should be sent for verification.Below is a code snippet to retrieve all the necessary information.import android.system.ErrnoExceptionimport android.system.Osimport android.system.OsConstantsimport android.util.Logimport java.io.BufferedReaderobject SecureEnvironmentCheckerInfo { private const val TAG = \"SecureEnvironmentCheckerInfo\"// The verified paths are : // \"/data/local/\",// \"/data/local/bin/\",// \"/data/local/xbin/\",// \"/sbin/\",// \"/system/bin/\",// \"/system/bin/.ext/\",// \"/system/bin/failsafe/\",// \"/system/sd/xbin/\",// \"/system/usr/we-need-root/\",// \"/system/xbin/\",// \"/system/etc/\",// \"/data/\",// \"/dev/\" fun getFileAccesses(paths: Array\u003cString\u003e): HashMap\u003cString, Boolean\u003e { Log.d(TAG, \"Checking file accesses using system calls\") val fileAccesses = HashMap\u003cString, Boolean\u003e() for (path in paths) { fileAccesses[path] = try { Os.access(path, OsConstants.F_OK) } catch (e: ErrnoException) { false } } Log.d(TAG, \"Checked ${fileAccesses.size} file accesses\") return fileAccesses } fun getSystemProperties(): HashMap\u003cString, String\u003e? { Log.d(TAG, \"Check system properties using property service\") val systemCommand = \"getprop\" val content = getOutput(systemCommand, event) ?: return null val systemProperties = SystemPropertyParser.parse(content) if (systemProperties != null) { Log.d(TAG, \"Retrieve${systemProperties.size} system properties\") } else { Log.e(TAG, \"Retrieve system properties from '$systemCommand' output\") } return systemProperties } fun getInstalledPackages(): Array\u003cString\u003e? { Log.d(TAG, \"Retrieve installed packages using package manager with user 0\") val systemCommand = \"pm list packages --user 0\" val content = getOutput(systemCommand) ?: return null val installedPackages = PackageParser.parse(content) Log.d(TAG, \"Retrieved ${installedPackages.size} installed packages\") return installedPackages } private fun getOutput(systemCommand: String): String? { var process: Process? = null return try { process = Runtime.getRuntime().exec(systemCommand) val output = process!!.inputStream.bufferedReader().use(BufferedReader::readText) val exitValue = process.waitFor() if (exitValue == 0) { output } else { Log.e(TAG, \"'$systemCommand' command terminated with exit value $exitValue\") null } } catch (e: Exception) { Log.e(TAG, \"Error occurred while executing '$systemCommand' command: $e\") null } finally { process?.destroy() if (process?.isAlive == true) { process.destroyForcibly() } } }}Anti-Sideloading: Restrict APK installation from untrusted sources, we recommand to download the application from Google play by checking the vendor application :object SideLoadingDetector { private const val AUTHORIZED_APP_VENDOR = \"com.android.vending\" private fun getInstallerPackageName(context: Context) = context.packageManager .getInstallSourceInfo(context.packageName) .installingPackageName fun isAppSideLoaded(context: Context): Boolean { return try { getInstallerPackageName(context) } catch (e: IllegalArgumentException) { Log.e(TAG, \"Cannot access to app installer\", e) null } ?.also { Log.d(TAG, \"Package installer is: $it\") } ?.takeIf { it == AUTHORIZED_APP_VENDOR } ?.let { false } ?: (true).also { Log.e(TAG, \"App side loaded\") } } }}Anti-Multiwindow: Prevent multi-window mode to avoid overlay attacks :fun MultiWindowModeDetector(activity: Activity): Boolean = activity.isInMultiWindowMode3. Preventing Data Leakage \u0026 Unauthorized AccessIn payment applications, data leakage and unauthorized access present significant security risks, potentially exposing sensitive user information such as Payment Card details (PAN, CVV, etc.). To mitigate these security vulnerabilities, it is crucial to implement the following protective measures:Log Protection: Avoid logging sensitive data using Log.d(); use structured logging with Timber…In best case, we should remove any logs using as example proguard rules (in case, we need logs for monotring, we must encrypt it before send it to backend) :# Remove Android logging calls-assumenosideeffects class android.util.Log { public static boolean isLoggable(java.lang.String, int); public static int v(...); public static int d(...); public static int i(...); public static int w(...); public static int e(...); public static int println(int, java.lang.String, java.lang.String); public static java.lang.String getStackTraceString(java.lang.Throwable);}Secure Database \u0026 Preference : We can use SQLCipher for encrypted database storage or save encrypted data directly in your DB and for shared pref, we recammand to use this library from Google EncryptedSharedPreferences.Secure Binding Services: When using services, it is essential to restrict AIDL exposure by properly configuring export and enable flags. Additionally, applying signature-based permissions ensures that only trusted applications with the correct signature can interact with the service, enhancing security:Here is below snippet code to how secure Android Service :\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003cuses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/\u003e \u003cpermission android:name=\"com.payment.app.permission.BIND_SERVICE\" android:protectionLevel=\"signature\" /\u003e \u003capplication android:name=\"com.payment.app.Application\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\"\u003e \u003cactivity android:name=\"com.payment.app.MainActivity\" android:exported=\"true\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.MAIN\" /\u003e \u003ccategory android:name=\"android.intent.category.LAUNCHER\" /\u003e \u003c/intent-filter\u003e \u003c/activity\u003e \u003cservice android:name=\"com.payment.app.service.CoreService\" android:exported=\"true\" android:enabled=\"true\" android:permission=\"com.payment.app.BIND_SERVICE\" \u003e \u003cintent-filter\u003e \u003caction android:name=\"com.payment.app.action.BIND_SERVICE\" /\u003e \u003c/intent-filter\u003e \u003c/service\u003e \u003c/application\u003e\u003c/manifest\u003eAnti-Screenshot \u0026 Overlay Detection: Android purpose multiple mechanisme to protect from overlay attacks : Use FLAG_SECURE to block screenshots and to block overlays using this flag permission android.permission.HIDE_OVERLAY_WINDOWS(introduced in Android 12). For oldest Android version, we can implement a custom solution to inject event in random touch and intercept it.Here is fully example of Overlay Detector class :import android.annotation.SuppressLintimport android.app.Activityimport android.app.Instrumentationimport android.graphics.Pointimport android.os.Buildimport android.os.SystemClockimport android.util.Logimport android.view.MotionEventimport android.view.Viewimport android.view.WindowManagerimport kotlinx.coroutines.*import kotlin.math.absoluteValueclass OverlayDetection( screenSize: Point, private var onOverlayDetected: (() -\u003e Unit)? = null) { companion object { private val TAG = OverlayDetection::class.java.simpleName const val INJECTED_STATE = -35 private const val OFFSET_PERCENT = 10 private const val RETRY_DELAY_INJECT_EVENT = 1500L //1.5 seconds private fun getFlagsWindow() = MotionEvent.FLAG_WINDOW_IS_OBSCURED or MotionEvent.FLAG_WINDOW_IS_PARTIALLY_OBSCURED } private var lastCallNotCaught = false private var overlayDetectionRunning = true private val scope = CoroutineScope(Dispatchers.IO) private val instrumentation = Instrumentation() private var view: SecureViewContainer? = null private var activity: Activity? = null private val offset: Point = Point( (screenSize.x * OFFSET_PERCENT) / 100, (screenSize.y * OFFSET_PERCENT) / 100 ) private val range = Point( screenSize.x - (2 * offset.x), screenSize.y - (2 * offset.y), ) private var job: Job? = null fun setViewToProtect(view: SecureViewContainer) { Log.d(TAG, \"OverlayDetection: protect view $view\") this.view = view activity = view.context as Activity this.view?.setOnTouchListener { _: View?, event: MotionEvent -\u003e onOverlayEventDetected(event) false } this.view?.setOnOverlayDetectionListener { onOverlayEventDetected(event) } } private fun hasSecureFlag(): Boolean = activity?.window?.attributes?.flags?.let { (it and WindowManager.LayoutParams.FLAG_SECURE) != 0 } ?: false private fun injectEvent() { if (lastCallNotCaught) { onOverlayDetected.invoke() } else { injectTouchEvent() } } private fun injectTouchEvent() = randomPoint().also { point -\u003e if (Build.VERSION.SDK_INT \u003c Build.VERSION_CODES.TIRAMISU) { if (point.value != null) { Log.d(TAG, \"Inject event at ${point.value}\") lastCallNotCaught = true try { touch(point.value, MotionEvent.ACTION_DOWN) touch(point.value, MotionEvent.ACTION_UP) } catch (e: Exception) { Log.e(TAG, e.stackTraceToString()) onOverlayDetected.invoke() } } else { Log.e(TAG, \"Random point can't be generated for inject event\") onOverlayDetected.invoke() } } else { Log.w(TAG, \"ANDROID 13: Touch injection deactivated at $point\") } } private fun touch(point: Point, event: Int) { instrumentation.sendPointerSync( MotionEvent.obtain( SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), event, point.x.toFloat(), point.y.toFloat(), INJECTED_STATE ) ) } private fun randomPoint(): Rand.Result\u003cPoint\u003e { val xRand = Rand.nextInt() val x = xRand.value ?: return Rand.Result(xRand.nativeResult!!) val yRand = Rand.nextInt() val y = yRand.value ?: return Rand.Result(yRand.nativeResult!!) val point = Point((x.absoluteValue % range.x) + offset.x, (y.absoluteValue % range.y) + offset.y) return Rand.Result(point) } fun start() { stop() overlayDetectionRunning = true lastCallNotCaught = false Log.d(TAG, \"Start overlay protection\") job = scope.launch { delay(1000L) view?.requestFocus() while (overlayDetectionRunning) { injectEvent() delay(RETRY_DELAY_INJECT_EVENT) } } } fun stop() { overlayDetectionRunning = false lastCallNotCaught = false Log.d(TAG, \"Stop overlay protection\") job?.cancel() job = null } fun forbidMultiWindowMode(activity: Activity): Boolean = activity.isInMultiWindowMode fun onOverlayEventDetected(event: MotionEvent) { Log.d(TAG, \"Received motion event: state(${event.metaState}) flags(${event.flags})\") when { !hasSecureFlag() -\u003e onOverlayEventDetected(event) event.metaState != INJECTED_STATE -\u003e Unit event.flags == MotionEvent.ACTION_MOVE -\u003e Unit // Workaround to avoid false/positive toast overlay detection (event.flags and getFlagsWindow()) != 0 -\u003e onOverlayDetected.invoke() } lastCallNotCaught = false }}import android.content.Contextimport android.util.AttributeSetimport android.util.Logimport android.view.MotionEventimport androidx.constraintlayout.widget.ConstraintLayoutclass SecureViewContainer @JvmOverloads constructor( context: Context, attributeSet: AttributeSet? = null, defStyle: Int = 0,) : ConstraintLayout( context, attributeSet, defStyle) { companion object { private val TAG = SecureViewContainer::class.java.simpleName } private var onOverlayDetectionListener: (() -\u003e Unit)? = null fun setOnOverlayDetectionListener(onOverlayDetectionListener: () -\u003e Unit) { this.onOverlayDetectionListener = onOverlayDetectionListener } override fun onFilterTouchEventForSecurity(ev: MotionEvent): Boolean { val checkIsObscured = ev.flags and MotionEvent.FLAG_WINDOW_IS_OBSCURED != 0 val checkIsPartiallyObscured = ev.flags and MotionEvent.FLAG_WINDOW_IS_PARTIALLY_OBSCURED != 0 Log.d(TAG, \"onFilterTouchEventForSecurity: \" + \"isObscured: $checkIsObscured, isPartiallyObscured: $checkIsPartiallyObscured\") if (checkIsObscured || checkIsPartiallyObscured) { onOverlayDetectionListener?.invoke() } return super.onFilterTouchEventForSecurity(ev) }}\u003ccom.payment.app.SecureViewContainer xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"\u003e \u003candroidx.appcompat.widget.AppCompatImageView android:id=\"@+id/icon\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" android:src=\"@drawable/icon\" /\u003e\u003c/com.payment.app.SecureViewContainer\u003eAnti-Camera \u0026 Microphone Abuse: Restrict background access using Android 10+ APIs and put some mechanism detection when camera is open and used by another threat application, here is an example to handle using the camera by another application:import android.content.Contextimport android.hardware.camera2.CameraManagerimport android.util.Logclass CameraDetector(context: Context, private var onCameraDetected: (() -\u003e Unit)? = null) { companion object { private val TAG = CameraDetector::class.java.simpleName } private val manager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager private val cameraAvailabilityCallback = object : CameraManager.AvailabilityCallback() { override fun onCameraUnavailable(cameraId: String) { super.onCameraUnavailable(cameraId) onCameraDetected.invoke() } } fun start() { try { manager.registerAvailabilityCallback(cameraAvailabilityCallback, null) } catch (e: Exception) { Log.e(TAG, \"Cannot register availability camera callback\", e) } } fun stop() { try { manager.unregisterAvailabilityCallback(cameraAvailabilityCallback) } catch (e: Exception) { Log.e(TAG, \"Cannot unregister availability camera callback\", e) } }}Anti-Accessibility Exploits: When Android introduced the Accessibility API, it was intended for beneficial use cases. However, over time, it has been exploited and considered a potential backdoor. To mitigate this risk and prevent unauthorized access to on-screen information via the Accessibility API.Here is an example of how to implement proper protections.:import android.graphics.Rectimport android.view.Viewimport android.view.accessibility.AccessibilityNodeInfoimport androidx.core.view.ViewCompatclass SecuredAccessibilityDelegateHelper(val view: View) : View.AccessibilityDelegate() { override fun onInitializeAccessibilityNodeInfo(host: View, info: AccessibilityNodeInfo) { super.onInitializeAccessibilityNodeInfo(host, info) view.importantForAccessibility = ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS info.isEnabled = false info.setBoundsInScreen(Rect(0, 0, 0, 0)) info.text = \"\" }}class SecuredText(context: Context, attrs: AttributeSet) : AppCompatTextView(context, attrs) { init { accessibilityDelegate = SecuredAccessibilityDelegateHelper(this) }}\u003ccom.payement.app.SecuredText android:id=\"@+id/text\" android:layout_width=\"wrap_content\"xxx android:layout_height=\"30dp\" android:gravity=\"center\" android:textColor=\"@color/white\" android:textSize=\"15sp\" android:textStyle=\"bold\" /\u003e4. Strengthening Authentication \u0026 Secure CommunicationBiometric Authentication: Starting Android 6.0 the Biometric API exist for strong user authentication like fingerprint, face, or iris which be used to verify the identity of the user before doing any transaction.Secure Connection (TLS/SSL): Communication must occur over a secure channel using protocols such as TLS/SSL. It is highly recommended to enforce TLS 1.2 or higher (preferably TLS 1.3 if supported by the server). Additionally, implementing certificate pinning is mandatory to prevent man-in-the-middle attacks. Below is the process for certificate enrollment :Android Certificate EnrollmentHTTPS/SSL Security: To prevent Man-in-the-Middle (MITM) attacks, Android 7 (API 24) introduced the Network Security Config, allowing developers to customize network security settings within their applications. Below is an example demonstrating how to configure it properly at manifest file:\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"co.payement.app\"\u003e \u003capplication android:networkSecurityConfig=\"@xml/network_security_config\"\u003e ... \u003c/application\u003e\u003c/manifestAt network security config file :\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\u003cnetwork-security-config\u003e \u003cdomain-config\u003e \u003cdomain includeSubdomains=\"true\"\u003epayment-domain.com\u003c/domain\u003e \u003cpin-set\u003e \u003cpin digest=\"SHA-256\"\u003eZEDJEEKKEKLEE+fibTqbIsWNR/X7CWNVW+CEEA=\u003c/pin\u003e \u003cpin digest=\"SHA-256\"\u003eBFDBDFDFVDccvVFVVcfdesdsdvsdsdvsd=\u003c/pin\u003e \u003c/pin-set\u003e \u003c/domain-config\u003e\u003c/network-security-config\u003eSecure Tokens (JWE, UUID): In some cases of Android authentication processes, tokenization is required. There are different types of tokens, such as JWT, JWS, JWE, and JWK. For security reasons, we recommend using the most suitable and secure type based on the application’s needs as encrypted token JWE.API Key Protection: Every connection that requires API keys should ensure they are stored securely, either as a Gradle property or an environment variable. Google provides an interesting plugin, Secrets Gradle Plugin, to help manage sensitive data securely. Additionally, it is recommended to restrict API key usage by specifying the allowed package ID in the API provider settings..5. Secure Cryptography \u0026 Key ManagementSecure Cryptography: In the programming world, cryptography is a vast and complex topic that cannot be fully covered in this article. However, there are key recommendations from Android security guidelines and well-known security organizations such as NIST (USA), ECRYPT (EU), and CRYPTREC (Japan) for selecting the appropriate cryptographic algorithms and best practices :From Android recommandation :Recommended cryptography algorithm by AndroidFrom NIST :Recommended cryptography algorithm by NISTFrom ECRYPTRecommended cryptography algorithm by ECRYPTFrom CRYPTRECRecommended cryptography algorithm by CRYPTRECand finally, to store the encrypted locally, it’s required to generate it by the Android Keystore API using Hardware-backed KeystoreKey Rotation: Programming security is time-sensitive, and in this context, cryptographic keys must be regularly updated to mitigate potential risks. It is recommended not to exceed a 90-day lifespan for secure keys to ensure optimal protection.Use Secure Random: When generating secure keys, one crucial parameter that must not be ignored is the random field. To generate it, it should come from trusted entropy sources such as the SecureRandom API. Therefore, we must avoid using any other sources for generating random values.6. Enhancing System Security \u0026 UpdatesSecure Elements \u0026 TEE (Trusted Execution Environment): As said in the last point, Android Keystore should be generated on Trusted Execution Environment (TEE) storage backed in StrongBox introduced in Android 9 (for lowest version, we can use software white box but it’s must be respect the security standard).GMS Security Updates: Google provides GMS (Google Mobile Services), which checks for any security updates. To verify this, we should check the currently installed version of Google Play Services. Below is the minimum version that should be present on the device :object GooglePlayServicesChecker { private val TAG = GooglePlayServices::class.java.simpleName private const val MINIMUM_VERSION = 201516018 private val availability = GoogleApiAvailability.getInstance() fun isSupported(context: Context): Boolean = (availability.isGooglePlayServicesAvailable( context, MINIMUM_VERSION ) == ConnectionResult.SUCCESS) .also { Log.d(TAG, \"Google Play Services availability: $it\") try { ProviderInstaller.installIfNeeded(context) Log.d(TAG, \"Google Play Services update ProviderInstaller installIfNeeded\") } catch (e: GooglePlayServicesRepairableException) { Log.e(TAG, \"An error has occurred\", e) // Indicates that Google Play services is out of date, disabled, etc. // Prompt the user to install/update/enable Google Play services. GoogleApiAvailability.getInstance() .showErrorNotification(context, e.connectionStatusCode) Log.e(TAG, \"Error occurred during check supported GooglePlayServices :\", e) } catch (e: GooglePlayServicesNotAvailableException) { // Indicates a non-recoverable error; the ProviderInstaller is not able // to install an up-to-date Provider. // Note: As the min version 201516018 is higher than which required 11925000 (extracted from // ProviderInstaller class) so no need to block the user by out-dated google play service popup. Log.e(TAG, \"An error has occurred\", e) } } .also { Log.d(TAG, \"Google Play Services version: \" + getVersion(context)) } private fun getVersion(context: Context): Long? = try { PackageInfoCompat.getLongVersionCode( context.packageManager.getPackageInfo( GoogleApiAvailability.GOOGLE_PLAY_SERVICES_PACKAGE, 0 ) ).also { Log.d(TAG, \"Google Play Services version: $it\") } } catch (e: PackageManager.NameNotFoundException) { Log.e(TAG, \"Google Play Services package not found\", e) null }}Backup Security: In Android, to retrieve your preferences after reinstalling an application, we use the backup mechanism. However, this represents a security issue, which is why it has been deprecated starting from Android 12 and may be removed in future versions. We recommend disabling auto-backups for sensitive data by setting android:allowBackup=\"false\". If there is a need to use backups, make sure not to store any sensitive data.CVE Patching \u0026 Dependency Updates: In Android, we have a higher probability to use third party library which can represent a vulenrability risk, so before integrating any library, we must check the origin , the maintainers community, the latest support date .. and after that we should regularly update and check for CVEs and finally use only Stable version.7. Advanced Security TechniquesSecure OpenGL: In some context , we need to draw some sensitive information in the screen as displaying the random PIN so to protect rendering data to be read illegaly from the RAM memory, Android purpose this flag EGL_PROTECTED_CONTENT_EXT used to protect the rendering data context.Here is below this intersting example code to create secured OpenGL context in Android :import android.content.Contextimport android.opengl.EGL14.*import android.opengl.GLSurfaceViewimport android.util.Logimport com.visa.BuildConfigimport javax.microedition.khronos.egl.*/** * A simple GLSurfaceView sub-class that demonstrate how to perform * OpenGL ES 2.0 rendering into a GL Surface. Note the following important * details: * * - The class must use a custom context factory to enable 2.0 rendering. * See ContextFactory class definition below. * * - The class must use a custom EGLConfigChooser to be able to select * an EGLConfig that supports 2.0. This is done by providing a config * specification to eglChooseConfig() that has the attribute * EGL10.ELG_RENDERABLE_TYPE containing the EGL_OPENGL_ES2_BIT flag * set. See ConfigChooser class definition below. * * - The class must select the surface's format, then choose an EGLConfig * that matches it exactly (with regards to red/green/blue/alpha channels * bit depths). Failure to do so would result in an EGL_BAD_MATCH error. * * - The class use some OpenGL protection extension if it's exist on the Android Device otherwise * the used context is standard. * About this mechanism of this protected extension EGL_PROTECTED_CONTENT_EXT = 0x32C0 : * * The attribute EGL_PROTECTED_CONTENT_EXT can be applied to EGL contexts, * EGL surfaces and EGLImages. If the attribute EGL_PROTECTED_CONTENT_EXT * is set to EGL_TRUE by the application, then the newly created EGL object * is said to be protected. A protected context is required to allow the * GPU to operate on protected resources, including protected surfaces and * protected EGLImages. * * GPU operations are grouped into pipeline stages. Pipeline stages can be * defined to be protected or not protected. Each stage defines * restrictions on whether it can read or write protected and unprotected * resources, as follows: * When a GPU stage is protected, it: * - Can read from protected resources * - Can read from unprotected resources * - Can write to protected resources * - Can NOT write to unprotected resources * * When a GPU stage is not protected, it: * - Can NOT read from protected resources * - Can read from unprotected resources * - Can NOT write to protected resources * - Can write to unprotected resources * */internal class GL2JNIView( context: Context?,) : GLSurfaceView(context) { companion object { private val TAG = GL2JNIView::class.java.simpleName private const val EGL_CONTEXT_CLIENT_ATTR_VERSION = 0x3098 private const val EGL_CONTEXT_CLIENT_VALUE_VERSION = 2 private const val EGL_EXTENSION_PROTECTED_CONTENT_NAME = \"EGL_EXT_protected_content\" private const val EGL_EXT_PROTECTED_CONTENT = 0x32C0 } init { val isSecureExtensionSupported = isSecureExtensionSupported() Log.d(TAG, \"OpenGl Secure extension supported : $isSecureExtensionSupported\") if (BuildConfig.DEBUG) { debugFlags = DEBUG_CHECK_GL_ERROR or DEBUG_LOG_GL_CALLS } setEGLContextFactory(ContextFactory(isSecureExtensionSupported)) setEGLWindowSurfaceFactory(WindowSurfaceFactory(isSecureExtensionSupported)) } internal inner class ContextFactory(private val secureContext: Boolean) : EGLContextFactory { override fun createContext(egl: EGL10, display: EGLDisplay, config: EGLConfig): EGLContext { val attrList = if (secureContext) { intArrayOf(EGL_CONTEXT_CLIENT_ATTR_VERSION, EGL_CONTEXT_CLIENT_VALUE_VERSION, EGL_EXT_PROTECTED_CONTENT, EGL_TRUE, EGL10.EGL_NONE) } else { intArrayOf(EGL_CONTEXT_CLIENT_VERSION, EGL_CONTEXT_CLIENT_VALUE_VERSION, EGL10.EGL_NONE) } val context = egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT, attrList) if (context == EGL10.EGL_NO_CONTEXT) { Log.e(TAG, \"Error creating EGL context.\") } checkEglError(\"eglCreateContext\") return context } override fun destroyContext(egl: EGL10, display: EGLDisplay, context: EGLContext) { if (!egl.eglDestroyContext(display, context)) { Log.e(\"DefaultContextFactory\", \"display: $display context: $context\") } } } internal inner class WindowSurfaceFactory(private val secureWindowSurface: Boolean) : EGLWindowSurfaceFactory { override fun createWindowSurface( egl: EGL10, display: EGLDisplay, config: EGLConfig, nativeWindow: Any, ): EGLSurface? { var result: EGLSurface? = null try { val attrList = if (secureWindowSurface) { intArrayOf(EGL_EXT_PROTECTED_CONTENT, EGL_TRUE, EGL10.EGL_NONE) } else { intArrayOf(EGL10.EGL_NONE, EGL10.EGL_NONE, EGL10.EGL_NONE) } result = egl.eglCreateWindowSurface(display, config, nativeWindow, attrList) checkEglError(\"eglCreateWindowSurface\") } catch (e: IllegalArgumentException) { Log.e(TAG, \"eglCreateWindowSurface\", e) } return result } override fun destroySurface(egl: EGL10, display: EGLDisplay, surface: EGLSurface) { egl.eglDestroySurface(display, surface) } } private fun isSecureExtensionSupported(): Boolean { val display: android.opengl.EGLDisplay? = eglGetDisplay(EGL_DEFAULT_DISPLAY) val extensions = eglQueryString(display, EGL10.EGL_EXTENSIONS) return extensions != null \u0026\u0026 extensions.contains(EGL_EXTENSION_PROTECTED_CONTENT_NAME) } private fun checkEglError(methodName: String) { val eglResult = eglGetError() if (eglResult == EGL_SUCCESS) { val message = \"$methodName succeeded without error (EGL_SUCCESS)\" Log.d(TAG, message) } else { val errorHexString = \"0x${Integer.toHexString(eglResult)}\" val errorDesc = eglResultDesc(eglResult) val message = \"$methodName: EGL error $errorHexString encountered. $errorDesc\" Log.e(TAG, message) } } // https://registry.khronos.org/EGL/sdk/docs/man/html/eglGetError.xhtml private fun eglResultDesc(eglResult: Int) = when (eglResult) { EGL_SUCCESS -\u003e \"The last function succeeded without error.\" EGL_NOT_INITIALIZED -\u003e \"EGL is not initialized, or could not be initialized, for the specified EGL display connection.\" EGL_BAD_ACCESS -\u003e \"EGL cannot access a requested resource (for example a context is bound in another thread).\" EGL_BAD_ALLOC -\u003e \"EGL failed to allocate resources for the requested operation.\" EGL_BAD_ATTRIBUTE -\u003e \"An unrecognized attribute or attribute value was passed in the attribute list.\" EGL_BAD_CONTEXT -\u003e \"An EGLContext argument does not name a valid EGL rendering context.\" EGL_BAD_CONFIG -\u003e \"An EGLConfig argument does not name a valid EGL frame buffer configuration.\" EGL_BAD_CURRENT_SURFACE -\u003e \"The current surface of the calling thread is a window, pixel buffer or pixmap that is no longer valid.\" EGL_BAD_DISPLAY -\u003e \"An EGLDisplay argument does not name a valid EGL display connection.\" EGL_BAD_SURFACE -\u003e \"An EGLSurface argument does not name a valid surface (window, pixel buffer or pixmap) configured for GL rendering.\" EGL_BAD_MATCH -\u003e \"Arguments are inconsistent (for example, a valid context requires buffers not supplied by a valid surface).\" EGL_BAD_PARAMETER -\u003e \"One or more argument values are invalid.\" EGL_BAD_NATIVE_PIXMAP -\u003e \"A NativePixmapType argument does not refer to a valid native pixmap.\" EGL_BAD_NATIVE_WINDOW -\u003e \"A NativeWindowType argument does not refer to a valid native window.\" EGL_CONTEXT_LOST -\u003e \"A power management event has occurred. The application must destroy all contexts and reinitialise OpenGL ES state and objects to continue rendering.\" else -\u003e \"\" }}Multiprocess Security: To avoid a global disaster in the event that reading data from memory is compromised, we recommend defining a multiprocess mechanism using isolatedProcess. This helps to prevent unauthorized access by ensuring that each process operates in a separate environment, making it more difficult for one process to access the memory or data of another..As example, introduce an isolted process service container :\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.payement.app\" xmlns:tools=\"http://schemas.android.com/tools\"\u003e \u003capplication\u003e \u003cservice android:name=\"com.payement.app.service.IsoltedProcessService\" android:process=\":isoltedProcessProcess\" /\u003e \u003c/application\u003e\u003c/manifest\u003eBonus: Here is some useful resources to be up to date by security world of Android: android_securecoding_en.pdf , security-best-practices, www-project-mobile-app-security.ConclusionBy reading this article, you can get an idea of how a simple payment transaction, which takes only a few seconds, goes through a comprehensive security workflow. Also, keep in mind that there is no final version of security — it’s crucial to continuously stay aligned and updated with the evolving security landscape of Android.And finally remember, in every update of your security layer, don’t forget this quote:“Don’t let security kill your business, try to find the right balance.”For any question \u0026 suggestion, Let’s discuss !",
  "image": "https://miro.medium.com/v2/resize:fit:683/1*CE80FjIOAuejO63_qItW6w.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@sofienrahmouni?source=post_page---byline--630b65905b9a---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Sofien Rahmouni\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*brOLc9Ce6l4u85AAHWzJ9g.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--630b65905b9a---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eSecure Payment Transaction TapToPay Android\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"97a0\"\u003eOver the past few months, I’ve been deeply involved in the development of an Android payment application, where security has been a fundamental pillar of the entire process.\u003c/p\u003e\u003cp id=\"7acc\"\u003eWorking on this project has given me invaluable insights into the intricate world of securing Android applications.\u003c/p\u003e\u003cp id=\"c1cb\"\u003eThe protection levels on this Android Payment App, can be devided in \u003cstrong\u003eCompilation Layer, Runtime Layer\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"44a5\"\u003eFor free complete read access, please continue with this link :\u003ca href=\"https://medium.com/@sofienrahmouni/securing-android-behind-a-few-seconds-of-payment-transaction-bf6817119d51?sk=0117880616ac48dde2590f0b8138d766\" rel=\"noopener\"\u003e https://medium.com/@sofienrahmouni/securing-android-behind-a-few-seconds-of-payment-transaction-bf6817119d51?source=friends_link\u0026amp;sk=0117880616ac48dde2590f0b8138d766\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"452f\"\u003e1. Protecting Your App from Reverse Engineering \u0026amp; Debugging\u003c/h2\u003e\u003cul\u003e\u003cli id=\"be7c\"\u003e\u003cstrong\u003eAnti-Developer-Options\u003c/strong\u003e: Developer options activation can be the first door for an attacker to start so we should check it :\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"1a51\"\u003efun isDeveloperOptionsEnabled(context: Context): Boolean {\u003cbr/\u003e        return try {\u003cbr/\u003e            Settings.Global.getInt(\u003cbr/\u003e                context.contentResolver,\u003cbr/\u003e                Settings.Global.DEVELOPMENT_SETTINGS_ENABLED\u003cbr/\u003e            ) == 1\u003cbr/\u003e        } catch (e: Exception) {\u003cbr/\u003e            Log.e(\u0026#34;DeveloperOptions\u0026#34;, \u0026#34;Error checking Developer Options\u0026#34;, e)\u003cbr/\u003e            false\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"d997\"\u003e\u003cstrong\u003eAnti-Debugging\u003c/strong\u003e: Detect debuggers at runtime using \u003ccode\u003eisDebuggerConnected()\u003c/code\u003e :\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"91b5\"\u003eHere is snippet code used to detect if the application was build on debug mode and when the debbuger attached:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6396\"\u003e// Check debbugable flag\u003cbr/\u003eval isDebuggable =(context.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"bc37\"\u003e// Check debugger is connected at runtime\u003cbr/\u003eimport android.os.Debug.isDebuggerConnected\u003c/span\u003e\u003cspan id=\"dd8e\"\u003eval isDebuggerConnected= isDebuggerConnected()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9b04\"\u003eThe debug check also can be done at the system level using native method\u003ccode\u003eptrace()\u003c/code\u003e :\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"23cb\"\u003ebool = ptrace(PTRACE_TRACEME, 0, 0, 0) == -1;\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"77e9\"\u003e\u003cstrong\u003eAnti-Root Detection\u003c/strong\u003e: As known in the Android world, the key to every attack vector starts with obtaining privileged access as an admin or root user. Therefore, we must protect our application by implementing root detection :\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"e23e\"\u003eobject RootDetectionUtil {\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"9de6\"\u003e    fun isRooted(): Boolean {\u003c/span\u003e\u003cspan id=\"57ed\"\u003e        // Check known binary root file paths\u003cbr/\u003e        val paths = listOf(\u003cbr/\u003e            \u0026#34;/data/local\u0026#34;, \u0026#34;/data/local/bin\u0026#34;, \u0026#34;/data/local/xbin\u0026#34;, \u0026#34;/sbin\u0026#34;,\u003cbr/\u003e            \u0026#34;/su/bin\u0026#34;, \u0026#34;/system\u0026#34;, \u0026#34;/system/app\u0026#34;, \u0026#34;/system/bin\u0026#34;,\u003cbr/\u003e            \u0026#34;/system/bin/.ext\u0026#34;, \u0026#34;/system/bin/failsafe\u0026#34;, \u0026#34;/system/sd/xbin\u0026#34;,\u003cbr/\u003e            \u0026#34;/system/usr/we-need-root\u0026#34;, \u0026#34;/system/xbin\u0026#34;\u003cbr/\u003e        )\u003c/span\u003e\u003cspan id=\"33b2\"\u003e        val binaries = listOf(\u003cbr/\u003e            \u0026#34;magisk\u0026#34;, \u0026#34;su\u0026#34;, \u0026#34;su2\u0026#34;, \u0026#34;superuser.apk\u0026#34;, \u0026#34;Superuser.apk\u0026#34;,\u003cbr/\u003e            \u0026#34;su-backup\u0026#34;, \u0026#34;.su\u0026#34;, \u0026#34;busybox\u0026#34;, \u0026#34;busybox.apk\u0026#34;\u003cbr/\u003e        )\u003c/span\u003e\u003cspan id=\"5279\"\u003e        for (path in paths) {\u003cbr/\u003e            for (bin in binaries) {\u003cbr/\u003e                val filePath = File(\u0026#34;$path/$bin\u0026#34;)\u003cbr/\u003e                if (filePath.exists()) {\u003cbr/\u003e                    Log.e(\u0026#34;RootDetection\u0026#34;, \u0026#34;Smartphone rooted ($filePath)\u0026#34;)\u003cbr/\u003e                    return true\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/span\u003e\u003cspan id=\"766e\"\u003e        // Check for the existence of the \u0026#34;su\u0026#34; binary      \u003cbr/\u003e        try {\u003cbr/\u003e            if (Runtime.getRuntime().exec(arrayOf(\u0026#34;/system/xbin/which\u0026#34;, \u0026#34;su\u0026#34;))\u003cbr/\u003e                    .inputStream.bufferedReader().readLine() != null\u003cbr/\u003e            ) {\u003cbr/\u003e                return true\u003cbr/\u003e            }\u003cbr/\u003e        } catch (e: Exception) {\u003cbr/\u003e            e.printStackTrace()\u003cbr/\u003e        }\u003c/span\u003e\u003cspan id=\"e2c4\"\u003e        // Check if AOSP ROM was signed with release keys else means isRooted\u003cbr/\u003e        if (android.os.Build.TAGS?.contains(\u0026#34;test-keys\u0026#34;) == true) {\u003cbr/\u003e            return true\u003cbr/\u003e        }\u003c/span\u003e\u003cspan id=\"fb10\"\u003e        Log.d(\u0026#34;RootDetection\u0026#34;, \u0026#34;Smartphone not rooted\u0026#34;)\u003cbr/\u003e        return false\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"51fa\"\u003e\u003cstrong\u003eObfuscation\u003c/strong\u003e: To make the reverse engineering process more difficult, Android offers open-source obfuscation tools such as \u003ca href=\"https://www.guardsquare.com/proguard\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eProGuard\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e and R8\u003c/strong\u003e, as well as\u003cstrong\u003e more advanced paid options like\u003c/strong\u003e \u003ca href=\"https://www.guardsquare.com/dexguard\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDexGuard\u003c/strong\u003e\u003c/a\u003e, to make decompilation harder.\u003c/li\u003e\u003cli id=\"625f\"\u003e\u003cstrong\u003eAnti-Tampering\u003c/strong\u003e: On the other hand, Google offers an interesting solution to verify app integrity using the \u003ca href=\"https://developer.android.com/google/play/integrity\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eGoogle Play Integrity API\u003c/strong\u003e\u003c/a\u003e. It is based on a verdict attestation service, making it a more reliable solution compared to local environment checks. However, this solution is subject to limitations, as Google provides only 10,000 free tokens per day.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"cf35\"\u003eHere is an example of \u003cstrong\u003edecoded response play integrity verdict \u003c/strong\u003e(The real world response is encrypted \u0026amp; encoded) :\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"be1a\"\u003e{\u003cbr/\u003e  \u0026#34;requestDetails\u0026#34;: {\u003cbr/\u003e    \u0026#34;requestPackageName\u0026#34;: \u0026#34;com.payment.app\u0026#34;,\u003cbr/\u003e    \u0026#34;nonce\u0026#34;: \u0026#34;b64_encoded_nonce\u0026#34;,\u003cbr/\u003e    \u0026#34;timestampMillis\u0026#34;: 1710000000000\u003cbr/\u003e  },\u003cbr/\u003e  \u0026#34;appIntegrity\u0026#34;: {\u003cbr/\u003e    \u0026#34;appRecognitionVerdict\u0026#34;: \u0026#34;PLAY_RECOGNIZED\u0026#34;,\u003cbr/\u003e    \u0026#34;packageName\u0026#34;: \u0026#34;com.payment.app\u0026#34;,\u003cbr/\u003e    \u0026#34;certificateSha256Digest\u0026#34;: [\u0026#34;b64_encoded_cert_hash\u0026#34;]\u003cbr/\u003e  },\u003cbr/\u003e  \u0026#34;deviceIntegrity\u0026#34;: {\u003cbr/\u003e    \u0026#34;deviceRecognitionVerdict\u0026#34;: [\u0026#34;MEETS_DEVICE_INTEGRITY\u0026#34;]\u003cbr/\u003e  },\u003cbr/\u003e  \u0026#34;accountDetails\u0026#34;: {\u003cbr/\u003e    \u0026#34;appLicensingVerdict\u0026#34;: \u0026#34;LICENSED\u0026#34;\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1120\"\u003eContinuing with \u003cstrong\u003eAnti-tampering\u003c/strong\u003e protection, we should also implement APK signature verification. It is recommended to perform this check on a remote server by sending the current certificate signature and comparing it on the server side.\u003c/p\u003e\u003cp id=\"ef69\"\u003eHere is below an example showing the mechanism to get signature application certificate :\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e0bb\"\u003eobject SignatureUtil {\u003cbr/\u003e    private val TAG = SignatureUtil::class.java.simpleName\u003cbr/\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"e24e\"\u003e     /**\u003cbr/\u003e      ** Get application signature to be used later in the check anti-tampering\u003cbr/\u003e      ** on Server side, in case have is different than setted in the BE means \u003cbr/\u003e      ** the application was changed/tampered. \u003cbr/\u003e      **/\u003cbr/\u003e    fun getApkSigners(context: Context): List\u0026lt;Signature\u0026gt;? {\u003cbr/\u003e        return try {\u003cbr/\u003e            if (context\u003cbr/\u003e                    .packageManager\u003cbr/\u003e                    .getPackageInfo(context.packageName, PackageManager.GET_SIGNING_CERTIFICATES)\u003cbr/\u003e                    .signingInfo?.hasMultipleSigners() == true\u003cbr/\u003e            ) {\u003cbr/\u003e                context\u003cbr/\u003e                    .packageManager\u003cbr/\u003e                    .getPackageInfo(context.packageName, PackageManager.GET_SIGNING_CERTIFICATES)\u003cbr/\u003e                    .signingInfo?.apkContentsSigners\u003cbr/\u003e                    ?.toList()\u003cbr/\u003e            } else {\u003cbr/\u003e                context\u003cbr/\u003e                    .packageManager\u003cbr/\u003e                    .getPackageInfo(context.packageName, PackageManager.GET_SIGNING_CERTIFICATES)\u003cbr/\u003e                    .signingInfo?.signingCertificateHistory\u003cbr/\u003e                    ?.toList()\u003cbr/\u003e            }\u003cbr/\u003e        } catch (e: PackageManager.NameNotFoundException) {\u003cbr/\u003e            Log.e(TAG, \u0026#34;Cannot read APK content signers\u0026#34;, e)\u003cbr/\u003e            null\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"32a9\"\u003eAnd finally, here is new anti-tampering protection addition was added in Android 10, the \u003ca href=\"https://developer.android.com/privacy-and-security/security-dex\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003euseEmbeddedDex\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e \u003c/strong\u003eflag which is really simple to be used.\u003c/p\u003e\u003cp id=\"3e96\"\u003eHere is an example how to use :\u003c/p\u003e\u003cul\u003e\u003cli id=\"f9cf\"\u003eIn manifest xml file, it should putted on it like this :\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"0805\"\u003e\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u003cbr/\u003e    package=\u0026#34;com.payement.app\u0026#34;\u003cbr/\u003e    xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"cb26\"\u003e    \u0026lt;application\u003cbr/\u003e        android:useEmbeddedDex=\u0026#34;true\u0026#34;\u003cbr/\u003e        tools:targetApi=\u0026#34;Q\u0026#34;\u0026gt;\u003cbr/\u003e        ....\u003cbr/\u003e    \u0026lt;/application\u0026gt;\u003cbr/\u003e\u0026lt;/manifest\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"35b4\"\u003eIn the build gradle :\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"f65c\"\u003epackagingOptions {\u003cbr/\u003e    dex {\u003cbr/\u003e      useLegacyPackaging = false\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e   // In case, bad behavior when genarting signed aab, we can use this aaptOptions\u003cbr/\u003e   //   aaptOptions {\u003cbr/\u003e   //     noCompress \u0026#39;dex\u0026#39;\u003cbr/\u003e   // }\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"891b\"\u003e2. Securing Execution Environment\u003c/h2\u003e\u003cul\u003e\u003cli id=\"6695\"\u003e\u003cstrong\u003eAnti-Emulation\u003c/strong\u003e: We should detect virtual environments VM detection Here is below method which check the multiple layers emulation environnements :\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"c9fe\"\u003eobject EmulatorDetection {\u003cbr/\u003e    private val QEMU_DRIVERS = arrayOf(\u0026#34;goldfish\u0026#34;)\u003cbr/\u003e    private val GENY_FILES = arrayOf(\u003cbr/\u003e        \u0026#34;/dev/socket/genyd\u0026#34;,\u003cbr/\u003e        \u0026#34;/dev/socket/baseband_genyd\u0026#34;\u003cbr/\u003e    )\u003cbr/\u003e    private val PIPES = arrayOf(\u003cbr/\u003e        \u0026#34;/dev/socket/qemud\u0026#34;,\u003cbr/\u003e        \u0026#34;/dev/qemu_pipe\u0026#34;\u003cbr/\u003e    )\u003cbr/\u003e    private val X86_FILES = arrayOf(\u003cbr/\u003e        \u0026#34;ueventd.android_x86.rc\u0026#34;,\u003cbr/\u003e        \u0026#34;x86.prop\u0026#34;,\u003cbr/\u003e        \u0026#34;ueventd.ttVM_x86.rc\u0026#34;,\u003cbr/\u003e        \u0026#34;init.ttVM_x86.rc\u0026#34;,\u003cbr/\u003e        \u0026#34;fstab.ttVM_x86\u0026#34;,\u003cbr/\u003e        \u0026#34;fstab.vbox86\u0026#34;,\u003cbr/\u003e        \u0026#34;init.vbox86.rc\u0026#34;,\u003cbr/\u003e        \u0026#34;ueventd.vbox86.rc\u0026#34;\u003cbr/\u003e    )\u003cbr/\u003e    private val ANDY_FILES = arrayOf(\u003cbr/\u003e        \u0026#34;fstab.andy\u0026#34;,\u003cbr/\u003e        \u0026#34;ueventd.andy.rc\u0026#34;\u003cbr/\u003e    )\u003cbr/\u003e    private val NOX_FILES = arrayOf(\u003cbr/\u003e        \u0026#34;fstab.nox\u0026#34;,\u003cbr/\u003e        \u0026#34;init.nox.rc\u0026#34;,\u003cbr/\u003e        \u0026#34;ueventd.nox.rc\u0026#34;\u003cbr/\u003e    )\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"056f\"\u003e    fun isRunningInEmulator(context: Context): Boolean {\u003cbr/\u003e        return when {\u003cbr/\u003e            checkBasic() -\u0026gt; true\u003cbr/\u003e            checkAdvanced() -\u0026gt; true\u003cbr/\u003e            checkPackageName(context) -\u0026gt; true\u003cbr/\u003e            else -\u0026gt; false\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"d7c8\"\u003e    private fun checkBasic(): Boolean {\u003cbr/\u003e        var rating = 0\u003cbr/\u003e        if (Build.PRODUCT == \u0026#34;sdk_x86_64\u0026#34; || Build.PRODUCT == \u0026#34;sdk_google_phone_x86\u0026#34; || Build.PRODUCT == \u0026#34;sdk_google_phone_x86_64\u0026#34; || Build.PRODUCT == \u0026#34;sdk_google_phone_arm64\u0026#34; || Build.PRODUCT == \u0026#34;vbox86p\u0026#34;) {\u003cbr/\u003e            rating++\u003cbr/\u003e        }\u003cbr/\u003e        if (Build.MANUFACTURER == \u0026#34;unknown\u0026#34;) {\u003cbr/\u003e            rating++\u003cbr/\u003e        }\u003cbr/\u003e        if (Build.BRAND == \u0026#34;generic\u0026#34; ||\u003cbr/\u003e            Build.BRAND.equals(\u0026#34;android\u0026#34;,\u003cbr/\u003e                ignoreCase = true) || Build.BRAND == \u0026#34;generic_arm64\u0026#34; || Build.BRAND == \u0026#34;generic_x86\u0026#34; || Build.BRAND == \u0026#34;generic_x86_64\u0026#34;\u003cbr/\u003e        ) {\u003cbr/\u003e            rating++\u003cbr/\u003e        }\u003cbr/\u003e        if (Build.DEVICE == \u0026#34;generic\u0026#34; || Build.DEVICE == \u0026#34;generic_arm64\u0026#34; || Build.DEVICE == \u0026#34;generic_x86\u0026#34; || Build.DEVICE == \u0026#34;generic_x86_64\u0026#34; || Build.DEVICE == \u0026#34;vbox86p\u0026#34;) {\u003cbr/\u003e            rating++\u003cbr/\u003e        }\u003cbr/\u003e        if (Build.MODEL == \u0026#34;sdk\u0026#34; || Build.MODEL == \u0026#34;Android SDK built for arm64\u0026#34; || Build.MODEL == \u0026#34;Android SDK built for armv7\u0026#34; || Build.MODEL == \u0026#34;Android SDK built for x86\u0026#34; || Build.MODEL == \u0026#34;Android SDK built for x86_64\u0026#34;) {\u003cbr/\u003e            rating++\u003cbr/\u003e        }\u003cbr/\u003e        if (Build.HARDWARE == \u0026#34;ranchu\u0026#34;) {\u003cbr/\u003e            rating++\u003cbr/\u003e        }\u003cbr/\u003e        if (Build.FINGERPRINT.contains(\u0026#34;sdk_google_phone_arm64\u0026#34;) ||\u003cbr/\u003e            Build.FINGERPRINT.contains(\u0026#34;sdk_google_phone_armv7\u0026#34;)\u003cbr/\u003e        ) {\u003cbr/\u003e            rating++\u003cbr/\u003e        }\u003cbr/\u003e        var result = (Build.FINGERPRINT.startsWith(\u0026#34;generic\u0026#34;)\u003cbr/\u003e                || Build.MODEL.contains(\u0026#34;google_sdk\u0026#34;)\u003cbr/\u003e                || Build.MODEL.lowercase().contains(\u0026#34;droid4x\u0026#34;)\u003cbr/\u003e                || Build.MODEL.contains(\u0026#34;Emulator\u0026#34;)\u003cbr/\u003e                || Build.MODEL.contains(\u0026#34;Android SDK built for x86\u0026#34;)\u003cbr/\u003e                || Build.MANUFACTURER.contains(\u0026#34;Genymotion\u0026#34;)\u003cbr/\u003e                || Build.HARDWARE == \u0026#34;goldfish\u0026#34; || Build.HARDWARE == \u0026#34;vbox86\u0026#34; || Build.PRODUCT == \u0026#34;sdk\u0026#34; || Build.PRODUCT.startsWith(\u003cbr/\u003e            \u0026#34;google_sdk\u0026#34;)\u003cbr/\u003e                || Build.PRODUCT == \u0026#34;sdk_x86\u0026#34; || Build.PRODUCT == \u0026#34;vbox86p\u0026#34; || Build.BOARD.lowercase()\u003cbr/\u003e            .contains(\u0026#34;nox\u0026#34;)\u003cbr/\u003e                || Build.BOOTLOADER.lowercase().contains(\u0026#34;nox\u0026#34;)\u003cbr/\u003e                || Build.HARDWARE.lowercase().contains(\u0026#34;nox\u0026#34;)\u003cbr/\u003e                || Build.PRODUCT.lowercase().contains(\u0026#34;nox\u0026#34;)\u003cbr/\u003e                || Build.SERIAL.lowercase().contains(\u0026#34;nox\u0026#34;)\u003cbr/\u003e                || Build.HOST.contains(\u0026#34;Droid4x-BuildStation\u0026#34;)\u003cbr/\u003e                || Build.MANUFACTURER.startsWith(\u0026#34;iToolsAVM\u0026#34;)\u003cbr/\u003e                || Build.DEVICE.startsWith(\u0026#34;iToolsAVM\u0026#34;)\u003cbr/\u003e                || Build.MODEL.startsWith(\u0026#34;iToolsAVM\u0026#34;)\u003cbr/\u003e                || Build.BRAND.startsWith(\u0026#34;generic\u0026#34;)\u003cbr/\u003e                || Build.HARDWARE.startsWith(\u0026#34;vbox86\u0026#34;))\u003cbr/\u003e        if (result) return true\u003cbr/\u003e        result = result or (Build.BRAND.startsWith(\u0026#34;generic\u0026#34;) \u0026amp;\u0026amp; Build.DEVICE.startsWith(\u0026#34;generic\u0026#34;))\u003cbr/\u003e        if (result) return true\u003cbr/\u003e        result = result or (\u0026#34;google_sdk\u0026#34; == Build.PRODUCT)\u003cbr/\u003e        return if (result) true else rating \u0026gt;= 2\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"2580\"\u003e    private fun checkQEmuDrivers(): Boolean {\u003cbr/\u003e        for (drivers_file in arrayOf(File(\u0026#34;/proc/tty/drivers\u0026#34;), File(\u0026#34;/proc/cpuinfo\u0026#34;))) {\u003cbr/\u003e            if (drivers_file.exists() \u0026amp;\u0026amp; drivers_file.canRead()) {\u003cbr/\u003e                val data = ByteArray(1024)\u003cbr/\u003e                try {\u003cbr/\u003e                    val `is`: InputStream = FileInputStream(drivers_file)\u003cbr/\u003e                    `is`.read(data)\u003cbr/\u003e                    `is`.close()\u003cbr/\u003e                } catch (exception: Exception) {\u003cbr/\u003e                    exception.printStackTrace()\u003cbr/\u003e                }\u003cbr/\u003e                val driverData = String(data)\u003cbr/\u003e                for (known_qemu_driver in QEMU_DRIVERS) {\u003cbr/\u003e                    if (driverData.contains(known_qemu_driver)) {\u003cbr/\u003e                        return true\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        return false\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"95f5\"\u003e    private fun checkAdvanced(): Boolean {\u003cbr/\u003e        return (checkFiles(GENY_FILES)\u003cbr/\u003e                || checkFiles(ANDY_FILES)\u003cbr/\u003e                || checkFiles(NOX_FILES)\u003cbr/\u003e                || checkQEmuDrivers()\u003cbr/\u003e                || checkFiles(PIPES)\u003cbr/\u003e                || checkFiles(X86_FILES))\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"fa0e\"\u003e    private fun checkFiles(targets: Array\u0026lt;String\u0026gt;): Boolean {\u003cbr/\u003e        for (pipe in targets) {\u003cbr/\u003e            val qemuFile = File(pipe)\u003cbr/\u003e            if (qemuFile.exists()) {\u003cbr/\u003e                return true\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        return false\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"da92\"\u003e    fun checkPackageName(context: Context): Boolean {\u003cbr/\u003e        val packageManager = context.packageManager\u003cbr/\u003e        val intent = Intent(Intent.ACTION_MAIN, null)\u003cbr/\u003e        intent.addCategory(Intent.CATEGORY_LAUNCHER)\u003cbr/\u003e        val availableActivities = packageManager.queryIntentActivities(intent, 0)\u003cbr/\u003e        for (resolveInfo in availableActivities) {\u003cbr/\u003e            if (resolveInfo.activityInfo.packageName.startsWith(\u0026#34;com.bluestacks.\u0026#34;)) {\u003cbr/\u003e                return true\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        val packages = packageManager\u003cbr/\u003e            .getInstalledApplications(PackageManager.GET_META_DATA)\u003cbr/\u003e        for (packageInfo in packages) {\u003cbr/\u003e            val packageName = packageInfo.packageName\u003cbr/\u003e            if (packageName.startsWith(\u0026#34;com.vphone.\u0026#34;)) {\u003cbr/\u003e                return true\u003cbr/\u003e            } else if (packageName.startsWith(\u0026#34;com.bignox.\u0026#34;)) {\u003cbr/\u003e                return true\u003cbr/\u003e            } else if (packageName.startsWith(\u0026#34;com.nox.mopen.app\u0026#34;)) {\u003cbr/\u003e                return true\u003cbr/\u003e            } else if (packageName.startsWith(\u0026#34;me.haima.\u0026#34;)) {\u003cbr/\u003e                return true\u003cbr/\u003e            } else if (packageName.startsWith(\u0026#34;com.bluestacks.\u0026#34;)) {\u003cbr/\u003e                return true\u003cbr/\u003e            } else if (packageName.startsWith(\u0026#34;cn.itools.\u0026#34;) \u0026amp;\u0026amp; Build.PRODUCT.startsWith(\u0026#34;iToolsAVM\u0026#34;)) {\u003cbr/\u003e                return true\u003cbr/\u003e            } else if (packageName.startsWith(\u0026#34;com.kop.\u0026#34;)) {\u003cbr/\u003e                return true\u003cbr/\u003e            } else if (packageName.startsWith(\u0026#34;com.kaopu.\u0026#34;)) {\u003cbr/\u003e                return true\u003cbr/\u003e            } else if (packageName.startsWith(\u0026#34;com.microvirt.\u0026#34;)) {\u003cbr/\u003e                return true\u003cbr/\u003e            } else if (packageName == \u0026#34;com.google.android.launcher.layouts.genymotion\u0026#34;) {\u003cbr/\u003e                return true\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        val manager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager\u003cbr/\u003e        val runningServices = manager.getRunningServices(30)\u003cbr/\u003e        for (serviceInfo in runningServices) {\u003cbr/\u003e            val serviceName = serviceInfo.service.className\u003cbr/\u003e            if (serviceName.startsWith(\u0026#34;com.bluestacks.\u0026#34;)) {\u003cbr/\u003e                return true\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        return false\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"9cc5\"\u003e\u003cstrong\u003eCheck Runtime Environment\u003c/strong\u003e: During runtime, it is essential to validate environment variables, such as running processes, file access, and installed applications, as well as system properties, to detect any anomalies. This check should be \u003cstrong\u003eperformed outside the Android environment, on the backend side\u003c/strong\u003e. Therefore, before executing any transaction-related actions, the current environment information should be sent for verification.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5971\"\u003eBelow is a code snippet to retrieve all the necessary information.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d5cb\"\u003eimport android.system.ErrnoException\u003cbr/\u003eimport android.system.Os\u003cbr/\u003eimport android.system.OsConstants\u003cbr/\u003eimport android.util.Log\u003cbr/\u003eimport java.io.BufferedReader\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"55df\"\u003eobject SecureEnvironmentCheckerInfo {\u003c/span\u003e\u003cspan id=\"8aa1\"\u003e    private const val TAG = \u0026#34;SecureEnvironmentCheckerInfo\u0026#34;\u003c/span\u003e\u003cspan id=\"576d\"\u003e// The verified paths are : \u003cbr/\u003e//    \u0026#34;/data/local/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/data/local/bin/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/data/local/xbin/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/sbin/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/system/bin/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/system/bin/.ext/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/system/bin/failsafe/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/system/sd/xbin/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/system/usr/we-need-root/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/system/xbin/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/system/etc/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/data/\u0026#34;,\u003cbr/\u003e//    \u0026#34;/dev/\u0026#34;\u003cbr/\u003e    fun getFileAccesses(paths: Array\u0026lt;String\u0026gt;): HashMap\u0026lt;String, Boolean\u0026gt; {\u003cbr/\u003e        Log.d(TAG, \u0026#34;Checking file accesses using system calls\u0026#34;)\u003c/span\u003e\u003cspan id=\"b2db\"\u003e        val fileAccesses = HashMap\u0026lt;String, Boolean\u0026gt;()\u003cbr/\u003e        for (path in paths) {\u003cbr/\u003e            fileAccesses[path] = try {\u003cbr/\u003e                Os.access(path, OsConstants.F_OK)\u003cbr/\u003e            } catch (e: ErrnoException) {\u003cbr/\u003e                false\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/span\u003e\u003cspan id=\"c927\"\u003e        Log.d(TAG, \u0026#34;Checked ${fileAccesses.size} file accesses\u0026#34;)\u003cbr/\u003e        return fileAccesses\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"7099\"\u003e    fun getSystemProperties(): HashMap\u0026lt;String, String\u0026gt;? {\u003cbr/\u003e        Log.d(TAG, \u0026#34;Check system properties using property service\u0026#34;)\u003c/span\u003e\u003cspan id=\"ab49\"\u003e        val systemCommand = \u0026#34;getprop\u0026#34;\u003cbr/\u003e        val content = getOutput(systemCommand, event) ?: return null\u003c/span\u003e\u003cspan id=\"c75e\"\u003e        val systemProperties = SystemPropertyParser.parse(content)\u003cbr/\u003e        if (systemProperties != null) {\u003cbr/\u003e            Log.d(TAG, \u0026#34;Retrieve${systemProperties.size} system properties\u0026#34;)\u003cbr/\u003e        } else {\u003cbr/\u003e            Log.e(TAG, \u0026#34;Retrieve system properties from \u0026#39;$systemCommand\u0026#39; output\u0026#34;)\u003cbr/\u003e        }\u003c/span\u003e\u003cspan id=\"0a9b\"\u003e        return systemProperties\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"960b\"\u003e    fun getInstalledPackages(): Array\u0026lt;String\u0026gt;? {\u003cbr/\u003e        Log.d(TAG, \u0026#34;Retrieve installed packages using package manager with user 0\u0026#34;)\u003c/span\u003e\u003cspan id=\"466d\"\u003e        val systemCommand = \u0026#34;pm list packages --user 0\u0026#34;\u003cbr/\u003e        val content = getOutput(systemCommand) ?: return null\u003c/span\u003e\u003cspan id=\"1725\"\u003e        val installedPackages = PackageParser.parse(content)\u003cbr/\u003e        Log.d(TAG, \u0026#34;Retrieved ${installedPackages.size} installed packages\u0026#34;)\u003c/span\u003e\u003cspan id=\"10aa\"\u003e        return installedPackages\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"5400\"\u003e    private fun getOutput(systemCommand: String): String? {\u003cbr/\u003e        var process: Process? = null\u003cbr/\u003e        return try {\u003cbr/\u003e            process = Runtime.getRuntime().exec(systemCommand)\u003cbr/\u003e            val output = process!!.inputStream.bufferedReader().use(BufferedReader::readText)\u003cbr/\u003e            val exitValue = process.waitFor()\u003cbr/\u003e            if (exitValue == 0) {\u003cbr/\u003e                output\u003cbr/\u003e            } else {\u003cbr/\u003e                Log.e(TAG, \u0026#34;\u0026#39;$systemCommand\u0026#39; command terminated with exit value $exitValue\u0026#34;)\u003cbr/\u003e                null\u003cbr/\u003e            }\u003cbr/\u003e        } catch (e: Exception) {\u003cbr/\u003e            Log.e(TAG, \u0026#34;Error occurred while executing \u0026#39;$systemCommand\u0026#39; command: $e\u0026#34;)\u003cbr/\u003e            null\u003cbr/\u003e        } finally {\u003cbr/\u003e            process?.destroy()\u003cbr/\u003e            if (process?.isAlive == true) {\u003cbr/\u003e                process.destroyForcibly()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"b406\"\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"88c9\"\u003e\u003cstrong\u003eAnti-Sideloading\u003c/strong\u003e: Restrict APK installation from untrusted sources, we recommand to download the application from Google play by checking the vendor application :\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"1a9a\"\u003eobject SideLoadingDetector {\u003cp\u003e       private const val AUTHORIZED_APP_VENDOR = \u0026#34;com.android.vending\u0026#34;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"171a\"\u003e    private fun getInstallerPackageName(context: Context) =\u003cbr/\u003e        context.packageManager\u003cbr/\u003e            .getInstallSourceInfo(context.packageName)\u003cbr/\u003e            .installingPackageName\u003c/span\u003e\u003cspan id=\"33ec\"\u003e    fun isAppSideLoaded(context: Context): Boolean {\u003cbr/\u003e        return try {\u003cbr/\u003e                getInstallerPackageName(context)\u003cbr/\u003e            } catch (e: IllegalArgumentException) {\u003cbr/\u003e                Log.e(TAG, \u0026#34;Cannot access to app installer\u0026#34;, e)\u003cbr/\u003e                null\u003cbr/\u003e            }\u003cbr/\u003e                ?.also { Log.d(TAG, \u0026#34;Package installer is: $it\u0026#34;) }\u003cbr/\u003e                ?.takeIf { it == AUTHORIZED_APP_VENDOR }\u003cbr/\u003e                ?.let { false }\u003cbr/\u003e                ?: (true).also { Log.e(TAG, \u0026#34;App side loaded\u0026#34;) }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"9558\"\u003e\u003cstrong\u003eAnti-Multiwindow\u003c/strong\u003e: Prevent multi-window mode to avoid overlay attacks :\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"bb76\"\u003efun MultiWindowModeDetector(activity: Activity): Boolean =\u003cbr/\u003e        activity.isInMultiWindowMode\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"d778\"\u003e3. Preventing Data Leakage \u0026amp; Unauthorized Access\u003c/h2\u003e\u003cp id=\"a66b\"\u003eIn payment applications, data leakage and unauthorized access present significant security risks, potentially exposing sensitive user information such as Payment Card details (PAN, CVV, etc.). To mitigate these security vulnerabilities, it is crucial to implement the following protective measures:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e28d\"\u003e\u003cstrong\u003eLog Protection\u003c/strong\u003e: Avoid logging sensitive data using \u003ccode\u003eLog.d()\u003c/code\u003e; use structured logging with \u003ccode\u003eTimber…\u003c/code\u003eIn best case, we should remove any logs using as example proguard rules (in case, we need logs for monotring, we must encrypt it before send it to backend) :\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"df4b\"\u003e# Remove Android logging calls\u003cbr/\u003e-assumenosideeffects class android.util.Log {\u003cbr/\u003e    public static boolean isLoggable(java.lang.String, int);\u003cbr/\u003e    public static int v(...);\u003cbr/\u003e    public static int d(...);\u003cbr/\u003e    public static int i(...);\u003cbr/\u003e    public static int w(...);\u003cbr/\u003e    public static int e(...);\u003cbr/\u003e    public static int println(int, java.lang.String, java.lang.String);\u003cbr/\u003e    public static java.lang.String getStackTraceString(java.lang.Throwable);\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"bb52\"\u003e\u003cstrong\u003eSecure Database \u0026amp; Preference \u003c/strong\u003e: We can use \u003ca href=\"https://www.zetetic.net/sqlcipher/sqlcipher-for-android/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eSQLCipher\u003c/strong\u003e \u003c/a\u003efor encrypted database storage or save encrypted data directly in your DB and for shared pref, we recammand to use this library from Google \u003ca href=\"https://developer.android.com/reference/androidx/security/crypto/EncryptedSharedPreferences\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eEncryptedSharedPreferences\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"807d\"\u003e\u003cstrong\u003eSecure Binding Services\u003c/strong\u003e: When using services, it is essential to restrict AIDL exposure by properly configuring export and enable flags. Additionally, applying signature-based permissions ensures that only trusted applications with the correct signature can interact with the service, enhancing security:\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"dc35\"\u003eHere is below snippet code to how secure Android Service :\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7e6c\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\u003cbr/\u003e\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"e981\"\u003e    \u0026lt;uses-permission android:name=\u0026#34;android.permission.FOREGROUND_SERVICE\u0026#34;/\u0026gt;\u003c/span\u003e\u003cspan id=\"cb61\"\u003e    \u0026lt;permission\u003cbr/\u003e        android:name=\u0026#34;com.payment.app.permission.BIND_SERVICE\u0026#34;\u003cbr/\u003e        android:protectionLevel=\u0026#34;signature\u0026#34; /\u0026gt;\u003c/span\u003e\u003cspan id=\"e2f4\"\u003e    \u0026lt;application\u003cbr/\u003e        android:name=\u0026#34;com.payment.app.Application\u0026#34;\u003cbr/\u003e        android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34;\u003cbr/\u003e        android:label=\u0026#34;@string/app_name\u0026#34;\u0026gt;\u003cbr/\u003e        \u0026lt;activity\u003cbr/\u003e            android:name=\u0026#34;com.payment.app.MainActivity\u0026#34;\u003cbr/\u003e            android:exported=\u0026#34;true\u0026#34;\u0026gt;\u003cbr/\u003e            \u0026lt;intent-filter\u0026gt;\u003cbr/\u003e                \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt;\u003cbr/\u003e                \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt;\u003cbr/\u003e            \u0026lt;/intent-filter\u0026gt;\u003cbr/\u003e        \u0026lt;/activity\u0026gt;\u003c/span\u003e\u003cspan id=\"5339\"\u003e        \u0026lt;service\u003cbr/\u003e            android:name=\u0026#34;com.payment.app.service.CoreService\u0026#34;\u003cbr/\u003e            android:exported=\u0026#34;true\u0026#34;\u003cbr/\u003e            android:enabled=\u0026#34;true\u0026#34;\u003cbr/\u003e            android:permission=\u0026#34;com.payment.app.BIND_SERVICE\u0026#34; \u0026gt;\u003cbr/\u003e            \u0026lt;intent-filter\u0026gt;\u003cbr/\u003e                \u0026lt;action android:name=\u0026#34;com.payment.app.action.BIND_SERVICE\u0026#34; /\u0026gt;\u003cbr/\u003e            \u0026lt;/intent-filter\u0026gt;\u003cbr/\u003e        \u0026lt;/service\u0026gt;\u003cbr/\u003e    \u0026lt;/application\u0026gt;\u003c/span\u003e\u003cspan id=\"b90d\"\u003e\u0026lt;/manifest\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"9a53\"\u003e\u003cstrong\u003eAnti-Screenshot \u0026amp; Overlay Detection\u003c/strong\u003e: Android purpose multiple mechanisme to protect from \u003ca href=\"https://developer.android.com/security/fraud-prevention/activities\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eoverlay attacks\u003c/a\u003e : Use \u003ccode\u003eFLAG_SECURE\u003c/code\u003e to block screenshots and to block overlays using this flag permission \u003cstrong\u003e\u003cem\u003eandroid.permission.HIDE_OVERLAY_WINDOWS\u003c/em\u003e\u003c/strong\u003e\u003ccode\u003e(introduced in Android 12)\u003c/code\u003e. For oldest Android version, we can implement a custom solution to inject event in random touch and intercept it.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e46b\"\u003eHere is fully example of Overlay Detector class :\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"615e\"\u003eimport android.annotation.SuppressLint\u003cbr/\u003eimport android.app.Activity\u003cbr/\u003eimport android.app.Instrumentation\u003cbr/\u003eimport android.graphics.Point\u003cbr/\u003eimport android.os.Build\u003cbr/\u003eimport android.os.SystemClock\u003cbr/\u003eimport android.util.Log\u003cbr/\u003eimport android.view.MotionEvent\u003cbr/\u003eimport android.view.View\u003cbr/\u003eimport android.view.WindowManager\u003cbr/\u003eimport kotlinx.coroutines.*\u003cbr/\u003eimport kotlin.math.absoluteValue\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"edc7\"\u003eclass OverlayDetection(\u003cbr/\u003e    screenSize: Point,\u003cbr/\u003e    private var onOverlayDetected: (() -\u0026gt; Unit)? = null\u003cbr/\u003e) {\u003cbr/\u003e    companion object {\u003cbr/\u003e        private val TAG = OverlayDetection::class.java.simpleName\u003cbr/\u003e        const val INJECTED_STATE = -35\u003cbr/\u003e        private const val OFFSET_PERCENT = 10\u003cbr/\u003e        private const val RETRY_DELAY_INJECT_EVENT = 1500L //1.5 seconds\u003c/span\u003e\u003cspan id=\"eedc\"\u003e        private fun getFlagsWindow() =\u003cbr/\u003e            MotionEvent.FLAG_WINDOW_IS_OBSCURED or MotionEvent.FLAG_WINDOW_IS_PARTIALLY_OBSCURED\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"3ee8\"\u003e    private var lastCallNotCaught = false\u003cbr/\u003e    private var overlayDetectionRunning = true\u003c/span\u003e\u003cspan id=\"a40a\"\u003e    private val scope = CoroutineScope(Dispatchers.IO)\u003cbr/\u003e    private val instrumentation = Instrumentation()\u003c/span\u003e\u003cspan id=\"b097\"\u003e    private var view: SecureViewContainer? = null\u003cbr/\u003e    private var activity: Activity? = null\u003cbr/\u003e    private val offset: Point = Point(\u003cbr/\u003e        (screenSize.x * OFFSET_PERCENT) / 100,\u003cbr/\u003e        (screenSize.y * OFFSET_PERCENT) / 100\u003cbr/\u003e    )\u003cbr/\u003e    private val range = Point(\u003cbr/\u003e        screenSize.x - (2 * offset.x),\u003cbr/\u003e        screenSize.y - (2 * offset.y),\u003cbr/\u003e    )\u003cbr/\u003e    private var job: Job? = null\u003c/span\u003e\u003cspan id=\"e17c\"\u003e    fun setViewToProtect(view: SecureViewContainer) {\u003cbr/\u003e        Log.d(TAG, \u0026#34;OverlayDetection: protect view $view\u0026#34;)\u003c/span\u003e\u003cspan id=\"4334\"\u003e        this.view = view\u003cbr/\u003e        activity = view.context as Activity\u003cbr/\u003e            this.view?.setOnTouchListener { _: View?, event: MotionEvent -\u0026gt;\u003cbr/\u003e                onOverlayEventDetected(event)\u003cbr/\u003e                false\u003cbr/\u003e            }\u003c/span\u003e\u003cspan id=\"ffc8\"\u003e            this.view?.setOnOverlayDetectionListener {\u003cbr/\u003e                onOverlayEventDetected(event)\u003cbr/\u003e           }\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"b458\"\u003e    private fun hasSecureFlag(): Boolean =\u003cbr/\u003e        activity?.window?.attributes?.flags?.let {\u003cbr/\u003e            (it and WindowManager.LayoutParams.FLAG_SECURE) != 0\u003cbr/\u003e        } ?: false\u003c/span\u003e\u003cspan id=\"fe81\"\u003e    private fun injectEvent() {\u003cbr/\u003e        if (lastCallNotCaught) {\u003cbr/\u003e            onOverlayDetected.invoke()\u003cbr/\u003e        } else {\u003cbr/\u003e            injectTouchEvent()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"b20e\"\u003e    private fun injectTouchEvent() =\u003cbr/\u003e        randomPoint().also { point -\u0026gt;\u003cbr/\u003e            if (Build.VERSION.SDK_INT \u0026lt; Build.VERSION_CODES.TIRAMISU) {\u003cbr/\u003e                if (point.value != null) {\u003cbr/\u003e                    Log.d(TAG, \u0026#34;Inject event at ${point.value}\u0026#34;)\u003cbr/\u003e                    lastCallNotCaught = true\u003cbr/\u003e                    try {\u003cbr/\u003e                        touch(point.value, MotionEvent.ACTION_DOWN)\u003cbr/\u003e                        touch(point.value, MotionEvent.ACTION_UP)\u003cbr/\u003e                    } catch (e: Exception) {\u003cbr/\u003e                        Log.e(TAG, e.stackTraceToString())\u003cbr/\u003e                        onOverlayDetected.invoke()\u003cbr/\u003e                    }\u003cbr/\u003e                } else {\u003cbr/\u003e                    Log.e(TAG, \u0026#34;Random point can\u0026#39;t be generated for inject event\u0026#34;)\u003cbr/\u003e                    onOverlayDetected.invoke()\u003cbr/\u003e                }\u003cbr/\u003e            } else {\u003cbr/\u003e                Log.w(TAG, \u0026#34;ANDROID 13: Touch injection deactivated at $point\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/span\u003e\u003cspan id=\"5c3d\"\u003e    private fun touch(point: Point, event: Int) {\u003cbr/\u003e        instrumentation.sendPointerSync(\u003cbr/\u003e            MotionEvent.obtain(\u003cbr/\u003e                SystemClock.uptimeMillis(), SystemClock.uptimeMillis(),\u003cbr/\u003e                event,\u003cbr/\u003e                point.x.toFloat(), point.y.toFloat(),\u003cbr/\u003e                INJECTED_STATE\u003cbr/\u003e            )\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"aa98\"\u003e    private fun randomPoint(): Rand.Result\u0026lt;Point\u0026gt; {\u003cbr/\u003e        val xRand = Rand.nextInt()\u003cbr/\u003e        val x = xRand.value ?: return Rand.Result(xRand.nativeResult!!)\u003c/span\u003e\u003cspan id=\"e8e5\"\u003e        val yRand = Rand.nextInt()\u003cbr/\u003e        val y = yRand.value ?: return Rand.Result(yRand.nativeResult!!)\u003c/span\u003e\u003cspan id=\"120c\"\u003e        val point =\u003cbr/\u003e            Point((x.absoluteValue % range.x) + offset.x, (y.absoluteValue % range.y) + offset.y)\u003cbr/\u003e        return Rand.Result(point)\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"dfca\"\u003e    fun start() {\u003cbr/\u003e            stop()\u003cbr/\u003e            overlayDetectionRunning = true\u003cbr/\u003e            lastCallNotCaught = false\u003cbr/\u003e            Log.d(TAG, \u0026#34;Start overlay protection\u0026#34;)\u003cbr/\u003e            job = scope.launch {\u003cbr/\u003e                delay(1000L)\u003cbr/\u003e                view?.requestFocus()\u003cbr/\u003e                while (overlayDetectionRunning) {\u003cbr/\u003e                    injectEvent()\u003cbr/\u003e                    delay(RETRY_DELAY_INJECT_EVENT)\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"2272\"\u003e    fun stop() {\u003cbr/\u003e        overlayDetectionRunning = false\u003cbr/\u003e        lastCallNotCaught = false\u003cbr/\u003e        Log.d(TAG, \u0026#34;Stop overlay protection\u0026#34;)\u003cbr/\u003e        job?.cancel()\u003cbr/\u003e        job = null\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"21c8\"\u003e    fun forbidMultiWindowMode(activity: Activity): Boolean =\u003cbr/\u003e        activity.isInMultiWindowMode\u003c/span\u003e\u003cspan id=\"b186\"\u003e    fun onOverlayEventDetected(event: MotionEvent) {\u003cbr/\u003e        Log.d(TAG, \u0026#34;Received motion event: state(${event.metaState}) flags(${event.flags})\u0026#34;)\u003cbr/\u003e        when {\u003cbr/\u003e            !hasSecureFlag() -\u0026gt; onOverlayEventDetected(event)\u003c/span\u003e\u003cspan id=\"48d6\"\u003e            event.metaState != INJECTED_STATE -\u0026gt; Unit\u003c/span\u003e\u003cspan id=\"9615\"\u003e            event.flags == MotionEvent.ACTION_MOVE -\u0026gt; Unit // Workaround  to avoid false/positive toast overlay detection\u003c/span\u003e\u003cspan id=\"4888\"\u003e            (event.flags and getFlagsWindow()) != 0 -\u0026gt; onOverlayDetected.invoke()\u003cbr/\u003e        }\u003cbr/\u003e        lastCallNotCaught = false\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"9dd8\"\u003eimport android.content.Context\u003cbr/\u003eimport android.util.AttributeSet\u003cbr/\u003eimport android.util.Log\u003cbr/\u003eimport android.view.MotionEvent\u003cbr/\u003eimport androidx.constraintlayout.widget.ConstraintLayout\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"78b5\"\u003eclass SecureViewContainer @JvmOverloads constructor(\u003cbr/\u003e    context: Context,\u003cbr/\u003e    attributeSet: AttributeSet? = null,\u003cbr/\u003e    defStyle: Int = 0,\u003cbr/\u003e) : ConstraintLayout(\u003cbr/\u003e    context,\u003cbr/\u003e    attributeSet,\u003cbr/\u003e    defStyle\u003cbr/\u003e) {\u003c/span\u003e\u003cspan id=\"760d\"\u003e    companion object {\u003cbr/\u003e        private val TAG = SecureViewContainer::class.java.simpleName\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"2e7f\"\u003e    private var onOverlayDetectionListener: (() -\u0026gt; Unit)? = null\u003c/span\u003e\u003cspan id=\"ef9a\"\u003e    fun setOnOverlayDetectionListener(onOverlayDetectionListener: () -\u0026gt; Unit) {\u003cbr/\u003e        this.onOverlayDetectionListener = onOverlayDetectionListener\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"cca6\"\u003e    override fun onFilterTouchEventForSecurity(ev: MotionEvent): Boolean {\u003cbr/\u003e        val checkIsObscured =\u003cbr/\u003e            ev.flags and MotionEvent.FLAG_WINDOW_IS_OBSCURED != 0\u003c/span\u003e\u003cspan id=\"d467\"\u003e        val checkIsPartiallyObscured =\u003cbr/\u003e            ev.flags and MotionEvent.FLAG_WINDOW_IS_PARTIALLY_OBSCURED != 0\u003c/span\u003e\u003cspan id=\"43f5\"\u003e        Log.d(TAG, \u0026#34;onFilterTouchEventForSecurity: \u0026#34; +\u003cbr/\u003e                \u0026#34;isObscured: $checkIsObscured, isPartiallyObscured: $checkIsPartiallyObscured\u0026#34;)\u003c/span\u003e\u003cspan id=\"14b5\"\u003e        if (checkIsObscured || checkIsPartiallyObscured) {\u003cbr/\u003e            onOverlayDetectionListener?.invoke()\u003cbr/\u003e        }\u003c/span\u003e\u003cspan id=\"23ab\"\u003e        return super.onFilterTouchEventForSecurity(ev)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"14cc\"\u003e\u0026lt;com.payment.app.SecureViewContainer xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u003cbr/\u003e    xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u003cbr/\u003e    xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u003cbr/\u003e    android:layout_width=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e    android:layout_height=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e    android:fitsSystemWindows=\u0026#34;true\u0026#34;\u0026gt;\u003cbr/\u003e    \u0026lt;androidx.appcompat.widget.AppCompatImageView\u003cbr/\u003e        android:id=\u0026#34;@+id/icon\u0026#34;\u003cbr/\u003e        android:layout_width=\u0026#34;200dp\u0026#34;\u003cbr/\u003e        android:layout_height=\u0026#34;200dp\u0026#34;\u003cbr/\u003e        android:src=\u0026#34;@drawable/icon\u0026#34; /\u0026gt;\u003cbr/\u003e\u0026lt;/com.payment.app.SecureViewContainer\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"9963\"\u003e\u003cstrong\u003eAnti-Camera \u0026amp; Microphone Abuse\u003c/strong\u003e: Restrict background access using Android 10+ APIs and put some mechanism detection when camera is open and used by another threat application, here is an example to handle using the camera by another application:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"daec\"\u003eimport android.content.Context\u003cbr/\u003eimport android.hardware.camera2.CameraManager\u003cbr/\u003eimport android.util.Log\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"6a29\"\u003eclass CameraDetector(context: Context, private var onCameraDetected: (() -\u0026gt; Unit)? = null) {\u003cbr/\u003e    companion object {\u003cbr/\u003e        private val TAG = CameraDetector::class.java.simpleName\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"e53d\"\u003e    private val manager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager\u003c/span\u003e\u003cspan id=\"d1ab\"\u003e    private val cameraAvailabilityCallback = object : CameraManager.AvailabilityCallback() {\u003cbr/\u003e        override fun onCameraUnavailable(cameraId: String) {\u003cbr/\u003e            super.onCameraUnavailable(cameraId)\u003cbr/\u003e            onCameraDetected.invoke()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"acdb\"\u003e    fun start() {\u003cbr/\u003e            try {\u003cbr/\u003e                manager.registerAvailabilityCallback(cameraAvailabilityCallback, null)\u003cbr/\u003e            } catch (e: Exception) {\u003cbr/\u003e                Log.e(TAG, \u0026#34;Cannot register availability camera callback\u0026#34;, e)\u003cbr/\u003e            }\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"2d01\"\u003e    fun stop() {\u003cbr/\u003e        try {\u003cbr/\u003e            manager.unregisterAvailabilityCallback(cameraAvailabilityCallback)\u003cbr/\u003e        } catch (e: Exception) {\u003cbr/\u003e            Log.e(TAG, \u0026#34;Cannot unregister availability camera callback\u0026#34;, e)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"0bce\"\u003e\u003cstrong\u003eAnti-Accessibility Exploits\u003c/strong\u003e: When Android introduced the Accessibility API, it was intended for beneficial use cases. However, over time, it has been exploited and considered a potential backdoor. To mitigate this risk and prevent unauthorized access to on-screen information via the Accessibility API.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"19ef\"\u003eHere is an example of how to implement proper protections.:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d8fc\"\u003eimport android.graphics.Rect\u003cbr/\u003eimport android.view.View\u003cbr/\u003eimport android.view.accessibility.AccessibilityNodeInfo\u003cbr/\u003eimport androidx.core.view.ViewCompat\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"b227\"\u003eclass SecuredAccessibilityDelegateHelper(val view: View) : View.AccessibilityDelegate() {\u003cbr/\u003e    override fun onInitializeAccessibilityNodeInfo(host: View, info: AccessibilityNodeInfo) {\u003cbr/\u003e        super.onInitializeAccessibilityNodeInfo(host, info)\u003cbr/\u003e            view.importantForAccessibility =\u003cbr/\u003e                ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS\u003cbr/\u003e            info.isEnabled = false\u003cbr/\u003e            info.setBoundsInScreen(Rect(0, 0, 0, 0))\u003cbr/\u003e            info.text = \u0026#34;\u0026#34;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"80c3\"\u003eclass SecuredText(context: Context, attrs: AttributeSet) : AppCompatTextView(context, attrs) {\u003cbr/\u003e    init {\u003cbr/\u003e        accessibilityDelegate = SecuredAccessibilityDelegateHelper(this)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"d6f2\"\u003e\u0026lt;com.payement.app.SecuredText\u003cbr/\u003e                android:id=\u0026#34;@+id/text\u0026#34;\u003cbr/\u003e                android:layout_width=\u0026#34;wrap_content\u0026#34;xxx\u003cbr/\u003e                android:layout_height=\u0026#34;30dp\u0026#34;\u003cbr/\u003e                android:gravity=\u0026#34;center\u0026#34;\u003cbr/\u003e                android:textColor=\u0026#34;@color/white\u0026#34;\u003cbr/\u003e                android:textSize=\u0026#34;15sp\u0026#34;\u003cbr/\u003e                android:textStyle=\u0026#34;bold\u0026#34; /\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4046\"\u003e4. Strengthening Authentication \u0026amp; Secure Communication\u003c/h2\u003e\u003cul\u003e\u003cli id=\"cdcf\"\u003e\u003ca href=\"https://developer.android.com/identity/sign-in/biometric-auth?hl=en\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eBiometric Authentication\u003c/strong\u003e\u003c/a\u003e: Starting Android 6.0 the \u003cstrong\u003eBiometric API \u003c/strong\u003eexist for strong user authentication like \u003cstrong\u003efingerprint\u003c/strong\u003e, \u003cstrong\u003eface\u003c/strong\u003e, or \u003cstrong\u003eiris \u003c/strong\u003ewhich be used to verify the identity of the user before doing any transaction.\u003c/li\u003e\u003cli id=\"7bc6\"\u003e\u003cstrong\u003eSecure Connection (TLS/SSL)\u003c/strong\u003e: Communication must occur over a secure channel using protocols such as TLS/SSL. It is highly recommended to enforce TLS 1.2 or higher (preferably TLS 1.3 if supported by the server). Additionally, implementing \u003ca href=\"https://developer.android.com/privacy-and-security/security-config#CertificatePinning\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003ecertificate pinning\u003c/strong\u003e\u003c/a\u003e is mandatory to prevent man-in-the-middle attacks. Below is the process for certificate enrollment :\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003eAndroid Certificate Enrollment\u003c/figcaption\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"a1aa\"\u003e\u003cstrong\u003eHTTPS/SSL Security\u003c/strong\u003e: To prevent Man-in-the-Middle (MITM) attacks, Android 7 (API 24) introduced the \u003ca href=\"https://developer.android.com/privacy-and-security/security-config\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eNetwork Security Config\u003c/strong\u003e\u003c/a\u003e, allowing developers to customize network security settings within their applications. Below is an example demonstrating how to configure it properly at manifest file:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"ea55\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\u003cbr/\u003e\u0026lt;manifest\u003cbr/\u003e   xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u003cbr/\u003e   package=\u0026#34;co.payement.app\u0026#34;\u0026gt;\u003cbr/\u003e   \u0026lt;application\u003cbr/\u003e       android:networkSecurityConfig=\u0026#34;@xml/network_security_config\u0026#34;\u0026gt;\u003cbr/\u003e       ...\u003cbr/\u003e   \u0026lt;/application\u0026gt;\u003cbr/\u003e\u0026lt;/manifest\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5a11\"\u003eAt network security config file :\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2498\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\u003cbr/\u003e\u0026lt;network-security-config\u0026gt;\u003cbr/\u003e   \u0026lt;domain-config\u0026gt;\u003cbr/\u003e       \u0026lt;domain includeSubdomains=\u0026#34;true\u0026#34;\u0026gt;payment-domain.com\u0026lt;/domain\u0026gt;\u003cbr/\u003e       \u0026lt;pin-set\u0026gt;\u003cbr/\u003e           \u0026lt;pin digest=\u0026#34;SHA-256\u0026#34;\u0026gt;ZEDJEEKKEKLEE+fibTqbIsWNR/X7CWNVW+CEEA=\u0026lt;/pin\u0026gt;\u003cbr/\u003e           \u0026lt;pin digest=\u0026#34;SHA-256\u0026#34;\u0026gt;BFDBDFDFVDccvVFVVcfdesdsdvsdsdvsd=\u0026lt;/pin\u0026gt;\u003cbr/\u003e       \u0026lt;/pin-set\u0026gt;\u003cbr/\u003e   \u0026lt;/domain-config\u0026gt;\u003cbr/\u003e\u0026lt;/network-security-config\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"1d56\"\u003e\u003cstrong\u003eSecure Tokens (JWE, UUID)\u003c/strong\u003e: In some cases of Android authentication processes, tokenization is required. There are different types of tokens, such as \u003cstrong\u003eJWT, JWS, JWE, and JWK\u003c/strong\u003e. For security reasons, we recommend using the most suitable and secure type based on the application’s needs as \u003ca href=\"https://connect2id.com/products/nimbus-jose-jwt\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eencrypted token JWE\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"2a42\"\u003e\u003cstrong\u003eAPI Key Protection\u003c/strong\u003e: Every connection that requires API keys should ensure they are stored securely, either as a \u003cstrong\u003eGradle property\u003c/strong\u003e or an \u003cstrong\u003eenvironment variable\u003c/strong\u003e. Google provides an interesting plugin, \u003ca href=\"https://github.com/google/secrets-gradle-plugin\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSecrets Gradle Plugin\u003c/a\u003e, to help manage sensitive data securely. Additionally, it is recommended to \u003cstrong\u003erestrict API key usage\u003c/strong\u003e by specifying the \u003cstrong\u003eallowed package ID\u003c/strong\u003e in the API provider settings..\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"8c46\"\u003e5. Secure Cryptography \u0026amp; Key Management\u003c/h2\u003e\u003cul\u003e\u003cli id=\"d252\"\u003e\u003cstrong\u003eSecure Cryptography\u003c/strong\u003e: In the programming world, \u003cstrong\u003ecryptography\u003c/strong\u003e is a vast and complex topic that cannot be fully covered in this article. However, there are key recommendations from \u003cstrong\u003eAndroid security guidelines\u003c/strong\u003e and well-known security organizations such as \u003cstrong\u003eNIST (USA), ECRYPT (EU), and CRYPTREC (Japan)\u003c/strong\u003e for selecting the appropriate cryptographic algorithms and best practices :\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9afd\"\u003eFrom \u003ca href=\"https://developer.android.com/privacy-and-security/cryptography#choose-algorithm\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroid recommandation\u003c/a\u003e :\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eRecommended cryptography algorithm by Android\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"be91\"\u003eFrom \u003ca href=\"https://www.jssec.org/dl/android_securecoding_en.pdf#page=514\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNIST \u003c/a\u003e:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eRecommended cryptography algorithm by NIST\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"34ac\"\u003eFrom \u003ca href=\"https://www.jssec.org/dl/android_securecoding_en.pdf#page=515\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eECRYPT\u003c/a\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eRecommended cryptography algorithm by ECRYPT\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"1ed2\"\u003eFrom \u003ca href=\"https://www.jssec.org/dl/android_securecoding_en.pdf#page=515\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCRYPTREC\u003c/a\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eRecommended cryptography algorithm by CRYPTREC\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"4adb\"\u003eand finally, to store the encrypted locally, it’s \u003cstrong\u003erequired \u003c/strong\u003eto generate it by the Android \u003ca href=\"https://source.android.com/docs/security/features/keystore?hl=en\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKeystore API\u003c/a\u003e using \u003ca href=\"https://source.android.com/docs/security/features/keystore\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHardware-backed Keystore\u003c/a\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"4b46\"\u003e\u003cstrong\u003eKey Rotation\u003c/strong\u003e: Programming security is time-sensitive, and in this context, cryptographic keys must be regularly updated to mitigate potential risks. It is recommended not to exceed a 90-day lifespan for secure keys to ensure optimal protection.\u003c/li\u003e\u003cli id=\"ec07\"\u003e\u003cstrong\u003eUse Secure Random\u003c/strong\u003e: When generating secure keys, one crucial parameter that must not be ignored is the random field. To generate it, it should come from trusted entropy sources such as the \u003ca href=\"https://developer.android.com/reference/java/security/SecureRandom\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eSecureRandom \u003c/strong\u003eAP\u003c/a\u003eI. Therefore, we must avoid using any other sources for generating random values.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"8b3f\"\u003e6. Enhancing System Security \u0026amp; Updates\u003c/h2\u003e\u003cul\u003e\u003cli id=\"d719\"\u003e\u003cstrong\u003eSecure Elements \u0026amp; TEE (Trusted Execution Environment)\u003c/strong\u003e: As said in the last point, \u003cstrong\u003eAndroid Keystore\u003c/strong\u003e should be generated on \u003cstrong\u003eTrusted Execution Environment (TEE)\u003c/strong\u003e storage backed in \u003cstrong\u003eStrongBox \u003c/strong\u003eintroduced in Android 9 (for lowest version, we can use \u003cstrong\u003esoftware white box\u003c/strong\u003e but it’s must be respect the security standard).\u003c/li\u003e\u003cli id=\"7f5b\"\u003e\u003cstrong\u003eGMS Security Updates\u003c/strong\u003e: Google provides GMS (Google Mobile Services), which checks for any security updates. To verify this, we should check the currently installed version of Google Play Services. Below is the minimum version that should be present on the device :\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"64fc\"\u003eobject GooglePlayServicesChecker {\u003cbr/\u003e    private val TAG = GooglePlayServices::class.java.simpleName\u003cbr/\u003e    private const val MINIMUM_VERSION = 201516018\u003cbr/\u003e    private val availability = GoogleApiAvailability.getInstance()\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"cd7e\"\u003e    fun isSupported(context: Context): Boolean =\u003cbr/\u003e        (availability.isGooglePlayServicesAvailable(\u003cbr/\u003e            context,\u003cbr/\u003e            MINIMUM_VERSION\u003cbr/\u003e        ) == ConnectionResult.SUCCESS)\u003cbr/\u003e            .also {\u003cbr/\u003e                Log.d(TAG, \u0026#34;Google Play Services availability: $it\u0026#34;)\u003cbr/\u003e                try {\u003cbr/\u003e                    ProviderInstaller.installIfNeeded(context)\u003cbr/\u003e                    Log.d(TAG, \u0026#34;Google Play Services update ProviderInstaller installIfNeeded\u0026#34;)\u003cbr/\u003e                } catch (e: GooglePlayServicesRepairableException) {\u003cbr/\u003e                    Log.e(TAG, \u0026#34;An error has occurred\u0026#34;, e)\u003cbr/\u003e                    // Indicates that Google Play services is out of date, disabled, etc.\u003cbr/\u003e                    // Prompt the user to install/update/enable Google Play services.\u003cbr/\u003e                    GoogleApiAvailability.getInstance()\u003cbr/\u003e                        .showErrorNotification(context, e.connectionStatusCode)\u003cbr/\u003e                    Log.e(TAG, \u0026#34;Error occurred during check supported GooglePlayServices :\u0026#34;, e)\u003cbr/\u003e                } catch (e: GooglePlayServicesNotAvailableException) {\u003cbr/\u003e                    // Indicates a non-recoverable error; the ProviderInstaller is not able\u003cbr/\u003e                    // to install an up-to-date Provider.\u003cbr/\u003e                    // Note: As the min version 201516018 is higher than which required 11925000 (extracted from\u003cbr/\u003e                    // ProviderInstaller class) so no need to block the user by out-dated google play service popup.\u003cbr/\u003e                    Log.e(TAG, \u0026#34;An error has occurred\u0026#34;, e)\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e            .also {\u003cbr/\u003e                Log.d(TAG, \u0026#34;Google Play Services version: \u0026#34; + getVersion(context))\u003cbr/\u003e            }\u003c/span\u003e\u003cspan id=\"9760\"\u003e    private fun getVersion(context: Context): Long? = try {\u003cbr/\u003e        PackageInfoCompat.getLongVersionCode(\u003cbr/\u003e            context.packageManager.getPackageInfo(\u003cbr/\u003e                GoogleApiAvailability.GOOGLE_PLAY_SERVICES_PACKAGE,\u003cbr/\u003e                0\u003cbr/\u003e            )\u003cbr/\u003e        ).also { Log.d(TAG, \u0026#34;Google Play Services version: $it\u0026#34;) }\u003c/span\u003e\u003cspan id=\"9988\"\u003e    } catch (e: PackageManager.NameNotFoundException) {\u003cbr/\u003e        Log.e(TAG, \u0026#34;Google Play Services package not found\u0026#34;, e)\u003cbr/\u003e        null\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"1b99\"\u003e\u003cstrong\u003eBackup Security\u003c/strong\u003e: In Android, to retrieve your preferences after reinstalling an application, we use the backup mechanism. However, this represents a security issue, which is why it has been deprecated starting from Android 12 and may be removed in future versions. We recommend disabling auto-backups for sensitive data by setting \u003ccode\u003eandroid:allowBackup=\u0026#34;false\u0026#34;\u003c/code\u003e. If there is a need to use backups, make sure not to store any sensitive data.\u003c/li\u003e\u003cli id=\"b96f\"\u003e\u003ca href=\"https://www.cvedetails.com/product/19997/Google-Android.html?vendor_id=1224\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eCVE Patching\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e \u0026amp; Dependency Updates\u003c/strong\u003e: In Android, we have a higher probability to use third party library which can represent a vulenrability risk, so before integrating any library, we must check the origin , the maintainers community, the latest support date .. and after that we should regularly update and check for CVEs and finally use only Stable version.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"4438\"\u003e7. Advanced Security Techniques\u003c/h2\u003e\u003cul\u003e\u003cli id=\"8254\"\u003e\u003cstrong\u003eSecure OpenGL\u003c/strong\u003e: In some context , we need to \u003cstrong\u003edraw \u003c/strong\u003esome sensitive information in the screen as displaying the random PIN so to protect rendering data to be read illegaly from the RAM memory, Android purpose this flag \u003cstrong\u003e\u003cem\u003eEGL_PROTECTED_CONTENT_EXT \u003c/em\u003e\u003c/strong\u003e\u003cem\u003eused to protect the rendering data context.\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"479b\"\u003eHere is below this intersting example code to create secured OpenGL context in Android :\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4430\"\u003eimport android.content.Context\u003cbr/\u003eimport android.opengl.EGL14.*\u003cbr/\u003eimport android.opengl.GLSurfaceView\u003cbr/\u003eimport android.util.Log\u003cbr/\u003eimport com.visa.BuildConfig\u003cbr/\u003eimport javax.microedition.khronos.egl.*\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"290d\"\u003e/**\u003cbr/\u003e * A simple GLSurfaceView sub-class that demonstrate how to perform\u003cbr/\u003e * OpenGL ES 2.0 rendering into a GL Surface. Note the following important\u003cbr/\u003e * details:\u003cbr/\u003e *\u003cbr/\u003e * - The class must use a custom context factory to enable 2.0 rendering.\u003cbr/\u003e * See ContextFactory class definition below.\u003cbr/\u003e *\u003cbr/\u003e * - The class must use a custom EGLConfigChooser to be able to select\u003cbr/\u003e * an EGLConfig that supports 2.0. This is done by providing a config\u003cbr/\u003e * specification to eglChooseConfig() that has the attribute\u003cbr/\u003e * EGL10.ELG_RENDERABLE_TYPE containing the EGL_OPENGL_ES2_BIT flag\u003cbr/\u003e * set. See ConfigChooser class definition below.\u003cbr/\u003e *\u003cbr/\u003e * - The class must select the surface\u0026#39;s format, then choose an EGLConfig\u003cbr/\u003e * that matches it exactly (with regards to red/green/blue/alpha channels\u003cbr/\u003e * bit depths). Failure to do so would result in an EGL_BAD_MATCH error.\u003cbr/\u003e *\u003cbr/\u003e * - The class use some OpenGL protection extension if it\u0026#39;s exist on the Android Device otherwise\u003cbr/\u003e *  the used context is standard.\u003cbr/\u003e *  About this mechanism of this protected extension EGL_PROTECTED_CONTENT_EXT = 0x32C0 :\u003cbr/\u003e *\u003cbr/\u003e *  The attribute EGL_PROTECTED_CONTENT_EXT can be applied to EGL contexts,\u003cbr/\u003e *  EGL surfaces and EGLImages. If the attribute EGL_PROTECTED_CONTENT_EXT\u003cbr/\u003e *  is set to EGL_TRUE by the application, then the newly created EGL object\u003cbr/\u003e *  is said to be protected. A protected context is required to allow the\u003cbr/\u003e *  GPU to operate on protected resources, including protected surfaces and\u003cbr/\u003e *  protected EGLImages.\u003cbr/\u003e *\u003cbr/\u003e *  GPU operations are grouped into pipeline stages. Pipeline stages can be\u003cbr/\u003e *  defined to be protected or not protected. Each stage defines\u003cbr/\u003e *  restrictions on whether it can read or write protected and unprotected\u003cbr/\u003e *  resources, as follows:\u003c/span\u003e\u003cspan id=\"7aa1\"\u003e *  When a GPU stage is protected, it:\u003cbr/\u003e * - Can read from protected resources\u003cbr/\u003e * - Can read from unprotected resources\u003cbr/\u003e * - Can write to protected resources\u003cbr/\u003e * - Can NOT write to unprotected resources\u003cbr/\u003e *\u003cbr/\u003e * When a GPU stage is not protected, it:\u003cbr/\u003e * - Can NOT read from protected resources\u003cbr/\u003e * - Can read from unprotected resources\u003cbr/\u003e * - Can NOT write to protected resources\u003cbr/\u003e * - Can write to unprotected resources\u003cbr/\u003e *\u003cbr/\u003e */\u003cbr/\u003einternal class GL2JNIView(\u003cbr/\u003e    context: Context?,\u003cbr/\u003e) : GLSurfaceView(context) {\u003c/span\u003e\u003cspan id=\"7167\"\u003e    companion object {\u003cbr/\u003e        private val TAG = GL2JNIView::class.java.simpleName\u003c/span\u003e\u003cspan id=\"c821\"\u003e        private const val EGL_CONTEXT_CLIENT_ATTR_VERSION = 0x3098\u003cbr/\u003e        private const val EGL_CONTEXT_CLIENT_VALUE_VERSION = 2\u003c/span\u003e\u003cspan id=\"49cc\"\u003e        private const val EGL_EXTENSION_PROTECTED_CONTENT_NAME = \u0026#34;EGL_EXT_protected_content\u0026#34;\u003cbr/\u003e        private const val EGL_EXT_PROTECTED_CONTENT = 0x32C0\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"f3e5\"\u003e    init {\u003cbr/\u003e        val isSecureExtensionSupported = isSecureExtensionSupported()\u003cbr/\u003e        Log.d(TAG, \u0026#34;OpenGl Secure extension supported : $isSecureExtensionSupported\u0026#34;)\u003c/span\u003e\u003cspan id=\"f3be\"\u003e        if (BuildConfig.DEBUG) {\u003cbr/\u003e            debugFlags = DEBUG_CHECK_GL_ERROR or DEBUG_LOG_GL_CALLS\u003cbr/\u003e        }\u003c/span\u003e\u003cspan id=\"fc23\"\u003e        setEGLContextFactory(ContextFactory(isSecureExtensionSupported))\u003cbr/\u003e        setEGLWindowSurfaceFactory(WindowSurfaceFactory(isSecureExtensionSupported))\u003c/span\u003e\u003cspan id=\"e752\"\u003e    }\u003c/span\u003e\u003cspan id=\"7e71\"\u003e    internal inner class ContextFactory(private val secureContext: Boolean) : EGLContextFactory {\u003cbr/\u003e        override fun createContext(egl: EGL10, display: EGLDisplay, config: EGLConfig): EGLContext {\u003c/span\u003e\u003cspan id=\"e889\"\u003e            val attrList = if (secureContext) {\u003cbr/\u003e                intArrayOf(EGL_CONTEXT_CLIENT_ATTR_VERSION,\u003cbr/\u003e                    EGL_CONTEXT_CLIENT_VALUE_VERSION,\u003cbr/\u003e                    EGL_EXT_PROTECTED_CONTENT,\u003cbr/\u003e                    EGL_TRUE,\u003cbr/\u003e                    EGL10.EGL_NONE)\u003cbr/\u003e            } else {\u003cbr/\u003e                intArrayOf(EGL_CONTEXT_CLIENT_VERSION,\u003cbr/\u003e                    EGL_CONTEXT_CLIENT_VALUE_VERSION,\u003cbr/\u003e                    EGL10.EGL_NONE)\u003cbr/\u003e            }\u003c/span\u003e\u003cspan id=\"4039\"\u003e            val context = egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT, attrList)\u003cbr/\u003e            if (context == EGL10.EGL_NO_CONTEXT) {\u003cbr/\u003e                Log.e(TAG, \u0026#34;Error creating EGL context.\u0026#34;)\u003cbr/\u003e            }\u003c/span\u003e\u003cspan id=\"eb52\"\u003e            checkEglError(\u0026#34;eglCreateContext\u0026#34;)\u003c/span\u003e\u003cspan id=\"6e77\"\u003e            return context\u003cbr/\u003e        }\u003c/span\u003e\u003cspan id=\"0f5c\"\u003e        override fun destroyContext(egl: EGL10, display: EGLDisplay, context: EGLContext) {\u003cbr/\u003e            if (!egl.eglDestroyContext(display, context)) {\u003cbr/\u003e                Log.e(\u0026#34;DefaultContextFactory\u0026#34;, \u0026#34;display: $display context: $context\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"fe87\"\u003e    internal inner class WindowSurfaceFactory(private val secureWindowSurface: Boolean) :\u003cbr/\u003e        EGLWindowSurfaceFactory {\u003cbr/\u003e        override fun createWindowSurface(\u003cbr/\u003e            egl: EGL10,\u003cbr/\u003e            display: EGLDisplay,\u003cbr/\u003e            config: EGLConfig,\u003cbr/\u003e            nativeWindow: Any,\u003cbr/\u003e        ): EGLSurface? {\u003cbr/\u003e            var result: EGLSurface? = null\u003c/span\u003e\u003cspan id=\"1aa3\"\u003e            try {\u003cbr/\u003e                val attrList = if (secureWindowSurface) {\u003cbr/\u003e                    intArrayOf(EGL_EXT_PROTECTED_CONTENT, EGL_TRUE, EGL10.EGL_NONE)\u003cbr/\u003e                } else {\u003cbr/\u003e                    intArrayOf(EGL10.EGL_NONE, EGL10.EGL_NONE, EGL10.EGL_NONE)\u003cbr/\u003e                }\u003cbr/\u003e                result = egl.eglCreateWindowSurface(display, config, nativeWindow, attrList)\u003c/span\u003e\u003cspan id=\"503a\"\u003e                checkEglError(\u0026#34;eglCreateWindowSurface\u0026#34;)\u003c/span\u003e\u003cspan id=\"04ed\"\u003e            } catch (e: IllegalArgumentException) {\u003cbr/\u003e                Log.e(TAG, \u0026#34;eglCreateWindowSurface\u0026#34;, e)\u003cbr/\u003e            }\u003c/span\u003e\u003cspan id=\"9b9c\"\u003e            return result\u003cbr/\u003e        }\u003c/span\u003e\u003cspan id=\"3e41\"\u003e        override fun destroySurface(egl: EGL10, display: EGLDisplay, surface: EGLSurface) {\u003cbr/\u003e            egl.eglDestroySurface(display, surface)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"3e30\"\u003e    private fun isSecureExtensionSupported(): Boolean {\u003cbr/\u003e        val display: android.opengl.EGLDisplay? = eglGetDisplay(EGL_DEFAULT_DISPLAY)\u003cbr/\u003e        val extensions = eglQueryString(display, EGL10.EGL_EXTENSIONS)\u003cbr/\u003e        return extensions != null \u0026amp;\u0026amp; extensions.contains(EGL_EXTENSION_PROTECTED_CONTENT_NAME)\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"5c9a\"\u003e    private fun checkEglError(methodName: String) {\u003cbr/\u003e        val eglResult = eglGetError()\u003cbr/\u003e        if (eglResult == EGL_SUCCESS) {\u003cbr/\u003e            val message = \u0026#34;$methodName succeeded without error (EGL_SUCCESS)\u0026#34;\u003cbr/\u003e            Log.d(TAG, message)\u003cbr/\u003e        } else {\u003cbr/\u003e            val errorHexString = \u0026#34;0x${Integer.toHexString(eglResult)}\u0026#34;\u003cbr/\u003e            val errorDesc = eglResultDesc(eglResult)\u003cbr/\u003e            val message = \u0026#34;$methodName: EGL error $errorHexString encountered. $errorDesc\u0026#34;\u003c/span\u003e\u003cspan id=\"b083\"\u003e            Log.e(TAG, message)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"b1c0\"\u003e    // \u003ca href=\"https://registry.khronos.org/EGL/sdk/docs/man/html/eglGetError.xhtml\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://registry.khronos.org/EGL/sdk/docs/man/html/eglGetError.xhtml\u003c/a\u003e\u003cbr/\u003e    private fun eglResultDesc(eglResult: Int) =\u003cbr/\u003e        when (eglResult) {\u003cbr/\u003e            EGL_SUCCESS -\u0026gt; \u0026#34;The last function succeeded without error.\u0026#34;\u003cbr/\u003e            EGL_NOT_INITIALIZED -\u0026gt; \u0026#34;EGL is not initialized, or could not be initialized, for the specified EGL display connection.\u0026#34;\u003cbr/\u003e            EGL_BAD_ACCESS -\u0026gt; \u0026#34;EGL cannot access a requested resource (for example a context is bound in another thread).\u0026#34;\u003cbr/\u003e            EGL_BAD_ALLOC -\u0026gt; \u0026#34;EGL failed to allocate resources for the requested operation.\u0026#34;\u003cbr/\u003e            EGL_BAD_ATTRIBUTE -\u0026gt; \u0026#34;An unrecognized attribute or attribute value was passed in the attribute list.\u0026#34;\u003cbr/\u003e            EGL_BAD_CONTEXT -\u0026gt; \u0026#34;An EGLContext argument does not name a valid EGL rendering context.\u0026#34;\u003cbr/\u003e            EGL_BAD_CONFIG -\u0026gt; \u0026#34;An EGLConfig argument does not name a valid EGL frame buffer configuration.\u0026#34;\u003cbr/\u003e            EGL_BAD_CURRENT_SURFACE -\u0026gt; \u0026#34;The current surface of the calling thread is a window, pixel buffer or pixmap that is no longer valid.\u0026#34;\u003cbr/\u003e            EGL_BAD_DISPLAY -\u0026gt; \u0026#34;An EGLDisplay argument does not name a valid EGL display connection.\u0026#34;\u003cbr/\u003e            EGL_BAD_SURFACE -\u0026gt; \u0026#34;An EGLSurface argument does not name a valid surface (window, pixel buffer or pixmap) configured for GL rendering.\u0026#34;\u003cbr/\u003e            EGL_BAD_MATCH -\u0026gt; \u0026#34;Arguments are inconsistent (for example, a valid context requires buffers not supplied by a valid surface).\u0026#34;\u003cbr/\u003e            EGL_BAD_PARAMETER -\u0026gt; \u0026#34;One or more argument values are invalid.\u0026#34;\u003cbr/\u003e            EGL_BAD_NATIVE_PIXMAP -\u0026gt; \u0026#34;A NativePixmapType argument does not refer to a valid native pixmap.\u0026#34;\u003cbr/\u003e            EGL_BAD_NATIVE_WINDOW -\u0026gt; \u0026#34;A NativeWindowType argument does not refer to a valid native window.\u0026#34;\u003cbr/\u003e            EGL_CONTEXT_LOST -\u0026gt; \u0026#34;A power management event has occurred. The application must destroy all contexts and reinitialise OpenGL ES state and objects to continue rendering.\u0026#34;\u003cbr/\u003e            else -\u0026gt; \u0026#34;\u0026#34;\u003cbr/\u003e        }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"cc07\"\u003e\u003cstrong\u003eMultiprocess Security\u003c/strong\u003e: To avoid a global disaster in the event that reading data from memory is compromised, we recommend defining a multiprocess mechanism using \u003ccode\u003e\u003cstrong\u003eisolatedProcess\u003c/strong\u003e\u003c/code\u003e. This helps to prevent unauthorized access by ensuring that each process operates in a separate environment, making it more difficult for one process to access the memory or data of another..\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f7c3\"\u003eAs example, introduce an isolted process service container :\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7df3\"\u003e\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u003cbr/\u003e    package=\u0026#34;com.payement.app\u0026#34;\u003cbr/\u003e    xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt;\u003cbr/\u003e    \u0026lt;application\u0026gt;\u003cbr/\u003e        \u0026lt;service\u003cbr/\u003e            android:name=\u0026#34;com.payement.app.service.IsoltedProcessService\u0026#34;\u003cbr/\u003e            android:process=\u0026#34;:isoltedProcessProcess\u0026#34; /\u0026gt;\u003cbr/\u003e    \u0026lt;/application\u0026gt;\u003cbr/\u003e\u0026lt;/manifest\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003cul\u003e\u003cli id=\"eeb1\"\u003e\u003cstrong\u003eBonus: \u003c/strong\u003eHere is some useful resources to be up to date by security world of Android: \u003ca href=\"https://www.jssec.org/dl/android_securecoding_en.pdf\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eandroid_securecoding_en.pdf\u003c/a\u003e , \u003ca href=\"https://developer.android.com/privacy-and-security/security-best-practices\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esecurity-best-practices\u003c/a\u003e, \u003ca href=\"https://owasp.org/www-project-mobile-app-security/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ewww-project-mobile-app-security\u003c/a\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"3e75\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"c31c\"\u003eBy reading this article, you can get an idea of how a simple payment transaction, which takes only a few seconds, goes through a comprehensive security workflow. Also, keep in mind that there is no final version of security — it’s crucial to continuously stay aligned and updated with the evolving security landscape of Android.\u003c/p\u003e\u003cp id=\"1fa4\"\u003eAnd finally remember, in every update of your security layer, don’t forget this quote:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"c3a4\"\u003e“Don’t let security kill your business, try to find the right balance.”\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"d064\"\u003eFor any question \u0026amp; suggestion, Let’s discuss !\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "51 min read",
  "publishedTime": "2025-04-14T14:14:16.551Z",
  "modifiedTime": null
}
