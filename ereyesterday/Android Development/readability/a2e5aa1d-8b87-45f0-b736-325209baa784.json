{
  "id": "a2e5aa1d-8b87-45f0-b736-325209baa784",
  "title": "The simplest way to understand side effects in compose",
  "link": "https://proandroiddev.com/the-simplest-way-to-understand-side-effects-in-compose-e82f470b88af?source=rss----c72404660798---4",
  "description": "",
  "author": "Karishma Agrawal",
  "published": "Sun, 20 Oct 2024 18:37:26 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "android-development",
    "side-effects",
    "compose"
  ],
  "byline": "Karishma Agrawal",
  "length": 9913,
  "excerpt": "In Jetpack Compose, a modern UI toolkit for Android, side effects are ways to handle changes outside the UI hierarchy that need to be reflected in your Compose functions or to ensure certain actions…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In Jetpack Compose, a modern UI toolkit for Android, side effects are ways to handle changes outside the UI hierarchy that need to be reflected in your Compose functions or to ensure certain actions take place as a result of state changes. Side effects help bridge the gap between the declarative nature of Compose and the imperative interactions that might be needed, such as updating a database, logging, or performing a one-time action.Key Side Effect APIs in Jetpack ComposeHere’s a breakdown of the main side effect functions provided by Compose and how they are typically used:1.SideEffectWhat is it?SideEffect is used to run code whenever the Composable function is re-composed. It ensures that code inside it will always run after the Composable function has finished rendering.Use Case:Logging or reporting analytics.You want to perform some actions that are related to the UI but don't directly affect its state.@Composablefun ExampleSideEffect(name: String) { Text(\"Hello, $name\") SideEffect { Log.d(\"ExampleSideEffect\", \"Composed with name: $name\") }}- This will log a message every time the name parameter changes, which means that the ExampleSideEffect gets recomposed.2. LaunchedEffectWhat is it?LaunchedEffect is used for running suspend functions (coroutines) when a particular key changes. It runs its block of code when the Composable enters the composition and again when its keys change.It cancels any previous coroutine if the key changes.Use Case:Fetching data from a network or database when a particular state changes.Showing a one-time toast message when the UI is first composed.Example:@Composablefun ExampleLaunchedEffect(userId: String) { var userName by remember { mutableStateOf(\"\") } LaunchedEffect(userId) { // Fetch user data when userId changes. userName = fetchUserName(userId) } Text(\"User name is $userName\")}In this example, whenever the userId changes, LaunchedEffect fetches the user name.3. rememberUpdatedStateWhat is it?This is used when you want a stable reference to some changing state within a side effect.It ensures that the latest value is available for a side effect while keeping the side effect stable.Use Case:You are launching a coroutine or a callback, but you want the latest state to be used within that coroutine.Example:@Composablefun ExampleRememberUpdatedState(onTimeout: () -\u003e Unit) { val currentOnTimeout by rememberUpdatedState(onTimeout) LaunchedEffect(Unit) { delay(5000) currentOnTimeout() // Uses the latest version of onTimeout. }}This ensures that if onTimeout changes, the LaunchedEffect will still call the latest onTimeout even though it might have been launched with an older version.4. DisposableEffectWhat is it?DisposableEffect is used when you need to perform cleanup actions when a Composable leaves the composition.It is similar to LaunchedEffect, but it provides a Disposable function for cleanup when the effect should be disposed of.Use Case:Starting and stopping a listener, such as a location listener or a sensor.Cleaning up resources, like closing a database connection or canceling a network request.Example:@Composablefun ExampleDisposableEffect() { DisposableEffect(Unit) { val listener = MyListener() listener.startListening() onDispose { listener.stopListening() // Clean up when this Composable leaves the composition. } } Text(\"Listening for updates...\")}This starts `MyListener` when the `Composable` enters the composition and stops it when the `Composable` leaves the composition.5. produceStateWhat is it?produceState is used to convert non-Compose state into State that can be used in Compose. It launches a coroutine and updates its State over time.Use Case:Fetching data from a repository and exposing it as a State that Composable can observe.Example:@Composablefun ExampleProduceState(userId: String): State\u003cString\u003e { return produceState(initialValue = \"Loading...\", userId) { value = fetchUserName(userId) }}This creates a state that initially holds \"Loading…” and updates with the user’s name once it’s fetched.6. snapshotFlowWhat is it?snapshotFlow is used when you want to observe changes to a State and convert them into a Flow.Use Case:Reacting to changes in a State variable and processing them in a coroutine.Example@Composablefun ExampleSnapshotFlow(counter: State\u003cInt\u003e) { LaunchedEffect(Unit) { snapshotFlow { counter.value } .collect { newValue -\u003e Log.d(\"ExampleSnapshotFlow\", \"Counter changed to $newValue\") } }}Here, any changes to counter will be collected and logged.7. rememberCoroutineScopeWhat is it?rememberCoroutineScope is used to create a CoroutineScope tied to the lifecycle of a Composable. It provides a CoroutineScope that can be used to launch coroutines for background work, such as network requests or animations, from inside a Composable.This scope is cancelled automatically when the Composable leaves the composition, so you don’t need to manage its lifecycle manually.Use Case:Triggering an asynchronous action when the user interacts with the UI, such as starting an animation or fetching data on button clicks.Example@Composablefun ExampleRememberCoroutineScope() { val coroutineScope = rememberCoroutineScope() var text by remember { mutableStateOf(\"Click to load\") } Button(onClick = { coroutineScope.launch { text = loadDataFromNetwork() } }) { Text(text) }}suspend fun loadDataFromNetwork(): String { delay(2000) // Simulate a network delay return \"Data loaded\"}In this example, rememberCoroutineScope allows us to launch a coroutine when the button is clicked, making the UI reactive to the asynchronous data loading without needing to manage the scope manually.8. rememberUpdatedStateWhat is it?rememberUpdatedState provides a way to remember the most recent value of a state without triggering recomposition. It’s particularly useful in LaunchedEffect or DisposableEffect to ensure that these side effects always have access to the latest state values even when they aren’t recomposed themselves.It ensures that a reference used inside a side effect block (e.g., a coroutine or listener) always points to the updated value of the variable.Use Case:When you have a long-running coroutine or callback and you want to ensure that it always refers to the latest state or value without restarting the coroutine.Example:@Composablefun ExampleRememberUpdatedState(onTimeout: () -\u003e Unit) { val currentOnTimeout by rememberUpdatedState(onTimeout) LaunchedEffect(Unit) { delay(5000) currentOnTimeout() // Uses the latest version of onTimeout. }}Here, even if onTimeout changes while the coroutine is still waiting during the delay, currentOnTimeout will always refer to the latest version of onTimeout. This is useful in scenarios where you have changing callbacks but don’t want to restart the side effect every time the callback changes.9. derivedStateOfWhat is it?derivedStateOf is used to create a State that is derived from other states, helping to optimize recompositions. It wraps a calculation or transformation of a state, and the derived state only gets recomposed when its dependencies change.This can reduce unnecessary recompositions by ensuring that the derivedState only changes when the underlying state it depends on changes.Use Case:Calculating values that are derived from other states, like filtering a list based on some condition or computing a derived value from an existing state.Example:@Composablefun ExampleDerivedStateOf() { var inputText by remember { mutableStateOf(\"\") } val isInputValid by derivedStateOf { inputText.length \u003e 3 } Column { TextField( value = inputText, onValueChange = { inputText = it }, label = { Text(\"Enter text\") } ) if (isInputValid) { Text(\"Input is valid\") } else { Text(\"Input is too short\") } }}In this example, isInputValid is derived from inputText using derivedStateOf. This means that isInputValid will only update when inputText changes, making the recomposition more efficient. It won’t trigger unnecessary recompositions if inputText stays the same length.Real-Time Example Using Multiple Side Effect APIsImagine a chat application where we need to fetch messages when a user logs in and keep listening for new messages. We also need to clean up resources when the user logs out.@Composablefun ChatScreen(userId: String, onLogout: () -\u003e Unit) { var messages by remember { mutableStateOf(listOf\u003cMessage\u003e()) } var isListening by remember { mutableStateOf(false) } // Fetch messages whenever the userId changes LaunchedEffect(userId) { messages = fetchChatMessages(userId) } // Start listening to new messages when we enter composition. DisposableEffect(Unit) { val listener = MessageListener { newMessage -\u003e messages = messages + newMessage } listener.startListening() onDispose { listener.stopListening() // Stop listening when ChatScreen leaves the composition. } } // Log when messages change using SideEffect. SideEffect { Log.d(\"ChatScreen\", \"New messages count: ${messages.size}\") } // Display messages. LazyColumn { items(messages) { message -\u003e Text(text = message.content) } }}In this example:LaunchedEffect fetches the initial messages when the userId changes.DisposableEffect starts a listener when ChatScreen enters the composition and stops it when it leaves.SideEffect logs each time the messages change.This approach ensures that each task (fetching, listening, logging) is handled appropriately based on the lifecycle of the `ChatScreen` Composable, making the code cleaner and more maintainable.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*c--J8hEDBqzXrBVlVG8zUA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp id=\"c61d\"\u003eIn Jetpack Compose, a modern UI toolkit for Android, \u003cstrong\u003eside effects\u003c/strong\u003e are ways to handle changes outside the UI hierarchy that need to be reflected in your Compose functions or to ensure certain actions take place as a result of state changes. Side effects help bridge the gap between the declarative nature of Compose and the imperative interactions that might be needed, such as updating a database, logging, or performing a one-time action.\u003c/p\u003e\u003ch2 id=\"ea89\"\u003eKey Side Effect APIs in Jetpack Compose\u003c/h2\u003e\u003cp id=\"0b49\"\u003eHere’s a breakdown of the main side effect functions provided by Compose and how they are typically used:\u003c/p\u003e\u003cp id=\"5992\"\u003e1.\u003ccode\u003eSideEffect\u003c/code\u003e\u003cbr/\u003e\u003cstrong\u003eWhat is it?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"2318\"\u003e\u003ccode\u003eSideEffect\u003c/code\u003e is used to run code whenever the \u003ccode\u003eComposable\u003c/code\u003e function is re-composed. It ensures that code inside it will always run \u003cstrong\u003eafter\u003c/strong\u003e the \u003ccode\u003eComposable\u003c/code\u003e function has finished rendering.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3b1a\"\u003e\u003cstrong\u003eUse Case:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"51fe\"\u003eLogging or reporting analytics.\u003c/li\u003e\u003cli id=\"151d\"\u003eYou want to perform some actions that are related to the UI but don\u0026#39;t directly affect its state.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"28bb\"\u003e@Composable\u003cbr/\u003efun ExampleSideEffect(name: String) {\u003cbr/\u003e    Text(\u0026#34;Hello, $name\u0026#34;)\u003cbr/\u003e    SideEffect {\u003cbr/\u003e        Log.d(\u0026#34;ExampleSideEffect\u0026#34;, \u0026#34;Composed with name: $name\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ad79\"\u003e- This will log a message every time the \u003ccode\u003ename\u003c/code\u003e parameter changes, which means that the \u003ccode\u003eExampleSideEffect\u003c/code\u003e gets recomposed.\u003c/p\u003e\u003ch2 id=\"69dd\"\u003e2. \u003ccode\u003eLaunchedEffect\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"2f67\"\u003e\u003cstrong\u003eWhat is it?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"8763\"\u003e\u003ccode\u003eLaunchedEffect\u003c/code\u003e is used for running \u003cstrong\u003esuspend functions\u003c/strong\u003e (coroutines) when a particular key changes. It runs its block of code when the \u003ccode\u003eComposable\u003c/code\u003e enters the composition and again when its keys change.\u003c/li\u003e\u003cli id=\"891a\"\u003eIt cancels any previous coroutine if the key changes.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8a43\"\u003e\u003cstrong\u003eUse Case:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"7804\"\u003eFetching data from a network or database when a particular state changes.\u003c/li\u003e\u003cli id=\"1f4b\"\u003eShowing a one-time toast message when the UI is first composed.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b2b7\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dc5c\"\u003e@Composable\u003cbr/\u003efun ExampleLaunchedEffect(userId: String) {\u003cbr/\u003e    var userName by remember { mutableStateOf(\u0026#34;\u0026#34;) }\u003cp\u003e    LaunchedEffect(userId) {\u003cbr/\u003e        // Fetch user data when userId changes.\u003cbr/\u003e        userName = fetchUserName(userId)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    Text(\u0026#34;User name is $userName\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fbda\"\u003eIn this example, whenever the \u003ccode\u003euserId\u003c/code\u003e changes, \u003ccode\u003eLaunchedEffect\u003c/code\u003e fetches the user name.\u003c/p\u003e\u003cp id=\"d1ad\"\u003e3. \u003ccode\u003erememberUpdatedState\u003c/code\u003e\u003c/p\u003e\u003cp id=\"3274\"\u003e\u003cstrong\u003eWhat is it?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"a4ac\"\u003eThis is used when you want a \u003cstrong\u003estable reference\u003c/strong\u003e to some changing state within a side effect.\u003c/li\u003e\u003cli id=\"8d5e\"\u003eIt ensures that the latest value is available for a side effect while keeping the side effect stable.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2c55\"\u003e\u003cstrong\u003eUse Case:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"2b5c\"\u003eYou are launching a coroutine or a callback, but you want the latest state to be used within that coroutine.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"a81c\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a2c0\"\u003e@Composable\u003cbr/\u003efun ExampleRememberUpdatedState(onTimeout: () -\u0026gt; Unit) {\u003cbr/\u003e    val currentOnTimeout by rememberUpdatedState(onTimeout)\u003cp\u003e    LaunchedEffect(Unit) {\u003cbr/\u003e        delay(5000)\u003cbr/\u003e        currentOnTimeout() // Uses the latest version of onTimeout.\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6025\"\u003eThis ensures that if \u003ccode\u003eonTimeout\u003c/code\u003e changes, the \u003ccode\u003eLaunchedEffect\u003c/code\u003e will still call the latest \u003ccode\u003eonTimeout\u003c/code\u003e even though it might have been launched with an older version.\u003c/p\u003e\u003cp id=\"658f\"\u003e4. \u003ccode\u003eDisposableEffect\u003c/code\u003e\u003c/p\u003e\u003cp id=\"357b\"\u003e\u003cstrong\u003eWhat is it?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"3a80\"\u003e\u003ccode\u003eDisposableEffect\u003c/code\u003e is used when you need to perform \u003cstrong\u003ecleanup actions\u003c/strong\u003e when a \u003ccode\u003eComposable\u003c/code\u003e leaves the composition.\u003c/li\u003e\u003cli id=\"8d3b\"\u003eIt is similar to \u003ccode\u003eLaunchedEffect\u003c/code\u003e, but it provides a \u003ccode\u003eDisposable\u003c/code\u003e function for cleanup when the effect should be disposed of.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8ced\"\u003e\u003cstrong\u003eUse Case:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"2d9a\"\u003eStarting and stopping a listener, such as a location listener or a sensor.\u003c/li\u003e\u003cli id=\"7f84\"\u003eCleaning up resources, like closing a database connection or canceling a network request.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2e21\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3e13\"\u003e@Composable\u003cbr/\u003efun ExampleDisposableEffect() {\u003cbr/\u003e    DisposableEffect(Unit) {\u003cbr/\u003e        val listener = MyListener()\u003cbr/\u003e        listener.startListening()\u003cp\u003e        onDispose {\u003cbr/\u003e            listener.stopListening() // Clean up when this Composable leaves the composition.\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    Text(\u0026#34;Listening for updates...\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9ec0\"\u003eThis starts `MyListener` when the `Composable` enters the composition and stops it when the `Composable` leaves the composition.\u003c/p\u003e\u003cp id=\"6924\"\u003e5. \u003ccode\u003eproduceState\u003c/code\u003e\u003c/p\u003e\u003cp id=\"fbd0\"\u003e\u003cstrong\u003eWhat is it?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"185d\"\u003e\u003ccode\u003eproduceState\u003c/code\u003e is used to convert \u003cstrong\u003enon-Compose state\u003c/strong\u003e into \u003ccode\u003eState\u003c/code\u003e that can be used in Compose. It launches a coroutine and updates its \u003ccode\u003eState\u003c/code\u003e over time.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c797\"\u003e\u003cstrong\u003eUse Case:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"b449\"\u003eFetching data from a repository and exposing it as a \u003ccode\u003eState\u003c/code\u003e that \u003ccode\u003eComposable\u003c/code\u003e can observe.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"29c2\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e854\"\u003e@Composable\u003cbr/\u003efun ExampleProduceState(userId: String): State\u0026lt;String\u0026gt; {\u003cbr/\u003e    return produceState(initialValue = \u0026#34;Loading...\u0026#34;, userId) {\u003cbr/\u003e        value = fetchUserName(userId)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"18c5\"\u003eThis creates a state that initially holds \u003ccode\u003e\u0026#34;Loading…”\u003c/code\u003e and updates with the user’s name once it’s fetched.\u003c/p\u003e\u003cp id=\"facb\"\u003e6. \u003ccode\u003esnapshotFlow\u003c/code\u003e\u003c/p\u003e\u003cp id=\"c5d3\"\u003e\u003cstrong\u003eWhat is it?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"d768\"\u003e\u003ccode\u003esnapshotFlow\u003c/code\u003e is used when you want to \u003cstrong\u003eobserve changes\u003c/strong\u003e to a \u003ccode\u003eState\u003c/code\u003e and convert them into a \u003ccode\u003eFlow\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"22b2\"\u003e\u003cstrong\u003eUse Case:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"c599\"\u003eReacting to changes in a \u003ccode\u003eState\u003c/code\u003e variable and processing them in a coroutine.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"564d\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"05b9\"\u003e@Composable\u003cbr/\u003efun ExampleSnapshotFlow(counter: State\u0026lt;Int\u0026gt;) {\u003cbr/\u003e    LaunchedEffect(Unit) {\u003cbr/\u003e        snapshotFlow { counter.value }\u003cbr/\u003e            .collect { newValue -\u0026gt;\u003cbr/\u003e                Log.d(\u0026#34;ExampleSnapshotFlow\u0026#34;, \u0026#34;Counter changed to $newValue\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9cb8\"\u003eHere, any changes to \u003ccode\u003ecounter\u003c/code\u003e will be collected and logged.\u003c/p\u003e\u003cp id=\"9114\"\u003e7. \u003ccode\u003erememberCoroutineScope\u003c/code\u003e\u003c/p\u003e\u003cp id=\"c26f\"\u003e\u003cstrong\u003eWhat is it?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"adf6\"\u003e\u003ccode\u003erememberCoroutineScope\u003c/code\u003e is used to create a \u003ccode\u003eCoroutineScope\u003c/code\u003e tied to the lifecycle of a \u003ccode\u003eComposable\u003c/code\u003e. It provides a \u003ccode\u003eCoroutineScope\u003c/code\u003e that can be used to launch coroutines for background work, such as network requests or animations, from inside a \u003ccode\u003eComposable\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"64fd\"\u003eThis scope is cancelled automatically when the \u003ccode\u003eComposable\u003c/code\u003e leaves the composition, so you don’t need to manage its lifecycle manually.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c417\"\u003e\u003cstrong\u003eUse Case:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"ba2a\"\u003eTriggering an asynchronous action when the user interacts with the UI, such as starting an animation or fetching data on button clicks.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"a5c4\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d158\"\u003e@Composable\u003cbr/\u003efun ExampleRememberCoroutineScope() {\u003cbr/\u003e    val coroutineScope = rememberCoroutineScope()\u003cbr/\u003e    var text by remember { mutableStateOf(\u0026#34;Click to load\u0026#34;) }\u003cp\u003e    Button(onClick = {\u003cbr/\u003e        coroutineScope.launch {\u003cbr/\u003e            text = loadDataFromNetwork()\u003cbr/\u003e        }\u003cbr/\u003e    }) {\u003cbr/\u003e        Text(text)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003esuspend fun loadDataFromNetwork(): String {\u003cbr/\u003e    delay(2000) // Simulate a network delay\u003cbr/\u003e    return \u0026#34;Data loaded\u0026#34;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1b36\"\u003eIn this example, \u003ccode\u003erememberCoroutineScope\u003c/code\u003e allows us to launch a coroutine when the button is clicked, making the UI reactive to the asynchronous data loading without needing to manage the scope manually.\u003c/p\u003e\u003cp id=\"ead4\"\u003e8. \u003ccode\u003erememberUpdatedState\u003c/code\u003e\u003c/p\u003e\u003cp id=\"95d4\"\u003e\u003cstrong\u003eWhat is it?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"a51c\"\u003e\u003ccode\u003erememberUpdatedState\u003c/code\u003e provides a way to remember the most recent value of a state without triggering recomposition. It’s particularly useful in \u003ccode\u003eLaunchedEffect\u003c/code\u003e or \u003ccode\u003eDisposableEffect\u003c/code\u003e to ensure that these side effects always have access to the latest state values even when they aren’t recomposed themselves.\u003c/li\u003e\u003cli id=\"c5e0\"\u003eIt ensures that a reference used inside a side effect block (e.g., a coroutine or listener) always points to the updated value of the variable.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6962\"\u003e\u003cstrong\u003eUse Case:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"594f\"\u003eWhen you have a long-running coroutine or callback and you want to ensure that it always refers to the latest state or value without restarting the coroutine.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"643e\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"78d5\"\u003e@Composable\u003cbr/\u003efun ExampleRememberUpdatedState(onTimeout: () -\u0026gt; Unit) {\u003cbr/\u003e    val currentOnTimeout by rememberUpdatedState(onTimeout)\u003cp\u003e    LaunchedEffect(Unit) {\u003cbr/\u003e        delay(5000)\u003cbr/\u003e        currentOnTimeout() // Uses the latest version of onTimeout.\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b931\"\u003eHere, even if \u003ccode\u003eonTimeout\u003c/code\u003e changes while the coroutine is still waiting during the \u003ccode\u003edelay\u003c/code\u003e, \u003ccode\u003ecurrentOnTimeout\u003c/code\u003e will always refer to the latest version of \u003ccode\u003eonTimeout\u003c/code\u003e. This is useful in scenarios where you have changing callbacks but don’t want to restart the side effect every time the callback changes.\u003c/p\u003e\u003cp id=\"5199\"\u003e9. \u003ccode\u003ederivedStateOf\u003c/code\u003e\u003c/p\u003e\u003cp id=\"4744\"\u003e\u003cstrong\u003eWhat is it?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"d1b0\"\u003e\u003ccode\u003ederivedStateOf\u003c/code\u003e is used to create a \u003ccode\u003eState\u003c/code\u003e that is derived from other states, helping to optimize recompositions. It wraps a calculation or transformation of a state, and the derived state only gets recomposed when its dependencies change.\u003c/li\u003e\u003cli id=\"cfdb\"\u003eThis can reduce unnecessary recompositions by ensuring that the \u003ccode\u003ederivedState\u003c/code\u003e only changes when the underlying state it depends on changes.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6ee1\"\u003e\u003cstrong\u003eUse Case:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"c6e2\"\u003eCalculating values that are derived from other states, like filtering a list based on some condition or computing a derived value from an existing state.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"0e7d\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e7ef\"\u003e@Composable\u003cbr/\u003efun ExampleDerivedStateOf() {\u003cbr/\u003e    var inputText by remember { mutableStateOf(\u0026#34;\u0026#34;) }\u003cbr/\u003e    val isInputValid by derivedStateOf {\u003cbr/\u003e        inputText.length \u0026gt; 3\u003cbr/\u003e    }\u003cp\u003e    Column {\u003cbr/\u003e        TextField(\u003cbr/\u003e            value = inputText,\u003cbr/\u003e            onValueChange = { inputText = it },\u003cbr/\u003e            label = { Text(\u0026#34;Enter text\u0026#34;) }\u003cbr/\u003e        )\u003c/p\u003e\u003cp\u003e        if (isInputValid) {\u003cbr/\u003e            Text(\u0026#34;Input is valid\u0026#34;)\u003cbr/\u003e        } else {\u003cbr/\u003e            Text(\u0026#34;Input is too short\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2ff8\"\u003eIn this example, \u003ccode\u003eisInputValid\u003c/code\u003e is derived from \u003ccode\u003einputText\u003c/code\u003e using \u003ccode\u003ederivedStateOf\u003c/code\u003e. This means that \u003ccode\u003eisInputValid\u003c/code\u003e will only update when \u003ccode\u003einputText\u003c/code\u003e changes, making the recomposition more efficient. It won’t trigger unnecessary recompositions if \u003ccode\u003einputText\u003c/code\u003e stays the same length.\u003c/p\u003e\u003ch2 id=\"9e12\"\u003eReal-Time Example Using Multiple Side Effect APIs\u003c/h2\u003e\u003cp id=\"b20a\"\u003eImagine a chat application where we need to fetch messages when a user logs in and keep listening for new messages. We also need to clean up resources when the user logs out.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4b17\"\u003e@Composable\u003cbr/\u003efun ChatScreen(userId: String, onLogout: () -\u0026gt; Unit) {\u003cbr/\u003e    var messages by remember { mutableStateOf(listOf\u0026lt;Message\u0026gt;()) }\u003cbr/\u003e    var isListening by remember { mutableStateOf(false) }\u003cp\u003e    // Fetch messages whenever the userId changes\u003cbr/\u003e    LaunchedEffect(userId) {\u003cbr/\u003e        messages = fetchChatMessages(userId)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // Start listening to new messages when we enter composition.\u003cbr/\u003e    DisposableEffect(Unit) {\u003cbr/\u003e        val listener = MessageListener { newMessage -\u0026gt;\u003cbr/\u003e            messages = messages + newMessage\u003cbr/\u003e        }\u003cbr/\u003e        listener.startListening()\u003c/p\u003e\u003cp\u003e        onDispose {\u003cbr/\u003e            listener.stopListening() // Stop listening when ChatScreen leaves the composition.\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // Log when messages change using SideEffect.\u003cbr/\u003e    SideEffect {\u003cbr/\u003e        Log.d(\u0026#34;ChatScreen\u0026#34;, \u0026#34;New messages count: ${messages.size}\u0026#34;)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // Display messages.\u003cbr/\u003e    LazyColumn {\u003cbr/\u003e        items(messages) { message -\u0026gt;\u003cbr/\u003e            Text(text = message.content)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"758a\"\u003eIn this example:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b603\"\u003e\u003ccode\u003e\u003cstrong\u003eLaunchedEffect\u003c/strong\u003e\u003c/code\u003e fetches the initial messages when the \u003ccode\u003euserId\u003c/code\u003e changes.\u003c/li\u003e\u003cli id=\"66ea\"\u003e\u003ccode\u003e\u003cstrong\u003eDisposableEffect\u003c/strong\u003e\u003c/code\u003e starts a listener when \u003ccode\u003eChatScreen\u003c/code\u003e enters the composition and stops it when it leaves.\u003c/li\u003e\u003cli id=\"3cf4\"\u003e\u003ccode\u003e\u003cstrong\u003eSideEffect\u003c/strong\u003e\u003c/code\u003e logs each time the messages change.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"69f3\"\u003eThis approach ensures that each task (fetching, listening, logging) is handled appropriately based on the lifecycle of the `ChatScreen` Composable, making the code cleaner and more maintainable.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2024-10-18T06:14:56.034Z",
  "modifiedTime": null
}
