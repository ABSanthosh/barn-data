{
  "id": "e9c90ee2-4fc9-4298-a883-a5c4264ea937",
  "title": "Why Your Network Calls on the Main Thread Aren’t Crashing your Android App",
  "link": "https://proandroiddev.com/why-your-network-calls-on-the-main-thread-arent-crashing-your-android-app-a7429bccdff8?source=rss----c72404660798---4",
  "description": "",
  "author": "Dobri Kostadinov",
  "published": "Fri, 14 Feb 2025 17:33:56 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "androiddev",
    "kotlin",
    "android",
    "android-app-development",
    "mobile-app-development"
  ],
  "byline": "Dobri Kostadinov",
  "length": 5594,
  "excerpt": "As an Android developer, you have probably heard many times that network calls should never be executed on the main thread. However, you may have noticed that your app does not crash even when…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Understanding Why Your App Does Not Crash Despite Running Network Requests on the Main Thread and Why Following Best Practices is EssentialIntroductionAs an Android developer, you have probably heard many times that network calls should never be executed on the main thread. However, you may have noticed that your app does not crash even when network logic runs on the main thread without explicitly switching to Dispatchers.IO. What is happening? Has something changed? Let’s explore the details.1. The Traditional Rule: Never Block the Main ThreadFor years, Android developers have followed this rule: network operations should not run on the main thread because:The main thread is responsible for rendering the UI and handling user interactions.If a network request takes too long, it will freeze the UI and lead to an Application Not Responding (ANR) error.In Android versions before 4.0, executing a network call on the main thread would immediately crash the app with a NetworkOnMainThreadException.If your app is not crashing, there must be a reason!2. Why Is Your App Not Crashing?2.1 OkHttp, Retrofit, and Ktor Do Not Always Handle Threading AutomaticallyIf you are using Retrofit with OkHttp and suspending functions, OkHttp internally handles network requests on a background thread. However, this only applies when Retrofit uses coroutines or its default async execution model.If you make a synchronous network request using OkHttp’s .execute() method directly on the main thread, it will block and may cause an ANR.Example:val response = api.getData().execute() // This will block the main threadHowever, if you use OkHttp’s asynchronous .enqueue() method, it will run on an internal OkHttp-managed thread:api.getData().enqueue(object : Callback\u003cResponse\u003cMyData\u003e\u003e { override fun onResponse(call: Call\u003cResponse\u003cMyData\u003e\u003e, response: Response\u003cMyData\u003e) { // Handle response } override fun onFailure(call: Call\u003cResponse\u003cMyData\u003e\u003e, t: Throwable) { // Handle failure }})Similarly, if you are using Retrofit with suspend functions, it ensures that network requests are automatically moved off the main thread:interface ApiService { @GET(\"endpoint\") suspend fun getData(): Response\u003cMyData\u003e}Calling this inside a coroutine will suspend execution without blocking the main thread:lifecycleScope.launch { val result = api.getData() // Suspends but does not block the UI thread handleResult(result)}Since coroutines suspend execution rather than blocking, the main thread remains responsive, and the app does not crash.Similarly, if you are using Ktor Client, it also provides automatic threading management, but its behavior depends on the chosen engine:val client = HttpClient(CIO) // Uses non-blocking I/Oval response: HttpResponse = client.get(\"https://api.example.com/data\")Using Ktor with CIO or OkHttp engines ensures that requests are executed off the main thread by default. However, if you use blocking calls such as runBlocking, you may inadvertently block the main thread and crash your app.2.2 How Ktor Can Crash Your App???While Ktor is designed to be non-blocking, improper usage can still lead to crashes. A common mistake is using runBlocking on the main thread while performing network operations. This forces the coroutine to block execution instead of suspending it properly.Example:fun fetchData() { runBlocking { val response: HttpResponse = client.get(\"https://api.example.com/data\") println(response.bodyAsText()) }}If fetchData() is called from the main thread, it blocks the UI, leading to potential ANRs and app freezes. Instead, the correct approach is to use launch or async inside a coroutine scope:fun fetchData() { CoroutineScope(Dispatchers.IO).launch { val response: HttpResponse = client.get(\"https://api.example.com/data\") println(response.bodyAsText()) }}This ensures that the network request runs on a background thread and does not interfere with the main thread.3. The Right Way: Always Use Dispatchers.IOEven if your app does not crash, relying on implicit behavior is risky. The safest approach is to explicitly switch to Dispatchers.IO when making network requests:val result = withContext(Dispatchers.IO) { api.getData()}This ensures that:The request runs on an optimized background thread.The main thread remains responsive.ANR issues on slow networks are avoided.4. Key TakeawaysSynchronous OkHttp calls (.execute()) on the main thread will block and may cause ANRs.Asynchronous OkHttp calls (.enqueue()) are handled on a background thread automatically.Retrofit with suspend functions ensures execution happens off the main thread.Ktor with appropriate engines like CIO ensures network operations are non-blocking.Improper use of runBlocking in Ktor can still block the main thread and crash your app.Coroutines suspend execution rather than blocking, keeping the UI thread responsive.Android 4.0 and later do not immediately throw a NetworkOnMainThreadException, but an ANR error can still occur if a network request takes too long.Relying on implicit behavior is risky, and best practice is to always use Dispatchers.IO explicitly.Even if your app appears to function correctly without Dispatchers.IO, it is not guaranteed to behave predictably in all situations. The best approach is to ensure that all networking operations run on an I/O-optimized thread.Have you observed this behavior in your projects? Share your thoughts in the comments below.Dobri KostadinovAndroid Consultant | TrainerEmail me | Follow me on LinkedIn | Follow me on Medium | Buy me a coffee",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*LN6avXgOWircQU6VWFawZg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"4b78\"\u003e\u003cstrong\u003eUnderstanding Why Your App Does Not Crash Despite Running Network Requests on the Main Thread and Why Following Best Practices is Essential\u003c/strong\u003e\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@dobri.kostadinov?source=post_page---byline--a7429bccdff8---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Dobri Kostadinov\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*PDWUz7RmoqP9kmFnZzGPUg.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--a7429bccdff8---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"c905\"\u003e\u003cstrong\u003eIntroduction\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"3b8f\"\u003eAs an Android developer, you have probably heard many times that network calls should never be executed on the main thread. However, you may have noticed that your app does not crash even when network logic runs on the main thread without explicitly switching to \u003ccode\u003eDispatchers.IO\u003c/code\u003e. What is happening? Has something changed? Let’s explore the details.\u003c/p\u003e\u003ch2 id=\"aa27\"\u003e1. The Traditional Rule: Never Block the Main Thread\u003c/h2\u003e\u003cp id=\"efa7\"\u003eFor years, Android developers have followed this rule: network operations should not run on the main thread because:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3ca3\"\u003eThe main thread is responsible for rendering the UI and handling user interactions.\u003c/li\u003e\u003cli id=\"00e3\"\u003eIf a network request takes too long, it will freeze the UI and lead to an Application Not Responding (ANR) error.\u003c/li\u003e\u003cli id=\"9738\"\u003eIn Android versions before 4.0, executing a network call on the main thread would immediately crash the app with a \u003ccode\u003eNetworkOnMainThreadException\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"a910\"\u003e\u003cstrong\u003eIf your app is not crashing, there must be a reason!\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"5766\"\u003e2. Why Is Your App Not Crashing?\u003c/h2\u003e\u003ch2 id=\"b542\"\u003e2.1 OkHttp, Retrofit, and Ktor Do Not Always Handle Threading Automatically\u003c/h2\u003e\u003cp id=\"141a\"\u003eIf you are using \u003cstrong\u003eRetrofit with OkHttp and suspending functions\u003c/strong\u003e, OkHttp internally handles network requests on a background thread. However, this only applies when Retrofit uses coroutines or its default async execution model.\u003c/p\u003e\u003cp id=\"0297\"\u003eIf you make a \u003cstrong\u003esynchronous\u003c/strong\u003e network request using OkHttp’s \u003ccode\u003e.execute()\u003c/code\u003e method directly on the main thread, it will block and may cause an ANR.\u003c/p\u003e\u003cp id=\"ebb7\"\u003eExample:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"832c\"\u003eval response = api.getData().execute() // This will block the main thread\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5cb2\"\u003eHowever, if you use OkHttp’s \u003cstrong\u003easynchronous\u003c/strong\u003e \u003ccode\u003e.enqueue()\u003c/code\u003e method, it will run on an internal OkHttp-managed thread:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6134\"\u003eapi.getData().enqueue(object : Callback\u0026lt;Response\u0026lt;MyData\u0026gt;\u0026gt; {\u003cbr/\u003e    override fun onResponse(call: Call\u0026lt;Response\u0026lt;MyData\u0026gt;\u0026gt;, response: Response\u0026lt;MyData\u0026gt;) {\u003cbr/\u003e        // Handle response\u003cbr/\u003e    }\u003cbr/\u003e    override fun onFailure(call: Call\u0026lt;Response\u0026lt;MyData\u0026gt;\u0026gt;, t: Throwable) {\u003cbr/\u003e        // Handle failure\u003cbr/\u003e    }\u003cbr/\u003e})\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ceb2\"\u003eSimilarly, if you are using \u003cstrong\u003eRetrofit with suspend functions\u003c/strong\u003e, it ensures that network requests are automatically moved off the main thread:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f644\"\u003einterface ApiService {\u003cbr/\u003e    @GET(\u0026#34;endpoint\u0026#34;)\u003cbr/\u003e    suspend fun getData(): Response\u0026lt;MyData\u0026gt;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6e07\"\u003eCalling this inside a coroutine will suspend execution without blocking the main thread:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8469\"\u003elifecycleScope.launch {\u003cbr/\u003e    val result = api.getData() // Suspends but does not block the UI thread\u003cbr/\u003e    handleResult(result)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"32c6\"\u003eSince coroutines suspend execution rather than blocking, the main thread remains responsive, and the app does not crash.\u003c/p\u003e\u003cp id=\"8578\"\u003eSimilarly, if you are using \u003cstrong\u003eKtor Client\u003c/strong\u003e, it also provides automatic threading management, but its behavior depends on the chosen \u003ccode\u003eengine\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"90e4\"\u003eval client = HttpClient(CIO) // Uses non-blocking I/O\u003cbr/\u003eval response: HttpResponse = client.get(\u0026#34;https://api.example.com/data\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2613\"\u003eUsing Ktor with \u003ccode\u003eCIO\u003c/code\u003e or \u003ccode\u003eOkHttp\u003c/code\u003e engines ensures that requests are executed off the main thread by default. However, if you use blocking calls such as \u003ccode\u003erunBlocking\u003c/code\u003e, you may inadvertently block the main thread and crash your app.\u003c/p\u003e\u003ch2 id=\"47e5\"\u003e2.2 How Ktor Can Crash Your App???\u003c/h2\u003e\u003cp id=\"3d9b\"\u003eWhile Ktor is designed to be non-blocking, improper usage can still lead to crashes. A common mistake is using \u003ccode\u003erunBlocking\u003c/code\u003e on the main thread while performing network operations. This forces the coroutine to block execution instead of suspending it properly.\u003c/p\u003e\u003cp id=\"be57\"\u003eExample:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2009\"\u003efun fetchData() {\u003cbr/\u003e    runBlocking {\u003cbr/\u003e        val response: HttpResponse = client.get(\u0026#34;https://api.example.com/data\u0026#34;)\u003cbr/\u003e        println(response.bodyAsText())\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2730\"\u003eIf \u003ccode\u003efetchData()\u003c/code\u003e is called from the main thread, it \u003cstrong\u003eblocks\u003c/strong\u003e the UI, leading to potential ANRs and app freezes. Instead, the correct approach is to use \u003ccode\u003elaunch\u003c/code\u003e or \u003ccode\u003easync\u003c/code\u003e inside a coroutine scope:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"626f\"\u003efun fetchData() {\u003cbr/\u003e    CoroutineScope(Dispatchers.IO).launch {\u003cbr/\u003e        val response: HttpResponse = client.get(\u0026#34;https://api.example.com/data\u0026#34;)\u003cbr/\u003e        println(response.bodyAsText())\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a6b8\"\u003eThis ensures that the network request runs on a background thread and does not interfere with the main thread.\u003c/p\u003e\u003ch2 id=\"3ef6\"\u003e3. The Right Way: Always Use \u003ccode\u003eDispatchers.IO\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"3a84\"\u003eEven if your app does not crash, relying on implicit behavior is risky. The safest approach is to explicitly switch to \u003ccode\u003eDispatchers.IO\u003c/code\u003e when making network requests:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"da61\"\u003eval result = withContext(Dispatchers.IO) {\u003cbr/\u003e    api.getData()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6a14\"\u003eThis ensures that:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a790\"\u003eThe request runs on an optimized background thread.\u003c/li\u003e\u003cli id=\"2ef5\"\u003eThe main thread remains responsive.\u003c/li\u003e\u003cli id=\"71ff\"\u003eANR issues on slow networks are avoided.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"1679\"\u003e4. Key Takeaways\u003c/h2\u003e\u003cul\u003e\u003cli id=\"bda5\"\u003e\u003cstrong\u003eSynchronous OkHttp calls (\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003e.execute()\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e) on the main thread will block and may cause ANRs.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"2cb1\"\u003e\u003cstrong\u003eAsynchronous OkHttp calls (\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003e.enqueue()\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e) are handled on a background thread automatically.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"361c\"\u003e\u003cstrong\u003eRetrofit with suspend functions ensures execution happens off the main thread.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"d261\"\u003e\u003cstrong\u003eKtor with appropriate engines like \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eCIO\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e ensures network operations are non-blocking.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"377c\"\u003e\u003cstrong\u003eImproper use of \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003erunBlocking\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e in Ktor can still block the main thread and crash your app.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"7bba\"\u003e\u003cstrong\u003eCoroutines suspend execution rather than blocking, keeping the UI thread responsive.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"d47b\"\u003e\u003cstrong\u003eAndroid 4.0 and later do not immediately throw a \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eNetworkOnMainThreadException\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e, but an ANR error can still occur if a network request takes too long.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"b71b\"\u003e\u003cstrong\u003eRelying on implicit behavior is risky, and best practice is to always use \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eDispatchers.IO\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e explicitly.\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f9e4\"\u003eEven if your app appears to function correctly without \u003ccode\u003eDispatchers.IO\u003c/code\u003e, it is not guaranteed to behave predictably in all situations. The best approach is to ensure that all networking operations run on an I/O-optimized thread.\u003c/p\u003e\u003cp id=\"7b81\"\u003eHave you observed this behavior in your projects? Share your thoughts in the comments below.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"1f46\"\u003e\u003cem\u003eDobri Kostadinov\u003c/em\u003e\u003cbr/\u003eAndroid Consultant | Trainer\u003cbr/\u003e\u003ca href=\"mailto:dobri.kostadinov@gmail.com\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEmail me\u003c/a\u003e | \u003ca href=\"https://www.linkedin.com/in/dobrikostadinov/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFollow me on LinkedIn\u003c/a\u003e | \u003ca href=\"https://medium.com/@dobri.kostadinov\" rel=\"noopener\"\u003eFollow me on Medium\u003c/a\u003e | \u003ca href=\"https://www.buymeacoffee.com/dobri.kostadinov\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBuy me a coffee\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-02-14T17:33:56.871Z",
  "modifiedTime": null
}
