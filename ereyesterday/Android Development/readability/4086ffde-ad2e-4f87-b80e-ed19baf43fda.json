{
  "id": "4086ffde-ad2e-4f87-b80e-ed19baf43fda",
  "title": "A Developer’s Roadmap to Mastering Kotlin Multiplatform",
  "link": "https://proandroiddev.com/a-developers-roadmap-to-mastering-kotlin-multiplatform-e4e03aef765f?source=rss----c72404660798---4",
  "description": "",
  "author": "Jaewoong Eum",
  "published": "Sat, 16 Nov 2024 06:48:13 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "roadmaps",
    "android",
    "kmp",
    "kotlin",
    "multiplatform"
  ],
  "byline": "Jaewoong Eum",
  "length": 17168,
  "excerpt": "In modern mobile development, cross-platform frameworks are gaining popularity because they offer key advantages, such as reducing the resources needed to develop separate native apps and maintaining…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In modern mobile development, cross-platform frameworks are gaining popularity because they offer key advantages, such as reducing the resources needed to develop separate native apps and maintaining code consistency across different platforms.By allowing developers to write shareable code, these frameworks enable faster development and easier maintenance, making them attractive not only to startups and large companies but also to individual developers. With a single codebase, it’s possible to build multiple platform-specific apps, making cross-platform solutions highly efficient for both time and cost management.Kotlin Multiplatform (KMP) is another rising star in cross-platform development driven by the collaboration between JetBrains and Google. It allows developers to share business logic seamlessly across multiple platforms, including Android, iOS, Desktop, and Web, all while using Kotlin. Compared to other cross-platform solutions like React Native or Flutter, Kotlin Multiplatform offers performance that is closer to native, making it an attractive choice for developers seeking efficiency and native-like performance without sacrificing the benefits of cross-platform development.In this article, you’ll explore the Kotlin Multiplatform (KMP) ecosystem using the Kotlin Multiplatform Developer Roadmap as your guide. The roadmap is designed to offer a comprehensive overview of the current KMP ecosystem, which provides suggested learning paths to help you better understand the various concepts involved in KMP development.Kotlin Multiplatform ArchitectureKotlin Multiplatform doesn’t inherently provide a UI framework. Instead, it focuses on sharing business logic across multiple platforms while enabling developers to create platform-specific UIs for Android, iOS, and other targets. The core idea is to write common logic in Kotlin once and reuse it across platforms like Android, JVM, iOS, macOS, JavaScript, and Linux, while maintaining full control over each platform’s native UI. This approach provides flexibility, as demonstrated in the illustration below:Let’s jump into the architecture with some code exploration! Before setting up your first Kotlin Multiplatform (KMP) project, ensure the following prerequisites:Install the Kotlin Multiplatform Plugin in Android Studio.Launch Xcode at least once and accept the terms of use if you plan to build iOS apps.After meeting these requirements, open the Kotlin Multiplatform Wizard. This will generate a project structure similar to the one below, giving you a foundation for cross-platform development.After selecting Android, iOS, and Web, the Kotlin Multiplatform Wizard downloads a project pre-configured with a multiplatform architecture. You can then open the composeApp module’s build.gradle.kts file to view the platform setup. This file outlines each targeted platform’s configuration, dependencies, and shared code structure, helping you better understand the cross-platform architecture and how shared business logic integrates with platform-specific code below:In the code above, you can configure target platforms and create hierarchical structures by grouping similar platforms, like iosX64 and iosArm64. This setup allows you to share common code between similar platform targets, simplifying maintenance and reducing redundancy.You can set up the targets below to configure KMP project platform architecture:applyDefaultHierarchyTemplate(): Configures a default shared source set hierarchy, simplifying setup by establishing common dependencies and configurations across platform targets, like Android, iOS, and JVM. It enables code reuse by creating shared source sets with logical hierarchies.androidTarget(): Adds Android as a target platform, allowing the KMP project to compile Android-specific code. For library modules, publishLibraryVariants(\"release\") can be used to specify which build variants are published.iosX64(), iosArm64(), iosSimulatorArm64(): Configures targets for different iOS CPU architectures, supporting iOS on x64 (for simulator), arm64 (for devices), and Simulator Arm64. The baseName field can specify a framework name, like “ComposeApp,” for the output.macosX64(), macosArm64(): Targets for macOS, allowing the code to be compiled for macOS on both x64 (Intel) and Arm64 (Apple Silicon) architectures. This setup supports building shared code for macOS applications.jvm(): Compiles the shared code for the Java Virtual Machine (JVM), which is compatible with desktop and Android applications, providing easy integration with Java libraries and environments.wasmJs(): Configures the project to target WebAssembly with JavaScript interop, enabling shared Kotlin code to execute as WebAssembly (WASM) in a web environment. This is especially useful for creating performant web apps.linuxX64(), linuxArm64(): Targets for Linux on x64 and Arm64 architectures, allowing the shared code to run on Linux environments, which is helpful for server-side applications or embedded Linux devices.Each target broadens the reach of your KMP project by allowing the core business logic to run across different operating systems and architectures. This flexibility helps maximize code reuse while supporting the specifics of each platform’s native capabilities.If you’re ready to dive into building your first Android and iOS mobile applications with Kotlin Multiplatform, check out this guide: Build Your First Android and iOS Mobile App With Kotlin Multiplatform.Share CodeKotlin Multiplatform lets you define a common interface specification across multiple platforms, unifying the interface hierarchy while allowing platform-specific implementations. To achieve this, you can use expected and actual declarations, which enable access to platform-specific APIs from Kotlin Multiplatform modules. This approach allows you to maintain platform-agnostic APIs in the common code, simplifying cross-platform development.The expect keyword is used in the shared (common) code to declare a function, class, or property without defining its implementation. This acts as a placeholder, allowing you to specify the API that platform-specific modules will need to implement. For example, if you want to declare a shared function that logs across different platforms, you can declare a function called log like the code below:The actual keyword is used in platform-specific modules to provide the implementation of the expect declarations. For each platform (e.g., Android, iOS), you create the actual implementation of the expected functionality. For instance, if you want to provide the actual implementation for the expected log function, you can define it differently for each specific platform, as shown in the example below:Now, you can use the log function across the common module. This approach provides flexibility by allowing platform-specific code without altering the common code. Additionally, it enables you to maintain platform-independent logic in the common module, maximizing code reuse. For more information about the expect and actual declarations, check out Expected and actual declarations.Compose MultiplatformYou’ve discovered that Kotlin Multiplatform is designed to share business logic across platforms but doesn’t include any UI solutions by default. This can be confusing, as most cross-platform frameworks provide UI components or layers that enable building screens with a unified codebase across different platforms.A great solution for cross-platform UI in Kotlin Multiplatform is Compose Multiplatform, which builds on Kotlin Multiplatform and enables developers to share UI code written in Jetpack Compose across various platforms. JetBrains has forked the Jetpack Compose library (for Android) into the compose-multiplatform repository and created compatible Compose UI clients for multiple platforms, including iOS, Desktop, and WebAssembly (WASM).With Compose Multiplatform, you can develop both Android and iOS applications using a unified UI implementation while sharing business logic written in Kotlin. Currently, Android and Desktop (Windows, macOS, Linux) support is stable, iOS is in beta, and Web is in alpha. For more details on future plans, check out the Kotlin Multiplatform Development Roadmap for 2025.AndroidX Library CompatibilityIf you’re an Android developer, you might be wondering about the best ways to minimize migration costs from native Android to Kotlin Multiplatform, and that must be using the same tech stacks as much as possible, such as Jetpack libraries. The Android team is aware of this and has begun officially supporting KMP for several Jetpack libraries, as listed below:Lifecycle: Lifecycle-aware components that react to changes in the lifecycle state of other components.Room Database: A persistence library that provides an abstraction layer over SQLite, enabling robust database access with the full power of SQLite.DataStore: Enables asynchronous, consistent, and transactional data storage, addressing limitations of SharedPreferences.Paging: Facilitates gradual and efficient data loading.Annotation: Provides metadata to enhance code understanding for tools and developers.Collection: Optimizes memory usage for small collections.Jetpack library releases for Android and iOS meet strict quality and compatibility standards. As Jetpack expands its Kotlin Multiplatform (KMP) support to other platforms, however, tooling and infrastructure are still developing. Check out the sample project on GitHub for KMP-supported Jetpack libraries.According to the official documentation, Jetpack libraries categorize platform support into three tiers:Tier 1: Android, JVM, iOSTier 2: macOS, LinuxTier 3: watchOS, tvOS, Windows, WASMFor additional information on Kotlin Multiplatform support for Jetpack libraries, refer to the Kotlin Multiplatform Overview.AsynchronousAsynchronous solutions are essential in mobile development due to limited resources compared to desktops. Both Android and iOS use the main thread (or UI thread) to handle all UI-related tasks, such as rendering elements, dispatching events, and managing interactions within the user interface.For I/O or computationally intensive tasks like network requests or database queries, it’s best to offload them to a worker thread. This keeps the main thread free for rendering and user interactions, ensuring a responsive UI. In Kotlin, Coroutines provide a powerful asynchronous solution, supported at the language level and enhanced through libraries, making it ideal for efficient concurrency.Coroutines fully support Kotlin Multiplatform, allowing you to use them seamlessly across multiple platforms. They offer a lightweight concurrency solution with robust error-handling APIs, providing greater flexibility than traditional threads. This makes Coroutines one of the most promising asynchronous solutions for Kotlin Multiplatform development.If you’re an avid ReactiveX user, consider exploring Reaktive on GitHub, which brings ReactiveX extensions to Kotlin Multiplatform.NetworkOn Android, Retrofit and OkHttp are the go-to solutions for handling type-safe HTTP network requests, streaming, and more. However, they don’t support Kotlin Multiplatform. Instead, there is another excellent HTTP asynchronous library Ktor, designed for creating multiplatform microservices and HTTP clients. Ktor is lightweight, flexible, and fully compatible with Coroutines, making them ideal for Kotlin Multiplatform projects.Ktor is an asynchronous framework created by JetBrains for building applications and microservices in Kotlin. It supports both client-side and server-side development, making it versatile for building HTTP clients, REST APIs, web applications, and microservices across multiple platforms, including Android, JVM, JavaScript, and iOS. The key features of Ktor are:Asynchronous by Design: Built with coroutines in mind, Ktor is fully asynchronous, leveraging Kotlin’s coroutines to provide high concurrency with minimal overhead.Multiplatform Support: Ktor can be used in Kotlin Multiplatform projects, allowing you to write HTTP clients that work across different platforms (Android, iOS, JVM, etc.) with the same codebase.Extensible and Modular: Ktor is modular, allowing you to add only the features you need, such as authentication, serialization, WebSocket support, and more, by including individual dependencies.Flexible Routing: Ktor’s routing system is flexible, supporting path parameters, query parameters, and more. It enables organized API endpoints in server applications.Built-In Serialization: Ktor integrates with Kotlin’s serialization library, making it easy to handle JSON, XML, and other serialization formats.On the other hand, a solution called Ktorfit is built on top of Ktor. Ktorfit is an HTTP client and Kotlin Symbol Processor designed for Kotlin Multiplatform, inspired by Retrofit. It offers a similar interface-based approach to define HTTP request methods, making it familiar for those who have used Retrofit.Image LoadingLoading images from the network is essential in modern mobile development for displaying user profiles, thumbnails, and more. However, rendering UIs differs across platforms like Android and iOS, requiring a solution that supports both Kotlin Multiplatform for core functionality and Compose Multiplatform for UI integration.Building an image-loading system from scratch is costly, as it requires implementing numerous features, such as downloading images from the network, resizing, caching, rendering, and memory management. Fortunately, there are several image-loading solutions available that support Kotlin Multiplatform:Coil: As of version 3.0.x, Coil supports Kotlin Multiplatform, allowing you to seamlessly integrate it into projects that already use Coil.Landscapist: A highly optimized, pluggable image-loading library for Jetpack Compose and Kotlin Multiplatform that supports features like placeholders, shimmer effects, blurring, and animations to enhance the user experience.Kamel: An asynchronous media-loading and caching library designed for Kotlin Multiplatform and Compose.compose-imageloader: A lightweight image-loading library for Compose with Kotlin Multiplatform support.Consider which solution best aligns with your project’s requirements, and choose the one that fits your needs.Local StorageLocal storage is essential in modern Android development for caching information on devices to enhance user experience. Fortunately, several Jetpack libraries now support Kotlin Multiplatform — especially DataStore and Room Database, as mentioned above — making them ideal choices since they’re already familiar to many Android developers.Room Database: A persistence library offering a powerful abstraction layer over SQLite, enabling reliable and efficient database access.DataStore: Provides asynchronous, consistent, and transactional data storage, overcoming the limitations of SharedPreferences. DataStore is highly effective for persisting key-value based data, making it a lightweight alternative to managing and querying large datasets in a full-fledged database.Another excellent option outside of Jetpack libraries is SQLDelight, which generates type-safe Kotlin APIs from your SQL statements. It performs compile-time checks for your schema, statements, and migrations, and offers IDE features like autocomplete and refactoring, making SQL development and maintenance straightforward and efficient. It basically supports Kotlin Multiplatform.Serialization \u0026 Date-TimeIf you’ve been using Gson or Moshi for serialization/deserialization on Android, you may have concerns since they don’t support Kotlin Multiplatform. Fortunately, JetBrains has developed their own solutions for serialization and date-time handling in Kotlin Multiplatform, as shown below:kotlinx.serialization: A Kotlin serialization library with a compiler plugin that generates serialization code for classes, a core runtime library with serialization APIs, and support libraries for various formats.kotlinx-datetime: A Kotlin Multiplatform library for handling date and time, designed to address common challenges developers encounter when working with dates and times.ConclusionIn this article, you’ve explored Kotlin Multiplatform’s platform architecture, library ecosystem, and various solutions for Kotlin Multiplatform development. Kotlin Multiplatform shows great promise, with active support from JetBrains and Google, and a growing number of companies adopting it for production-level projects.While the Kotlin Multiplatform ecosystem is still in its early stages and has room to grow, its biggest advantage is that Android developers can easily dive in, as it’s entirely built in Kotlin. This familiarity makes it an accessible and appealing option for those interested in cross-platform development, allowing them to leverage their existing skills.If you have any questions or feedback on this article, you can find the author on Twitter @github_skydoves or GitHub if you have any questions or feedback. If you’d like to stay up to date with Stream, follow us on Twitter @getstream_io for more great technical content.As always, happy coding!— Jaewoong",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*D-ieHZMS5IWWRJUG",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://skydoves.medium.com/?source=post_page---byline--e4e03aef765f--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Jaewoong Eum\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*to22-X47VSP4tZeElwVKKA.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--e4e03aef765f--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"139f\"\u003eIn modern mobile development, cross-platform frameworks are gaining popularity because they offer key advantages, such as reducing the resources needed to develop separate native apps and maintaining code consistency across different platforms.\u003c/p\u003e\u003cp id=\"cf12\"\u003eBy allowing developers to write shareable code, these frameworks enable faster development and easier maintenance, making them attractive not only to startups and large companies but also to individual developers. With a single codebase, it’s possible to build multiple platform-specific apps, making cross-platform solutions highly efficient for both time and cost management.\u003c/p\u003e\u003cp id=\"580a\"\u003e\u003ca href=\"https://kotlinlang.org/docs/multiplatform.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Multiplatform (KMP)\u003c/a\u003e is another rising star in cross-platform development driven by the collaboration between \u003ca href=\"https://www.jetbrains.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetBrains\u003c/a\u003e and Google. It allows developers to share business logic seamlessly across multiple platforms, including Android, iOS, Desktop, and Web, all while using Kotlin. Compared to other cross-platform solutions like \u003ca href=\"https://reactnative.dev/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eReact Native\u003c/a\u003e or \u003ca href=\"https://flutter.dev/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFlutter\u003c/a\u003e, Kotlin Multiplatform offers performance that is closer to native, making it an attractive choice for developers seeking efficiency and native-like performance without sacrificing the benefits of cross-platform development.\u003c/p\u003e\u003cp id=\"a54e\"\u003eIn this article, you’ll explore the Kotlin Multiplatform (KMP) ecosystem using the \u003ca href=\"https://github.com/skydoves/kmp-developer-roadmap\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Multiplatform Developer Roadmap\u003c/a\u003e as your guide. The roadmap is designed to offer a comprehensive overview of the current KMP ecosystem, which provides suggested learning paths to help you better understand the various concepts involved in KMP development.\u003c/p\u003e\u003ch2 id=\"26ad\"\u003eKotlin Multiplatform Architecture\u003c/h2\u003e\u003cp id=\"b6a1\"\u003eKotlin Multiplatform doesn’t inherently provide a UI framework. Instead, it focuses on sharing business logic across multiple platforms while enabling developers to create platform-specific UIs for Android, iOS, and other targets. The core idea is to write common logic in Kotlin once and reuse it across platforms like Android, JVM, iOS, macOS, JavaScript, and Linux, while maintaining full control over each platform’s native UI. This approach provides flexibility, as demonstrated in the illustration below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"05de\"\u003eLet’s jump into the architecture with some code exploration! Before setting up your first Kotlin Multiplatform (KMP) project, ensure the following prerequisites:\u003c/p\u003e\u003cul\u003e\u003cli id=\"d633\"\u003eInstall the \u003ca href=\"https://plugins.jetbrains.com/plugin/14936-kotlin-multiplatform\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Multiplatform Plugin\u003c/a\u003e in Android Studio.\u003c/li\u003e\u003cli id=\"7666\"\u003eLaunch Xcode at least once and accept the terms of use if you plan to build iOS apps.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"a15f\"\u003eAfter meeting these requirements, open the \u003ca href=\"https://kmp.jetbrains.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Multiplatform Wizard\u003c/a\u003e. This will generate a project structure similar to the one below, giving you a foundation for cross-platform development.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ff05\"\u003eAfter selecting Android, iOS, and Web, the Kotlin Multiplatform Wizard downloads a project pre-configured with a multiplatform architecture. You can then open the \u003ccode\u003ecomposeApp\u003c/code\u003e module’s \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e file to view the platform setup. This file outlines each targeted platform’s configuration, dependencies, and shared code structure, helping you better understand the cross-platform architecture and how shared business logic integrates with platform-specific code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e889\"\u003eIn the code above, you can configure target platforms and create hierarchical structures by grouping similar platforms, like \u003ccode\u003eiosX64\u003c/code\u003e and \u003ccode\u003eiosArm64\u003c/code\u003e. This setup allows you to share common code between similar platform targets, simplifying maintenance and reducing redundancy.\u003c/p\u003e\u003cp id=\"4a10\"\u003eYou can set up the targets below to configure KMP project platform architecture:\u003c/p\u003e\u003cul\u003e\u003cli id=\"67b4\"\u003e\u003ccode\u003eapplyDefaultHierarchyTemplate()\u003c/code\u003e: Configures a default shared source set hierarchy, simplifying setup by establishing common dependencies and configurations across platform targets, like Android, iOS, and JVM. It enables code reuse by creating shared source sets with logical hierarchies.\u003c/li\u003e\u003cli id=\"5cea\"\u003e\u003ccode\u003eandroidTarget()\u003c/code\u003e: Adds Android as a target platform, allowing the KMP project to compile Android-specific code. For library modules, \u003ccode\u003epublishLibraryVariants(\u0026#34;release\u0026#34;)\u003c/code\u003e can be used to specify which build variants are published.\u003c/li\u003e\u003cli id=\"b1d1\"\u003e\u003ccode\u003eiosX64()\u003c/code\u003e, \u003ccode\u003eiosArm64()\u003c/code\u003e, \u003ccode\u003eiosSimulatorArm64()\u003c/code\u003e: Configures targets for different iOS CPU architectures, supporting iOS on x64 (for simulator), arm64 (for devices), and Simulator Arm64. The \u003ccode\u003ebaseName\u003c/code\u003e field can specify a framework name, like “ComposeApp,” for the output.\u003c/li\u003e\u003cli id=\"79b6\"\u003e\u003ccode\u003emacosX64()\u003c/code\u003e, \u003ccode\u003emacosArm64()\u003c/code\u003e: Targets for macOS, allowing the code to be compiled for macOS on both x64 (Intel) and Arm64 (Apple Silicon) architectures. This setup supports building shared code for macOS applications.\u003c/li\u003e\u003cli id=\"6462\"\u003e\u003ccode\u003ejvm()\u003c/code\u003e: Compiles the shared code for the Java Virtual Machine (JVM), which is compatible with desktop and Android applications, providing easy integration with Java libraries and environments.\u003c/li\u003e\u003cli id=\"e84e\"\u003e\u003ccode\u003ewasmJs()\u003c/code\u003e: Configures the project to target WebAssembly with JavaScript interop, enabling shared Kotlin code to execute as WebAssembly (WASM) in a web environment. This is especially useful for creating performant web apps.\u003c/li\u003e\u003cli id=\"43a7\"\u003e\u003ccode\u003elinuxX64()\u003c/code\u003e, \u003ccode\u003elinuxArm64()\u003c/code\u003e: Targets for Linux on x64 and Arm64 architectures, allowing the shared code to run on Linux environments, which is helpful for server-side applications or embedded Linux devices.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1216\"\u003eEach target broadens the reach of your KMP project by allowing the core business logic to run across different operating systems and architectures. This flexibility helps maximize code reuse while supporting the specifics of each platform’s native capabilities.\u003c/p\u003e\u003cp id=\"3c24\"\u003eIf you’re ready to dive into building your first Android and iOS mobile applications with Kotlin Multiplatform, check out this guide: \u003ca href=\"https://getstream.io/blog/build-app-kotlin-multiplatform/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBuild Your First Android and iOS Mobile App With Kotlin Multiplatform\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"2743\"\u003eShare Code\u003c/h2\u003e\u003cp id=\"8776\"\u003eKotlin Multiplatform lets you define a common interface specification across multiple platforms, unifying the interface hierarchy while allowing platform-specific implementations. To achieve this, you can use \u003ccode\u003eexpected\u003c/code\u003e and \u003ccode\u003eactual\u003c/code\u003e declarations, which enable access to platform-specific APIs from Kotlin Multiplatform modules. This approach allows you to maintain platform-agnostic APIs in the common code, simplifying cross-platform development.\u003c/p\u003e\u003cp id=\"4f1c\"\u003eThe \u003ccode\u003eexpect\u003c/code\u003e keyword is used in the shared (common) code to declare a function, class, or property without defining its implementation. This acts as a placeholder, allowing you to specify the API that platform-specific modules will need to implement. For example, if you want to declare a shared function that logs across different platforms, you can declare a function called \u003ccode\u003elog\u003c/code\u003e like the code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"75c3\"\u003eThe \u003ccode\u003eactual\u003c/code\u003e keyword is used in platform-specific modules to provide the implementation of the \u003ccode\u003eexpect\u003c/code\u003e declarations. For each platform (e.g., Android, iOS), you create the \u003ccode\u003eactual\u003c/code\u003e implementation of the expected functionality. For instance, if you want to provide the actual implementation for the expected \u003ccode\u003elog\u003c/code\u003e function, you can define it differently for each specific platform, as shown in the example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f3e5\"\u003eNow, you can use the \u003ccode\u003elog\u003c/code\u003e function across the common module. This approach provides flexibility by allowing platform-specific code without altering the common code. Additionally, it enables you to maintain platform-independent logic in the common module, maximizing code reuse. For more information about the \u003ccode\u003eexpect\u003c/code\u003e and \u003ccode\u003eactual\u003c/code\u003e declarations, check out \u003ca href=\"https://kotlinlang.org/docs/multiplatform-expect-actual.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eExpected and actual declarations\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"51c4\"\u003eCompose Multiplatform\u003c/h2\u003e\u003cp id=\"fb7c\"\u003eYou’ve discovered that Kotlin Multiplatform is designed to share business logic across platforms but doesn’t include any UI solutions by default. This can be confusing, as most cross-platform frameworks provide UI components or layers that enable building screens with a unified codebase across different platforms.\u003c/p\u003e\u003cp id=\"7e41\"\u003eA great solution for cross-platform UI in Kotlin Multiplatform is \u003ca href=\"https://www.jetbrains.com/compose-multiplatform/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCompose Multiplatform\u003c/a\u003e, which builds on Kotlin Multiplatform and enables developers to share UI code written in \u003ca href=\"https://developer.android.com/compose\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetpack Compose\u003c/a\u003e across various platforms. JetBrains has forked the Jetpack Compose library (for Android) into the \u003ca href=\"https://github.com/JetBrains/compose-multiplatform\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecompose-multiplatform\u003c/a\u003e repository and created compatible Compose UI clients for multiple platforms, including iOS, Desktop, and WebAssembly (WASM).\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e8c2\"\u003eWith Compose Multiplatform, you can develop both Android and iOS applications using a unified UI implementation while sharing business logic written in Kotlin. Currently, Android and Desktop (Windows, macOS, Linux) support is stable, iOS is in beta, and Web is in alpha. For more details on future plans, check out the \u003ca href=\"https://blog.jetbrains.com/kotlin/2024/10/kotlin-multiplatform-development-roadmap-for-2025/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Multiplatform Development Roadmap for 2025\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"badb\"\u003eAndroidX Library Compatibility\u003c/h2\u003e\u003cp id=\"db3f\"\u003eIf you’re an Android developer, you might be wondering about the best ways to minimize migration costs from native Android to Kotlin Multiplatform, and that must be using the same tech stacks as much as possible, such as Jetpack libraries. The Android team is aware of this and has begun officially supporting KMP for several Jetpack libraries, as listed below:\u003c/p\u003e\u003cul\u003e\u003cli id=\"5ebf\"\u003e\u003ca href=\"https://developer.android.com/jetpack/androidx/releases/lifecycle\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLifecycle\u003c/a\u003e: Lifecycle-aware components that react to changes in the lifecycle state of other components.\u003c/li\u003e\u003cli id=\"55a1\"\u003e\u003ca href=\"https://developer.android.com/jetpack/androidx/releases/room\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRoom Database\u003c/a\u003e: A persistence library that provides an abstraction layer over SQLite, enabling robust database access with the full power of SQLite.\u003c/li\u003e\u003cli id=\"4d2b\"\u003e\u003ca href=\"https://developer.android.com/jetpack/androidx/releases/datastore\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDataStore\u003c/a\u003e: Enables asynchronous, consistent, and transactional data storage, addressing limitations of SharedPreferences.\u003c/li\u003e\u003cli id=\"1ecc\"\u003e\u003ca href=\"https://developer.android.com/jetpack/androidx/releases/paging\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePaging\u003c/a\u003e: Facilitates gradual and efficient data loading.\u003c/li\u003e\u003cli id=\"077b\"\u003e\u003ca href=\"https://developer.android.com/jetpack/androidx/releases/annotation\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAnnotation\u003c/a\u003e: Provides metadata to enhance code understanding for tools and developers.\u003c/li\u003e\u003cli id=\"3b89\"\u003e\u003ca href=\"https://developer.android.com/jetpack/androidx/releases/collection\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCollection\u003c/a\u003e: Optimizes memory usage for small collections.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"626e\"\u003eJetpack library releases for Android and iOS meet strict quality and compatibility standards. As Jetpack expands its Kotlin Multiplatform (KMP) support to other platforms, however, tooling and infrastructure are still developing. Check out the \u003ca href=\"https://github.com/android/kotlin-multiplatform-samples\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esample project on GitHub\u003c/a\u003e for KMP-supported Jetpack libraries.\u003c/p\u003e\u003cp id=\"9fd9\"\u003eAccording to the \u003ca href=\"https://developer.android.com/kotlin/multiplatform#supported-platforms\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eofficial documentation\u003c/a\u003e, Jetpack libraries categorize platform support into three tiers:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e999\"\u003eTier 1: Android, JVM, iOS\u003c/li\u003e\u003cli id=\"da89\"\u003eTier 2: macOS, Linux\u003c/li\u003e\u003cli id=\"ed25\"\u003eTier 3: watchOS, tvOS, Windows, WASM\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6f3e\"\u003eFor additional information on Kotlin Multiplatform support for Jetpack libraries, refer to the \u003ca href=\"https://developer.android.com/kotlin/multiplatform\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Multiplatform Overview\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"ca07\"\u003eAsynchronous\u003c/h2\u003e\u003cp id=\"b535\"\u003eAsynchronous solutions are essential in mobile development due to limited resources compared to desktops. Both Android and iOS use the main thread (or UI thread) to handle all UI-related tasks, such as rendering elements, dispatching events, and managing interactions within the user interface.\u003c/p\u003e\u003cp id=\"a922\"\u003eFor I/O or computationally intensive tasks like network requests or database queries, it’s best to offload them to a worker thread. This keeps the main thread free for rendering and user interactions, ensuring a responsive UI. In Kotlin, \u003ca href=\"https://kotlinlang.org/docs/coroutines-overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoroutines\u003c/a\u003e provide a powerful asynchronous solution, supported at the language level and enhanced through libraries, making it ideal for efficient concurrency.\u003c/p\u003e\u003cp id=\"3b45\"\u003eCoroutines fully support Kotlin Multiplatform, allowing you to use them seamlessly across multiple platforms. They offer a lightweight concurrency solution with robust error-handling APIs, providing greater flexibility than traditional threads. This makes Coroutines one of the most promising asynchronous solutions for Kotlin Multiplatform development.\u003c/p\u003e\u003cp id=\"dfd6\"\u003eIf you’re an avid \u003ca href=\"https://reactivex.io/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eReactiveX\u003c/a\u003e user, consider exploring \u003ca href=\"https://github.com/badoo/Reaktive\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eReaktive on GitHub\u003c/a\u003e, which brings ReactiveX extensions to Kotlin Multiplatform.\u003c/p\u003e\u003ch2 id=\"e371\"\u003eNetwork\u003c/h2\u003e\u003cp id=\"faaf\"\u003eOn Android, Retrofit and OkHttp are the go-to solutions for handling type-safe HTTP network requests, streaming, and more. However, they don’t support Kotlin Multiplatform. Instead, there is another excellent HTTP asynchronous library \u003ca href=\"https://ktor.io/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKtor\u003c/a\u003e, designed for creating multiplatform microservices and HTTP clients. Ktor is lightweight, flexible, and fully compatible with Coroutines, making them ideal for Kotlin Multiplatform projects.\u003c/p\u003e\u003cp id=\"9365\"\u003eKtor is an asynchronous framework created by JetBrains for building applications and microservices in Kotlin. It supports both client-side and server-side development, making it versatile for building HTTP clients, REST APIs, web applications, and microservices across multiple platforms, including Android, JVM, JavaScript, and iOS. The key features of Ktor are:\u003c/p\u003e\u003col\u003e\u003cli id=\"2971\"\u003eAsynchronous by Design: Built with coroutines in mind, Ktor is fully asynchronous, leveraging Kotlin’s coroutines to provide high concurrency with minimal overhead.\u003c/li\u003e\u003cli id=\"614a\"\u003eMultiplatform Support: Ktor can be used in Kotlin Multiplatform projects, allowing you to write HTTP clients that work across different platforms (Android, iOS, JVM, etc.) with the same codebase.\u003c/li\u003e\u003cli id=\"8d20\"\u003eExtensible and Modular: Ktor is modular, allowing you to add only the features you need, such as authentication, serialization, WebSocket support, and more, by including individual dependencies.\u003c/li\u003e\u003cli id=\"f988\"\u003eFlexible Routing: Ktor’s routing system is flexible, supporting path parameters, query parameters, and more. It enables organized API endpoints in server applications.\u003c/li\u003e\u003cli id=\"e32d\"\u003eBuilt-In Serialization: Ktor integrates with Kotlin’s serialization library, making it easy to handle JSON, XML, and other serialization formats.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"a9d6\"\u003eOn the other hand, a solution called \u003ca href=\"https://github.com/Foso/Ktorfit\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKtorfit\u003c/a\u003e is built on top of Ktor. Ktorfit is an HTTP client and Kotlin Symbol Processor designed for Kotlin Multiplatform, inspired by Retrofit. It offers a similar interface-based approach to define HTTP request methods, making it familiar for those who have used Retrofit.\u003c/p\u003e\u003ch2 id=\"7b13\"\u003eImage Loading\u003c/h2\u003e\u003cp id=\"46dc\"\u003eLoading images from the network is essential in modern mobile development for displaying user profiles, thumbnails, and more. However, rendering UIs differs across platforms like Android and iOS, requiring a solution that supports both Kotlin Multiplatform for core functionality and Compose Multiplatform for UI integration.\u003c/p\u003e\u003cp id=\"4ff1\"\u003eBuilding an image-loading system from scratch is costly, as it requires implementing numerous features, such as downloading images from the network, resizing, caching, rendering, and memory management. Fortunately, there are several image-loading solutions available that support Kotlin Multiplatform:\u003c/p\u003e\u003cul\u003e\u003cli id=\"8d99\"\u003e\u003ca href=\"https://github.com/coil-kt/coil\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoil\u003c/a\u003e: As of version 3.0.x, Coil supports Kotlin Multiplatform, allowing you to seamlessly integrate it into projects that already use Coil.\u003c/li\u003e\u003cli id=\"b703\"\u003e\u003ca href=\"https://github.com/skydoves/landscapist\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLandscapist\u003c/a\u003e: A highly optimized, pluggable image-loading library for Jetpack Compose and Kotlin Multiplatform that supports features like placeholders, shimmer effects, blurring, and animations to enhance the user experience.\u003c/li\u003e\u003cli id=\"a80d\"\u003e\u003ca href=\"https://github.com/Kamel-Media/Kamel\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKamel\u003c/a\u003e: An asynchronous media-loading and caching library designed for Kotlin Multiplatform and Compose.\u003c/li\u003e\u003cli id=\"b621\"\u003e\u003ca href=\"https://github.com/qdsfdhvh/compose-imageloader\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecompose-imageloader\u003c/a\u003e: A lightweight image-loading library for Compose with Kotlin Multiplatform support.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ded4\"\u003eConsider which solution best aligns with your project’s requirements, and choose the one that fits your needs.\u003c/p\u003e\u003ch2 id=\"3dd7\"\u003eLocal Storage\u003c/h2\u003e\u003cp id=\"7b39\"\u003eLocal storage is essential in modern Android development for caching information on devices to enhance user experience. Fortunately, several Jetpack libraries now support Kotlin Multiplatform — especially DataStore and Room Database, as mentioned above — making them ideal choices since they’re already familiar to many Android developers.\u003c/p\u003e\u003cul\u003e\u003cli id=\"f920\"\u003e\u003ca href=\"https://developer.android.com/jetpack/androidx/releases/room\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRoom Database\u003c/a\u003e: A persistence library offering a powerful abstraction layer over SQLite, enabling reliable and efficient database access.\u003c/li\u003e\u003cli id=\"8eb4\"\u003e\u003ca href=\"https://developer.android.com/jetpack/androidx/releases/datastore\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDataStore\u003c/a\u003e: Provides asynchronous, consistent, and transactional data storage, overcoming the limitations of SharedPreferences. DataStore is highly effective for persisting key-value based data, making it a lightweight alternative to managing and querying large datasets in a full-fledged database.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"dbf8\"\u003eAnother excellent option outside of Jetpack libraries is \u003ca href=\"https://github.com/sqldelight/sqldelight\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSQLDelight\u003c/a\u003e, which generates type-safe Kotlin APIs from your SQL statements. It performs compile-time checks for your schema, statements, and migrations, and offers IDE features like autocomplete and refactoring, making SQL development and maintenance straightforward and efficient. It basically supports Kotlin Multiplatform.\u003c/p\u003e\u003ch2 id=\"6ad1\"\u003eSerialization \u0026amp; Date-Time\u003c/h2\u003e\u003cp id=\"892c\"\u003eIf you’ve been using \u003ca href=\"https://github.com/google/gson\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGson\u003c/a\u003e or \u003ca href=\"https://github.com/square/moshi\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMoshi\u003c/a\u003e for serialization/deserialization on Android, you may have concerns since they don’t support Kotlin Multiplatform. Fortunately, JetBrains has developed their own solutions for serialization and date-time handling in Kotlin Multiplatform, as shown below:\u003c/p\u003e\u003cul\u003e\u003cli id=\"443f\"\u003e\u003ca href=\"https://github.com/Kotlin/kotlinx.serialization\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlinx.serialization\u003c/a\u003e: A Kotlin serialization library with a compiler plugin that generates serialization code for classes, a core runtime library with serialization APIs, and support libraries for various formats.\u003c/li\u003e\u003cli id=\"727e\"\u003e\u003ca href=\"https://github.com/Kotlin/kotlinx-datetime\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlinx-datetime\u003c/a\u003e: A Kotlin Multiplatform library for handling date and time, designed to address common challenges developers encounter when working with dates and times.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"802a\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"8a9b\"\u003eIn this article, you’ve explored Kotlin Multiplatform’s platform architecture, library ecosystem, and various solutions for Kotlin Multiplatform development. Kotlin Multiplatform shows great promise, with active support from JetBrains and Google, and a growing number of companies adopting it for production-level projects.\u003c/p\u003e\u003cp id=\"482b\"\u003eWhile the Kotlin Multiplatform ecosystem is still in its early stages and has room to grow, its biggest advantage is that Android developers can easily dive in, as it’s entirely built in Kotlin. This familiarity makes it an accessible and appealing option for those interested in cross-platform development, allowing them to leverage their existing skills.\u003c/p\u003e\u003cp id=\"bcff\"\u003eIf you have any questions or feedback on this article, you can find the author on Twitter \u003ca href=\"https://twitter.com/github_skydoves\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@github_skydoves\u003c/a\u003e or \u003ca href=\"https://github.com/skydoves\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub\u003c/a\u003e if you have any questions or feedback. If you’d like to stay up to date with Stream, follow us on Twitter \u003ca href=\"https://twitter.com/getstream_io\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@getstream_io\u003c/a\u003e for more great technical content.\u003c/p\u003e\u003cp id=\"8cf8\"\u003eAs always, happy coding!\u003c/p\u003e\u003cp id=\"eea4\"\u003e— \u003ca href=\"https://github.com/skydoves\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJaewoong\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": "2024-11-15T15:10:31.866Z",
  "modifiedTime": null
}
