{
  "id": "d1a3866d-21aa-4102-b59e-3f83b625446e",
  "title": "Composition Locals in Jetpack Compose: A Beginner-to-Advanced Guide",
  "link": "https://proandroiddev.com/composition-locals-in-jetpack-compose-a-beginner-to-advanced-guide-e6a812ca7620?source=rss----c72404660798---4",
  "description": "",
  "author": "Ioannis Anifantakis",
  "published": "Mon, 13 Jan 2025 02:30:09 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "androiddev",
    "jetpack-compose",
    "android-app-development",
    "kotlin",
    "mobile-app-development"
  ],
  "byline": "Ioannis Anifantakis",
  "length": 18177,
  "excerpt": "Did you ever need to pass irrelevant parameters through multiple composable functions just to forward a parameter down the composable tree somewhere? ComposableLocals help with that",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Did you ever need to pass irrelevant parameters through multiple composable functions just to forward a parameter down the composable tree somewhere?That’s exactly the problem Composition Locals solve! In this article, we’ll discover what Composition Locals are, why they’re so useful, and how to create your own.What Are Composition Locals?Composition Locals are like invisible messengers in Jetpack Compose. They allow any child composable — no matter how deeply nested — to read values provided higher up the composition tree. If you’ve used React Native, they’re similar to the Context API, which solves the “prop drilling” problem (passing props through components that don’t directly need them).Example: Instead of passing a theme object to every composable, you can provide it once and have child composables fetch it as needed.The Problem They SolveHere’s a typical example without Composition Locals:@Composablefun MyApp(theme: Theme) { MainScreen(theme = theme)}@Composablefun MainScreen(theme: Theme) { Column { Header(theme = theme) Content(theme = theme) }}@Composablefun Header(theme: Theme) { // Use theme}@Composablefun Content(theme: Theme) { // Use theme}Every composable has a theme parameter, even if it doesn’t use it. This leads to “parameter pollution” and makes the code harder to maintain.Why Are Composition Locals Important?Reduced BoilerplateProvide data once at a higher level, consume it wherever necessary.Better EncapsulationIntermediate composables don’t need to manage data they don’t directly use.Easier TestingYou can override Composition Locals in tests without changing public APIs.Scoped ValuesData is only available to composables within the specific composition scope.What Composition Locals Are (and Aren’t)Due to a comment in LinkedIn about this post, let me make something clear…CompositionLocals shine when you’re dealing with cross-cutting UI stuff like theming or spacing. That’s where they save you from passing the same parameters through every composable.But for actual app logic its better to avoid using them.Are For:Design system tokens (themes, spacing, typography)UI infrastructure (keyboard controller, focus management)Cross-cutting UI concerns that follow the visual hierarchyValues that need different overrides at different levels of your UI treeAren’t For:Business logic or application stateData that should be managed by state management solutionsValues that affect application behavior — Database connections, repositories, or other non-UI dependenciesAvoiding proper dependency injectionThink of Composition Locals as part of your UI toolkit, not as a general dependency injection mechanism. They shine when dealing with UI-related values that naturally follow your component hierarchy, but shouldn’t be used to bypass proper architecture patterns or hide important dependencies.A good rule of thumb:- if it’s about how things look or interact at the UI level, a CompositionLocal might be appropriate.- If it’s about what your app does, use proper state management or dependency injection instead.Creating and Using Composition Locals1. Declare a Composition Local// For dynamic values that change frequentlyval LocalTheme = compositionLocalOf\u003cTheme\u003e { error(\"No theme provided!\") }// For values that rarely or never change at runtimeval LocalTheme = staticCompositionLocalOf { Theme.Light }staticCompositionLocalOf: For values that never or rarely change during runtime (like design tokens—typography, spacing, etc.). This doesn’t automatically trigger recompositions if the value changes, making it more efficient.compositionLocalOf: For dynamic values that change frequently (like a theme toggled by the user). When the provided value updates, any composable consuming it will automatically recompose.2. Provide a Value@Composablefun MyApp() { val theme = Theme.Dark CompositionLocalProvider(LocalTheme provides theme) { MainScreen() }}3. Consume the Value@Composablefun MyComponent() { val theme = LocalTheme.current // Use theme}Comparing to React Native’s Context APIIf you’re familiar with React Native’s Context API, Composition Locals feel very similar:Jetpack Compose Example:val LocalTheme = compositionLocalOf { Theme.Light }@Composablefun App() { CompositionLocalProvider(LocalTheme provides Theme.Dark) { ScreenA() }}@Composablefun Header() { val theme = LocalTheme.current Text( text = \"Title\", color = if (theme == Theme.Dark) Color.White else Color.Black )}React Native Example:// Create contextconst ThemeContext = React.createContext(Theme.Light);function App() { return ( \u003cThemeContext.Provider value={Theme.Dark}\u003e \u003cMainScreen /\u003e \u003c/ThemeContext.Provider\u003e );}function Header() { const theme = React.useContext(ThemeContext); return \u003ch1 style={{ color: theme === Theme.Dark ? \"#fff\" : \"#000\" }}\u003eTitle\u003c/h1\u003e;}Both approaches solve prop drilling, allow subtree overrides, and supply default values — but differ in syntax and recomposition mechanics.Understanding Scope: Not Global by DefaultA crucial point: Composition Locals are not automatically global! They’re scoped to wherever you provide them:@Composablefun App() { // LocalTheme is Dark only in ScreenA's hierarchy CompositionLocalProvider(LocalTheme provides Theme.Dark) { ScreenA() } // ScreenB uses default or throws an error if no default is set ScreenB() // LocalTheme is Light only in ScreenC's hierarchy CompositionLocalProvider(LocalTheme provides Theme.Light) { ScreenC() }}You can override values deeper down:@Composablefun ScreenA() { // Using Dark theme from parent Header() CompositionLocalProvider(LocalTheme provides Theme.Light) { // Overrides Dark theme SpecialSection() } // Back to Dark Footer()}Making Them “Global”f you want values available throughout your entire app, provide them at the top level:@Composablefun MyApp() { CompositionLocalProvider( LocalTheme provides appTheme, LocalSpacing provides appSpacing ) { AppContent() }}That said, truly global state (like user profiles, auth tokens, or server data) often belongs in a dedicated state management solution (e.g., ViewModel, Hilt, Redux, etc.).Real-World Example: Spacing SystemLet’s say we want a custom spacing system:// 1. Define a spacing data classdata class Spacing(val small: Dp = 4.dp, val medium: Dp = 8.dp, val large: Dp = 16.dp)// 2. Create a CompositionLocalval LocalSpacing = compositionLocalOf { Spacing() }// 3. Provide custom spacing for a specific screen@Composablefun SpecialScreen() { CompositionLocalProvider(LocalSpacing provides Spacing(8.dp, 16.dp, 24.dp)) { CustomCard(\"Hello\", \"This card uses custom spacing\") }}// 4. Consume it@Composablefun CustomCard(title: String, content: String) { val spacing = LocalSpacing.current Card(modifier = Modifier.padding(spacing.medium)) { Column(modifier = Modifier.padding(spacing.medium)) { Text(title, modifier = Modifier.padding(bottom = spacing.small)) Text(content) } }}@Preview ComposablesAn important gotcha: @Preview composables are completely isolated from your app’s composition tree. This means they can’t access any CompositionLocals that you’ve provided elsewhere in your app, even at the root level!// In your app@Composablefun MyApp() { CompositionLocalProvider(LocalTheme provides Theme.Dark) { AppContent() // All children here can access LocalTheme }}// In your preview - THIS WON'T WORK!@Preview@Composablefun SomeComponentPreview() { MyComponent() // CRASH! No access to LocalTheme}Instead, you need to provide all necessary CompositionLocals again in your preview:@Preview@Composablefun SomeComponentPreview() { CompositionLocalProvider(LocalTheme provides Theme.Dark) { MyComponent() // Now it works! }}To avoid repeating this setup in every preview, create a preview wrapper:@Composableprivate fun PreviewWrapper( content: @Composable () -\u003e Unit) { CompositionLocalProvider( LocalTheme provides Theme.Light, LocalSpacing provides Spacing(), LocalContentColor provides Color.Black, // Add other necessary CompositionLocals ) { Surface { // Optional: provide a surface for proper theming content() } }}// Now you can easily create previews@Preview@Composablefun ComponentPreview() { PreviewWrapper { MyComponent() }}This approach:Makes previews more maintainableEnsures consistency across previewsReduces boilerplateMakes it easy to add preview variantsUnderstanding Thread Usage with CompositionLocalsThe .current property is synchronized with Compose's composition systemYou can’t accidentally access CompositionLocals from background threads because they’re only available in @Composable functions// This is safe - always runs on the main thread during composition@Composablefun SafeComponent() { val theme = LocalTheme.current // Thread-safe access}// This would crash - trying to access outside compositionCoroutineScope(Dispatchers.IO).launch { val theme = LocalTheme.current // CRASH: Wrong thread and not in composition}2. Value UpdatesChanges to CompositionLocal values are always synchronized with recompositionUpdates are atomic — you’ll never get partial or inconsistent valuesAll readers see the same value at the same point in the composition@Composablefun ThemeProvider(theme: Theme) { // Thread-safe: Updates are synchronized with composition CompositionLocalProvider(LocalTheme provides theme) { Content() }}3. Background Thread ConsiderationsIf you need to use CompositionLocal values in background work:@Composablefun BackgroundWorker() { val theme = LocalTheme.current // Safely capture during composition LaunchedEffect(theme) { withContext(Dispatchers.IO) { // Safe: using captured value, not accessing .current processTheme(theme) } }}Usage RulesWhat is .current?The .current property is how you actually read a value from a CompositionLocal. Think of it as the \"getter\" that retrieves the most recently provided value in the composition tree above your composable.// Defining a CompositionLocalval LocalTheme = compositionLocalOf\u003cTheme\u003e { Theme.Light }@Composablefun MyComponent() { // Using .current to read the value val theme = LocalTheme.current // This gets the closest provided Theme value Text( text = \"Hello\", color = theme.textColor // Using the retrieved theme )}Built-in CompositionLocalsJetpack Compose already comes with many useful Composition Locals. For instance:LocalContext: Fetches the Android Context inside a composable.LocalSoftwareKeyboardController: Helps you control the software keyboard (show/hide).LocalFocusManager: Manages focus state across composables.These are excellent examples of how Composition Locals make it easy to access shared resources without needing to pass them around everywhere.Let’s see how to use .current with some built-in CompositionLocals:@Composablefun ExampleWithBuiltInLocals() { // Getting the Android Context val context = LocalContext.current // Getting the keyboard controller val keyboardController = LocalSoftwareKeyboardController.current // Getting the focus manager val focusManager = LocalFocusManager.current Button(onClick = { // Using the retrieved values Toast.makeText(context, \"Clicked!\", Toast.LENGTH_SHORT).show() keyboardController?.hide() // Note: keyboard controller might be null focusManager.clearFocus() }) { Text(\"Click Me\") }}1. Only Use .current in @Composable FunctionsComposition Locals are tied to Compose’s composition system. The .current property can only be accessed during composition, which happens within @Composable functions. Trying to access it elsewhere will crash your app because the composition system isn't active to provide the value.// WRONG - Will crash!class MyViewModel { private val theme = LocalTheme.current // Crash: Not in a @Composable}// WRONG - Will crash!fun normalFunction() { val theme = LocalTheme.current // Crash: Not in a @Composable}// RIGHT@Composablefun MyComponent() { val theme = LocalTheme.current // OK: Inside a @Composable}2. Don’t Store .current ValuesCompositionLocal values can change during recomposition. If you store a .current value in a property or long-lived variable, that stored value might become stale when the actual CompositionLocal value changes. Always read the value fresh when you need it.// WRONG@Composablefun BadExample() { // Don't store in properties or variables that outlive the composition class StateHolder { val theme = LocalTheme.current // BAD: Value might become stale }}// RIGHT@Composablefun GoodExample() { // Read the value each time you need it val theme = LocalTheme.current Button( onClick = { /* ... */ }, colors = ButtonDefaults.buttonColors( backgroundColor = theme.buttonColor // Fresh value each recomposition ) ) { Text(\"Click Me\") }}3. Passing to Non-Composable CodeSometimes you need to use CompositionLocal values in regular classes or functions. The safe way to do this is to read the value in your composable and pass it as a parameter. This ensures the non-composable code always has the current value and maintains proper separation of concerns.class ThemeAwareHelper(private val theme: Theme) { fun getStyledText(text: String): SpannedString { // Use theme safely here }}@Composablefun MyComponent() { val theme = LocalTheme.current val helper = remember(theme) { ThemeAwareHelper(theme) } // Use helper safely}4. Accessing in Side EffectsWhen using CompositionLocal values in side effects (like LaunchedEffect or SideEffect), capture the value during composition and use it as a parameter to ensure the side effect reruns when the value changes.@Composablefun MyComponent() { val theme = LocalTheme.current // Side effect will relaunch if theme changes LaunchedEffect(theme) { // Safe to use theme here as it's captured from composition analytics.logThemeUsed(theme.name) } // DisposableEffect example DisposableEffect(theme) { val themeListener = ThemeListener(theme) themeListener.start() onDispose { themeListener.stop() } }}5. Multiple CompositionLocalsWhen your composable needs multiple CompositionLocal values, read each one individually at the top level of your composable. This makes it clear what values your composable depends on and ensures you’re always working with fresh values.@Composablefun MyComponent() { // Read all needed values at the start val theme = LocalTheme.current val spacing = LocalSpacing.current val context = LocalContext.current Column( modifier = Modifier.padding(spacing.medium) ) { Text( text = \"Hello\", style = theme.typography.body1, color = theme.textColor ) Button(onClick = { // Using context safely Toast.makeText(context, \"Clicked!\", Toast.LENGTH_SHORT).show() }) { Text(\"Click Me\") } }}These rules ensure that:Your app doesn’t crash from incorrect CompositionLocal accessValues stay up-to-date when CompositionLocals changeSide effects and non-composable code work correctly with CompositionLocal valuesYour code remains maintainable and predictableRecomposition works properly with your CompositionLocal usagePractical Examples with MVI/MVVMEven if you’re using MVI (Model-View-Intent) or MVVM, Composition Locals remain helpful for UI infrastructure or cross-cutting concerns — like theming, feature flags, or navigation — while your state management handles the business logic and data flow. Here are some real-world scenarios:Design SystemUse staticCompositionLocalOf for values such as colors, typography, and spacing. These design tokens rarely change at runtime, so a static local avoids unnecessary recompositions.Snackbar ManagerMake a shared SnackbarManager accessible via a Composition Local. Any screen can trigger a global snackbar message without passing extra parameters or polluting the ViewModel.Feature Flags / A/B TestingStore feature flags in a Composition Local so your UI can easily reflect whether a feature is enabled or disabled. This prevents flag data from cluttering your application’s primary state.Accessibility SettingsProvide user accessibility preferences (font scale, reduce motion, high contrast, etc.) through a Composition Local, allowing any composable to adapt UI based on these settings.By leveraging Composition Locals for these cross-cutting concerns, your MVI/MVVM architecture remains focused on state and logic, while the UI benefits from easier access to shared resources.Best PracticesChoose the Right TypeUse compositionLocalOf for values that change and staticCompositionLocalOf for values that rarely change.Provide Default ValuesAlways give a sensible default or throw an error when creating your CompositionLocal.Limit ScopeAvoid providing everything globally. Keep values in the smallest scope needed.Document UsageHelp other developers (and future you!) understand when and how to use your Composition Locals.Consider PerformanceChanges in compositionLocalOf cause recomposition, while staticCompositionLocalOf does not.ConclusionComposition Locals are a powerful way to share data in Jetpack Compose. They shine when you have UI-related values (theme, spacing, navigation, etc.) that need to be accessible throughout your composables — without the hassle of passing parameters everywhere.However, remember that they’re not a replacement for proper state management. Keep your app-specific or user interaction data in your MVI/MVVM state, and let Composition Locals handle cross-cutting concerns and design tokens.By using Composition Locals effectively alongside a robust architecture, you’ll write cleaner, more scalable, and easier-to-test Compose code.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*h601q76q5F9ONmhaa2W7Nw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://ioannisanif.medium.com/?source=post_page---byline--e6a812ca7620--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ioannis Anifantakis\" src=\"https://miro.medium.com/v2/resize:fill:88:88/2*2hbIkl_9zix1pLi8u9osuQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--e6a812ca7620--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3fd3\"\u003e\u003cstrong\u003eDid you ever need to pass irrelevant parameters through multiple composable functions just to forward a parameter down the composable tree somewhere?\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"890d\"\u003eThat’s exactly the problem Composition Locals solve! In this article, we’ll discover what Composition Locals are, why they’re so useful, and how to create your own.\u003c/p\u003e\u003ch2 id=\"8a13\"\u003eWhat Are Composition Locals?\u003c/h2\u003e\u003cp id=\"2f0d\"\u003eComposition Locals are like invisible messengers in Jetpack Compose. They allow any child composable — no matter how deeply nested — to read values provided higher up the composition tree. If you’ve used \u003cstrong\u003eReact Native\u003c/strong\u003e, they’re similar to the \u003cstrong\u003eContext API\u003c/strong\u003e, which solves the “prop drilling” problem (passing props through components that don’t directly need them).\u003c/p\u003e\u003cp id=\"3a7e\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e: Instead of passing a \u003ccode\u003etheme\u003c/code\u003e object to every composable, you can provide it once and have child composables fetch it as needed.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"6b08\"\u003eThe Problem They Solve\u003c/h2\u003e\u003cp id=\"5c67\"\u003eHere’s a typical example without Composition Locals:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7c77\"\u003e@Composable\u003cbr/\u003efun MyApp(theme: Theme) {\u003cbr/\u003e    MainScreen(theme = theme)\u003cbr/\u003e}\u003cp\u003e@Composable\u003cbr/\u003efun MainScreen(theme: Theme) {\u003cbr/\u003e    Column {\u003cbr/\u003e        Header(theme = theme)\u003cbr/\u003e        Content(theme = theme)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun Header(theme: Theme) {\u003cbr/\u003e    // Use theme\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun Content(theme: Theme) {\u003cbr/\u003e    // Use theme\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ef99\"\u003eEvery composable has a \u003ccode\u003etheme\u003c/code\u003e parameter, even if it doesn’t use it. This leads to “parameter pollution” and makes the code harder to maintain.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9383\"\u003eWhy Are Composition Locals Important?\u003c/h2\u003e\u003col\u003e\u003cli id=\"e5af\"\u003e\u003cstrong\u003eReduced Boilerplate\u003c/strong\u003e\u003cbr/\u003eProvide data once at a higher level, consume it wherever necessary.\u003c/li\u003e\u003cli id=\"4c46\"\u003e\u003cstrong\u003eBetter Encapsulation\u003c/strong\u003e\u003cbr/\u003eIntermediate composables don’t need to manage data they don’t directly use.\u003c/li\u003e\u003cli id=\"b503\"\u003e\u003cstrong\u003eEasier Testing\u003c/strong\u003e\u003cbr/\u003eYou can override Composition Locals in tests without changing public APIs.\u003c/li\u003e\u003cli id=\"efc3\"\u003e\u003cstrong\u003eScoped Values\u003c/strong\u003e\u003cbr/\u003eData is only available to composables within the specific composition scope.\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"cbdb\"\u003eWhat Composition Locals Are (and Aren’t)\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"9531\"\u003eDue to a comment in LinkedIn about this post, let me make something clear…\u003c/p\u003e\u003cp id=\"2b2f\"\u003e\u003cem\u003eCompositionLocals shine when you’re dealing with cross-cutting UI stuff like theming or spacing. That’s where they save you from passing the same parameters through every composable.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"45a7\"\u003e\u003cem\u003eBut for actual app logic its better to avoid using them.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"bc79\"\u003e\u003cstrong\u003eAre For:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"327f\"\u003eDesign system tokens (themes, spacing, typography)\u003c/li\u003e\u003cli id=\"5025\"\u003eUI infrastructure (keyboard controller, focus management)\u003c/li\u003e\u003cli id=\"cc73\"\u003eCross-cutting UI concerns that follow the visual hierarchy\u003c/li\u003e\u003cli id=\"6e13\"\u003eValues that need different overrides at different levels of your UI tree\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"aa1c\"\u003e\u003cstrong\u003eAren’t For:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"b5b6\"\u003eBusiness logic or application state\u003c/li\u003e\u003cli id=\"b91f\"\u003eData that should be managed by state management solutions\u003c/li\u003e\u003cli id=\"3be9\"\u003eValues that affect application behavior — Database connections, repositories, or other non-UI dependencies\u003c/li\u003e\u003cli id=\"838f\"\u003eAvoiding proper dependency injection\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7d4b\"\u003eThink of Composition Locals as part of your UI toolkit, not as a general dependency injection mechanism. They shine when dealing with UI-related values that naturally follow your component hierarchy, but shouldn’t be used to bypass proper architecture patterns or hide important dependencies.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"604d\"\u003e\u003cstrong\u003eA go\u003cem\u003eod rule of thumb\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e:\u003c/em\u003e\u003c/p\u003e\u003cp id=\"cb92\"\u003e\u003cem\u003e- if it’s about how things look or interact at the UI level, a CompositionLocal might be appropriate.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"f91d\"\u003e\u003cem\u003e- If it’s about what your app does, use proper state management or dependency injection instead.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"da15\"\u003eCreating and Using Composition Locals\u003c/h2\u003e\u003ch2 id=\"f9c8\"\u003e1. Declare a Composition Local\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"c308\"\u003e// For dynamic values that change frequently\u003cbr/\u003eval LocalTheme = compositionLocalOf\u0026lt;Theme\u0026gt; { error(\u0026#34;No theme provided!\u0026#34;) }\u003cp\u003e// For values that rarely or never change at runtime\u003cbr/\u003eval LocalTheme = staticCompositionLocalOf { Theme.Light }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"ebd5\"\u003e\u003ccode\u003e\u003cstrong\u003estaticCompositionLocalOf\u003c/strong\u003e\u003c/code\u003e: For values that never or rarely change during runtime (like design tokens—typography, spacing, etc.). This doesn’t automatically trigger recompositions if the value changes, making it more efficient.\u003c/li\u003e\u003cli id=\"f1f1\"\u003e\u003ccode\u003e\u003cstrong\u003ecompositionLocalOf\u003c/strong\u003e\u003c/code\u003e: For dynamic values that change frequently (like a theme toggled by the user). When the provided value updates, any composable consuming it will automatically recompose.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"cb45\"\u003e2. Provide a Value\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"83c0\"\u003e@Composable\u003cbr/\u003efun MyApp() {\u003cbr/\u003e    val theme = Theme.Dark\u003cbr/\u003e    CompositionLocalProvider(LocalTheme provides theme) {\u003cbr/\u003e        MainScreen()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3a8c\"\u003e3. Consume the Value\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"98f0\"\u003e@Composable\u003cbr/\u003efun MyComponent() {\u003cbr/\u003e    val theme = LocalTheme.current\u003cbr/\u003e    // Use theme\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"2d31\"\u003eComparing to React Native’s Context API\u003c/h2\u003e\u003cp id=\"8334\"\u003eIf you’re familiar with React Native’s Context API, Composition Locals feel very similar:\u003c/p\u003e\u003ch2 id=\"2f1f\"\u003e\u003cstrong\u003eJetpack Compose Example\u003c/strong\u003e:\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"774f\"\u003e\u003cbr/\u003eval LocalTheme = compositionLocalOf { Theme.Light }\u003cp\u003e@Composable\u003cbr/\u003efun App() {\u003cbr/\u003e    CompositionLocalProvider(LocalTheme provides Theme.Dark) {\u003cbr/\u003e        ScreenA()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun Header() {\u003cbr/\u003e    val theme = LocalTheme.current\u003cbr/\u003e    Text(\u003cbr/\u003e        text = \u0026#34;Title\u0026#34;,\u003cbr/\u003e        color = if (theme == Theme.Dark) Color.White else Color.Black\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"257b\"\u003e\u003cstrong\u003eReact Native Example\u003c/strong\u003e:\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"ae76\"\u003e// Create context\u003cbr/\u003econst ThemeContext = React.createContext(Theme.Light);\u003cp\u003efunction App() {\u003cbr/\u003e  return (\u003cbr/\u003e    \u0026lt;ThemeContext.Provider value={Theme.Dark}\u0026gt;\u003cbr/\u003e      \u0026lt;MainScreen /\u0026gt;\u003cbr/\u003e    \u0026lt;/ThemeContext.Provider\u0026gt;\u003cbr/\u003e  );\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efunction Header() {\u003cbr/\u003e  const theme = React.useContext(ThemeContext);\u003cbr/\u003e  return \u0026lt;h1 style={{ color: theme === Theme.Dark ? \u0026#34;#fff\u0026#34; : \u0026#34;#000\u0026#34; }}\u0026gt;Title\u0026lt;/h1\u0026gt;;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"eeb7\"\u003eBoth approaches solve prop drilling, allow subtree overrides, and supply default values — but differ in syntax and recomposition mechanics.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d41a\"\u003eUnderstanding Scope: Not Global by Default\u003c/h2\u003e\u003cp id=\"8f18\"\u003eA crucial point: \u003cstrong\u003eComposition Locals are not automatically global!\u003c/strong\u003e They’re scoped to wherever you provide them:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d699\"\u003e@Composable\u003cbr/\u003efun App() {\u003cbr/\u003e    // LocalTheme is Dark only in ScreenA\u0026#39;s hierarchy\u003cbr/\u003e    CompositionLocalProvider(LocalTheme provides Theme.Dark) {\u003cbr/\u003e        ScreenA()\u003cbr/\u003e    }\u003cp\u003e        // ScreenB uses default or throws an error if no default is set\u003cbr/\u003e    ScreenB()\u003c/p\u003e\u003cp\u003e        // LocalTheme is Light only in ScreenC\u0026#39;s hierarchy\u003cbr/\u003e    CompositionLocalProvider(LocalTheme provides Theme.Light) {\u003cbr/\u003e        ScreenC()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5beb\"\u003eYou can \u003cstrong\u003eoverride\u003c/strong\u003e values deeper down:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fd02\"\u003e@Composable\u003cbr/\u003efun ScreenA() {\u003cbr/\u003e    // Using Dark theme from parent\u003cbr/\u003e    Header()\u003cp\u003e        CompositionLocalProvider(LocalTheme provides Theme.Light) {\u003cbr/\u003e        // Overrides Dark theme\u003cbr/\u003e        SpecialSection()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // Back to Dark\u003cbr/\u003e    Footer()\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"7fe8\"\u003eMaking Them “Global”\u003c/h2\u003e\u003cp id=\"7d04\"\u003ef you want values available throughout your entire app, provide them at the top level:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"596e\"\u003e@Composable\u003cbr/\u003efun MyApp() {\u003cbr/\u003e    CompositionLocalProvider(\u003cbr/\u003e        LocalTheme provides appTheme,\u003cbr/\u003e        LocalSpacing provides appSpacing\u003cbr/\u003e    ) {\u003cbr/\u003e        AppContent()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1155\"\u003eThat said, truly global state (like user profiles, auth tokens, or server data) often belongs in a dedicated state management solution (e.g., \u003cstrong\u003eViewModel\u003c/strong\u003e, \u003cstrong\u003eHilt\u003c/strong\u003e, \u003cstrong\u003eRedux\u003c/strong\u003e, etc.).\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"0856\"\u003eReal-World Example: Spacing System\u003c/h2\u003e\u003cp id=\"fff8\"\u003eLet’s say we want a \u003cstrong\u003ecustom spacing system\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b579\"\u003e// 1. Define a spacing data class\u003cbr/\u003edata class Spacing(val small: Dp = 4.dp, val medium: Dp = 8.dp, val large: Dp = 16.dp)\u003cp\u003e// 2. Create a CompositionLocal\u003cbr/\u003eval LocalSpacing = compositionLocalOf { Spacing() }\u003c/p\u003e\u003cp\u003e// 3. Provide custom spacing for a specific screen\u003cbr/\u003e@Composable\u003cbr/\u003efun SpecialScreen() {\u003cbr/\u003e    CompositionLocalProvider(LocalSpacing provides Spacing(8.dp, 16.dp, 24.dp)) {\u003cbr/\u003e        CustomCard(\u0026#34;Hello\u0026#34;, \u0026#34;This card uses custom spacing\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// 4. Consume it\u003cbr/\u003e@Composable\u003cbr/\u003efun CustomCard(title: String, content: String) {\u003cbr/\u003e    val spacing = LocalSpacing.current\u003cbr/\u003e    Card(modifier = Modifier.padding(spacing.medium)) {\u003cbr/\u003e        Column(modifier = Modifier.padding(spacing.medium)) {\u003cbr/\u003e            Text(title, modifier = Modifier.padding(bottom = spacing.small))\u003cbr/\u003e            Text(content)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9b75\"\u003e@Preview Composables\u003c/h2\u003e\u003cp id=\"f609\"\u003eAn important gotcha: \u003ccode\u003e\u003cstrong\u003e@Preview\u003c/strong\u003e\u003c/code\u003e composables are completely isolated from your app’s composition tree. This means they can’t access any CompositionLocals that you’ve provided elsewhere in your app, even at the root level!\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"664d\"\u003e// In your app\u003cbr/\u003e@Composable\u003cbr/\u003efun MyApp() {\u003cbr/\u003e    CompositionLocalProvider(LocalTheme provides Theme.Dark) {\u003cbr/\u003e        AppContent()  // All children here can access LocalTheme\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e// In your preview - THIS WON\u0026#39;T WORK!\u003cbr/\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun SomeComponentPreview() {\u003cbr/\u003e    MyComponent()  // CRASH! No access to LocalTheme\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a3b0\"\u003eInstead, you need to provide all necessary CompositionLocals \u003cstrong\u003eagain\u003c/strong\u003e in your preview:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e87f\"\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun SomeComponentPreview() {\u003cbr/\u003e    CompositionLocalProvider(LocalTheme provides Theme.Dark) {\u003cbr/\u003e        MyComponent()  // Now it works!\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"24f4\"\u003eTo avoid repeating this setup in every preview, \u003cstrong\u003ecreate a preview wrapper\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8010\"\u003e@Composable\u003cbr/\u003eprivate fun PreviewWrapper(\u003cbr/\u003e    content: @Composable () -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    CompositionLocalProvider(\u003cbr/\u003e        LocalTheme provides Theme.Light,\u003cbr/\u003e        LocalSpacing provides Spacing(),\u003cbr/\u003e        LocalContentColor provides Color.Black,\u003cbr/\u003e        // Add other necessary CompositionLocals\u003cbr/\u003e    ) {\u003cbr/\u003e        Surface {  // Optional: provide a surface for proper theming\u003cbr/\u003e            content()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e// Now you can easily create previews\u003cbr/\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun ComponentPreview() {\u003cbr/\u003e    PreviewWrapper {\u003cbr/\u003e        MyComponent()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4146\"\u003eThis approach:\u003c/p\u003e\u003cul\u003e\u003cli id=\"fcc0\"\u003eMakes previews more maintainable\u003c/li\u003e\u003cli id=\"fa22\"\u003eEnsures consistency across previews\u003c/li\u003e\u003cli id=\"6d1c\"\u003eReduces boilerplate\u003c/li\u003e\u003cli id=\"e90b\"\u003eMakes it easy to add preview variants\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"ac47\"\u003eUnderstanding Thread Usage with CompositionLocals\u003c/h2\u003e\u003cul\u003e\u003cli id=\"97ae\"\u003eThe \u003ccode\u003e.current\u003c/code\u003e property is synchronized with Compose\u0026#39;s composition system\u003c/li\u003e\u003cli id=\"a19b\"\u003eYou can’t accidentally access CompositionLocals from background threads because they’re only available in @Composable functions\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"9c80\"\u003e// This is safe - always runs on the main thread during composition\u003cbr/\u003e@Composable\u003cbr/\u003efun SafeComponent() {\u003cbr/\u003e    val theme = LocalTheme.current  // Thread-safe access\u003cbr/\u003e}\u003cp\u003e// This would crash - trying to access outside composition\u003cbr/\u003eCoroutineScope(Dispatchers.IO).launch {\u003cbr/\u003e    val theme = LocalTheme.current  // CRASH: Wrong thread and not in composition\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4aba\"\u003e\u003cstrong\u003e2. Value Updates\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"33ad\"\u003eChanges to CompositionLocal values are always synchronized with recomposition\u003c/li\u003e\u003cli id=\"d204\"\u003eUpdates are atomic — you’ll never get partial or inconsistent values\u003c/li\u003e\u003cli id=\"9862\"\u003eAll readers see the same value at the same point in the composition\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"47c0\"\u003e@Composable\u003cbr/\u003efun ThemeProvider(theme: Theme) {\u003cbr/\u003e    // Thread-safe: Updates are synchronized with composition\u003cbr/\u003e    CompositionLocalProvider(LocalTheme provides theme) {\u003cbr/\u003e        Content()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"46e2\"\u003e\u003cstrong\u003e3. Background Thread Considerations\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"93d8\"\u003eIf you need to use CompositionLocal values in background work:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cb3d\"\u003e@Composable\u003cbr/\u003efun BackgroundWorker() {\u003cbr/\u003e    val theme = LocalTheme.current  // Safely capture during composition\u003cp\u003e        LaunchedEffect(theme) {\u003cbr/\u003e        withContext(Dispatchers.IO) {\u003cbr/\u003e            // Safe: using captured value, not accessing .current\u003cbr/\u003e            processTheme(theme)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5497\"\u003eUsage Rules\u003c/h2\u003e\u003ch2 id=\"5e1e\"\u003eWhat is \u003ccode\u003e.current\u003c/code\u003e?\u003c/h2\u003e\u003cp id=\"1469\"\u003eThe \u003ccode\u003e\u003cstrong\u003e.current\u003c/strong\u003e\u003c/code\u003e property is how you actually read a value from a CompositionLocal. Think of it as the \u0026#34;getter\u0026#34; that retrieves the most recently provided value in the composition tree above your composable.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ebac\"\u003e// Defining a CompositionLocal\u003cbr/\u003eval LocalTheme = compositionLocalOf\u0026lt;Theme\u0026gt; { Theme.Light }\u003cp\u003e@Composable\u003cbr/\u003efun MyComponent() {\u003cbr/\u003e    // Using .current to read the value\u003cbr/\u003e    val theme = LocalTheme.current  // This gets the closest provided Theme value\u003c/p\u003e\u003cp\u003e        Text(\u003cbr/\u003e        text = \u0026#34;Hello\u0026#34;,\u003cbr/\u003e        color = theme.textColor  // Using the retrieved theme\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"fe9b\"\u003eBuilt-in CompositionLocals\u003c/h2\u003e\u003cp id=\"dee6\"\u003eJetpack Compose already comes with many useful Composition Locals. For instance:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a0a0\"\u003e\u003ccode\u003e\u003cstrong\u003eLocalContext\u003c/strong\u003e\u003c/code\u003e: Fetches the Android \u003ccode\u003eContext\u003c/code\u003e inside a composable.\u003c/li\u003e\u003cli id=\"8f87\"\u003e\u003ccode\u003e\u003cstrong\u003eLocalSoftwareKeyboardController\u003c/strong\u003e\u003c/code\u003e: Helps you control the software keyboard (show/hide).\u003c/li\u003e\u003cli id=\"38a8\"\u003e\u003ccode\u003e\u003cstrong\u003eLocalFocusManager\u003c/strong\u003e\u003c/code\u003e: Manages focus state across composables.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d4df\"\u003eThese are excellent examples of how Composition Locals make it easy to access shared resources without needing to pass them around everywhere.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"f25f\"\u003eLet’s see how to use \u003ccode\u003e.current\u003c/code\u003e with some built-in CompositionLocals:\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"d96a\"\u003e@Composable\u003cbr/\u003efun ExampleWithBuiltInLocals() {\u003cbr/\u003e    // Getting the Android Context\u003cbr/\u003e    val context = LocalContext.current\u003cp\u003e        // Getting the keyboard controller\u003cbr/\u003e    val keyboardController = LocalSoftwareKeyboardController.current\u003c/p\u003e\u003cp\u003e        // Getting the focus manager\u003cbr/\u003e    val focusManager = LocalFocusManager.current\u003c/p\u003e\u003cp\u003e        Button(onClick = {\u003cbr/\u003e        // Using the retrieved values\u003cbr/\u003e        Toast.makeText(context, \u0026#34;Clicked!\u0026#34;, Toast.LENGTH_SHORT).show()\u003cbr/\u003e        keyboardController?.hide()  // Note: keyboard controller might be null\u003cbr/\u003e        focusManager.clearFocus()\u003cbr/\u003e    }) {\u003cbr/\u003e        Text(\u0026#34;Click Me\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1dda\"\u003e1. Only Use .current in \u003ccode\u003e@Composable\u003c/code\u003e Functions\u003c/h2\u003e\u003cp id=\"c5b1\"\u003eComposition Locals are tied to Compose’s composition system. The \u003ccode\u003e.current\u003c/code\u003e property can only be accessed during composition, which happens within @Composable functions. Trying to access it elsewhere will crash your app because the composition system isn\u0026#39;t active to provide the value.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"59cb\"\u003e// WRONG - Will crash!\u003cbr/\u003eclass MyViewModel {\u003cbr/\u003e    private val theme = LocalTheme.current  // Crash: Not in a @Composable\u003cbr/\u003e}\u003cp\u003e// WRONG - Will crash!\u003cbr/\u003efun normalFunction() {\u003cbr/\u003e    val theme = LocalTheme.current  // Crash: Not in a @Composable\u003cbr/\u003e}\u003cbr/\u003e// RIGHT\u003cbr/\u003e@Composable\u003cbr/\u003efun MyComponent() {\u003cbr/\u003e    val theme = LocalTheme.current  // OK: Inside a @Composable\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4269\"\u003e2. Don’t Store .current Values\u003c/h2\u003e\u003cp id=\"5fb7\"\u003eCompositionLocal values can change during recomposition. If you store a \u003ccode\u003e.current\u003c/code\u003e value in a property or long-lived variable, that stored value might become stale when the actual CompositionLocal value changes. Always read the value fresh when you need it.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6db7\"\u003e// WRONG\u003cbr/\u003e@Composable\u003cbr/\u003efun BadExample() {\u003cbr/\u003e    // Don\u0026#39;t store in properties or variables that outlive the composition\u003cbr/\u003e    class StateHolder {\u003cbr/\u003e        val theme = LocalTheme.current  // BAD: Value might become stale\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e// RIGHT\u003cbr/\u003e@Composable\u003cbr/\u003efun GoodExample() {\u003cbr/\u003e    // Read the value each time you need it\u003cbr/\u003e    val theme = LocalTheme.current\u003c/p\u003e\u003cp\u003e        Button(\u003cbr/\u003e        onClick = { /* ... */ },\u003cbr/\u003e        colors = ButtonDefaults.buttonColors(\u003cbr/\u003e            backgroundColor = theme.buttonColor  // Fresh value each recomposition\u003cbr/\u003e        )\u003cbr/\u003e    ) {\u003cbr/\u003e        Text(\u0026#34;Click Me\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"37f2\"\u003e\u003cstrong\u003e3. Passing to Non-Composable Code\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"8f42\"\u003eSometimes you need to use CompositionLocal values in regular classes or functions. The safe way to do this is to read the value in your composable and pass it as a parameter. This ensures the non-composable code always has the current value and maintains proper separation of concerns.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"850d\"\u003eclass ThemeAwareHelper(private val theme: Theme) {\u003cbr/\u003e    fun getStyledText(text: String): SpannedString {\u003cbr/\u003e        // Use theme safely here\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e@Composable\u003cbr/\u003efun MyComponent() {\u003cbr/\u003e    val theme = LocalTheme.current\u003cbr/\u003e    val helper = remember(theme) { ThemeAwareHelper(theme) }\u003c/p\u003e\u003cp\u003e        // Use helper safely\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4922\"\u003e\u003cstrong\u003e4. Accessing in Side Effects\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"d27e\"\u003eWhen using CompositionLocal values in side effects (like \u003ccode\u003eLaunchedEffect\u003c/code\u003e or \u003ccode\u003eSideEffect\u003c/code\u003e), capture the value during composition and use it as a parameter to ensure the side effect reruns when the value changes.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5746\"\u003e@Composable\u003cbr/\u003efun MyComponent() {\u003cbr/\u003e    val theme = LocalTheme.current\u003cp\u003e        // Side effect will relaunch if theme changes\u003cbr/\u003e    LaunchedEffect(theme) {\u003cbr/\u003e        // Safe to use theme here as it\u0026#39;s captured from composition\u003cbr/\u003e        analytics.logThemeUsed(theme.name)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        // DisposableEffect example\u003cbr/\u003e    DisposableEffect(theme) {\u003cbr/\u003e        val themeListener = ThemeListener(theme)\u003cbr/\u003e        themeListener.start()\u003c/p\u003e\u003cp\u003e                onDispose {\u003cbr/\u003e            themeListener.stop()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"8af0\"\u003e\u003cstrong\u003e5. Multiple CompositionLocals\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"ccfb\"\u003eWhen your composable needs multiple CompositionLocal values, read each one individually at the top level of your composable. This makes it clear what values your composable depends on and ensures you’re always working with fresh values.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a998\"\u003e@Composable\u003cbr/\u003efun MyComponent() {\u003cbr/\u003e    // Read all needed values at the start\u003cbr/\u003e    val theme = LocalTheme.current\u003cbr/\u003e    val spacing = LocalSpacing.current\u003cbr/\u003e    val context = LocalContext.current\u003cp\u003e        Column(\u003cbr/\u003e        modifier = Modifier.padding(spacing.medium)\u003cbr/\u003e    ) {\u003cbr/\u003e        Text(\u003cbr/\u003e            text = \u0026#34;Hello\u0026#34;,\u003cbr/\u003e            style = theme.typography.body1,\u003cbr/\u003e            color = theme.textColor\u003cbr/\u003e        )\u003c/p\u003e\u003cp\u003e                Button(onClick = {\u003cbr/\u003e            // Using context safely\u003cbr/\u003e            Toast.makeText(context, \u0026#34;Clicked!\u0026#34;, Toast.LENGTH_SHORT).show()\u003cbr/\u003e        }) {\u003cbr/\u003e            Text(\u0026#34;Click Me\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0ee8\"\u003eThese rules ensure that:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e06c\"\u003eYour app doesn’t crash from incorrect CompositionLocal access\u003c/li\u003e\u003cli id=\"1679\"\u003eValues stay up-to-date when CompositionLocals change\u003c/li\u003e\u003cli id=\"ce7b\"\u003eSide effects and non-composable code work correctly with CompositionLocal values\u003c/li\u003e\u003cli id=\"e634\"\u003eYour code remains maintainable and predictable\u003c/li\u003e\u003cli id=\"d06f\"\u003eRecomposition works properly with your CompositionLocal usage\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5003\"\u003ePractical Examples with MVI/MVVM\u003c/h2\u003e\u003cp id=\"d196\"\u003eEven if you’re using MVI (Model-View-Intent) or MVVM, \u003cstrong\u003eComposition Locals\u003c/strong\u003e remain helpful for UI infrastructure or cross-cutting concerns — like theming, feature flags, or navigation — while your state management handles the \u003cstrong\u003ebusiness logic\u003c/strong\u003e and \u003cstrong\u003edata flow\u003c/strong\u003e. Here are some real-world scenarios:\u003c/p\u003e\u003cul\u003e\u003cli id=\"cd69\"\u003e\u003cstrong\u003eDesign System\u003c/strong\u003e\u003cbr/\u003eUse \u003ccode\u003estaticCompositionLocalOf\u003c/code\u003e for values such as colors, typography, and spacing. These design tokens rarely change at runtime, so a static local avoids unnecessary recompositions.\u003c/li\u003e\u003cli id=\"747a\"\u003e\u003cstrong\u003eSnackbar Manager\u003c/strong\u003e\u003cbr/\u003eMake a shared \u003ccode\u003eSnackbarManager\u003c/code\u003e accessible via a Composition Local. Any screen can trigger a global snackbar message without passing extra parameters or polluting the ViewModel.\u003c/li\u003e\u003cli id=\"b38a\"\u003e\u003cstrong\u003eFeature Flags / A/B Testing\u003c/strong\u003e\u003cbr/\u003eStore feature flags in a Composition Local so your UI can easily reflect whether a feature is enabled or disabled. This prevents flag data from cluttering your application’s primary state.\u003c/li\u003e\u003cli id=\"5ed6\"\u003e\u003cstrong\u003eAccessibility Settings\u003c/strong\u003e\u003cbr/\u003eProvide user accessibility preferences (font scale, reduce motion, high contrast, etc.) through a Composition Local, allowing any composable to adapt UI based on these settings.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"062d\"\u003eBy leveraging Composition Locals for these cross-cutting concerns, your \u003cstrong\u003eMVI/MVVM\u003c/strong\u003e architecture remains focused on state and logic, while the UI benefits from easier access to shared resources.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5d8b\"\u003eBest Practices\u003c/h2\u003e\u003col\u003e\u003cli id=\"e7b5\"\u003e\u003cstrong\u003eChoose the Right Type\u003c/strong\u003e\u003cbr/\u003eUse \u003ccode\u003ecompositionLocalOf\u003c/code\u003e for values that change and \u003ccode\u003estaticCompositionLocalOf\u003c/code\u003e for values that rarely change.\u003c/li\u003e\u003cli id=\"a4ae\"\u003e\u003cstrong\u003eProvide Default Values\u003c/strong\u003e\u003cbr/\u003eAlways give a sensible default or throw an error when creating your CompositionLocal.\u003c/li\u003e\u003cli id=\"3cb3\"\u003e\u003cstrong\u003eLimit Scope\u003c/strong\u003e\u003cbr/\u003eAvoid providing everything globally. Keep values in the smallest scope needed.\u003c/li\u003e\u003cli id=\"e355\"\u003e\u003cstrong\u003eDocument Usage\u003c/strong\u003e\u003cbr/\u003eHelp other developers (and future you!) understand when and how to use your Composition Locals.\u003c/li\u003e\u003cli id=\"f613\"\u003e\u003cstrong\u003eConsider Performance\u003c/strong\u003e\u003cbr/\u003eChanges in \u003ccode\u003ecompositionLocalOf\u003c/code\u003e cause recomposition, while \u003ccode\u003estaticCompositionLocalOf\u003c/code\u003e does not.\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5ffc\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"a725\"\u003eComposition Locals are a powerful way to share data in Jetpack Compose. They shine when you have UI-related values (theme, spacing, navigation, etc.) that need to be accessible throughout your composables — without the hassle of passing parameters everywhere.\u003c/p\u003e\u003cp id=\"7f7e\"\u003eHowever, remember that they’re not a replacement for proper state management. Keep your app-specific or user interaction data in your MVI/MVVM state, and let Composition Locals handle cross-cutting concerns and design tokens.\u003c/p\u003e\u003cp id=\"b76a\"\u003eBy using Composition Locals effectively alongside a robust architecture, you’ll write cleaner, more scalable, and easier-to-test Compose code.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "19 min read",
  "publishedTime": "2025-01-13T02:30:09.389Z",
  "modifiedTime": null
}
