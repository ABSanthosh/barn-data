{
  "id": "ad5b39a6-c450-4489-a0d8-506f880b57d5",
  "title": "Making Android Code Cleaner with Use Cases: A Practical Approach Using Kotlin Coroutines",
  "link": "https://proandroiddev.com/making-android-code-cleaner-with-use-cases-a-practical-approach-using-kotlin-coroutines-2700e724c4fd?source=rss----c72404660798---4",
  "description": "",
  "author": "Siarhei Krupenich",
  "published": "Thu, 17 Apr 2025 13:53:54 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "androiddev",
    "android-app-development",
    "use-cases",
    "kotlin-coroutines",
    "android"
  ],
  "byline": "Siarhei Krupenich",
  "length": 8600,
  "excerpt": "Earlier, we developed an Android application with a focus on Clean Architecture, Inputs/Outputs MVVM splitting, and the Repository pattern. This approach follows best practices recommended by the…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Structure your Android app with clear, testable, and coroutine-ready use cases.IntroductionEarlier, we developed an Android application with a focus on Clean Architecture, Inputs/Outputs MVVM splitting, and the Repository pattern. This approach follows best practices recommended by the Android team at Google, making the codebase scalable, maintainable, and testable. In this article, we’ll dive into one more essential concept — Use Case — and I’ll walk you through its usage and the background behind it. Embracing this pattern will make your code even more readable and testable — which is a pretty big win.Problems with InteractorsBack in the day, we often used Interactors as middleware components between layers — for example, a Presenter could use an interactor to communicate with the domain layer. This allowed us to move some logic out of the presenter and into separate, reusable components. At the time, it was a solid solution for splitting logic and keeping things cleaner. Let’s look at a simple example:// Interactorclass UserInteractor { private var username: String = \"Guest\" fun getUsername(): String { return username } fun saveUsername(name: String) { username = name }}// Presenterclass UserPresenter( private val view: UserView, private val interactor: UserInteractor) { fun loadUsername() { val name = interactor.getUsername() view.showUsername(name) } fun updateUsername(name: String) { interactor.saveUsername(name) view.showSavedMessage() }}As the presenter grows, so does the complexity of the logic — and that usually leads to a growing number of methods in the interactor. The bigger the presenter, the bigger the interactor becomes. Eventually, we end up with a setup full of states, methods, and variables all crammed into one place.Obviously, such a codebase becomes tough to maintain, hard to test, and even harder to cover with proper unit tests. On top of that, this setup drifts into anti-pattern territory, breaking core principles like SOLID (especially the Single Responsibility Principle) and KISS.That’s why I’d highlight the following pitfalls when using the interactor approach:Too Much Stuff in One Place When one class handles everything — reading, writing, deleting — it ends up doing too much. That makes it harder to test and tricky to change without breaking something else.Not Clear What It Does A use case like LoginUser() tells you exactly what’s going on. But with a big interactor, it’s not obvious — is it about users, settings, or something else?Hard to Reuse Use cases with one job are easy to plug in wherever you need them. Interactors grow over time and become too messy to reuse easily.Doesn’t Scale Well Imagine having 10 features and each one has its own interactor with 5+ methods. That’s a lot to remember and a lot of code to manage.Logic Gets Mixed Up When everything lives in one file, it’s easy to accidentally combine things that shouldn’t be together — like login logic getting tangled with profile updates.Use Case: From UML to Android All the issues we just discussed can be fully or at least partially resolved by using the Use Case approach. But before jumping into the Android implementation, let’s take a quick look at what a Use Case means in UML terms. In UML, a use case is all about one clear intent — it represents a specific piece of business logic or functionality. Check out the example below to see how it’s typically visualized:Diagram 1: UML Use CaseBasically, the use cases we’re about to implement follow the same idea as in UML: one intent — one use case. That simple rule helps us deal with all the earlier problems — testing gets easier, the code becomes more scalable, and the whole thing is cleaner to maintain.Now, let’s improve the code snippet above using the Use-Case approach:// Use-Case 1class GetUserNameUseCase( val repository: UserRepository,) { operator fun invoke(): String { return repository.getUserName() }}// Use-Case 2class SaveUsernameUseCase( val repository: UserRepository,) { operator fun invoke(name: String) { repository.save(name) }}So we’ve just split the interactor into two use cases. I recommend using the invoke operator function, which allows us to treat their use-case names as functions. On top of that, it’s much easier to test it this way.The usage of the use cases is demonstrated in the following ViewModel:// ViewModelclass ViewModel( private val getUsername: GetUserNameUseCase, private val saveUsername: SaveUsernameUseCase) { val userName: StateFlow\u003cString\u003e fun loadUsername() { userName.update(getUsername()) } fun updateUsername(name: String) { saveUsername(name) }}And simple tests can be written as follows:@Beforefun setup() { useCase = GetUserNameUseCase(repository)}@Testfun `should return username from repository`() { `when`(repository.getUserName()).thenReturn(\"JohnDoe\") val result = useCase() assertEquals(\"JohnDoe\", result) verify(repository).getUserName()}@Testfun `should save username to repository`() { val testName = \"JaneDoe\" useCase(testName) verify(repository).save(testName)}How this could be incorporated into a real Repos applicationMy proposal is to always start with an abstraction. Given the nature of a Use-Case, which typically has only one public method, I recommend using operator functions (e.g., invoke works well here). The following abstraction could be implemented:// A template interface as an abstraction for all Use-Casesinterface SuspendUseCase\u003cin T, out O\u003e { suspend operator fun invoke(param: T): O}Its name has the suffix Suspend to indicate that it handles a suspended result. This generic approach allows us to define specific types for both the parameters and the return type. For example, the following specific Use-Case interface could be used further:// A particular Use-case interfaceinterface GetReposUseCase: SuspendUseCase\u003cBoolean, ResultWithFallback\u003cList\u003cDomainRepoEntity\u003e\u003e\u003eBased on its name, it can be used to obtain the Repos, throwing its Result wrapper. A client would use it in a function-style approach (e.g., val repos = getRepos(...)). Here’s its implementation:// A simple implementation of the GetReposUseCaseinternal class GetReposUseCaseImpl( private val mapper: Mapper, private val repository: ReposRepository) : GetReposUseCase { override suspend operator fun invoke(param: Boolean): ResultWithFallback\u003cList\u003cDomainRepoEntity\u003e\u003e = repository.getRepos(param).map(mapper::map)}Now, let’s make the task more challenging and add an additional abstract layer to the Use-Case structure. I want to implement use cases that interact solely with repositories. These will include an instance of the repository as an additional parameter type in the generic. Let’s take a look at this snippet:// A template interface as an abstraction for all Use-Casesinterface SuspendUseCase\u003cin T, out O\u003e { suspend fun execute(param: T): O}I’ve changed the execute method to allow calling one from a further abstract child. Here’s the updated code snippet:// Extending the SuspendUseCase interfaceinterface RepositoryUseCase\u003cin I, out O, R : Repository\u003e : SuspendUseCase\u003cI, O\u003e { var repository: R}Every child that implements the repository of type R will adhere to the contract. The most appropriate approach is to use an abstract class. Let’s implement one to cover this:// Abstract class for ensuring following the contractabstract class BaseRepositoryUseCase\u003cin I, out O, R : Repository\u003e(override var repository: R) : RepositoryUseCase\u003cI, O, R\u003e { suspend operator fun invoke(params: I? = null): O { // here is a call of the SuspendUseCase inteface return execute(params) }}All we need to do is extend the BaseRepositoryUseCase, adhering to its generic contract by providing an input class, an output class, and the repository instance that is overridden. The following implementation is good to go:// Use-case implementationclass GetReposUseCase(repository: RepoRepository): BaseRepositoryUseCase\u003cBoolean,ResultWithFallback\u003cList\u003cDomainRepoEntity\u003e\u003e, RepoRepository\u003e(repository) { override suspend fun execute(param: Boolean): ResultWithFallback\u003cList\u003cDomainRepoEntity\u003e\u003e = // obtaining and returning result using the repository like repository.getData() }}ConclusionThus, we’ve explored the optimal approach to using use cases from scratch, capturing client intents. I’ve demonstrated how to implement and use them in a functional manner, making them easy to test and integrate.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1024/0*eVj9Vuqq31RUWd2y",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"7dde\"\u003eStructure your Android app with clear, testable, and coroutine-ready use cases.\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@siarhei.krupenich?source=post_page---byline--2700e724c4fd---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Siarhei Krupenich\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*HrYgJ8XqQc9RbTXL5TJ99Q.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--2700e724c4fd---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"12da\"\u003e\u003cstrong\u003eIntroduction\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"d3ad\"\u003eEarlier, we developed an Android application with a focus on Clean Architecture, Inputs/Outputs MVVM splitting, and the Repository pattern. This approach follows best practices recommended by the Android team at Google, making the codebase scalable, maintainable, and testable.\u003cbr/\u003e In this article, we’ll dive into one more essential concept — \u003cstrong\u003eUse Case\u003c/strong\u003e — and I’ll walk you through its usage and the background behind it. Embracing this pattern will make your code even more readable and testable — which is a pretty big win.\u003c/p\u003e\u003cp id=\"0c8d\"\u003e\u003cstrong\u003eProblems with Interactors\u003c/strong\u003e\u003cbr/\u003eBack in the day, we often used \u003cstrong\u003eInteractors\u003c/strong\u003e as middleware components between layers — for example, a Presenter could use an interactor to communicate with the domain layer. This allowed us to move some logic out of the presenter and into separate, reusable components. At the time, it was a solid solution for splitting logic and keeping things cleaner.\u003cbr/\u003e Let’s look at a simple example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fe92\"\u003e// Interactor\u003cbr/\u003eclass UserInteractor {\u003cbr/\u003e    private var username: String = \u0026#34;Guest\u0026#34;\u003cp\u003e    fun getUsername(): String {\u003cbr/\u003e        return username\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun saveUsername(name: String) {\u003cbr/\u003e        username = name\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Presenter\u003cbr/\u003eclass UserPresenter(\u003cbr/\u003e    private val view: UserView,\u003cbr/\u003e    private val interactor: UserInteractor\u003cbr/\u003e) {\u003cbr/\u003e    fun loadUsername() {\u003cbr/\u003e        val name = interactor.getUsername()\u003cbr/\u003e        view.showUsername(name)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun updateUsername(name: String) {\u003cbr/\u003e        interactor.saveUsername(name)\u003cbr/\u003e        view.showSavedMessage()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"111a\"\u003eAs the presenter grows, so does the complexity of the logic — and that usually leads to a growing number of methods in the interactor. The bigger the presenter, the bigger the interactor becomes. Eventually, we end up with a setup full of states, methods, and variables all crammed into one place.\u003cbr/\u003eObviously, such a codebase becomes tough to maintain, hard to test, and even harder to cover with proper unit tests. On top of that, this setup drifts into anti-pattern territory, breaking core principles like \u003cstrong\u003eSOLID\u003c/strong\u003e (especially the \u003cem\u003eSingle Responsibility Principle\u003c/em\u003e) and \u003cstrong\u003eKISS\u003c/strong\u003e.\u003cbr/\u003eThat’s why I’d highlight the following pitfalls when using the interactor approach:\u003c/p\u003e\u003cul\u003e\u003cli id=\"09e6\"\u003e\u003cstrong\u003eToo Much Stuff in One Place\u003c/strong\u003e\u003cbr/\u003e When one class handles everything — reading, writing, deleting — it ends up doing too much. That makes it harder to test and tricky to change without breaking something else.\u003c/li\u003e\u003cli id=\"81ad\"\u003e\u003cstrong\u003eNot Clear What It Does\u003c/strong\u003e\u003cbr/\u003e A use case like \u003ccode\u003eLoginUser()\u003c/code\u003e tells you exactly what’s going on. But with a big interactor, it’s not obvious — is it about users, settings, or something else?\u003c/li\u003e\u003cli id=\"5560\"\u003e\u003cstrong\u003eHard to Reuse\u003c/strong\u003e\u003cbr/\u003e Use cases with one job are easy to plug in wherever you need them. Interactors grow over time and become too messy to reuse easily.\u003c/li\u003e\u003cli id=\"ef2d\"\u003e\u003cstrong\u003eDoesn’t Scale Well\u003c/strong\u003e\u003cbr/\u003e Imagine having 10 features and each one has its own interactor with 5+ methods. That’s a lot to remember and a lot of code to manage.\u003c/li\u003e\u003cli id=\"8164\"\u003e\u003cstrong\u003eLogic Gets Mixed Up\u003c/strong\u003e\u003cbr/\u003e When everything lives in one file, it’s easy to accidentally combine things that shouldn’t be together — like login logic getting tangled with profile updates.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"61f8\"\u003e\u003cstrong\u003eUse Case: From UML to Android\u003c/strong\u003e\u003cbr/\u003e All the issues we just discussed can be fully or at least partially resolved by using the Use Case approach. But before jumping into the Android implementation, let’s take a quick look at what a Use Case means in UML terms. In UML, a use case is all about \u003cem\u003eone\u003c/em\u003e clear intent — it represents a specific piece of business logic or functionality. Check out the example below to see how it’s typically visualized:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eDiagram 1: UML Use Case\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"1097\"\u003eBasically, the use cases we’re about to implement follow the same idea as in UML: \u003cstrong\u003eone intent — one use case\u003c/strong\u003e. That simple rule helps us deal with all the earlier problems — testing gets easier, the code becomes more scalable, and the whole thing is cleaner to maintain.\u003c/p\u003e\u003cp id=\"b286\"\u003eNow, let’s improve the code snippet above using the Use-Case approach:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b538\"\u003e// Use-Case 1\u003cbr/\u003eclass GetUserNameUseCase(\u003cbr/\u003e    val repository: UserRepository,\u003cbr/\u003e) {\u003cbr/\u003e    operator fun invoke(): String {\u003cbr/\u003e        return repository.getUserName()\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e// Use-Case 2\u003cbr/\u003eclass SaveUsernameUseCase(\u003cbr/\u003e    val repository: UserRepository,\u003cbr/\u003e) {\u003cbr/\u003e    operator fun invoke(name: String) {\u003cbr/\u003e        repository.save(name)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f01c\"\u003eSo we’ve just split the interactor into two use cases. I recommend using the invoke operator function, which allows us to treat their use-case names as functions. On top of that, it’s much easier to test it this way.\u003c/p\u003e\u003cp id=\"4469\"\u003eThe usage of the use cases is demonstrated in the following ViewModel:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ffe8\"\u003e// ViewModel\u003cbr/\u003eclass ViewModel(\u003cbr/\u003e    private val getUsername: GetUserNameUseCase,\u003cbr/\u003e    private val saveUsername: SaveUsernameUseCase\u003cbr/\u003e) {\u003cbr/\u003e    val userName: StateFlow\u0026lt;String\u0026gt;\u003cp\u003e    fun loadUsername() {\u003cbr/\u003e        userName.update(getUsername())\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun updateUsername(name: String) {\u003cbr/\u003e        saveUsername(name)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"68cd\"\u003eAnd simple tests can be written as follows:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d2f9\"\u003e@Before\u003cbr/\u003efun setup() {\u003cbr/\u003e    useCase = GetUserNameUseCase(repository)\u003cbr/\u003e}\u003cp\u003e@Test\u003cbr/\u003efun `should return username from repository`() {\u003cbr/\u003e     `when`(repository.getUserName()).thenReturn(\u0026#34;JohnDoe\u0026#34;)\u003cbr/\u003e     val result = useCase()\u003c/p\u003e\u003cp\u003e     assertEquals(\u0026#34;JohnDoe\u0026#34;, result)\u003cbr/\u003e     verify(repository).getUserName()\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Test\u003cbr/\u003efun `should save username to repository`() {\u003cbr/\u003e    val testName = \u0026#34;JaneDoe\u0026#34;\u003cbr/\u003e    useCase(testName)\u003c/p\u003e\u003cp\u003e    verify(repository).save(testName)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"6502\"\u003eHow this could be incorporated into a real Repos application\u003c/h2\u003e\u003cp id=\"5e07\"\u003eMy proposal is to always start with an abstraction. Given the nature of a Use-Case, which typically has only one public method, I recommend using operator functions (e.g., \u003ccode\u003einvoke\u003c/code\u003e works well here). The following abstraction could be implemented:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a542\"\u003e// A template interface as an abstraction for all Use-Cases\u003cbr/\u003einterface SuspendUseCase\u0026lt;in T, out O\u0026gt; {\u003cbr/\u003e    suspend operator fun invoke(param: T): O\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cc8a\"\u003eIts name has the suffix \u003ccode\u003eSuspend\u003c/code\u003e to indicate that it handles a suspended result. This generic approach allows us to define specific types for both the parameters and the return type. For example, the following specific Use-Case interface could be used further:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"704c\"\u003e// A particular Use-case interface\u003cbr/\u003einterface GetReposUseCase: SuspendUseCase\u0026lt;Boolean, ResultWithFallback\u0026lt;List\u0026lt;DomainRepoEntity\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"81b5\"\u003eBased on its name, it can be used to obtain the Repos, throwing its Result wrapper. A client would use it in a function-style approach (e.g., \u003ccode\u003eval repos = getRepos(...)\u003c/code\u003e). Here’s its implementation:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"58dd\"\u003e// A simple implementation of the GetReposUseCase\u003cbr/\u003einternal class GetReposUseCaseImpl(\u003cbr/\u003e    private val mapper: Mapper,\u003cbr/\u003e    private val repository: ReposRepository\u003cbr/\u003e) : GetReposUseCase {\u003cbr/\u003e  override suspend operator fun invoke(param: Boolean):\u003cbr/\u003e      ResultWithFallback\u0026lt;List\u0026lt;DomainRepoEntity\u0026gt;\u0026gt; =\u003cbr/\u003e          repository.getRepos(param).map(mapper::map)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6811\"\u003eNow, let’s make the task more challenging and add an additional abstract layer to the Use-Case structure. I want to implement use cases that interact solely with repositories. These will include an instance of the repository as an additional parameter type in the generic. Let’s take a look at this snippet:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2b5d\"\u003e// A template interface as an abstraction for all Use-Cases\u003cbr/\u003einterface SuspendUseCase\u0026lt;in T, out O\u0026gt; {\u003cbr/\u003e    suspend fun execute(param: T): O\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"084d\"\u003eI’ve changed the \u003ccode\u003eexecute\u003c/code\u003e method to allow calling one from a further abstract child. Here’s the updated code snippet:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0898\"\u003e// Extending the SuspendUseCase interface\u003cbr/\u003einterface RepositoryUseCase\u0026lt;in I, out O, R : Repository\u0026gt; :\u003cbr/\u003e    SuspendUseCase\u0026lt;I, O\u0026gt; {\u003cp\u003e    var repository: R\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5a00\"\u003eEvery child that implements the repository of type \u003ccode\u003eR\u003c/code\u003e will adhere to the contract. The most appropriate approach is to use an abstract class. Let’s implement one to cover this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d74c\"\u003e// Abstract class for ensuring following the contract\u003cbr/\u003eabstract class BaseRepositoryUseCase\u0026lt;in I, out O, R : Repository\u0026gt;(override var repository: R) :\u003cbr/\u003e    RepositoryUseCase\u0026lt;I, O, R\u0026gt; {\u003cp\u003e    suspend operator fun invoke(params: I? = null): O {\u003cbr/\u003e        // here is a call of the SuspendUseCase inteface\u003cbr/\u003e        return execute(params)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f965\"\u003eAll we need to do is extend the \u003ccode\u003eBaseRepositoryUseCase\u003c/code\u003e, adhering to its generic contract by providing an input class, an output class, and the repository instance that is overridden. The following implementation is good to go:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c69a\"\u003e// Use-case implementation\u003cbr/\u003eclass GetReposUseCase(repository: RepoRepository):\u003cbr/\u003e    BaseRepositoryUseCase\u0026lt;Boolean,ResultWithFallback\u0026lt;List\u0026lt;DomainRepoEntity\u0026gt;\u0026gt;, RepoRepository\u0026gt;(repository) {\u003cp\u003e        override suspend fun execute(param: Boolean): ResultWithFallback\u0026lt;List\u0026lt;DomainRepoEntity\u0026gt;\u0026gt; =\u003cbr/\u003e        // obtaining and returning result using the repository like repository.getData()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"2aa0\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"a945\"\u003eThus, we’ve explored the optimal approach to using use cases from scratch, capturing client intents. I’ve demonstrated how to implement and use them in a functional manner, making them easy to test and integrate.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-04-10T18:29:34.444Z",
  "modifiedTime": null
}
