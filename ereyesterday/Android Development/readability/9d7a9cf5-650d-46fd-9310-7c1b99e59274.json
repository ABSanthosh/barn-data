{
  "id": "9d7a9cf5-650d-46fd-9310-7c1b99e59274",
  "title": "Exploring LazySuspend in Kotlin: A Thread-Safe Lazy Initialization with Coroutines",
  "link": "https://proandroiddev.com/exploring-lazysuspend-in-kotlin-a-thread-safe-lazy-initialization-with-coroutines-4cf8e18f55ac?source=rss----c72404660798---4",
  "description": "",
  "author": "Leo N",
  "published": "Fri, 07 Feb 2025 21:35:40 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "android-app-development",
    "kotlin",
    "coroutine",
    "androiddev"
  ],
  "byline": "Leo N",
  "length": 10402,
  "excerpt": "In October 2018, a GitHub user proposed introducing a suspending version of Kotlin‚Äôs lazy { ... } function to handle expensive initializations without blocking threads. While lazy effectively defers‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "ü§î Problem StatementIn October 2018, a GitHub user proposed introducing a suspending version of Kotlin‚Äôs lazy { ... } function to handle expensive initializations without blocking threads. While lazy effectively defers initialization until needed, it can still block execution, making it less suitable for coroutine-based, non-blocking applications.To solve this, contributors suggested using async(start = LAZY), allowing initialization to be deferred and executed asynchronously on first access. Several custom coroutine-based implementations emerged to bridge this gap, but despite strong interest, the feature was never integrated into the standard Kotlin library.As of now, the Kotlin standard library does not include a built-in suspending version of the lazy function. The discussion on GitHub Issue #706 concluded without integrating this feature into the library.In the meantime, developers have explored alternative approaches, such as using async with start = CoroutineStart.LAZY or implementing custom suspending lazy mechanisms. However, it's important to note that the use of CoroutineStart.LAZY has been debated within the community. A recent discussion in GitHub Issue #4202 considered discouraging its use due to potential complexities and difficulties in code readability.Given these considerations, if you require suspending lazy initialization, you might opt for a custom implementation tailored to your specific use case. So, how can we implement true non-blocking lazy initialization in coroutines? Let‚Äôs explore some practical solutions. üöÄü§î Problem StatementüéØ Introductionüî• ImplementationüèÜ Conclusionüåê ReferencesüéØ IntroductionLazy initialization is a powerful pattern that delays object creation until it‚Äôs actually needed, improving performance and resource management. But what if you need to initialize a value asynchronously inside Kotlin coroutines? That‚Äôs where LazySuspend comes in! üåüüõ† Why Do We Need LazySuspend?Kotlin provides lazy {} for synchronous lazy initialization, but it does not support suspending functions. Imagine you need to load data from a database or fetch an API response asynchronously. ü§Ø Consider this example:val storageProvider by lazy { initializeStorageProvider() // Cannot be a suspend function üò¢}suspend fun initializeStorageProvider(){ // ... long-running task}This won‚Äôt work if initializeStorageProvider is a suspend function! Instead, we need a coroutine-friendly lazy initialization mechanism. üí°üî• Implementation1Ô∏è‚É£ Approach 1import kotlinx.coroutines.*import kotlin.coroutines.*class LazySuspend\u003cT\u003e(private val initializer: suspend () -\u003e T) { @Volatile private var cachedValue: T? = null private val mutex = Mutex() suspend fun getValue(): T { if (cachedValue != null) return cachedValue!! return mutex.withLock { if (cachedValue == null) { cachedValue = initializer() } cachedValue!! } }}‚úÖ Uses a suspending function for initialization.‚úÖ Uses a mutex (withLock) to ensure thread safety (prevents race conditions in multithreading).‚úÖ Stores the computed value after the first call, so subsequent calls return instantly.suspend fun main() { val lazyValue = LazySuspend { println(\"Initializing...\") delay(1000) // Simulate long computation \"Hello, Coroutine Lazy!\" } println(\"Before accessing value...\") println(\"Value: ${lazyValue.getValue()}\") // Triggers initialization println(\"Value again: ${lazyValue.getValue()}\") // Uses cached value}// outputBefore accessing value...Initializing...Value: Hello, Coroutine Lazy!Value again: Hello, Coroutine Lazy!2Ô∏è‚É£ Approach 2: Deferredclass LazySuspendDeferred\u003cT\u003e(scope: CoroutineScope, initializer: suspend () -\u003e T) { private val deferred = scope.async(start = CoroutineStart.LAZY) { initializer() } suspend fun getValue(): T = deferred.await()}3Ô∏è‚É£ Approach 3: SuspendLazyThis function allows deferred execution of a block of code that is initialized only once in a coroutine, similar to lazy initialization. It ensures thread safety by using a Mutex and provides mechanisms to handle initialization failures and context propagation. The article includes code examples and tests to demonstrate its usage. For further details, visit the original article.https://gist.github.com/nphausg/d5f8a5e49f199dd4903a696052f5f042‚úÖ Deferred Initialization: The initializer function is stored in innerInitializer and only executed when invoke() is called.‚úÖ Thread-Safety: A Mutex ensures only one coroutine initializes the value.‚úÖ Memoization: Once initialized, the value is stored in holder, and innerInitializer is set to null to prevent re-execution.The two implementations (approach 2, approach 3) are similar in that they both deal with lazy initialization in a coroutine context, but they differ in structure:suspendLazy uses an object implementing the SuspendLazy interface, with state management via innerInitializer, mutex, and holder. It checks for initialization and uses a lock to handle initialization safely.LazySuspend encapsulates the initialization in a class, uses a Volatile cached value, and exposes a getValue() function that ensures thread-safe initialization and caching.Both use Mutex for safe initialization but differ in design patterns (object vs. class). If you need more control over lazy initialization with an interface, suspendLazy might be better. For simplicity, LazySuspend is sufficient.4Ô∏è‚É£ Approach 4: LazySuspendThe approach 3 may have some ‚ú® potential improvements?‚úÖ Avoid Unsafe CastsThe code currently casts holder to T, which might cause issues if holder was never properly assigned.Instead, you can use a sealed class or an AtomicReference.üîê Ensuring Thread-Safety with MutexUsing Mutex, we ensure that only one coroutine initializes the value at a time, preventing race conditions. üèéüí®mutex.withLock {} guarantees that the initialization block executes safely in concurrent environments.‚ö†Ô∏è Handling Exceptions GracefullyIf the initializer fails, holder remains Any?, causing an unsafe cast, leading to a ClassCastException. Let's fix this:/** * Sealed class representing the state of a lazily initialized value. * It can either be uninitialized, initialized with a value, or failed due to an exception. * * @param T The type of the value being lazily initialized. */sealed class LazyState\u003cout T\u003e { /** * Represents an uninitialized state. */ data object Uninitialized : LazyState\u003cNothing\u003e() /** * Represents an initialized state holding a value of type [T]. * * @param value The initialized value of type [T]. */ data class Initialized\u003cT\u003e(val value: T) : LazyState\u003cT\u003e() /** * Represents a failed state containing an exception. * * @param exception The exception that occurred during initialization. */ data class Failed(val exception: Throwable) : LazyState\u003cNothing\u003e()}https://gist.github.com/nphausg/d370986b1575b7c75085a6132bc123aeLazyState Sealed Class: This class is used to represent the current state of a value, whether it‚Äôs uninitialized, initialized with a value, or failed due to an exception.LazySuspend Interface: This interface extends a suspending function (suspend () -\u003e T) and adds additional properties and methods:isInitialized: A boolean property to check if the value has been initialized.valueOrNull(): Returns the value if initialized, or null if not.invoke(): The main suspending function to retrieve the lazily initialized value.lazySuspend Function: This function creates an instance of LazySuspend that lazily initializes a value using the provided suspending function (initializer). It uses atomic references for thread-safety and double-checked locking to ensure that the value is initialized only once.This class and function are useful for managing lazily initialized, thread-safe, suspending properties.How can I ensure that the lazySuspend initialization runs on a background thread instead of the main thread in Kotlin?To ensure that the lazySuspend initialization does not run on the main thread, you can explicitly use a different coroutine dispatcher when invoking the suspending function inside the initializer. You can use Dispatchers.IO, Dispatchers.Default, or any custom dispatcher to offload the work to a background thread.Here‚Äôs how you can modify your lazySuspend initialization to run on a background thread:import kotlinx.coroutines.*val lazyValue = lazySuspend { withContext(Dispatchers.IO) { // Ensure this runs on a background thread println(\"Initialized on thread: ${Thread.currentThread().name}\") longRunningTask() // Simulate some background work }}üèÜ ConclusionWhy I choose LazySuspend instead of SuspendLazy?Both LazySuspend and SuspendLazy are reasonable names, but the better choice depends on readability, consistency, and convention.1Ô∏è‚É£ LazySuspend‚úÖ Pros:Matches the existing lazy { ... } function in Kotlin.Emphasizes ‚Äúlazy‚Äù behavior first, making it clear this is an alternative to lazy { ... }.Easier to recognize for Kotlin developers already familiar with lazy.‚ùå Cons:‚ÄúSuspend‚Äù at the end might make it sound like a verb (‚Äúsuspend something lazily‚Äù).2Ô∏è‚É£ SuspendLazy‚úÖ Pros:Follows Kotlin‚Äôs usual order (suspend fun, suspendCoroutine), making it more familiar in coroutine-related naming.Clearly indicates that this is a suspending version of lazy initialization.‚ùå Cons:‚ÄúLazy‚Äù at the end might be less intuitive because lazy {} is a well-known concept in Kotlin, and reversing the order might make it harder to associate.So for me the best Choice isLazySuspend (since it keeps consistency with lazy {} in Kotlin). The LazySuspend provides lazy, suspend-aware initialization while ensuring thread safety and error handling. üöÄ Whether you're fetching API data, caching results, or managing expensive computations, LazySuspend is a powerful tool in your Kotlin arsenal.Give it a try in your next project! üõ†Ô∏è// Step 1: Grab from Maven central at the coordinates:repositories { google() mavenCentral() maven { url = uri(\"https://maven.pkg.github.com/nphausg/loomIn\") }}// Step 2: Implementation from your module$latestVersion = \"0.0.1-alpha\"implementation(\"com.nphausg:loom:$latestVersion\")üåê ReferencesKotlin Coroutines Documentation ‚Äî Kotlinlang.orgMutex in Kotlin Coroutines ‚Äî Kotlin Coroutines GuideLazy Initialization in Kotlin ‚Äî JetBrains BlogAtomicReference in Java ‚Äî Java Documentation",
  "image": "https://miro.medium.com/v2/resize:fit:1019/1*aGYc3X0_UTO4kZT9IJX10g.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://nphausg.medium.com/?source=post_page---byline--4cf8e18f55ac--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Leo N\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*Tb0dILXcghQeKPocCvlv6g.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--4cf8e18f55ac--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"d12f\"\u003eü§î Problem Statement\u003c/h2\u003e\u003cp id=\"c392\"\u003e\u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/issues/706\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eIn October 2018, a GitHub user proposed introducing a \u003cstrong\u003esuspending version\u003c/strong\u003e\u003c/a\u003e of Kotlin‚Äôs \u003ccode\u003elazy { ... }\u003c/code\u003e function to handle expensive initializations \u003cstrong\u003ewithout blocking threads\u003c/strong\u003e. While \u003ccode\u003elazy\u003c/code\u003e effectively defers initialization until needed, it can still \u003cstrong\u003eblock\u003c/strong\u003e execution, making it less suitable for coroutine-based, non-blocking applications.\u003c/p\u003e\u003cp id=\"a4a9\"\u003eTo solve this, contributors suggested using \u003ccode\u003easync(start = LAZY)\u003c/code\u003e, allowing initialization to be deferred and executed \u003cstrong\u003easynchronously\u003c/strong\u003e on first access. Several custom coroutine-based implementations emerged to bridge this gap, but despite strong interest, the feature was \u003cstrong\u003enever integrated\u003c/strong\u003e into the standard Kotlin library.\u003c/p\u003e\u003cp id=\"2149\"\u003eAs of now, the Kotlin standard library \u003cstrong\u003edoes not include a built-in suspending version of the \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003elazy\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e function\u003c/strong\u003e. The discussion on \u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/issues/706\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub Issue #706\u003c/a\u003e concluded without integrating this feature into the library.\u003c/p\u003e\u003cp id=\"7639\"\u003eIn the meantime, developers have explored alternative approaches, such as using \u003ccode\u003easync\u003c/code\u003e with \u003ccode\u003estart = CoroutineStart.LAZY\u003c/code\u003e or implementing custom suspending lazy mechanisms. However, it\u0026#39;s important to note that the use of \u003ccode\u003eCoroutineStart.LAZY\u003c/code\u003e has been debated within the community. A recent discussion in \u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/issues/4202\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub Issue #4202\u003c/a\u003e considered discouraging its use due to potential complexities and difficulties in code readability.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"debb\"\u003e\u003cem\u003eGiven these considerations, if you require suspending lazy initialization, you might opt for a custom implementation tailored to your specific use case. So, how can we implement \u003c/em\u003e\u003cstrong\u003e\u003cem\u003etrue non-blocking lazy initialization\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e in coroutines? Let‚Äôs explore some practical solutions. üöÄ\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cul\u003e\u003cli id=\"7440\"\u003eü§î Problem Statement\u003c/li\u003e\u003cli id=\"b1c0\"\u003eüéØ Introduction\u003c/li\u003e\u003cli id=\"42c2\"\u003eüî• Implementation\u003c/li\u003e\u003cli id=\"3ea8\"\u003eüèÜ Conclusion\u003c/li\u003e\u003cli id=\"793c\"\u003eüåê References\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"25d1\"\u003eüéØ Introduction\u003c/h2\u003e\u003cp id=\"f268\"\u003e\u003cstrong\u003eLazy\u003c/strong\u003e initialization is a powerful pattern that delays object creation until it‚Äôs actually needed, improving performance and resource management. But what if you need to initialize a value \u003cstrong\u003easynchronously\u003c/strong\u003e inside Kotlin coroutines? That‚Äôs where \u003ccode\u003eLazySuspend\u003c/code\u003e comes in! üåü\u003c/p\u003e\u003ch2 id=\"6040\"\u003eüõ† Why Do We Need \u003ccode\u003eLazySuspend\u003c/code\u003e?\u003c/h2\u003e\u003cp id=\"f405\"\u003eKotlin provides \u003ccode\u003elazy {}\u003c/code\u003e for \u003cstrong\u003esynchronous\u003c/strong\u003e lazy initialization, but it does not support suspending functions. Imagine you need to load data from a database or fetch an API response asynchronously. ü§Ø Consider this example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3430\"\u003eval storageProvider by lazy {\u003cbr/\u003e    initializeStorageProvider() // Cannot be a suspend function üò¢\u003cbr/\u003e}\u003cp\u003esuspend fun initializeStorageProvider(){\u003cbr/\u003e   // ... long-running task\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7d64\"\u003eThis won‚Äôt work if \u003ccode\u003einitializeStorageProvider\u003c/code\u003e is a \u003ccode\u003esuspend\u003c/code\u003e function! Instead, we need a coroutine-friendly lazy initialization mechanism. üí°\u003c/p\u003e\u003ch2 id=\"d357\"\u003eüî• Implementation\u003c/h2\u003e\u003ch2 id=\"272c\"\u003e1Ô∏è‚É£ Approach 1\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"104a\"\u003eimport kotlinx.coroutines.*\u003cbr/\u003eimport kotlin.coroutines.*\u003cp\u003eclass LazySuspend\u0026lt;T\u0026gt;(private val initializer: suspend () -\u0026gt; T) {\u003cbr/\u003e    @Volatile\u003cbr/\u003e    private var cachedValue: T? = null\u003cbr/\u003e    private val mutex = Mutex()\u003c/p\u003e\u003cp\u003e    suspend fun getValue(): T {\u003cbr/\u003e        if (cachedValue != null) return cachedValue!!\u003c/p\u003e\u003cp\u003e        return mutex.withLock {\u003cbr/\u003e            if (cachedValue == null) {\u003cbr/\u003e                cachedValue = initializer()\u003cbr/\u003e            }\u003cbr/\u003e            cachedValue!!\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"6345\"\u003e‚úÖ Uses a \u003cstrong\u003esuspending function\u003c/strong\u003e for initialization.\u003c/li\u003e\u003cli id=\"4268\"\u003e‚úÖ Uses a \u003cstrong\u003emutex (\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ewithLock\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e)\u003c/strong\u003e to ensure \u003cstrong\u003ethread safety\u003c/strong\u003e (prevents race conditions in multithreading).\u003c/li\u003e\u003cli id=\"8301\"\u003e‚úÖ Stores the computed value \u003cstrong\u003eafter the first call\u003c/strong\u003e, so subsequent calls \u003cstrong\u003ereturn instantly\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"0469\"\u003esuspend fun main() {\u003cbr/\u003e    val lazyValue = LazySuspend {\u003cbr/\u003e        println(\u0026#34;Initializing...\u0026#34;)\u003cbr/\u003e        delay(1000)  // Simulate long computation\u003cbr/\u003e        \u0026#34;Hello, Coroutine Lazy!\u0026#34;\u003cbr/\u003e    }\u003cp\u003e    println(\u0026#34;Before accessing value...\u0026#34;)\u003cbr/\u003e    println(\u0026#34;Value: ${lazyValue.getValue()}\u0026#34;)  // Triggers initialization\u003cbr/\u003e    println(\u0026#34;Value again: ${lazyValue.getValue()}\u0026#34;)  // Uses cached value\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// output\u003cbr/\u003eBefore accessing value...\u003cbr/\u003eInitializing...\u003cbr/\u003eValue: Hello, Coroutine Lazy!\u003cbr/\u003eValue again: Hello, Coroutine Lazy!\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"5af5\"\u003e2Ô∏è‚É£ Approach 2: Deferred\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"4906\"\u003eclass LazySuspendDeferred\u0026lt;T\u0026gt;(scope: CoroutineScope, initializer: suspend () -\u0026gt; T) {\u003cbr/\u003e    private val deferred = scope.async(start = CoroutineStart.LAZY) { initializer() }\u003cbr/\u003e    suspend fun getValue(): T = deferred.await()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4902\"\u003e3Ô∏è‚É£ Approach 3: SuspendLazy\u003c/h2\u003e\u003cp id=\"44a1\"\u003eThis function allows deferred execution of a block of code that is initialized only once in a coroutine, similar to lazy initialization. It ensures thread safety by using a \u003ccode\u003eMutex\u003c/code\u003e and provides mechanisms to handle initialization failures and context propagation. The article includes code examples and tests to demonstrate its usage. For further details, visit the \u003ca href=\"https://kt.academy/article/s_suspended_lazy\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eoriginal article\u003c/a\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://gist.github.com/nphausg/d5f8a5e49f199dd4903a696052f5f042\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://gist.github.com/nphausg/d5f8a5e49f199dd4903a696052f5f042\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"2fa1\"\u003e‚úÖ \u003cstrong\u003eDeferred Initialization\u003c/strong\u003e: The \u003ccode\u003einitializer\u003c/code\u003e function is stored in \u003ccode\u003einnerInitializer\u003c/code\u003e and only executed when \u003ccode\u003einvoke()\u003c/code\u003e is called.\u003c/li\u003e\u003cli id=\"4333\"\u003e‚úÖ \u003cstrong\u003eThread-Safety\u003c/strong\u003e: A \u003ccode\u003eMutex\u003c/code\u003e ensures only one coroutine initializes the value.\u003c/li\u003e\u003cli id=\"c685\"\u003e‚úÖ \u003cstrong\u003eMemoization\u003c/strong\u003e: Once initialized, the value is stored in \u003ccode\u003eholder\u003c/code\u003e, and \u003ccode\u003einnerInitializer\u003c/code\u003e is set to \u003ccode\u003enull\u003c/code\u003e to prevent re-execution.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"12ae\"\u003eThe two implementations (approach 2, approach 3) are similar in that they both deal with lazy initialization in a coroutine context, but they differ in structure:\u003c/p\u003e\u003col\u003e\u003cli id=\"88e8\"\u003e\u003ccode\u003e\u003cstrong\u003esuspendLazy\u003c/strong\u003e\u003c/code\u003e uses an object implementing the \u003ccode\u003eSuspendLazy\u003c/code\u003e interface, with state management via \u003ccode\u003einnerInitializer\u003c/code\u003e, \u003ccode\u003emutex\u003c/code\u003e, and \u003ccode\u003eholder\u003c/code\u003e. It checks for initialization and uses a lock to handle initialization safely.\u003c/li\u003e\u003cli id=\"265c\"\u003e\u003ccode\u003e\u003cstrong\u003eLazySuspend\u003c/strong\u003e\u003c/code\u003e encapsulates the initialization in a class, uses a \u003ccode\u003eVolatile\u003c/code\u003e cached value, and exposes a \u003ccode\u003egetValue()\u003c/code\u003e function that ensures thread-safe initialization and caching.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"4c02\"\u003eBoth use \u003ccode\u003eMutex\u003c/code\u003e for safe initialization but differ in design patterns (object vs. class). If you need more control over lazy initialization with an interface, \u003ccode\u003esuspendLazy\u003c/code\u003e might be better. For simplicity, \u003ccode\u003eLazySuspend\u003c/code\u003e is sufficient.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e28f\"\u003e4Ô∏è‚É£ Approach 4: LazySuspend\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"be28\"\u003eThe approach 3 may have some ‚ú® potential improvements?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"d361\"\u003e‚úÖ \u003cstrong\u003eAvoid Unsafe Casts\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"d502\"\u003eThe code currently casts \u003ccode\u003eholder\u003c/code\u003e to \u003ccode\u003eT\u003c/code\u003e, which might cause issues if \u003ccode\u003eholder\u003c/code\u003e was never properly assigned.\u003c/li\u003e\u003cli id=\"7aa1\"\u003eInstead, you can use a sealed class or an \u003ccode\u003eAtomicReference\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"0144\"\u003e\u003cstrong\u003eüîê Ensuring Thread-Safety with \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eMutex\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cp id=\"16d1\"\u003eUsing \u003ccode\u003eMutex\u003c/code\u003e, we ensure that \u003cstrong\u003eonly one coroutine initializes the value\u003c/strong\u003e at a time, preventing race conditions. üèéüí®\u003c/p\u003e\u003cul\u003e\u003cli id=\"ddfc\"\u003e\u003ccode\u003emutex.withLock {}\u003c/code\u003e guarantees that the initialization block executes safely in concurrent environments.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ace6\"\u003e\u003cstrong\u003e‚ö†Ô∏è Handling Exceptions Gracefully\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"7c59\"\u003eIf the \u003ccode\u003einitializer\u003c/code\u003e fails, \u003ccode\u003eholder\u003c/code\u003e remains \u003ccode\u003eAny?\u003c/code\u003e, causing an unsafe cast, leading to a \u003cstrong\u003eClassCastException\u003c/strong\u003e. Let\u0026#39;s fix this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8987\"\u003e\u003cbr/\u003e/**\u003cbr/\u003e * Sealed class representing the state of a lazily initialized value.\u003cbr/\u003e * It can either be uninitialized, initialized with a value, or failed due to an exception.\u003cbr/\u003e *\u003cbr/\u003e * @param T The type of the value being lazily initialized.\u003cbr/\u003e */\u003cbr/\u003esealed class LazyState\u0026lt;out T\u0026gt; {\u003cbr/\u003e    /**\u003cbr/\u003e     * Represents an uninitialized state.\u003cbr/\u003e     */\u003cbr/\u003e    data object Uninitialized : LazyState\u0026lt;Nothing\u0026gt;()\u003cp\u003e    /**\u003cbr/\u003e     * Represents an initialized state holding a value of type [T].\u003cbr/\u003e     *\u003cbr/\u003e     * @param value The initialized value of type [T].\u003cbr/\u003e     */\u003cbr/\u003e    data class Initialized\u0026lt;T\u0026gt;(val value: T) : LazyState\u0026lt;T\u0026gt;()\u003c/p\u003e\u003cp\u003e    /**\u003cbr/\u003e     * Represents a failed state containing an exception.\u003cbr/\u003e     *\u003cbr/\u003e     * @param exception The exception that occurred during initialization.\u003cbr/\u003e     */\u003cbr/\u003e    data class Failed(val exception: Throwable) : LazyState\u0026lt;Nothing\u0026gt;()\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://gist.github.com/nphausg/d370986b1575b7c75085a6132bc123ae\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://gist.github.com/nphausg/d370986b1575b7c75085a6132bc123ae\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"8d50\"\u003e\u003ccode\u003e\u003cstrong\u003eLazyState\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e Sealed Class\u003c/strong\u003e: This class is used to represent the current state of a value, whether it‚Äôs uninitialized, initialized with a value, or failed due to an exception.\u003c/li\u003e\u003cli id=\"b39c\"\u003e\u003ccode\u003e\u003cstrong\u003eLazySuspend\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e Interface\u003c/strong\u003e: This interface extends a suspending function (\u003ccode\u003esuspend () -\u0026gt; T\u003c/code\u003e) and adds additional properties and methods:\u003c/li\u003e\u003cli id=\"1c9a\"\u003e\u003ccode\u003eisInitialized\u003c/code\u003e: A boolean property to check if the value has been initialized.\u003c/li\u003e\u003cli id=\"1e43\"\u003e\u003ccode\u003evalueOrNull()\u003c/code\u003e: Returns the value if initialized, or null if not.\u003c/li\u003e\u003cli id=\"2174\"\u003e\u003ccode\u003einvoke()\u003c/code\u003e: The main suspending function to retrieve the lazily initialized value.\u003c/li\u003e\u003cli id=\"bc28\"\u003e\u003ccode\u003e\u003cstrong\u003elazySuspend\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e Function\u003c/strong\u003e: This function creates an instance of \u003ccode\u003eLazySuspend\u003c/code\u003e that lazily initializes a value using the provided suspending function (\u003ccode\u003einitializer\u003c/code\u003e). It uses atomic references for thread-safety and double-checked locking to ensure that the value is initialized only once.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"db9d\"\u003eThis class and function are useful for managing lazily initialized, thread-safe, suspending properties.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"5058\"\u003eHow can I ensure that the \u003ccode\u003elazySuspend\u003c/code\u003e initialization runs on a background thread instead of the main thread in Kotlin?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"3a31\"\u003eTo ensure that the \u003ccode\u003elazySuspend\u003c/code\u003e initialization does not run on the main thread, you can explicitly use a different coroutine dispatcher when invoking the suspending function inside the initializer. You can use \u003ccode\u003eDispatchers.IO\u003c/code\u003e, \u003ccode\u003eDispatchers.Default\u003c/code\u003e, or any custom dispatcher to offload the work to a background thread.\u003c/p\u003e\u003cp id=\"b655\"\u003eHere‚Äôs how you can modify your \u003ccode\u003elazySuspend\u003c/code\u003e initialization to run on a background thread:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bcfa\"\u003eimport kotlinx.coroutines.*\u003cp\u003eval lazyValue = lazySuspend {\u003cbr/\u003e    withContext(Dispatchers.IO) {  // Ensure this runs on a background thread\u003cbr/\u003e        println(\u0026#34;Initialized on thread: ${Thread.currentThread().name}\u0026#34;)\u003cbr/\u003e        longRunningTask()  // Simulate some background work\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"0dd3\"\u003eüèÜ Conclusion\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"30e7\"\u003eWhy I choose \u003cstrong\u003eLazySuspend \u003c/strong\u003einstead of \u003cstrong\u003eSuspendLazy?\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"4cb1\"\u003eBoth \u003cstrong\u003eLazySuspend\u003c/strong\u003e and \u003cstrong\u003eSuspendLazy\u003c/strong\u003e are reasonable names, but the better choice depends on \u003cstrong\u003ereadability, consistency, and convention\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"f78c\"\u003e1Ô∏è‚É£ LazySuspend\u003c/h2\u003e\u003cp id=\"7ebd\"\u003e‚úÖ \u003cstrong\u003ePros:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"78b8\"\u003eMatches the existing \u003ccode\u003elazy { ... }\u003c/code\u003e function in Kotlin.\u003c/li\u003e\u003cli id=\"7a6d\"\u003eEmphasizes ‚Äúlazy‚Äù behavior first, making it clear this is an alternative to \u003ccode\u003elazy { ... }\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"3ac9\"\u003eEasier to recognize for Kotlin developers already familiar with \u003ccode\u003elazy\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"588e\"\u003e‚ùå \u003cstrong\u003eCons:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"8c1d\"\u003e‚ÄúSuspend‚Äù at the end might make it sound like a verb (‚Äúsuspend something lazily‚Äù).\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"baca\"\u003e2Ô∏è‚É£ SuspendLazy\u003c/h2\u003e\u003cp id=\"64b5\"\u003e‚úÖ \u003cstrong\u003ePros:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"21cf\"\u003eFollows Kotlin‚Äôs usual order (\u003ccode\u003esuspend fun\u003c/code\u003e, \u003ccode\u003esuspendCoroutine\u003c/code\u003e), making it more familiar in coroutine-related naming.\u003c/li\u003e\u003cli id=\"0714\"\u003eClearly indicates that this is a \u003cstrong\u003esuspending version\u003c/strong\u003e of lazy initialization.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ee71\"\u003e‚ùå \u003cstrong\u003eCons:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"5403\"\u003e‚ÄúLazy‚Äù at the end might be less intuitive because \u003ccode\u003elazy {}\u003c/code\u003e is a well-known concept in Kotlin, and reversing the order might make it harder to associate.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"0b8e\"\u003eSo for me the b\u003cstrong\u003eest Choice \u003c/strong\u003eis\u003ccode\u003e\u003cstrong\u003eLazySuspend\u003c/strong\u003e\u003c/code\u003e (since it keeps consistency with \u003ccode\u003elazy {}\u003c/code\u003e in Kotlin). The \u003ccode\u003eLazySuspend\u003c/code\u003e provides \u003cstrong\u003elazy, suspend-aware initialization\u003c/strong\u003e while ensuring \u003cstrong\u003ethread safety\u003c/strong\u003e and \u003cstrong\u003eerror handling\u003c/strong\u003e. üöÄ Whether you\u0026#39;re fetching API data, caching results, or managing expensive computations, \u003ccode\u003eLazySuspend\u003c/code\u003e is a \u003cstrong\u003epowerful tool\u003c/strong\u003e in your Kotlin arsenal.\u003c/p\u003e\u003cp id=\"a077\"\u003eGive it a try in your next project! üõ†Ô∏è\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7c5b\"\u003e// Step 1: Grab from Maven central at the coordinates:\u003cp\u003erepositories {\u003cbr/\u003e  google()\u003cbr/\u003e  mavenCentral()\u003cbr/\u003e  maven {\u003cbr/\u003e    url = uri(\u0026#34;https://maven.pkg.github.com/nphausg/loomIn\u0026#34;)\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Step 2: Implementation from your module\u003cbr/\u003e$latestVersion = \u0026#34;0.0.1-alpha\u0026#34;\u003cbr/\u003eimplementation(\u0026#34;com.nphausg:loom:$latestVersion\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4544\"\u003eüåê References\u003c/h2\u003e\u003cul\u003e\u003cli id=\"73f8\"\u003eKotlin Coroutines Documentation ‚Äî Kotlinlang.org\u003c/li\u003e\u003cli id=\"ef79\"\u003eMutex in Kotlin Coroutines ‚Äî Kotlin Coroutines Guide\u003c/li\u003e\u003cli id=\"48e0\"\u003eLazy Initialization in Kotlin ‚Äî \u003ca href=\"https://blog.jetbrains.com/kotlin/2020/06/idiomatic-kotlin-lazy-initialization/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetBrains Blog\u003c/a\u003e\u003c/li\u003e\u003cli id=\"5d0c\"\u003eAtomicReference in Java ‚Äî \u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJava Documentation\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-02-07T21:35:39.921Z",
  "modifiedTime": null
}
