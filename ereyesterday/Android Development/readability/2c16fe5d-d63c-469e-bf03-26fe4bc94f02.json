{
  "id": "2c16fe5d-d63c-469e-bf03-26fe4bc94f02",
  "title": "Room in Kotlin Multiplatform (KMP) with Koin",
  "link": "https://proandroiddev.com/room-in-kotlin-multiplatform-kmp-with-koin-d7716bdd8783?source=rss----c72404660798---4",
  "description": "",
  "author": "Harry",
  "published": "Fri, 07 Feb 2025 21:37:34 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin-multiplatform",
    "android-app-development",
    "androiddev",
    "android",
    "compose-multiplatform"
  ],
  "byline": "Harry",
  "length": 7464,
  "excerpt": "In this article, weâ€™ll explore the recommended approach for implementing Room in Kotlin Multiplatform (KMP) with Koin",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Photo by Andreas GÃ¼cklhorn on UnsplashIn this article, weâ€™ll explore the recommended approach for implementing Room in Kotlin Multiplatform (KMP) with Koin for dependency injection and the motivations behind each decision.To visualise the Room implementation, weâ€™ll build a screen using Compose Multiplatform (CMP) and launch the app on Android and iOS.Getting startedTo begin, we add the required dependencies to our libs.versions.toml file.We then use these dependencies in our build.gradle.kts file, alongside using the Room plugin to declare the database schema directory.Room setupIn common code, we create an entity to define the structure of the database table. In this article, weâ€™re storing a list of movies.Next, we set up a MovieDao to interact with the database. Using Flow makes the movie list reactive, and suspend functions ensure we donâ€™t block the UI thread during database operations.Still in common code, we create an abstract class that extends RoomDatabase and incorporates the entity and DAO. We also define a database constructor and link this to the database using the @ConstructedBy annotation.The Room compiler will generate the actual implementations of the database constructor for us, so we add a @Suppress annotation to ignore any warnings related to this.Database builderThe database requires a builder, and this is the only component in Room for KMP that requires platform-specific logic.In androidMain, we create a function that takes in an Android Context to define a database path and uses this to return a database builder.Similarly, in iosMain we create a function that uses NSFileManager and NSDocumentDirectory to define a database path and return a database builder.Database creationBack in commonMain, we define a function that takes in the platform-specific database builders and creates the database. For the database driver, we use the BundledSQLiteDriver â€” this is the recommended driver for Room KMP as it provides the most consistent and up-to-date version of SQLite across all platforms. The BundledSQLiteDriver also has the benefit of being usable in common code, which means we donâ€™t have to specify a driver for each platform.We also configure the database to use Dispatchers.IO for executing asynchronous queries, which is the recommended Dispatcher for database IO operations and ensures the queries wonâ€™t block the UI thread.Koin setupThe final part of this Room KMP setup is using Koin to tie everything together. To start, we create a commonModule in commonMain to manage shared dependencies.For platform-specific dependencies, we create a platformModule in commonMain using the expect / actual mechanism.We implement this platformModule in androidMain using a provided Context value to create the database.Implementing the platformModule in iosMain is simpler since it does not require a Context value.Initialising KoinNext, we define functions to initialise Koin on both platforms in our common code. As seen above, our Android platformModule requires a Context for the database builder. To provide this, we add a KoinAppDeclaration parameter to our initKoin function. We use this inside the startKoin function, which gives Koin modules access to the Context value.We then create a new class in androidMain that extends Application and calls the initKoin function, passing the Android Context in.To use this new MainApplication class, we are required to update the AndroidManifest.xml file.Now we can define a function to initialise Koin for iOS, which doesnâ€™t require a Context value. We encounter a quirk in KMP here, as function default values do not work in native iOS code, so we canâ€™t simply call the initKoin function. To solve this, we define an initKoinIos function that passes in an empty lambda value for the appDeclaration parameter.The initKoinIos function has to be called in native Swift code. To do this, we use the file name of the function and the function name with the do value prepended. We also import ComposeApp to give the Swift code access to the function.Complete RoomThatâ€™s it! We can now inject the MovieDao in common code, giving us access to our Room database on both platforms.Crafting a UITo visualise the Room implementation, weâ€™ll build a movie list screen using Compose Multiplatform and launch the app on both Android and iOS, all within our common code.We start by defining a MovieUiState for the screen, which holds a movie name the user can enter, and a list of movies to display. For the movie name, we use the recommended TextFieldValue instead of a simple String value.Next, we create a MovieViewModel and inject our MovieDao in. The MovieDao is injected straight into the ViewModel here to keep things simple for this article. In production code, the app layering would be more robust, and the MovieDao would be injected into a repository or a data source.We also add a private MutableStateFlow backing field to store the movie name value.State productionTo produce the UI state, we combine the Flow list of movies with the MutableStateFlow movie name field.The stateIn operator is the recommended way to produce UI state from reactive streams. A key reason for this is because it allows state production to start only when collection begins in the UI, instead of occurring as soon as the ViewModel is created if the init{} function is used. This gives you more control over the ViewModel and uiState, making it easier to test.The stateIn operator also gives us finer-grained control over the state production behaviour through the started parameter. This can be set to either SharingStarted.WhileSubscribed if the state should only be active when the UI is visible, or SharingStarted.Lazily if the state should be active as long as the user may return to the UI.Finalising the ViewModelTo complete the ViewModel, we provide three functions to update the state.We also add the ViewModel to our Koin commonModule, allowing us to inject it into our screen.Movie screenWith the ViewModel set up, the next step is to create the screen. It is recommended practice to create both a stateful and a stateless version of each screen in your app, as it makes them more reusable, easier to test, and simpler to preview.We first create the stateful screen by injecting the ViewModel using Koin and collecting the UI state. We then pass the UI state and the state updating functions into the stateless screen.We then create the stateless screen, using a Scaffold to ensure proper inset padding.Inside the Column, we add two Composables that enable the user to add a movie to the Room database.To display the movies, we define a MovieItem and use this within a LazyColumn to create a scrollable list of movies.To clear the movies list, we create a button and hook this up to the onDeleteMovies function.To make the MovieScreen reachable within the app, we simply add it to the base App Composable. In a production app, you would instead integrate this MovieScreen into your existing navigation logic.App deploymentWe can now deploy the finished app to both platforms, starting with Android.Running the app on iOS produces the same behaviour, and validates that the Room implementation is functioning correctly on both platforms! ðŸŽ‰ConclusionThat wraps up this article â€” I hope it has given you a better understanding of how to use Room in Kotlin Multiplatform with Koin.You can find my app projects on GitHub â€” feel free to reach out with any questions or feedback.Happy coding!",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*AqbaidgCIsZmKZM8",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@shorthousedev?source=post_page---byline--d7716bdd8783--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Harry\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*BlxifvY-Eh8iZ0gevvJKXA.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--d7716bdd8783--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@draufsicht?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndreas GÃ¼cklhorn\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ea3d\"\u003eIn this article, weâ€™ll explore the recommended approach for implementing Room in Kotlin Multiplatform (KMP) with Koin for dependency injection and the motivations behind each decision.\u003c/p\u003e\u003cp id=\"ef27\"\u003eTo visualise the Room implementation, weâ€™ll build a screen using Compose Multiplatform (CMP) and launch the app on Android and iOS.\u003c/p\u003e\u003ch2 id=\"0996\"\u003eGetting started\u003c/h2\u003e\u003cp id=\"7324\"\u003eTo begin, we add the required dependencies to our \u003ccode\u003elibs.versions.toml\u003c/code\u003e file.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9c81\"\u003eWe then use these dependencies in our \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e file, alongside using the Room plugin to declare the database schema directory.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"2675\"\u003eRoom setup\u003c/h2\u003e\u003cp id=\"dfb4\"\u003eIn common code, we create an entity to define the structure of the database table. In this article, weâ€™re storing a list of movies.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5356\"\u003eNext, we set up a \u003ccode\u003eMovieDao\u003c/code\u003e to interact with the database. Using \u003ccode\u003eFlow\u003c/code\u003e makes the movie list reactive, and \u003ccode\u003esuspend\u003c/code\u003e functions ensure we donâ€™t block the UI thread during database operations.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"94d8\"\u003eStill in common code, we create an \u003ccode\u003eabstract\u003c/code\u003e class that extends \u003ccode\u003eRoomDatabase\u003c/code\u003e and incorporates the entity and DAO. We also define a database constructor and link this to the database using the \u003ccode\u003e@ConstructedBy\u003c/code\u003e annotation.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"077b\"\u003eThe Room compiler will generate the \u003ccode\u003eactual\u003c/code\u003e implementations of the database constructor for us, so we add a \u003ccode\u003e@Suppress\u003c/code\u003e annotation to ignore any warnings related to this.\u003c/p\u003e\u003ch2 id=\"e46f\"\u003eDatabase builder\u003c/h2\u003e\u003cp id=\"00a6\"\u003eThe database requires a builder, and this is the only component in Room for KMP that requires platform-specific logic.\u003c/p\u003e\u003cp id=\"f4f3\"\u003eIn \u003ccode\u003eandroidMain\u003c/code\u003e, we create a function that takes in an Android \u003ccode\u003eContext\u003c/code\u003e to define a database path and uses this to return a database builder.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"91d4\"\u003eSimilarly, in \u003ccode\u003eiosMain\u003c/code\u003e we create a function that uses \u003ccode\u003eNSFileManager\u003c/code\u003e and \u003ccode\u003eNSDocumentDirectory\u003c/code\u003e to define a database path and return a database builder.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"3d8d\"\u003eDatabase creation\u003c/h2\u003e\u003cp id=\"1a54\"\u003eBack in \u003ccode\u003ecommonMain\u003c/code\u003e, we define a function that takes in the platform-specific database builders and creates the database. For the database driver, we use the \u003ccode\u003eBundledSQLiteDriver\u003c/code\u003e â€” this is the \u003ca href=\"https://developer.android.com/kotlin/multiplatform/room#database-instantiation\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003erecommended \u003c/a\u003edriver for Room KMP as it provides the most consistent and up-to-date version of SQLite across all platforms. The \u003ccode\u003eBundledSQLiteDriver\u003c/code\u003e also has the benefit of being usable in common code, which means we donâ€™t have to specify a driver for each platform.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2af9\"\u003eWe also configure the database to use \u003ccode\u003eDispatchers.IO\u003c/code\u003e for executing asynchronous queries, which is the \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003erecommended\u003c/a\u003e \u003ccode\u003eDispatcher\u003c/code\u003e for database IO operations and ensures the queries wonâ€™t block the UI thread.\u003c/p\u003e\u003ch2 id=\"1697\"\u003eKoin setup\u003c/h2\u003e\u003cp id=\"b2e4\"\u003eThe final part of this Room KMP setup is using Koin to tie everything together. To start, we create a \u003ccode\u003ecommonModule\u003c/code\u003e in \u003ccode\u003ecommonMain\u003c/code\u003e to manage shared dependencies.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"78cc\"\u003eFor platform-specific dependencies, we create a \u003ccode\u003eplatformModule\u003c/code\u003e in \u003ccode\u003ecommonMain\u003c/code\u003e using the \u003ccode\u003eexpect\u003c/code\u003e / \u003ccode\u003eactual\u003c/code\u003e mechanism.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5237\"\u003eWe implement this \u003ccode\u003eplatformModule\u003c/code\u003e in \u003ccode\u003eandroidMain\u003c/code\u003e using a provided \u003ccode\u003eContext\u003c/code\u003e value to create the database.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2604\"\u003eImplementing the \u003ccode\u003eplatformModule\u003c/code\u003e in \u003ccode\u003eiosMain\u003c/code\u003e is simpler since it does not require a \u003ccode\u003eContext\u003c/code\u003e value.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"7e6a\"\u003eInitialising Koin\u003c/h2\u003e\u003cp id=\"567d\"\u003eNext, we define functions to initialise Koin on both platforms in our common code. As seen above, our Android \u003ccode\u003eplatformModule\u003c/code\u003e requires a \u003ccode\u003eContext\u003c/code\u003e for the database builder. To provide this, we add a \u003ccode\u003eKoinAppDeclaration\u003c/code\u003e parameter to our \u003ccode\u003einitKoin\u003c/code\u003e function. We use this inside the \u003ccode\u003estartKoin\u003c/code\u003e function, which gives Koin modules access to the \u003ccode\u003eContext\u003c/code\u003e value.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3ca6\"\u003eWe then create a new class in \u003ccode\u003eandroidMain\u003c/code\u003e that extends \u003ccode\u003eApplication\u003c/code\u003e and calls the \u003ccode\u003einitKoin\u003c/code\u003e function, passing the Android \u003ccode\u003eContext\u003c/code\u003e in.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e416\"\u003eTo use this new \u003ccode\u003eMainApplication\u003c/code\u003e class, we are required to update the \u003ccode\u003eAndroidManifest.xml\u003c/code\u003e file.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"452b\"\u003eNow we can define a function to initialise Koin for iOS, which doesnâ€™t require a \u003ccode\u003eContext\u003c/code\u003e value. We encounter a quirk in KMP here, as function default values do not work in native iOS code, so we canâ€™t simply call the \u003ccode\u003einitKoin\u003c/code\u003e function. To solve this, we define an \u003ccode\u003einitKoinIos\u003c/code\u003e function that passes in an empty lambda value for the \u003ccode\u003eappDeclaration\u003c/code\u003e parameter.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"6c1d\"\u003eThe \u003ccode\u003einitKoinIos\u003c/code\u003e function has to be called in native Swift code. To do this, we use the file name of the function and the function name with the \u003ccode\u003edo\u003c/code\u003e value prepended. We also import \u003ccode\u003eComposeApp\u003c/code\u003e to give the Swift code access to the function.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"b0f8\"\u003eComplete Room\u003c/h2\u003e\u003cp id=\"c8a8\"\u003eThatâ€™s it! We can now inject the \u003ccode\u003eMovieDao\u003c/code\u003e in common code, giving us access to our Room database on both platforms.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"bd3f\"\u003eCrafting a UI\u003c/h2\u003e\u003cp id=\"c73b\"\u003eTo visualise the Room implementation, weâ€™ll build a movie list screen using Compose Multiplatform and launch the app on both Android and iOS, all within our common code.\u003c/p\u003e\u003cp id=\"9959\"\u003eWe start by defining a \u003ccode\u003eMovieUiState\u003c/code\u003e for the screen, which holds a movie name the user can enter, and a list of movies to display. For the movie name, we use the \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/basictextfield2-a-textfield-of-dreams-1-2-0103fd7cc0ec\"\u003erecommended\u003c/a\u003e \u003ccode\u003eTextFieldValue\u003c/code\u003e instead of a simple \u003ccode\u003eString\u003c/code\u003e value.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7f80\"\u003eNext, we create a \u003ccode\u003eMovieViewModel\u003c/code\u003e and inject our \u003ccode\u003eMovieDao\u003c/code\u003e in. The \u003ccode\u003eMovieDao\u003c/code\u003e is injected straight into the \u003ccode\u003eViewModel\u003c/code\u003e here to keep things simple for this article. In production code, the app layering would be more robust, and the \u003ccode\u003eMovieDao\u003c/code\u003e would be injected into a repository or a data source.\u003c/p\u003e\u003cp id=\"2907\"\u003eWe also add a private \u003ccode\u003eMutableStateFlow\u003c/code\u003e backing field to store the movie name value.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"a3cf\"\u003eState production\u003c/h2\u003e\u003cp id=\"5405\"\u003eTo produce the UI state, we combine the \u003ccode\u003eFlow\u003c/code\u003e list of movies with the \u003ccode\u003eMutableStateFlow\u003c/code\u003e movie name field.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2157\"\u003eThe \u003ccode\u003estateIn\u003c/code\u003e operator is the \u003ca href=\"https://developer.android.com/topic/architecture/ui-layer/state-production#stream-apis\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003erecommended\u003c/a\u003e way to produce UI state from reactive streams. A key reason for this is because it allows state production to start only when collection begins in the UI, instead of occurring as soon as the \u003ccode\u003eViewModel\u003c/code\u003e is created if the \u003ccode\u003einit{}\u003c/code\u003e function is used. This gives you more control over the \u003ccode\u003eViewModel\u003c/code\u003e and \u003ccode\u003euiState\u003c/code\u003e, making it easier to test.\u003c/p\u003e\u003cp id=\"3f70\"\u003eThe \u003ccode\u003estateIn\u003c/code\u003e operator also gives us finer-grained control over the state production behaviour through the \u003ccode\u003estarted\u003c/code\u003e parameter. This can be set to either \u003ccode\u003eSharingStarted.WhileSubscribed\u003c/code\u003e if the state should only be active when the UI is visible, or \u003ccode\u003eSharingStarted.Lazily\u003c/code\u003e if the state should be active as long as the user may return to the UI.\u003c/p\u003e\u003ch2 id=\"f22f\"\u003eFinalising the ViewModel\u003c/h2\u003e\u003cp id=\"c9b0\"\u003eTo complete the \u003ccode\u003eViewModel\u003c/code\u003e, we provide three functions to update the state.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b336\"\u003eWe also add the \u003ccode\u003eViewModel\u003c/code\u003e to our Koin \u003ccode\u003ecommonModule\u003c/code\u003e, allowing us to inject it into our screen.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"3981\"\u003eMovie screen\u003c/h2\u003e\u003cp id=\"25fe\"\u003eWith the \u003ccode\u003eViewModel\u003c/code\u003e set up, the next step is to create the screen. It is \u003ca href=\"https://developer.android.com/jetpack/compose/state#stateful-vs-stateless\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003erecommended practice\u003c/a\u003e to create both a \u003cem\u003estateful\u003c/em\u003e and a \u003cem\u003estateless\u003c/em\u003e version of each screen in your app, as it makes them more reusable, easier to test, and simpler to preview.\u003c/p\u003e\u003cp id=\"b61e\"\u003eWe first create the \u003cem\u003estateful\u003c/em\u003e screen by injecting the \u003ccode\u003eViewModel\u003c/code\u003e using Koin and collecting the UI state. We then pass the UI state and the state updating functions into the \u003cem\u003estateless\u003c/em\u003e screen.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"09ce\"\u003eWe then create the \u003cem\u003estateless\u003c/em\u003e screen, using a \u003ccode\u003eScaffold\u003c/code\u003e to ensure proper inset padding.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b6f4\"\u003eInside the \u003ccode\u003eColumn\u003c/code\u003e, we add two Composables that enable the user to add a movie to the Room database.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ff90\"\u003eTo display the movies, we define a \u003ccode\u003eMovieItem\u003c/code\u003e and use this within a \u003ccode\u003eLazyColumn\u003c/code\u003e to create a scrollable list of movies.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"65bc\"\u003eTo clear the movies list, we create a button and hook this up to the \u003ccode\u003eonDeleteMovies\u003c/code\u003e function.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5575\"\u003eTo make the \u003ccode\u003eMovieScreen\u003c/code\u003e reachable within the app, we simply add it to the base \u003ccode\u003eApp\u003c/code\u003e Composable. In a production app, you would instead integrate this \u003ccode\u003eMovieScreen\u003c/code\u003e into your existing navigation logic.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"0c14\"\u003eApp deployment\u003c/h2\u003e\u003cp id=\"3f4a\"\u003eWe can now deploy the finished app to both platforms, starting with Android.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"df16\"\u003eRunning the app on iOS produces the same behaviour, and validates that the Room implementation is functioning correctly on both platforms! ðŸŽ‰\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"0b74\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"4522\"\u003eThat wraps up this article â€” I hope it has given you a better understanding of how to use Room in Kotlin Multiplatform with Koin.\u003c/p\u003e\u003cp id=\"79a2\"\u003eYou can find my app projects on \u003ca href=\"https://github.com/shorthouse\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub\u003c/a\u003e â€” feel free to reach out with any questions or feedback.\u003c/p\u003e\u003cp id=\"1a20\"\u003eHappy coding!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-02-07T18:59:13.625Z",
  "modifiedTime": null
}
