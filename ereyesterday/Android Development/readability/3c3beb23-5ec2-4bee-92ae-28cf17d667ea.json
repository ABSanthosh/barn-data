{
  "id": "3c3beb23-5ec2-4bee-92ae-28cf17d667ea",
  "title": "Swipeable Image Carousel with Smooth Animations in Jetpack Compose",
  "link": "https://proandroiddev.com/swipeable-image-carousel-with-smooth-animations-in-jetpack-compose-76eacdc89bfb?source=rss----c72404660798---4",
  "description": "",
  "author": "Sahil Thakar",
  "published": "Thu, 13 Mar 2025 23:57:36 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "ios",
    "android",
    "android-development",
    "jetpack-compose",
    "java"
  ],
  "byline": "Sahil Thakar",
  "length": 8513,
  "excerpt": "To ensure that Page2 is partially visible alongside Page1, and both Page1 and Page3 are partially visible with Page2, we need to use contentPadding. Let‚Äôs add it and observe the result. What‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Hello Folks,Jetpack Compose is seriously taking over, and it‚Äôs only getting bigger! Today, we‚Äôre about to create something awesome ‚Äî our own Swipeable Image Carousel using Horizontal Pager in Compose. Cool, right?Let‚Äôs jump in and design this whole thing from the ground up! üî•How are we going to do that?Alright, let‚Äôs get into it!@Composablefun ImageCarousel( modifier: Modifier = Modifier) { val imageList = listOf( R.drawable.image_banner_1, R.drawable.image_banner_2, R.drawable.image_banner_3, R.drawable.image_banner_4 ) val pagerState = rememberPagerState { imageList.size } Column( modifier .defaultMinSize(minHeight = 300.dp) .fillMaxWidth() ) { HorizontalPager( state = pagerState, modifier = Modifier.fillMaxWidth(), ) { page -\u003e Image( painter = painterResource(id = imageList[page]), contentDescription = \"\", modifier = Modifier .fillMaxWidth() .height(100.dp), contentScale = ContentScale.Crop ) } }}Here, the Output is a simple, swipable image corousel, which many people might know already.To ensure that Page2 is partially visible alongside Page1, and both Page1 and Page3 are partially visible with Page2, we need to use contentPadding. Let‚Äôs add it and observe the result.@Composablefun ImageCarousel( modifier: Modifier = Modifier) { val imageList = listOf( R.drawable.image_banner_1, R.drawable.image_banner_2, R.drawable.image_banner_3, R.drawable.image_banner_4 ) val pagerState = rememberPagerState { imageList.size } Column( modifier .defaultMinSize(minHeight = 300.dp) .fillMaxWidth() ) { HorizontalPager( state = pagerState, modifier = Modifier.fillMaxWidth(), contentPadding = PaddingValues(horizontal = 30.dp) ) { page -\u003e Image( painter = painterResource(id = imageList[page]), contentDescription = \"\", modifier = Modifier .fillMaxWidth() .height(100.dp), contentScale = ContentScale.Crop ) } }}Output:-What contentPadding does: In a HorizontalPager, contentPadding adds extra space to the left and right edges of the content area. With PaddingValues(horizontal = 100.dp), you‚Äôre adding:100dp of padding to the left of the first page.100dp of padding to the right of the last page.Impact on Layout: This padding shifts the entire content inward, meaning the first page doesn‚Äôt start at the left edge of the screen, and the last page doesn‚Äôt end at the right edge. As a result, when one page is centered, the pages on either side can become partially visible within the screen bounds.Now, we also need to add spacing between the two cards. How can we achieve this?We‚Äôll use pageSpacing to accomplish this. @Composablefun ImageCarousel( modifier: Modifier = Modifier) { val imageList = listOf( R.drawable.image_banner_1, R.drawable.image_banner_2, R.drawable.image_banner_3, R.drawable.image_banner_4 ) val pagerState = rememberPagerState { imageList.size } Column( modifier .defaultMinSize(minHeight = 300.dp) .fillMaxWidth() ) { HorizontalPager( state = pagerState, modifier = Modifier.fillMaxWidth(), pageSpacing = 10.dp, contentPadding = PaddingValues(horizontal = 30.dp) ) { page -\u003e Image( painter = painterResource(id = imageList[page]), contentDescription = \"\", modifier = Modifier .fillMaxWidth() .height(100.dp), contentScale = ContentScale.Crop ) } }}Output:-We‚Äôre very close to achieving the desired behavior! But before moving forward, let‚Äôs take a moment to understand what this is and how it has helped us so far.What it does: pageSpacing defines the gap (or spacing) between consecutive pages in the HorizontalPager.Effect: This means there will be a horizontal gap of 70 density-independent pixels (dp) between the edges of one page‚Äôs content (the Image) and the next page‚Äôs content.How it helps:Visual Separation: The 70dp spacing ensures that images don‚Äôt feel cramped or overlap as the user scrolls through the pager. It gives each image its own ‚Äúbreathing room,‚Äù making the UI cleaner and easier to navigate.Focus on the Current Page: Combined with the scaling effect from lerp, this spacing emphasizes the centered image (which scales to 100.dp) while pushing adjacent images further apart, reducing visual clutter.Smooth Scrolling: The spacing contributes to a natural scrolling feel, as pages aren‚Äôt too tightly packed, allowing the user to distinguish between them during transitions.Now, for the final touch! We want to add animation when moving from left to right, ensuring that partially visible images scale down compared to the centered image.To achieve this, we‚Äôll manipulate the image itself rather than HorizontalPager. We'll use graphicsLayer and lerp to create the desired effect.@OptIn(ExperimentalFoundationApi::class)@Composablefun ImageCarousel( modifier: Modifier = Modifier) { val imageList = listOf( R.drawable.image_banner_1, R.drawable.image_banner_2, R.drawable.image_banner_3, R.drawable.image_banner_4 ) val pagerState = rememberPagerState { imageList.size } Column( modifier .defaultMinSize(minHeight = 300.dp) .fillMaxWidth() ) { HorizontalPager( state = pagerState, modifier = Modifier.fillMaxWidth(), pageSpacing = 10.dp, contentPadding = PaddingValues(horizontal = 30.dp) ) { page -\u003e Image( painter = painterResource(id = imageList[page]), contentDescription = \"\", modifier = Modifier .fillMaxWidth() .height(100.dp) .graphicsLayer { val pageOffset = (pagerState.currentPage - page + pagerState.currentPageOffsetFraction).absoluteValue lerp( start = 75.dp, stop = 100.dp, fraction = 1f - pageOffset.coerceIn(0f, 1f) ).also { scale -\u003e scaleY = scale / 100.dp } }, contentScale = ContentScale.Crop ) } }}In the context of your code snippet, lerp stands for linear interpolation. It‚Äôs a mathematical function commonly used in graphics, animations, and UI programming to smoothly transition between two values based on a fraction or percentage.Definition of lerpLinear interpolation calculates an intermediate value between a start and a stop value, based on a fraction (typically a value between 0 and 1). The formula is:lerp(start, stop, fraction) = start + (stop - start) * fractionWhen fraction = 0, the result is start.When the fraction = 1, the result is stop.When the fraction is between 0 and 1, the result is a value proportionally between start and stop.lerp( start = 75.dp, stop = 100.dp, fraction = 1f - pageOffset.coerceIn(0f, 1f)).also { scale -\u003e scaleY = scale / 100.dp}start = 75.dp: The minimum scale value (75 density-independent pixels).stop = 100.dp: The maximum scale value (100 density-independent pixels).fraction = 1f ‚Äî pageOffset.coerceIn(0f, 1f):pageOffset represents how far the current page is from being fully centered in the HorizontalPager. It‚Äôs a value that can range beyond 0 to 1, but coerceIn(0f, 1f) clamps it to the range [0, 1].1f ‚Äî pageOffset inverts this value, so when the page is fully centered (pageOffset = 0), the fraction is 1, and when the page is fully off-screen (pageOffset = 1), the fraction is 0.lerp Result: The result is a smooth transition between 75.dp and 100.dp. For example:If fraction = 1 (page centered), the result is 100.dp.If fraction = 0 (page fully offset), the result is 75.dp.If fraction = 0.5 (halfway), the result is 87.5.dp.If you have any questions, just drop a comment, and I‚Äôll get back to you ASAP. We‚Äôll dive deeper into Jetpack Compose soon. Until then, happy coding!",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:798/1*QmRDZjEsfrKCAyl9T41lWg.gif",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://codeint.medium.com/?source=post_page---byline--76eacdc89bfb---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Sahil Thakar\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*KdqqwZdYVTnxCt2BVb2eqQ.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--76eacdc89bfb---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"89fa\"\u003eHello Folks,\u003c/h2\u003e\u003cul\u003e\u003cli id=\"99c8\"\u003eJetpack Compose is seriously taking over, and it‚Äôs only getting bigger! Today, we‚Äôre about to create something awesome ‚Äî our own Swipeable Image Carousel using Horizontal Pager in Compose. Cool, right?\u003c/li\u003e\u003cli id=\"a0ef\"\u003eLet‚Äôs jump in and design this whole thing from the ground up! üî•How are we going to do that?\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4f11\"\u003eAlright, let‚Äôs get into it!\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cpre\u003e\u003cspan id=\"854c\"\u003e@Composable\u003cbr/\u003efun ImageCarousel(\u003cbr/\u003e    modifier: Modifier = Modifier\u003cbr/\u003e) {\u003cbr/\u003e    val imageList = listOf(\u003cbr/\u003e        R.drawable.image_banner_1,\u003cbr/\u003e        R.drawable.image_banner_2,\u003cbr/\u003e        R.drawable.image_banner_3,\u003cbr/\u003e        R.drawable.image_banner_4\u003cbr/\u003e    )\u003cp\u003e    val pagerState = rememberPagerState { imageList.size }\u003c/p\u003e\u003cp\u003e    Column(\u003cbr/\u003e        modifier\u003cbr/\u003e            .defaultMinSize(minHeight = 300.dp)\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e    ) {\u003c/p\u003e\u003cp\u003e        HorizontalPager(\u003cbr/\u003e            state = pagerState,\u003cbr/\u003e            modifier = Modifier.fillMaxWidth(),\u003cbr/\u003e        ) { page -\u0026gt;\u003cbr/\u003e            Image(\u003cbr/\u003e                painter = painterResource(id = imageList[page]),\u003cbr/\u003e                contentDescription = \u0026#34;\u0026#34;,\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .height(100.dp),\u003cbr/\u003e                contentScale = ContentScale.Crop\u003cbr/\u003e            )\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e    }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4f91\"\u003eHere, the Output is a simple, swipable image corousel, which many people might know already.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"031d\"\u003eTo ensure that Page2 is partially visible alongside Page1, and both Page1 and Page3 are partially visible with Page2, we need to use \u003ccode\u003econtentPadding\u003c/code\u003e. Let‚Äôs add it and observe the result.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dda5\"\u003e@Composable\u003cbr/\u003efun ImageCarousel(\u003cbr/\u003e    modifier: Modifier = Modifier\u003cbr/\u003e) {\u003cbr/\u003e    val imageList = listOf(\u003cbr/\u003e        R.drawable.image_banner_1,\u003cbr/\u003e        R.drawable.image_banner_2,\u003cbr/\u003e        R.drawable.image_banner_3,\u003cbr/\u003e        R.drawable.image_banner_4\u003cbr/\u003e    )\u003cp\u003e    val pagerState = rememberPagerState { imageList.size }\u003c/p\u003e\u003cp\u003e    Column(\u003cbr/\u003e        modifier\u003cbr/\u003e            .defaultMinSize(minHeight = 300.dp)\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e    ) {\u003c/p\u003e\u003cp\u003e        HorizontalPager(\u003cbr/\u003e            state = pagerState,\u003cbr/\u003e            modifier = Modifier.fillMaxWidth(),\u003cbr/\u003e            contentPadding = PaddingValues(horizontal = 30.dp)\u003cbr/\u003e        ) { page -\u0026gt;\u003cbr/\u003e            Image(\u003cbr/\u003e                painter = painterResource(id = imageList[page]),\u003cbr/\u003e                contentDescription = \u0026#34;\u0026#34;,\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .height(100.dp),\u003cbr/\u003e                contentScale = ContentScale.Crop\u003cbr/\u003e            )\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e    }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6a19\"\u003eOutput:-\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5abd\"\u003e\u003cstrong\u003eWhat contentPadding does\u003c/strong\u003e: In a HorizontalPager, contentPadding adds extra space to the left and right edges of the content area. With PaddingValues(horizontal = 100.dp), you‚Äôre adding:\u003c/p\u003e\u003cul\u003e\u003cli id=\"ed02\"\u003e100dp of padding to the \u003cem\u003eleft\u003c/em\u003e of the first page.\u003c/li\u003e\u003cli id=\"9d35\"\u003e100dp of padding to the \u003cem\u003eright\u003c/em\u003e of the last page.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2676\"\u003e\u003cstrong\u003eImpact on Layout\u003c/strong\u003e: This padding shifts the entire content inward, meaning the first page doesn‚Äôt start at the left edge of the screen, and the last page doesn‚Äôt end at the right edge. As a result, when one page is centered, the pages on either side can become partially visible within the screen bounds.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"1262\"\u003eNow, we also need to add spacing between the two cards. How can we achieve this?\u003c/p\u003e\u003cp id=\"0605\"\u003eWe‚Äôll use \u003ccode\u003epageSpacing\u003c/code\u003e to accomplish this.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e070\"\u003e @Composable\u003cbr/\u003efun ImageCarousel(\u003cbr/\u003e    modifier: Modifier = Modifier\u003cbr/\u003e) {\u003cbr/\u003e    val imageList = listOf(\u003cbr/\u003e        R.drawable.image_banner_1,\u003cbr/\u003e        R.drawable.image_banner_2,\u003cbr/\u003e        R.drawable.image_banner_3,\u003cbr/\u003e        R.drawable.image_banner_4\u003cbr/\u003e    )\u003cp\u003e    val pagerState = rememberPagerState { imageList.size }\u003c/p\u003e\u003cp\u003e    Column(\u003cbr/\u003e        modifier\u003cbr/\u003e            .defaultMinSize(minHeight = 300.dp)\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e    ) {\u003c/p\u003e\u003cp\u003e        HorizontalPager(\u003cbr/\u003e            state = pagerState,\u003cbr/\u003e            modifier = Modifier.fillMaxWidth(),\u003cbr/\u003e            pageSpacing = 10.dp,\u003cbr/\u003e            contentPadding = PaddingValues(horizontal = 30.dp)\u003cbr/\u003e        ) { page -\u0026gt;\u003cbr/\u003e            Image(\u003cbr/\u003e                painter = painterResource(id = imageList[page]),\u003cbr/\u003e                contentDescription = \u0026#34;\u0026#34;,\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .height(100.dp),\u003cbr/\u003e                contentScale = ContentScale.Crop\u003cbr/\u003e            )\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e    }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2b17\"\u003eOutput:-\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"130f\"\u003eWe‚Äôre very close to achieving the desired behavior! But before moving forward, let‚Äôs take a moment to understand what this is and how it has helped us so far.\u003c/p\u003e\u003cp id=\"2f1e\"\u003e\u003cstrong\u003eWhat it does\u003c/strong\u003e: pageSpacing defines the gap (or spacing) between consecutive pages in the HorizontalPager.\u003c/p\u003e\u003cul\u003e\u003cli id=\"e0f6\"\u003e\u003cstrong\u003eEffect\u003c/strong\u003e: This means there will be a horizontal gap of 70 density-independent pixels (dp) between the edges of one page‚Äôs content (the Image) and the next page‚Äôs content.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3dc7\"\u003e\u003cstrong\u003eHow it helps\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"8f66\"\u003e\u003cstrong\u003eVisual Separation\u003c/strong\u003e: The 70dp spacing ensures that images don‚Äôt feel cramped or overlap as the user scrolls through the pager. It gives each image its own ‚Äúbreathing room,‚Äù making the UI cleaner and easier to navigate.\u003c/li\u003e\u003cli id=\"3f9c\"\u003e\u003cstrong\u003eFocus on the Current Page\u003c/strong\u003e: Combined with the scaling effect from lerp, this spacing emphasizes the centered image (which scales to 100.dp) while pushing adjacent images further apart, reducing visual clutter.\u003c/li\u003e\u003cli id=\"b1ff\"\u003e\u003cstrong\u003eSmooth Scrolling\u003c/strong\u003e: The spacing contributes to a natural scrolling feel, as pages aren‚Äôt too tightly packed, allowing the user to distinguish between them during transitions.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"8a6e\"\u003eNow, for the final touch! We want to add animation when moving from left to right, ensuring that partially visible images scale down compared to the centered image.\u003c/p\u003e\u003cp id=\"0e92\"\u003eTo achieve this, we‚Äôll manipulate the image itself rather than \u003ccode\u003eHorizontalPager\u003c/code\u003e. We\u0026#39;ll use \u003ccode\u003egraphicsLayer\u003c/code\u003e and \u003ccode\u003elerp\u003c/code\u003e to create the desired effect.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9da6\"\u003e@OptIn(ExperimentalFoundationApi::class)\u003cbr/\u003e@Composable\u003cbr/\u003efun ImageCarousel(\u003cbr/\u003e    modifier: Modifier = Modifier\u003cbr/\u003e) {\u003cbr/\u003e    val imageList = listOf(\u003cbr/\u003e        R.drawable.image_banner_1,\u003cbr/\u003e        R.drawable.image_banner_2,\u003cbr/\u003e        R.drawable.image_banner_3,\u003cbr/\u003e        R.drawable.image_banner_4\u003cbr/\u003e    )\u003cp\u003e    val pagerState = rememberPagerState { imageList.size }\u003c/p\u003e\u003cp\u003e    Column(\u003cbr/\u003e        modifier\u003cbr/\u003e            .defaultMinSize(minHeight = 300.dp)\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e    ) {\u003c/p\u003e\u003cp\u003e        HorizontalPager(\u003cbr/\u003e            state = pagerState,\u003cbr/\u003e            modifier = Modifier.fillMaxWidth(),\u003cbr/\u003e            pageSpacing = 10.dp,\u003cbr/\u003e            contentPadding = PaddingValues(horizontal = 30.dp)\u003cbr/\u003e        ) { page -\u0026gt;\u003cbr/\u003e            Image(\u003cbr/\u003e                painter = painterResource(id = imageList[page]),\u003cbr/\u003e                contentDescription = \u0026#34;\u0026#34;,\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .height(100.dp)\u003cbr/\u003e                    .graphicsLayer {\u003cbr/\u003e                        val pageOffset =\u003cbr/\u003e                            (pagerState.currentPage - page + pagerState.currentPageOffsetFraction).absoluteValue\u003c/p\u003e\u003cp\u003e                        lerp(\u003cbr/\u003e                            start = 75.dp,\u003cbr/\u003e                            stop = 100.dp,\u003cbr/\u003e                            fraction = 1f - pageOffset.coerceIn(0f, 1f)\u003cbr/\u003e                        ).also { scale -\u0026gt;\u003cbr/\u003e                            scaleY = scale / 100.dp\u003cbr/\u003e                        }\u003cbr/\u003e                    },\u003cbr/\u003e                contentScale = ContentScale.Crop\u003cbr/\u003e            )\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e    }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d18d\"\u003eIn the context of your code snippet, lerp stands for \u003cstrong\u003elinear interpolation\u003c/strong\u003e. It‚Äôs a mathematical function commonly used in graphics, animations, and UI programming to smoothly transition between two values based on a fraction or percentage.\u003c/p\u003e\u003ch2 id=\"7ee5\"\u003eDefinition of lerp\u003c/h2\u003e\u003cp id=\"c4a3\"\u003eLinear interpolation calculates an intermediate value between a start and a stop value, based on a fraction (typically a value between 0 and 1). The formula is:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c2cc\"\u003elerp(start, stop, fraction) = start + (stop - start) * fraction\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"f8c1\"\u003eWhen fraction = 0, the result is start.\u003c/li\u003e\u003cli id=\"bda2\"\u003eWhen the fraction = 1, the result is stop.\u003c/li\u003e\u003cli id=\"603b\"\u003eWhen the fraction is between 0 and 1, the result is a value proportionally between start and stop.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"78ed\"\u003elerp(\u003cbr/\u003e    start = 75.dp,\u003cbr/\u003e    stop = 100.dp,\u003cbr/\u003e    fraction = 1f - pageOffset.coerceIn(0f, 1f)\u003cbr/\u003e).also { scale -\u0026gt;\u003cbr/\u003e    scaleY = scale / 100.dp\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"df37\"\u003e\u003cstrong\u003estart = 75.dp\u003c/strong\u003e: The minimum scale value (75 density-independent pixels).\u003c/p\u003e\u003cp id=\"2fe9\"\u003e\u003cstrong\u003estop = 100.dp\u003c/strong\u003e: The maximum scale value (100 density-independent pixels).\u003c/p\u003e\u003cp id=\"6252\"\u003e\u003cstrong\u003efraction = 1f ‚Äî pageOffset.coerceIn(0f, 1f)\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1b17\"\u003e\u003ccode\u003epageOffset\u003c/code\u003e represents how far the current page is from being fully centered in the \u003ccode\u003eHorizontalPager\u003c/code\u003e. It‚Äôs a value that can range beyond 0 to 1, but \u003ccode\u003ecoerceIn(0f, 1f)\u003c/code\u003e clamps it to the range [0, 1].\u003c/li\u003e\u003cli id=\"31a6\"\u003e\u003ccode\u003e1f ‚Äî pageOffset\u003c/code\u003e inverts this value, so when the page is fully centered \u003ccode\u003e(pageOffset = 0)\u003c/code\u003e, the fraction is 1, and when the page is fully off-screen \u003ccode\u003e(pageOffset = 1)\u003c/code\u003e, the fraction is 0.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f06f\"\u003e\u003cstrong\u003elerp Result\u003c/strong\u003e: The result is a smooth transition between \u003ccode\u003e75.dp\u003c/code\u003e and \u003ccode\u003e100.dp\u003c/code\u003e. For example:\u003c/p\u003e\u003cul\u003e\u003cli id=\"bfbe\"\u003eIf \u003ccode\u003efraction = 1\u003c/code\u003e (page centered), the result is \u003ccode\u003e100.dp\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"05fe\"\u003eIf \u003ccode\u003efraction = 0\u003c/code\u003e (page fully offset), the result is \u003ccode\u003e75.dp\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"e7c2\"\u003eIf \u003ccode\u003efraction = 0.5\u003c/code\u003e (halfway), the result is \u003ccode\u003e87.5.dp\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"30f6\"\u003eIf you have any questions, just drop a comment, and I‚Äôll get back to you ASAP. We‚Äôll dive deeper into Jetpack Compose soon. Until then, happy coding!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-03-13T18:17:36.816Z",
  "modifiedTime": null
}
