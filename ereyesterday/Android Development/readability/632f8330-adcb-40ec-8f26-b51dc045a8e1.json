{
  "id": "632f8330-adcb-40ec-8f26-b51dc045a8e1",
  "title": "Avoid using lambda in the data class constructor in Kotlin",
  "link": "https://proandroiddev.com/avoid-using-lambda-in-the-data-class-constructor-in-kotlin-a7d952de25c9?source=rss----c72404660798---4",
  "description": "",
  "author": "Anatolii Frolov",
  "published": "Thu, 05 Jun 2025 16:02:17 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "android",
    "kotlin",
    "androiddev",
    "lambda"
  ],
  "byline": "Anatolii Frolov",
  "length": 3366,
  "excerpt": "In my previous articles, I showed why using var or Array in a Kotlin data class constructor leads to unexpected behavior and subtle bugs. These issues mostly relate to how equals(), hashCode(), andâ€¦",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In my previous articles, I showed why using var or Array in a Kotlin data class constructor leads to unexpected behavior and subtle bugs.These issues mostly relate to how equals(), hashCode(), and copy() behave under the hood â€” especially in collections like HashMap, HashSet, or in UI frameworks such as Jetpack Compose.Avoid using Array in the data class constructorAvoid using var in the data class constructorAvoid using var in the data class constructor â€“ now with Jetpack ComposeThose problems are related to logic and data modeling, and they often appear when working with collections, comparing objects, or optimizing recompositions.In this article, weâ€™ll look at another case: using a lambda in the constructor of a data class.Even if two lambdas do exactly the same thing, they are treated as different objects.This breaks equality and can lead to subtle bugs when storing or comparing instances.Weâ€™ll look at why this happens, what the implications are, and what to consider if you decide to use this pattern.Comparing data classes with lambdasLetâ€™s define a simple data class that includes a lambda in its constructor:data class Action( val label: String, val onClick: () -\u003e Unit)fun main() { val action1 = Action(\"Retry\") { println(\"Retryingâ€¦\") } val action2 = Action(\"Retry\") { println(\"Retryingâ€¦\") } println(action1 == action2)}Output:falseEven though both Action instances have the same label and the same lambda body, they are not considered equal.This happens because lambdas in Kotlin are compared by reference.Each { println(\"Retryingâ€¦\") } creates a new object in memory â€” even if the logic is the same.Reusing the same lambda referenceNow letâ€™s extract the lambda and pass the same reference to both instances:val retryLambda: () -\u003e Unit = { println(\"Retryingâ€¦\") }val action1 = Action(\"Retry\", retryLambda)val action2 = Action(\"Retry\", retryLambda)println(action1 == action2)Output:trueIn this case, both instances receive the same lambda reference, so the equals() function compares the same lambda object â€” and the result is true.This demonstrates that equality is based on the lambdaâ€™s identity, not on its logic.Why this detail is worth knowingTo be clear â€” I havenâ€™t seen this cause real problems in production code.But I think itâ€™s useful to understand how lambdas behave when used in data class constructors.If you decide to model your state this way, itâ€™s important to keep in mind that:Lambdas are compared by referenceThis can break equals() and hashCode()It may lead to subtle issues in lists, caching, or UI state updatesThis kind of knowledge is also useful in interviews â€” especially when youâ€™re asked about how Kotlin handles data classes under the hood.And if youâ€™ve seen a real-world case where this caused a problem â€” feel free to share it in the comments.ConclusionLambdas in data class constructors can silently break equality by introducing reference-based comparisons.Itâ€™s a small detail â€” but one thatâ€™s worth understanding.You might also like:If you learned something new or found this breakdown useful, feel free to leave a clap â€” it helps others discover the article.You can also follow me on Medium for more posts about Kotlin, Android development, and practical engineering topics.Anatolii FrolovSenior Android DeveloperWriting honest, real-world Kotlin \u0026 Jetpack Compose insights.ðŸ“¬ Follow me on Medium",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*YwFrDnVPmnRlrMNfPgtC0Q.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@af2905g?source=post_page---byline--a7d952de25c9---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Anatolii Frolov\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*PUwz5znLfXDNlKnDndJggA.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"83d3\"\u003eIn my previous articles, I showed why using \u003ccode\u003evar\u003c/code\u003e or \u003ccode\u003eArray\u003c/code\u003e in a Kotlin data class constructor leads to unexpected behavior and subtle bugs.\u003cbr/\u003eThese issues mostly relate to how \u003ccode\u003eequals()\u003c/code\u003e, \u003ccode\u003ehashCode()\u003c/code\u003e, and \u003ccode\u003ecopy()\u003c/code\u003e behave under the hood â€” especially in collections like \u003ccode\u003eHashMap\u003c/code\u003e, \u003ccode\u003eHashSet\u003c/code\u003e, or in UI frameworks such as Jetpack Compose.\u003c/p\u003e\u003cul\u003e\u003cli id=\"f430\"\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-array-in-the-data-class-constructor-in-kotlin-ebc308e46a95\" rel=\"noopener\"\u003eAvoid using \u003c/a\u003e\u003ccode\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-array-in-the-data-class-constructor-in-kotlin-ebc308e46a95\" rel=\"noopener\"\u003eArray\u003c/a\u003e\u003c/code\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-array-in-the-data-class-constructor-in-kotlin-ebc308e46a95\" rel=\"noopener\"\u003e in the data class constructor\u003c/a\u003e\u003c/li\u003e\u003cli id=\"52c9\"\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-var-in-the-data-class-constructor-in-kotlin-f40cfb8e16c7\" rel=\"noopener\"\u003eAvoid using \u003c/a\u003e\u003ccode\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-var-in-the-data-class-constructor-in-kotlin-f40cfb8e16c7\" rel=\"noopener\"\u003evar\u003c/a\u003e\u003c/code\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-var-in-the-data-class-constructor-in-kotlin-f40cfb8e16c7\" rel=\"noopener\"\u003e in the data class constructor\u003c/a\u003e\u003c/li\u003e\u003cli id=\"1444\"\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-var-in-the-data-class-constructor-in-kotlin-now-with-jetpack-compose-e0ebaf5445b6\" rel=\"noopener\"\u003eAvoid using \u003c/a\u003e\u003ccode\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-var-in-the-data-class-constructor-in-kotlin-now-with-jetpack-compose-e0ebaf5445b6\" rel=\"noopener\"\u003evar\u003c/a\u003e\u003c/code\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-var-in-the-data-class-constructor-in-kotlin-now-with-jetpack-compose-e0ebaf5445b6\" rel=\"noopener\"\u003e in the data class constructor â€“ now with Jetpack Compose\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"08b0\"\u003eThose problems are related to logic and data modeling, and they often appear when working with collections, comparing objects, or optimizing recompositions.\u003c/p\u003e\u003cp id=\"2f62\"\u003eIn this article, weâ€™ll look at another case: using a lambda in the constructor of a data class.\u003c/p\u003e\u003cp id=\"1b4c\"\u003eEven if two lambdas do exactly the same thing, they are treated as different objects.\u003cbr/\u003eThis breaks equality and can lead to subtle bugs when storing or comparing instances.\u003c/p\u003e\u003cp id=\"2b4d\"\u003eWeâ€™ll look at why this happens, what the implications are, and what to consider if you decide to use this pattern.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e660\"\u003eComparing data classes with lambdas\u003c/h2\u003e\u003cp id=\"8187\"\u003eLetâ€™s define a simple data class that includes a lambda in its constructor:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7aad\"\u003edata class Action(\u003cbr/\u003e    val label: String,\u003cbr/\u003e    val onClick: () -\u0026gt; Unit\u003cbr/\u003e)\u003cp\u003efun main() {\u003cbr/\u003e    val action1 = Action(\u0026#34;Retry\u0026#34;) { println(\u0026#34;Retryingâ€¦\u0026#34;) }\u003cbr/\u003e    val action2 = Action(\u0026#34;Retry\u0026#34;) { println(\u0026#34;Retryingâ€¦\u0026#34;) }\u003c/p\u003e\u003cp\u003e    println(action1 == action2)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8438\"\u003eOutput:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9e7e\"\u003efalse\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c0f5\"\u003eEven though both \u003ccode\u003eAction\u003c/code\u003e instances have the same label and the same lambda body, they are not considered equal.\u003c/p\u003e\u003cp id=\"1459\"\u003eThis happens because lambdas in Kotlin are compared by reference.\u003cbr/\u003eEach \u003ccode\u003e{ println(\u0026#34;Retryingâ€¦\u0026#34;) }\u003c/code\u003e creates a new object in memory â€” even if the logic is the same.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"8ae8\"\u003eReusing the same lambda reference\u003c/h2\u003e\u003cp id=\"3140\"\u003eNow letâ€™s extract the lambda and pass the same reference to both instances:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4d94\"\u003eval retryLambda: () -\u0026gt; Unit = { println(\u0026#34;Retryingâ€¦\u0026#34;) }\u003cp\u003eval action1 = Action(\u0026#34;Retry\u0026#34;, retryLambda)\u003cbr/\u003eval action2 = Action(\u0026#34;Retry\u0026#34;, retryLambda)\u003c/p\u003e\u003cp\u003eprintln(action1 == action2)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5333\"\u003eOutput:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e270\"\u003etrue\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ebf0\"\u003eIn this case, both instances receive the same lambda reference, so the \u003ccode\u003eequals()\u003c/code\u003e function compares the same lambda object â€” and the result is \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"f5bd\"\u003eThis demonstrates that equality is based on the lambdaâ€™s identity, not on its logic.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d9ca\"\u003eWhy this detail is worth knowing\u003c/h2\u003e\u003cp id=\"88c1\"\u003eTo be clear â€” I havenâ€™t seen this cause real problems in production code.\u003cbr/\u003eBut I think itâ€™s useful to understand how lambdas behave when used in data class constructors.\u003c/p\u003e\u003cp id=\"da1a\"\u003eIf you decide to model your state this way, itâ€™s important to keep in mind that:\u003c/p\u003e\u003cul\u003e\u003cli id=\"5f9e\"\u003eLambdas are compared by reference\u003c/li\u003e\u003cli id=\"d624\"\u003eThis can break \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e\u003c/li\u003e\u003cli id=\"d5e4\"\u003eIt may lead to subtle issues in lists, caching, or UI state updates\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"250f\"\u003eThis kind of knowledge is also useful in interviews â€” especially when youâ€™re asked about how Kotlin handles data classes under the hood.\u003c/p\u003e\u003cp id=\"5f9f\"\u003eAnd if youâ€™ve seen a real-world case where this caused a problem â€” feel free to share it in the comments.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"eb41\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"9346\"\u003eLambdas in data class constructors can silently break equality by introducing reference-based comparisons.\u003cbr/\u003eItâ€™s a small detail â€” but one thatâ€™s worth understanding.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"1dc8\"\u003eYou might also like:\u003c/h2\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"e35e\"\u003eIf you learned something new or found this breakdown useful, feel free to leave a clap â€” it helps others discover the article.\u003c/p\u003e\u003cp id=\"098e\"\u003eYou can also follow me on Medium for more posts about Kotlin, Android development, and practical engineering topics.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0667\"\u003e\u003cstrong\u003eAnatolii Frolov\u003c/strong\u003e\u003cbr/\u003eSenior Android Developer\u003cbr/\u003eWriting honest, real-world Kotlin \u0026amp; Jetpack Compose insights.\u003cbr/\u003eðŸ“¬ \u003ca href=\"https://medium.com/@af2905g\" rel=\"noopener\"\u003eFollow me on Medium\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-06-05T16:02:17.715Z",
  "modifiedTime": null
}
