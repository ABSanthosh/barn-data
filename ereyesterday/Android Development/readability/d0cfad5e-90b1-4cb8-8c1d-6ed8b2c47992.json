{
  "id": "d0cfad5e-90b1-4cb8-8c1d-6ed8b2c47992",
  "title": "Widgets With Glance: Beyond String States",
  "link": "https://proandroiddev.com/widgets-with-glance-beyond-string-states-2dcc4db2f76c?source=rss----c72404660798---4",
  "description": "",
  "author": "Katie Barnett",
  "published": "Thu, 21 Nov 2024 07:03:53 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "widget",
    "android-app-development",
    "state-management",
    "android",
    "jetpack-glance"
  ],
  "byline": "Katie Barnett",
  "length": 6238,
  "excerpt": "Use a custom GlanceStateDefinition to manage your GlanceAppWidget state in a typesafe way and optionally implement custom serialization or storage solution.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Image created by ChatGPT.I have recently been working on an app (Pay Day: Earnings Time Tracker) that includes a lot of widgets that show different types of data, but very quickly I came across a problem. The standard way of passing data to a widget uses PreferencesGlanceStateDefinition to manage the state. The way of setting state is using key \u0026 value pairs where the values are always strings. In my app I also needed enums \u0026 float values and was constantly converting to and from strings for many different data arguments and many different widget implementations. This became hard to manage and hard to read and a reusable and type safe solution was required.I had read about using a CustomGlanceStateDefinition but I couldn’t find much about it in the official documentation so here is my deep dive to hopefully help anyone else struggling with managing complex GlanceWidget state!Basic widget stateFor the purposes of this article I have used a simpler example that just displays a text quote. While this example probably could get away with just using the string based values, adding some structure to the model can enable better loading and error states.The starting point just sets a topic and quote as strings:A CoroutineWorker is used to update the state periodically. You could use any method of setting the widget state, the same principles apply.A custom state model with Json SerializationSo this works well if the state is fairly straightforward and is just represented as simple strings, but what if we want a more complex model?My first attempt to use a more complex model, I started by serializing the model to Json.Using my QuoteWidget example, a better model might be:Then, we can serialize the model as Json and then use that as the string value in the widget.The first step is to use kotlinx.serialization to serialize the data model:Then, we can use kotlinx.serialization.json to encode and decode the model to a string when writing and reading from the state object:This is pretty good, we can easily fetch and save the model as long as it serializes well. We do have to handle any encoding or decoding errors and respond as needed.Creating a custom GlanceStateDefinitionBut what if we want a different method of serialization? Or a different storage location (rather than the default preferences file). The documentation discusses the standard way of saving and fetching states, but there is not much information on using a custom model instead of strings. There is an example in the platform-samples Github repository that includes a breif implementation, I am expanding on this here.In order to be able to handle different widget states, I have extended my model to be a sealed interface and include different implementations for various states:The next step is to create a custom GlanceStateDefinition , this gives us several advantages:We can set a custom serializer, in this case I am using kotlinx.serialization as in the previous step, but you could use whatever works in readFrom and writeTo for your existing architecture. Errors in serialization can be handled here.We can specify the DataStore file location. In this case I am using a new file for every widget by using the fileKey as part of the DataStore file location name (see getLocation in the below example code). If you only have only one state for all of your widgets of a specific type and want them all to rely on the same file, you can set the file location as a static value (this is the approach used by the platform-samples example).If you are using a different DataStore for each widget you need to create a new one with a DataStoreFactory, otherwise the DataStore can be created as a variable at the top level of the GlanceStateDefinition (as is done in platform-samples)You can create a specific DataStore implementation. The example I am using creates a standard androidx.datastore.core.DataStore with a custom Serializer but you could instead use a database or protobuf storage implementation instead depending on your usecase. I have not found many examples of this other than this StackOverflow answer where the user has created a database backed version of the DataStore.This could be a good option if for some reason you do not want to make your model serializable or if your data object is too large to store in a DataStore string based file.The final advantage is allowing us to abstract the implementation of the widget state away from the rest of the widget implementation. If the data source or serialization method changes, then this can be adjusted in one place without affecting the rest of the implementation.The GlanceStateDefinition is implemented as follows:Using the custom GlanceStateDefinitionWe then need to override the stateDefinition in the GlanceAppWidget class so that the widget implementation uses that instead of the default PreferencesGlanceStateDefinition. This is as simple as:override val stateDefinition = QuoteWidgetStateDefinitionFollowing that, every instance of updateAppWidgetState needs to set the definition argument:updateAppWidgetState(... definition = QuoteWidgetStateDefinition,...)We can see this in more detail in the examples below:Fetching the custom stateIn this code snippit we are setting the stateDefinition and when reading the current state, specifying the type we are expecting (WidgetState in this case). From here I can detect which class implementation is used and select the right composable to display. It’s type safe and much more readable than using key-value pairs or Json serialization.Saving the custom stateWhen saving the state the updateAppWidgetState function call is updated to include the definition argument, and then the updateState lambda just needs to return the right type, no serialization is need at this point — this is all done by the custom GlanceStateDefinition . Again, it is type safe, and allows us more freedom to set loading and error behaviours.So there it is, a custom GlanceStateDefinition, the data model can be as complex or as large as you like as long as you can either serialize it or store it. The code is more readable and state management is easy no matter how many widgets you have!To see a full example, see my sample widget app:",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*CRseHrplJF6Df_UEDsD73g.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003cfigcaption\u003eImage created by \u003ca href=\"https://chatgpt.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eChatGPT\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"97a4\"\u003eI have recently been working on an app (\u003ca href=\"https://play.google.com/store/apps/details?id=dev.veryniche.buckaroo\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePay Day: Earnings Time Tracker\u003c/a\u003e) that includes a lot of widgets that show different types of data, but very quickly I came across a problem. The standard way of passing data to a widget uses \u003ccode\u003ePreferencesGlanceStateDefinition\u003c/code\u003e to manage the state. The way of setting state is using key \u0026amp; value pairs where the values are always \u003ccode\u003estrings\u003c/code\u003e. In my app I also needed \u003ccode\u003eenums\u003c/code\u003e \u0026amp; \u003ccode\u003efloat\u003c/code\u003e values and was constantly converting to and from strings for many different data arguments and many different widget implementations. This became hard to manage and hard to read and a reusable and type safe solution was required.\u003c/p\u003e\u003cp id=\"3a31\"\u003eI had read about using a \u003ccode\u003eCustomGlanceStateDefinition\u003c/code\u003e but I couldn’t find much about it in the official \u003ca href=\"https://developer.android.com/develop/ui/compose/glance/glance-app-widget\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocumentation\u003c/a\u003e so here is my deep dive to hopefully help anyone else struggling with managing complex \u003ccode\u003eGlanceWidget\u003c/code\u003e state!\u003c/p\u003e\u003ch2 id=\"70db\"\u003eBasic widget state\u003c/h2\u003e\u003cp id=\"e316\"\u003eFor the purposes of this article I have used a simpler \u003ca href=\"https://github.com/KatieBarnett/MotivateMe/tree/blog/CustomGlanceStateDefinition\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eexample\u003c/a\u003e that just displays a text quote. While this example probably could get away with just using the string based values, adding some structure to the model can enable better loading and error states.\u003c/p\u003e\u003cp id=\"8a7d\"\u003eThe starting point just sets a topic and quote as strings:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"02a7\"\u003eA \u003ccode\u003eCoroutineWorker\u003c/code\u003e is used to update the state periodically. You could use any method of setting the widget state, the same principles apply.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"6ed8\"\u003eA custom state model with Json Serialization\u003c/h2\u003e\u003cp id=\"bf4a\"\u003eSo this works well if the state is fairly straightforward and is just represented as simple strings, but what if we want a more complex model?\u003c/p\u003e\u003cp id=\"522d\"\u003eMy first attempt to use a more complex model, I started by serializing the model to \u003ccode\u003eJson\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"5286\"\u003eUsing my \u003ccode\u003eQuoteWidget\u003c/code\u003e example, a better model might be:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2302\"\u003eThen, we can serialize the model as \u003ccode\u003eJson\u003c/code\u003e and then use that as the string value in the widget.\u003c/p\u003e\u003cp id=\"3f12\"\u003eThe first step is to use \u003ccode\u003ekotlinx.serialization\u003c/code\u003e to serialize the data model:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0a9a\"\u003eThen, we can use \u003ccode\u003ekotlinx.serialization.json\u003c/code\u003e to encode and decode the model to a string when writing and reading from the state object:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"67e9\"\u003eThis is pretty good, we can easily fetch and save the model as long as it serializes well. We do have to handle any encoding or decoding errors and respond as needed.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"2be5\"\u003eCreating a custom GlanceStateDefinition\u003c/h2\u003e\u003cp id=\"c06e\"\u003eBut what if we want a different method of serialization? Or a different storage location (rather than the default preferences file). The \u003ca href=\"https://developer.android.com/develop/ui/compose/glance/glance-app-widget\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocumentation\u003c/a\u003e discusses the standard way of saving and fetching states, but there is not much information on using a custom model instead of strings. There is an example in the \u003ca href=\"https://github.com/android/user-interface-samples/tree/main/AppWidget/app/src/main/java/com/example/android/appwidget/glance/weather\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eplatform-samples Github repository\u003c/a\u003e that includes a breif implementation, I am expanding on this here.\u003c/p\u003e\u003cp id=\"1c1c\"\u003eIn order to be able to handle different widget states, I have extended my model to be a \u003ccode\u003esealed interface\u003c/code\u003e and include different implementations for various states:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0e01\"\u003eThe next step is to create a custom \u003ccode\u003eGlanceStateDefinition\u003c/code\u003e , this gives us several advantages:\u003c/p\u003e\u003col\u003e\u003cli id=\"8d8c\"\u003eWe can set a \u003cstrong\u003ecustom serializer\u003c/strong\u003e, in this case I am using \u003ccode\u003ekotlinx.serialization\u003c/code\u003e as in the previous step, but you could use whatever works in \u003ccode\u003ereadFrom\u003c/code\u003e and \u003ccode\u003ewriteTo\u003c/code\u003e for your existing architecture. \u003cbr/\u003eErrors in serialization can be handled here.\u003c/li\u003e\u003cli id=\"9867\"\u003eWe can specify the \u003cstrong\u003eDataStore file location\u003c/strong\u003e. In this case I am using a new file for every widget by using the \u003ccode\u003efileKey\u003c/code\u003e as part of the \u003ccode\u003eDataStore\u003c/code\u003e file location name (see \u003ccode\u003egetLocation\u003c/code\u003e in the below example code). If you only have only one state for all of your widgets of a specific type and want them all to rely on the same file, you can set the file \u003ccode\u003elocation\u003c/code\u003e as a static value (this is the approach used by the \u003ca href=\"https://github.com/android/user-interface-samples/tree/main/AppWidget/app/src/main/java/com/example/android/appwidget/glance/weather\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eplatform-samples\u003c/a\u003e example).\u003cbr/\u003eIf you are using a different \u003ccode\u003eDataStore\u003c/code\u003e for each widget you need to create a new one with a \u003ccode\u003eDataStoreFactory\u003c/code\u003e, otherwise the \u003ccode\u003eDataStore\u003c/code\u003e can be created as a variable at the top level of the \u003ccode\u003eGlanceStateDefinition\u003c/code\u003e (as is done in \u003ca href=\"https://github.com/android/user-interface-samples/tree/main/AppWidget/app/src/main/java/com/example/android/appwidget/glance/weather\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eplatform-samples\u003c/a\u003e)\u003c/li\u003e\u003cli id=\"60da\"\u003eYou can create a \u003cstrong\u003especific DataStore implementation\u003c/strong\u003e. The example I am using creates a standard \u003ccode\u003eandroidx.datastore.core.DataStore\u003c/code\u003e with a custom \u003ccode\u003eSerializer\u003c/code\u003e but you could instead use a database or \u003ccode\u003eprotobuf\u003c/code\u003e storage implementation instead depending on your usecase. I have not found many examples of this other than this \u003ca href=\"https://stackoverflow.com/a/77095689\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStackOverflow answer\u003c/a\u003e where the user has created a database backed version of the \u003ccode\u003eDataStore\u003c/code\u003e.\u003cbr/\u003eThis could be a good option if for some reason you do not want to make your model serializable or if your data object is too large to store in a \u003ccode\u003eDataStore\u003c/code\u003e string based file.\u003c/li\u003e\u003cli id=\"bcac\"\u003eThe final advantage is allowing us to \u003cstrong\u003eabstract the implementation\u003c/strong\u003e of the widget state away from the rest of the widget implementation. If the data source or serialization method changes, then this can be adjusted in one place without affecting the rest of the implementation.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"8867\"\u003eThe \u003ccode\u003eGlanceStateDefinition\u003c/code\u003e is implemented as follows:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"32a7\"\u003eUsing the custom GlanceStateDefinition\u003c/h2\u003e\u003cp id=\"543a\"\u003eWe then need to override the \u003ccode\u003estateDefinition\u003c/code\u003e in the \u003ccode\u003eGlanceAppWidget\u003c/code\u003e class so that the widget implementation uses that instead of the default \u003ccode\u003ePreferencesGlanceStateDefinition\u003c/code\u003e. This is as simple as:\u003c/p\u003e\u003cp id=\"1af7\"\u003e\u003ccode\u003eoverride val stateDefinition = QuoteWidgetStateDefinition\u003c/code\u003e\u003c/p\u003e\u003cp id=\"7e1c\"\u003eFollowing that, every instance of \u003ccode\u003eupdateAppWidgetState\u003c/code\u003e needs to set the \u003ccode\u003edefinition\u003c/code\u003e argument:\u003c/p\u003e\u003cp id=\"4deb\"\u003e\u003ccode\u003eupdateAppWidgetState(... definition = QuoteWidgetStateDefinition,...)\u003c/code\u003e\u003c/p\u003e\u003cp id=\"8604\"\u003eWe can see this in more detail in the examples below:\u003c/p\u003e\u003ch2 id=\"a8cb\"\u003eFetching the custom state\u003c/h2\u003e\u003cp id=\"16c6\"\u003eIn this code snippit we are setting the \u003ccode\u003estateDefinition\u003c/code\u003e and when reading the current state, specifying the type we are expecting (\u003ccode\u003eWidgetState\u003c/code\u003e in this case). From here I can detect which class implementation is used and select the right composable to display. It’s type safe and much more readable than using key-value pairs or Json serialization.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"7626\"\u003eSaving the custom state\u003c/h2\u003e\u003cp id=\"8255\"\u003eWhen saving the state the \u003ccode\u003eupdateAppWidgetState\u003c/code\u003e function call is updated to include the \u003ccode\u003edefinition\u003c/code\u003e argument, and then the \u003ccode\u003eupdateState\u003c/code\u003e lambda just needs to return the right type, no serialization is need at this point — this is all done by the custom \u003ccode\u003eGlanceStateDefinition\u003c/code\u003e . Again, it is type safe, and allows us more freedom to set loading and error behaviours.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e56b\"\u003eSo there it is, a custom \u003ccode\u003eGlanceStateDefinition\u003c/code\u003e, the data model can be as complex or as large as you like as long as you can either serialize it or store it. The code is more readable and state management is easy no matter how many widgets you have!\u003c/p\u003e\u003cp id=\"6d80\"\u003eTo see a full example, see my \u003ca href=\"https://github.com/KatieBarnett/MotivateMe/tree/blog/CustomGlanceStateDefinition\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esample widget app\u003c/a\u003e:\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2024-11-21T07:03:53.504Z",
  "modifiedTime": null
}
