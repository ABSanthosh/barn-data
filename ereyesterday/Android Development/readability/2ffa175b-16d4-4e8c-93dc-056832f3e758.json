{
  "id": "2ffa175b-16d4-4e8c-93dc-056832f3e758",
  "title": "When Kotlin object Stops Being a Singleton",
  "link": "https://proandroiddev.com/when-kotlin-object-stops-being-a-singleton-604a3354e4ec?source=rss----c72404660798---4",
  "description": "",
  "author": "Anatolii Frolov",
  "published": "Fri, 04 Jul 2025 00:13:47 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "androiddev",
    "android",
    "kotlin",
    "kotlin-beginners"
  ],
  "byline": "Anatolii Frolov",
  "length": 5266,
  "excerpt": "Kotlin object is the standard way to declare a singleton â€” a single, globally accessible instance created once per JVM. This guarantee holds at the language level. But in real-world projects, it canâ€¦",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "When Kotlin object Stops Being a SingletonKotlin object is the standard way to declare a singleton â€” a single, globally accessible instance created once per JVM.This guarantee holds at the language level. But in real-world projects, it can break â€” without compiler errors or visible warnings.One common cause is serialization. Some libraries return a new instance during deserialization, breaking reference equality and shared state.This article explains when Kotlin singletons stop being singletons â€” and how to avoid it in practice.How Gson breaks Kotlin object identityMost developers use object in Kotlin as a language-level singleton. Itâ€™s created once, holds global state, and is referenced consistently throughout the app.But this guarantee only applies within the same classloader â€” and only if the object is used directly. Runtime tools like serializers can break this behavior without warning.Hereâ€™s what happens when you serialize and deserialize a Kotlin object using Gson:object MySingleton { const val NAME: String = \"MySingleton\"}fun main() { val gson = Gson() // serialize val json = gson.toJson(MySingleton) // deserialize val deserialized = gson.fromJson(json, MySingleton::class.java) println(\"MySingleton before serialization hashCode: ${System.identityHashCode(MySingleton)}\") println(\"MySingleton after serialization hashCode: ${System.identityHashCode(deserialized)}\") println(\"Same instance: ${deserialized === MySingleton}\")}Output:MySingleton before serialization hashCode: 399534175 MySingleton after serialization hashCode: 428910174 Same instance: falseEven though the original type is object, Gson creates a new instance on deserialization. Reference equality is lost, and any global state held inside the singleton is not preserved.Why this happensGson does not recognize Kotlinâ€™s object. It treats it as a regular class with fields. During deserialization, it uses reflection to create a new instance â€” even though object was designed to be a singleton.This is not a bug in Gson. Itâ€™s a mismatch between a Kotlin-specific construct and a library that works at the Java class level.What to rememberKotlin object guarantees a single instance per classloader â€” at the language level.Serialization libraries like Gson treat it as a regular class and create new instances during deserialization.If identity matters, using object with serialization requires explicit handling.To preserve singleton behavior, use a custom adapter that always returns the original instance.How kotlinx.serialization preserves object identityKotlinâ€™s official serialization library does recognize object. When annotated with @Serializable, the deserializer knows it's a singleton â€” and returns the existing instance.@Serializableobject MySingleton { const val NAME: String = \"MySingleton\"}@OptIn(InternalSerializationApi::class)fun main() { val json = Json { encodeDefaults = true } // serialize val serialized = json.encodeToString(MySingleton) // deserialize val deserialized = json.decodeFromString(MySingleton::class.serializer(), serialized) println(\"MySingleton before serialization hashCode: ${System.identityHashCode(MySingleton)}\") println(\"MySingleton after serialization hashCode: ${System.identityHashCode(deserialized)}\") println(\"Same instance: ${deserialized === MySingleton}\")}Output:MySingleton before serialization hashCode: 399534175 MySingleton after serialization hashCode: 399534175 Same instance: trueThis behavior is by design. The Kotlin serialization plugin understands object declarations and reuses the existing instance safely.How Moshi handles Kotlin objectMoshi takes a stricter approach. Instead of creating a new instance, it throws an exception when asked to serialize or deserialize a Kotlin object.object MySingleton { const val NAME: String = \"MySingleton\"}fun main() { val moshi = Moshi.Builder() .add(KotlinJsonAdapterFactory()) .build() val adapter = moshi.adapter(MySingleton::class.java) val json = adapter.toJson(MySingleton) val deserialized = adapter.fromJson(json)}Output:Exception in thread \"main\" java.lang.IllegalArgumentException: Cannot serialize object declaration com.example.MySingletonThis behavior prevents accidental duplication. To deserialize a Kotlin object with Moshi, you must write a custom adapter that always returns the original instance.SummaryKotlin object works reliably as a singleton â€” but only at the language level.With serialization, that guarantee can break.Gson creates a new instance on deserializationMoshi throws an error and refuses to serializekotlinx.serialization preserves the original instanceIf your app relies on identity, reference equality, or shared state â€” use caution when combining object with third-party serializers.In Kotlin-first projects, prefer kotlinx.serialization when working with object.If you found this article helpfulIf you found this article helpful, consider leaving a clap â€” it helps others discover it.You can also follow me on Medium for more articles about Kotlin, Android development, and practical engineering topics.You might also like:Anatolii FrolovSenior Android DeveloperWriting honest, real-world Kotlin \u0026 Jetpack Compose insights.ðŸ“¬ Follow me on Medium",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*47xM0TQZjLJMVB_zQVFxiA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"214b\" data-testid=\"storyTitle\"\u003eWhen Kotlin \u003ccode\u003eobject\u003c/code\u003e Stops Being a Singleton\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@af2905g?source=post_page---byline--604a3354e4ec---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Anatolii Frolov\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*PUwz5znLfXDNlKnDndJggA.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"01c6\"\u003eKotlin \u003ccode\u003eobject\u003c/code\u003e is the standard way to declare a singleton â€” a single, globally accessible instance created once per JVM.\u003c/p\u003e\u003cp id=\"45cc\"\u003eThis guarantee holds at the language level. But in real-world projects, it can break â€” without compiler errors or visible warnings.\u003c/p\u003e\u003cp id=\"9635\"\u003eOne common cause is serialization. Some libraries return a new instance during deserialization, breaking reference equality and shared state.\u003c/p\u003e\u003cp id=\"59b0\"\u003eThis article explains when Kotlin singletons stop being singletons â€” and how to avoid it in practice.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"1daa\"\u003eHow Gson breaks Kotlin object identity\u003c/h2\u003e\u003cp id=\"7ed4\"\u003eMost developers use \u003ccode\u003eobject\u003c/code\u003e in Kotlin as a language-level singleton. Itâ€™s created once, holds global state, and is referenced consistently throughout the app.\u003c/p\u003e\u003cp id=\"bb43\"\u003eBut this guarantee only applies within the same classloader â€” and only if the object is used directly. Runtime tools like serializers can break this behavior without warning.\u003c/p\u003e\u003cp id=\"37dc\"\u003eHereâ€™s what happens when you serialize and deserialize a Kotlin \u003ccode\u003eobject\u003c/code\u003e using Gson:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"91b4\"\u003eobject MySingleton {\u003cbr/\u003e    const val NAME: String = \u0026#34;MySingleton\u0026#34;\u003cbr/\u003e}\u003cp\u003efun main() {\u003cbr/\u003e    val gson = Gson()\u003c/p\u003e\u003cp\u003e    // serialize\u003cbr/\u003e    val json = gson.toJson(MySingleton)\u003c/p\u003e\u003cp\u003e    // deserialize\u003cbr/\u003e    val deserialized = gson.fromJson(json, MySingleton::class.java)\u003c/p\u003e\u003cp\u003e    println(\u0026#34;MySingleton before serialization hashCode: ${System.identityHashCode(MySingleton)}\u0026#34;)\u003cbr/\u003e    println(\u0026#34;MySingleton after serialization hashCode: ${System.identityHashCode(deserialized)}\u0026#34;)\u003c/p\u003e\u003cp\u003e    println(\u0026#34;Same instance: ${deserialized === MySingleton}\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8d11\"\u003eOutput:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"784d\"\u003eMySingleton before serialization hashCode: 399534175  \u003cbr/\u003eMySingleton after serialization hashCode: 428910174  \u003cbr/\u003eSame instance: false\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9659\"\u003eEven though the original type is \u003ccode\u003eobject\u003c/code\u003e, Gson creates a new instance on deserialization. Reference equality is lost, and any global state held inside the singleton is not preserved.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9653\"\u003eWhy this happens\u003c/h2\u003e\u003cp id=\"14c3\"\u003eGson does not recognize Kotlinâ€™s \u003ccode\u003eobject\u003c/code\u003e. It treats it as a regular class with fields. During deserialization, it uses reflection to create a new instance â€” even though \u003ccode\u003eobject\u003c/code\u003e was designed to be a singleton.\u003c/p\u003e\u003cp id=\"c3fa\"\u003eThis is not a bug in Gson. Itâ€™s a mismatch between a Kotlin-specific construct and a library that works at the Java class level.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"eb8d\"\u003eWhat to remember\u003c/h2\u003e\u003cp id=\"6e06\"\u003eKotlin \u003ccode\u003eobject\u003c/code\u003e guarantees a single instance per classloader â€” at the language level.\u003c/p\u003e\u003cp id=\"80ba\"\u003eSerialization libraries like Gson treat it as a regular class and create new instances during deserialization.\u003c/p\u003e\u003cp id=\"bc64\"\u003eIf identity matters, using \u003ccode\u003eobject\u003c/code\u003e with serialization requires explicit handling.\u003c/p\u003e\u003cp id=\"5db6\"\u003eTo preserve singleton behavior, use a custom adapter that always returns the original instance.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"718a\"\u003eHow kotlinx.serialization preserves object identity\u003c/h2\u003e\u003cp id=\"ee02\"\u003eKotlinâ€™s official serialization library does recognize \u003ccode\u003eobject\u003c/code\u003e. When annotated with \u003ccode\u003e@Serializable\u003c/code\u003e, the deserializer knows it\u0026#39;s a singleton â€” and returns the existing instance.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2f68\"\u003e@Serializable\u003cbr/\u003eobject MySingleton {\u003cbr/\u003e    const val NAME: String = \u0026#34;MySingleton\u0026#34;\u003cbr/\u003e}\u003cp\u003e@OptIn(InternalSerializationApi::class)\u003cbr/\u003efun main() {\u003cbr/\u003e    val json = Json { encodeDefaults = true }\u003c/p\u003e\u003cp\u003e    // serialize\u003cbr/\u003e    val serialized = json.encodeToString(MySingleton)\u003c/p\u003e\u003cp\u003e    // deserialize\u003cbr/\u003e    val deserialized = json.decodeFromString(MySingleton::class.serializer(), serialized)\u003c/p\u003e\u003cp\u003e    println(\u0026#34;MySingleton before serialization hashCode: ${System.identityHashCode(MySingleton)}\u0026#34;)\u003cbr/\u003e    println(\u0026#34;MySingleton after serialization hashCode: ${System.identityHashCode(deserialized)}\u0026#34;)\u003c/p\u003e\u003cp\u003e    println(\u0026#34;Same instance: ${deserialized === MySingleton}\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"223b\"\u003eOutput:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"823d\"\u003eMySingleton before serialization hashCode: 399534175  \u003cbr/\u003eMySingleton after serialization hashCode: 399534175  \u003cbr/\u003eSame instance: true\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3c60\"\u003eThis behavior is by design. The Kotlin serialization plugin understands \u003ccode\u003eobject\u003c/code\u003e declarations and reuses the existing instance safely.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"bc90\"\u003eHow Moshi handles Kotlin \u003ccode\u003eobject\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"f329\"\u003eMoshi takes a stricter approach. Instead of creating a new instance, it throws an exception when asked to serialize or deserialize a Kotlin \u003ccode\u003eobject\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4ccf\"\u003eobject MySingleton {\u003cbr/\u003e    const val NAME: String = \u0026#34;MySingleton\u0026#34;\u003cbr/\u003e}\u003cp\u003efun main() {\u003cbr/\u003e    val moshi = Moshi.Builder()\u003cbr/\u003e        .add(KotlinJsonAdapterFactory())\u003cbr/\u003e        .build()\u003c/p\u003e\u003cp\u003e    val adapter = moshi.adapter(MySingleton::class.java)\u003c/p\u003e\u003cp\u003e    val json = adapter.toJson(MySingleton)\u003cbr/\u003e    val deserialized = adapter.fromJson(json)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2015\"\u003eOutput:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fc05\"\u003eException in thread \u0026#34;main\u0026#34; java.lang.IllegalArgumentException: \u003cbr/\u003eCannot serialize object declaration com.example.MySingleton\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"741e\"\u003eThis behavior prevents accidental duplication. To deserialize a Kotlin \u003ccode\u003eobject\u003c/code\u003e with Moshi, you must write a custom adapter that always returns the original instance.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"7a23\"\u003eSummary\u003c/h2\u003e\u003cp id=\"51e0\"\u003eKotlin \u003ccode\u003eobject\u003c/code\u003e works reliably as a singleton â€” but only at the language level.\u003c/p\u003e\u003cp id=\"364a\"\u003eWith serialization, that guarantee can break.\u003c/p\u003e\u003cul\u003e\u003cli id=\"8873\"\u003eGson creates a new instance on deserialization\u003c/li\u003e\u003cli id=\"ab45\"\u003eMoshi throws an error and refuses to serialize\u003c/li\u003e\u003cli id=\"06f9\"\u003ekotlinx.serialization preserves the original instance\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"fef3\"\u003eIf your app relies on identity, reference equality, or shared state â€” use caution when combining \u003ccode\u003eobject\u003c/code\u003e with third-party serializers.\u003c/p\u003e\u003cp id=\"43be\"\u003eIn Kotlin-first projects, prefer kotlinx.serialization when working with \u003ccode\u003eobject\u003c/code\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"ec17\"\u003eIf you found this article helpful\u003c/h2\u003e\u003cp id=\"1ddc\"\u003eIf you found this article helpful, consider leaving a clap â€” it helps others discover it.\u003cbr/\u003eYou can also follow me on Medium for more articles about Kotlin, Android development, and practical engineering topics.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"4274\"\u003eYou might also like:\u003c/h2\u003e\u003c/div\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9daa\"\u003e\u003cstrong\u003eAnatolii Frolov\u003c/strong\u003e\u003cbr/\u003eSenior Android Developer\u003cbr/\u003eWriting honest, real-world Kotlin \u0026amp; Jetpack Compose insights.\u003cbr/\u003eðŸ“¬ \u003ca href=\"https://medium.com/@af2905g\" rel=\"noopener\"\u003eFollow me on Medium\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-07-04T00:13:46.908Z",
  "modifiedTime": null
}
