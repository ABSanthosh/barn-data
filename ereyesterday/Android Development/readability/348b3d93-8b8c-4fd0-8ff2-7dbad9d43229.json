{
  "id": "348b3d93-8b8c-4fd0-8ff2-7dbad9d43229",
  "title": "Making Direct Messages Reliable and Fast",
  "link": "https://instagram-engineering.com/making-direct-messages-reliable-and-fast-a152bdfd697f?source=rss----37dc2a3034f2--android",
  "description": "",
  "author": "Tommy Crush",
  "published": "Wed, 05 Jun 2019 14:57:10 GMT",
  "source": "https://instagram-engineering.com/feed/tagged/android",
  "categories": [
    "instagram",
    "ios",
    "software-engineering",
    "android",
    "messaging"
  ],
  "byline": "Tommy Crush",
  "length": 7574,
  "excerpt": "Over the last few years, Instagram Direct has grown to be a core part of sharing content and experiences with your close friends on Instagram. This isn’t a privilege we take lightly; it’s incredibly…",
  "siteName": "Instagram Engineering",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Making Direct Messages Reliable and FastOver the last few years, Instagram Direct has grown to be a core part of sharing content and experiences with your close friends on Instagram. This isn’t a privilege we take lightly; it’s incredibly important that we deliver each message as reliably and as quickly as possible. The Internet transfers data at the Speed of Light, but in many cases, due to large distances and network inefficiencies, the human eye can still pickup on the delay between a request’s start and finish. Additionally, network requests can fail for a wide variety of reasons, such as connection-loss or transient server issues. In this blog post, we’ll discuss Instagram’s infrastructure on iOS and Android to not only retry these actions, but also to make the whole experience feel much faster and reliable to the user.How mobile apps make network requests look fastOften, when someone is building a mobile app that wants to “mutate” state on the server (such as tell the server to send a message), they have their view layer initiate a network request. It doesn’t take long before the developer realizes that this request could easily take a second or two even in good network conditions.A common pattern used to make it seem like the application is fast and responsive (i.e., reduce the user-perceived latency) is to “optimistically” guess the expected output of the successful request and immediately apply it to the view — all before the request is even made. We call this concept “optimistic state”.In this iOS example, I have an app that stores a color. The existing color, Red, is stored in _savedColor, but when MyViewController has set off a network request to change it, the app immediately overwrites the view's color to Blue, in the _updatingToColor value. This makes the app feel much faster than waiting for the request to complete. This pattern, however, becomes unmanageable as the application grows. If I leave MyViewController, the other views in the app that depend on the same color value don't reflect this ongoing request. This confuses the user, and makes the app look inconsistent, buggy, and slow! To handle this, many developers simply apply the Color change to the app's global data-cache. In fact, Direct also used to apply optimistic changes to our global caches. But this poses many problems, too. What happens if some other event (such as fetching the Color from network) overwrites my ongoing-Blue color back to Red? This concept is referred to as “Clobbering”. It creates weird experiences for the user, and it's difficult for developers to debug/reproduce.Additionally, tying a network request to a short-lived ViewController causes its own set of issues. If my request fails for a retriable reason, such as a loss of network, we should be able to perform this request again later, even if MyViewController is deallocated.As you can quickly see, optimistic state and network-request retry-logic are easy to build, but difficult to get right.Direct’s Mutation ManagerGiven the number of different network conditions we must operate within, and the number of product surfaces we must support, building a consistent retry and optimistic state policy is a difficult task. To solve these problems, we built a piece of infrastructure that we call the Mutation Manager. The Mutation Manager is designed to answer the questions above. Specifically, we wanted to make it effortless for mobile engineers to get:Intelligent and customizable auto-retry strategies for their network requests, with backoff behavior and retries across cold-starts.Optimistic State applied to all surfaces of the application, and free lifecycle management (adding, removing, handling clobbering, etc).How the Mutation Manager WorksDirect’s Mutation Manager (or short: DMM) achieves these goals (and more) by creating a centralized service that owns the network requests, serializes them to disk for retries, and safely manages the flow of their resulting optimistic state. In Instagram Direct, all surfaces implement this pattern. Let’s follow an example: imagine you navigate into a Direct thread with a message your friend just sent you. In that scenario, these steps occur:Submit a “Mark Thread as Read” mutation to the DMM.The DMM saves an entry into the OptimisticState cache. This entry is an instruction object, which describes the desired data change before the data is given to any UI.Mutation is saved to disk, in case we need to retry after an app termination such as a crash.The UI will then use ViewModels, which represent the merged state of the published-data and the entry that was saved to the OptimisticState cache.The network request is sent out. Each mutation has a MutationToken in its payload, which is a unique id created on the client.Once we have received the new confirmed state (with the matching MutationToken) from the server and updated the published-data, we remove and thus stop applying the entry from the optimistic state cache.After all our mutations and surfaces were migrated to this pattern, optimistic state became an afterthought of product development, and yet all UX surfaces remain consistent and the app feels fast to the user. Since optimistic state and server data are stored separately, and only merged on-the-fly at the View layer, Clobbering is impossible. Of course, nothing is free. The amount of client-side processing happening here has definitely increased. But, in practice, we’ve been able to mitigate any performance issues by keeping the application of the Optimistic State entry to the View Model as cheap as possible. The DMM also preserves the order in which requests were sent, so mutations that should be visually ordered now get this support for free; for example, the DMM will only send the messages in the exact order in which the API was invoked, sending messages in the order that users expect a messaging service to work.The Developer ExperienceAs seen above, there are many benefits to centralizing mutations and the flow of optimistic state. The Mutation Manager not only enforces good patterns for the app, but its also makes adding new mutations to this system extremely simple and quick. When adding a new mutation type, the compiler will guide you to answer all necessary questions about this request (network payloads, optimistic entries, etc). This ensures that as our team grows, our UX remains performant and reliable. Let’s take the “Mark Thread as Read” mutation as an example. Previously, this mutation applied optimistic state directly to the Server-Data cache. As a result, that data could accidentally be clobbered back to an Unread state. To prevent this, we introduced merging logic directly in the Server-Data cache, which, while functional, was unfortunately quite complicated. However, once the mutation was moved onto the DMM, not only did it drastically simplify the merging logic, but it also resulted in a more consistent experience for the user. Additionally, requests within the Mutation Manager are easier to debug. In our employee-only debug builds, the Mutation Manager logs events to a file that can be uploaded by the bug reporter. The engineer is then able to easily parse these logs and diagnose the request. In this example, we can see the request failed on the first attempt with a 500 error code, retried a second later, and succeeded.As you can see, this infrastructure allows our product teams to move quickly without compromising performance and reliability. Check out our open engineering roles to join a fast-moving team at Instagram today.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*hn1cPtyuSP9VYlojdkb_hA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"8932\" data-testid=\"storyTitle\"\u003eMaking Direct Messages Reliable and Fast\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@tommycrush?source=post_page---byline--a152bdfd697f---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Tommy Crush\" src=\"https://miro.medium.com/v2/resize:fill:88:88/2*Fc2abKtqegwx6h6ZCLHEkw.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://instagram-engineering.com/?source=post_page---byline--a152bdfd697f---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Instagram Engineering\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*CPgwLHR6jno_tOmF0--7eg.jpeg\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"629c\"\u003e\u003cp\u003eOver the last few years, Instagram Direct has grown to be a core part of sharing content and experiences with your close friends on Instagram. This isn’t a privilege we take lightly; it’s incredibly important that we deliver each message as reliably and as quickly as possible.\u003c/p\u003e\u003cp\u003e The Internet transfers data at the Speed of Light, but in many cases, due to large distances and network inefficiencies, the human eye can still pickup on the delay between a request’s start and finish. Additionally, network requests can fail for a wide variety of reasons, such as connection-loss or transient server issues. In this blog post, we’ll discuss Instagram’s infrastructure on iOS and Android to not only retry these actions, but also to make the whole experience \u003cem\u003efeel\u003c/em\u003e much faster and reliable to the user.\u003c/p\u003e\u003c/div\u003e\u003ch2 id=\"0642\"\u003eHow mobile apps make network requests look fast\u003c/h2\u003e\u003cp id=\"3946\"\u003eOften, when someone is building a mobile app that wants to “mutate” state on the server (such as tell the server to send a message), they have their view layer initiate a network request. It doesn’t take long before the developer realizes that this request could easily take a second or two even in good network conditions.\u003c/p\u003e\u003cp id=\"b52a\"\u003eA common pattern used to make it seem like the application is fast and responsive (i.e., reduce the user-perceived latency) is to “optimistically” guess the expected output of the successful request and immediately apply it to the view — all before the request is even made. We call this concept “optimistic state”.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv id=\"e51a\"\u003e\u003cp\u003eIn this iOS example, I have an app that stores a color. The existing color, Red, is stored in \u003ccode\u003e_savedColor\u003c/code\u003e, but when MyViewController has set off a network request to change it, the app immediately overwrites the view\u0026#39;s color to Blue, in the \u003ccode\u003e_updatingToColor\u003c/code\u003e value. This makes the app feel much faster than waiting for the request to complete.\u003c/p\u003e\u003cp\u003e This pattern, however, becomes unmanageable as the application grows. \u003c/p\u003e\u003cp\u003e If I leave MyViewController, the other views in the app that depend on the same color value don\u0026#39;t reflect this ongoing request. This confuses the user, and makes the app look inconsistent, buggy, and slow! To handle this, many developers simply apply the Color change to the app\u0026#39;s global data-cache. In fact, Direct also used to apply optimistic changes to our global caches. But this poses many problems, too. What happens if some other event (such as fetching the Color from network) overwrites my ongoing-Blue color back to Red? This concept is referred to as “\u003ca href=\"https://en.wikipedia.org/wiki/Clobbering\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eClobbering\u003c/a\u003e”. It creates weird experiences for the user, and it\u0026#39;s difficult for developers to debug/reproduce.\u003c/p\u003e\u003c/div\u003e\u003cp id=\"3dbd\"\u003eAdditionally, tying a network request to a short-lived ViewController causes its own set of issues. If my request fails for a retriable reason, such as a loss of network, we should be able to perform this request again later, even if MyViewController is deallocated.\u003c/p\u003e\u003cp id=\"2ca5\"\u003eAs you can quickly see, optimistic state and network-request retry-logic are easy to build, but difficult to get right.\u003c/p\u003e\u003ch2 id=\"feed\"\u003eDirect’s Mutation Manager\u003c/h2\u003e\u003cdiv id=\"646d\"\u003e\u003cp\u003eGiven the number of different network conditions we must operate within, and the number of product surfaces we must support, building a consistent retry and optimistic state policy is a difficult task. To solve these problems, we built a piece of infrastructure that we call the Mutation Manager. \u003c/p\u003e\u003cp\u003e The Mutation Manager is designed to answer the questions above. Specifically, we wanted to make it effortless for mobile engineers to get:\u003c/p\u003e\u003c/div\u003e\u003cul\u003e\u003cli id=\"cbea\"\u003eIntelligent and customizable auto-retry strategies for their network requests, with backoff behavior and retries across cold-starts.\u003c/li\u003e\u003cli id=\"1c01\"\u003eOptimistic State applied to all surfaces of the application, and free lifecycle management (adding, removing, handling clobbering, etc).\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"1114\"\u003eHow the Mutation Manager Works\u003c/h2\u003e\u003cdiv id=\"c339\"\u003e\u003cp\u003eDirect’s Mutation Manager (or short: DMM) achieves these goals (and more) by creating a centralized service that owns the network requests, serializes them to disk for retries, and safely manages the flow of their resulting optimistic state.\u003c/p\u003e\u003cp\u003e In Instagram Direct, all surfaces implement this pattern. Let’s follow an example: imagine you navigate into a Direct thread with a message your friend just sent you. In that scenario, these steps occur:\u003c/p\u003e\u003c/div\u003e\u003col\u003e\u003cli id=\"d1fa\"\u003eSubmit a “Mark Thread as Read” mutation to the DMM.\u003c/li\u003e\u003cli id=\"ff37\"\u003eThe DMM saves an entry into the OptimisticState cache. This entry is an instruction object, which describes the desired data change before the data is given to any UI.\u003c/li\u003e\u003cli id=\"f62c\"\u003eMutation is saved to disk, in case we need to retry after an app termination such as a crash.\u003c/li\u003e\u003cli id=\"3bb6\"\u003eThe UI will then use ViewModels, which represent the merged state of the published-data and the entry that was saved to the OptimisticState cache.\u003c/li\u003e\u003cli id=\"40cc\"\u003eThe network request is sent out. Each mutation has a MutationToken in its payload, which is a unique id created on the client.\u003c/li\u003e\u003cli id=\"6700\"\u003eOnce we have received the new confirmed state (with the matching MutationToken) from the server and updated the published-data, we remove and thus stop applying the entry from the optimistic state cache.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv id=\"658e\"\u003e\u003cp\u003eAfter all our mutations and surfaces were migrated to this pattern, optimistic state became an afterthought of product development, and yet all UX surfaces remain consistent and the app feels fast to the user. Since optimistic state and server data are stored separately, and only merged on-the-fly at the View layer, \u003ca href=\"https://en.wikipedia.org/wiki/Clobbering\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eClobbering\u003c/a\u003e is impossible. \u003c/p\u003e\u003cp\u003e Of course, nothing is free. The \u003cem\u003eamount\u003c/em\u003e of client-side processing happening here has definitely increased. But, in practice, we’ve been able to mitigate any performance issues by keeping the application of the Optimistic State entry to the View Model as cheap as possible. \u003c/p\u003e\u003cp\u003e The DMM also preserves the order in which requests were sent, so mutations that should be visually ordered now get this support for free; for example, the DMM will only send the messages in the exact order in which the API was invoked, sending messages in the order that users expect a messaging service to work.\u003c/p\u003e\u003c/div\u003e\u003ch2 id=\"3c2e\"\u003eThe Developer Experience\u003c/h2\u003e\u003cdiv id=\"5d1b\"\u003e\u003cp\u003eAs seen above, there are many benefits to centralizing mutations and the flow of optimistic state. The Mutation Manager not only enforces good patterns for the app, but its also makes adding new mutations to this system extremely simple and quick. When adding a new mutation type, the compiler will guide you to answer all necessary questions about this request (network payloads, optimistic entries, etc). This ensures that as our team grows, our UX remains performant and reliable.\u003c/p\u003e\u003cp\u003e Let’s take the “Mark Thread as Read” mutation as an example. Previously, this mutation applied optimistic state directly to the Server-Data cache. As a result, that data could accidentally be clobbered back to an Unread state. To prevent this, we introduced merging logic directly in the Server-Data cache, which, while functional, was unfortunately quite complicated. However, once the mutation was moved onto the DMM, not only did it drastically simplify the merging logic, but it also resulted in a more consistent experience for the user.\u003c/p\u003e\u003cp\u003e Additionally, requests within the Mutation Manager are easier to debug. In our employee-only debug builds, the Mutation Manager logs events to a file that can be uploaded by the bug reporter. The engineer is then able to easily parse these logs and diagnose the request. In this example, we can see the request failed on the first attempt with a 500 error code, retried a second later, and succeeded.\u003c/p\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"44c2\"\u003eAs you can see, this infrastructure allows our product teams to move quickly without compromising performance and reliability. Check out our \u003ca href=\"https://www.instagram.com/about/jobs/#Software%20Engineering\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eopen engineering roles\u003c/a\u003e to join a fast-moving team at Instagram today.\u003c/p\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2019-06-05T14:57:10.205Z",
  "modifiedTime": null
}
