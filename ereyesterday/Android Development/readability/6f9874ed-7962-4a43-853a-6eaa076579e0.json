{
  "id": "6f9874ed-7962-4a43-853a-6eaa076579e0",
  "title": "Building a macOS screen saver in Kotlin",
  "link": "https://zsmb.co/building-a-macos-screen-saver-in-kotlin/",
  "description": "This article documents how I created my own custom screen saver for macOS, built almost entirely in Kotlin, using the powers of Kotlin Multiplatform compiled to macOS. Join me for a tale of Kotlin success and macOS failures.",
  "author": "M√°rton Braun",
  "published": "Tue, 05 Mar 2024 12:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "M√°rton Braun",
  "length": 33310,
  "excerpt": "This article documents how I created my own custom screen saver for macOS, built almost entirely in Kotlin, using the powers of Kotlin Multiplatform compiled to macOS. Join me for a tale of Kotlin success and macOS failures.",
  "siteName": "zsmb.co",
  "favicon": "",
  "text": "This article documents how I created my own custom screen saver for macOS, built almost entirely in Kotlin, using the powers of Kotlin Multiplatform to target macOS. The inspiration for this project was the KotlinConf 2023 idle video, which had Kotlin‚Äôs logos through the ages bouncing around the screen, in the style of classic DVD player screen savers. When I found out that this was a pre-rendered video, and in fact not a screen saver I could just grab and start using, I figured it‚Äôs a nice challenge to try to build it ‚Äî in Kotlin, of course. Here‚Äôs the end result: I also went a bit further, and added customization options. These include a second logo set (images of Kodee instead of the Kotlin logos), and options to configure the speed, size, and number of logos bouncing around. This way you can choose for yourself, whether you‚Äôd prefer a single Kotlin logo bouncing around, or a hundred Kodees: You can find the code for this screen saver in the GitHub project ‚≠êÔ∏è, where you‚Äôll also find release binaries and detailed installation instructions. If you choose to use this screen saver and enjoy it, I‚Äôd really appreciate it if you shared it on social media and tagged me in the post! I‚Äôm also happy to accept improvement ideas and PR contributions to the repository. I‚Äôve managed to cobble this together with no macOS development experience, I‚Äôm sure there are many things that could be done in a nicer way. Now, let‚Äôs see how I got here‚Ä¶ A word of warning This probably sounds great so far, so it‚Äôs high time for a word of warning. Here be dragons. And creatures APIs much scarier than dragons. Don‚Äôt say I did not warn you. Creating a custom screen saver for macOS is a barely supported use case, with little to no documentation, which takes you through a perilous path. The problems aren‚Äôt with Kotlin or interoperability ‚Äî this whole system in macOS is rotten. I did my best to document my struggles here. If you want to follow in these footsteps, I wish you the best of luck. You can find a starter project creating a Hello World screen saver with Kotlin in this repository. Just using a custom screen saver can be troublesome too, but I think this one should be perfectly fine to use if you like it. I‚Äôve tried hard to make it a well-behaved process, as you‚Äôll see detailed later on. Table of contents This is a long post. Here‚Äôs what you‚Äôll find in it: Setting up Getting the basics working ScreenSaverView A note about drawing Delegating to Kotlin My development setup Building the screen saver Installing, removing, and re-installing the screen saver Preview problems Development Using AppKit from Kotlin Assets Configuration panel Storing preferences Debugging Previews Thumbnails Distribution macOS Sonoma What‚Äôs really happening How do we fix this Conclusion and resources Setting up Still here? Let‚Äôs get rolling. Getting the basics working To get started with building a screen saver, you can create a project using Xcode‚Äôs project wizard, selecting the macOS category and then Screen Saver. This gives you a project with a blank ScreenSaverView in it that renders nothing at 30 frames per second, with‚Ä¶ ü•Å‚Ä¶ Objective-C code! As I was browsing old posts (which are the only posts you can find on this topic, really), I found many complaints that screen savers may only be implemented in ObjC and not Swift. Luckily, this has improved since then, and Swift works just fine as well. With that, we can convert the starter code to Swift. import ScreenSaver class KotlinLogosView : ScreenSaverView { override init?(frame: NSRect, isPreview: Bool) { super.init(frame: frame, isPreview: isPreview) animationTimeInterval = 1 / 60.0 // Bumped to 60 fps } required init?(coder decoder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } override func animateOneFrame() { super.animateOneFrame() } override var hasConfigureSheet: Bool { return false } override var configureSheet: NSWindow? { return nil } } ScreenSaverView The reference documentation of this class provides an overview of its methods, while the screen saver documentation gives a basic overview of its behaviour. Let‚Äôs examine its contents briefly: init is where your setup logic goes. You get access to an isPreview parameter, should you want to draw your screen saver differently in the preview that‚Äôs shown in System Settings than when in ‚Äúproduction‚Äù. An overload that takes an NSCoder is also required, but apparently can have an always-failing implementation. animateOneFrame is called periodically as time passes, to be used to update the state of the screen saver (for example, move objects by one step). You can also choose to draw the updated state of the screen saver in this method, which is what I chose to do. hasConfigureSheet determines whether there are configuration options available for your screen saver in System Settings, and configureSheet is the UI that will be shown when someone clicks the Options‚Ä¶ button while your screen saver is selected. A note about drawing The documentation of animateOneFrame says: The system locks focus on your view before it calls this method, so you can use this method to draw content. You can also let draw(_:) perform the drawing, in which case you use this method to call setNeedsDisplay(_:) to mark your view as dirty. So, the choice is either: Just update your state and then draw in animateOneFrame. Update your state in animateOneFrame and then call setNeedsDisplay when done. Also implement draw to perform your drawing, which will be triggered by that setNeedsDisplay call. I initially discovered the second way of doing this, and I moved to the first one when I realized that that‚Äôs also an option. I don‚Äôt see why you‚Äôd want to go through the draw method. Delegating to Kotlin So we have our entry point in Swift, and try as I might, I did not manage to move that class to the Kotlin side of the code. So what I ended up with is a thin Swift ScreenSaverView implementation which instantiates a similar class that‚Äôs defined in Kotlin, and then delegates the implementation of its methods to the Kotlin code. I‚Äôll be omitting some details in the code snippets here for readability, but you‚Äôll always find the full code on GitHub. import ScreenSaver import KotlinLogo class KotlinLogosView: ScreenSaverView { let kotlinScreenSaverView = KotlinScreenSaverViewKt.create() override init?(frame: NSRect, isPreview: Bool) { super.init(frame: frame, isPreview: isPreview) kotlinScreenSaverView.doInit(screenSaverView: self, isPreview: isPreview) } override func animateOneFrame() { super.animateOneFrame() kotlinScreenSaverView.animateOneFrame() } override var hasConfigureSheet: Bool { kotlinScreenSaverView.configureSheet != nil } override var configureSheet: NSWindow? { kotlinScreenSaverView.configureSheet } } Let‚Äôs see what this calls on the Kotlin side: fun create(): KotlinScreenSaverView = LogoScreenSaverView() abstract class KotlinScreenSaverView { protected lateinit var view: ScreenSaverView private set protected lateinit var bundle: NSBundle private set protected var isPreview = false private set open fun init(screenSaverView: ScreenSaverView, isPreview: Boolean) { this.view = screenSaverView this.bundle = NSBundle.bundleWithIdentifier(\"co.zsmb.KotlinLogos\")!! this.isPreview = isPreview } abstract fun animateOneFrame() open val configureSheet: NSWindow? = null } This is a simple base class, mimicking the ScreenSaverView framework class. It sets up some basic values that will be accessible in the concrete implementation. That implementation is provided to the Swift code by the create factory function above the class. Before we dive further into the code, now that we have some Swift and some Kotlin, it‚Äôs a good time to have a look at what I used to work on this project. My development setup Xcode was required for getting started and setting up the project, but with the initial steps done, I could proceed to use Fleet for all the rest of my work. I initially wrote a proof of concept implementation in Swift, and then gradually worked towards moving more and more of the code into Kotlin. Things like cross-language navigation to usages work like a charm here! Building the screen saver The project can be built from Xcode, but it‚Äôs also fairly easy to build it from Fleet. I created the following run configurations in Fleet (.fleet/run.json) to make it easy to run builds: { \"configurations\": [ { \"type\": \"command\", \"name\": \"xcodebuild debug\", \"program\": \"xcodebuild\", \"args\": [\"-scheme\", \"KotlinLogos\", \"build\"], \"workingDir\": \"KotlinLogos\", }, { \"type\": \"command\", \"name\": \"xcodebuild release\", \"program\": \"xcodebuild\", \"args\": [\"-scheme\", \"KotlinLogosRelease\", \"build\"], \"workingDir\": \"KotlinLogos\", }, ] } These are conveniently available on the UI once set up: A successful build of the project will produce a screen saver file with the .saver extension. The output folder is somewhat hard to find, in my case it was at a path like this: ~/Library/Developer/Xcode/DerivedData/KotlinLogos-fczypfdumappcugzfailioehwspp/Build/Products/Debug/KotlinLogos.saver If you‚Äôre building in Xcode, you can use Product -\u003e Show Build Folder in Finder to find this folder. When building from Fleet, I found that the end of the output contains this location as well, making it easy to copy and then cd to or open directly: /usr/bin/codesign --force --sign - --timestamp\\=none --generate-entitlement-der \\ /Users/zsmb/Library/Developer/Xcode/DerivedData/KotlinLogos-fczypfdumappcugzfailioehwspp/Build/Products/Debug/KotlinLogos.saver ** BUILD SUCCEEDED ** A neat way of keeping track of this folder in Fleet is to add it to the workspace in addition to the project folder. This can be done by just dragging the extra folder into the Files view: If you‚Äôre ever looking at the Date Modified field of your .saver in Finder, don‚Äôt be surprised if you don‚Äôt see it updating as you‚Äôre running new builds. It seems like it gets stuck at the first time this file was created. Of course, this isn‚Äôt really a file, it‚Äôs one of the magic actually-just-a-folder formats of macOS. You can see this easily in the Fleet Files panel. Installing, removing, and re-installing the screen saver To install a screen saver on macOS, open its .saver file. This will open System Settings and ask you if you want to install it. If you‚Äôre installing an updated version of the screen saver, you‚Äôll get some additional warnings. Expect about 2‚Äì4 popups that you need to confirm each time, as there tend to be buggy duplicate popups created here depending on your OS version, and apparently, the speed with which you accept them. You might think installing a new build of the screen saver and confirming a couple of times that you want to replace the old one is sufficient for changes to take effect, but you‚Äôd be wrong. There are many, many things you can do ‚Äúwrong‚Äù to not cause the screen saver to be refreshed. It can be quite frustrating trying to check the effects of code changes you‚Äôve made, only to eventually figure out that you never managed to launch the new version. Here are all the things you can attempt to make sure that your changes are applied: Delete your old output files before running a new build Build your project Go to Activity Monitor and force quit any legacyScreenSaver processes (especially on Sonoma - we‚Äôll discuss this more later) Go to System Settings, choose any screen saver other than your custom one Delete your custom screen saver from System Settings Quit System Settings Install your new screen saver and perform the dialog dance You don‚Äôt always need all these steps, but you will find yourself in situations where missing one of them somehow makes your screen saver not update. From my latest experience, normally it‚Äôs enough to quit System Settings and force quit any legacyScreenSaver processes before installing an updated version. You can also install or remove a screen saver manually by going to ~/Library/Screen Savers. To install something, place it in this folder. To remove it, delete its file. Preview problems If after installing your screen saver your preview in System Settings doesn‚Äôt animate, or the Options‚Ä¶ button doesn‚Äôt do anything when clicked, select another screen saver and then select your custom screen saver again. Not sure why this is required and whether there‚Äôs a nice fix for it. Development With those detours about setup and installing a screen saver, it‚Äôs time to get into how you can implement one with Kotlin! Using AppKit from Kotlin So we have access to a ScreenSaverView instance from Kotlin code. How can we draw on this? The approach I took was to create AppKit views and add them as children (subviews) to the ScreenSaverView. This is made possible by all these system APIs being mapped in Kotlin native with interop, and automatically made available. For example, to put an image on the screen, you can instantiate an NSImageView, set its image to an NSImage, and use NSMakeRect to create a rectangle describing its on-screen position: val imageView = NSImageView().apply { imageScaling = NSImageScaleProportionallyUpOrDown image = loadImage() // Grab an NSImage, for example from assets frame = NSMakeRect(x = 300.0, y = 300.0, w = 200.0, h = 200.0) } screenSaverView.addSubview(imageView) To progress this image across the screen, we can simply update the x and y coordinates every time a new frame is requested. This is done by calling NSMakeRect again with the new values and assigning this to the frame of the view: imageView.frame = NSMakeRect(x = newX, y = newY, w = 200.0, h = 200.0) To remove a view that you no longer want to display: imageView.removeFromSuperview() You can use these interop APIs to easily create and place any type of AppKit views, such as an NSTextView. Assets The screen saver needs to contain the various Kotlin logos and images of Kodee. To package these with the screen saver, I‚Äôve added them to the Assets of the Xcode project. For some reason I initially thought these assets could not be SVGs, so I used huge PNG files, as you can see in the history of the repository. However, SVGs actually work just fine too, so that‚Äôs what the current implementation uses. Shout-out to Boxy SVG, which I found while trying to make some minor edits to the Kotlin logos that I had. It‚Äôs a super simple and useful tool. Accessing these assets is possible through a Bundle - or an NSBundle when looking at it from Kotlin. This is simple enough, using the name of the asset: val image: NSImage = bundle.imageForResource(\"kodee-greeting\") However, for a good while I could only instantiate the NSBundle to work with in Swift code: let bundle = Bundle(for: type(of: self)) ‚Ä¶ and then I passed this to the Kotlin code. I wanted to move the creation of the Bundle to the Kotlin side as well, but I did not find a way to express type(of: self) in Kotlin code. Through some debugging, I eventually found the following solution instead, which grabs the Bundle based on the app‚Äôs identifier: val bundle = NSBundle.bundleWithIdentifier(\"co.zsmb.KotlinLogos\")!! Storing preferences Next, let‚Äôs look at making the screen saver user-configurable. The first step for this is to find a place for persistent value storage. The documentation says you‚Äôre supposed to use ScreenSaverDefaults. I have missed this initially and used UserDefaults instead. This turned out to be lucky, as when I later tried moving to ScreenSaverDefaults instead, it failed to notify my screen saver of changes in values, and it also wouldn‚Äôt persist them through re-launches of the screen saver. I assume I was doing something wrong, but I ended up with reverting to UserDefaults as that works perfectly fine. As with previous iOS APIs, this can be accessed seamlessly from Kotlin. I have a bit of a history of storing preferences using delegated properties, so I‚Äôve applied that pattern again, like so: class UserDefaultDelegate(private val default: Long) : ReadWriteProperty\u003cAny?, Int\u003e { private val userDefaults = NSUserDefaults() override fun getValue(thisRef: Any?, property: KProperty\u003c*\u003e): Int { return ((userDefaults.objectForKey(property.name) as? Long) ?: default).toInt() } override fun setValue(thisRef: Any?, property: KProperty\u003c*\u003e, value: Int) { userDefaults.setInteger(value.toLong(), property.name) } } I‚Äôve then created a Preferences object in my project to hold such values in a globally accessible place: object Preferences { var LOGO_SET by UserDefaultDelegate(0) var LOGO_SIZE by UserDefaultDelegate(200) var LOGO_COUNT by UserDefaultDelegate(1) var SPEED by UserDefaultDelegate(10) } Lastly, I wanted my implementation to know whenever these values changed through the configuration panel, so that I can reload the logos. This is useful to immediately reflect changes in the System Settings preview, for example, without having to quit and reopen it. This can also be easily set up, using NSNotificationCenter and NSUserDefaultsDidChangeNotification: NSNotificationCenter.defaultCenter .addObserverForName(NSUserDefaultsDidChangeNotification, null, null) { initLogos() } Configuration panel Now that we know where to save values, it‚Äôs time to build the UI where the user can actually change them. This is the configuration panel that‚Äôs accessed through the Options‚Ä¶ button in System Settings. Building this panel required way more traditional UI work than anything else around the screen saver. Having no real experience with AppKit or UIKit made it an interesting challenge to figure out how to use the various constraint APIs to get the desired layout, even though I just had to stack things vertically and horizontally. My understanding is that programmatically creating UI elements is actually popular with these toolkits, but I could not really get behind that. You can find what I‚Äôve managed to cobble together in this file. It‚Äôs not spectacular, but it‚Äôs decently navigable code and it gets the job done. The hardest part of this UI building was setting listeners on elements, such as the OK and Cancel buttons. In Swift, this would look something like this, referencing a method of the current controller class: okButton.target = self okButton.action = #selector(ViewController.performOk) The first line here is easy enough, it‚Äôs the fancy selector that‚Äôs hard to translate to Kotlin. With some help from Florian Kistner (builder of KMP tooling for Fleet!), I eventually figured out that this sort of syntax works, naming a public function of the controller in a stringly typed manner: target = this action = NSSelectorFromString(\"performOk\") As I found this terrifying, I ended up wrapping it like so: private fun NSControl.setListener(selfFunc: KFunction\u003cUnit\u003e) { target = this@KotlinLogosPrefController action = NSSelectorFromString(selfFunc.name) } Which gives us these kinds of neat use sites: val okButton = NSButton().apply { setListener(::performOk) } Here, again, aggressively quitting System Preferences before deploying a new build of your screen saver comes in handy. If you don‚Äôt do this, it‚Äôs more than likely that the configuration UI will keep running an old instance without your latest changes. I learned this quickly after an hour or two of debugging. Debugging Screen savers are interesting applications to debug. You can‚Äôt really run them in debug mode to place breakpoints, and you also can‚Äôt really run them directly from the IDE to even just capture logs easily. This article from 2005 is (unfortunately) still an important article in the screen saver topic. It has a tip to automatically copy the newly built screen saver on top of the old one ‚Äî I did not try this, though some of the issues I was having would have definitely broken this. Another good strategy from the past was to invoke the system‚Äôs ScreenSaverEngine in debug mode, make it host your screen saver, and have Xcode connect to it for debugging purposes. As far as I understand, this is no longer possible due to new OS level protections that don‚Äôt allow you to do this to ScreenSaverEngine. The best idea I saw pop up in discussions was in this comment on StackOverflow, which is to create a macOS application within your Xcode project that takes your ScreenSaverView implementation and displays it in a window. I have tried this briefly and failed to get through configuring this in Xcode. I assume it‚Äôs possible to do if you‚Äôre more familiar with the tool. So with that, I was stuck with testing my screen saver in production, by installing it and starting it as normal every time I‚Äôve changed something. I also used the following: Another tip I need to thank Florian for teaching me was that I can use NSLog to log things from my screen saver, and then I can open the macOS Console app to start listening for logs and filter for the ones that my screen saver produced. I also saw the occasional screen saver process crash here, which was useful. I built myself some ‚Äúdebug mode‚Äù functionality within the screen saver itself, controlled by a boolean flag that I‚Äôd change manually for debug and release builds. When this was turned on, I‚Äôve added NSTextView instances to the UI and then set them to display strings of debug information, like coordinates and indices. I‚Äôve since removed this in an effort to optimize the screen saver code, but you can go to this revision to check out how it worked. Previews The System Settings dialog for setting up screen savers offers a nice, but tiny preview of your screen saver when you select it. It does this by instantiating your ScreenSaverView implementation and running it in a process called legacyScreenSaver (Screen Saver (System Settings)). It‚Äôs definitely descriptive! This comes with a fun challenge: the code you write to display at full screen sizes (the screen size on my MacBook measures as 2056 x 1329) is forced into a much, much smaller space (143 x 80 on my machine). If you‚Äôve been hardcoding bouncing Kotlin logos that are 200‚Äì400 wide on their own, you‚Äôre going to have a bad time, and this preview will just keep crashing. My workaround for this was to compute a magic multiplier that I then use to scale all dimension measurements by. You can find the implementation in this file. Thanks to this, not only does the screen saver work fine in the tiny preview window, but it also has pretty reasonable sizing for its elements on screens of different sizes, ratios, and densities. Thumbnails To give your custom screen saver a nice thumbnail image in System Settings, you have to add an asset called thumbnail to your project. This gives you something like this: There‚Äôs a well-known bug which makes these thumbnails look awful for custom screen savers, which I also experienced while creating mine. However, I think updating to Sonoma might have actually fixed this, because it seems alright now. Distribution To properly ship a screen saver, the distribution steps are very similar to distributing any other macOS application. The signing part for a screen saver is slightly complicated, but this article seems to describe it really nicely. This is a shockingly good resource considering the general availability information in this whole topic. However, this does still require an Apple developer account, which costs about $99 more than what it‚Äôd be worth for me at this time. This leaves me without a nicely signed release version of my screen saver. To get the Kotlin Logo screen saver, you can either take the unsigned release binaries from the GitHub releases page that I‚Äôve published and click through the warnings that macOS presents, or clone the project and build it yourself. macOS Sonoma More like custom screen savers no ma‚Äô, am I right..? The latest version of macOS at the time of writing is Sonoma, which was released while I was developing this screen saver and writing up this post. Sonoma has apparently brought two great new updates in the realm of screen savers: Fancy new screen savers built-in to the OS, making people more likely to stick to these than go for custom ones. Tons of new bugs and problems around custom screen savers. It seems like Sonoma has trouble properly shutting down the legacyScreenSaver process that hosts any custom ScreenSaverView. This can cause various problems, including unnecessary CPU use, severe memory leaks, and complete crashes of a custom screen saver where it will just show up as a blank black screen. Here are a few examples of these issues being reported‚Ä¶ What‚Äôs really happening Here‚Äôs how that latter problem works in detail, from my testing: When your screen saver is first displayed, the legacyScreenSaver (Wallpaper) process starts, and an instance of your ScreenSaverView implementation is created and added to view, displaying the screensaver. So far so good. When you dismiss the screen saver and your content is no longer visible, this process keeps going in the background, running your ScreenSaverView code, still calling methods like animateOneFrame repeatedly (in the case of my code, bouncing Kodees around constantly). This seems to keep going indefinitely. Uh-oh. When you enter the screen saver again, the process is reused, but a new ScreenSaverView is created and displayed. The old one still doesn‚Äôt get dismissed however, it keeps hanging out in the process next to the new one. As you might be able to tell at this point, this leads to a fascinating stacking of actively spinning ScreenSaverView instances over time, as you show and dismiss the screen saver. Depending on the intensity of the screen saver implementation (in our example, how many logos you have bouncing and how fast), these can add 1‚Äì10% CPU usage with every new stack. Somewhere above 100%, the process gives up and simply fails, requiring you to force quit it to see your screen saver again. Warning: rapidly flashing video below. (Video is at 2x speed) In previous macOS versions, the ScreenSaverView would no longer receive callbacks after it‚Äôs dismissed, as one might reasonably expect. At this point, you might also wonder what happens when you have multiple displays connected, as visually, these all run their own independent copies of your custom screen saver. As an example, for three displays the implementation creates three instances of your ScreenSaverView, which are all hosted in the same process. Dismissing and entering the screen saver again creates three new instances of your ScreenSaverView again. So the more displays you have, the faster you‚Äôre stacking up invisible, leaking views. The challenge, then, is to figure out when your ScreenSaverView isn‚Äôt being shown anymore, and dealing with that scenario in the best way possible. For a start, it‚Äôd be nice if the instances that are no longer visible wouldn‚Äôt do any work when their methods are called. Even better would be to be able to destroy them (or at least all but the latest instance). Ideally, we should be able to shut down the screen saver entirely once it‚Äôs dismissed. How do we fix this The superclass has startAnimation and stopAnimation methods which I never needed to use in my implementation, but figured I could attempt to use here. One of the first mitigation strategies I tried was to simply set a flag, and skip doing any work in animateOneFrame after stopAnimation has happened. This was clearly naive, which I realized as I kept testing and saw that stopAnimation is essentially never called in production, only in the System Settings preview. During my testing, I saw that global variables are kept around through instances, as the process hosting these stacking views is the same one over time. You can use this, for example, to count how bad the situation has gotten: var viewCount = 0 class KotlinLogosView: ScreenSaverView { override init?(frame: NSRect, isPreview: Bool) { super.init(frame: frame, isPreview: isPreview) NSLog(\"Created instance \\(viewCount)\") viewCount += 1 } } You can also use it to keep track of the previous instance of the view, and remove it from its parent when a new one is created in its place: var previousView: ScreenSaverView? = nil class KotlinLogosView: ScreenSaverView { override init?(frame: NSRect, isPreview: Bool) { super.init(frame: frame, isPreview: isPreview) if let prev = previousView { prev.removeFromSuperview() } previousView = self } } This sort of helps (as long as you have a single display), as it makes sure that there‚Äôs only ever one active instance of the ScreenSaverView. However, it still doesn‚Äôt shut that instance down when the screen saver is dismissed, so you have a spinning screen saver in the background eating up resources 24/7. Having been able to save this previousView reference, I figured I could check various properties of the previous view at the time when the new view is being created. If I found a property that tells me that previousView isn‚Äôt actually visible, perhaps I could check for the value of that property in animateOneFrame, and shut down my view manually. I tested a dozen different properties describing whether the view is animated, hidden, whether its window is the main or key window, and so on, and so on. I did not find anything that would change its value at the time when the screen saver is dismissed. Seeing earlier how I could react to changes in NSUserDefaults values using notification observers, I‚Äôve tried searching the list of available notification types, and I subscribed to several like NSApplicationDidHideNotification. None of these were being called when the screen saver was dismissed either. Another dead end. Eventually, after even more searching around, I found some answers describing another approach of subscribing to events. This included willstop and didstop events, and these are actually delivered to your screen saver! ü§Ø In theory, either of these two events should be fine to catch and react to, but I had a test run where only the willstop one was being caught, so I‚Äôve stuck to using that. Your mileage may of course vary. class KotlinLogosView: ScreenSaverView { override init?(frame: NSRect, isPreview: Bool) { super.init(frame: frame, isPreview: isPreview) DistributedNotificationCenter.default.addObserver( self, selector: #selector(KotlinLogosView.willStop(_:)), name: Notification.Name(\"com.apple.screensaver.willstop\"), object: nil ) } @objc func willStop(_ aNotification: Notification) { // Do something! } } The only remaining question is, what to do when this happens? I initially made a self.removeFromSuperview() call, which nicely shuts down the ScreenSaverView when it should. When doing this, the legacyScreenSaver process still sticks around 24/7, but consumes a negligible amount of resources. I have later figured out that I can also just shut down the entire process programmatically, which seems to not cause any practical issues. To only handle the fullscreen mode of our screen saver and not when it‚Äôs being previewed in System Settings, we‚Äôll wrap this action in a check of the isPreview property. @objc func willStop(_ aNotification: Notification) { if (!isPreview) { NSApplication.shared.terminate(nil) } } Now, could I move this to Kotlin? I think I could. But I‚Äôll just pretend that the bugs here will eventually get fixed, and then I can remove this code instead of moving it. Conclusion and resources Check out the GitHub repository for the screen saver where you‚Äôll find builds, installation instructions, and all the code. Star it, open PRs, file issues. Buy it, use it, break it, fix it. I‚Äôve also created a blank starter project for Kotlin-based macOS screen savers which you can use if you want to build your own. Finally, here are some other screen saver projects I found while researching this topic which seem like they might be useful to reference: ayltai/MacOS-Developers-Excuses pedrommcarrasco/Brooklyn AerialScreensaver/ScreenSaverMinimal ggu/LanguageSaver Have you ever encountered APIs that show warnings or errors when you use them, saying that they're internal or experimental? In this guide, you'll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.StateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.For the longest time, I proudly had no idea of how Modifier ordering works, and would just guess and then guess again when something didn't look quite right. Here's how I finally ended up remembering how the ordering works.Another year over, a new one's almost begun. Here's a brief summary of what I've done in this one.",
  "image": "https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/meta.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003cp\u003eThis article documents how I created my own \u003ca href=\"https://github.com/zsmb13/KotlinLogo-ScreenSaver\"\u003ecustom screen saver for macOS\u003c/a\u003e, built almost entirely in Kotlin, using the powers of \u003ca href=\"https://www.jetbrains.com/kotlin-multiplatform/\"\u003eKotlin Multiplatform\u003c/a\u003e to target macOS.\u003c/p\u003e\n\u003cp\u003eThe inspiration for this project was the KotlinConf 2023 idle video, which had Kotlin‚Äôs logos through the ages bouncing around the screen, in the style of \u003ca href=\"https://www.youtube.com/watch?v=QOtuX0jL85Y\"\u003eclassic DVD player screen savers\u003c/a\u003e.\u003c/p\u003e\n\u003cvideo autoplay=\"\" controls=\"\" loop=\"\" muted=\"\" width=\"100%\"\u003e\n    \u003csource src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/kc2023_idle_video.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003cp\u003eWhen I found out that this was a pre-rendered video, and in fact \u003cem\u003enot\u003c/em\u003e a screen saver I could just grab and start using, I figured it‚Äôs a nice challenge to try to build it ‚Äî in Kotlin, of course.\u003c/p\u003e\n\u003cp\u003eHere‚Äôs the end result:\u003c/p\u003e\n\u003cvideo autoplay=\"\" controls=\"\" loop=\"\" muted=\"\" width=\"100%\"\u003e\n    \u003csource src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/kotlin_screensaver_logo.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003cp\u003eI also went a bit further, and added customization options. These include a second logo set (images of \u003ca href=\"https://blog.jetbrains.com/kotlin/2023/04/the-kotlin-mascot-returns/\"\u003eKodee\u003c/a\u003e instead of the Kotlin logos), and options to configure the speed, size, and number of logos bouncing around.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/config_panel.png\" alt=\"The configuration panel of the screen saver in System Settings\"/\u003e\u003c/p\u003e\n\u003cp\u003eThis way you can choose for yourself, whether you‚Äôd prefer a single Kotlin logo bouncing around, or a hundred Kodees:\u003c/p\u003e\n\u003cvideo autoplay=\"\" controls=\"\" loop=\"\" muted=\"\" width=\"100%\"\u003e\n    \u003csource src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/kotlin_screensaver_kodee.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003cp\u003e\u003cstrong\u003eYou can find the code for this screen saver \u003ca href=\"https://github.com/zsmb13/KotlinLogo-ScreenSaver\"\u003ein the GitHub project\u003c/a\u003e ‚≠êÔ∏è, where you‚Äôll also find release binaries and detailed installation instructions.\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIf you choose to use this screen saver and enjoy it, I‚Äôd really appreciate it if you shared it on social media and tagged me in the post!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eI‚Äôm also happy to accept improvement ideas and PR contributions to the repository. I‚Äôve managed to \u003ca href=\"https://i.kym-cdn.com/entries/icons/original/000/008/342/ihave.jpg\"\u003ecobble this together\u003c/a\u003e with no macOS development experience, I‚Äôm sure there are many things that could be done in a nicer way.\u003c/p\u003e\n\u003cp\u003eNow, let‚Äôs see how I got here‚Ä¶\u003c/p\u003e\n\u003ch2 id=\"a-word-of-warning\"\u003eA word of warning\u003c/h2\u003e\n\u003cp\u003eThis probably sounds great so far, so it‚Äôs high time for a word of warning. \u003cstrong\u003eHere be dragons.\u003c/strong\u003e And \u003cdel\u003ecreatures\u003c/del\u003e APIs much scarier than dragons. Don‚Äôt say I did not warn you.\u003c/p\u003e\n\u003cp\u003eCreating a custom screen saver for macOS is a barely supported use case, with little to no documentation, which takes you through a perilous path. The problems aren‚Äôt with Kotlin or interoperability ‚Äî this whole system in macOS is rotten. I did my best to document my struggles here.\u003c/p\u003e\n\u003cp\u003eIf you want to follow in these footsteps, I wish you the best of luck. You can find a starter project creating a Hello World screen saver with Kotlin \u003ca href=\"https://github.com/zsmb13/Kotlin-macOS-ScreenSaver-Template\"\u003ein this repository\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eJust using a custom screen saver can be troublesome too, but I think this one should be perfectly fine to use if you like it. I‚Äôve tried hard to make it a well-behaved process, as you‚Äôll see detailed \u003ca href=\"#how-do-we-fix-this\"\u003elater on\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003cp\u003eThis is a \u003cstrong\u003elong\u003c/strong\u003e post. Here‚Äôs what you‚Äôll find in it:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#setting-up\"\u003eSetting up\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#getting-the-basics-working\"\u003eGetting the basics working\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#screensaverview\"\u003eScreenSaverView\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#a-note-about-drawing\"\u003eA note about drawing\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#delegating-to-kotlin\"\u003eDelegating to Kotlin\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#my-development-setup\"\u003eMy development setup\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#building-the-screen-saver\"\u003eBuilding the screen saver\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#installing-removing-and-re-installing-the-screen-saver\"\u003eInstalling, removing, and re-installing the screen saver\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#preview-problems\"\u003ePreview problems\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#development\"\u003eDevelopment\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#using-appkit-from-kotlin\"\u003eUsing AppKit from Kotlin\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#assets\"\u003eAssets\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#configuration-panel\"\u003eConfiguration panel\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#storing-preferences\"\u003eStoring preferences\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#debugging\"\u003eDebugging\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#previews\"\u003ePreviews\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#thumbnails\"\u003eThumbnails\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#distribution\"\u003eDistribution\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#macos-sonoma\"\u003emacOS Sonoma\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#whats-really-happening\"\u003eWhat‚Äôs really happening\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-do-we-fix-this\"\u003eHow do we fix this\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion-and-resources\"\u003eConclusion and resources\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"setting-up\"\u003eSetting up\u003c/h2\u003e\n\u003cp\u003eStill here? Let‚Äôs get rolling.\u003c/p\u003e\n\u003ch3 id=\"getting-the-basics-working\"\u003eGetting the basics working\u003c/h3\u003e\n\u003cp\u003eTo get started with building a screen saver, you can create a project using Xcode‚Äôs project wizard, selecting the macOS category and then \u003cem\u003eScreen Saver\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/xcode_wizard.png\" alt=\"The Xcode wizard templates, with the screen saver template selected\"/\u003e\u003c/p\u003e\n\u003cp\u003eThis gives you a project with a blank \u003ca href=\"https://developer.apple.com/documentation/screensaver/screensaverview\"\u003e\u003ccode\u003eScreenSaverView\u003c/code\u003e\u003c/a\u003e in it that renders nothing at 30 frames per second, with‚Ä¶ ü•Å‚Ä¶ Objective-C code!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/xcode_objective_c.png\" alt=\"The freshly generated Xcode project with an Objective-C implemented ScreenSaverView\"/\u003e\u003c/p\u003e\n\u003cp\u003eAs I was browsing old posts (which are the only posts you can find on this topic, really), I found many \u003ca href=\"https://forums.developer.apple.com/forums/thread/110418\"\u003ecomplaints\u003c/a\u003e that screen savers may only be implemented in ObjC and not Swift. Luckily, this has improved since then, and Swift works just fine as well. With that, we can convert the starter code to Swift.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport ScreenSaver\n\nclass KotlinLogosView : ScreenSaverView {\n    override init?(frame: NSRect, isPreview: Bool) {\n        super.init(frame: frame, isPreview: isPreview)\n        animationTimeInterval = 1 / 60.0 // Bumped to 60 fps\n    }\n\n    required init?(coder decoder: NSCoder) {\n        fatalError(\u0026#34;init(coder:) has not been implemented\u0026#34;)\n    }\n\n    override func animateOneFrame() {\n        super.animateOneFrame()\n    }\n\n    override var hasConfigureSheet: Bool { return false }\n    override var configureSheet: NSWindow? { return nil }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"screensaverview\"\u003eScreenSaverView\u003c/h3\u003e\n\u003cp\u003eThe \u003ca href=\"https://developer.apple.com/documentation/screensaver/screensaverview\"\u003ereference documentation\u003c/a\u003e of this class provides an overview of its methods, while the \u003ca href=\"https://developer.apple.com/documentation/screensaver\"\u003escreen saver documentation\u003c/a\u003e gives a basic overview of its behaviour.\u003c/p\u003e\n\u003cp\u003eLet‚Äôs examine its contents briefly:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einit\u003c/code\u003e is where your setup logic goes. You get access to an \u003ccode\u003eisPreview\u003c/code\u003e parameter, should you want to draw your screen saver differently in the preview that‚Äôs shown in System Settings than when in ‚Äúproduction‚Äù. An overload that takes an \u003ccode\u003eNSCoder\u003c/code\u003e is also required, but apparently can have an always-failing implementation.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eanimateOneFrame\u003c/code\u003e is called periodically as time passes, to be used to update the state of the screen saver (for example, move objects by one step). You can also choose to draw the updated state of the screen saver in this method, which is what I chose to do.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehasConfigureSheet\u003c/code\u003e determines whether there are configuration options available for your screen saver in System Settings, and \u003ccode\u003econfigureSheet\u003c/code\u003e is the UI that will be shown when someone clicks the \u003cem\u003eOptions‚Ä¶\u003c/em\u003e button while your screen saver is selected.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"a-note-about-drawing\"\u003eA note about drawing\u003c/h4\u003e\n\u003cp\u003eThe \u003ca href=\"https://developer.apple.com/documentation/screensaver/screensaverview/animateoneframe()\"\u003edocumentation of \u003ccode\u003eanimateOneFrame\u003c/code\u003e\u003c/a\u003e says:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe system locks focus on your view before it calls this method, \u003cem\u003eso you can use this method to draw content\u003c/em\u003e. You can also let \u003ccode\u003edraw(_:)\u003c/code\u003e perform the drawing, in which case you use this method to call \u003ccode\u003esetNeedsDisplay(_:)\u003c/code\u003e to mark your view as dirty.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSo, the choice is either:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eJust update your state and then draw in \u003ccode\u003eanimateOneFrame\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eUpdate your state in \u003ccode\u003eanimateOneFrame\u003c/code\u003e and then call \u003ccode\u003esetNeedsDisplay\u003c/code\u003e when done. Also implement \u003ccode\u003edraw\u003c/code\u003e to perform your drawing, which will be triggered by that \u003ccode\u003esetNeedsDisplay\u003c/code\u003e call.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eI initially discovered the second way of doing this, and I moved to the first one when I realized that that‚Äôs also an option. I don‚Äôt see why you‚Äôd want to go through the \u003ccode\u003edraw\u003c/code\u003e method.\u003c/p\u003e\n\u003ch3 id=\"delegating-to-kotlin\"\u003eDelegating to Kotlin\u003c/h3\u003e\n\u003cp\u003eSo we have our entry point in Swift, and try as I might, I did not manage to move that class to the Kotlin side of the code. So what I ended up with is a thin Swift \u003ccode\u003eScreenSaverView\u003c/code\u003e implementation which instantiates a similar class that‚Äôs defined in Kotlin, and then delegates the implementation of its methods to the Kotlin code.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI‚Äôll be omitting some details in the code snippets here for readability, but you‚Äôll always find the full code \u003ca href=\"https://github.com/zsmb13/KotlinLogo-ScreenSaver/\"\u003eon GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode\u003eimport ScreenSaver\nimport KotlinLogo\n\nclass KotlinLogosView: ScreenSaverView {\n    let kotlinScreenSaverView = KotlinScreenSaverViewKt.create()\n\n    override init?(frame: NSRect, isPreview: Bool) {\n        super.init(frame: frame, isPreview: isPreview)\n        kotlinScreenSaverView.doInit(screenSaverView: self, isPreview: isPreview)\n    }\n\n    override func animateOneFrame() {\n        super.animateOneFrame()\n        kotlinScreenSaverView.animateOneFrame()\n    }\n\n    override var hasConfigureSheet: Bool {\n        kotlinScreenSaverView.configureSheet != nil\n    }\n    override var configureSheet: NSWindow? {\n        kotlinScreenSaverView.configureSheet\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet‚Äôs see what this calls on the Kotlin side:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efun create(): KotlinScreenSaverView = LogoScreenSaverView()\n\nabstract class KotlinScreenSaverView {\n    protected lateinit var view: ScreenSaverView\n        private set\n\n    protected lateinit var bundle: NSBundle\n        private set\n\n    protected var isPreview = false\n        private set\n\n    open fun init(screenSaverView: ScreenSaverView, isPreview: Boolean) {\n        this.view = screenSaverView\n        this.bundle = NSBundle.bundleWithIdentifier(\u0026#34;co.zsmb.KotlinLogos\u0026#34;)!!\n        this.isPreview = isPreview\n    }\n\n    abstract fun animateOneFrame()\n\n    open val configureSheet: NSWindow? = null\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is a simple base class, mimicking the \u003ccode\u003eScreenSaverView\u003c/code\u003e framework class. It sets up some basic values that will be accessible in the concrete implementation. That implementation is provided to the Swift code by the \u003ccode\u003ecreate\u003c/code\u003e factory function above the class.\u003c/p\u003e\n\u003cp\u003eBefore we dive further into the code, now that we have some Swift and some Kotlin, it‚Äôs a good time to have a look at what I used to work on this project.\u003c/p\u003e\n\u003ch3 id=\"my-development-setup\"\u003eMy development setup\u003c/h3\u003e\n\u003cp\u003eXcode was required for getting started and setting up the project, but with the initial steps done, I could proceed to use \u003ca href=\"https://www.jetbrains.com/fleet/\"\u003eFleet\u003c/a\u003e for all the rest of my work. I initially wrote a proof of concept implementation in Swift, and then gradually worked towards moving more and more of the code into Kotlin. Things like cross-language navigation to usages work like a charm here!\u003c/p\u003e\n\u003cvideo autoplay=\"\" controls=\"\" loop=\"\" muted=\"\" width=\"100%\"\u003e\n    \u003csource src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/cross_language_nav.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003ch3 id=\"building-the-screen-saver\"\u003eBuilding the screen saver\u003c/h3\u003e\n\u003cp\u003eThe project can be built from Xcode, but it‚Äôs also fairly easy to build it from Fleet. I created the following run configurations in Fleet (\u003ca href=\"https://github.com/zsmb13/KotlinLogo-ScreenSaver/blob/main/.fleet/run.json\"\u003e\u003ccode\u003e.fleet/run.json\u003c/code\u003e\u003c/a\u003e) to make it easy to run builds:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n    \u0026#34;configurations\u0026#34;: [\n        {\n            \u0026#34;type\u0026#34;: \u0026#34;command\u0026#34;,\n            \u0026#34;name\u0026#34;: \u0026#34;xcodebuild debug\u0026#34;,\n            \u0026#34;program\u0026#34;: \u0026#34;xcodebuild\u0026#34;,\n            \u0026#34;args\u0026#34;: [\u0026#34;-scheme\u0026#34;,  \u0026#34;KotlinLogos\u0026#34;, \u0026#34;build\u0026#34;],\n            \u0026#34;workingDir\u0026#34;: \u0026#34;KotlinLogos\u0026#34;,\n        },\n        {\n            \u0026#34;type\u0026#34;: \u0026#34;command\u0026#34;,\n            \u0026#34;name\u0026#34;: \u0026#34;xcodebuild release\u0026#34;,\n            \u0026#34;program\u0026#34;: \u0026#34;xcodebuild\u0026#34;,\n            \u0026#34;args\u0026#34;: [\u0026#34;-scheme\u0026#34;,  \u0026#34;KotlinLogosRelease\u0026#34;, \u0026#34;build\u0026#34;],\n            \u0026#34;workingDir\u0026#34;: \u0026#34;KotlinLogos\u0026#34;,\n        },\n    ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese are conveniently available on the UI once set up:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/run_configs.png\" alt=\"The custom xcode run configurations on the Fleet UI\"/\u003e\u003c/p\u003e\n\u003cp\u003eA successful build of the project will produce a screen saver file with the \u003ccode\u003e.saver\u003c/code\u003e extension. The output folder is somewhat hard to find, in my case it was at a path like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e~/Library/Developer/Xcode/DerivedData/KotlinLogos-fczypfdumappcugzfailioehwspp/Build/Products/Debug/KotlinLogos.saver\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you‚Äôre building in Xcode, you can use \u003cem\u003eProduct -\u0026gt; Show Build Folder in Finder\u003c/em\u003e to find this folder.\u003c/p\u003e\n\u003cp\u003eWhen building from Fleet, I found that the end of the output contains this location as well, making it easy to copy and then \u003ccode\u003ecd\u003c/code\u003e to or \u003ccode\u003eopen\u003c/code\u003e directly:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/usr/bin/codesign --force --sign - --timestamp\\=none --generate-entitlement-der \\\n/Users/zsmb/Library/Developer/Xcode/DerivedData/KotlinLogos-fczypfdumappcugzfailioehwspp/Build/Products/Debug/KotlinLogos.saver\n\n** BUILD SUCCEEDED **\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA neat way of keeping track of this folder in Fleet is to add it to the workspace in addition to the project folder. This can be done by just dragging the extra folder into the \u003cem\u003eFiles\u003c/em\u003e view:\u003c/p\u003e\n\u003cvideo autoplay=\"\" controls=\"\" loop=\"\" muted=\"\" width=\"100%\"\u003e\n    \u003csource src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/fleet_add_products_folder.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003cp\u003eIf you‚Äôre ever looking at the \u003cem\u003eDate Modified\u003c/em\u003e field of your \u003ccode\u003e.saver\u003c/code\u003e in Finder, don‚Äôt be surprised if you don‚Äôt see it updating as you‚Äôre running new builds. It seems like it gets stuck at the first time this file was created.\u003c/p\u003e\n\u003cp\u003eOf course, this isn‚Äôt really a file, it‚Äôs one of the \u003ca href=\"https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/AboutBundles/AboutBundles.html\"\u003emagic actually-just-a-folder formats\u003c/a\u003e of macOS. You can see this easily in the Fleet Files panel.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/saver_file_structure.png\" alt=\"The structure of the .saver ‚Äúfile‚Äù\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"installing-removing-and-re-installing-the-screen-saver\"\u003eInstalling, removing, and re-installing the screen saver\u003c/h3\u003e\n\u003cp\u003eTo install a screen saver on macOS, open its \u003ccode\u003e.saver\u003c/code\u003e file. This will open System Settings and ask you if you want to install it. If you‚Äôre installing an updated version of the screen saver, you‚Äôll get some additional warnings.\u003c/p\u003e\n\u003cp\u003eExpect about 2‚Äì4 popups that you need to confirm each time, as there tend to be buggy duplicate popups created here depending on your OS version, and apparently, the speed with which you accept them.\u003c/p\u003e\n\u003cvideo autoplay=\"\" controls=\"\" loop=\"\" muted=\"\" width=\"100%\"\u003e\n    \u003csource src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/replace_dialogs.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003cp\u003eYou might think installing a new build of the screen saver and confirming a couple of times that you want to replace the old one is sufficient for changes to take effect, but you‚Äôd be wrong.\u003c/p\u003e\n\u003cp\u003eThere are many, many things you can do ‚Äúwrong‚Äù to not cause the screen saver to be refreshed. It can be quite frustrating trying to check the effects of code changes you‚Äôve made, only to eventually figure out that you never managed to launch the new version.\u003c/p\u003e\n\u003cp\u003eHere are all the things you can attempt to make sure that your changes are applied:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDelete your old output files before running a new build\u003c/li\u003e\n\u003cli\u003eBuild your project\u003c/li\u003e\n\u003cli\u003eGo to Activity Monitor and force quit any \u003ccode\u003elegacyScreenSaver\u003c/code\u003e processes (especially on Sonoma - we‚Äôll discuss this more \u003ca href=\"#macos-sonoma\"\u003elater\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003eGo to System Settings, choose any screen saver other than your custom one\u003c/li\u003e\n\u003cli\u003eDelete your custom screen saver from System Settings\u003c/li\u003e\n\u003cli\u003eQuit System Settings\u003c/li\u003e\n\u003cli\u003eInstall your new screen saver and perform the dialog dance\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eYou don‚Äôt always need all these steps, but you will find yourself in situations where missing one of them somehow makes your screen saver not update. From my latest experience, \u003cem\u003enormally\u003c/em\u003e it‚Äôs enough to quit System Settings and force quit any \u003ccode\u003elegacyScreenSaver\u003c/code\u003e processes before installing an updated version.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eYou can also install or remove a screen saver manually by going to \u003ccode\u003e~/Library/Screen Savers\u003c/code\u003e. To install something, place it in this folder. To remove it, delete its file.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"preview-problems\"\u003ePreview problems\u003c/h3\u003e\n\u003cp\u003eIf after installing your screen saver your preview in System Settings doesn‚Äôt animate, or the \u003cem\u003eOptions‚Ä¶\u003c/em\u003e button doesn‚Äôt do anything when clicked, select another screen saver and then select your custom screen saver again.\u003c/p\u003e\n\u003cp\u003eNot sure why this is required and whether there‚Äôs a nice fix for it.\u003c/p\u003e\n\u003ch2 id=\"development\"\u003eDevelopment\u003c/h2\u003e\n\u003cp\u003eWith those detours about setup and installing a screen saver, it‚Äôs time to get into how you can implement one with Kotlin!\u003c/p\u003e\n\u003ch3 id=\"using-appkit-from-kotlin\"\u003eUsing AppKit from Kotlin\u003c/h3\u003e\n\u003cp\u003eSo we have access to a \u003ccode\u003eScreenSaverView\u003c/code\u003e instance from Kotlin code. How can we draw on this? The approach I took was to create \u003ca href=\"https://developer.apple.com/documentation/appkit/\"\u003eAppKit\u003c/a\u003e views and add them as children (subviews) to the \u003ccode\u003eScreenSaverView\u003c/code\u003e. This is made possible by all these system APIs being mapped in Kotlin native with interop, and automatically made available.\u003c/p\u003e\n\u003cp\u003eFor example, to put an image on the screen, you can instantiate an \u003ccode\u003eNSImageView\u003c/code\u003e, set its \u003ccode\u003eimage\u003c/code\u003e to an \u003ccode\u003eNSImage\u003c/code\u003e, and use \u003ccode\u003eNSMakeRect\u003c/code\u003e to create a rectangle describing its on-screen position:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval imageView = NSImageView().apply {\n    imageScaling = NSImageScaleProportionallyUpOrDown\n    image = loadImage() // Grab an NSImage, for example from assets\n    frame = NSMakeRect(x = 300.0, y = 300.0, w = 200.0, h = 200.0)\n}\nscreenSaverView.addSubview(imageView)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo progress this image across the screen, we can simply update the \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e coordinates every time a new frame is requested. This is done by calling \u003ccode\u003eNSMakeRect\u003c/code\u003e again with the new values and assigning this to the \u003ccode\u003eframe\u003c/code\u003e of the view:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimageView.frame = NSMakeRect(x = newX, y = newY, w = 200.0, h = 200.0)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo remove a view that you no longer want to display:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimageView.removeFromSuperview()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can use these interop APIs to easily create and place any type of AppKit views, such as an \u003ccode\u003eNSTextView\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"assets\"\u003eAssets\u003c/h3\u003e\n\u003cp\u003eThe screen saver needs to contain the various Kotlin logos and images of Kodee. To package these with the screen saver, I‚Äôve added them to the Assets of the Xcode project.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/assets.png\" alt=\"The assets in Xcode\"/\u003e\u003c/p\u003e\n\u003cp\u003eFor some reason I initially thought these assets could not be SVGs, so I used huge PNG files, as you can see in the \u003ca href=\"https://github.com/zsmb13/KotlinLogo-ScreenSaver/commit/a0c209c1bd377dddf785b33a88a0b0cbbfa1b99e\"\u003ehistory of the repository\u003c/a\u003e. However, SVGs actually work just fine too, so that‚Äôs what the current implementation uses.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eShout-out to \u003ca href=\"https://boxy-svg.com/\"\u003eBoxy SVG\u003c/a\u003e, which I found while trying to make some minor edits to the Kotlin logos that I had. It‚Äôs a super simple and useful tool.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAccessing these assets is possible through a \u003ccode\u003eBundle\u003c/code\u003e - or an \u003ccode\u003eNSBundle\u003c/code\u003e when looking at it from Kotlin. This is simple enough, using the name of the asset:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval image: NSImage = bundle.imageForResource(\u0026#34;kodee-greeting\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHowever, for a good while I could only instantiate the \u003ccode\u003eNSBundle\u003c/code\u003e to work with in Swift code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet bundle = Bundle(for: type(of: self))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e‚Ä¶ and then I passed this to the Kotlin code. I wanted to move the creation of the \u003ccode\u003eBundle\u003c/code\u003e to the Kotlin side as well, but I did not find a way to express \u003ccode\u003etype(of: self)\u003c/code\u003e in Kotlin code.\u003c/p\u003e\n\u003cp\u003eThrough some debugging, I eventually found the following solution instead, which grabs the \u003ccode\u003eBundle\u003c/code\u003e based on the app‚Äôs identifier:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval bundle = NSBundle.bundleWithIdentifier(\u0026#34;co.zsmb.KotlinLogos\u0026#34;)!!\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"storing-preferences\"\u003eStoring preferences\u003c/h3\u003e\n\u003cp\u003eNext, let‚Äôs look at making the screen saver user-configurable. The first step for this is to find a place for persistent value storage. The documentation says you‚Äôre supposed to use \u003ca href=\"https://developer.apple.com/documentation/screensaver/screensaverdefaults\"\u003e\u003ccode\u003eScreenSaverDefaults\u003c/code\u003e\u003c/a\u003e. I have missed this initially and used \u003ca href=\"https://developer.apple.com/documentation/foundation/userdefaults\"\u003e\u003ccode\u003eUserDefaults\u003c/code\u003e\u003c/a\u003e instead.\u003c/p\u003e\n\u003cp\u003eThis turned out to be lucky, as when I later tried moving to \u003ccode\u003eScreenSaverDefaults\u003c/code\u003e instead, it failed to notify my screen saver of changes in values, and it also wouldn‚Äôt persist them through re-launches of the screen saver. I assume I was doing something wrong, but I ended up with reverting to \u003ccode\u003eUserDefaults\u003c/code\u003e as that works perfectly fine.\u003c/p\u003e\n\u003cp\u003eAs with previous iOS APIs, this can be accessed seamlessly from Kotlin. I have a \u003ca href=\"https://zsmb.co/talks/delightful-delegate-design/\"\u003ebit of a history\u003c/a\u003e of storing preferences using delegated properties, so I‚Äôve applied that pattern again, like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass UserDefaultDelegate(private val default: Long) : ReadWriteProperty\u0026lt;Any?, Int\u0026gt; {\n    private val userDefaults = NSUserDefaults()\n\n    override fun getValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;): Int {\n        return ((userDefaults.objectForKey(property.name) as? Long) ?: default).toInt() \n    }\n\n    override fun setValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;, value: Int) {\n        userDefaults.setInteger(value.toLong(), property.name)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI‚Äôve then created a \u003ccode\u003ePreferences\u003c/code\u003e object in my project to hold such values in a globally accessible place:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eobject Preferences {\n    var LOGO_SET by UserDefaultDelegate(0)\n    var LOGO_SIZE by UserDefaultDelegate(200)\n    var LOGO_COUNT by UserDefaultDelegate(1)\n    var SPEED by UserDefaultDelegate(10)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLastly, I wanted my implementation to know whenever these values changed through the configuration panel, so that I can reload the logos. This is useful to immediately reflect changes in the System Settings preview, for example, without having to quit and reopen it.\u003c/p\u003e\n\u003cp\u003eThis can also be easily set up, using \u003ca href=\"https://developer.apple.com/documentation/foundation/nsnotificationcenter\"\u003e\u003ccode\u003eNSNotificationCenter\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/documentation/foundation/nsuserdefaultsdidchangenotification\"\u003e\u003ccode\u003eNSUserDefaultsDidChangeNotification\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eNSNotificationCenter.defaultCenter\n    .addObserverForName(NSUserDefaultsDidChangeNotification, null, null) {\n        initLogos()\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"configuration-panel\"\u003eConfiguration panel\u003c/h3\u003e\n\u003cp\u003eNow that we know where to save values, it‚Äôs time to build the UI where the user can actually change them. This is the configuration panel that‚Äôs accessed through the \u003cem\u003eOptions‚Ä¶\u003c/em\u003e button in System Settings.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/config_panel.png\" alt=\"The configuration panel of the screen saver in System Settings\"/\u003e\u003c/p\u003e\n\u003cp\u003eBuilding this panel required way more traditional UI work than anything else around the screen saver. Having no real experience with AppKit or UIKit made it an interesting challenge to figure out how to use the various constraint APIs to get the desired layout, even though I just had to stack things vertically and horizontally. My understanding is that programmatically creating UI elements is actually popular with these toolkits, but I could not really get behind that.\u003c/p\u003e\n\u003cp\u003eYou can find what I‚Äôve managed to cobble together in \u003ca href=\"https://github.com/zsmb13/KotlinLogo-ScreenSaver/blob/main/src/nativeMain/kotlin/config/Config.kt\"\u003ethis file\u003c/a\u003e. It‚Äôs not spectacular, but it‚Äôs decently navigable code and it gets the job done.\u003c/p\u003e\n\u003cp\u003eThe hardest part of this UI building was setting listeners on elements, such as the OK and Cancel buttons. In Swift, this would look something like this, referencing a method of the current controller class:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eokButton.target = self\nokButton.action = #selector(ViewController.performOk)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe first line here is easy enough, it‚Äôs the fancy selector that‚Äôs hard to translate to Kotlin. With some help from \u003ca href=\"https://www.linkedin.com/in/fkistner/\"\u003eFlorian Kistner\u003c/a\u003e (builder of KMP tooling for Fleet!), I eventually figured out that this sort of syntax works, naming a public function of the controller in a stringly typed manner:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etarget = this\naction = NSSelectorFromString(\u0026#34;performOk\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs I found this terrifying, I ended up wrapping it like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprivate fun NSControl.setListener(selfFunc: KFunction\u0026lt;Unit\u0026gt;) {\n    target = this@KotlinLogosPrefController\n    action = NSSelectorFromString(selfFunc.name)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhich gives us these kinds of neat use sites:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval okButton = NSButton().apply {\n    setListener(::performOk)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, again, aggressively quitting System Preferences before deploying a new build of your screen saver comes in handy. If you don‚Äôt do this, it‚Äôs more than likely that the configuration UI will keep running an old instance without your latest changes. I learned this quickly after an hour or two of debugging.\u003c/p\u003e\n\u003ch3 id=\"debugging\"\u003eDebugging\u003c/h3\u003e\n\u003cp\u003eScreen savers are interesting applications to debug. You can‚Äôt really run them in debug mode to place breakpoints, and you also can‚Äôt really run them directly from the IDE to even just capture logs easily.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://preserve.mactech.com/articles/mactech/Vol.21/21.06/SaveOurScreens/index.html\"\u003eThis article\u003c/a\u003e from 2005 is (unfortunately) still an important article in the screen saver topic. It has a tip to automatically copy the newly built screen saver on top of the old one ‚Äî I did not try this, though some of the issues I was having would have definitely broken this. Another good strategy from the past was to invoke the system‚Äôs \u003ccode\u003eScreenSaverEngine\u003c/code\u003e in debug mode, make it host your screen saver, and have Xcode connect to it for debugging purposes. As far as I understand, this is no longer possible due to new OS level protections that don‚Äôt allow you to do this to \u003ccode\u003eScreenSaverEngine\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe best idea I saw pop up in discussions was in \u003ca href=\"https://stackoverflow.com/a/1104007/4465208\"\u003ethis comment on StackOverflow\u003c/a\u003e, which is to create a macOS application within your Xcode project that takes your \u003ccode\u003eScreenSaverView\u003c/code\u003e implementation and displays it in a window. I have tried this briefly and failed to get through configuring this in Xcode. I assume it‚Äôs possible to do if you‚Äôre more familiar with the tool.\u003c/p\u003e\n\u003cp\u003eSo with that, I was stuck with testing my screen saver in production, by installing it and starting it as normal every time I‚Äôve changed something. I also used the following:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eAnother tip I need to thank \u003ca href=\"https://www.linkedin.com/in/fkistner/\"\u003eFlorian\u003c/a\u003e for teaching me was that I can use \u003ccode\u003eNSLog\u003c/code\u003e to log things from my screen saver, and then I can open the macOS Console app to start listening for logs and filter for the ones that my screen saver produced. I also saw the occasional screen saver process crash here, which was useful.\u003c/li\u003e\n\u003cli\u003eI built myself some ‚Äúdebug mode‚Äù functionality within the screen saver itself, controlled by a boolean flag that I‚Äôd change manually for debug and release builds. When this was turned on, I‚Äôve added \u003ccode\u003eNSTextView\u003c/code\u003e instances to the UI and then set them to display strings of debug information, like coordinates and indices. I‚Äôve since removed this in an effort to optimize the screen saver code, but you can go to \u003ca href=\"https://github.com/zsmb13/KotlinLogo-ScreenSaver/blob/1b441e3eaa91c283f5f3b24f62255c136d7d9164/src/nativeMain/kotlin/BouncingLogo.kt\"\u003ethis revision\u003c/a\u003e to check out how it worked.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"previews\"\u003ePreviews\u003c/h3\u003e\n\u003cp\u003eThe System Settings dialog for setting up screen savers offers a nice, but tiny preview of your screen saver when you select it. It does this by instantiating your \u003ccode\u003eScreenSaverView\u003c/code\u003e implementation and running it in a process called \u003ccode\u003elegacyScreenSaver (Screen Saver (System Settings))\u003c/code\u003e. It‚Äôs definitely descriptive!\u003c/p\u003e\n\u003cvideo autoplay=\"\" controls=\"\" loop=\"\" muted=\"\" width=\"100%\"\u003e\n    \u003csource src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/system_settings_preview.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003cp\u003eThis comes with a fun challenge: the code you write to display at full screen sizes (the screen size on my MacBook measures as 2056 x 1329) is forced into a much, much smaller space (143 x 80 on my machine). If you‚Äôve been hardcoding bouncing Kotlin logos that are 200‚Äì400 wide on their own, you‚Äôre going to have a bad time, and this preview will just keep crashing.\u003c/p\u003e\n\u003cp\u003eMy workaround for this was to compute a magic multiplier that I then use to scale all dimension measurements by. You can find the implementation in \u003ca href=\"https://github.com/zsmb13/KotlinLogo-ScreenSaver/blob/main/src/nativeMain/kotlin/ScreenSpecs.kt\"\u003ethis file\u003c/a\u003e. Thanks to this, not only does the screen saver work fine in the tiny preview window, but it also has pretty reasonable sizing for its elements on screens of different sizes, ratios, and densities.\u003c/p\u003e\n\u003ch3 id=\"thumbnails\"\u003eThumbnails\u003c/h3\u003e\n\u003cp\u003eTo give your custom screen saver a nice thumbnail image in System Settings, you have to add an asset called \u003ccode\u003ethumbnail\u003c/code\u003e to your project.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/thumbnail_asset.png\" alt=\"The thumbnail asset in various sizes\"/\u003e\u003c/p\u003e\n\u003cp\u003eThis gives you something like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/thumbnails.png\" alt=\"The structure of the .saver ‚Äúfile‚Äù\"/\u003e\u003c/p\u003e\n\u003cp\u003eThere‚Äôs a \u003ca href=\"https://stackoverflow.com/questions/34030980/os-x-screensaver-retina-thumbnail-image\"\u003ewell-known bug\u003c/a\u003e which makes these thumbnails look awful for custom screen savers, which I also experienced while creating mine. However, I think updating to Sonoma might have actually fixed this, because it seems alright now.\u003c/p\u003e\n\u003ch3 id=\"distribution\"\u003eDistribution\u003c/h3\u003e\n\u003cp\u003eTo properly ship a screen saver, the distribution steps are very similar to distributing any other macOS application.\u003c/p\u003e\n\u003cp\u003eThe signing part for a screen saver is slightly complicated, but \u003ca href=\"https://gabrieluribe.me/blog/how-to-distribute-a-screensaver-on-macos-2022\"\u003ethis article\u003c/a\u003e seems to describe it really nicely. This is a shockingly good resource considering the general availability information in this whole topic.\u003c/p\u003e\n\u003cp\u003eHowever, this does still require an \u003ca href=\"https://developer.apple.com/support/compare-memberships/\"\u003eApple developer account\u003c/a\u003e, which costs about $99 more than what it‚Äôd be worth for me at this time. This leaves me without a nicely signed release version of my screen saver.\u003c/p\u003e\n\u003cp\u003eTo get the Kotlin Logo screen saver, you can either \u003ca href=\"https://github.com/zsmb13/KotlinLogo-ScreenSaver#use-an-unsigned-release-build\"\u003etake the unsigned release binaries\u003c/a\u003e from the GitHub releases page that I‚Äôve published and click through the warnings that macOS presents, or clone the project and \u003ca href=\"https://github.com/zsmb13/KotlinLogo-ScreenSaver#build-it-yourself\"\u003ebuild it yourself\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"macos-sonoma\"\u003emacOS Sonoma\u003c/h2\u003e\n\u003cp\u003eMore like \u003cem\u003ecustom screen savers no ma‚Äô\u003c/em\u003e, am I right..?\u003c/p\u003e\n\u003cp\u003eThe latest version of macOS at the time of writing is Sonoma, which was released while I was developing this screen saver and writing up this post. Sonoma has apparently brought two \u003cem\u003egreat\u003c/em\u003e new updates in the realm of screen savers:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://arstechnica.com/gadgets/2023/09/macos-14-sonoma-the-ars-technica-review/8/\"\u003eFancy new screen savers\u003c/a\u003e built-in to the OS, making people more likely to stick to these than go for custom ones.\u003c/li\u003e\n\u003cli\u003eTons of new bugs and problems around custom screen savers. It seems like Sonoma has trouble properly shutting down the \u003ccode\u003elegacyScreenSaver\u003c/code\u003e process that hosts any custom \u003ccode\u003eScreenSaverView\u003c/code\u003e. This can cause various problems, including unnecessary CPU use, severe memory leaks, and complete crashes of a custom screen saver where it will just show up as a blank black screen.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca href=\"https://discussions.apple.com/thread/255256761\"\u003eHere\u003c/a\u003e\n\u003ca href=\"https://forums.developer.apple.com/forums/thread/738547\"\u003eare\u003c/a\u003e\n\u003ca href=\"https://github.com/JohnCoates/Aerial/issues/1305\"\u003ea\u003c/a\u003e\n\u003ca href=\"https://github.com/vpeschenkov/Predator/issues/13\"\u003efew\u003c/a\u003e\n\u003ca href=\"https://www.reddit.com/r/MacOS/comments/173kw6d/comment/kaly0hg/\"\u003eexamples\u003c/a\u003e\n\u003ca href=\"https://www.reddit.com/r/MacOS/comments/174np4z/external_screensaver_issue/\"\u003eof\u003c/a\u003e\n\u003ca href=\"https://www.reddit.com/r/MacOSBeta/comments/14h9p4j/sonoma_screen_saver_memory_usage/\"\u003ethese\u003c/a\u003e\n\u003ca href=\"https://www.reddit.com/r/MacOSBeta/comments/15t3hpo/legacyscreensaverx86_64_not_closing_and_using_100/\"\u003eissues\u003c/a\u003e\n\u003ca href=\"https://www.reddit.com/r/apple/comments/18iw6tt/comment/kdh55ri/\"\u003ebeing\u003c/a\u003e\n\u003ca href=\"https://www.reddit.com/r/mac/comments/16vgeol/any_way_to_prevent_this_specs_in_comments/\"\u003ereported\u003c/a\u003e‚Ä¶\u003c/p\u003e\n\u003ch3 id=\"whats-really-happening\"\u003eWhat‚Äôs really happening\u003c/h3\u003e\n\u003cp\u003eHere‚Äôs how that latter problem works in detail, from my testing:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWhen your screen saver is first displayed, the \u003ccode\u003elegacyScreenSaver (Wallpaper)\u003c/code\u003e process starts, and an instance of your \u003ccode\u003eScreenSaverView\u003c/code\u003e implementation is created and added to view, displaying the screensaver. So far so good.\u003c/li\u003e\n\u003cli\u003eWhen you dismiss the screen saver and your content is no longer visible, this process keeps going in the background, running your \u003ccode\u003eScreenSaverView\u003c/code\u003e code, still calling methods like \u003ccode\u003eanimateOneFrame\u003c/code\u003e repeatedly (in the case of my code, bouncing Kodees around constantly). This seems to keep going indefinitely. Uh-oh.\u003c/li\u003e\n\u003cli\u003eWhen you enter the screen saver again, the process is reused, but a new \u003ccode\u003eScreenSaverView\u003c/code\u003e is created and displayed. The old one still doesn‚Äôt get dismissed however, it keeps hanging out in the process next to the new one.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAs you might be able to tell at this point, this leads to a fascinating stacking of actively spinning \u003ccode\u003eScreenSaverView\u003c/code\u003e instances over time, as you show and dismiss the screen saver. Depending on the intensity of the screen saver implementation (in our example, how many logos you have bouncing and how fast), these can add 1‚Äì10% CPU usage with every new stack. Somewhere above 100%, the process gives up and simply fails, requiring you to force quit it to see your screen saver again.\u003c/p\u003e\n\u003cp\u003eWarning: rapidly flashing video below. \u003cem\u003e(Video is at 2x speed)\u003c/em\u003e\u003c/p\u003e\n\u003cvideo controls=\"\" loop=\"\" muted=\"\" width=\"100%\"\u003e\n    \u003csource src=\"https://zsmb.co/images/building-a-macos-screen-saver-in-kotlin/screensaver_cpu_usage.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn previous macOS versions, the \u003ccode\u003eScreenSaverView\u003c/code\u003e would no longer receive callbacks after it‚Äôs dismissed, as one might reasonably expect.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAt this point, you might also wonder what happens when you have multiple displays connected, as visually, these all run their own independent copies of your custom screen saver. As an example, for three displays the implementation creates three instances of your \u003ccode\u003eScreenSaverView\u003c/code\u003e, which are all hosted in the same process. Dismissing and entering the screen saver again creates three new instances of your \u003ccode\u003eScreenSaverView\u003c/code\u003e again. So the more displays you have, the faster you‚Äôre stacking up invisible, leaking views.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe challenge, then, is to figure out when your \u003ccode\u003eScreenSaverView\u003c/code\u003e isn‚Äôt being shown anymore, and dealing with that scenario in the best way possible. For a start, it‚Äôd be nice if the instances that are no longer visible wouldn‚Äôt do any work when their methods are called. Even better would be to be able to destroy them (or at least all but the latest instance). Ideally, we should be able to shut down the screen saver entirely once it‚Äôs dismissed.\u003c/p\u003e\n\u003ch3 id=\"how-do-we-fix-this\"\u003eHow do we fix this\u003c/h3\u003e\n\u003cp\u003eThe superclass has \u003ca href=\"https://developer.apple.com/documentation/screensaver/screensaverview/startanimation()\"\u003e\u003ccode\u003estartAnimation\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/documentation/screensaver/screensaverview/stopanimation()\"\u003e\u003ccode\u003estopAnimation\u003c/code\u003e\u003c/a\u003e methods which I never needed to use in my implementation, but figured I could attempt to use here. One of the first mitigation strategies I tried was to simply set a flag, and skip doing any work in \u003ccode\u003eanimateOneFrame\u003c/code\u003e after \u003ccode\u003estopAnimation\u003c/code\u003e has happened.\u003c/p\u003e\n\u003cp\u003eThis was clearly naive, which I realized as I kept testing and saw that \u003ccode\u003estopAnimation\u003c/code\u003e is essentially never called in production, only in the System Settings preview.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eDuring my testing, I saw that global variables are kept around through instances, as the process hosting these stacking views is the same one over time. You can use this, for example, to count how bad the situation has gotten:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar viewCount = 0\n\nclass KotlinLogosView: ScreenSaverView {\n    override init?(frame: NSRect, isPreview: Bool) {\n        super.init(frame: frame, isPreview: isPreview)\n\n        NSLog(\u0026#34;Created instance \\(viewCount)\u0026#34;)\n        viewCount += 1\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can also use it to keep track of the previous instance of the view, and remove it from its parent when a new one is created in its place:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar previousView: ScreenSaverView? = nil\n\nclass KotlinLogosView: ScreenSaverView {\n    override init?(frame: NSRect, isPreview: Bool) {\n        super.init(frame: frame, isPreview: isPreview)\n        if let prev = previousView {\n            prev.removeFromSuperview()\n        }\n        previousView = self\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis sort of helps (as long as you have a single display), as it makes sure that there‚Äôs only ever one active instance of the \u003ccode\u003eScreenSaverView\u003c/code\u003e. However, it still doesn‚Äôt shut that instance down when the screen saver is dismissed, so you have a spinning screen saver in the background eating up resources 24/7.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eHaving been able to save this \u003ccode\u003epreviousView\u003c/code\u003e reference, I figured I could check various properties of the previous view at the time when the new view is being created. If I found a property that tells me that \u003ccode\u003epreviousView\u003c/code\u003e isn‚Äôt actually visible, perhaps I could check for the value of that property in \u003ccode\u003eanimateOneFrame\u003c/code\u003e, and shut down my view manually.\u003c/p\u003e\n\u003cp\u003eI tested a dozen different properties describing whether the view is animated, hidden, whether its window is the main or key window, and so on, and so on. I did not find anything that would change its value at the time when the screen saver is dismissed.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eSeeing earlier how I could react to changes in \u003ccode\u003eNSUserDefaults\u003c/code\u003e values using notification observers, I‚Äôve tried searching the list of available notification types, and I subscribed to several like \u003ca href=\"https://developer.apple.com/documentation/appkit/nsapplicationdidhidenotification\"\u003e\u003ccode\u003eNSApplicationDidHideNotification\u003c/code\u003e\u003c/a\u003e. None of these were being called when the screen saver was dismissed either. Another dead end.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eEventually, after even more searching around, I found \u003ca href=\"https://stackoverflow.com/questions/66861833/audio-keeps-playing-after-screensaver-ends\"\u003esome\u003c/a\u003e \u003ca href=\"https://stackoverflow.com/questions/1419531/mac-screensaver-start-event\"\u003eanswers\u003c/a\u003e describing another approach of subscribing to events. This included \u003ccode\u003ewillstop\u003c/code\u003e and \u003ccode\u003edidstop\u003c/code\u003e events, and these are actually delivered to your screen saver! ü§Ø\u003c/p\u003e\n\u003cp\u003eIn theory, either of these two events should be fine to catch and react to, but I had a test run where only the \u003ccode\u003ewillstop\u003c/code\u003e one was being caught, so I‚Äôve stuck to using that. Your mileage may of course vary.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass KotlinLogosView: ScreenSaverView {\n    override init?(frame: NSRect, isPreview: Bool) {\n        super.init(frame: frame, isPreview: isPreview)\n        DistributedNotificationCenter.default.addObserver(\n            self,\n            selector: #selector(KotlinLogosView.willStop(_:)),\n            name: Notification.Name(\u0026#34;com.apple.screensaver.willstop\u0026#34;),\n            object: nil\n        )\n    }\n\n    @objc func willStop(_ aNotification: Notification) {\n        // Do something!\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe only remaining question is, what to do when this happens? I initially made a \u003ccode\u003eself.removeFromSuperview()\u003c/code\u003e call, which nicely shuts down the \u003ccode\u003eScreenSaverView\u003c/code\u003e when it should. When doing this, the \u003ccode\u003elegacyScreenSaver\u003c/code\u003e process still sticks around 24/7, but consumes a negligible amount of resources.\u003c/p\u003e\n\u003cp\u003eI have later figured out that I can also just shut down the entire process programmatically, which seems to not cause any practical issues. To only handle the fullscreen mode of our screen saver and not when it‚Äôs being previewed in System Settings, we‚Äôll wrap this action in a check of the \u003ccode\u003eisPreview\u003c/code\u003e property.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@objc func willStop(_ aNotification: Notification) {\n    if (!isPreview) {\n        NSApplication.shared.terminate(nil)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, could I move this to Kotlin? I think I could. But I‚Äôll just pretend that the bugs here will eventually get fixed, and then I can remove this code instead of moving it.\u003c/p\u003e\n\u003ch3 id=\"conclusion-and-resources\"\u003eConclusion and resources\u003c/h3\u003e\n\u003cp\u003eCheck out the \u003ca href=\"https://github.com/zsmb13/KotlinLogo-ScreenSaver\"\u003eGitHub repository for the screen saver\u003c/a\u003e where you‚Äôll find builds, installation instructions, and all the code. Star it, open PRs, file issues. Buy it, use it, break it, fix it.\u003c/p\u003e\n\u003cp\u003eI‚Äôve also created a \u003ca href=\"https://github.com/zsmb13/Kotlin-macOS-ScreenSaver-Template\"\u003eblank starter project for Kotlin-based macOS screen savers\u003c/a\u003e which you can use if you want to build your own.\u003c/p\u003e\n\u003cp\u003eFinally, here are some other screen saver projects I found while researching this topic which seem like they might be useful to reference:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ayltai/MacOS-Developers-Excuses\"\u003eayltai/MacOS-Developers-Excuses\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/pedrommcarrasco/Brooklyn\"\u003epedrommcarrasco/Brooklyn\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/AerialScreensaver/ScreenSaverMinimal\"\u003eAerialScreensaver/ScreenSaverMinimal\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ggu/LanguageSaver\"\u003eggu/LanguageSaver\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003c/div\u003e\u003cp\u003eHave you ever encountered APIs that show warnings or errors when you use them, saying that they\u0026#39;re internal or experimental? In this guide, you\u0026#39;ll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.\u003c/p\u003e\u003cp\u003eStateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.\u003c/p\u003e\u003cp\u003eFor the longest time, I proudly had no idea of how Modifier ordering works, and would just guess and then guess again when something didn\u0026#39;t look quite right. Here\u0026#39;s how I finally ended up remembering how the ordering works.\u003c/p\u003e\u003cp\u003eAnother year over, a new one\u0026#39;s almost begun. Here\u0026#39;s a brief summary of what I\u0026#39;ve done in this one.\u003c/p\u003e\u003c/div\u003e",
  "readingTime": "35 min read",
  "publishedTime": null,
  "modifiedTime": null
}
