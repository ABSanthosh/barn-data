{
  "id": "ba55f464-3ae5-4ef3-a2fc-cd5a73008387",
  "title": "The dark corners of inline, crossinline, and reified in Kotlin",
  "link": "https://proandroiddev.com/the-dark-corners-of-inline-crossinline-and-reified-in-kotlin-d244eaa07bb1?source=rss----c72404660798---4",
  "description": "",
  "author": "Dmitry Glazunov",
  "published": "Thu, 24 Jul 2025 16:56:32 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "kotlin",
    "software-engineering",
    "software-development",
    "androiddev"
  ],
  "byline": "Dmitry Glazunov",
  "length": 5311,
  "excerpt": "Kotlin’s inline, crossinline, and reified are marketed as zero-cost abstractions. They indeed can eliminate allocations, enable type-safe builders, and improve performance. In this article, I’ll…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Zoom image will be displayedPhoto by Johannes Plenio on UnsplashKotlin’s inline, crossinline, and reified are marketed as zero-cost abstractions. They indeed can eliminate allocations, enable type-safe builders, and improve performance.However, misusing them can lead to:Broken stack traces, making crashes unreadable in production.Subtle coroutine cancellation or IllegalStateException.Unintentional API leaks and tightly coupled inlined code.In this article, I’ll share some subtle quirks and caveats of using inline, crossinline, and reified — details that might save you from unexpected headaches down the road.1. The promise and peril of inlineWhat it doesMarking a function as inline tells the compiler:“Replace calls to this function with its body, substituting parameters directly, avoiding function call overhead.”Benefits:Removes function call overhead (especially for small higher-order functions).Eliminates lambda object creation, reducing allocations.Hidden pitfall: broken stack tracesConsider:inline fun runSafe(block: () -\u003e Unit) { try { block() } catch (e: Exception) { println(e.stackTraceToString()) }}fun fail() { throw RuntimeException(\"Fail\")}fun main() { runSafe { fail() }}You might expect:RuntimeException: Fail at fail at runSafe$lambda... at runSafe at mainBut due to inlining, you get:RuntimeException: Fail at fail at mainThe runSafe frame is gone, complicating debugging and crash analysis.Recommendations:Be aware that all inlined frames disappear in stack traces unless you explicitly add logging and markers.Tools like Talsec or crash reporting pipelines can annotate inlined code to preserve context.Keep non-trivial error boundaries as non-inline functions.2. Why crossinline matters in suspending contextsProblem: non-local returnsKotlin lambdas support non-local returns in inline functions:inline fun runBlock(block: () -\u003e Unit) { block() // can `return` from the caller of runBlock}fun test() { runBlock { return // returns from test() }}However, non-local returns are not allowed:From lambdas passed to noinline parameters.From lambdas used inside suspend contexts (e.g., launched coroutines).Example: crashing misuseinline fun runInline(scope: CoroutineScope, block: () -\u003e Unit) { scope.launch { block() // Kotlin: Cannot inline 'block: () -\u003e Unit' here: it might contain non-local returns. }}Solution: Use crossinlineinline fun runInlineCross(scope: CoroutineScope, crossinline block: () -\u003e Unit) { scope.launch { block() // Allowed, non-local returns are disallowed explicitly }}Using crossinline ensures:The compiler enforces no non-local returns.Your inline functions remain usable in suspending and coroutine contexts.3. Reified: type-safe builders and beyondWhat reified enablesNormally, generic types are erased at runtime:fun \u003cT\u003e foo() { println(T::class) // Error: Cannot use 'T' as reified type parameter}By marking an inline function with reified, type information is preserved:inline fun \u003creified T\u003e foo() { println(T::class) // It works}Type-safe builders with reifiedConsider a JSON serializer builder:inline fun \u003creified T\u003e Moshi.getAdapter(): JsonAdapter\u003cT\u003e = this.adapter(T::class.java)Now you get:Type safety without explicitly passing Class\u003cT\u003e.Cleaner APIs in DSLs.Hidden Pitfall: inline is requiredreified only works with inline functions. However, overusing inline for the sake of reified can:Inflate bytecode if misused in large functions.Reduce binary stability if you frequently change inlined logic in library APIs.Guidelines:Use reified for factory/builders, reflection-based utilities, and type-safe APIs.Avoid using inline + reified in large or complex functions that change often in libraries.Consider alternative explicit Class\u003cT\u003e passing if inline/reified is overkill.4. Debugging and testing inline codeUse -Xinline-classes and decompiler tools (e.g., JADX) to view how your inline code compiles.Use ProGuard/R8 mappings to map minified crashes back to readable stack traces.When profiling, remember inlined functions will not appear in call graphs, so measure allocations directly.5. Checklist for safe useUse inline:For small higher-order functions where lambda allocation is a real bottleneck.For DSL builders where readability and ergonomics matter.Avoid inline:For large functions or when stack traces are critical for debugging.For functions with heavy internal logic that can change frequently in libraries.Use crossinline:Whenever you pass lambdas into suspend or coroutine contexts inside inline functions.When you want to prevent non-local returns explicitly.Use reified:For type-safe builders, factories, and reflective utilities.When it genuinely improves ergonomics over Class\u003cT\u003e.ConclusionKotlin gives us powerful tools — inline, crossinline, and reified — to write expressive and performant code. But with power comes nuance. Misusing these keywords won’t necessarily crash your app, but it can lead to subtle bugs, confusing stack traces, or bloated binaries. Understanding how they behave under the hood isn’t just for language nerds — it’s how you write safer, smarter Kotlin.If you found this helpful, feel free to follow me here on Medium where I share hands-on insights into Kotlin, mobile development and engineering.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*AymhZMo2UDqi3GJV",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\" role=\"tooltip\"\u003e\u003ca href=\"https://medium.com/@d_glazunov?source=post_page---byline--d244eaa07bb1---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Dmitry Glazunov\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*dKOSY-bx7KXF8f2lVdocqw.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003cdiv role=\"button\" tabindex=\"0\"\u003e\u003cp\u003e\u003cspan\u003eZoom image will be displayed\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@jplenio?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJohannes Plenio\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"dec7\"\u003eKotlin’s \u003ccode\u003einline\u003c/code\u003e, \u003ccode\u003ecrossinline\u003c/code\u003e, and \u003ccode\u003ereified\u003c/code\u003e are marketed as zero-cost abstractions. They indeed can eliminate allocations, enable type-safe builders, and improve performance.\u003c/p\u003e\u003cp id=\"e05c\"\u003eHowever, misusing them can lead to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"bfac\"\u003eBroken stack traces, making crashes unreadable in production.\u003c/li\u003e\u003cli id=\"b8db\"\u003eSubtle coroutine cancellation or \u003ccode\u003eIllegalStateException\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"39fe\"\u003eUnintentional API leaks and tightly coupled inlined code.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8199\"\u003eIn this article, I’ll share some subtle quirks and caveats of using \u003ccode\u003einline\u003c/code\u003e, \u003ccode\u003ecrossinline\u003c/code\u003e, and \u003ccode\u003ereified\u003c/code\u003e — details that might save you from unexpected headaches down the road.\u003c/p\u003e\u003ch2 id=\"0691\"\u003e1. The promise and peril of \u003ccode\u003einline\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"3da4\"\u003e\u003cstrong\u003eWhat it does\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"35e3\"\u003eMarking a function as \u003ccode\u003einline\u003c/code\u003e tells the compiler:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"1e27\"\u003e“Replace calls to this function with its body, substituting parameters directly, avoiding function call overhead.”\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"b8a8\"\u003e\u003cstrong\u003eBenefits:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"998c\"\u003eRemoves function call overhead (especially for small higher-order functions).\u003c/li\u003e\u003cli id=\"50c7\"\u003eEliminates lambda object creation, reducing allocations.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9c91\"\u003e\u003cstrong\u003eHidden pitfall: broken stack traces\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"6c18\"\u003eConsider:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3fb4\"\u003einline fun runSafe(block: () -\u0026gt; Unit) {\u003cbr/\u003e    try {\u003cbr/\u003e        block()\u003cbr/\u003e    } catch (e: Exception) {\u003cbr/\u003e        println(e.stackTraceToString())\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003efun fail() {\u003cbr/\u003e    throw RuntimeException(\u0026#34;Fail\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efun main() {\u003cbr/\u003e    runSafe { fail() }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"55a0\"\u003eYou might expect:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d705\"\u003eRuntimeException: Fail\u003cbr/\u003e    at fail\u003cbr/\u003e    at runSafe$lambda...\u003cbr/\u003e    at runSafe\u003cbr/\u003e    at main\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a129\"\u003eBut due to inlining, you get:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8679\"\u003eRuntimeException: Fail\u003cbr/\u003e    at fail\u003cbr/\u003e    at main\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b3d9\"\u003eThe \u003ccode\u003erunSafe\u003c/code\u003e frame is gone, complicating debugging and crash analysis.\u003c/p\u003e\u003cp id=\"4d67\"\u003e\u003cstrong\u003eRecommendations:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"ba25\"\u003eBe aware that all inlined frames disappear in stack traces unless you explicitly add logging and markers.\u003c/li\u003e\u003cli id=\"7247\"\u003eTools like \u003ca href=\"https://talsec.app\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTalsec\u003c/a\u003e or crash reporting pipelines can annotate inlined code to preserve context.\u003c/li\u003e\u003cli id=\"3219\"\u003eKeep non-trivial error boundaries as non-inline functions.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"081f\"\u003e2. Why \u003ccode\u003ecrossinline\u003c/code\u003e matters in suspending contexts\u003c/h2\u003e\u003cp id=\"3bdf\"\u003e\u003cstrong\u003eProblem: non-local returns\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"f38b\"\u003eKotlin lambdas support non-local returns in \u003ccode\u003einline\u003c/code\u003e functions:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9ded\"\u003einline fun runBlock(block: () -\u0026gt; Unit) {\u003cbr/\u003e    block() // can `return` from the caller of runBlock\u003cbr/\u003e}\u003cp\u003efun test() {\u003cbr/\u003e    runBlock {\u003cbr/\u003e        return // returns from test()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e355\"\u003eHowever, \u003cstrong\u003enon-local returns are not allowed:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"bf6a\"\u003eFrom lambdas passed to \u003ccode\u003enoinline\u003c/code\u003e parameters.\u003c/li\u003e\u003cli id=\"df0d\"\u003eFrom lambdas used inside suspend contexts (e.g., launched coroutines).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ada8\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e: crashing misuse\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7fce\"\u003einline fun runInline(scope: CoroutineScope, block: () -\u0026gt; Unit) {\u003cbr/\u003e    scope.launch {\u003cbr/\u003e        block() // Kotlin: Cannot inline \u0026#39;block: () -\u0026gt; Unit\u0026#39; here: it might contain non-local returns.\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f392\"\u003e\u003cstrong\u003eSolution\u003c/strong\u003e: Use \u003ccode\u003ecrossinline\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1ef4\"\u003einline fun runInlineCross(scope: CoroutineScope, crossinline block: () -\u0026gt; Unit) {\u003cbr/\u003e    scope.launch {\u003cbr/\u003e        block() // Allowed, non-local returns are disallowed explicitly\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0534\"\u003eUsing \u003ccode\u003ecrossinline\u003c/code\u003e ensures:\u003c/p\u003e\u003cul\u003e\u003cli id=\"6552\"\u003eThe compiler enforces no non-local returns.\u003c/li\u003e\u003cli id=\"d68a\"\u003eYour inline functions remain usable in suspending and coroutine contexts.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"704f\"\u003e3. R\u003ccode\u003eeified\u003c/code\u003e: type-safe builders and beyond\u003c/h2\u003e\u003cp id=\"05f6\"\u003eWhat \u003ccode\u003ereified\u003c/code\u003e enables\u003c/p\u003e\u003cp id=\"0dc1\"\u003eNormally, generic types are erased at runtime:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"21bb\"\u003efun \u0026lt;T\u0026gt; foo() {\u003cbr/\u003e    println(T::class) // Error: Cannot use \u0026#39;T\u0026#39; as reified type parameter\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"21f2\"\u003eBy marking an \u003ccode\u003einline\u003c/code\u003e function with \u003ccode\u003ereified\u003c/code\u003e, type information is preserved:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e156\"\u003einline fun \u0026lt;reified T\u0026gt; foo() {\u003cbr/\u003e    println(T::class) // It works\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1c64\"\u003eType-safe builders with \u003ccode\u003ereified\u003c/code\u003e\u003c/p\u003e\u003cp id=\"fa36\"\u003eConsider a JSON serializer builder:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6095\"\u003einline fun \u0026lt;reified T\u0026gt; Moshi.getAdapter(): JsonAdapter\u0026lt;T\u0026gt; =\u003cbr/\u003e    this.adapter(T::class.java)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a260\"\u003eNow you get:\u003c/p\u003e\u003cul\u003e\u003cli id=\"cd5d\"\u003eType safety without explicitly passing \u003ccode\u003eClass\u0026lt;T\u0026gt;\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"2ea3\"\u003eCleaner APIs in DSLs.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b09d\"\u003e\u003cstrong\u003eHidden Pitfall: \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e is required\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"73b8\"\u003e\u003ccode\u003ereified\u003c/code\u003e only works with \u003ccode\u003einline\u003c/code\u003e functions. However, overusing \u003ccode\u003einline\u003c/code\u003e for the sake of \u003ccode\u003ereified\u003c/code\u003e can:\u003c/p\u003e\u003cul\u003e\u003cli id=\"78fa\"\u003eInflate bytecode if misused in large functions.\u003c/li\u003e\u003cli id=\"6508\"\u003eReduce binary stability if you frequently change inlined logic in library APIs.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"837f\"\u003e\u003cstrong\u003eGuidelines:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"a692\"\u003eUse \u003ccode\u003ereified\u003c/code\u003e for factory/builders, reflection-based utilities, and type-safe APIs.\u003c/li\u003e\u003cli id=\"00e8\"\u003eAvoid using \u003ccode\u003einline + reified\u003c/code\u003e in large or complex functions that change often in libraries.\u003c/li\u003e\u003cli id=\"fc38\"\u003eConsider alternative explicit \u003ccode\u003eClass\u0026lt;T\u0026gt;\u003c/code\u003e passing if \u003ccode\u003einline\u003c/code\u003e/\u003ccode\u003ereified\u003c/code\u003e is overkill.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"426d\"\u003e4. Debugging and testing inline code\u003c/h2\u003e\u003cul\u003e\u003cli id=\"3558\"\u003eUse \u003ccode\u003e-Xinline-classes\u003c/code\u003e and decompiler tools (e.g., JADX) to view how your inline code compiles.\u003c/li\u003e\u003cli id=\"891f\"\u003eUse ProGuard/R8 mappings to map minified crashes back to readable stack traces.\u003c/li\u003e\u003cli id=\"6ad3\"\u003eWhen profiling, remember inlined functions will not appear in call graphs, so measure allocations directly.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"4d12\"\u003e5. Checklist for safe use\u003c/h2\u003e\u003cp id=\"c269\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"5ba2\"\u003eFor small higher-order functions where lambda allocation is a real bottleneck.\u003c/li\u003e\u003cli id=\"e777\"\u003eFor DSL builders where readability and ergonomics matter.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"611c\"\u003e\u003cstrong\u003eAvoid \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"d23b\"\u003eFor large functions or when stack traces are critical for debugging.\u003c/li\u003e\u003cli id=\"ad31\"\u003eFor functions with heavy internal logic that can change frequently in libraries.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7091\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecrossinline\u003c/strong\u003e\u003c/code\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3570\"\u003eWhenever you pass lambdas into \u003ccode\u003esuspend\u003c/code\u003e or coroutine contexts inside inline functions.\u003c/li\u003e\u003cli id=\"b59b\"\u003eWhen you want to prevent non-local returns explicitly.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1a68\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b183\"\u003eFor type-safe builders, factories, and reflective utilities.\u003c/li\u003e\u003cli id=\"6483\"\u003eWhen it genuinely improves ergonomics over \u003ccode\u003eClass\u0026lt;T\u0026gt;\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"67aa\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"eb19\"\u003eKotlin gives us powerful tools — \u003ccode\u003einline\u003c/code\u003e, \u003ccode\u003ecrossinline\u003c/code\u003e, and \u003ccode\u003ereified\u003c/code\u003e — to write expressive and performant code. But with power comes nuance. Misusing these keywords won’t necessarily crash your app, but it can lead to subtle bugs, confusing stack traces, or bloated binaries. Understanding how they behave under the hood isn’t just for language nerds — it’s how you write safer, smarter Kotlin.\u003c/p\u003e\u003cp id=\"d644\"\u003eIf you found this helpful, feel free to follow me here on \u003ca href=\"https://medium.com/@d_glazunov\" rel=\"noopener\"\u003eMedium\u003c/a\u003e where I share hands-on insights into Kotlin, mobile development and engineering.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-07-24T16:56:32.364Z",
  "modifiedTime": null
}
