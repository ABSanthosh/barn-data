{
  "id": "98a809cc-eadf-43fb-874b-a2cd2e145cb8",
  "title": "Seamless shimmer integration with existing Compose code",
  "link": "https://proandroiddev.com/seamless-shimmer-integration-with-existing-compose-code-b95cc3bbcd17?source=rss----c72404660798---4",
  "description": "",
  "author": "Igor Escodro",
  "published": "Sat, 01 Feb 2025 19:05:27 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "development",
    "shimmer",
    "user-experience",
    "compose",
    "android"
  ],
  "byline": "Igor Escodro",
  "length": 4688,
  "excerpt": "Shimmer is an effect that improves the user experience by providing a smoother transition between the ‚Äúloading‚Äù and ‚Äúready‚Äù states by showing a skeleton of the UI that is about to be shown. This‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Shimmer is an effect that improves the user experience by providing a smoother transition between the ‚Äúloading‚Äù and ‚Äúready‚Äù states by showing a skeleton of the UI that is about to be shown. This effect reduces the user uncertainty about what will be shown, and it‚Äôs widely used in applications that rely on remote data.The goal of this article is not to show how to implement the shimmer effect, there are multiple interesting articles about this topic. This article will cover how to seamlessly integrate it with your existent Compose code.ChallengeRecently, I was tasked to rebuild a screen that loads content from the server and display to the user. During the development, I thought it would be nice to add a shimmer effect since the request took a few seconds and the screen doesn‚Äôt have a cache mechanism.Loading without shimmerLoading with shimmerMy first attempt was to create a new Composable to ‚Äúmirror‚Äù the real one, having the shimmer effect. The benefit of this approach is that since there is no data ready, we can draw shapes in the same position as the real components. However, maintaining two different sets of Composables is difficult, especially for more complex screens that have multiple nested ones. In addition, all the UI changes in the original Composable needs to be ported to these ‚Äúmirrored‚Äù versions to keep the consistency.After some investigation, I decided to mix-and-match some solutions and develop a way to use the shimmer, modifying as little as possible the existing Composables.ImplementationAdding the shimmer effectAs mentioned earlier, there are several references on how to implement your custom shimmer effect. To keep this article simple and focused on the integration, we will use the valentinilk/compose-shimmer library, which is easy to use and have multiplatform support.Implementing a new ModifierWe will implement a new Modifier to wrap the shimmer effect and draw the placeholder, if needed. Here is the proposed code:Analyzing the code above, the implementation:Receives a boolean and have an early return if the effect should not be enabledReceives a color and shape that can be customizedIf enabled, the Modifier will draw the shape where the content should be and do not draw the content at allHere‚Äôs how the Compose Preview will look like:Preview: shimmer disabled (top) vs. shimmer enabled (bottom)For using it, all we need to do is adding the Modifier to the Composables we want to have this support:Integrating with the existing codeAs you might have noticed, even though we are sending the isLoading value to enable the shimmer effect, since the code is loading the data from the server, we don‚Äôt have ItemData available yet to display. To help solve this issue, we can apply the concepts:Make the Composable stateless, making it easy to integrate any data without introducing side effects;Create a fake representation of the data, similarly to the data we will use in the Composable PreviewAfter applying the concepts above, we would have a code similar to the following:Optional: Implement a custom CompositionLocalBefore diving into the implementation, it‚Äôs important to notice that CompositionLocal should be used with care, since its over-usage adds extra complexity to the code. For more information about this component and when or not use, please access the official docs.The solution we developed worked good so far, however the original goal was to change the original Composable code as little as possible. In the current state, we need to pass the isLoading: Boolean around to determine if theModifier.shimmerable should be enabled or not.By implementing a custom CompositionLocal, we can pass this information down the Composable nodes implicitly, making the Composables unaware of this value since it only matters for our custom Modifier. One possible implementation for this feature is:The usage will be simplified to:After this changes, we only need two changes in our code:Wrap the loading state with the shimmer with our CompositionLocalAdd .shimmerable() in all the Composables we want to have this supportCode diff: before and after shimmer support ‚Äî just one line changed per componentWhat‚Äôs next?As usual, the code used here is available in full on GitHub. Feel free to use and modify it as you wish. üòäConclusionThe shimmer effect is a well known strategy to improve the user experience by creating a smoother transition. Implementing the shimmer effect in Compose is well documented and there are libraries to help us on this task. However, making it easy to implement on existing codebases and keep it scalable might be a challenge. Hopefully, this article help you have some ideas on how to achieve it.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*H3W1jzOge8Q9gi0A60pUOQ.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp id=\"010b\"\u003eShimmer is an effect that improves the user experience by providing a smoother transition between the ‚Äúloading‚Äù and ‚Äúready‚Äù states by showing a \u003cem\u003eskeleton\u003c/em\u003e of the UI that is about to be shown. This effect reduces the user uncertainty about what will be shown, and it‚Äôs widely used in applications that rely on remote data.\u003c/p\u003e\u003cp id=\"0c81\"\u003eThe goal of this article is not to show how to implement the shimmer effect, there are \u003ca href=\"https://medium.com/@m.derakhshan/how-to-implement-the-shimmer-effect-using-jetpack-compose-fc0e81e47747\" rel=\"noopener\"\u003emultiple\u003c/a\u003e \u003ca href=\"https://medium.com/@bahromzoda.behruz27/shimmer-effects-in-jetpack-compose-b974a3f63aec\" rel=\"noopener\"\u003einteresting\u003c/a\u003e \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/shimmer-shadow-loading-effect-animation-with-jetpack-compose-f4b3de28dc2b\"\u003earticles\u003c/a\u003e about this topic. This article will cover how to seamlessly integrate it with your existent Compose code.\u003c/p\u003e\u003ch2 id=\"27a2\"\u003eChallenge\u003c/h2\u003e\u003cp id=\"b659\"\u003eRecently, I was tasked to rebuild a screen that loads content from the server and display to the user. During the development, I thought it would be nice to add a shimmer effect since the request took a few seconds and the screen doesn‚Äôt have a cache mechanism.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eLoading without shimmer\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003eLoading with shimmer\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"70af\"\u003eMy first attempt was to create a new Composable to ‚Äúmirror‚Äù the real one, having the shimmer effect. The benefit of this approach is that since there is no data ready, we can draw shapes in the same position as the real components. However, maintaining two different sets of Composables is difficult, especially for more complex screens that have multiple nested ones. In addition, all the UI changes in the original Composable needs to be ported to these ‚Äúmirrored‚Äù versions to keep the consistency.\u003c/p\u003e\u003cp id=\"5f5c\"\u003eAfter some investigation, I decided to mix-and-match some solutions and develop a way to use the shimmer, modifying as little as possible the existing Composables.\u003c/p\u003e\u003ch2 id=\"771f\"\u003eImplementation\u003c/h2\u003e\u003ch2 id=\"c022\"\u003eAdding the shimmer effect\u003c/h2\u003e\u003cp id=\"1051\"\u003eAs mentioned earlier, there are several references on how to implement your custom shimmer effect. To keep this article simple and focused on the integration, we will use the \u003ca href=\"https://github.com/valentinilk/compose-shimmer\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003evalentinilk/compose-shimmer\u003c/a\u003e library, which is easy to use and have multiplatform support.\u003c/p\u003e\u003ch2 id=\"c12c\"\u003eImplementing a new Modifier\u003c/h2\u003e\u003cp id=\"ed48\"\u003eWe will implement a new Modifier to wrap the shimmer effect and draw the placeholder, if needed. Here is the proposed code:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a9e0\"\u003eAnalyzing the code above, the implementation:\u003c/p\u003e\u003col\u003e\u003cli id=\"a34e\"\u003eReceives a boolean and have an early return if the effect should not be enabled\u003c/li\u003e\u003cli id=\"43e1\"\u003eReceives a color and shape that can be customized\u003c/li\u003e\u003cli id=\"5ae0\"\u003eIf enabled, the Modifier will draw the shape where the content should be and do not draw the content at all\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"33f4\"\u003eHere‚Äôs how the Compose Preview will look like:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003ePreview: shimmer disabled (top) vs. shimmer enabled (bottom)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"4621\"\u003eFor using it, all we need to do is adding the Modifier to the Composables we want to have this support:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"8bea\"\u003eIntegrating with the existing code\u003c/h2\u003e\u003cp id=\"7dee\"\u003eAs you might have noticed, even though we are sending the \u003ccode\u003eisLoading\u003c/code\u003e value to enable the shimmer effect, since the code is loading the data from the server, we don‚Äôt have \u003ccode\u003eItemData\u003c/code\u003e available yet to display. To help solve this issue, we can apply the concepts:\u003c/p\u003e\u003col\u003e\u003cli id=\"6331\"\u003eMake the Composable \u003ca href=\"https://developer.android.com/develop/ui/compose/state#stateful-vs-stateless\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003estateless\u003c/a\u003e, making it easy to integrate any data without introducing side effects;\u003c/li\u003e\u003cli id=\"3486\"\u003eCreate a fake representation of the data, similarly to the data we will use in the Composable Preview\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"9d44\"\u003eAfter applying the concepts above, we would have a code similar to the following:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"a566\"\u003eOptional: Implement a custom CompositionLocal\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"6de4\"\u003eBefore diving into the implementation, it‚Äôs important to notice that CompositionLocal should be used with care, since its over-usage adds extra complexity to the code. For more information about this component and when or not use, please access the \u003ca href=\"https://developer.android.com/develop/ui/compose/compositionlocal#creating-apis\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eofficial docs\u003c/a\u003e.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"a006\"\u003eThe solution we developed worked good so far, however the original goal was to change the original Composable code as little as possible. In the current state, we need to pass the \u003ccode\u003eisLoading: Boolean\u003c/code\u003e around to determine if the\u003ccode\u003eModifier.shimmerable\u003c/code\u003e should be enabled or not.\u003c/p\u003e\u003cp id=\"b855\"\u003eBy implementing a custom CompositionLocal, we can pass this information down the Composable nodes implicitly, making the Composables unaware of this value since it only matters for our custom Modifier. One possible implementation for this feature is:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ae6d\"\u003eThe usage will be simplified to:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a4ca\"\u003eAfter this changes, we only need two changes in our code:\u003c/p\u003e\u003col\u003e\u003cli id=\"df6e\"\u003eWrap the loading state with the shimmer with our CompositionLocal\u003c/li\u003e\u003cli id=\"2a9b\"\u003eAdd \u003ccode\u003e.shimmerable()\u003c/code\u003e in all the Composables we want to have this support\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003cfigcaption\u003eCode diff: before and after shimmer support ‚Äî just one line changed per component\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"9ee0\"\u003eWhat‚Äôs next?\u003c/h2\u003e\u003cp id=\"fd7b\"\u003eAs usual, the code used here is available in full on GitHub. Feel free to use and modify it as you wish. üòä\u003c/p\u003e\u003ch2 id=\"34e1\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"c601\"\u003eThe shimmer effect is a well known strategy to improve the user experience by creating a smoother transition. Implementing the shimmer effect in Compose is well documented and there are libraries to help us on this task. However, making it easy to implement on existing codebases and keep it scalable might be a challenge. Hopefully, this article help you have some ideas on how to achieve it.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-01-31T01:46:52.654Z",
  "modifiedTime": null
}
