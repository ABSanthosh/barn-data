{
  "id": "44a85d0e-09e0-4b52-bb9f-adc0396b0ad8",
  "title": "Zoho Achieves 6x Faster Logins with Passkey and Credential Manager Integration",
  "link": "http://android-developers.googleblog.com/2025/05/zoho-achieves-faster-logins-passkey-credential-manager-integration.html",
  "description": "",
  "author": "Android Developers",
  "published": "2025-05-07T09:00:00.000-07:00",
  "source": "http://feeds.feedburner.com/blogspot/hsDu",
  "categories": [
    "#CredentialManager",
    "#passkeys",
    "Authentication",
    "FIDO2",
    "passwordless authentication"
  ],
  "byline": "",
  "length": 18300,
  "excerpt": "Zoho integrated passkeys and Android's Credential Manager API, resulting in faster logins and month-over-month growth in passkey adoption.",
  "siteName": "Android Developers Blog",
  "favicon": "",
  "text": "Posted by Niharika Arora – Senior Developer Relations Engineer, Joseph Lewis – Staff Technical Writer, and Kumareshwaran Sreedharan – Product Manager, Zoho. As an Android developer, you're constantly looking for ways to enhance security, improve user experience, and streamline development. Zoho, a comprehensive cloud-based software suite focused on security and seamless experiences, achieved significant improvements by adopting passkeys in their OneAuth Android app. Since integrating passkeys in 2024, Zoho achieved login speeds up to 6x faster than previous methods and a 31% month-over-month (MoM) growth in passkey adoption. This case study examines Zoho's adoption of passkeys and Android's Credential Manager API to address authentication difficulties. It details the technical implementation process and highlights the impactful results. Overcoming authentication challenges Zoho utilizes a combination of authentication methods to protect user accounts. This included Zoho OneAuth, their own multi-factor authentication (MFA) solution, which supported both password-based and passwordless authentication using push notifications, QR codes, and time-based one-time passwords (TOTP). Zoho also supported federated logins, allowing authentication through Security Assertion Markup Language (SAML) and other third-party identity providers. Challenges Zoho, like many organizations, aimed to improve authentication security and user experience while reducing operational burdens. The primary challenges that led to the adoption of passkeys included: Security vulnerabilities: Traditional password-based methods left users susceptible to phishing attacks and password breaches. User friction: Password fatigue led to forgotten passwords, frustration, and increased reliance on cumbersome recovery processes. Operational inefficiencies: Handling password resets and MFA issues generated significant support overhead. Scalability concerns: A growing user base demanded a more secure and efficient authentication solution. Why the shift to passkeys? Passkeys were implemented in Zoho's apps to address authentication challenges by offering a passwordless approach that significantly improves security and user experience. This solution leverages phishing-resistant authentication, cloud-synchronized credentials for effortless cross-device access, and biometrics (such as a fingerprint or facial recognition), PIN, or pattern for secure logins, thereby reducing the vulnerabilities and inconveniences associated with traditional passwords. By adopting passkeys with Credential Manager, Zoho cut login times by up to 6x, slashed password-related support costs, and saw strong user adoption – doubling passkey sign-ins in 4 months with 31% MoM growth. Zoho users now enjoy faster, easier logins and phishing-resistant security. Implementation with Credential Manager on Android So, how did Zoho achieve these results? They used Android's Credential Manager API, the recommended Jetpack library for implementing authentication on Android. Credential Manager provides a unified API that simplifies handling of the various authentication methods. Instead of juggling different APIs for passwords, passkeys, and federated logins (like Sign in with Google), you use a single interface. Implementing passkeys at Zoho required both client-side and server-side adjustments. Here's a detailed breakdown of the passkey creation, sign-in, and server-side implementation process. Passkey creation To create a passkey, the app first retrieves configuration details from Zoho's server. This process includes a unique verification, such as a fingerprint or facial recognition. This verification data, formatted as a requestJson string), is used by the app to build a CreatePublicKeyCredentialRequest. The app then calls the credentialManager.createCredential method, which prompts the user to authenticate using their device screen lock (biometrics, fingerprint, PIN, etc.). Upon successful user confirmation, the app receives the new passkey credential data, sends it back to Zoho's server for verification, and the server then stores the passkey information linked to the user's account. Failures or user cancellations during the process are caught and handled by the app. Sign-in The Zoho Android app initiates the passkey sign-in process by requesting sign-in options, including a unique challenge, from Zoho's backend server. The app then uses this data to construct a GetCredentialRequest, indicating it will authenticate with a passkey. It then invokes the Android CredentialManager.getCredential() API with this request. This action triggers a standardized Android system interface, prompting the user to choose their Zoho account (if multiple passkeys exist) and authenticate using their device's configured screen lock (fingerprint, face scan, or PIN). After successful authentication, Credential Manager returns a signed assertion (proof of login) to the Zoho app. The app forwards this assertion to Zoho's server, which verifies the signature against the user's stored public key and validates the challenge, completing the secure sign-in process. Server-side implementation Zoho's transition to supporting passkeys benefited from their backend systems already being FIDO WebAuthn compliant, which streamlined the server-side implementation process. However, specific modifications were still necessary to fully integrate passkey functionality. The most significant challenge involved adapting the credential storage system. Zoho's existing authentication methods, which primarily used passwords and FIDO security keys for multi-factor authentication, required different storage approaches than passkeys, which are based on cryptographic public keys. To address this, Zoho implemented a new database schema specifically designed to securely store passkey public keys and related data according to WebAuthn protocols. This new system was built alongside a lookup mechanism to validate and retrieve credentials based on user and device information, ensuring backward compatibility with older authentication methods. Another server-side adjustment involved implementing the ability to handle requests from Android devices. Passkey requests originating from Android apps use a unique origin format (android:apk-key-hash:example) that is distinct from standard web origins that use a URI-based format (https://example.com/app). The server logic needed to be updated to correctly parse this format, extract the SHA-256 fingerprint hash of the app's signing certificate, and validate it against a pre-registered list. This verification step ensures that authentication requests genuinely originate from Zoho's Android app and protects against phishing attacks. This code snippet demonstrates how the server checks for the Android-specific origin format and validates the certificate hash: val origin: String = clientData.getString(\"origin\") if (origin.startsWith(\"android:apk-key-hash:\")) { val originSplit: List\u003cString\u003e = origin.split(\":\") if (originSplit.size \u003e 3) { val androidOriginHashDecoded: ByteArray = Base64.getDecoder().decode(originSplit[3]) if (!androidOriginHashDecoded.contentEquals(oneAuthSha256FingerPrint)) { throw IAMException(IAMErrorCode.WEBAUTH003) } } else { // Optional: Handle the case where the origin string is malformed } } Error handling Zoho implemented robust error handling mechanisms to manage both user-facing and developer-facing errors. A common error, CreateCredentialCancellationException, appeared when users manually canceled their passkey setup. Zoho tracked the frequency of this error to assess potential UX improvements. Based on Android's UX recommendations, Zoho took steps to better educate their users about passkeys, ensure users were aware of passkey availability, and promote passkey adoption during subsequent sign-in attempts. This code example demonstrates Zoho's approach for how they handled their most common passkey creation errors: private fun handleFailure(e: CreateCredentialException) { val msg = when (e) { is CreateCredentialCancellationException -\u003e { Analytics.addAnalyticsEvent(eventProtocol: \"PASSKEY_SETUP_CANCELLED\", GROUP_NAME) Analytics.addNonFatalException(e) \"The operation was canceled by the user.\" } is CreateCredentialInterruptedException -\u003e { Analytics.addAnalyticsEvent(eventProtocol: \"PASSKEY_SETUP_INTERRUPTED\", GROUP_NAME) Analytics.addNonFatalException(e) \"Passkey setup was interrupted. Please try again.\" } is CreateCredentialProviderConfigurationException -\u003e { Analytics.addAnalyticsEvent(eventProtocol: \"PASSKEY_PROVIDER_MISCONFIGURED\", GROUP_NAME) Analytics.addNonFatalException(e) \"Credential provider misconfigured. Contact support.\" } is CreateCredentialUnknownException -\u003e { Analytics.addAnalyticsEvent(eventProtocol: \"PASSKEY_SETUP_UNKNOWN_ERROR\", GROUP_NAME) Analytics.addNonFatalException(e) \"An unknown error occurred during Passkey setup.\" } is CreatePublicKeyCredentialDomException -\u003e { Analytics.addAnalyticsEvent(eventProtocol: \"PASSKEY_WEB_AUTHN_ERROR\", GROUP_NAME) Analytics.addNonFatalException(e) \"Passkey creation failed: ${e.domError}\" } else -\u003e { Analytics.addAnalyticsEvent(eventProtocol: \"PASSKEY_SETUP_FAILED\", GROUP_NAME) Analytics.addNonFatalException(e) \"An unexpected error occurred. Please try again.\" } } } Testing passkeys in intranet environments Zoho faced an initial challenge in testing passkeys within a closed intranet environment. The Google Password Manager verification process for passkeys requires public domain access to validate the relying party (RP) domain. However, Zoho's internal testing environment lacked this public Internet access, causing the verification process to fail and hindering successful passkey authentication testing. To overcome this, Zoho created a publicly accessible test environment, which included hosting a temporary server with an asset link file and domain validation. This example from the assetlinks.json file used in Zoho's public test environment demonstrates how to associate the relying party domain with the specified Android app for passkey validation. [ { \"relation\": [ \"delegate_permission/common.handle_all_urls\", \"delegate_permission/common.get_login_creds\" ], \"target\": { \"namespace\": \"android_app\", \"package_name\": \"com.zoho.accounts.oneauth\", \"sha256_cert_fingerprints\": [ \"SHA_HEX_VALUE\" ] } } ] Integrate with an existing FIDO server Android's passkey system utilizes the modern FIDO2 WebAuthn standard. This standard requires requests in a specific JSON format, which helps maintain consistency between native applications and web platforms. To enable Android passkey support, Zoho did minor compatibility and structural changes to correctly generate and process requests that adhere to the required FIDO2 JSON structure. This server update involved several specific technical adjustments: 1. Encoding conversion: The server converts the Base64 URL encoding (commonly used in WebAuthn for fields like credential IDs) to standard Base64 encoding before it stores the relevant data. The snippet below shows how a rawId might be encoded to standard Base64: // Convert rawId bytes to a standard Base64 encoded string for storage val base64RawId: String = Base64.getEncoder().encodeToString(rawId.toByteArray()) 2. Transport list format: To ensure consistent data processing, the server logic handles lists of transport mechanisms (such as USB, NFC, and Bluetooth, which specify how the authenticator communicated) as JSON arrays. 3. Client data alignment: The Zoho team adjusted how the server encodes and decodes the clientDataJson field. This ensures the data structure aligns precisely with the expectations of Zoho’s existing internal APIs. The example below illustrates part of the conversion logic applied to client data before the server processes it: private fun convertForServer(type: String): String { val clientDataBytes = BaseEncoding.base64().decode(type) val clientDataJson = JSONObject(String(clientDataBytes, StandardCharsets.UTF_8)) val clientJson = JSONObject() val challengeFromJson = clientDataJson.getString(\"challenge\") // 'challenge' is a technical identifier/token, not localizable text. clientJson.put(\"challenge\", BaseEncoding.base64Url() .encode(challengeFromJson.toByteArray(StandardCharsets.UTF_8))) clientJson.put(\"origin\", clientDataJson.getString(\"origin\")) clientJson.put(\"type\", clientDataJson.getString(\"type\")) clientJson.put(\"androidPackageName\", clientDataJson.getString(\"androidPackageName\")) return BaseEncoding.base64().encode(clientJson.toString().toByteArray()) } User guidance and authentication preferences A central part of Zoho's passkey strategy involved encouraging user adoption while providing flexibility to align with different organizational requirements. This was achieved through careful UI design and policy controls. Zoho recognized that organizations have varying security needs. To accommodate this, Zoho implemented: Admin enforcement: Through the Zoho Directory admin panel, administrators can designate passkeys as the mandatory, default authentication method for their entire organization. When this policy is enabled, employees are required to set up a passkey upon their next login and use it going forward. User choice: If an organization does not enforce a specific policy, individual users maintain control. They can choose their preferred authentication method during login, selecting from passkeys or other configured options via their authentication settings. To make adopting passkeys appealing and straightforward for end-users, Zoho implemented: Easy setup: Zoho integrated passkey setup directly into the Zoho OneAuth mobile app (available for both Android and iOS). Users can conveniently configure their passkeys within the app at any time, smoothing the transition. Consistent access: Passkey support was implemented across key user touchpoints, ensuring users can register and authenticate using passkeys via: The Zoho OneAuth mobile app (Android \u0026 iOS); Their Zoho web accounts page. This method ensured that the process of setting up and using passkeys was accessible and integrated into the platforms they already use, regardless of whether it was mandated by an admin or chosen by the user. You can learn more about how to create smooth user flows for passkey authentication by exploring our comprehensive passkeys user experience guide. Impact on developer velocity and integration efficiency Credential Manager, as a unified API, also helped improve developer productivity compared to older sign-in flows. It reduced the complexity of handling multiple authentication methods and APIs separately, leading to faster integration, from months to weeks, and fewer implementation errors. This collectively streamlined the sign-in process and improved overall reliability. By implementing passkeys with Credential Manager, Zoho achieved significant, measurable improvements across the board: Dramatic speed improvements 2x faster login compared to traditional password authentication. 4x faster login compared to username or mobile number with email or SMS OTP authentication. 6x faster login compared to username, password, and SMS or authenticator OTP authentication. Reduced support costs Reduced password-related support requests, especially for forgotten passwords. Lower costs associated with SMS-based 2FA, as existing users can onboard directly with passkeys. Strong user adoption \u0026 enhanced security: Passkey sign-ins doubled in just 4 months, showing high user acceptance. Users migrating to passkeys are fully protected from common phishing and password breach threats. With 31% MoM adoption growth, more users are benefiting daily from enhanced security against vulnerabilities like phishing and SIM swaps. Recommendations and best practices To successfully implement passkeys on Android, developers should consider the following best practices: Leverage Android's Credential Manager API: Credential Manager simplifies credential retrieval, reducing developer effort and ensuring a unified authentication experience. Handles passwords, passkeys, and federated login flows in a single interface. Ensure data encoding consistency while migrating from other FIDO authentication solutions: Make sure you handle consistent formatting for all inputs/outputs while migrating from other FIDO authentication solutions such as FIDO security keys. Optimize error handling and logging: Implement robust error handling for a seamless user experience. Provide localized error messages and use detailed logs to debug and resolve unexpected failures. Educate users on passkey recovery options: Prevent lockout scenarios by proactively guiding users on recovery options. Monitor adoption metrics and user feedback: Track user engagement, passkey adoption rates, and login success rates to keep optimizing user experience. Conduct A/B testing on different authentication flows to improve conversion and retention. Passkeys, combined with the Android Credential Manager API, offer a powerful, unified authentication solution that enhances security while simplifying user experience. Passkeys significantly reduce phishing risks, credential theft, and unauthorized access. We encourage developers to try out the experience in their app and bring the most secure authentication to their users. Get started with passkeys and Credential Manager Get hands on with passkeys and Credential Manager on Android using our public sample code. If you have any questions or issues, you can share with us through the Android Credentials issues tracker.",
  "image": "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi5qpwVAje1AjhxTuWNrSBSelhGRekoGR0BYjBIJIkK1OEur5I0AXf8QRJJ4zvt1YIPu6UHS-byMolDEWSwVreJInX3OnOAQbd15rKH_YV04B5Bq2qrsY0ZU4x6ULPMWiqHtmMo4nECQkaeSFgylV98zp0QWriwSBjjbsufqXSGlNHuN6L3esFrVLZ_7d4/w1200-h630-p-k-no-nu/ANDDM_Zoho_Header.gif",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cmeta content=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi5qpwVAje1AjhxTuWNrSBSelhGRekoGR0BYjBIJIkK1OEur5I0AXf8QRJJ4zvt1YIPu6UHS-byMolDEWSwVreJInX3OnOAQbd15rKH_YV04B5Bq2qrsY0ZU4x6ULPMWiqHtmMo4nECQkaeSFgylV98zp0QWriwSBjjbsufqXSGlNHuN6L3esFrVLZ_7d4/s1600/ANDDM_Zoho_Header.gif\" name=\"twitter:image\"/\u003e\n\u003cp\u003e\n\n\u003cem\u003ePosted by \u003ca href=\"https://x.com/thedroidlady\" target=\"_blank\"\u003eNiharika Arora\u003c/a\u003e – Senior Developer Relations Engineer, Joseph Lewis – Staff Technical Writer, and Kumareshwaran Sreedharan – Product Manager, Zoho.\u003c/em\u003e\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi5qpwVAje1AjhxTuWNrSBSelhGRekoGR0BYjBIJIkK1OEur5I0AXf8QRJJ4zvt1YIPu6UHS-byMolDEWSwVreJInX3OnOAQbd15rKH_YV04B5Bq2qrsY0ZU4x6ULPMWiqHtmMo4nECQkaeSFgylV98zp0QWriwSBjjbsufqXSGlNHuN6L3esFrVLZ_7d4/s1600/ANDDM_Zoho_Header.gif\"\u003e\u003cimg data-original-height=\"800\" data-original-width=\"100%\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi5qpwVAje1AjhxTuWNrSBSelhGRekoGR0BYjBIJIkK1OEur5I0AXf8QRJJ4zvt1YIPu6UHS-byMolDEWSwVreJInX3OnOAQbd15rKH_YV04B5Bq2qrsY0ZU4x6ULPMWiqHtmMo4nECQkaeSFgylV98zp0QWriwSBjjbsufqXSGlNHuN6L3esFrVLZ_7d4/s1600/ANDDM_Zoho_Header.gif\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAs an Android developer, you\u0026#39;re constantly looking for ways to enhance security, improve user experience, and streamline development. Zoho, a comprehensive cloud-based software suite focused on security and seamless experiences, achieved significant improvements by adopting passkeys in their \u003ca href=\"https://play.google.com/store/apps/details?id=com.zoho.accounts.oneauth\u0026amp;hl=en_IN\" target=\"_blank\"\u003eOneAuth\u003c/a\u003e Android app.\u003c/p\u003e\n\n\u003cp\u003eSince integrating passkeys in 2024, Zoho achieved \u003cb\u003elogin speeds up to 6x faster\u003c/b\u003e than previous methods and a \u003cb\u003e31% month-over-month (MoM) growth in passkey adoption\u003c/b\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis case study examines Zoho\u0026#39;s adoption of passkeys and Android\u0026#39;s \u003ca href=\"https://developer.android.com/training/sign-in/passkeys\" target=\"_blank\"\u003eCredential Manager API\u003c/a\u003e to address authentication difficulties. It details the technical implementation process and highlights the impactful results.\u003c/p\u003e\n\n\u003ch2\u003e\u003cspan\u003eOvercoming authentication challenges\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eZoho utilizes a combination of authentication methods to protect user accounts. This included Zoho \u003ca href=\"https://www.zoho.com/accounts/oneauth/\" target=\"_blank\"\u003eOneAuth\u003c/a\u003e, their own multi-factor authentication (MFA) solution, which supported both password-based and passwordless authentication using push notifications, QR codes, and time-based one-time passwords (TOTP). Zoho also supported federated logins, allowing authentication through Security Assertion Markup Language (SAML) and other third-party identity providers.\u003c/p\u003e\n\n\u003ch3\u003e\u003cspan\u003eChallenges\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eZoho, like many organizations, aimed to improve authentication security and user experience while reducing operational burdens. The primary challenges that led to the adoption of passkeys included:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003eSecurity vulnerabilities: Traditional password-based methods left users susceptible to phishing attacks and password breaches.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eUser friction: Password fatigue led to forgotten passwords, frustration, and increased reliance on cumbersome recovery processes.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e   \n\u003cli\u003eOperational inefficiencies: Handling password resets and MFA issues generated significant support overhead.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eScalability concerns: A growing user base demanded a more secure and efficient authentication solution.\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\n\u003ch3\u003e\u003cspan\u003eWhy the shift to passkeys?\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003ePasskeys were implemented in Zoho\u0026#39;s apps to address authentication challenges by offering a passwordless approach that significantly improves security and user experience. This solution leverages phishing-resistant authentication, cloud-synchronized credentials for effortless cross-device access, and biometrics (such as a fingerprint or facial recognition), PIN, or pattern for secure logins, thereby reducing the vulnerabilities and inconveniences associated with traditional passwords.\u003c/p\u003e\n\n\u003cp\u003eBy adopting passkeys with Credential Manager, Zoho cut login times by \u003cb\u003eup to 6x\u003c/b\u003e, slashed password-related support costs, and saw \u003cb\u003estrong\u003c/b\u003e user adoption – \u003cb\u003edoubling\u003c/b\u003e passkey sign-ins in 4 months with \u003cb\u003e31% MoM growth\u003c/b\u003e. Zoho users now enjoy \u003cb\u003efaster, easier logins and phishing-resistant security\u003c/b\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"Quote card reads \u0026#39;Cloud Lion now enjoys logins that are 30% faster and more secure using passkeys – allowing us to use our thumb instead of a password. With passkeys, we can also protect our critical business data against phishing and brute force attacks.\u0026#39; – Fabrice Venegas, Founder, Cloud Lion (a Zoho integration partner)\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj_KgbYAjdIfbrxwxOCRZF36RV0C0bRNtfjF0Y0RnIPgCnShzvFf1OLZv35aegZmYhC2SCr6AKGngCxDMF_zA9BZwtwst_PtdxtczPd_n_9d1ruFfI36i1oqMrro8TEz20rKehP5PMbcbaA0mnmcG76ke0bW0_bBxgvtYxGIhDidr8yEGaVUxujAt5jAOM/s16000/ANDDM_Zoho_Quote.png\"/\u003e\u003c/p\u003e\n\n\n\u003ch2\u003e\u003cspan\u003eImplementation with Credential Manager on Android\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eSo, how did Zoho achieve these results? They used Android\u0026#39;s Credential Manager API, the recommended Jetpack library for implementing authentication on Android.\u003c/p\u003e\n\n\u003cp\u003eCredential Manager provides a unified API that simplifies handling of the various authentication methods. Instead of juggling different APIs for passwords, passkeys, and federated logins (like Sign in with Google), you use a single interface.\u003c/p\u003e\n\n\u003cp\u003eImplementing passkeys at Zoho required both client-side and server-side adjustments. Here\u0026#39;s a detailed breakdown of the passkey creation, sign-in, and server-side implementation process.\u003c/p\u003e\n\n\u003ch3\u003e\u003cspan\u003ePasskey creation\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003e\u003cimg alt=\"Passkey creation in OneAuth on a small screen mobile device\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEimfnzjHxc_7oDTDgQEmgDpiAE4u_nQ5IohsE1EeDctS23kSiFHmEG20nwI3LqiRw5OU1u1gBDUd6O3dbJU4lVQvR6eqPWT5CTcITJb8rC5VLay60WHtLziC9EmfypOGNhpZRbWeBSFz9u9pKTj08jqCvazVEu3ZdrWHXxpqz7ZWZSsO8UliPOWOTgua-4/s16000/image1.png\" width=\"45%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eTo \u003ca href=\"https://developer.android.com/identity/sign-in/credential-manager#registration-flows\" target=\"_blank\"\u003ecreate a passkey\u003c/a\u003e, the app first retrieves configuration details from Zoho\u0026#39;s server. This process includes a unique verification, such as a fingerprint or facial recognition. This verification data, formatted as a \u003cspan\u003erequestJson\u003c/span\u003e string), is used by the app to build a \u003cspan\u003eCreatePublicKeyCredentialRequest\u003c/span\u003e. The app then calls the \u003cspan\u003ecredentialManager.createCredential\u003c/span\u003e method, which prompts the user to authenticate using their device screen lock (biometrics, fingerprint, PIN, etc.).\u003c/p\u003e\n\n\u003cp\u003eUpon successful user confirmation, the app receives the new passkey credential data, sends it back to Zoho\u0026#39;s server for verification, and the server then stores the passkey information linked to the user\u0026#39;s account. Failures or user cancellations during the process are caught and handled by the app.\u003c/p\u003e\n\n\u003ch3\u003e\u003cspan\u003eSign-in\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eThe Zoho Android app initiates the \u003ca href=\"https://developer.android.com/identity/sign-in/credential-manager#sign-in\" target=\"_blank\"\u003epasskey sign-in\u003c/a\u003e process by requesting sign-in options, including a unique \u003cspan\u003echallenge\u003c/span\u003e, from Zoho\u0026#39;s backend server. The app then uses this data to construct a \u003cspan\u003eGetCredentialRequest\u003c/span\u003e, indicating it will authenticate with a passkey. It then invokes the Android \u003cspan\u003eCredentialManager.getCredential()\u003c/span\u003e API with this request. This action triggers a standardized Android system interface, prompting the user to choose their Zoho account (if multiple passkeys exist) and authenticate using their device\u0026#39;s configured screen lock (fingerprint, face scan, or PIN). After successful authentication, Credential Manager returns a signed assertion (proof of login) to the Zoho app. The app forwards this assertion to Zoho\u0026#39;s server, which verifies the signature against the user\u0026#39;s stored public key and validates the challenge, completing the secure sign-in process.\u003c/p\u003e\n\n\u003ch3\u003e\u003cspan\u003eServer-side implementation\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eZoho\u0026#39;s transition to supporting passkeys benefited from their backend systems already being FIDO WebAuthn compliant, which streamlined the server-side implementation process. However, specific modifications were still necessary to fully integrate passkey functionality.\u003c/p\u003e\n\n\u003cp\u003eThe most significant challenge involved adapting the credential storage system. Zoho\u0026#39;s existing authentication methods, which primarily used passwords and FIDO security keys for multi-factor authentication, required different storage approaches than passkeys, which are based on cryptographic public keys. To address this, Zoho implemented a new database schema specifically designed to securely store passkey public keys and related data according to WebAuthn protocols. This new system was built alongside a lookup mechanism to validate and retrieve credentials based on user and device information, ensuring backward compatibility with older authentication methods.\u003c/p\u003e\n\n\u003cp\u003eAnother server-side adjustment involved implementing the ability to handle requests from Android devices. Passkey requests originating from Android apps use a unique origin format (\u003cspan\u003eandroid:apk-key-hash:example\u003c/span\u003e) that is distinct from standard web origins that use a URI-based format (\u003cspan\u003ehttps://example.com/app\u003c/span\u003e). The server logic needed to be updated to correctly parse this format, extract the SHA-256 fingerprint hash of the app\u0026#39;s signing certificate, and validate it against a pre-registered list. This verification step ensures that authentication requests genuinely originate from Zoho\u0026#39;s Android app and protects against phishing attacks.\u003c/p\u003e\n\n\u003cp\u003eThis code snippet demonstrates how the server checks for the Android-specific origin format and validates the certificate hash:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e origin: String = clientData.getString(\u003cspan\u003e\u0026#34;origin\u0026#34;\u003c/span\u003e)\n\n\u003cspan\u003eif\u003c/span\u003e (origin.startsWith(\u003cspan\u003e\u0026#34;android:apk-key-hash:\u0026#34;\u003c/span\u003e)) { \n    \u003cspan\u003eval\u003c/span\u003e originSplit: List\u0026lt;String\u0026gt; = origin.split(\u003cspan\u003e\u0026#34;:\u0026#34;\u003c/span\u003e)\n    \u003cspan\u003eif\u003c/span\u003e (originSplit.size \u0026gt; \u003cspan\u003e3\u003c/span\u003e) {\n               \u003cspan\u003eval\u003c/span\u003e androidOriginHashDecoded: ByteArray = Base64.getDecoder().decode(originSplit[\u003cspan\u003e3\u003c/span\u003e])\n\n                \u003cspan\u003eif\u003c/span\u003e (!androidOriginHashDecoded.contentEquals(oneAuthSha256FingerPrint)) {\n            \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003eIAMException\u003c/span\u003e(IAMErrorCode.WEBAUTH003)\n        }\n    } \u003cspan\u003eelse\u003c/span\u003e {\n        \u003cspan\u003e// Optional: Handle the case where the origin string is malformed    }\u003c/span\u003e\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3\u003e\u003cspan\u003eError handling\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eZoho implemented robust \u003ca href=\"https://developer.android.com/identity/sign-in/credential-manager-troubleshooting-guide\" target=\"_blank\"\u003eerror handling mechanisms\u003c/a\u003e to manage both user-facing and developer-facing errors. A common error, \u003cspan\u003eCreateCredentialCancellationException\u003c/span\u003e, appeared when users manually canceled their passkey setup. Zoho tracked the frequency of this error to assess potential UX improvements. Based on Android\u0026#39;s \u003ca href=\"https://developer.android.com/design/ui/mobile/guides/patterns/passkeys\" target=\"_blank\"\u003eUX recommendations\u003c/a\u003e, Zoho took steps to better educate their users about passkeys, ensure users were aware of passkey availability, and promote passkey adoption during subsequent sign-in attempts.\u003c/p\u003e\n\n\u003cp\u003eThis code example demonstrates Zoho\u0026#39;s approach for how they handled their most common passkey creation errors:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003ehandleFailure\u003c/span\u003e(e: CreateCredentialException) {\n    \u003cspan\u003eval\u003c/span\u003e msg = \u003cspan\u003ewhen\u003c/span\u003e (e) {\n        \u003cspan\u003eis\u003c/span\u003e CreateCredentialCancellationException -\u0026gt; {\n            Analytics.addAnalyticsEvent(eventProtocol: \u003cspan\u003e\u0026#34;PASSKEY_SETUP_CANCELLED\u0026#34;\u003c/span\u003e, GROUP_NAME)\n            Analytics.addNonFatalException(e)\n            \u003cspan\u003e\u0026#34;The operation was canceled by the user.\u0026#34;\u003c/span\u003e\n        }\n        \u003cspan\u003eis\u003c/span\u003e CreateCredentialInterruptedException -\u0026gt; {\n            Analytics.addAnalyticsEvent(eventProtocol: \u003cspan\u003e\u0026#34;PASSKEY_SETUP_INTERRUPTED\u0026#34;\u003c/span\u003e, GROUP_NAME)\n            Analytics.addNonFatalException(e)\n            \u003cspan\u003e\u0026#34;Passkey setup was interrupted. Please try again.\u0026#34;\u003c/span\u003e\n        }\n        \u003cspan\u003eis\u003c/span\u003e CreateCredentialProviderConfigurationException -\u0026gt; {\n            Analytics.addAnalyticsEvent(eventProtocol: \u003cspan\u003e\u0026#34;PASSKEY_PROVIDER_MISCONFIGURED\u0026#34;\u003c/span\u003e, GROUP_NAME)\n            Analytics.addNonFatalException(e)\n            \u003cspan\u003e\u0026#34;Credential provider misconfigured. Contact support.\u0026#34;\u003c/span\u003e\n        }\n        \u003cspan\u003eis\u003c/span\u003e CreateCredentialUnknownException -\u0026gt; {\n            Analytics.addAnalyticsEvent(eventProtocol: \u003cspan\u003e\u0026#34;PASSKEY_SETUP_UNKNOWN_ERROR\u0026#34;\u003c/span\u003e, GROUP_NAME)\n            Analytics.addNonFatalException(e)\n            \u003cspan\u003e\u0026#34;An unknown error occurred during Passkey setup.\u0026#34;\u003c/span\u003e\n        }\n        \u003cspan\u003eis\u003c/span\u003e CreatePublicKeyCredentialDomException -\u0026gt; {\n            Analytics.addAnalyticsEvent(eventProtocol: \u003cspan\u003e\u0026#34;PASSKEY_WEB_AUTHN_ERROR\u0026#34;\u003c/span\u003e, GROUP_NAME)\n            Analytics.addNonFatalException(e)\n            \u003cspan\u003e\u0026#34;Passkey creation failed: ${e.domError}\u0026#34;\u003c/span\u003e\n        }\n        \u003cspan\u003eelse\u003c/span\u003e -\u0026gt; {\n            Analytics.addAnalyticsEvent(eventProtocol: \u003cspan\u003e\u0026#34;PASSKEY_SETUP_FAILED\u0026#34;\u003c/span\u003e, GROUP_NAME)\n            Analytics.addNonFatalException(e)\n            \u003cspan\u003e\u0026#34;An unexpected error occurred. Please try again.\u0026#34;\u003c/span\u003e\n        }\n    }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3\u003e\u003cspan\u003eTesting passkeys in intranet environments\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eZoho faced an initial challenge in testing passkeys within a closed intranet environment. The Google Password Manager \u003ca href=\"https://developer.android.com/identity/sign-in/credential-manager#add-support-dal\" target=\"_blank\"\u003everification process\u003c/a\u003e for passkeys requires public domain access to validate the relying party (RP) domain. However, Zoho\u0026#39;s internal testing environment lacked this public Internet access, causing the verification process to fail and hindering successful passkey authentication testing. To overcome this, Zoho created a publicly accessible test environment, which included hosting a temporary server with an \u003ca href=\"https://developer.android.com/identity/sign-in/credential-manager#add-support-dal\" target=\"_blank\"\u003easset link file\u003c/a\u003e and domain validation.\u003c/p\u003e\n\n\u003cp\u003eThis example from the \u003cspan\u003eassetlinks.json\u003c/span\u003e file used in Zoho\u0026#39;s public test environment demonstrates how to associate the relying party domain with the specified Android app for passkey validation.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e[\u003c/span\u003e\n\u003cspan\u003e    {\u003c/span\u003e\n\u003cspan\u003e        \u0026#34;relation\u0026#34;: [\u003c/span\u003e\n\u003cspan\u003e            \u0026#34;delegate_permission/common.handle_all_urls\u0026#34;,\u003c/span\u003e\n\u003cspan\u003e            \u0026#34;delegate_permission/common.get_login_creds\u0026#34;\u003c/span\u003e\n\u003cspan\u003e        ]\u003c/span\u003e,\n        \u003cspan\u003e\u0026#34;target\u0026#34;\u003c/span\u003e: {\n            \u003cspan\u003e\u0026#34;namespace\u0026#34;\u003c/span\u003e: \u003cspan\u003e\u0026#34;android_app\u0026#34;\u003c/span\u003e,\n            \u003cspan\u003e\u0026#34;package_name\u0026#34;\u003c/span\u003e: \u003cspan\u003e\u0026#34;com.zoho.accounts.oneauth\u0026#34;\u003c/span\u003e,\n            \u003cspan\u003e\u0026#34;sha256_cert_fingerprints\u0026#34;\u003c/span\u003e: [\n                \u003cspan\u003e\u0026#34;SHA_HEX_VALUE\u0026#34;\u003c/span\u003e \n            ]\n        }\n    }\n]\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3\u003e\u003cspan\u003eIntegrate with an existing FIDO server\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eAndroid\u0026#39;s passkey system utilizes the modern FIDO2 WebAuthn standard. This standard requires requests in a specific JSON format, which helps maintain consistency between native applications and web platforms. To enable Android passkey support, Zoho did minor compatibility and structural changes to correctly generate and process requests that adhere to the required FIDO2 JSON structure.\u003c/p\u003e\n\n\u003cp\u003eThis server update involved several specific technical adjustments:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\n\u003cp\u003e1. \u003cb\u003eEncoding conversion:\u003c/b\u003e The server converts the Base64 URL encoding (commonly used in WebAuthn for fields like credential IDs) to standard Base64 encoding before it stores the relevant data. The snippet below shows how a \u003cspan\u003erawId\u003c/span\u003e might be encoded to standard Base64:\u003c/p\u003e\n  \n\u003c/ul\u003e\u003c/ul\u003e\n  \n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e// Convert rawId bytes to a standard Base64 encoded string for storage\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e base64RawId: String = Base64.getEncoder().encodeToString(rawId.toByteArray())\n\u003c/pre\u003e\u003c/div\u003e\n \n\u003cul\u003e\u003cul\u003e\n\n\u003cp\u003e2. \u003cb\u003eTransport list format:\u003c/b\u003e To ensure consistent data processing, the server logic handles lists of transport mechanisms (such as USB, NFC, and Bluetooth, which specify how the authenticator communicated) as JSON arrays.\u003c/p\u003e\n  \n\u003cp\u003e3. \u003cb\u003eClient data alignment:\u003c/b\u003e The Zoho team adjusted how the server encodes and decodes the \u003cspan\u003eclientDataJson\u003c/span\u003e field. This ensures the data structure aligns precisely with the expectations of Zoho’s existing internal APIs. The example below illustrates part of the conversion logic applied to client data before the server processes it:\u003c/p\u003e\n\n\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003econvertForServer\u003c/span\u003e(type: String): String {\n    \u003cspan\u003eval\u003c/span\u003e clientDataBytes = BaseEncoding.base64().decode(type)\n    \u003cspan\u003eval\u003c/span\u003e clientDataJson = JSONObject(String(clientDataBytes, StandardCharsets.UTF_8))\n    \u003cspan\u003eval\u003c/span\u003e clientJson = JSONObject()\n    \u003cspan\u003eval\u003c/span\u003e challengeFromJson = clientDataJson.getString(\u003cspan\u003e\u0026#34;challenge\u0026#34;\u003c/span\u003e)\n    \u003cspan\u003e// \u0026#39;challenge\u0026#39; is a technical identifier/token, not localizable text.\u003c/span\u003e\n    clientJson.put(\u003cspan\u003e\u0026#34;challenge\u0026#34;\u003c/span\u003e, BaseEncoding.base64Url()\n        .encode(challengeFromJson.toByteArray(StandardCharsets.UTF_8))) \n\n    clientJson.put(\u003cspan\u003e\u0026#34;origin\u0026#34;\u003c/span\u003e, clientDataJson.getString(\u003cspan\u003e\u0026#34;origin\u0026#34;\u003c/span\u003e))\n    clientJson.put(\u003cspan\u003e\u0026#34;type\u0026#34;\u003c/span\u003e, clientDataJson.getString(\u003cspan\u003e\u0026#34;type\u0026#34;\u003c/span\u003e))\n    clientJson.put(\u003cspan\u003e\u0026#34;androidPackageName\u0026#34;\u003c/span\u003e, clientDataJson.getString(\u003cspan\u003e\u0026#34;androidPackageName\u0026#34;\u003c/span\u003e))\n    \u003cspan\u003ereturn\u003c/span\u003e BaseEncoding.base64().encode(clientJson.toString().toByteArray())\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3\u003e\u003cspan\u003eUser guidance and authentication preferences\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eA central part of Zoho\u0026#39;s passkey strategy involved encouraging user adoption while providing flexibility to align with different organizational requirements. This was achieved through careful UI design and policy controls.\u003c/p\u003e\n\n\u003cp\u003eZoho recognized that organizations have varying security needs. To accommodate this, Zoho implemented:\u003c/p\u003e\n\n\u003cul\u003e\u003cul\u003e\n  \n\u003cli\u003e\u003cb\u003eAdmin enforcement:\u003c/b\u003e Through the \u003ca href=\"https://www.zoho.com/directory/\" target=\"_blank\"\u003eZoho Directory\u003c/a\u003e admin panel, administrators can designate passkeys as the mandatory, default authentication method for their entire organization. When this policy is enabled, employees are required to set up a passkey upon their next login and use it going forward.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\n\u003cli\u003e\u003cb\u003eUser choice:\u003c/b\u003e If an organization does not enforce a specific policy, individual users maintain control. They can choose their preferred authentication method during login, selecting from passkeys or other configured options via their authentication settings.\u003c/li\u003e\n\n\u003c/ul\u003e\u003c/ul\u003e\n  \n\u003cp\u003eTo make adopting passkeys appealing and straightforward for end-users, Zoho implemented:\u003c/p\u003e\n\n\u003cul\u003e\u003cul\u003e\n\n\u003cli\u003e\u003cb\u003eEasy setup:\u003c/b\u003e Zoho integrated passkey setup directly into the Zoho OneAuth mobile app (available for both \u003ca href=\"https://play.google.com/store/apps/details?id=com.zoho.accounts.oneauth\u0026amp;hl=en_IN\" target=\"_blank\"\u003eAndroid\u003c/a\u003e and \u003ca href=\"https://apps.apple.com/in/app/authenticator-app-oneauth/id1142928979\" target=\"_blank\"\u003eiOS\u003c/a\u003e). Users can conveniently configure their passkeys within the app at any time, smoothing the transition.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n  \n\u003cli\u003e\u003cb\u003eConsistent access:\u003c/b\u003e Passkey support was implemented across key user touchpoints, ensuring users can register and authenticate using passkeys via:\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003eThe Zoho OneAuth mobile app (Android \u0026amp; iOS);\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eTheir Zoho web \u003ca href=\"https://accounts.zoho.com/home#multiTFA/pfamodes\" target=\"_blank\"\u003eaccounts\u003c/a\u003e page.\u003c/li\u003e\n  \n\u003c/ul\u003e\u003c/ul\u003e\u003c/ul\u003e\u003c/ul\u003e\n  \n  \n\u003cp\u003eThis method ensured that the process of setting up and using passkeys was accessible and integrated into the platforms they already use, regardless of whether it was mandated by an admin or chosen by the user. You can learn more about how to create smooth user flows for passkey authentication by exploring our comprehensive \u003ca href=\"https://developer.android.com/design/ui/mobile/guides/patterns/passkeys\" target=\"_blank\"\u003epasskeys user experience guide\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2\u003e\u003cspan\u003eImpact on developer velocity and integration efficiency\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eCredential Manager, as a unified API, also helped improve developer productivity compared to older sign-in flows. It reduced the complexity of handling multiple authentication methods and APIs separately, leading to faster integration, from months to weeks, and fewer implementation errors. This collectively streamlined the sign-in process and improved overall reliability.\u003c/p\u003e\n\n\u003cp\u003eBy implementing passkeys with Credential Manager, Zoho achieved significant, measurable improvements across the board:\u003c/p\u003e\n\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003e\u003cb\u003eDramatic speed improvements\u003c/b\u003e\u003c/li\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003e\u003cb\u003e2x faster\u003c/b\u003e login compared to traditional password authentication.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003e\u003cb\u003e4x faster\u003c/b\u003e login compared to username or mobile number with email or SMS OTP authentication.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003e\u003cb\u003e6x faster\u003c/b\u003e login compared to username, password, and SMS or authenticator OTP authentication.\u003c/li\u003e\n  \u003c/ul\u003e\u003c/ul\u003e\n\u003cli\u003e\u003cb\u003eReduced support costs\u003c/b\u003e\u003c/li\u003e\n\u003cul\u003e\u003cul\u003e  \n  \u003cli\u003e\u003cb\u003eReduced password-related support requests\u003c/b\u003e, especially for forgotten passwords.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n  \u003cli\u003e\u003cb\u003eLower costs\u003c/b\u003e associated with SMS-based 2FA, as existing users can onboard directly with passkeys.\u003c/li\u003e\n  \u003c/ul\u003e\u003c/ul\u003e\n\u003cli\u003e\u003cb\u003eStrong user adoption \u0026amp; enhanced security:\u003c/b\u003e\u003c/li\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003e\u003cb\u003ePasskey sign-ins doubled\u003c/b\u003e in just 4 months, showing high user acceptance.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eUsers migrating to passkeys are \u003cb\u003efully protected\u003c/b\u003e from common phishing and password breach threats.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eWith \u003cb\u003e31% MoM adoption growth\u003c/b\u003e, more users are benefiting daily from enhanced security against vulnerabilities like phishing and SIM swaps.\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\u003c/ul\u003e\u003c/ul\u003e\n\n\n\n\n\u003ch2\u003e\u003cspan\u003eRecommendations and best practices\u003c/span\u003e\u003c/h2\u003e\n  \n\u003cp\u003eTo successfully implement passkeys on Android, developers should consider the following best practices:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003e\u003cb\u003eLeverage Android\u0026#39;s Credential Manager API:\u003c/b\u003e\u003c/li\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003eCredential Manager simplifies credential retrieval, reducing developer effort and ensuring a unified authentication experience.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eHandles passwords, passkeys, and federated login flows in a single interface.\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\u003cli\u003e\u003cb\u003eEnsure data encoding consistency while migrating from other FIDO authentication solutions:\u003c/b\u003e\u003c/li\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003eMake sure you handle consistent formatting for all inputs/outputs while migrating from other FIDO authentication solutions such as FIDO security keys.\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e \n\u003cli\u003e\u003cb\u003eOptimize error handling and logging:\u003c/b\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003eImplement robust error handling for a seamless user experience.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eProvide localized error messages and use detailed logs to debug and resolve unexpected failures.\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\u003c/li\u003e\u003cli\u003e\u003cb\u003eEducate users on passkey recovery options:\u003c/b\u003e\u003c/li\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003ePrevent lockout scenarios by proactively guiding users on recovery options.\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\u003cli\u003e\u003cb\u003eMonitor adoption metrics and user feedback:\u003c/b\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003eTrack user engagement, passkey adoption rates, and login success rates to keep optimizing user experience.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eConduct A/B testing on different authentication flows to improve conversion and retention.\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cp\u003ePasskeys, combined with the \u003ca href=\"https://developer.android.com/training/sign-in/passkeys\" target=\"_blank\"\u003eAndroid Credential Manager API\u003c/a\u003e, offer a powerful, unified authentication solution that enhances security while simplifying user experience. Passkeys significantly reduce phishing risks, credential theft, and unauthorized access. We encourage developers to try out the experience in their app and bring the most secure authentication to their users.\u003c/p\u003e\n  \n\u003ch2\u003e\u003cspan\u003eGet started with passkeys and Credential Manager\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eGet hands on with passkeys and Credential Manager on Android using our \u003ca href=\"https://github.com/android/identity-samples/tree/credman-compose\" target=\"_blank\"\u003epublic sample code\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf you have any questions or issues, you can share with us through the \u003ca href=\"https://issuetracker.google.com/issues?q=1301097\" target=\"_blank\"\u003eAndroid Credentials issues tracker\u003c/a\u003e.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": null,
  "modifiedTime": null
}
