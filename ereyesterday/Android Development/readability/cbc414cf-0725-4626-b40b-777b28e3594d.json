{
  "id": "cbc414cf-0725-4626-b40b-777b28e3594d",
  "title": "Generics in Kotlin",
  "link": "https://proandroiddev.com/generics-in-kotlin-9880e062c5c0?source=rss----c72404660798---4",
  "description": "",
  "author": "Anthony",
  "published": "Mon, 31 Mar 2025 00:27:02 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "variance",
    "generics",
    "kotlin",
    "android",
    "kotlin-generics"
  ],
  "byline": "Anthony",
  "length": 6206,
  "excerpt": "In the world of programming, generics provide a powerful way to write code that is not only flexible but also type-safe. We will explore the concept of generics in Kotlin, cover the basics, dive into…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "HiIn the world of programming, generics provide a powerful way to write code that is not only flexible but also type-safe. We will explore the concept of generics in Kotlin, cover the basics, dive into practical use cases, and discuss best practices. As we delve into this topic, you’ll discover how generics in Kotlin can be used to craft elegant solutions that adapt to a wide array of data types. From the fundamental principles of declaring and using generics to advanced topics like generic variance, this blog post will serve as your guide to mastering this pivotal aspect of Kotlin generics.Kotlin Type SystemBefore going in-depth in generic it is important to have an overview of kotlin type systems since kotlin generic deals with type parameters.Kotlin Types by zsmb.coAs you can see in the above diagram the Any? type is a superclass for all types and it is nullable meaning that you can pass in null values to it. The Any is a subtype of Any? and it is not nullable. Nothing and Nothing? are both subtypes of all types.What is Generics?Generics are a way to create classes, interfaces, and functions that can work with different data types while maintaining type safety. In Kotlin, generics are implemented through type parameters. This allows you to write code that can operate on a variety of data types without sacrificing compile-time type checking.Basics of GenericsDeclaring GenericsIn Kotlin, you declare generics by using angle brackets \u003c\u003e after the class or function name, followed by the type parameter. For example:class MyClass\u003cT\u003e(value: T)Where T is a type parameter that can represent any data type because it is of type Any? .we can also have a generic function:fun \u003cT\u003e sum(Item:T): List\u003cT\u003e{TODO()}Using GenericsSample Generic typeCode SummaryThe myType_0 will output an Integer, while the myType_1 will output a String. Since “T” in “myClass” is generic and of type Any? the “value” member variable can be any type parameter.Variance in kotlinTo fully understand how generic types work you have to understand what variances mean.What is Variance:Variance tells you the relationship between two objects with the same base class but different type parameters. it refers to how subtyping relationships between generic types are maintained. Variance is important when working with generic classes or interfaces, as it defines whether subtypes of a generic type are considered subtypes of the parameterized type.Example:Variance SampleCode SummaryIn the above code, both list1 and list2 are of the List class, but they are of different types. list1 is of type String? (This String can accept null values and is a superclass for String), while list2 is of type String(it only accepts non-nullable and is a subtype of String?)Variance refers to how a generic class relate to other forms of generic class, it focuses on the relationship of List\u003cString?\u003e and List\u003cString\u003e, and not on the relationship of String? and String.Type of VarianceKotlin has three types of variance: Invariant, Covariant, and ContravariantInvariant:For invariant relationships, when carrying out an operation between two or more types all types must be of exactly the same types. This means that Subtyping preservation or Supertyping (Inverts of Subtyping) preservation is not allowed. Therefore if “Bird” is a subtype of “Animal”, we can’t handle List\u003cBird\u003e as a subtype of List\u003cAnimal\u003e or vice-versa, only List\u003cAnimal\u003e and List\u003cAnimal\u003e or List\u003cBird\u003e and List\u003cBird\u003e can be handled as same types in an Invariant relation.Covariant:For covariant relationships subtyping is preserved(it ensures that the behaviour of a program remains consistent when you replace an instance of a supertype with an instance of a subtype.). The Liskov substitution principle (“L” in SOLID principle ) states that objects of a superclass shall be replaceable with objects of its subclasses without breaking the application, simply meaning that the Variance between a Superclass and a Subclass should be covariant in their behaviour. Therefore if “Bird” is a subtype of “Animal”, than List\u003cBird\u003e will be seen as a subtype of List\u003cAnimal\u003e.A good example of this can be given for:Example:Covariant SampleContravariant:Contravariant relationships between two types is the invert of Covariant what I may refer to as SuperTyping(Subtyping is not preserved). Therefore if “Bird” is a subtype of “Animal”, then List\u003cAnimal\u003e will be seen as a subtype of List\u003cBird\u003e.Creating your Generic Classes with given Variance behaviourTo declare your generic classes with a given set of variance there are two main Kotlin keywords needed, “out” Covariant for and “in” for Contravariant, for Invariant declaration, there are no keywords needed because generic classes defined in Kotlin are invariant by default.outout-types are type parameters that only occur in returning values of a function(Producer types) or on val properties. out-types can not be passed as function parameters, the out-type in Kotlin helps the compiler understand the variance of the generic class is Covariant and with that, the compiler can ensure the type safety of your code by making sure that the out-type is only used as a returning type.inin types are type parameters that only occur as function arguments(Consumer types), they can not occur as returning types of a function. The in-type declaration makes a generic type Contravariant.Full code Example Explaining all the variance:Code example for all the varianceAdvantages of GenericsType Safety: Compile-time type checking ensures that you don’t mix incompatible types.Code Reusability: You can write generic classes and functions that work with various data types.Cleaner Code: Generics can help reduce code duplication.ConclusionIn this blog post, we’ve covered the basics of generics, Kotlin type System, Variance and coding samples to help you get started with this essential Kotlin feature.Finally, Generics in Kotlin are a powerful feature that enhances code reusability, type safety, and overall maintainability. With this knowledge, you’re now prepared to harness the full potential of generics in Kotlin, enhancing your ability to craft resilient, adaptable, and type-safe software. Stay happy coding.References",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*l8wwCKPvAOfcv5w4",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"858e\"\u003e\u003cstrong\u003eHi\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"eac2\"\u003eIn the world of programming, generics provide a powerful way to write code that is not only flexible but also type-safe. We will explore the concept of generics in Kotlin, cover the basics, dive into practical use cases, and discuss best practices. As we delve into this topic, you’ll discover how generics in Kotlin can be used to craft elegant solutions that adapt to a wide array of data types. From the fundamental principles of declaring and using generics to advanced topics like generic variance, this blog post will serve as your guide to mastering this pivotal aspect of Kotlin generics.\u003c/p\u003e\u003ch2 id=\"5cca\"\u003eKotlin Type System\u003c/h2\u003e\u003cp id=\"f4fa\"\u003eBefore going in-depth in generic it is important to have an overview of kotlin type systems since kotlin generic deals with type parameters.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eKotlin Types by zsmb.co\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"93e0\"\u003eAs you can see in the above diagram the \u003cem\u003eAny?\u003c/em\u003e type is a superclass for all types and it is nullable meaning that you can pass in null values to it. The \u003cem\u003eAny\u003c/em\u003e is a subtype of Any? and it is not nullable. \u003cem\u003eNothing\u003c/em\u003e and \u003cem\u003eNothing?\u003c/em\u003e are both subtypes of all types.\u003c/p\u003e\u003ch2 id=\"3de1\"\u003eWhat is Generics?\u003c/h2\u003e\u003cp id=\"a569\"\u003eGenerics are a way to create classes, interfaces, and functions that can work with different data types while maintaining type safety. In Kotlin, generics are implemented through type parameters. This allows you to write code that can operate on a variety of data types without sacrificing compile-time type checking.\u003c/p\u003e\u003ch2 id=\"36ad\"\u003eBasics of Generics\u003c/h2\u003e\u003ch2 id=\"926f\"\u003eDeclaring Generics\u003c/h2\u003e\u003cp id=\"7406\"\u003eIn Kotlin, you declare generics by using angle brackets \u003ccode\u003e\u0026lt;\u0026gt;\u003c/code\u003e after the class or function name, followed by the type parameter. For example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b386\"\u003eclass MyClass\u0026lt;T\u0026gt;(value: T)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a87c\"\u003eWhere \u003cem\u003eT\u003c/em\u003e is a type parameter that can represent any data type because it is of type \u003cem\u003eAny?\u003c/em\u003e .\u003c/p\u003e\u003cp id=\"1438\"\u003ewe can also have a generic function:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dfcc\"\u003efun \u0026lt;T\u0026gt; sum(Item:T): List\u0026lt;T\u0026gt;{TODO()}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3b0a\"\u003eUsing Generics\u003c/h2\u003e\u003cfigure\u003e\u003cfigcaption\u003eSample Generic type\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"c9d6\"\u003e\u003cstrong\u003eCode Summary\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"94e5\"\u003eThe \u003cstrong\u003emyType_0\u003c/strong\u003e will output an Integer, while the \u003cstrong\u003emyType_1\u003c/strong\u003e will output a String. Since “T” in “myClass” is generic and of type Any? the “value” member variable can be any type parameter.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"91fd\"\u003e\u003cstrong\u003eVariance in kotlin\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"fa08\"\u003eTo fully understand how generic types work you have to understand what variances mean.\u003c/p\u003e\u003cp id=\"7351\"\u003e\u003cstrong\u003eWhat is Variance:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"9c6b\"\u003eVariance tells you the relationship between two objects with the same base class but different type parameters. it refers to how subtyping relationships between generic types are maintained. Variance is important when working with generic classes or interfaces, as it defines whether subtypes of a generic type are considered subtypes of the parameterized type.\u003c/p\u003e\u003cp id=\"2e90\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eVariance Sample\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"7170\"\u003e\u003cstrong\u003eCode Summary\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"752f\"\u003eIn the above code, both\u003cem\u003e \u003c/em\u003e\u003cstrong\u003e\u003cem\u003elist1\u003c/em\u003e\u003c/strong\u003e and\u003cstrong\u003e\u003cem\u003e list2\u003c/em\u003e\u003c/strong\u003e are of the \u003cem\u003eList\u003c/em\u003e class, but they are of different types. \u003cstrong\u003e\u003cem\u003elist1\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e \u003c/em\u003eis of type String? (This String can accept null values and is a superclass for String)\u003cem\u003e, \u003c/em\u003ewhile\u003cem\u003e \u003c/em\u003e\u003cstrong\u003e\u003cem\u003elist2\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e \u003c/em\u003eis of type String(it only accepts non-nullable and is a subtype of String?)\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"5b0a\"\u003eVariance refers to how a generic class relate to other forms of generic class, it focuses on the relationship of \u003cstrong\u003e\u003cem\u003eList\u0026lt;String?\u0026gt;\u003c/em\u003e\u003c/strong\u003e and \u003cstrong\u003e\u003cem\u003eList\u0026lt;String\u0026gt;\u003c/em\u003e\u003c/strong\u003e, and not on the relationship of \u003cem\u003eString?\u003c/em\u003e and \u003cem\u003eString\u003c/em\u003e.\u003c/p\u003e\u003ch2 id=\"9020\"\u003e\u003cstrong\u003eType of Variance\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"0936\"\u003eKotlin has three types of variance: Invariant, Covariant, and Contravariant\u003c/p\u003e\u003cp id=\"6655\"\u003e\u003cstrong\u003eInvariant:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"3a0c\"\u003eFor invariant relationships, when carrying out an operation between two or more types all types must be of exactly the same types. This means that Subtyping preservation or Supertyping (Inverts of Subtyping) preservation is not allowed. Therefore if “Bird” is a subtype of “Animal”, we can’t handle \u003cstrong\u003eList\u0026lt;Bird\u0026gt;\u003c/strong\u003e as a subtype of \u003cstrong\u003eList\u0026lt;Animal\u0026gt;\u003c/strong\u003e or vice-versa, only\u003cstrong\u003e List\u0026lt;Animal\u0026gt;\u003c/strong\u003e and \u003cstrong\u003eList\u0026lt;Animal\u0026gt;\u003c/strong\u003e or \u003cstrong\u003eList\u0026lt;Bird\u0026gt;\u003c/strong\u003e and \u003cstrong\u003eList\u0026lt;Bird\u0026gt;\u003c/strong\u003e can be handled as same types in an Invariant relation.\u003c/p\u003e\u003cp id=\"eb64\"\u003e\u003cstrong\u003eCovariant:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"9041\"\u003eFor covariant relationships subtyping is preserved(it ensures that the behaviour of a program remains consistent when you replace an instance of a supertype with an instance of a subtype.). The \u003cstrong\u003e\u003cem\u003eLiskov substitution\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e principle (“L” in SOLID principle ) states that\u003c/em\u003e objects of a superclass shall be replaceable with objects of its subclasses without breaking the application, simply meaning that the Variance between a Superclass and a Subclass should be covariant in their behaviour. Therefore if “Bird” is a subtype of “Animal”, than \u003cstrong\u003eList\u0026lt;Bird\u0026gt;\u003c/strong\u003e will be seen as a subtype of \u003cstrong\u003eList\u0026lt;Animal\u0026gt;\u003c/strong\u003e.A good example of this can be given for:\u003c/p\u003e\u003cp id=\"e7c1\"\u003eExample:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eCovariant Sample\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"90d4\"\u003e\u003cstrong\u003eContravariant:\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"1ae5\"\u003eContravariant relationships between two types is the invert of Covariant what I may refer to as SuperTyping(Subtyping is not preserved). Therefore if “Bird” is a subtype of “Animal”, then List\u0026lt;Animal\u0026gt; will be seen as a subtype of List\u0026lt;Bird\u0026gt;.\u003c/p\u003e\u003cp id=\"fd33\"\u003eCreating your Generic Classes with given Variance behaviour\u003c/p\u003e\u003cp id=\"04d2\"\u003eTo declare your generic classes with a given set of variance there are two main Kotlin keywords needed, “out” \u003cem\u003eCovariant\u003c/em\u003e for and “in” for \u003cem\u003eContravariant\u003c/em\u003e, for Invariant declaration, there are no keywords needed because generic classes defined in Kotlin are invariant by default.\u003c/p\u003e\u003cp id=\"7626\"\u003e\u003cstrong\u003eout\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"519e\"\u003eout-types are type parameters that only occur in returning values of a function(Producer types) or on val properties. out-types can not be passed as function parameters, the out-type in Kotlin helps the compiler understand the variance of the generic class is Covariant and with that, the compiler can ensure the type safety of your code by making sure that the out-type is only used as a returning type.\u003c/p\u003e\u003cp id=\"c5b5\"\u003e\u003cstrong\u003ein\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"bd22\"\u003ein types are type parameters that only occur as function arguments(Consumer types), they can not occur as returning types of a function. The in-type declaration makes a generic type Contravariant.\u003c/p\u003e\u003cp id=\"e5bc\"\u003eFull code Example Explaining all the variance:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eCode example for all the variance\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"f778\"\u003e\u003cstrong\u003eAdvantages of Generics\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"d879\"\u003eType Safety: Compile-time type checking ensures that you don’t mix incompatible types.\u003c/li\u003e\u003cli id=\"3df6\"\u003eCode Reusability: You can write generic classes and functions that work with various data types.\u003c/li\u003e\u003cli id=\"4573\"\u003eCleaner Code: Generics can help reduce code duplication.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"b1c1\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"2275\"\u003eIn this blog post, we’ve covered the basics of generics, Kotlin type System, Variance and coding samples to help you get started with this essential Kotlin feature.\u003c/p\u003e\u003cp id=\"721c\"\u003eFinally, Generics in Kotlin are a powerful feature that enhances code reusability, type safety, and overall maintainability. With this knowledge, you’re now prepared to harness the full potential of generics in Kotlin, enhancing your ability to craft resilient, adaptable, and type-safe software. \u003cstrong\u003eStay happy coding.\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"cf34\"\u003e\u003cstrong\u003eReferences\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-01-11T02:20:06.36Z",
  "modifiedTime": null
}
