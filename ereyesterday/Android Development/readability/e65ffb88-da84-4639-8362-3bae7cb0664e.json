{
  "id": "e65ffb88-da84-4639-8362-3bae7cb0664e",
  "title": "Most Android Apps Break This One Clean Code Rule!",
  "link": "https://proandroiddev.com/most-android-apps-break-this-one-clean-code-rule-f2fb44f98e90?source=rss----c72404660798---4",
  "description": "",
  "author": "Reza",
  "published": "Tue, 20 May 2025 20:14:06 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "push-notification",
    "android",
    "testing",
    "dependency-injection",
    "clean-architecture"
  ],
  "byline": "Reza",
  "length": 2467,
  "excerpt": "Learn how to write clean, testable Android code by keeping FirebaseMessagingService, BroadcastReceiver, and other components dumb and logic-free.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "📦 FCM Push Notifications: A Case Study:Setting up Firebase Cloud Messaging (FCM) on Android is straightforward. You set up the AndroidManifest.xml, request permissions, and override two key methods:onNewToken(String token) — called when a new FCM token is generatedonMessageReceived(RemoteMessage message) — triggered when a push message arrivesThen you’d have something like:⚠️ It works… until it doesn’t. Why?❌ You can’t unit test it❌ You can’t reuse the logic❌ You need real pushes to test itLet’s clean it up.✅ The Better Way: Delegate Everything🧩 1. Keep FirebaseMessagingService ThinYour service shouldn’t contain logic. It should forward work to injected, testable components.This gives you the power of dependency injection (e.g., Hilt or Koin), and isolates the logic for reuse and testing.🧱 2. Map to a Clean Domain ModelDon’t pass around Firebase’s RemoteMessage. Instead, extract a platform-agnostic model that reflects your app’s needs.Map FCM data into this class:By abstracting RemoteMessage, you decouple your core logic from Firebase.🛠️ 3. Inject and Test Business LogicNow create a PushHandler that takes your domain model and decides what to do.Now your logic is testable, extendable, and easy to maintain.🔁 Same Pattern for BroadcastReceiversThis mistake isn’t limited to push notifications. BroadcastReceiver is another classic offender.Bad pattern — logic inside the receiver:Better pattern — delegate logic:This allows you to test rescheduling logic with unit tests — no need to simulate broadcasts.🧪 Unit Testing with Robolectric and FakesThis is where it gets fun. Because your core logic is no longer tied to Android components, testing is simple:You don’t need a device or emulator — just plain Kotlin and Robolectric.📲 End-to-End Verification with UIAutomatorYou can also test real system-level behavior with UIAutomator:Perfect for verifying real device behavior on CI or pre-release tests.💡 Final AdviceKeep your Android components dumb, and your logic clean.🤖 FirebaseMessagingService should not contain notification code📡 BroadcastReceiver should not enqueue jobs🎬 Activity should not contain business logicUse @Inject, @Binds, and interfaces to make every part of your system testable and modular.✅ TL;DRAndroid components should delegate, not doMove logic into injectable classesCreate domain models to decouple from SDKsUnit test with fakes, verify UI with UIAutomator🧼 Clean architecture starts with one rule: Keep Components Dumb.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*BsHHctxJ_B2DZQxs",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"000b\"\u003e📦 FCM Push Notifications: A Case Study:\u003c/h2\u003e\u003cp id=\"45e5\"\u003eSetting up Firebase Cloud Messaging (FCM) on Android is straightforward. You set up the AndroidManifest.xml, request permissions, and override two key methods:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"6dbf\"\u003eonNewToken(String token) — called when a new FCM token is generated\u003c/li\u003e\u003cli id=\"3685\"\u003eonMessageReceived(RemoteMessage message) — triggered when a push message arrives\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3fe2\"\u003eThen you’d have something like:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"10aa\"\u003e⚠️ It works… until it doesn’t. Why?\u003c/p\u003e\u003cul\u003e\u003cli id=\"533c\"\u003e❌ You can’t unit test it\u003c/li\u003e\u003cli id=\"fe44\"\u003e❌ You can’t reuse the logic\u003c/li\u003e\u003cli id=\"53d4\"\u003e❌ You need real pushes to test it\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8912\"\u003eLet’s clean it up.\u003c/p\u003e\u003ch2 id=\"9cb9\"\u003e✅ The Better Way: Delegate Everything\u003c/h2\u003e\u003ch2 id=\"5c6f\"\u003e🧩 1. Keep FirebaseMessagingService Thin\u003c/h2\u003e\u003cp id=\"d6b5\"\u003eYour service shouldn’t contain logic. It should forward work to injected, testable components.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"27b8\"\u003eThis gives you the power of dependency injection (e.g., Hilt or Koin), and isolates the logic for reuse and testing.\u003c/p\u003e\u003ch2 id=\"754c\"\u003e🧱 2. Map to a Clean Domain Model\u003c/h2\u003e\u003cp id=\"91e8\"\u003eDon’t pass around Firebase’s RemoteMessage. Instead, extract a platform-agnostic model that reflects your app’s needs.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"56d6\"\u003eMap FCM data into this class:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f763\"\u003eBy abstracting RemoteMessage, you decouple your core logic from Firebase.\u003c/p\u003e\u003ch2 id=\"edaa\"\u003e🛠️ 3. Inject and Test Business Logic\u003c/h2\u003e\u003cp id=\"92e2\"\u003eNow create a PushHandler that takes your domain model and decides what to do.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"099e\"\u003eNow your logic is testable, extendable, and easy to maintain.\u003c/p\u003e\u003ch2 id=\"77e7\"\u003e🔁 Same Pattern for BroadcastReceivers\u003c/h2\u003e\u003cp id=\"224c\"\u003eThis mistake isn’t limited to push notifications. BroadcastReceiver is another classic offender.\u003c/p\u003e\u003cp id=\"834a\"\u003e\u003cstrong\u003eBad pattern\u003c/strong\u003e — logic inside the receiver:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5540\"\u003e\u003cstrong\u003eBetter pattern\u003c/strong\u003e — delegate logic:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3b11\"\u003eThis allows you to test rescheduling logic with unit tests — no need to simulate broadcasts.\u003c/p\u003e\u003ch2 id=\"b4bf\"\u003e🧪 Unit Testing with Robolectric and Fakes\u003c/h2\u003e\u003cp id=\"8162\"\u003eThis is where it gets fun. Because your core logic is no longer tied to Android components, testing is simple:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"db95\"\u003eYou don’t need a device or emulator — just plain Kotlin and Robolectric.\u003c/p\u003e\u003ch2 id=\"b473\"\u003e📲 End-to-End Verification with UIAutomator\u003c/h2\u003e\u003cp id=\"4a28\"\u003eYou can also test real system-level behavior with UIAutomator:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5735\"\u003ePerfect for verifying real device behavior on CI or pre-release tests.\u003c/p\u003e\u003ch2 id=\"a79d\"\u003e💡 Final Advice\u003c/h2\u003e\u003cp id=\"8fcd\"\u003eKeep your Android components \u003cstrong\u003edumb\u003c/strong\u003e, and your logic \u003cstrong\u003eclean\u003c/strong\u003e.\u003c/p\u003e\u003cul\u003e\u003cli id=\"7573\"\u003e🤖 FirebaseMessagingService should not contain notification code\u003c/li\u003e\u003cli id=\"90ee\"\u003e📡 BroadcastReceiver should not enqueue jobs\u003c/li\u003e\u003cli id=\"b985\"\u003e🎬 Activity should not contain business logic\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f8da\"\u003eUse \u003ccode\u003e@Inject\u003c/code\u003e, \u003ccode\u003e@Binds\u003c/code\u003e, and \u003ccode\u003einterfaces\u003c/code\u003e to make every part of your system testable and modular.\u003c/p\u003e\u003ch2 id=\"4758\"\u003e✅ TL;DR\u003c/h2\u003e\u003cul\u003e\u003cli id=\"d475\"\u003eAndroid components should \u003cstrong\u003edelegate\u003c/strong\u003e, not \u003cstrong\u003edo\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"80f6\"\u003eMove logic into injectable classes\u003c/li\u003e\u003cli id=\"ea9f\"\u003eCreate domain models to decouple from SDKs\u003c/li\u003e\u003cli id=\"57c2\"\u003eUnit test with fakes, verify UI with UIAutomator\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"f9fe\"\u003e\u003cem\u003e🧼 Clean architecture starts with one rule: \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eKeep Components Dumb.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2025-05-20T20:14:06.846Z",
  "modifiedTime": null
}
