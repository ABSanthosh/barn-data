{
  "id": "198f4c41-db24-4405-ad27-3124c7f579be",
  "title": "Kotlin 2.2 — guards when with subject, more than a technical question.",
  "link": "https://proandroiddev.com/kotlin-2-2-guards-when-with-subject-more-than-a-technical-question-cdecec87348f?source=rss----c72404660798---4",
  "description": "",
  "author": "First I have fika, then I write apps.",
  "published": "Thu, 29 May 2025 19:29:00 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "software-development",
    "android-development",
    "swift",
    "computer-science"
  ],
  "byline": "First I have fika, then I write apps.",
  "length": 12214,
  "excerpt": "Kotlin 2.2 is in RC2 stage, and soon we’ll get it. I saw many (not all of them I read) articles about the introduction of “when guards”. Most shows the syntax, which is pretty technical. However…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Kotlin 2.2 is in RC2 stage, and soon we’ll get it. I saw many (not all of them I read) articles about the introduction of “when guards”. Most shows the syntax, which is pretty technical. However, with the introduction of this enhancement, it is more interesting to look at the philosophy behind language design.The first time I heard about guards in Kotlin, I thought — Yes! It should be the same way as in Swift. Right? Well… I was a bit disappointed (because well.. KMP, you know… attracting iOS devs to Kotlin… ) when I read how it was actually implemented. I was questioning, what is the point? We can do the same already, and there is no point in naming it “feature”… or not?In mobile, two languages are primary today — Swift and Kotlin.Swift introduced its own guard feature quite early, aiming to handle errors and edge cases in a better way. Here is simple example of narrowing a nullable type and checking if it matches a more specific condition:func handle(anythingYouCanThinkAbout: BasicTypeOfAnything?) { guard let safeData = anythingYouCanThinkAbout, anythingYouCanThinkAbout is SomethingNarrow else { // This does not work, run away from here, we have no choice // in Swift return } // We can do something good with the data}Kotlin guards conditions in when with subject (yeah kind of official naming):fun handle(data: BasicTypeOfAnything?) { when (data) { is SomethingNarrow if data is SomethingEvenMoreSpecific -\u003e { // We can do something good with the data } else -\u003e { // This does not work, run away from here? // ah no! We are allowed not to do this in Kotlin. } }}Kotlin does not introduce a separate keyword for early returns like Swift’s guard. Instead, it builds on top of existing when expressions by allowing additional conditions with if. This supposed to keep Kotlin’s design compact.How does the new design compare to old options, and does it truly offer something better?The same logic could be implemented using a when expression without a subject:when { value is SomethingNarrow \u0026\u0026 value is SomethingEvenMoreSpecific -\u003e { // We can do something good with the data } else -\u003e { // Something else }}orvalue?.let { when { it is SomethingNarrow \u0026\u0026 it is SomethingEvenMoreSpecific -\u003e { // We can do something good with the data } else -\u003e { // Something else } }}These forms are already readable and flexible. They support complete expression logic, work well with smart casts, and are part of the existing language rules. So what is the gain with when guards?This is where the philosophical aspect of language comes in. Kotlin facilitates readability and compact syntax. A when(value) block clearly communicates that we are branching based on value. By embedding the conditions inside when we make this dependency explicit.The syntax rules around guards introduce restrictions that are not intuitive.(I need this class for demonstration)sealed class Shape { data class Circle(val radius: Double) : Shape() data class Ellipse(val radius: Double) : Shape() data class Rectangle(val width: Double, val height: Double) : Shape()}1. You cannot mix multiple when conditions using commas with an if guard. The following code will not compile:when (shape) { is Shape.Circle, is Shape.Ellipse if shape.radius \u003e 10 -\u003e // Big round shape // Error: guard cannot be combined with multiple entries}2. To express the same logic, developers must duplicate branches (this comes from 1.):when (shape) { is Shape.Circle if shape.radius \u003e 10 -\u003e // Big round shape is Shape.Ellipse if shape.radius \u003e 10 -\u003e // Big not-that-round shape else -\u003e // Other shape}3. The else if construct is not equivalent to a regular else followed by if . It is a special syntax used only in when guards, and looks like this:when (shape) { is Shape.Rectangle -\u003e // Rectangle? else if shape is Shape.Circle \u0026\u0026 shape.radius \u003e 10 -\u003e // Big round shape else -\u003e // Could be a hamster}These new constructs differ from existing patterns. Although they improve the expressiveness of when, they also raise the bar for entrance.To see this complexity more clearly, look at this:With when guards:when (shape) { is Shape.Circle if shape.radius \u003e 0 -\u003e return // compiler error: ‘when’ expression must be exhaustive}Compare this to the old way:when { shape is Shape.Circle \u0026\u0026 shape.radius \u003e 10 -\u003e return // no compiler warning about exhaustiveness}This demonstrates an important distinction. In the new when guard form, Kotlin expects exhaustiveness to be preserved, even if you are only interested in a subset of a subtype. The compiler does not treat a guarded condition as fully covering that subtype, so it still expects an else or additional branches.when without a subject lets you write arbitrary expressions without this constraint. The control flow no longer explicitly shows that it’s based on shape, and the smart cast logic is obscure to read.And again, the question.What are we trading here — clarity for structure, or structure for clarity?It triggers a deeper question about the design philosophy of the language. Should Kotlin keep layering enhancements into existing constructs, like when, making them more powerful but more complex? Or should it leave such power to the more general-purpose if/when without subject forms, which are already expressive?Is this a new dilemma? Not really. The idea of guards in control structures is far from new. The concept of guarded conditions in control flow dates back to one of the most influential computer scientists of the 20th century: Edsger W. Dijkstra.Dijkstra introduced the concept of guarded commands as part of his proposal for a new language construct designed to simplify nondeterministic programming. That approach was designed to make it easier to express programs where the next step in execution depends on multiple possible conditions, any of which could be valid.Each guarded command takes the form:guard -\u003e commandThe meaning is simple. If the guard (a boolean expression) is true, then the corresponding command may execute. When multiple guards are true, the choice among them is nondeterministic — the language or runtime may pick any of them. This model was elegant because it allowed for writing correct and concise specifications of complex programs without hardcoding control flow too early. At the time, many programming models tightly coupled decision logic and execution order, making it hard to express alternatives without deeply nested if-chains or flag-based branching. Dijkstra’s approach broke that ‘normal’ by suggesting that you don’t always need to know the exact next step — you just need to describe the valid possibilities and let the runtime (or verification process) choose among them.Dijkstra’s guards were more than just a syntactic convenience — they were a way of expressing possibilities, and shifting the pressure of choosing between them from the programmer to the program logic itself. I’d say it was declarative before “declarative” was cool.So far, as you see, Kotlin’s when guards are deterministic and not tied to concurrent or nondeterministic execution, the philosophical influence is clear: they allow developers to attach conditions to branches in a way that makes control flow more expressive, compact, and logically scoped.But Dijkstra’s idea was not the end of the road for guards. In the following decades, the concept found new life and purpose in functional languages, which shaped it into a more practical, pattern-oriented construct. Many languages have adapted and redefined guards for everyday coding.Haskell is closest to Dijkstra’s ideas. This guard’s implementation closely mirrors Dijkstra’s idea of specifying valid branches rather than enforcing exact control flow.In Haskell, guards are used to write conditional logic in a more declarative, readable way within function definitions. Instead of using nested if expressions, Haskell allows a series of conditions to be attached directly to function clauses:handle value | isSomethingNarrow value \u0026\u0026 isSomethingEvenMoreSpecific value = “We can do something good with the data” | otherwise = “Something else”Each guard is introduced with a |, and evaluated top to bottom. This style is concise and makes the branching logic explicit. otherwise keyword is just an alias for true, and acts like Kotlin’s else.Another example is from Scala. Scala is often seen as a hybrid language that combines object-oriented and functional paradigms. It provides a practical and concise form of guards inside match expressions. In Scala, guards let developers refine pattern matches with extra conditions without leaving the context of structured branching. This makes guards in Scala highly ergonomic and expressive, especially for those coming from imperative or Java-like languages. As such, Scala plays a bridge role — showing how ideas from functional programming can live comfortably in general-purpose, pragmatic languages.data match { case d: SomethingNarrow if d.isInstanceOf[SomethingEvenMoreSpecific] =\u003e // We can do something good with the data case _ =\u003e // Something else}These examples share a common trait with Dijkstra’s idea: the branching is conditional, declarative, and refined in place. But they also deviate from the original nondeterministic model. Instead, Haskell and Scala integrate guards as ergonomic tools for deterministic pattern-based branching.Kotlin’s when guards fall somewhere in the middle: they borrow syntax and intent from these functional languages, while staying embedded in Kotlin’s imperative model. Their purpose is not to introduce a new paradigm, but to extend an existing when.Just for a moment — Swift took a different path.Swift’s guard statement was introduced not as an extension of pattern matching, but as a control-flow primitive for early exits. Unlike Dijkstra’s guarded commands or Haskell-style inline refinements, Swift’s guard is more about protecting the happy path:func handle(shape: Shape?) { guard let shape = shape else { // You shaaaaaaall not paaaaaas!11 return } // Good to go}This syntax is readable, but if you look at it through the historical and philosophical lens, you find that Swift’s guard is somewhat of an outlier. It doesn’t participate in pattern refinement like Haskell or Scala, nor does it expand the shape of existing syntax like Kotlin’s when. Instead, guard forms a new structural unit with strict semantics: the condition must fail, and scope must exit.In this sense, guard is imperative, sequential, and flow-oriented. It reflects Swift’s overall design tendency toward explicit control and readability over composability. It’s declarative in feel, but not in origin (Comments section is below. Welcome.)Swift’s design solves a very real problem: how to make early exits visible and pleasant. But it doesn’t follow the same evolution as Kotlin. Rather than a refinement of match-based logic, Swift’s guard is a rethinking of if and turned inside out.This contrast is critical for understanding why Kotlin did not adopt this guard statement. Kotlin tends to evolve by extending constructs already familiar to developers, rather than introducing entirely new paradigms. Not all the time for sure! However, there is evidence in features that have been part of Kotlin since version 1.0 like the Elvis operator (?:), safe calls (?.), and the when expression itself. None of these were invented from scratch. Instead, each distilled a widely used idiom (null-checking, defaulting, branching) into a more consistent form that integrated smoothly into the language’s expression-oriented design.In the case of when guards, Kotlin already provided multiple ways to write complex conditionals and match logic: with if, with when without subject, and with smart casting. What it didn’t offer was a concise and idiomatic way to combine type-based branching with additional conditions directly in a when subject block. I think that when guards were introduced to refine this edge case — not to replace existing patterns, but to make a common structure more readable and discoverable.Do we need them? Maybe not always.But do they fit Kotlin’s evolution? I think — absolutely.It’s quite possible that the real value of when guards will become clear only after the release of Rich Errors in Kotlin 2.4.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*tHWo3ZpsaW8rk-KmnTFVmA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@sporentusjourney?source=post_page---byline--cdecec87348f---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"First I have fika, then I write apps.\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*_F9tUfm4Cr1DcCXHyrpQAA.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"e8c1\"\u003eKotlin 2.2 is in RC2 stage, and soon we’ll get it. I saw many (not all of them I read) articles about the introduction of “when guards”. Most shows the syntax, which is pretty technical. However, with the introduction of this enhancement, it is more interesting to look at the philosophy behind language design.\u003c/p\u003e\u003cp id=\"50e4\"\u003eThe first time I heard about guards in Kotlin, I thought — Yes! It should be the same way as in Swift. Right? Well… I was a bit disappointed (because well.. KMP, you know… attracting iOS devs to Kotlin… ) when I read how it was actually implemented. I was questioning, what is the point? We can do the same already, and there is no point in naming it “feature”… or not?\u003c/p\u003e\u003cp id=\"e6bc\"\u003eIn mobile, two languages are primary today — Swift and Kotlin.\u003cbr/\u003eSwift introduced its own guard feature quite early, aiming to handle errors and edge cases in a better way. Here is simple example of narrowing a nullable type and checking if it matches a more specific condition:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4058\"\u003efunc handle(anythingYouCanThinkAbout: BasicTypeOfAnything?) {\u003cbr/\u003e guard let safeData = anythingYouCanThinkAbout, anythingYouCanThinkAbout is SomethingNarrow else {\u003cbr/\u003e // This does not work, run away from here, we have no choice\u003cbr/\u003e // in Swift\u003cbr/\u003e return\u003cbr/\u003e }\u003cbr/\u003e // We can do something good with the data\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a0a4\"\u003eKotlin guards conditions in when with subject (yeah kind of official naming):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3f30\"\u003efun handle(data: BasicTypeOfAnything?) {\u003cbr/\u003e when (data) {\u003cbr/\u003e is SomethingNarrow if data is SomethingEvenMoreSpecific -\u0026gt; {\u003cbr/\u003e // We can do something good with the data\u003cbr/\u003e }\u003cbr/\u003e else -\u0026gt; {\u003cbr/\u003e // This does not work, run away from here? \u003cbr/\u003e // ah no! We are allowed not to do this in Kotlin.\u003cbr/\u003e }\u003cbr/\u003e }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"75dd\"\u003eKotlin does not introduce a separate keyword for early returns like Swift’s \u003ccode\u003eguard\u003c/code\u003e. Instead, it builds on top of existing \u003ccode\u003ewhen\u003c/code\u003e expressions by allowing additional conditions with if. This supposed to keep Kotlin’s design compact.\u003c/p\u003e\u003ch2 id=\"ac24\"\u003eHow does the new design compare to old options, and does it truly offer something better?\u003c/h2\u003e\u003cp id=\"3d90\"\u003eThe same logic could be implemented using a when expression without a subject:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fd1d\"\u003ewhen {\u003cbr/\u003e value is SomethingNarrow \u0026amp;\u0026amp; value is SomethingEvenMoreSpecific -\u0026gt; {\u003cbr/\u003e // We can do something good with the data\u003cbr/\u003e }\u003cbr/\u003e else -\u0026gt; {\u003cbr/\u003e // Something else\u003cbr/\u003e }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"66dc\"\u003eor\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3f55\"\u003evalue?.let {\u003cbr/\u003e when {\u003cbr/\u003e it is SomethingNarrow \u0026amp;\u0026amp; it is SomethingEvenMoreSpecific -\u0026gt; {\u003cbr/\u003e // We can do something good with the data\u003cbr/\u003e }\u003cbr/\u003e else -\u0026gt; {\u003cbr/\u003e // Something else\u003cbr/\u003e }\u003cbr/\u003e }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b7f7\"\u003eThese forms are already readable and flexible. They support complete expression logic, work well with smart casts, and are part of the existing language rules. So what is the gain with when guards?\u003c/p\u003e\u003cp id=\"84aa\"\u003eThis is where the philosophical aspect of language comes in. Kotlin facilitates readability and compact syntax. A \u003ccode\u003ewhen(value)\u003c/code\u003e block clearly communicates that we are branching based on \u003ccode\u003evalue\u003c/code\u003e. By embedding the conditions inside \u003ccode\u003ewhen\u003c/code\u003e we make this dependency explicit.\u003c/p\u003e\u003cp id=\"8a69\"\u003eThe syntax rules around guards introduce restrictions that are not intuitive.\u003c/p\u003e\u003cp id=\"9117\"\u003e(I need this class for demonstration)\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cf32\"\u003esealed class Shape {\u003cbr/\u003e   data class Circle(val radius: Double) : Shape()\u003cbr/\u003e   data class Ellipse(val radius: Double) : Shape()\u003cbr/\u003e   data class Rectangle(val width: Double, val height: Double) : Shape()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d2d3\"\u003e1. You cannot mix multiple when conditions using commas with an if guard. The following code will not compile:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b252\"\u003ewhen (shape) {\u003cbr/\u003e is Shape.Circle, is Shape.Ellipse if shape.radius \u0026gt; 10 -\u0026gt; // Big round shape\u003cbr/\u003e // Error: guard cannot be combined with multiple entries\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c7a8\"\u003e2. To express the same logic, developers must duplicate branches (this comes from 1.):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f9f3\"\u003ewhen (shape) {\u003cbr/\u003e is Shape.Circle if shape.radius \u0026gt; 10 -\u0026gt; // Big round shape\u003cbr/\u003e is Shape.Ellipse if shape.radius \u0026gt; 10 -\u0026gt; // Big not-that-round shape\u003cbr/\u003e else -\u0026gt; // Other shape\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"aa48\"\u003e3. The \u003ccode\u003eelse if\u003c/code\u003e construct is not equivalent to a regular \u003ccode\u003eelse\u003c/code\u003e followed by \u003ccode\u003eif\u003c/code\u003e . It is a special syntax used only in when guards, and looks like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4f19\"\u003ewhen (shape) {\u003cbr/\u003e is Shape.Rectangle -\u0026gt; // Rectangle?\u003cbr/\u003e else if shape is Shape.Circle \u0026amp;\u0026amp; shape.radius \u0026gt; 10 -\u0026gt; // Big round shape\u003cbr/\u003e else -\u0026gt; // Could be a hamster\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6795\"\u003eThese new constructs differ from existing patterns. Although they improve the expressiveness of \u003ccode\u003ewhen\u003c/code\u003e, they also raise the bar for entrance.\u003c/p\u003e\u003cp id=\"5b9a\"\u003eTo see this complexity more clearly, look at this:\u003c/p\u003e\u003cp id=\"1e58\"\u003eWith \u003ccode\u003ewhen\u003c/code\u003e guards:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ec3c\"\u003ewhen (shape) {\u003cbr/\u003e is Shape.Circle if shape.radius \u0026gt; 0 -\u0026gt; return\u003cbr/\u003e // compiler error: ‘when’ expression must be exhaustive\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8e0f\"\u003eCompare this to the old way:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3da7\"\u003ewhen {\u003cbr/\u003e shape is Shape.Circle \u0026amp;\u0026amp; shape.radius \u0026gt; 10 -\u0026gt; return\u003cbr/\u003e // no compiler warning about exhaustiveness\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f3c3\"\u003eThis demonstrates an important distinction. In the new when guard form, Kotlin expects exhaustiveness to be preserved, even if you are only interested in a subset of a subtype. The compiler does not treat a guarded condition as fully covering that subtype, so it still expects an \u003ccode\u003eelse\u003c/code\u003e or additional branches.\u003c/p\u003e\u003cp id=\"5b20\"\u003e\u003ccode\u003ewhen\u003c/code\u003e without a subject lets you write arbitrary expressions without this constraint. The control flow no longer explicitly shows that it’s based on \u003ccode\u003eshape\u003c/code\u003e, and the smart cast logic is obscure to read.\u003c/p\u003e\u003cp id=\"2f9b\"\u003eAnd again, the question.\u003c/p\u003e\u003ch2 id=\"a9f7\"\u003eWhat are we trading here — clarity for structure, or structure for clarity?\u003c/h2\u003e\u003cp id=\"dcee\"\u003eIt triggers a deeper question about the design philosophy of the language. Should Kotlin keep layering enhancements into existing constructs, like \u003ccode\u003ewhen\u003c/code\u003e, making them more powerful but more complex? Or should it leave such power to the more general-purpose \u003ccode\u003eif/when\u003c/code\u003e without subject forms, which are already expressive?\u003c/p\u003e\u003cp id=\"c21e\"\u003eIs this a new dilemma? Not really. The idea of guards in control structures is far from new. The concept of guarded conditions in control flow dates back to one of the most influential computer scientists of the 20th century: Edsger W. Dijkstra.\u003c/p\u003e\u003cp id=\"3aa4\"\u003eDijkstra introduced the concept of guarded commands as part of his proposal for a new language construct designed to simplify nondeterministic programming. That approach was designed to make it easier to express programs where the next step in execution depends on multiple possible conditions, any of which could be valid.\u003c/p\u003e\u003cp id=\"a1ad\"\u003eEach guarded command takes the form:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"652a\"\u003eguard -\u0026gt; command\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c93a\"\u003eThe meaning is simple. If the guard (a boolean expression) is true, then the corresponding command may execute. When multiple guards are true, the choice among them is nondeterministic — the language or runtime may pick any of them. This model was elegant because it allowed for writing correct and concise specifications of complex programs without hardcoding control flow too early. At the time, many programming models tightly coupled decision logic and execution order, making it hard to express alternatives without deeply nested if-chains or flag-based branching. Dijkstra’s approach broke that ‘normal’ by suggesting that you don’t always need to know the exact next step — you just need to describe the valid possibilities and let the runtime (or verification process) choose among them.\u003c/p\u003e\u003cp id=\"3b51\"\u003eDijkstra’s guards were more than just a syntactic convenience — they were a way of expressing possibilities, and shifting the pressure of choosing between them from the programmer to the program logic itself. I’d say it was declarative before “declarative” was cool.\u003c/p\u003e\u003cp id=\"d4e5\"\u003eSo far, as you see, Kotlin’s when guards are deterministic and not tied to concurrent or nondeterministic execution, the philosophical influence is clear: they allow developers to attach conditions to branches in a way that makes control flow more expressive, compact, and logically scoped.\u003c/p\u003e\u003cp id=\"257c\"\u003eBut Dijkstra’s idea was not the end of the road for guards. In the following decades, the concept found new life and purpose in functional languages, which shaped it into a more practical, pattern-oriented construct. Many languages have adapted and redefined guards for everyday coding.\u003c/p\u003e\u003cp id=\"32ab\"\u003eHaskell is closest to Dijkstra’s ideas. This guard’s implementation closely mirrors Dijkstra’s idea of specifying valid branches rather than enforcing exact control flow.\u003c/p\u003e\u003cp id=\"7182\"\u003eIn Haskell, guards are used to write conditional logic in a more declarative, readable way within function definitions. Instead of using nested if expressions, Haskell allows a series of conditions to be attached directly to function clauses:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"28c0\"\u003ehandle value\u003cbr/\u003e | isSomethingNarrow value \u0026amp;\u0026amp; isSomethingEvenMoreSpecific value = “We can do something good with the data”\u003cbr/\u003e | otherwise = “Something else”\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"44ad\"\u003eEach guard is introduced with a \u003ccode\u003e|\u003c/code\u003e, and evaluated top to bottom. This style is concise and makes the branching logic explicit. \u003ccode\u003eotherwise\u003c/code\u003e keyword is just an alias for \u003ccode\u003etrue\u003c/code\u003e, and acts like Kotlin’s \u003ccode\u003eelse\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"584a\"\u003eAnother example is from Scala. Scala is often seen as a hybrid language that combines object-oriented and functional paradigms. It provides a practical and concise form of guards inside match expressions. In Scala, guards let developers refine pattern matches with extra conditions without leaving the context of structured branching. This makes guards in Scala highly ergonomic and expressive, especially for those coming from imperative or Java-like languages. As such, Scala plays a bridge role — showing how ideas from functional programming can live comfortably in general-purpose, pragmatic languages.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"42c6\"\u003edata match {\u003cbr/\u003e case d: SomethingNarrow if d.isInstanceOf[SomethingEvenMoreSpecific] =\u0026gt;\u003cbr/\u003e // We can do something good with the data\u003cbr/\u003e case _ =\u0026gt;\u003cbr/\u003e // Something else\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"09d7\"\u003eThese examples share a common trait with Dijkstra’s idea: the branching is conditional, declarative, and refined in place. But they also deviate from the original nondeterministic model. Instead, Haskell and Scala integrate guards as ergonomic tools for deterministic pattern-based branching.\u003c/p\u003e\u003cp id=\"2e49\"\u003eKotlin’s when guards fall somewhere in the middle: they borrow syntax and intent from these functional languages, while staying embedded in Kotlin’s imperative model. Their purpose is not to introduce a new paradigm, but to extend an existing \u003ccode\u003ewhen\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"4eb5\"\u003eJust for a moment — Swift took a different path.\u003c/p\u003e\u003cp id=\"1ab7\"\u003eSwift’s guard statement was introduced not as an extension of pattern matching, but as a control-flow primitive for early exits. Unlike Dijkstra’s guarded commands or Haskell-style inline refinements, Swift’s guard is more about protecting the happy path:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7661\"\u003efunc handle(shape: Shape?) {\u003cbr/\u003e guard let shape = shape else {\u003cbr/\u003e // You shaaaaaaall not paaaaaas!11\u003cbr/\u003e return\u003cbr/\u003e }\u003cbr/\u003e // Good to go\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2629\"\u003eThis syntax is readable, but if you look at it through the historical and philosophical lens, you find that Swift’s \u003ccode\u003eguard\u003c/code\u003e is somewhat of an outlier. It doesn’t participate in pattern refinement like Haskell or Scala, nor does it expand the shape of existing syntax like Kotlin’s \u003ccode\u003ewhen\u003c/code\u003e. Instead, guard forms a new structural unit with strict semantics: the condition must fail, and scope must exit.\u003c/p\u003e\u003cp id=\"73bb\"\u003eIn this sense, guard is imperative, sequential, and flow-oriented. It reflects Swift’s overall design tendency toward explicit control and readability over composability. It’s declarative in feel, but not in origin (Comments section is below. Welcome.)\u003c/p\u003e\u003cp id=\"f098\"\u003eSwift’s design solves a very real problem: how to make early exits visible and pleasant. But it doesn’t follow the same evolution as Kotlin. Rather than a refinement of match-based logic, Swift’s guard is a rethinking of \u003ccode\u003eif\u003c/code\u003e and turned inside out.\u003c/p\u003e\u003cp id=\"b4c6\"\u003eThis contrast is critical for understanding why Kotlin did not adopt this \u003ccode\u003eguard\u003c/code\u003e statement. Kotlin tends to evolve by extending constructs already familiar to developers, rather than introducing entirely new paradigms. Not all the time for sure! However, there is evidence in features that have been part of Kotlin since version 1.0 like the Elvis operator (\u003ccode\u003e?:\u003c/code\u003e), safe calls (\u003ccode\u003e?.\u003c/code\u003e), and the \u003ccode\u003ewhen\u003c/code\u003e expression itself. None of these were invented from scratch. Instead, each distilled a widely used idiom (null-checking, defaulting, branching) into a more consistent form that integrated smoothly into the language’s expression-oriented design.\u003c/p\u003e\u003cp id=\"c5e4\"\u003eIn the case of when guards, Kotlin already provided multiple ways to write complex conditionals and match logic: with \u003ccode\u003eif\u003c/code\u003e, with \u003ccode\u003ewhen\u003c/code\u003e without subject, and with smart casting. What it didn’t offer was a concise and idiomatic way to combine type-based branching with additional conditions directly in a \u003ccode\u003ewhen\u003c/code\u003e subject block. I think that when guards were introduced to refine this edge case — not to replace existing patterns, but to make a common structure more readable and discoverable.\u003c/p\u003e\u003cp id=\"d5d7\"\u003eDo we need them? Maybe not always.\u003c/p\u003e\u003cp id=\"a3d3\"\u003eBut do they fit Kotlin’s evolution? I think — absolutely.\u003c/p\u003e\u003cp id=\"da4c\"\u003eIt’s quite possible that the real value of when guards will become clear only after the release of Rich Errors in Kotlin 2.4.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2025-05-28T23:54:30.367Z",
  "modifiedTime": null
}
