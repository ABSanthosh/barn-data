{
  "id": "946398a2-cbcb-48e7-91b2-3f4eb2070d17",
  "title": "Mastering Android Text-to-Speech: The Ultimate Guide!",
  "link": "https://proandroiddev.com/mastering-android-text-to-speech-the-ultimate-guide-8932b21afcda?source=rss----c72404660798---4",
  "description": "",
  "author": "Ashiq Fury",
  "published": "Fri, 04 Jul 2025 20:27:48 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "jetpack-compose",
    "technology",
    "text-to-speech",
    "compose-multiplatform"
  ],
  "byline": "Ashiq Fury",
  "length": 26662,
  "excerpt": "Learn how to build a production-ready TextToSpeech handler in Kotlin. Master long text, chunking, lifecycle-aware pause/resume, and synchronized word highlighting.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Mastering Android Text-to-Speech: The Ultimate Guide!A Deep Dive into Building a Robust Text To Speech Handler with Pause, Resume, and Word Highlighting.Not a member? Please use this link my friend ‚ò∫Ô∏è.Table Of Contents:¬∑ ‚ú® The Trailer: Initial Setup¬∑ ü§´ Chapter 1: The First Tension ‚Äî ‚ÄúUnexpected Silence‚Äù¬∑ ‚ö°Ô∏è Chapter 2: The ‚ÄúWow‚Äù Factor ‚Äî Lighting Up Words on the Screen¬∑ üí™ Chapter 3: The ‚ÄúToo Much Text!‚Äù Problem¬∑ ‚öñÔ∏è Chapter 4: The Real Brain-Teaser ‚Äî Pause, Resume, and All That Drama¬∑ üëª Chapter 5: The ‚ÄúGhost Speaker‚Äù That Won‚Äôt Shut Up¬∑ üòâ Bonus Tips:¬∑ üß† Conclusion:¬∑ üí¨ Let‚Äôs Talk¬∑ üìö My Articles:Hey Android Developers!Let‚Äôs talk about the Android TextToSpeech (TTS) engine. At first glance, it looks simple, right? You give it some text, it speaks. Done!. But if you have ever tried to use it in a proper production level application, you will know the real story ü•∏. Its like expecting a simple two-minutes Maggi üçú noodles and ending up having to cook a full biriyani ü•ò.What happens when you need to pause and resume?How do you highlight words as they‚Äôre spoken?What if the user tries to speak a paragraph longer than the engine‚Äôs buffer limit?How do you handle the user minimising the app or navigating to another screen?Today, we are going on a journey. We‚Äôll start with the basic, ‚Äúit‚Äôs not working‚Äù code and, step-by-step, turn it into a rock-solid TextToSpeech handler that can handle anything you throw at it. We will be using modern Android libraries like Coroutines, Flows, and Lifecycle Observers.Let‚Äôs get started!‚ú® The Trailer: Initial Setupclass TextToSpeechManager(private val context: Context) { private val coroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate) private var tts: TextToSpeech? = null fun speak(text: String) { // TODO.. } fun stop() { tts?.stop() } fun shutdown() { stop() tts?.shutdown() tts = null coroutineScope.cancel() }}In TextToSpeechManager, we have initialised our TTS instance as null, and it will be initialised only if the speak is called.ü§´ Chapter 1: The First Tension ‚Äî ‚ÄúUnexpected Silence‚ÄùYou write your first piece of TextToSpeech code, run the app, click the button, and‚Ä¶ nothing. Pin-drop silence. You click it again, and suddenly it works. What‚Äôs this magic?fun speak(text: String) { // The code that gives every developer trust issues tts = TextToSpeech(context) { status -\u003e if (status == TextToSpeech.SUCCESS) { // This part runs after some time... a long time... } } // ...but your code reaches here in a flash! tts?.speak(\"Hello, world!\", TextToSpeech.QUEUE_FLUSH, null, null) // Silently fails}The main problem is that the TextToSpeech engine takes its own sweet time to get ready. Your code calls .speak() and moves on, while the engine is still waking up.The modern, clean way to solve this is to stop thinking in callbacks and start thinking in coroutines. We will use suspendCancellableCoroutine to create a ‚Äúbridge‚Äù. This function will patiently wait for the TextToSpeech engine to be ready before letting our code proceed.Create a suspend function that only returns when the engine is 100% ready.private suspend fun initialize() { // If already initialized, do nothing. if (tts != null) returntts = suspendCancellableCoroutine { continuation -\u003e var ttsInstance: TextToSpeech? = null val listener = TextToSpeech.OnInitListener { status -\u003e if (status == TextToSpeech.SUCCESS) { ttsInstance?.let { if (continuation.isActive) { // If worked! Resume the coroutine with the engine instance. continuation.resume(it) } } } else { if (continuation.isActive) { // If failed. Throw a exception. continuation.resumeWithException(Exception(\"Init failed!\")) } } } ttsInstance = TextToSpeech(context, listener) // A safety net: if the coroutine is cancelled while waiting, shut down the engine. continuation.invokeOnCancellation { ttsInstance.shutdown() } }}This function will be our gateway to a ready-to-use TTS engine. Now, our code is simple and readable, just calling this initialize method to get TextToSpeech instance. No more guesswork!‚ö°Ô∏è Chapter 2: The ‚ÄúWow‚Äù Factor ‚Äî Lighting Up Words on the ScreenTo make our app look really premium, let‚Äôs highlight words as they are being spoken. This needs a bit of teamwork between our handler and the UI.The TextToSpeech API has a secret weapon for this: UtteranceProgressListener. Inside it, the onRangeStart() method tells us exactly which characters are about to be spoken.Our plan is simple:When onRangeStart() is called, we will emit an event with the start and end character positions.We will use a SharedFlow to send these events out from our handler.Our ViewModel and UI will listen to this flow and update the screen.class TextToSpeechManager(private val context: Context) { // (1) private val _highlight = MutableStateFlow\u003cPair\u003cInt, Int\u003e?\u003e(null) val highlight: StateFlow\u003cPair\u003cInt, Int\u003e?\u003e = _highlight // (2) private fun createProgressListener() = object : UtteranceProgressListener() { override fun onStart(utteranceId: String?) {} override fun onError(utteranceId: String?) { stop() }override fun onDone(utteranceId: String?) {} override fun onRangeStart(utteranceId: String?, start: Int, end: Int, frame: Int) { // (3) coroutineScope.launch { _highlight.emit(Pair(absoluteStart, absoluteEnd)) } } } private suspend fun initialize() { // existing code... if (status == TextToSpeech.SUCCESS) { // (4) it.setOnUtteranceProgressListener(createProgressListener()) // resume... } // assign tts instance.. }}We first declare a stateFlow inside our TTSManager to track the currently spoken word.Creating an UtteranceProgressListener object.In the onRangeStart method, we just emit the start and end value into our highlight flow.Finally, assigning the listener into the TextToSpeech instance in our initialise method.In Jetpack Compose, this is super easy to handle. We just collect the flow and use an AnnotatedString to paint a nice yellow background on the text. Simple, na?üí™ Chapter 3: The ‚ÄúToo Much Text!‚Äù ProblemThe TextToSpeech engine isn‚Äôt a miracle worker. If you give it a 10,000-character essay, it will simply give up. Most engines have a limit of around 4000 characters.The solution? We become smarter. We‚Äôll chop the big text into smaller, digestible chunks (say, 3000 characters each). For a natural feel, we‚Äôll try to chop at the end of a sentence (., !, ?).We will feed the first chunk to the engine. When the onDone() callback tells us it‚Äôs finished, we simply feed it the next chunk.Let‚Äôs create a data class for better handling of this case:private data class TtsSession( val text: String, val chunks: List\u003cString\u003e, val chunkOffsets: List\u003cInt\u003e, // Start index of each chunk in originalText var currentChunkIndex: Int = 0,)text ‚Äî Contains the original text.chunks ‚Äî Contains the chunk of sentences.chunkOffsets ‚Äî Start index of the each chunk in original text.currentChunkIndex ‚Äî Index of the chunk which is currently speaking.Let‚Äôs create a util function to split the original text into chunks:class TextTospeechManager(private val context: Context) { // ... existing code companion object { private const val TTS_CHUNK_SIZE_LIMIT = 3000 private fun splitTextIntoChunks(text: String): List\u003cString\u003e { if (text.length \u003c= TTS_CHUNK_SIZE_LIMIT) { return listOf(text) } val chunks = mutableListOf\u003cString\u003e() var remainingText = text while (remainingText.isNotEmpty()) { if (remainingText.length \u003c= TTS_CHUNK_SIZE_LIMIT) { chunks.add(remainingText) break } val potentialChunk = remainingText.substring(0, TTS_CHUNK_SIZE_LIMIT) var splitIndex = potentialChunk.lastIndexOfAny(charArrayOf('.', '!', '?')) if (splitIndex == -1) { splitIndex = potentialChunk.lastIndexOf(' ') } if (splitIndex == -1) { splitIndex = TTS_CHUNK_SIZE_LIMIT - 1 } chunks.add(remainingText.substring(0, splitIndex + 1)) remainingText = remainingText.substring(splitIndex + 1) } return chunks } }}As I have already mentioned, this method splits the original text into chunks. To get a natural feeling, it looks for (‚Äò.‚Äô, ‚Äò!‚Äô, ‚Äò?‚Äô). It‚Äôs also aware of not splitting the word. For example, if we have a long word at the 2995th index, it will not split the chunk at 3000; it will split at 2994th index (probably whitespace). Because splitting the word into two is not what we want, it will be weird when speaking, as if it‚Äôs two separate words.Let‚Äôs combine all together:class TextToSpeechManager(...) { private var currentSession: TtsSession? = null suspend fun speak(text: String) { initialize() stop() // Stop any previous session // Create and store the new session val chunks = splitTextIntoChunks(text) // Use runningFold to correctly calculate start offsets for each chunk val offsets = chunks.runningFold(0) { acc, chunk -\u003e acc + chunk.length }.dropLast(1) currentSession = TtsSession(text, chunks, offsets) speakCurrentChunk() } private fun speakCurrentChunk() { val session = currentSession ?: return val ttsInstance = tts ?: return val chunkIndex = session.currentChunkIndex if (chunkIndex \u003e= session.chunks.size) { stop() // All chunks are done return } val chunk = session.chunks[chunkIndex] ttsInstance.speak(chunk, TextToSpeech.QUEUE_FLUSH, null, \"chunk_${chunkIndex}\") }}In speak method: we get the chunks from our splitTextIntoChunks() method and find the chunkOffset for each chunks. Then store it into the TTsSession state.In speakCurrentChunk method: It‚Äôs pretty straight forward, we just get the chunk text from the currentChunkIndex and feed the chunk into TTS‚Äôs speak method.override fun onDone(utteranceId: String?) { // This chunk is done, let's play the next one. currentSession?.let { it.currentChunkIndex++ speakCurrentChunk() }}And increment then current chunk and call the speakCurrentChunk method in OnDone method of the UtteranceProgressListener .‚öñÔ∏è Chapter 4: The Real Brain-Teaser ‚Äî Pause, Resume, and All That DramaHere‚Äôs where the real headache begins. TextToSpeech has a stop() method, but no pause() or resume() method. And stop() is destructive ‚Äî it forgets everything it was supposed to say.So, what to do? We have to build our own pause / resume logic. It‚Äôs a bit of a an innovative, but an engineering one!The Master Plan:We will create a TtsSession data class to be our ‚Äútracker‚Äù. It will keep track of the full text, whether we are paused, and most importantly, a bookmark of where we last stopped.On Pause: We will set a flag isPaused = true in our session and then call tts.stop().On Resume: We check our isPaused flag. We‚Äôll find our bookmark, chop the original text from that point, and give this new, smaller piece of text to the TTS engine to speak.private data class TtsSession( // ... var lastSpokenTextEndIndex: Int = 0, var resumeOffsetInChunk: Int = 0)class TextToSpeechManager(...) { fun pause() { tts?.stop() } fun resume() { speakCurrentChunk(fromPause = true) } private fun speakCurrentChunk(fromPause: Boolean = false) { // existing code... val chunk = session.chunks[chunkIndex] val textToSpeak: String if (fromPause) { // We are resuming. Calculate the starting point within the chunk. val resumeIndex = session.lastSpokenTextEndIndex - session.chunkOffsets[chunkIndex] // Set the state for the onRangeStart listener to use. session.resumeOffsetInChunk = if (resumeIndex \u003e 0) resumeIndex else 0 textToSpeak = if (session.resumeOffsetInChunk \u003c chunk.length) { chunk.substring(session.resumeOffsetInChunk) } else { // Paused at the very end, move to the next chunk. session.currentChunkIndex++ speakCurrentChunk() // Recursive call for the next chunk return } } else { // Playing normally from the start of the chunk. Reset the offset. session.resumeOffsetInChunk = 0 textToSpeak = chunk } ttsInstance.speak(textToSpeak, TextToSpeech.QUEUE_FLUSH, null, \"chunk_${chunkIndex}\") }}But wait, there‚Äôs a catch! When you resume, the onRangeStart() callback gives you indices based on the smaller, chopped text. This will mess up our highlighting!The Fix: Our session ‚Äútracker‚Äù must also store an offset ‚Äî the starting point of the current text chunk.override fun onRangeStart(utteranceId: String?, start: Int, end: Int, frame: Int) { val session = currentSession ?: return // 1. Get the offset of the current chunk within the full text. val chunkOffset = session.chunkOffsets[session.currentChunkIndex] // 2. Get the resume offset we explicitly set in speakCurrentChunk(). // This is 0 for normal playback, and \u003e 0 for resumed playback. val resumeOffset = session.resumeOffsetInChunk // 3. Calculate the true absolute start and end indices. // Absolute Index = (Start of Chunk) + (Start of Spoken Substring) + (Start from TTS) val absoluteStart = chunkOffset + resumeOffset + start val absoluteEnd = chunkOffset + resumeOffset + end // 4. Save our position and emit the highlight for the UI. session.lastSpokenTextEndIndex = absoluteEnd coroutineScope.launch { _highlight.emit(Pair(absoluteStart, absoluteEnd)) }}With this, our pause, resume, and highlighting work together like a charm.üëª Chapter 5: The ‚ÄúGhost Speaker‚Äù That Won‚Äôt Shut UpThis is a common mistake. The user leaves a screen, but the TextToSpeech keeps talking in the background. It‚Äôs annoying!App goes to the background: We can make our handler a LifecycleObserver and watch the entire app‚Äôs lifecycle using DefaultLifecycleObserver. When the app‚Äôs onPause() is called, we can automatically pause all our TextToSpeech sessions.import androidx.lifecycle.DefaultLifecycleObserverclass TextToSpeechManager(...): DefaultLifecycleObserver { override fun onPause(owner: LifecycleOwner) { pause() } override fun onDestroy(owner: LifecycleOwner) { shutdown() }}User navigates back: We can handle the TextToSpeech to stop when the user leaves the page. We expose a simple function: destroy() to handle this. There are two ways to handle this:‚Äî Using ViewModel‚Äôs onCleared method.‚Äî Using DisposableEffect in composable.DisposableEffect(Unit) { onDispose { viewModel.destroy() // like calling shutdown in TTSManager }}üòâ Bonus Tips:There are some additional implementations we can do like tracking the current state of the TTS instance.Here is the entire code for your reference:sealed class TtsState { data object Idle : TtsState() data object Speaking : TtsState() data object Paused : TtsState()}private data class TtsSession( val text: String, val chunks: List\u003cString\u003e, val chunkOffsets: List\u003cInt\u003e, var currentChunkIndex: Int = 0, var lastSpokenTextEndIndex: Int = 0, var resumeOffsetInChunk: Int = 0)class TextToSpeechManager(private val context: Context): DefaultLifecycleObserver { private val coroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate) private var tts: TextToSpeech? = null private var currentSession: TtsSession? = null private val _state = MutableStateFlow\u003cTtsState\u003e(TtsState.Idle) val state: StateFlow\u003cTtsState\u003e = _state private val _highlight = MutableStateFlow\u003cPair\u003cInt, Int\u003e?\u003e(null) val highlight: StateFlow\u003cPair\u003cInt, Int\u003e?\u003e = _highlight suspend fun speak(text: String) { initialize() stop() val chunks = splitTextIntoChunks(text) val offsets = chunks.runningFold(0) { acc, chunk -\u003e acc + chunk.length }.dropLast(1) currentSession = TtsSession(text, chunks, offsets) _state.value = TtsState.Speaking speakCurrentChunk() } fun pause() { if (_state.value == TtsState.Speaking) { tts?.stop() _state.value = TtsState.Paused } } fun resume() { if (_state.value == TtsState.Paused) { _state.value = TtsState.Speaking speakCurrentChunk(fromPause = true) } } fun stop() { tts?.stop() currentSession = null _state.value = TtsState.Idle _highlight.value = null } fun shutdown() { stop() tts?.shutdown() tts = null coroutineScope.cancel() } private fun speakCurrentChunk(fromPause: Boolean = false) { val session = currentSession ?: return val ttsInstance = tts ?: return val chunkIndex = session.currentChunkIndex if (chunkIndex \u003e= session.chunks.size) { stop() return } val chunk = session.chunks[chunkIndex] val textToSpeak: String if (fromPause) { val resumeIndex = session.lastSpokenTextEndIndex - session.chunkOffsets[chunkIndex] session.resumeOffsetInChunk = if (resumeIndex \u003e 0) resumeIndex else 0 textToSpeak = if (session.resumeOffsetInChunk \u003c chunk.length) { chunk.substring(session.resumeOffsetInChunk) } else { session.currentChunkIndex++ speakCurrentChunk() return } } else { session.resumeOffsetInChunk = 0 textToSpeak = chunk } ttsInstance.speak(textToSpeak, TextToSpeech.QUEUE_FLUSH, null, \"chunk_${chunkIndex}\") } private suspend fun initialize() { if (tts != null) return tts = suspendCancellableCoroutine { continuation -\u003e var ttsInstance: TextToSpeech? = null val listener = TextToSpeech.OnInitListener { status -\u003e if (status == TextToSpeech.SUCCESS) { ttsInstance?.let { it.setOnUtteranceProgressListener(createProgressListener()) if (continuation.isActive) { continuation.resume(it) } } } else { if (continuation.isActive) { continuation.resumeWithException(Exception(\"Init failed.\")) } } } ttsInstance = TextToSpeech(context, listener) continuation.invokeOnCancellation { ttsInstance.shutdown() } } } private fun createProgressListener() = object : UtteranceProgressListener() { override fun onStart(utteranceId: String?) {} override fun onError(utteranceId: String?) { stop() } override fun onDone(utteranceId: String?) { if (_state.value == TtsState.Speaking) { currentSession?.let { it.currentChunkIndex++ speakCurrentChunk() } } } override fun onRangeStart(utteranceId: String?, start: Int, end: Int, frame: Int) { val session = currentSession ?: return val chunkOffset = session.chunkOffsets[session.currentChunkIndex] val resumeOffset = session.resumeOffsetInChunk val absoluteStart = chunkOffset + resumeOffset + start val absoluteEnd = chunkOffset + resumeOffset + end session.lastSpokenTextEndIndex = absoluteEnd coroutineScope.launch { _highlight.emit(Pair(absoluteStart, absoluteEnd)) } } } companion object { private const val TTS_CHUNK_SIZE_LIMIT = 3000 private fun splitTextIntoChunks(text: String): List\u003cString\u003e { if (text.length \u003c= TTS_CHUNK_SIZE_LIMIT) { return listOf(text) } val chunks = mutableListOf\u003cString\u003e() var remainingText = text while (remainingText.isNotEmpty()) { if (remainingText.length \u003c= TTS_CHUNK_SIZE_LIMIT) { chunks.add(remainingText) break } val potentialChunk = remainingText.substring(0, TTS_CHUNK_SIZE_LIMIT) var splitIndex = potentialChunk.lastIndexOfAny(charArrayOf('.', '!', '?')) if (splitIndex == -1) { splitIndex = potentialChunk.lastIndexOf(' ') } if (splitIndex == -1) { splitIndex = TTS_CHUNK_SIZE_LIMIT - 1 } chunks.add(remainingText.substring(0, splitIndex + 1)) remainingText = remainingText.substring(splitIndex + 1) } return chunks } } override fun onPause(owner: LifecycleOwner) { if (_state.value == TtsState.Speaking) { pause() } } override fun onDestroy(owner: LifecycleOwner) { shutdown() }}Here is the sample compose UI:@Composablefun RecipeReaderScreen() { val context = LocalContext.current val lifecycleOwner = androidx.lifecycle.compose.LocalLifecycleOwner.current // Remember the manager across recompositions val ttsManager = remember { TextToSpeechManager(context) } // Clean up the manager when the composable leaves the screen DisposableEffect(lifecycleOwner) { onDispose { ttsManager.shutdown() } } DisposableEffect(lifecycleOwner) { // When the Composable enters the composition, add the observer. lifecycleOwner.lifecycle.addObserver(ttsManager) // When the Composable leaves the composition, remove the observer. // This is also where the manager's onDestroy will be called, // which in turn calls shutdown(), cleaning up all resources. onDispose { lifecycleOwner.lifecycle.removeObserver(ttsManager) } } val recipeText = \"First, preheat the oven to 180 degrees Celsius. \" + \"While it heats, whisk together the flour, sugar, and cocoa powder in a large bowl. \" + \"Slowly mix in the eggs and milk until the batter is smooth. \" + \"Finally, pour the batter into a greased baking pan and bake for 30 minutes. Enjoy your delicious cake!\" // Collect states from our manager to drive the UI val ttsState by ttsManager.state.collectAsState() val highlight by ttsManager.highlight.collectAsState() val coroutineScope = rememberCoroutineScope() // Create the annotated string for highlighting text val annotatedText = buildAnnotatedString { append(recipeText) highlight?.let { (start, end) -\u003e if (start in recipeText.indices \u0026\u0026 end \u003c= recipeText.length \u0026\u0026 start \u003c end) { addStyle( style = SpanStyle( fontWeight = FontWeight.ExtraBold, background = Color(0xFFFFF59D) // A pleasant yellow ), start = start, end = end ) } } } Column( modifier = Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally ) { Text( text = \"Chocolate Lava Cake Recipe\", style = MaterialTheme.typography.headlineMedium, modifier = Modifier.padding(bottom = 16.dp) ) Card( modifier = Modifier .fillMaxWidth() .weight(1f), elevation = CardDefaults.cardElevation(4.dp) ) { Text( text = annotatedText, style = MaterialTheme.typography.bodyMedium, modifier = Modifier.padding(16.dp) ) } Spacer(modifier = Modifier.height(24.dp)) Row( horizontalArrangement = Arrangement.Center, modifier = Modifier.fillMaxWidth() ) { // The main Play/Pause/Resume Button Button( onClick = { when (ttsState) { TtsState.Idle -\u003e { coroutineScope.launch { ttsManager.speak(recipeText) } } TtsState.Paused -\u003e { ttsManager.resume() } TtsState.Speaking -\u003e { ttsManager.pause() } } }, modifier = Modifier.height(48.dp) ) { val buttonText = when(ttsState) { TtsState.Idle -\u003e \"Read Recipe\" TtsState.Speaking -\u003e \"Pause\" TtsState.Paused -\u003e \"Resume\" } Text(buttonText) } Spacer(modifier = Modifier.width(16.dp)) // The Stop Button Button( onClick = { ttsManager.stop() }, enabled = ttsState != TtsState.Idle, modifier = Modifier.height(48.dp), colors = ButtonDefaults.buttonColors( containerColor = MaterialTheme.colorScheme.error, contentColor = Color.White ) ) { Text(\"Stop\") } } }}If you run the app, you will see something like this:In the video sample, I have demonstrated the Speak, Pause, Resume and Hightlight functionality. Due to image limitation in Medium.com, audio will not be hearable in the video (GIF Image).üß† Conclusion:And there we have it! We started with a simple, buggy piece of code and tackled every problem one by one. Our final TextToSpeech handler is now a thing of beauty:It waits patiently for the engine to be ready.It highlights words beautifully.It handles Pause and Resume like a pro.It doesn‚Äôt choke on large texts.It behaves itself when the user leaves the app or the screen.üí¨ Let‚Äôs TalkHave you tried building your Text To Speech? Have you handled any additional features? Or have you handled it in better way?‚Äî I‚Äôd love to hear from you!üìö My Articles:",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*2UvubTC1faRk0XRfzybwYQ.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"0a77\" data-testid=\"storyTitle\"\u003eMastering Android Text-to-Speech: The Ultimate Guide!\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@ashiqfury?source=post_page---byline--8932b21afcda---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ashiq Fury\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*VkzDKa_cCd2qoJw8UsCfJw.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"af98\"\u003e\u003cem\u003eA Deep Dive into Building a Robust Text To Speech Handler with Pause, Resume, and Word Highlighting.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cblockquote\u003e\u003cp id=\"d782\"\u003eNot a member? Please use this \u003ca href=\"https://medium.com/@ashiqfury/mastering-android-text-to-speech-the-ultimate-guide-8932b21afcda?sk=d7af922cd15688f57a17f16247f50b67\" rel=\"noopener\"\u003elink\u003c/a\u003e my friend ‚ò∫Ô∏è.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"80b8\"\u003eTable Of Contents:\u003c/h2\u003e\u003cp id=\"e301\"\u003e¬∑ \u003ca href=\"#e199\" rel=\"noopener ugc nofollow\"\u003e‚ú® The Trailer: Initial Setup\u003c/a\u003e\u003cbr/\u003e¬∑ \u003ca href=\"#f2ce\" rel=\"noopener ugc nofollow\"\u003eü§´ Chapter 1: The First Tension ‚Äî ‚ÄúUnexpected Silence‚Äù\u003c/a\u003e\u003cbr/\u003e¬∑ \u003ca href=\"#64e2\" rel=\"noopener ugc nofollow\"\u003e‚ö°Ô∏è Chapter 2: The ‚ÄúWow‚Äù Factor ‚Äî Lighting Up Words on the Screen\u003c/a\u003e\u003cbr/\u003e¬∑ \u003ca href=\"#89de\" rel=\"noopener ugc nofollow\"\u003eüí™ Chapter 3: The ‚ÄúToo Much Text!‚Äù Problem\u003c/a\u003e\u003cbr/\u003e¬∑ \u003ca href=\"#cac3\" rel=\"noopener ugc nofollow\"\u003e‚öñÔ∏è Chapter 4: The Real Brain-Teaser ‚Äî Pause, Resume, and All That Drama\u003c/a\u003e\u003cbr/\u003e¬∑ \u003ca href=\"#bddf\" rel=\"noopener ugc nofollow\"\u003eüëª Chapter 5: The ‚ÄúGhost Speaker‚Äù That Won‚Äôt Shut Up\u003c/a\u003e\u003cbr/\u003e¬∑ \u003ca href=\"#2ee8\" rel=\"noopener ugc nofollow\"\u003eüòâ Bonus Tips:\u003c/a\u003e\u003cbr/\u003e¬∑ \u003ca href=\"#e51b\" rel=\"noopener ugc nofollow\"\u003eüß† Conclusion:\u003c/a\u003e\u003cbr/\u003e¬∑ \u003ca href=\"#8a11\" rel=\"noopener ugc nofollow\"\u003eüí¨ Let‚Äôs Talk\u003c/a\u003e\u003cbr/\u003e¬∑ \u003ca href=\"#9479\" rel=\"noopener ugc nofollow\"\u003eüìö My Articles:\u003c/a\u003e\u003c/p\u003e\u003cp id=\"dfac\"\u003e\u003cem\u003eHey \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eAndroid Developers\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e!\u003c/em\u003e\u003c/p\u003e\u003cp id=\"d1cf\"\u003eLet‚Äôs talk about the Android \u003ccode\u003eTextToSpeech\u003c/code\u003e (TTS) engine. At first glance, it looks simple, right? You give it some text, it speaks. Done!. But if you have ever tried to use it in a proper production level application, you will know the real story ü•∏. Its like expecting a simple two-minutes Maggi üçú noodles and ending up having to cook a full biriyani ü•ò.\u003c/p\u003e\u003cul\u003e\u003cli id=\"c095\"\u003eWhat happens when you need to \u003cstrong\u003epause and resume\u003c/strong\u003e?\u003c/li\u003e\u003cli id=\"6bf1\"\u003eHow do you \u003cstrong\u003ehighlight words\u003c/strong\u003e as they‚Äôre spoken?\u003c/li\u003e\u003cli id=\"78ba\"\u003eWhat if the user tries to \u003cstrong\u003espeak a paragraph longer\u003c/strong\u003e than the engine‚Äôs buffer limit?\u003c/li\u003e\u003cli id=\"42fc\"\u003eHow do you handle the user \u003cstrong\u003eminimising the app\u003c/strong\u003e or navigating to another screen?\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c926\"\u003eToday, we are going on a journey. We‚Äôll start with the basic, ‚Äúit‚Äôs not working‚Äù code and, step-by-step, turn it into a rock-solid \u003ccode\u003eTextToSpeech\u003c/code\u003e handler that can handle anything you throw at it. We will be using modern Android libraries like \u003cem\u003eCoroutines, Flows, and Lifecycle Observers.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"6c4e\"\u003eLet‚Äôs get started!\u003c/p\u003e\u003ch2 id=\"e199\"\u003e‚ú® The Trailer: Initial Setup\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"4883\"\u003eclass TextToSpeechManager(private val context: Context) {\u003cbr/\u003e    private val coroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)\u003cbr/\u003e    private var tts: TextToSpeech? = null\u003cp\u003e        fun speak(text: String) {\u003cbr/\u003e        // TODO.. \u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        fun stop() {\u003cbr/\u003e        tts?.stop()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        fun shutdown() {\u003cbr/\u003e        stop()\u003cbr/\u003e        tts?.shutdown()\u003cbr/\u003e        tts = null\u003cbr/\u003e        coroutineScope.cancel()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e770\"\u003eIn \u003ccode\u003eTextToSpeechManager\u003c/code\u003e, we have initialised our TTS instance as \u003ccode\u003enull\u003c/code\u003e, and it will be initialised only if the speak is called.\u003c/p\u003e\u003ch2 id=\"f2ce\"\u003eü§´ Chapter 1: The First Tension ‚Äî ‚ÄúUnexpected Silence‚Äù\u003c/h2\u003e\u003cp id=\"2fb2\"\u003eYou write your first piece of \u003ccode\u003eTextToSpeech\u003c/code\u003e code, run the app, click the button, and‚Ä¶ nothing. Pin-drop silence. You click it again, and suddenly it works. What‚Äôs this magic?\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"18ff\"\u003efun speak(text: String) {\u003cbr/\u003e    // The code that gives every developer trust issues\u003cbr/\u003e    tts = TextToSpeech(context) { status -\u0026gt;\u003cbr/\u003e        if (status == TextToSpeech.SUCCESS) {\u003cbr/\u003e            // This part runs after some time... a long time...\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    // ...but your code reaches here in a flash!\u003cbr/\u003e    tts?.speak(\u0026#34;Hello, world!\u0026#34;, TextToSpeech.QUEUE_FLUSH, null, null) // Silently fails\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bd70\"\u003eThe main problem is that the \u003ccode\u003eTextToSpeech\u003c/code\u003e engine takes its own sweet time to get ready. Your code calls \u003ccode\u003e.speak()\u003c/code\u003e and moves on, while the engine is still waking up.\u003c/p\u003e\u003cp id=\"f0aa\"\u003eThe modern, clean way to solve this is to stop thinking in callbacks and start thinking in coroutines. We will use \u003ccode\u003esuspendCancellableCoroutine\u003c/code\u003e to create a ‚Äúbridge‚Äù. This function will patiently wait for the \u003ccode\u003eTextToSpeech\u003c/code\u003e engine to be ready before letting our code proceed.\u003c/p\u003e\u003cp id=\"dc0e\"\u003eCreate a suspend function that only returns when the engine is 100% ready.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"848f\"\u003eprivate suspend fun initialize() {\u003cbr/\u003e    // If already initialized, do nothing.\u003cbr/\u003e    if (tts != null) return\u003cbr/\u003etts = suspendCancellableCoroutine { continuation -\u0026gt;\u003cbr/\u003e        var ttsInstance: TextToSpeech? = null\u003cbr/\u003e        val listener = TextToSpeech.OnInitListener { status -\u0026gt;\u003cbr/\u003e            if (status == TextToSpeech.SUCCESS) {\u003cbr/\u003e                ttsInstance?.let {\u003cbr/\u003e                    if (continuation.isActive) {\u003cbr/\u003e                     // If worked! Resume the coroutine with the engine instance.\u003cbr/\u003e                        continuation.resume(it)\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            } else {\u003cbr/\u003e                if (continuation.isActive) {\u003cbr/\u003e                  // If failed. Throw a exception.\u003cbr/\u003e                    continuation.resumeWithException(Exception(\u0026#34;Init failed!\u0026#34;))\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        ttsInstance = TextToSpeech(context, listener)\u003cbr/\u003e    // A safety net: if the coroutine is cancelled while waiting, shut down the engine.\u003cbr/\u003e        continuation.invokeOnCancellation {\u003cbr/\u003e            ttsInstance.shutdown()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d2ff\"\u003eThis function will be our gateway to a ready-to-use TTS engine. Now, our code is simple and readable, just calling this \u003ccode\u003einitialize\u003c/code\u003e method to get \u003ccode\u003eTextToSpeech\u003c/code\u003e instance. No more guesswork!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"64e2\"\u003e‚ö°Ô∏è Chapter 2: The ‚ÄúWow‚Äù Factor ‚Äî Lighting Up Words on the Screen\u003c/h2\u003e\u003cp id=\"c056\"\u003eTo make our app look really premium, let‚Äôs highlight words as they are being spoken. This needs a bit of teamwork between our handler and the UI.\u003c/p\u003e\u003cp id=\"69ce\"\u003eThe \u003ccode\u003eTextToSpeech\u003c/code\u003e API has a secret weapon for this: \u003ccode\u003eUtteranceProgressListener\u003c/code\u003e. Inside it, the \u003ccode\u003eonRangeStart()\u003c/code\u003e method tells us \u003cem\u003eexactly\u003c/em\u003e which characters are about to be spoken.\u003c/p\u003e\u003cp id=\"75e4\"\u003eOur plan is simple:\u003c/p\u003e\u003col\u003e\u003cli id=\"b810\"\u003eWhen \u003ccode\u003eonRangeStart()\u003c/code\u003e is called, we will emit an event with the start and end character positions.\u003c/li\u003e\u003cli id=\"e2bc\"\u003eWe will use a \u003ccode\u003eSharedFlow\u003c/code\u003e to send these events out from our handler.\u003c/li\u003e\u003cli id=\"6044\"\u003eOur ViewModel and UI will listen to this flow and update the screen.\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"9b0a\"\u003eclass TextToSpeechManager(private val context: Context) {\u003cbr/\u003e    // (1)\u003cbr/\u003e    private val _highlight = MutableStateFlow\u0026lt;Pair\u0026lt;Int, Int\u0026gt;?\u0026gt;(null)\u003cbr/\u003e    val highlight: StateFlow\u0026lt;Pair\u0026lt;Int, Int\u0026gt;?\u0026gt; = _highlight\u003cp\u003e        // (2)\u003cbr/\u003e    private fun createProgressListener() = object : UtteranceProgressListener() {\u003cbr/\u003e        override fun onStart(utteranceId: String?) {}\u003cbr/\u003e        override fun onError(utteranceId: String?) { stop() }\u003cbr/\u003eoverride fun onDone(utteranceId: String?) {}\u003cbr/\u003e        override fun onRangeStart(utteranceId: String?, start: Int, end: Int, frame: Int) {\u003cbr/\u003e          // (3)\u003cbr/\u003e            coroutineScope.launch {\u003cbr/\u003e                _highlight.emit(Pair(absoluteStart, absoluteEnd))\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e      private suspend fun initialize() {\u003cbr/\u003e    // existing code...\u003c/p\u003e\u003cp\u003e        if (status == TextToSpeech.SUCCESS) {\u003cbr/\u003e      // (4)\u003cbr/\u003e      it.setOnUtteranceProgressListener(createProgressListener())\u003cbr/\u003e      // resume...\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        // assign tts instance..\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003col\u003e\u003cli id=\"f5ca\"\u003eWe first declare a \u003ccode\u003estateFlow\u003c/code\u003e inside our TTSManager to track the currently spoken word.\u003c/li\u003e\u003cli id=\"d0d6\"\u003eCreating an \u003ccode\u003eUtteranceProgressListener\u003c/code\u003e object.\u003c/li\u003e\u003cli id=\"ea71\"\u003eIn the \u003ccode\u003eonRangeStart\u003c/code\u003e method, we just emit the start and end value into our highlight flow.\u003c/li\u003e\u003cli id=\"6a77\"\u003eFinally, assigning the listener into the TextToSpeech instance in our \u003ccode\u003einitialise\u003c/code\u003e method.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"1af1\"\u003eIn Jetpack Compose, this is super easy to handle. We just collect the flow and use an \u003ccode\u003eAnnotatedString\u003c/code\u003e to paint a nice yellow background on the text. Simple, na?\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"89de\"\u003eüí™ Chapter 3: The ‚ÄúToo Much Text!‚Äù Problem\u003c/h2\u003e\u003cp id=\"8a97\"\u003eThe \u003ccode\u003eTextToSpeech\u003c/code\u003e engine isn‚Äôt a miracle worker. If you give it a 10,000-character essay, it will simply give up. Most engines have a limit of around 4000 characters.\u003c/p\u003e\u003cp id=\"0bdf\"\u003eThe solution? We become smarter. We‚Äôll chop the big text into smaller, digestible chunks (say, 3000 characters each). For a natural feel, we‚Äôll try to chop at the end of a sentence (., !, ?).\u003c/p\u003e\u003cp id=\"3856\"\u003eWe will feed the first chunk to the engine. When the \u003ccode\u003eonDone()\u003c/code\u003e callback tells us it‚Äôs finished, we simply feed it the next chunk.\u003c/p\u003e\u003cp id=\"c034\"\u003eLet‚Äôs create a data class for better handling of this case:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"50b1\"\u003eprivate data class TtsSession(\u003cbr/\u003e    val text: String,\u003cbr/\u003e    val chunks: List\u0026lt;String\u0026gt;,\u003cbr/\u003e    val chunkOffsets: List\u0026lt;Int\u0026gt;, // Start index of each chunk in originalText\u003cbr/\u003e    var currentChunkIndex: Int = 0,\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"499b\"\u003e\u003cstrong\u003etext\u003c/strong\u003e ‚Äî Contains the original text.\u003c/li\u003e\u003cli id=\"0ffe\"\u003e\u003cstrong\u003echunks\u003c/strong\u003e ‚Äî Contains the chunk of sentences.\u003c/li\u003e\u003cli id=\"61d1\"\u003e\u003cstrong\u003echunkOffsets\u003c/strong\u003e ‚Äî Start index of the each chunk in original text.\u003c/li\u003e\u003cli id=\"c017\"\u003e\u003cstrong\u003ecurrentChunkIndex\u003c/strong\u003e ‚Äî Index of the chunk which is currently speaking.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8e0a\"\u003eLet‚Äôs create a util function to split the original text into chunks:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c3e9\"\u003eclass TextTospeechManager(private val context: Context) {\u003cbr/\u003e    // ... existing code\u003cp\u003e\t\t    companion object {\u003cbr/\u003e        private const val TTS_CHUNK_SIZE_LIMIT = 3000\u003c/p\u003e\u003cp\u003e        private fun splitTextIntoChunks(text: String): List\u0026lt;String\u0026gt; {\u003cbr/\u003e            if (text.length \u0026lt;= TTS_CHUNK_SIZE_LIMIT) {\u003cbr/\u003e                return listOf(text)\u003cbr/\u003e            }\u003cbr/\u003e            val chunks = mutableListOf\u0026lt;String\u0026gt;()\u003cbr/\u003e            var remainingText = text\u003cbr/\u003e            while (remainingText.isNotEmpty()) {\u003cbr/\u003e                if (remainingText.length \u0026lt;= TTS_CHUNK_SIZE_LIMIT) {\u003cbr/\u003e                    chunks.add(remainingText)\u003cbr/\u003e                    break\u003cbr/\u003e                }\u003cbr/\u003e                val potentialChunk = remainingText.substring(0, TTS_CHUNK_SIZE_LIMIT)\u003cbr/\u003e                var splitIndex = potentialChunk.lastIndexOfAny(charArrayOf(\u0026#39;.\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;?\u0026#39;))\u003cbr/\u003e                if (splitIndex == -1) {\u003cbr/\u003e                    splitIndex = potentialChunk.lastIndexOf(\u0026#39; \u0026#39;)\u003cbr/\u003e                }\u003cbr/\u003e                if (splitIndex == -1) {\u003cbr/\u003e                    splitIndex = TTS_CHUNK_SIZE_LIMIT - 1\u003cbr/\u003e                }\u003cbr/\u003e                chunks.add(remainingText.substring(0, splitIndex + 1))\u003cbr/\u003e                remainingText = remainingText.substring(splitIndex + 1)\u003cbr/\u003e            }\u003cbr/\u003e            return chunks\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"72b8\"\u003eAs I have already mentioned, this method splits the original text into chunks. To get a natural feeling, it looks for (‚Äò.‚Äô, ‚Äò!‚Äô, ‚Äò?‚Äô). It‚Äôs also aware of not splitting the word. For example, if we have a long word at the \u003cem\u003e2995th\u003c/em\u003e index, it will not split the chunk at \u003cem\u003e3000\u003c/em\u003e; it will split at \u003cem\u003e2994th\u003c/em\u003e index (probably whitespace). Because splitting the word into two is not what we want, it will be weird when speaking, as if it‚Äôs two separate words.\u003c/p\u003e\u003cp id=\"f9e4\"\u003eLet‚Äôs combine all together:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"61e8\"\u003eclass TextToSpeechManager(...) {\u003cbr/\u003e    private var currentSession: TtsSession? = null\u003cp\u003e\t\t    suspend fun speak(text: String) {\u003cbr/\u003e        initialize()\u003cbr/\u003e        stop() // Stop any previous session\u003c/p\u003e\u003cp\u003e        // Create and store the new session\u003cbr/\u003e        val chunks = splitTextIntoChunks(text)\u003cbr/\u003e        // Use runningFold to correctly calculate start offsets for each chunk\u003cbr/\u003e        val offsets = chunks.runningFold(0) { acc, chunk -\u0026gt; acc + chunk.length }.dropLast(1)\u003cbr/\u003e        currentSession = TtsSession(text, chunks, offsets)\u003cbr/\u003e        speakCurrentChunk()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        private fun speakCurrentChunk() {\u003cbr/\u003e        val session = currentSession ?: return\u003cbr/\u003e        val ttsInstance = tts ?: return\u003cbr/\u003e        val chunkIndex = session.currentChunkIndex\u003cbr/\u003e        if (chunkIndex \u0026gt;= session.chunks.size) {\u003cbr/\u003e            stop() // All chunks are done\u003cbr/\u003e            return\u003cbr/\u003e        }\u003cbr/\u003e        val chunk = session.chunks[chunkIndex]\u003cbr/\u003e        ttsInstance.speak(chunk, TextToSpeech.QUEUE_FLUSH, null, \u0026#34;chunk_${chunkIndex}\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"267d\"\u003eIn \u003ccode\u003espeak\u003c/code\u003e method: we get the chunks from our \u003ccode\u003esplitTextIntoChunks()\u003c/code\u003e method and find the \u003ccode\u003echunkOffset\u003c/code\u003e for each chunks. Then store it into the \u003ccode\u003eTTsSession\u003c/code\u003e state.\u003c/li\u003e\u003cli id=\"59d4\"\u003eIn \u003ccode\u003espeakCurrentChunk\u003c/code\u003e method: It‚Äôs pretty straight forward, we just get the chunk text from the \u003ccode\u003ecurrentChunkIndex\u003c/code\u003e and feed the chunk into TTS‚Äôs speak method.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"015b\"\u003eoverride fun onDone(utteranceId: String?) {\u003cbr/\u003e    // This chunk is done, let\u0026#39;s play the next one.\u003cbr/\u003e    currentSession?.let {\u003cbr/\u003e        it.currentChunkIndex++\u003cbr/\u003e        speakCurrentChunk()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8baf\"\u003eAnd increment then current chunk and call the \u003ccode\u003espeakCurrentChunk\u003c/code\u003e method in \u003ccode\u003eOnDone\u003c/code\u003e method of the \u003ccode\u003eUtteranceProgressListener\u003c/code\u003e .\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"cac3\"\u003e‚öñÔ∏è Chapter 4: The Real Brain-Teaser ‚Äî Pause, Resume, and All That Drama\u003c/h2\u003e\u003cp id=\"6574\"\u003eHere‚Äôs where the real headache begins. \u003ccode\u003eTextToSpeech\u003c/code\u003e has a \u003ccode\u003estop()\u003c/code\u003e method, but no \u003ccode\u003epause()\u003c/code\u003e or \u003ccode\u003eresume()\u003c/code\u003e method. And \u003ccode\u003estop()\u003c/code\u003e is destructive ‚Äî it forgets everything it was supposed to say.\u003c/p\u003e\u003cp id=\"0951\"\u003eSo, what to do? We have to build our own pause / resume logic. It‚Äôs a bit of a an innovative, but an engineering one!\u003c/p\u003e\u003cp id=\"7674\"\u003e\u003cstrong\u003eThe Master Plan:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"d8b5\"\u003eWe will create a \u003ccode\u003eTtsSession\u003c/code\u003e data class to be our ‚Äú\u003cstrong\u003etracker\u003c/strong\u003e‚Äù. It will keep track of the full text, whether we are paused, and most importantly, a bookmark of where we last stopped.\u003c/li\u003e\u003cli id=\"cb24\"\u003e\u003cstrong\u003eOn Pause:\u003c/strong\u003e We will set a flag \u003ccode\u003eisPaused = true\u003c/code\u003e in our session and then call tts.stop().\u003c/li\u003e\u003cli id=\"11a5\"\u003e\u003cstrong\u003eOn Resume:\u003c/strong\u003e We check our \u003ccode\u003eisPaused\u003c/code\u003e flag. We‚Äôll find our bookmark, chop the original text from that point, and give this \u003cem\u003enew, smaller piece of text\u003c/em\u003e to the TTS engine to speak.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"cc70\"\u003eprivate data class TtsSession(\u003cbr/\u003e    // ...\u003cbr/\u003e    var lastSpokenTextEndIndex: Int = 0,\u003cbr/\u003e    var resumeOffsetInChunk: Int = 0\u003cbr/\u003e)\u003cp\u003eclass TextToSpeechManager(...) {\u003cbr/\u003e  fun pause() {\u003cbr/\u003e      tts?.stop()\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e    fun resume() {\u003cbr/\u003e      speakCurrentChunk(fromPause = true)\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e    private fun speakCurrentChunk(fromPause: Boolean = false) {\u003cbr/\u003e        // existing code...\u003cbr/\u003e        val chunk = session.chunks[chunkIndex]\u003cbr/\u003e        val textToSpeak: String\u003cbr/\u003e        if (fromPause) {\u003cbr/\u003e            // We are resuming. Calculate the starting point within the chunk.\u003cbr/\u003e            val resumeIndex = session.lastSpokenTextEndIndex - session.chunkOffsets[chunkIndex]\u003cbr/\u003e            // Set the state for the onRangeStart listener to use.\u003cbr/\u003e            session.resumeOffsetInChunk = if (resumeIndex \u0026gt; 0) resumeIndex else 0\u003cbr/\u003e            textToSpeak = if (session.resumeOffsetInChunk \u0026lt; chunk.length) {\u003cbr/\u003e                chunk.substring(session.resumeOffsetInChunk)\u003cbr/\u003e            } else {\u003cbr/\u003e                // Paused at the very end, move to the next chunk.\u003cbr/\u003e                session.currentChunkIndex++\u003cbr/\u003e                speakCurrentChunk() // Recursive call for the next chunk\u003cbr/\u003e                return\u003cbr/\u003e            }\u003cbr/\u003e        } else {\u003cbr/\u003e            // Playing normally from the start of the chunk. Reset the offset.\u003cbr/\u003e            session.resumeOffsetInChunk = 0\u003cbr/\u003e            textToSpeak = chunk\u003cbr/\u003e        }\u003cbr/\u003e        ttsInstance.speak(textToSpeak, TextToSpeech.QUEUE_FLUSH, null, \u0026#34;chunk_${chunkIndex}\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d466\"\u003eBut wait, there‚Äôs a catch! When you resume, the \u003ccode\u003eonRangeStart()\u003c/code\u003e callback gives you indices based on the \u003cem\u003esmaller, chopped text\u003c/em\u003e. This will mess up our highlighting!\u003c/p\u003e\u003cp id=\"68b3\"\u003e\u003cstrong\u003eThe Fix:\u003c/strong\u003e Our session ‚Äútracker‚Äù must also store an offset ‚Äî the starting point of the current text chunk.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6b30\"\u003eoverride fun onRangeStart(utteranceId: String?, start: Int, end: Int, frame: Int) {\u003cbr/\u003e    val session = currentSession ?: return\u003cp\u003e    // 1. Get the offset of the current chunk within the full text.\u003cbr/\u003e    val chunkOffset = session.chunkOffsets[session.currentChunkIndex]\u003c/p\u003e\u003cp\u003e    // 2. Get the resume offset we explicitly set in speakCurrentChunk().\u003cbr/\u003e    // This is 0 for normal playback, and \u0026gt; 0 for resumed playback.\u003cbr/\u003e    val resumeOffset = session.resumeOffsetInChunk\u003c/p\u003e\u003cp\u003e    // 3. Calculate the true absolute start and end indices.\u003cbr/\u003e    // Absolute Index = (Start of Chunk) + (Start of Spoken Substring) + (Start from TTS)\u003cbr/\u003e    val absoluteStart = chunkOffset + resumeOffset + start\u003cbr/\u003e    val absoluteEnd = chunkOffset + resumeOffset + end\u003c/p\u003e\u003cp\u003e    // 4. Save our position and emit the highlight for the UI.\u003cbr/\u003e    session.lastSpokenTextEndIndex = absoluteEnd\u003cbr/\u003e    coroutineScope.launch {\u003cbr/\u003e        _highlight.emit(Pair(absoluteStart, absoluteEnd))\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"841e\"\u003eWith this, our pause, resume, and highlighting work together like a charm.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"bddf\"\u003eüëª Chapter 5: The ‚ÄúGhost Speaker‚Äù That Won‚Äôt Shut Up\u003c/h2\u003e\u003cp id=\"998e\"\u003eThis is a common mistake. The user leaves a screen, but the \u003ccode\u003eTextToSpeech\u003c/code\u003e keeps talking in the background. It‚Äôs annoying!\u003c/p\u003e\u003cul\u003e\u003cli id=\"64d1\"\u003e\u003cstrong\u003eApp goes to the background:\u003c/strong\u003e We can make our handler a \u003ccode\u003eLifecycleObserver\u003c/code\u003e and watch the entire app‚Äôs lifecycle using \u003ccode\u003eDefaultLifecycleObserver\u003c/code\u003e. When the app‚Äôs \u003ccode\u003eonPause()\u003c/code\u003e is called, we can automatically pause all our \u003ccode\u003eTextToSpeech\u003c/code\u003e sessions.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"bf83\"\u003eimport androidx.lifecycle.DefaultLifecycleObserver\u003cp\u003eclass TextToSpeechManager(...): DefaultLifecycleObserver {\u003cbr/\u003e  override fun onPause(owner: LifecycleOwner) {\u003cbr/\u003e        pause()\u003cbr/\u003e    }\u003cbr/\u003e    override fun onDestroy(owner: LifecycleOwner) {\u003cbr/\u003e        shutdown()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"e48c\"\u003e\u003cstrong\u003eUser navigates back:\u003c/strong\u003e We can handle the \u003ccode\u003eTextToSpeech\u003c/code\u003e to stop when the user leaves the page. We expose a simple function: \u003ccode\u003edestroy()\u003c/code\u003e to handle this. There are two ways to handle this:\u003c/li\u003e\u003cli id=\"8844\"\u003e‚Äî Using ViewModel‚Äôs \u003ccode\u003eonCleared\u003c/code\u003e method.\u003c/li\u003e\u003cli id=\"f7cf\"\u003e‚Äî Using \u003ccode\u003eDisposableEffect\u003c/code\u003e in composable.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"92e9\"\u003eDisposableEffect(Unit) {\u003cbr/\u003e    onDispose {\u003cbr/\u003e        viewModel.destroy() // like calling shutdown in TTSManager\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"2ee8\"\u003eüòâ Bonus Tips:\u003c/h2\u003e\u003cp id=\"a51b\"\u003eThere are some additional implementations we can do like tracking the current state of the TTS instance.\u003c/p\u003e\u003cp id=\"c941\"\u003eHere is the entire code for your reference:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a65f\"\u003esealed class TtsState {\u003cbr/\u003e    data object Idle : TtsState()\u003cbr/\u003e    data object Speaking : TtsState()\u003cbr/\u003e    data object Paused : TtsState()\u003cbr/\u003e}\u003cp\u003eprivate data class TtsSession(\u003cbr/\u003e    val text: String,\u003cbr/\u003e    val chunks: List\u0026lt;String\u0026gt;,\u003cbr/\u003e    val chunkOffsets: List\u0026lt;Int\u0026gt;,\u003cbr/\u003e    var currentChunkIndex: Int = 0,\u003cbr/\u003e    var lastSpokenTextEndIndex: Int = 0,\u003cbr/\u003e    var resumeOffsetInChunk: Int = 0\u003cbr/\u003e)\u003cbr/\u003eclass TextToSpeechManager(private val context: Context): DefaultLifecycleObserver {\u003cbr/\u003e    private val coroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)\u003cbr/\u003e    private var tts: TextToSpeech? = null\u003cbr/\u003e    private var currentSession: TtsSession? = null\u003cbr/\u003e    private val _state = MutableStateFlow\u0026lt;TtsState\u0026gt;(TtsState.Idle)\u003cbr/\u003e    val state: StateFlow\u0026lt;TtsState\u0026gt; = _state\u003cbr/\u003e    private val _highlight = MutableStateFlow\u0026lt;Pair\u0026lt;Int, Int\u0026gt;?\u0026gt;(null)\u003cbr/\u003e    val highlight: StateFlow\u0026lt;Pair\u0026lt;Int, Int\u0026gt;?\u0026gt; = _highlight\u003cbr/\u003e    suspend fun speak(text: String) {\u003cbr/\u003e        initialize()\u003cbr/\u003e        stop()\u003cbr/\u003e        val chunks = splitTextIntoChunks(text)\u003cbr/\u003e        val offsets = chunks.runningFold(0) { acc, chunk -\u0026gt; acc + chunk.length }.dropLast(1)\u003cbr/\u003e        currentSession = TtsSession(text, chunks, offsets)\u003cbr/\u003e        _state.value = TtsState.Speaking\u003cbr/\u003e        speakCurrentChunk()\u003cbr/\u003e    }\u003cbr/\u003e    fun pause() {\u003cbr/\u003e        if (_state.value == TtsState.Speaking) {\u003cbr/\u003e            tts?.stop()\u003cbr/\u003e            _state.value = TtsState.Paused\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    fun resume() {\u003cbr/\u003e        if (_state.value == TtsState.Paused) {\u003cbr/\u003e            _state.value = TtsState.Speaking\u003cbr/\u003e            speakCurrentChunk(fromPause = true)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    fun stop() {\u003cbr/\u003e        tts?.stop()\u003cbr/\u003e        currentSession = null\u003cbr/\u003e        _state.value = TtsState.Idle\u003cbr/\u003e        _highlight.value = null\u003cbr/\u003e    }\u003cbr/\u003e    fun shutdown() {\u003cbr/\u003e        stop()\u003cbr/\u003e        tts?.shutdown()\u003cbr/\u003e        tts = null\u003cbr/\u003e        coroutineScope.cancel()\u003cbr/\u003e    }\u003cbr/\u003e    private fun speakCurrentChunk(fromPause: Boolean = false) {\u003cbr/\u003e        val session = currentSession ?: return\u003cbr/\u003e        val ttsInstance = tts ?: return\u003cbr/\u003e        val chunkIndex = session.currentChunkIndex\u003cbr/\u003e        if (chunkIndex \u0026gt;= session.chunks.size) {\u003cbr/\u003e            stop()\u003cbr/\u003e            return\u003cbr/\u003e        }\u003cbr/\u003e        val chunk = session.chunks[chunkIndex]\u003cbr/\u003e        val textToSpeak: String\u003cbr/\u003e        if (fromPause) {\u003cbr/\u003e            val resumeIndex = session.lastSpokenTextEndIndex - session.chunkOffsets[chunkIndex]\u003cbr/\u003e            session.resumeOffsetInChunk = if (resumeIndex \u0026gt; 0) resumeIndex else 0\u003cbr/\u003e            textToSpeak = if (session.resumeOffsetInChunk \u0026lt; chunk.length) {\u003cbr/\u003e                chunk.substring(session.resumeOffsetInChunk)\u003cbr/\u003e            } else {\u003cbr/\u003e                session.currentChunkIndex++\u003cbr/\u003e                speakCurrentChunk()\u003cbr/\u003e                return\u003cbr/\u003e            }\u003cbr/\u003e        } else {\u003cbr/\u003e            session.resumeOffsetInChunk = 0\u003cbr/\u003e            textToSpeak = chunk\u003cbr/\u003e        }\u003cbr/\u003e        ttsInstance.speak(textToSpeak, TextToSpeech.QUEUE_FLUSH, null, \u0026#34;chunk_${chunkIndex}\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    private suspend fun initialize() {\u003cbr/\u003e        if (tts != null) return\u003cbr/\u003e        tts = suspendCancellableCoroutine { continuation -\u0026gt;\u003cbr/\u003e            var ttsInstance: TextToSpeech? = null\u003cbr/\u003e            val listener = TextToSpeech.OnInitListener { status -\u0026gt;\u003cbr/\u003e                if (status == TextToSpeech.SUCCESS) {\u003cbr/\u003e                    ttsInstance?.let {\u003cbr/\u003e                        it.setOnUtteranceProgressListener(createProgressListener())\u003cbr/\u003e                        if (continuation.isActive) {\u003cbr/\u003e                            continuation.resume(it)\u003cbr/\u003e                        }\u003cbr/\u003e                    }\u003cbr/\u003e                } else {\u003cbr/\u003e                    if (continuation.isActive) {\u003cbr/\u003e                        continuation.resumeWithException(Exception(\u0026#34;Init failed.\u0026#34;))\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e            ttsInstance = TextToSpeech(context, listener)\u003cbr/\u003e            continuation.invokeOnCancellation {\u003cbr/\u003e                ttsInstance.shutdown()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    private fun createProgressListener() = object : UtteranceProgressListener() {\u003cbr/\u003e        override fun onStart(utteranceId: String?) {}\u003cbr/\u003e        override fun onError(utteranceId: String?) { stop() }\u003cbr/\u003e        override fun onDone(utteranceId: String?) {\u003cbr/\u003e            if (_state.value == TtsState.Speaking) {\u003cbr/\u003e                currentSession?.let {\u003cbr/\u003e                    it.currentChunkIndex++\u003cbr/\u003e                    speakCurrentChunk()\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        override fun onRangeStart(utteranceId: String?, start: Int, end: Int, frame: Int) {\u003cbr/\u003e            val session = currentSession ?: return\u003cbr/\u003e       val chunkOffset = session.chunkOffsets[session.currentChunkIndex]\u003cbr/\u003e            val resumeOffset = session.resumeOffsetInChunk\u003cbr/\u003e            val absoluteStart = chunkOffset + resumeOffset + start\u003cbr/\u003e            val absoluteEnd = chunkOffset + resumeOffset + end\u003cbr/\u003e            session.lastSpokenTextEndIndex = absoluteEnd\u003cbr/\u003e            coroutineScope.launch {\u003cbr/\u003e                _highlight.emit(Pair(absoluteStart, absoluteEnd))\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    companion object {\u003cbr/\u003e        private const val TTS_CHUNK_SIZE_LIMIT = 3000\u003cbr/\u003e        private fun splitTextIntoChunks(text: String): List\u0026lt;String\u0026gt; {\u003cbr/\u003e            if (text.length \u0026lt;= TTS_CHUNK_SIZE_LIMIT) {\u003cbr/\u003e                return listOf(text)\u003cbr/\u003e            }\u003cbr/\u003e            val chunks = mutableListOf\u0026lt;String\u0026gt;()\u003cbr/\u003e            var remainingText = text\u003cbr/\u003e            while (remainingText.isNotEmpty()) {\u003cbr/\u003e                if (remainingText.length \u0026lt;= TTS_CHUNK_SIZE_LIMIT) {\u003cbr/\u003e                    chunks.add(remainingText)\u003cbr/\u003e                    break\u003cbr/\u003e                }\u003cbr/\u003e                val potentialChunk = remainingText.substring(0, TTS_CHUNK_SIZE_LIMIT)\u003cbr/\u003e                var splitIndex = potentialChunk.lastIndexOfAny(charArrayOf(\u0026#39;.\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;?\u0026#39;))\u003cbr/\u003e                if (splitIndex == -1) {\u003cbr/\u003e                    splitIndex = potentialChunk.lastIndexOf(\u0026#39; \u0026#39;)\u003cbr/\u003e                }\u003cbr/\u003e                if (splitIndex == -1) {\u003cbr/\u003e                    splitIndex = TTS_CHUNK_SIZE_LIMIT - 1\u003cbr/\u003e                }\u003cbr/\u003e                chunks.add(remainingText.substring(0, splitIndex + 1))\u003cbr/\u003e                remainingText = remainingText.substring(splitIndex + 1)\u003cbr/\u003e            }\u003cbr/\u003e            return chunks\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    override fun onPause(owner: LifecycleOwner) {\u003cbr/\u003e        if (_state.value == TtsState.Speaking) {\u003cbr/\u003e            pause()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    override fun onDestroy(owner: LifecycleOwner) {\u003cbr/\u003e        shutdown()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"70ea\"\u003eHere is the sample compose UI:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5a79\"\u003e@Composable\u003cbr/\u003efun RecipeReaderScreen() {\u003cbr/\u003e    val context = LocalContext.current\u003cbr/\u003e    val lifecycleOwner = androidx.lifecycle.compose.LocalLifecycleOwner.current\u003cp\u003e    // Remember the manager across recompositions\u003cbr/\u003e    val ttsManager = remember { TextToSpeechManager(context) }\u003cbr/\u003e    // Clean up the manager when the composable leaves the screen\u003cbr/\u003e    DisposableEffect(lifecycleOwner) {\u003cbr/\u003e        onDispose {\u003cbr/\u003e            ttsManager.shutdown()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    DisposableEffect(lifecycleOwner) {\u003cbr/\u003e        // When the Composable enters the composition, add the observer.\u003cbr/\u003e        lifecycleOwner.lifecycle.addObserver(ttsManager)\u003cbr/\u003e        // When the Composable leaves the composition, remove the observer.\u003cbr/\u003e        // This is also where the manager\u0026#39;s onDestroy will be called,\u003cbr/\u003e        // which in turn calls shutdown(), cleaning up all resources.\u003cbr/\u003e        onDispose {\u003cbr/\u003e            lifecycleOwner.lifecycle.removeObserver(ttsManager)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    val recipeText = \u0026#34;First, preheat the oven to 180 degrees Celsius. \u0026#34; +\u003cbr/\u003e            \u0026#34;While it heats, whisk together the flour, sugar, and cocoa powder in a large bowl. \u0026#34; +\u003cbr/\u003e            \u0026#34;Slowly mix in the eggs and milk until the batter is smooth. \u0026#34; +\u003cbr/\u003e            \u0026#34;Finally, pour the batter into a greased baking pan and bake for 30 minutes. Enjoy your delicious cake!\u0026#34;\u003cbr/\u003e    // Collect states from our manager to drive the UI\u003cbr/\u003e    val ttsState by ttsManager.state.collectAsState()\u003cbr/\u003e    val highlight by ttsManager.highlight.collectAsState()\u003cbr/\u003e    val coroutineScope = rememberCoroutineScope()\u003cbr/\u003e    // Create the annotated string for highlighting text\u003cbr/\u003e    val annotatedText = buildAnnotatedString {\u003cbr/\u003e        append(recipeText)\u003cbr/\u003e        highlight?.let { (start, end) -\u0026gt;\u003cbr/\u003e            if (start in recipeText.indices \u0026amp;\u0026amp; end \u0026lt;= recipeText.length \u0026amp;\u0026amp; start \u0026lt; end) {\u003cbr/\u003e                addStyle(\u003cbr/\u003e                    style = SpanStyle(\u003cbr/\u003e                        fontWeight = FontWeight.ExtraBold,\u003cbr/\u003e                        background = Color(0xFFFFF59D) // A pleasant yellow\u003cbr/\u003e                    ),\u003cbr/\u003e                    start = start,\u003cbr/\u003e                    end = end\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    Column(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e            .padding(16.dp),\u003cbr/\u003e        horizontalAlignment = Alignment.CenterHorizontally\u003cbr/\u003e    ) {\u003cbr/\u003e        Text(\u003cbr/\u003e            text = \u0026#34;Chocolate Lava Cake Recipe\u0026#34;,\u003cbr/\u003e            style = MaterialTheme.typography.headlineMedium,\u003cbr/\u003e            modifier = Modifier.padding(bottom = 16.dp)\u003cbr/\u003e        )\u003cbr/\u003e        Card(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .fillMaxWidth()\u003cbr/\u003e                .weight(1f),\u003cbr/\u003e            elevation = CardDefaults.cardElevation(4.dp)\u003cbr/\u003e        ) {\u003cbr/\u003e            Text(\u003cbr/\u003e                text = annotatedText,\u003cbr/\u003e                style = MaterialTheme.typography.bodyMedium,\u003cbr/\u003e                modifier = Modifier.padding(16.dp)\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e        Spacer(modifier = Modifier.height(24.dp))\u003cbr/\u003e        Row(\u003cbr/\u003e            horizontalArrangement = Arrangement.Center,\u003cbr/\u003e            modifier = Modifier.fillMaxWidth()\u003cbr/\u003e        ) {\u003cbr/\u003e            // The main Play/Pause/Resume Button\u003cbr/\u003e            Button(\u003cbr/\u003e                onClick = {\u003cbr/\u003e                    when (ttsState) {\u003cbr/\u003e                        TtsState.Idle -\u0026gt; {\u003cbr/\u003e                            coroutineScope.launch { ttsManager.speak(recipeText) }\u003cbr/\u003e                        }\u003cbr/\u003e                        TtsState.Paused -\u0026gt; {\u003cbr/\u003e                            ttsManager.resume()\u003cbr/\u003e                        }\u003cbr/\u003e                        TtsState.Speaking -\u0026gt; {\u003cbr/\u003e                            ttsManager.pause()\u003cbr/\u003e                        }\u003cbr/\u003e                    }\u003cbr/\u003e                },\u003cbr/\u003e                modifier = Modifier.height(48.dp)\u003cbr/\u003e            ) {\u003cbr/\u003e                val buttonText = when(ttsState) {\u003cbr/\u003e                    TtsState.Idle -\u0026gt; \u0026#34;Read Recipe\u0026#34;\u003cbr/\u003e                    TtsState.Speaking -\u0026gt; \u0026#34;Pause\u0026#34;\u003cbr/\u003e                    TtsState.Paused -\u0026gt; \u0026#34;Resume\u0026#34;\u003cbr/\u003e                }\u003cbr/\u003e                Text(buttonText)\u003cbr/\u003e            }\u003cbr/\u003e            Spacer(modifier = Modifier.width(16.dp))\u003cbr/\u003e            // The Stop Button\u003cbr/\u003e            Button(\u003cbr/\u003e                onClick = { ttsManager.stop() },\u003cbr/\u003e                enabled = ttsState != TtsState.Idle,\u003cbr/\u003e                modifier = Modifier.height(48.dp),\u003cbr/\u003e                colors = ButtonDefaults.buttonColors(\u003cbr/\u003e                    containerColor = MaterialTheme.colorScheme.error,\u003cbr/\u003e                    contentColor = Color.White\u003cbr/\u003e                )\u003cbr/\u003e            ) {\u003cbr/\u003e                Text(\u0026#34;Stop\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"10a2\"\u003eIf you run the app, you will see something like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7537\"\u003eIn the video sample, I have demonstrated the \u003cstrong\u003eSpeak\u003c/strong\u003e, \u003cstrong\u003ePause\u003c/strong\u003e, \u003cstrong\u003eResume\u003c/strong\u003e and \u003cstrong\u003eHightlight\u003c/strong\u003e functionality. Due to image limitation in Medium.com, audio will not be hearable in the video (GIF Image).\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e51b\"\u003eüß† Conclusion:\u003c/h2\u003e\u003cp id=\"b309\"\u003eAnd there we have it! We started with a simple, buggy piece of code and tackled every problem one by one. Our final \u003ccode\u003eTextToSpeech\u003c/code\u003e handler is now a thing of beauty:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b592\"\u003eIt waits patiently for the engine to be ready.\u003c/li\u003e\u003cli id=\"2966\"\u003eIt highlights words beautifully.\u003c/li\u003e\u003cli id=\"da98\"\u003eIt handles Pause and Resume like a pro.\u003c/li\u003e\u003cli id=\"c8b2\"\u003eIt doesn‚Äôt choke on large texts.\u003c/li\u003e\u003cli id=\"8a39\"\u003eIt behaves itself when the user leaves the app or the screen.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"8a11\"\u003eüí¨ Let‚Äôs Talk\u003c/h2\u003e\u003cp id=\"8601\"\u003eHave you tried building your Text To Speech? Have you handled any additional features? Or have you handled it in better way?‚Äî I‚Äôd love to hear from you!\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9479\"\u003eüìö My Articles:\u003c/h2\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "28 min read",
  "publishedTime": "2025-07-04T20:27:48.423Z",
  "modifiedTime": null
}
