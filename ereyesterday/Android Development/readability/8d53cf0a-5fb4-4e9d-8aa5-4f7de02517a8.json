{
  "id": "8d53cf0a-5fb4-4e9d-8aa5-4f7de02517a8",
  "title": "Koin’s Isolated Context",
  "link": "https://proandroiddev.com/koins-isolated-context-803e8047b358?source=rss----c72404660798---4",
  "description": "",
  "author": "Stefano Natali",
  "published": "Mon, 09 Dec 2024 14:42:44 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "kotlin",
    "koin",
    "androiddev",
    "android"
  ],
  "byline": "Stefano Natali",
  "length": 6945,
  "excerpt": "Dependency Injection is an essential aspect of modern Android development, and Koin has earned its place as one of the most developer-friendly libraries for this purpose. I’ve previously shared my…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Create a separate dependency injection container for your libraries and SDKsGenerated by Leonardo.AIDependency Injection is an essential aspect of modern Android development, and Koin has earned its place as one of the most developer-friendly libraries for this purpose. I’ve previously shared my thoughts on Koin in this article, which you can check out if you’re looking for an introduction.Among Koin’s many features, Isolated Context stands out as a powerful tool for creating independent dependency graphs. It is perfect in scenarios like building modular libraries or SDKs, where a completely separate DI setup is crucial.In this article, I’ll delve into what Isolated Context is, how it works, and how it can be applied and tested to design fully independent modules.What is Koin’s Isolated Context?Koin’s Isolated Context allows you to define a completely independent DI graph that operates separately from your main application’s modules configuration. This feature is invaluable when you need temporary or isolated setups without interfering with the primary DI environment.It plays a crucial role in supporting modular applications, enabling you to run isolated modules within specific contexts.For example, imagine you’re building a library that uses Koin internally for its dependency management. If the main application also uses Koin, you face two options:The dirty way: Document your library’s modules and instruct developers to include them in the main app’s Koin initialization.The better way: Use Context Isolation to create a completely independent instance of Koin, managing all objects for your library without affecting the main application’s setup.By choosing the second approach, you ensure clean separation, improved modularity, and reduced risk of conflicts between dependency graphs.Setting Up Koin’s Isolated ContextTo get started, let’s assume your library already includes a Koin instance (if you’re unfamiliar with setting up Koin, I recommend checking out my previous article for a quick introduction).The first step is to create an object class that will maintain your isolated context instance. This class should be a singleton, ensuring it remains accessible throughout the entire lifecycle of your library.Here’s how you can define it:object MyIsolatedKoinContext { val koinApp = koinApplication { modules(myModule) } val koin = koinApp.koin}In this setup:koinApp is the Koin application instance that initializes with the provided modules.koin is the Koin instance, which will be used to resolve dependencies within your library.You can define the modules (myModule) just as you normally would in Koin. There’s no special syntax or additional requirements for isolated contexts, they work seamlessly with the familiar Koin module definitions.Using the Isolated Koin Context in ComposeLet’s see how to integrate MyIsolatedKoinContext into a Jetpack Compose environment.The process is straightforward. Instead of relying on KoinAndroidContext, you can directly inject your isolated Koin context into the Compose hierarchy after calling setContent. Here’s how it looks:setContent { KoinIsolatedContext(context = MyIsolatedKoinContext.koinApp) { // Your Compose content here }}By doing this, all your Compose content will automatically use the isolated Koin context defined in MyIsolatedKoinContext.This approach is not only simple but also powerful. With just one line of code, you gain the flexibility to switch Koin contexts without altering any of your existing Compose functions. It keeps your implementation clean and ensures the modularity of your app or library.Using the Isolated Koin Context in Other ClassesNow that we’ve defined MyIsolatedKoinContext and used it in the Compose environment, let’s address how to handle other classes that rely on Koin.For instance, you might already have something like this:class Example : KoinComponent { // Existing Koin usage}To ensure these classes use the isolated context instead of the default one, we’ll create our own implementation of KoinComponent that leverages the isolated Koin instance. This is simple to achieve with an abstract class:abstract class IsolatedKoinComponent : KoinComponent { // Override the default Koin instance override fun getKoin(): Koin = MyIsolatedKoinContext.koin}This abstract class overrides the getKoin method to return the isolated context from MyIsolatedKoinContext. Now, you can replace all occurrences of KoinComponent in your code with IsolatedKoinComponent.Your updated code would look like this:class Example : IsolatedKoinComponent { // Uses the isolated Koin context}That’s it! Once again, this highlights the simplicity of Koin. With a small change in your class definition, you seamlessly switch to the new isolated context without needing to modify the actual logic inside your classes.TestingTesting with Koin is straightforward, as I discussed in my previous article. However, when dealing with complex cases , such as testing classes that use inject directly in their implementation, you can override the getKoin function in your test class to use the isolated context.Here’s an example:class MyClassTest : KoinTest { // Override the default Koin instance with the isolated context override fun getKoin(): Koin = MyIsolatedKoinContext.koin @Before fun setUp() { val testModule = module { // Define your test-specific dependencies here } koin.loadModules(listOf(testModule)) }}With this approach, you can easily define custom modules for your tests, including mock implementations of your dependencies. This setup ensures that your tests are isolated and do not interfere with the main application’s DI graph.ConclusionKoin’s Isolated Context is a game-changer for modular and independent development in Android. It empowers developers to create standalone dependency injection setups for libraries and SDKs, ensuring clean separation and minimal interference with the main application’s DI configuration.Throughout this article, we’ve explored how to set up and use an isolated context effectively whether in Compose, other classes, or even in tests. By adopting this approach, you can achieve a more modular architecture, simplify the integration process, and provide a better experience for both developers and users of your libraries or SDKs.Koin continues to demonstrate its developer-friendly nature with features like Isolated Context, allowing for flexible and robust DI solutions. As you implement this in your projects, you’ll likely find it an invaluable tool in your Android development toolkit.If you found this article interesting, feel free to follow me for more insightful content on Android development and Jetpack Compose. I regularly publish new articles on these topics. Don’t hesitate to share your comments or reach out to me on Bluesky or LinkedIn for further discussions.Have a great day, and happy coding!",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*4sFAijAeYR-RLimXptxwxw.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"be35\"\u003eCreate a separate dependency injection container for your libraries and SDKs\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@stefanoq21?source=post_page---byline--803e8047b358--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Stefano Natali\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*nJT9nmRwE28kmJAEiRyHMw.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--803e8047b358--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eGenerated by Leonardo.AI\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"05e0\"\u003e\u003cstrong\u003eDependency Injection\u003c/strong\u003e is an essential aspect of modern Android development, and \u003cstrong\u003eKoin\u003c/strong\u003e has earned its place as one of the most developer-friendly libraries for this purpose. I’ve previously shared my thoughts on Koin in \u003ca href=\"https://medium.com/proandroiddev/koin-my-favorite-dependency-injection-library-for-android-776db4d455c8\" rel=\"noopener\"\u003e\u003cstrong\u003ethis article\u003c/strong\u003e\u003c/a\u003e, which you can check out if you’re looking for an introduction.\u003c/p\u003e\u003cp id=\"2aca\"\u003eAmong Koin’s many features, \u003cstrong\u003eIsolated Context\u003c/strong\u003e stands out as a powerful tool for creating independent dependency graphs. It is perfect in scenarios like building modular libraries or SDKs, where a completely separate DI setup is crucial.\u003c/p\u003e\u003cp id=\"f1b9\"\u003eIn this article, I’ll delve into what Isolated Context is, how it works, and how it can be applied and tested to design fully independent modules.\u003c/p\u003e\u003ch2 id=\"b291\"\u003eWhat is Koin’s Isolated Context?\u003c/h2\u003e\u003cp id=\"ed6d\"\u003eKoin’s \u003cstrong\u003eIsolated Context\u003c/strong\u003e allows you to define a completely independent DI graph that operates separately from your main application’s modules configuration. This feature is invaluable when you need temporary or isolated setups without interfering with the primary DI environment.\u003c/p\u003e\u003cp id=\"f39f\"\u003eIt plays a crucial role in supporting \u003cstrong\u003emodular applications\u003c/strong\u003e, enabling you to run isolated modules within specific contexts.\u003c/p\u003e\u003cp id=\"3e1f\"\u003eFor example, imagine you’re building a library that uses Koin internally for its dependency management. If the main application also uses Koin, you face two options:\u003c/p\u003e\u003col\u003e\u003cli id=\"606e\"\u003e\u003cstrong\u003e\u003cem\u003eThe dirty way\u003c/em\u003e\u003c/strong\u003e: Document your library’s modules and instruct developers to include them in the main app’s Koin initialization.\u003c/li\u003e\u003cli id=\"ee42\"\u003e\u003cstrong\u003e\u003cem\u003eThe better way\u003c/em\u003e\u003c/strong\u003e: Use \u003cstrong\u003eContext Isolation\u003c/strong\u003e to create a completely independent instance of Koin, managing all objects for your library without affecting the main application’s setup.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"e2d7\"\u003eBy choosing the second approach, you ensure clean separation, improved modularity, and reduced risk of conflicts between dependency graphs.\u003c/p\u003e\u003ch2 id=\"210e\"\u003eSetting Up Koin’s Isolated Context\u003c/h2\u003e\u003cp id=\"107c\"\u003eTo get started, let’s assume your library already includes a Koin instance (if you’re unfamiliar with setting up Koin, I recommend checking out \u003ca href=\"https://medium.com/proandroiddev/koin-my-favorite-dependency-injection-library-for-android-776db4d455c8\" rel=\"noopener\"\u003e\u003cstrong\u003emy previous article\u003c/strong\u003e\u003c/a\u003e for a quick introduction).\u003c/p\u003e\u003cp id=\"3ed6\"\u003eThe first step is to create an \u003cstrong\u003eobject \u003c/strong\u003eclass that will maintain your isolated context instance. This class should be a \u003cstrong\u003esingleton\u003c/strong\u003e, ensuring it remains accessible throughout the entire lifecycle of your library.\u003c/p\u003e\u003cp id=\"50f3\"\u003eHere’s how you can define it:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"09f2\"\u003eobject MyIsolatedKoinContext {\u003cp\u003e    val koinApp = koinApplication {\u003cbr/\u003e        modules(myModule)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    val koin = koinApp.koin\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8bfc\"\u003eIn this setup:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a502\"\u003e\u003cstrong\u003ekoinApp \u003c/strong\u003eis the Koin application instance that initializes with the provided modules.\u003c/li\u003e\u003cli id=\"8e9d\"\u003e\u003cstrong\u003ekoin \u003c/strong\u003eis the Koin instance, which will be used to resolve dependencies within your library.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ac13\"\u003eYou can define the modules (\u003cstrong\u003emyModule\u003c/strong\u003e) just as you normally would in Koin. There’s no special syntax or additional requirements for isolated contexts, they work seamlessly with the familiar Koin module definitions.\u003c/p\u003e\u003ch2 id=\"b7a3\"\u003eUsing the Isolated Koin Context in Compose\u003c/h2\u003e\u003cp id=\"a0e0\"\u003eLet’s see how to integrate \u003cstrong\u003eMyIsolatedKoinContext \u003c/strong\u003einto a \u003cstrong\u003eJetpack Compose\u003c/strong\u003e environment.\u003c/p\u003e\u003cp id=\"98f4\"\u003eThe process is straightforward. Instead of relying on \u003cstrong\u003eKoinAndroidContext\u003c/strong\u003e, you can directly inject your isolated Koin context into the Compose hierarchy after calling \u003cstrong\u003esetContent\u003c/strong\u003e. Here’s how it looks:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d612\"\u003esetContent {\u003cbr/\u003e  KoinIsolatedContext(context = MyIsolatedKoinContext.koinApp) {\u003cbr/\u003e    // Your Compose content here\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dc01\"\u003eBy doing this, all your Compose content will automatically use the isolated Koin context defined in \u003cstrong\u003eMyIsolatedKoinContext\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"e4b5\"\u003eThis approach is not only simple but also powerful. With just one line of code, you gain the flexibility to switch Koin contexts without altering any of your existing Compose functions. It keeps your implementation clean and ensures the modularity of your app or library.\u003c/p\u003e\u003ch2 id=\"309b\"\u003eUsing the Isolated Koin Context in Other Classes\u003c/h2\u003e\u003cp id=\"2d37\"\u003eNow that we’ve defined \u003cstrong\u003eMyIsolatedKoinContext\u003c/strong\u003e and used it in the Compose environment, let’s address how to handle other classes that rely on \u003cstrong\u003eKoin\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"d498\"\u003eFor instance, you might already have something like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"25e7\"\u003eclass Example : KoinComponent {\u003cbr/\u003e    // Existing Koin usage\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"76c1\"\u003eTo ensure these classes use the isolated context instead of the default one, we’ll create our own implementation of \u003cstrong\u003eKoinComponent \u003c/strong\u003ethat leverages the isolated Koin instance. This is simple to achieve with an abstract class:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"07d3\"\u003eabstract class IsolatedKoinComponent : KoinComponent {\u003cp\u003e    // Override the default Koin instance\u003cbr/\u003e    override fun getKoin(): Koin = MyIsolatedKoinContext.koin\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"48a7\"\u003eThis abstract class overrides the \u003cstrong\u003egetKoin \u003c/strong\u003emethod to return the isolated context from \u003cstrong\u003eMyIsolatedKoinContext\u003c/strong\u003e. Now, you can replace all occurrences of \u003cstrong\u003eKoinComponent \u003c/strong\u003ein your code with \u003cstrong\u003eIsolatedKoinComponent\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"0a7a\"\u003eYour updated code would look like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f7a9\"\u003eclass Example : IsolatedKoinComponent {\u003cbr/\u003e    // Uses the isolated Koin context\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cbac\"\u003eThat’s it! Once again, this highlights the simplicity of Koin. With a small change in your class definition, you seamlessly switch to the new isolated context without needing to modify the actual logic inside your classes.\u003c/p\u003e\u003ch2 id=\"9ab1\"\u003eTesting\u003c/h2\u003e\u003cp id=\"2f45\"\u003eTesting with Koin is straightforward, as I discussed in \u003ca href=\"https://medium.com/proandroiddev/koin-my-favorite-dependency-injection-library-for-android-776db4d455c8\" rel=\"noopener\"\u003e\u003cstrong\u003emy previous article\u003c/strong\u003e\u003c/a\u003e. However, when dealing with complex cases , such as testing classes that use \u003cstrong\u003einject \u003c/strong\u003edirectly in their implementation, you can override the \u003cstrong\u003egetKoin \u003c/strong\u003efunction in your test class to use the isolated context.\u003c/p\u003e\u003cp id=\"5fcc\"\u003eHere’s an example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"41e5\"\u003eclass MyClassTest : KoinTest {\u003cp\u003e    // Override the default Koin instance with the isolated context\u003cbr/\u003e    override fun getKoin(): Koin = MyIsolatedKoinContext.koin\u003c/p\u003e\u003cp\u003e    @Before\u003cbr/\u003e    fun setUp() {\u003cbr/\u003e        val testModule = module {\u003cbr/\u003e            // Define your test-specific dependencies here\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        koin.loadModules(listOf(testModule))\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1aca\"\u003eWith this approach, you can easily define custom modules for your tests, including \u003cstrong\u003emock \u003c/strong\u003eimplementations of your dependencies. This setup ensures that your tests are isolated and do not interfere with the main application’s DI graph.\u003c/p\u003e\u003ch2 id=\"277f\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"6fcb\"\u003eKoin’s \u003cstrong\u003eIsolated Context\u003c/strong\u003e is a game-changer for modular and independent development in Android. It empowers developers to create standalone dependency injection setups for libraries and SDKs, ensuring clean separation and minimal interference with the main application’s DI configuration.\u003c/p\u003e\u003cp id=\"84d3\"\u003eThroughout this article, we’ve explored how to set up and use an isolated context effectively whether in Compose, other classes, or even in tests. By adopting this approach, you can achieve a more modular architecture, simplify the integration process, and provide a better experience for both developers and users of your libraries or SDKs.\u003c/p\u003e\u003cp id=\"a64b\"\u003e\u003cstrong\u003eKoin \u003c/strong\u003econtinues to demonstrate its developer-friendly nature with features like Isolated Context, allowing for flexible and robust DI solutions. As you implement this in your projects, you’ll likely find it an invaluable tool in your Android development toolkit.\u003c/p\u003e\u003cp id=\"f28c\"\u003eIf you found this article interesting, feel free to follow me for more insightful content on Android development and Jetpack Compose. I regularly publish new articles on these topics. Don’t hesitate to share your comments or reach out to me on \u003ca href=\"https://bsky.app/profile/stefanoq21.bsky.social\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eBluesky\u003c/strong\u003e\u003c/a\u003e or \u003ca href=\"http://www.linkedin.com/in/stefano-natali-q21\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLinkedIn\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e \u003c/strong\u003efor further discussions.\u003c/p\u003e\u003cp id=\"35a0\"\u003eHave a great day, and happy coding!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-12-07T12:24:31.701Z",
  "modifiedTime": null
}
