{
  "id": "d9c964c1-ad32-418b-abe0-4dd5daffec54",
  "title": "Write Testable Time-Dependent Coroutine Code in Kotlin: Avoid System.currentTimeMillis",
  "link": "https://proandroiddev.com/write-testable-time-dependent-coroutine-code-in-kotlin-avoid-system-currenttimemillis-fb9b7eb1ddf9?source=rss----c72404660798---4",
  "description": "",
  "author": "Omar Sahl",
  "published": "Thu, 03 Apr 2025 21:42:17 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "programming",
    "android",
    "time",
    "testing"
  ],
  "byline": "Omar Sahl",
  "length": 11490,
  "excerpt": "Write testable, time-dependent coroutine code in Kotlin by replacing System.currentTimeMillis() with a TestCoroutineScheduler-based time source.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Photo by JÃ¡nos VenczÃ¡k on UnsplashWhenever we need to access the current time in Kotlin, one of the simplest approaches that comes to mind is using the System.currentTimeMillis() function. Itâ€™s straightforward, it returns the number of milliseconds since the Unix epoch (1970â€“01â€“01T00:00:00Z). However, when it comes to writing testable code, relying on this function can be problematic.A key aspect of testable code is the ability to run it in a fully controlled environment â€” and time is no exception. If your code depends on the passage of time, you need a way to manage and control it during tests.So, whatâ€™s the problem with System.currentTimeMillis()? The issue is that it retrieves the current time directly from the operating system, a value you canâ€™t easily control during testing. You can't just manipulate the OS clock to suit your test scenarios. On top of that, you also can't guarantee that the system clock won't change while your test is running, causing flaky or inconsistent results. Thatâ€™s why System.currentTimeMillis() isnâ€™t the best choice for code that you want to test reliably.To explain what I mean, letâ€™s walk through a simple example.Letâ€™s assume we have the following Cache interface:interface Cache\u003cKey\u003e { suspend fun put(key: Key, value: Any, ttl: Duration) suspend fun \u003cValue : Any\u003e get(key: Key): Value?}This interface defines two suspend functions: put, which caches a value with a supplied key and a time-to-live (ttl) that specifies when the cache entry expires, and get, which retrieves the value for a given key. If the cached value exists and is still valid (i.e. the ttl hasnâ€™t expired), it returns that value, otherwise, it returns null.Now, letâ€™s add a simple in-memory cache implementation, which weâ€™ll call SimpleCache:class SimpleCache\u003cKey\u003e : Cache\u003cKey\u003e { private val mutex = Mutex() private val entries = mutableMapOf\u003cKey, CacheEntry\u003c*\u003e\u003e() override suspend fun put(key: Key, value: Any, ttl: Duration) = mutex.withLock { val expiryTime = System.currentTimeMillis() + ttl.inWholeMilliseconds entries[key] = CacheEntry(value, expiryTime) } override suspend fun \u003cValue : Any\u003e get(key: Key): Value? = mutex.withLock { val entry = entries[key] if (entry != null \u0026\u0026 System.currentTimeMillis() \u003c entry.expiryTime) { @Suppress(\"UNCHECKED_CAST\") return entry.value as Value } invalidate(key) return null } private fun invalidate(key: Key) { entries.remove(key) } private data class CacheEntry\u003cValue\u003e(val value: Value, val expiryTime: Long)}In this implementation, SimpleCache uses a mutable map to store cached entries. The put function adds a value to the map by calculating its expiration time as the sum of System.currentTimeMillis() and the specified ttl. Similarly, the get function retrieves the value only if the current timeâ€”again retrieved via System.currentTimeMillis()â€”is still before the expiry time. If the ttl has expired, the cache entry is invalidated (removed from the map) and null is returned.The key takeaway here is how System.currentTimeMillis() is used both to determine when a cache entry should expire and to verify its validity upon retrieval.With that out of the way, letâ€™s now write a unit test to verify that our cache implementation behaves as expected.import kotlinx.coroutines.test.runTestimport kotlinx.coroutines.delayimport org.junit.Testimport kotlin.test.assertNullimport kotlin.test.assertNotNullimport kotlin.time.Duration.Companion.minutesclass SimpleCacheTest { @Test fun `cache returns expected values based on ttl`() = runTest { val key = \"my_key\" val cache = SimpleCache\u003cString\u003e() // At the start, the cache should be empty. assertNull(cache.get\u003cString\u003e(key)) // Add a value with a ttl of 5 minutes. cache.put(key, \"My Value\", 5.minutes) // Wait for 2 minutes and verify the cached value is still present. delay(2.minutes) assertNotNull(cache.get\u003cString\u003e(key)) // Wait for another 4 minutes and verify the cached value is invalidated. delay(4.minutes) assertNull(cache.get\u003cString\u003e(key)) }}So here we use runTest() from the kotlinx-coroutines-test library, it's the go-to function for testing suspend functions and coroutines.At first glance, this test seems to correctly cover the intended scenario:The cache is initially empty.A value is added with a ttl of 5 minutes.After a 2-minute delay, we expect the cache to return the value.After a further 4-minute delay (making it 6 minutes in total), the cache should have invalidated the entry and return null.However, if we run this test as-is, it will fail. The reason is that runTest skips all calls to delay, which is exactly why the test finishes immediately.When delay is called within runTest(), it gets skipped, but it also advances what's known as the virtual time. This virtual time is completely separate from the OS time that's returned by calls to System.currentTimeMillis().In other words, after calling delay(2.minutes) or delay(4.minutes), the OS time remains unchanged from the perspective of System.currentTimeMillis() (and in turn, from the perspective of SimpleCache), even though the test code is moving forward in virtual time.To illustrate this, consider the following snippet, which will print 0:runTest { val start = System.currentTimeMillis() delay(5.minutes) val end = System.currentTimeMillis() print(end - start) // This will effectively print 0.}So, to fix our unit test, we need to make SimpleCache depend on an abstraction of a time source. By swapping out this time source during tests, we can use virtual time instead of system time.Letâ€™s start by introducing a new Clock interface that represents a time source (more on this in the note at the end):fun interface Clock { /** * The number of milliseconds from the Unix epoch `1970-01-01T00:00:00Z`. */ fun now(): Long}Now, letâ€™s define the default implementation of Clock, which returns the current system time. Weâ€™ll call it SystemClock:object SystemClock : Clock { override fun now(): Long = System.currentTimeMillis()}As you can see, this implementation relies on System.currentTimeMillis().The next step is to refactor SimpleCache so that it depends on the Clock interface instead of directly using the system time. Hereâ€™s how that looks:class SimpleCache\u003cKey\u003e(private val clock: Clock = SystemClock) : Cache\u003cKey\u003e { ... override suspend fun put(key: Key, value: Any, ttl: Duration) = mutex.withLock { val expiryTime = clock.now() + ttl.inWholeMilliseconds // 1 entries[key] = CacheEntry(value, expiryTime) } override suspend fun \u003cValue : Any\u003e get(key: Key): Value? = mutex.withLock { val entry = entries[key] if (entry != null \u0026\u0026 clock.now() \u003c entry.expiryTime) { // 2 @Suppress(\"UNCHECKED_CAST\") return entry.value as Value } invalidate(key) return null } ...}Now, SimpleCache depends on the Clock interface, so we can provide any time source we want. By default, it uses system time. But in our tests, we can provide a different implementation that uses the virtual time that we can control.So, how do we access the virtual time?Well, runTest provides a special coroutine scope for testing called TestScope. This scope uses a TestDispatcher (a CoroutineDispatcher implementation), which internally relies on a TestCoroutineScheduler. That scheduler is what provides the delay-skipping behavior and manages the virtual time. Itâ€™s exactly what we need to base our test time source on.We can retrieve the current virtual time from the TestCoroutineScheduler using its currentTime property. With that, letâ€™s create a Clock implementation that uses the virtual time. Weâ€™ll call it TestClock:class TestClock(private val scheduler: TestCoroutineScheduler) : Clock { override fun now(): Long = scheduler.currentTime}To make things a bit more idiomatic, letâ€™s also create a convenience extension function on TestScope that returns a TestClock:fun TestScope.createTestClock() = TestClock(testScheduler)With that ready, letâ€™s go back to our failing test and update it to use an instance of TestClock:@Testfun `cache returns expected values based on ttl`() = runTest { val key = \"my_key\" val cache = SimpleCache\u003cString\u003e(createTestClock()) // We now use a TestClock assertNull(cache.get\u003cString\u003e(key)) cache.put(key, \"My Value\", 5.minutes) delay(2.minutes) // This advances virtual time by 2 minutes. assertNotNull(cache.get\u003cString\u003e(key)) delay(4.minutes) // This advances virtual time by 4 more minutes. assertNull(cache.get\u003cString\u003e(key))}The only change is that SimpleCache now takes an instance of TestClock, which uses virtual time instead of the system time. So when we call delay, it gets skipped, but it also advances the test clock under the hood. This allows the test to finish immediately while still simulating the correct passage of time. And because SimpleCache now uses that same virtual time, everything stays in sync and works exactly as expected.If we run the test now â€” it will pass!Now, you might have noticed that we didnâ€™t need to interact directly with TestCoroutineScheduler in our test. Thatâ€™s because delay already works well for our use case. However, in more complex scenarios, you may need finer control over coroutine dispatching and time progression. Thatâ€™s where the functions provided by TestCoroutineScheduler come into play.One such function is advanceTimeBy, which we can also use in our test. Hereâ€™s how the same test would look using it:@Testfun `cache returns expected values based on ttl`() = runTest { val key = \"my_key\" val cache = SimpleCache\u003cString\u003e(createTestClock()) assertNull(cache.get\u003cString\u003e(key)) cache.put(key, \"My Value\", 5.minutes) advanceTimeBy(2.minutes) assertNotNull(cache.get\u003cString\u003e(key)) advanceTimeBy(4.minutes) assertNull(cache.get\u003cString\u003e(key))}And with that, we now have a controllable time source that makes testing time-dependent coroutine code simple, reliable, and approachable.About the Clock InterfaceOne thing worth mentioning is that if youâ€™re already using the kotlinx-datetime library, you can use the Clock interface it provides, so there's no need to define your own.And if youâ€™re using Kotlin version 2.1.20 or later, the Clock interface has been moved into the Kotlin standard library, so you don't even need to depend on kotlinx-datetime at all. However, itâ€™s still experimental. To opt in, use the @OptIn(ExperimentalTime::class) annotation.Closing Remark:While the example used here was intentionally kept simple to demonstrate coroutine testing tools like runTest and TestCoroutineScheduler, the SimpleCache class could have been tested using a mocking framework like MockK, without needing runTest or any coroutine-specific setup at all.However, knowing these tools makes testing more complex coroutine-based code, such as when working with flows and channels, much simpler and approachable, as they offer fine-grained control over coroutine dispatching and time progression, which can be a huge help when writing reliable tests.Thatâ€™s it, thank you for reading! I hope this article has been helpful. If you have any questions or suggestions, feel free to share them in the comments below.Happy coding!If you enjoyed this article, consider giving it a clap (or 50 ðŸ˜‰) and follow me for more content on Android development. See you!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*ip1tEOlCDQnGMZDH9g-G9A.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@venczakjanos?utm_content=creditCopyText\u0026amp;utm_medium=referral\u0026amp;utm_source=unsplash\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJÃ¡nos VenczÃ¡k\u003c/a\u003e on \u003ca href=\"https://unsplash.com/photos/silver-and-black-round-analog-watch-5ZdLguSDWXM?utm_content=creditCopyText\u0026amp;utm_medium=referral\u0026amp;utm_source=unsplash\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@omarsahl?source=post_page---byline--fb9b7eb1ddf9---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Omar Sahl\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*TB_nVStV_doFD3tJYIwjsA@2x.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--fb9b7eb1ddf9---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"abe8\"\u003eWhenever we need to access the current time in Kotlin, one of the simplest approaches that comes to mind is using the \u003ccode\u003e\u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#currentTimeMillis--\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSystem.currentTimeMillis()\u003c/a\u003e\u003c/code\u003e function. Itâ€™s straightforward, it returns the number of milliseconds since the \u003ca href=\"https://en.wikipedia.org/wiki/Unix_time\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnix epoch\u003c/a\u003e (1970â€“01â€“01T00:00:00Z). However, when it comes to writing testable code, relying on this function can be problematic.\u003c/p\u003e\u003cp id=\"d150\"\u003eA key aspect of testable code is the ability to run it in a fully controlled environment â€” and time is no exception. If your code depends on the passage of time, you need a way to manage and control it during tests.\u003c/p\u003e\u003cp id=\"955b\"\u003eSo, whatâ€™s the problem with \u003ccode\u003eSystem.currentTimeMillis()\u003c/code\u003e? The issue is that it retrieves the current time directly from the operating system, a value you canâ€™t easily control during testing. You can\u0026#39;t just manipulate the OS clock to suit your test scenarios. On top of that, you also can\u0026#39;t guarantee that the system clock won\u0026#39;t change while your test is running, causing flaky or inconsistent results. Thatâ€™s why \u003ccode\u003eSystem.currentTimeMillis()\u003c/code\u003e isnâ€™t the best choice for code that you want to test reliably.\u003c/p\u003e\u003cp id=\"4dd4\"\u003eTo explain what I mean, letâ€™s walk through a simple example.\u003c/p\u003e\u003cp id=\"31f8\"\u003eLetâ€™s assume we have the following \u003ccode\u003eCache\u003c/code\u003e interface:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9e3c\"\u003einterface Cache\u0026lt;Key\u0026gt; {\u003cp\u003e    suspend fun put(key: Key, value: Any, ttl: Duration)\u003c/p\u003e\u003cp\u003e    suspend fun \u0026lt;Value : Any\u0026gt; get(key: Key): Value?\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4a5a\"\u003eThis interface defines two suspend functions: \u003ccode\u003eput\u003c/code\u003e, which caches a value with a supplied key and a time-to-live (ttl) that specifies when the cache entry expires, and \u003ccode\u003eget\u003c/code\u003e, which retrieves the value for a given key. If the cached value exists and is still valid (i.e. the ttl hasnâ€™t expired), it returns that value, otherwise, it returns \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"9ad2\"\u003eNow, letâ€™s add a simple in-memory cache implementation, which weâ€™ll call \u003ccode\u003eSimpleCache\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"80d4\"\u003eclass SimpleCache\u0026lt;Key\u0026gt; : Cache\u0026lt;Key\u0026gt; {\u003cp\u003e    private val mutex = Mutex()\u003cbr/\u003e    private val entries = mutableMapOf\u0026lt;Key, CacheEntry\u0026lt;*\u0026gt;\u0026gt;()\u003c/p\u003e\u003cp\u003e    override suspend fun put(key: Key, value: Any, ttl: Duration) = mutex.withLock {\u003cbr/\u003e        val expiryTime = System.currentTimeMillis() + ttl.inWholeMilliseconds\u003cbr/\u003e        entries[key] = CacheEntry(value, expiryTime)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override suspend fun \u0026lt;Value : Any\u0026gt; get(key: Key): Value? = mutex.withLock {\u003cbr/\u003e        val entry = entries[key]\u003cbr/\u003e        if (entry != null \u0026amp;\u0026amp; System.currentTimeMillis() \u0026lt; entry.expiryTime) {\u003cbr/\u003e            @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;)\u003cbr/\u003e            return entry.value as Value\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        invalidate(key)\u003cbr/\u003e        return null\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun invalidate(key: Key) {\u003cbr/\u003e        entries.remove(key)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private data class CacheEntry\u0026lt;Value\u0026gt;(val value: Value, val expiryTime: Long)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5404\"\u003eIn this implementation, \u003ccode\u003eSimpleCache\u003c/code\u003e uses a mutable map to store cached entries. The \u003ccode\u003eput\u003c/code\u003e function adds a value to the map by calculating its expiration time as the sum of \u003ccode\u003eSystem.currentTimeMillis()\u003c/code\u003e and the specified \u003ccode\u003ettl\u003c/code\u003e. Similarly, the \u003ccode\u003eget\u003c/code\u003e function retrieves the value only if the current timeâ€”again retrieved via \u003ccode\u003eSystem.currentTimeMillis()\u003c/code\u003eâ€”is still before the expiry time. If the \u003ccode\u003ettl\u003c/code\u003e has expired, the cache entry is invalidated (removed from the map) and \u003ccode\u003enull\u003c/code\u003e is returned.\u003c/p\u003e\u003cp id=\"f10c\"\u003eThe key takeaway here is how \u003ccode\u003eSystem.currentTimeMillis()\u003c/code\u003e is used both to determine when a cache entry should expire and to verify its validity upon retrieval.\u003c/p\u003e\u003cp id=\"419c\"\u003eWith that out of the way, letâ€™s now write a unit test to verify that our cache implementation behaves as expected.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0d10\"\u003eimport kotlinx.coroutines.test.runTest\u003cbr/\u003eimport kotlinx.coroutines.delay\u003cbr/\u003eimport org.junit.Test\u003cbr/\u003eimport kotlin.test.assertNull\u003cbr/\u003eimport kotlin.test.assertNotNull\u003cbr/\u003eimport kotlin.time.Duration.Companion.minutes\u003cp\u003eclass SimpleCacheTest {\u003c/p\u003e\u003cp\u003e    @Test\u003cbr/\u003e    fun `cache returns expected values based on ttl`() = runTest {\u003cbr/\u003e        val key = \u0026#34;my_key\u0026#34;\u003cbr/\u003e        val cache = SimpleCache\u0026lt;String\u0026gt;()\u003c/p\u003e\u003cp\u003e        // At the start, the cache should be empty.\u003cbr/\u003e        assertNull(cache.get\u0026lt;String\u0026gt;(key))\u003c/p\u003e\u003cp\u003e        // Add a value with a ttl of 5 minutes.\u003cbr/\u003e        cache.put(key, \u0026#34;My Value\u0026#34;, 5.minutes)\u003c/p\u003e\u003cp\u003e        // Wait for 2 minutes and verify the cached value is still present.\u003cbr/\u003e        delay(2.minutes)\u003cbr/\u003e        assertNotNull(cache.get\u0026lt;String\u0026gt;(key))\u003c/p\u003e\u003cp\u003e        // Wait for another 4 minutes and verify the cached value is invalidated.\u003cbr/\u003e        delay(4.minutes)\u003cbr/\u003e        assertNull(cache.get\u0026lt;String\u0026gt;(key))\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bfbe\"\u003eSo here we use \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003erunTest\u003c/a\u003e()\u003c/code\u003e from the \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlinx-coroutines-test\u003c/a\u003e\u003c/code\u003e library, it\u0026#39;s the go-to function for testing suspend functions and coroutines.\u003c/p\u003e\u003cp id=\"afcb\"\u003eAt first glance, this test seems to correctly cover the intended scenario:\u003c/p\u003e\u003col\u003e\u003cli id=\"cab1\"\u003eThe cache is initially empty.\u003c/li\u003e\u003cli id=\"851b\"\u003eA value is added with a ttl of 5 minutes.\u003c/li\u003e\u003cli id=\"e001\"\u003eAfter a 2-minute delay, we expect the cache to return the value.\u003c/li\u003e\u003cli id=\"b99d\"\u003eAfter a further 4-minute delay (making it 6 minutes in total), the cache should have invalidated the entry and return \u003ccode\u003enull\u003c/code\u003e.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"baa1\"\u003eHowever, if we run this test as-is, it will fail. The reason is that \u003ccode\u003erunTest\u003c/code\u003e \u003cstrong\u003eskips\u003c/strong\u003e all calls to \u003ccode\u003edelay\u003c/code\u003e, which is exactly why the test finishes immediately.\u003c/p\u003e\u003cp id=\"2858\"\u003eWhen \u003ccode\u003edelay\u003c/code\u003e is called within \u003ccode\u003erunTest()\u003c/code\u003e, it gets skipped, but it also advances what\u0026#39;s known as the \u003cem\u003evirtual time\u003c/em\u003e. This virtual time is completely separate from the OS time that\u0026#39;s returned by calls to \u003ccode\u003eSystem.currentTimeMillis()\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"a79b\"\u003eIn other words, after calling \u003ccode\u003edelay(2.minutes)\u003c/code\u003e or \u003ccode\u003edelay(4.minutes)\u003c/code\u003e, the OS time remains unchanged from the perspective of \u003ccode\u003eSystem.currentTimeMillis()\u003c/code\u003e (and in turn, from the perspective of \u003ccode\u003eSimpleCache\u003c/code\u003e), even though the test code is moving forward in virtual time.\u003c/p\u003e\u003cp id=\"80fa\"\u003eTo illustrate this, consider the following snippet, which will print \u003ccode\u003e0\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7689\"\u003erunTest {\u003cbr/\u003e    val start = System.currentTimeMillis()\u003cbr/\u003e    delay(5.minutes)\u003cbr/\u003e    val end = System.currentTimeMillis()\u003cbr/\u003e    print(end - start)  // This will effectively print 0.\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"88db\"\u003eSo, to fix our unit test, we need to make \u003ccode\u003eSimpleCache\u003c/code\u003e depend on an abstraction of a time source. By swapping out this time source during tests, we can use virtual time instead of system time.\u003c/p\u003e\u003cp id=\"3bff\"\u003eLetâ€™s start by introducing a new \u003ccode\u003eClock\u003c/code\u003e interface that represents a time source (more on this in the note at the end):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3bcd\"\u003efun interface Clock {\u003cp\u003e    /**\u003cbr/\u003e     * The number of milliseconds from the Unix epoch `1970-01-01T00:00:00Z`.\u003cbr/\u003e     */\u003cbr/\u003e    fun now(): Long\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3833\"\u003eNow, letâ€™s define the default implementation of \u003ccode\u003eClock\u003c/code\u003e, which returns the current system time. Weâ€™ll call it \u003ccode\u003eSystemClock\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a82c\"\u003eobject SystemClock : Clock {\u003cbr/\u003e    override fun now(): Long = System.currentTimeMillis()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3fa5\"\u003eAs you can see, this implementation relies on \u003ccode\u003eSystem.currentTimeMillis()\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"41b9\"\u003eThe next step is to refactor \u003ccode\u003eSimpleCache\u003c/code\u003e so that it depends on the \u003ccode\u003eClock\u003c/code\u003e interface instead of directly using the system time. Hereâ€™s how that looks:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a83b\"\u003eclass SimpleCache\u0026lt;Key\u0026gt;(private val clock: Clock = SystemClock) : Cache\u0026lt;Key\u0026gt; {\u003cbr/\u003e    ...\u003cbr/\u003e    override suspend fun put(key: Key, value: Any, ttl: Duration) = mutex.withLock {\u003cbr/\u003e        val expiryTime = clock.now() + ttl.inWholeMilliseconds // 1\u003cbr/\u003e        entries[key] = CacheEntry(value, expiryTime)\u003cbr/\u003e    }\u003cp\u003e    override suspend fun \u0026lt;Value : Any\u0026gt; get(key: Key): Value? = mutex.withLock {\u003cbr/\u003e        val entry = entries[key]\u003cbr/\u003e        if (entry != null \u0026amp;\u0026amp; clock.now() \u0026lt; entry.expiryTime) { // 2\u003cbr/\u003e            @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;)\u003cbr/\u003e            return entry.value as Value\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        invalidate(key)\u003cbr/\u003e        return null\u003cbr/\u003e    }\u003cbr/\u003e    ...\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ef3c\"\u003eNow, \u003ccode\u003eSimpleCache\u003c/code\u003e depends on the \u003ccode\u003eClock\u003c/code\u003e interface, so we can provide any time source we want. By default, it uses system time. But in our tests, we can provide a different implementation that uses the virtual time that we can control.\u003c/p\u003e\u003ch2 id=\"19d0\"\u003eSo, how do we access the virtual time?\u003c/h2\u003e\u003cp id=\"327d\"\u003eWell, \u003ccode\u003erunTest\u003c/code\u003e provides a special coroutine scope for testing called \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTestScope\u003c/a\u003e\u003c/code\u003e. This scope uses a \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTestDispatcher\u003c/a\u003e\u003c/code\u003e (a \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoroutineDispatcher\u003c/a\u003e\u003c/code\u003e implementation), which internally relies on a \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTestCoroutineScheduler\u003c/a\u003e\u003c/code\u003e. That scheduler is what provides the delay-skipping behavior and manages the virtual time. Itâ€™s exactly what we need to base our test time source on.\u003c/p\u003e\u003cp id=\"47d3\"\u003eWe can retrieve the current virtual time from the \u003ccode\u003eTestCoroutineScheduler\u003c/code\u003e using its \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/#1786279536%2FProperties%2F1391162071\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecurrentTime\u003c/a\u003e\u003c/code\u003e property. With that, letâ€™s create a \u003ccode\u003eClock\u003c/code\u003e implementation that uses the virtual time. Weâ€™ll call it \u003ccode\u003eTestClock\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5a93\"\u003eclass TestClock(private val scheduler: TestCoroutineScheduler) : Clock {\u003cbr/\u003e    override fun now(): Long = scheduler.currentTime\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9683\"\u003eTo make things a bit more idiomatic, letâ€™s also create a convenience extension function on \u003ccode\u003eTestScope\u003c/code\u003e that returns a \u003ccode\u003eTestClock\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ec80\"\u003efun TestScope.createTestClock() = TestClock(testScheduler)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"42ec\"\u003eWith that ready, letâ€™s go back to our failing test and update it to use an instance of \u003ccode\u003eTestClock\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7a53\"\u003e@Test\u003cbr/\u003efun `cache returns expected values based on ttl`() = runTest {\u003cbr/\u003e    val key = \u0026#34;my_key\u0026#34;\u003cbr/\u003e    val cache = SimpleCache\u0026lt;String\u0026gt;(createTestClock()) // We now use a TestClock\u003cbr/\u003e    assertNull(cache.get\u0026lt;String\u0026gt;(key))\u003cp\u003e    cache.put(key, \u0026#34;My Value\u0026#34;, 5.minutes)\u003c/p\u003e\u003cp\u003e    delay(2.minutes) // This advances virtual time by 2 minutes.\u003cbr/\u003e    assertNotNull(cache.get\u0026lt;String\u0026gt;(key))\u003c/p\u003e\u003cp\u003e    delay(4.minutes) // This advances virtual time by 4 more minutes.\u003cbr/\u003e    assertNull(cache.get\u0026lt;String\u0026gt;(key))\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f4e8\"\u003eThe only change is that \u003ccode\u003eSimpleCache\u003c/code\u003e now takes an instance of \u003ccode\u003eTestClock\u003c/code\u003e, which uses virtual time instead of the system time. So when we call \u003ccode\u003edelay\u003c/code\u003e, it gets skipped, but it also advances the test clock under the hood. This allows the test to finish immediately while still simulating the correct passage of time. And because \u003ccode\u003eSimpleCache\u003c/code\u003e now uses that same virtual time, everything stays in sync and works exactly as expected.\u003c/p\u003e\u003cp id=\"d264\"\u003eIf we run the test now â€” it will pass!\u003c/p\u003e\u003cp id=\"835b\"\u003eNow, you might have noticed that we didnâ€™t need to interact directly with \u003ccode\u003eTestCoroutineScheduler\u003c/code\u003e in our test. Thatâ€™s because \u003ccode\u003edelay\u003c/code\u003e already works well for our use case. However, in more complex scenarios, you may need finer control over coroutine dispatching and time progression. Thatâ€™s where the functions provided by \u003ccode\u003eTestCoroutineScheduler\u003c/code\u003e come into play.\u003c/p\u003e\u003cp id=\"98fe\"\u003eOne such function is \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/advance-time-by.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eadvanceTimeBy\u003c/a\u003e\u003c/code\u003e, which we can also use in our test. Hereâ€™s how the same test would look using it:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"048a\"\u003e@Test\u003cbr/\u003efun `cache returns expected values based on ttl`() = runTest {\u003cbr/\u003e    val key = \u0026#34;my_key\u0026#34;\u003cbr/\u003e    val cache = SimpleCache\u0026lt;String\u0026gt;(createTestClock())\u003cbr/\u003e    assertNull(cache.get\u0026lt;String\u0026gt;(key))\u003cp\u003e    cache.put(key, \u0026#34;My Value\u0026#34;, 5.minutes)\u003c/p\u003e\u003cp\u003e    advanceTimeBy(2.minutes)\u003cbr/\u003e    assertNotNull(cache.get\u0026lt;String\u0026gt;(key))\u003c/p\u003e\u003cp\u003e    advanceTimeBy(4.minutes)\u003cbr/\u003e    assertNull(cache.get\u0026lt;String\u0026gt;(key))\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e666\"\u003eAnd with that, we now have a controllable time source that makes testing time-dependent coroutine code simple, reliable, and approachable.\u003c/p\u003e\u003ch2 id=\"49bf\"\u003eAbout the Clock Interface\u003c/h2\u003e\u003cp id=\"d972\"\u003eOne thing worth mentioning is that if youâ€™re already using the \u003ccode\u003ekotlinx-datetime\u003c/code\u003e library, you can use the \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx-datetime/kotlinx-datetime/kotlinx.datetime/-clock/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eClock\u003c/a\u003e\u003c/code\u003e interface it provides, so there\u0026#39;s no need to define your own.\u003c/p\u003e\u003cp id=\"1f5e\"\u003eAnd if youâ€™re using Kotlin version \u003cstrong\u003e2.1.20 or later\u003c/strong\u003e, the \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.time/-clock/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eClock\u003c/a\u003e\u003c/code\u003e interface \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-72480\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehas been moved into the Kotlin standard library\u003c/a\u003e, so you don\u0026#39;t even need to depend on \u003ccode\u003ekotlinx-datetime\u003c/code\u003e at all. However, itâ€™s still experimental. To opt in, use the \u003ccode\u003e@OptIn(ExperimentalTime::class)\u003c/code\u003e annotation.\u003c/p\u003e\u003ch2 id=\"4acd\"\u003eClosing Remark:\u003c/h2\u003e\u003cp id=\"b506\"\u003eWhile the example used here was intentionally kept simple to demonstrate coroutine testing tools like \u003ccode\u003erunTest\u003c/code\u003e and \u003ccode\u003eTestCoroutineScheduler\u003c/code\u003e, the \u003ccode\u003eSimpleCache\u003c/code\u003e class could have been tested using a mocking framework like MockK, without needing \u003ccode\u003erunTest\u003c/code\u003e or any coroutine-specific setup at all.\u003c/p\u003e\u003cp id=\"e9af\"\u003eHowever, knowing these tools makes testing more complex coroutine-based code, such as when working with flows and channels, much simpler and approachable, as they offer fine-grained control over coroutine dispatching and time progression, which can be a huge help when writing reliable tests.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"e65b\"\u003eThatâ€™s it, thank you for reading! I hope this article has been helpful. If you have any questions or suggestions, feel free to share them in the comments below.\u003c/p\u003e\u003cp id=\"cca4\"\u003e\u003cstrong\u003eHappy coding!\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"4a2c\"\u003e\u003cem\u003eIf you enjoyed this article, consider giving it a clap (or 50 ðŸ˜‰) and follow me for more content on Android development. See you!\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-03-31T01:09:31.142Z",
  "modifiedTime": null
}
