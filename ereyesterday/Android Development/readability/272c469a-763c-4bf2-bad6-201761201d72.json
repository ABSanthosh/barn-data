{
  "id": "272c469a-763c-4bf2-bad6-201761201d72",
  "title": "The Evolution of Android Architecture Patterns: From UI-Centric to MVC to MVP to MVVM to MVI",
  "link": "https://proandroiddev.com/the-evolution-of-android-architecture-patterns-from-ui-centric-to-mvc-to-mvp-to-mvvm-to-mvi-ea811518ff49?source=rss----c72404660798---4",
  "description": "",
  "author": "Ioannis Anifantakis",
  "published": "Tue, 31 Dec 2024 16:41:36 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "application-architecture",
    "jetpack-compose",
    "androiddev",
    "android"
  ],
  "byline": "Ioannis Anifantakis",
  "length": 15730,
  "excerpt": "From God Activities to MVI: A journey through Android's architectural evolution, showing how each pattern solved its predecessor's limitations.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Modern Android development stands on the shoulders of many architectural patterns. Each one emerged to address problems of the previous approach, especially around coupling between UI and logic and managing state across lifecycle events. This article traces that evolution step-by-step, illustrating how Android developers moved from “everything in the Activity” to more decoupled, testable patterns.1. The Early Days: UI-Centric (God Activity)What It IsEarly Android apps often threw all logic — business logic, UI updates, and state management — into one Activity or Fragment. This was sometimes erroneously labeled “MVC,” but in practice, there was no separate Controller file. Everything lived in the same UI class, leading to “God Activities.”Example (Counter App)class MainActivity : AppCompatActivity() { private var count = 0 private lateinit var countTextView: TextView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) countTextView = findViewById(R.id.countTextView) findViewById\u003cButton\u003e(R.id.incrementButton).setOnClickListener { // Business logic + UI in the same place count++ updateView() } } private fun updateView() { countTextView.text = count.toString() }}ShortcomingsTight Coupling: The UI class owns everything — difficult to expand or test.Difficult Testing: All logic is in an Activity that depends on Android framework code.State Loss: Rotations recreate the Activity, losing the count unless you manually handle it.No Separation of Concerns: Business logic and UI code are interwoven.2. Classic MVC: Introducing a Separate ControllerWhat It IsA true or classic MVC on Android means we physically separate Model, View, and Controller classes. The Activity serves as the View, while a distinct Controller class references both the View and the Model. This is a step up from the UI-centric approach: at least we have a separate logic class.Base MVC Example (Without Loaders)// Modelclass CounterModel { private var count = 0 fun increment() { count++ } fun getCount(): Int = count}// The \"Controller\" references a concrete Activity as the Viewclass CounterController( private val view: MainActivity, // Direct link to Activity (the View) private val model: CounterModel) { fun onIncrementClicked() { model.increment() view.updateCounter(model.getCount()) }}// The Activity as \"View\"class MainActivity : AppCompatActivity() { private lateinit var controller: CounterController private lateinit var model: CounterModel private lateinit var countTextView: TextView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) countTextView = findViewById(R.id.countTextView) model = CounterModel() controller = CounterController(this, model) findViewById\u003cButton\u003e(R.id.incrementButton).setOnClickListener { controller.onIncrementClicked() } } fun updateCounter(count: Int) { countTextView.text = count.toString() }}Adding a Loader to Retain the Controller(Legacy approach: For completeness, we show how developers once handled rotation prior to ViewModel.)// 1) Create a Loader to hold the Controllerclass ControllerLoader( context: Context, private val initialView: MainActivity) : Loader\u003cCounterController\u003e(context) { private var controller: CounterController? = null override fun onStartLoading() { if (controller == null) { // Create a fresh Model and Controller the first time val model = CounterModel() controller = CounterController(initialView, model) } // Deliver the existing controller (if any) controller?.let { deliverResult(it) } }}// 2) Activity: Using the Loader to persist Controllerclass MainActivity : AppCompatActivity() { companion object { private const val LOADER_ID = 1001 } private var controller: CounterController? = null private lateinit var countTextView: TextView private val loaderCallbacks = object : LoaderManager.LoaderCallbacks\u003cCounterController\u003e { override fun onCreateLoader(id: Int, args: Bundle?): Loader\u003cCounterController\u003e { return ControllerLoader(this@MainActivity, this@MainActivity) } override fun onLoadFinished(loader: Loader\u003cCounterController\u003e, data: CounterController?) { // We have our controller (could be newly created or retained) controller = data } override fun onLoaderReset(loader: Loader\u003cCounterController\u003e) { // Called if the Loader is reset or destroyed controller = null } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) countTextView = findViewById(R.id.countTextView) // Init or reattach the Loader that holds our Controller loaderManager.initLoader(LOADER_ID, null, loaderCallbacks) findViewById\u003cButton\u003e(R.id.incrementButton).setOnClickListener { controller?.onIncrementClicked() } } fun updateCounter(count: Int) { countTextView.text = count.toString() }}How It Works:ControllerLoader is responsible for creating and holding onto the CounterController.On rotation, LoaderManager reattaches the same loader, so the same CounterController instance is retained.The result is an MVC setup that can survive rotations — albeit with extra boilerplate.Why MVC Is Still LimitedStrong Coupling: The Controller knows about MainActivity by name.Testing Challenges: The Controller depends on a real Android class (MainActivity).Loader Boilerplate: Even with Loaders, you still have more manual code to handle rotations.3. MVP: Breaking the Direct Coupling with a View InterfaceWhat It IsMVP (Model-View-Presenter) addresses the two-way coupling problem in classical MVC by introducing a View interface. The Presenter references only this interface, not the concrete Activity or Fragment. Meanwhile, the Activity implements that interface.Base MVP Example (Without Loaders)// Modelclass CounterModel { private var count = 0 fun increment() { count++ } fun getCount(): Int = count}// View Interfaceinterface CounterView { fun updateCount(count: Int) fun showError(message: String)}// Presenterclass CounterPresenter(private val model: CounterModel) { private var view: CounterView? = null fun attachView(view: CounterView) { this.view = view view.updateCount(model.getCount()) } fun detachView() { this.view = null } fun onIncrementClicked() { model.increment() view?.updateCount(model.getCount()) }}// Activity implementing the View interfaceclass MainActivity : AppCompatActivity(), CounterView { private lateinit var presenter: CounterPresenter override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) presenter = CounterPresenter(CounterModel()) presenter.attachView(this) findViewById\u003cButton\u003e(R.id.incrementButton).setOnClickListener { presenter.onIncrementClicked() } } override fun updateCount(count: Int) { findViewById\u003cTextView\u003e(R.id.countTextView).text = count.toString() } override fun showError(message: String) { Toast.makeText(this, message, Toast.LENGTH_SHORT).show() } override fun onDestroy() { super.onDestroy() presenter.detachView() }}As we have already seen how the long-deprecated Loaders historically were applied in the MVC section, there is no reason to repeat showing how the above code would adapt using Loaders.Why MVP Is Better Than Classic MVCLoose Coupling: The Presenter has no direct reference to MainActivity; it only knows CounterView.Easier Testing: You can test CounterPresenter by providing a mock or fake CounterView.Clear Contracts: The CounterView interface declares exactly what UI methods the Presenter can invoke.4. MVVM: Achieving Full UI Isolation with Reactive StreamsWhat It IsMVVM (Model-View-ViewModel) goes even further by removing “push” calls from the Presenter. Instead, the ViewModel holds data in a reactive manner (LiveData, Flow, or RxJava Observables), and the View “observes” that data. This means the ViewModel is totally UI-agnostic—it has no references to Activity or Fragment.Crucially, the arrival of ViewModel in Architecture Components removed the need for Loaders for rotation handling. The ViewModel class is inherently lifecycle-aware and survives configuration changes automatically.Jetpack Compose IntegrationJetpack Compose, a modern declarative UI toolkit, pairs naturally with MVVM. The UI “collects” or “observes” StateFlow or LiveData, and Compose re-composes automatically upon changes. This synergy helps maintain a unidirectional data flow: user events go to the ViewModel, state is updated, and Compose re-renders.Example (Using StateFlow + Jetpack Compose)// ViewModelclass CounterViewModel : ViewModel() { private val _counter = MutableStateFlow(0) val counter: StateFlow\u003cInt\u003e = _counter.asStateFlow() fun increment() { _counter.value++ }}@Composablefun CounterScreen(viewModel: CounterViewModel = viewModel()) { val count by viewModel.counter.collectAsState() Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(text = count.toString()) Button(onClick = { viewModel.increment() }) { Text(\"Increment\") } }}Key PointsNo Direct Reference to the UI: The ViewModel never calls something like activity?.updateCount().Lifecycle-Aware: The ViewModel outlives the Activity by default, eliminating the need for Loaders or retained Fragments.Completely UI-Agnostic: The UI “pulls” data changes, making the ViewModel trivial to unit test.Unidirectional Data Flow: With Compose or LiveData/Flow in XML-based apps, the user actions feed into the ViewModel, which updates state that the UI observes.Note: The introduction of ViewModel effectively replaced the need for Loaders in modern architectures, since it automatically survives configuration changes and handles state retention.Why the MVVM replaced the MVPThe MVVM approach ensures a unidirectional data flow:The UI knows about the ViewModel, but the ViewModel knows absolutely nothing about the UI.With reactive programming, the ViewModel communicates back to the View via observables (e.g., LiveData, Flow, or RxJava).Unlike iOS, where the ViewModel is often just a plain class, in Android the ViewModel inherits from the ViewModel base class, binding it to the Activity or Fragment lifecycle. This means it survives configuration changes automatically, replacing Loaders in the process.By combining lifecycle-awareness and reactive updates, MVVM eliminates the boilerplate needed for rotation handling and keeps business logic fully decoupled from the UI.5. MVI: Enforcing Unidirectional Data FlowWhat It IsMVI (Model-View-Intent) refines MVVM’s reactive model further. Every user action is an “Intent” that transforms a single “State” object. This yields high predictability — you always know how the app transitions from one state to another, with no “mystery” side updates.MVI is especially helpful in large or complex applications that benefit from a single “source of truth” and explicit state transitions. It can, however, be verbose for smaller screens.// 1) State: Single source of truth for the UIdata class CounterState( val count: Int = 0, val error: String? = null)// 2) Intents: All possible user actionssealed interface CounterIntent { object Increment : CounterIntent object Reset : CounterIntent data class SetCount(val value: Int) : CounterIntent}// 3) ViewModel in MVI styleclass CounterMviViewModel : ViewModel() { // Internal MutableStateFlow private val _state = MutableStateFlow(CounterState()) // Exposed as a read-only StateFlow val state: StateFlow\u003cCounterState\u003e = _state.asStateFlow() fun processIntent(intent: CounterIntent) { when (intent) { CounterIntent.Increment -\u003e { _state.update { it.copy(count = oldState.count+1, error = null) } } CounterIntent.Reset -\u003e { _state.update { it.copy(count=0, error = null) } } is CounterIntent.SetCount -\u003e { if (intent.value \u003e= 0) { _state.update { it.copy(count = intent.value, error = null) } } else { _state.update { it.copy(error = \"Negative counts not allowed\") } } } } }}// 4) Composable \"View\" observing the StateFlow@Composablefun CounterMviScreen(viewModel: CounterMviViewModel = viewModel()) { // Collect the current state from our MVI ViewModel val uiState by viewModel.state.collectAsState() Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text( text = uiState.count.toString(), style = MaterialTheme.typography.headlineMedium ) // Show an error if any uiState.error?.let { error -\u003e Text( text = error, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodyMedium ) } Spacer(modifier = Modifier.height(16.dp)) Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) { Button(onClick = { viewModel.processIntent(CounterIntent.Increment) }) { Text(\"Increment\") } Button(onClick = { viewModel.processIntent(CounterIntent.Reset) }) { Text(\"Reset\") } } Spacer(modifier = Modifier.height(16.dp)) // Example: Setting a specific count Button(onClick = { viewModel.processIntent(CounterIntent.SetCount(5)) }) { Text(\"Set Count to 5\") } }}Why MVI?Predictable State Changes: Each user action is formalized as an Intent, ensuring no hidden or random updates.Single Source of Truth: The entire UI state is in one CounterState data class.Perfect Fit with Jetpack Compose: Because Compose is inherently reactive and expects a unidirectional flow, MVI integrates seamlessly.ConclusionAndroid’s architectural evolution reflects a consistent push toward loose coupling, testability, and robust state management:UI-Centric lumps everything into one place (the “God Activity”), making code untestable and fragile.Classic MVC separates logic from UI but still references the Activity directly in the Controller. Loaders could help preserve logic, though it required extra boilerplate.MVP introduces a View interface, decoupling Presenter logic from the concrete UI classes; Loaders (or retained Fragments) again offered a rotation fix before ViewModel.MVVM uses lifecycle-aware ViewModels to naturally retain state, eliminating the need for Loaders. The UI observes reactive data, fully isolating business logic from UI code.MVI locks down unidirectional state changes with an Intent→State approach, ideal for complex apps where predictability is paramount.Now, most developers prefer MVVM or MVI for clean, testable, and lifecycle-friendly architecture. Regardless of which you choose, the guiding principle remains: separate your business logic from the UI to keep apps maintainable and testable.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*Zobqg1tpFCAPV9CW85LBbg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://ioannisanif.medium.com/?source=post_page---byline--ea811518ff49--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ioannis Anifantakis\" src=\"https://miro.medium.com/v2/resize:fill:88:88/2*2hbIkl_9zix1pLi8u9osuQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--ea811518ff49--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"fd9f\"\u003eModern Android development stands on the shoulders of many architectural patterns. Each one emerged to address problems of the previous approach, especially around \u003cstrong\u003ecoupling\u003c/strong\u003e between UI and logic and \u003cstrong\u003emanaging state\u003c/strong\u003e across lifecycle events. This article traces that evolution step-by-step, illustrating how Android developers moved from \u003cstrong\u003e“everything in the Activity”\u003c/strong\u003e to more decoupled, testable patterns.\u003c/p\u003e\u003ch2 id=\"9dd3\"\u003e1. The Early Days: UI-Centric (God Activity)\u003c/h2\u003e\u003ch2 id=\"7e3a\"\u003eWhat It Is\u003c/h2\u003e\u003cp id=\"2f70\"\u003eEarly Android apps often threw \u003cstrong\u003eall\u003c/strong\u003e logic — business logic, UI updates, and state management — into one \u003ccode\u003eActivity\u003c/code\u003e or \u003ccode\u003eFragment\u003c/code\u003e. This was sometimes erroneously labeled “MVC,” but in practice, there was \u003cstrong\u003eno\u003c/strong\u003e separate Controller file. Everything lived in the same UI class, leading to “God Activities.”\u003c/p\u003e\u003ch2 id=\"78ee\"\u003eExample (Counter App)\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"c559\"\u003eclass MainActivity : AppCompatActivity() {\u003cbr/\u003e    private var count = 0\u003cbr/\u003e    private lateinit var countTextView: TextView\u003cp\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContentView(R.layout.activity_main)\u003c/p\u003e\u003cp\u003e        countTextView = findViewById(R.id.countTextView)\u003c/p\u003e\u003cp\u003e        findViewById\u0026lt;Button\u0026gt;(R.id.incrementButton).setOnClickListener {\u003cbr/\u003e            // Business logic + UI in the same place\u003cbr/\u003e            count++\u003cbr/\u003e            updateView()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun updateView() {\u003cbr/\u003e        countTextView.text = count.toString()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"08a3\"\u003eShortcomings\u003c/h2\u003e\u003cul\u003e\u003cli id=\"47c3\"\u003e\u003cstrong\u003eTight Coupling\u003c/strong\u003e: The UI class owns everything — difficult to expand or test.\u003c/li\u003e\u003cli id=\"0f71\"\u003e\u003cstrong\u003eDifficult Testing\u003c/strong\u003e: All logic is in an \u003ccode\u003eActivity\u003c/code\u003e that depends on Android framework code.\u003c/li\u003e\u003cli id=\"0316\"\u003e\u003cstrong\u003eState Loss\u003c/strong\u003e: Rotations recreate the \u003ccode\u003eActivity\u003c/code\u003e, losing the \u003ccode\u003ecount\u003c/code\u003e unless you manually handle it.\u003c/li\u003e\u003cli id=\"97b4\"\u003e\u003cstrong\u003eNo Separation of Concerns\u003c/strong\u003e: Business logic and UI code are interwoven.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"27a4\"\u003e2. Classic MVC: Introducing a Separate Controller\u003c/h2\u003e\u003ch2 id=\"130a\"\u003eWhat It Is\u003c/h2\u003e\u003cp id=\"1db0\"\u003eA \u003cstrong\u003etrue\u003c/strong\u003e or \u003cstrong\u003eclassic\u003c/strong\u003e MVC on Android means we physically separate \u003cstrong\u003eModel\u003c/strong\u003e, \u003cstrong\u003eView\u003c/strong\u003e, and \u003cstrong\u003eController\u003c/strong\u003e classes. The \u003ccode\u003eActivity\u003c/code\u003e serves as the View, while a distinct \u003ccode\u003eController\u003c/code\u003e class references both the View and the Model. This is a step up from the UI-centric approach: at least we have a separate logic class.\u003c/p\u003e\u003ch2 id=\"4333\"\u003eBase MVC Example (Without Loaders)\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"99e1\"\u003e// Model\u003cbr/\u003eclass CounterModel {\u003cbr/\u003e    private var count = 0\u003cbr/\u003e    fun increment() { count++ }\u003cbr/\u003e    fun getCount(): Int = count\u003cbr/\u003e}\u003cp\u003e// The \u0026#34;Controller\u0026#34; references a concrete Activity as the View\u003cbr/\u003eclass CounterController(\u003cbr/\u003e    private val view: MainActivity, // Direct link to Activity (the View)\u003cbr/\u003e    private val model: CounterModel\u003cbr/\u003e) {\u003cbr/\u003e    fun onIncrementClicked() {\u003cbr/\u003e        model.increment()\u003cbr/\u003e        view.updateCounter(model.getCount())\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// The Activity as \u0026#34;View\u0026#34;\u003cbr/\u003eclass MainActivity : AppCompatActivity() {\u003cbr/\u003e    private lateinit var controller: CounterController\u003cbr/\u003e    private lateinit var model: CounterModel\u003cbr/\u003e    private lateinit var countTextView: TextView\u003c/p\u003e\u003cp\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContentView(R.layout.activity_main)\u003c/p\u003e\u003cp\u003e        countTextView = findViewById(R.id.countTextView)\u003c/p\u003e\u003cp\u003e        model = CounterModel()\u003cbr/\u003e        controller = CounterController(this, model)\u003c/p\u003e\u003cp\u003e        findViewById\u0026lt;Button\u0026gt;(R.id.incrementButton).setOnClickListener {\u003cbr/\u003e            controller.onIncrementClicked()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun updateCounter(count: Int) {\u003cbr/\u003e        countTextView.text = count.toString()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1eca\"\u003eAdding a Loader to Retain the Controller\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"4c3a\"\u003e(Legacy approach: For completeness, we show how developers once handled rotation prior to \u003ccode\u003eViewModel\u003c/code\u003e.)\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"6acf\"\u003e// 1) Create a Loader to hold the Controller\u003cbr/\u003eclass ControllerLoader(\u003cbr/\u003e    context: Context,\u003cbr/\u003e    private val initialView: MainActivity\u003cbr/\u003e) : Loader\u0026lt;CounterController\u0026gt;(context) {\u003cp\u003e    private var controller: CounterController? = null\u003c/p\u003e\u003cp\u003e    override fun onStartLoading() {\u003cbr/\u003e        if (controller == null) {\u003cbr/\u003e            // Create a fresh Model and Controller the first time\u003cbr/\u003e            val model = CounterModel()\u003cbr/\u003e            controller = CounterController(initialView, model)\u003cbr/\u003e        }\u003cbr/\u003e        // Deliver the existing controller (if any)\u003cbr/\u003e        controller?.let { deliverResult(it) }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// 2) Activity: Using the Loader to persist Controller\u003cbr/\u003eclass MainActivity : AppCompatActivity() {\u003cbr/\u003e    companion object {\u003cbr/\u003e        private const val LOADER_ID = 1001\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private var controller: CounterController? = null\u003cbr/\u003e    private lateinit var countTextView: TextView\u003c/p\u003e\u003cp\u003e    private val loaderCallbacks = object : LoaderManager.LoaderCallbacks\u0026lt;CounterController\u0026gt; {\u003cbr/\u003e        override fun onCreateLoader(id: Int, args: Bundle?): Loader\u0026lt;CounterController\u0026gt; {\u003cbr/\u003e            return ControllerLoader(this@MainActivity, this@MainActivity)\u003cbr/\u003e        }\u003cbr/\u003e        override fun onLoadFinished(loader: Loader\u0026lt;CounterController\u0026gt;, data: CounterController?) {\u003cbr/\u003e            // We have our controller (could be newly created or retained)\u003cbr/\u003e            controller = data\u003cbr/\u003e        }\u003cbr/\u003e        override fun onLoaderReset(loader: Loader\u0026lt;CounterController\u0026gt;) {\u003cbr/\u003e            // Called if the Loader is reset or destroyed\u003cbr/\u003e            controller = null\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContentView(R.layout.activity_main)\u003c/p\u003e\u003cp\u003e        countTextView = findViewById(R.id.countTextView)\u003c/p\u003e\u003cp\u003e        // Init or reattach the Loader that holds our Controller\u003cbr/\u003e        loaderManager.initLoader(LOADER_ID, null, loaderCallbacks)\u003c/p\u003e\u003cp\u003e        findViewById\u0026lt;Button\u0026gt;(R.id.incrementButton).setOnClickListener {\u003cbr/\u003e            controller?.onIncrementClicked()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun updateCounter(count: Int) {\u003cbr/\u003e        countTextView.text = count.toString()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2e7e\"\u003e\u003cstrong\u003eHow It Works\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"374d\"\u003e\u003ccode\u003eControllerLoader\u003c/code\u003e is responsible for creating and holding onto the \u003ccode\u003eCounterController\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"7032\"\u003eOn rotation, \u003ccode\u003eLoaderManager\u003c/code\u003e reattaches the same loader, so the same \u003ccode\u003eCounterController\u003c/code\u003e instance is retained.\u003c/li\u003e\u003cli id=\"c8ed\"\u003eThe result is an MVC setup that can survive rotations — albeit with \u003cstrong\u003eextra\u003c/strong\u003e boilerplate.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"2d0f\"\u003eWhy MVC Is Still Limited\u003c/h2\u003e\u003col\u003e\u003cli id=\"411f\"\u003e\u003cstrong\u003eStrong Coupling\u003c/strong\u003e: The Controller knows about \u003ccode\u003eMainActivity\u003c/code\u003e by name.\u003c/li\u003e\u003cli id=\"915a\"\u003e\u003cstrong\u003eTesting Challenges\u003c/strong\u003e: The Controller depends on a real Android class (\u003ccode\u003eMainActivity\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"3e9d\"\u003e\u003cstrong\u003eLoader Boilerplate\u003c/strong\u003e: Even with Loaders, you still have more manual code to handle rotations.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"bfe7\"\u003e3. MVP: Breaking the Direct Coupling with a View Interface\u003c/h2\u003e\u003ch2 id=\"343a\"\u003eWhat It Is\u003c/h2\u003e\u003cp id=\"0c68\"\u003e\u003cstrong\u003eMVP (Model-View-Presenter)\u003c/strong\u003e addresses the \u003cstrong\u003etwo-way\u003c/strong\u003e coupling problem in classical MVC by introducing a \u003cstrong\u003eView interface\u003c/strong\u003e. The \u003cstrong\u003ePresenter\u003c/strong\u003e references \u003cstrong\u003eonly\u003c/strong\u003e this interface, not the concrete \u003ccode\u003eActivity\u003c/code\u003e or \u003ccode\u003eFragment\u003c/code\u003e. Meanwhile, the \u003ccode\u003eActivity\u003c/code\u003e implements that interface.\u003c/p\u003e\u003ch2 id=\"1994\"\u003eBase MVP Example (Without Loaders)\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"36a1\"\u003e// Model\u003cbr/\u003eclass CounterModel {\u003cbr/\u003e    private var count = 0\u003cbr/\u003e    fun increment() { count++ }\u003cbr/\u003e    fun getCount(): Int = count\u003cbr/\u003e}\u003cp\u003e// View Interface\u003cbr/\u003einterface CounterView {\u003cbr/\u003e    fun updateCount(count: Int)\u003cbr/\u003e    fun showError(message: String)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Presenter\u003cbr/\u003eclass CounterPresenter(private val model: CounterModel) {\u003cbr/\u003e    private var view: CounterView? = null\u003c/p\u003e\u003cp\u003e    fun attachView(view: CounterView) {\u003cbr/\u003e        this.view = view\u003cbr/\u003e        view.updateCount(model.getCount())\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun detachView() {\u003cbr/\u003e        this.view = null\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun onIncrementClicked() {\u003cbr/\u003e        model.increment()\u003cbr/\u003e        view?.updateCount(model.getCount())\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Activity implementing the View interface\u003cbr/\u003eclass MainActivity : AppCompatActivity(), CounterView {\u003cbr/\u003e    private lateinit var presenter: CounterPresenter\u003c/p\u003e\u003cp\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContentView(R.layout.activity_main)\u003c/p\u003e\u003cp\u003e        presenter = CounterPresenter(CounterModel())\u003cbr/\u003e        presenter.attachView(this)\u003c/p\u003e\u003cp\u003e        findViewById\u0026lt;Button\u0026gt;(R.id.incrementButton).setOnClickListener {\u003cbr/\u003e            presenter.onIncrementClicked()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun updateCount(count: Int) {\u003cbr/\u003e        findViewById\u0026lt;TextView\u0026gt;(R.id.countTextView).text = count.toString()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun showError(message: String) {\u003cbr/\u003e        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun onDestroy() {\u003cbr/\u003e        super.onDestroy()\u003cbr/\u003e        presenter.detachView()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"761c\"\u003eAs we have already seen how the long-deprecated Loaders historically were applied in the MVC section, there is no reason to repeat showing how the above code would adapt using Loaders.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"1dfb\"\u003eWhy MVP Is Better Than Classic MVC\u003c/h2\u003e\u003col\u003e\u003cli id=\"dba7\"\u003e\u003cstrong\u003eLoose Coupling\u003c/strong\u003e: The Presenter has no direct reference to \u003ccode\u003eMainActivity\u003c/code\u003e; it only knows \u003ccode\u003eCounterView\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"c153\"\u003e\u003cstrong\u003eEasier Testing\u003c/strong\u003e: You can test \u003ccode\u003eCounterPresenter\u003c/code\u003e by providing a mock or fake \u003ccode\u003eCounterView\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"7322\"\u003e\u003cstrong\u003eClear Contracts\u003c/strong\u003e: The \u003ccode\u003eCounterView\u003c/code\u003e interface declares exactly what UI methods the Presenter can invoke.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"6aff\"\u003e4. MVVM: Achieving Full UI Isolation with Reactive Streams\u003c/h2\u003e\u003ch2 id=\"897b\"\u003eWhat It Is\u003c/h2\u003e\u003cp id=\"1b4b\"\u003e\u003cstrong\u003eMVVM (Model-View-ViewModel)\u003c/strong\u003e goes even further by removing “push” calls from the Presenter. Instead, the \u003cstrong\u003eViewModel\u003c/strong\u003e holds data in a reactive manner (LiveData, Flow, or RxJava Observables), and the \u003cstrong\u003eView\u003c/strong\u003e “observes” that data. This means the \u003ccode\u003eViewModel\u003c/code\u003e is totally \u003cstrong\u003eUI-agnostic\u003c/strong\u003e—it has no references to \u003ccode\u003eActivity\u003c/code\u003e or \u003ccode\u003eFragment\u003c/code\u003e.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"c907\"\u003e\u003cstrong\u003eCrucially\u003c/strong\u003e, the arrival of \u003ccode\u003eViewModel\u003c/code\u003e in Architecture Components \u003cstrong\u003eremoved the need for Loaders\u003c/strong\u003e for rotation handling. The \u003ccode\u003eViewModel\u003c/code\u003e class is inherently lifecycle-aware and survives configuration changes automatically.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"c5b4\"\u003e\u003cstrong\u003eJetpack Compose Integration\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"a290\"\u003e\u003cstrong\u003eJetpack Compose\u003c/strong\u003e, a modern declarative UI toolkit, pairs naturally with \u003cstrong\u003eMVVM\u003c/strong\u003e. The UI “collects” or “observes” \u003ccode\u003eStateFlow\u003c/code\u003e or \u003ccode\u003eLiveData\u003c/code\u003e, and Compose re-composes automatically upon changes. This synergy helps maintain a \u003cstrong\u003eunidirectional data flow\u003c/strong\u003e: user events go to the ViewModel, state is updated, and Compose re-renders.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"bb9b\"\u003eExample (Using StateFlow + Jetpack Compose)\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"a266\"\u003e// ViewModel\u003cbr/\u003eclass CounterViewModel : ViewModel() {\u003cbr/\u003e    private val _counter = MutableStateFlow(0)\u003cbr/\u003e    val counter: StateFlow\u0026lt;Int\u0026gt; = _counter.asStateFlow()\u003cp\u003e    fun increment() {\u003cbr/\u003e        _counter.value++\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun CounterScreen(viewModel: CounterViewModel = viewModel()) {\u003cbr/\u003e    val count by viewModel.counter.collectAsState()\u003c/p\u003e\u003cp\u003e    Column(\u003cbr/\u003e        modifier = Modifier.fillMaxSize(),\u003cbr/\u003e        horizontalAlignment = Alignment.CenterHorizontally,\u003cbr/\u003e        verticalArrangement = Arrangement.Center\u003cbr/\u003e    ) {\u003cbr/\u003e        Text(text = count.toString())\u003cbr/\u003e        Button(onClick = { viewModel.increment() }) {\u003cbr/\u003e            Text(\u0026#34;Increment\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1cff\"\u003eKey Points\u003c/h2\u003e\u003cul\u003e\u003cli id=\"1c82\"\u003e\u003cstrong\u003eNo Direct Reference to the UI\u003c/strong\u003e: The ViewModel never calls something like \u003ccode\u003eactivity?.updateCount()\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"e241\"\u003e\u003cstrong\u003eLifecycle-Aware\u003c/strong\u003e: The ViewModel outlives the \u003ccode\u003eActivity\u003c/code\u003e by default, eliminating the need for Loaders or retained Fragments.\u003c/li\u003e\u003cli id=\"4e18\"\u003e\u003cstrong\u003eCompletely UI-Agnostic\u003c/strong\u003e: The UI “pulls” data changes, making the ViewModel trivial to unit test.\u003c/li\u003e\u003cli id=\"9acd\"\u003e\u003cstrong\u003eUnidirectional Data Flow\u003c/strong\u003e: With Compose or LiveData/Flow in XML-based apps, the user actions feed into the ViewModel, which updates state that the UI observes.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"beb3\"\u003e\u003cstrong\u003e\u003cem\u003eNote\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e: The introduction of \u003c/em\u003e\u003ccode\u003e\u003cem\u003eViewModel\u003c/em\u003e\u003c/code\u003e\u003cem\u003e effectively replaced the need for \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eLoaders\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e in modern architectures, since it automatically survives configuration changes and handles state retention.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"d2e7\"\u003eWhy the MVVM replaced the MVP\u003c/h2\u003e\u003cp id=\"c76c\"\u003eThe \u003cstrong\u003eMVVM\u003c/strong\u003e approach ensures a \u003cstrong\u003eunidirectional\u003c/strong\u003e data flow:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e3d9\"\u003eThe \u003cstrong\u003eUI\u003c/strong\u003e knows about the ViewModel, but the ViewModel knows absolutely \u003cstrong\u003enothing\u003c/strong\u003e about the UI.\u003c/li\u003e\u003cli id=\"170e\"\u003eWith \u003cstrong\u003ereactive programming\u003c/strong\u003e, the ViewModel communicates \u003cem\u003eback\u003c/em\u003e to the View via observables (e.g., \u003ccode\u003eLiveData\u003c/code\u003e, \u003ccode\u003eFlow\u003c/code\u003e, or RxJava).\u003c/li\u003e\u003cli id=\"99a0\"\u003eUnlike iOS, where the ViewModel is often just a plain class, \u003cstrong\u003ein Android\u003c/strong\u003e the ViewModel inherits from the \u003ccode\u003eViewModel\u003c/code\u003e base class, binding it to the \u003ccode\u003eActivity\u003c/code\u003e or \u003ccode\u003eFragment\u003c/code\u003e lifecycle. This means it survives configuration changes automatically, \u003cstrong\u003ereplacing Loaders\u003c/strong\u003e in the process.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"28d2\"\u003eBy combining lifecycle-awareness and reactive updates, MVVM eliminates the boilerplate needed for rotation handling and keeps business logic fully decoupled from the UI.\u003c/p\u003e\u003ch2 id=\"ad56\"\u003e5. MVI: Enforcing Unidirectional Data Flow\u003c/h2\u003e\u003ch2 id=\"12f0\"\u003eWhat It Is\u003c/h2\u003e\u003cp id=\"850e\"\u003e\u003cstrong\u003eMVI (Model-View-Intent)\u003c/strong\u003e refines MVVM’s reactive model further. Every user action is an “Intent” that transforms a single “State” object. This yields \u003cstrong\u003ehigh predictability\u003c/strong\u003e — you always know how the app transitions from one state to another, with no “mystery” side updates.\u003c/p\u003e\u003cp id=\"593d\"\u003e\u003cstrong\u003eMVI\u003c/strong\u003e is especially helpful in large or complex applications that benefit from a single “source of truth” and explicit state transitions. It can, however, be verbose for smaller screens.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3547\"\u003e// 1) State: Single source of truth for the UI\u003cbr/\u003edata class CounterState(\u003cbr/\u003e    val count: Int = 0,\u003cbr/\u003e    val error: String? = null\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"cce6\"\u003e// 2) Intents: All possible user actions\u003cbr/\u003esealed interface CounterIntent {\u003cbr/\u003e    object Increment : CounterIntent\u003cbr/\u003e    object Reset : CounterIntent\u003cbr/\u003e    data class SetCount(val value: Int) : CounterIntent\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"b9e2\"\u003e// 3) ViewModel in MVI style\u003cbr/\u003eclass CounterMviViewModel : ViewModel() {\u003cp\u003e    // Internal MutableStateFlow\u003cbr/\u003e    private val _state = MutableStateFlow(CounterState())\u003cbr/\u003e    // Exposed as a read-only StateFlow\u003cbr/\u003e    val state: StateFlow\u0026lt;CounterState\u0026gt; = _state.asStateFlow()\u003c/p\u003e\u003cp\u003e    fun processIntent(intent: CounterIntent) {\u003cbr/\u003e        when (intent) {\u003cbr/\u003e            CounterIntent.Increment -\u0026gt; {\u003cbr/\u003e                _state.update { it.copy(count = oldState.count+1, error = null) }\u003cbr/\u003e            }\u003cbr/\u003e            CounterIntent.Reset -\u0026gt; {\u003cbr/\u003e                _state.update { it.copy(count=0, error = null) }\u003cbr/\u003e            }\u003cbr/\u003e            is CounterIntent.SetCount -\u0026gt; {\u003cbr/\u003e                if (intent.value \u0026gt;= 0) {\u003cbr/\u003e                    _state.update { it.copy(count = intent.value, error = null) }\u003cbr/\u003e                } else {\u003cbr/\u003e                    _state.update { it.copy(error = \u0026#34;Negative counts not allowed\u0026#34;) }\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"8bb9\"\u003e// 4) Composable \u0026#34;View\u0026#34; observing the StateFlow\u003cbr/\u003e@Composable\u003cbr/\u003efun CounterMviScreen(viewModel: CounterMviViewModel = viewModel()) {\u003cbr/\u003e    // Collect the current state from our MVI ViewModel\u003cbr/\u003e    val uiState by viewModel.state.collectAsState()\u003cp\u003e    Column(\u003cbr/\u003e        modifier = Modifier.fillMaxSize(),\u003cbr/\u003e        horizontalAlignment = Alignment.CenterHorizontally,\u003cbr/\u003e        verticalArrangement = Arrangement.Center\u003cbr/\u003e    ) {\u003cbr/\u003e        Text(\u003cbr/\u003e            text = uiState.count.toString(),\u003cbr/\u003e            style = MaterialTheme.typography.headlineMedium\u003cbr/\u003e        )\u003c/p\u003e\u003cp\u003e        // Show an error if any\u003cbr/\u003e        uiState.error?.let { error -\u0026gt;\u003cbr/\u003e            Text(\u003cbr/\u003e                text = error,\u003cbr/\u003e                color = MaterialTheme.colorScheme.error,\u003cbr/\u003e                style = MaterialTheme.typography.bodyMedium\u003cbr/\u003e            )\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        Spacer(modifier = Modifier.height(16.dp))\u003c/p\u003e\u003cp\u003e        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {\u003cbr/\u003e            Button(onClick = { viewModel.processIntent(CounterIntent.Increment) }) {\u003cbr/\u003e                Text(\u0026#34;Increment\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e            Button(onClick = { viewModel.processIntent(CounterIntent.Reset) }) {\u003cbr/\u003e                Text(\u0026#34;Reset\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        Spacer(modifier = Modifier.height(16.dp))\u003c/p\u003e\u003cp\u003e        // Example: Setting a specific count\u003cbr/\u003e        Button(onClick = { viewModel.processIntent(CounterIntent.SetCount(5)) }) {\u003cbr/\u003e            Text(\u0026#34;Set Count to 5\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"6448\"\u003eWhy MVI?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"6d83\"\u003e\u003cstrong\u003ePredictable State Changes\u003c/strong\u003e: Each user action is formalized as an Intent, ensuring no hidden or random updates.\u003c/li\u003e\u003cli id=\"1641\"\u003e\u003cstrong\u003eSingle Source of Truth\u003c/strong\u003e: The entire UI state is in one \u003ccode\u003eCounterState\u003c/code\u003e data class.\u003c/li\u003e\u003cli id=\"3c2e\"\u003e\u003cstrong\u003ePerfect Fit with Jetpack Compose\u003c/strong\u003e: Because Compose is inherently reactive and expects a unidirectional flow, MVI integrates seamlessly.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"afda\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"130e\"\u003eAndroid’s architectural evolution reflects a consistent push toward \u003cstrong\u003eloose coupling\u003c/strong\u003e, \u003cstrong\u003etestability\u003c/strong\u003e, and \u003cstrong\u003erobust state management\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b597\"\u003e\u003cstrong\u003eUI-Centric\u003c/strong\u003e lumps everything into one place (the “God Activity”), making code untestable and fragile.\u003c/li\u003e\u003cli id=\"9dde\"\u003e\u003cstrong\u003eClassic MVC\u003c/strong\u003e separates logic from UI but still references the \u003ccode\u003eActivity\u003c/code\u003e directly in the Controller. \u003cstrong\u003eLoaders\u003c/strong\u003e could help preserve logic, though it required extra boilerplate.\u003c/li\u003e\u003cli id=\"4b05\"\u003e\u003cstrong\u003eMVP\u003c/strong\u003e introduces a \u003cstrong\u003eView interface\u003c/strong\u003e, decoupling Presenter logic from the concrete UI classes; Loaders (or retained Fragments) again offered a rotation fix before \u003ccode\u003eViewModel\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"7a75\"\u003e\u003cstrong\u003eMVVM\u003c/strong\u003e uses lifecycle-aware \u003ccode\u003eViewModel\u003c/code\u003es to naturally retain state, eliminating the need for Loaders. The UI observes reactive data, fully isolating business logic from UI code.\u003c/li\u003e\u003cli id=\"d482\"\u003e\u003cstrong\u003eMVI\u003c/strong\u003e locks down \u003cstrong\u003eunidirectional\u003c/strong\u003e state changes with an \u003cstrong\u003eIntent\u003c/strong\u003e→\u003cstrong\u003eState\u003c/strong\u003e approach, ideal for complex apps where predictability is paramount.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ed23\"\u003eNow, most developers prefer MVVM or MVI for clean, testable, and lifecycle-friendly architecture. Regardless of which you choose, the guiding principle remains: \u003cstrong\u003eseparate your business logic from the UI\u003c/strong\u003e to keep apps maintainable and testable.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2024-12-31T16:41:35.863Z",
  "modifiedTime": null
}
