{
  "id": "cdb793f4-a931-41bc-a330-78fce81557f4",
  "title": "Understanding Kotlin Delegates with Practical Examples",
  "link": "https://proandroiddev.com/understanding-kotlin-delegates-with-practical-examples-c0ea976fb184?source=rss----c72404660798---4",
  "description": "",
  "author": "Md Imam Hossain",
  "published": "Wed, 29 Jan 2025 14:12:30 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "coding",
    "kotlin",
    "android",
    "software-engineering",
    "design-patterns"
  ],
  "byline": "Md Imam Hossain",
  "length": 18753,
  "excerpt": "If you write code in Kotlin, you’ve likely encountered the concept of Kotlin delegates, whether while using the by keyword to initialize a variable with a lazy block or obtaining a ViewModel instance…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Image Credit: Photo by Md Imam Hossain (Author)If you write code in Kotlin, you’ve likely encountered the concept of Kotlin delegates, whether while using the by keyword to initialize a variable with a lazy block or obtaining a ViewModel instance via viewModels(). These are classic examples of Kotlin delegates. In this post, I’ll walk you through Kotlin delegates with clear explanations and practical examples.What Are Kotlin Delegates?Kotlin delegates simplify and reuse code by allowing one object to handle certain tasks on behalf of another object. It’s like saying, “Hey, you take care of this part for me!”What does it mean?Imagine you have a class A with a property x. You want to log every time a new value is assigned to x or perform some custom tasks when it’s accessed or modified. While you can achieve this by adding custom logic directly in the getter and setter of x, it can quickly become repetitive and messy if you need to apply similar behavior to multiple properties. Instead of duplicating code, you can create a custom delegate class that handles this behavior. Then, you can reuse this delegate for any property in your class.// Custom delegate classclass CustomLogDelegate\u003cT\u003e(private var value: T) { operator fun getValue(thisRef: Any?, property: KProperty\u003c*\u003e): T { println(\"Getting value of '${property.name}': $value\") return value } operator fun setValue(thisRef: Any?, property: KProperty\u003c*\u003e, newValue: T) { println(\"Setting value of '${property.name}' from $value to $newValue\") value = newValue }}class A { var x: String by CustomLogDelegate(\"Initial Value\") var y: Int by CustomLogDelegate(0)}Here, the CustomLogDelegate handles logging for properties x and y. Kotlin also provides built-in delegate types and allows creating custom delegates.Types of Delegation in KotlinProperty Delegation: Delegating property behavior to another object.Class Delegation: Delegating the implementation of an interface to another object.Property DelegationProperty Delegation enables defining the behavior of a property in a separate class or function, reducing boilerplate code for repetitive tasks like getters and setters.Syntax of Property Delegationvar \u003cproperty-name\u003e: \u003cType\u003e by \u003cdelegate\u003eThe by keyword links the property to its delegate.Built-in Property Delegates in KotlinLazy DelegationOne of the most commonly used delegate in Kotlin that helps you initialize a property only when it’s accessed for the first time. The lazy delegate is a part of the Kotlin standard library and works by taking a lambda that provides the initialization logic. Once initialized, the value is cached and reused whenever the property is accessed again.val propertyName: Type by lazy { // Initialization logic here}Use cases for lazy:Expensive Operations: Use it for properties that involve heavy computation or data fetching.Optional Data: For properties that might not always be accessed during the lifecycle of an object.Thread-Safe Initialization: Ideal for properties shared across threads.Scenarios where lazy is useful:class TwitterClient { private val client by lazy { // Complex API setup only happens when first needed RetrofitBuilder() .setBaseUrl(\"https://api.twitter.com\") .setAuthToken(loadToken()) .build() }}class Repository { private val database by lazy { // Expensive database connection only opened when needed Room.databaseBuilder(context, AppDatabase::class.java, \"mydb\") .build() }}class ImageProcessor { private val bitmap by lazy { // Large image only loaded when needed context.resources.getDrawable(R.drawable.large_image) .toBitmap() }}Observable DelegationThe observable delegation in Kotlin allows to monitor changes to a property and react whenever its value changes. The observable function is part of Kotlin’s standard library and provides a callback mechanism that gets invoked on every value change.var propertyName: Type by observable(initialValue) { property, oldValue, newValue -\u003e // React to the change}Use cases for observable:Live Data Tracking: Monitor and update UI settings in real timeDebugging: Track and log property changesScenarios where observable is useful:class RegistrationForm { var password: String by Delegates.observable(\"\") { _, _, newValue -\u003e // Automatically validate password on change passwordStrength = calculateStrength(newValue) updatePasswordIndicator(passwordStrength) } var email: String by Delegates.observable(\"\") { _, _, newValue -\u003e // Real-time email validation isEmailValid = validateEmail(newValue) updateEmailIndicator(isEmailValid) }}class UserActivity { var currentScreen: String by Delegates.observable(\"Home\") { _, oldValue, newValue -\u003e // Log screen changes for analytics analyticsTracker.logScreenChange(from = oldValue, to = newValue) // Update user's last known location updateUserLocation(newValue) }}class ProductPrice { var price by Delegates.observable(0.0) { _, oldPrice, newPrice -\u003e val difference = newPrice - oldPrice when { difference \u003e 0 -\u003e { priceView.setTextColor(Color.RED) showPriceChange(\"Price increased by $${difference}\") } difference \u003c 0 -\u003e { priceView.setTextColor(Color.GREEN) showPriceChange(\"Price decreased by $${-difference}\") } } }}Vetoable DelegationThe vetoable delegation in Kotlin allows to monitor and potentially block changes to a property’s value. The vetoable function is also part of Kotlin’s standard library and provides a validation mechanism that lets enforce rules whenever the property is updated.var propertyName: Type by vetoable(initialValue) { property, oldValue, newValue -\u003e // Decide whether to allow the change conditionToAllowChange}Use cases for vetoable:Validation: Ensure a property’s value meets specific criteria before accepting changes.Restricting Updates: Prevent undesired or unsafe modifications to critical properties.Scenarios where vetoable is useful:class UserSettings { var theme: String by Delegates.vetoable(\"Light\") { _, _, newValue -\u003e // Allow only specific themes val allowedThemes = listOf(\"Light\", \"Dark\") if (newValue in allowedThemes) { println(\"Theme updated to $newValue\") true } else { println(\"Invalid theme: $newValue\") false } }}class BankAccount { var balance: Double by Delegates.vetoable(0.0) { _, oldValue, newValue -\u003e // Prevent balance from going negative if (newValue \u003c 0) { println(\"Invalid operation: Balance cannot be negative.\") false } else { println(\"Balance updated from $oldValue to $newValue\") true } }}class UserProfile { var age: Int by Delegates.vetoable(18) { _, oldValue, newValue -\u003e // Allow only valid age range if (newValue in 13..100) { println(\"Age updated from $oldValue to $newValue\") true } else { println(\"Invalid age: $newValue. Keeping $oldValue.\") false } } var username: String by Delegates.vetoable(\"Guest\") { _, _, newValue -\u003e // Enforce username validation if (newValue.matches(\"^[a-zA-Z0-9_]{3,15}$\".toRegex())) { println(\"Username updated to $newValue\") true } else { println(\"Invalid username: $newValue. Must be 3-15 alphanumeric characters.\") false } }}Map DelegationThe map delegation in Kotlin allows to delegate property storage to a Map object. This is particularly useful for working with dynamic or external data sources, like JSON objects or database rows, where property values are stored and retrieved using keys.val propertyMap = mapOf(\"key1\" to value1, \"key2\" to value2)val key1: Type by propertyMapval key2: Type by propertyMapUse cases for map delegation:JSON Parsing: Simplify access to fields in JSON objects retrieved from REST APIs by mapping keys to properties directly.Intent or Bundle Data: Simplify extracting values from Android Intent extras or Bundle objects, making the code cleaner and more maintainable.Scenarios where map delegation is useful:class Product(private val attributes: Map\u003cString, Any\u003e) { val productId: Int by attributes val productName: String by attributes val price: Double by attributes}val productData = mapOf(\"productId\" to 501, \"productName\" to \"Laptop\", \"price\" to 1500.0)val product = Product(productData)private val data: Map\u003cString, Any?\u003e by lazy { // `keySet()` retrieves all the keys, and `associateWith` maps each key to its corresponding value. intent.extras?.keySet()?.associateWith { intent.extras?.get(it) } ?: emptyMap()}val title: String? by dataval itemId: Int? by dataprivate val sharedPrefs = context.getSharedPreferences(\"UserPrefs\", Context.MODE_PRIVATE)private val prefsMap: Map\u003cString, Any?\u003e by lazy { sharedPrefs.all // Get all stored preferences as a map}val isDarkMode: Boolean by prefsMapval username: String? by prefsMapDelegating to Another PropertyKotlin also always to delegate the getter and setter of a property to another property. This feature is available for both top-level and class properties, including member and extension properties. To delegate a property, use the :: qualifier with the name of the delegate property, such as this::delegate or MyClass::delegate.var propertyName: Type by this::delegatePropertyNameUse Cases for Delegating to Another Property:Backward Compatibility: Gradually transition from an old property to a new one while maintaining compatibility with older versions of the codebase.Streamlining Updates: Maintain a single source of truth for property values across different properties.Scenarios where delegating to another property is useful:class Employee { // New property for storing the current role var currentRole: String = \"Junior Developer\" // Deprecated property delegating to the new one @Deprecated(\"Use 'currentRole' instead\", ReplaceWith(\"currentRole\")) var previousRole: String by this::currentRole}fun main() { val employee = Employee() // Using the deprecated property // Notification: 'previousRole: String' is deprecated. Use 'currentRole' instead. employee.previousRole = \"Senior Developer\" // The new property reflects the change println(employee.currentRole) // Output: Senior Developer}Custom Property Delegates in KotlinLet’s explore how to map JSON keys directly to Kotlin properties with a custom property delegates. First create a custom extension function to delegating JSON properties.operator fun \u003cT\u003e JSONObject.getValue(thisRef: Any?, property: kotlin.reflect.KProperty\u003c*\u003e): T = this.get(property.name) as TOperator Overloading: The operator keyword allows getValue to be used with the by keyword, enabling seamless property delegation.Property Mapping: The property parameter provides the name of the delegated property, which is used to fetch the corresponding value from the JSONObject using this.get(property.name).Generic Return Type: The \u003cT\u003e makes the function flexible, allowing it to return values of any type (e.g., String, Double) by casting the JSON value to the expected type.Finally this function maps JSON keys directly to Kotlin properties using the by keyword, simplifying JSON parsing with a clean, reusable pattern.class Product(json: JSONObject) { val id: String by json val name: String by json val price: Double by json}val json = JSONObject(\"\"\"{\"id\": \"123\", \"name\": \"Smartphone\", \"price\": 799.99}\"\"\")val product = Product(json)println(product.name) // Output: SmartphoneLet’s create another simple reusable custom property delegate to handle reading and writing SharedPreferences properties.// Basic implementation of a custom sharedPreferences delegateclass SharedPreferencesDelegate\u003cT\u003e( private val sharedPreferences: SharedPreferences, private val key: String, private val defaultValue: T) { @Suppress(\"UNCHECKED_CAST\") operator fun getValue(thisRef: Any?, property: KProperty\u003c*\u003e): T { return when (defaultValue) { is String -\u003e sharedPreferences.getString(key, defaultValue) as T is Int -\u003e sharedPreferences.getInt(key, defaultValue) as T is Boolean -\u003e sharedPreferences.getBoolean(key, defaultValue) as T is Float -\u003e sharedPreferences.getFloat(key, defaultValue) as T is Long -\u003e sharedPreferences.getLong(key, defaultValue) as T else -\u003e throw IllegalArgumentException(\"Unsupported type\") } } operator fun setValue(thisRef: Any?, property: KProperty\u003c*\u003e, value: T) { with(sharedPreferences.edit()) { when (value) { is String -\u003e putString(key, value) is Int -\u003e putInt(key, value) is Boolean -\u003e putBoolean(key, value) is Float -\u003e putFloat(key, value) is Long -\u003e putLong(key, value) else -\u003e throw IllegalArgumentException(\"Unsupported type\") } apply() } }}// Create a Wrapper Classclass AppPreferences(context: Context) { private val sharedPreferences = context.getSharedPreferences(\"AppPreferences\", Context.MODE_PRIVATE) var username: String by SharedPreferencesDelegate(sharedPreferences, \"username\", \"Guest\") var isLoggedIn: Boolean by SharedPreferencesDelegate(sharedPreferences, \"isLoggedIn\", false) var highScore: Int by SharedPreferencesDelegate(sharedPreferences, \"highScore\", 0)}// Use the AppPreferences class in Android activity:class MainActivity : AppCompatActivity() { private lateinit var preferences: AppPreferences override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // Initialize AppPreferences preferences = AppPreferences(this) // Save data to SharedPreferences preferences.username = \"JohnDoe\" preferences.isLoggedIn = true preferences.highScore = 1200 // Retrieve and display data from SharedPreferences println(\"Username: ${preferences.username}\") println(\"Is Logged In: ${preferences.isLoggedIn}\") println(\"High Score: ${preferences.highScore}\") }}Class DelegationClass delegation is a powerful feature in Kotlin that enables a class to delegate the implementation of an interface to another object. This promotes code reusability and simplifies code by separating concerns, allowing to focus on composition over inheritance.Composition over inheritance means creating software by combining small, reusable pieces instead of using class hierarchies, making code more flexible and easier to maintain.// Define a generic interfaceinterface BaseInterface { fun doSomething(): String}// Concrete implementation of the interfaceclass ConcreteImplementation : BaseInterface { override fun doSomething(): String { return \"Doing something in ConcreteImplementation\" }}// Delegating class that delegates functionality to another objectclass DelegatingClass(delegate: BaseInterface) : BaseInterface by delegatefun main() { val realImplementation = ConcreteImplementation() // Create a delegating object val delegatingObject = DelegatingClass(realImplementation) // Call the function via the delegating object println(delegatingObject.doSomething()) // Output: Doing something in ConcreteImplementation}Here the Base Interface defines the contract, the Concrete Implementation provides the functionality, and the Delegating Class uses by to automatically forward all functions to the provided implementation.Use cases for class delegation:Reusable Logic: Class delegation lets reuse code by passing responsibilities to another class instead of repeating the code in subclasses.Composition Over Inheritance: It offers a cleaner alternative to inheritance, helping create modular classes that focus on composition rather than subclassing.Decouple Code: Delegation reduces tight coupling by allowing a class to delegate some of its tasks to another class, making code more flexible and easier to maintain.Scenarios where class delegation is useful://Define Multiple Interfaces for Delegationinterface LoadingState { fun showLoading(isLoading: Boolean)}interface ErrorHandler { fun handleNetworkError(error: String)}interface UserInteraction { fun handleUserClick(action: String)}// Implement the Interfacesclass LoadingStateImpl : LoadingState { override fun showLoading(isLoading: Boolean) { if (isLoading) { println(\"Loading...\") } else { println(\"Loading finished.\") } }}class ErrorHandlerImpl : ErrorHandler { override fun handleNetworkError(error: String) { println(\"Network Error: $error\") }}class UserInteractionImpl : UserInteraction { override fun handleUserClick(action: String) { println(\"User clicked on: $action\") }}//Delegate Only Necessary Behaviors in the Activityclass MainActivity : AppCompatActivity(), LoadingState by LoadingStateImpl(), ErrorHandler by ErrorHandlerImpl(), UserInteraction by UserInteractionImpl() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // Show loading state showLoading(true) // Simulate a network error handleNetworkError(\"Failed to fetch data\") // Handle user click action handleUserClick(\"Submit Button\") }}//Delegate Only Necessary Behaviors in the Activityclass AnotherActivity : AppCompatActivity(), LoadingState by LoadingStateImpl(), ErrorHandler by ErrorHandlerImpl(){ override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_another) // Show loading showLoading(true) // Simulate a network error handleNetworkError(\"Connection timeout\") }}Unlike base class inheritance, class delegation enables you to share behavior without tightly coupling activities to a common base class. It provides greater flexibility and separation of concerns, keeping your code clean, modular, and easier to extend.Kotlin Delegates are a great way to simplify your code and improve readability. Explore the built-in and custom delegates to enhance your Kotlin projects. Feel free to reach out and share your thoughts on this article or any other Kotlin-related topics! You can connect with me on LinkedIn — let’s keep the conversation going!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*--O5le3MOAVJlArhsnfANw.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://iimamhossain.medium.com/?source=post_page---byline--c0ea976fb184--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Md Imam Hossain\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*wbDPJNZ_virfFmxWrJoGLA.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--c0ea976fb184--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eImage Credit\u003c/strong\u003e: Photo by Md Imam Hossain (Author)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"4dd1\"\u003eIf you write code in Kotlin, you’ve likely encountered the concept of Kotlin delegates, whether while using the \u003ccode\u003eby\u003c/code\u003e keyword to initialize a variable with a \u003ccode\u003elazy\u003c/code\u003e block or obtaining a ViewModel instance via \u003ccode\u003eviewModels()\u003c/code\u003e. These are classic examples of Kotlin delegates. In this post, I’ll walk you through Kotlin delegates with clear explanations and practical examples.\u003c/p\u003e\u003ch2 id=\"1415\"\u003eWhat Are Kotlin Delegates?\u003c/h2\u003e\u003cp id=\"2d09\"\u003eKotlin delegates simplify and reuse code by allowing one object to handle certain tasks on behalf of another object. It’s like saying, “Hey, you take care of this part for me!”\u003c/p\u003e\u003ch2 id=\"11ad\"\u003e\u003cstrong\u003eWhat does it mean?\u003c/strong\u003e\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"062c\"\u003eImagine you have a class \u003ccode\u003eA\u003c/code\u003e with a property \u003ccode\u003ex\u003c/code\u003e. You want to log every time a new value is assigned to \u003ccode\u003ex\u003c/code\u003e or perform some custom tasks when it’s accessed or modified. While you can achieve this by adding custom logic directly in the getter and setter of \u003ccode\u003ex\u003c/code\u003e, it can quickly become repetitive and messy if you need to apply similar behavior to multiple properties. Instead of duplicating code, you can create a custom delegate class that handles this behavior. Then, you can reuse this delegate for any property in your class.\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"fb89\"\u003e// Custom delegate class\u003cbr/\u003eclass CustomLogDelegate\u0026lt;T\u0026gt;(private var value: T) {\u003cbr/\u003e    operator fun getValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;): T {\u003cbr/\u003e        println(\u0026#34;Getting value of \u0026#39;${property.name}\u0026#39;: $value\u0026#34;)\u003cbr/\u003e        return value\u003cbr/\u003e    }\u003cp\u003e    operator fun setValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;, newValue: T) {\u003cbr/\u003e        println(\u0026#34;Setting value of \u0026#39;${property.name}\u0026#39; from $value to $newValue\u0026#34;)\u003cbr/\u003e        value = newValue\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eclass A {\u003cbr/\u003e    var x: String by CustomLogDelegate(\u0026#34;Initial Value\u0026#34;)\u003cbr/\u003e    var y: Int by CustomLogDelegate(0)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dd85\"\u003eHere, the \u003cstrong\u003eCustomLogDelegate\u003c/strong\u003e handles logging for properties \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e. Kotlin also provides built-in delegate types and allows creating custom delegates.\u003c/p\u003e\u003ch2 id=\"40c2\"\u003eTypes of Delegation in Kotlin\u003c/h2\u003e\u003col\u003e\u003cli id=\"226e\"\u003e\u003cstrong\u003eProperty Delegation\u003c/strong\u003e: Delegating property behavior to another object.\u003c/li\u003e\u003cli id=\"ed1b\"\u003e\u003cstrong\u003eClass Delegation\u003c/strong\u003e: Delegating the implementation of an interface to another object.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"a92f\"\u003eProperty Delegation\u003c/h2\u003e\u003cp id=\"caf7\"\u003eProperty Delegation enables defining the behavior of a property in a separate class or function, reducing boilerplate code for repetitive tasks like getters and setters.\u003c/p\u003e\u003cp id=\"043c\"\u003e\u003cstrong\u003eSyntax of Property Delegation\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"63f5\"\u003evar \u0026lt;property-name\u0026gt;: \u0026lt;Type\u0026gt; by \u0026lt;delegate\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4841\"\u003eThe \u003ccode\u003eby\u003c/code\u003e keyword links the property to its delegate.\u003c/p\u003e\u003ch2 id=\"3254\"\u003eBuilt-in Property Delegates in Kotlin\u003c/h2\u003e\u003ch2 id=\"75e9\"\u003e\u003cstrong\u003eLazy Delegation\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"700c\"\u003eOne of the most commonly used delegate in Kotlin that helps you initialize a property only when it’s accessed for the first time. The lazy delegate is a part of the Kotlin standard library and works by taking a lambda that provides the initialization logic. Once initialized, the value is cached and reused whenever the property is accessed again.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"894b\"\u003eval propertyName: Type by lazy {\u003cbr/\u003e    // Initialization logic here\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"43ea\"\u003e\u003cstrong\u003eUse cases for lazy:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"0f9a\"\u003eExpensive Operations: Use it for properties that involve heavy computation or data fetching.\u003c/li\u003e\u003cli id=\"cf41\"\u003eOptional Data: For properties that might not always be accessed during the lifecycle of an object.\u003c/li\u003e\u003cli id=\"0e3b\"\u003eThread-Safe Initialization: Ideal for properties shared across threads.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e809\"\u003e\u003cstrong\u003eScenarios where lazy is useful:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f9aa\"\u003eclass TwitterClient {\u003cbr/\u003e    private val client by lazy {\u003cbr/\u003e        // Complex API setup only happens when first needed\u003cbr/\u003e        RetrofitBuilder()\u003cbr/\u003e            .setBaseUrl(\u0026#34;https://api.twitter.com\u0026#34;)\u003cbr/\u003e            .setAuthToken(loadToken())\u003cbr/\u003e            .build()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"cd67\"\u003eclass Repository {\u003cbr/\u003e    private val database by lazy {\u003cbr/\u003e        // Expensive database connection only opened when needed\u003cbr/\u003e        Room.databaseBuilder(context, AppDatabase::class.java, \u0026#34;mydb\u0026#34;)\u003cbr/\u003e            .build()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"1b27\"\u003eclass ImageProcessor {\u003cbr/\u003e    private val bitmap by lazy {\u003cbr/\u003e        // Large image only loaded when needed\u003cbr/\u003e        context.resources.getDrawable(R.drawable.large_image)\u003cbr/\u003e            .toBitmap()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"dbe4\"\u003eObservable Delegation\u003c/h2\u003e\u003cp id=\"17cc\"\u003eThe observable delegation in Kotlin allows to monitor changes to a property and react whenever its value changes. The observable function is part of Kotlin’s standard library and provides a callback mechanism that gets invoked on every value change.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"370d\"\u003evar propertyName: Type by observable(initialValue) { property, oldValue, newValue -\u0026gt;\u003cbr/\u003e    // React to the change\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cbc6\"\u003e\u003cstrong\u003eUse cases for observable:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"3eac\"\u003eLive Data Tracking: Monitor and update UI settings in real time\u003c/li\u003e\u003cli id=\"d5f4\"\u003eDebugging: Track and log property changes\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f306\"\u003e\u003cstrong\u003eScenarios where observable is useful:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0c2e\"\u003eclass RegistrationForm {\u003cbr/\u003e    var password: String by Delegates.observable(\u0026#34;\u0026#34;) { _, _, newValue -\u0026gt;\u003cbr/\u003e        // Automatically validate password on change\u003cbr/\u003e        passwordStrength = calculateStrength(newValue)\u003cbr/\u003e        updatePasswordIndicator(passwordStrength)\u003cbr/\u003e    }\u003cp\u003e        var email: String by Delegates.observable(\u0026#34;\u0026#34;) { _, _, newValue -\u0026gt;\u003cbr/\u003e        // Real-time email validation\u003cbr/\u003e        isEmailValid = validateEmail(newValue)\u003cbr/\u003e        updateEmailIndicator(isEmailValid)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"8f4c\"\u003eclass UserActivity {\u003cbr/\u003e    var currentScreen: String by Delegates.observable(\u0026#34;Home\u0026#34;) { _, oldValue, newValue -\u0026gt;\u003cbr/\u003e        // Log screen changes for analytics\u003cbr/\u003e        analyticsTracker.logScreenChange(from = oldValue, to = newValue)\u003cp\u003e                // Update user\u0026#39;s last known location\u003cbr/\u003e        updateUserLocation(newValue)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"4371\"\u003eclass ProductPrice {\u003cbr/\u003e    var price by Delegates.observable(0.0) { _, oldPrice, newPrice -\u0026gt;\u003cbr/\u003e        val difference = newPrice - oldPrice\u003cbr/\u003e        when {\u003cbr/\u003e            difference \u0026gt; 0 -\u0026gt; {\u003cbr/\u003e                priceView.setTextColor(Color.RED)\u003cbr/\u003e                showPriceChange(\u0026#34;Price increased by $${difference}\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e            difference \u0026lt; 0 -\u0026gt; {\u003cbr/\u003e                priceView.setTextColor(Color.GREEN)\u003cbr/\u003e                showPriceChange(\u0026#34;Price decreased by $${-difference}\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"6c22\"\u003eVetoable Delegation\u003c/h2\u003e\u003cp id=\"d6d9\"\u003eThe vetoable delegation in Kotlin allows to monitor and potentially block changes to a property’s value. The vetoable function is also part of Kotlin’s standard library and provides a validation mechanism that lets enforce rules whenever the property is updated.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a2fd\"\u003evar propertyName: Type by vetoable(initialValue) { property, oldValue, newValue -\u0026gt;\u003cbr/\u003e    // Decide whether to allow the change\u003cbr/\u003e    conditionToAllowChange\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a0b0\"\u003e\u003cstrong\u003eUse cases for vetoable:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"a011\"\u003eValidation: Ensure a property’s value meets specific criteria before accepting changes.\u003c/li\u003e\u003cli id=\"3e88\"\u003eRestricting Updates: Prevent undesired or unsafe modifications to critical properties.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b49b\"\u003e\u003cstrong\u003eScenarios where vetoable is useful:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9e86\"\u003eclass UserSettings {\u003cbr/\u003e    var theme: String by Delegates.vetoable(\u0026#34;Light\u0026#34;) { _, _, newValue -\u0026gt;\u003cbr/\u003e        // Allow only specific themes\u003cbr/\u003e        val allowedThemes = listOf(\u0026#34;Light\u0026#34;, \u0026#34;Dark\u0026#34;)\u003cbr/\u003e        if (newValue in allowedThemes) {\u003cbr/\u003e            println(\u0026#34;Theme updated to $newValue\u0026#34;)\u003cbr/\u003e            true\u003cbr/\u003e        } else {\u003cbr/\u003e            println(\u0026#34;Invalid theme: $newValue\u0026#34;)\u003cbr/\u003e            false\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"6bdc\"\u003eclass BankAccount {\u003cbr/\u003e    var balance: Double by Delegates.vetoable(0.0) { _, oldValue, newValue -\u0026gt;\u003cbr/\u003e        // Prevent balance from going negative\u003cbr/\u003e        if (newValue \u0026lt; 0) {\u003cbr/\u003e            println(\u0026#34;Invalid operation: Balance cannot be negative.\u0026#34;)\u003cbr/\u003e            false\u003cbr/\u003e        } else {\u003cbr/\u003e            println(\u0026#34;Balance updated from $oldValue to $newValue\u0026#34;)\u003cbr/\u003e            true\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"a245\"\u003e\u003cbr/\u003eclass UserProfile {\u003cbr/\u003e    var age: Int by Delegates.vetoable(18) { _, oldValue, newValue -\u0026gt;\u003cbr/\u003e        // Allow only valid age range\u003cbr/\u003e        if (newValue in 13..100) {\u003cbr/\u003e            println(\u0026#34;Age updated from $oldValue to $newValue\u0026#34;)\u003cbr/\u003e            true\u003cbr/\u003e        } else {\u003cbr/\u003e            println(\u0026#34;Invalid age: $newValue. Keeping $oldValue.\u0026#34;)\u003cbr/\u003e            false\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cp\u003e    var username: String by Delegates.vetoable(\u0026#34;Guest\u0026#34;) { _, _, newValue -\u0026gt;\u003cbr/\u003e        // Enforce username validation\u003cbr/\u003e        if (newValue.matches(\u0026#34;^[a-zA-Z0-9_]{3,15}$\u0026#34;.toRegex())) {\u003cbr/\u003e            println(\u0026#34;Username updated to $newValue\u0026#34;)\u003cbr/\u003e            true\u003cbr/\u003e        } else {\u003cbr/\u003e            println(\u0026#34;Invalid username: $newValue. Must be 3-15 alphanumeric characters.\u0026#34;)\u003cbr/\u003e            false\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"d7e4\"\u003eMap Delegation\u003c/h2\u003e\u003cp id=\"130a\"\u003eThe map delegation in Kotlin allows to delegate property storage to a Map object. This is particularly useful for working with dynamic or external data sources, like JSON objects or database rows, where property values are stored and retrieved using keys.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"596f\"\u003eval propertyMap = mapOf(\u0026#34;key1\u0026#34; to value1, \u0026#34;key2\u0026#34; to value2)\u003cbr/\u003eval key1: Type by propertyMap\u003cbr/\u003eval key2: Type by propertyMap\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8666\"\u003e\u003cstrong\u003eUse cases for map delegation:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"6445\"\u003eJSON Parsing: Simplify access to fields in JSON objects retrieved from REST APIs by mapping keys to properties directly.\u003c/li\u003e\u003cli id=\"497d\"\u003eIntent or Bundle Data: Simplify extracting values from Android Intent extras or Bundle objects, making the code cleaner and more maintainable.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"a38b\"\u003e\u003cstrong\u003eScenarios where map delegation is useful:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"032b\"\u003eclass Product(private val attributes: Map\u0026lt;String, Any\u0026gt;) {\u003cbr/\u003e    val productId: Int by attributes\u003cbr/\u003e    val productName: String by attributes\u003cbr/\u003e    val price: Double by attributes\u003cbr/\u003e}\u003cp\u003eval productData = mapOf(\u0026#34;productId\u0026#34; to 501, \u0026#34;productName\u0026#34; to \u0026#34;Laptop\u0026#34;, \u0026#34;price\u0026#34; to 1500.0)\u003cbr/\u003eval product = Product(productData)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"b735\"\u003eprivate val data: Map\u0026lt;String, Any?\u0026gt; by lazy {\u003cbr/\u003e  // `keySet()` retrieves all the keys, and `associateWith` maps each key to its corresponding value.\u003cbr/\u003e    intent.extras?.keySet()?.associateWith { intent.extras?.get(it) } ?: emptyMap()\u003cbr/\u003e}\u003cp\u003eval title: String? by data\u003cbr/\u003eval itemId: Int? by data\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"5560\"\u003eprivate val sharedPrefs = context.getSharedPreferences(\u0026#34;UserPrefs\u0026#34;, Context.MODE_PRIVATE)\u003cp\u003eprivate val prefsMap: Map\u0026lt;String, Any?\u0026gt; by lazy {\u003cbr/\u003e    sharedPrefs.all // Get all stored preferences as a map\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eval isDarkMode: Boolean by prefsMap\u003cbr/\u003eval username: String? by prefsMap\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"608c\"\u003eDelegating to Another Property\u003c/h2\u003e\u003cp id=\"6cb1\"\u003eKotlin also always to delegate the getter and setter of a property to another property. This feature is available for both top-level and class properties, including member and extension properties. To delegate a property, use the :: qualifier with the name of the delegate property, such as this::delegate or MyClass::delegate.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e90c\"\u003evar propertyName: Type by this::delegatePropertyName\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f436\"\u003e\u003cstrong\u003eUse Cases for Delegating to Another Property:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"adc6\"\u003eBackward Compatibility: Gradually transition from an old property to a new one while maintaining compatibility with older versions of the codebase.\u003c/li\u003e\u003cli id=\"e3f8\"\u003eStreamlining Updates: Maintain a single source of truth for property values across different properties.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9ddc\"\u003e\u003cstrong\u003eScenarios where delegating to another property is useful:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b42d\"\u003eclass Employee {\u003cbr/\u003e    // New property for storing the current role\u003cbr/\u003e    var currentRole: String = \u0026#34;Junior Developer\u0026#34;\u003cp\u003e    // Deprecated property delegating to the new one\u003cbr/\u003e    @Deprecated(\u0026#34;Use \u0026#39;currentRole\u0026#39; instead\u0026#34;, ReplaceWith(\u0026#34;currentRole\u0026#34;))\u003cbr/\u003e    var previousRole: String by this::currentRole\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efun main() {\u003cbr/\u003e    val employee = Employee()\u003c/p\u003e\u003cp\u003e    // Using the deprecated property\u003cbr/\u003e    // Notification: \u0026#39;previousRole: String\u0026#39; is deprecated. Use \u0026#39;currentRole\u0026#39; instead.\u003cbr/\u003e    employee.previousRole = \u0026#34;Senior Developer\u0026#34;\u003c/p\u003e\u003cp\u003e    // The new property reflects the change\u003cbr/\u003e    println(employee.currentRole) // Output: Senior Developer\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"2bea\"\u003eCustom Property Delegates in Kotlin\u003c/h2\u003e\u003cp id=\"fd64\"\u003eLet’s explore how to map JSON keys directly to Kotlin properties with a custom property delegates. First create a custom extension function to delegating JSON properties.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"edae\"\u003eoperator fun \u0026lt;T\u0026gt; JSONObject.getValue(thisRef: Any?, property: kotlin.reflect.KProperty\u0026lt;*\u0026gt;): T =\u003cbr/\u003e    this.get(property.name) as T\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"3dc8\"\u003eOperator Overloading: The \u003ccode\u003eoperator\u003c/code\u003e keyword allows \u003ccode\u003egetValue\u003c/code\u003e to be used with the \u003ccode\u003eby\u003c/code\u003e keyword, enabling seamless property delegation.\u003c/li\u003e\u003cli id=\"5036\"\u003eProperty Mapping: The \u003ccode\u003eproperty\u003c/code\u003e parameter provides the name of the delegated property, which is used to fetch the corresponding value from the \u003ccode\u003eJSONObject\u003c/code\u003e using \u003ccode\u003ethis.get(property.name)\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"9414\"\u003eGeneric Return Type: The \u003ccode\u003e\u0026lt;T\u0026gt;\u003c/code\u003e makes the function flexible, allowing it to return values of any type (e.g., \u003ccode\u003eString\u003c/code\u003e, \u003ccode\u003eDouble\u003c/code\u003e) by casting the JSON value to the expected type.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e135\"\u003eFinally this function maps JSON keys directly to Kotlin properties using the \u003ccode\u003eby\u003c/code\u003e keyword, simplifying JSON parsing with a clean, reusable pattern.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"644e\"\u003eclass Product(json: JSONObject) {\u003cbr/\u003e    val id: String by json\u003cbr/\u003e    val name: String by json\u003cbr/\u003e    val price: Double by json\u003cbr/\u003e}\u003cp\u003eval json = JSONObject(\u0026#34;\u0026#34;\u0026#34;{\u0026#34;id\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Smartphone\u0026#34;, \u0026#34;price\u0026#34;: 799.99}\u0026#34;\u0026#34;\u0026#34;)\u003cbr/\u003eval product = Product(json)\u003c/p\u003e\u003cp\u003eprintln(product.name) // Output: Smartphone\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"fc54\"\u003eLet’s create another simple reusable custom property delegate to handle reading and writing SharedPreferences properties.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5a2e\"\u003e// Basic implementation of a custom sharedPreferences delegate\u003cbr/\u003eclass SharedPreferencesDelegate\u0026lt;T\u0026gt;(\u003cbr/\u003e    private val sharedPreferences: SharedPreferences,\u003cbr/\u003e    private val key: String,\u003cbr/\u003e    private val defaultValue: T\u003cbr/\u003e) {\u003cbr/\u003e    @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;)\u003cbr/\u003e    operator fun getValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;): T {\u003cbr/\u003e        return when (defaultValue) {\u003cbr/\u003e            is String -\u0026gt; sharedPreferences.getString(key, defaultValue) as T\u003cbr/\u003e            is Int -\u0026gt; sharedPreferences.getInt(key, defaultValue) as T\u003cbr/\u003e            is Boolean -\u0026gt; sharedPreferences.getBoolean(key, defaultValue) as T\u003cbr/\u003e            is Float -\u0026gt; sharedPreferences.getFloat(key, defaultValue) as T\u003cbr/\u003e            is Long -\u0026gt; sharedPreferences.getLong(key, defaultValue) as T\u003cbr/\u003e            else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unsupported type\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cp\u003e    operator fun setValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;, value: T) {\u003cbr/\u003e        with(sharedPreferences.edit()) {\u003cbr/\u003e            when (value) {\u003cbr/\u003e                is String -\u0026gt; putString(key, value)\u003cbr/\u003e                is Int -\u0026gt; putInt(key, value)\u003cbr/\u003e                is Boolean -\u0026gt; putBoolean(key, value)\u003cbr/\u003e                is Float -\u0026gt; putFloat(key, value)\u003cbr/\u003e                is Long -\u0026gt; putLong(key, value)\u003cbr/\u003e                else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unsupported type\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e            apply()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Create a Wrapper Class\u003cbr/\u003eclass AppPreferences(context: Context) {\u003cbr/\u003e    private val sharedPreferences =\u003cbr/\u003e        context.getSharedPreferences(\u0026#34;AppPreferences\u0026#34;, Context.MODE_PRIVATE)\u003c/p\u003e\u003cp\u003e    var username: String by SharedPreferencesDelegate(sharedPreferences, \u0026#34;username\u0026#34;, \u0026#34;Guest\u0026#34;)\u003cbr/\u003e    var isLoggedIn: Boolean by SharedPreferencesDelegate(sharedPreferences, \u0026#34;isLoggedIn\u0026#34;, false)\u003cbr/\u003e    var highScore: Int by SharedPreferencesDelegate(sharedPreferences, \u0026#34;highScore\u0026#34;, 0)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Use the AppPreferences class in Android activity:\u003cbr/\u003eclass MainActivity : AppCompatActivity() {\u003cbr/\u003e    private lateinit var preferences: AppPreferences\u003c/p\u003e\u003cp\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContentView(R.layout.activity_main)\u003c/p\u003e\u003cp\u003e        // Initialize AppPreferences\u003cbr/\u003e        preferences = AppPreferences(this)\u003c/p\u003e\u003cp\u003e        // Save data to SharedPreferences\u003cbr/\u003e        preferences.username = \u0026#34;JohnDoe\u0026#34;\u003cbr/\u003e        preferences.isLoggedIn = true\u003cbr/\u003e        preferences.highScore = 1200\u003c/p\u003e\u003cp\u003e        // Retrieve and display data from SharedPreferences\u003cbr/\u003e        println(\u0026#34;Username: ${preferences.username}\u0026#34;)\u003cbr/\u003e        println(\u0026#34;Is Logged In: ${preferences.isLoggedIn}\u0026#34;)\u003cbr/\u003e        println(\u0026#34;High Score: ${preferences.highScore}\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3517\"\u003eClass Delegation\u003c/h2\u003e\u003cp id=\"8f79\"\u003eClass delegation is a powerful feature in Kotlin that enables a class to delegate the implementation of an interface to another object. This promotes code reusability and simplifies code by separating concerns, allowing to focus on composition over inheritance.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"158b\"\u003eComposition over inheritance means creating software by combining small, reusable pieces instead of using class hierarchies, making code more flexible and easier to maintain.\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"1b25\"\u003e// Define a generic interface\u003cbr/\u003einterface BaseInterface {\u003cbr/\u003e    fun doSomething(): String\u003cbr/\u003e}\u003cp\u003e// Concrete implementation of the interface\u003cbr/\u003eclass ConcreteImplementation : BaseInterface {\u003cbr/\u003e    override fun doSomething(): String {\u003cbr/\u003e        return \u0026#34;Doing something in ConcreteImplementation\u0026#34;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Delegating class that delegates functionality to another object\u003cbr/\u003eclass DelegatingClass(delegate: BaseInterface) : BaseInterface by delegate\u003c/p\u003e\u003cp\u003efun main() {\u003cbr/\u003e    val realImplementation = ConcreteImplementation()\u003c/p\u003e\u003cp\u003e    // Create a delegating object\u003cbr/\u003e    val delegatingObject = DelegatingClass(realImplementation)\u003c/p\u003e\u003cp\u003e    // Call the function via the delegating object\u003cbr/\u003e    println(delegatingObject.doSomething()) // Output: Doing something in ConcreteImplementation\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bf0c\"\u003eHere the Base Interface defines the contract, the Concrete Implementation provides the functionality, and the Delegating Class uses by to automatically forward all functions to the provided implementation.\u003c/p\u003e\u003cp id=\"3b8f\"\u003e\u003cstrong\u003eUse cases for class delegation:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"0a34\"\u003eReusable Logic: Class delegation lets reuse code by passing responsibilities to another class instead of repeating the code in subclasses.\u003c/li\u003e\u003cli id=\"2cd9\"\u003eComposition Over Inheritance: It offers a cleaner alternative to inheritance, helping create modular classes that focus on composition rather than subclassing.\u003c/li\u003e\u003cli id=\"b846\"\u003eDecouple Code: Delegation reduces tight coupling by allowing a class to delegate some of its tasks to another class, making code more flexible and easier to maintain.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"0195\"\u003e\u003cstrong\u003eScenarios where class delegation is useful:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a47c\"\u003e//Define Multiple Interfaces for Delegation\u003cbr/\u003einterface LoadingState {\u003cbr/\u003e    fun showLoading(isLoading: Boolean)\u003cbr/\u003e}\u003cp\u003einterface ErrorHandler {\u003cbr/\u003e    fun handleNetworkError(error: String)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003einterface UserInteraction {\u003cbr/\u003e    fun handleUserClick(action: String)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Implement the Interfaces\u003cbr/\u003eclass LoadingStateImpl : LoadingState {\u003cbr/\u003e    override fun showLoading(isLoading: Boolean) {\u003cbr/\u003e        if (isLoading) {\u003cbr/\u003e            println(\u0026#34;Loading...\u0026#34;)\u003cbr/\u003e        } else {\u003cbr/\u003e            println(\u0026#34;Loading finished.\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eclass ErrorHandlerImpl : ErrorHandler {\u003cbr/\u003e    override fun handleNetworkError(error: String) {\u003cbr/\u003e        println(\u0026#34;Network Error: $error\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eclass UserInteractionImpl : UserInteraction {\u003cbr/\u003e    override fun handleUserClick(action: String) {\u003cbr/\u003e        println(\u0026#34;User clicked on: $action\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e//Delegate Only Necessary Behaviors in the Activity\u003cbr/\u003eclass MainActivity : AppCompatActivity(), LoadingState by LoadingStateImpl(),\u003cbr/\u003e    ErrorHandler by ErrorHandlerImpl(), UserInteraction by UserInteractionImpl() {\u003c/p\u003e\u003cp\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContentView(R.layout.activity_main)\u003c/p\u003e\u003cp\u003e        // Show loading state\u003cbr/\u003e        showLoading(true)\u003c/p\u003e\u003cp\u003e        // Simulate a network error\u003cbr/\u003e        handleNetworkError(\u0026#34;Failed to fetch data\u0026#34;)\u003c/p\u003e\u003cp\u003e        // Handle user click action\u003cbr/\u003e        handleUserClick(\u0026#34;Submit Button\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e//Delegate Only Necessary Behaviors in the Activity\u003cbr/\u003eclass AnotherActivity : AppCompatActivity(), LoadingState by LoadingStateImpl(),\u003cbr/\u003e    ErrorHandler by ErrorHandlerImpl(){\u003c/p\u003e\u003cp\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContentView(R.layout.activity_another)\u003c/p\u003e\u003cp\u003e        // Show loading\u003cbr/\u003e        showLoading(true)\u003c/p\u003e\u003cp\u003e        // Simulate a network error\u003cbr/\u003e        handleNetworkError(\u0026#34;Connection timeout\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a157\"\u003eUnlike base class inheritance, class delegation enables you to share behavior without tightly coupling activities to a common base class. It provides greater flexibility and separation of concerns, keeping your code clean, modular, and easier to extend.\u003c/p\u003e\u003cp id=\"daec\"\u003eKotlin Delegates are a great way to simplify your code and improve readability. Explore the built-in and custom delegates to enhance your Kotlin projects. Feel free to reach out and share your thoughts on this article or any other Kotlin-related topics! You can connect with me on \u003ca href=\"https://www.linkedin.com/in/ihjohny/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e — let’s keep the conversation going!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2025-01-26T11:23:35.433Z",
  "modifiedTime": null
}
