{
  "id": "65b8ecc4-494c-4f47-8c60-ecc0911c9ff5",
  "title": "Exercise Caution When Using Kotlin runBlocking on Android",
  "link": "https://proandroiddev.com/exercise-caution-when-using-runblocking-on-android-e335796f869e?source=rss----c72404660798---4",
  "description": "",
  "author": "Jaewoong Eum",
  "published": "Thu, 06 Feb 2025 14:36:04 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "kotlin",
    "androiddev",
    "coroutine",
    "android-app-development"
  ],
  "byline": "Jaewoong Eum",
  "length": 11363,
  "excerpt": "As Kotlin continues to dominate as the preferred language for Android development, developers must understand its underlying mechanisms. One of Kotlin’s standout features is its built-in support for…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "As Kotlin continues to dominate as the preferred language for Android development, developers must understand its underlying mechanisms. One of Kotlin’s standout features is its built-in support for asynchronous and non-blocking programming at the language level, offering developers powerful tools to build efficient and responsive applications.Coroutines in Kotlin can be created using coroutine builders — specialized functions designed to initiate and manage coroutines. Common builders include launch, async, and runBlocking. Among these, runBlocking is frequently featured in Kotlin's official documentation to demonstrate coroutine usage, such as within the main() function. As a result, many Android developers are already familiar with its use cases.So, how does runBlocking work under the hood? In this article, we will delve into its internal mechanism and explore why it should be used cautiously by looking at some sample cases, particularly in Android development.Understanding runBlockingIf you’ve explored Coroutines references, you’ve likely encountered code like the example below across official Kotlin documentation, articles, sample projects, and other resources:Sample code examples frequently showcase runBlocking within the main function, which might lead you to think, \"Oh, this is amazing. I can call any suspend function without needing a coroutine scope and even retrieve its result effortlessly. This is convenient!\"Nowadays, most developers are aware of using viewModelScope to launch coroutines safely, ensuring jobs are automatically canceled in alignment with the ViewModel's lifecycle in Android development. However, when Coroutines were first introduced, it was a common mistake for developers to write code like the example below:This approach worked seamlessly without introducing noticeable delays or issues in the application because fetching a small chunk of data from the network is not a big deal in most cases. Why can this approach pose a problem? According to the official documentation, runBlocking launches a new coroutine and blocks the current thread until the coroutine's execution is complete.On the Android system, the main thread is responsible for rendering screens and handling UI interactions. If the main thread is blocked or utilized for tasks like I/O operations, it can lead to screen freezes or even cause an Application Not Responding (ANR). So, using runBlocking in the Android UI code to execute I/O tasks, such as querying a database or fetching data from the network, poses significant risks in Android development and should be avoided.Examining runBlocking internalsLet’s delve into the internal implementation of runBlocking to understand how it operates under the hood:If you examine the internal implementation of runBlocking, you’ll find that it launches a new coroutine on the current thread while leveraging the GlobalScope to derive the coroutine context.It initializes a new instance of BlockingCoroutine, and upon examining the internal implementation of BlockingCoroutine, particularly the joinBlocking method, it becomes evident that this method blocks and occupies the current thread entirely until all tasks are completed.As demonstrated in the code above, the BlockingCoroutine blocks the current thread by executing a while (true) infinite loop. It continuously processes events (blocking) from the current thread's event loop, breaking the infinite loop (and unblocking) only when the coroutine job is completed. Ultimately, this represents a synchronization task that halts the current thread until the launched coroutine task finishes execution.For this reason, it is essential to use runBlocking cautiously to avoid blocking the Android main thread. Doing so can result in an ANR, severely impacting your application's performance and user experience.Why is using runBlocking on Android problematic?Let’s delve into why runBlocking can pose challenges in Android development by examining the provided sample code examples.The first exampleYou might now be curious about what happens when you set the dispatcher to Dispatchers.IO for launching coroutines, as shown in the example below:It might seem like everything should work as expected since we’ve switched to using Dispatchers.IO to launch the coroutines on a background thread. However, when you execute the function, it will produce logs similar to the output shown below:11:50:07.077 17067-17067 onCreate11:50:07.094 17067-17092 currentThread: Thread[DefaultDispatcher-worker-2,5,main]11:50:10.100 17067-17092 job completedAs evident from the log output above, it takes 3 seconds before the “job completed” log message is printed. Although the delay(3000) function runs on a worker thread, the main thread remains blocked, waiting for the coroutine task to complete. Consequently, the entire UI will remain frozen for 3 seconds, causing the application to become unresponsive during this period. Running the coroutine on a different thread using Dispatchers.IO on runBlocking does not achieve true asynchronous behavior in this scenario.The second exampleWhat happens if you use Dispatchers.Main instead of Dispatchers.IO with the runBlocking function? Since runBlocking operates on the main thread by default, it should theoretically work as expected with the sample code shown below:However, if you run the function above, you’ll see the log result below:12:05:42.802 17827-17827 onCreateHere’s something interesting: even the log message about the current thread is not printed, indicating that the function was blocked during the execution of runBlocking(Dispatchers.Main). Additionally, the UI remains frozen indefinitely and fails to render any layouts on the screen.This happens because the runBlocking function inherently blocks the main thread to launch a new coroutine scope. However, the coroutine scope attempts to switch the context to Dispatchers.Main, leading to a deadlock. Since the main thread is already occupied by runBlocking, it cannot process the coroutine on the same thread, causing a complete deadlock.As a result, the main thread remains blocked indefinitely, making this scenario even worse than using Dispatchers.IO.The third exampleNow, let’s explore another scenario. Since runBlocking blocks the current thread internally, what happens if we launch it on a worker thread? Consider the sample code below:If you run the function above, you’ll see the log message result below:12:19:09.883 17946-17946 onCreate12:19:09.907 17946-17971 currentThread: Thread[DefaultDispatcher-worker-2,5,main]12:19:09.917 17946-17971 currentThread: Thread[DefaultDispatcher-worker-2,5,main]12:19:12.919 17946-17971 job completed12:19:12.919 17946-17971 Result: 24Since the current thread executing runBlocking is switched to a worker thread by creating the coroutine scope with CoroutineScope(Dispatchers.IO), runBlocking will block only the worker thread. This means that while the execution takes 3 seconds to complete, it runs entirely on the worker thread, ensuring the main thread remains unblocked and unaffected, avoiding any UI freezing issues. In this case, blocking the main thread and freezing the UI layouts is entirely avoided.When can you use runBlocking?So when can you use runBlocking safely? There are two primary scenarios where its usage is appropriate: unit testing and synchronization tasks.Writing Unit TestOne of the most common use cases for runBlocking is executing unit test code. In testing scenarios, runBlocking is frequently used to test suspending functions or coroutine-based code in a blocking manner, as shown in the example below:This approach is particularly useful in synchronous testing environments where the coroutine context is controlled, ensuring predictable behavior for assertions.However, in unit testing, runTest is generally the preferred method. On JVM and Native platforms, it functions similarly to runBlocking, but with the added advantage of skipping delays within the code. This enables you to use delay without prolonging test execution time, resulting in more efficient and faster tests.Synchronization and launch()The second use case for runBlocking arises when you can confidently ensure that the operation will run on an I/O thread. Since runBlocking blocks the current thread until the coroutine task is complete, it can be suitable for running synchronized tasks on an I/O thread where blocking behavior is acceptable.For instance, Stream Video SDK uses runBlocking to implement its socket re-joining feature. This is because the publisher and subscriber of the socket must be properly closed after the socket disconnection is fully completed. The SDK carefully ensures that the prepareRejoin method is executed exclusively on the I/O thread to maintain thread safety and reliability.Alternatively, you can execute a coroutine task synchronously using the Job.join() method instead of runBlocking. Before delving into Job.join(), it’s important to first understand the behavior of the launch() method, as it returns a Job instance. Consider the example below:13:05:26.353 2273-2273 onCreate13:05:26.653 2273-2964 currentThread: Thread[DefaultDispatcher-worker-1,5,main]13:05:26.654 job completed: StandaloneCoroutine{Active}@dbc77c913:05:26.706 2273-2964 currentThread: Thread[DefaultDispatcher-worker-1,5,main]13:05:29.707 2273-3367 end launchYou may have noticed that the \"job completed\" log message is printed earlier than the \"end launch\" message. This behavior is due to the nature of the launch() function. The launch() function starts a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job, allowing it to execute asynchronously while the next tasks continue. But what if you want to suspend the coroutine until this job is complete?The solution is to use the Job.join() method, which suspends the coroutine until the job is completed. This method resumes execution normally once the job finishes for any reason, provided the invoking coroutine's job is still active. You can leverage Job.join() for synchronization purposes, as demonstrated in the example below:If you run the example above, you will see the following log messages:13:21:02.246 6237-6237 onCreate13:21:02.279 6237-6260 currentThread: Thread[DefaultDispatcher-worker-1,5,main]13:21:02.279 6237-6262 currentThread: Thread[DefaultDispatcher-worker-3,5,main]13:21:05.281 6237-6294 end launch13:21:05.282 6237-6294 job completed: StandaloneCoroutine{Completed}@a5573c8As shown in the log messages above, it took 3 seconds to print the \"end launch\" message, followed by the \"job completed\" message.ConclusionIn this article, you’ve explored why runBlocking should be used with caution, particularly on Android. Coroutines have gained significant popularity in recent years for handling asynchronous tasks at the language level, becoming one of the most widely adopted tools. However, to use them effectively in your projects, it’s essential to understand their exact role, internal mechanisms, and proper application.If you have any questions or feedback on this article, you can find the author on Twitter @github_skydoves or GitHub if you have any questions or feedback. If you’d like to stay up to date with Stream, follow us on Twitter @getstream_io for more great technical content.As always, happy coding!— Jaewoong",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*_-6RFnU7DtCjU2uS",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://skydoves.medium.com/?source=post_page---byline--e335796f869e--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Jaewoong Eum\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*to22-X47VSP4tZeElwVKKA.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--e335796f869e--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"9135\"\u003eAs Kotlin continues to dominate as the preferred language for Android development, developers must understand its underlying mechanisms. One of Kotlin’s standout features is its built-in support for \u003ca href=\"https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003easynchronous\u003c/a\u003e and \u003ca href=\"https://en.wikipedia.org/wiki/Non-blocking_algorithm\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003enon-blocking\u003c/a\u003e programming at the language level, offering developers powerful tools to build efficient and responsive applications.\u003c/p\u003e\u003cp id=\"5253\"\u003e\u003ca href=\"https://kotlinlang.org/docs/coroutines-overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoroutines\u003c/a\u003e in Kotlin can be created using coroutine builders — specialized functions designed to initiate and manage coroutines. Common builders include \u003ccode\u003elaunch\u003c/code\u003e, \u003ccode\u003easync\u003c/code\u003e, and \u003ccode\u003erunBlocking\u003c/code\u003e. Among these, \u003ccode\u003erunBlocking\u003c/code\u003e is frequently featured in Kotlin\u0026#39;s official documentation to demonstrate coroutine usage, such as within the \u003ccode\u003emain()\u003c/code\u003e function. As a result, many Android developers are already familiar with its use cases.\u003c/p\u003e\u003cp id=\"b7a8\"\u003eSo, how does \u003ccode\u003erunBlocking\u003c/code\u003e work under the hood? In this article, we will delve into its internal mechanism and explore why it should be used cautiously by looking at some sample cases, particularly in Android development.\u003c/p\u003e\u003ch2 id=\"c4e2\"\u003eUnderstanding runBlocking\u003c/h2\u003e\u003cp id=\"4a3d\"\u003eIf you’ve explored Coroutines references, you’ve likely encountered code like the example below across official Kotlin documentation, articles, sample projects, and other resources:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d791\"\u003eSample code examples frequently showcase \u003ccode\u003erunBlocking\u003c/code\u003e within the main function, which might lead you to think, \u003cem\u003e\u0026#34;Oh, this is amazing. I can call any suspend function without needing a coroutine scope and even retrieve its result effortlessly. This is convenient!\u0026#34;\u003c/em\u003e\u003c/p\u003e\u003cp id=\"6a95\"\u003eNowadays, most developers are aware of using \u003ca href=\"https://developer.android.com/topic/libraries/architecture/coroutines#viewmodelscope\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eviewModelScope\u003c/a\u003e to launch coroutines safely, ensuring jobs are automatically canceled in alignment with the \u003ccode\u003eViewModel\u003c/code\u003e\u0026#39;s lifecycle in Android development. However, when Coroutines were first introduced, it was a common mistake for developers to write code like the example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"45d0\"\u003eThis approach worked seamlessly without introducing noticeable delays or issues in the application because fetching a small chunk of data from the network is not a big deal in most cases. Why can this approach pose a problem? \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAccording to the official documentation\u003c/a\u003e, \u003ccode\u003erunBlocking\u003c/code\u003e launches a new coroutine and blocks the current thread until the coroutine\u0026#39;s execution is complete.\u003c/p\u003e\u003cp id=\"2b9a\"\u003eOn the Android system, the main thread is responsible for rendering screens and handling UI interactions. If the main thread is blocked or utilized for tasks like I/O operations, it can lead to screen freezes or even cause an \u003ca href=\"https://developer.android.com/topic/performance/vitals/anr\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eApplication Not Responding (ANR)\u003c/a\u003e. So, using \u003ccode\u003erunBlocking\u003c/code\u003e in the Android UI code to execute I/O tasks, such as querying a database or fetching data from the network, poses significant risks in Android development and should be avoided.\u003c/p\u003e\u003ch2 id=\"541b\"\u003eExamining runBlocking internals\u003c/h2\u003e\u003cp id=\"ca13\"\u003eLet’s delve into the internal implementation of \u003ccode\u003erunBlocking\u003c/code\u003e to understand how it operates under the hood:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"30e2\"\u003eIf you examine the internal implementation of runBlocking, you’ll find that it launches a new coroutine on the current thread while leveraging the \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGlobalScope\u003c/a\u003e to derive the coroutine context.\u003c/p\u003e\u003cp id=\"8805\"\u003eIt initializes a new instance of \u003ccode\u003eBlockingCoroutine\u003c/code\u003e, and upon examining the internal implementation of \u003ccode\u003eBlockingCoroutine\u003c/code\u003e, particularly the \u003ccode\u003ejoinBlocking\u003c/code\u003e method, it becomes evident that this method blocks and occupies the current thread entirely until all tasks are completed.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a6c5\"\u003eAs demonstrated in the code above, the \u003ccode\u003eBlockingCoroutine\u003c/code\u003e blocks the current thread by executing a \u003ccode\u003ewhile (true)\u003c/code\u003e infinite loop. It continuously processes events (blocking) from the current thread\u0026#39;s event loop, breaking the infinite loop (and unblocking) only when the coroutine job is completed. Ultimately, this represents a synchronization task that halts the current thread until the launched coroutine task finishes execution.\u003c/p\u003e\u003cp id=\"1ef9\"\u003eFor this reason, it is essential to use \u003ccode\u003erunBlocking\u003c/code\u003e cautiously to avoid blocking the Android main thread. Doing so can result in an ANR, severely impacting your application\u0026#39;s performance and user experience.\u003c/p\u003e\u003ch2 id=\"c5f8\"\u003eWhy is using runBlocking on Android problematic?\u003c/h2\u003e\u003cp id=\"24f4\"\u003eLet’s delve into why \u003ccode\u003erunBlocking\u003c/code\u003e can pose challenges in Android development by examining the provided sample code examples.\u003c/p\u003e\u003ch2 id=\"8bae\"\u003eThe first example\u003c/h2\u003e\u003cp id=\"0d46\"\u003eYou might now be curious about what happens when you set the dispatcher to \u003ccode\u003eDispatchers.IO\u003c/code\u003e for launching coroutines, as shown in the example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a6ec\"\u003eIt might seem like everything should work as expected since we’ve switched to using \u003ccode\u003eDispatchers.IO\u003c/code\u003e to launch the coroutines on a background thread. However, when you execute the function, it will produce logs similar to the output shown below:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8571\"\u003e11:50:07.077 17067-17067 onCreate\u003cbr/\u003e11:50:07.094 17067-17092 currentThread: Thread[DefaultDispatcher-worker-2,5,main]\u003cbr/\u003e11:50:10.100 17067-17092 job completed\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5e3a\"\u003eAs evident from the log output above, it takes 3 seconds before the “job completed” log message is printed. Although the \u003ccode\u003edelay(3000)\u003c/code\u003e function runs on a worker thread, the main thread remains blocked, waiting for the coroutine task to complete. Consequently, the entire UI will remain frozen for 3 seconds, causing the application to become unresponsive during this period. Running the coroutine on a different thread using \u003ccode\u003eDispatchers.IO\u003c/code\u003e on \u003ccode\u003erunBlocking\u003c/code\u003e does not achieve true asynchronous behavior in this scenario.\u003c/p\u003e\u003ch2 id=\"88c9\"\u003eThe second example\u003c/h2\u003e\u003cp id=\"5631\"\u003eWhat happens if you use \u003ccode\u003eDispatchers.Main\u003c/code\u003e instead of \u003ccode\u003eDispatchers.IO\u003c/code\u003e with the \u003ccode\u003erunBlocking\u003c/code\u003e function? Since \u003ccode\u003erunBlocking\u003c/code\u003e operates on the main thread by default, it should theoretically work as expected with the sample code shown below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"092e\"\u003eHowever, if you run the function above, you’ll see the log result below:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0016\"\u003e12:05:42.802 17827-17827 onCreate\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"14da\"\u003eHere’s something interesting: even the log message about the current thread is not printed, indicating that the function was blocked during the execution of \u003ccode\u003erunBlocking(Dispatchers.Main)\u003c/code\u003e. Additionally, the UI remains frozen indefinitely and fails to render any layouts on the screen.\u003c/p\u003e\u003cp id=\"710f\"\u003eThis happens because the \u003ccode\u003erunBlocking\u003c/code\u003e function inherently blocks the main thread to launch a new coroutine scope. However, the coroutine scope attempts to switch the context to \u003ccode\u003eDispatchers.Main\u003c/code\u003e, leading to a deadlock. Since the main thread is already occupied by \u003ccode\u003erunBlocking\u003c/code\u003e, it cannot process the coroutine on the same thread, causing a complete deadlock.\u003c/p\u003e\u003cp id=\"3a09\"\u003eAs a result, the main thread remains blocked indefinitely, making this scenario even worse than using \u003ccode\u003eDispatchers.IO\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"e2af\"\u003eThe third example\u003c/h2\u003e\u003cp id=\"2790\"\u003eNow, let’s explore another scenario. Since \u003ccode\u003erunBlocking\u003c/code\u003e blocks the current thread internally, what happens if we launch it on a worker thread? Consider the sample code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"226f\"\u003eIf you run the function above, you’ll see the log message result below:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c442\"\u003e12:19:09.883 17946-17946 onCreate\u003cbr/\u003e12:19:09.907 17946-17971 currentThread: Thread[DefaultDispatcher-worker-2,5,main]\u003cbr/\u003e12:19:09.917 17946-17971 currentThread: Thread[DefaultDispatcher-worker-2,5,main]\u003cbr/\u003e12:19:12.919 17946-17971 job completed\u003cbr/\u003e12:19:12.919 17946-17971 Result: 24\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"70ce\"\u003eSince the current thread executing \u003ccode\u003erunBlocking\u003c/code\u003e is switched to a worker thread by creating the coroutine scope with \u003ccode\u003eCoroutineScope(Dispatchers.IO)\u003c/code\u003e, \u003ccode\u003erunBlocking\u003c/code\u003e will block only the worker thread. This means that while the execution takes 3 seconds to complete, it runs entirely on the worker thread, ensuring the main thread remains unblocked and unaffected, avoiding any UI freezing issues. In this case, blocking the main thread and freezing the UI layouts is entirely avoided.\u003c/p\u003e\u003ch2 id=\"97a7\"\u003eWhen can you use runBlocking?\u003c/h2\u003e\u003cp id=\"cf6f\"\u003eSo when can you use \u003ccode\u003erunBlocking\u003c/code\u003e safely? There are two primary scenarios where its usage is appropriate: unit testing and synchronization tasks.\u003c/p\u003e\u003ch2 id=\"126f\"\u003eWriting Unit Test\u003c/h2\u003e\u003cp id=\"1734\"\u003eOne of the most common use cases for \u003ccode\u003erunBlocking\u003c/code\u003e is executing unit test code. In testing scenarios, \u003ccode\u003erunBlocking\u003c/code\u003e is frequently used to test suspending functions or coroutine-based code in a blocking manner, as shown in the example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d604\"\u003eThis approach is particularly useful in synchronous testing environments where the coroutine context is controlled, ensuring predictable behavior for assertions.\u003c/p\u003e\u003cp id=\"6a25\"\u003eHowever, in unit testing, \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003erunTest\u003c/a\u003e is generally the preferred method. On JVM and Native platforms, it functions similarly to \u003ccode\u003erunBlocking\u003c/code\u003e, but with the added advantage of skipping delays within the code. This enables you to use \u003ccode\u003edelay\u003c/code\u003e without prolonging test execution time, resulting in more efficient and faster tests.\u003c/p\u003e\u003ch2 id=\"2a7c\"\u003eSynchronization and launch()\u003c/h2\u003e\u003cp id=\"4935\"\u003eThe second use case for \u003ccode\u003erunBlocking\u003c/code\u003e arises when you can confidently ensure that the operation will run on an I/O thread. Since \u003ccode\u003erunBlocking\u003c/code\u003e blocks the current thread until the coroutine task is complete, it can be suitable for running synchronized tasks on an I/O thread where blocking behavior is acceptable.\u003c/p\u003e\u003cp id=\"9b5d\"\u003eFor instance, \u003ca href=\"https://getstream.io/video/docs/android/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStream Video SDK\u003c/a\u003e uses \u003ccode\u003erunBlocking\u003c/code\u003e to implement its socket re-joining feature. This is because the publisher and subscriber of the socket must be properly closed after the socket disconnection is fully completed. The SDK carefully ensures that the \u003ccode\u003e\u003ca href=\"https://github.com/GetStream/stream-video-android/blob/0d9bd7c43170369b6986eeaf0e5d8403d1383ebc/stream-video-android-core/src/main/kotlin/io/getstream/video/android/core/call/RtcSession.kt#L1682\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eprepareRejoin\u003c/a\u003e\u003c/code\u003e method is executed exclusively on the I/O thread to maintain thread safety and reliability.\u003c/p\u003e\u003cp id=\"dea8\"\u003eAlternatively, you can execute a coroutine task synchronously using the \u003ccode\u003eJob.join()\u003c/code\u003e method instead of \u003ccode\u003erunBlocking\u003c/code\u003e. Before delving into \u003ccode\u003eJob.join()\u003c/code\u003e, it’s important to first understand the behavior of the \u003ccode\u003elaunch()\u003c/code\u003e method, as it returns a \u003ccode\u003eJob\u003c/code\u003e instance. Consider the example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cpre\u003e\u003cspan id=\"e03f\"\u003e13:05:26.353  2273-2273 onCreate\u003cbr/\u003e13:05:26.653  2273-2964 currentThread: Thread[DefaultDispatcher-worker-1,5,main]\u003cbr/\u003e13:05:26.654 job completed: StandaloneCoroutine{Active}@dbc77c9\u003cbr/\u003e13:05:26.706  2273-2964 currentThread: Thread[DefaultDispatcher-worker-1,5,main]\u003cbr/\u003e13:05:29.707  2273-3367 end launch\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"15b6\"\u003eYou may have noticed that the \u0026#34;job completed\u0026#34; log message is printed earlier than the \u0026#34;end launch\u0026#34; message. This behavior is due to the nature of the \u003ccode\u003elaunch()\u003c/code\u003e function. The \u003ccode\u003elaunch()\u003c/code\u003e function starts a new coroutine without blocking the current thread and returns a reference to the coroutine as a \u003ccode\u003eJob\u003c/code\u003e, allowing it to execute asynchronously while the next tasks continue. But what if you want to suspend the coroutine until this job is complete?\u003c/p\u003e\u003cp id=\"15cb\"\u003eThe solution is to use the \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJob.join()\u003c/a\u003e\u003c/code\u003e method, which suspends the coroutine until the job is completed. This method resumes execution normally once the job finishes for any reason, provided the invoking coroutine\u0026#39;s job is still active. You can leverage \u003ccode\u003eJob.join()\u003c/code\u003e for synchronization purposes, as demonstrated in the example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"bfd1\"\u003eIf you run the example above, you will see the following log messages:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4073\"\u003e13:21:02.246  6237-6237 onCreate\u003cbr/\u003e13:21:02.279  6237-6260 currentThread: Thread[DefaultDispatcher-worker-1,5,main]\u003cbr/\u003e13:21:02.279  6237-6262 currentThread: Thread[DefaultDispatcher-worker-3,5,main]\u003cbr/\u003e13:21:05.281  6237-6294 end launch\u003cbr/\u003e13:21:05.282  6237-6294 job completed: StandaloneCoroutine{Completed}@a5573c8\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"05ff\"\u003eAs shown in the log messages above, it took 3 seconds to print the \u0026#34;end launch\u0026#34; message, followed by the \u0026#34;job completed\u0026#34; message.\u003c/p\u003e\u003ch2 id=\"2988\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"773a\"\u003eIn this article, you’ve explored why \u003ccode\u003erunBlocking\u003c/code\u003e should be used with caution, particularly on Android. Coroutines have gained significant popularity in recent years for handling asynchronous tasks at the language level, becoming one of the most widely adopted tools. However, to use them effectively in your projects, it’s essential to understand their exact role, internal mechanisms, and proper application.\u003c/p\u003e\u003cp id=\"8df1\"\u003eIf you have any questions or feedback on this article, you can find the author on Twitter \u003ca href=\"https://twitter.com/github_skydoves\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@github_skydoves\u003c/a\u003e or \u003ca href=\"https://github.com/skydoves\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub\u003c/a\u003e if you have any questions or feedback. If you’d like to stay up to date with Stream, follow us on Twitter \u003ca href=\"https://twitter.com/getstream_io\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@getstream_io\u003c/a\u003e for more great technical content.\u003c/p\u003e\u003cp id=\"5936\"\u003eAs always, happy coding!\u003c/p\u003e\u003cp id=\"332a\"\u003e— \u003ca href=\"https://github.com/skydoves\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJaewoong\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-02-06T00:52:55.557Z",
  "modifiedTime": null
}
