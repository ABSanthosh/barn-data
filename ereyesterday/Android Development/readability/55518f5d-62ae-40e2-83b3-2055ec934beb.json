{
  "id": "55518f5d-62ae-40e2-83b3-2055ec934beb",
  "title": "Getting Started with CameraX in Jetpack Compose",
  "link": "https://medium.com/androiddevelopers/getting-started-with-camerax-in-jetpack-compose-781c722ca0c4?source=rss----95b274b437c2---4",
  "description": "",
  "author": "Jolanda Verhoef",
  "published": "Tue, 07 Jan 2025 17:31:10 GMT",
  "source": "https://medium.com/feed/androiddevelopers",
  "categories": [
    "android",
    "jetpack-compose",
    "androidx",
    "programming",
    "kotlin"
  ],
  "byline": "Jolanda Verhoef",
  "length": 10032,
  "excerpt": "This blog post is a part of Camera and Media Spotlight Week. Weâ€™re providing resources â€” blog posts, videos, sample code, and more â€” all designed to help you uplevel the media experiences in yourâ€¦",
  "siteName": "Android Developers",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Part 1 of Unlocking the Power of CameraX in Jetpack ComposeThis blog post is a part of Camera and Media Spotlight Week. Weâ€™re providing resources â€” blog posts, videos, sample code, and more â€” all designed to help you uplevel the media experiences in your app.To learn more about what Spotlight Week has to offer and how it can benefit you, be sure to read our overview blog post.Weâ€™ve heard from you that you love the power that both the CameraX and Jetpack Compose libraries give you, but that youâ€™d like idiomatic Compose APIs for building Camera UIs. This year, our engineering teams worked on two new Compose artifacts, the low-level viewfinder-compose and the high-level camera-compose. Both are now available as alpha releases ðŸš€ðŸš€ðŸš€.In this blog post series, weâ€™ll show you how to integrate the camera-compose APIs in your app. But more excitingly, weâ€™ll show you some of the âœ¨ delightful UI experiences that integration with Compose unlocks. All the amazing Compose features, like adaptive APIs and animation support, integrate seamlessly with the camera preview!Hereâ€™s a short summary of what each post will contain:ðŸ§± Part 1 (this post): Building a basic camera preview using the new camera-compose artifact. Weâ€™ll cover permission handling and basic integration.ðŸ‘† Part 2: Using the Compose gesture system, graphics, and coroutines to implement a visual tap-to-focus.ðŸ”Ž Part 3: Exploring how to overlay Compose UI elements on top of your camera preview for a richer user experience.ðŸ“‚ Part 4: Using adaptive APIs and the Compose animation framework to smoothly animate to and from tabletop mode on foldable phones.With all of these in action, our final app will look as follows:In addition, it will smoothly move to and from tabletop mode:By the end of this first post, youâ€™ll have a functional camera viewfinder ready to be expanded upon in the subsequent parts of the series. Do please code along, itâ€™s the best way to learn!Add the library dependenciesIâ€™m assuming that you already have Compose set up in your app. If you want to follow along, simply create a new app in Android Studio. I typically use the latest Canary version, because it has the latest Compose templates (and because I like living on the edge ðŸ˜€).Add the following to your libs.versions.toml file:[versions]..camerax = \"1.5.0-alpha03\"accompanist = \"0.36.0\" # or whatever matches with your Compose version[libraries]..# Contains the basic camera functionality such as SurfaceRequestandroidx-camera-core = { module = \"androidx.camera:camera-core\", version.ref = \"camerax\" }# Contains the CameraXViewfinder composableandroidx-camera-compose = { module = \"androidx.camera:camera-compose\", version.ref = \"camerax\" }# Allows us to bind the camera preview to our UI lifecycleandroidx-camera-lifecycle = { group = \"androidx.camera\", name = \"camera-lifecycle\", version.ref = \"camerax\" }# The specific camera implementation that renders the previewandroidx-camera-camera2 = { module = \"androidx.camera:camera-camera2\", version.ref = \"camerax\" }# The helper library to grant the camera permissionaccompanist-permissions = { module = \"com.google.accompanist:accompanist-permissions\", version.ref = \"accompanist\" }Next, add these to your module build.gradle.kts dependencies block:dependencies { .. implementation(libs.androidx.camera.core) implementation(libs.androidx.camera.compose) implementation(libs.androidx.camera.lifecycle) implementation(libs.androidx.camera.camera2) implementation(libs.accompanist.permissions)}We added all dependencies so that we can grant the camera permission and then actually display the camera preview. Next, letâ€™s look at granting the right permission.Grant camera permissionsThe Accompanist permissions library allows us to easily grant the right camera permission. First, we need to set up the AndroidManifest.xml:\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003cuses-feature android:name=\"android.hardware.camera\" android:required=\"true\" /\u003e \u003cuses-permission android:name=\"android.permission.CAMERA\" /\u003e ..\u003c/manifest\u003eNow, we can simply follow the libraryâ€™s instructions to grant the right permission:class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) enableEdgeToEdge() setContent { MyApplicationTheme { CameraPreviewScreen() } } }}@OptIn(ExperimentalPermissionsApi::class)@Composablefun CameraPreviewScreen(modifier: Modifier = Modifier) { val cameraPermissionState = rememberPermissionState(android.Manifest.permission.CAMERA) if (cameraPermissionState.status.isGranted) { CameraPreviewContent(modifier) } else { Column( modifier = modifier.fillMaxSize().wrapContentSize().widthIn(max = 480.dp), horizontalAlignment = Alignment.CenterHorizontally ) { val textToShow = if (cameraPermissionState.status.shouldShowRationale) { // If the user has denied the permission but the rationale can be shown, // then gently explain why the app requires this permission \"Whoops! Looks like we need your camera to work our magic!\" + \"Don't worry, we just wanna see your pretty face (and maybe some cats). \" + \"Grant us permission and let's get this party started!\" } else { // If it's the first time the user lands on this feature, or the user // doesn't want to be asked again for this permission, explain that the // permission is required \"Hi there! We need your camera to work our magic! âœ¨\\n\" + \"Grant us permission and let's get this party started! \\uD83C\\uDF89\" } Text(textToShow, textAlign = TextAlign.Center) Spacer(Modifier.height(16.dp)) Button(onClick = { cameraPermissionState.launchPermissionRequest() }) { Text(\"Unleash the Camera!\") } } }}@Composableprivate fun CameraPreviewContent(modifier: Modifier = Modifier) { // TODO: Implement}With this, we get a nice UI that allows the user to grant the camera permission before showing the camera preview:Create a ViewModelIt is good practice to separate our business logic from our UI. We can do this by creating a view model for our screen. This view model sets up the CameraX Preview use case. Please note that use cases in CameraX represent configurations of various workflows one can implement with the library, i.e. previewing, capturing, recording, and analyzing. The view model also binds the UI to the camera provider:class CameraPreviewViewModel : ViewModel() { // Used to set up a link between the Camera and your UI. private val _surfaceRequest = MutableStateFlow\u003cSurfaceRequest?\u003e(null) val surfaceRequest: StateFlow\u003cSurfaceRequest?\u003e = _surfaceRequest private val cameraPreviewUseCase = Preview.Builder().build().apply { setSurfaceProvider { newSurfaceRequest -\u003e _surfaceRequest.update { newSurfaceRequest } } } suspend fun bindToCamera(appContext: Context, lifecycleOwner: LifecycleOwner) { val processCameraProvider = ProcessCameraProvider.awaitInstance(appContext) processCameraProvider.bindToLifecycle( lifecycleOwner, DEFAULT_FRONT_CAMERA, cameraPreviewUseCase ) // Cancellation signals we're done with the camera try { awaitCancellation() } finally { processCameraProvider.unbindAll() } }}Thereâ€™s quite a bit going on here! The code defines a CameraPreviewViewModel class, responsible for managing the camera preview. It uses the CameraX Preview builder to configure how the preview should be bound to the UI. The bindToCamera function initializes the camera, binds to the provided LifecycleOwner so that the camera only runs when the lifecycle is at least started, and starts the preview stream.The camera, which is part of the internals of the camera libraries, needs to render to the surface that is provided by the UI. So the library needs to have a way to request a surface. Thatâ€™s exactly what the SurfaceRequest is for! So whenever the camera indicates it needs a surface, a surfaceRequest is triggered. You then forward that request to the UI, where it can pass the surface to the request object.Finally, we wait until the UI is done binding to the camera, and make sure that we release the camera resources to avoid leaks.Implement the camera preview UINow that we have a view model, we can implement our CameraPreviewContent composable. It reads the surface request from the view model, binds to the camera while the composable is in the composition tree, and calls the CameraXViewfinder from the library:@Composablefun CameraPreviewContent( viewModel: CameraPreviewViewModel, modifier: Modifier = Modifier, lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current) { val surfaceRequest by viewModel.surfaceRequest.collectAsStateWithLifecycle() val context = LocalContext.current LaunchedEffect(lifecycleOwner) { viewModel.bindToCamera(context.applicationContext, lifecycleOwner) } surfaceRequest?.let { request -\u003e CameraXViewfinder( surfaceRequest = request, modifier = modifier ) }}As mentioned in the previous section, the surfaceRequest allows the camera library to request a surface when it needs one to render to. In this piece of code, we collect those surfaceRequest instances and forward them to the CameraXViewfinder, which is part of the camera-compose artifact.ResultAnd with that, we have a working full screen viewfinder! You can find the full code snippet here. In the next blog post, we will add a smooth tabletop mode by listening to the deviceâ€™s display features, and by using Compose animations to go to and from tabletop mode. Stay tuned!The code snippets in this blog have the following license:// Copyright 2024 Google LLC. SPDX-License-Identifier: Apache-2.0",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*k-WDMPkp9zsnxyyQ6v1VMA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"89a5\"\u003ePart 1 of Unlocking the Power of CameraX in Jetpack Compose\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@lojanda?source=post_page---byline--781c722ca0c4--------------------------------\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Jolanda Verhoef\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*XXxKnGkW5RkuVemStEYjdw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/androiddevelopers?source=post_page---byline--781c722ca0c4--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Android Developers\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*4Tg6pPzer7cIarYaszIKaQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"8c71\"\u003e\u003cem\u003eThis blog post is a part of Camera and Media Spotlight Week. Weâ€™re providing resources â€” blog posts, videos, sample code, and more â€” all designed to help you uplevel the media experiences in your app.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"7582\"\u003e\u003cem\u003eTo learn more about what Spotlight Week has to offer and how it can benefit you, be sure to \u003c/em\u003e\u003ca href=\"https://android-developers.googleblog.com/2025/01/spotlight-week-android-camera-and-media.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eread our overview blog post\u003c/em\u003e\u003c/a\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"2bcb\"\u003eWeâ€™ve heard from you that you love the power that both the \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/camera\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCameraX\u003c/a\u003e and \u003ca href=\"https://developer.android.com/compose\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetpack Compose\u003c/a\u003e libraries give you, but that youâ€™d like idiomatic Compose APIs for building Camera UIs. This year, our engineering teams worked on two new Compose artifacts, the low-level \u003ccode\u003e\u003ca href=\"https://developer.android.com/jetpack/androidx/releases/camera#viewfinder-compose-1.0.0-alpha01\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eviewfinder-compose\u003c/a\u003e\u003c/code\u003e and the high-level \u003ccode\u003e\u003ca href=\"https://developer.android.com/jetpack/androidx/releases/camera#1.5.0-alpha01\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecamera-compose\u003c/a\u003e\u003c/code\u003e. Both are now available as alpha releases ðŸš€ðŸš€ðŸš€.\u003c/p\u003e\u003cp id=\"116d\"\u003eIn this blog post series, weâ€™ll show you how to integrate the \u003ccode\u003ecamera-compose\u003c/code\u003e APIs in your app. But more excitingly, weâ€™ll show you some of the âœ¨ delightful UI experiences that integration with Compose unlocks. All the amazing Compose features, like adaptive APIs and animation support, integrate seamlessly with the camera preview!\u003c/p\u003e\u003cp id=\"f17a\"\u003eHereâ€™s a short summary of what each post will contain:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e834\"\u003eðŸ§±\u003cstrong\u003e Part 1 (this post):\u003c/strong\u003e Building a basic camera preview using the new \u003ccode\u003ecamera-compose\u003c/code\u003e artifact. Weâ€™ll cover permission handling and basic integration.\u003c/li\u003e\u003cli id=\"2e64\"\u003eðŸ‘† \u003cstrong\u003ePart 2: \u003c/strong\u003eUsing the Compose gesture system, graphics, and coroutines to implement a visual tap-to-focus.\u003c/li\u003e\u003cli id=\"613b\"\u003eðŸ”Ž \u003cstrong\u003ePart 3:\u003c/strong\u003e Exploring how to overlay Compose UI elements on top of your camera preview for a richer user experience.\u003c/li\u003e\u003cli id=\"7a44\"\u003eðŸ“‚ \u003cstrong\u003ePart 4: \u003c/strong\u003eUsing adaptive APIs and the Compose animation framework to smoothly animate to and from tabletop mode on foldable phones.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3410\"\u003eWith all of these in action, our final app will look as follows:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0812\"\u003eIn addition, it will smoothly move to and from tabletop mode:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f8cf\"\u003eBy the end of this first post, youâ€™ll have a functional camera viewfinder ready to be expanded upon in the subsequent parts of the series. Do please code along, itâ€™s the best way to learn!\u003c/p\u003e\u003ch2 id=\"8b08\"\u003eAdd the library dependencies\u003c/h2\u003e\u003cp id=\"fc3e\"\u003eIâ€™m assuming that you already have Compose set up in your app. If you want to follow along, simply create a new app in Android Studio. I typically use the latest Canary version, because it has the latest Compose templates (and because I like living on the edge ðŸ˜€).\u003c/p\u003e\u003cp id=\"ff6a\"\u003eAdd the following to your \u003ccode\u003elibs.versions.toml\u003c/code\u003e file:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"43fa\"\u003e[versions]\u003cbr/\u003e..\u003cbr/\u003ecamerax = \u0026#34;1.5.0-alpha03\u0026#34;\u003cbr/\u003eaccompanist = \u0026#34;0.36.0\u0026#34; # or whatever matches with your Compose version\u003cp\u003e[libraries]\u003cbr/\u003e..\u003cbr/\u003e# Contains the basic camera functionality such as SurfaceRequest\u003cbr/\u003eandroidx-camera-core = { module = \u0026#34;androidx.camera:camera-core\u0026#34;, version.ref = \u0026#34;camerax\u0026#34; }\u003cbr/\u003e# Contains the CameraXViewfinder composable\u003cbr/\u003eandroidx-camera-compose = { module = \u0026#34;androidx.camera:camera-compose\u0026#34;, version.ref = \u0026#34;camerax\u0026#34; }\u003cbr/\u003e# Allows us to bind the camera preview to our UI lifecycle\u003cbr/\u003eandroidx-camera-lifecycle = { group = \u0026#34;androidx.camera\u0026#34;, name = \u0026#34;camera-lifecycle\u0026#34;, version.ref = \u0026#34;camerax\u0026#34; }\u003cbr/\u003e# The specific camera implementation that renders the preview\u003cbr/\u003eandroidx-camera-camera2 = { module = \u0026#34;androidx.camera:camera-camera2\u0026#34;, version.ref = \u0026#34;camerax\u0026#34; }\u003cbr/\u003e# The helper library to grant the camera permission\u003cbr/\u003eaccompanist-permissions = { module = \u0026#34;com.google.accompanist:accompanist-permissions\u0026#34;, version.ref = \u0026#34;accompanist\u0026#34; }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d378\"\u003eNext, add these to your module \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e dependencies block:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3b0f\"\u003edependencies {\u003cbr/\u003e  ..\u003cbr/\u003e  implementation(libs.androidx.camera.core)\u003cbr/\u003e  implementation(libs.androidx.camera.compose)\u003cbr/\u003e  implementation(libs.androidx.camera.lifecycle)\u003cbr/\u003e  implementation(libs.androidx.camera.camera2)\u003cbr/\u003e  implementation(libs.accompanist.permissions)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3d86\"\u003eWe added all dependencies so that we can grant the camera permission and then actually display the camera preview. Next, letâ€™s look at granting the right permission.\u003c/p\u003e\u003ch2 id=\"e19f\"\u003eGrant camera permissions\u003c/h2\u003e\u003cp id=\"169a\"\u003eThe \u003ca href=\"https://google.github.io/accompanist/permissions/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAccompanist permissions library\u003c/a\u003e allows us to easily grant the right camera permission. First, we need to set up the \u003ccode\u003eAndroidManifest.xml\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0a06\"\u003e\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt;\u003cbr/\u003e    \u0026lt;uses-feature android:name=\u0026#34;android.hardware.camera\u0026#34; android:required=\u0026#34;true\u0026#34; /\u0026gt;\u003cbr/\u003e    \u0026lt;uses-permission android:name=\u0026#34;android.permission.CAMERA\u0026#34; /\u0026gt;\u003cp\u003e    ..\u003c/p\u003e\u003cp\u003e\u0026lt;/manifest\u0026gt;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b609\"\u003eNow, we can simply follow the libraryâ€™s instructions to grant the right permission:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d33d\"\u003eclass MainActivity : ComponentActivity() {\u003cbr/\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        enableEdgeToEdge()\u003cbr/\u003e        setContent {\u003cbr/\u003e            MyApplicationTheme {\u003cbr/\u003e                CameraPreviewScreen()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e@OptIn(ExperimentalPermissionsApi::class)\u003cbr/\u003e@Composable\u003cbr/\u003efun CameraPreviewScreen(modifier: Modifier = Modifier) {\u003cbr/\u003e    val cameraPermissionState = rememberPermissionState(android.Manifest.permission.CAMERA)\u003cbr/\u003e    if (cameraPermissionState.status.isGranted) {\u003cbr/\u003e        CameraPreviewContent(modifier)\u003cbr/\u003e    } else {\u003cbr/\u003e        Column(\u003cbr/\u003e            modifier = modifier.fillMaxSize().wrapContentSize().widthIn(max = 480.dp),\u003cbr/\u003e            horizontalAlignment = Alignment.CenterHorizontally\u003cbr/\u003e        ) {\u003cbr/\u003e            val textToShow = if (cameraPermissionState.status.shouldShowRationale) {\u003cbr/\u003e                // If the user has denied the permission but the rationale can be shown,\u003cbr/\u003e                // then gently explain why the app requires this permission\u003cbr/\u003e                \u0026#34;Whoops! Looks like we need your camera to work our magic!\u0026#34; +\u003cbr/\u003e                    \u0026#34;Don\u0026#39;t worry, we just wanna see your pretty face (and maybe some cats).  \u0026#34; +\u003cbr/\u003e                    \u0026#34;Grant us permission and let\u0026#39;s get this party started!\u0026#34;\u003cbr/\u003e            } else {\u003cbr/\u003e                // If it\u0026#39;s the first time the user lands on this feature, or the user\u003cbr/\u003e                // doesn\u0026#39;t want to be asked again for this permission, explain that the\u003cbr/\u003e                // permission is required\u003cbr/\u003e                \u0026#34;Hi there! We need your camera to work our magic! âœ¨\\n\u0026#34; +\u003cbr/\u003e                    \u0026#34;Grant us permission and let\u0026#39;s get this party started! \\uD83C\\uDF89\u0026#34;\u003cbr/\u003e            }\u003cbr/\u003e            Text(textToShow, textAlign = TextAlign.Center)\u003cbr/\u003e            Spacer(Modifier.height(16.dp))\u003cbr/\u003e            Button(onClick = { cameraPermissionState.launchPermissionRequest() }) {\u003cbr/\u003e                Text(\u0026#34;Unleash the Camera!\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003eprivate fun CameraPreviewContent(modifier: Modifier = Modifier) {\u003cbr/\u003e    // TODO: Implement\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b226\"\u003eWith this, we get a nice UI that allows the user to grant the camera permission before showing the camera preview:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"1cc6\"\u003eCreate a ViewModel\u003c/h2\u003e\u003cp id=\"e4a0\"\u003eIt is good practice to separate our business logic from our UI. We can do this by creating a view model for our screen. This view model sets up the CameraX \u003ccode\u003ePreview\u003c/code\u003e use case. Please note that \u003ca href=\"https://developer.android.com/media/camera/camerax#ease-of-use\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003euse cases in CameraX\u003c/a\u003e represent configurations of various workflows one can implement with the library, i.e. previewing, capturing, recording, and analyzing. The view model also binds the UI to the camera provider:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6a82\"\u003eclass CameraPreviewViewModel : ViewModel() {\u003cbr/\u003e    // Used to set up a link between the Camera and your UI.\u003cbr/\u003e    private val _surfaceRequest = MutableStateFlow\u0026lt;SurfaceRequest?\u0026gt;(null)\u003cbr/\u003e    val surfaceRequest: StateFlow\u0026lt;SurfaceRequest?\u0026gt; = _surfaceRequest\u003cp\u003e    private val cameraPreviewUseCase = Preview.Builder().build().apply {\u003cbr/\u003e        setSurfaceProvider { newSurfaceRequest -\u0026gt;\u003cbr/\u003e            _surfaceRequest.update { newSurfaceRequest }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun bindToCamera(appContext: Context, lifecycleOwner: LifecycleOwner) {\u003cbr/\u003e        val processCameraProvider = ProcessCameraProvider.awaitInstance(appContext)\u003cbr/\u003e        processCameraProvider.bindToLifecycle(\u003cbr/\u003e            lifecycleOwner, DEFAULT_FRONT_CAMERA, cameraPreviewUseCase\u003cbr/\u003e        )\u003c/p\u003e\u003cp\u003e        // Cancellation signals we\u0026#39;re done with the camera\u003cbr/\u003e        try { awaitCancellation() } finally { processCameraProvider.unbindAll() }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"07db\"\u003eThereâ€™s quite a bit going on here! The code defines a \u003ccode\u003eCameraPreviewViewModel\u003c/code\u003e class, responsible for managing the camera preview. It uses the CameraX \u003ccode\u003ePreview\u003c/code\u003e \u003ca href=\"https://developer.android.com/reference/androidx/camera/core/Preview.Builder\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ebuilder\u003c/a\u003e to configure how the preview should be bound to the UI. The \u003ccode\u003ebindToCamera\u003c/code\u003e function initializes the camera, binds to the provided \u003ccode\u003eLifecycleOwner\u003c/code\u003e so that the camera only runs when the lifecycle is at least started, and starts the preview stream.\u003c/p\u003e\u003cp id=\"e234\"\u003eThe camera, which is part of the internals of the camera libraries, needs to render to the surface that is provided by the UI. So the library needs to have a way to request a surface. Thatâ€™s exactly what the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/camera/core/SurfaceRequest\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSurfaceRequest\u003c/a\u003e\u003c/code\u003e is for! So whenever the camera indicates it needs a surface, a \u003ccode\u003esurfaceRequest\u003c/code\u003e is triggered. You then forward that request to the UI, where it can pass the surface to the request object.\u003c/p\u003e\u003cp id=\"f705\"\u003eFinally, we wait until the UI is done binding to the camera, and make sure that we release the camera resources to avoid leaks.\u003c/p\u003e\u003ch2 id=\"f269\"\u003eImplement the camera preview UI\u003c/h2\u003e\u003cp id=\"61c5\"\u003eNow that we have a view model, we can implement our \u003ccode\u003eCameraPreviewContent\u003c/code\u003e composable. It reads the surface request from the view model, binds to the camera while the composable is in the composition tree, and calls the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/camera/compose/package-summary#CameraXViewfinder(androidx.camera.core.SurfaceRequest,androidx.compose.ui.Modifier,androidx.camera.viewfinder.surface.ImplementationMode,androidx.camera.viewfinder.compose.MutableCoordinateTransformer)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCameraXViewfinder\u003c/a\u003e\u003c/code\u003e from the library:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9188\"\u003e@Composable\u003cbr/\u003efun CameraPreviewContent(\u003cbr/\u003e    viewModel: CameraPreviewViewModel,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current\u003cbr/\u003e) {\u003cbr/\u003e    val surfaceRequest by viewModel.surfaceRequest.collectAsStateWithLifecycle()\u003cbr/\u003e    val context = LocalContext.current\u003cbr/\u003e    LaunchedEffect(lifecycleOwner) { \u003cbr/\u003e        viewModel.bindToCamera(context.applicationContext, lifecycleOwner) \u003cbr/\u003e    }\u003cp\u003e    surfaceRequest?.let { request -\u0026gt;\u003cbr/\u003e        CameraXViewfinder(\u003cbr/\u003e            surfaceRequest = request,\u003cbr/\u003e            modifier = modifier\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3b32\"\u003eAs mentioned in the previous section, the \u003ccode\u003esurfaceRequest\u003c/code\u003e allows the camera library to request a surface when it needs one to render to. In this piece of code, we collect those \u003ccode\u003esurfaceRequest\u003c/code\u003e instances and forward them to the \u003ccode\u003eCameraXViewfinder\u003c/code\u003e, which is part of the \u003ccode\u003ecamera-compose\u003c/code\u003e artifact.\u003c/p\u003e\u003ch2 id=\"905c\"\u003eResult\u003c/h2\u003e\u003cp id=\"0f4a\"\u003eAnd with that, we have a working full screen viewfinder! You can find the full code snippet \u003ca href=\"https://gist.github.com/JolandaVerhoef/74d4696b804736c698450bd34b5c9ff8\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e. In the next blog post, we will add a smooth tabletop mode by listening to the deviceâ€™s display features, and by using Compose animations to go to and from tabletop mode. Stay tuned!\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"e26e\"\u003eThe code snippets in this blog have the following license:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3cbe\"\u003e// Copyright 2024 Google LLC. SPDX-License-Identifier: Apache-2.0\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-01-07T17:31:10.871Z",
  "modifiedTime": null
}
