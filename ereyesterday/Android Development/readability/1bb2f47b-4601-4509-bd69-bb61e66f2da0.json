{
  "id": "1bb2f47b-4601-4509-bd69-bb61e66f2da0",
  "title": "How to Answer Hashing Like a Java/Kotlin Expert",
  "link": "https://proandroiddev.com/how-to-answer-hashing-like-a-java-kotlin-expert-fc934ffabf02?source=rss----c72404660798---4",
  "description": "",
  "author": "Shakarim Bazhenov",
  "published": "Wed, 16 Jul 2025 02:04:48 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "data-structures",
    "kotlin",
    "interview",
    "java"
  ],
  "byline": "Shakarim Bazhenov",
  "length": 8231,
  "excerpt": "Understanding hashing and the relationship between equals() and hashCode() is essential not just for interviews but for writing high-performance Java and Kotlin applications. In this guide, you'll…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "How to Answer Hashing Like a Java/Kotlin ExpertUnderstanding hashing and the relationship between equals() and hashCode() is essential not just for interviews but for writing high-performance Java and Kotlin applications. In this guide, you'll learn how to explain hashing and its applications with confidence.equals() and hashCode()What is equals()?equals() determines logical equality. By default (in Object), it checks reference equality (this == other). Typically, you override it to compare the actual content of objects.What is hashCode()?hashCode() returns an integer that represents the object in hash-based collections like HashMap and HashSet. It is used to compute which bucket an object goes into.What is the Default hashCode() Value?If you don’t override hashCode(), Java uses the default implementation from Object, which often returns an integer related to the object's memory address (although not guaranteed to be the exact memory address). It typically looks like:public int hashCode() { return System.identityHashCode(this);}This value is unique only for the object identity and not based on its field values.The Contract Between ThemIf a.equals(b) is true, then a.hashCode() == b.hashCode() must also be trueThe reverse is not necessarily true: equal hash codes don’t imply equals() is trueBoth methods must be consistent over time unless fields involved in the logic changeKotlin Example Explainedclass User(val name: String, val age: Int) { override fun equals(other: Any?): Boolean { if (this === other) return true // Reference equality check if (other !is User) return false // Type check return name == other.name \u0026\u0026 age == other.age // Logical field comparison } override fun hashCode(): Int { // Combines hash codes of multiple fields using a prime multiplier chain to minimize collisions var result = name.hashCode() result = 31 * result + age return result }}Kotlin data class handles this automatically:data class User(val name: String, val age: Int)Why 31?The number 31 is chosen because it’s an odd prime number, which helps reduce collisions by spreading hash values more uniformly. It also has a subtle performance benefit: the JVM can optimize 31 * x as (x \u003c\u003c 5) - x (i.e., x * 32 - x), which uses a fast bitwise shift and subtraction instead of multiplication. Other odd primes like 37, 41, or 53 could work, but 31 has been found through empirical testing to strike a solid balance between distribution quality and performance across a wide range of use cases.Why Use a Recursive Multiplier Chain?The formula for combining multiple fields into a single hashCode() value follows a recursive multiplier chain of the form:result = (((0 * 31 + f1) * 31 + f2) * 31 + f3) ...Each field is added only after multiplying the accumulated result by 31, which ensures that both the field content and field order influence the final result. This makes it highly unlikely for objects with different structures to produce the same hash code.Example with three fields:var result = f1.hashCode()result = 31 * result + f2.hashCode()result = 31 * result + f3.hashCode()What is Hashing and Why Do We Need It?Hashing is the process of converting an object into a fixed-size integer value (hash code). This value is used to quickly store, retrieve, and compare objects in collections like HashMap, HashSet, ConcurrentHashMap, etc.Why?Fast lookups (O(1) average time complexity)Efficient use of memoryIdeal for use in caching, indexing, mapsBuckets and Bucket Indexing FormulaIn hash-based collections, the hash code is converted into a bucket index:index = hash \u0026 (capacity - 1)This is possible because capacity is always a power of 2, making \u0026 (capacity - 1) an efficient bitwise substitute for modulo (%).Example:hash = 123capacity = 16index = 123 \u0026 15 = 11What is a Hash Collision?A hash collision happens when two different keys map to the same bucket index. This can happen in several ways:1. Same hash code for different objects\"FB\".hashCode() == \"Ea\".hashCode() // Both are 2236 in JavaThis is a known edge case in Java’s String.hashCode() algorithm:s[0] * 31ⁿ⁻¹ + s[1] * 31ⁿ⁻² + ... + s[n-1]The characters are arranged in such a way that the final result is identical for both strings, even though they are logically different. This proves that hashCode collisions are inevitable and can occur even with a good hash function.2. Different hash codes → Same index due to bitmaskingval h1 = 12345val h2 = 28777val capacity = 16println(h1 and (capacity - 1)) // 1println(h2 and (capacity - 1)) // 1 → same bucketEven though the hash codes are different, they can still land in the same bucket when the capacity is small. This is due to how hash \u0026 (capacity - 1) truncates higher-order bits.3. Poor hashCode implementationoverride fun hashCode(): Int = 1 // ⚠️ Every object collides!This is legal, but it forces all entries into the same bucket, turning the hash table into a linked list or tree. Performance drops to O(n) for all operations.How to Avoid Bucket CollisionsChoose higher capacity if many entries are expectedThis reduces the chance of two values being placed in the same bucket due to index overlap.Avoid clusteringIf your custom hashCode() returns values that are multiples of powers of 2 or only vary in higher bits (e.g., always divisible by 8), they will tend to collide after bit masking. Instead, spread values across all 32 bits to avoid localized concentration.To avoid this, it's generally enough to override hashCode() using the 31-multiplier pattern described earlier.Collision Resolution Strategies1. Separate Chaining (Used in Java’s HashMap)When a collision occurs (i.e., multiple entries map to the same bucket index), Java stores those entries in a secondary data structure inside that bucket.Initially, the bucket contains a linked list of entries.If the number of entries in a bucket exceeds a threshold (TREEIFY_THRESHOLD = 8) and the map has sufficient capacity (≥ 64), the list is converted into a red-black tree.Why do we need this?Because otherwise, when multiple keys share the same bucket, finding the right key using equals() becomes linear time. Turning the list into a tree ensures logarithmic time lookups.This structure makes HashMap resilient to hash collisions, offering better performance under worst-case scenarios.Time complexity:Best case (well-distributed): O(1)Worst case with list: O(n)Worst case with tree: O(log n)2. Open Addressing (Used in other languages, not HashMap)In this approach, no secondary structures like lists are used. If a collision occurs, the algorithm probes the table to find the next available slot.Variants:Linear Probing: check index +1, +2, …Quadratic Probing: check index +1², +2², …Double Hashing: use a second hash function to determine step sizeComparison TableSeparate Chaining • Memory Use: More • Average Lookup: O(1) • Worst Case: O(log n) • Used In: Java HashMapOpen Addressing • Memory Use: Less • Average Lookup: O(1) • Worst Case: O(n) • Used In: Python dict, GoLoad Factor and Initial CapacityinitialCapacityInitial number of buckets in the hash tableAlways rounded up to the next power of twoDefault: 16loadFactorDetermines when to resize (rehash) the tableFormula:threshold = capacity * loadFactorDefault: 0.75Example:new HashMap\u003c\u003e(16, 0.75f); // Resizes when 13th element is addedChoosing Values:High loadFactor (e.g., 0.9) → saves memory, but increases risk of collisionsLow loadFactor (e.g., 0.5) → faster lookups, but uses more memoryWhy Capacity Must Be a Power of TwoTo allow this efficient formula:index = hash \u0026 (capacity - 1)If capacity weren’t a power of two, this bitmask trick wouldn’t work correctly. That would lead to uneven bucket distribution and worse performance.Final WordsHashing is more than just calling .hashCode() and .equals(). It’s the foundation of efficient data structures that power real-time systems, caches, and databases. Mastering it means you understand performance, memory, and algorithmic principles all at once.When an interviewer asks, “How does HashMap work?”, don’t stop at saying “it uses hashCode.” Show them you know why hashing works the way it does.Now you can answer hashing like a true Java/Kotlin expert",
  "image": "https://miro.medium.com/v2/resize:fit:1007/0*L3RccpNdMIP5SW0d.PNG",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"c24c\" data-testid=\"storyTitle\"\u003eHow to Answer Hashing Like a Java/Kotlin Expert\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@shbazhenov?source=post_page---byline--fc934ffabf02---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Shakarim Bazhenov\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*hiI_stOtJ4Av1nxkxrYAXg.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"bc35\"\u003eUnderstanding hashing and the relationship between \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e is essential not just for interviews but for writing high-performance Java and Kotlin applications. In this guide, you\u0026#39;ll learn how to explain hashing and its applications with confidence.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"57ec\"\u003e\u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e\u003c/h2\u003e\u003ch2 id=\"d555\"\u003eWhat is \u003ccode\u003eequals()\u003c/code\u003e?\u003c/h2\u003e\u003cp id=\"1eb1\"\u003e\u003ccode\u003eequals()\u003c/code\u003e determines \u003cstrong\u003elogical equality\u003c/strong\u003e. By default (in \u003ccode\u003eObject\u003c/code\u003e), it checks reference equality (\u003ccode\u003ethis == other\u003c/code\u003e). Typically, you override it to compare the actual \u003cstrong\u003econtent\u003c/strong\u003e of objects.\u003c/p\u003e\u003ch2 id=\"4bf9\"\u003eWhat is \u003ccode\u003ehashCode()\u003c/code\u003e?\u003c/h2\u003e\u003cp id=\"533f\"\u003e\u003ccode\u003ehashCode()\u003c/code\u003e returns an integer that represents the object in \u003cstrong\u003ehash-based collections\u003c/strong\u003e like \u003ccode\u003eHashMap\u003c/code\u003e and \u003ccode\u003eHashSet\u003c/code\u003e. It is used to compute which \u003cstrong\u003ebucket\u003c/strong\u003e an object goes into.\u003c/p\u003e\u003ch2 id=\"acc3\"\u003eWhat is the Default \u003ccode\u003ehashCode()\u003c/code\u003e Value?\u003c/h2\u003e\u003cp id=\"adaa\"\u003eIf you don’t override \u003ccode\u003ehashCode()\u003c/code\u003e, Java uses the default implementation from \u003ccode\u003eObject\u003c/code\u003e, which often returns an integer related to the object\u0026#39;s memory address (although not guaranteed to be the exact memory address). It typically looks like:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3a85\"\u003epublic int hashCode() {\u003cbr/\u003e    return System.identityHashCode(this);\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1f24\"\u003eThis value is unique only for the object identity and not based on its field values.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5fae\"\u003eThe Contract Between Them\u003c/h2\u003e\u003cul\u003e\u003cli id=\"9b01\"\u003eIf \u003ccode\u003ea.equals(b)\u003c/code\u003e is \u003ccode\u003etrue\u003c/code\u003e, then \u003ccode\u003ea.hashCode() == b.hashCode()\u003c/code\u003e must also be \u003ccode\u003etrue\u003c/code\u003e\u003c/li\u003e\u003cli id=\"7326\"\u003eThe reverse is \u003cstrong\u003enot necessarily true\u003c/strong\u003e: equal hash codes don’t imply \u003ccode\u003eequals()\u003c/code\u003e is \u003ccode\u003etrue\u003c/code\u003e\u003c/li\u003e\u003cli id=\"51f8\"\u003eBoth methods must be \u003cstrong\u003econsistent\u003c/strong\u003e over time unless fields involved in the logic change\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9f1c\"\u003eKotlin Example Explained\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"ee13\"\u003eclass User(val name: String, val age: Int) {\u003cbr/\u003e    override fun equals(other: Any?): Boolean {\u003cbr/\u003e        if (this === other) return true // Reference equality check\u003cbr/\u003e        if (other !is User) return false // Type check\u003cbr/\u003e        return name == other.name \u0026amp;\u0026amp; age == other.age // Logical field comparison\u003cbr/\u003e    }\u003cp\u003e    override fun hashCode(): Int {\u003cbr/\u003e        // Combines hash codes of multiple fields using a prime multiplier chain to minimize collisions\u003cbr/\u003e        var result = name.hashCode()\u003cbr/\u003e        result = 31 * result + age\u003cbr/\u003e        return result\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3692\"\u003eKotlin \u003ccode\u003edata class\u003c/code\u003e handles this automatically:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c20f\"\u003edata class User(val name: String, val age: Int)\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"f256\"\u003eWhy 31?\u003c/h2\u003e\u003cp id=\"c084\"\u003eThe number 31 is chosen because it’s an \u003cstrong\u003eodd prime number\u003c/strong\u003e, which helps reduce collisions by spreading hash values more uniformly. It also has a subtle performance benefit: the JVM can optimize \u003ccode\u003e31 * x\u003c/code\u003e as \u003ccode\u003e(x \u0026lt;\u0026lt; 5) - x\u003c/code\u003e (i.e., \u003ccode\u003ex * 32 - x\u003c/code\u003e), which uses a fast bitwise shift and subtraction instead of multiplication. Other odd primes like 37, 41, or 53 could work, but 31 has been found through empirical testing to strike a solid balance between distribution quality and performance across a wide range of use cases.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"410d\"\u003eWhy Use a Recursive Multiplier Chain?\u003c/h2\u003e\u003cp id=\"e82b\"\u003eThe formula for combining multiple fields into a single \u003ccode\u003ehashCode()\u003c/code\u003e value follows a \u003cstrong\u003erecursive multiplier chain\u003c/strong\u003e of the form:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"93e6\"\u003eresult = (((0 * 31 + f1) * 31 + f2) * 31 + f3) ...\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bf23\"\u003eEach field is added only after multiplying the accumulated result by 31, which ensures that both the \u003cstrong\u003efield content\u003c/strong\u003e and \u003cstrong\u003efield order\u003c/strong\u003e influence the final result. This makes it highly unlikely for objects with different structures to produce the same hash code.\u003c/p\u003e\u003ch2 id=\"d8b8\"\u003eExample with three fields:\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"cfd3\"\u003evar result = f1.hashCode()\u003cbr/\u003eresult = 31 * result + f2.hashCode()\u003cbr/\u003eresult = 31 * result + f3.hashCode()\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"31cb\"\u003eWhat is Hashing and Why Do We Need It?\u003c/h2\u003e\u003cp id=\"0951\"\u003eHashing is the process of converting an object into a \u003cstrong\u003efixed-size integer value\u003c/strong\u003e (hash code). This value is used to quickly \u003cstrong\u003estore\u003c/strong\u003e, \u003cstrong\u003eretrieve\u003c/strong\u003e, and \u003cstrong\u003ecompare\u003c/strong\u003e objects in collections like \u003ccode\u003eHashMap\u003c/code\u003e, \u003ccode\u003eHashSet\u003c/code\u003e, \u003ccode\u003eConcurrentHashMap\u003c/code\u003e, etc.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"0a67\"\u003eWhy?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"13a4\"\u003eFast lookups (\u003ccode\u003eO(1)\u003c/code\u003e average time complexity)\u003c/li\u003e\u003cli id=\"9e39\"\u003eEfficient use of memory\u003c/li\u003e\u003cli id=\"1a07\"\u003eIdeal for use in caching, indexing, maps\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"8674\"\u003eBuckets and Bucket Indexing Formula\u003c/h2\u003e\u003cp id=\"81ea\"\u003eIn hash-based collections, the hash code is converted into a \u003cstrong\u003ebucket index\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4b80\"\u003eindex = hash \u0026amp; (capacity - 1)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c228\"\u003eThis is possible because \u003ccode\u003ecapacity\u003c/code\u003e is always a \u003cstrong\u003epower of 2\u003c/strong\u003e, making \u003ccode\u003e\u0026amp; (capacity - 1)\u003c/code\u003e an efficient bitwise substitute for modulo (\u003ccode\u003e%\u003c/code\u003e).\u003c/p\u003e\u003ch2 id=\"ac28\"\u003eExample:\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"a1a5\"\u003ehash = 123\u003cbr/\u003ecapacity = 16\u003cbr/\u003eindex = 123 \u0026amp; 15 = 11\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"45b4\"\u003eWhat is a Hash Collision?\u003c/h2\u003e\u003cp id=\"b2ae\"\u003eA \u003cstrong\u003ehash collision\u003c/strong\u003e happens when two different keys map to the \u003cstrong\u003esame bucket index\u003c/strong\u003e. This can happen in several ways:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"1760\"\u003e1. Same hash code for different objects\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"f7a7\"\u003e\u0026#34;FB\u0026#34;.hashCode() == \u0026#34;Ea\u0026#34;.hashCode() // Both are 2236 in Java\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"04a5\"\u003eThis is a \u003cstrong\u003eknown edge case\u003c/strong\u003e in Java’s \u003ccode\u003eString.hashCode()\u003c/code\u003e algorithm:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c9b4\"\u003es[0] * 31ⁿ⁻¹ + s[1] * 31ⁿ⁻² + ... + s[n-1]\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1a5f\"\u003eThe characters are arranged in such a way that the final result is identical for both strings, even though they are logically different. This proves that hashCode collisions are \u003cstrong\u003einevitable\u003c/strong\u003e and can occur even with a good hash function.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d8e2\"\u003e2. Different hash codes → Same index due to bitmasking\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"0da0\"\u003eval h1 = 12345\u003cbr/\u003eval h2 = 28777\u003cbr/\u003eval capacity = 16\u003cbr/\u003eprintln(h1 and (capacity - 1)) // 1\u003cbr/\u003eprintln(h2 and (capacity - 1)) // 1 → same bucket\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6d56\"\u003eEven though the hash codes are different, they can still land in the same bucket when the capacity is small. This is due to how \u003ccode\u003ehash \u0026amp; (capacity - 1)\u003c/code\u003e truncates higher-order bits.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9acf\"\u003e3. Poor hashCode implementation\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"dd16\"\u003eoverride fun hashCode(): Int = 1 // ⚠️ Every object collides!\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d55f\"\u003eThis is legal, but it forces \u003cstrong\u003eall entries into the same bucket\u003c/strong\u003e, turning the hash table into a linked list or tree. Performance drops to \u003ccode\u003eO(n)\u003c/code\u003e for all operations.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"09e6\"\u003eHow to Avoid Bucket Collisions\u003c/h2\u003e\u003ch2 id=\"f17f\"\u003eChoose higher capacity if many entries are expected\u003c/h2\u003e\u003cp id=\"79e4\"\u003eThis reduces the chance of two values being placed in the same bucket due to index overlap.\u003c/p\u003e\u003ch2 id=\"9961\"\u003eAvoid clustering\u003c/h2\u003e\u003cp id=\"e7d6\"\u003eIf your custom \u003ccode\u003ehashCode()\u003c/code\u003e returns values that are multiples of powers of 2 or only vary in higher bits (e.g., always divisible by 8), they will tend to collide after bit masking. Instead, spread values across all 32 bits to avoid localized concentration.\u003c/p\u003e\u003cp id=\"7e05\"\u003eTo avoid this, it\u0026#39;s generally enough to override \u003ccode\u003ehashCode()\u003c/code\u003e using the \u003cstrong\u003e31-multiplier pattern\u003c/strong\u003e described earlier.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e610\"\u003eCollision Resolution Strategies\u003c/h2\u003e\u003ch2 id=\"454c\"\u003e1. Separate Chaining (Used in Java’s HashMap)\u003c/h2\u003e\u003cp id=\"26a2\"\u003eWhen a collision occurs (i.e., multiple entries map to the same bucket index), Java stores those entries in a \u003cstrong\u003esecondary data structure\u003c/strong\u003e inside that bucket.\u003c/p\u003e\u003cul\u003e\u003cli id=\"bf17\"\u003eInitially, the bucket contains a \u003cstrong\u003elinked list\u003c/strong\u003e of entries.\u003c/li\u003e\u003cli id=\"5ac7\"\u003eIf the number of entries in a bucket exceeds a threshold (\u003ccode\u003eTREEIFY_THRESHOLD = 8\u003c/code\u003e) and the map has sufficient capacity (≥ 64), the list is converted into a \u003cstrong\u003ered-black tree\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"816d\"\u003e\u003cstrong\u003eWhy do we need this?\u003c/strong\u003e\u003cbr/\u003eBecause otherwise, when multiple keys share the same bucket, finding the right key using \u003ccode\u003eequals()\u003c/code\u003e becomes \u003cstrong\u003elinear time\u003c/strong\u003e. Turning the list into a tree ensures \u003cstrong\u003elogarithmic time\u003c/strong\u003e lookups.\u003c/p\u003e\u003cp id=\"0b43\"\u003eThis structure makes HashMap \u003cstrong\u003eresilient to hash collisions\u003c/strong\u003e, offering better performance under worst-case scenarios.\u003c/p\u003e\u003ch2 id=\"576e\"\u003eTime complexity:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"b70d\"\u003eBest case (well-distributed): \u003ccode\u003eO(1)\u003c/code\u003e\u003c/li\u003e\u003cli id=\"76d1\"\u003eWorst case with list: \u003ccode\u003eO(n)\u003c/code\u003e\u003c/li\u003e\u003cli id=\"a65a\"\u003eWorst case with tree: \u003ccode\u003eO(log n)\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f77d\"\u003e2. Open Addressing (Used in other languages, not HashMap)\u003c/h2\u003e\u003cp id=\"6975\"\u003eIn this approach, \u003cstrong\u003eno secondary structures\u003c/strong\u003e like lists are used. If a collision occurs, the algorithm \u003cstrong\u003eprobes\u003c/strong\u003e the table to find the next available slot.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"a102\"\u003eVariants:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"a070\"\u003e\u003cstrong\u003eLinear Probing\u003c/strong\u003e: check index +1, +2, …\u003c/li\u003e\u003cli id=\"1d70\"\u003e\u003cstrong\u003eQuadratic Probing\u003c/strong\u003e: check index +1², +2², …\u003c/li\u003e\u003cli id=\"75c6\"\u003e\u003cstrong\u003eDouble Hashing\u003c/strong\u003e: use a second hash function to determine step size\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"7466\"\u003eComparison Table\u003c/h2\u003e\u003cp id=\"e7be\"\u003e\u003cstrong\u003eSeparate Chaining\u003c/strong\u003e\u003cbr/\u003e • \u003cstrong\u003eMemory Use:\u003c/strong\u003e More\u003cbr/\u003e • \u003cstrong\u003eAverage Lookup:\u003c/strong\u003e O(1)\u003cbr/\u003e • \u003cstrong\u003eWorst Case:\u003c/strong\u003e O(log n)\u003cbr/\u003e • \u003cstrong\u003eUsed In:\u003c/strong\u003e Java HashMap\u003c/p\u003e\u003cp id=\"8fa6\"\u003e\u003cstrong\u003eOpen Addressing\u003c/strong\u003e\u003cbr/\u003e • \u003cstrong\u003eMemory Use:\u003c/strong\u003e Less\u003cbr/\u003e • \u003cstrong\u003eAverage Lookup:\u003c/strong\u003e O(1)\u003cbr/\u003e • \u003cstrong\u003eWorst Case:\u003c/strong\u003e O(n)\u003cbr/\u003e • \u003cstrong\u003eUsed In:\u003c/strong\u003e Python dict, Go\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5607\"\u003eLoad Factor and Initial Capacity\u003c/h2\u003e\u003ch2 id=\"e808\"\u003e\u003ccode\u003einitialCapacity\u003c/code\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"aafe\"\u003eInitial number of buckets in the hash table\u003c/li\u003e\u003cli id=\"6d86\"\u003eAlways rounded up to the \u003cstrong\u003enext power of two\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"92dd\"\u003eDefault: \u003ccode\u003e16\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5b91\"\u003e\u003ccode\u003eloadFactor\u003c/code\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"0c6b\"\u003eDetermines when to \u003cstrong\u003eresize (rehash)\u003c/strong\u003e the table\u003c/li\u003e\u003cli id=\"5daf\"\u003eFormula:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"b03e\"\u003ethreshold = capacity * loadFactor\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"c7ea\"\u003eDefault: \u003ccode\u003e0.75\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"7680\"\u003eExample:\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"b1c9\"\u003enew HashMap\u0026lt;\u0026gt;(16, 0.75f); // Resizes when 13th element is added\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"29ce\"\u003eChoosing Values:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"a6e6\"\u003eHigh loadFactor (e.g., \u003ccode\u003e0.9\u003c/code\u003e) → saves memory, but increases \u003cstrong\u003erisk of collisions\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"815d\"\u003eLow loadFactor (e.g., \u003ccode\u003e0.5\u003c/code\u003e) → faster lookups, but uses more memory\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"1e6a\"\u003eWhy Capacity Must Be a Power of Two\u003c/h2\u003e\u003cp id=\"626e\"\u003eTo allow this efficient formula:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e86a\"\u003eindex = hash \u0026amp; (capacity - 1)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1257\"\u003eIf capacity weren’t a power of two, this bitmask trick wouldn’t work correctly. That would lead to \u003cstrong\u003euneven bucket distribution\u003c/strong\u003e and worse performance.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"911a\"\u003eFinal Words\u003c/h2\u003e\u003cp id=\"2dc1\"\u003eHashing is more than just calling \u003ccode\u003e.hashCode()\u003c/code\u003e and \u003ccode\u003e.equals()\u003c/code\u003e. It’s the foundation of efficient data structures that power real-time systems, caches, and databases. Mastering it means you understand performance, memory, and algorithmic principles all at once.\u003c/p\u003e\u003cp id=\"c16a\"\u003eWhen an interviewer asks, “How does HashMap work?”, don’t stop at saying “it uses hashCode.” Show them you know \u003cstrong\u003ewhy\u003c/strong\u003e hashing works the way it does.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"3e7e\"\u003e\u003cem\u003eNow you can answer hashing like a true Java/Kotlin expert\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-04-19T09:25:33.764Z",
  "modifiedTime": null
}
