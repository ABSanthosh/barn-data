{
  "id": "3f458642-838c-43c4-b9c1-1bf9e9719517",
  "title": "Loading Initial Data properly with MVI",
  "link": "https://proandroiddev.com/loading-initial-data-properly-with-mvi-5e54edd8ae56?source=rss----c72404660798---4",
  "description": "",
  "author": "Maxime Michel",
  "published": "Thu, 13 Feb 2025 18:48:56 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "architecture",
    "android-app-development",
    "mvi",
    "android",
    "androiddev"
  ],
  "byline": "Maxime Michel",
  "length": 7572,
  "excerpt": "I previously wrote an article on implementing MVI with Jetpack Compose (you can find it here). In that article, I loaded the initial data in the init block of the ViewModel. You‚Äôre more than likely‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "I previously wrote an article on implementing MVI with Jetpack Compose (you can find it here). In that article, I loaded the initial data in the init block of the ViewModel. You‚Äôre more than likely curious as to what the correct way to load initial data is and funnily enough, the init block isn‚Äôt it‚Ä¶ üòÖI wasn‚Äôt very satisfied with doing this but at the time, I considered it more important to publish the article and that this issue was quite minor compared to the overall contents of the article (which it was).The first helping handHowever, two months later, an article popped in my feed which dived into, you guessed it, best practices for loading initial data. I thank Jaewoong Eum for this article as it really helped me understand the strengths and weaknesses of both major approaches.The two approaches are:A LaunchedEffect in the screen that calls a ViewModel functionThe ViewModel init blockI read through the article and the explanations and slowly understood the intrinsic behaviour of each approach. It helped me understand why some developers prefer one solution over the other but overall, I needed a bit more context on how the proposed solution helps but also how it should be implemented. The article gives some code to guide readers but didn‚Äôt give me enough to fully grasp how it should be done, so I set the whole thing aside for some time.The second helping handTime went by and other things piled up on my never-ending pile of developer-things-to-do until one day (ooooh exciting!), a generic YouTube notification popped up which I was about to dismiss until I saw what it was‚Ä¶I started to think that I was being taunted about not having finished my implementation for data loading (maybe I was, who knows ü§î). Those of you who know this man, know that his content is worth watching and if you don‚Äôt, you should probably take a look!The video dives into more detail on the advantages and disadvantages of the two previously mentioned approaches:The LaunchedEffectWe control when data loading happensTesting can execute the function when neededRecomposition calls the LaunchedEffect again‚Ä¶Defeats the purpose of ViewModels outliving configuration changesThe init blockNo reloading on configuration changes!No control over when the data is loaded‚Ä¶Some testing scenarios require code to be executed between ViewModel initialisation and data loading which is not possible hereLet‚Äôs write some code!I‚Äôll be working up from what I previously wrote in my MVI article to integrate the proper way of loading initial data.My first issue was the way the state variable was definedThere‚Äôs nothing inherently wrong with this code. However, in its current form, there is no way to load initial data directly into the state. The only initial data that can be loaded is from the initialState variable but this doesn‚Äôt correspond to what we want for one major reason:It‚Äôs static. i.e. Once you inherit from the BaseViewModel class, you have to pass in a variable to be able to compile the project.What we want is the following:Given the initialState as a starting point,When the state variable is accessed for the first time,Then proceed with loading the initial data into it.To be able to do this, we need two helper functions that thankfully already exist: onStart and stateIn.onStart to the rescueThis extension function was clearly one I had forgotten about and I‚Äôm very thankful to Philipp for reminding me of it, especially how to use it!The official documentation states that it ‚ÄúReturns a flow that invokes the given action before this flow starts to be collected.‚ÄùNow I don‚Äôt know about you but that sounds very close to what we need ü§î The only issue is that Flow != StateFlow so we need another puzzle piece to bring all of this together.stateIn to save the dayThis extension function is well known amongst developers that use Kotlin Flows regularly and will come as no surprise. The behaviour here is simply to take an input Flow and, with the provided parameters, returns a StateFlow.All together nowThe use of by lazy { } here is to ensure the content of the onStart is only called when getting the data and not every time we access the state variableAs you can see, we now have a way to load initial data directly into our state variable. We use viewModelScope to link our state to the underlying ViewModel, the initialValue is our existing initialState and finally, the started parameter is set to share the state when the first collector appears and stop 5 seconds after the last one disappears. Why 5 seconds? I always assumed it was an arbitrary value but after reading Jaewoong‚Äôs article, I learnt that it actually is the ANR deadline! (Thanks Ian Lake for the explanation)We need more codeWait a minute‚Ä¶What? What do you mean wai-aaahhhh yes‚Ä¶ If you think about what we have right now, can you tell me how each ViewModel loads its specific initial data into the state?Yep, currently, it can‚Äôt. So we have this very nice initial-data-ready state variable that pretty much just looks good but does nothing (Kind of like a plastic plant). Ok let‚Äôs fix this and be done with it!99% of the time, my data loads are done via a UseCase (I explain what this is in this article ‚Üê To Be Published) and require a Coroutine (or a suspend function). Since we‚Äôre in a ViewModel, we‚Äôre obviously going to use viewModelScope for this.Woohoo, now we‚Äôre done! Right?NopeWhat do you mean ‚Äúnope‚Äù?How does each ViewModel use this?Well, all you need to do is call yourrrrrr-‚Äôre absolutely right‚Ä¶ they can‚Äôt use this‚Ä¶ Ok fine! I‚Äôll add more code to fix this because more code always fixes everything üôÑThe issue is that although we‚Äôve added the viewModelScope to the onStart, we need to provide a way for specific ViewModel implementations to call their own data loading functions within it. Kotlin has this neat keyword called open that will allow us to do just that!We could use abstract here instead of open but this would force all ViewModel‚Äôs to define a data loading function even when they don‚Äôt load data so open allows us to only override the function where we want.Now we‚Äôre done (seriously, we are)! In this state, each ViewModel can override the initialDataLoad and specify its specific data loading operation which will be executed as soon as the state has an active collector.An example integration would look like the following:Override the initialDataLoad functionCall the initial data loading UseCaseCollect the data from itUpdate our MVI state with the sendEvent functionAnd voil√†!We‚Äôre good to go!‚Ä¶ Why is this list still going?Ahh, better. As you can see, with our MVI implementation, we can now cleanly load initial data whilst taking advantage of the easy testability of our architecture. We also ensure performance is optimal by not loading data when not needed and, inversely, loading it when it should be.Enforcing the behaviourAs a small bonus, you‚Äôll have noticed that nothing prevents you from still using the init or LaunchedEffect methods.To prevent the use of the init block for data loading, you can use the Konsist library with the following test:For the LaunchedEffect method, unfortunately, I haven‚Äôt found a simple way to prevent its use since it implies calling a function defined in the ViewModel which could have any name. Testing against this, with such a wide range of possibilities, would be more cumbersome than beneficial in my opinion so I‚Äôll you find a solution yourself if needed üòâ.That‚Äôs all folks!You can find the complete code implementation here:And you‚Äôll find Jaewoong‚Äôs article here (be sure to give him a follow too!)",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*G_FrICpOU6UR8FAu",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@maxime.h.d.michel?source=post_page---byline--5e54edd8ae56---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Maxime Michel\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*5XdFo2879C-2MlDcOrC9qw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--5e54edd8ae56---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"817e\"\u003eI previously wrote an article on implementing MVI with Jetpack Compose (you can find it \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/a-robust-mvi-with-jetpack-compose-e08882d2c4ff\"\u003ehere\u003c/a\u003e). In that article, I loaded the initial data in the \u003ccode\u003einit\u003c/code\u003e block of the ViewModel. You‚Äôre more than likely curious as to what the correct way to load initial data is and funnily enough, the \u003ccode\u003einit\u003c/code\u003e block isn‚Äôt it‚Ä¶ üòÖ\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"94c9\"\u003eI wasn‚Äôt very satisfied with doing this but at the time, I considered it more important to publish the article and that this issue was quite minor compared to the overall contents of the article (which it was).\u003c/p\u003e\u003ch2 id=\"3498\"\u003eThe first helping hand\u003c/h2\u003e\u003cp id=\"3b3f\"\u003eHowever, two months later, an article popped in my feed which dived into, you guessed it, best practices for loading initial data. I thank \u003cspan\u003e\u003cspan aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/u/9bb203a4ab2e?source=post_page---user_mention--5e54edd8ae56---------------------------------------\" rel=\"noopener\" target=\"_blank\"\u003eJaewoong Eum\u003c/a\u003e\u003c/span\u003e\u003c/span\u003e for this article as it really helped me understand the strengths and weaknesses of both major approaches.\u003c/p\u003e\u003cp id=\"1d39\"\u003eThe two approaches are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b614\"\u003eA \u003ccode\u003eLaunchedEffect\u003c/code\u003e in the screen that calls a ViewModel function\u003c/li\u003e\u003cli id=\"4462\"\u003eThe ViewModel \u003ccode\u003einit\u003c/code\u003e block\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"788b\"\u003eI read through the article and the explanations and slowly understood the intrinsic behaviour of each approach. It helped me understand why some developers prefer one solution over the other but overall, I needed a bit more context on how the proposed solution helps but also how it should be implemented. The article gives some code to guide readers but didn‚Äôt give me enough to fully grasp how it should be done, so I set the whole thing aside for some time.\u003c/p\u003e\u003ch2 id=\"ebc8\"\u003eThe second helping hand\u003c/h2\u003e\u003cp id=\"f9b8\"\u003eTime went by and other things piled up on my never-ending pile of developer-things-to-do until one day (ooooh exciting!), a generic YouTube notification popped up which I was about to dismiss until I saw what it was‚Ä¶\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"667d\"\u003eI started to think that I was being taunted about not having finished my implementation for data loading (maybe I was, who knows ü§î). Those of you who know this man, know that his content is worth watching and if you don‚Äôt, you should probably take a look!\u003c/p\u003e\u003cp id=\"a97e\"\u003eThe video dives into more detail on the advantages and disadvantages of the two previously mentioned approaches:\u003c/p\u003e\u003ch2 id=\"279f\"\u003eThe LaunchedEffect\u003c/h2\u003e\u003cul\u003e\u003cli id=\"5d82\"\u003eWe \u003cstrong\u003econtrol \u003c/strong\u003ewhen data loading happens\u003c/li\u003e\u003cli id=\"f600\"\u003eTesting can execute the function \u003cstrong\u003ewhen needed\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"125a\"\u003e\u003cstrong\u003eRecomposition \u003c/strong\u003ecalls the \u003ccode\u003eLaunchedEffect\u003c/code\u003e again‚Ä¶\u003c/li\u003e\u003cli id=\"3f3a\"\u003e\u003cstrong\u003eDefeats \u003c/strong\u003ethe purpose of ViewModels \u003cstrong\u003eoutliving \u003c/strong\u003econfiguration changes\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"36c6\"\u003eThe init block\u003c/h2\u003e\u003cul\u003e\u003cli id=\"76c8\"\u003e\u003cstrong\u003eNo reloading\u003c/strong\u003e on configuration changes!\u003c/li\u003e\u003cli id=\"5b45\"\u003e\u003cstrong\u003eNo control\u003c/strong\u003e over when the data is loaded‚Ä¶\u003c/li\u003e\u003cli id=\"1528\"\u003eSome testing scenarios \u003cstrong\u003erequire \u003c/strong\u003ecode to be executed \u003cstrong\u003ebetween \u003c/strong\u003eViewModel initialisation and data loading which is \u003cstrong\u003enot possible\u003c/strong\u003e here\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d183\"\u003eLet‚Äôs write some code!\u003c/h2\u003e\u003cp id=\"308e\"\u003eI‚Äôll be working up from what I previously wrote in my MVI article to integrate the \u003cstrong\u003eproper way\u003c/strong\u003e of loading initial data.\u003c/p\u003e\u003cp id=\"f140\"\u003eMy first issue was the way the \u003ccode\u003estate\u003c/code\u003e variable was defined\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"66e0\"\u003eThere‚Äôs nothing inherently wrong with this code. However, in its current form, there is no way to load initial data directly into the \u003ccode\u003estate\u003c/code\u003e. The only initial data that can be loaded is from the \u003ccode\u003einitialState\u003c/code\u003e variable but this doesn‚Äôt correspond to what we want for one major reason:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3b42\"\u003eIt‚Äôs \u003cstrong\u003estatic\u003c/strong\u003e. i.e. Once you inherit from the \u003ccode\u003eBaseViewModel\u003c/code\u003e class, you have to pass in a variable to be able to compile the project.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2e5f\"\u003eWhat we want is the following:\u003c/p\u003e\u003cul\u003e\u003cli id=\"2eb8\"\u003eGiven the \u003ccode\u003einitialState\u003c/code\u003e as a starting point,\u003c/li\u003e\u003cli id=\"12b0\"\u003eWhen the \u003ccode\u003estate\u003c/code\u003e variable is accessed for the first time,\u003c/li\u003e\u003cli id=\"f74b\"\u003eThen proceed with loading the initial data into it.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"582d\"\u003eTo be able to do this, we need two helper functions that thankfully already exist: \u003ccode\u003eonStart\u003c/code\u003e and \u003ccode\u003estateIn\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"f982\"\u003e\u003ccode\u003eonStart\u003c/code\u003e to the rescue\u003c/h2\u003e\u003cp id=\"335c\"\u003eThis extension function was clearly one I had forgotten about and I‚Äôm very thankful to Philipp for reminding me of it, especially how to use it!\u003c/p\u003e\u003cp id=\"68a1\"\u003eThe official documentation states that it ‚Äú\u003cem\u003eReturns a flow that invokes the given action \u003c/em\u003e\u003cstrong\u003e\u003cem\u003ebefore\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e this flow starts to be collected.‚Äù\u003c/em\u003e\u003c/p\u003e\u003cp id=\"ea22\"\u003eNow I don‚Äôt know about you but that sounds very close to what we need ü§î The only issue is that \u003cstrong\u003eFlow \u003c/strong\u003e!= \u003cstrong\u003eStateFlow\u003c/strong\u003e so we need another puzzle piece to bring all of this together.\u003c/p\u003e\u003ch2 id=\"3665\"\u003estateIn to save the day\u003c/h2\u003e\u003cp id=\"9f90\"\u003eThis extension function is well known amongst developers that use Kotlin Flows regularly and will come as no surprise. The behaviour here is simply to take an input \u003ccode\u003eFlow\u003c/code\u003e and, with the provided parameters, returns a \u003ccode\u003eStateFlow\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"5845\"\u003eAll together now\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"9f7a\"\u003eThe use of \u003ccode\u003eby lazy { }\u003c/code\u003e here is to ensure the content of the \u003ccode\u003eonStart\u003c/code\u003e is only called when getting the data and not every time we access the \u003ccode\u003estate\u003c/code\u003e variable\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"1d87\"\u003eAs you can see, we now have a way to load initial data directly into our \u003ccode\u003estate\u003c/code\u003e variable. We use \u003ccode\u003eviewModelScope\u003c/code\u003e to link our \u003ccode\u003estate\u003c/code\u003e to the underlying ViewModel, the \u003ccode\u003einitialValue\u003c/code\u003e is our existing \u003ccode\u003einitialState\u003c/code\u003e and finally, the \u003ccode\u003estarted\u003c/code\u003e parameter is set to share the state when the first collector appears and stop 5 seconds after the last one disappears. Why 5 seconds? I always assumed it was an arbitrary value but after reading Jaewoong‚Äôs article, I learnt that it actually is the ANR deadline! (Thanks Ian Lake for the explanation)\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e6fd\"\u003eWe need more code\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"a86a\"\u003eWait a minute‚Ä¶\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"4539\"\u003eWhat? What do you mean wai-aaahhhh yes‚Ä¶ If you think about what we have right now, can you tell me how each ViewModel loads its specific initial data into the \u003ccode\u003estate\u003c/code\u003e?\u003c/p\u003e\u003cp id=\"5aa8\"\u003eYep, currently, \u003cstrong\u003eit can‚Äôt\u003c/strong\u003e. So we have this very nice initial-data-ready \u003ccode\u003estate\u003c/code\u003e variable that pretty much just looks good but does nothing (Kind of like a plastic plant). Ok let‚Äôs fix this and be done with it!\u003c/p\u003e\u003cp id=\"0b43\"\u003e99% of the time, my data loads are done via a UseCase (I explain what this is in this article ‚Üê To Be Published) and require a Coroutine (or a suspend function). Since we‚Äôre in a ViewModel, we‚Äôre obviously going to use \u003ccode\u003eviewModelScope\u003c/code\u003e for this.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"8497\"\u003eWoohoo, \u003cem\u003enow\u003c/em\u003e we‚Äôre done! Right?\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"e065\"\u003eNope\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"8975\"\u003eWhat do you mean ‚Äúnope‚Äù?\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"fbb0\"\u003eHow does each ViewModel use this?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"a503\"\u003eWell, all you need to do is call yourrrrrr-‚Äôre absolutely right‚Ä¶ they can‚Äôt use this‚Ä¶ Ok fine! I‚Äôll add more code to fix this because more code \u003cem\u003ealways\u003c/em\u003e fixes everything üôÑ\u003c/p\u003e\u003cp id=\"e35e\"\u003eThe issue is that although we‚Äôve added the \u003ccode\u003eviewModelScope\u003c/code\u003e to the \u003ccode\u003eonStart\u003c/code\u003e, we need to provide a way for specific ViewModel implementations to call their own data loading functions within it. Kotlin has this neat keyword called \u003ccode\u003eopen\u003c/code\u003e that will allow us to do just that!\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"41a4\"\u003eWe could use \u003ccode\u003eabstract\u003c/code\u003e here instead of \u003ccode\u003eopen\u003c/code\u003e but this would force all ViewModel‚Äôs to define a data loading function even when they don‚Äôt load data so \u003ccode\u003eopen\u003c/code\u003e allows us to only override the function where we want.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"d59e\"\u003e\u003cstrong\u003e\u003cem\u003eNow\u003c/em\u003e\u003c/strong\u003e we‚Äôre done (seriously, we are)! In this state, each ViewModel can override the \u003ccode\u003einitialDataLoad\u003c/code\u003e and specify its specific data loading operation which will be executed as soon as the \u003ccode\u003estate\u003c/code\u003e has an active collector.\u003c/p\u003e\u003cp id=\"4b17\"\u003eAn example integration would look like the following:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003col\u003e\u003cli id=\"6935\"\u003eOverride the \u003ccode\u003einitialDataLoad\u003c/code\u003e function\u003c/li\u003e\u003cli id=\"ac37\"\u003eCall the initial data loading UseCase\u003c/li\u003e\u003cli id=\"bd2e\"\u003eCollect the data from it\u003c/li\u003e\u003cli id=\"a2a3\"\u003eUpdate our MVI state with the \u003ccode\u003esendEvent\u003c/code\u003e function\u003c/li\u003e\u003cli id=\"fe88\"\u003eAnd voil√†!\u003c/li\u003e\u003cli id=\"043d\"\u003eWe‚Äôre good to go!\u003c/li\u003e\u003cli id=\"34f2\"\u003e‚Ä¶ Why is this list still going?\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"4e78\"\u003eAhh, better. As you can see, with our MVI implementation, we can now cleanly load initial data whilst taking advantage of the easy testability of our architecture. We also ensure performance is optimal by not loading data when not needed and, inversely, loading it when it should be.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"55d6\"\u003eEnforcing the behaviour\u003c/h2\u003e\u003cp id=\"a263\"\u003eAs a small bonus, you‚Äôll have noticed that nothing prevents you from still using the \u003ccode\u003einit\u003c/code\u003e or \u003ccode\u003eLaunchedEffect\u003c/code\u003e methods.\u003c/p\u003e\u003cp id=\"1120\"\u003eTo prevent the use of the \u003ccode\u003einit\u003c/code\u003e block for data loading, you can use the \u003ca href=\"https://github.com/LemonAppDev/konsist\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKonsist\u003c/a\u003e library with the following test:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2603\"\u003eFor the \u003ccode\u003eLaunchedEffect\u003c/code\u003e method, unfortunately, I haven‚Äôt found a simple way to prevent its use since it implies calling a function defined in the ViewModel which could have any name. Testing against this, with such a wide range of possibilities, would be more cumbersome than beneficial in my opinion so I‚Äôll you find a solution yourself if needed üòâ.\u003c/p\u003e\u003ch2 id=\"111c\"\u003eThat‚Äôs all folks!\u003c/h2\u003e\u003cp id=\"9c22\"\u003eYou can find the complete code implementation here:\u003c/p\u003e\u003cp id=\"a153\"\u003eAnd you‚Äôll find Jaewoong‚Äôs article here (be sure to give him a follow too!)\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-02-13T18:48:55.98Z",
  "modifiedTime": null
}
