{
  "id": "9ac5fc13-49b6-4cc4-9184-97ae326073f2",
  "title": "Collapsing Toolbar in Compose— PART 2",
  "link": "https://proandroiddev.com/collapsing-toolbar-in-compose-part-2-abb4632d0b47?source=rss----c72404660798---4",
  "description": "",
  "author": "Karishma Agrawal",
  "published": "Fri, 15 Nov 2024 02:17:35 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "compose",
    "nestedscrollconnection",
    "scroll"
  ],
  "byline": "Karishma Agrawal",
  "length": 18756,
  "excerpt": "Creating smooth, responsive user experiences in modern UI development often involves complex scrolling interactions. One common requirement is nested scrolling, where a scrollable component is…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "IntroductionCreating smooth, responsive user experiences in modern UI development often involves complex scrolling interactions. One common requirement is nested scrolling, where a scrollable component is embedded within another. Jetpack Compose, with its declarative approach, provides an elegant way to handle such interactions.In PART 1 of this article, we covered scroll states and the basics of nested scrolling. Now, in PART 2, we will build a dynamic UI with a collapsing toolbar and learn how to handle nested scrolling effectively.Mastering Scroll in Jetpack Compose — PART 1OverviewWe aim to create an interface with a lazy list where scrolling causes the top card to transform into a toolbar, with a smooth, curved path transition effect.What You’ll LearnCreating custom layoutsResizing layouts based on states (collapsed or expanded)Combining lazy list scrolling with screen contentWorking with nested scrolling and NestedScrollConnectionStep 1: Building the HeaderThe header has two states: expanded and collapsed. We use dynamic elements with changing heights and widths to achieve a smooth transition between these states.Expanded stateCollapsed stateTo calculate the height for these containers we will use Custom layout in compose. If you already not know custom layout checkout this.# Defining the Heightsprivate val expandedBoxHeight = 200.dpprivate val collapsedBoxHeight = 96.dpprivate val ExpandedLeoHeight = 80.dpprivate val CollapsedLeoHeight = 32.dpprivate val leoTextHeight = 16.spprivate val ButtonSize = 24.dpWe interpolate between these values as the header transitions between states.To get the linear sizes ar each state we use lerp function.val leoHeight = with(LocalDensity.current) { lerp(CollapsedLeoHeight.toPx(), ExpandedLeoHeight.toPx(), progress).toDp()}where progress is changing from 1f to 0f lineraly.# Create box to set background image.@Composablefun CollapsingToolbar( @DrawableRes backgroundImageResId: Int, progress: Float, onPrivacyTipButtonClicked: () -\u003e Unit, onSettingsButtonClicked: () -\u003e Unit, modifier: Modifier = Modifier) { val leoHeight = with(LocalDensity.current) { lerp(CollapsedLeoHeight.toPx(), ExpandedLeoHeight.toPx(), progress).toDp() } val logoPadding = with(LocalDensity.current) { lerp(CollapsedPadding.toPx(), ExpandedPadding.toPx(), progress).toDp() }Surface( color = MaterialTheme.colors.primary, elevation = Elevation, modifier = modifier) { Box( modifier = Modifier .fillMaxWidth() .height(if (progress == 1f) 200.dp else leoHeight * 3) ) { //#Background Image Image( painter = painterResource(id = backgroundImageResId), contentDescription = null, contentScale = ContentScale.FillWidth, modifier = Modifier .fillMaxSize() .graphicsLayer { alpha = progress * Alpha }, alignment = BiasAlignment(0f, 1f - ((1f - progress) * 0.75f)) ) ....... // inside content }}}Here background image alignment is changing with progress.when progress = 1f(0f , 1f — ((1f — progress) * 0.75f) = (0f , 1f — ((1f — 1f) * 0.75f)(0f, 1f — 0f * 0.75f) = (0f, 1f) which mean it will start from horizontal 0 to vertical 1.when progress = 0f(0f , 1f — ((1f — progress) * 0.75f) = (0f , 1f — ((1f — 0f) * 0.75f)(0f, 1f — 1f * 0.75f) = (0f, 1f-0.75f) = (0f, 0.25f)which mean it will start from horizontal 0 to vertical 0.25f alignment of whole box size .and alpga is changing with progress which means on 1f it will be completely visible to get invisible on 0f progress value.# Now let’s add all these element without any sense of direction for now.//Inside card elementsImage( painter = painterResource(id = R.drawable.ic_leo), contentDescription = null, modifier = Modifier .padding(logoPadding) .height(leoHeight) .width(leoHeight))Text( text = \"LEO\", color = Color.White, fontSize = 16.sp, modifier = Modifier .padding(logoPadding) .wrapContentWidth(),)Row( modifier = Modifier.wrapContentSize(), horizontalArrangement = Arrangement.spacedBy(ContentPadding)) { IconButton( onClick = onPrivacyTipButtonClicked, modifier = Modifier .size(ButtonSize) .background( color = LocalContentColor.current.copy(alpha = 0.0f), shape = CircleShape ) ) { Icon( modifier = Modifier.fillMaxSize(), imageVector = Icons.Rounded.Edit, contentDescription = null, ) } IconButton( onClick = onSettingsButtonClicked, modifier = Modifier .size(ButtonSize) .background( color = LocalContentColor.current.copy(alpha = 0.0f), shape = CircleShape ) ) { Icon( modifier = Modifier.fillMaxSize(), imageVector = Icons.Rounded.Share, contentDescription = null, ) }}# Arrange them dynamically using custom layout@Composablefun CollapsingToolbar( @DrawableRes backgroundImageResId: Int, progress: Float, onPrivacyTipButtonClicked: () -\u003e Unit, onSettingsButtonClicked: () -\u003e Unit, modifier: Modifier = Modifier) { val leoHeight = with(LocalDensity.current) { lerp(CollapsedLeoHeight.toPx(), ExpandedLeoHeight.toPx(), progress).toDp() } val logoPadding = with(LocalDensity.current) { lerp(CollapsedPadding.toPx(), ExpandedPadding.toPx(), progress).toDp() }Surface( color = MaterialTheme.colors.primary, elevation = Elevation, modifier = modifier) { Box( modifier = Modifier .fillMaxWidth() .height(if (progress == 1f) 200.dp else leoHeight * 3) ) { //#Background Image Image( painter = painterResource(id = backgroundImageResId), contentDescription = null, contentScale = ContentScale.FillWidth, modifier = Modifier .fillMaxSize() .graphicsLayer { alpha = progress * Alpha }, alignment = BiasAlignment(0f, 1f - ((1f - progress) * 0.75f)) ) CollapsingToolbarLayout(progress, Modifier) { //Inside card elements .............................. } } }}}@Composableprivate fun CollapsingToolbarLayout( progress: Float, modifier: Modifier = Modifier, content: @Composable () -\u003e Unit) { Layout( modifier = modifier, content = content ) { measurables, constraints -\u003e// Repositioning of the elements... }}now check element count is 3(1. cat image, 2. Text, 3. row of buttons) and get placables from that.check(measurables.size == 3)val placeables = measurables.map { it.measure(constraints)}layout( width = constraints.maxWidth, height = constraints.maxHeight) { val expandedHorizontalGuideline = (constraints.maxHeight * 0.4f).roundToInt() val collapsedHorizontalGuideline = (constraints.maxHeight * 0.5f).roundToInt() val leoImage = placeables[0] val petName = placeables[1] val buttons = placeables[2]We will check the positioning of each item in#Collapsed stateCat Image : because content padding was already added. x cooridnate can start from 0 in this case. and y can be middle of collapsed card.x = 0y = collapsedHorizontalGuideline/2Text : x coordinate will start after cat image. and padding was already added.x = leoImage.widthy = (collapsedHorizontalGuideline — petName.height/2)Buttons :x = constraints.maxWidth - buttons.widthy = (constraints.maxHeight - buttons.height) / 2Same way place expanded content. whole code will look something like this.@Composableprivate fun CollapsingToolbarLayout( progress: Float, modifier: Modifier = Modifier, content: @Composable () -\u003e Unit) { Layout( modifier = modifier, content = content ) { measurables, constraints -\u003e check(measurables.size == 3) val placeables = measurables.map { it.measure(constraints) } layout( width = constraints.maxWidth, height = constraints.maxHeight ) { val expandedHorizontalGuideline = (constraints.maxHeight * 0.4f).roundToInt() val collapsedHorizontalGuideline = (constraints.maxHeight * 0.5f).roundToInt() val leoImage = placeables[0] val petName = placeables[1] val buttons = placeables[2] leoImage.placeRelative( x = lerp( start = 0, stop = constraints.maxWidth / 2 - leoImage.width / 2, fraction = progress ), y = lerp( start = collapsedHorizontalGuideline / 2, stop = expandedHorizontalGuideline / 2, fraction = progress ) ) petName.placeRelative( x = lerp( start = leoImage.width , stop = constraints.maxWidth / 2 - petName.width / 2, fraction = progress ), y = lerp( start = (collapsedHorizontalGuideline - petName.height/2), stop = constraints.maxHeight / 2 + leoImage.width / 3, fraction = progress ) ) buttons.placeRelative( x = constraints.maxWidth - buttons.width, y = lerp( start = (constraints.maxHeight - buttons.height) / 2, stop = 0, fraction = progress ) ) } }}Here placeRelative function takes x, y, z coordinates. and to set x, y we will again use lerp function we defines linear path for these cooridinates, where start being collapsed state and stop being expanded state.I hope it was pretty clean till now.Step 2: In this step we will create a list below header and add scroll state to create collapsing view@Composablefun LazyColumnExample(progress: Float, scrollState: ScrollableState) { val items = listOf( \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\", \"Item 6\", \"Item 7\", \"Item 8\", \"Item 9\", \"Item 10\", \"Item 11\", \"Item 12\", \"Item 13\", \"Item 14\", \"Item 15\", \"Item 16\", \"Item 17\", \"Item 18\", \"Item 19\", \"Item 20\" ) LazyColumn( modifier = Modifier .fillMaxSize() .background(Color.LightGray) .scrollable(scrollState, Orientation.Vertical) ) { item { CollapsingToolbar(R.drawable.ic_unsplash_background, progress, {}, {}, Modifier) } items(items.size) { item -\u003e Box( modifier = Modifier .fillMaxWidth() .padding(16.dp), contentAlignment = Alignment.Center ) { Text( text = items[item], color = Color.Black ) } } }}This will create a list below header. now add scrolling.@Composablefun MyScreen() { val scrollState = rememberScrollState() val maxScrollOffset = 500 // Adjust this to your desired maximum scroll offset val progress = remember { derivedStateOf { val currentScrollOffset = scrollState.value val progressValue = currentScrollOffset.toFloat() / maxScrollOffset.toFloat() progressValue.coerceIn(0f, 1f) } } // Use the 'progress' state to control the toolbar's appearance Box( modifier = Modifier .fillMaxSize() ) { LazyColumnExample(progress.value, scrollState) }}In this code, scrollOffset is an Animatable object used to keep track of the toolbar's current offset (or position) on the Y-axis as it transitions between expanded and collapsed states. It's animated to provide smooth, gradual transitions between these states based on the scroll direction (up or down).Progress value will change on bases of scroll offset. Let’s run this code and see.Oops. Both the scrolling containers are not working together. something it collapses the header, but other time it is just scrolling the list.Step 3: Add Nested scrollingThis is where nested scrolling comes into picture.Nested scrolling is a system where multiple scrolling components contained within each other work together by reacting to a single scroll gesture and communicating their scrolling deltas (changes). This is essential when there are nested scrollable elements, like a scrollable toolbar (collapsing or expanding) at the top of a list, where both components need to respond to the user’s scroll input in a synchronized manner.How Nested Scrolling Works in This ExampleNestedScrollConnection: This interface lets you intercept, control, and respond to scroll events for coordinated scrolling. We use NestedScrollConnection here to control the toolbar's expand and collapse behavior based on the user's scroll actions.val nestedScrollConnection = remember { object : NestedScrollConnection { override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {} override fun onPostScroll( consumed: Offset, available: Offset, source: NestedScrollSource ): Offset {}}The Nested Scroll Chain: When nested scrolling is active, events are passed through a chain of scrollable components, which communicate with each other:onPreScroll: This method lets a parent component intercept a scroll event before the child handles it. In this example, onPreScroll checks the scroll delta (how much the user has scrolled) to determine if the toolbar should expand or collapse based on the scroll direction. override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset { val delta = available.y val newOffset = (scrollOffset.value + delta).coerceIn(0f, maxScrollOffsetPx) val consumed = newOffset - scrollOffset.value scrollOffset.value = newOffset return Offset(x = 0f, y = consumed) }. onPostScroll : This pass occurs when the dispatching (scrolling) descendant made their consumption and notifies ancestors with what’s left for them to consume.override fun onPostScroll( consumed: Offset, available: Offset, source: NestedScrollSource): Offset { val delta = available.y val newOffset = (scrollOffset.value + delta).coerceIn(0f, maxScrollOffsetPx) scrollOffset.value = newOffset return Offset.Zero}Accumulating Scroll Delta: By accumulating the scroll delta, the code ensures that the toolbar doesn’t collapse or expand for small scrolls, only for significant gestures in the up or down direction.Animating scrollOffset Based on Scroll Direction: If the accumulated scroll delta crosses a threshold (e.g., 500f), the scrollOffset is animated to collapse (scroll up) or expand (scroll down) the toolbar.val maxScrollOffsetPx = 500f// Remember the scroll offset stateval scrollOffset = remember { androidx.compose.runtime.mutableStateOf(0f) }val scrollProgress = (scrollOffset.value / maxScrollOffsetPx).coerceIn(0f, 1f)Nested Scrolling with LazyColumn: The LazyColumn is the scrollable list of items within the screen. When the user scrolls, the LazyColumn emits scroll events. These events are intercepted by the NestedScrollConnection to adjust the toolbar’s position before they are passed on to the list for normal scrolling.Modifier Setup: Modifier.nestedScroll(nestedScrollConnection) is applied to the main Box container. This connects the main scrollable content (LazyColumn) with the toolbar’s NestedScrollConnection.Box( modifier = Modifier .fillMaxSize() .nestedScroll(nestedScrollConnection)) { LazyColumnExample(scrollProgress)}As a result:When the user scrolls up, the toolbar collapses first until it’s fully hidden, then the list scrolls.When the user scrolls down, the toolbar expands first, then the list scrolls after the toolbar reaches its fully expanded state.Here is the full code@Composablefun MyScreen() { // Total scroll distance for toolbar collapse val maxScrollOffsetPx = 500f // Remember the scroll offset state val scrollOffset = remember { androidx.compose.runtime.mutableStateOf(0f) } val scrollProgress = (scrollOffset.value / maxScrollOffsetPx).coerceIn(0f, 1f) // Set up a nested scroll connection for nested scroll handling val nestedScrollConnection = remember { object : NestedScrollConnection { override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset { val delta = available.y val newOffset = (scrollOffset.value + delta).coerceIn(0f, maxScrollOffsetPx) val consumed = newOffset - scrollOffset.value scrollOffset.value = newOffset return Offset(x = 0f, y = consumed) } override fun onPostScroll( consumed: Offset, available: Offset, source: NestedScrollSource ): Offset { val delta = available.y val newOffset = (scrollOffset.value + delta).coerceIn(0f, maxScrollOffsetPx) scrollOffset.value = newOffset return Offset.Zero } } } Box( modifier = Modifier .fillMaxSize() .nestedScroll(nestedScrollConnection) ) { LazyColumnExample(scrollProgress) }}ConclusionIn this article, we delved into the realm of creating a dynamic, collapsing header in Jetpack Compose. We explored the intricacies of custom layouts, dynamic sizing, and the powerful concept of nested scrolling.By leveraging the NestedScrollConnection, we were able to seamlessly integrate the header's behavior with the underlying scrollable content. This connection allows for a smooth and intuitive user experience, as the header gracefully expands and collapses in response to user gestures.By mastering these techniques, you can elevate your Jetpack Compose applications to new heights, providing users with engaging and delightful experiences.ReferencesI hope this article was helpful to you. You can write me back at karishma.agr1996@gmail.com if you want me to improve something in upcoming articles. Your feedback is valuable.Also, follow me on Medium and LinkedinYour claps are appreciated to help others find this article 😃 .",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*khPFw1H7giplcH42MXQfFw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://karishma-agr1996.medium.com/?source=post_page---byline--abb4632d0b47--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Karishma Agrawal\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*hp8ICXAiwBt5JdknmItJ9g.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--abb4632d0b47--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f0bf\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"e7e6\"\u003eCreating smooth, responsive user experiences in modern UI development often involves complex scrolling interactions. One common requirement is nested scrolling, where a scrollable component is embedded within another. Jetpack Compose, with its declarative approach, provides an elegant way to handle such interactions.\u003c/p\u003e\u003cp id=\"8e43\"\u003eIn \u003cstrong\u003ePART 1\u003c/strong\u003e of this article, we covered scroll states and the basics of nested scrolling. Now, in \u003cstrong\u003ePART 2\u003c/strong\u003e, we will build a dynamic UI with a collapsing toolbar and learn how to handle nested scrolling effectively.\u003c/p\u003e\u003cp id=\"d701\"\u003e\u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/mastering-scroll-in-jetpack-compose-part-1-7bacefce436e#e62c-f7d9ba16a21c\"\u003e\u003cstrong\u003e\u003cem\u003eMastering Scroll in Jetpack Compose — PART 1\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"6ab2\"\u003eOverview\u003c/h2\u003e\u003cp id=\"169a\"\u003eWe aim to create an interface with a lazy list where scrolling causes the top card to transform into a toolbar, with a smooth, curved path transition effect.\u003c/p\u003e\u003ch2 id=\"4895\"\u003eWhat You’ll Learn\u003c/h2\u003e\u003cul\u003e\u003cli id=\"e587\"\u003eCreating custom layouts\u003c/li\u003e\u003cli id=\"bc06\"\u003eResizing layouts based on states (collapsed or expanded)\u003c/li\u003e\u003cli id=\"4012\"\u003eCombining lazy list scrolling with screen content\u003c/li\u003e\u003cli id=\"ac3e\"\u003eWorking with nested scrolling and \u003ccode\u003eNestedScrollConnection\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"2055\"\u003e\u003cem\u003eStep 1: \u003c/em\u003eBuilding the Header\u003c/h2\u003e\u003cp id=\"f30a\"\u003eThe header has two states: \u003cstrong\u003eexpanded\u003c/strong\u003e and \u003cstrong\u003ecollapsed\u003c/strong\u003e. We use dynamic elements with changing heights and widths to achieve a smooth transition between these states.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eExpanded state\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cem\u003eCollapsed state\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"a420\"\u003e\u003cem\u003eTo calculate the height for these containers we will use Custom layout in compose. If you already not know custom layout checkout \u003c/em\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/custom\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ethis\u003c/em\u003e\u003c/a\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"16b5\"\u003e\u003cstrong\u003e# Defining the Heights\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9cf6\"\u003eprivate val expandedBoxHeight = 200.dp\u003cbr/\u003eprivate val collapsedBoxHeight = 96.dp\u003cbr/\u003eprivate val ExpandedLeoHeight = 80.dp\u003cbr/\u003eprivate val CollapsedLeoHeight = 32.dp\u003cbr/\u003eprivate val leoTextHeight = 16.sp\u003cbr/\u003eprivate val ButtonSize = 24.dp\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b924\"\u003eWe interpolate between these values as the header transitions between states.\u003c/p\u003e\u003cp id=\"be56\"\u003e\u003cem\u003eTo get the linear sizes ar each state we use \u003c/em\u003e\u003ccode\u003e\u003cem\u003elerp\u003c/em\u003e\u003c/code\u003e\u003cem\u003e function.\u003c/em\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9dc2\"\u003eval leoHeight = with(LocalDensity.current) {\u003cbr/\u003e    lerp(CollapsedLeoHeight.toPx(), ExpandedLeoHeight.toPx(), progress).toDp()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2724\"\u003e\u003cem\u003ewhere progress is changing from 1f to 0f lineraly.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"5b9a\"\u003e\u003cstrong\u003e\u003cem\u003e# Create box to set background image.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"95bb\"\u003e@Composable\u003cbr/\u003efun CollapsingToolbar(\u003cbr/\u003e    @DrawableRes backgroundImageResId: Int,\u003cbr/\u003e    progress: Float,\u003cbr/\u003e    onPrivacyTipButtonClicked: () -\u0026gt; Unit,\u003cbr/\u003e    onSettingsButtonClicked: () -\u0026gt; Unit,\u003cbr/\u003e    modifier: Modifier = Modifier\u003cbr/\u003e) {\u003cbr/\u003e    val leoHeight = with(LocalDensity.current) {\u003cbr/\u003e        lerp(CollapsedLeoHeight.toPx(), ExpandedLeoHeight.toPx(), progress).toDp()\u003cbr/\u003e    }\u003cbr/\u003e    val logoPadding = with(LocalDensity.current) {\u003cbr/\u003e        lerp(CollapsedPadding.toPx(), ExpandedPadding.toPx(), progress).toDp()\u003cbr/\u003e    }\u003cbr/\u003eSurface(\u003cbr/\u003e    color = MaterialTheme.colors.primary,\u003cbr/\u003e    elevation = Elevation,\u003cbr/\u003e    modifier = modifier\u003cbr/\u003e) {\u003cbr/\u003e    Box(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e            .height(if (progress == 1f) 200.dp else leoHeight * 3)\u003cbr/\u003e    ) {\u003cbr/\u003e    //#Background Image\u003cbr/\u003e            Image(\u003cbr/\u003e                painter = painterResource(id = backgroundImageResId),\u003cbr/\u003e                contentDescription = null,\u003cbr/\u003e                contentScale = ContentScale.FillWidth,\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxSize()\u003cbr/\u003e                    .graphicsLayer {\u003cbr/\u003e                        alpha = progress * Alpha\u003cbr/\u003e                    },\u003cbr/\u003e                alignment = BiasAlignment(0f, 1f - ((1f - progress) * 0.75f))\u003cbr/\u003e            )\u003cp\u003e      ....... // inside content }\u003cbr/\u003e}\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"25df\"\u003e\u003cem\u003eHere background image alignment is changing with progress.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"e4db\"\u003e\u003cstrong\u003e\u003cem\u003ewhen progress = 1f\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e\u003cbr/\u003e(0f , 1f — ((1f — progress) * 0.75f) = (0f , 1f — ((1f — 1f) * 0.75f)\u003c/em\u003e\u003c/p\u003e\u003cp id=\"ef62\"\u003e\u003cem\u003e(0f, 1f — 0f * 0.75f) = (0f, 1f) which mean it will start from horizontal 0 to vertical 1.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"839b\"\u003e\u003cstrong\u003e\u003cem\u003ewhen progress = 0f\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"ae07\"\u003e\u003cem\u003e(0f , 1f — ((1f — progress) * 0.75f) = (0f , 1f — ((1f — 0f) * 0.75f)\u003c/em\u003e\u003c/p\u003e\u003cp id=\"313d\"\u003e\u003cem\u003e(0f, 1f — 1f * 0.75f) = (0f, 1f-0.75f) = (0f, 0.25f)\u003c/em\u003e\u003c/p\u003e\u003cp id=\"438c\"\u003e\u003cem\u003ewhich mean it will start from horizontal 0 to vertical 0.25f alignment of whole box size .\u003c/em\u003e\u003c/p\u003e\u003cp id=\"c517\"\u003e\u003cem\u003eand alpga is changing with progress which means on 1f it will be completely visible to get invisible on 0f progress value.\u003c/em\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"fd6c\"\u003e\u003cstrong\u003e\u003cem\u003e# Now let’s add all these element without any sense of direction for now.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a7f7\"\u003e//Inside card elements\u003cbr/\u003eImage(\u003cbr/\u003e    painter = painterResource(id = R.drawable.ic_leo),\u003cbr/\u003e    contentDescription = null,\u003cbr/\u003e    modifier = Modifier\u003cbr/\u003e        .padding(logoPadding)\u003cbr/\u003e        .height(leoHeight)\u003cbr/\u003e        .width(leoHeight)\u003cbr/\u003e)\u003cbr/\u003eText(\u003cbr/\u003e    text = \u0026#34;LEO\u0026#34;,\u003cbr/\u003e    color = Color.White,\u003cbr/\u003e    fontSize = 16.sp,\u003cbr/\u003e    modifier = Modifier\u003cbr/\u003e        .padding(logoPadding)\u003cbr/\u003e        .wrapContentWidth(),\u003cbr/\u003e)\u003cbr/\u003eRow(\u003cbr/\u003e    modifier = Modifier.wrapContentSize(),\u003cbr/\u003e    horizontalArrangement = Arrangement.spacedBy(ContentPadding)\u003cbr/\u003e) {\u003cbr/\u003e    IconButton(\u003cbr/\u003e        onClick = onPrivacyTipButtonClicked,\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .size(ButtonSize)\u003cbr/\u003e            .background(\u003cbr/\u003e                color = LocalContentColor.current.copy(alpha = 0.0f),\u003cbr/\u003e                shape = CircleShape\u003cbr/\u003e            )\u003cbr/\u003e    ) {\u003cbr/\u003e        Icon(\u003cbr/\u003e            modifier = Modifier.fillMaxSize(),\u003cbr/\u003e            imageVector = Icons.Rounded.Edit,\u003cbr/\u003e            contentDescription = null,\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e    IconButton(\u003cbr/\u003e        onClick = onSettingsButtonClicked,\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .size(ButtonSize)\u003cbr/\u003e            .background(\u003cbr/\u003e                color = LocalContentColor.current.copy(alpha = 0.0f),\u003cbr/\u003e                shape = CircleShape\u003cbr/\u003e            )\u003cbr/\u003e    ) {\u003cbr/\u003e        Icon(\u003cbr/\u003e            modifier = Modifier.fillMaxSize(),\u003cbr/\u003e            imageVector = Icons.Rounded.Share,\u003cbr/\u003e            contentDescription = null,\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3827\"\u003e\u003cstrong\u003e\u003cem\u003e# Arrange them dynamically using custom layout\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ad3e\"\u003e@Composable\u003cbr/\u003efun CollapsingToolbar(\u003cbr/\u003e    @DrawableRes backgroundImageResId: Int,\u003cbr/\u003e    progress: Float,\u003cbr/\u003e    onPrivacyTipButtonClicked: () -\u0026gt; Unit,\u003cbr/\u003e    onSettingsButtonClicked: () -\u0026gt; Unit,\u003cbr/\u003e    modifier: Modifier = Modifier\u003cbr/\u003e) {\u003cbr/\u003e    val leoHeight = with(LocalDensity.current) {\u003cbr/\u003e        lerp(CollapsedLeoHeight.toPx(), ExpandedLeoHeight.toPx(), progress).toDp()\u003cbr/\u003e    }\u003cbr/\u003e    val logoPadding = with(LocalDensity.current) {\u003cbr/\u003e        lerp(CollapsedPadding.toPx(), ExpandedPadding.toPx(), progress).toDp()\u003cbr/\u003e    }\u003cbr/\u003eSurface(\u003cbr/\u003e    color = MaterialTheme.colors.primary,\u003cbr/\u003e    elevation = Elevation,\u003cbr/\u003e    modifier = modifier\u003cbr/\u003e) {\u003cbr/\u003e    Box(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e            .height(if (progress == 1f) 200.dp else leoHeight * 3)\u003cbr/\u003e    ) {\u003cbr/\u003e    //#Background Image\u003cbr/\u003e            Image(\u003cbr/\u003e                painter = painterResource(id = backgroundImageResId),\u003cbr/\u003e                contentDescription = null,\u003cbr/\u003e                contentScale = ContentScale.FillWidth,\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxSize()\u003cbr/\u003e                    .graphicsLayer {\u003cbr/\u003e                        alpha = progress * Alpha\u003cbr/\u003e                    },\u003cbr/\u003e                alignment = BiasAlignment(0f, 1f - ((1f - progress) * 0.75f))\u003cbr/\u003e            )\u003cbr/\u003e            CollapsingToolbarLayout(progress, Modifier) {\u003cbr/\u003e                    //Inside card elements \u003cbr/\u003e                      ..............................\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e}\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"76cf\"\u003e@Composable\u003cbr/\u003eprivate fun CollapsingToolbarLayout(\u003cbr/\u003e    progress: Float,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    content: @Composable () -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e Layout(\u003cbr/\u003e        modifier = modifier,\u003cbr/\u003e        content = content\u003cbr/\u003e    ) { measurables, constraints -\u0026gt;\u003cp\u003e// Repositioning of the elements\u003cbr/\u003e... \u003cbr/\u003e}\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d815\"\u003e\u003cem\u003enow check element count is 3(1. cat image, 2. Text, 3. row of buttons) and get placables from that.\u003c/em\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"86e4\"\u003echeck(measurables.size == 3)\u003cbr/\u003eval placeables = measurables.map {\u003cbr/\u003e    it.measure(constraints)\u003cbr/\u003e}\u003cbr/\u003elayout(\u003cbr/\u003e    width = constraints.maxWidth,\u003cbr/\u003e    height = constraints.maxHeight\u003cbr/\u003e) {\u003cbr/\u003e    val expandedHorizontalGuideline = (constraints.maxHeight * 0.4f).roundToInt()\u003cbr/\u003e    val collapsedHorizontalGuideline = (constraints.maxHeight * 0.5f).roundToInt()\u003cp\u003e    val leoImage = placeables[0]\u003cbr/\u003e    val petName = placeables[1]\u003cbr/\u003e    val buttons = placeables[2]\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3465\"\u003eWe will check the positioning of each item in\u003c/p\u003e\u003cp id=\"14a9\"\u003e\u003cstrong\u003e#Collapsed state\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"4036\"\u003e\u003cstrong\u003eCat Image \u003c/strong\u003e: because content padding was already added. x cooridnate can start from 0 in this case. and y can be middle of collapsed card.\u003c/p\u003e\u003cp id=\"792c\"\u003e\u003ccode\u003ex = 0\u003cbr/\u003ey = collapsedHorizontalGuideline/2\u003c/code\u003e\u003c/p\u003e\u003cp id=\"3c53\"\u003e\u003cstrong\u003eText\u003c/strong\u003e : x coordinate will start after cat image. and padding was already added.\u003cbr/\u003e\u003ccode\u003ex = leoImage.width\u003cbr/\u003ey = (collapsedHorizontalGuideline — petName.height/2)\u003c/code\u003e\u003c/p\u003e\u003cp id=\"815c\"\u003e\u003cstrong\u003eButtons\u003c/strong\u003e :\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e9b3\"\u003ex = constraints.maxWidth - buttons.width\u003cbr/\u003ey = (constraints.maxHeight - buttons.height) / 2\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"67d5\"\u003eSame way place expanded content. whole code will look something like this.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7edf\"\u003e@Composable\u003cbr/\u003eprivate fun CollapsingToolbarLayout(\u003cbr/\u003e    progress: Float,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    content: @Composable () -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    Layout(\u003cbr/\u003e        modifier = modifier,\u003cbr/\u003e        content = content\u003cbr/\u003e    ) { measurables, constraints -\u0026gt;\u003cbr/\u003e        check(measurables.size == 3)\u003cbr/\u003e        val placeables = measurables.map {\u003cbr/\u003e            it.measure(constraints)\u003cbr/\u003e        }\u003cbr/\u003e        layout(\u003cbr/\u003e            width = constraints.maxWidth,\u003cbr/\u003e            height = constraints.maxHeight\u003cbr/\u003e        ) {\u003cbr/\u003e            val expandedHorizontalGuideline = (constraints.maxHeight * 0.4f).roundToInt()\u003cbr/\u003e            val collapsedHorizontalGuideline = (constraints.maxHeight * 0.5f).roundToInt()\u003cp\u003e            val leoImage = placeables[0]\u003cbr/\u003e            val petName = placeables[1]\u003cbr/\u003e            val buttons = placeables[2]\u003c/p\u003e\u003cp\u003e            leoImage.placeRelative(\u003cbr/\u003e                x = lerp(\u003cbr/\u003e                    start = 0,\u003cbr/\u003e                    stop = constraints.maxWidth / 2 - leoImage.width / 2,\u003cbr/\u003e                    fraction = progress\u003cbr/\u003e                ),\u003cbr/\u003e                y = lerp(\u003cbr/\u003e                    start = collapsedHorizontalGuideline / 2,\u003cbr/\u003e                    stop = expandedHorizontalGuideline / 2,\u003cbr/\u003e                    fraction = progress\u003cbr/\u003e                )\u003cbr/\u003e            )\u003cbr/\u003e            petName.placeRelative(\u003cbr/\u003e                x = lerp(\u003cbr/\u003e                    start = leoImage.width ,\u003cbr/\u003e                    stop = constraints.maxWidth / 2 - petName.width / 2,\u003cbr/\u003e                    fraction = progress\u003cbr/\u003e                ),\u003cbr/\u003e                y = lerp(\u003cbr/\u003e                    start = (collapsedHorizontalGuideline - petName.height/2),\u003cbr/\u003e                    stop = constraints.maxHeight / 2 + leoImage.width / 3,\u003cbr/\u003e                    fraction = progress\u003cbr/\u003e                )\u003cbr/\u003e            )\u003cbr/\u003e            buttons.placeRelative(\u003cbr/\u003e                x = constraints.maxWidth - buttons.width,\u003cbr/\u003e                y = lerp(\u003cbr/\u003e                    start = (constraints.maxHeight - buttons.height) / 2,\u003cbr/\u003e                    stop = 0,\u003cbr/\u003e                    fraction = progress\u003cbr/\u003e                )\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"36a4\"\u003e\u003cem\u003eHere \u003c/em\u003e\u003ccode\u003e\u003cem\u003eplaceRelative\u003c/em\u003e\u003c/code\u003e\u003cem\u003e function takes x, y, z coordinates. and to set x, y we will again use lerp function we defines linear path for these cooridinates, where start being collapsed state and stop being expanded state.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"5c45\"\u003eI hope it was pretty clean till now.\u003c/p\u003e\u003ch2 id=\"1072\"\u003e\u003cstrong\u003eStep 2: In this step we will create a list below header and add scroll state to create collapsing view\u003c/strong\u003e\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"38e8\"\u003e@Composable\u003cbr/\u003efun LazyColumnExample(progress: Float, scrollState: ScrollableState) {\u003cbr/\u003e    val items = listOf(\u003cbr/\u003e        \u0026#34;Item 1\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 2\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 3\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 4\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 5\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 6\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 7\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 8\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 9\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 10\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 11\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 12\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 13\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 14\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 15\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 16\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 17\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 18\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 19\u0026#34;,\u003cbr/\u003e        \u0026#34;Item 20\u0026#34;\u003cbr/\u003e    )\u003cp\u003e    LazyColumn(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e            .background(Color.LightGray)\u003cbr/\u003e            .scrollable(scrollState, Orientation.Vertical)\u003cbr/\u003e    ) {\u003cbr/\u003e        item {\u003cbr/\u003e            CollapsingToolbar(R.drawable.ic_unsplash_background, progress, {}, {}, Modifier)\u003cbr/\u003e        }\u003cbr/\u003e        items(items.size) { item -\u0026gt;\u003cbr/\u003e            Box(\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .padding(16.dp),\u003cbr/\u003e                contentAlignment = Alignment.Center\u003cbr/\u003e            ) {\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = items[item],\u003cbr/\u003e                    color = Color.Black\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"881d\"\u003eThis will create a list below header. now add scrolling.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"de28\"\u003e@Composable\u003cbr/\u003efun MyScreen() {\u003cbr/\u003e    val scrollState = rememberScrollState()\u003cbr/\u003e    val maxScrollOffset = 500 // Adjust this to your desired maximum scroll offset\u003cp\u003e    val progress = remember {\u003cbr/\u003e        derivedStateOf {\u003cbr/\u003e            val currentScrollOffset = scrollState.value\u003cbr/\u003e            val progressValue = currentScrollOffset.toFloat() / maxScrollOffset.toFloat()\u003cbr/\u003e            progressValue.coerceIn(0f, 1f)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // Use the \u0026#39;progress\u0026#39; state to control the toolbar\u0026#39;s appearance\u003cbr/\u003e    Box(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e    ) {\u003cbr/\u003e        LazyColumnExample(progress.value, scrollState)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"913f\"\u003eIn this code, \u003ccode\u003escrollOffset\u003c/code\u003e is an \u003ccode\u003eAnimatable\u003c/code\u003e object used to keep track of the toolbar\u0026#39;s current offset (or position) on the Y-axis as it transitions between expanded and collapsed states. It\u0026#39;s animated to provide smooth, gradual transitions between these states based on the scroll direction (up or down).\u003c/p\u003e\u003cp id=\"c544\"\u003eProgress value will change on bases of scroll offset. Let’s run this code and see.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"8cab\"\u003eOops. Both the scrolling containers are not working together. something it collapses the header, but other time it is just scrolling the list.\u003c/p\u003e\u003ch2 id=\"e364\"\u003e\u003cstrong\u003eStep 3: Add Nested scrolling\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"c32f\"\u003eThis is where nested scrolling comes into picture.\u003c/p\u003e\u003cp id=\"0589\"\u003eNested scrolling is a system where multiple scrolling components contained within each other work together by reacting to a single scroll gesture and communicating their scrolling deltas (changes). This is essential when there are nested scrollable elements, like a scrollable toolbar (collapsing or expanding) at the top of a list, where both components need to respond to the user’s scroll input in a synchronized manner.\u003c/p\u003e\u003cp id=\"b1f2\"\u003e\u003cstrong\u003eHow Nested Scrolling Works in This Example\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"4f40\"\u003e\u003ccode\u003e\u003cstrong\u003eNestedScrollConnection\u003c/strong\u003e\u003c/code\u003e: This interface lets you intercept, control, and respond to scroll events for coordinated scrolling. We use \u003ccode\u003eNestedScrollConnection\u003c/code\u003e here to control the toolbar\u0026#39;s expand and collapse behavior based on the user\u0026#39;s scroll actions.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a898\"\u003eval nestedScrollConnection = remember {\u003cbr/\u003e    object : NestedScrollConnection {\u003cbr/\u003e            override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {\u003cbr/\u003e}\u003cp\u003e  override fun onPostScroll(\u003cbr/\u003e                consumed: Offset,\u003cbr/\u003e                available: Offset,\u003cbr/\u003e                source: NestedScrollSource\u003cbr/\u003e            ): Offset {\u003cbr/\u003e}\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3377\"\u003e\u003cstrong\u003eThe Nested Scroll Chain\u003c/strong\u003e: When nested scrolling is active, events are passed through a chain of scrollable components, which communicate with each other:\u003c/p\u003e\u003cp id=\"88cb\"\u003e\u003ccode\u003e\u003cstrong\u003eonPreScroll\u003c/strong\u003e\u003c/code\u003e: This method lets a parent component intercept a scroll event before the child handles it. In this example, \u003ccode\u003eonPreScroll\u003c/code\u003e checks the scroll delta (how much the user has scrolled) to determine if the toolbar should expand or collapse based on the scroll direction.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f87b\"\u003e  override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {\u003cbr/\u003e                val delta = available.y\u003cbr/\u003e                val newOffset = (scrollOffset.value + delta).coerceIn(0f, maxScrollOffsetPx)\u003cbr/\u003e                val consumed = newOffset - scrollOffset.value\u003cbr/\u003e                scrollOffset.value = newOffset\u003cbr/\u003e                return Offset(x = 0f, y = consumed)\u003cbr/\u003e            }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a1ce\"\u003e\u003cstrong\u003e. \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eonPostScroll\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e : \u003c/strong\u003eThis pass occurs when the dispatching (scrolling) descendant made their consumption and notifies ancestors with what’s left for them to consume.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f47b\"\u003eoverride fun onPostScroll(\u003cbr/\u003e    consumed: Offset,\u003cbr/\u003e    available: Offset,\u003cbr/\u003e    source: NestedScrollSource\u003cbr/\u003e): Offset {\u003cbr/\u003e    val delta = available.y\u003cbr/\u003e    val newOffset = (scrollOffset.value + delta).coerceIn(0f, maxScrollOffsetPx)\u003cbr/\u003e    scrollOffset.value = newOffset\u003cbr/\u003e    return Offset.Zero\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"caae\"\u003e\u003cstrong\u003eAccumulating Scroll Delta\u003c/strong\u003e: By accumulating the scroll delta, the code ensures that the toolbar doesn’t collapse or expand for small scrolls, only for significant gestures in the up or down direction.\u003c/li\u003e\u003cli id=\"8cf9\"\u003e\u003cstrong\u003eAnimating \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003escrollOffset\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e Based on Scroll Direction\u003c/strong\u003e: If the accumulated scroll delta crosses a threshold (e.g., \u003ccode\u003e500f\u003c/code\u003e), the \u003ccode\u003escrollOffset\u003c/code\u003e is animated to collapse (scroll up) or expand (scroll down) the toolbar.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"d762\"\u003eval maxScrollOffsetPx = 500f\u003cp\u003e// Remember the scroll offset state\u003cbr/\u003eval scrollOffset = remember { androidx.compose.runtime.mutableStateOf(0f) }\u003cbr/\u003eval scrollProgress = (scrollOffset.value / maxScrollOffsetPx).coerceIn(0f, 1f)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"187f\"\u003e\u003cstrong\u003eNested Scrolling with \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eLazyColumn\u003c/strong\u003e\u003c/code\u003e: The \u003ccode\u003eLazyColumn\u003c/code\u003e is the scrollable list of items within the screen. When the user scrolls, the \u003ccode\u003eLazyColumn\u003c/code\u003e emits scroll events. These events are intercepted by the \u003ccode\u003eNestedScrollConnection\u003c/code\u003e to adjust the toolbar’s position before they are passed on to the list for normal scrolling.\u003c/li\u003e\u003cli id=\"2728\"\u003e\u003cstrong\u003eModifier Setup\u003c/strong\u003e: \u003ccode\u003eModifier.nestedScroll(nestedScrollConnection)\u003c/code\u003e is applied to the main \u003ccode\u003eBox\u003c/code\u003e container. This connects the main scrollable content (\u003ccode\u003eLazyColumn\u003c/code\u003e) with the toolbar’s \u003ccode\u003eNestedScrollConnection\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"2c42\"\u003eBox(\u003cbr/\u003e    modifier = Modifier\u003cbr/\u003e        .fillMaxSize()\u003cbr/\u003e        .nestedScroll(nestedScrollConnection)\u003cbr/\u003e) {\u003cbr/\u003e    LazyColumnExample(scrollProgress)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cd7f\"\u003eAs a result:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1ea8\"\u003eWhen the user scrolls up, the toolbar collapses first until it’s fully hidden, then the list scrolls.\u003c/li\u003e\u003cli id=\"1684\"\u003eWhen the user scrolls down, the toolbar expands first, then the list scrolls after the toolbar reaches its fully expanded state.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"bb3a\"\u003eHere is the full code\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ff36\"\u003e@Composable\u003cbr/\u003efun MyScreen() {\u003cbr/\u003e    // Total scroll distance for toolbar collapse\u003cbr/\u003e    val maxScrollOffsetPx = 500f\u003cp\u003e    // Remember the scroll offset state\u003cbr/\u003e    val scrollOffset = remember { androidx.compose.runtime.mutableStateOf(0f) }\u003cbr/\u003e    val scrollProgress = (scrollOffset.value / maxScrollOffsetPx).coerceIn(0f, 1f)\u003c/p\u003e\u003cp\u003e    // Set up a nested scroll connection for nested scroll handling\u003cbr/\u003e    val nestedScrollConnection = remember {\u003cbr/\u003e        object : NestedScrollConnection {\u003cbr/\u003e            override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {\u003cbr/\u003e                val delta = available.y\u003cbr/\u003e                val newOffset = (scrollOffset.value + delta).coerceIn(0f, maxScrollOffsetPx)\u003cbr/\u003e                val consumed = newOffset - scrollOffset.value\u003cbr/\u003e                scrollOffset.value = newOffset\u003cbr/\u003e                return Offset(x = 0f, y = consumed)\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            override fun onPostScroll(\u003cbr/\u003e                consumed: Offset,\u003cbr/\u003e                available: Offset,\u003cbr/\u003e                source: NestedScrollSource\u003cbr/\u003e            ): Offset {\u003cbr/\u003e                val delta = available.y\u003cbr/\u003e                val newOffset = (scrollOffset.value + delta).coerceIn(0f, maxScrollOffsetPx)\u003cbr/\u003e                scrollOffset.value = newOffset\u003cbr/\u003e                return Offset.Zero\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    Box(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e            .nestedScroll(nestedScrollConnection)\u003cbr/\u003e    ) {\u003cbr/\u003e        LazyColumnExample(scrollProgress)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"c11c\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"a192\"\u003eIn this article, we delved into the realm of creating a dynamic, collapsing header in Jetpack Compose. We explored the intricacies of custom layouts, dynamic sizing, and the powerful concept of nested scrolling.\u003c/p\u003e\u003cp id=\"91cd\"\u003eBy leveraging the \u003ccode\u003eNestedScrollConnection\u003c/code\u003e, we were able to seamlessly integrate the header\u0026#39;s behavior with the underlying scrollable content. This connection allows for a smooth and intuitive user experience, as the header gracefully expands and collapses in response to user gestures.\u003c/p\u003e\u003cp id=\"1df4\"\u003eBy mastering these techniques, you can elevate your Jetpack Compose applications to new heights, providing users with engaging and delightful experiences.\u003c/p\u003e\u003ch2 id=\"8e9f\"\u003e\u003cem\u003eReferences\u003c/em\u003e\u003c/h2\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"0995\"\u003eI hope this article was helpful to you. You can write me back at \u003cstrong\u003ekarishma.agr1996@gmail.com\u003c/strong\u003e if you want me to improve something in upcoming articles. Your feedback is valuable.\u003c/p\u003e\u003cp id=\"664b\"\u003eAlso, follow me on Medium and \u003ca href=\"https://www.linkedin.com/in/karishma-agrawal-she-her-06966a126/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinkedin\u003c/a\u003e\u003c/p\u003e\u003cp id=\"738f\"\u003eYour claps are appreciated to help others find this article 😃 .\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2024-11-14T05:49:17.357Z",
  "modifiedTime": null
}
