{
  "id": "4de764f9-4e5d-4813-8350-8fbd9a2ed4e9",
  "title": "Android Maps Usage from A to Z — Working with Google Maps SDK: Marker, Polyline, Polygon, Circle…",
  "link": "https://proandroiddev.com/android-maps-usage-from-a-to-z-working-with-google-maps-sdk-marker-polyline-polygon-circle-4b8b6fbdbd3e?source=rss----c72404660798---4",
  "description": "",
  "author": "Tolga Pirim",
  "published": "Tue, 10 Jun 2025 15:59:21 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "google-maps",
    "android",
    "android-app-development",
    "androiddev",
    "maps"
  ],
  "byline": "Tolga Pirim",
  "length": 29805,
  "excerpt": "This article explains how to add interactive elements to maps in Android applications using the Google Maps SDK. It covers how to create and customize map components such as markers, polylines…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "This article explains how to add interactive elements to maps in Android applications using the Google Maps SDK. It covers how to create and customize map components such as markers, polylines, polygons, and circles. Additionally, it provides practical tips for using marker clustering to improve the visual organization of map elements.Photo by Tamas Tuzes-Katai on UnsplashAdding Required Dependencies and Generating an API Key for Map UsageTo use Google Maps in Android applications, you need to add specific dependencies to your project.The maps-ktx library allows you to leverage Kotlin language features while working with the Maps SDK on Android.Add the following dependencies to your build.gradle (Module: app) file:implementation(\"com.google.android.gms:play-services-maps:19.0.0\")implementation(\"com.google.maps.android:maps-ktx:5.1.1\")After adding the necessary dependencies, you need to create a project in the Google Cloud Platform (GCP) and generate an API key to enable Google Maps services.1 - Generating an API Key on Google CloudTo use the Google Maps API, follow these steps:Go to the Google Cloud Platform.Create a new project.From the left-hand menu, navigate to APIs \u0026 Services.Click on the Credentials tab.Click Create API Key to generate a new API key.Securing Your API KeyFor security purposes, it is recommended to restrict your API key by specifying:Your application’s package nameThe SHA-1 certificate fingerprintGetting the SHA-1 Certificate FingerprintTo obtain the SHA-1 fingerprint, open your terminal in the root directory of your Android project and run the following command:./gradlew signingReportAfter the command executes, the terminal will display the SHA-1 value. You can use this value in the API key restriction settings on Google Cloud.2 - Adding the API Key to Your ApplicationTo securely store your API key in your Android project, follow these steps:Use the Secrets Gradle PluginYou can use the Secrets Gradle Plugin to manage your API key securely.Add the following dependency to your project-level build.gradle or build.gradle.kts file:buildscript { dependencies { classpath(\"com.google.android.libraries.mapsplatform.secrets-gradle-plugin:secrets-gradle-plugin:2.0.1\") }}2. Apply the PluginIn your module-level build.gradle or build.gradle.kts file, apply the plugin:plugins { id(\"com.google.android.libraries.mapsplatform.secrets-gradle-plugin\")}3. Create a secrets.properties FileIn the root directory of your project, create a file named secrets.properties and add the following line:MAPS_API_KEY=YOUR_API_KEY4. Add a Default ValueTo avoid build errors when the API key is missing, create a local.defaults.properties file and add:MAPS_API_KEY=DEFAULT_API_KEY5. Add API Key to AndroidManifest.xmlInsert the following \u003cmeta-data\u003e tag inside your \u003capplication\u003e tag:\u003capplication\u003e ... \u003cmeta-data android:name=\"com.google.android.geo.API_KEY\" android:value=\"${MAPS_API_KEY}\" /\u003e\u003c/application\u003e6. Configure the PluginIn your module-level build.gradle file, configure the plugin:android { secrets { propertiesFileName = \"secrets.properties\" defaultPropertiesFileName = \"local.defaults.properties\" ignoreList.add(\"keyToIgnore\") ignoreList.add(\"sdk.*\") }}After completing these steps, your API key will be securely integrated into your application.3 - The New Map RendererWith version 18.2.0 of the Google Maps SDK, a new map renderer was introduced. This renderer brings several improvements and benefits for developers:Cloud-based Maps Styling: Allows dynamic updates to the visual styling of maps through the cloud.Advanced Polyline Customization: Enables more refined and visually appealing line styles.Reduced Network and Memory Usage: Enhances app efficiency by minimizing unnecessary data consumption.Improved Motion Controls: Offers smoother animations, panning, and zooming experiences.Backward CompatibilityGoogle ensures that devices not supporting the new renderer will continue to use the legacy renderer. Although you can work with version 18.2.0 or later, developers may opt to use the legacy renderer until March 2025. After this date, the choice will be removed, and Google will automatically apply the legacy renderer on unsupported devices.Selecting a RendererYou can specify whether to use the legacy or latest renderer with the following setup:class MapRendererOptInApplication : Application(), OnMapsSdkInitializedCallback { override fun onCreate() { super.onCreate() // Select the renderer here (LEGACY or LATEST) MapsInitializer.initialize(applicationContext, Renderer.LEGACY, this) } override fun onMapsSdkInitialized(renderer: MapsInitializer.Renderer) { when (renderer) { Renderer.LATEST -\u003e Log.d(\"MapsDemo\", \"The latest version of the renderer is used.\") Renderer.LEGACY -\u003e Log.d(\"MapsDemo\", \"The legacy version of the renderer is used.\") } }}In this example, the MapsInitializer.initialize() method lets you define which renderer to use, while onMapsSdkInitialized() provides feedback on the active renderer at runtime.Core Google Maps ClassesHere are some fundamental classes used when working with the Google Maps SDK in Android:GoogleMap: The main entry point for interacting with the map’s data and features. It is only accessible via a SupportMapFragment or MapView.SupportMapFragment: A fragment that manages the lifecycle of a GoogleMap instance.MapView: A View-based alternative that also manages the GoogleMap lifecycle.OnMapReadyCallback: An interface that is triggered once the map is ready to be used.Among these, SupportMapFragment is more modern and widely adopted. We'll continue using this approach in our implementation.Step 1: Add the Fragment in XML\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"\u003e \u003candroidx.fragment.app.FragmentContainerView android:id=\"@+id/mapView\" android:name=\"com.google.android.gms.maps.SupportMapFragment\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" /\u003e\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003eStep 2: Implement OnMapReadyCallback in Your Activityclass MainActivity : AppCompatActivity(), OnMapReadyCallback { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val supportMapFragment = supportFragmentManager .findFragmentById(R.id.mapView) as SupportMapFragment supportMapFragment.getMapAsync(this) } override fun onMapReady(googleMap: GoogleMap) { googleMap.moveCamera( CameraUpdateFactory.newLatLngZoom( LatLng(41.0082, 28.9784), // Istanbul, Turkey 15f ) ) }}In this setup:We implement OnMapReadyCallback to detect when the map is fully loaded.getMapAsync(this) initializes the map asynchronously.Once ready, the map centers on a sample location (Istanbul, Turkey) using CameraUpdateFactory.newLatLngZoom() with a zoom level of 15x.4 - Adding a MarkerTo highlight a specific location on the map, you can use the Marker object. Markers are commonly used to provide users with a visual reference and additional contextual information.Here’s how to add a basic marker:googleMap.addMarker( MarkerOptions() .position(istanbul) .title(\"Istanbul\") .snippet(\"Tarihi Yarımada\") .icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_BLUE)))googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(istanbul, 12f))Using a Custom IconThe Google Maps SDK supports icons of type BitmapDescriptor. If you want to use your own image (like a vector drawable), you'll first need to convert it to a Bitmap.Convert Vector Drawable to Bitmapfun vectorToBitmap( context: Context, @DrawableRes vectorResId: Int): Bitmap { val drawable = ContextCompat.getDrawable(context, vectorResId) val bitmap = Bitmap.createBitmap( drawable?.intrinsicWidth ?: 0, drawable?.intrinsicHeight ?: 0, Bitmap.Config.ARGB_8888 ) val canvas = Canvas(bitmap) drawable?.setBounds(0, 0, canvas.width, canvas.height) drawable?.draw(canvas) return bitmap}Add a Marker with a Custom Bitmap IcongoogleMap.addMarker( MarkerOptions() .position(istanbul) .title(\"İstanbul\") .snippet(\"Tarihi Yarımada\") .icon( BitmapDescriptorFactory.fromBitmap( vectorToBitmap(this, R.drawable.ic_launcher_foreground) ) ))This allows you to personalize marker icons with your own vector images.Removing a MarkerIn Google Maps SDK, to remove a marker, you need to keep a reference to the Marker object. The googleMap.addMarker() method returns this reference, which you can then use to remove the marker from the map:val marker: Marker? = googleMap.addMarker( MarkerOptions() .position(LatLng(41.0082, 28.9784)) .title(\"Istanbul\") .snippet(\"Tarihi Yarımada\"))// Remove the marker from the mapmarker?.remove()5 - Google Maps Camera MovementsThe Google Maps SDK provides several ways to control the camera’s position and orientation on the map, enhancing user experience by focusing on specific areas.Core Classes for Camera Control:CameraUpdateFactory: Creates camera update objects.GoogleMap.moveCamera(): Instantly moves the camera.GoogleMap.animateCamera(): Moves the camera with animation.moveCamera()Quickly moves the camera to a specific location and zoom level:val istanbul = LatLng(41.0082, 28.9784)googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(istanbul, 12f))Zoom levels meaning:1–5: Global view10–15: City view16+: Street-level detailanimateCamera()Smoothly animates the camera movement:val ankara = LatLng(39.9334, 32.8597)googleMap.animateCamera(CameraUpdateFactory.newLatLngZoom(ankara, 14f))Rotate and Tilt the CameraYou can rotate (bearing) and tilt the camera for better perspectives:val cameraPosition = CameraPosition.Builder() .target(LatLng(41.0082, 28.9784)) .zoom(16f) .bearing(90f) // East (0 = North, 90 = East) .tilt(45f) // Tilt angle (0-90 degrees) .build()googleMap.moveCamera(CameraUpdateFactory.newCameraPosition(cameraPosition))Camera Bounds for Multiple LocationsTo frame multiple locations within the viewport:val bounds = LatLngBounds.builder() .include(LatLng(41.0082, 28.9784)) // Istanbul .include(LatLng(39.9334, 32.8597)) // Ankara .build()googleMap.animateCamera(CameraUpdateFactory.newLatLngBounds(bounds, 100))This adjusts the camera to show both points with padding.6 - Drawing a Polyline on Google MapsGoogle Maps SDK allows you to create Polyline objects that connect two or more points on the map. Polylines are commonly used to visualize routes, paths, or boundaries.Here is a simple example of how to draw a polyline:val polylineOptions = PolylineOptions() .add(LatLng(40.989010, 29.022949)) // First point .add(LatLng(40.986484, 29.023937)) // Second point .color(ContextCompat.getColor(this, R.color.blue)) // Line color .width(10f) // Line width in pixelsgoogleMap.addPolyline(polylineOptions)Use .add() multiple times to include each point in the polyline.Customize the polyline’s color and width for better visibility.The polyline will be rendered as a connected line between the given points on the map.You can make polylines more visually appealing by customizing their patterns using the pattern() method. Google Maps SDK supports these pattern elements:Dot(): A dotted pattern.Dash(length): A solid dash with the specified length in pixels.Gap(length): A blank gap with the specified length in pixels.Here’s an example of a polyline with a dashed pattern:val polylineOptions = PolylineOptions() .add(LatLng(40.989010, 29.022949)) .add(LatLng(40.986484, 29.023937)) .color(ContextCompat.getColor(this, R.color.blue)) .pattern(listOf(Dash(20f), Gap(20f), Dash(20f))) // Dash-Gap-Dash pattern .width(10f)googleMap.addPolyline(polylineOptions)This creates a polyline with alternating dashes and gaps, enhancing the visual style of the line on the map.Remove PolylineTo remove a polyline from the map, you need to keep a reference to the Polyline object returned by googleMap.addPolyline(). Then, you can call the remove() method on that reference:val polyline: Polyline = googleMap.addPolyline( PolylineOptions() .add(LatLng(40.989010, 29.022949)) .add(LatLng(40.986484, 29.023937)) .color(ContextCompat.getColor(this, R.color.blue)) .width(10f))// Remove the polyline from the mappolyline.remove()If you have multiple polylines or markers, managing them with unique IDs stored in a HashMap\u003cString, Polyline\u003e or HashMap\u003cString, Marker\u003e is useful. This way, you can find, update, or remove specific items by their ID easily.7- Adding a PolygonPolygons are similar to polylines but differ in that they form a closed shape and can have a filled interior. They are typically used to visually represent boundaries such as city limits, districts, or service areas on the map.For example, if your app serves only specific neighborhoods or cities, you can draw these boundaries using polygons to clearly communicate the service area to users. Conversely, polygons can also highlight areas where service is not available. The fill color makes these regions visually distinct, improving user experience by preventing incorrect location selections.Example of drawing a polygon with stroke and fill colors:val polygonOptions = PolygonOptions() .add(LatLng(40.989010, 29.022949)) .add(LatLng(40.986484, 29.023937)) .add(LatLng(40.988638, 29.025182)) .strokeColor(ContextCompat.getColor(this, R.color.red)) // Border color .strokeWidth(5f) .fillColor(ContextCompat.getColor(this, R.color.light_red)) // Interior fill colorval polygon: Polygon = googleMap.addPolygon(polygonOptions)This will draw a filled polygon on the map, clearly marking areas such as no-service zones, allowing users to distinguish between serviceable and non-serviceable regions easily.Polygons can be customized with border patterns, similar to polylines. Border lines can be made aesthetic by using dotted, striped or spaced patterns. Deletion is also done by referencing the polygon object, as in polylines. In order to manage multiple polygons in the application, they can be stored in a collection by assigning an ID to each one and removed when necessary.8 - Adding a Circleval circleOptions = CircleOptions() .center(istanbul) .radius(200.0) .strokeColor(ContextCompat.getColor(this, R.color.blue)) .strokeWidth(5f) .fillColor(ContextCompat.getColor(this, R.color.light_blue)) .strokePattern(listOf(Dash(30f), Gap(20f)))googleMap.addCircle(circleOptions)Using Clustering in Google Maps SDKWhen adding many markers to a Google Map, visual clutter and overlapping can reduce clarity. To solve this, the Cluster feature groups nearby markers into a single icon. As users zoom in, the cluster breaks apart and individual markers become visible.Benefits of Clustering:Improved UX — Prevents overcrowding by grouping markers.Performance — Reduces rendering load when many markers are displayed.Scalability — Essential for apps showing dynamic or large datasets.Clustering is especially useful in apps like delivery tracking, real estate, or social networks, where many pins can appear in close proximity.Implementation typically uses the Android Maps Utils library, which provides a ClusterManager to manage and render marker clusters easily.Sample Scenario: Vehicle Sharing App with Marker Selection and ClusteringIn a vehicle-sharing service, we aim to display the locations of available vehicles on the map using individual markers, each with a unique vehicle icon. To manage a clean interface:Marker Display:Each vehicle location is represented with a custom marker icon.When a user taps on a vehicle, the app updates the selected marker with a distinct icon or color to indicate selection.Clustering Implementation:When too many vehicles are shown in one area, clustering groups markers visually.The cluster icon displays the number of grouped vehicles, e.g., +10, +50.Technical Approach:Use ClusterManager from the Google Maps Utils library.Customize ClusterItem to represent each vehicle.Listen for marker clicks to handle selection and update the marker icon accordingly.This approach provides a user-friendly and performant map interface for real-time vehicle discovery.Using ClusteringTo enable clustering on Google Maps, you need to add the following dependency to your build.gradle (Module: app) file:implementation(\"com.google.maps.android:android-maps-utils:3.9.0\")After adding the dependency, you need to create a data class that represents each individual item to be displayed on the map and included in the cluster. This class must implement the ClusterItem interface.This approach allows the clustering utility to manage and group nearby items automatically, improving performance and map readability, especially when displaying a large number of markers.data class CarClusterItem( val lat: Double, val lng: Double, val isSelected: Boolean, val clusterId: String = UUID.randomUUID().toString()) : ClusterItem { override fun getPosition(): LatLng { return LatLng(lat, lng) } override fun getTitle(): String? { return null } override fun getSnippet(): String? { return null } override fun getZIndex(): Float? { return null }}Cluster Managerclass CarClusterManager\u003cT : ClusterItem\u003e( private val context: Context, private val map: GoogleMap) : ClusterManager\u003cT\u003e(context, map) { companion object { private const val CLUSTER_MAX_ZOOM_LEVEL = 14 } private var _shouldClusterZoom: Boolean = true val shouldClusterZoom get() = _shouldClusterZoom override fun onCameraIdle() { super.onCameraIdle() _shouldClusterZoom = map.cameraPosition.zoom \u003c CLUSTER_MAX_ZOOM_LEVEL }}The CarClusterManager class extends the ClusterManager\u003cT\u003e class and is used to manage clustering behavior on the map. This custom class is responsible for configuring how and when markers on the map should be grouped into clusters.A constant named CLUSTER_MAX_ZOOM_LEVEL defines the maximum zoom level at which clustering will be active. In this example, it is set to 14.If the zoom level is less than 14, the _shouldClusterZoom variable is set to true, enabling clustering behavior.If the zoom level is 14 or greater, the _shouldClusterZoom variable is set to false, disabling clustering and allowing markers to be displayed individually.This logic helps improve map readability by dynamically switching between clustered and individual marker views based on the user’s zoom level.Utility Functions for Cluster and Car Iconsobject IconHelper { fun getClusterIcon( context: Context, cluster: Cluster\u003cCarClusterItem\u003e ): BitmapDescriptor { val bucketStr = getBucketString(cluster.size) val bmpClusterSize = vectorToBitmap(context, R.drawable.ic_cluster) val bitmap = bmpClusterSize.drawClusterCount(context, bucketStr, R.color.white) return BitmapDescriptorFactory.fromBitmap(bitmap) } fun getCarIcon( item: CarClusterItem, context: Context ): BitmapDescriptor? { val bitmap = if (item.isSelected) { R.drawable.ic_selected } else { R.drawable.ic_unselected } return vectorToBitmapDescriptor(context, bitmap) } private fun getBucketString(size: Int): String { return when { size \u003e 999 -\u003e \"1000+\" size \u003e 499 -\u003e \"500+\" size \u003e 99 -\u003e \"100+\" size \u003e 49 -\u003e \"50+\" size \u003e 19 -\u003e \"20+\" size \u003e 9 -\u003e \"10+\" else -\u003e size.toString() } } private fun Bitmap.drawClusterCount(context: Context, text: String, color: Int): Bitmap { val bitmap = copy(config!!, true) val canvas = Canvas(bitmap) val paint = createPaint(context, color) val bounds = Rect() paint.getTextBounds(text, 0, text.length, bounds) val width = bitmap.width / 2 val height = bitmap.height / 2.7 canvas.drawText(text, width.toFloat(), height.toFloat(), paint) return bitmap } private fun createPaint(context: Context, color: Int): Paint { return Paint().apply { flags = Paint.ANTI_ALIAS_FLAG textAlign = Paint.Align.CENTER this.color = ContextCompat.getColor(context, color) this.textSize = context.resources.getDimensionPixelSize(R.dimen.text_size_9sp).toFloat() typeface = Typeface.create(Typeface.SANS_SERIF, Typeface.BOLD) } } private fun vectorToBitmap( context: Context, @DrawableRes vectorResId: Int, ): Bitmap { val drawable = ContextCompat.getDrawable(context, vectorResId) val bitmap = Bitmap.createBitmap( drawable?.intrinsicWidth ?: 0, drawable?.intrinsicHeight ?: 0, Bitmap.Config.ARGB_8888 ) val canvas = Canvas(bitmap) drawable?.setBounds(0, 0, canvas.width, canvas.height) drawable?.draw(canvas) return bitmap } private fun vectorToBitmapDescriptor( context: Context, @DrawableRes vectorResId: Int ): BitmapDescriptor? { val bitmap = vectorToBitmap(context, vectorResId) return BitmapDescriptorFactory.fromBitmap(bitmap) }}Before moving on to implementing the ClusterRenderer, let's look at a few utility functions that will help us define custom icons for cars and clusters.getClusterIcon() This function generates an appropriate icon based on the size of the cluster. It visually represents the number of items contained within the cluster to the user.getCarIcon() This function determines which car icon should be displayed on the map depending on whether the item is in a selected or unselected state.vectorToBitmap() Converts a vector-based drawable resource (@DrawableRes) into a Bitmap object, which is required for custom marker icons on Google Maps.These functions provide the visual foundation for customizing how items and clusters are displayed on the map.Cluster Rendererclass CarClusterRenderer( private val context: Context, private val map: GoogleMap?, private val clusterManager: CarClusterManager\u003cCarClusterItem\u003e?,) : DefaultClusterRenderer\u003cCarClusterItem\u003e(context, map, clusterManager) { override fun onBeforeClusterItemRendered( item: CarClusterItem, markerOptions: MarkerOptions, ) { super.onBeforeClusterItemRendered(item, markerOptions) markerOptions.icon( IconHelper.getCarIcon( item = item, context = context ) ) } override fun onClusterItemUpdated(item: CarClusterItem, marker: Marker) { super.onClusterItemUpdated(item, marker) marker.setIcon( IconHelper.getCarIcon( item = item, context = context ) ) } override fun onBeforeClusterRendered( cluster: Cluster\u003cCarClusterItem\u003e, markerOptions: MarkerOptions, ) { super.onBeforeClusterRendered(cluster, markerOptions) markerOptions.icon(IconHelper.getClusterIcon(context = context, cluster = cluster)) } override fun onClusterUpdated(cluster: Cluster\u003cCarClusterItem\u003e, marker: Marker) { super.onClusterUpdated(cluster, marker) marker.setIcon(IconHelper.getClusterIcon(context = context, cluster = cluster)) } override fun shouldRenderAsCluster(cluster: Cluster\u003cCarClusterItem\u003e): Boolean = cluster.size \u003e= 4 \u0026\u0026 clusterManager?.shouldClusterZoom == true}The CarClusterRenderer class is a helper class used to customize how markers appear on the map. It extends the DefaultClusterRenderer class and is responsible for setting the icons of both individual car markers and clusters displayed on the map.Let’s review the key functions:onBeforeClusterItemRendered Called when a cluster item is added to the map for the first time. This is where you configure the marker’s appearance, such as its icon, title, or color.onClusterItemUpdated Invoked when an existing marker on the map needs to be updated. For example, after clicking a marker, if you want to update its icon or reflect a change in its state (e.g., updating an isSelected property), this function handles the visual update dynamically.onBeforeClusterRendered Called when a new cluster is created on the map for the first time. You can customize the cluster’s icon here.onClusterUpdated Triggered when an existing cluster on the map is updated, such as when the number of markers in the cluster changes. This function allows you to refresh the cluster’s appearance accordingly.After implementing these methods, we can proceed with additional cluster-related configurations by creating a helper class named MarkerManager.class MarkerManager { private lateinit var clusterManager: CarClusterManager\u003cCarClusterItem\u003e private var googleMap: GoogleMap? = null fun initClusterManager(context: Context, map: GoogleMap) { clusterManager = CarClusterManager\u003cCarClusterItem\u003e(context, map) googleMap = map clusterManager.apply { setAlgorithm() renderer = CarClusterRenderer(context, map, this) map.setOnCameraIdleListener(this) setOnClusterClickListener { onClickedCluster(it, map) } setOnClusterItemClickListener { item -\u003e onClickedClusterItem(item) } } } private fun setAlgorithm() { val metrics: DisplayMetrics = Resources.getSystem().displayMetrics val widthDp = (metrics.widthPixels / metrics.density).toInt() val heightDp = (metrics.heightPixels / metrics.density).toInt() clusterManager.algorithm = NonHierarchicalViewBasedAlgorithm(widthDp, heightDp) } private fun onClickedCluster(item: Cluster\u003cCarClusterItem\u003e, map: GoogleMap): Boolean { map.animateCamera( CameraUpdateFactory.newLatLngZoom( item.position, map.cameraPosition.zoom + 1 ) ) return true } private fun onClickedClusterItem( item: CarClusterItem ): Boolean { val newItem = if (item.isSelected) { item.copy(isSelected = false) } else { item.copy(isSelected = true) } clusterManager.removeItem(item) clusterManager.addItem(newItem) clusterManager.cluster() googleMap?.animateCamera( CameraUpdateFactory.newLatLngZoom( newItem.position, googleMap?.cameraPosition?.zoom ?: 0f ) ) return true } fun addSampleMarkers() { for (i in 0..2000) { val lat = 40.989010 + (Math.random() - 0.5) / 10 val lng = 29.022949 + (Math.random() - 0.5) / 10 val carClusterItem = CarClusterItem( lat = lat, lng = lng, isSelected = false ) clusterManager.addItem(carClusterItem) clusterManager.cluster() } }}initClusterManager() In this function, we create the ClusterManager and integrate it with the map. The ClusterManager optimizes performance by grouping markers shown on the map. Inside this function, we instantiate our custom CarClusterRenderer (which handles marker appearance) and assign it to the ClusterManager’s renderer property.setAlgorithm() This function sets the algorithm that determines how the ClusterManager groups markers. Here, we use the NonHierarchicalViewBasedAlgorithm, which clusters markers based on the visible region of the screen. This algorithm only processes markers currently visible on the map, significantly improving performance. Being non-hierarchical, it dynamically manages markers to reduce unnecessary calculations and offers a smoother user experience.onClickedCluster() This function handles the zoom-in action on the map when a clustered group is clicked.onClickedClusterItem() This function triggers when an individual marker inside a cluster is clicked.addSampleMarkers() This method creates sample markers and adds them to the map for demonstration purposes.override fun onMapReady(googleMap: GoogleMap) { val istanbul = LatLng(40.989010, 29.022949) val lat = 40.989010 + (Math.random() - 0.5) / 10 val lng = 29.022949 + (Math.random() - 0.5) / 10 googleMap.moveCamera( CameraUpdateFactory.newLatLngZoom( istanbul, 15f ) ) val markerManager = MarkerManager() markerManager.initClusterManager(context = this, map = googleMap) markerManager.addSampleMarkers()}Integrating ClusterManager in MainActivityFinally, once our map is ready in the MainActivity, we create an instance of the MarkerManager class and call the initClusterManager() function. This initializes the clustering functionality and enables efficient marker management on the map.I’ve shared the Cluster example in the GitHub repo. You can visit the repo to review the project in detail. Before running the project, you need to get your own Google Maps API key and add it to the project.📱 Connect with me🔗 LinkedIn💻 GitHub",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*T91_PybuWq7SpPzg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@tolgapirim25?source=post_page---byline--4b8b6fbdbd3e---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Tolga Pirim\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*JftXplR7HEGeMaTUCtPiBw.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"7fe4\"\u003eThis article explains how to add interactive elements to maps in Android applications using the Google Maps SDK. It covers how to create and customize map components such as markers, polylines, polygons, and circles. Additionally, it provides practical tips for using marker clustering to improve the visual organization of map elements.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@tamas_tuzeskatai?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTamas Tuzes-Katai\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e204\"\u003eAdding Required Dependencies and Generating an API Key for Map Usage\u003c/h2\u003e\u003cp id=\"6c6f\"\u003eTo use Google Maps in Android applications, you need to add specific dependencies to your project.\u003c/p\u003e\u003cp id=\"e155\"\u003eThe \u003ccode\u003emaps-ktx\u003c/code\u003e library allows you to leverage Kotlin language features while working with the Maps SDK on Android.\u003c/p\u003e\u003cp id=\"3a7e\"\u003eAdd the following dependencies to your \u003ccode\u003ebuild.gradle (Module: app)\u003c/code\u003e file:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dff9\"\u003eimplementation(\u0026#34;com.google.android.gms:play-services-maps:19.0.0\u0026#34;)\u003cbr/\u003eimplementation(\u0026#34;com.google.maps.android:maps-ktx:5.1.1\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f05c\"\u003eAfter adding the necessary dependencies, you need to create a project in the Google Cloud Platform (GCP) and generate an API key to enable Google Maps services.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"bfba\"\u003e1 - Generating an API Key on Google Cloud\u003c/h2\u003e\u003cp id=\"60ee\"\u003eTo use the Google Maps API, follow these steps:\u003c/p\u003e\u003col\u003e\u003cli id=\"3ffb\"\u003eGo to the \u003ca href=\"https://console.cloud.google.com/welcome\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGoogle Cloud Platform\u003c/a\u003e.\u003c/li\u003e\u003cli id=\"a436\"\u003eCreate a new project.\u003c/li\u003e\u003cli id=\"cc6b\"\u003eFrom the left-hand menu, navigate to \u003cstrong\u003eAPIs \u0026amp; Services\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"a7de\"\u003eClick on the \u003cstrong\u003eCredentials\u003c/strong\u003e tab.\u003c/li\u003e\u003cli id=\"d52c\"\u003eClick \u003cstrong\u003eCreate API Key\u003c/strong\u003e to generate a new API key.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"aff8\"\u003eSecuring Your API Key\u003c/h2\u003e\u003cp id=\"97ee\"\u003eFor security purposes, it is recommended to restrict your API key by specifying:\u003c/p\u003e\u003cul\u003e\u003cli id=\"f065\"\u003eYour application’s \u003cstrong\u003epackage name\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"8d99\"\u003eThe \u003cstrong\u003eSHA-1 certificate fingerprint\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"9166\"\u003eGetting the SHA-1 Certificate Fingerprint\u003c/h2\u003e\u003cp id=\"4bc7\"\u003eTo obtain the \u003cstrong\u003e\u003cem\u003eSHA-1 fingerprint\u003c/em\u003e\u003c/strong\u003e, open your terminal in the root directory of your Android project and run the following command:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"411d\"\u003e./gradlew signingReport\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"575f\"\u003eAfter the command executes, the terminal will display the SHA-1 value. You can use this value in the API key restriction settings on Google Cloud.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f1f2\"\u003e2 - Adding the API Key to Your Application\u003c/h2\u003e\u003cp id=\"ca37\"\u003eTo securely store your API key in your Android project, follow these steps:\u003c/p\u003e\u003col\u003e\u003cli id=\"a2ec\"\u003e\u003cstrong\u003eUse the Secrets Gradle Plugin\u003c/strong\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"10cc\"\u003eYou can use the Secrets Gradle Plugin to manage your API key securely.\u003c/p\u003e\u003cp id=\"0f7d\"\u003eAdd the following dependency to your \u003cstrong\u003eproject-level\u003c/strong\u003e \u003ccode\u003ebuild.gradle\u003c/code\u003e or \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e file:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9ea9\"\u003ebuildscript {\u003cbr/\u003e    dependencies {\u003cbr/\u003e        classpath(\u0026#34;com.google.android.libraries.mapsplatform.secrets-gradle-plugin:secrets-gradle-plugin:2.0.1\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"eb17\"\u003e\u003cstrong\u003e2. Apply the Plugin\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"cdca\"\u003eIn your \u003cstrong\u003emodule-level\u003c/strong\u003e \u003ccode\u003ebuild.gradle\u003c/code\u003e or \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e file, apply the plugin:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"820a\"\u003eplugins {\u003cbr/\u003e    id(\u0026#34;com.google.android.libraries.mapsplatform.secrets-gradle-plugin\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ef3e\"\u003e\u003cstrong\u003e3. Create a \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003esecrets.properties\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e File\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"380d\"\u003eIn the root directory of your project, create a file named \u003ccode\u003esecrets.properties\u003c/code\u003e and add the following line:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ff7b\"\u003eMAPS_API_KEY=YOUR_API_KEY\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2fdc\"\u003e\u003cstrong\u003e4. Add a Default Value\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"c8d8\"\u003eTo avoid build errors when the API key is missing, create a \u003ccode\u003elocal.defaults.properties\u003c/code\u003e file and add:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"63e3\"\u003eMAPS_API_KEY=DEFAULT_API_KEY\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dd28\"\u003e\u003cstrong\u003e5. Add API Key to AndroidManifest.xml\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"de86\"\u003eInsert the following \u003ccode\u003e\u0026lt;meta-data\u0026gt;\u003c/code\u003e tag inside your \u003ccode\u003e\u0026lt;application\u0026gt;\u003c/code\u003e tag:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7078\"\u003e\u0026lt;application\u0026gt;\u003cbr/\u003e    ...\u003cbr/\u003e    \u0026lt;meta-data\u003cbr/\u003e        android:name=\u0026#34;com.google.android.geo.API_KEY\u0026#34;\u003cbr/\u003e        android:value=\u0026#34;${MAPS_API_KEY}\u0026#34; /\u0026gt;\u003cbr/\u003e\u0026lt;/application\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5dfb\"\u003e\u003cstrong\u003e6. Configure the Plugin\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"d211\"\u003eIn your \u003cstrong\u003emodule-level\u003c/strong\u003e \u003ccode\u003ebuild.gradle\u003c/code\u003e file, configure the plugin:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"58a2\"\u003eandroid {\u003cbr/\u003e    secrets {\u003cbr/\u003e        propertiesFileName = \u0026#34;secrets.properties\u0026#34;\u003cbr/\u003e        defaultPropertiesFileName = \u0026#34;local.defaults.properties\u0026#34;\u003cbr/\u003e        ignoreList.add(\u0026#34;keyToIgnore\u0026#34;)\u003cbr/\u003e        ignoreList.add(\u0026#34;sdk.*\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fb11\"\u003eAfter completing these steps, your API key will be securely integrated into your application.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"926b\"\u003e3 - The New Map Renderer\u003c/h2\u003e\u003cp id=\"e386\"\u003eWith version \u003cstrong\u003e18.2.0\u003c/strong\u003e of the Google Maps SDK, a \u003cstrong\u003enew map renderer\u003c/strong\u003e was introduced. This renderer brings several improvements and benefits for developers:\u003c/p\u003e\u003cul\u003e\u003cli id=\"5e6b\"\u003e\u003cstrong\u003eCloud-based Maps Styling\u003c/strong\u003e: Allows dynamic updates to the visual styling of maps through the cloud.\u003c/li\u003e\u003cli id=\"7fa6\"\u003e\u003cstrong\u003eAdvanced Polyline Customization\u003c/strong\u003e: Enables more refined and visually appealing line styles.\u003c/li\u003e\u003cli id=\"6b9b\"\u003e\u003cstrong\u003eReduced Network and Memory Usage\u003c/strong\u003e: Enhances app efficiency by minimizing unnecessary data consumption.\u003c/li\u003e\u003cli id=\"0b19\"\u003e\u003cstrong\u003eImproved Motion Controls\u003c/strong\u003e: Offers smoother animations, panning, and zooming experiences.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"abc8\"\u003e\u003cstrong\u003eBackward Compatibility\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"d198\"\u003eGoogle ensures that devices not supporting the new renderer will continue to use the \u003cstrong\u003elegacy renderer\u003c/strong\u003e. Although you can work with version 18.2.0 or later, developers may opt to use the legacy renderer until \u003cstrong\u003eMarch 2025\u003c/strong\u003e. After this date, the choice will be removed, and Google will automatically apply the legacy renderer on unsupported devices.\u003c/p\u003e\u003ch2 id=\"49ee\"\u003eSelecting a Renderer\u003c/h2\u003e\u003cp id=\"d5c4\"\u003eYou can specify whether to use the \u003cstrong\u003elegacy\u003c/strong\u003e or \u003cstrong\u003elatest\u003c/strong\u003e renderer with the following setup:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6c8f\"\u003eclass MapRendererOptInApplication : Application(), OnMapsSdkInitializedCallback {\u003cbr/\u003e    override fun onCreate() {\u003cbr/\u003e        super.onCreate()\u003cbr/\u003e        // Select the renderer here (LEGACY or LATEST)\u003cbr/\u003e        MapsInitializer.initialize(applicationContext, Renderer.LEGACY, this)\u003cbr/\u003e    }\u003cp\u003e    override fun onMapsSdkInitialized(renderer: MapsInitializer.Renderer) {\u003cbr/\u003e        when (renderer) {\u003cbr/\u003e            Renderer.LATEST -\u0026gt; Log.d(\u0026#34;MapsDemo\u0026#34;, \u0026#34;The latest version of the renderer is used.\u0026#34;)\u003cbr/\u003e            Renderer.LEGACY -\u0026gt; Log.d(\u0026#34;MapsDemo\u0026#34;, \u0026#34;The legacy version of the renderer is used.\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b3a2\"\u003eIn this example, the \u003ccode\u003eMapsInitializer.initialize()\u003c/code\u003e method lets you define which renderer to use, while \u003ccode\u003eonMapsSdkInitialized()\u003c/code\u003e provides feedback on the active renderer at runtime.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"3ab3\"\u003eCore Google Maps Classes\u003c/h2\u003e\u003cp id=\"dc00\"\u003eHere are some fundamental classes used when working with the Google Maps SDK in Android:\u003c/p\u003e\u003cul\u003e\u003cli id=\"c318\"\u003e\u003cstrong\u003eGoogleMap\u003c/strong\u003e: The main entry point for interacting with the map’s data and features. It is only accessible via a \u003ccode\u003eSupportMapFragment\u003c/code\u003e or \u003ccode\u003eMapView\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"27c0\"\u003e\u003cstrong\u003eSupportMapFragment\u003c/strong\u003e: A fragment that manages the lifecycle of a \u003ccode\u003eGoogleMap\u003c/code\u003e instance.\u003c/li\u003e\u003cli id=\"c4c8\"\u003e\u003cstrong\u003eMapView\u003c/strong\u003e: A View-based alternative that also manages the \u003ccode\u003eGoogleMap\u003c/code\u003e lifecycle.\u003c/li\u003e\u003cli id=\"a718\"\u003e\u003cstrong\u003eOnMapReadyCallback\u003c/strong\u003e: An interface that is triggered once the map is ready to be used.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"191c\"\u003eAmong these, \u003ccode\u003eSupportMapFragment\u003c/code\u003e is more modern and widely adopted. We\u0026#39;ll continue using this approach in our implementation.\u003c/p\u003e\u003ch2 id=\"0980\"\u003e\u003cstrong\u003eStep 1: Add the Fragment in XML\u003c/strong\u003e\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"c778\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\u003cbr/\u003e\u0026lt;androidx.constraintlayout.widget.ConstraintLayout \u003cbr/\u003e    xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u003cbr/\u003e    xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u003cbr/\u003e    xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u003cbr/\u003e    android:id=\u0026#34;@+id/main\u0026#34;\u003cbr/\u003e    android:layout_width=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e    android:layout_height=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e    tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt;\u003cp\u003e    \u0026lt;androidx.fragment.app.FragmentContainerView\u003cbr/\u003e        android:id=\u0026#34;@+id/mapView\u0026#34;\u003cbr/\u003e        android:name=\u0026#34;com.google.android.gms.maps.SupportMapFragment\u0026#34;\u003cbr/\u003e        android:layout_width=\u0026#34;0dp\u0026#34;\u003cbr/\u003e        android:layout_height=\u0026#34;0dp\u0026#34;\u003cbr/\u003e        app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34;\u003cbr/\u003e        app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34;\u003cbr/\u003e        app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34;\u003cbr/\u003e        app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; /\u0026gt;\u003cbr/\u003e\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1094\"\u003eStep 2: Implement \u003ccode\u003eOnMapReadyCallback\u003c/code\u003e in Your Activity\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"1a8c\"\u003eclass MainActivity : AppCompatActivity(), OnMapReadyCallback {\u003cbr/\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContentView(R.layout.activity_main)\u003cp\u003e        val supportMapFragment = supportFragmentManager\u003cbr/\u003e            .findFragmentById(R.id.mapView) as SupportMapFragment\u003c/p\u003e\u003cp\u003e        supportMapFragment.getMapAsync(this)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun onMapReady(googleMap: GoogleMap) {\u003cbr/\u003e        googleMap.moveCamera(\u003cbr/\u003e            CameraUpdateFactory.newLatLngZoom(\u003cbr/\u003e                LatLng(41.0082, 28.9784), // Istanbul, Turkey\u003cbr/\u003e                15f\u003cbr/\u003e            )\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ccb5\"\u003eIn this setup:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7cbf\"\u003eWe implement \u003ccode\u003eOnMapReadyCallback\u003c/code\u003e to detect when the map is fully loaded.\u003c/li\u003e\u003cli id=\"2e6b\"\u003e\u003ccode\u003egetMapAsync(this)\u003c/code\u003e initializes the map asynchronously.\u003c/li\u003e\u003cli id=\"f08e\"\u003eOnce ready, the map centers on a sample location (Istanbul, Turkey) using \u003ccode\u003eCameraUpdateFactory.newLatLngZoom()\u003c/code\u003e with a zoom level of 15x.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"bf66\"\u003e4 - Adding a Marker\u003c/h2\u003e\u003cp id=\"3e68\"\u003eTo highlight a specific location on the map, you can use the \u003ccode\u003eMarker\u003c/code\u003e object. Markers are commonly used to provide users with a visual reference and additional contextual information.\u003c/p\u003e\u003cp id=\"f17c\"\u003eHere’s how to add a basic marker:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"596c\"\u003egoogleMap.addMarker(\u003cbr/\u003e    MarkerOptions()\u003cbr/\u003e        .position(istanbul)\u003cbr/\u003e        .title(\u0026#34;Istanbul\u0026#34;)\u003cbr/\u003e        .snippet(\u0026#34;Tarihi Yarımada\u0026#34;)\u003cbr/\u003e        .icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_BLUE))\u003cbr/\u003e)\u003cp\u003egoogleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(istanbul, 12f))\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"ccd9\"\u003eUsing a Custom Icon\u003c/h2\u003e\u003cp id=\"427b\"\u003eThe Google Maps SDK supports icons of type \u003ccode\u003eBitmapDescriptor\u003c/code\u003e. If you want to use your own image (like a vector drawable), you\u0026#39;ll first need to convert it to a \u003ccode\u003eBitmap\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"96d0\"\u003eConvert Vector Drawable to Bitmap\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"028d\"\u003efun vectorToBitmap(\u003cbr/\u003e    context: Context,\u003cbr/\u003e    @DrawableRes vectorResId: Int\u003cbr/\u003e): Bitmap {\u003cbr/\u003e    val drawable = ContextCompat.getDrawable(context, vectorResId)\u003cbr/\u003e    val bitmap = Bitmap.createBitmap(\u003cbr/\u003e        drawable?.intrinsicWidth ?: 0,\u003cbr/\u003e        drawable?.intrinsicHeight ?: 0,\u003cbr/\u003e        Bitmap.Config.ARGB_8888\u003cbr/\u003e    )\u003cbr/\u003e    val canvas = Canvas(bitmap)\u003cbr/\u003e    drawable?.setBounds(0, 0, canvas.width, canvas.height)\u003cbr/\u003e    drawable?.draw(canvas)\u003cbr/\u003e    return bitmap\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"c516\"\u003eAdd a Marker with a Custom Bitmap Icon\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"53b3\"\u003egoogleMap.addMarker(\u003cbr/\u003e    MarkerOptions()\u003cbr/\u003e        .position(istanbul)\u003cbr/\u003e        .title(\u0026#34;İstanbul\u0026#34;)\u003cbr/\u003e        .snippet(\u0026#34;Tarihi Yarımada\u0026#34;)\u003cbr/\u003e        .icon(\u003cbr/\u003e            BitmapDescriptorFactory.fromBitmap(\u003cbr/\u003e                vectorToBitmap(this, R.drawable.ic_launcher_foreground)\u003cbr/\u003e            )\u003cbr/\u003e        )\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"86e1\"\u003eThis allows you to personalize marker icons with your own vector images.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"4679\"\u003eRemoving a Marker\u003c/h2\u003e\u003cp id=\"c332\"\u003eIn Google Maps SDK, to remove a marker, you need to keep a reference to the \u003ccode\u003eMarker\u003c/code\u003e object. The \u003ccode\u003egoogleMap.addMarker()\u003c/code\u003e method returns this reference, which you can then use to remove the marker from the map:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8eda\"\u003eval marker: Marker? = googleMap.addMarker(\u003cbr/\u003e    MarkerOptions()\u003cbr/\u003e        .position(LatLng(41.0082, 28.9784))\u003cbr/\u003e        .title(\u0026#34;Istanbul\u0026#34;)\u003cbr/\u003e        .snippet(\u0026#34;Tarihi Yarımada\u0026#34;)\u003cbr/\u003e)\u003cp\u003e// Remove the marker from the map\u003cbr/\u003emarker?.remove()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"28ca\"\u003e5 - Google Maps Camera Movements\u003c/h2\u003e\u003cp id=\"d534\"\u003eThe Google Maps SDK provides several ways to control the camera’s position and orientation on the map, enhancing user experience by focusing on specific areas.\u003c/p\u003e\u003ch2 id=\"e819\"\u003eCore Classes for Camera Control:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"0de4\"\u003e\u003ccode\u003eCameraUpdateFactory\u003c/code\u003e: Creates camera update objects.\u003c/li\u003e\u003cli id=\"1db6\"\u003e\u003ccode\u003eGoogleMap.moveCamera()\u003c/code\u003e: Instantly moves the camera.\u003c/li\u003e\u003cli id=\"2705\"\u003e\u003ccode\u003eGoogleMap.animateCamera()\u003c/code\u003e: Moves the camera with animation.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"2c08\"\u003emoveCamera()\u003c/h2\u003e\u003cp id=\"21bc\"\u003eQuickly moves the camera to a specific location and zoom level:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7971\"\u003eval istanbul = LatLng(41.0082, 28.9784)\u003cbr/\u003egoogleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(istanbul, 12f))\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bd38\"\u003eZoom levels meaning:\u003c/p\u003e\u003cul\u003e\u003cli id=\"98ac\"\u003e1–5: Global view\u003c/li\u003e\u003cli id=\"2879\"\u003e10–15: City view\u003c/li\u003e\u003cli id=\"167d\"\u003e16+: Street-level detail\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"60f2\"\u003eanimateCamera()\u003c/h2\u003e\u003cp id=\"68c0\"\u003eSmoothly animates the camera movement:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"20e0\"\u003eval ankara = LatLng(39.9334, 32.8597)\u003cbr/\u003egoogleMap.animateCamera(CameraUpdateFactory.newLatLngZoom(ankara, 14f))\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"5080\"\u003eRotate and Tilt the Camera\u003c/h2\u003e\u003cp id=\"9b59\"\u003eYou can rotate (bearing) and tilt the camera for better perspectives:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7380\"\u003eval cameraPosition = CameraPosition.Builder()\u003cbr/\u003e    .target(LatLng(41.0082, 28.9784))\u003cbr/\u003e    .zoom(16f)\u003cbr/\u003e    .bearing(90f) // East (0 = North, 90 = East)\u003cbr/\u003e    .tilt(45f)    // Tilt angle (0-90 degrees)\u003cbr/\u003e    .build()\u003cp\u003egoogleMap.moveCamera(CameraUpdateFactory.newCameraPosition(cameraPosition))\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"366c\"\u003eCamera Bounds for Multiple Locations\u003c/h2\u003e\u003cp id=\"0735\"\u003eTo frame multiple locations within the viewport:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"35d0\"\u003eval bounds = LatLngBounds.builder()\u003cbr/\u003e    .include(LatLng(41.0082, 28.9784))  // Istanbul\u003cbr/\u003e    .include(LatLng(39.9334, 32.8597))  // Ankara\u003cbr/\u003e    .build()\u003cp\u003egoogleMap.animateCamera(CameraUpdateFactory.newLatLngBounds(bounds, 100))\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9950\"\u003eThis adjusts the camera to show both points with padding.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"5451\"\u003e6 - Drawing a Polyline on Google Maps\u003c/h2\u003e\u003cp id=\"fcdd\"\u003eGoogle Maps SDK allows you to create \u003cstrong\u003ePolyline\u003c/strong\u003e objects that connect two or more points on the map. Polylines are commonly used to visualize routes, paths, or boundaries.\u003c/p\u003e\u003cp id=\"ad4d\"\u003eHere is a simple example of how to draw a polyline:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0cf5\"\u003eval polylineOptions = PolylineOptions()\u003cbr/\u003e    .add(LatLng(40.989010, 29.022949))  // First point\u003cbr/\u003e    .add(LatLng(40.986484, 29.023937))  // Second point\u003cbr/\u003e    .color(ContextCompat.getColor(this, R.color.blue))  // Line color\u003cbr/\u003e    .width(10f)  // Line width in pixels\u003cp\u003egoogleMap.addPolyline(polylineOptions)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"e471\"\u003eUse \u003ccode\u003e.add()\u003c/code\u003e multiple times to include each point in the polyline.\u003c/li\u003e\u003cli id=\"9e13\"\u003eCustomize the polyline’s \u003cstrong\u003ecolor\u003c/strong\u003e and \u003cstrong\u003ewidth\u003c/strong\u003e for better visibility.\u003c/li\u003e\u003cli id=\"3155\"\u003eThe polyline will be rendered as a connected line between the given points on the map.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c368\"\u003eYou can make polylines more visually appealing by customizing their patterns using the \u003ccode\u003epattern()\u003c/code\u003e method. Google Maps SDK supports these pattern elements:\u003c/p\u003e\u003cul\u003e\u003cli id=\"8819\"\u003e\u003ccode\u003eDot()\u003c/code\u003e: A dotted pattern.\u003c/li\u003e\u003cli id=\"f69e\"\u003e\u003ccode\u003eDash(length)\u003c/code\u003e: A solid dash with the specified length in pixels.\u003c/li\u003e\u003cli id=\"02d4\"\u003e\u003ccode\u003eGap(length)\u003c/code\u003e: A blank gap with the specified length in pixels.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f2fe\"\u003eHere’s an example of a polyline with a dashed pattern:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c01f\"\u003eval polylineOptions = PolylineOptions()\u003cbr/\u003e    .add(LatLng(40.989010, 29.022949))\u003cbr/\u003e    .add(LatLng(40.986484, 29.023937))\u003cbr/\u003e    .color(ContextCompat.getColor(this, R.color.blue))\u003cbr/\u003e    .pattern(listOf(Dash(20f), Gap(20f), Dash(20f)))  // Dash-Gap-Dash pattern\u003cbr/\u003e    .width(10f)\u003cp\u003egoogleMap.addPolyline(polylineOptions)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f37c\"\u003eThis creates a polyline with alternating dashes and gaps, enhancing the visual style of the line on the map.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"b528\"\u003eRemove Polyline\u003c/h2\u003e\u003cp id=\"87f7\"\u003eTo remove a polyline from the map, you need to keep a reference to the \u003ccode\u003ePolyline\u003c/code\u003e object returned by \u003ccode\u003egoogleMap.addPolyline()\u003c/code\u003e. Then, you can call the \u003ccode\u003eremove()\u003c/code\u003e method on that reference:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b4ec\"\u003eval polyline: Polyline = googleMap.addPolyline(\u003cbr/\u003e    PolylineOptions()\u003cbr/\u003e        .add(LatLng(40.989010, 29.022949))\u003cbr/\u003e        .add(LatLng(40.986484, 29.023937))\u003cbr/\u003e        .color(ContextCompat.getColor(this, R.color.blue))\u003cbr/\u003e        .width(10f)\u003cbr/\u003e)\u003cp\u003e// Remove the polyline from the map\u003cbr/\u003epolyline.remove()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f987\"\u003eIf you have multiple polylines or markers, managing them with unique IDs stored in a \u003ccode\u003eHashMap\u0026lt;String, Polyline\u0026gt;\u003c/code\u003e or \u003ccode\u003eHashMap\u0026lt;String, Marker\u0026gt;\u003c/code\u003e is useful. This way, you can find, update, or remove specific items by their ID easily.\u003c/p\u003e\u003ch2 id=\"4fd0\"\u003e7- Adding a Polygon\u003c/h2\u003e\u003cp id=\"c978\"\u003ePolygons are similar to polylines but differ in that they form a closed shape and can have a filled interior. They are typically used to visually represent boundaries such as city limits, districts, or service areas on the map.\u003c/p\u003e\u003cp id=\"fd8a\"\u003eFor example, if your app serves only specific neighborhoods or cities, you can draw these boundaries using polygons to clearly communicate the service area to users. Conversely, polygons can also highlight areas where service is not available. The fill color makes these regions visually distinct, improving user experience by preventing incorrect location selections.\u003c/p\u003e\u003cp id=\"683c\"\u003eExample of drawing a polygon with stroke and fill colors:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"49b6\"\u003eval polygonOptions = PolygonOptions()\u003cbr/\u003e    .add(LatLng(40.989010, 29.022949))\u003cbr/\u003e    .add(LatLng(40.986484, 29.023937))\u003cbr/\u003e    .add(LatLng(40.988638, 29.025182))\u003cbr/\u003e    .strokeColor(ContextCompat.getColor(this, R.color.red))  // Border color\u003cbr/\u003e    .strokeWidth(5f) \u003cbr/\u003e    .fillColor(ContextCompat.getColor(this, R.color.light_red))  // Interior fill color\u003cp\u003eval polygon: Polygon = googleMap.addPolygon(polygonOptions)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"20c8\"\u003eThis will draw a filled polygon on the map, clearly marking areas such as no-service zones, allowing users to distinguish between serviceable and non-serviceable regions easily.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"5fa3\"\u003ePolygons can be customized with border patterns, similar to polylines. Border lines can be made aesthetic by using dotted, striped or spaced patterns. Deletion is also done by referencing the polygon object, as in polylines. In order to manage multiple polygons in the application, they can be stored in a collection by assigning an ID to each one and removed when necessary.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"5bfa\"\u003e8 - Adding a Circle\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"9808\"\u003eval circleOptions = CircleOptions()\u003cbr/\u003e    .center(istanbul)\u003cbr/\u003e    .radius(200.0)\u003cbr/\u003e    .strokeColor(ContextCompat.getColor(this, R.color.blue))\u003cbr/\u003e    .strokeWidth(5f)\u003cbr/\u003e    .fillColor(ContextCompat.getColor(this, R.color.light_blue))\u003cbr/\u003e    .strokePattern(listOf(Dash(30f), Gap(20f)))\u003cp\u003egoogleMap.addCircle(circleOptions)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"9fd7\"\u003eUsing Clustering in Google Maps SDK\u003c/h2\u003e\u003cp id=\"9e10\"\u003eWhen adding many markers to a Google Map, visual clutter and overlapping can reduce clarity. To solve this, the \u003cstrong\u003eCluster\u003c/strong\u003e feature groups nearby markers into a single icon. As users zoom in, the cluster breaks apart and individual markers become visible.\u003c/p\u003e\u003cp id=\"93a4\"\u003e\u003cstrong\u003eBenefits of Clustering:\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"1d37\"\u003e\u003cstrong\u003eImproved UX\u003c/strong\u003e — Prevents overcrowding by grouping markers.\u003c/li\u003e\u003cli id=\"9975\"\u003e\u003cstrong\u003ePerformance\u003c/strong\u003e — Reduces rendering load when many markers are displayed.\u003c/li\u003e\u003cli id=\"a706\"\u003e\u003cstrong\u003eScalability\u003c/strong\u003e — Essential for apps showing dynamic or large datasets.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"a3a8\"\u003eClustering is especially useful in apps like delivery tracking, real estate, or social networks, where many pins can appear in close proximity.\u003c/p\u003e\u003cp id=\"1ad2\"\u003eImplementation typically uses the \u003ca href=\"https://github.com/googlemaps/android-maps-utils\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroid Maps Utils library\u003c/a\u003e, which provides a \u003ccode\u003eClusterManager\u003c/code\u003e to manage and render marker clusters easily.\u003c/p\u003e\u003ch2 id=\"822e\"\u003eSample Scenario: Vehicle Sharing App with Marker Selection and Clustering\u003c/h2\u003e\u003cp id=\"3b5b\"\u003eIn a vehicle-sharing service, we aim to display the locations of available vehicles on the map using individual \u003cstrong\u003emarkers\u003c/strong\u003e, each with a unique \u003cstrong\u003evehicle icon\u003c/strong\u003e. To manage a clean interface:\u003c/p\u003e\u003col\u003e\u003cli id=\"02b3\"\u003e\u003cstrong\u003eMarker Display:\u003c/strong\u003e\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli id=\"e18b\"\u003eEach vehicle location is represented with a custom marker icon.\u003c/li\u003e\u003cli id=\"e200\"\u003eWhen a user taps on a vehicle, the app updates the \u003cstrong\u003eselected marker\u003c/strong\u003e with a distinct icon or color to indicate selection.\u003c/li\u003e\u003c/ul\u003e\u003col\u003e\u003cli id=\"977e\"\u003e\u003cstrong\u003eClustering Implementation:\u003c/strong\u003e\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli id=\"49b8\"\u003eWhen too many vehicles are shown in one area, \u003cstrong\u003eclustering\u003c/strong\u003e groups markers visually.\u003c/li\u003e\u003cli id=\"2c41\"\u003eThe cluster icon displays the number of grouped vehicles, e.g., \u003ccode\u003e+10\u003c/code\u003e, \u003ccode\u003e+50\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003col\u003e\u003cli id=\"8096\"\u003e\u003cstrong\u003eTechnical Approach:\u003c/strong\u003e\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli id=\"d456\"\u003eUse \u003ccode\u003eClusterManager\u003c/code\u003e from the \u003ca href=\"https://github.com/googlemaps/android-maps-utils\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGoogle Maps Utils library\u003c/a\u003e.\u003c/li\u003e\u003cli id=\"7c4f\"\u003eCustomize \u003ccode\u003eClusterItem\u003c/code\u003e to represent each vehicle.\u003c/li\u003e\u003cli id=\"8223\"\u003eListen for marker clicks to handle selection and update the marker icon accordingly.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d6f7\"\u003eThis approach provides a user-friendly and performant map interface for real-time vehicle discovery.\u003c/p\u003e\u003ch2 id=\"e9a1\"\u003eUsing Clustering\u003c/h2\u003e\u003cp id=\"c723\"\u003eTo enable clustering on Google Maps, you need to add the following dependency to your \u003ccode\u003ebuild.gradle (Module: app)\u003c/code\u003e file:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"34ef\"\u003eimplementation(\u0026#34;com.google.maps.android:android-maps-utils:3.9.0\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e49c\"\u003eAfter adding the dependency, you need to create a data class that represents each individual item to be displayed on the map and included in the cluster. This class must implement the \u003ccode\u003eClusterItem\u003c/code\u003e interface.\u003c/p\u003e\u003cp id=\"e133\"\u003eThis approach allows the clustering utility to manage and group nearby items automatically, improving performance and map readability, especially when displaying a large number of markers.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d8f3\"\u003edata class CarClusterItem(\u003cbr/\u003e    val lat: Double,\u003cbr/\u003e    val lng: Double,\u003cbr/\u003e    val isSelected: Boolean,\u003cbr/\u003e    val clusterId: String = UUID.randomUUID().toString()\u003cbr/\u003e) : ClusterItem {\u003cp\u003e    override fun getPosition(): LatLng {\u003cbr/\u003e        return LatLng(lat, lng)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun getTitle(): String? {\u003cbr/\u003e        return null\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun getSnippet(): String? {\u003cbr/\u003e        return null\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun getZIndex(): Float? {\u003cbr/\u003e        return null\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"79db\"\u003eCluster Manager\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"328c\"\u003eclass CarClusterManager\u0026lt;T : ClusterItem\u0026gt;(\u003cbr/\u003e    private val context: Context,\u003cbr/\u003e    private val map: GoogleMap\u003cbr/\u003e) : ClusterManager\u0026lt;T\u0026gt;(context, map) {\u003cp\u003e    companion object {\u003cbr/\u003e        private const val CLUSTER_MAX_ZOOM_LEVEL = 14\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private var _shouldClusterZoom: Boolean = true\u003cbr/\u003e    val shouldClusterZoom get() = _shouldClusterZoom\u003c/p\u003e\u003cp\u003e    override fun onCameraIdle() {\u003cbr/\u003e        super.onCameraIdle()\u003cbr/\u003e        _shouldClusterZoom = map.cameraPosition.zoom \u0026lt; CLUSTER_MAX_ZOOM_LEVEL\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5906\"\u003eThe \u003ccode\u003eCarClusterManager\u003c/code\u003e class extends the \u003ccode\u003eClusterManager\u0026lt;T\u0026gt;\u003c/code\u003e class and is used to manage clustering behavior on the map. This custom class is responsible for configuring how and when markers on the map should be grouped into clusters.\u003c/p\u003e\u003cp id=\"0319\"\u003eA constant named \u003ccode\u003eCLUSTER_MAX_ZOOM_LEVEL\u003c/code\u003e defines the maximum zoom level at which clustering will be active. In this example, it is set to \u003ccode\u003e14\u003c/code\u003e.\u003c/p\u003e\u003cul\u003e\u003cli id=\"9970\"\u003eIf the zoom level is \u003cstrong\u003eless than 14\u003c/strong\u003e, the \u003ccode\u003e_shouldClusterZoom\u003c/code\u003e variable is set to \u003ccode\u003etrue\u003c/code\u003e, enabling clustering behavior.\u003c/li\u003e\u003cli id=\"fa88\"\u003eIf the zoom level is \u003cstrong\u003e14 or greater\u003c/strong\u003e, the \u003ccode\u003e_shouldClusterZoom\u003c/code\u003e variable is set to \u003ccode\u003efalse\u003c/code\u003e, disabling clustering and allowing markers to be displayed individually.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6b12\"\u003eThis logic helps improve map readability by dynamically switching between clustered and individual marker views based on the user’s zoom level.\u003c/p\u003e\u003ch2 id=\"2149\"\u003eUtility Functions for Cluster and Car Icons\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"36a7\"\u003eobject IconHelper {\u003cp\u003e    fun getClusterIcon(\u003cbr/\u003e        context: Context,\u003cbr/\u003e        cluster: Cluster\u0026lt;CarClusterItem\u0026gt;\u003cbr/\u003e    ): BitmapDescriptor {\u003cbr/\u003e        val bucketStr = getBucketString(cluster.size)\u003cbr/\u003e        val bmpClusterSize = vectorToBitmap(context, R.drawable.ic_cluster)\u003cbr/\u003e        val bitmap = bmpClusterSize.drawClusterCount(context, bucketStr, R.color.white)\u003cbr/\u003e        return BitmapDescriptorFactory.fromBitmap(bitmap)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun getCarIcon(\u003cbr/\u003e        item: CarClusterItem,\u003cbr/\u003e        context: Context\u003cbr/\u003e    ): BitmapDescriptor? {\u003cbr/\u003e        val bitmap = if (item.isSelected) {\u003cbr/\u003e            R.drawable.ic_selected\u003cbr/\u003e        } else {\u003cbr/\u003e            R.drawable.ic_unselected\u003cbr/\u003e        }\u003cbr/\u003e        return vectorToBitmapDescriptor(context, bitmap)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun getBucketString(size: Int): String {\u003cbr/\u003e        return when {\u003cbr/\u003e            size \u0026gt; 999 -\u0026gt; \u0026#34;1000+\u0026#34;\u003cbr/\u003e            size \u0026gt; 499 -\u0026gt; \u0026#34;500+\u0026#34;\u003cbr/\u003e            size \u0026gt; 99 -\u0026gt; \u0026#34;100+\u0026#34;\u003cbr/\u003e            size \u0026gt; 49 -\u0026gt; \u0026#34;50+\u0026#34;\u003cbr/\u003e            size \u0026gt; 19 -\u0026gt; \u0026#34;20+\u0026#34;\u003cbr/\u003e            size \u0026gt; 9 -\u0026gt; \u0026#34;10+\u0026#34;\u003cbr/\u003e            else -\u0026gt; size.toString()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun Bitmap.drawClusterCount(context: Context, text: String, color: Int): Bitmap {\u003cbr/\u003e        val bitmap = copy(config!!, true)\u003cbr/\u003e        val canvas = Canvas(bitmap)\u003cbr/\u003e        val paint = createPaint(context, color)\u003cbr/\u003e        val bounds = Rect()\u003cbr/\u003e        paint.getTextBounds(text, 0, text.length, bounds)\u003cbr/\u003e        val width = bitmap.width / 2\u003cbr/\u003e        val height = bitmap.height / 2.7\u003cbr/\u003e        canvas.drawText(text, width.toFloat(), height.toFloat(), paint)\u003cbr/\u003e        return bitmap\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun createPaint(context: Context, color: Int): Paint {\u003cbr/\u003e        return Paint().apply {\u003cbr/\u003e            flags = Paint.ANTI_ALIAS_FLAG\u003cbr/\u003e            textAlign = Paint.Align.CENTER\u003cbr/\u003e            this.color = ContextCompat.getColor(context, color)\u003cbr/\u003e            this.textSize = context.resources.getDimensionPixelSize(R.dimen.text_size_9sp).toFloat()\u003cbr/\u003e            typeface = Typeface.create(Typeface.SANS_SERIF, Typeface.BOLD)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun vectorToBitmap(\u003cbr/\u003e        context: Context,\u003cbr/\u003e        @DrawableRes vectorResId: Int,\u003cbr/\u003e    ): Bitmap {\u003cbr/\u003e        val drawable = ContextCompat.getDrawable(context, vectorResId)\u003cbr/\u003e        val bitmap = Bitmap.createBitmap(\u003cbr/\u003e            drawable?.intrinsicWidth ?: 0,\u003cbr/\u003e            drawable?.intrinsicHeight ?: 0,\u003cbr/\u003e            Bitmap.Config.ARGB_8888\u003cbr/\u003e        )\u003cbr/\u003e        val canvas = Canvas(bitmap)\u003cbr/\u003e        drawable?.setBounds(0, 0, canvas.width, canvas.height)\u003cbr/\u003e        drawable?.draw(canvas)\u003cbr/\u003e        return bitmap\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun vectorToBitmapDescriptor(\u003cbr/\u003e        context: Context,\u003cbr/\u003e        @DrawableRes vectorResId: Int\u003cbr/\u003e    ): BitmapDescriptor? {\u003cbr/\u003e        val bitmap = vectorToBitmap(context, vectorResId)\u003cbr/\u003e        return BitmapDescriptorFactory.fromBitmap(bitmap)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5719\"\u003eBefore moving on to implementing the \u003ccode\u003eClusterRenderer\u003c/code\u003e, let\u0026#39;s look at a few utility functions that will help us define custom icons for cars and clusters.\u003c/p\u003e\u003cul\u003e\u003cli id=\"88aa\"\u003e\u003ccode\u003e\u003cstrong\u003egetClusterIcon()\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e This function generates an appropriate icon based on the size of the cluster. It visually represents the number of items contained within the cluster to the user.\u003c/li\u003e\u003cli id=\"076d\"\u003e\u003ccode\u003e\u003cstrong\u003egetCarIcon()\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e This function determines which car icon should be displayed on the map depending on whether the item is in a \u003cstrong\u003eselected\u003c/strong\u003e or \u003cstrong\u003eunselected\u003c/strong\u003e state.\u003c/li\u003e\u003cli id=\"9084\"\u003e\u003ccode\u003e\u003cstrong\u003evectorToBitmap()\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e Converts a vector-based drawable resource (\u003ccode\u003e@DrawableRes\u003c/code\u003e) into a \u003ccode\u003eBitmap\u003c/code\u003e object, which is required for custom marker icons on Google Maps.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"df94\"\u003eThese functions provide the visual foundation for customizing how items and clusters are displayed on the map.\u003c/p\u003e\u003ch2 id=\"af1a\"\u003eCluster Renderer\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"236b\"\u003eclass CarClusterRenderer(\u003cbr/\u003e    private val context: Context,\u003cbr/\u003e    private val map: GoogleMap?,\u003cbr/\u003e    private val clusterManager: CarClusterManager\u0026lt;CarClusterItem\u0026gt;?,\u003cbr/\u003e) : DefaultClusterRenderer\u0026lt;CarClusterItem\u0026gt;(context, map, clusterManager) {\u003cp\u003e    override fun onBeforeClusterItemRendered(\u003cbr/\u003e        item: CarClusterItem,\u003cbr/\u003e        markerOptions: MarkerOptions,\u003cbr/\u003e    ) {\u003cbr/\u003e        super.onBeforeClusterItemRendered(item, markerOptions)\u003cbr/\u003e        markerOptions.icon(\u003cbr/\u003e            IconHelper.getCarIcon(\u003cbr/\u003e                item = item,\u003cbr/\u003e                context = context\u003cbr/\u003e            )\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun onClusterItemUpdated(item: CarClusterItem, marker: Marker) {\u003cbr/\u003e        super.onClusterItemUpdated(item, marker)\u003cbr/\u003e        marker.setIcon(\u003cbr/\u003e            IconHelper.getCarIcon(\u003cbr/\u003e                item = item,\u003cbr/\u003e                context = context\u003cbr/\u003e            )\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun onBeforeClusterRendered(\u003cbr/\u003e        cluster: Cluster\u0026lt;CarClusterItem\u0026gt;,\u003cbr/\u003e        markerOptions: MarkerOptions,\u003cbr/\u003e    ) {\u003cbr/\u003e        super.onBeforeClusterRendered(cluster, markerOptions)\u003cbr/\u003e        markerOptions.icon(IconHelper.getClusterIcon(context = context, cluster = cluster))\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun onClusterUpdated(cluster: Cluster\u0026lt;CarClusterItem\u0026gt;, marker: Marker) {\u003cbr/\u003e        super.onClusterUpdated(cluster, marker)\u003cbr/\u003e        marker.setIcon(IconHelper.getClusterIcon(context = context, cluster = cluster))\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun shouldRenderAsCluster(cluster: Cluster\u0026lt;CarClusterItem\u0026gt;): Boolean =\u003cbr/\u003e        cluster.size \u0026gt;= 4 \u0026amp;\u0026amp; clusterManager?.shouldClusterZoom == true\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"64fb\"\u003eThe \u003ccode\u003eCarClusterRenderer\u003c/code\u003e class is a helper class used to customize how markers appear on the map. It extends the \u003ccode\u003eDefaultClusterRenderer\u003c/code\u003e class and is responsible for setting the icons of both individual car markers and clusters displayed on the map.\u003c/p\u003e\u003cp id=\"bef8\"\u003eLet’s review the key functions:\u003c/p\u003e\u003cul\u003e\u003cli id=\"59f8\"\u003e\u003ccode\u003e\u003cstrong\u003eonBeforeClusterItemRendered\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e Called when a cluster item is added to the map for the first time. This is where you configure the marker’s appearance, such as its icon, title, or color.\u003c/li\u003e\u003cli id=\"bf73\"\u003e\u003ccode\u003e\u003cstrong\u003eonClusterItemUpdated\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e Invoked when an existing marker on the map needs to be updated. For example, after clicking a marker, if you want to update its icon or reflect a change in its state (e.g., updating an \u003ccode\u003eisSelected\u003c/code\u003e property), this function handles the visual update dynamically.\u003c/li\u003e\u003cli id=\"447d\"\u003e\u003ccode\u003e\u003cstrong\u003eonBeforeClusterRendered\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e Called when a new cluster is created on the map for the first time. You can customize the cluster’s icon here.\u003c/li\u003e\u003cli id=\"efbb\"\u003e\u003ccode\u003e\u003cstrong\u003eonClusterUpdated\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e Triggered when an existing cluster on the map is updated, such as when the number of markers in the cluster changes. This function allows you to refresh the cluster’s appearance accordingly.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"cbaf\"\u003eAfter implementing these methods, we can proceed with additional cluster-related configurations by creating a helper class named \u003ccode\u003eMarkerManager\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5a7c\"\u003eclass MarkerManager {\u003cp\u003e    private lateinit var clusterManager: CarClusterManager\u0026lt;CarClusterItem\u0026gt;\u003cbr/\u003e    private var googleMap: GoogleMap? = null\u003c/p\u003e\u003cp\u003e    fun initClusterManager(context: Context, map: GoogleMap) {\u003cbr/\u003e        clusterManager = CarClusterManager\u0026lt;CarClusterItem\u0026gt;(context, map)\u003cbr/\u003e        googleMap = map\u003c/p\u003e\u003cp\u003e        clusterManager.apply {\u003cbr/\u003e            setAlgorithm()\u003cbr/\u003e            renderer = CarClusterRenderer(context, map, this)\u003cbr/\u003e            map.setOnCameraIdleListener(this)\u003cbr/\u003e            setOnClusterClickListener { onClickedCluster(it, map) }\u003cbr/\u003e            setOnClusterItemClickListener { item -\u0026gt;\u003cbr/\u003e                onClickedClusterItem(item)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun setAlgorithm() {\u003cbr/\u003e        val metrics: DisplayMetrics = Resources.getSystem().displayMetrics\u003cbr/\u003e        val widthDp = (metrics.widthPixels / metrics.density).toInt()\u003cbr/\u003e        val heightDp = (metrics.heightPixels / metrics.density).toInt()\u003cbr/\u003e        clusterManager.algorithm = NonHierarchicalViewBasedAlgorithm(widthDp, heightDp)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun onClickedCluster(item: Cluster\u0026lt;CarClusterItem\u0026gt;, map: GoogleMap): Boolean {\u003cbr/\u003e        map.animateCamera(\u003cbr/\u003e            CameraUpdateFactory.newLatLngZoom(\u003cbr/\u003e                item.position,\u003cbr/\u003e                map.cameraPosition.zoom + 1\u003cbr/\u003e            )\u003cbr/\u003e        )\u003cbr/\u003e        return true\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun onClickedClusterItem(\u003cbr/\u003e        item: CarClusterItem\u003cbr/\u003e    ): Boolean {\u003cbr/\u003e        val newItem = if (item.isSelected) {\u003cbr/\u003e            item.copy(isSelected = false)\u003cbr/\u003e        } else {\u003cbr/\u003e            item.copy(isSelected = true)\u003cbr/\u003e        }\u003cbr/\u003e        clusterManager.removeItem(item)\u003cbr/\u003e        clusterManager.addItem(newItem)\u003cbr/\u003e        clusterManager.cluster()\u003cbr/\u003e        googleMap?.animateCamera(\u003cbr/\u003e            CameraUpdateFactory.newLatLngZoom(\u003cbr/\u003e                newItem.position,\u003cbr/\u003e                googleMap?.cameraPosition?.zoom ?: 0f\u003cbr/\u003e            )\u003cbr/\u003e        )\u003cbr/\u003e        return true\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun addSampleMarkers() {\u003cbr/\u003e        for (i in 0..2000) {\u003cbr/\u003e            val lat = 40.989010 + (Math.random() - 0.5) / 10\u003cbr/\u003e            val lng = 29.022949 + (Math.random() - 0.5) / 10\u003cbr/\u003e            val carClusterItem = CarClusterItem(\u003cbr/\u003e                lat = lat,\u003cbr/\u003e                lng = lng,\u003cbr/\u003e                isSelected = false\u003cbr/\u003e            )\u003cbr/\u003e            clusterManager.addItem(carClusterItem)\u003cbr/\u003e            clusterManager.cluster()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"a636\"\u003e\u003ccode\u003e\u003cstrong\u003einitClusterManager()\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e In this function, we create the \u003ccode\u003eClusterManager\u003c/code\u003e and integrate it with the map. The \u003ccode\u003eClusterManager\u003c/code\u003e optimizes performance by grouping markers shown on the map. Inside this function, we instantiate our custom \u003ccode\u003eCarClusterRenderer\u003c/code\u003e (which handles marker appearance) and assign it to the \u003ccode\u003eClusterManager\u003c/code\u003e’s renderer property.\u003c/li\u003e\u003cli id=\"785f\"\u003e\u003ccode\u003e\u003cstrong\u003esetAlgorithm()\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e This function sets the algorithm that determines how the \u003ccode\u003eClusterManager\u003c/code\u003e groups markers. Here, we use the \u003ccode\u003eNonHierarchicalViewBasedAlgorithm\u003c/code\u003e, which clusters markers based on the visible region of the screen. This algorithm only processes markers currently visible on the map, significantly improving performance. Being non-hierarchical, it dynamically manages markers to reduce unnecessary calculations and offers a smoother user experience.\u003c/li\u003e\u003cli id=\"5527\"\u003e\u003ccode\u003e\u003cstrong\u003eonClickedCluster()\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e This function handles the zoom-in action on the map when a clustered group is clicked.\u003c/li\u003e\u003cli id=\"323f\"\u003e\u003ccode\u003e\u003cstrong\u003eonClickedClusterItem()\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e This function triggers when an individual marker inside a cluster is clicked.\u003c/li\u003e\u003cli id=\"48c3\"\u003e\u003ccode\u003e\u003cstrong\u003eaddSampleMarkers()\u003c/strong\u003e\u003c/code\u003e\u003cbr/\u003e This method creates sample markers and adds them to the map for demonstration purposes.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"8850\"\u003eoverride fun onMapReady(googleMap: GoogleMap) {\u003cbr/\u003e    val istanbul = LatLng(40.989010, 29.022949)\u003cbr/\u003e    val lat = 40.989010 + (Math.random() - 0.5) / 10\u003cbr/\u003e    val lng = 29.022949 + (Math.random() - 0.5) / 10\u003cp\u003e    googleMap.moveCamera(\u003cbr/\u003e        CameraUpdateFactory.newLatLngZoom(\u003cbr/\u003e            istanbul,\u003cbr/\u003e            15f\u003cbr/\u003e        )\u003cbr/\u003e    )\u003cbr/\u003e    val markerManager = MarkerManager()\u003c/p\u003e\u003cp\u003e    markerManager.initClusterManager(context = this, map = googleMap)\u003c/p\u003e\u003cp\u003e    markerManager.addSampleMarkers()\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"5e64\"\u003eIntegrating ClusterManager in MainActivity\u003c/h2\u003e\u003cp id=\"1735\"\u003eFinally, once our map is ready in the \u003ccode\u003eMainActivity\u003c/code\u003e, we create an instance of the \u003ccode\u003eMarkerManager\u003c/code\u003e class and call the \u003ccode\u003einitClusterManager()\u003c/code\u003e function. This initializes the clustering functionality and enables efficient marker management on the map.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ac3d\"\u003eI’ve shared the Cluster example in the GitHub repo. You can visit the repo to review the project in detail. Before running the project, you need to get your own Google Maps API key and add it to the project.\u003c/p\u003e\u003ch2 id=\"0c2d\"\u003e📱 Connect with me\u003c/h2\u003e\u003cul\u003e\u003cli id=\"36ce\"\u003e🔗 \u003ca href=\"https://www.linkedin.com/in/tolga-pirim/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e\u003c/li\u003e\u003cli id=\"e67f\"\u003e💻 \u003ca href=\"https://github.com/tolgaprm\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "31 min read",
  "publishedTime": "2025-06-10T09:48:26.364Z",
  "modifiedTime": null
}
