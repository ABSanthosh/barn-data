{
  "id": "b581f021-00ff-4853-93c2-16eb6b181033",
  "title": "How to Use Swift Packages in Kotlin Multiplatform using Koin",
  "link": "https://proandroiddev.com/how-to-use-swift-packages-in-kotlin-multiplatform-using-koin-c7d24fdbbbd7?source=rss----c72404660798---4",
  "description": "",
  "author": "Mirzamehdi Karimov",
  "published": "Mon, 03 Mar 2025 15:36:56 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "swift",
    "kotlin-multiplatform",
    "koin",
    "compose-multiplatform"
  ],
  "byline": "Mirzamehdi Karimov",
  "length": 5916,
  "excerpt": "When developing Kotlin or Compose Multiplatform applications, sometimes dependencies are not supported in Kotlin Multiplatform, and we need a way to make them work. There are several ways to use…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "When developing Kotlin or Compose Multiplatform applications, sometimes dependencies are not supported in Kotlin Multiplatform, and we need a way to make them work. There are several ways to use Swift dependencies in Kotlin Multiplatform. If we’re lucky and the library has a CocoaPods dependency, some libraries expose Objective-C headers and can be used directly in Kotlin by including the CocoaPods dependency. But sometimes, that is not the case, and we are limited to writing Swift code only. However, we still need to provide this Swift implementation to our Kotlin Multiplatform project.Using Swift Libraries in Kotlin Multiplatform using KoinIn this blog post, I’ll go through using Firebase Analytics as an example, but this approach can be applied to any Swift dependency.Step 1: Create a Common Analytics InterfaceFirst, we need to create a common Analytics interface:interface Analytics { fun logEvent(event: String, params: Map\u003cString, Any\u003e? = emptyMap()) fun setEnabled(enabled: Boolean = true) //Can be used based on user consent companion object { const val EVENT_SCREEN_VIEW = \"screen_view\" const val PARAM_SCREEN_NAME = \"screen_name\" }}You can also add commonly used event names here. I also like to create an extra extension function to log each screen view:fun Analytics.logScreenView(screenName: String, params: Map\u003cString, Any\u003e? = emptyMap()) { logEvent( event = Analytics.EVENT_SCREEN_VIEW, params = mapOf(Analytics.PARAM_SCREEN_NAME to screenName) + (params ?: emptyMap()) )}Step 2: Implement Analytics for Each PlatformAndroid ImplementationIn the androidMain source set, create FirebaseAnalyticsImpl:import android.os.Bundleimport com.google.firebase.analytics.FirebaseAnalyticsclass FirebaseAnalyticsImpl(private val firebaseAnalytics: FirebaseAnalytics) : Analytics { override fun logEvent(event: String, params: Map\u003cString, Any\u003e?) { val bundle = Bundle().apply { for (entry in params ?: emptyMap()) putString(entry.key, entry.value.toString()) } firebaseAnalytics.logEvent(event, bundle) } override fun setEnabled(enabled: Boolean) { firebaseAnalytics.setAnalyticsCollectionEnabled(enabled) }}iOS ImplementationSince we don’t have CocoaPods dependencies in Kotlin Multiplatform, we need to create a Swift file in the iOS project. First, make sure you add FirebaseAnalytics dependency using Swift Package Manager. Then, in iosApp, create a new Swift file called FirebaseAnalyticsImpl:import Foundationimport ComposeAppimport FirebaseAnalyticsimport FirebaseCoreclass FirebaseAnalyticsImpl: ComposeApp.Analytics { func logEvent(event: String, params: [String : Any]?) { var eventParams: [String: Any] = [:] params?.forEach { key, value in eventParams[key] = \"\\(value)\" } Analytics.logEvent(event, parameters: eventParams) } func setEnabled(enabled: Bool) { Analytics.setAnalyticsCollectionEnabled(enabled) }}Step 3: Provide Implementations to Kotlin Multiplatform with KoinKoin makes dependency injection easier. I assume you’re already familiar with providing platform-specific modules using Koin in Kotlin Multiplatform. If not, check out my blog post:Achieving Platform-Specific Implementations with Koin in KMPAndroid SideIn platformModule, provide the implementation as a singleton:internal actual val platformModule: Module = module { single { FirebaseAnalyticsImpl(firebaseAnalytics = Firebase.analytics) } bind Analytics::class}iOS SideSince Kotlin can’t directly access Swift classes, we need a factory to create instances. First, create SwiftLibDependencyFactory in iosMain:interface SwiftLibDependencyFactory { fun provideFirebaseAnalyticsImpl(): Analytics}Then, in iosApp, create SwiftLibDependencyFactoryImpl.swift:import Foundationimport ComposeAppimport SwiftUIimport UIKitclass SwiftLibDependencyFactoryImpl: SwiftLibDependencyFactory { static var shared = SwiftLibDependencyFactoryImpl() func provideFirebaseAnalyticsImpl() -\u003e any Analytics { return FirebaseAnalyticsImpl() }}Although this requires some boilerplate code, the advantage is that you only need to do this once. When adding a new Swift library, just add a function in SwiftLibDependencyFactory and provide its implementation.Step 4: Connect Everything in Kotlin MultiplatformIn iosMain, add a new koin module to manage the dependency:internal fun swiftLibDependenciesModule(factory: SwiftLibDependencyFactory): Module = module { single { factory.provideFirebaseAnalyticsImpl() } bind Analytics::class}Step 5: Provide SwiftLibDependencyFactoryImpl to KoinIn iosMain main.kt, add an extension function to provide the module to the application:fun KoinApplication.provideSwiftLibDependencyFactory(factory: SwiftLibDependencyFactory) = run { modules(swiftLibDependenciesModule(factory)) }You probably initialize dependencies in your project something similar to this:object AppInitializer { fun initialize(onKoinStart: KoinApplication.() -\u003e Unit) { startKoin { onKoinStart() modules(appModules) } }}In your Swift application, call:AppInitializer.shared.initialize(onKoinStart: { koinApp in koinApp.provideSwiftLibDependencyFactory( factory: SwiftLibDependencyFactoryImpl.shared )})Step 6: Use AnalyticsNow that everything is set up, you can inject Analytics anywhere in your Kotlin code. For example, in a Composable function:val analytics = koinInject\u003cAnalytics\u003e()analytics.logEvent(event = \"PurchaseButtonClick\")Make sure to call analytics.setEnabled(true) at app startup or after obtaining user consent.This approach ensures integration of any Swift dependencies into Kotlin Multiplatform while keeping everything organized using Koin in Kotlin Multiplatform project. And if you’re using KAppMaker, the boilerplate for this is already set up for you, so you can get started even faster.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*lS25_M6me30l7knx163AHw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@mirzemehdi?source=post_page---byline--c7d24fdbbbd7---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Mirzamehdi Karimov\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*67sqU2xhnqMHQWvF23_vGw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--c7d24fdbbbd7---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"75a1\"\u003eWhen developing Kotlin or Compose Multiplatform applications, sometimes dependencies are not supported in Kotlin Multiplatform, and we need a way to make them work. There are several ways to use Swift dependencies in Kotlin Multiplatform. If we’re lucky and the library has a CocoaPods dependency, some libraries expose Objective-C headers and can be used directly in Kotlin by including the CocoaPods dependency. But sometimes, that is not the case, and we are limited to writing Swift code only. However, we still need to provide this Swift implementation to our Kotlin Multiplatform project.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eUsing Swift Libraries in Kotlin Multiplatform using Koin\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"e741\"\u003eIn this blog post, I’ll go through using Firebase Analytics as an example, but this approach can be applied to any Swift dependency.\u003c/p\u003e\u003ch2 id=\"7a5f\"\u003eStep 1: Create a Common Analytics Interface\u003c/h2\u003e\u003cp id=\"bd74\"\u003eFirst, we need to create a common \u003ccode\u003eAnalytics\u003c/code\u003e interface:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b83f\"\u003einterface Analytics {\u003cbr/\u003e    fun logEvent(event: String, params: Map\u0026lt;String, Any\u0026gt;? = emptyMap())\u003cbr/\u003e    fun setEnabled(enabled: Boolean = true) //Can be used based on user consent\u003cp\u003e    companion object {\u003cbr/\u003e        const val EVENT_SCREEN_VIEW = \u0026#34;screen_view\u0026#34;\u003cbr/\u003e        const val PARAM_SCREEN_NAME = \u0026#34;screen_name\u0026#34;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bc82\"\u003eYou can also add commonly used event names here. I also like to create an extra extension function to log each screen view:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1b5d\"\u003efun Analytics.logScreenView(screenName: String, params: Map\u0026lt;String, Any\u0026gt;? = emptyMap()) {\u003cbr/\u003e    logEvent(\u003cbr/\u003e        event = Analytics.EVENT_SCREEN_VIEW,\u003cbr/\u003e        params = mapOf(Analytics.PARAM_SCREEN_NAME to screenName) + (params ?: emptyMap())\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"fc8d\"\u003eStep 2: Implement Analytics for Each Platform\u003c/h2\u003e\u003ch2 id=\"667b\"\u003eAndroid Implementation\u003c/h2\u003e\u003cp id=\"34c2\"\u003eIn the \u003ccode\u003eandroidMain\u003c/code\u003e source set, create \u003ccode\u003eFirebaseAnalyticsImpl\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5105\"\u003eimport android.os.Bundle\u003cbr/\u003eimport com.google.firebase.analytics.FirebaseAnalytics\u003cp\u003eclass FirebaseAnalyticsImpl(private val firebaseAnalytics: FirebaseAnalytics) : Analytics {\u003c/p\u003e\u003cp\u003e    override fun logEvent(event: String, params: Map\u0026lt;String, Any\u0026gt;?) {\u003cbr/\u003e        val bundle = Bundle().apply {\u003cbr/\u003e            for (entry in params ?: emptyMap()) putString(entry.key, entry.value.toString())\u003cbr/\u003e        }\u003cbr/\u003e        firebaseAnalytics.logEvent(event, bundle)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun setEnabled(enabled: Boolean) {\u003cbr/\u003e        firebaseAnalytics.setAnalyticsCollectionEnabled(enabled)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"2b23\"\u003eiOS Implementation\u003c/h2\u003e\u003cp id=\"2b29\"\u003eSince we don’t have CocoaPods dependencies in Kotlin Multiplatform, we need to create a Swift file in the iOS project. First, make sure you add FirebaseAnalytics dependency using Swift Package Manager. Then, in \u003ccode\u003eiosApp\u003c/code\u003e, create a new Swift file called \u003ccode\u003eFirebaseAnalyticsImpl\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e5d4\"\u003eimport Foundation\u003cbr/\u003eimport ComposeApp\u003cbr/\u003eimport FirebaseAnalytics\u003cbr/\u003eimport FirebaseCore\u003cp\u003eclass FirebaseAnalyticsImpl: ComposeApp.Analytics {\u003cbr/\u003e    func logEvent(event: String, params: [String : Any]?) {\u003cbr/\u003e        var eventParams: [String: Any] = [:]\u003cbr/\u003e        params?.forEach { key, value in eventParams[key] = \u0026#34;\\(value)\u0026#34; }\u003cbr/\u003e        Analytics.logEvent(event, parameters: eventParams)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    func setEnabled(enabled: Bool) {\u003cbr/\u003e        Analytics.setAnalyticsCollectionEnabled(enabled)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"b24e\"\u003eStep 3: Provide Implementations to Kotlin Multiplatform with Koin\u003c/h2\u003e\u003cp id=\"c8b3\"\u003eKoin makes dependency injection easier. I assume you’re already familiar with providing platform-specific modules using Koin in Kotlin Multiplatform. If not, check out my blog post:\u003c/p\u003e\u003cp id=\"ecc0\"\u003e\u003ca href=\"https://medium.com/proandroiddev/achieving-platform-specific-implementations-with-koin-in-kmm-5cb029ba4f3b\" rel=\"noopener\"\u003eAchieving Platform-Specific Implementations with Koin in KMP\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"e0a4\"\u003eAndroid Side\u003c/h2\u003e\u003cp id=\"ddf1\"\u003eIn \u003ccode\u003eplatformModule\u003c/code\u003e, provide the implementation as a singleton:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"554e\"\u003einternal actual val platformModule: Module = module {\u003cbr/\u003e    single { FirebaseAnalyticsImpl(firebaseAnalytics = Firebase.analytics) } bind Analytics::class\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"548f\"\u003eiOS Side\u003c/h2\u003e\u003cp id=\"bcb2\"\u003eSince Kotlin can’t directly access Swift classes, we need a factory to create instances. First, create \u003ccode\u003eSwiftLibDependencyFactory\u003c/code\u003e in \u003ccode\u003eiosMain\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"57e4\"\u003einterface SwiftLibDependencyFactory {\u003cbr/\u003e    fun provideFirebaseAnalyticsImpl(): Analytics\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8afc\"\u003eThen, in \u003ccode\u003eiosApp\u003c/code\u003e, create \u003ccode\u003eSwiftLibDependencyFactoryImpl.swift\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"33e9\"\u003eimport Foundation\u003cbr/\u003eimport ComposeApp\u003cbr/\u003eimport SwiftUI\u003cbr/\u003eimport UIKit\u003cp\u003eclass SwiftLibDependencyFactoryImpl: SwiftLibDependencyFactory {\u003cbr/\u003e    static var shared = SwiftLibDependencyFactoryImpl()\u003c/p\u003e\u003cp\u003e        func provideFirebaseAnalyticsImpl() -\u0026gt; any Analytics {\u003cbr/\u003e        return FirebaseAnalyticsImpl()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"278a\"\u003eAlthough this requires some boilerplate code, the advantage is that you only need to do this once. When adding a new Swift library, just add a function in \u003ccode\u003eSwiftLibDependencyFactory\u003c/code\u003e and provide its implementation.\u003c/p\u003e\u003ch2 id=\"47cc\"\u003eStep 4: Connect Everything in Kotlin Multiplatform\u003c/h2\u003e\u003cp id=\"6f4e\"\u003eIn \u003ccode\u003eiosMain\u003c/code\u003e, add a new koin module to manage the dependency:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"69f6\"\u003einternal fun swiftLibDependenciesModule(factory: SwiftLibDependencyFactory): Module = module {\u003cbr/\u003e    single { factory.provideFirebaseAnalyticsImpl() } bind Analytics::class\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"8332\"\u003eStep 5: Provide \u003ccode\u003eSwiftLibDependencyFactoryImpl\u003c/code\u003e to Koin\u003c/h2\u003e\u003cp id=\"f9f7\"\u003eIn iosMain \u003ccode\u003emain.kt\u003c/code\u003e, add an extension function to provide the module to the application:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2b0d\"\u003efun KoinApplication.provideSwiftLibDependencyFactory(factory: SwiftLibDependencyFactory) =\u003cbr/\u003e    run { modules(swiftLibDependenciesModule(factory)) }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c36a\"\u003eYou probably initialize dependencies in your project something similar to this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e5c0\"\u003eobject AppInitializer {\u003cbr/\u003e    fun initialize(onKoinStart: KoinApplication.() -\u0026gt; Unit) {\u003cbr/\u003e        startKoin {\u003cbr/\u003e            onKoinStart()\u003cbr/\u003e            modules(appModules)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"decc\"\u003eIn your Swift application, call:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6748\"\u003eAppInitializer.shared.initialize(onKoinStart: { koinApp in\u003cbr/\u003e    koinApp.provideSwiftLibDependencyFactory(\u003cbr/\u003e        factory: SwiftLibDependencyFactoryImpl.shared\u003cbr/\u003e    )\u003cbr/\u003e})\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e72c\"\u003eStep 6: Use Analytics\u003c/h2\u003e\u003cp id=\"86df\"\u003eNow that everything is set up, you can inject \u003ccode\u003eAnalytics\u003c/code\u003e anywhere in your Kotlin code. For example, in a Composable function:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1982\"\u003eval analytics = koinInject\u0026lt;Analytics\u0026gt;()\u003cbr/\u003eanalytics.logEvent(event = \u0026#34;PurchaseButtonClick\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6570\"\u003eMake sure to call \u003ccode\u003eanalytics.setEnabled(true)\u003c/code\u003e at app startup or after obtaining user consent.\u003c/p\u003e\u003cp id=\"e2db\"\u003eThis approach ensures integration of any Swift dependencies into Kotlin Multiplatform while keeping everything organized using Koin in Kotlin Multiplatform project. And if you’re using \u003ca href=\"https://kappmaker.com/?utm_source=blogpost\u0026amp;utm_medium=post\u0026amp;utm_campaign=swift_dependency_integration\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eKAppMaker\u003c/em\u003e\u003c/a\u003e, the boilerplate for this is already set up for you, so you can get started even faster.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-03-03T13:48:10.377Z",
  "modifiedTime": null
}
