{
  "id": "1b817cae-56f7-4bb5-bddf-99a2914a065f",
  "title": "Building for multi-form factor devices in Android: The optimal architecture",
  "link": "https://proandroiddev.com/building-for-multi-form-factor-devices-in-android-the-optimal-architecture-6311221463ab?source=rss----c72404660798---4",
  "description": "",
  "author": "Gérard Paligot",
  "published": "Fri, 29 Nov 2024 04:25:01 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "adaptive",
    "kotlin",
    "android",
    "architecture-components",
    "jetpack-compose"
  ],
  "byline": "Gérard Paligot",
  "length": 10212,
  "excerpt": "This article is inspired by a talk I gave with David Ta in 2024, entitled “Why is Adaptive Layout a Nightmare?”. During that presentation, we wanted to explain how complex it was to migrate an…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Generated by Ideogram.aiThis article is inspired by a talk I gave with David Ta in 2024, entitled “Why is Adaptive Layout a Nightmare?”. During that presentation, we wanted to explain how complex it was to migrate an existing Android application to be compatible with adaptive layouts and the unexpected obstacles which you face across different screen sizes and device configurations. The journey of creating adaptive layouts can indeed feel like a nightmare if you don’t have the proper architectural foundation.In this post, I’ll present a summarized version of our talk on component modular architecture. This architectural pattern provides a structured solution to achieve designs that are adaptable and reusable in a layered manner. With its multiple layers, a developer can more easily handle navigation, the content at screen levels, and the UI components with ease, making adaptive layouts practical and less challenging to maintain.The component architecture: Modular design to support additional form factorsAs Android applications get more complex and need to handle new form factors like phones, tablets, and foldable devices, traditional architectures can be rigid to handle with the unique demands on each device type. Component architecture addresses these challenges by breaking the presentation layer into modular levels of granularity that are specifically designed for adaptability and scalability across diverse screen configurations.Overview of the component architectureThe component architecture organizes the presentation layer into three hierarchical levels:Gradle modules categorized by component levelsApp-Level (navigation layer): The app level deals with the global navigation of the application, structures, and flows across different screens. This level makes components handle centralized control over navigation while adapting to various device sizes. In such architecture, the use of navigation components is targeted to toggle between bottom navigation, navigation rails, or drawers concerning device configuration so that it can respond dynamically to changes in screen dimensions.Screen-Level (adaptive layouts and panes): Screen-level components are responsible for managing layout and structure within a given screen, such that on different screen sizes and orientations, it would adapt to them. Components that may change their layout as the window size changes. This level uses scaffolds like SupportingPaneScaffold or ListDetailPaneScaffold that enable adaptive layouts and make sure content is always presented in the most optimal way for each of the form factors. For example, a screen can display only one pane on a small device, but automatically switch to a dual-pane layout on larger screens.UI Component Level (reusable components): The UI component level consists of smaller reusable components across various screens. These components are isolated and focus on individual UI elements, which do not change in device configuration but are foundational to screen-level compositions. Examples include buttons, icons, or text fields. By modularizing these components, the architecture allows for reuse and rapid testing across a wide number of screens and layouts.Key characteristicsModularity and reusability: Instead of having a single monolithic app strategy, the component approach really encourages modular components to make use of such things as navigation, displays of content, and specific UI elements, which can be reused across various devices and screen configurations. It becomes an ideal paradigm for multi-form factor compatibility whereby each component may independently be designed to adapt to various form factors without affecting the whole application.Adaptive UI components: Components are designed with adaptability in mind in top of WindowSizeClass add and adaptive scaffolds like NavigationSuiteScaffold, SupportingPaneScaffold, and ListDetailPaneScaffold. These scaffolds automatically change according to different screen dimensions, adapting screen real estate and screen orientation into proper layout.Separation of Concerns: Compared to other architectures, component architecture extends the principle of separation of concerns, decoupling UI logic from business logic and device-specific configurations. Each layer is going to stay independent, but the UI components will adjust dynamically due to screen size, whereas business logic with core functionalities would remain the same. Due to this approach, code will not be complex; testing is easy, and allows developers to avoid spreading changes in one layer across an entire codebase.Component modular architecture: Structured for adaptabilityIn the component modular architecture, components are organized in distinct modules of the presentation layer for better adaptability and maintainability on different screen sizes and device configurations. The modular structure may have three major levels: an application-level, screen-level and a UI component-level. Each of these levels corresponds to a separate module so that the structure of an application is able to cope with multi-form factor devices without noticeable efforts.The modular architecture in the presentation layer is divided into three hierarchical levels:App-Level: App-level components, like AppNavigation, are placed in a centralized module, typically named main or navigation. This layer controls primary navigation elements across the app, managing the flow and layout of screens in response to different device configurations.@Composablefun AppNavigation( navActions: Immutable\u003cNavAction\u003e, routeSelected: String, modifier: Modifier = Modifier, navController: NavHostController = rememberNavController(),) { NavigationSuiteScaffold( modifier = modifier, navigationSuiteItems = { navActions.forEach { action -\u003e val selected = action.route == routeSelected item( selected = selected, icon = { Icon( imageVector = if (selected) action.iconSelected else action.icon, contentDescription = action.contentDescription ) }, onClick = { // use navController to navigate to your screen } ) } } ) { NavHost( navController = navController, startDestination = \"first-screen\", builder = { // composables } ) }}Screen-Level: Screen-level components, including those that manage adaptive layouts and link to ViewModels, are organized into a module called presentation. This module includes adaptive components like MyScreenAdaptive, which handles layout adjustments based on the device’s WindowSizeClass. Additionally, screen-level components specific to different panes are grouped in a module named panes.@Composablefun MyScreenAdaptive( showFilterIcon: Boolean, modifier: Modifier = Modifier,) { SupportingPaneScaffold( modifier = modifier, mainPane = { MyFirstPaneVM() }, supportingPane = { MySecondPaneVM(showFilterIcon = showFilterIcon) } )}UI Component-Level (reusable components): Contain small UI parts, such as buttons and icons. Those are organized in the ui module of each specific feature. For more general components, UI components are developed at the internal design system level for common use across different screens and features.By assigning components to the main, presentation, panes, and ui modules, the architecture ensures a structured approach in both flexibility and high scalability. This modular hierarchy enables each layer independently to be tested, maintained, and updated while reducing dependency, thus best suited for multi-form factor design.Why Modular, component-based architecture is ideal for multi-form factors compatibilityEmbracing this modern architecture will greatly enhance the flexibility and adaptability of your app across devices. Let me just outline why this approach will fit perfectly for you:Enhanced adaptability with less codeAutomatic UI adjustment: Components such as NavigationSuiteScaffold will automatically handle different device configurations without requiring you to adjust the layout manually.Less redundancy: Due to the reusable elements, it is no longer a need for creating separate layouts or components for each device type. ListDetailPaneScaffold and SupportingPaneScaffold self-adjust according to the size of the screen, reducing redundancy of code per screen level.Improved scalability and maintainabilityModular codebase: Separation of navigation, panes and UI components will allow you to develop screens for any device without worrying about the device configuration.Lower maintenance costs: It reduces the total number of views or layouts to maintain, with fewer errors and easier updates. This modularity is extremely valuable when handling compatibility problems as new device types emerge.Simplification of consistent UIThis architecture lends itself to naturally forcing consistency of UI. Adaptive scaffolds, such as NavigationSuiteScaffold and SupportingPaneScaffold, keep design patterns consistent across devices for cohesiveness in user experience no matter the form factor.ConclusionThe notion of building multi-form factor compatible applications for Android devices automatically requires a rethink in architecture. Conventional Android architectures are very efficient in building simple apps, probably single-screen apps, but start to limit the developers as screen variations grow. Google’s new component-based and modular architecture empowers developers to design adaptive UIs that can dynamically change with screen size and configuration with minimal redundancy in code and less load of maintenance. This is the architecture that would enable Android developers to create applications, keeping users in mind by providing a seamless experience on all devices while remaining efficient and highly scalable over time.This new approach makes it even easier to deliver high-quality applications, giving one a consistent and adaptive experience across the diverse Android ecosystem.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*CmxybFjv1I2x-C6CbiPp7w.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003cfigcaption\u003eGenerated by Ideogram.ai\u003c/figcaption\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@GerardPaligot?source=post_page---byline--6311221463ab--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Gérard Paligot\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*Np7tVOyPRHslpXEaBARioA.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--6311221463ab--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"2f11\"\u003eThis article is inspired by a talk I gave with David Ta in 2024, entitled \u003cem\u003e“Why is Adaptive Layout a Nightmare?”\u003c/em\u003e. During that presentation, we wanted to explain how complex it was to migrate an existing Android application to be compatible with adaptive layouts and the unexpected obstacles which you face across different screen sizes and device configurations. The journey of creating adaptive layouts can indeed feel like a nightmare if you don’t have the proper architectural foundation.\u003c/p\u003e\u003cp id=\"6a37\"\u003eIn this post, I’ll present a summarized version of our talk on component modular architecture. This architectural pattern provides a structured solution to achieve designs that are adaptable and reusable in a layered manner. With its multiple layers, a developer can more easily handle navigation, the content at screen levels, and the UI components with ease, making adaptive layouts practical and less challenging to maintain.\u003c/p\u003e\u003ch2 id=\"efb7\"\u003eThe component architecture: Modular design to support additional form factors\u003c/h2\u003e\u003cp id=\"f051\"\u003eAs Android applications get more complex and need to handle new form factors like phones, tablets, and foldable devices, traditional architectures can be rigid to handle with the unique demands on each device type. Component architecture addresses these challenges by breaking the presentation layer into modular levels of granularity that are specifically designed for adaptability and scalability across diverse screen configurations.\u003c/p\u003e\u003ch2 id=\"26a5\"\u003eOverview of the component architecture\u003c/h2\u003e\u003cp id=\"2f61\"\u003eThe component architecture organizes the presentation layer into three hierarchical levels:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eGradle modules categorized by component levels\u003c/figcaption\u003e\u003c/figure\u003e\u003col\u003e\u003cli id=\"1bbb\"\u003e\u003cstrong\u003eApp-Level (navigation layer):\u003c/strong\u003e The app level deals with the global navigation of the application, structures, and flows across different screens. This level makes components handle centralized control over navigation while adapting to various device sizes. In such architecture, the use of navigation components is targeted to toggle between bottom navigation, navigation rails, or drawers concerning device configuration so that it can respond dynamically to changes in screen dimensions.\u003c/li\u003e\u003cli id=\"5d4d\"\u003e\u003cstrong\u003eScreen-Level (adaptive layouts and panes):\u003c/strong\u003e Screen-level components are responsible for managing layout and structure within a given screen, such that on different screen sizes and orientations, it would adapt to them. Components that may change their layout as the window size changes. This level uses scaffolds like SupportingPaneScaffold or ListDetailPaneScaffold that enable adaptive layouts and make sure content is always presented in the most optimal way for each of the form factors. For example, a screen can display only one pane on a small device, but automatically switch to a dual-pane layout on larger screens.\u003c/li\u003e\u003cli id=\"571b\"\u003e\u003cstrong\u003eUI Component Level (reusable components):\u003c/strong\u003e The UI component level consists of smaller reusable components across various screens. These components are isolated and focus on individual UI elements, which do not change in device configuration but are foundational to screen-level compositions. Examples include buttons, icons, or text fields. By modularizing these components, the architecture allows for reuse and rapid testing across a wide number of screens and layouts.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"57ac\"\u003eKey characteristics\u003c/h2\u003e\u003col\u003e\u003cli id=\"e140\"\u003e\u003cstrong\u003eModularity and reusability:\u003c/strong\u003e Instead of having a single monolithic app strategy, the component approach really encourages modular components to make use of such things as navigation, displays of content, and specific UI elements, which can be reused across various devices and screen configurations. It becomes an ideal paradigm for multi-form factor compatibility whereby each component may independently be designed to adapt to various form factors without affecting the whole application.\u003c/li\u003e\u003cli id=\"a6a0\"\u003e\u003cstrong\u003eAdaptive UI components:\u003c/strong\u003e Components are designed with adaptability in mind in top of WindowSizeClass add and adaptive scaffolds like NavigationSuiteScaffold, SupportingPaneScaffold, and ListDetailPaneScaffold. These scaffolds automatically change according to different screen dimensions, adapting screen real estate and screen orientation into proper layout.\u003c/li\u003e\u003cli id=\"4b52\"\u003e\u003cstrong\u003eSeparation of Concerns:\u003c/strong\u003e Compared to other architectures, component architecture extends the principle of separation of concerns, decoupling UI logic from business logic and device-specific configurations. Each layer is going to stay independent, but the UI components will adjust dynamically due to screen size, whereas business logic with core functionalities would remain the same. Due to this approach, code will not be complex; testing is easy, and allows developers to avoid spreading changes in one layer across an entire codebase.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"ff3d\"\u003eComponent modular architecture: Structured for adaptability\u003c/h2\u003e\u003cp id=\"5ab4\"\u003eIn the component modular architecture, components are organized in distinct modules of the presentation layer for better adaptability and maintainability on different screen sizes and device configurations. The modular structure may have three major levels: an application-level, screen-level and a UI component-level. Each of these levels corresponds to a separate module so that the structure of an application is able to cope with multi-form factor devices without noticeable efforts.\u003c/p\u003e\u003cp id=\"271d\"\u003eThe modular architecture in the presentation layer is divided into three hierarchical levels:\u003c/p\u003e\u003cp id=\"44a2\"\u003e\u003cstrong\u003eApp-Level\u003c/strong\u003e: App-level components, like AppNavigation, are placed in a centralized module, typically named \u003cem\u003emain\u003c/em\u003e or \u003cem\u003enavigation\u003c/em\u003e. This layer controls primary navigation elements across the app, managing the flow and layout of screens in response to different device configurations.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1d14\"\u003e@Composable\u003cbr/\u003efun AppNavigation(\u003cbr/\u003e   navActions: Immutable\u0026lt;NavAction\u0026gt;,\u003cbr/\u003e   routeSelected: String,\u003cbr/\u003e   modifier: Modifier = Modifier,\u003cbr/\u003e   navController: NavHostController = rememberNavController(),\u003cbr/\u003e) {\u003cbr/\u003e   NavigationSuiteScaffold(\u003cbr/\u003e      modifier = modifier,\u003cbr/\u003e      navigationSuiteItems = {\u003cbr/\u003e         navActions.forEach { action -\u0026gt;\u003cbr/\u003e            val selected = action.route == routeSelected\u003cbr/\u003e            item(\u003cbr/\u003e               selected = selected,\u003cbr/\u003e               icon = {\u003cbr/\u003e                  Icon(\u003cbr/\u003e                     imageVector = if (selected) action.iconSelected else action.icon,\u003cbr/\u003e                     contentDescription = action.contentDescription\u003cbr/\u003e                  )\u003cbr/\u003e               },\u003cbr/\u003e               onClick = {\u003cbr/\u003e                  // use navController to navigate to your screen\u003cbr/\u003e               }\u003cbr/\u003e            )\u003cbr/\u003e         }\u003cbr/\u003e      }\u003cbr/\u003e   ) {\u003cbr/\u003e      NavHost(\u003cbr/\u003e         navController = navController,\u003cbr/\u003e         startDestination = \u0026#34;first-screen\u0026#34;,\u003cbr/\u003e         builder = {\u003cbr/\u003e            // composables\u003cbr/\u003e         }\u003cbr/\u003e      )\u003cbr/\u003e   }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f3dc\"\u003e\u003cstrong\u003eScreen-Level\u003c/strong\u003e: Screen-level components, including those that manage adaptive layouts and link to ViewModels, are organized into a module called \u003cem\u003epresentation\u003c/em\u003e. This module includes adaptive components like MyScreenAdaptive, which handles layout adjustments based on the device’s WindowSizeClass. Additionally, screen-level components specific to different panes are grouped in a module named \u003cem\u003epanes\u003c/em\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"82c9\"\u003e@Composable\u003cbr/\u003efun MyScreenAdaptive(\u003cbr/\u003e   showFilterIcon: Boolean,\u003cbr/\u003e   modifier: Modifier = Modifier,\u003cbr/\u003e) {\u003cbr/\u003e   SupportingPaneScaffold(\u003cbr/\u003e       modifier = modifier,\u003cbr/\u003e       mainPane = {\u003cbr/\u003e           MyFirstPaneVM()\u003cbr/\u003e       },\u003cbr/\u003e       supportingPane = {\u003cbr/\u003e           MySecondPaneVM(showFilterIcon = showFilterIcon)\u003cbr/\u003e       }\u003cbr/\u003e   )\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bab1\"\u003e\u003cstrong\u003eUI Component-Level (reusable components)\u003c/strong\u003e: Contain small UI parts, such as buttons and icons. Those are organized in the \u003cem\u003eui\u003c/em\u003e module of each specific feature. For more general components, UI components are developed at the internal design system level for common use across different screens and features.\u003c/p\u003e\u003cp id=\"149e\"\u003eBy assigning components to the \u003cem\u003emain\u003c/em\u003e, \u003cem\u003epresentation\u003c/em\u003e, \u003cem\u003epanes\u003c/em\u003e, and \u003cem\u003eui\u003c/em\u003e modules, the architecture ensures a structured approach in both flexibility and high scalability. This modular hierarchy enables each layer independently to be tested, maintained, and updated while reducing dependency, thus best suited for multi-form factor design.\u003c/p\u003e\u003ch2 id=\"11d8\"\u003eWhy Modular, component-based architecture is ideal for multi-form factors compatibility\u003c/h2\u003e\u003cp id=\"178a\"\u003eEmbracing this modern architecture will greatly enhance the flexibility and adaptability of your app across devices. Let me just outline why this approach will fit perfectly for you:\u003c/p\u003e\u003ch2 id=\"c09f\"\u003eEnhanced adaptability with less code\u003c/h2\u003e\u003cul\u003e\u003cli id=\"7cb4\"\u003e\u003cstrong\u003eAutomatic UI adjustment:\u003c/strong\u003e Components such as NavigationSuiteScaffold will automatically handle different device configurations without requiring you to adjust the layout manually.\u003c/li\u003e\u003cli id=\"3f25\"\u003e\u003cstrong\u003eLess redundancy:\u003c/strong\u003e Due to the reusable elements, it is no longer a need for creating separate layouts or components for each device type. ListDetailPaneScaffold and SupportingPaneScaffold self-adjust according to the size of the screen, reducing redundancy of code per screen level.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"7e84\"\u003eImproved scalability and maintainability\u003c/h2\u003e\u003cul\u003e\u003cli id=\"d15d\"\u003e\u003cstrong\u003eModular codebase:\u003c/strong\u003e Separation of navigation, panes and UI components will allow you to develop screens for any device without worrying about the device configuration.\u003c/li\u003e\u003cli id=\"ce44\"\u003e\u003cstrong\u003eLower maintenance costs\u003c/strong\u003e: It reduces the total number of views or layouts to maintain, with fewer errors and easier updates. This modularity is extremely valuable when handling compatibility problems as new device types emerge.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f04b\"\u003eSimplification of consistent UI\u003c/h2\u003e\u003cp id=\"1d67\"\u003eThis architecture lends itself to naturally forcing consistency of UI. Adaptive scaffolds, such as NavigationSuiteScaffold and SupportingPaneScaffold, keep design patterns consistent across devices for cohesiveness in user experience no matter the form factor.\u003c/p\u003e\u003ch2 id=\"cdf3\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"8b51\"\u003eThe notion of building multi-form factor compatible applications for Android devices automatically requires a rethink in architecture. Conventional Android architectures are very efficient in building simple apps, probably single-screen apps, but start to limit the developers as screen variations grow. Google’s new component-based and modular architecture empowers developers to design adaptive UIs that can dynamically change with screen size and configuration with minimal redundancy in code and less load of maintenance. This is the architecture that would enable Android developers to create applications, keeping users in mind by providing a seamless experience on all devices while remaining efficient and highly scalable over time.\u003c/p\u003e\u003cp id=\"fd7d\"\u003eThis new approach makes it even easier to deliver high-quality applications, giving one a consistent and adaptive experience across the diverse Android ecosystem.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2024-11-12T10:02:22.229Z",
  "modifiedTime": null
}
