{
  "id": "195fcd16-b15a-4480-ae92-0900d2f0d9fe",
  "title": "Bridging StateFlow and Jetpack Compose State: A Cleaner Architectural Approach",
  "link": "https://proandroiddev.com/bridging-the-gap-between-jetpack-compose-state-and-stateflow-for-reactive-ui-163efeb1d0d9?source=rss----c72404660798---4",
  "description": "",
  "author": "Ioannis Anifantakis",
  "published": "Fri, 27 Dec 2024 23:35:29 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "state-management",
    "android-app-development",
    "jetpack-compose",
    "androiddev",
    "android"
  ],
  "byline": "Ioannis Anifantakis",
  "length": 8151,
  "excerpt": "Managing UI state in Android apps often involves a delicate balance: Compose’s built-in state (mutableStateOf) makes it incredibly easy to keep your UI updated, while Kotlin’s StateFlow offers…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Managing UI state in Android apps often involves a delicate balance: Compose’s built-in state (mutableStateOf) makes it incredibly easy to keep your UI updated, while Kotlin’s StateFlow offers powerful, testable, and thread-safe reactive data streams. The challenge arises when you try to combine these approaches. While it’s simple to drop collectAsStateWithLifecycle() calls into your composables, you end up repeating code and sprinkling collection logic throughout your UI layer.In this article, we’ll show you a step-by-step method to leverage both Compose’s ergonomic property delegation and StateFlow’s reactive capabilities. We’ll start simple, then scale up to more complex scenarios, all while ensuring our composables remain focused on rendering and not on state management details.Starting Simple: Compose’s Built-In StateConsider a basic ViewModel controlling a splash screen:data class MainState( val showSplash: Boolean = false)class MainViewModel : ViewModel() { var state by mutableStateOf(MainState()) private set init { viewModelScope.launch { // Show splash for a couple of seconds state = state.copy(showSplash = true) delay(2000L) state = state.copy(showSplash = false) } }}In your UI, this is straightforward:@Composablefun MainScreen(viewModel: MainViewModel = viewModel()) { val state = viewModel.state if (state.showSplash) { SplashScreen() } else { MainContent() }}Here, it feels natural: the composable just reads viewModel.state. Compose takes care of recomposing when state changes—no extra hoops to jump through.Introducing StateFlow for More Complex LogicAs your app grows, you may need reactive streams that are testable, concurrent-safe, and easily combined. StateFlow excels here:class MainViewModel : ViewModel() { private val _state = MutableStateFlow(MainState()) val state: StateFlow\u003cMainState\u003e = _state init { viewModelScope.launch { _state.update { it.copy(showSplash = true) } delay(2000L) _state.update { it.copy(showSplash = false) } } }}In your composable, collecting this StateFlow is still simple:@Composablefun MainScreen(viewModel: MainViewModel = viewModel()) { val state = viewModel.state.collectAsStateWithLifecycle().value if (state.showSplash) { SplashScreen() } else { MainContent() }}This works fine but adds a minor annoyance: every place you consume this StateFlow, you have to remember to use collectAsStateWithLifecycle(). The UI code now contains logic to convert flows into Compose state. While not a deal-breaker, this pattern can start feeling repetitive as you scale up and handle more complex states or multiple flows.A More Declarative Approach: toComposeState()What if you could keep StateFlow in the ViewModel (for all its benefits) while maintaining the simple val state by ... pattern in the UI? The answer is a small extension function that moves the “collection” step out of the composable and into the ViewModel layer:fun \u003cT\u003e StateFlow\u003cT\u003e.toComposeState(scope: CoroutineScope): State\u003cT\u003e { val composeState = mutableStateOf(value) scope.launch { this@toComposeState.collect { newValue -\u003e composeState.value = newValue } } return composeState}Now, you can use it in your ViewModel:class MainViewModel : ViewModel() { private val _state = MutableStateFlow(MainState()) val state by _state.toComposeState(viewModelScope) init { viewModelScope.launch { _state.update { it.copy(showSplash = true) } delay(2000L) _state.update { it.copy(showSplash = false) } } }}In the composable:@Composablefun MainScreen(viewModel: MainViewModel = viewModel()) { val state = viewModel.state if (state.showSplash) { SplashScreen() } else { MainContent() }}What’s the gain here? You’ve removed boilerplate from the UI. Instead of repeatedly calling collectAsStateWithLifecycle() in every composable that needs the state, the ViewModel directly provides a State\u003cT\u003e. The UI remains as simple as if you were using mutableStateOf, but under the hood, you still leverage StateFlow’s advanced features.This might seem like a small win, but as your app grows, keeping state conversion centralized in the ViewModel (or a shared layer) is more maintainable than spreading Flow-to-Compose logic across multiple composables.Scaling Up: Combining Multiple FlowsReal apps rarely have just one piece of state. Consider a scenario like a clock alarm app “Snoozeloo” where:_baseAlarmState is a StateFlow of the current alarm configuration.minuteTicker is another StateFlow that emits updates every minute.You can combine these flows, filter them, and still present them as a single State to your UI:val alarmUiState = combine( _baseAlarmState, minuteTicker) { currentAlarm, _ -\u003e currentAlarm?.let { alarm -\u003e val timeUntilNextAlarm = calculateTimeUntilNextAlarm(alarm.hour, alarm.minute, alarm.selectedDays) AlarmUiState( alarm = alarm, timeUntilNextAlarm = UiText.StringResource(timeUntilNextAlarm.formatTimeUntil()), hasChanges = originalAlarm?.let { it != alarm || alarm.isNewAlarm } ?: false ) }}.filterNotNull().filter { state -\u003e true } // Additional filtering if needed.stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5000), initialValue = null).toComposeState(viewModelScope)Your UI now receives a fully combined, filtered, and prepared state without knowing anything about how these flows are wired up:@Composablefun AlarmScreen(viewModel: AlarmViewModel = viewModel()) { val state = viewModel.alarmUiState state?.let { // The UI automatically updates whenever state changes, // no manual collecting needed. ShowAlarmDetails(it) }}By front-loading complexity into a single, reusable layer, you ensure that no matter how intricate your data sources get, your composables remain as simple as accessing a val state.Why Not Just Use collectAsStateWithLifecycle() Everywhere?collectAsStateWithLifecycle() works perfectly for many scenarios. If your codebase is small or you’re comfortable with sprinkling collection logic in your UI, it may be enough.But as your application scales, so does repetition. Each time you introduce a new StateFlow, every composable using it must contain the same collection logic. With toComposeState(), you establish a single pattern that:Keeps the UI declarative and focused solely on rendering.Centralizes Flow-to-Compose conversion in the ViewModel or another shared layer.Makes complex transformations invisible to the UI, so you can pivot and refine data logic without touching your UI code.In larger apps or when multiple StateFlows and combinations are involved, this pattern leads to cleaner architecture, reduces boilerplate, and improves maintainability.When to Use This ApproachStart Simple: If a single mutableStateOf suffices, stick with it. Simplicity first.Power Up with StateFlow: When you need testability, concurrency, or multiple combined data sources, StateFlow is a natural fit.Keep UI Code Clean: If you don’t want repetitive collectAsStateWithLifecycle() calls scattered in your UI, toComposeState() gives you a direct State\u003cT\u003e to consume, just like Compose’s built-in state.Scale Gracefully: As complexity grows, having a consistent pattern for Flow-to-Compose integration pays off. Your UI stays clean and maintainable, no matter how sophisticated your data pipelines become.ConclusionIntegrating StateFlow with Jetpack Compose doesn’t have to come at the cost of simplicity. By introducing a small extension function, you bring together the best of both worlds: StateFlow’s reactive power and Compose’s ergonomic state model.This approach lets you start small and then scale up complexity without burdening your composables. With toComposeState(), you keep your UI code neat, your architecture cleaner, and your state management more maintainable—even as your app logic evolves into richer, more dynamic interactions.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*6hVzDzADLAICMUbMQwukeA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://ioannisanif.medium.com/?source=post_page---byline--163efeb1d0d9--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ioannis Anifantakis\" src=\"https://miro.medium.com/v2/resize:fill:88:88/2*2hbIkl_9zix1pLi8u9osuQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--163efeb1d0d9--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"50bf\"\u003eManaging UI state in Android apps often involves a delicate balance: Compose’s built-in state (\u003ccode\u003emutableStateOf\u003c/code\u003e) makes it incredibly easy to keep your UI updated, while Kotlin’s \u003ccode\u003eStateFlow\u003c/code\u003e offers powerful, testable, and thread-safe reactive data streams. The challenge arises when you try to combine these approaches. While it’s simple to drop \u003ccode\u003ecollectAsStateWithLifecycle()\u003c/code\u003e calls into your composables, you end up repeating code and sprinkling collection logic throughout your UI layer.\u003c/p\u003e\u003cp id=\"b15e\"\u003eIn this article, we’ll show you a step-by-step method to leverage both Compose’s ergonomic property delegation and StateFlow’s reactive capabilities. We’ll start simple, then scale up to more complex scenarios, all while ensuring our composables remain focused on rendering and not on state management details.\u003c/p\u003e\u003ch2 id=\"98e4\"\u003eStarting Simple: Compose’s Built-In State\u003c/h2\u003e\u003cp id=\"f517\"\u003eConsider a basic \u003ccode\u003eViewModel\u003c/code\u003e controlling a splash screen:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1cae\"\u003edata class MainState(\u003cbr/\u003e    val showSplash: Boolean = false\u003cbr/\u003e)\u003cp\u003eclass MainViewModel : ViewModel() {\u003cbr/\u003e    var state by mutableStateOf(MainState())\u003cbr/\u003e        private set\u003c/p\u003e\u003cp\u003e    init {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            // Show splash for a couple of seconds\u003cbr/\u003e            state = state.copy(showSplash = true)\u003cbr/\u003e            delay(2000L)\u003cbr/\u003e            state = state.copy(showSplash = false)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e190\"\u003eIn your UI, this is straightforward:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f1a3\"\u003e@Composable\u003cbr/\u003efun MainScreen(viewModel: MainViewModel = viewModel()) {\u003cbr/\u003e    val state = viewModel.state\u003cp\u003e    if (state.showSplash) {\u003cbr/\u003e        SplashScreen()\u003cbr/\u003e    } else {\u003cbr/\u003e        MainContent()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bf57\"\u003eHere, it feels natural: the composable just reads \u003ccode\u003eviewModel.state\u003c/code\u003e. Compose takes care of recomposing when \u003ccode\u003estate\u003c/code\u003e changes—no extra hoops to jump through.\u003c/p\u003e\u003ch2 id=\"6f26\"\u003eIntroducing StateFlow for More Complex Logic\u003c/h2\u003e\u003cp id=\"3350\"\u003eAs your app grows, you may need reactive streams that are testable, concurrent-safe, and easily combined. StateFlow excels here:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ccc7\"\u003eclass MainViewModel : ViewModel() {\u003cbr/\u003e    private val _state = MutableStateFlow(MainState())\u003cbr/\u003e    val state: StateFlow\u0026lt;MainState\u0026gt; = _state\u003cp\u003e    init {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            _state.update { it.copy(showSplash = true) }\u003cbr/\u003e            delay(2000L)\u003cbr/\u003e            _state.update { it.copy(showSplash = false) }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3393\"\u003eIn your composable, collecting this StateFlow is still simple:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b66c\"\u003e@Composable\u003cbr/\u003efun MainScreen(viewModel: MainViewModel = viewModel()) {\u003cbr/\u003e    val state = viewModel.state.collectAsStateWithLifecycle().value\u003cp\u003e    if (state.showSplash) {\u003cbr/\u003e        SplashScreen()\u003cbr/\u003e    } else {\u003cbr/\u003e        MainContent()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4026\"\u003eThis works fine but adds a minor annoyance: every place you consume this StateFlow, you have to remember to use \u003ccode\u003ecollectAsStateWithLifecycle()\u003c/code\u003e. The UI code now contains logic to convert flows into Compose state. While not a deal-breaker, this pattern can start feeling repetitive as you scale up and handle more complex states or multiple flows.\u003c/p\u003e\u003ch2 id=\"b31f\"\u003eA More Declarative Approach: \u003ccode\u003etoComposeState()\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"605b\"\u003eWhat if you could keep StateFlow in the ViewModel (for all its benefits) while maintaining the simple \u003ccode\u003eval state by ...\u003c/code\u003e pattern in the UI? The answer is a small extension function that moves the “collection” step out of the composable and into the ViewModel layer:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f700\"\u003efun \u0026lt;T\u0026gt; StateFlow\u0026lt;T\u0026gt;.toComposeState(scope: CoroutineScope): State\u0026lt;T\u0026gt; {\u003cbr/\u003e    val composeState = mutableStateOf(value)\u003cbr/\u003e    scope.launch {\u003cbr/\u003e        this@toComposeState.collect { newValue -\u0026gt;\u003cbr/\u003e            composeState.value = newValue\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    return composeState\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"169f\"\u003eNow, you can use it in your ViewModel:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dd56\"\u003eclass MainViewModel : ViewModel() {\u003cbr/\u003e    private val _state = MutableStateFlow(MainState())\u003cbr/\u003e    val state by _state.toComposeState(viewModelScope)\u003cp\u003e    init {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            _state.update { it.copy(showSplash = true) }\u003cbr/\u003e            delay(2000L)\u003cbr/\u003e            _state.update { it.copy(showSplash = false) }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d7ce\"\u003eIn the composable:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"233d\"\u003e@Composable\u003cbr/\u003efun MainScreen(viewModel: MainViewModel = viewModel()) {\u003cbr/\u003e    val state = viewModel.state\u003cbr/\u003e    if (state.showSplash) {\u003cbr/\u003e        SplashScreen()\u003cbr/\u003e    } else {\u003cbr/\u003e        MainContent()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b0e7\"\u003e\u003cstrong\u003eWhat’s the gain here?\u003c/strong\u003e You’ve removed boilerplate from the UI. Instead of repeatedly calling \u003ccode\u003ecollectAsStateWithLifecycle()\u003c/code\u003e in every composable that needs the state, the ViewModel directly provides a \u003ccode\u003eState\u0026lt;T\u0026gt;\u003c/code\u003e. The UI remains as simple as if you were using \u003ccode\u003emutableStateOf\u003c/code\u003e, but under the hood, you still leverage StateFlow’s advanced features.\u003c/p\u003e\u003cp id=\"d85c\"\u003eThis might seem like a small win, but as your app grows, keeping state conversion centralized in the ViewModel (or a shared layer) is more maintainable than spreading Flow-to-Compose logic across multiple composables.\u003c/p\u003e\u003ch2 id=\"2224\"\u003eScaling Up: Combining Multiple Flows\u003c/h2\u003e\u003cp id=\"0187\"\u003eReal apps rarely have just one piece of state. Consider a scenario like a clock alarm app “Snoozeloo” where:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9136\"\u003e\u003ccode\u003e_baseAlarmState\u003c/code\u003e is a StateFlow of the current alarm configuration.\u003c/li\u003e\u003cli id=\"0eee\"\u003e\u003ccode\u003eminuteTicker\u003c/code\u003e is another StateFlow that emits updates every minute.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3003\"\u003eYou can combine these flows, filter them, and still present them as a single \u003ccode\u003eState\u003c/code\u003e to your UI:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cd6f\"\u003eval alarmUiState = combine(\u003cbr/\u003e    _baseAlarmState,\u003cbr/\u003e    minuteTicker\u003cbr/\u003e) { currentAlarm, _ -\u0026gt;\u003cbr/\u003e    currentAlarm?.let { alarm -\u0026gt;\u003cbr/\u003e        val timeUntilNextAlarm = calculateTimeUntilNextAlarm(alarm.hour, alarm.minute, alarm.selectedDays)\u003cbr/\u003e        AlarmUiState(\u003cbr/\u003e            alarm = alarm,\u003cbr/\u003e            timeUntilNextAlarm = UiText.StringResource(timeUntilNextAlarm.formatTimeUntil()),\u003cbr/\u003e            hasChanges = originalAlarm?.let { it != alarm || alarm.isNewAlarm } ?: false\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003cbr/\u003e.filterNotNull()\u003cbr/\u003e.filter { state -\u0026gt; true } // Additional filtering if needed\u003cbr/\u003e.stateIn(\u003cbr/\u003e    scope = viewModelScope,\u003cbr/\u003e    started = SharingStarted.WhileSubscribed(5000),\u003cbr/\u003e    initialValue = null\u003cbr/\u003e)\u003cbr/\u003e.toComposeState(viewModelScope)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"afd7\"\u003eYour UI now receives a fully combined, filtered, and prepared state without knowing anything about how these flows are wired up:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e1e3\"\u003e@Composable\u003cbr/\u003efun AlarmScreen(viewModel: AlarmViewModel = viewModel()) {\u003cbr/\u003e    val state = viewModel.alarmUiState\u003cp\u003e    state?.let {\u003cbr/\u003e        // The UI automatically updates whenever state changes,\u003cbr/\u003e        // no manual collecting needed.\u003cbr/\u003e        ShowAlarmDetails(it)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3669\"\u003eBy front-loading complexity into a single, reusable layer, you ensure that no matter how intricate your data sources get, your composables remain as simple as accessing a \u003ccode\u003eval state\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"792f\"\u003eWhy Not Just Use \u003ccode\u003ecollectAsStateWithLifecycle()\u003c/code\u003e Everywhere?\u003c/h2\u003e\u003cp id=\"b221\"\u003e\u003ccode\u003ecollectAsStateWithLifecycle()\u003c/code\u003e works perfectly for many scenarios. If your codebase is small or you’re comfortable with sprinkling collection logic in your UI, it may be enough.\u003c/p\u003e\u003cp id=\"70aa\"\u003eBut as your application scales, so does repetition. Each time you introduce a new \u003ccode\u003eStateFlow\u003c/code\u003e, every composable using it must contain the same collection logic. With \u003ccode\u003etoComposeState()\u003c/code\u003e, you establish a single pattern that:\u003c/p\u003e\u003cul\u003e\u003cli id=\"8cbd\"\u003eKeeps the UI declarative and focused solely on rendering.\u003c/li\u003e\u003cli id=\"0f60\"\u003eCentralizes Flow-to-Compose conversion in the ViewModel or another shared layer.\u003c/li\u003e\u003cli id=\"d481\"\u003eMakes complex transformations invisible to the UI, so you can pivot and refine data logic without touching your UI code.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"29fd\"\u003eIn larger apps or when multiple StateFlows and combinations are involved, this pattern leads to cleaner architecture, reduces boilerplate, and improves maintainability.\u003c/p\u003e\u003ch2 id=\"232b\"\u003eWhen to Use This Approach\u003c/h2\u003e\u003cul\u003e\u003cli id=\"a691\"\u003e\u003cstrong\u003eStart Simple:\u003c/strong\u003e If a single \u003ccode\u003emutableStateOf\u003c/code\u003e suffices, stick with it. Simplicity first.\u003c/li\u003e\u003cli id=\"7bf7\"\u003e\u003cstrong\u003ePower Up with StateFlow:\u003c/strong\u003e When you need testability, concurrency, or multiple combined data sources, StateFlow is a natural fit.\u003c/li\u003e\u003cli id=\"2c27\"\u003e\u003cstrong\u003eKeep UI Code Clean:\u003c/strong\u003e If you don’t want repetitive \u003ccode\u003ecollectAsStateWithLifecycle()\u003c/code\u003e calls scattered in your UI, \u003ccode\u003etoComposeState()\u003c/code\u003e gives you a direct \u003ccode\u003eState\u0026lt;T\u0026gt;\u003c/code\u003e to consume, just like Compose’s built-in state.\u003c/li\u003e\u003cli id=\"686e\"\u003e\u003cstrong\u003eScale Gracefully:\u003c/strong\u003e As complexity grows, having a consistent pattern for Flow-to-Compose integration pays off. Your UI stays clean and maintainable, no matter how sophisticated your data pipelines become.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f09d\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"f4a7\"\u003eIntegrating \u003ccode\u003eStateFlow\u003c/code\u003e with Jetpack Compose doesn’t have to come at the cost of simplicity. By introducing a small extension function, you bring together the best of both worlds: StateFlow’s reactive power and Compose’s ergonomic state model.\u003c/p\u003e\u003cp id=\"b427\"\u003eThis approach lets you start small and then scale up complexity without burdening your composables. With \u003ccode\u003etoComposeState()\u003c/code\u003e, you keep your UI code neat, your architecture cleaner, and your state management more maintainable—even as your app logic evolves into richer, more dynamic interactions.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2024-12-06T09:23:22.97Z",
  "modifiedTime": null
}
