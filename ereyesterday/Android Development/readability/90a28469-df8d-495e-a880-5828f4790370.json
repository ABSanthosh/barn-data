{
  "id": "90a28469-df8d-495e-a880-5828f4790370",
  "title": "Modularizing with Intent: Finding the Right Module Naming Convention",
  "link": "https://chrynan.codes/modularizing-with-intent-finding-the-right-module-naming-convention/",
  "description": "Kotlin module naming convention: [group-]domain-layer[-contexts]. Flat, flexible, KMP-friendly—read on!",
  "author": "Chris Keenan",
  "published": "Wed, 19 Mar 2025 16:05:10 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "kotlin",
    "gradle",
    "module",
    "naming",
    "convention",
    "conventions",
    "kmp",
    "structure",
    "organization",
    "code"
  ],
  "byline": "Chris Keenan",
  "length": 2786,
  "excerpt": "Kotlin module naming convention: [group-]domain-layer[-contexts]. Flat, flexible, KMP-friendly—read on!",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "Kotlin module naming convention: [group-]domain-layer[-contexts]. Flat, flexible, KMP-friendly—read on! Naming modules is a recurring puzzle I face in my coding journey. As my projects expand, I naturally split them into feature modules—neatly separated by purpose, encapsulated, and easy to test and understand. But the challenge always creeps up: what’s the best way to name and group them? Should I organize by domain? Split UI from APIs and databases? How granular should I get? And how do I avoid duplicating code while sharing it across features? These questions drove me to craft a naming convention that’s become my go-to. It’s a flexible approach—[group-]domain-layer[-contexts]—designed to group related components intuitively and streamline code sharing, and I’m working to make it a consistent habit in my projects.TLDRThis convention keeps my projects organized and scalable. It groups features (e.g., feature-support-ui), centers on domains (e.g., support), and supports shared code (e.g., -shared, -client, -server). Benefits: clear grouping, KMP-friendly, flat structure, and flexibility.The Convention[group-]domain-layer[-contexts]Imagine a flat module list that’s easy to scan, groups related functionality, and works seamlessly with Kotlin Multiplatform (KMP). Here’s how it breaks down:Group (optional): A prefix like feature- to cluster related modules (e.g., user-facing features).Domain: The core focus—what the module serves (e.g., support, settings, auth).Layer: Its role in the stack (e.g., ui, api, data).Contexts (optional): Zero, one, or more variation suffixes for \"sharedness\" or specifics (e.g., -shared, -client, -server).ExamplesExamples from a typical project might look like:feature-support-ui: Ticket submission UI.feature-support-api-shared: Shared API models for tickets.feature-support-api-client: Client-side API calls.feature-support-api-server: Server-side ticket handling.feature-settings-ui: Settings screen UI.data-core: Core and shared data logic.app-shared: The shared application module.app-android: The Android application module.In settings.gradle.kts, it’s a clean list:include( \":feature-support-ui\", \":feature-support-api-shared\", \":feature-support-api-client\", \":feature-support-api-server\", \":feature-settings-ui\", \":data-core\", \":app-shared\", \":app-android\" )Try It OutGive it a try in your next Kotlin multiplatform project. The standard is not set in stone, but I have been shaping it over time and gravitating towards this approach for awhile. It gives my projects some consistency and I think it makes the code easy to understand at a quick glance. Let me know what you think and if you have any ideas for refinements!",
  "image": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2025/03/img-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"site-main\"\u003e\n\u003carticle\u003e\n\n    \u003cheader\u003e\n\n        \n\n        \n\n            \u003cp\u003eKotlin module naming convention: [group-]domain-layer[-contexts]. Flat, flexible, KMP-friendly—read on!\u003c/p\u003e\n\n        \n\n            \u003cfigure\u003e\n                \u003cimg srcset=\"https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w300/2025/03/img-2.png 300w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w600/2025/03/img-2.png 600w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w1000/2025/03/img-2.png 1000w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2025/03/img-2.png 2000w\" sizes=\"(min-width: 1400px) 1400px, 92vw\" src=\"https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2025/03/img-2.png\" alt=\"Modularizing with Intent: Finding the Right Module Naming Convention\"/\u003e\n            \u003c/figure\u003e\n\n    \u003c/header\u003e\n\n    \u003csection\u003e\n        \u003cp\u003eNaming modules is a recurring puzzle I face in my coding journey. As my projects expand, I naturally split them into feature modules—neatly separated by purpose, encapsulated, and easy to test and understand. But the challenge always creeps up: what’s the best way to name and group them? Should I organize by domain? Split UI from APIs and databases? How granular should I get? And how do I avoid duplicating code while sharing it across features? These questions drove me to craft a naming convention that’s become my go-to. It’s a flexible approach—\u003ccode\u003e[group-]domain-layer[-contexts]\u003c/code\u003e—designed to group related components intuitively and streamline code sharing, and I’m working to make it a consistent habit in my projects.\u003c/p\u003e\u003ch2 id=\"tldr\"\u003eTLDR\u003c/h2\u003e\u003cp\u003eThis convention keeps my projects organized and scalable. It groups features (e.g., feature-support-ui), centers on domains (e.g., support), and supports shared code (e.g., -shared, -client, -server). Benefits: clear grouping, KMP-friendly, flat structure, and flexibility.\u003c/p\u003e\u003ch2 id=\"the-convention\"\u003eThe Convention\u003c/h2\u003e\u003cp\u003e\u003ccode\u003e[group-]domain-layer[-contexts]\u003c/code\u003e\u003c/p\u003e\u003cp\u003eImagine a flat module list that’s easy to scan, groups related functionality, and works seamlessly with Kotlin Multiplatform (KMP). Here’s how it breaks down:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eGroup\u003c/strong\u003e (optional): A prefix like \u003cstrong\u003efeature-\u003c/strong\u003e to cluster related modules (e.g., user-facing features).\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eDomain\u003c/strong\u003e: The core focus—what the module serves (e.g., \u003ccode\u003esupport\u003c/code\u003e, \u003ccode\u003esettings\u003c/code\u003e, \u003ccode\u003eauth\u003c/code\u003e).\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLayer\u003c/strong\u003e: Its role in the stack (e.g., \u003ccode\u003eui\u003c/code\u003e, \u003ccode\u003eapi\u003c/code\u003e, \u003ccode\u003edata\u003c/code\u003e).\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eContexts\u003c/strong\u003e (optional): Zero, one, or more variation suffixes for \u0026#34;sharedness\u0026#34; or specifics (e.g., \u003ccode\u003e-shared\u003c/code\u003e, \u003ccode\u003e-client\u003c/code\u003e, \u003ccode\u003e-server\u003c/code\u003e).\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"examples\"\u003eExamples\u003c/h2\u003e\u003cp\u003eExamples from a typical project might look like:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003efeature-support-ui\u003c/code\u003e: Ticket submission UI.\u003c/li\u003e\u003cli\u003e\u003ccode\u003efeature-support-api-shared\u003c/code\u003e: Shared API models for tickets.\u003c/li\u003e\u003cli\u003e\u003ccode\u003efeature-support-api-client\u003c/code\u003e: Client-side API calls.\u003c/li\u003e\u003cli\u003e\u003ccode\u003efeature-support-api-server\u003c/code\u003e: Server-side ticket handling.\u003c/li\u003e\u003cli\u003e\u003ccode\u003efeature-settings-ui\u003c/code\u003e: Settings screen UI.\u003c/li\u003e\u003cli\u003e\u003ccode\u003edata-core\u003c/code\u003e: Core and shared data logic.\u003c/li\u003e\u003cli\u003e\u003ccode\u003eapp-shared\u003c/code\u003e: The shared application module.\u003c/li\u003e\u003cli\u003e\u003ccode\u003eapp-android\u003c/code\u003e: The Android application module.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIn \u003ccode\u003esettings.gradle.kts\u003c/code\u003e, it’s a clean list:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003einclude(\n    \u0026#34;:feature-support-ui\u0026#34;,\n    \u0026#34;:feature-support-api-shared\u0026#34;,\n    \u0026#34;:feature-support-api-client\u0026#34;,\n    \u0026#34;:feature-support-api-server\u0026#34;,\n    \u0026#34;:feature-settings-ui\u0026#34;,\n    \u0026#34;:data-core\u0026#34;,\n    \u0026#34;:app-shared\u0026#34;,\n    \u0026#34;:app-android\u0026#34;\n)\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"try-it-out\"\u003eTry It Out\u003c/h2\u003e\u003cp\u003eGive it a try in your next Kotlin multiplatform project. The standard is not set in stone, but I have been shaping it over time and gravitating towards this approach for awhile. It gives my projects some consistency and I think it makes the code easy to understand at a quick glance. Let me know what you think and if you have any ideas for refinements!\u003c/p\u003e\n    \u003c/section\u003e\n\n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-03-19T16:05:10Z",
  "modifiedTime": "2025-03-19T16:05:10Z"
}
