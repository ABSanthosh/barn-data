{
  "id": "d20f7467-53a2-4790-9380-13b2ab42d50b",
  "title": "Understanding Execution Order in Jetpack Compose: DisposableEffect, LaunchedEffect, and Composables.",
  "link": "https://proandroiddev.com/understanding-execution-order-in-jetpack-compose-disposableeffect-launchedeffect-and-composables-d2d0b75b7ec8?source=rss----c72404660798---4",
  "description": "",
  "author": "Sahil Thakar",
  "published": "Sun, 13 Apr 2025 15:12:16 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "jetpack-compose",
    "android",
    "ios-app-development",
    "mobile-app-development"
  ],
  "byline": "Sahil Thakar",
  "length": 7673,
  "excerpt": "Here we are again with a small topic of Jetpack-Compose. It is also a small but necessary one for new or experienced devs. We are going to talk about the execution order of Jetpack Compose side…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Hello Folks,Here we are again with a small topic of Jetpack-Compose. It is also a small but necessary one for new or experienced devs. We are going to talk about the execution order of Jetpack Compose side effects and composables, specifically focusing on the execution order and lifecycle interactions of DisposableEffect, LaunchedEffect, and composable functions.We’ll take a closer look at how DisposableEffect and LaunchedEffect are executed when navigating between composables, especially focusing on their behavior when returning to a previously visited screen. (Many experience devs will tell I know that but I bet you many of you don’t).So, let’s jump in.@Composablefun MyComposable(cartId: String) { val lifecycleOwner = LocalLifecycleOwner.current // DisposableEffect observes the lifecycleOwner DisposableEffect(lifecycleOwner) { Log.e(\"Init\", \"DisposableEffect\") onDispose { Log.e(\"Init\", \"DisposableEffect - onDispose\") } } // LaunchedEffect triggers when cartId changes LaunchedEffect(key1 = cartId) { Log.e(\"Init\", \"LaunchedEffect\") } // Scaffold is the UI container Column { Log.e(\"Init\", \"Column\") // You can add your screen content here }}Output:-E/Init: ColumnE/Init: DisposableEffectE/Init: LaunchedEffectExecution Order:-Why does Column log first?The answer lies in when these side-effect APIs (DisposableEffect, LaunchedEffect) are actually executed relative to composition.1. Composition Phase Comes FirstJetpack Compose first builds the UI tree during composition.At this point, Column is a composable function. It is executed immediately during the composition phase to build the UI.So: Column() runs first → logs “Column”.2. Side-Effects Are Registered During Composition But Executed AfterDisposableEffect and LaunchedEffect register their work during composition, but their actual execution happens after the composition finishes.Compose uses an internal scheduler (via Recomposer) to run side effects after the frame is committed.So, the real timeline looks like this:Composition starts → Column() runs → logs \"Column\" → Registers DisposableEffect block → Registers LaunchedEffect blockComposition ends→ Side effects start → DisposableEffect executes → logs \"DisposableEffect\" → LaunchedEffect launches coroutine → logs \"LaunchedEffect\"But here, we have talked about the Execution order between composable and Side-Effects.But what about the SideEffects which execute first between LaunchEffect and DisposableEffect .Let’s look into that.Order of Execution (After Composition Completes):DisposableEffect → runs firstLaunchedEffect → runs afterWhy?This order is defined by the Compose runtime itself:DisposableEffect is synchronous and meant to handle setup/cleanup immediately after composition.LaunchedEffect starts a coroutine, and coroutine launching is asynchronous, scheduled to run after other synchronous effects like DisposableEffect.Internally:Jetpack Compose maintains a well-defined order of applying effects:Side effects like DisposableEffect, SideEffect, SnapshotFlow, etc., are triggered immediately after composition (synchronously).Then coroutine-based effects like LaunchedEffect are dispatched to run next (asynchronously, via Recomposer).Now, Let’s see how DisposableEffect and LaunchedEffect are executed when navigating between composables, especially focusing on their behavior when returning to a previously visited screen.Output is going to surprise you.@Composablefun MyApp() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \"screenA\") { composable(\"screenA\") { ScreenA( cartId = \"123\", onNavigateToB = { navController.navigate(\"screenB\") } ) } composable(\"screenB\") { ScreenB( cartId = \"456\", onNavigateBack = { navController.popBackStack() } ) } }}@Composablefun ScreenA(cartId: String, onNavigateToB: () -\u003e Unit) { DisposableEffect(Unit) { println(\"😇 ScreenA -\u003e DisposableEffect\") onDispose { println(\"😇 ScreenA -\u003e DisposableEffect - onDispose\") } } LaunchedEffect(cartId) { println(\"😇ScreenA -\u003e LaunchedEffect\") } Column(modifier = Modifier.padding(top = 100.dp)) { Button(onClick = onNavigateToB) { Text(text = \"Navigate To ScreenB\") } }}@Composablefun ScreenB(cartId: String, onNavigateBack: () -\u003e Unit) { val lifecycleOwner = LocalLifecycleOwner.current DisposableEffect(lifecycleOwner) { println(\"😇 ScreenB -\u003e DisposableEffect\") onDispose { println(\"😇 ScreenB -\u003e DisposableEffect - onDispose\") } } LaunchedEffect(cartId) { println(\"😇 ScreenB -\u003e LaunchedEffect\") } Column{ Column(modifier = Modifier) { Button(onClick = onNavigateBack) { Text(\"Back to Screen A\") } } }}Output:- when ScreenA init😇 ScreenA -\u003e DisposableEffect😇 ScreenA -\u003e LaunchedEffectNavigate To ScreenA -\u003e ScreenB😇 ScreenB -\u003e DisposableEffect😇 ScreenB -\u003e LaunchedEffect😇 ScreenA -\u003e DisposableEffect - onDisposeNavigate back to ScreenB -\u003e ScreenA😇 ScreenA -\u003e DisposableEffect😇 ScreenA -\u003e LaunchedEffect😇 ScreenB -\u003e DisposableEffect - onDisposeWhat Actually Happens Internally (Jetpack Compose Navigation)?Compose Navigation’s behavior around composables in a NavHost follows this logic:1. Composition of the new destination (ScreenA here) happens first.Compose immediately creates the UI for the new screen upon navigation.DisposableEffect and LaunchedEffect of the new screen (ScreenA) immediately execute during or right after this new composition.2. Disposal of the previous screen’s composable (ScreenB) happens after the new destination is successfully composed and committed to the UI hierarchy.Compose keeps the previous composable (ScreenB) briefly active until the new one (ScreenA) is stable, ensuring smooth navigation.Only once the new composable (ScreenA) is fully composed does Compose clean up and remove (dispose) the previous composable (ScreenB).Thus, the real-world lifecycle flow during navigation is:Navigate back (ScreenB → ScreenA)│├── 1️⃣ Compose immediately creates ScreenA│ ├─ ScreenA DisposableEffect executes instantly.│ └─ ScreenA LaunchedEffect coroutine launched.│└── 2️⃣ After successfully stabilizing ScreenA: └─ ScreenB DisposableEffect onDispose runs.Why Does Compose Do It This Way?Compose Navigation handles screens carefully to ensure seamless user experience and stability:It doesn’t prematurely dispose of the previous composable (ScreenB) before ensuring that the destination (ScreenA) is composed and ready.This avoids visual glitches or blank screens during transitions.Only after ensuring the new screen is safely in place does Compose trigger disposal of previous screen.Internal Jetpack Compose NavHost Mechanics (Simplified):Internally, Compose’s NavHost works like this when calling popBackStack() or navigate():New route composition begins (Composable creation).After successful composition and frame commit, old composable nodes that are no longer in the NavHost’s backstack are marked for disposal.Compose then runs disposal logic (onDispose) of these removed composables in the next frame.Thus, even though you visually navigate back immediately, disposal operations (onDispose) are slightly deferred for UI stability.If you have any questions, just drop a comment, and I’ll get back to you ASAP. 💬✨We’ll be diving deeper into Jetpack Compose soon, so stay tuned! 🚀Until then, happy coding! 🎉👨‍💻",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*44_HTD27S8k-mxkIc_A9zg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://codeint.medium.com/?source=post_page---byline--d2d0b75b7ec8---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Sahil Thakar\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*KdqqwZdYVTnxCt2BVb2eqQ.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--d2d0b75b7ec8---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"975a\"\u003eHello Folks,\u003c/p\u003e\u003cp id=\"f9fa\"\u003eHere we are again with a small topic of Jetpack-Compose. It is also a small but necessary one for new or experienced devs. We are going to talk about the execution order of Jetpack Compose side effects and composables, specifically focusing on the execution order and lifecycle interactions of \u003ccode\u003eDisposableEffect\u003c/code\u003e, \u003ccode\u003eLaunchedEffect\u003c/code\u003e, and composable functions.\u003c/p\u003e\u003cp id=\"33c2\"\u003eWe’ll take a closer look at how \u003ccode\u003eDisposableEffect\u003c/code\u003e and \u003ccode\u003eLaunchedEffect\u003c/code\u003e are executed when navigating between composables, especially focusing on their behavior when returning to a previously visited screen. (Many experience devs will tell I know that but I bet you many of you don’t).\u003c/p\u003e\u003cp id=\"8510\"\u003eSo, let’s jump in.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e6eb\"\u003e@Composable\u003cbr/\u003efun MyComposable(cartId: String) {\u003cbr/\u003e    val lifecycleOwner = LocalLifecycleOwner.current\u003cp\u003e    // DisposableEffect observes the lifecycleOwner\u003cbr/\u003e    DisposableEffect(lifecycleOwner) {\u003cbr/\u003e        Log.e(\u0026#34;Init\u0026#34;, \u0026#34;DisposableEffect\u0026#34;)\u003c/p\u003e\u003cp\u003e        onDispose {\u003cbr/\u003e            Log.e(\u0026#34;Init\u0026#34;, \u0026#34;DisposableEffect - onDispose\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // LaunchedEffect triggers when cartId changes\u003cbr/\u003e    LaunchedEffect(key1 = cartId) {\u003cbr/\u003e        Log.e(\u0026#34;Init\u0026#34;, \u0026#34;LaunchedEffect\u0026#34;)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // Scaffold is the UI container\u003cbr/\u003e    Column {\u003cbr/\u003e        Log.e(\u0026#34;Init\u0026#34;, \u0026#34;Column\u0026#34;)\u003cbr/\u003e        // You can add your screen content here\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eOutput:-\u003c/p\u003e\u003cp\u003eE/Init: Column\u003cbr/\u003eE/Init: DisposableEffect\u003cbr/\u003eE/Init: LaunchedEffect\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"506b\"\u003eExecution Order:-\u003c/h2\u003e\u003ch2 id=\"466e\"\u003e\u003cstrong\u003eWhy does \u003c/strong\u003eColumn\u003cstrong\u003e log first?\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"eb13\"\u003eThe answer lies in \u003cstrong\u003ewhen these side-effect APIs (DisposableEffect, LaunchedEffect) are actually executed relative to composition.\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"e773\"\u003e\u003cstrong\u003e1. Composition Phase Comes First\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"9ffc\"\u003eJetpack Compose first \u003cstrong\u003ebuilds the UI tree\u003c/strong\u003e during composition.\u003c/li\u003e\u003cli id=\"0038\"\u003eAt this point, Column is a \u003cstrong\u003ecomposable function.\u003c/strong\u003e It is \u003cstrong\u003eexecuted immediately\u003c/strong\u003e during the composition phase to build the UI.\u003c/li\u003e\u003cli id=\"78a3\"\u003eSo: Column() runs \u003cstrong\u003efirst\u003c/strong\u003e → logs “Column”.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"373f\"\u003e\u003cstrong\u003e2. Side-Effects Are Registered During Composition But Executed After\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"bc5a\"\u003eDisposableEffect and LaunchedEffect \u003cstrong\u003eregister\u003c/strong\u003e their work during composition, but their actual \u003cstrong\u003eexecution happens after the composition\u003c/strong\u003e finishes.\u003c/li\u003e\u003cli id=\"4b96\"\u003eCompose uses an internal scheduler (via Recomposer) to \u003cstrong\u003erun side effects after the frame is committed\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4359\"\u003e\u003cstrong\u003eSo, the real timeline looks like this:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"be91\"\u003eComposition starts\u003cbr/\u003e   → Column() runs → logs \u0026#34;Column\u0026#34;\u003cbr/\u003e   → Registers DisposableEffect block\u003cbr/\u003e   → Registers LaunchedEffect block\u003cbr/\u003eComposition ends\u003cbr/\u003e→ Side effects start\u003cbr/\u003e   → DisposableEffect executes → logs \u0026#34;DisposableEffect\u0026#34;\u003cbr/\u003e   → LaunchedEffect launches coroutine → logs \u0026#34;LaunchedEffect\u0026#34;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bd07\"\u003eBut here, we have talked about the Execution order between composable and Side-Effects.\u003c/p\u003e\u003cp id=\"ebae\"\u003eBut what about the SideEffects which execute first between \u003ccode\u003eLaunchEffect\u003c/code\u003e and \u003ccode\u003eDisposableEffect\u003c/code\u003e .\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"b3ec\"\u003eLet’s look into that.\u003c/p\u003e\u003cp id=\"6f48\"\u003e\u003cstrong\u003eOrder of Execution (After Composition Completes):\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"9c10\"\u003eDisposableEffect → \u003cstrong\u003eruns first\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"c829\"\u003eLaunchedEffect → \u003cstrong\u003eruns after\u003c/strong\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"fffd\"\u003e\u003cstrong\u003eWhy?\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"7a80\"\u003e\u003cstrong\u003eThis order is defined by the Compose runtime itself:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"1cbd\"\u003e\u003cstrong\u003eDisposableEffect\u003c/strong\u003e is \u003cstrong\u003esynchronous\u003c/strong\u003e and meant to handle setup/cleanup \u003cstrong\u003eimmediately\u003c/strong\u003e after composition.\u003c/li\u003e\u003cli id=\"5553\"\u003e\u003cstrong\u003eLaunchedEffect\u003c/strong\u003e starts a \u003cstrong\u003ecoroutine\u003c/strong\u003e, and coroutine launching is \u003cstrong\u003easynchronous\u003c/strong\u003e, scheduled to run \u003cstrong\u003eafter\u003c/strong\u003e other synchronous effects like DisposableEffect.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ad0b\"\u003e\u003cstrong\u003eInternally:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"d6c1\"\u003eJetpack Compose maintains a well-defined order of applying effects:\u003c/p\u003e\u003col\u003e\u003cli id=\"6661\"\u003e\u003cstrong\u003eSide effects like DisposableEffect, SideEffect, SnapshotFlow, etc.,\u003c/strong\u003e are triggered \u003cstrong\u003eimmediately after composition\u003c/strong\u003e (synchronously).\u003c/li\u003e\u003cli id=\"0436\"\u003e\u003cstrong\u003eThen coroutine-based effects like LaunchedEffect\u003c/strong\u003e are dispatched to run next (asynchronously, via Recomposer).\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"7e1c\"\u003eNow, Let’s see how \u003ccode\u003eDisposableEffect\u003c/code\u003e and \u003ccode\u003eLaunchedEffect\u003c/code\u003e are executed when navigating between composables, especially focusing on their behavior when returning to a previously visited screen.\u003c/p\u003e\u003cp id=\"0780\"\u003eOutput is going to surprise you.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5964\"\u003e\u003cbr/\u003e@Composable\u003cbr/\u003efun MyApp() {\u003cbr/\u003e    val navController = rememberNavController()\u003cp\u003e    NavHost(navController = navController, startDestination = \u0026#34;screenA\u0026#34;) {\u003cbr/\u003e        composable(\u0026#34;screenA\u0026#34;) {\u003cbr/\u003e            ScreenA(\u003cbr/\u003e                cartId = \u0026#34;123\u0026#34;,\u003cbr/\u003e                onNavigateToB = { navController.navigate(\u0026#34;screenB\u0026#34;) }\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e        composable(\u0026#34;screenB\u0026#34;) {\u003cbr/\u003e            ScreenB(\u003cbr/\u003e                cartId = \u0026#34;456\u0026#34;,\u003cbr/\u003e                onNavigateBack = { navController.popBackStack() }\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun ScreenA(cartId: String, onNavigateToB: () -\u0026gt; Unit) {\u003cbr/\u003e    DisposableEffect(Unit) {\u003cbr/\u003e        println(\u0026#34;😇 ScreenA -\u0026gt; DisposableEffect\u0026#34;)\u003cbr/\u003e        onDispose {\u003cbr/\u003e            println(\u0026#34;😇 ScreenA -\u0026gt; DisposableEffect - onDispose\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    LaunchedEffect(cartId) {\u003cbr/\u003e        println(\u0026#34;😇ScreenA -\u0026gt; LaunchedEffect\u0026#34;)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    Column(modifier = Modifier.padding(top = 100.dp)) {\u003cbr/\u003e        Button(onClick = onNavigateToB) {\u003cbr/\u003e            Text(text = \u0026#34;Navigate To ScreenB\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun ScreenB(cartId: String, onNavigateBack: () -\u0026gt; Unit) {\u003cbr/\u003e    val lifecycleOwner = LocalLifecycleOwner.current\u003c/p\u003e\u003cp\u003e    DisposableEffect(lifecycleOwner) {\u003cbr/\u003e        println(\u0026#34;😇 ScreenB -\u0026gt; DisposableEffect\u0026#34;)\u003cbr/\u003e        onDispose {\u003cbr/\u003e            println(\u0026#34;😇 ScreenB -\u0026gt; DisposableEffect - onDispose\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    LaunchedEffect(cartId) {\u003cbr/\u003e        println(\u0026#34;😇 ScreenB -\u0026gt; LaunchedEffect\u0026#34;)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    Column{\u003cbr/\u003e        Column(modifier = Modifier) {\u003cbr/\u003e            Button(onClick = onNavigateBack) {\u003cbr/\u003e                Text(\u0026#34;Back to Screen A\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eOutput:- \u003c/p\u003e\u003cp\u003ewhen ScreenA init\u003cbr/\u003e😇 ScreenA -\u0026gt; DisposableEffect\u003cbr/\u003e😇 ScreenA -\u0026gt; LaunchedEffect\u003c/p\u003e\u003cp\u003eNavigate To ScreenA -\u0026gt; ScreenB\u003cbr/\u003e😇 ScreenB -\u0026gt; DisposableEffect\u003cbr/\u003e😇 ScreenB -\u0026gt; LaunchedEffect\u003cbr/\u003e😇 ScreenA -\u0026gt; DisposableEffect - onDispose\u003c/p\u003e\u003cp\u003eNavigate back to ScreenB -\u0026gt; ScreenA\u003cbr/\u003e😇 ScreenA -\u0026gt; DisposableEffect\u003cbr/\u003e😇 ScreenA -\u0026gt; LaunchedEffect\u003cbr/\u003e😇 ScreenB -\u0026gt; DisposableEffect - onDispose\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e34b\"\u003eWhat Actually Happens Internally (Jetpack Compose Navigation)?\u003c/h2\u003e\u003cp id=\"a763\"\u003eCompose Navigation’s behavior around composables in a NavHost follows this logic:\u003c/p\u003e\u003cp id=\"060f\"\u003e\u003cstrong\u003e1. Composition of the new destination\u003c/strong\u003e (ScreenA here) happens first.\u003c/p\u003e\u003cul\u003e\u003cli id=\"4936\"\u003eCompose immediately creates the UI for the new screen upon navigation.\u003c/li\u003e\u003cli id=\"80d0\"\u003e\u003cstrong\u003eDisposableEffect\u003c/strong\u003e and \u003cstrong\u003eLaunchedEffect\u003c/strong\u003e of the new screen (ScreenA) immediately execute during or right after this new composition.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5f7a\"\u003e\u003cstrong\u003e2. Disposal of the previous screen’s composable\u003c/strong\u003e (ScreenB) happens \u003cstrong\u003eafter\u003c/strong\u003e the new destination is successfully composed and committed to the UI hierarchy.\u003c/p\u003e\u003cul\u003e\u003cli id=\"f418\"\u003eCompose keeps the previous composable (ScreenB) briefly active until the new one (ScreenA) is stable, ensuring smooth navigation.\u003c/li\u003e\u003cli id=\"bb22\"\u003eOnly once the new composable (ScreenA) is fully composed does Compose clean up and remove (dispose) the previous composable (ScreenB).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"26fa\"\u003eThus, the real-world lifecycle flow during navigation is:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d80a\"\u003eNavigate back (ScreenB → ScreenA)\u003cbr/\u003e│\u003cbr/\u003e├── 1️⃣ Compose immediately creates ScreenA\u003cbr/\u003e│      ├─ ScreenA DisposableEffect executes instantly.\u003cbr/\u003e│      └─ ScreenA LaunchedEffect coroutine launched.\u003cbr/\u003e│\u003cbr/\u003e└── 2️⃣ After successfully stabilizing ScreenA:\u003cbr/\u003e       └─ ScreenB DisposableEffect onDispose runs.\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"264b\"\u003eWhy Does Compose Do It This Way?\u003c/h2\u003e\u003cp id=\"c24e\"\u003eCompose Navigation handles screens carefully to ensure \u003cstrong\u003eseamless user experience and stability\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a1f6\"\u003eIt doesn’t prematurely dispose of the previous composable (ScreenB) before ensuring that the destination (ScreenA) is composed and ready.\u003c/li\u003e\u003cli id=\"d4ec\"\u003eThis avoids visual glitches or blank screens during transitions.\u003c/li\u003e\u003cli id=\"9326\"\u003eOnly after ensuring the new screen is safely in place does Compose trigger disposal of previous screen.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"481b\"\u003eInternal Jetpack Compose NavHost Mechanics (Simplified):\u003c/h2\u003e\u003cp id=\"fedd\"\u003eInternally, Compose’s NavHost works like this when calling popBackStack() or navigate():\u003c/p\u003e\u003cul\u003e\u003cli id=\"9111\"\u003eNew route composition begins (Composable creation).\u003c/li\u003e\u003cli id=\"0b3b\"\u003eAfter successful composition and frame commit, old composable nodes that are no longer in the NavHost’s backstack are marked for disposal.\u003c/li\u003e\u003cli id=\"e512\"\u003eCompose then runs disposal logic (onDispose) of these removed composables in the next frame.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3af4\"\u003eThus, even though you visually navigate back immediately, disposal operations (onDispose) are slightly deferred for UI stability.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"d69e\"\u003eIf you have any questions, just drop a comment, and I’ll get back to you ASAP. 💬✨\u003c/p\u003e\u003cp id=\"c725\"\u003eWe’ll be diving deeper into \u003cstrong\u003eJetpack Compose\u003c/strong\u003e soon, so stay tuned! 🚀\u003c/p\u003e\u003cp id=\"08b8\"\u003eUntil then, \u003cstrong\u003ehappy coding!\u003c/strong\u003e 🎉👨‍💻\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-04-13T11:48:32.7Z",
  "modifiedTime": null
}
