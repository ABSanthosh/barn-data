{
  "id": "b98d180c-eb2e-428a-8be2-46bbfb7c6566",
  "title": "Avoid using var in the data class constructor in Kotlin â€“ now with Jetpack Compose",
  "link": "https://proandroiddev.com/avoid-using-var-in-the-data-class-constructor-in-kotlin-now-with-jetpack-compose-e0ebaf5445b6?source=rss----c72404660798---4",
  "description": "",
  "author": "Anatolii Frolov",
  "published": "Sun, 25 May 2025 09:55:31 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "kotlin",
    "android-app-development",
    "androiddev",
    "jetpack-compose"
  ],
  "byline": "Anatolii Frolov",
  "length": 8360,
  "excerpt": "In my previous articles, I showed why using var or Array in a Kotlin data class constructor leads to unexpected behavior and subtle bugs. These issues mostly relate to how equals(), hashCode(), andâ€¦",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In my previous articles, I showed why using var or Array in a Kotlin data class constructor leads to unexpected behavior and subtle bugs.These issues mostly relate to how equals(), hashCode(), and copy() behave under the hood â€” especially in collections like HashMap or HashSet.Avoid using Array in the data class constructor in KotlinAvoid using var in the data class constructor in KotlinThose problems are related to logic and data modeling, and they often appear when working with collections or comparing objects.But now, with the introduction of Jetpack Compose, thereâ€™s another important reason to avoid using var in your data class constructors:it directly affects stability analysis and recomposition behavior at runtime.In this article, weâ€™ll walk through a minimal Compose example to show how a single var can make your data class unstable, prevent skipping recompositions, and reduce performance.Youâ€™ll also see how a small change â€” replacing var with val â€” helps Compose optimize rendering and avoid unnecessary recompositions.Enabling Compose Compiler MetricsTo understand how var affects recomposition in Jetpack Compose, we need visibility into what the Compose compiler sees at build time â€” specifically, whether classes and functions are marked as stable, unstable, or skippable.The Compose compiler provides diagnostic reports that can be enabled as part of the regular build process.Relevant documentation:JetBrains: Compose Compiler MetricsAndroid Developers: Diagnose recompositions using compiler reportsWhat to enableIn your gradle.properties file:androidx.enableComposeCompilerMetrics=trueandroidx.enableComposeCompilerReports=trueIn your build.gradle.kts (module-level):tasks.withType\u003corg.jetbrains.kotlin.gradle.tasks.KotlinCompile\u003e().configureEach { val buildDirProvider = project.layout.buildDirectory compilerOptions.freeCompilerArgs.addAll( \"-P\", \"plugin:androidx.compose.compiler.plugins.kotlin:metricsDestination=\" + buildDirProvider.get().asFile.absolutePath + \"/compose_compiler\" ) compilerOptions.freeCompilerArgs.addAll( \"-P\", \"plugin:androidx.compose.compiler.plugins.kotlin:reportsDestination=\" + buildDirProvider.get().asFile.absolutePath + \"/compose_compiler\" )}After building the project, the reports will be available under:app/build/compose_compiler/The key files are:*-classes.txt: stability information for your classes*-composables.txt: skippability and recomposition classification of your Composables*-composables.csv: structured summary of Composables and their characteristicsThese reports help detect unnecessary recompositions, which can be especially costly in large or deeply nested Compose layouts.Minimal model setupLetâ€™s consider a simple Compose screen that displays a user profile card. The card shows basic information such as name, email, and marital status. Another user can view the profile and submit a rating â€” for example, as feedback or to indicate interest.To focus on stability and recomposition behavior, weâ€™ll look only at the data model and the screen state:data class UserProfile( val id: String, val name: String, val email: String, val avatarUrl: String, var isMarried: Boolean // mutable property)data class ProfileState( val profile: UserProfile, val rating: Int)This state is managed in a ViewModel and exposed to the UI via StateFlow.When the user updates the rating, only the rating field is updated â€” the profile object remains unchanged.However, because UserProfile includes a var property, the Compose compiler marks it as unstable, which directly affects how recomposition is handled.Hereâ€™s what the screen looks like in the UI:Compose compiler stability outputOnce the app is built with Compose compiler metrics enabled, we can inspect the generated stability report.The file app_debug-classes.txt clearly shows that the UserProfile class is marked as unstable. This is caused solely by the presence of a var property in the constructor:With var:As you can see:UserProfile is unstable due to var isMarriedProfileState, which contains UserProfile, is also marked as unstableAny composable that receives ProfileState as input will be treated as non-skippable by ComposeTo demonstrate this, hereâ€™s how the recomposition count looks in Layout Inspector after interacting with the rating control:Even though the UserProfile object did not change, UserCard still recomposes on every rating update â€” because Compose cannot guarantee that the value is stable and hasnâ€™t changed.Now letâ€™s replace var with val and rebuild the project.With val:data class UserProfile( val id: String, val name: String, val email: String, val avatarUrl: String, val isMarried: Boolean)The stability report now shows:UserProfile is now marked as stableProfileState becomes stable as wellThe result: Compose now treats any function using UserProfile or ProfileState as potentially skippable.And indeed, the Layout Inspector confirms that UserCard is no longer recomposed unnecessarily:Compose may skip recomposition despite instabilityEven when a data class is marked as unstable, Jetpack Compose may still skip recomposition. This behavior might seem unexpected, but it has a clear technical explanation.Compose relies on two mechanisms to decide whether a Composable needs to recompose:Stability analysis â€” performed at compile time; determines if a type is Stable or UnstableReference equality check â€” performed at runtime; compares object instances using ===When a parameter is marked as unstable, Compose disables structural equality checks.This means Compose no longer compares the contents of the object â€” it assumes the data might have changed.However, it still compares object references. If the exact same instance is passed again, recomposition may be skipped, even for an unstable type.For example:val state by viewModel.state.collectAsState()UserCard(profile = state.profile)If state.profile refers to the same UserProfile instance as before, Compose may skip recomposing UserCard.This is a runtime optimization â€” and it only works if the object is reused as-is. As soon as the object is replaced or copied, recomposition will happen, because Compose can no longer assume itâ€™s safe to skip.Why relying on this is a bad ideaThis kind of recomposition skipping is fragile:It only works if the same object reference is preservedIt breaks as soon as the model is rebuilt or copiedIt hides recomposition costs that may appear later during refactoring or feature growthIn other words:Just because recomposition doesnâ€™t happen today doesnâ€™t mean your setup is correct. The underlying instability still limits Composeâ€™s ability to optimize your UI safely.For predictable and maintainable Compose code, itâ€™s better to avoid mutable properties in the constructor and rely on stable models. This allows Compose to apply both structural and reference-based optimizations â€” reliably and by design.ConclusionUsing var in a Kotlin data class constructor has always been discouraged â€” mostly due to how it affects equals(), hashCode(), and collection behavior.With Jetpack Compose, this design choice introduces an additional concern.Mutable constructor properties make the class unstable from Composeâ€™s perspective.This limits how efficiently Compose can track changes and optimize recompositions.Although Compose may still skip recomposition in some cases â€” for example, when the same object instance is reused â€” relying on such behavior is fragile and not recommended.What to do insteadUse val in data class constructors whenever possibleKeep your UI models immutable and predictableIf mutable state is needed, declare it outside the constructorStable models allow Compose to reason about your UI more effectively and apply optimizations safely.Avoiding var in data class constructors is not just about code style â€” it's also a way to write faster, more predictable Compose UIs.You might also like:Found this useful?If this article helped you understand how var affects stability and recomposition in Jetpack Compose â€” consider leaving a clap. It helps others discover the article.If youâ€™re working with Kotlin and Compose, feel free to follow â€” more practical articles coming soon.Anatolii FrolovSenior Android DeveloperWriting honest, real-world Kotlin \u0026 Jetpack Compose insights.ðŸ“¬ Follow me on Medium",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*88Hc4uw5iKZwk8j1DO0fmg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@af2905g?source=post_page---byline--e0ebaf5445b6---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Anatolii Frolov\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*PUwz5znLfXDNlKnDndJggA.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"9939\"\u003eIn my previous articles, I showed why using \u003ccode\u003evar\u003c/code\u003e or \u003ccode\u003eArray\u003c/code\u003e in a Kotlin data class constructor leads to unexpected behavior and subtle bugs.\u003cbr/\u003eThese issues mostly relate to how \u003ccode\u003eequals()\u003c/code\u003e, \u003ccode\u003ehashCode()\u003c/code\u003e, and \u003ccode\u003ecopy()\u003c/code\u003e behave under the hood â€” especially in collections like \u003ccode\u003eHashMap\u003c/code\u003e or \u003ccode\u003eHashSet\u003c/code\u003e.\u003c/p\u003e\u003cul\u003e\u003cli id=\"feff\"\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-array-in-the-data-class-constructor-in-kotlin-ebc308e46a95\" rel=\"noopener\"\u003eAvoid using \u003c/a\u003e\u003ccode\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-array-in-the-data-class-constructor-in-kotlin-ebc308e46a95\" rel=\"noopener\"\u003eArray\u003c/a\u003e\u003c/code\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-array-in-the-data-class-constructor-in-kotlin-ebc308e46a95\" rel=\"noopener\"\u003e in the data class constructor in Kotlin\u003c/a\u003e\u003c/li\u003e\u003cli id=\"56d0\"\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-var-in-the-data-class-constructor-in-kotlin-f40cfb8e16c7\" rel=\"noopener\"\u003eAvoid using \u003c/a\u003e\u003ccode\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-var-in-the-data-class-constructor-in-kotlin-f40cfb8e16c7\" rel=\"noopener\"\u003evar\u003c/a\u003e\u003c/code\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-var-in-the-data-class-constructor-in-kotlin-f40cfb8e16c7\" rel=\"noopener\"\u003e in the data class constructor in Kotlin\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"67e0\"\u003eThose problems are related to logic and data modeling, and they often appear when working with collections or comparing objects.\u003c/p\u003e\u003cp id=\"524c\"\u003eBut now, with the introduction of Jetpack Compose, thereâ€™s another important reason to avoid using \u003ccode\u003evar\u003c/code\u003e in your data class constructors:\u003cbr/\u003eit directly affects stability analysis and recomposition behavior at runtime.\u003c/p\u003e\u003cp id=\"e45b\"\u003eIn this article, weâ€™ll walk through a minimal Compose example to show how a single \u003ccode\u003evar\u003c/code\u003e can make your data class unstable, prevent skipping recompositions, and reduce performance.\u003cbr/\u003eYouâ€™ll also see how a small change â€” replacing \u003ccode\u003evar\u003c/code\u003e with \u003ccode\u003eval\u003c/code\u003e â€” helps Compose optimize rendering and avoid unnecessary recompositions.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"464a\"\u003eEnabling Compose Compiler Metrics\u003c/h2\u003e\u003cp id=\"799e\"\u003eTo understand how \u003ccode\u003evar\u003c/code\u003e affects recomposition in Jetpack Compose, we need visibility into what the Compose compiler sees at build time â€” specifically, whether classes and functions are marked as \u003cstrong\u003estable\u003c/strong\u003e, \u003cstrong\u003eunstable\u003c/strong\u003e, or \u003cstrong\u003eskippable\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"0a6c\"\u003eThe Compose compiler provides diagnostic reports that can be enabled as part of the regular build process.\u003c/p\u003e\u003cp id=\"7549\"\u003eRelevant documentation:\u003c/p\u003e\u003cul\u003e\u003cli id=\"d95a\"\u003e\u003ca href=\"https://github.com/JetBrains/kotlin/blob/master/plugins/compose/design/compiler-metrics.md\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetBrains: Compose Compiler Metrics\u003c/a\u003e\u003c/li\u003e\u003cli id=\"c131\"\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/performance/stability/diagnose#compose-compiler\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroid Developers: Diagnose recompositions using compiler reports\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"91ce\"\u003e\u003cstrong\u003eWhat to enable\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"ccd8\"\u003eIn your \u003ccode\u003egradle.properties\u003c/code\u003e file:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9dfb\"\u003eandroidx.enableComposeCompilerMetrics=true\u003cbr/\u003eandroidx.enableComposeCompilerReports=true\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"544f\"\u003eIn your \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e (module-level):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"632f\"\u003etasks.withType\u0026lt;org.jetbrains.kotlin.gradle.tasks.KotlinCompile\u0026gt;().configureEach {\u003cbr/\u003e    val buildDirProvider = project.layout.buildDirectory\u003cp\u003e    compilerOptions.freeCompilerArgs.addAll(\u003cbr/\u003e        \u0026#34;-P\u0026#34;,\u003cbr/\u003e        \u0026#34;plugin:androidx.compose.compiler.plugins.kotlin:metricsDestination=\u0026#34; +\u003cbr/\u003e            buildDirProvider.get().asFile.absolutePath + \u0026#34;/compose_compiler\u0026#34;\u003cbr/\u003e    )\u003cbr/\u003e    compilerOptions.freeCompilerArgs.addAll(\u003cbr/\u003e        \u0026#34;-P\u0026#34;,\u003cbr/\u003e        \u0026#34;plugin:androidx.compose.compiler.plugins.kotlin:reportsDestination=\u0026#34; +\u003cbr/\u003e            buildDirProvider.get().asFile.absolutePath + \u0026#34;/compose_compiler\u0026#34;\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1259\"\u003eAfter building the project, the reports will be available under:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c59b\"\u003eapp/build/compose_compiler/\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5c10\"\u003eThe key files are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3dda\"\u003e\u003ccode\u003e*-classes.txt\u003c/code\u003e: stability information for your classes\u003c/li\u003e\u003cli id=\"f97a\"\u003e\u003ccode\u003e*-composables.txt\u003c/code\u003e: skippability and recomposition classification of your Composables\u003c/li\u003e\u003cli id=\"7ba5\"\u003e\u003ccode\u003e*-composables.csv\u003c/code\u003e: structured summary of Composables and their characteristics\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b25b\"\u003eThese reports help detect unnecessary recompositions, which can be especially costly in large or deeply nested Compose layouts.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"b29a\"\u003eMinimal model setup\u003c/h2\u003e\u003cp id=\"b6d9\"\u003eLetâ€™s consider a simple Compose screen that displays a user profile card. The card shows basic information such as name, email, and marital status. Another user can view the profile and submit a rating â€” for example, as feedback or to indicate interest.\u003c/p\u003e\u003cp id=\"6cda\"\u003eTo focus on stability and recomposition behavior, weâ€™ll look only at the data model and the screen state:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8120\"\u003edata class UserProfile(\u003cbr/\u003e    val id: String,\u003cbr/\u003e    val name: String,\u003cbr/\u003e    val email: String,\u003cbr/\u003e    val avatarUrl: String,\u003cbr/\u003e    var isMarried: Boolean // mutable property\u003cbr/\u003e)\u003cp\u003edata class ProfileState(\u003cbr/\u003e    val profile: UserProfile,\u003cbr/\u003e    val rating: Int\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a512\"\u003eThis state is managed in a \u003ccode\u003eViewModel\u003c/code\u003e and exposed to the UI via \u003ccode\u003eStateFlow\u003c/code\u003e.\u003cbr/\u003eWhen the user updates the rating, only the \u003ccode\u003erating\u003c/code\u003e field is updated â€” the \u003ccode\u003eprofile\u003c/code\u003e object remains unchanged.\u003c/p\u003e\u003cp id=\"c14d\"\u003eHowever, because \u003ccode\u003eUserProfile\u003c/code\u003e includes a \u003ccode\u003evar\u003c/code\u003e property, the Compose compiler marks it as \u003cstrong\u003eunstable\u003c/strong\u003e, which directly affects how recomposition is handled.\u003c/p\u003e\u003cp id=\"c093\"\u003eHereâ€™s what the screen looks like in the UI:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9386\"\u003eCompose compiler stability output\u003c/h2\u003e\u003cp id=\"3bf7\"\u003eOnce the app is built with Compose compiler metrics enabled, we can inspect the generated stability report.\u003c/p\u003e\u003cp id=\"a7bf\"\u003eThe file \u003ccode\u003eapp_debug-classes.txt\u003c/code\u003e clearly shows that the \u003ccode\u003eUserProfile\u003c/code\u003e class is marked as \u003ccode\u003eunstable\u003c/code\u003e. This is caused solely by the presence of a \u003ccode\u003evar\u003c/code\u003e property in the constructor:\u003c/p\u003e\u003cp id=\"4581\"\u003e\u003cstrong\u003eWith \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003evar\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"081a\"\u003eAs you can see:\u003c/p\u003e\u003cul\u003e\u003cli id=\"c211\"\u003e\u003ccode\u003eUserProfile\u003c/code\u003e is \u003ccode\u003eunstable\u003c/code\u003e due to \u003ccode\u003evar isMarried\u003c/code\u003e\u003c/li\u003e\u003cli id=\"913d\"\u003e\u003ccode\u003eProfileState\u003c/code\u003e, which contains \u003ccode\u003eUserProfile\u003c/code\u003e, is also marked as \u003ccode\u003eunstable\u003c/code\u003e\u003c/li\u003e\u003cli id=\"f7f7\"\u003eAny composable that receives \u003ccode\u003eProfileState\u003c/code\u003e as input will be treated as non-skippable by Compose\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9827\"\u003eTo demonstrate this, hereâ€™s how the recomposition count looks in Layout Inspector after interacting with the rating control:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f467\"\u003eEven though the \u003ccode\u003eUserProfile\u003c/code\u003e object did not change, \u003ccode\u003eUserCard\u003c/code\u003e still recomposes on every rating update â€” because Compose cannot guarantee that the value is stable and hasnâ€™t changed.\u003c/p\u003e\u003cp id=\"ce2c\"\u003eNow letâ€™s replace \u003ccode\u003evar\u003c/code\u003e with \u003ccode\u003eval\u003c/code\u003e and rebuild the project.\u003c/p\u003e\u003cp id=\"adfa\"\u003e\u003cstrong\u003eWith \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eval\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d3ce\"\u003edata class UserProfile(\u003cbr/\u003e    val id: String,\u003cbr/\u003e    val name: String,\u003cbr/\u003e    val email: String,\u003cbr/\u003e    val avatarUrl: String,\u003cbr/\u003e    val isMarried: Boolean\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"06cd\"\u003eThe stability report now shows:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"5feb\"\u003e\u003ccode\u003eUserProfile\u003c/code\u003e is now marked as \u003ccode\u003estable\u003c/code\u003e\u003c/li\u003e\u003cli id=\"db33\"\u003e\u003ccode\u003eProfileState\u003c/code\u003e becomes \u003ccode\u003estable\u003c/code\u003e as well\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8c89\"\u003eThe result: Compose now treats any function using \u003ccode\u003eUserProfile\u003c/code\u003e or \u003ccode\u003eProfileState\u003c/code\u003e as potentially \u003cstrong\u003eskippable\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"68aa\"\u003eAnd indeed, the Layout Inspector confirms that \u003ccode\u003eUserCard\u003c/code\u003e is no longer recomposed unnecessarily:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"df49\"\u003eCompose may skip recomposition despite instability\u003c/h2\u003e\u003cp id=\"dc9f\"\u003eEven when a data class is marked as unstable, Jetpack Compose may still skip recomposition. This behavior might seem unexpected, but it has a clear technical explanation.\u003c/p\u003e\u003cp id=\"b698\"\u003eCompose relies on two mechanisms to decide whether a Composable needs to recompose:\u003c/p\u003e\u003col\u003e\u003cli id=\"0cbd\"\u003eStability analysis â€” performed at compile time; determines if a type is \u003ccode\u003eStable\u003c/code\u003e or \u003ccode\u003eUnstable\u003c/code\u003e\u003c/li\u003e\u003cli id=\"4c4f\"\u003eReference equality check â€” performed at runtime; compares object instances using \u003ccode\u003e===\u003c/code\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"cdbe\"\u003eWhen a parameter is marked as unstable, Compose disables structural equality checks.\u003cbr/\u003eThis means Compose no longer compares the contents of the object â€” it assumes the data \u003cem\u003emight\u003c/em\u003e have changed.\u003c/p\u003e\u003cp id=\"cd6b\"\u003eHowever, it still compares object references. If the exact same instance is passed again, recomposition may be skipped, even for an unstable type.\u003c/p\u003e\u003cp id=\"96a2\"\u003eFor example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7ccb\"\u003eval state by viewModel.state.collectAsState()\u003cbr/\u003eUserCard(profile = state.profile)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c77d\"\u003eIf \u003ccode\u003estate.profile\u003c/code\u003e refers to the same \u003ccode\u003eUserProfile\u003c/code\u003e instance as before, Compose may skip recomposing \u003ccode\u003eUserCard\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"4e40\"\u003eThis is a runtime optimization â€” and it only works if the object is reused as-is. As soon as the object is replaced or copied, recomposition will happen, because Compose can no longer assume itâ€™s safe to skip.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"bc16\"\u003eWhy relying on this is a bad idea\u003c/h2\u003e\u003cp id=\"c253\"\u003eThis kind of recomposition skipping is fragile:\u003c/p\u003e\u003cul\u003e\u003cli id=\"526d\"\u003eIt only works if the same object reference is preserved\u003c/li\u003e\u003cli id=\"e130\"\u003eIt breaks as soon as the model is rebuilt or copied\u003c/li\u003e\u003cli id=\"fda6\"\u003eIt hides recomposition costs that may appear later during refactoring or feature growth\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"31b8\"\u003eIn other words:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"b402\"\u003e\u003cem\u003eJust because recomposition doesnâ€™t happen today doesnâ€™t mean your setup is correct. The underlying instability still limits Composeâ€™s ability to optimize your UI safely.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"d2a4\"\u003eFor predictable and maintainable Compose code, itâ€™s better to avoid mutable properties in the constructor and rely on stable models. This allows Compose to apply both structural and reference-based optimizations â€” reliably and by design.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"6deb\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"c0cb\"\u003eUsing \u003ccode\u003evar\u003c/code\u003e in a Kotlin \u003ccode\u003edata class\u003c/code\u003e constructor has always been discouraged â€” mostly due to how it affects \u003ccode\u003eequals()\u003c/code\u003e, \u003ccode\u003ehashCode()\u003c/code\u003e, and collection behavior.\u003c/p\u003e\u003cp id=\"8308\"\u003eWith Jetpack Compose, this design choice introduces an additional concern.\u003c/p\u003e\u003cp id=\"8583\"\u003eMutable constructor properties make the class \u003cstrong\u003eunstable\u003c/strong\u003e from Composeâ€™s perspective.\u003cbr/\u003eThis limits how efficiently Compose can track changes and optimize recompositions.\u003c/p\u003e\u003cp id=\"6710\"\u003eAlthough Compose may still skip recomposition in some cases â€” for example, when the same object instance is reused â€” relying on such behavior is fragile and not recommended.\u003c/p\u003e\u003ch2 id=\"25cd\"\u003eWhat to do instead\u003c/h2\u003e\u003cul\u003e\u003cli id=\"f7f2\"\u003eUse \u003ccode\u003eval\u003c/code\u003e in data class constructors whenever possible\u003c/li\u003e\u003cli id=\"b0f3\"\u003eKeep your UI models immutable and predictable\u003c/li\u003e\u003cli id=\"c69c\"\u003eIf mutable state is needed, declare it outside the constructor\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"89f9\"\u003eStable models allow Compose to reason about your UI more effectively and apply optimizations safely.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"49fd\"\u003eAvoiding \u003ccode\u003evar\u003c/code\u003e in data class constructors is not just about code style â€” it\u0026#39;s also a way to write faster, more predictable Compose UIs.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"766a\"\u003eYou might also like:\u003c/h2\u003e\u003ch2 id=\"fed9\"\u003e\u003cstrong\u003eFound this useful?\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"8cf3\"\u003eIf this article helped you understand how \u003ccode\u003evar\u003c/code\u003e affects stability and recomposition in Jetpack Compose â€” consider leaving a clap. It helps others discover the article.\u003c/p\u003e\u003cp id=\"34b1\"\u003eIf youâ€™re working with Kotlin and Compose, feel free to follow â€” more practical articles coming soon.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"bae6\"\u003e\u003cstrong\u003eAnatolii Frolov\u003c/strong\u003e\u003cbr/\u003eSenior Android Developer\u003cbr/\u003eWriting honest, real-world Kotlin \u0026amp; Jetpack Compose insights.\u003cbr/\u003eðŸ“¬ \u003ca href=\"https://medium.com/@af2905g\" rel=\"noopener\"\u003eFollow me on Medium\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-05-25T09:55:30.997Z",
  "modifiedTime": null
}
