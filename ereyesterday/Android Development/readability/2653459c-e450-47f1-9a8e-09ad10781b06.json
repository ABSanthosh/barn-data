{
  "id": "2653459c-e450-47f1-9a8e-09ad10781b06",
  "title": "Introducing Trio | Part II",
  "link": "https://medium.com/airbnb-engineering/introducing-trio-part-ii-fe836013a798?source=rss----53c7c27702d5--android",
  "description": "",
  "author": "Eli Hart",
  "published": "Thu, 04 Apr 2024 16:52:13 GMT",
  "source": "https://medium.com/feed/airbnb-engineering/tagged/android",
  "categories": [
    "mobile",
    "mobile-app-development",
    "engineering",
    "jetpack-compose",
    "android"
  ],
  "byline": "Eli Hart",
  "length": 17026,
  "excerpt": "In the previous post in this series, we introduced you to Trio, Airbnb’s framework for Jetpack Compose screen architecture in Android. Some of the advantages of Trio include: If you need a refresher…",
  "siteName": "The Airbnb Tech Blog",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Introducing Trio | Part IIPart two on how we built a Compose based architecture with Mavericks in the Airbnb Android appBy: Eli Hart, Ben Schwab, and Yvonne WongIn the previous post in this series, we introduced you to Trio, Airbnb’s framework for Jetpack Compose screen architecture in Android. Some of the advantages of Trio include:Guarantees type safety when communicating across module boundaries in complex appsCodifies expectations about how ViewModels are used and shared, and what interfaces look like between screensAllows for stable screenshot and UI tests and simple navigation testingCompatible with Mavericks, Airbnb’s open source state management library for Jetpack (Trio is built on top of Mavericks)If you need a refresher on Trio or are learning about this framework for the first time, start with Part 1. It provides an overview of why we built Trio when transitioning to Compose from a Fragments-based architecture. Part 1 also explains the core framework concepts like the Trio class and UI class.In this post, we’ll build upon what we’ve shared so far and dive into how navigation works in Trio. As you’ll see, we designed Trio to make navigation simpler and easier to test, especially for large, modularized applications.Navigating with TrioA unique approach in our design is that Trios are stored in the ViewModel’s State, right alongside all other data that a Screen exposes to the UI. For example, a common use case is to store a list of Trios to represent a stack of screens.data class ParentState( @PersistState val trioStack: List\u003cTrio\u003e) : MavericksStateThe PersistState annotation is a mechanism of Mavericks that automatically saves and restores parcelable State values across process death, so the navigation state is preserved. A compile time validation ensures that Trio values in State classes are annotated like this so that their state is always saved correctly.The ViewModel controls this state, and can expose functions to push a new screen or pop off a screen. Since the ViewModel has direct control over the list of Trios, it can also easily perform more complex navigation changes such as reordering screens, dropping multiple screens, or clearing all screens. This makes navigation extremely flexible.class ParentViewModel : TrioViewModel { fun pushScreen(trio: Trio) = setState { copy(trioStack = trioStack + trio) } fun pop() = setState { copy(trioStack = trioStack.dropLast(1)) }}The Parent Trio’s UI accesses the Trio list from State and chooses how and where to place the Trios. We can implement a screen flow by showing the latest Trio in the stack.@Composableoverride fun TrioRenderScope.Content(state: ParentState) { ShowTrio(state.trioStack.last())}Coordinating NavigationWhy store Trios in State? Alternative approaches might use a navigator object in the Compose UI. However, representing the application’s navigation graph in State allows the ViewModel to update its data and navigation in a single place. This can be extremely helpful when we need to delay making a navigation change until after an asynchronous action, like a network request, completes. We could not do this easily with Fragments and found that with Trio’s approach, our navigation becomes simpler, more explicit, and more easily testable.This example shows how the ViewModel can handle a “save and exit” call from the UI by launching a suspending network request in a coroutine. Once the request completes, we can pop the screen by updating the Trio stack in State. We can also atomically modify other values in the state at the same time, perhaps based on the result of the network request. This easily guarantees that navigation and ViewModel state stay in sync.class CounterViewModel : TrioViewModel { fun saveAndExit() = viewModelScope.launch { val success = performSaveRequest() setState { copy( trioStack = trioStack.dropLast(1), success = success ) } }}As the navigation stack becomes more complex, application UI hierarchy gets modeled by a chain of ViewModels and their States. As the state is rendered, it creates a corresponding Compose UI hierarchy.A Trio can represent an arbitrary UI element of any size, including nested screens and sections, while providing a backing state and a mechanism to communicate with other Trios in the hierarchy.There are two additional nice benefits of modeling the hierarchy in ViewModel state like this. One is that it becomes simple to specify custom navigation scenarios when setting up testing — we can easily create whatever navigation states we want for our tests.Another benefit is that since the navigation hierarchy is decoupled from the Compose UI, we can pre-load Trios that we anticipate needing, just by initializing their ViewModels ahead of time. This has made it significantly simpler for us to optimize performance through preloading screens.Mavericks State typically holds simple data classes, and not complex objects like a Trio, which have a lifecycle. However, we find that the benefits this approach brings are well worth the extra complexity.Managing ActivitiesIdeally, an application with Trio would use just a single activity, following the standard application architecture recommendation from Google. However, especially for interop purposes, Trios will sometimes need to start new activity intents. Traditionally, this isn’t done from a ViewModel because ViewModels should not contain Activity references, since they outlive the Activity lifecycle; however, in order to maintain our paradigm of doing all navigation in the ViewModel, Trio makes an exception.During initialization, the Trio ViewModel is given a Flow of Activity via its initializer. This Flow provides the current activity that the ViewModel is attached to, and null when it is detached, such as during activity recreation. Trio internals manage the Flow to guarantee that it is up to date and the activity is not leaked.When needed, a ViewModel can access the next non-null activity value via the awaitActivity suspend function. For example, we can use it to start a new activity after a network request completes.class ViewModelInitializer\u003cS : MavericksState\u003e( val initialState: S, internal val activityFlow: Flow\u003cActivity?\u003e, ...)class CounterViewModel( initializer: ViewModelInitializer) : TrioViewModel { fun saveAndOpenNextPage() = viewModelScope.launch { performSaveRequest() awaitActivity().startActivity() }}The awaitActivity function is provided by the TrioViewModel as a convenient way to get the next value in the activity flow.suspend fun awaitActivity(): ComponentActivity { return initializer.activityFlow.filterNotNull().first()}While a bit unorthodox, this pattern allows activity-based navigation to also be collocated with other business logic in the ViewModel.Modularization StructureProperly modularizing a large code base is a problem that many applications face. At Airbnb, we’ve split our codebase into over 2000 modules to allow faster build speeds and explicit ownership boundaries. To support this, we’ve built an in house navigation system that decouples feature modules. It was originally created to support Fragments and Activities, and was later expanded to integrate with Trio, helping us to solve the general problem of navigation at scale in a large application.In our project structure, each module has a specific type, indicated by its prefix and suffix, which defines its purpose and enforces a set of rules about which other modules it can depend on.Feature modules, prefixed with “feat”, contain our Trio screens; each screen in the app might live in its own separate module. To prevent circular dependencies and improve build speeds, we do not allow feature modules to depend on each other.This means that one feature cannot directly instantiate another. Instead, each feature module has a corresponding navigation module, suffixed with “nav”, which defines a router to its feature. To avoid a circular dependency, the router and its destination Trio are associated with Dagger multibinding.In this simple example, we have a counter feature and a decimal feature. The counter feature can open the decimal feature to modify the decimal count, so the counter module needs to depend on the decimal navigation module.RoutingThe navigation module is small. It contains only a Routers class with nested Router objects corresponding to each Trio in the feature module.// In feat.decimal.nav@Plugin(pluginPoint = RoutersPluginPoint::class)class DecimalRouters : RouterDeclarations() { @Parcelize data class DecimalArgs(val count: Double) : Parcelable object DecimalScreen : TrioRouter\u003cDecimalArgs, NavigationProps, NoResult\u003e}A Router object is parameterized with the types that define the Trio’s public interface: the Arguments to instantiate it, the Props that it uses for active communication, and if desired, the Result that the Trio returns.Arguments is a data class, often including primitive data indicating starting values for a screen.Importantly, the Routers class is annotated with @Plugin to declare that it should be added to the Routers PluginPoint. This annotation is part of an internal KSP processor that we use for dependency injection, but it essentially just generates the boilerplate code to set up a Dagger multibinding set. The result is that each Routers class is added to a set, which we can access from the Dagger graph at runtime.On the corresponding Trio class in the feature module, we use the @TrioRouter annotation to specify which Router the Trio maps to. Our KSP processor matches these at compile time, and generates code that we can use at runtime to find the Trio destination for each Router.// In feat.decimal@TrioRouter(DecimalRouters.DecimalScreen::class)class DecimalScreen( initializer: Initializer\u003cDecimalArgs, ...\u003e) : Trio\u003cDecimalArgs, NavigationProps, ...\u003eThe processor validates at compile time that the Arguments and Props on the Router match the types on the Trio, and that each Router has a single corresponding destination. This guarantees runtime type safety in our navigation system.Router UsageInstead of manually instantiating Trios, we let the Router do it for us. The Router ensures that the proper type of Arguments is provided, looks up the matching Trio class in the Dagger graph, creates the initializer class to wrap the arguments, and finally, uses reflection to invoke the Trio’s constructor.This functionality is accessible through a createTrio function on the router, which we can invoke from the ViewModel. This allows us to easily create a new instance of a Trio, and push it onto our Trio stack. In the following example, the Props instance allows the Trio to call back to its parent to perform this push; we’ll explore Props in detail in Part 3 of this series.class CounterViewModel : TrioViewModel { fun showDecimal(count: Double) { val trio = DecimalRouters.DecimalScreen.createTrio(DecimalArgs(count)) props.pushScreen(trio) }}If we want to instead start a Trio in a new activity, the Router also provides a function to create an intent for a new activity that wraps the Trio instance; we can then start it from the ViewModel using Trio’s activity mechanism, as discussed earlier.class CounterViewModel : TrioViewModel { fun showDecimal(count: Double) = viewModelScope.launch { val activity = awaitActivity() val intent = DecimalRouters.DecimalScreen .newIntent(activity, DecimalArgs(count)) activity.startActivity(intent) }}When a Trio is started in a new activity, we simply need to extract the Parcelable Trio instance from the intent, and show it at the root of the Activity’s content.class TrioActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val trio = intent.parseTrio() setContent { ShowTrio(trio) } }}We can also start activities for a result by defining a Result type on the router.class DecimalRouters : RouterDeclarations() { data class DecimalResult(val count: Double) object DecimalScreen : TrioRouter\u003cDecimalArgs, …, DecimalResult\u003e}In this case, the ViewModel contains a “launcher” property, which is used to start the new activity.class CounterViewModel : TrioViewModel { val decimalLauncher = DecimalScreen.createResultLauncher { result -\u003e setState { copy(count = result.count) } } fun showDecimal(count: Double) { decimalLauncher.startActivityForResult(DecimalArgs(count)) }}For example, if the user adjusts the decimals on the decimal screen, we could return the new count to update our state in the counter. The lambda argument to the launcher allows us to handle the result when the decimal screen returns, which we can then use to update the state. This furthers our goal of centralizing all navigation in the ViewModel, while guaranteeing type safety.Our Router system offers other nice features in addition to modularization, like interceptor chains in the Router resolution providing intermediary screens before showing the final Trio destination. We use this to redirect users to the login page when required, and also to show a loading page if a dynamic feature needs to be downloaded first.Fragment InteropMaking Trio screens interoperable with our existing Fragment screens was very important to us. Our migration to Trio is a years-long effort, and Trios and Fragments need to easily coexist.Our approach to interoperability is twofold. First, if a Fragment and Trio don’t need to dynamically share information while created (i.e., they only take initial arguments and return a result), then it is easiest to start a new activity when transitioning between a Fragment and a Trio. Both architecture types can be easily started in a new activity with Arguments, and can optionally return a result when finished, so it is very easy to navigate between them this way.Alternatively, if a Trio and Fragment screen need to share data between themselves while the screens are both active (i.e., the equivalent of Props with Trio), or they need to share complex data that is too large to pass with Arguments, then the Trio can be nested within an “Interop Fragment”, and the two Fragments can be shown in the same activity. The Fragments can communicate via a shared ViewModel, similar to how Fragments normally share ViewModels with Mavericks.Our Router object makes it easy to create and show a Trio from another Fragment, with a single function call:class LegacyFragment : MavericksFragment { fun showTrioScreen() { showFragment( CounterRouters .CounterScreen .newInteropFragment(SharedCounterViewModelPropsAdapter::class) ) }}The Router creates a shell Fragment and renders the Trio inside of it. An optional adapter class, the SharedCounterViewModelPropsAdapter in the above example, can be passed to the Fragment to specify how the Trio will communicate with Mavericks ViewModels used by other Fragments in the activity. This adapter allows the Trio to specify which ViewModels it wants to access, and creates a StateFlow that converts those ViewModel states into the Props class that the Trio consumes.class SharedCounterViewModelPropsAdapter : LegacyViewModelPropsAdapter\u003cSharedCounterScreenProps\u003e { override suspend fun createPropsStateFlow( legacyViewModelProvider: LegacyViewModelProvider, navController: NavController\u003cSharedCounterScreenProps\u003e, scope: CoroutineScope): StateFlow\u003cSharedCounterScreenProps\u003e { // Look up an activity view model val sharedCounterViewModel: SharedCounterViewModel = legacyViewModelProvider.getActivityViewModel() // You can look up multiple view models if necessary val fragmentClickViewModel: SharedCounterViewModel = legacyViewModelProvider.requireExistingViewModel(viewModelKey = { SharedCounterViewModelKeys.fragmentOnlyCounterKey }) // Combine state updates into Props for the Trio, // and return as a StateFlow. This will be invoked anytime // any state flow has a new state object. return combine(sharedCounterViewModel.stateFlow, fragmentClickViewModel.stateFlow) { sharedState, fragmentState -\u003e SharedCounterScreenProps( navController = navController, sharedClickCount = sharedState.count, fragmentClickCount = fragmentState.count, increaseSharedCount = { sharedCounterViewModel.increaseCounter() } ) }.stateIn(scope) }}ConclusionIn this article, we discussed how navigation works in Trio. We use some unique approaches, such as our custom routing system, providing access to activities in a ViewModel, and storing Trios in the ViewModel State to achieve our goals of modularization, interoperability, and making it simpler to reason about navigation logic.Continue reading in Part 3, where we explain how Trio’s Props enable dynamic communication between screens.And if this sounds like the kind of challenge you love working on, check out open roles — we’re hiring!",
  "image": "https://miro.medium.com/v2/resize:fit:862/1*Ill4nQ2nbUwqQakROhb-6Q.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"ade8\" data-testid=\"storyTitle\"\u003eIntroducing Trio | Part II\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"81e2\"\u003ePart two on how we built a Compose based architecture with Mavericks in the Airbnb Android app\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@konakid?source=post_page---byline--fe836013a798---------------------------------------\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Eli Hart\" src=\"https://miro.medium.com/v2/resize:fill:88:88/2*qR91fuLzUz5PI59hjTTcRQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/airbnb-engineering?source=post_page---byline--fe836013a798---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"The Airbnb Tech Blog\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*MlNQKg-sieBGW5prWoe9HQ.jpeg\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9b98\"\u003eBy: \u003ca href=\"https://www.linkedin.com/in/eli-hart-54a4b975/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEli Hart\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/schwabben/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBen Schwab\u003c/a\u003e, and \u003ca href=\"https://www.linkedin.com/in/yvonnejwong\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eYvonne Wong\u003c/a\u003e\u003c/p\u003e\u003cp id=\"d35a\"\u003eIn the previous post in this series, we introduced you to Trio, Airbnb’s framework for Jetpack Compose screen architecture in Android. Some of the advantages of Trio include:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0646\"\u003eGuarantees type safety when communicating across module boundaries in complex apps\u003c/li\u003e\u003cli id=\"5837\"\u003eCodifies expectations about how ViewModels are used and shared, and what interfaces look like between screens\u003c/li\u003e\u003cli id=\"c292\"\u003eAllows for stable screenshot and UI tests and simple navigation testing\u003c/li\u003e\u003cli id=\"c691\"\u003eCompatible with \u003ca href=\"https://github.com/airbnb/mavericks\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMavericks\u003c/a\u003e, Airbnb’s open source state management library for Jetpack (Trio is built on top of Mavericks)\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"471f\"\u003eIf you need a refresher on Trio or are learning about this framework for the first time, start with \u003ca rel=\"noopener\" href=\"https://medium.com/p/7f5017a1a903\"\u003ePart 1\u003c/a\u003e. It provides an overview of why we built Trio when transitioning to Compose from a Fragments-based architecture. Part 1 also explains the core framework concepts like the Trio class and UI class.\u003c/p\u003e\u003cp id=\"8a4c\"\u003eIn this post, we’ll build upon what we’ve shared so far and dive into how navigation works in Trio. As you’ll see, we designed Trio to make navigation simpler and easier to test, especially for large, modularized applications.\u003c/p\u003e\u003ch2 id=\"427b\"\u003eNavigating with Trio\u003c/h2\u003e\u003cp id=\"565c\"\u003eA unique approach in our design is that Trios are stored in the ViewModel’s State, right alongside all other data that a Screen exposes to the UI. For example, a common use case is to store a list of Trios to represent a stack of screens.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a5dc\"\u003edata class ParentState(\u003cbr/\u003e  @PersistState val trioStack: List\u0026lt;Trio\u0026gt;\u003cbr/\u003e) : MavericksState\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c0bd\"\u003eThe \u003ccode\u003ePersistState\u003c/code\u003e annotation is a mechanism of Mavericks that automatically saves and restores parcelable State values across process death, so the navigation state is preserved. A compile time validation ensures that Trio values in State classes are annotated like this so that their state is always saved correctly.\u003c/p\u003e\u003cp id=\"8da8\"\u003eThe ViewModel controls this state, and can expose functions to push a new screen or pop off a screen. Since the ViewModel has direct control over the list of Trios, it can also easily perform more complex navigation changes such as reordering screens, dropping multiple screens, or clearing all screens. This makes navigation extremely flexible.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"05e2\"\u003eclass ParentViewModel : TrioViewModel {\u003cbr/\u003e  fun pushScreen(trio: Trio) = setState {\u003cbr/\u003e    copy(trioStack = trioStack + trio)\u003cbr/\u003e  }\u003cp\u003e  fun pop() = setState {\u003cbr/\u003e    copy(trioStack = trioStack.dropLast(1))\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"209d\"\u003eThe Parent Trio’s UI accesses the Trio list from State and chooses how and where to place the Trios. We can implement a screen flow by showing the latest Trio in the stack.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4612\"\u003e@Composable\u003cbr/\u003eoverride fun TrioRenderScope.Content(state: ParentState) {\u003cbr/\u003e  ShowTrio(state.trioStack.last())\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"a765\"\u003eCoordinating Navigation\u003c/h2\u003e\u003cp id=\"b9a9\"\u003eWhy store Trios in State? Alternative approaches might use a navigator object in the Compose UI. However, representing the application’s navigation graph in State allows the ViewModel to update its data and navigation in a single place. This can be extremely helpful when we need to delay making a navigation change until after an asynchronous action, like a network request, completes. We could not do this easily with Fragments and found that with Trio’s approach, our navigation becomes simpler, more explicit, and more easily testable.\u003c/p\u003e\u003cp id=\"7154\"\u003eThis example shows how the ViewModel can handle a “save and exit” call from the UI by launching a suspending network request in a coroutine. Once the request completes, we can pop the screen by updating the Trio stack in State. We can also atomically modify other values in the state at the same time, perhaps based on the result of the network request. This easily guarantees that navigation and ViewModel state stay in sync.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ad29\"\u003eclass CounterViewModel : TrioViewModel {\u003cp\u003e  fun saveAndExit() = viewModelScope.launch {\u003cbr/\u003e    val success = performSaveRequest()\u003c/p\u003e\u003cp\u003e    setState {\u003cbr/\u003e      copy(\u003cbr/\u003e        trioStack = trioStack.dropLast(1),\u003cbr/\u003e        success = success\u003cbr/\u003e      )\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"bf5c\"\u003eAs the navigation stack becomes more complex, application UI hierarchy gets modeled by a chain of ViewModels and their States. As the state is rendered, it creates a corresponding Compose UI hierarchy.\u003c/p\u003e\u003cp id=\"a921\"\u003eA Trio can represent an arbitrary UI element of any size, including nested screens and sections, while providing a backing state and a mechanism to communicate with other Trios in the hierarchy.\u003c/p\u003e\u003cp id=\"a0f0\"\u003eThere are two additional nice benefits of modeling the hierarchy in ViewModel state like this. One is that it becomes simple to specify custom navigation scenarios when setting up testing — we can easily create whatever navigation states we want for our tests.\u003c/p\u003e\u003cp id=\"51db\"\u003eAnother benefit is that since the navigation hierarchy is decoupled from the Compose UI, we can pre-load Trios that we anticipate needing, just by initializing their ViewModels ahead of time. This has made it significantly simpler for us to optimize performance through preloading screens.\u003c/p\u003e\u003cp id=\"2d96\"\u003eMavericks State typically holds simple data classes, and not complex objects like a Trio, which have a lifecycle. However, we find that the benefits this approach brings are well worth the extra complexity.\u003c/p\u003e\u003ch2 id=\"ac51\"\u003eManaging Activities\u003c/h2\u003e\u003cp id=\"d15b\"\u003eIdeally, an application with Trio would use just a single activity, following the standard \u003ca href=\"https://developer.android.com/topic/architecture/recommendations\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eapplication architecture recommendation\u003c/a\u003e from Google. However, especially for interop purposes, Trios will sometimes need to start new activity intents. Traditionally, this isn’t done from a ViewModel because ViewModels \u003ca href=\"https://developer.android.com/topic/libraries/architecture/viewmodel#:~:text=A%20ViewModel%20usually%20shouldn%27t%20reference\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eshould not contain Activity references\u003c/a\u003e, since they outlive the Activity lifecycle; however, in order to maintain our paradigm of doing all navigation in the ViewModel, Trio makes an exception.\u003c/p\u003e\u003cp id=\"feec\"\u003eDuring initialization, the Trio ViewModel is given a Flow of Activity via its initializer. This Flow provides the current activity that the ViewModel is attached to, and null when it is detached, such as during activity recreation. Trio internals manage the Flow to guarantee that it is up to date and the activity is not leaked.\u003c/p\u003e\u003cp id=\"e043\"\u003eWhen needed, a ViewModel can access the next non-null activity value via the awaitActivity suspend function. For example, we can use it to start a new activity after a network request completes.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a57f\"\u003eclass ViewModelInitializer\u0026lt;S : MavericksState\u0026gt;(\u003cbr/\u003e  val initialState: S,\u003cbr/\u003e  internal val activityFlow: Flow\u0026lt;Activity?\u0026gt;,\u003cbr/\u003e  ...\u003cbr/\u003e)\u003cp\u003eclass CounterViewModel(\u003cbr/\u003e  initializer: ViewModelInitializer\u003cbr/\u003e) : TrioViewModel {\u003c/p\u003e\u003cp\u003e  fun saveAndOpenNextPage() = viewModelScope.launch {\u003cbr/\u003e    performSaveRequest()\u003cbr/\u003e    awaitActivity().startActivity()\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c5b5\"\u003eThe \u003ccode\u003eawaitActivity\u003c/code\u003e function is provided by the TrioViewModel as a convenient way to get the next value in the activity flow.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9216\"\u003esuspend fun awaitActivity(): ComponentActivity {\u003cbr/\u003e  return initializer.activityFlow.filterNotNull().first()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8af6\"\u003eWhile a bit unorthodox, this pattern allows activity-based navigation to also be collocated with other business logic in the ViewModel.\u003c/p\u003e\u003ch2 id=\"e957\"\u003eModularization Structure\u003c/h2\u003e\u003cp id=\"746d\"\u003eProperly modularizing a large code base is a problem that many applications face. At Airbnb, we’ve split our codebase into over 2000 modules to allow faster build speeds and explicit ownership boundaries. To support this, we’ve built an in house navigation system that decouples feature modules. It was originally created to support Fragments and Activities, and was later expanded to integrate with Trio, helping us to solve the general problem of navigation at scale in a large application.\u003c/p\u003e\u003cp id=\"e5b0\"\u003eIn our project structure, each module has a specific type, indicated by its prefix and suffix, which defines its purpose and enforces a set of rules about which other modules it can depend on.\u003c/p\u003e\u003cp id=\"04b7\"\u003eFeature modules, prefixed with “feat”, contain our Trio screens; each screen in the app might live in its own separate module. To prevent circular dependencies and improve build speeds, we do not allow feature modules to depend on each other.\u003c/p\u003e\u003cp id=\"64ab\"\u003eThis means that one feature cannot directly instantiate another. Instead, each feature module has a corresponding navigation module, suffixed with “nav”, which defines a router to its feature. To avoid a circular dependency, the router and its destination Trio are associated with Dagger multibinding.\u003c/p\u003e\u003cp id=\"f026\"\u003eIn this simple example, we have a counter feature and a decimal feature. The counter feature can open the decimal feature to modify the decimal count, so the counter module needs to depend on the decimal navigation module.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"af91\"\u003eRouting\u003c/h2\u003e\u003cp id=\"5494\"\u003eThe navigation module is small. It contains only a Routers class with nested Router objects corresponding to each Trio in the feature module.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"43d2\"\u003e// In feat.decimal.nav\u003cbr/\u003e@Plugin(pluginPoint = RoutersPluginPoint::class)\u003cbr/\u003eclass DecimalRouters : RouterDeclarations() {\u003cp\u003e  @Parcelize\u003cbr/\u003e  data class DecimalArgs(val count: Double) : Parcelable\u003c/p\u003e\u003cp\u003e  object DecimalScreen \u003cbr/\u003e    : TrioRouter\u0026lt;DecimalArgs, NavigationProps, NoResult\u0026gt;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"757a\"\u003eA Router object is parameterized with the types that define the Trio’s public interface: the Arguments to instantiate it, the Props that it uses for active communication, and if desired, the Result that the Trio returns.\u003c/p\u003e\u003cp id=\"4163\"\u003eArguments is a data class, often including primitive data indicating starting values for a screen.\u003c/p\u003e\u003cp id=\"44f9\"\u003eImportantly, the Routers class is annotated with \u003ccode\u003e@Plugin\u003c/code\u003e to declare that it should be added to the Routers PluginPoint. This annotation is part of an internal KSP processor that we use for dependency injection, but it essentially just generates the boilerplate code to set up a Dagger multibinding set. The result is that each Routers class is added to a set, which we can access from the Dagger graph at runtime.\u003c/p\u003e\u003cp id=\"6bc9\"\u003eOn the corresponding Trio class in the feature module, we use the \u003ccode\u003e@TrioRouter\u003c/code\u003e annotation to specify which Router the Trio maps to. Our KSP processor matches these at compile time, and generates code that we can use at runtime to find the Trio destination for each Router.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"076e\"\u003e// In feat.decimal\u003cbr/\u003e@TrioRouter(DecimalRouters.DecimalScreen::class)\u003cbr/\u003eclass DecimalScreen(\u003cbr/\u003e  initializer: Initializer\u0026lt;DecimalArgs, ...\u0026gt;\u003cbr/\u003e) : Trio\u0026lt;DecimalArgs, NavigationProps, ...\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f77e\"\u003eThe processor validates at compile time that the Arguments and Props on the Router match the types on the Trio, and that each Router has a single corresponding destination. This guarantees runtime type safety in our navigation system.\u003c/p\u003e\u003ch2 id=\"eca3\"\u003eRouter Usage\u003c/h2\u003e\u003cp id=\"4f65\"\u003eInstead of manually instantiating Trios, we let the Router do it for us. The Router ensures that the proper type of Arguments is provided, looks up the matching Trio class in the Dagger graph, creates the initializer class to wrap the arguments, and finally, uses reflection to invoke the Trio’s constructor.\u003c/p\u003e\u003cp id=\"c753\"\u003eThis functionality is accessible through a \u003ccode\u003ecreateTrio\u003c/code\u003e function on the router, which we can invoke from the ViewModel. This allows us to easily create a new instance of a Trio, and push it onto our Trio stack. In the following example, the Props instance allows the Trio to call back to its parent to perform this push; we’ll explore Props in detail in Part 3 of this series.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e69b\"\u003eclass CounterViewModel : TrioViewModel {\u003cp\u003e  fun showDecimal(count: Double) {\u003cbr/\u003e    val trio = DecimalRouters.DecimalScreen.createTrio(DecimalArgs(count))\u003cbr/\u003e    props.pushScreen(trio)\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f0da\"\u003eIf we want to instead start a Trio in a new activity, the Router also provides a function to create an intent for a new activity that wraps the Trio instance; we can then start it from the ViewModel using Trio’s activity mechanism, as discussed earlier.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3c12\"\u003eclass CounterViewModel : TrioViewModel {\u003cp\u003e  fun showDecimal(count: Double) = viewModelScope.launch {\u003cbr/\u003e    val activity = awaitActivity()\u003cbr/\u003e    val intent = DecimalRouters.DecimalScreen\u003cbr/\u003e                    .newIntent(activity, DecimalArgs(count))\u003c/p\u003e\u003cp\u003e        activity.startActivity(intent)\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9fef\"\u003eWhen a Trio is started in a new activity, we simply need to extract the Parcelable Trio instance from the intent, and show it at the root of the Activity’s content.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6d1a\"\u003eclass TrioActivity : ComponentActivity() {\u003cbr/\u003e  override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e    super.onCreate(savedInstanceState)\u003cp\u003e    val trio = intent.parseTrio()\u003cbr/\u003e    setContent {\u003cbr/\u003e      ShowTrio(trio)\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2ccd\"\u003eWe can also start activities for a result by defining a Result type on the router.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fd66\"\u003eclass DecimalRouters : RouterDeclarations() {\u003cp\u003e  data class DecimalResult(val count: Double)\u003c/p\u003e\u003cp\u003e  object DecimalScreen : TrioRouter\u0026lt;DecimalArgs, …, DecimalResult\u0026gt;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"350e\"\u003eIn this case, the ViewModel contains a “launcher” property, which is used to start the new activity.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1836\"\u003eclass CounterViewModel : TrioViewModel {\u003cp\u003e  val decimalLauncher = DecimalScreen.createResultLauncher { result -\u0026gt;\u003cbr/\u003e    setState {\u003cbr/\u003e      copy(count = result.count)\u003cbr/\u003e    }\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  fun showDecimal(count: Double) {\u003cbr/\u003e    decimalLauncher.startActivityForResult(DecimalArgs(count))\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0ff1\"\u003eFor example, if the user adjusts the decimals on the decimal screen, we could return the new count to update our state in the counter. The lambda argument to the launcher allows us to handle the result when the decimal screen returns, which we can then use to update the state. This furthers our goal of centralizing all navigation in the ViewModel, while guaranteeing type safety.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"8d6a\"\u003eOur Router system offers other nice features in addition to modularization, like interceptor chains in the Router resolution providing intermediary screens before showing the final Trio destination. We use this to redirect users to the login page when required, and also to show a loading page if a dynamic feature needs to be downloaded first.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"18e3\"\u003eFragment Interop\u003c/h2\u003e\u003cp id=\"5237\"\u003eMaking Trio screens interoperable with our existing Fragment screens was very important to us. Our migration to Trio is a years-long effort, and Trios and Fragments need to easily coexist.\u003c/p\u003e\u003cp id=\"8c2e\"\u003eOur approach to interoperability is twofold. First, if a Fragment and Trio don’t need to dynamically share information while created (i.e., they only take initial arguments and return a result), then it is easiest to start a new activity when transitioning between a Fragment and a Trio. Both architecture types can be easily started in a new activity with Arguments, and can optionally return a result when finished, so it is very easy to navigate between them this way.\u003c/p\u003e\u003cp id=\"f539\"\u003eAlternatively, if a Trio and Fragment screen need to share data between themselves while the screens are both active (i.e., the equivalent of Props with Trio), or they need to share complex data that is too large to pass with Arguments, then the Trio can be nested within an “Interop Fragment”, and the two Fragments can be shown in the same activity. The Fragments can communicate via a shared ViewModel, similar to how Fragments normally share ViewModels with Mavericks.\u003c/p\u003e\u003cp id=\"a655\"\u003eOur Router object makes it easy to create and show a Trio from another Fragment, with a single function call:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7c99\"\u003eclass LegacyFragment : MavericksFragment {\u003cp\u003e  fun showTrioScreen() {        \u003cbr/\u003e    showFragment(\u003cbr/\u003e      CounterRouters\u003cbr/\u003e             .CounterScreen\u003cbr/\u003e             .newInteropFragment(SharedCounterViewModelPropsAdapter::class)\u003cbr/\u003e    )\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"eae7\"\u003eThe Router creates a shell Fragment and renders the Trio inside of it. An optional adapter class, the SharedCounterViewModelPropsAdapter in the above example, can be passed to the Fragment to specify how the Trio will communicate with Mavericks ViewModels used by other Fragments in the activity. This adapter allows the Trio to specify which ViewModels it wants to access, and creates a StateFlow that converts those ViewModel states into the Props class that the Trio consumes.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6c61\"\u003eclass SharedCounterViewModelPropsAdapter : LegacyViewModelPropsAdapter\u0026lt;SharedCounterScreenProps\u0026gt; {\u003cp\u003e    override suspend fun createPropsStateFlow(\u003cbr/\u003e  legacyViewModelProvider: LegacyViewModelProvider,\u003cbr/\u003e  navController: NavController\u0026lt;SharedCounterScreenProps\u0026gt;,\u003cbr/\u003e  scope: CoroutineScope\u003cbr/\u003e): StateFlow\u0026lt;SharedCounterScreenProps\u0026gt; {\u003c/p\u003e\u003cp\u003e           // Look up an activity view model\u003cbr/\u003e  val sharedCounterViewModel: SharedCounterViewModel = legacyViewModelProvider.getActivityViewModel()\u003c/p\u003e\u003cp\u003e           // You can look up multiple view models if necessary\u003cbr/\u003e  val fragmentClickViewModel: SharedCounterViewModel = legacyViewModelProvider.requireExistingViewModel(viewModelKey = {\u003cbr/\u003e    SharedCounterViewModelKeys.fragmentOnlyCounterKey\u003cbr/\u003e  })\u003c/p\u003e\u003cp\u003e  // Combine state updates into Props for the Trio, \u003cbr/\u003e  // and return as a StateFlow. This will be invoked anytime\u003cbr/\u003e  // any state flow has a new state object.\u003cbr/\u003e  return combine(sharedCounterViewModel.stateFlow, fragmentClickViewModel.stateFlow) { sharedState, fragmentState -\u0026gt;\u003cbr/\u003e            SharedCounterScreenProps(\u003cbr/\u003e                navController = navController,\u003cbr/\u003e                sharedClickCount = sharedState.count,\u003cbr/\u003e                fragmentClickCount = fragmentState.count,\u003cbr/\u003e                increaseSharedCount = {\u003cbr/\u003e                    sharedCounterViewModel.increaseCounter()\u003cbr/\u003e                }\u003cbr/\u003e            )\u003cbr/\u003e    }.stateIn(scope)\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"ca0f\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"5170\"\u003eIn this article, we discussed how navigation works in Trio. We use some unique approaches, such as our custom routing system, providing access to activities in a ViewModel, and storing Trios in the ViewModel State to achieve our goals of modularization, interoperability, and making it simpler to reason about navigation logic.\u003c/p\u003e\u003cp id=\"73d7\"\u003eContinue reading in \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/introducing-trio-part-iii-033fbfe2171b\"\u003ePart 3\u003c/a\u003e, where we explain how Trio’s Props enable dynamic communication between screens.\u003c/p\u003e\u003cp id=\"1b48\"\u003eAnd if this sounds like the kind of challenge you love working on, check out \u003ca href=\"https://careers.airbnb.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eopen roles\u003c/a\u003e — we’re hiring!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": "2024-04-04T16:52:13.376Z",
  "modifiedTime": null
}
