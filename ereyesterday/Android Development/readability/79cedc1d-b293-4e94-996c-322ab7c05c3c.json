{
  "id": "79cedc1d-b293-4e94-996c-322ab7c05c3c",
  "title": "SDK Development; The Good, The Bad, The Ugly",
  "link": "https://proandroiddev.com/sdk-development-the-good-the-bad-the-ugly-9e9ab2a81697?source=rss----c72404660798---4",
  "description": "",
  "author": "Javad Arjmandi",
  "published": "Wed, 11 Dec 2024 21:29:27 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "clean-architecture",
    "android",
    "android-sdk",
    "software-engineering",
    "android-app-development"
  ],
  "byline": "Javad Arjmandi",
  "length": 27332,
  "excerpt": "A few years ago, a friend roped me into a “simple” side project to make some extra cash. The plan? Build a few apps, slap on some ads, and watch the money roll in. Easy, right? Well… not quite. We…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Some boring backstory introA few years ago, a friend roped me into a “simple” side project to make some extra cash. The plan? Build a few apps, slap on some ads, and watch the money roll in. Easy, right? Well… not quite. We quickly found ourselves tangled in a mess of issues. Google AdMob gave us trouble, some ad networks were outright shady, and others offered rates so bad, it wasn’t even worth the effort. After one particularly frustrating day, it hit me: “Why not build a library to handle all these ad networks and decide which ads to show based on the best deal?” Little did I know, this concept already had a name — ad mediation. Since we had a few adnetworks to play with, the idea of creating our own SDK seemed like a no-brainer.To our surprise, the SDK became such a hit (in our scale) that it completely overshadowed the apps we were trying to monetize in the first place. Suddenly, the SDK was the star of the show, and our apps? Well, they took a back seat.That was the start of my SDK-building journey.Fast forward through a decade of working with SDKs — both my own and ones from big-name companies and niche B2B partners — and let’s just say, I’ve seen the good, the bad, and the downright ugly when it comes to SDKs. I think I qualify as a SDK expert.Part 1: How NOT to develop a SDK (At least targetting the Android platform)?0. Developing the SDK with a Client-Side Application MindsetWhy it’s a bad idea?Sure, building an SDK like it’s just another app sounds tempting. But remember, your SDK is going to live in other people’s apps, all with their own unique setups and preferences. Treating it like a client-side app leads to all kinds of fun issues, like tightly coupled architecture, a complete lack of flexibility, and some deliciously unintended side effects. Client apps come with all kinds of assumptions — about UI, lifecycle, and direct access to device resources — that your SDK has no business messing with. It’s like crashing someone else’s dinner party and rearranging all their furniture.I’m not saying you should disregard good practices for client-side apps. It’s equally important for them to have a good, maintainable architecture and remain flexible. However, client-side apps are generally more resilient to faults that would be unacceptable when developing an SDK. Ideally, there shouldn’t even be an option to create technical debt when building an SDK.What to do instead:Instead of treating your SDK like an app, think of it as a backend service that cannot be updated once live. Decouple your concerns, provide asynchronous operations, and for goodness’ sake, be lightweight and unobtrusive. Your SDK should blend into the background, flexible enough to work across a variety of apps without needing to know how they handle their UI, threading, or device resources. Be the guest that’s never noticed — until they need you.Example: “I Control the UI Now, Mwahaha!”class Sdk { fun showProgressDialog(context: Context) { // Let's hijack the UI without asking! ProgressDialog(context).apply { setTitle(\"Please wait...\") setMessage(\"SDK is doing something super important!\") show() } }}Because who doesn’t want their UI randomly hijacked by some SDK? You’ve spent hours perfecting your app’s UX, but sure, let’s just throw in this uninvited ProgressDialog in the middle of everything. Thanks, SDK!Good Practice: “Wait, SDKs Shouldn’t Mess With UIs?”class Sdk { fun performBackendOperation(callback: (Result\u003cString\u003e) -\u003e Unit) { // Asynchronous backend logic without UI intervention callback(Result.success(\"Operation Completed!\")) }}Look, mom, no UI! The SDK does what it’s supposed to: backend operations, leaving the app developer to decide how to show progress, if at all.Wait, what if the UI is part of what our SDK is trying to offer?You’re already going to ruin the experience of the poor developer trying to integrate your SDK into their app. You might think:But the end user will have a good experienceAnd while that might be true in some cases, it’s often unlikely for various reasons, including:1. Lack of Flexibility for Developers: Predefined UI components limit developers’ ability to customize the user interface, making it difficult to align the SDK’s UI with the app’s branding and design. Since the UI is fixed, integrators also lose the ability to embed custom analytics, making it harder to track user activity for marketing or product analysis. This leads to inconsistent user experiences and missed insights, negatively impacting the perception of both the app and the SDK.2. Resource Conflicts: Bundling UI components can cause resource naming collisions (e.g., IDs, styles, or themes) between the SDK and the host app, leading to unexpected crashes or visual inconsistencies. These issues can require significant debugging effort, reducing developers’ trust in the SDK.3. Increased Maintenance Complexity: Including UI in the SDK requires ongoing maintenance to ensure compatibility with various Android versions, devices, and design guidelines. This increases the maintenance burden, and delays or unaddressed issues can frustrate developers and users, making the SDK less appealing.4. Larger SDK Size: Shipping UI components increases the overall size of the SDK, which contributes to larger app sizes. This can deter developers from adopting the SDK, and end-users may avoid downloading apps or uninstall them due to size concerns, indirectly affecting SDK adoption. (like yeah, let’s integrate “com.github.javad:awesome-animation:0.0.2” and add 5 more megabytes to poor developer’s app)5. Limited Reusability and Scalability: UI components shipped with the SDK are often not reusable or scalable across different projects. Developers working on apps with custom flows or designs may need to bypass or rewrite the SDK’s UI. Additionally, because the UI is fixed, integrators cannot track user activity within the SDK for custom marketing or product analytics purposes, reducing its value and making it appear rigid and developer-unfriendly.If you absolutely have to ship UI as part of your project, the best way to approach it is to make the UI optional and modular. Here’s how you can do it:Separate UI and Core Logic: Create two distinct packages: one for the core functionality and one for the UI components. This allows developers to choose whether they want to use the provided UI or build their own while still leveraging the core logic of the SDK.Provide Clear Documentation: Offer detailed instructions for implementing the SDK with and without the built-in UI. Include code samples and guidelines for developers who want to customize or replace the default UI.Make the UI Customizable: If you include a UI package, ensure it is fully customizable. Allow developers to override styles, colors, fonts, and even layouts to match their app’s branding and design.Design for Integration: Ensure the UI components follow Android’s Material Design guidelines and can adapt seamlessly to different themes, orientations, and screen sizes. Use isolated namespaces to avoid resource conflicts.Support Analytics Hooks: Provide APIs or callbacks that allow developers to integrate their analytics and tracking solutions into the SDK’s UI. This ensures that they can still collect data and maintain insights into user behavior.Offer a “Headless Mode”: For advanced users, offer a “headless” mode that exposes only the core logic, enabling developers to integrate it into their own UI without relying on your SDK’s visuals.An ideal SDK with UI should have at least 2 importable modules, 1 for the core functionality, and one for UI.1. Using 3rd Party Libraries Inside Your SDKWhy it’s a bad idea?Sure, nothing says “I’m in a hurry” like cramming in every shiny third-party library you can find. But here’s the catch: it comes with a whole list of issues. Ever dealt with version conflicts? Yeah, enjoy those. Licensing problems? Even better! Or how about making the host app developers manage complex dependency resolution because your SDK decided to use a different version of Retrofit, OkHttp, Glide, and Lottie than they do? Just imagine the joy when their app breaks, and they have to dig through Maven hell to figure out which library caused the explosion. You’re welcome!What to do instead:Minimize external dependencies like you’re on a code diet. Especially for core functionality. If you absolutely must drag in third-party libraries (and hey, I get it, they’re useful), isolate them. Or better yet, give the app developers the option to exclude or replace them. And please, document what libraries you’re using so it doesn’t feel like a game of “surprise dependency roulette.” It’s a party no one wants to attend.Example: “Let’s Bring the Whole Party! Retrofit, OkHttp, Glide, and Lottie!”class Sdk { // Retrofit to fetch data private val retrofit = Retrofit.Builder() .baseUrl(\"https://api.example.com/\") .build() // OkHttp for all the fancy HTTP interceptors private val client = OkHttpClient.Builder().build() // Glide to load images, of course fun loadImage(context: Context, imageUrl: String, imageView: ImageView) { Glide.with(context) .load(imageUrl) .into(imageView) } // And why not add Lottie animations for good measure? fun showLottieAnimation(context: Context, animationView: LottieAnimationView) { animationView.setAnimation(\"cool_animation.json\") animationView.playAnimation() }}Because why just load ads when you can load the entire internet along with them? Let’s add Retrofit for fetching some unnecessary data, OkHttp for all those fancy interceptors, Glide to load the most important image in history, and hey, let’s slap a Lottie animation on it too. What could go wrong? 🤷‍♂️I mean, who doesn’t love an SDK that bloats your app by 10MB with libraries it never even needed? Oh, and good luck dealing with version conflicts in your app! 😎Good Practice: “Just Keep It Simple, Stupid”class Sdk { // Avoid unnecessary dependencies fun performSimpleNetworkOperation(callback: (Result\u003cString\u003e) -\u003e Unit) { // Use plain old URL and HttpURLConnection, or let the app manage HTTP libraries. callback(Result.success(\"Fetched data\")) } // Let the app handle image loading and animations fun loadDataAndReturnUrl(callback: (String) -\u003e Unit) { // Just return a URL and let the app handle loading the image or animation callback(\"https://image.example.com\") }}Here’s an idea: let the developer decide if they want to use Retrofit, OkHttp, Glide, or Lottie. Stop packing your SDK like it’s the IKEA of dependencies. Simplicity wins the day.1.1 Using Deprecated LibrariesWhy it’s a bad idea? (as if them being a 3rd party is not bad enough)Ah, deprecated libraries — like old, broken toys that should’ve been thrown out years ago, but somehow you just can’t let go. They no longer receive updates, bug fixes, or any kind of love. In fact, they bring along security vulnerabilities and compatibility issues like unwanted party crashers. If your SDK relies on them, congratulations: you’ve just created a ticking time bomb for your users’ apps.What to do instead:Keep up with the times. Refactor your SDK and ditch deprecated libraries before they sink the ship. Continuously monitor the libraries you’re using (yes, that means some extra work) and update them before they’re completely irrelevant — or worse, break something critical. Your users will thank you for not making them fight with zombie dependencies.Example: “AsyncTask is My Best Friend”class Sdk { fun fetchDataInBackground() { // Who cares if AsyncTask is deprecated? It’s a classic! object : AsyncTask\u003cVoid, Void, String\u003e() { override fun doInBackground(vararg params: Void?): String { // Simulating a network call return \"Data fetched from background\" } override fun onPostExecute(result: String?) { // Handle result on the main thread } }.execute() }}Because who cares about Kotlin coroutines when we can use trusty old AsyncTask that Google has been telling us to avoid for years? Let’s keep that 2012 vibe going strong. (And yes, I first hand found someone use it in 2024)Good Practice: “Welcome to the 2020s — We Have Coroutines Now”class Sdk { fun fetchDataInBackground(callback: (Result\u003cString\u003e) -\u003e Unit) { GlobalScope.launch(Dispatchers.IO) { try { val data = \"Fetched data\" withContext(Dispatchers.Main) { callback(Result.success(data)) } } catch (e: Exception) { withContext(Dispatchers.Main) { callback(Result.failure(e)) } } } }}Ah, Kotlin Coroutines, the cool, modern way to handle background tasks without dragging apps back to the dark ages. The best part? They don’t trigger ANRs and actually make you look like you know what you’re doing.I’m not ranting about coroutines. I’m talking about those libraries buried six feet under in the graveyard of GitHub, last updated in 2019. Found some old but “reliable” library that’s no longer maintained? Great, now definitely don’t use its sketchy forks in an SDK you’re shipping for poor developers to suffer through. Always remember: if the original library was abandoned, there’s probably a good reason for it. Do everyone a favor and find a modern replacement instead.2. Using Singletons and Global State ManagementWhy It’s a Bad Idea:Ah yes, singletons — easy to set up, but a nightmare to live with when combined with mutable global state. They introduce unpredictable behavior, especially in multi-threaded environments, leading to race conditions, inconsistent states, and debugging nightmares. Need more than one instance of your SDK in the same app? Good luck with that. Worse, singletons often cause memory leaks by holding references to contexts or activities. They also hide dependencies, making code harder to test, maintain, and extend. Simply put, global state is a global headache.What to Do Instead:Use dependency injection or factory patterns to create and manage your SDK instances. This gives the client app control over the scope and lifecycle of your SDK components, ensuring predictable behavior. Avoid mutable global state — keep state context-aware and scoped to instances. If you need shared functionality, consider context-safe singletons with immutable state or thread-safe designs. And always design your SDK to support multiple instances where applicable. Responsible scoping leads to cleaner code and fewer headaches.Example: “Global State, Global Headache”object SdkSingleton { var globalAdState: String = \"No ad loaded yet\" fun loadAd() { // Modify global state at will! globalAdState = \"Ad loaded!\" }}Good Practice: “Let’s Scope This Like Adults”class Sdk(private var adState: String) { fun loadAd(): Sdk { // Create a new instance with updated state return Sdk(\"Ad loaded!\") }}// Create new instances without messing with global stateval sdkInstance = Sdk(\"No ad loaded\")val newSdkInstance = sdkInstance.loadAd()Keep your global state to yourself, thank you. Scoping state to instances like a responsible developer means fewer headaches and less chaos.3. Poor DocumentationWhy it’s a bad idea?So, you’ve built an amazing SDK, but forgot to tell anyone how to actually use it. Now developers are banging their heads against the wall trying to figure out what your methods do. Misuse, bugs, and frustrated support emails follow. But hey, it’s their fault for not reading your mind, right?What to do instead:Write documentation like you’re being graded on it. Clear, concise, and, most importantly, up-to-date. Include everything developers need: installation instructions, detailed API references, code examples, common use cases, and troubleshooting guides. And remember, just like your SDK, your docs should evolve. Developers don’t have time for guesswork; help them out!Example: “Good Luck, You’ll Need It”class Sdk { fun doSomethingSuperImportant() { // But I won’t tell you how or why }}Good Practice: “Let’s Be Nice — Write Documentation”/** * Performs an important task that retrieves user data. * * @param userId ID of the user to fetch data for. * @return User data in a Result wrapper. */class Sdk { fun fetchUserData(userId: String, callback: (Result\u003cString\u003e) -\u003e Unit) { // Retrieves user data and passes it to the callback callback(Result.success(\"User data for $userId\")) }}Imagine the joy on a developer’s face when they actually understand how your SDK works! Clear documentation is like a ray of sunshine on a cloudy day.4. Bad Communication of ChangesWhy it’s a bad idea?Making breaking changes without telling anyone is the ultimate plot twist. You’ll leave developers scratching their heads when their app mysteriously starts crashing after your latest update. And when features disappear or behaviors change with no explanation? Well, you’ve just created a new level of frustration. Bonus points if the developer only finds out after deploying their app to production! What to do instead:Communicate like an adult. Use proper versioning (ever heard of semantic versioning? It’s your friend). Maintain a changelog that’s actually useful, marking breaking changes clearly, and providing migration guides. Offering beta releases to let developers adapt before the official update drops? Now that’s next-level professional.5. Heavy-loading and Big Size of the AARWhy it’s a bad idea?Your SDK should be lean and mean, but instead, it’s bloated like a post-buffet nap. A large SDK increases app size, leading to longer build times, sluggish performance, and higher memory usage. You’ve just transformed that sleek app into a lumbering dinosaur. End users now get to enjoy painfully slow downloads, and developers get to spend their days trying to optimize around your behemoth of an SDK.What to do instead:Trim the fat. Optimize your SDK by stripping unused code and resources. Use ProGuard or R8 to shrink and obfuscate code, and modularize your SDK so developers can choose only the parts they need. The goal? A lightweight core with optional feature modules. Because no one likes dragging around unnecessary baggage.Example: “Let’s Make This AAR the Size of a Small Planet”// Packed with unnecessary resources like high-res images and massive JSON filesres/drawable/hd_background.pngres/animations/full_length_animation.jsonasset/mother_nature.soGood Practice: “Let’s Not Make Developers Hate Us”// Use ProGuard to slim down the AAR android { buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } }}// Split into modules so developers can choose what they actually needimplementation(\"com.example.sdk:core:1.0.0\")implementation(\"com.example.sdk:ad-module:1.0.0\")Part 2: An Ideal approach1. SDKs Are Modules in DisguiseThe process of developing an SDK closely resembles that of designing a module in a modular architecture, and adhering to clean architecture principles isn’t just “nice to have” — it’s essential. An SDK must behave like a guest in someone else’s app, blending seamlessly without imposing on the host app’s architecture. Let’s break this down technically:Why Clean Architecture is Essential for SDKsDecoupling Concerns:Clean architecture separates business logic (what the SDK does) from implementation details (how it does it). For example, the SDK should expose its core functionality via interfaces or abstract classes, while internal implementations remain private and modularized.This ensures the SDK is flexible and doesn’t directly tie its implementation to specific frameworks or third-party libraries.interface AdLoader { fun loadAd(callback: (Result\u003cString\u003e) -\u003e Unit)}class AdLoaderImpl(private val networkClient: NetworkClient) : AdLoader { override fun loadAd(callback: (Result\u003cString\u003e) -\u003e Unit) { networkClient.fetchAd { result -\u003e callback(result) } }}Here, AdLoader abstracts the business logic of loading ads, while AdLoaderImpl provides the implementation. The app integrating the SDK only interacts with the interface, keeping things modular and easy to test.2. Testability:Clean architecture ensures your SDK’s core logic is independent of Android-specific APIs, making it easier to test. For instance, avoid tying core logic to Activity, Context, or ViewModel classes.Instead, inject platform-dependent dependencies where needed, keeping the core business logic free from platform concerns.3. Scalability:Modular SDKs are easier to maintain and scale. If you decide to add a new feature (e.g., analytics integration), you can do so without overhauling the existing code. Separate the analytics feature into a module, and expose it only to apps that choose to include it.How to Apply Clean Architecture to SDKsDomain Layer: Handles the business rules and logic of your SDK. Expose only what’s necessary through interfaces and keep this layer entirely independent of third-party libraries or platform code.Data Layer: Manages data sources (e.g., network or local storage). Use repository patterns to abstract data operations.Interface Layer (Optional): If your SDK includes UI, provide it as an optional package, separate from the core SDK logic. Use Compose or Views but allow developers to customize it or bypass it entirely.Dependency Injection: Design your SDK to work with DI frameworks like Dagger, Koin, or Hilt, or provide a way to inject dependencies manually. This gives integrators full control over lifecycle and scoping.Key Takeaway:Clean architecture makes your SDK predictable, maintainable, and easy to integrate. Developers can trust that it will not clash with their app’s architecture or create unwanted dependencies.And I might not be the best person for teaching clean architecture. There are more than enough resources out there that you can learn from. The “Clean Architecture: A Craftsman’s Guide to Software Structure and Design” by uncle bob is the perfect resource.Swallow the Hard Pill of Library ImplementationSDK development requires a different mindset compared to app development, particularly when it comes to handling dependencies. Relying on third-party libraries in your SDK can lead to dependency hell for developers integrating it into their apps. Here’s a deeper dive into why and how to handle this challenge:Why Overusing Third-Party Libraries is ProblematicVersion Conflicts: Apps integrating your SDK may already use the same libraries (e.g., Retrofit, OkHttp, Glide) but with different versions. If your SDK forces its version of these libraries, it can lead to dependency clashes that break the app. For example The host app uses Retrofit 2.9.0, but your SDK is built with Retrofit 2.5.0. The app fails to compile because Gradle doesn’t know which version to use. Even if it compiles, runtime crashes could occur due to API differences.Increased APK Size: Every third-party library you include adds weight to the SDK. For instance, Glide adds several MBs of resources and code, which might not even be used if the app already has its own image-loading library, bloating the integrator’s app.Licensing Issues: Not all libraries are compatible with commercial or open-source SDKs. Using a library with a restrictive license (e.g., GPL) can expose your SDK and its users to legal risks. Just because a project or developer hasn’t sued you yet, doesn’t mean what you’re doing is legal.How to Avoid These PitfallsImplement Features Yourself: Yeah yeah “Don’t reinvent the wheel” and all, but we have the above problems to address, rememeber? Instead of relying on libraries for common tasks, consider implementing lightweight, custom solutions tailored to your SDK’s needs.Example: For networking, instead of using Retrofit:fun fetchAd(callback: (Result\u003cString\u003e) -\u003e Unit) { val url = URL(\"https://api.example.com/ads\") val connection = url.openConnection() as HttpURLConnection try { val data = connection.inputStream.bufferedReader().readText() callback(Result.success(data)) } catch (e: Exception) { callback(Result.failure(e)) } finally { connection.disconnect() }}This implementation avoids dragging in a large library and keeps your SDK lightweight.2. Isolate Dependencies: If a library is unavoidable, wrap it in an abstraction layer so the host app doesn’t interact with it directly. This also makes it easier to replace the library in the future without breaking the SDK’s API.Example:interface ImageLoader { fun loadImage(url: String, imageView: ImageView)}class GlideImageLoader : ImageLoader { override fun loadImage(url: String, imageView: ImageView) { Glide.with(imageView.context).load(url).into(imageView) }}Again, do this as a last resort. It’s always better to have your own implementation of essential libraries for networking, asynchronous operations, etc.3. Make Dependencies Optional: Use Gradle’s optional dependencies to allow developers to exclude libraries they don’t need.implementation(\"com.example.sdk:core:1.0.0\")implementation(\"com.example.sdk:ui:1.0.0\") // Include only if UI is neededDoes your SDK provides more than 1 functionality? Then chances are you’re gonna need a package per functionality. A very perfect and relatable example is how Firebase has designed its dependencies with its Android SDK.Key Takeaway: By implementing features in-house and isolating dependencies, you ensure your SDK is lightweight, conflict-free, and safe to integrate. Yes, it’s more work upfront, but it’s worth it to avoid becoming the SDK developers hate using.Conclusion:Developing an SDK is not just about building functionality; it’s about crafting a developer-friendly experience that integrates seamlessly into diverse apps without causing headaches. As this article has outlined, creating an effective SDK requires careful consideration of architecture, dependencies, UI integration, and communication with developers. It’s a balancing act between providing robust functionality and maintaining flexibility, scalability, and simplicity.By treating your SDK as a modular system adhering to clean architecture principles, you ensure maintainability, testability, and long-term compatibility. Writing your own libraries, while a harder path, avoids the pitfalls of third-party dependency conflicts, licensing issues, and bloated SDK sizes, making your SDK a lightweight, reliable addition to any app.Ultimately, an SDK is a tool meant to empower developers, not frustrate them. Keep your design unobtrusive, your APIs intuitive, and your documentation thorough. If you approach SDK development with the same care you would a mission-critical backend service, you’ll create a product that developers trust and love to use.SDK development may be challenging, but by applying these principles, you can turn the good, the bad, and the ugly into a toolkit that stands out in the best way possible. Remember, when developers integrate your SDK, they’re placing their trust in you — don’t let them down.",
  "image": "https://miro.medium.com/v2/resize:fit:524/1*kuUn75vaLysOS3OLM360rg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@javadlv?source=post_page---byline--9e9ab2a81697--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Javad Arjmandi\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*j1Tsxt0SOjXS-sXeat49dg.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--9e9ab2a81697--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"6f60\"\u003eSome boring backstory intro\u003c/h2\u003e\u003cp id=\"4565\"\u003eA few years ago, a friend roped me into a “simple” side project to make some extra cash. The plan? Build a few apps, slap on some ads, and watch the money roll in. Easy, right? Well… not quite. We quickly found ourselves tangled in a mess of issues. Google AdMob gave us trouble, some ad networks were outright shady, and others offered rates so bad, it wasn’t even worth the effort. After one particularly frustrating day, it hit me: “Why not build a library to handle all these ad networks and decide which ads to show based on the best deal?” Little did I know, this concept already had a name — ad mediation. Since we had a few adnetworks to play with, the idea of creating our own SDK seemed like a no-brainer.\u003cbr/\u003eTo our surprise, the SDK became such a hit (in our scale) that it completely overshadowed the apps we were trying to monetize in the first place. Suddenly, the SDK was the star of the show, and our apps? Well, they took a back seat.\u003cbr/\u003eThat was the start of my SDK-building journey.\u003c/p\u003e\u003cp id=\"23f9\"\u003eFast forward through a decade of working with SDKs — both my own and ones from big-name companies and niche B2B partners — and let’s just say, I’ve seen the good, the bad, and the downright ugly when it comes to SDKs. I think I qualify as a SDK expert.\u003c/p\u003e\u003ch2 id=\"4832\"\u003ePart 1: How NOT to develop a SDK (At least targetting the Android platform)?\u003c/h2\u003e\u003ch2 id=\"0c53\"\u003e0. Developing the SDK with a Client-Side Application Mindset\u003c/h2\u003e\u003cp id=\"3343\"\u003e\u003cstrong\u003eWhy it’s a bad idea?\u003c/strong\u003e\u003cbr/\u003eSure, building an SDK like it’s just another app sounds tempting. But remember, your SDK is going to live in other people’s apps, all with their own unique setups and preferences. Treating it like a client-side app leads to all kinds of fun issues, like tightly coupled architecture, a complete lack of flexibility, and some deliciously unintended side effects. Client apps come with all kinds of assumptions — about UI, lifecycle, and direct access to device resources — that your SDK has no business messing with. It’s like crashing someone else’s dinner party and rearranging all their furniture.\u003c/p\u003e\u003cp id=\"9c01\"\u003eI’m not saying you should disregard good practices for client-side apps. It’s equally important for them to have a good, maintainable architecture and remain flexible. However, client-side apps are generally more resilient to faults that would be unacceptable when developing an SDK. Ideally, there shouldn’t even be an option to create technical debt when building an SDK.\u003cbr/\u003e\u003cstrong\u003eWhat to do instead:\u003c/strong\u003e\u003cbr/\u003eInstead of treating your SDK like an app, think of it as a backend service that cannot be updated once live. Decouple your concerns, provide asynchronous operations, and for goodness’ sake, be lightweight and unobtrusive. Your SDK should blend into the background, flexible enough to work across a variety of apps without needing to know how they handle their UI, threading, or device resources. Be the guest that’s never noticed — until they need you.\u003c/p\u003e\u003cp id=\"784f\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e: “I Control the UI Now, Mwahaha!”\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a5b8\"\u003eclass Sdk {\u003cbr/\u003e    fun showProgressDialog(context: Context) {\u003cbr/\u003e        // Let\u0026#39;s hijack the UI without asking!\u003cbr/\u003e        ProgressDialog(context).apply {\u003cbr/\u003e            setTitle(\u0026#34;Please wait...\u0026#34;)\u003cbr/\u003e            setMessage(\u0026#34;SDK is doing something super important!\u0026#34;)\u003cbr/\u003e            show()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2a0e\"\u003eBecause who doesn’t want their UI randomly hijacked by some SDK? You’ve spent hours perfecting your app’s UX, but sure, let’s just throw in this uninvited \u003ccode\u003eProgressDialog\u003c/code\u003e in the middle of everything. Thanks, SDK!\u003c/p\u003e\u003cp id=\"9c3c\"\u003e\u003cstrong\u003eGood Practice\u003c/strong\u003e: “Wait, SDKs Shouldn’t Mess With UIs?”\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8fc6\"\u003eclass Sdk {\u003cbr/\u003e    fun performBackendOperation(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) {\u003cbr/\u003e        // Asynchronous backend logic without UI intervention\u003cbr/\u003e        callback(Result.success(\u0026#34;Operation Completed!\u0026#34;))\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c69e\"\u003eLook, mom, no UI! The SDK does what it’s supposed to: backend operations, leaving the app developer to decide how to show progress, if at all.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"08f0\"\u003eWait, what if the UI is part of what our SDK is trying to offer?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"aaf7\"\u003eYou’re already going to ruin the experience of the poor developer trying to integrate your SDK into their app. You might think:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"4528\"\u003eBut the end user will have a good experience\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"de57\"\u003eAnd while that might be true in some cases, it’s often unlikely for various reasons, including:\u003cbr/\u003e\u003cstrong\u003e1. Lack of Flexibility for Developers\u003c/strong\u003e: Predefined UI components limit developers’ ability to customize the user interface, making it difficult to align the SDK’s UI with the app’s branding and design. Since the UI is fixed, integrators also lose the ability to embed custom analytics, making it harder to track user activity for marketing or product analysis. This leads to inconsistent user experiences and missed insights, negatively impacting the perception of both the app and the SDK.\u003c/p\u003e\u003cp id=\"41e9\"\u003e\u003cstrong\u003e2. Resource Conflicts\u003c/strong\u003e: Bundling UI components can cause resource naming collisions (e.g., IDs, styles, or themes) between the SDK and the host app, leading to unexpected crashes or visual inconsistencies. These issues can require significant debugging effort, reducing developers’ trust in the SDK.\u003c/p\u003e\u003cp id=\"6001\"\u003e\u003cstrong\u003e3. Increased Maintenance Complexity\u003c/strong\u003e: Including UI in the SDK requires ongoing maintenance to ensure compatibility with various Android versions, devices, and design guidelines. This increases the maintenance burden, and delays or unaddressed issues can frustrate developers and users, making the SDK less appealing.\u003c/p\u003e\u003cp id=\"068e\"\u003e\u003cstrong\u003e4. Larger SDK Size\u003c/strong\u003e: Shipping UI components increases the overall size of the SDK, which contributes to larger app sizes. This can deter developers from adopting the SDK, and end-users may avoid downloading apps or uninstall them due to size concerns, indirectly affecting SDK adoption. (like yeah, let’s integrate “com.github.javad:awesome-animation:0.0.2” and add 5 more megabytes to poor developer’s app)\u003c/p\u003e\u003cp id=\"329f\"\u003e\u003cstrong\u003e5. Limited Reusability and Scalability\u003c/strong\u003e: UI components shipped with the SDK are often not reusable or scalable across different projects. Developers working on apps with custom flows or designs may need to bypass or rewrite the SDK’s UI. Additionally, because the UI is fixed, integrators cannot track user activity within the SDK for custom marketing or product analytics purposes, reducing its value and making it appear rigid and developer-unfriendly.\u003c/p\u003e\u003cp id=\"936b\"\u003eIf you \u003cstrong\u003e\u003cem\u003eabsolutely have to\u003c/em\u003e\u003c/strong\u003e ship UI as part of your project, the best way to approach it is \u003cstrong\u003eto make the UI optional and modular\u003c/strong\u003e. Here’s how you can do it:\u003c/p\u003e\u003col\u003e\u003cli id=\"b01c\"\u003e\u003cstrong\u003eSeparate UI and Core Logic\u003c/strong\u003e: Create two distinct packages: one for the core functionality and one for the UI components. This allows developers to choose whether they want to use the provided UI or build their own while still leveraging the core logic of the SDK.\u003c/li\u003e\u003cli id=\"95e0\"\u003e\u003cstrong\u003eProvide Clear Documentation\u003c/strong\u003e: Offer detailed instructions for implementing the SDK with and without the built-in UI. Include code samples and guidelines for developers who want to customize or replace the default UI.\u003c/li\u003e\u003cli id=\"69d0\"\u003e\u003cstrong\u003eMake the UI Customizable\u003c/strong\u003e: If you include a UI package, ensure it is fully customizable. Allow developers to override styles, colors, fonts, and even layouts to match their app’s branding and design.\u003c/li\u003e\u003cli id=\"b341\"\u003e\u003cstrong\u003eDesign for Integration\u003c/strong\u003e: Ensure the UI components follow Android’s Material Design guidelines and can adapt seamlessly to different themes, orientations, and screen sizes. Use isolated namespaces to avoid resource conflicts.\u003c/li\u003e\u003cli id=\"1c1d\"\u003e\u003cstrong\u003eSupport Analytics Hooks\u003c/strong\u003e: Provide APIs or callbacks that allow developers to integrate their analytics and tracking solutions into the SDK’s UI. This ensures that they can still collect data and maintain insights into user behavior.\u003c/li\u003e\u003cli id=\"c961\"\u003e\u003cstrong\u003eOffer a “Headless Mode”\u003c/strong\u003e: For advanced users, offer a “headless” mode that exposes only the core logic, enabling developers to integrate it into their own UI without relying on your SDK’s visuals.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"ec47\"\u003eAn ideal SDK with UI should have at least 2 importable modules, 1 for the core functionality, and one for UI.\u003c/p\u003e\u003ch2 id=\"796a\"\u003e1. Using 3rd Party Libraries Inside Your SDK\u003c/h2\u003e\u003cp id=\"a33c\"\u003e\u003cstrong\u003eWhy it’s a bad idea?\u003c/strong\u003e\u003cbr/\u003eSure, nothing says “I’m in a hurry” like cramming in every shiny third-party library you can find. But here’s the catch: it comes with a whole list of issues. Ever dealt with version conflicts? Yeah, enjoy those. Licensing problems? Even better! Or how about making the host app developers manage complex dependency resolution because your SDK decided to use a different version of Retrofit, OkHttp, Glide, and Lottie than they do? Just imagine the joy when their app breaks, and they have to dig through Maven hell to figure out which library caused the explosion. You’re welcome!\u003cbr/\u003e\u003cstrong\u003eWhat to do instead:\u003c/strong\u003e\u003cbr/\u003eMinimize external dependencies like you’re on a code diet. Especially for core functionality. If you absolutely must drag in third-party libraries (and hey, I get it, they’re useful), isolate them. Or better yet, give the app developers the option to exclude or replace them. And please, document what libraries you’re using so it doesn’t feel like a game of “surprise dependency roulette.” It’s a party no one wants to attend.\u003c/p\u003e\u003cp id=\"f260\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e: “Let’s Bring the Whole Party! Retrofit, OkHttp, Glide, and Lottie!”\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"efcb\"\u003eclass Sdk {\u003cbr/\u003e    // Retrofit to fetch data\u003cbr/\u003e    private val retrofit = Retrofit.Builder()\u003cbr/\u003e        .baseUrl(\u0026#34;https://api.example.com/\u0026#34;)\u003cbr/\u003e        .build()\u003cp\u003e    // OkHttp for all the fancy HTTP interceptors\u003cbr/\u003e    private val client = OkHttpClient.Builder().build()\u003c/p\u003e\u003cp\u003e    // Glide to load images, of course\u003cbr/\u003e    fun loadImage(context: Context, imageUrl: String, imageView: ImageView) {\u003cbr/\u003e        Glide.with(context)\u003cbr/\u003e            .load(imageUrl)\u003cbr/\u003e            .into(imageView)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // And why not add Lottie animations for good measure?\u003cbr/\u003e    fun showLottieAnimation(context: Context, animationView: LottieAnimationView) {\u003cbr/\u003e        animationView.setAnimation(\u0026#34;cool_animation.json\u0026#34;)\u003cbr/\u003e        animationView.playAnimation()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"304b\"\u003eBecause why just load ads when you can load the entire internet along with them? Let’s add \u003cstrong\u003eRetrofit\u003c/strong\u003e for fetching some unnecessary data, \u003cstrong\u003eOkHttp\u003c/strong\u003e for all those fancy interceptors, \u003cstrong\u003eGlide\u003c/strong\u003e to load the most important image in history, and hey, let’s slap a \u003cstrong\u003eLottie\u003c/strong\u003e animation on it too. What could go wrong? 🤷‍♂️\u003c/li\u003e\u003cli id=\"44cb\"\u003eI mean, who doesn’t love an SDK that bloats your app by 10MB with libraries it never even needed? Oh, and good luck dealing with version conflicts in your app! 😎\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7ab8\"\u003e\u003cstrong\u003eGood Practice\u003c/strong\u003e: “Just Keep It Simple, Stupid”\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b0e0\"\u003eclass Sdk {\u003cbr/\u003e    // Avoid unnecessary dependencies\u003cbr/\u003e    fun performSimpleNetworkOperation(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) {\u003cbr/\u003e        // Use plain old URL and HttpURLConnection, or let the app manage HTTP libraries.\u003cbr/\u003e        callback(Result.success(\u0026#34;Fetched data\u0026#34;))\u003cbr/\u003e    }\u003cp\u003e    // Let the app handle image loading and animations\u003cbr/\u003e    fun loadDataAndReturnUrl(callback: (String) -\u0026gt; Unit) {\u003cbr/\u003e        // Just return a URL and let the app handle loading the image or animation\u003cbr/\u003e        callback(\u0026#34;https://image.example.com\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4896\"\u003eHere’s an idea: let the \u003cstrong\u003edeveloper\u003c/strong\u003e decide if they want to use Retrofit, OkHttp, Glide, or Lottie. Stop packing your SDK like it’s the IKEA of dependencies. Simplicity wins the day.\u003c/p\u003e\u003ch2 id=\"64fe\"\u003e1.1 Using Deprecated Libraries\u003c/h2\u003e\u003cp id=\"794f\"\u003e\u003cstrong\u003eWhy it’s a bad idea? (as if them being a 3rd party is not bad enough)\u003c/strong\u003e\u003cbr/\u003eAh, deprecated libraries — like old, broken toys that should’ve been thrown out years ago, but somehow you just can’t let go. They no longer receive updates, bug fixes, or any kind of love. In fact, they bring along security vulnerabilities and compatibility issues like unwanted party crashers. If your SDK relies on them, congratulations: you’ve just created a ticking time bomb for your users’ apps.\u003cbr/\u003e\u003cstrong\u003eWhat to do instead:\u003c/strong\u003e\u003cbr/\u003eKeep up with the times. Refactor your SDK and ditch deprecated libraries before they sink the ship. Continuously monitor the libraries you’re using (yes, that means some extra work) and update them before they’re completely irrelevant — or worse, break something critical. Your users will thank you for not making them fight with zombie dependencies.\u003c/p\u003e\u003cp id=\"fbc6\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e: “AsyncTask is My Best Friend”\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d643\"\u003eclass Sdk {\u003cbr/\u003e    fun fetchDataInBackground() {\u003cbr/\u003e        // Who cares if AsyncTask is deprecated? It’s a classic!\u003cbr/\u003e        object : AsyncTask\u0026lt;Void, Void, String\u0026gt;() {\u003cbr/\u003e            override fun doInBackground(vararg params: Void?): String {\u003cbr/\u003e                // Simulating a network call\u003cbr/\u003e                return \u0026#34;Data fetched from background\u0026#34;\u003cbr/\u003e            }\u003cp\u003e            override fun onPostExecute(result: String?) {\u003cbr/\u003e                // Handle result on the main thread\u003cbr/\u003e            }\u003cbr/\u003e        }.execute()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6243\"\u003eBecause who cares about Kotlin coroutines when we can use trusty old \u003cstrong\u003eAsyncTask\u003c/strong\u003e that Google has been telling us to avoid for years? Let’s keep that 2012 vibe going strong. (And yes, I first hand found someone use it in 2024)\u003c/p\u003e\u003cp id=\"a900\"\u003e\u003cstrong\u003eGood Practice\u003c/strong\u003e: “Welcome to the 2020s — We Have Coroutines Now”\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3a7a\"\u003eclass Sdk {\u003cbr/\u003e    fun fetchDataInBackground(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) {\u003cbr/\u003e        GlobalScope.launch(Dispatchers.IO) {\u003cbr/\u003e            try {\u003cbr/\u003e                val data = \u0026#34;Fetched data\u0026#34;\u003cbr/\u003e                withContext(Dispatchers.Main) {\u003cbr/\u003e                    callback(Result.success(data))\u003cbr/\u003e                }\u003cbr/\u003e            } catch (e: Exception) {\u003cbr/\u003e                withContext(Dispatchers.Main) {\u003cbr/\u003e                    callback(Result.failure(e))\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"942d\"\u003eAh, \u003cstrong\u003eKotlin Coroutines\u003c/strong\u003e, the cool, modern way to handle background tasks without dragging apps back to the dark ages. The best part? They don’t trigger ANRs and actually make you look like you know what you’re doing.\u003c/p\u003e\u003cp id=\"5551\"\u003eI’m not ranting about coroutines. I’m talking about those libraries buried six feet under in the graveyard of GitHub, last updated in 2019. Found some old but “reliable” library that’s no longer maintained? Great, now \u003cem\u003edefinitely\u003c/em\u003e don’t use its sketchy forks in an SDK you’re shipping for poor developers to suffer through. Always remember: if the original library was abandoned, there’s probably a good reason for it. Do everyone a favor and find a modern replacement instead.\u003c/p\u003e\u003ch2 id=\"0bc9\"\u003e2. Using Singletons and Global State Management\u003c/h2\u003e\u003ch2 id=\"4fa0\"\u003eWhy It’s a Bad Idea:\u003c/h2\u003e\u003cp id=\"e6cc\"\u003eAh yes, singletons — easy to set up, but a nightmare to live with when combined with mutable global state. They introduce unpredictable behavior, especially in multi-threaded environments, leading to race conditions, inconsistent states, and debugging nightmares. Need more than one instance of your SDK in the same app? Good luck with that. Worse, singletons often cause memory leaks by holding references to contexts or activities. They also hide dependencies, making code harder to test, maintain, and extend. Simply put, global state is a global headache.\u003c/p\u003e\u003ch2 id=\"e824\"\u003eWhat to Do Instead:\u003c/h2\u003e\u003cp id=\"8ded\"\u003eUse dependency injection or factory patterns to create and manage your SDK instances. This gives the client app control over the scope and lifecycle of your SDK components, ensuring predictable behavior. Avoid mutable global state — keep state context-aware and scoped to instances. If you need shared functionality, consider context-safe singletons with immutable state or thread-safe designs. And always design your SDK to support multiple instances where applicable. Responsible scoping leads to cleaner code and fewer headaches.\u003c/p\u003e\u003cp id=\"4786\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e: “Global State, Global Headache”\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"eda3\"\u003eobject SdkSingleton {\u003cbr/\u003e    var globalAdState: String = \u0026#34;No ad loaded yet\u0026#34;\u003cp\u003e    fun loadAd() {\u003cbr/\u003e        // Modify global state at will!\u003cbr/\u003e        globalAdState = \u0026#34;Ad loaded!\u0026#34;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b3da\"\u003e\u003cstrong\u003eGood Practice: “Let’s Scope This Like Adults”\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1dd8\"\u003eclass Sdk(private var adState: String) {\u003cbr/\u003e    fun loadAd(): Sdk {\u003cbr/\u003e        // Create a new instance with updated state\u003cbr/\u003e        return Sdk(\u0026#34;Ad loaded!\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e// Create new instances without messing with global state\u003cbr/\u003eval sdkInstance = Sdk(\u0026#34;No ad loaded\u0026#34;)\u003cbr/\u003eval newSdkInstance = sdkInstance.loadAd()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6693\"\u003eKeep your global state to yourself, thank you. Scoping state to instances like a responsible developer means fewer headaches and less chaos.\u003c/p\u003e\u003ch2 id=\"54ff\"\u003e3. Poor Documentation\u003c/h2\u003e\u003cp id=\"b817\"\u003e\u003cstrong\u003eWhy it’s a bad idea?\u003c/strong\u003e\u003cbr/\u003eSo, you’ve built an amazing SDK, but forgot to tell anyone how to actually use it. Now developers are banging their heads against the wall trying to figure out what your methods do. Misuse, bugs, and frustrated support emails follow. But hey, it’s their fault for not reading your mind, right?\u003cbr/\u003e\u003cstrong\u003eWhat to do instead:\u003c/strong\u003e\u003cbr/\u003eWrite documentation like you’re being graded on it. Clear, concise, and, most importantly, up-to-date. Include everything developers need: installation instructions, detailed API references, code examples, common use cases, and troubleshooting guides. And remember, just like your SDK, your docs should evolve. Developers don’t have time for guesswork; help them out!\u003c/p\u003e\u003cp id=\"16bd\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e: “Good Luck, You’ll Need It”\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"82e3\"\u003eclass Sdk {\u003cbr/\u003e    fun doSomethingSuperImportant() {\u003cbr/\u003e        // But I won’t tell you how or why\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1e1d\"\u003e\u003cstrong\u003eGood Practice\u003c/strong\u003e: “Let’s Be Nice — Write Documentation”\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4493\"\u003e/**\u003cbr/\u003e * Performs an important task that retrieves user data.\u003cbr/\u003e *\u003cbr/\u003e * @param userId ID of the user to fetch data for.\u003cbr/\u003e * @return User data in a Result wrapper.\u003cbr/\u003e */\u003cbr/\u003eclass Sdk {\u003cbr/\u003e    fun fetchUserData(userId: String, callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) {\u003cbr/\u003e        // Retrieves user data and passes it to the callback\u003cbr/\u003e        callback(Result.success(\u0026#34;User data for $userId\u0026#34;))\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"315a\"\u003eImagine the joy on a developer’s face when they actually understand how your SDK works! Clear documentation is like a ray of sunshine on a cloudy day.\u003c/p\u003e\u003ch2 id=\"b397\"\u003e4. Bad Communication of Changes\u003c/h2\u003e\u003cp id=\"3f9f\"\u003e\u003cstrong\u003eWhy it’s a bad idea?\u003c/strong\u003e\u003cbr/\u003eMaking breaking changes without telling anyone is the ultimate plot twist. You’ll leave developers scratching their heads when their app mysteriously starts crashing after your latest update. And when features disappear or behaviors change with no explanation? Well, you’ve just created a new level of frustration. Bonus points if the developer only finds out after deploying their app to production! \u003cbr/\u003e\u003cstrong\u003eWhat to do instead:\u003c/strong\u003e\u003cbr/\u003eCommunicate like an adult. Use proper versioning (ever heard of semantic versioning? It’s your friend). Maintain a changelog that’s actually useful, marking breaking changes clearly, and providing migration guides. Offering beta releases to let developers adapt before the official update drops? Now that’s next-level professional.\u003c/p\u003e\u003ch2 id=\"6eb6\"\u003e5. Heavy-loading and Big Size of the AAR\u003c/h2\u003e\u003cp id=\"044c\"\u003e\u003cstrong\u003eWhy it’s a bad idea?\u003c/strong\u003e\u003cbr/\u003eYour SDK should be lean and mean, but instead, it’s bloated like a post-buffet nap. A large SDK increases app size, leading to longer build times, sluggish performance, and higher memory usage. You’ve just transformed that sleek app into a lumbering dinosaur. End users now get to enjoy painfully slow downloads, and developers get to spend their days trying to optimize around your behemoth of an SDK.\u003cbr/\u003e\u003cstrong\u003eWhat to do instead:\u003c/strong\u003e\u003cbr/\u003eTrim the fat. Optimize your SDK by stripping unused code and resources. Use ProGuard or R8 to shrink and obfuscate code, and modularize your SDK so developers can choose only the parts they need. The goal? A lightweight core with optional feature modules. Because no one likes dragging around unnecessary baggage.\u003c/p\u003e\u003cp id=\"d2c7\"\u003e\u003cstrong\u003eExample: \u003c/strong\u003e“Let’s Make This AAR the Size of a Small Planet”\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7185\"\u003e// Packed with unnecessary resources like high-res images and massive JSON files\u003cbr/\u003eres/drawable/hd_background.png\u003cbr/\u003eres/animations/full_length_animation.json\u003cbr/\u003easset/mother_nature.so\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b0b3\"\u003e\u003cstrong\u003eGood Practice: “Let’s Not Make Developers Hate Us”\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1e08\"\u003e// Use ProGuard to slim down the AAR \u003cbr/\u003eandroid {\u003cbr/\u003e    buildTypes {\u003cbr/\u003e        release {\u003cbr/\u003e            minifyEnabled true\u003cbr/\u003e            proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39;\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e// Split into modules so developers can choose what they actually need\u003cbr/\u003eimplementation(\u0026#34;com.example.sdk:core:1.0.0\u0026#34;)\u003cbr/\u003eimplementation(\u0026#34;com.example.sdk:ad-module:1.0.0\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"ee7a\"\u003ePart 2: An Ideal approach\u003c/h2\u003e\u003ch2 id=\"fc7d\"\u003e1. SDKs Are Modules in Disguise\u003c/h2\u003e\u003cp id=\"27e4\"\u003eThe process of developing an SDK closely resembles that of designing a module in a modular architecture, and adhering to \u003cstrong\u003eclean architecture principles\u003c/strong\u003e isn’t just “nice to have” — it’s essential. An SDK must behave like a guest in someone else’s app, blending seamlessly without imposing on the host app’s architecture. Let’s break this down technically:\u003c/p\u003e\u003ch2 id=\"58a4\"\u003eWhy Clean Architecture is Essential for SDKs\u003c/h2\u003e\u003col\u003e\u003cli id=\"ac76\"\u003e\u003cstrong\u003eDecoupling Concerns\u003c/strong\u003e:\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli id=\"4d83\"\u003eClean architecture separates \u003cstrong\u003ebusiness logic\u003c/strong\u003e (what the SDK does) from \u003cstrong\u003eimplementation details\u003c/strong\u003e (how it does it). For example, the SDK should expose its core functionality via interfaces or abstract classes, while internal implementations remain private and modularized.\u003c/li\u003e\u003cli id=\"79e8\"\u003eThis ensures the SDK is flexible and doesn’t directly tie its implementation to specific frameworks or third-party libraries.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"9642\"\u003einterface AdLoader {\u003cbr/\u003e    fun loadAd(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit)\u003cbr/\u003e}\u003cp\u003eclass AdLoaderImpl(private val networkClient: NetworkClient) : AdLoader {\u003cbr/\u003e    override fun loadAd(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) {\u003cbr/\u003e        networkClient.fetchAd { result -\u0026gt;\u003cbr/\u003e            callback(result)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"013f\"\u003eHere, \u003ccode\u003eAdLoader\u003c/code\u003e abstracts the business logic of loading ads, while \u003ccode\u003eAdLoaderImpl\u003c/code\u003e provides the implementation. The app integrating the SDK only interacts with the interface, keeping things modular and easy to test.\u003c/p\u003e\u003cp id=\"5346\"\u003e2. \u003cstrong\u003eTestability\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"418d\"\u003eClean architecture ensures your SDK’s core logic is independent of Android-specific APIs, making it easier to test. For instance, avoid tying core logic to \u003ccode\u003eActivity\u003c/code\u003e, \u003ccode\u003eContext\u003c/code\u003e, or \u003ccode\u003eViewModel\u003c/code\u003e classes.\u003c/li\u003e\u003cli id=\"ddda\"\u003eInstead, inject platform-dependent dependencies where needed, keeping the core business logic free from platform concerns.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"32b5\"\u003e\u003cstrong\u003e3. Scalability\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"441d\"\u003eModular SDKs are easier to maintain and scale. If you decide to add a new feature (e.g., analytics integration), you can do so without overhauling the existing code. Separate the analytics feature into a module, and expose it only to apps that choose to include it.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"8010\"\u003eHow to Apply Clean Architecture to SDKs\u003c/h2\u003e\u003col\u003e\u003cli id=\"9b35\"\u003e\u003cstrong\u003eDomain Layer\u003c/strong\u003e: Handles the business rules and logic of your SDK. Expose only what’s necessary through interfaces and keep this layer entirely independent of third-party libraries or platform code.\u003c/li\u003e\u003cli id=\"62d5\"\u003e\u003cstrong\u003eData Layer: \u003c/strong\u003eManages data sources (e.g., network or local storage). Use repository patterns to abstract data operations.\u003c/li\u003e\u003cli id=\"5b59\"\u003e\u003cstrong\u003eInterface Layer (Optional)\u003c/strong\u003e: If your SDK includes UI, provide it as an optional package, separate from the core SDK logic. Use Compose or Views but allow developers to customize it or bypass it entirely.\u003c/li\u003e\u003cli id=\"93bf\"\u003e\u003cstrong\u003eDependency Injection\u003c/strong\u003e: Design your SDK to work with DI frameworks like Dagger, Koin, or Hilt, or provide a way to inject dependencies manually. This gives integrators full control over lifecycle and scoping.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"f204\"\u003e\u003cstrong\u003eKey Takeaway\u003c/strong\u003e:\u003cbr/\u003eClean architecture makes your SDK predictable, maintainable, and easy to integrate. Developers can trust that it will not clash with their app’s architecture or create unwanted dependencies.\u003c/p\u003e\u003cp id=\"9e87\"\u003eAnd I might not be the best person for teaching clean architecture. There are more than enough resources out there that you can learn from. The “Clean Architecture: A Craftsman’s Guide to Software Structure and Design” by \u003ca href=\"https://en.wikipedia.org/wiki/Robert_C._Martin\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003euncle bob\u003c/a\u003e is the perfect resource.\u003c/p\u003e\u003ch2 id=\"c21d\"\u003eSwallow the Hard Pill of Library Implementation\u003c/h2\u003e\u003cp id=\"ec0e\"\u003eSDK development requires a different mindset compared to app development, particularly when it comes to handling dependencies. Relying on third-party libraries in your SDK can lead to \u003ca href=\"https://en.wikipedia.org/wiki/Dependency_hell\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003edependency hell\u003c/strong\u003e\u003c/a\u003e for developers integrating it into their apps. Here’s a deeper dive into why and how to handle this challenge:\u003c/p\u003e\u003ch2 id=\"4075\"\u003eWhy Overusing Third-Party Libraries is Problematic\u003c/h2\u003e\u003col\u003e\u003cli id=\"638b\"\u003e\u003cstrong\u003eVersion Conflicts\u003c/strong\u003e: Apps integrating your SDK may already use the same libraries (e.g., Retrofit, OkHttp, Glide) but with different versions. If your SDK forces its version of these libraries, it can lead to dependency clashes that break the app. For example The host app uses Retrofit 2.9.0, but your SDK is built with Retrofit 2.5.0. The app fails to compile because Gradle doesn’t know which version to use. Even if it compiles, runtime crashes could occur due to API differences.\u003c/li\u003e\u003cli id=\"6ce7\"\u003e\u003cstrong\u003eIncreased APK Size\u003c/strong\u003e: Every third-party library you include adds weight to the SDK. For instance, Glide adds several MBs of resources and code, which might not even be used if the app already has its own image-loading library, bloating the integrator’s app.\u003c/li\u003e\u003cli id=\"c46e\"\u003e\u003cstrong\u003eLicensing Issues\u003c/strong\u003e: Not all libraries are compatible with commercial or open-source SDKs. Using a library with a restrictive license (e.g., GPL) can expose your SDK and its users to legal risks. Just because a project or developer hasn’t sued you yet, doesn’t mean what you’re doing is legal.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"f1bf\"\u003eHow to Avoid These Pitfalls\u003c/h2\u003e\u003col\u003e\u003cli id=\"fd58\"\u003e\u003cstrong\u003eImplement Features Yourself\u003c/strong\u003e: Yeah yeah “Don’t reinvent the wheel” and all, but we have the above problems to address, rememeber? Instead of relying on libraries for common tasks, consider implementing lightweight, custom solutions tailored to your SDK’s needs.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"3666\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e: For networking, instead of using Retrofit:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"81c1\"\u003efun fetchAd(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) {\u003cbr/\u003e    val url = URL(\u0026#34;https://api.example.com/ads\u0026#34;)\u003cbr/\u003e    val connection = url.openConnection() as HttpURLConnection\u003cbr/\u003e    try {\u003cbr/\u003e        val data = connection.inputStream.bufferedReader().readText()\u003cbr/\u003e        callback(Result.success(data))\u003cbr/\u003e    } catch (e: Exception) {\u003cbr/\u003e        callback(Result.failure(e))\u003cbr/\u003e    } finally {\u003cbr/\u003e        connection.disconnect()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e6b9\"\u003eThis implementation avoids dragging in a large library and keeps your SDK lightweight.\u003c/p\u003e\u003cp id=\"7a7e\"\u003e\u003cstrong\u003e2. Isolate Dependencies\u003c/strong\u003e: If a library is \u003ca href=\"https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eunavoidable\u003c/a\u003e, wrap it in an abstraction layer so the host app doesn’t interact with it directly. This also makes it easier to replace the library in the future without breaking the SDK’s API.\u003c/p\u003e\u003cp id=\"6b39\"\u003eExample:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4152\"\u003einterface ImageLoader {\u003cbr/\u003e    fun loadImage(url: String, imageView: ImageView)\u003cbr/\u003e}\u003cp\u003eclass GlideImageLoader : ImageLoader {\u003cbr/\u003e    override fun loadImage(url: String, imageView: ImageView) {\u003cbr/\u003e        Glide.with(imageView.context).load(url).into(imageView)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9000\"\u003eAgain, do this as a last resort. It’s always better to have your own implementation of essential libraries for networking, asynchronous operations, etc.\u003c/p\u003e\u003cp id=\"ba78\"\u003e\u003cstrong\u003e3. Make Dependencies Optional\u003c/strong\u003e: Use Gradle’s optional dependencies to allow developers to exclude libraries they don’t need.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ae0e\"\u003eimplementation(\u0026#34;com.example.sdk:core:1.0.0\u0026#34;)\u003cbr/\u003eimplementation(\u0026#34;com.example.sdk:ui:1.0.0\u0026#34;) // Include only if UI is needed\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6591\"\u003eDoes your SDK provides more than 1 functionality? Then chances are you’re gonna need a package per functionality. A very perfect and relatable example is how \u003ca href=\"https://firebase.google.com/docs/android/android-play-services\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFirebase\u003c/a\u003e has designed its dependencies with its Android SDK.\u003c/p\u003e\u003cp id=\"ea56\"\u003e\u003cstrong\u003eKey Takeaway\u003c/strong\u003e: By implementing features in-house and isolating dependencies, you ensure your SDK is lightweight, conflict-free, and safe to integrate. Yes, it’s more work upfront, but it’s worth it to avoid becoming the SDK developers hate using.\u003c/p\u003e\u003ch2 id=\"c2b9\"\u003eConclusion:\u003c/h2\u003e\u003cp id=\"9583\"\u003eDeveloping an SDK is not just about building functionality; it’s about crafting a developer-friendly experience that integrates seamlessly into diverse apps without causing headaches. As this article has outlined, creating an effective SDK requires careful consideration of architecture, dependencies, UI integration, and communication with developers. It’s a balancing act between providing robust functionality and maintaining flexibility, scalability, and simplicity.\u003c/p\u003e\u003cp id=\"343c\"\u003eBy treating your SDK as a modular system adhering to clean architecture principles, you ensure maintainability, testability, and long-term compatibility. Writing your own libraries, while a harder path, avoids the pitfalls of third-party dependency conflicts, licensing issues, and bloated SDK sizes, making your SDK a lightweight, reliable addition to any app.\u003c/p\u003e\u003cp id=\"8339\"\u003eUltimately, an SDK is a tool meant to empower developers, not frustrate them. Keep your design unobtrusive, your APIs intuitive, and your documentation thorough. If you approach SDK development with the same care you would a mission-critical backend service, you’ll create a product that developers trust and love to use.\u003c/p\u003e\u003cp id=\"ef45\"\u003eSDK development may be challenging, but by applying these principles, you can turn the good, the bad, and the ugly into a toolkit that stands out in the best way possible. Remember, when developers integrate your SDK, they’re placing their trust in you — don’t let them down.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "29 min read",
  "publishedTime": "2024-11-21T22:47:18.179Z",
  "modifiedTime": null
}
