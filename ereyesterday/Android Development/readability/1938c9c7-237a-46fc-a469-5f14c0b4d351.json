{
  "id": "1938c9c7-237a-46fc-a469-5f14c0b4d351",
  "title": "Widgets with Glance: Displaying Images",
  "link": "https://proandroiddev.com/widgets-with-glance-displaying-images-fe6a1c63c128?source=rss----c72404660798---4",
  "description": "",
  "author": "Katie Barnett",
  "published": "Fri, 17 Jan 2025 20:17:12 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "widget",
    "image-loading-and-caching",
    "android",
    "jetpack-glance",
    "android-development"
  ],
  "byline": "Katie Barnett",
  "length": 6942,
  "excerpt": "Images from drawables, from bitmaps, from a url - from anywhere! See how to efficiently display images in your home page widgets no matter the source.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "If you are getting into widgets, pretty soon you are going to want to display images, whether that be a simple icon or a lovely graphic to brighten up your user’s home screen. Depending on where your image is stored (within your app as a drawable or from the internet) there are a few methods and some are more straightforward than others.Let’s start simple with drawables…Displaying drawablesDisplaying a local icon or image is easy from an app drawable resource, all you need is to create an ImageProvider, pass in the drawable resource ID and then use it in a Image Glance composable:In the above I have applied a ColorFilter to tint the image and a contentDescription for accessibility. Any sizing or padding can be set via the GlanceModifier as usual and contentScale will control how the image fits within the Image boundaries (more on this later).Just a simple happy drawable displaying on a widget. The drawable is emoji by Maxim Kulikov from The Noun ProjectNow, this is pretty simple, what if we want the widget to display a pretty photo? If it is stored as a drawable resource then this is exactly the same:Looking pretty. Image from Lorem PicsumHere I have expanded the image to fit the space and used ContentScale.Crop so it maintains the original aspect ratio and displays edge to edge in my widget.Glance ContentScale optionsLet’s go back to looking at ContentScale. As usual, with Jetpack Glance we have fewer options than we have with regular Jetpack Compose. The ContentScale options are:ContentScale.Crop — Scale uniformly (maintaining aspect ratio) so that both dimensions (width and height) will be equal to or larger than the corresponding dimension of the image composable.ContentScale.Fit — Scale uniformly (maintaining aspect ratio) so that both dimensions (width and height) will be equal to or less than the corresponding dimension of the image composableContentScale.FillBounds — Scale horizontal and vertically non-uniformly to fill the image composable bounds.Displaying an image from a urlNow, we get to what you are probably reading this article for. How to display an image from the internet in a widget. Unfortunately we can’t just directly use your favourite image loading library like Coil, Glide or Picasso as they don’t have Glance composables that we can put in Glance widget UI code (for various reasons). Instead, we need to load the image first into a bitmap, then use ImageProvider(bitmap) to load this in our Image Glance composable.For this, we have two options depending on the use case:Load the image as a bitmap using a background threadUse a coroutine worker to download the image as a fileImage Bitmap with a background threadThis is the simplest option and is useful for widgets where the image is independent from the rest of the widget display (see below for when you wouldn’t want to use this option).The first step is making use of Coil ImageRequest to download the image as a bitmap.In the above I am explicitly disabling the image caching in the request, but you can alter this depending what your image is used for.By placing this in a LaunchedEffect with a a context of Dispatches.IO we can run this code on the background thread and not lock up the UI thread.Saving the result into a mutableState then enables the rest of the composable to respond once the image has been downloaded:While the loadedBitmap state is null we can show a loading indicator and once it is ready, display the image using the Image Glance composable and a ImageProvider.Now this works well:The author information is fetched during the first “Loading”, the image is downloaded while the spinner is displayed.Except in this case, it doesn’t make sense to show the image author before we actually show the image. Also, if an error occurs during loading we just have this circular progress indicator without any way of recovery.We could fix this by adding more logic to the UI to set success \u0026 error states based on the image download but this is more brittle especially when we have data coming from different sources (in this case metadata from one endpoint and image from another — for the full example see my widget demo github repository).So ideally we don’t want to use this method if showing the rest of the widget without the image makes no sense.To load everything together and respond to the whole data state use a Coroutine Worker.Image file with a Coroutine WorkerThis method, while more complex, is useful if you are doing other background processing (such as fetching other data from a remote source) and want the image and the new data state to be available at the same time.For this you can use string states using the standard PreferencesGlanceStateDefinition but I recommend using a CustomGlanceStateDefinition so that the different widget data states (e.g. success, loading \u0026 error) are more clearly defined. You can find more details on how to implement this and the Coroutine Worker itself in my previous blog post Widgets with Glance: Beyond String States.To achieve this the first task is to download the image as a temporary file on the device that we can read later from the widget. We can do this using Coil and the image cache:In this case we have enabled the Coil image cache — we want the image to be cached so we can fetch the file from the cache.So here, the image file is downloaded into the cache using the url as the cache key so we can retrieve it later (the url is the key by default).This method should be in your Coroutine Worker for the widget and called within the doWork method when you update the rest of the widget state.Next, we need to access the Coil image cache. For this we need a FileProvider and specify which files we will be accessing:Setting up this provider enables us to access the files in theimage_cache directory which is the default used by Coil.Now, we can use this in the downloadImage method:Permission handling for File ProvidersIf you are using a FileProvider you may encouter something like this error:Permission Denial: opening provider com.your.package.ImageFileProvider from ProcessRecord{...} that is not exported from UID xxxxxThis will usually occur if you are displaying (or changing) an image in your widget a long time after your app was last open. What happens here is that the permission for the URI is lost when the MainActivity is lost (such as being naturally closed in the background). If you have recently installed or updated your app (such as debugging and deploying to your device) you are unlikely to see this as your activity is still open. (Thanks to this Stack Overflow post for the explanation).To fix this we need to request the permission prior to accessing the image. This won’t show anything to the user as it is not a restricted or special permission. To do this, add the following to the downloadImage method:Now, the image and data load at the same time!The complete downloadImage method that returns the file url:",
  "image": "https://miro.medium.com/v2/resize:fill:780:411/g:fp:0.5:0.46/1*TgILaaTwLMBvCJb98TlX2Q.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp id=\"79b4\"\u003eIf you are getting into widgets, pretty soon you are going to want to display images, whether that be a simple icon or a lovely graphic to brighten up your user’s home screen. Depending on where your image is stored (within your app as a drawable or from the internet) there are a few methods and some are more straightforward than others.\u003c/p\u003e\u003cp id=\"802a\"\u003eLet’s start simple with drawables…\u003c/p\u003e\u003ch2 id=\"4d6a\"\u003eDisplaying drawables\u003c/h2\u003e\u003cp id=\"f3fb\"\u003eDisplaying a local icon or image is easy from an app drawable resource, all you need is to create an \u003ccode\u003eImageProvider\u003c/code\u003e, pass in the drawable resource ID and then use it in a \u003ccode\u003eImage\u003c/code\u003e Glance composable:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"65b7\"\u003eIn the above I have applied a \u003ccode\u003eColorFilter\u003c/code\u003e to tint the image and a \u003ccode\u003econtentDescription\u003c/code\u003e for accessibility. Any sizing or padding can be set via the \u003ccode\u003eGlanceModifier\u003c/code\u003e as usual and \u003ccode\u003econtentScale\u003c/code\u003e will control how the image fits within the \u003ccode\u003eImage\u003c/code\u003e boundaries (more on this later).\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eJust a simple happy drawable displaying on a widget. The drawable is \u003ca href=\"https://thenounproject.com/icon/emoji-2588114/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eemoji by Maxim Kulikov from The Noun Project\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"5126\"\u003eNow, this is pretty simple, what if we want the widget to display a pretty photo? If it is stored as a drawable resource then this is exactly the same:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003eLooking pretty. Image from \u003ca href=\"https://picsum.photos/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLorem Picsum\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"73ec\"\u003eHere I have expanded the image to fit the space and used \u003ccode\u003eContentScale.Crop\u003c/code\u003e so it maintains the original aspect ratio and displays edge to edge in my widget.\u003c/p\u003e\u003ch2 id=\"55f1\"\u003eGlance ContentScale options\u003c/h2\u003e\u003cp id=\"8c94\"\u003eLet’s go back to looking at \u003ccode\u003eContentScale\u003c/code\u003e. As usual, with Jetpack Glance we have fewer options than we have with regular Jetpack Compose. The \u003ccode\u003eContentScale\u003c/code\u003e options are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"d1e5\"\u003e\u003ccode\u003eContentScale.Crop\u003c/code\u003e — Scale uniformly (maintaining aspect ratio) so that both dimensions (width and height) will be \u003cstrong\u003eequal to or larger\u003c/strong\u003e than the corresponding dimension of the image composable.\u003c/li\u003e\u003cli id=\"2191\"\u003e\u003ccode\u003eContentScale.Fit\u003c/code\u003e — Scale uniformly (maintaining aspect ratio) so that both dimensions (width and height) will be \u003cstrong\u003eequal to or less\u003c/strong\u003e than the corresponding dimension of the image composable\u003c/li\u003e\u003cli id=\"5118\"\u003e\u003ccode\u003eContentScale.FillBounds\u003c/code\u003e — Scale horizontal and vertically \u003cstrong\u003enon-uniformly\u003c/strong\u003e to fill the image composable bounds.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"a703\"\u003eDisplaying an image from a url\u003c/h2\u003e\u003cp id=\"9b84\"\u003eNow, we get to what you are probably reading this article for. How to display an image from the internet in a widget. Unfortunately we can’t just directly use your favourite image loading library like \u003ca href=\"https://coil-kt.github.io/coil/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoil\u003c/a\u003e, \u003ca href=\"https://github.com/bumptech/glide\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGlide\u003c/a\u003e or \u003ca href=\"https://github.com/square/picasso\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePicasso\u003c/a\u003e as they don’t have Glance composables that we can put in Glance widget UI code (for various reasons). Instead, we need to load the image first into a bitmap, then use \u003ccode\u003eImageProvider(bitmap)\u003c/code\u003e to load this in our \u003ccode\u003eImage\u003c/code\u003e Glance composable.\u003c/p\u003e\u003cp id=\"ee05\"\u003eFor this, we have two options depending on the use case:\u003c/p\u003e\u003col\u003e\u003cli id=\"c9c0\"\u003eLoad the image as a bitmap using a background thread\u003c/li\u003e\u003cli id=\"7929\"\u003eUse a coroutine worker to download the image as a file\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"f3ee\"\u003eImage Bitmap with a background thread\u003c/h2\u003e\u003cp id=\"9d23\"\u003eThis is the simplest option and is useful for widgets where the image is independent from the rest of the widget display (see below for when you wouldn’t want to use this option).\u003c/p\u003e\u003cp id=\"494e\"\u003eThe first step is making use of \u003ca href=\"https://coil-kt.github.io/coil/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoil\u003c/a\u003e \u003ccode\u003eImageRequest\u003c/code\u003e to download the image as a \u003ccode\u003ebitmap\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eIn the above I am explicitly disabling the image caching in the request, but you can alter this depending what your image is used for.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"e6e0\"\u003eBy placing this in a \u003ccode\u003eLaunchedEffect\u003c/code\u003e with a a context of \u003ccode\u003eDispatches.IO\u003c/code\u003e we can run this code on the background thread and not lock up the \u003ccode\u003eUI\u003c/code\u003e thread.\u003c/p\u003e\u003cp id=\"a7e9\"\u003eSaving the result into a \u003ccode\u003emutableState\u003c/code\u003e then enables the rest of the composable to respond once the image has been downloaded:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e79e\"\u003eWhile the \u003ccode\u003eloadedBitmap\u003c/code\u003e state is null we can show a loading indicator and once it is ready, display the image using the \u003ccode\u003eImage\u003c/code\u003e Glance composable and a \u003ccode\u003eImageProvider\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"f907\"\u003eNow this works well:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eThe author information is fetched during the first “Loading”, the image is downloaded while the spinner is displayed.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"1db1\"\u003eExcept in this case, it doesn’t make sense to show the image author before we actually show the image. Also, if an error occurs during loading we just have this circular progress indicator without any way of recovery.\u003c/p\u003e\u003cp id=\"02fb\"\u003eWe could fix this by adding more logic to the UI to set success \u0026amp; error states based on the image download but this is more brittle especially when we have data coming from different sources (in this case metadata from one endpoint and image from another — for the full example see my \u003ca href=\"https://github.com/KatieBarnett/MotivateMe/tree/blog/LoadingImagesInWidgets\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ewidget demo github repository\u003c/a\u003e).\u003c/p\u003e\u003cp id=\"23c3\"\u003eSo ideally we don’t want to use this method if showing the rest of the widget without the image makes no sense.\u003c/p\u003e\u003cp id=\"c4d2\"\u003eTo load everything together and respond to the whole data state use a Coroutine Worker.\u003c/p\u003e\u003ch2 id=\"83ea\"\u003eImage file with a Coroutine Worker\u003c/h2\u003e\u003cp id=\"b656\"\u003eThis method, while more complex, is useful if you are doing other background processing (such as fetching other data from a remote source) and want the image and the new data state to be available at the same time.\u003c/p\u003e\u003cp id=\"a725\"\u003eFor this you can use string states using the standard \u003ccode\u003ePreferencesGlanceStateDefinition\u003c/code\u003e but I recommend using a \u003ccode\u003eCustomGlanceStateDefinition\u003c/code\u003e so that the different widget data states (e.g. success, loading \u0026amp; error) are more clearly defined. You can find more details on how to implement this and the Coroutine Worker itself in my previous blog post \u003ca href=\"https://medium.com/proandroiddev/widgets-with-glance-beyond-string-states-2dcc4db2f76c\" rel=\"noopener\"\u003eWidgets with Glance: Beyond String States\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"b2f4\"\u003eTo achieve this the first task is to download the image as a temporary file on the device that we can read later from the widget. We can do this using \u003ca href=\"https://coil-kt.github.io/coil/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoil\u003c/a\u003e and the image cache:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eIn this case we have enabled the Coil image cache — we want the image to be cached so we can fetch the file from the cache.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"6fb1\"\u003eSo here, the image file is downloaded into the cache using the url as the cache key so we can retrieve it later (the url is the key by default).\u003c/p\u003e\u003cp id=\"edd9\"\u003eThis method should be in your Coroutine Worker for the widget and called within the doWork method when you update the rest of the widget state.\u003c/p\u003e\u003cp id=\"b803\"\u003eNext, we need to access the Coil image cache. For this we need a \u003ccode\u003eFileProvider\u003c/code\u003e and specify which files we will be accessing:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"00c9\"\u003eSetting up this provider enables us to access the files in the\u003ccode\u003eimage_cache\u003c/code\u003e directory which is the default used by Coil.\u003c/p\u003e\u003cp id=\"e379\"\u003eNow, we can use this in the \u003ccode\u003edownloadImage\u003c/code\u003e method:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"2d7f\"\u003e\u003cstrong\u003ePermission handling for File Providers\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"5f40\"\u003eIf you are using a FileProvider you may encouter something like this error:\u003c/p\u003e\u003cp id=\"2392\"\u003e\u003ccode\u003ePermission Denial: opening provider com.your.package.ImageFileProvider from ProcessRecord{...} that is not exported from UID xxxxx\u003c/code\u003e\u003c/p\u003e\u003cp id=\"1d53\"\u003eThis will usually occur if you are displaying (or changing) an image in your widget a long time after your app was last open. What happens here is that the permission for the URI is lost when the MainActivity is lost (such as being naturally closed in the background). If you have recently installed or updated your app (such as debugging and deploying to your device) you are unlikely to see this as your activity is still open. (Thanks to this \u003ca href=\"https://stackoverflow.com/questions/77101459/permission-denial-opening-file-provider-from-launcher-after-reboot-or-restart-a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStack Overflow post\u003c/a\u003e for the explanation).\u003c/p\u003e\u003cp id=\"f5a9\"\u003eTo fix this we need to request the permission prior to accessing the image. This won’t show anything to the user as it is not a restricted or special permission. To do this, add the following to the \u003ccode\u003edownloadImage\u003c/code\u003e method:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0bc9\"\u003eNow, the image and data load at the same time!\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0fdc\"\u003eThe complete \u003ccode\u003edownloadImage\u003c/code\u003e method that returns the file url:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-01-17T20:17:12.565Z",
  "modifiedTime": null
}
