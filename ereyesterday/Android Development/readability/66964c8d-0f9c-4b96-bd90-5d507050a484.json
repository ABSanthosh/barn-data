{
  "id": "66964c8d-0f9c-4b96-bd90-5d507050a484",
  "title": "Compile-time validation of JNI signatures",
  "link": "https://jakewharton.com/compile-time-validation-of-jni-signatures/",
  "description": "",
  "author": "",
  "published": "2025-03-12T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "",
  "length": 12107,
  "excerpt": "12 March 2025",
  "siteName": "Jake Wharton",
  "favicon": "",
  "text": "Compile-time validation of JNI signatures 12 March 2025 JNI allows managed code inside the JVM or ART to call into native code. Java methods can be declared as native, and then a corresponding C function1 can be written and automatically wired together when the native library is loaded. Native code lacks mechanisms like packages and overloads, so a special format is used to encode the Java method signature. A Java method defined as: package com.example; class Things { static native long createThing(String name, int count); } Requires a matching C declaration which looks like: jlong Java_com_example_Things_createThing( JNIEnv *env, jclass type, jstring name, jint count) { // … } If you add parameter overloading into the mix, the C declaration must include the parameter signature as well: jlong Java_com_example_Things_createThing_Ljava_lang_String_2I( JNIEnv *env, jclass type, jstring name, jint count) { // … } Woof! And if you get any part of the encoding wrong, the method call will fail at runtime: Exception in thread \"main\" java.lang.UnsatisfiedLinkError: 'long Things.createThing(java.lang.String, int)' at Things.createThing(Native Method) at Main.main(example.java:6) In my experience, these signatures do not change frequently. Once they’re correct you can mostly just leave them untouched. However, it’s a class of problem that would be nice to eliminate completely. Especially if within your projects they do change frequently. When compiling native code, a header represents a series of functions implemented somewhere else. It allows consumers of a library to compile against its API without requiring the full implementation. When compiling the library itself, the compiler requires all header functions have corresponding implementations. Defining a manually-written header for our C functions would be redundant and subject to all the same problems above. Instead, we want to automatically derive the header from the corresponding Java code. As of Java 8, javac can do this for us with its -h flag. Let’s learn how to use it from javac’s help output ❯ javac -h error: -h requires an argument Usage: javac \u003coptions\u003e \u003csource files\u003e use --help for a list of possible options Wait… shit. Please don’t use -h for real flags. Anyway, it just takes a directory. ❯ javac -h h -d out Example.java ❯ tree . ├── Example.java ├── things.c ├── h │ └── com_example_Things.h └── out └── com └── example └── Things.class Here is the full content of com_example_Things.h: /* DO NOT EDIT THIS FILE - it is machine generated */ #include \u003cjni.h\u003e /* Header for class com_example_Things */ #ifndef _Included_com_example_Things #define _Included_com_example_Things #ifdef __cplusplus extern \"C\" { #endif /* * Class: com_example_Things * Method: createThing * Signature: (Ljava/lang/String;I)J */ JNIEXPORT jlong JNICALL Java_com_example_Things_createThing (JNIEnv *, jclass, jstring, jint); #ifdef __cplusplus } #endif #endif Among the requisite boilerplate for single inclusion and C++ support is a function signature matching the one we wrote above! Including this file from our .c will cause the native compiler to validate all header functions have corresponding C implementations. Let’s change the Java native method signature and see what happens. class Things { - static native long createThing(String name, int count); + static native long createThing(String name, int count, byte[] buffer); } ❯ javac -h h -d out Example.java ❯ clang -I \"$JAVA_HOME/include\" \\ -I \"$JAVA_HOME/include/darwin\" \\ -I h \\ things.c things.c:4:7: error: conflicting types for 'Java_com_example_Things_createThing' jlong Java_com_example_Things_createThing( ^ h/com_example_Things.h:15:25: note: previous declaration is here JNIEXPORT jlong JNICALL Java_com_example_Things_createThing ^ 1 error generated. It’s not the most amazing message that I have seen. But it did fail compilation! Fixing the problem is now a matter of comparing the two signatures and updating the C file as needed. Gradle does this automatically Do you use Gradle? Good news! It automatically configures your javac with the -h flag so you don’t really need to do much. ❯ tree . ├── build │   ├── classes │   │   └── java │   │   └── main │   │   └── com │   │   └── example │   │   └── Things.class │   ├── generated │   │   └── sources │   ⋮   └── headers │      └── java │      └── main │      └── com_example_Things.h ⋮ ├── build.gradle ├── src │   └── main │   └── java │   └── com │   └── example │   └── Example.java └── things.c This is the result after moving Example.java into src/main/java/, writing apply plugin: 'java-library' in build.gradle, and invoking ./gradlew assemble If your native build occurs outside Gradle, the compileJava task should be run first, then the external native build, and finally (with the native binaries put somewhere like src/main/resources/) the full assemble or build task can be run. For native builds which run as a Gradle task, you can consume the associated JavaCompile task’s options.headerOutputDirectory property which becomes an additional include directory. Kotlin (and other JVM languages) Alternative languages which target Java bytecode usually have equivalent markers to bind to native functions, such as Kotlin’s external modifier. Unsurprisingly, when writing Kotlin we cannot use java -h because we don’t have any Java! There remains a long-standing feature request for kotlinc to generate these headers like javac. Until then, there are three approaches to solving this problem: just write Java, use javah, or write our own tool. Just write Java Since JNI methods are only stubs, continuing to write them in Java is not too painful. The Kotlin compiler supports bidirectional references from Java-to-Kotlin and Kotlin-to-Java. This allows your Kotlin to reference the Java stubs, while any Kotlin types needed in those Java stubs still work. final class Jni { static { loadLibrary(\"my-library\"); } private Jni() {} static native long createThing(String name, int count); } Centralizing the stubs in a Java class creates a single location for the native library to be loaded. This does end up limiting access to a single package, which may or may not be desired. If you are building with Gradle, both Kotlin/JVM and Kotlin/Multiplatform still get the automatic inclusion of the -h flag on the resulting javac execution. All you need to do is create the Java file, and you’re good to go! Finally, writing JNI stubs in Java helps avoid the need to understand how Kotlin (or any other language) maps its features to the underlying bytecode. You no longer need to worry about how objects, internal funs, or value class parameters get converted. Use old javah tool Prior to the javac’s -h flag producing headers, the JDK contained a standalone javah tool which parsed Java .class files. This means that any other language which targeted Java bytecode and used its ACC_NATIVE flag could generate headers. While this sounds like the perfect solution for alternate languages, the tool was deprecated in Java 9 and removed in Java 10. However, if your code still targets Java 9 or older your class files can be read by this tool. If you use Gradle, fetching old-ass JDKs is the perfect use-case for Gradle toolchains (which despite their docs are otherwise rarely a good idea). def launcher = javaToolchains.launcherFor { languageVersion = JavaLanguageVersion.of(8) } tasks.register('generateHeaders', Exec) { def javah = launcher.map { it.metadata.installationPath.file(\"bin/javah\") } executable(javah.get().asFile) // TODO Lazy, once Gradle supports. args(\"-h\") // TODO Pass class dirs, etc. } ❯ ./gradlew -q generateHeaders Usage: javah [options] \u003cclasses\u003e … Write your own tool With the ASM library or Java’s new Class-File API, parsing these files to find native methods is possible. Once found, the mapping to their native signature can be done with a well-documented formula. Someone just has to do the work. There was a repo which attempted this, but it is incomplete and now seemingly abandoned. When the JDK removed the javah tool, the Scala community forked that library to create their sbt-jni plugin. But to my knowledge there is no other general-purpose tool for other languages which fulfills this need today. Java 22 and FFM JNI is generally avoided unless extenuating circumstances demand its use. It remains a challenging system even with compile-time validation due to performance concerns, multiple memory spaces, and almost no safety or security. Elaborate tools such as JNA and SWIG were invented to try and simplify native library use over JNI. Starting last year with Java 22, the new Foreign Function \u0026 Memory API became available to use. FFM inverts ownership of the stubs, generating the Java sources from native headers using the jextract tool. If I manually write a things.h file with a regular C API that can be fed into jextract. #ifndef things_h #define things_h long createThing(char* name, int count, void* buffer); #endif // things_h ❯ jextract --output ffm things.h ❯ tree ffm ffm └── things_h.java The resulting things_h.java file is a chonker, but among a slew of FFM implementation detail is a public Java API which corresponds to our native function. public class things_h { // … /** * {@snippet lang=c : * long createThing(char *name, int count, void *buffer) * } */ public static long createThing(MemorySegment name, int count, MemorySegment buffer) { var mh$ = createThing.HANDLE; try { if (TRACE_DOWNCALLS) { traceDowncall(\"createThing\", name, count, buffer); } return (long)mh$.invokeExact(name, count, buffer); } catch (Throwable ex$) { throw new AssertionError(\"should not reach here\", ex$); } } } Since both the name and buffer parameters on the C function were pointers to memory, they come across typed as MemorySegments. If we have a Java String and byte[], conversion and/or pinning of their managed memory such that it can be used by native code is required. The FFM API provides utilities for this conversion in a similar way to which jni.h provided conversion utilities for jstring and jbytearray types. The boilerplate which makes up the rest of the file helps the JVM understand the shape of the native code so that it can be optimized alongside regular Java as well as layered with safety checks to avoid things like unrestricted memory access. If your minimum-supported JDK is not yet Java 22 or newer, you can still use FFM through multi-release jars. This embeds your FFM-flavored class files inside the META-INF/versions/22/ directory which is only loaded when the consumer is running on Java 22 or newer. With the ownership reversed, there is no chance of changes to Java breaking the native code. Instead, changes to the native code will now break the Java compilation. #ifndef things_h #define things_h -long createThing(char* name, int count, void* buffer); +long createThing(char* name, int count); #endif // things_h ❯ jextract --output ffm things.h ❯ javac -d out Example.java ffm/things_h.java Example.java:23: error: method createThing in class things_h cannot be applied to given types; return things_h.createThing(nameSegment, count, bufferSegment); ^ required: MemorySegment,int found: MemorySegment,int,MemorySegment reason: actual and formal argument lists differ in length 1 error With jextract able to parse native headers, the need to write custom C code to support the use of native libraries is diminished. Ideally you would only run jextract on the headers of the desired native libraries and then write 100% of your interaction with it from Java or your favorite JVM language. — Jake Wharton",
  "image": "https://jakewharton.com/static/default_image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003ch2\u003eCompile-time validation of JNI signatures\u003c/h2\u003e\n      \u003cp\u003e12 March 2025\u003c/p\u003e\n\n      \u003cp\u003e\u003cabbr title=\"(The) Java Native Interface\"\u003eJNI\u003c/abbr\u003e allows managed code inside the \u003cabbr title=\"Java Virtual Machine\"\u003eJVM\u003c/abbr\u003e or \u003cabbr title=\"(The) Android Runtime\"\u003eART\u003c/abbr\u003e to call into native code.\nJava methods can be declared as \u003ccode\u003enative\u003c/code\u003e, and then a corresponding C function\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\"\u003e1\u003c/a\u003e\u003c/sup\u003e can be written and automatically wired together when the native library is loaded.\u003c/p\u003e\n\n\u003cp\u003eNative code lacks mechanisms like packages and overloads, so a special format is used to encode the Java method signature.\nA Java method defined as:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epackage\u003c/span\u003e \u003cspan\u003ecom.example\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eThings\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003enative\u003c/span\u003e \u003cspan\u003elong\u003c/span\u003e \u003cspan\u003ecreateThing\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eRequires a matching C declaration which looks like:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003ejlong\u003c/span\u003e \u003cspan\u003eJava_com_example_Things_createThing\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003eJNIEnv\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eenv\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ejclass\u003c/span\u003e \u003cspan\u003etype\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ejstring\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ejint\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// …\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIf you add parameter overloading into the mix, the C declaration must include the parameter signature as well:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003ejlong\u003c/span\u003e \u003cspan\u003eJava_com_example_Things_createThing_Ljava_lang_String_2I\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003eJNIEnv\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eenv\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ejclass\u003c/span\u003e \u003cspan\u003etype\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ejstring\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ejint\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// …\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWoof! And if you get any part of the encoding wrong, the method call will fail at runtime:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eException in thread \u0026#34;main\u0026#34; java.lang.UnsatisfiedLinkError:\n    \u0026#39;long Things.createThing(java.lang.String, int)\u0026#39;\n  at Things.createThing(Native Method)\n  at Main.main(example.java:6)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIn my experience, these signatures do not change frequently.\nOnce they’re correct you can mostly just leave them untouched.\nHowever, it’s a class of problem that would be nice to eliminate completely.\nEspecially if within your projects they \u003cem\u003edo\u003c/em\u003e change frequently.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen compiling native code, a header represents a series of functions implemented somewhere else.\nIt allows consumers of a library to compile against its API without requiring the full implementation.\nWhen compiling the library itself, the compiler requires all header functions have corresponding implementations.\u003c/p\u003e\n\n\u003cp\u003eDefining a manually-written header for our C functions would be redundant and subject to all the same problems above.\nInstead, we want to automatically derive the header from the corresponding Java code.\nAs of Java 8, \u003ccode\u003ejavac\u003c/code\u003e can do this for us with its \u003ccode\u003e-h\u003c/code\u003e flag.\nLet’s learn how to use it from \u003ccode\u003ejavac\u003c/code\u003e’s help output\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e❯ javac -h\nerror: -h requires an argument\nUsage: javac \u0026lt;options\u0026gt; \u0026lt;source files\u0026gt;\nuse --help for a list of possible options\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWait… shit. Please don’t use \u003ccode\u003e-h\u003c/code\u003e for real flags.\u003c/p\u003e\n\n\u003cp\u003eAnyway, it just takes a directory.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e❯ javac -h h -d out Example.java\n\n❯ tree\n.\n├── Example.java\n├── things.c\n├── h\n│   └── com_example_Things.h\n└── out\n    └── com\n        └── example\n            └── Things.class\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eHere is the full content of \u003ccode\u003ecom_example_Things.h\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e/* DO NOT EDIT THIS FILE - it is machine generated */\u003c/span\u003e\n\u003cspan\u003e#include \u0026lt;jni.h\u0026gt;\n\u003c/span\u003e\u003cspan\u003e/* Header for class com_example_Things */\u003c/span\u003e\n\n\u003cspan\u003e#ifndef _Included_com_example_Things\n#define _Included_com_example_Things\n#ifdef __cplusplus\n\u003c/span\u003e\u003cspan\u003eextern\u003c/span\u003e \u003cspan\u003e\u0026#34;C\u0026#34;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e#endif\n\u003c/span\u003e\u003cspan\u003e/*\n * Class:     com_example_Things\n * Method:    createThing\n * Signature: (Ljava/lang/String;I)J\n */\u003c/span\u003e\n\u003cspan\u003eJNIEXPORT\u003c/span\u003e \u003cspan\u003ejlong\u003c/span\u003e \u003cspan\u003eJNICALL\u003c/span\u003e \u003cspan\u003eJava_com_example_Things_createThing\u003c/span\u003e\n  \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eJNIEnv\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ejclass\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ejstring\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ejint\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n\u003cspan\u003e#ifdef __cplusplus\n\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e#endif\n#endif\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAmong the requisite boilerplate for single inclusion and C++ support is a function signature matching the one we wrote above!\nIncluding this file from our \u003ccode\u003e.c\u003c/code\u003e will cause the native compiler to validate all header functions have corresponding C implementations.\u003c/p\u003e\n\n\u003cp\u003eLet’s change the Java native method signature and see what happens.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e class Things {\n\u003cspan\u003e-  static native long createThing(String name, int count);\n\u003c/span\u003e\u003cspan\u003e+  static native long createThing(String name, int count, byte[] buffer);\n\u003c/span\u003e }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e❯ javac -h h -d out Example.java\n\n❯ clang -I \u0026#34;$JAVA_HOME/include\u0026#34; \\\n    -I \u0026#34;$JAVA_HOME/include/darwin\u0026#34; \\\n    -I h \\\n    things.c\n\nthings.c:4:7: error: conflicting types for \u0026#39;Java_com_example_Things_createThing\u0026#39;\njlong Java_com_example_Things_createThing(\n      ^\nh/com_example_Things.h:15:25: note: previous declaration is here\nJNIEXPORT jlong JNICALL Java_com_example_Things_createThing\n                        ^\n1 error generated.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIt’s not the most amazing message that I have seen.\nBut it did fail compilation!\nFixing the problem is now a matter of comparing the two signatures and updating the C file as needed.\u003c/p\u003e\n\n\u003ch4 id=\"gradle-does-this-automatically\"\u003eGradle does this automatically\u003c/h4\u003e\n\n\u003cp\u003eDo you use Gradle?\nGood news!\nIt automatically configures your \u003ccode\u003ejavac\u003c/code\u003e with the \u003ccode\u003e-h\u003c/code\u003e flag so you don’t really need to do much.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e❯ tree\n.\n├── build\n│   ├── classes\n│   │   └── java\n│   │       └── main\n│   │           └── com\n│   │               └── example\n│   │                   └── Things.class\n│   ├── generated\n│   │   └── sources\n│   ⋮       └── headers\n│               └── java\n│                   └── main\n│                       └── com_example_Things.h\n⋮\n├── build.gradle\n├── src\n│   └── main\n│       └── java\n│           └── com\n│               └── example\n│                   └── Example.java\n└── things.c\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis is the result after moving \u003ccode\u003eExample.java\u003c/code\u003e into \u003ccode\u003esrc/main/java/\u003c/code\u003e, writing \u003ccode\u003eapply plugin: \u0026#39;java-library\u0026#39;\u003c/code\u003e in \u003ccode\u003ebuild.gradle\u003c/code\u003e, and invoking \u003ccode\u003e./gradlew assemble\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eIf your native build occurs outside Gradle, the \u003ccode\u003ecompileJava\u003c/code\u003e task should be run first, then the external native build, and finally (with the native binaries put somewhere like \u003ccode\u003esrc/main/resources/\u003c/code\u003e) the full \u003ccode\u003eassemble\u003c/code\u003e or \u003ccode\u003ebuild\u003c/code\u003e task can be run.\u003c/p\u003e\n\n\u003cp\u003eFor native builds which run as a Gradle task, you can consume the associated \u003ccode\u003eJavaCompile\u003c/code\u003e task’s \u003ccode\u003eoptions.headerOutputDirectory\u003c/code\u003e property which becomes an additional include directory.\u003c/p\u003e\n\n\u003ch3 id=\"kotlin-and-other-jvm-languages\"\u003eKotlin (and other JVM languages)\u003c/h3\u003e\n\n\u003cp\u003eAlternative languages which target Java bytecode usually have equivalent markers to bind to native functions, such as Kotlin’s \u003ccode\u003eexternal\u003c/code\u003e modifier.\nUnsurprisingly, when writing Kotlin we cannot use \u003ccode\u003ejava -h\u003c/code\u003e because we don’t have any Java!\u003c/p\u003e\n\n\u003cp\u003eThere remains a \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-35127\"\u003elong-standing feature request\u003c/a\u003e for \u003ccode\u003ekotlinc\u003c/code\u003e to generate these headers like \u003ccode\u003ejavac\u003c/code\u003e.\nUntil then, there are three approaches to solving this problem: just write Java, use \u003ccode\u003ejavah\u003c/code\u003e, or write our own tool.\u003c/p\u003e\n\n\u003ch4 id=\"just-write-java\"\u003eJust write Java\u003c/h4\u003e\n\n\u003cp\u003eSince JNI methods are only stubs, continuing to write them in Java is not too painful.\nThe Kotlin compiler supports bidirectional references from Java-to-Kotlin and Kotlin-to-Java.\nThis allows your Kotlin to reference the Java stubs, while any Kotlin types needed in those Java stubs still work.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eJni\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eloadLibrary\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;my-library\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eJni\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{}\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003enative\u003c/span\u003e \u003cspan\u003elong\u003c/span\u003e \u003cspan\u003ecreateThing\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eCentralizing the stubs in a Java class creates a single location for the native library to be loaded.\nThis does end up limiting access to a single package, which may or may not be desired.\u003c/p\u003e\n\n\u003cp\u003eIf you are building with Gradle, both Kotlin/JVM and Kotlin/Multiplatform still get the automatic inclusion of the \u003ccode\u003e-h\u003c/code\u003e flag on the resulting \u003ccode\u003ejavac\u003c/code\u003e execution.\nAll you need to do is create the Java file, and you’re good to go!\u003c/p\u003e\n\n\u003cp\u003eFinally, writing JNI stubs in Java helps avoid the need to understand how Kotlin (or any other language) maps its features to the underlying bytecode.\nYou no longer need to worry about how \u003ccode\u003eobject\u003c/code\u003es, \u003ccode\u003einternal fun\u003c/code\u003es, or \u003ccode\u003evalue class\u003c/code\u003e parameters get converted.\u003c/p\u003e\n\n\u003ch4 id=\"use-old-javah-tool\"\u003eUse old \u003ccode\u003ejavah\u003c/code\u003e tool\u003c/h4\u003e\n\n\u003cp\u003ePrior to the \u003ccode\u003ejavac\u003c/code\u003e’s \u003ccode\u003e-h\u003c/code\u003e flag producing headers, the JDK contained a standalone \u003ccode\u003ejavah\u003c/code\u003e tool which parsed Java \u003ccode\u003e.class\u003c/code\u003e files.\nThis means that any other language which targeted Java bytecode and used its \u003ccode\u003eACC_NATIVE\u003c/code\u003e flag could generate headers.\u003c/p\u003e\n\n\u003cp\u003eWhile this sounds like the perfect solution for alternate languages, the tool was deprecated in Java 9 and removed in Java 10.\nHowever, if your code still \u003cem\u003etargets\u003c/em\u003e Java 9 or older your class files can be read by this tool.\u003c/p\u003e\n\n\u003cp\u003eIf you use Gradle, fetching old-ass JDKs is the perfect use-case for \u003ca href=\"https://docs.gradle.org/current/userguide/toolchains.html\"\u003eGradle toolchains\u003c/a\u003e (which despite their docs are otherwise \u003ca href=\"https://jakewharton.com/gradle-toolchains-are-rarely-a-good-idea/\"\u003erarely a good idea\u003c/a\u003e).\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003elauncher\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ejavaToolchains\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elauncherFor\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003elanguageVersion\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eJavaLanguageVersion\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003etasks\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eregister\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;generateHeaders\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eExec\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003ejavah\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003elauncher\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emetadata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einstallationPath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efile\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;bin/javah\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003eexecutable\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ejavah\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e().\u003c/span\u003e\u003cspan\u003easFile\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e// TODO Lazy, once Gradle supports.\u003c/span\u003e\n  \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;-h\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e// TODO Pass class dirs, etc.\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e❯ ./gradlew -q generateHeaders\nUsage:\n  javah [options] \u0026lt;classes\u0026gt;\n  …\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch4 id=\"write-your-own-tool\"\u003eWrite your own tool\u003c/h4\u003e\n\n\u003cp\u003eWith the \u003ca href=\"https://asm.ow2.io/\"\u003eASM\u003c/a\u003e library or Java’s \u003ca href=\"https://openjdk.org/jeps/484\"\u003enew Class-File API\u003c/a\u003e, parsing these files to find native methods is possible.\nOnce found, the mapping to their native signature can be done with a \u003ca href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names\"\u003ewell-documented formula\u003c/a\u003e.\nSomeone just has to do the work.\u003c/p\u003e\n\n\u003cp\u003eThere was \u003ca href=\"https://github.com/Glavo/gjavah\"\u003ea repo\u003c/a\u003e which attempted this, but it is incomplete and now seemingly abandoned.\nWhen the JDK removed the \u003ccode\u003ejavah\u003c/code\u003e tool, the Scala community forked that library to create their \u003ca href=\"https://github.com/sbt/sbt-jni/\"\u003esbt-jni\u003c/a\u003e plugin.\nBut to my knowledge there is no other general-purpose tool for other languages which fulfills this need today.\u003c/p\u003e\n\n\u003ch3 id=\"java-22-and-ffm\"\u003eJava 22 and FFM\u003c/h3\u003e\n\n\u003cp\u003eJNI is generally avoided unless extenuating circumstances demand its use.\nIt remains a challenging system even with compile-time validation due to performance concerns, multiple memory spaces, and almost no safety or security.\nElaborate tools such as JNA and SWIG were invented to try and simplify native library use over JNI.\u003c/p\u003e\n\n\u003cp\u003eStarting last year with Java 22, the new \u003ca href=\"https://openjdk.org/jeps/484\"\u003eForeign Function \u0026amp; Memory API\u003c/a\u003e became available to use.\nFFM inverts ownership of the stubs, generating the Java sources from native headers using the \u003ca href=\"https://github.com/openjdk/jextract\"\u003ejextract\u003c/a\u003e tool.\u003c/p\u003e\n\n\u003cp\u003eIf I manually write a \u003ccode\u003ethings.h\u003c/code\u003e file with a regular C API that can be fed into \u003ccode\u003ejextract\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e#ifndef things_h\n#define things_h\n\u003c/span\u003e\n\u003cspan\u003elong\u003c/span\u003e \u003cspan\u003ecreateThing\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e \u003cspan\u003ebuffer\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n\u003cspan\u003e#endif // things_h\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e❯ jextract --output ffm things.h\n\n❯ tree ffm\nffm\n└── things_h.java\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe resulting \u003ccode\u003ethings_h.java\u003c/code\u003e file is a chonker, but among a slew of FFM implementation detail is a public Java API which corresponds to our native function.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003ethings_h\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e// …\u003c/span\u003e\n    \n    \u003cspan\u003e/**\n     * {@snippet lang=c :\n     * long createThing(char *name, int count, void *buffer)\n     * }\n     */\u003c/span\u003e\n    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003elong\u003c/span\u003e \u003cspan\u003ecreateThing\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eMemorySegment\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eMemorySegment\u003c/span\u003e \u003cspan\u003ebuffer\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003emh\u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecreateThing\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eHANDLE\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n        \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTRACE_DOWNCALLS\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003etraceDowncall\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;createThing\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ebuffer\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elong\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003emh\u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einvokeExact\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ebuffer\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003ecatch\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eThrowable\u003c/span\u003e \u003cspan\u003eex\u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n           \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eAssertionError\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;should not reach here\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eex\u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eSince both the \u003ccode\u003ename\u003c/code\u003e and \u003ccode\u003ebuffer\u003c/code\u003e parameters on the C function were pointers to memory, they come across typed as \u003ccode\u003eMemorySegment\u003c/code\u003es.\nIf we have a Java \u003ccode\u003eString\u003c/code\u003e and \u003ccode\u003ebyte[]\u003c/code\u003e, conversion and/or pinning of their managed memory such that it can be used by native code is required.\nThe FFM API provides utilities for this conversion in a similar way to which \u003ccode\u003ejni.h\u003c/code\u003e provided conversion utilities for \u003ccode\u003ejstring\u003c/code\u003e and \u003ccode\u003ejbytearray\u003c/code\u003e types.\u003c/p\u003e\n\n\u003cp\u003eThe boilerplate which makes up the rest of the file helps the JVM understand the shape of the native code so that it can be optimized alongside regular Java as well as layered with safety checks to avoid things like unrestricted memory access.\u003c/p\u003e\n\n\u003cp\u003eIf your minimum-supported JDK is not yet Java 22 or newer, you can still use FFM through \u003ca href=\"https://openjdk.org/jeps/238\"\u003emulti-release jars\u003c/a\u003e.\nThis embeds your FFM-flavored class files inside the \u003ccode\u003eMETA-INF/versions/22/\u003c/code\u003e directory which is only loaded when the consumer is running on Java 22 or newer.\u003c/p\u003e\n\n\u003cp\u003eWith the ownership reversed, there is no chance of changes to Java breaking the native code. Instead, changes to the native code will now break the Java compilation.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e #ifndef things_h\n #define things_h\n \n\u003cspan\u003e-long createThing(char* name, int count, void* buffer);\n\u003c/span\u003e\u003cspan\u003e+long createThing(char* name, int count);\n\u003c/span\u003e\n #endif // things_h\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e❯ jextract --output ffm things.h\n\n❯ javac -d out Example.java ffm/things_h.java\nExample.java:23: error: method createThing in class things_h cannot be applied to given types;\n    return things_h.createThing(nameSegment, count, bufferSegment);\n                   ^\n  required: MemorySegment,int\n  found:    MemorySegment,int,MemorySegment\n  reason: actual and formal argument lists differ in length\n1 error\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWith \u003ccode\u003ejextract\u003c/code\u003e able to parse native headers, the need to write custom C code to support the use of native libraries is diminished.\nIdeally you would only run \u003ccode\u003ejextract\u003c/code\u003e on the headers of the desired native libraries and then write 100% of your interaction with it from Java or your favorite JVM language.\u003c/p\u003e\n\n\n\n      \u003cp\u003e— Jake Wharton\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-03-12T00:00:00Z",
  "modifiedTime": null
}
