{
  "id": "4098b80a-0951-4c6c-a736-b397f653130e",
  "title": "Top Nine Android Developer Interview Questions You Should Know",
  "link": "https://proandroiddev.com/top-9-android-developer-interview-questions-you-should-know-05e8fe2acd2c?source=rss----c72404660798---4",
  "description": "",
  "author": "Jaewoong Eum",
  "published": "Sat, 09 Nov 2024 16:22:20 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "androiddev",
    "kotlin",
    "android",
    "jetpack-compose"
  ],
  "byline": "Jaewoong Eum",
  "length": 25092,
  "excerpt": "When applying for a job as an Android developer, you’ll need expertise in Android, Kotlin, and other relevant skills, depending on the team you’re joining. While it’s impossible to predict every…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Unsplash@adolfofelixWhen applying for a job as an Android developer, you’ll need expertise in Android, Kotlin, and other relevant skills, depending on the team you’re joining. While it’s impossible to predict every interview question, you can prepare by mastering the fundamental knowledge essential for working as an Android developer.The best way to prepare for an interview is to review the minimum requirements and preferred qualifications for the role, ensuring you align with the team’s needs. Interview questions can vary widely depending on the team, the company’s industry, and its development culture. As a result, tailoring your preparation to the specific team and company is crucial for success.While preferred requirements can vary greatly between teams, some common questions tend to surface universally for Android developer roles. In this article, you’ll discover the top nine Android developer interview questions featured in Dove Letter. Dove Letter is a subscription repository where you can learn, discuss, and share new insights about Android and Kotlin with industrial Android developer interview questions, tips with code, articles, discussion, and trending news. If you’re interested in joining, be sure to check out “Learn Kotlin and Android With Dove Letter.”AndroidAndroid boasts over a decade of history, with Android 15 announced already, reflecting significant technical advancements over time. Despite these changes, the core systems and components, such as the Activity and Fragment lifecycles or Intents, have remained largely consistent. Understanding these fundamental systems, even if they feel like “old-school” technologies, is still crucial for any Android developer.1. Describe the Activity LifecycleThe Android Activity lifecycle describes the different states an activity goes through during its lifetime, from creation to destruction. Understanding these states is crucial for managing resources effectively, handling user input, and ensuring a smooth user experience. Here are the main stages of the Activity lifecycle:The activity lifecycleonCreate(): This is the first method called when an activity is created. It’s where you initialize the activity, set up UI components, and restore any saved instance state. It’s only called once during the activity’s lifecycle unless the activity is destroyed and recreated.onStart(): The activity becomes visible to the user but is not yet interactive. This is called after onCreate() and before onResume().onRestart(): If the activity is stopped and then restarted (e.g., the user navigates back to it), this method is called before onStart().onResume(): The activity is in the foreground and the user can interact with it. This is where you resume any paused UI updates, animations, or input listeners.onPause(): This is called when the activity is partially obscured by another activity (e.g., a dialog). The activity is still visible but not in focus. It’s often used to pause operations like animations, sensor updates, or saving data.onStop(): The activity is no longer visible to the user (for example, when another activity comes to the foreground). You should release resources that are not needed while the activity is stopped, such as background tasks or heavy objects.onDestroy(): This is called before the activity is fully destroyed and removed from memory. It’s the final clean-up method for releasing all remaining resources.SummaryAn activity goes through these methods based on user interactions and the Android system’s management of app resources. Developers use these callbacks to manage transitions, conserve resources, and provide a smooth experience for users. For more details, check out the Android official documentation.You might also encounter related questions, such as those about the Fragment lifecycle or View lifecycle in Android. For more insights, be sure to check out Dove Letter.2. What is an Intent?An Intent in Android is an abstract description of an operation to be performed. It serves as a messaging object that allows activities, services, and broadcast receivers to communicate. Intents are typically used to start an activity, send a broadcast, or initiate a service. They can also pass data between components, making them a fundamental part of Android’s component-based architecture.There are two primary types of intents in Android: explicit and implicit.1. Explicit IntentDefinition: An explicit intent specifies the exact component (activity or service) to be invoked by directly naming it.Use Case: Explicit intents are used when you know the target component (e.g., starting a specific activity within your app).Example:Scenario: If you switch from one activity to another within the same app, you use explicit intent.2. Implicit IntentDefinition: An implicit intent does not specify a specific component but declares a general action to be performed. The system resolves which component(s) can handle the intent based on the action, category, and data.Use Case: Implicit intents are useful when you want to perform an action that other apps or system components can handle (e.g., opening a URL or sharing content).Example:Scenario: If you open a web page in a browser or share content with other apps, you use an implicit intent. The system will decide which app to handle the intent.SummaryExplicit intents are used for internal app navigation where the target component is known. Implicit intents are used for actions that external apps or other components may handle without directly specifying the target. This makes the Android ecosystem more flexible and allows apps to interact seamlessly.3. What’s the difference between Serialization and Parcelable?In Android, both Serializable and Parcelable are mechanisms used to pass data between different components (such as activities or fragments), but they function differently in terms of performance and implementation. Here’s a comparison of the two:SerializableJava Standard Interface: Serializable is a standard Java interface used to convert an object into a byte stream, which can then be passed between activities or written to disk.Reflection-Based: It works through Java reflection, meaning the system dynamically inspects the class and its fields at runtime to serialize the object.Performance: Serializable is slower compared to Parcelable because reflection is a slow process. It also generates a lot of temporary objects during serialization, increasing the memory overhead.Use Case: Serializable is useful in scenarios where performance is not critical or when dealing with non-Android-specific codebases.ParcelableAndroid-Specific Interface: Parcelable is an Android-specific interface designed specifically for high-performance inter-process communication (IPC) within Android components.Performance: Parcelable is faster than Serializable because it’s optimized for Android and doesn’t rely on reflection. It minimizes garbage collection by avoiding creating many temporary objects.Use Case: Parcelable is preferred for passing data in Android when performance is important, especially for IPC or passing data between activities or services.SummaryIn general, Parcelable is the recommended approach for Android applications due to its better performance in most use cases. However, if you need simplicity and performance is not a concern, Serializable might be easier to implement.Use Serializable for simpler cases when dealing with non-performance-critical operations or when working with non-Android-specific code.Use Parcelable when working with Android-specific components where performance matters, as it is much more efficient for Android’s IPC mechanism.KotlinSince Google announced its Kotlin-first approach to Android development at Google I/O 2019, the adoption of Kotlin has skyrocketed. By the end of 2024, the majority of Android projects have transitioned to Kotlin, especially with Jetpack Compose reaching its stable release and gaining widespread popularity. So, in most cases, most of the team is likely using Kotlin instead of Java in most cases nowadays.1. What is data class in Kotlin? How does a data class in Kotlin differ from a regular class?In Kotlin, the data class is a special type of class specifically designed to hold data. Kotlin generates several useful methods automatically for data classes, which makes them ideal for representing simple data-holding objects.Key Features of Data ClassesWhen you declare a data class, Kotlin automatically generates the following:equals(): Compares two instances of the class for equality based on their properties.hashCode(): Generates a hash code based on the properties.toString(): Provides a string representation of the object with its property values.copy(): Allows for creating a new object with some properties copied from the existing one, with the option to modify specific values.Component functions: For de-structuring declarations (e.g., component1(), component2()), allowing you to extract properties easily.ExampleIn the example below, Kotlin automatically provides equals(), hashCode(), toString(), and copy() for the User class.Differences Between Data Class and Normal ClassBoilerplate Reduction: In a normal class, you would need to manually override equals(), hashCode(), toString(), and other utility methods. With a data class, Kotlin generates these for you automatically.Primary Constructor Requirement: A data class requires at least one property to be declared in the primary constructor, whereas a normal class does not.Use Case: Data classes are primarily used for holding immutable data (though you can use mutable properties), whereas normal classes can be used for any kind of behavior or logic.Example of Normal Class for ComparisonIn the example above, Kotlin automatically provides equals(), hashCode(), toString(), and copy() for the User class.SummaryData classes are used for objects that only contain data, and Kotlin automatically generates utility methods like equals(), hashCode(), toString(), and copy(). A normal class is more flexible but doesn’t provide those methods by default, making it more suited for objects with behavior and complex logic.2. What’s the Extension, and what are its pros and cons?The Extensions is a way to add new functionality to existing classes without modifying their code directly. Kotlin allows you to “extend” a class with new functions or properties using extension functions and extension properties. This is especially useful for enhancing classes from third-party libraries or the standard library where you don’t have access to the source code.Example of an Extension FunctionSuppose you want to add a isEven() function to the Int class. You can do it like this:Here, isEven() becomes a new function available to all Int objects, even though you haven’t modified the Int class itself.Example of an Extension PropertyKotlin also allows you to add new properties to a class in a similar way. Note that these properties can’t store state and are just syntactic sugar for getter functions.Another great example is adding an extension property to an existing type:Pros of ExtensionsEnhanced Readability: Extensions make code more readable and expressive.Modularity: They allow you to add functionality without modifying the original class.Code Reusability: Extensions can be reused across different parts of your application, helping to avoid boilerplate code.While Kotlin extensions are powerful and flexible, they come with disadvantages and limitations.Cons of ExtensionsPotential for Confusion: Extensions can sometimes lead to confusion, especially if they clash with functions already present in the class or if there are multiple extensions with similar names. In cases where both an extension function and a member function have the same name, the member function takes precedence, which can be unintuitive.Overuse Can Lead to Poor Code Organization: Overusing extensions to add numerous functions to existing classes can make code harder to navigate and maintain, especially if these functions are spread across various files or modules. This can lead to a bloated API and make the codebase less cohesive.Hard to Trace Origin of Functions: In large codebases, it can be difficult to locate where an extension function is defined, as it may be in a different module or package. This makes code navigation and debugging more challenging.SummaryExtensions in Kotlin are powerful tools that enhance functionality in a clean, modular way without requiring inheritance or modification of the original class. While Kotlin extensions offer convenience and flexibility, they should be used judiciously to avoid complications and maintain clear, maintainable code.3. What’s the difference between Coroutines and Thread?The difference between Kotlin Coroutines and Threads in Android (and Kotlin in general) lies in how they manage concurrency, resource consumption, and performance.1. Lightweight vs. Heavyweight: Coroutines are lightweight. They run within a single thread but can be suspended without blocking the thread. This allows thousands of coroutines to run concurrently on fewer threads with minimal overhead. Threads, on the other hand, are heavyweight. Each thread has its own memory and resources, and switching between threads involves more overhead, leading to higher resource consumption when dealing with many threads.2. Concurrency vs. Parallelism: Coroutines offer concurrency by allowing multiple tasks to be suspended and resumed without occupying a separate thread. They do not necessarily run tasks in parallel but allow cooperative multitasking. Threads offer parallelism by running tasks simultaneously on multiple cores. Each thread can perform tasks independently, which can be useful for CPU-bound operations.3. Thread Blocking vs. Suspension: Coroutines use a suspension mechanism, meaning they do not block a thread while waiting for a task to complete. When a coroutine is suspended (e.g., while waiting for a network response), the underlying thread can execute other coroutines. Threads perform blocking operations. If a thread is waiting for an I/O operation or sleep call, it will not be able to perform other tasks.4. Efficiency: Coroutines are more efficient regarding memory and CPU usage because they avoid context-switching between threads and use fewer system resources. Threads consume more resources due to the overhead of thread creation, scheduling, and context switching between threads.5. Context Switching: Coroutines allow switching between tasks using suspension points (like delay() or withContext()), which is less expensive than switching between threads. Threads involve context switching handled by the operating system, which can be more costly in terms of performance.6. Use Cases: Coroutines are ideal for I/O-bound tasks, like making network requests, handling database operations, and UI updates. Threads are better suited for CPU-bound tasks, where actual parallel computation (e.g., intensive image processing, large computations) may be needed.7. Error Handling: Coroutines provide structured concurrency APIs like Job, CoroutineExceptionHandler to handle exceptions and cancel tasks easily, and coroutine builder, such as launch and async, which immediately propagates exceptions. Threads require more manual error handling (try-catch or uncaughtExceptionHandler) and coordination for task cancellation and exception propagation.SummaryCoroutines are more suitable for managing large numbers of tasks concurrently with minimal overhead, while Threads are better for parallel execution when multiple CPU cores are required.You might also encounter related questions, such as those about the sealed/companion classes or Flow, StateFlow, and SharedFlow. For more insights, be sure to check out Dove Letter.Jetpack ComposeJetpack Compose, Google’s modern UI toolkit, has demonstrated tremendous potential since its stable 1.0 release. Its adoption for production has soared, with over 125,000 apps built with Jetpack Compose now live on the Google Play Store, according to Google.However, many companies are still in the process of adopting Jetpack Compose or considering a migration from traditional View systems, as transitioning an entire large-scale project can be costly. Whether Jetpack Compose-related questions are part of an interview will largely depend on the specific company.1. What’s Recomposition?Recomposition in Jetpack Compose is the process by which the framework redraws parts of the UI to reflect updated data or state. Instead of redrawing the entire screen, Compose smartly “recomposes” (smart recomposition) only the parts of the UI that need to change, making it more efficient than traditional UI frameworks.How Recomposition WorksState-Driven UI: Compose is a declarative UI framework where the UI is built based on the current state. When state changes, Compose triggers recomposition for the affected parts of the UI tree.Selective Redraw: Only the composable functions that rely on the updated state will recompose. If a composable function doesn’t depend on the changed state, it will not recompose, making the UI update more efficient.Composable Functions: Recomposition happens at the function level, where Compose calls the affected composable functions again with the new data. Compose reuses as much as possible from the previous composition to avoid unnecessary redraws.For example, imagine there’s a text displaying a click count and a button that increments this count each time the user clicks it.The example above plays:Each time the button is clicked, count is updated, triggering recomposition of the Counter function.Compose redraws only the Text composable showing the count value, rather than the entire UI.To summarize, the key points about recomposition are:State-Driven: Recomposition occurs when state changes. remember and mutableStateOf are commonly used to hold state that affects recomposition.Optimized Performance: Compose tries to recompose only what’s necessary, helping to improve performance.Idempotency: Composable functions should be designed to produce the same UI output for the same input, making recomposition reliable.The Jetpack Compose Runtime library offers several functions that are closely related to state management, designed to either preserve data across recompositions or handle side effects efficiently.remember: Caches values across recompositions, so they aren’t reset each time.derivedStateOf: Optimizes recomposition by only triggering when the derived state changes.LaunchedEffect, SideEffect, and DisposableEffect: Manage side effects in composable functions across recompositions.SummaryRecomposition is the process that updates and redraws UI elements based on new states, focusing only on parts of the UI that need to change. This approach, known as “smart recomposition,” allows Jetpack Compose to efficiently update the UI, preserving responsiveness by keeping it synchronized with the current state.2. What’s State Hoisting?State hoisting in Jetpack Compose refers to a design pattern where you “hoist” the state up to the caller or parent composable, allowing the parent to control the state while the child composable only focuses on displaying the UI. This concept is inspired by React’s state management approach. The main goal of state hoisting is to separate concerns, keeping UI components stateless and promoting reusability and easier testing.In state hoisting:State is managed in the parent composable.Events or triggers (like onClick, onValueChange) are passed from the child back to the parent, which updates the state.The updated state is then passed back down as parameters to the child, creating a unidirectional data flow.Example:In this example, the Parent composable manages the state (sliderValue), while the SliderComponent is stateless and receives both the value and the event handler from the parent. This approach promotes better structure and maintainability in Compose applications.State hoisting in Jetpack Compose offers several benefits below:Single Source of Truth: State hoisting ensures that the state is managed in a single place (usually the parent composable), preventing conflicting states between child and parent composables. This improves data consistency across the app.Reusability: Since child composables don’t manage their own state, they can be reused in different parts of the app. You can pass different states and event handlers, making components more versatile and reusable.Separation of Concerns: By hoisting state to the parent, you can keep your child composables stateless, focusing purely on rendering the UI. This makes components simpler, easier to read, and maintain.Improved Testability: Stateless composables are easier to test because they don’t have to manage state internally. You can pass in different states and event handlers to simulate various scenarios.Unidirectional Data Flow: State hoisting enforces a unidirectional data flow, where the state is passed down from the parent, and events are sent back up, making the flow of data more predictable and easier to debug.Better Control Over Lifecycle: When the state is managed in the parent, you have better control over its lifecycle. The parent can decide when and how the state should change, which can improve performance and efficiency in managing resources like memory.These benefits collectively improve the overall structure, maintainability, and scalability of your Jetpack Compose codebase.SummaryYou should hoist UI state to the lowest common ancestor of all the composables that need to read or modify that state. Keeping the state as close as possible to where it is consumed helps maintain a clean separation of concerns and ensures efficient data flow. From the state owner, expose an immutable state to consumers along with events or callbacks that allow them to modify the state as needed. For more details, refer to Where to hoist state.3. What are side-effectsIn Jetpack Compose, a side effect refers to any operation that affects state outside the scope of the composable function or persists beyond its recomposition. Since composables are designed to be pure functions that simply render UI based on the current state, side effects are used when you need to perform actions outside the composable function’s lifecycle, like updating shared state, triggering one-time events, or interacting with external resources.Jetpack Compose provides several side-effect APIs to handle these scenarios safely and predictably, such as LaunchedEffect, SideEffect, and DisposableEffect.1. LaunchedEffect: Used for launching coroutines in a composableLaunchedEffect allows you to start a coroutine in response to certain key state changes. It runs within the Composition and will cancel and restart if the specified key changes, making it useful for one-time or reactive tasks, such as fetching data or handling animations.Example:2. SideEffect: Used to perform non-restartable side effectsSideEffect is invoked every time a composable successfully recomposes. It’s used for performing lightweight, non-restartable actions like updating a mutable shared object or logging.Example:3. DisposableEffect: Used for effects that need cleanupDisposableEffect is used for actions that require both setup and cleanup, such as registering a listener or resource that should be released when the composition leaves the screen or is recomposed. This API lets you define onDispose block, which will be invoked when the Composable function's lifecycle is ended up.Example:SummaryUsing these side-effect APIs properly allows you to manage external resources, events, and state changes efficiently within the composable lifecycle, maintaining a clean, predictable UI. For more information, check out the official Android docs Side-effects in Compose.LaunchedEffect: Triggers a coroutine based on state changes; ideal for async actions like data loading.SideEffect: Executes non-restartable code after each recomposition; useful for logging or relevant actions.DisposableEffect: Manages effects with setup and cleanup/disposing requirements, such as resource listeners.ConclusionIn this article, you’ve explored the top nine Android developer interview questions you might encounter during the hiring process. Remember, interview questions can vary significantly based on the role, team culture, industry, and even the interviewers themselves. It’s essential to tailor your preparation to align with the specific company and position you’re applying for.All these interview questions are covered in Dove Letter, a private repository offering daily insights on Android and Kotlin, including topics like Compose, architecture, industry interview questions, and practical code tips. In just 15 weeks since its launch, Dove Letter has surpassed 350 individual subscribers and 8 business/lifetime subscribers. If you’re eager to deepen your knowledge of Android, Kotlin, and Compose, be sure to check out ‘Learn Kotlin and Android With Dove Letter’.As always, happy coding!— Jaewoong",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*QhM1jZ56sVMbyc0hgOgRPw.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003cfigcaption\u003eUnsplash@adolfofelix\u003c/figcaption\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://skydoves.medium.com/?source=post_page---byline--05e8fe2acd2c--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Jaewoong Eum\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*to22-X47VSP4tZeElwVKKA.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--05e8fe2acd2c--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"b063\"\u003e\u003cspan\u003eW\u003c/span\u003ehen applying for a job as an Android developer, you’ll need expertise in Android, Kotlin, and other relevant skills, depending on the team you’re joining. While it’s impossible to predict every interview question, you can prepare by mastering the fundamental knowledge essential for working as an Android developer.\u003c/p\u003e\u003cp id=\"e133\"\u003eThe best way to prepare for an interview is to review the minimum requirements and preferred qualifications for the role, ensuring you align with the team’s needs. Interview questions can vary widely depending on the team, the company’s industry, and its development culture. As a result, tailoring your preparation to the specific team and company is crucial for success.\u003c/p\u003e\u003cp id=\"04a7\"\u003eWhile preferred requirements can vary greatly between teams, some common questions tend to surface universally for Android developer roles. In this article, you’ll discover the top nine Android developer interview questions featured in \u003ca href=\"https://github.com/doveletter\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eDove Letter\u003c/em\u003e\u003c/a\u003e. \u003ca href=\"https://github.com/doveletter\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003eDove Letter\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e is a subscription repository where you can learn, discuss, and share new insights about Android and Kotlin with industrial Android developer interview questions, tips with code, articles, discussion, and trending news. If you’re interested in joining, be sure to check out “\u003ca href=\"https://medium.com/@skydoves/learn-kotlin-and-android-with-dove-letter-26265da11903\" rel=\"noopener\"\u003e\u003cstrong\u003eLearn Kotlin and Android With Dove Letter\u003c/strong\u003e\u003c/a\u003e.”\u003c/p\u003e\u003ch2 id=\"0f20\"\u003eAndroid\u003c/h2\u003e\u003cp id=\"6760\"\u003eAndroid boasts over a decade of history, with \u003ca href=\"https://developer.android.com/about/versions/15\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroid 15 announced\u003c/a\u003e already, reflecting significant technical advancements over time. Despite these changes, the core systems and components, such as the Activity and Fragment lifecycles or Intents, have remained largely consistent. Understanding these fundamental systems, even if they feel like “old-school” technologies, is still crucial for any Android developer.\u003c/p\u003e\u003ch2 id=\"7e95\"\u003e1. Describe the Activity Lifecycle\u003c/h2\u003e\u003cp id=\"5e3e\"\u003eThe Android Activity lifecycle describes the different states an activity goes through during its lifetime, from creation to destruction. Understanding these states is crucial for managing resources effectively, handling user input, and ensuring a smooth user experience. Here are the main stages of the Activity lifecycle:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://developer.android.com/guide/components/activities/activity-lifecycle\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eThe activity lifecycle\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003col\u003e\u003cli id=\"0034\"\u003e\u003cstrong\u003eonCreate()\u003c/strong\u003e: This is the first method called when an activity is created. It’s where you initialize the activity, set up UI components, and restore any saved instance state. It’s only called once during the activity’s lifecycle unless the activity is destroyed and recreated.\u003c/li\u003e\u003cli id=\"619e\"\u003e\u003cstrong\u003eonStart()\u003c/strong\u003e: The activity becomes visible to the user but is not yet interactive. This is called after onCreate() and before onResume().\u003c/li\u003e\u003cli id=\"20f5\"\u003e\u003cstrong\u003eonRestart()\u003c/strong\u003e: If the activity is stopped and then restarted (e.g., the user navigates back to it), this method is called before onStart().\u003c/li\u003e\u003cli id=\"de36\"\u003e\u003cstrong\u003eonResume()\u003c/strong\u003e: The activity is in the foreground and the user can interact with it. This is where you resume any paused UI updates, animations, or input listeners.\u003c/li\u003e\u003cli id=\"cfca\"\u003e\u003cstrong\u003eonPause()\u003c/strong\u003e: This is called when the activity is partially obscured by another activity (e.g., a dialog). The activity is still visible but not in focus. It’s often used to pause operations like animations, sensor updates, or saving data.\u003c/li\u003e\u003cli id=\"801b\"\u003e\u003cstrong\u003eonStop()\u003c/strong\u003e: The activity is no longer visible to the user (for example, when another activity comes to the foreground). You should release resources that are not needed while the activity is stopped, such as background tasks or heavy objects.\u003c/li\u003e\u003cli id=\"fb38\"\u003e\u003cstrong\u003eonDestroy()\u003c/strong\u003e: This is called before the activity is fully destroyed and removed from memory. It’s the final clean-up method for releasing all remaining resources.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"c4e6\"\u003e\u003cstrong\u003eSummary\u003cbr/\u003e\u003c/strong\u003eAn activity goes through these methods based on user interactions and the Android system’s management of app resources. Developers use these callbacks to manage transitions, conserve resources, and provide a smooth experience for users. For more details, check out \u003ca href=\"https://developer.android.com/reference/android/app/Activity\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethe Android official documentation\u003c/a\u003e.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"7afe\"\u003eYou might also encounter related questions, such as those about the Fragment lifecycle or View lifecycle in Android. For more insights, be sure to check out \u003ca href=\"https://github.com/doveletter\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003eDove Letter\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e\u003cem\u003e.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"b962\"\u003e2. What is an Intent?\u003c/h2\u003e\u003cp id=\"07e1\"\u003eAn Intent in Android is an abstract description of an operation to be performed. It serves as a messaging object that allows activities, services, and broadcast receivers to communicate. Intents are typically used to start an activity, send a broadcast, or initiate a service. They can also pass data between components, making them a fundamental part of Android’s component-based architecture.\u003c/p\u003e\u003cp id=\"f346\"\u003eThere are two primary types of intents in Android: \u003cstrong\u003eexplicit\u003c/strong\u003e and \u003cstrong\u003eimplicit\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"7ad2\"\u003e\u003cstrong\u003e1. Explicit Intent\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"48da\"\u003e\u003cstrong\u003eDefinition\u003c/strong\u003e: An explicit intent specifies the exact component (activity or service) to be invoked by directly naming it.\u003c/li\u003e\u003cli id=\"a172\"\u003e\u003cstrong\u003eUse Case\u003c/strong\u003e: Explicit intents are used when you know the target component (e.g., starting a specific activity within your app).\u003c/li\u003e\u003cli id=\"7409\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e:\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"399f\"\u003e\u003cstrong\u003eScenario\u003c/strong\u003e: If you switch from one activity to another within the same app, you use explicit intent.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3822\"\u003e\u003cstrong\u003e2. Implicit Intent\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"a8fd\"\u003e\u003cstrong\u003eDefinition\u003c/strong\u003e: An implicit intent does not specify a specific component but declares a general action to be performed. The system resolves which component(s) can handle the intent based on the action, category, and data.\u003c/li\u003e\u003cli id=\"97da\"\u003e\u003cstrong\u003eUse Case\u003c/strong\u003e: Implicit intents are useful when you want to perform an action that other apps or system components can handle (e.g., opening a URL or sharing content).\u003c/li\u003e\u003cli id=\"ac10\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e:\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"caa5\"\u003e\u003cstrong\u003eScenario\u003c/strong\u003e: If you open a web page in a browser or share content with other apps, you use an implicit intent. The system will decide which app to handle the intent.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"76c0\"\u003e\u003cstrong\u003eSummary\u003cbr/\u003e\u003c/strong\u003eExplicit intents are used for internal app navigation where the target component is known. Implicit intents are used for actions that external apps or other components may handle without directly specifying the target. This makes the Android ecosystem more flexible and allows apps to interact seamlessly.\u003c/p\u003e\u003ch2 id=\"9c0b\"\u003e3. What’s the difference between Serialization and Parcelable?\u003c/h2\u003e\u003cp id=\"7efa\"\u003eIn Android, both \u003ccode\u003eSerializable\u003c/code\u003e and \u003ccode\u003eParcelable\u003c/code\u003e are mechanisms used to pass data between different components (such as activities or fragments), but they function differently in terms of performance and implementation. Here’s a comparison of the two:\u003c/p\u003e\u003cp id=\"6527\"\u003e\u003cstrong\u003eSerializable\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"9b6f\"\u003e\u003cstrong\u003eJava Standard Interface\u003c/strong\u003e: \u003ccode\u003eSerializable\u003c/code\u003e is a standard Java interface used to convert an object into a byte stream, which can then be passed between activities or written to disk.\u003c/li\u003e\u003cli id=\"677a\"\u003e\u003cstrong\u003eReflection-Based:\u003c/strong\u003e It works through Java reflection, meaning the system dynamically inspects the class and its fields at runtime to serialize the object.\u003c/li\u003e\u003cli id=\"9001\"\u003e\u003cstrong\u003ePerformance:\u003c/strong\u003e \u003ccode\u003eSerializable\u003c/code\u003e is slower compared to \u003ccode\u003eParcelable\u003c/code\u003e because reflection is a slow process. It also generates a lot of temporary objects during serialization, increasing the memory overhead.\u003c/li\u003e\u003cli id=\"48a1\"\u003e\u003cstrong\u003eUse Case:\u003c/strong\u003e \u003ccode\u003eSerializable\u003c/code\u003e is useful in scenarios where performance is not critical or when dealing with non-Android-specific codebases.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ac47\"\u003e\u003cstrong\u003eParcelable\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"a4c8\"\u003e\u003cstrong\u003eAndroid-Specific Interface:\u003c/strong\u003e \u003ccode\u003eParcelable\u003c/code\u003e is an Android-specific interface designed specifically for high-performance inter-process communication (IPC) within Android components.\u003c/li\u003e\u003cli id=\"ade6\"\u003e\u003cstrong\u003ePerformance:\u003c/strong\u003e \u003ccode\u003eParcelable\u003c/code\u003e is faster than \u003ccode\u003eSerializable\u003c/code\u003e because it’s optimized for Android and doesn’t rely on reflection. It minimizes garbage collection by avoiding creating many temporary objects.\u003c/li\u003e\u003cli id=\"ae64\"\u003e\u003cstrong\u003eUse Case:\u003c/strong\u003e \u003ccode\u003eParcelable\u003c/code\u003e is preferred for passing data in Android when performance is important, especially for IPC or passing data between activities or services.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1044\"\u003e\u003cstrong\u003eSummary\u003cbr/\u003e\u003c/strong\u003eIn general, \u003ccode\u003eParcelable\u003c/code\u003e is the recommended approach for Android applications due to its better performance in most use cases. However, if you need simplicity and performance is not a concern, \u003ccode\u003eSerializable\u003c/code\u003e might be easier to implement.\u003c/p\u003e\u003cul\u003e\u003cli id=\"0b61\"\u003eUse \u003ccode\u003eSerializable\u003c/code\u003e for simpler cases when dealing with non-performance-critical operations or when working with non-Android-specific code.\u003c/li\u003e\u003cli id=\"4182\"\u003eUse \u003ccode\u003eParcelable\u003c/code\u003e when working with Android-specific components where performance matters, as it is much more efficient for Android’s IPC mechanism.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f0b8\"\u003eKotlin\u003c/h2\u003e\u003cp id=\"154c\"\u003eSince Google announced its \u003ca href=\"https://developer.android.com/kotlin/first\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin-first approach to Android development\u003c/a\u003e at Google I/O 2019, the adoption of Kotlin has skyrocketed. By the end of 2024, the majority of Android projects have transitioned to Kotlin, especially with\u003ca href=\"https://android-developers.googleblog.com/2021/07/jetpack-compose-announcement.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e Jetpack Compose reaching its stable release\u003c/a\u003e and gaining widespread popularity. So, in most cases, most of the team is likely using Kotlin instead of Java in most cases nowadays.\u003c/p\u003e\u003ch2 id=\"2ab8\"\u003e1. What is data class in Kotlin? How does a data class in Kotlin differ from a regular class?\u003c/h2\u003e\u003cp id=\"6987\"\u003eIn Kotlin, the \u003ca href=\"https://kotlinlang.org/docs/data-classes.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edata class\u003c/a\u003e is a special type of class specifically designed to hold data. Kotlin generates several useful methods automatically for data classes, which makes them ideal for representing simple data-holding objects.\u003c/p\u003e\u003cp id=\"6d3a\"\u003e\u003cstrong\u003eKey Features of Data Classes\u003cbr/\u003e\u003c/strong\u003eWhen you declare a data class, Kotlin automatically generates the following:\u003c/p\u003e\u003col\u003e\u003cli id=\"02cc\"\u003e\u003ccode\u003e\u003cstrong\u003eequals()\u003c/strong\u003e\u003c/code\u003e: Compares two instances of the class for equality based on their properties.\u003c/li\u003e\u003cli id=\"7b32\"\u003e\u003ccode\u003e\u003cstrong\u003ehashCode(\u003c/strong\u003e)\u003c/code\u003e: Generates a hash code based on the properties.\u003c/li\u003e\u003cli id=\"4116\"\u003e\u003ccode\u003e\u003cstrong\u003etoString()\u003c/strong\u003e\u003c/code\u003e: Provides a string representation of the object with its property values.\u003c/li\u003e\u003cli id=\"03f5\"\u003e\u003ccode\u003e\u003cstrong\u003ecopy()\u003c/strong\u003e\u003c/code\u003e: Allows for creating a new object with some properties copied from the existing one, with the option to modify specific values.\u003c/li\u003e\u003cli id=\"72a3\"\u003e\u003cstrong\u003eComponent functions\u003c/strong\u003e: For de-structuring declarations (e.g., \u003ccode\u003ecomponent1()\u003c/code\u003e, \u003ccode\u003ecomponent2()\u003c/code\u003e), allowing you to extract properties easily.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"0db8\"\u003e\u003cstrong\u003eExample\u003cbr/\u003e\u003c/strong\u003eIn the example below, Kotlin automatically provides \u003ccode\u003eequals()\u003c/code\u003e, \u003ccode\u003ehashCode()\u003c/code\u003e, \u003ccode\u003etoString()\u003c/code\u003e, and \u003ccode\u003ecopy()\u003c/code\u003e for the \u003ccode\u003eUser\u003c/code\u003e class.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9010\"\u003e\u003cstrong\u003eDifferences Between Data Class and Normal Class\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"7b3e\"\u003e\u003cstrong\u003eBoilerplate Reduction\u003c/strong\u003e: In a normal class, you would need to manually override \u003ccode\u003eequals()\u003c/code\u003e, \u003ccode\u003ehashCode()\u003c/code\u003e, \u003ccode\u003etoString()\u003c/code\u003e, and other utility methods. With a data class, Kotlin generates these for you automatically.\u003c/li\u003e\u003cli id=\"5921\"\u003e\u003cstrong\u003ePrimary Constructor Requirement\u003c/strong\u003e: A data class requires at least one property to be declared in the primary constructor, whereas a normal class does not.\u003c/li\u003e\u003cli id=\"9d08\"\u003e\u003cstrong\u003eUse Case\u003c/strong\u003e: Data classes are primarily used for holding immutable data (though you can use mutable properties), whereas normal classes can be used for any kind of behavior or logic.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"d06b\"\u003e\u003cstrong\u003eExample of Normal Class for Comparison\u003cbr/\u003e\u003c/strong\u003eIn the example above, Kotlin automatically provides \u003ccode\u003eequals()\u003c/code\u003e, \u003ccode\u003ehashCode()\u003c/code\u003e, \u003ccode\u003etoString()\u003c/code\u003e, and \u003ccode\u003ecopy()\u003c/code\u003e for the \u003ccode\u003eUser\u003c/code\u003e class.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f699\"\u003e\u003cstrong\u003eSummary\u003cbr/\u003e\u003c/strong\u003eData classes are used for objects that only contain data, and Kotlin automatically generates utility methods like \u003ccode\u003eequals()\u003c/code\u003e, \u003ccode\u003ehashCode()\u003c/code\u003e, \u003ccode\u003etoString()\u003c/code\u003e, and \u003ccode\u003ecopy()\u003c/code\u003e. A normal class is more flexible but doesn’t provide those methods by default, making it more suited for objects with behavior and complex logic.\u003c/p\u003e\u003ch2 id=\"65ba\"\u003e2. What’s the Extension, and what are its pros and cons?\u003c/h2\u003e\u003cp id=\"9d01\"\u003eThe \u003ca href=\"https://kotlinlang.org/docs/extensions.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eExtensions\u003c/a\u003e is a way to add new functionality to existing classes without modifying their code directly. Kotlin allows you to “extend” a class with new functions or properties using extension functions and extension properties. This is especially useful for enhancing classes from third-party libraries or the standard library where you don’t have access to the source code.\u003c/p\u003e\u003cp id=\"7961\"\u003e\u003cstrong\u003eExample of an Extension Function\u003cbr/\u003e\u003c/strong\u003eSuppose you want to add a \u003ccode\u003eisEven()\u003c/code\u003e function to the \u003ccode\u003eInt\u003c/code\u003e class. You can do it like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"052c\"\u003eHere, \u003ccode\u003eisEven()\u003c/code\u003e becomes a new function available to all \u003ccode\u003eInt\u003c/code\u003e objects, even though you haven’t modified the \u003ccode\u003eInt\u003c/code\u003e class itself.\u003c/p\u003e\u003cp id=\"8c2c\"\u003e\u003cstrong\u003eExample of an Extension Property\u003cbr/\u003e\u003c/strong\u003eKotlin also allows you to add new properties to a class in a similar way. Note that these properties can’t store state and are just syntactic sugar for getter functions.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7d60\"\u003eAnother great example is adding an extension property to an existing type:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e33e\"\u003e\u003cstrong\u003ePros of Extensions\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"1185\"\u003e\u003cstrong\u003eEnhanced Readability\u003c/strong\u003e: Extensions make code more readable and expressive.\u003c/li\u003e\u003cli id=\"a2e8\"\u003e\u003cstrong\u003eModularity\u003c/strong\u003e: They allow you to add functionality without modifying the original class.\u003c/li\u003e\u003cli id=\"ac99\"\u003e\u003cstrong\u003eCode Reusability\u003c/strong\u003e: Extensions can be reused across different parts of your application, helping to avoid boilerplate code.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"a2ce\"\u003eWhile Kotlin extensions are powerful and flexible, they come with disadvantages and limitations.\u003c/p\u003e\u003cp id=\"9d21\"\u003e\u003cstrong\u003eCons of Extensions\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"b350\"\u003e\u003cstrong\u003ePotential for Confusion\u003c/strong\u003e: Extensions can sometimes lead to confusion, especially if they clash with functions already present in the class or if there are multiple extensions with similar names. In cases where both an extension function and a member function have the same name, the member function takes precedence, which can be unintuitive.\u003c/li\u003e\u003cli id=\"6127\"\u003e\u003cstrong\u003eOveruse Can Lead to Poor Code Organization\u003c/strong\u003e: Overusing extensions to add numerous functions to existing classes can make code harder to navigate and maintain, especially if these functions are spread across various files or modules. This can lead to a bloated API and make the codebase less cohesive.\u003c/li\u003e\u003cli id=\"cedc\"\u003e\u003cstrong\u003eHard to Trace Origin of Functions\u003c/strong\u003e: In large codebases, it can be difficult to locate where an extension function is defined, as it may be in a different module or package. This makes code navigation and debugging more challenging.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"59ff\"\u003e\u003cstrong\u003eSummary\u003cbr/\u003e\u003c/strong\u003eExtensions in Kotlin are powerful tools that enhance functionality in a clean, modular way without requiring inheritance or modification of the original class. While Kotlin extensions offer convenience and flexibility, they should be used judiciously to avoid complications and maintain clear, maintainable code.\u003c/p\u003e\u003ch2 id=\"763f\"\u003e3. What’s the difference between Coroutines and Thread?\u003c/h2\u003e\u003cp id=\"1d4f\"\u003eThe difference between \u003ca href=\"https://kotlinlang.org/docs/coroutines-overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Coroutines\u003c/a\u003e and Threads in Android (and Kotlin in general) lies in how they manage concurrency, resource consumption, and performance.\u003c/p\u003e\u003cp id=\"1335\"\u003e\u003cstrong\u003e1. Lightweight vs. Heavyweight: \u003c/strong\u003eCoroutines are lightweight. They run within a single thread but can be suspended without blocking the thread. This allows thousands of coroutines to run concurrently on fewer threads with minimal overhead. Threads, on the other hand, are heavyweight. Each thread has its own memory and resources, and switching between threads involves more overhead, leading to higher resource consumption when dealing with many threads.\u003c/p\u003e\u003cp id=\"22ae\"\u003e\u003cstrong\u003e2. Concurrency vs. Parallelism: \u003c/strong\u003eCoroutines offer concurrency by allowing multiple tasks to be suspended and resumed without occupying a separate thread. They do not necessarily run tasks in parallel but allow cooperative multitasking. Threads offer parallelism by running tasks simultaneously on multiple cores. Each thread can perform tasks independently, which can be useful for CPU-bound operations.\u003c/p\u003e\u003cp id=\"1c64\"\u003e\u003cstrong\u003e3. Thread Blocking vs. Suspension: \u003c/strong\u003eCoroutines use a suspension mechanism, meaning they do not block a thread while waiting for a task to complete. When a coroutine is suspended (e.g., while waiting for a network response), the underlying thread can execute other coroutines. Threads perform blocking operations. If a thread is waiting for an I/O operation or sleep call, it will not be able to perform other tasks.\u003c/p\u003e\u003cp id=\"981e\"\u003e\u003cstrong\u003e4. Efficiency: \u003c/strong\u003eCoroutines are more efficient regarding memory and CPU usage because they avoid context-switching between threads and use fewer system resources. Threads consume more resources due to the overhead of thread creation, scheduling, and context switching between threads.\u003c/p\u003e\u003cp id=\"1f7f\"\u003e\u003cstrong\u003e5. Context Switching: \u003c/strong\u003eCoroutines allow switching between tasks using suspension points (like \u003ccode\u003edelay()\u003c/code\u003e or \u003ccode\u003ewithContext()\u003c/code\u003e), which is less expensive than switching between threads. Threads involve context switching handled by the operating system, which can be more costly in terms of performance.\u003c/p\u003e\u003cp id=\"a1cc\"\u003e\u003cstrong\u003e6. Use Cases: \u003c/strong\u003eCoroutines are ideal for I/O-bound tasks, like making network requests, handling database operations, and UI updates. Threads are better suited for CPU-bound tasks, where actual parallel computation (e.g., intensive image processing, large computations) may be needed.\u003c/p\u003e\u003cp id=\"6880\"\u003e\u003cstrong\u003e7. Error Handling: \u003c/strong\u003eCoroutines provide structured concurrency APIs like \u003ccode\u003eJob\u003c/code\u003e, \u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e to handle exceptions and cancel tasks easily, and coroutine builder, such as \u003ccode\u003elaunch\u003c/code\u003e and \u003ccode\u003easync\u003c/code\u003e, which immediately propagates exceptions. Threads require more manual error handling (try-catch or \u003ccode\u003euncaughtExceptionHandler\u003c/code\u003e) and coordination for task cancellation and exception propagation.\u003c/p\u003e\u003cp id=\"b659\"\u003e\u003cstrong\u003eSummary\u003cbr/\u003e\u003c/strong\u003eCoroutines are more suitable for managing large numbers of tasks concurrently with minimal overhead, while Threads are better for parallel execution when multiple CPU cores are required.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"7484\"\u003eYou might also encounter related questions, such as those about the sealed/companion classes or Flow, StateFlow, and SharedFlow. For more insights, be sure to check out \u003ca href=\"https://github.com/doveletter\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003eDove Letter\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e\u003cem\u003e.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"bb23\"\u003eJetpack Compose\u003c/h2\u003e\u003cp id=\"f32e\"\u003eJetpack Compose, Google’s modern UI toolkit, has demonstrated tremendous potential since \u003ca href=\"https://android-developers.googleblog.com/2021/07/jetpack-compose-announcement.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eits stable 1.0 release\u003c/a\u003e. Its adoption for production has soared, with over 125,000 apps built with Jetpack Compose now live on the Google Play Store, \u003ca href=\"https://x.com/AndroidDev/status/1726662755724181663\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eaccording to Google\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"5a5a\"\u003eHowever, many companies are still in the process of adopting Jetpack Compose or considering a migration from traditional View systems, as transitioning an entire large-scale project can be costly. Whether Jetpack Compose-related questions are part of an interview will largely depend on the specific company.\u003c/p\u003e\u003ch2 id=\"efd2\"\u003e1. What’s Recomposition?\u003c/h2\u003e\u003cp id=\"5493\"\u003eRecomposition in Jetpack Compose is the process by which the framework redraws parts of the UI to reflect updated data or state. Instead of redrawing the entire screen, Compose smartly “recomposes” (smart recomposition) only the parts of the UI that need to change, making it more efficient than traditional UI frameworks.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0996\"\u003e\u003cstrong\u003eHow Recomposition Works\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"8cc9\"\u003e\u003cstrong\u003eState-Driven UI\u003c/strong\u003e: Compose is a declarative UI framework where the UI is built based on the current state. When state changes, Compose triggers recomposition for the affected parts of the UI tree.\u003c/li\u003e\u003cli id=\"0fb4\"\u003e\u003cstrong\u003eSelective Redraw\u003c/strong\u003e: Only the composable functions that rely on the updated state will recompose. If a composable function doesn’t depend on the changed state, it will not recompose, making the UI update more efficient.\u003c/li\u003e\u003cli id=\"e3af\"\u003e\u003cstrong\u003eComposable Functions\u003c/strong\u003e: Recomposition happens at the function level, where Compose calls the affected composable functions again with the new data. Compose reuses as much as possible from the previous composition to avoid unnecessary redraws.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"b027\"\u003eFor example, imagine there’s a text displaying a click count and a button that increments this count each time the user clicks it.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"6c4f\"\u003eThe example above plays:\u003c/p\u003e\u003cul\u003e\u003cli id=\"c805\"\u003eEach time the button is clicked, \u003ccode\u003ecount\u003c/code\u003e is updated, triggering recomposition of the \u003ccode\u003eCounter\u003c/code\u003e function.\u003c/li\u003e\u003cli id=\"496e\"\u003eCompose redraws only the \u003ccode\u003eText\u003c/code\u003e composable showing the count value, rather than the entire UI.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4590\"\u003eTo summarize, the key points about recomposition are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"01c3\"\u003e\u003cstrong\u003eState-Driven\u003c/strong\u003e: Recomposition occurs when state changes. \u003ccode\u003eremember\u003c/code\u003e and \u003ccode\u003emutableStateOf\u003c/code\u003e are commonly used to hold state that affects recomposition.\u003c/li\u003e\u003cli id=\"c528\"\u003e\u003cstrong\u003eOptimized Performance\u003c/strong\u003e: Compose tries to recompose only what’s necessary, helping to improve performance.\u003c/li\u003e\u003cli id=\"5a9e\"\u003e\u003cstrong\u003eIdempotency\u003c/strong\u003e: Composable functions should be designed to produce the same UI output for the same input, making recomposition reliable.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e64c\"\u003eThe Jetpack Compose Runtime library offers several functions that are closely related to state management, designed to either preserve data across recompositions or handle side effects efficiently.\u003c/p\u003e\u003cul\u003e\u003cli id=\"209e\"\u003e\u003ccode\u003eremember\u003c/code\u003e: Caches values across recompositions, so they aren’t reset each time.\u003c/li\u003e\u003cli id=\"16b0\"\u003e\u003ccode\u003ederivedStateOf\u003c/code\u003e: Optimizes recomposition by only triggering when the derived state changes.\u003c/li\u003e\u003cli id=\"80ca\"\u003e\u003ccode\u003eLaunchedEffect\u003c/code\u003e, \u003ccode\u003eSideEffect\u003c/code\u003e, and \u003ccode\u003eDisposableEffect\u003c/code\u003e: Manage side effects in composable functions across recompositions.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"e6be\"\u003eSummary\u003c/h2\u003e\u003cp id=\"75d1\"\u003eRecomposition is the process that updates and redraws UI elements based on new states, focusing only on parts of the UI that need to change. This approach, known as “smart recomposition,” allows Jetpack Compose to efficiently update the UI, preserving responsiveness by keeping it synchronized with the current state.\u003c/p\u003e\u003ch2 id=\"236e\"\u003e2. What’s State Hoisting?\u003c/h2\u003e\u003cp id=\"aae9\"\u003eState hoisting in Jetpack Compose refers to a design pattern where you “hoist” the state up to the caller or parent composable, allowing the parent to control the state while the child composable only focuses on displaying the UI. This concept is inspired by React’s state management approach. The main goal of state hoisting is to separate concerns, keeping UI components stateless and promoting reusability and easier testing.\u003c/p\u003e\u003cp id=\"2ab9\"\u003eIn state hoisting:\u003c/p\u003e\u003cul\u003e\u003cli id=\"da48\"\u003eState is managed in the parent composable.\u003c/li\u003e\u003cli id=\"2574\"\u003eEvents or triggers (like onClick, onValueChange) are passed from the child back to the parent, which updates the state.\u003c/li\u003e\u003cli id=\"5a5b\"\u003eThe updated state is then passed back down as parameters to the child, creating a unidirectional data flow.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"da3c\"\u003eExample:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e3f9\"\u003eIn this example, the \u003ccode\u003eParent\u003c/code\u003e composable manages the state (\u003ccode\u003esliderValue\u003c/code\u003e), while the \u003ccode\u003eSliderComponent\u003c/code\u003e is stateless and receives both the value and the event handler from the parent. This approach promotes better structure and maintainability in Compose applications.\u003c/p\u003e\u003cp id=\"36ea\"\u003eState hoisting in Jetpack Compose offers several benefits below:\u003c/p\u003e\u003col\u003e\u003cli id=\"9dbf\"\u003e\u003cstrong\u003eSingle Source of Truth\u003c/strong\u003e: State hoisting ensures that the state is managed in a single place (usually the parent composable), preventing conflicting states between child and parent composables. This improves data consistency across the app.\u003c/li\u003e\u003cli id=\"34ae\"\u003e\u003cstrong\u003eReusability\u003c/strong\u003e: Since child composables don’t manage their own state, they can be reused in different parts of the app. You can pass different states and event handlers, making components more versatile and reusable.\u003c/li\u003e\u003cli id=\"ea49\"\u003e\u003cstrong\u003eSeparation of Concerns\u003c/strong\u003e: By hoisting state to the parent, you can keep your child composables stateless, focusing purely on rendering the UI. This makes components simpler, easier to read, and maintain.\u003c/li\u003e\u003cli id=\"4146\"\u003e\u003cstrong\u003eImproved Testability\u003c/strong\u003e: Stateless composables are easier to test because they don’t have to manage state internally. You can pass in different states and event handlers to simulate various scenarios.\u003c/li\u003e\u003cli id=\"ebe0\"\u003e\u003cstrong\u003eUnidirectional Data Flow\u003c/strong\u003e: State hoisting enforces a unidirectional data flow, where the state is passed down from the parent, and events are sent back up, making the flow of data more predictable and easier to debug.\u003c/li\u003e\u003cli id=\"19d7\"\u003e\u003cstrong\u003eBetter Control Over Lifecycle\u003c/strong\u003e: When the state is managed in the parent, you have better control over its lifecycle. The parent can decide when and how the state should change, which can improve performance and efficiency in managing resources like memory.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"f3b9\"\u003eThese benefits collectively improve the overall structure, maintainability, and scalability of your Jetpack Compose codebase.\u003c/p\u003e\u003cp id=\"9d87\"\u003e\u003cstrong\u003eSummary\u003cbr/\u003e\u003c/strong\u003eYou should hoist UI state to the lowest common ancestor of all the composables that need to read or modify that state. Keeping the state as close as possible to where it is consumed helps maintain a clean separation of concerns and ensures efficient data flow. From the state owner, expose an immutable state to consumers along with events or callbacks that allow them to modify the state as needed. For more details, refer to \u003ca href=\"https://developer.android.com/develop/ui/compose/state-hoisting\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWhere to hoist state\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"a336\"\u003e3. What are side-effects\u003c/h2\u003e\u003cp id=\"5136\"\u003eIn Jetpack Compose, a side effect refers to any operation that affects state outside the scope of the composable function or persists beyond its recomposition. Since composables are designed to be pure functions that simply render UI based on the current state, side effects are used when you need to perform actions outside the composable function’s lifecycle, like updating shared state, triggering one-time events, or interacting with external resources.\u003c/p\u003e\u003cp id=\"b55b\"\u003eJetpack Compose provides several side-effect APIs to handle these scenarios safely and predictably, such as \u003ccode\u003eLaunchedEffect\u003c/code\u003e, \u003ccode\u003eSideEffect\u003c/code\u003e, and \u003ccode\u003eDisposableEffect\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"6125\"\u003e\u003cstrong\u003e1. LaunchedEffect: Used for launching coroutines in a composable\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"946b\"\u003e\u003ccode\u003eLaunchedEffect\u003c/code\u003e allows you to start a coroutine in response to certain key state changes. It runs within the \u003ccode\u003eComposition\u003c/code\u003e and will cancel and restart if the specified key changes, making it useful for one-time or reactive tasks, such as fetching data or handling animations.\u003c/li\u003e\u003cli id=\"986a\"\u003eExample:\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a6f6\"\u003e\u003cstrong\u003e2. SideEffect: Used to perform non-restartable side effects\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"1374\"\u003e\u003ccode\u003eSideEffect\u003c/code\u003e is invoked every time a composable successfully recomposes. It’s used for performing lightweight, non-restartable actions like updating a mutable shared object or logging.\u003c/li\u003e\u003cli id=\"7437\"\u003eExample:\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d09b\"\u003e\u003cstrong\u003e3. DisposableEffect: Used for effects that need cleanup\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"d00c\"\u003e\u003ccode\u003eDisposableEffect\u003c/code\u003e is used for actions that require both setup and cleanup, such as registering a listener or resource that should be released when the composition leaves the screen or is recomposed. This API lets you define \u003ccode\u003eonDispose\u003c/code\u003e block, which will be invoked when the Composable function\u0026#39;s lifecycle is ended up.\u003c/li\u003e\u003cli id=\"4f59\"\u003eExample:\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"846f\"\u003e\u003cstrong\u003eSummary\u003cbr/\u003e\u003c/strong\u003eUsing these side-effect APIs properly allows you to manage external resources, events, and state changes efficiently within the composable lifecycle, maintaining a clean, predictable UI. For more information, check out the official Android docs \u003ca href=\"https://developer.android.com/develop/ui/compose/side-effects\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSide-effects in Compose\u003c/a\u003e.\u003c/p\u003e\u003cul\u003e\u003cli id=\"c162\"\u003e\u003cstrong\u003eLaunchedEffect\u003c/strong\u003e: Triggers a coroutine based on state changes; ideal for async actions like data loading.\u003c/li\u003e\u003cli id=\"30a3\"\u003e\u003cstrong\u003eSideEffect\u003c/strong\u003e: Executes non-restartable code after each recomposition; useful for logging or relevant actions.\u003c/li\u003e\u003cli id=\"8d32\"\u003e\u003cstrong\u003eDisposableEffect\u003c/strong\u003e: Manages effects with setup and cleanup/disposing requirements, such as resource listeners.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"0c38\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"4038\"\u003eIn this article, you’ve explored the top nine Android developer interview questions you might encounter during the hiring process. Remember, interview questions can vary significantly based on the role, team culture, industry, and even the interviewers themselves. It’s essential to tailor your preparation to align with the specific company and position you’re applying for.\u003c/p\u003e\u003cp id=\"e70a\"\u003eAll these interview questions are covered in \u003ca href=\"https://github.com/doveletter/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDove Letter\u003c/strong\u003e\u003c/a\u003e, a private repository offering daily insights on Android and Kotlin, including topics like Compose, architecture, industry interview questions, and practical code tips. \u003cstrong\u003eIn just 15 weeks since its launch, Dove Letter has surpassed 350 individual subscribers and 8 business/lifetime subscribers\u003c/strong\u003e. If you’re eager to deepen your knowledge of Android, Kotlin, and Compose, be sure to check out ‘\u003ca href=\"https://medium.com/@skydoves/learn-kotlin-and-android-with-dove-letter-26265da11903\" rel=\"noopener\"\u003eLearn Kotlin and Android With Dove Letter\u003c/a\u003e’.\u003c/p\u003e\u003cp id=\"2753\"\u003eAs always, happy coding!\u003c/p\u003e\u003cp id=\"1afe\"\u003e— \u003ca href=\"https://github.com/skydoves\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJaewoong\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "26 min read",
  "publishedTime": "2024-11-09T01:09:50.956Z",
  "modifiedTime": null
}
