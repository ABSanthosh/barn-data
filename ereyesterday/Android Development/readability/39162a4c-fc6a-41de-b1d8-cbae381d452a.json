{
  "id": "39162a4c-fc6a-41de-b1d8-cbae381d452a",
  "title": "Implementing Passkeys in Android‚Ää‚Äî‚ÄäA Full-Stack Guide",
  "link": "https://proandroiddev.com/implementing-passkeys-in-android-a-full-stack-guide-9436744af9ab?source=rss----c72404660798---4",
  "description": "",
  "author": "Tom Colvin",
  "published": "Mon, 12 May 2025 22:52:38 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "security",
    "android-app-development",
    "android",
    "kotlin",
    "passkey"
  ],
  "byline": "Tom Colvin",
  "length": 14438,
  "excerpt": "The internet would be a much more secure place for its users if passkeys replaced passwords. They are phishing-proof, guess-proof and come with built-in two-factor authentication (2FA). They are also‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Image credit: authorThe internet would be a much more secure place for its users if passkeys replaced passwords. They are phishing-proof, guess-proof and come with built-in two-factor authentication (2FA). They are also more privacy-preserving than OAuth methods like Sign In With Google, because they don‚Äôt attach your account to a centralised identity.But they aren‚Äôt that easy for us developers to implement.The aim of this article, therefore, is to show you how to implement passkeys in your Android app all the way from back- to front-end.That back-end part is important, as that‚Äôs what I found missing in existing documentation. It‚Äôs too easy to build an Android front-end that doesn‚Äôt works against any back-end, and likewise a back-end that doesn‚Äôt work with Android.Here are the repos we‚Äôll use in this article:Android app: https://github.com/tdcolvin/PasskeyAuthDemoAndroidBack-end server (NodeJS): https://github.com/tdcolvin/PasskeyAuthDemoServerThe full-stack application we‚Äôre going to buildThis is the application we‚Äôre going to build. We‚Äôll use Android‚Äôs Jetpack Credential Manager to sign ourselves up ‚Äî that is, ‚Äúregister‚Äù a passkey ‚Äî and then sign in (‚Äúauthenticate‚Äù) with that passkey. And at each step we‚Äôll see what the server needs to respond with:But before we can build this, we need a back end to sign up to. I promised a full-stack tutorial, right? So:An Android-compatible passkey serverYou can do this the easy way, or you can give yourself full control:Easy: Use my implementation at auth.tomcolvin.co.uk which works for every part of this tutorial (but is deliberately insecure so not for production use!)Full control: Or, you can run your own server locally on your computer, which gives you the benefit of being able to tinker with the back end and see it working. To do that, install NodeJS then clone this repo: https://github.com/tdcolvin/PasskeyAuthDemoServer.Then run npm i and npm run start. More details are in the readme of that repo.Either way, you‚Äôll be talking to a NodeJS server which uses SimpleWebAuthn to do the complex cryptographic work. On top of that I‚Äôve added the relevant bits to make it compatible with Android‚Äôs needs. We‚Äôll see what those are later.Now that we‚Äôve got the server working, let‚Äôs create an Android app to talk to it.The Android app using Jetpack Credential ManagerIf you‚Äôre creating a new project for tinkering, your life will be made easier if you give it the ID com.tdcolvin.passkeyauthdemo, because then you can use the above back ends without alteration. But don‚Äôt worry if not!To add the relevant libraries, add the following lines to your app/build.gradle.kts and gradle/lib.versions.toml files:The libraries we‚Äôre adding are:Jetpack Credential Manager, which does all the complex cryptography stuff around passkeys, and manages secure storage of passkeysOkHttp, my chosen HTTP library (there are others! For tutorial purposes OkHttp is useful for its simplicity)Right, now that we‚Äôve got an Android app with the relevant libraries, let‚Äôs tell the server about it.Authorising your app: easy modeAndroid will refuse to talk to a passkey auth server which isn‚Äôt expecting it. And a passkey auth server will refuse to talk to an app it‚Äôs not expecting.If you just want to make this work with the ready-made back-end I posted above (either auth.tomcolvin.co.uk or the self-host NodeJS back-end), then:Set your app‚Äôs ID to com.tdcolvin.passkeyauthdemoSign it with this key (password aaaaaa).That gives it a recognised ID and fingerprint. And it means you can skip the next bit. But don‚Äôt use this key for production apps! (Obviously. It‚Äôs been posted online üòÇ).Otherwise, let‚Äôs go hardcore.Authorising your app: hard modeBut, if you‚Äôre integrating passkeys into your own app with an existing ID/key, then you‚Äôll need to tell the server about its ID and fingerprint.To make things difficult, the Android app has to be specified in two different places in two different ways. Which is nuts. The server needs to know about your app:In a publicly available file which the server provides (assetlinks.json)In the server‚Äôs configuration (the expected origin).Note in both places we identify the app using its SHA-256 fingerprint, which is slightly unusual in the Android world (SHA-1 being more common).The assetlinks.json fileThe publicly available file has to be served at /.well-known/assetlinks.json. In the demo project, you can find it in the public directory. Its format is as follows:Edit package_name and sha256_cert_fingerprints to match your app. Note that the SHA-256 fingerprint has colon-separators. (How to find your app‚Äôs SHA-256 fingerprint.)The expected originIn the demo project‚Äôs /src/simplewebauthn/index.ts file, we have:What‚Äôs that weird format after android:apk-key-hash:!?!It turns out it‚Äôs the raw bytes of the SHA-256 hash, converted to base64url format. You can use this utility to do that, but make sure you select Base64url as the Base64 variant:Cryptii pipeline for converting raw hex bytes to base64url (credit: author)Edit that line, then you‚Äôre good to go.OK, now that we‚Äôve got an Android app set up and its ID is authorised, let‚Äôs create a new passkey in the front end.Registering a userLooking ahead, here‚Äôs an overview of how passkeys are created. You will need to keep this process in mind because without it the code is going to look pretty strange.You create a passkey like this:Those steps are:The client asks for information necessary to create a passkey for their accountThe server responds with a small piece of JSON which contains, among other things, the user‚Äôs unique ID and some cryptographic detailsThe client creates the passkey for the user and sends it to the serverSigning up a brand new userNote that the above assumes that the user already exists on the system. That‚Äôs really important. If the user is brand new, they need to create an account first. From a UI perspective, you can make it look like it‚Äôs all happening in one, but actually you need to create an account first and assign a passkey to it after.Getting the registration optionsThe client asks the server for /generate-registration-options, which contains the information it needs to create a passkey.Note: /generate-registration-options is what I‚Äôve called it in my back-end implementation. But note that there‚Äôs no particular naming convention defined, so other back end implementations will probably call it something else. (This fact confused me during research because the back end documentation talked about different URLs than the front end documentation did.)Here‚Äôs the code to get that, using OkHttp:Those registration options look like this:// Registration Options retrieved from server{ \"challenge\": \"Fsfnx23eI0x07Dbd63QMDiqXH3WelwsVADSowKgninI\", \"rp\": { \"name\": \"Tom's secret site\", \"id\": \"auth.tomcolvin.co.uk\" }, \"user\": { \"id\": \"9M0ZKXgNSaqpYkNm9vt9ay6RYwfa8Px7WZvvmcCTLC8\", \"name\": \"tomcolvin\", \"displayName\": \"tomcolvin\" }, \"pubKeyCredParams\": [ { \"alg\": -7, \"type\": \"public-key\" }, { \"alg\": -257, \"type\": \"public-key\" } ], \"timeout\": 60000, \"attestation\": \"none\", \"excludeCredentials\": [], \"authenticatorSelection\": { \"residentKey\": \"required\", \"userVerification\": \"preferred\", \"requireResidentKey\": true }, \"extensions\": { \"credProps\": true }, \"hints\": []}This is like an ‚Äúoffer‚Äù to allow you, the client, to create a passkey. It tells you which user you can create the passkey for, when you can create it, and some security constraints. Specifically:challenge: this is like a one-time passcode to ensure that this request can‚Äôt be reused to create another passkey at a later daterp: stands for ‚ÄúRelying Party‚Äù ‚Äî identification details for the serveruser: information on the user, according to the server. Importantly this contains the user ID as generated by the servertimeout: the passkey needs to be created within this timeattestation: allows the server to request that the device creating the passkey proves it‚Äôs of a certain type or has certain features. We set this to ‚Äúnone‚Äù because that‚Äôs better for privacy (otherwise, it potentially requires users to reveal hardware details and IDs).authenticatorSelection: allows the server to specify security properties of the passkey created. Can it be used across devices? Are biometrics required?Question: can‚Äôt the client just generate this registration options JSON itself? The answer is no: for security reasons, only the server should control whether a client is allowed to create a passkey for a given account. This registrations options response is like a ‚Äúticket‚Äù allowing the client to do so. The ‚Äúbarcode‚Äù on the ticket (the bit which gets scanned to allow you in) is the challenge element.Now that we have the registration options, we have all the info we need to ask the user to create a passkey. Let‚Äôs get Jetpack Credential Manager to do that for us‚Ä¶Generating the passkeyJetpack Credential Manager takes the registration options, maybe asks the user some questions, takes their biometrics or screenlock, then builds a passkey.We never get to see the passkey itself! It gets saved to whatever password manager we want, and obviously plays a part in the login phase, but the actual private key can never be seen by human eyes. That‚Äôs why passkeys are almost completely phishing-proof.We start by creating an instance of CredentialManager. Assuming you‚Äôre using Compose:We can then feed that CredentialManager our registration options JSON, and ask it to make a passkey:And that results in the following popup:Note that this popup is actually from Google Password Manager, not Jetpack Credential Manager. If you use a different password manager (which you can, because recent Android version support third-party ones) then you‚Äôll see a different UI.Follow that UI through and a passkey gets created by your password manager. It has a private key which gets encrypted and secured using your biometrics or PIN, and a public key which we have to pass to the server. Let‚Äôs do that bit next‚Ä¶Passing the passkey back to the serverThe createCredentialResponse that we get back from credentialManager.createCredential() has a registrationResponseJson field, which we pass as-is to the server. That contains all it needs to know about the passkey we‚Äôve just created.This process is what the passkey standard calls verifying a credential. My server accepts this JSON via an HTTP POST to /verify-registration. (Again, no formally-defined URLs, so your implementation will differ).Here‚Äôs the function for doing that POST:And we use it in our sign up flow:The server creates the user‚Äôs account at that point (if necessary ‚Äî the user might already be logged into an existing account using another authentication method). And it adds the passkey to the account.Even a server break-in won‚Äôt compromise your passkeyBy the way, we‚Äôve just seen another bit of passkey cleverness. That is, the data in this response JSON isn‚Äôt sufficient for someone else to figure out your passkey and use it for themselves.Passkeys rely on public key cryptography, where you have a private and public key. The private key is needed for authentication. The public key is there to allow you to prove that you have the private key without revealing it.Only the public key gets sent to the server. So even if a bad guy broke into the server and stole all those public keys, they still couldn‚Äôt authenticate as you. They don‚Äôt have the private key, as it never left your device.Contrast this with passwords where there has to be a shared secret. The reason I can authenticate with my password ‚Äúabc123‚Äù is because the server has stored ‚Äúabc123‚Äù in some form, and compares it to my input.Public key cryptography is magic. ü™Ñüé©üêáOK, now we have an account with a passkey. How do we authenticate next time?Authenticating with a passkeyThe process starts in the same way for authentication as it did for registration:To start with, we need an ‚Äúoffer‚Äù from the server. This contains details of the credentials it‚Äôll accept, and a challenge for us to sign using one of them:The authentication options JSON looks like this:{ \"rpId\": \"auth.tomcolvin.co.uk\", \"challenge\": \"nL_rWyPqXhvnyo-6_C8V7FaJITnDg6uUa2KWAlrJpEM\", \"allowCredentials\": [ { \"id\": \"wsHlHo8rk1RjUpMZV4eLNw\", \"type\": \"public-key\", \"transports\": [ \"hybrid\", \"internal\" ] } ], \"timeout\": 60000, \"userVerification\": \"preferred\"}That challenge is all-important. In order to authenticate ourselves, we‚Äôll have to sign it (together with some other bits) with our private key. The passkey server then knows it‚Äôs us because it has our public key to verify that signature.And in order to get the private key, we have to ask the user for their biometrics and decrypt it out of the secure storage.But we don‚Äôt have to worry about the complexity of any of the above! Because Credential Manager does everything we need, in just a single credentialManager.getCredential() call:That code pops up the following screen:The credential we get out of the code above has an authenticationResponse field. This is a JSON object containing the proof of our identity, and it‚Äôs what needs to go up to the server.Once that‚Äôs all done, the server should respond that you‚Äôre authenticated correctly. And that‚Äôs all there is to it!To concludeMy aim in writing this article is just to get more apps to support passkeys. They are a win-win, being more secure than passwords, and more privacy-preserving than OAuth options. They are a little harder to implement, but I hope you‚Äôll agree now that it‚Äôs worth the effort.We‚Äôve seen how to create passkeys in both the back- and front end. To do so, I introduced my passkey server repo and cloud-based demo. And we‚Äôve seen how to use those passkeys to authenticate users.Here are the repos we used in this article:Android app: https://github.com/tdcolvin/PasskeyAuthDemoAndroidBack-end server (NodeJS): https://github.com/tdcolvin/PasskeyAuthDemoServerI hope this has been helpful! As ever please leave questions/comments below, or contact me directly.Hi, I‚Äôm Tom Colvin; I help build and grow app businesses. I‚Äôm a Google Developer Expert in Android with experience launching literally hundreds of apps. I‚Äôm available as a software architect and mobile app strategist, with specialism in Android development. Engage me either freelance or via the mobile app agency Apptaura which I co-founded. Find me on LinkedIn or Bluesky.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*58fPjBjUbwh3AEBHM5J8gw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://tdcolvin.medium.com/?source=post_page---byline--9436744af9ab---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Tom Colvin\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*vnM2uh3V90GdEN5zLwhFpQ.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp\u003e\u003cfigure\u003e\u003cpicture\u003e\u003csource srcset=\"https://miro.medium.com/v2/resize:fit:640/format:webp/1*58fPjBjUbwh3AEBHM5J8gw.png 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/1*58fPjBjUbwh3AEBHM5J8gw.png 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/1*58fPjBjUbwh3AEBHM5J8gw.png 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/1*58fPjBjUbwh3AEBHM5J8gw.png 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/1*58fPjBjUbwh3AEBHM5J8gw.png 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/1*58fPjBjUbwh3AEBHM5J8gw.png 1100w, https://miro.medium.com/v2/resize:fit:4096/format:webp/1*58fPjBjUbwh3AEBHM5J8gw.png 4096w\" sizes=\"(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 2048px\" type=\"image/webp\"/\u003e\u003csource data-testid=\"og\" srcset=\"https://miro.medium.com/v2/resize:fit:640/1*58fPjBjUbwh3AEBHM5J8gw.png 640w, https://miro.medium.com/v2/resize:fit:720/1*58fPjBjUbwh3AEBHM5J8gw.png 720w, https://miro.medium.com/v2/resize:fit:750/1*58fPjBjUbwh3AEBHM5J8gw.png 750w, https://miro.medium.com/v2/resize:fit:786/1*58fPjBjUbwh3AEBHM5J8gw.png 786w, https://miro.medium.com/v2/resize:fit:828/1*58fPjBjUbwh3AEBHM5J8gw.png 828w, https://miro.medium.com/v2/resize:fit:1100/1*58fPjBjUbwh3AEBHM5J8gw.png 1100w, https://miro.medium.com/v2/resize:fit:4096/1*58fPjBjUbwh3AEBHM5J8gw.png 4096w\" sizes=\"(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 2048px\"/\u003e\u003c/picture\u003e\u003cfigcaption\u003eImage credit: \u003ca href=\"https://www.linkedin.com/in/tdcolvin/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eauthor\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003c/p\u003e\u003cdiv\u003e\u003cp id=\"5180\"\u003eThe internet would be a much more secure place for its users if passkeys replaced passwords. They are phishing-proof, guess-proof and come with built-in two-factor authentication (2FA). They are also more privacy-preserving than OAuth methods like Sign In With Google, because they don‚Äôt attach your account to a centralised identity.\u003c/p\u003e\u003cp id=\"1d57\"\u003eBut they aren‚Äôt that easy for us developers to implement.\u003c/p\u003e\u003cp id=\"4740\"\u003e\u003cstrong\u003eThe aim of this article, therefore, is to show you how to implement passkeys in your Android app all the way from back- to front-end.\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"55a7\"\u003eThat back-end part is important, as that‚Äôs what I found missing in existing documentation. It‚Äôs too easy to build an Android front-end that doesn‚Äôt works against any back-end, and likewise a back-end that doesn‚Äôt work with Android.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"8057\"\u003eHere are the repos we‚Äôll use in this article:\u003cbr/\u003e\u003cstrong\u003eAndroid app\u003c/strong\u003e: \u003ca href=\"https://github.com/tdcolvin/PasskeyAuthDemoAndroid\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.com/tdcolvin/PasskeyAuthDemoAndroid\u003c/a\u003e\u003cbr/\u003e\u003cstrong\u003eBack-end server (NodeJS)\u003c/strong\u003e: \u003ca href=\"https://github.com/tdcolvin/PasskeyAuthDemoServer\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.com/tdcolvin/PasskeyAuthDemoServer\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"8228\"\u003eThe full-stack application we‚Äôre going to build\u003c/h2\u003e\u003cp id=\"5c6e\"\u003eThis is the application we‚Äôre going to build. We‚Äôll use Android‚Äôs Jetpack Credential Manager to sign ourselves up ‚Äî that is, ‚Äúregister‚Äù a passkey ‚Äî and then sign in (‚Äúauthenticate‚Äù) with that passkey. And at each step we‚Äôll see what the server needs to respond with:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ee7d\"\u003eBut before we can build this, we need a back end to sign up to. I promised a full-stack tutorial, right? So:\u003c/p\u003e\u003ch2 id=\"a6af\"\u003eAn Android-compatible passkey server\u003c/h2\u003e\u003cp id=\"1af5\"\u003eYou can do this the easy way, or you can give yourself full control:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1c16\"\u003e\u003cstrong\u003eEasy\u003c/strong\u003e: Use my implementation at \u003ca href=\"http://auth.tomcolvin.co.uk\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eauth.tomcolvin.co.uk\u003c/a\u003e which works for every part of this tutorial (but is \u003cstrong\u003edeliberately insecure\u003c/strong\u003e so not for production use!)\u003c/li\u003e\u003cli id=\"050d\"\u003e\u003cstrong\u003eFull control\u003c/strong\u003e: Or, you can run your own server locally on your computer, which gives you the benefit of being able to tinker with the back end and see it working. To do that, install NodeJS then clone this repo: \u003ca href=\"https://github.com/tdcolvin/PasskeyAuthDemoServer\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.com/tdcolvin/PasskeyAuthDemoServer\u003c/a\u003e.\u003cbr/\u003eThen run \u003ccode\u003enpm i\u003c/code\u003e and \u003ccode\u003enpm run start\u003c/code\u003e. More details are in the \u003ca href=\"https://github.com/tdcolvin/PasskeyAuthDemoServer/blob/master/README.md\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ereadme\u003c/a\u003e of that repo.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"655a\"\u003eEither way, you‚Äôll be talking to a NodeJS server which uses \u003ca href=\"https://simplewebauthn.dev/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSimpleWebAuthn\u003c/a\u003e to do the complex cryptographic work. On top of that I‚Äôve added the relevant bits to make it compatible with Android‚Äôs needs. We‚Äôll see what those are later.\u003c/p\u003e\u003cp id=\"e83f\"\u003eNow that we‚Äôve got the server working, let‚Äôs create an Android app to talk to it.\u003c/p\u003e\u003ch2 id=\"a7fd\"\u003eThe Android app using Jetpack Credential Manager\u003c/h2\u003e\u003cp id=\"44e5\"\u003eIf you‚Äôre creating a new project for tinkering, your life will be made easier if you give it the ID \u003cstrong\u003ecom.tdcolvin.passkeyauthdemo\u003c/strong\u003e, because then you can use the above back ends without alteration. But don‚Äôt worry if not!\u003c/p\u003e\u003cp id=\"130b\"\u003eTo add the relevant libraries, add the following lines to your app/build.gradle.kts and gradle/lib.versions.toml files:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"1082\"\u003eThe libraries we‚Äôre adding are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7d29\"\u003e\u003ca href=\"https://developer.android.com/identity/sign-in/credential-manager\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetpack Credential Manager\u003c/a\u003e, which does all the complex cryptography stuff around passkeys, and manages secure storage of passkeys\u003c/li\u003e\u003cli id=\"e7c0\"\u003e\u003ca href=\"https://square.github.io/okhttp/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eOkHttp\u003c/a\u003e, my chosen HTTP library (there are others! For tutorial purposes OkHttp is useful for its simplicity)\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"763a\"\u003eRight, now that we‚Äôve got an Android app with the relevant libraries, let‚Äôs tell the server about it.\u003c/p\u003e\u003ch2 id=\"8fd5\"\u003eAuthorising your app: easy mode\u003c/h2\u003e\u003cp id=\"b025\"\u003eAndroid will refuse to talk to a passkey auth server which isn‚Äôt expecting it. And a passkey auth server will refuse to talk to an app it‚Äôs not expecting.\u003c/p\u003e\u003cp id=\"f25d\"\u003eIf you just want to make this work with the ready-made back-end I posted above (either \u003ca href=\"http://auth.tomcolvin.co.uk\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eauth.tomcolvin.co.uk\u003c/a\u003e or the self-host NodeJS back-end), then:\u003c/p\u003e\u003col\u003e\u003cli id=\"cfd5\"\u003eSet your app‚Äôs ID to com.tdcolvin.passkeyauthdemo\u003c/li\u003e\u003cli id=\"b376\"\u003eSign it with \u003ca href=\"https://github.com/tdcolvin/PasskeyAuthDemoAndroid/raw/refs/heads/master/keystore-password-aaaaaa.jks\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethis key\u003c/a\u003e (password aaaaaa).\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"b072\"\u003eThat gives it a recognised ID and fingerprint. And it means you can skip the next bit. But \u003cstrong\u003edon‚Äôt use this key for production apps!\u003c/strong\u003e (Obviously. It‚Äôs been posted online üòÇ).\u003c/p\u003e\u003cp id=\"0618\"\u003eOtherwise, let‚Äôs go hardcore.\u003c/p\u003e\u003ch2 id=\"9fe6\"\u003eAuthorising your app: hard mode\u003c/h2\u003e\u003cp id=\"dc1d\"\u003eBut, if you‚Äôre integrating passkeys into your own app with an existing ID/key, then you‚Äôll need to tell the server about its ID and fingerprint.\u003c/p\u003e\u003cp id=\"2626\"\u003eTo make things difficult, the Android app has to be specified in two different places \u003cem\u003ein two different ways\u003c/em\u003e. Which is nuts. The server needs to know about your app:\u003c/p\u003e\u003col\u003e\u003cli id=\"8fe5\"\u003eIn a publicly available file which the server provides (\u003cstrong\u003eassetlinks.json\u003c/strong\u003e)\u003c/li\u003e\u003cli id=\"13bf\"\u003eIn the server‚Äôs configuration (the \u003cstrong\u003eexpected origin\u003c/strong\u003e).\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"9ae2\"\u003eNote in both places we identify the app using its \u003cstrong\u003eSHA-256\u003c/strong\u003e fingerprint, which is slightly unusual in the Android world (SHA-1 being more common).\u003c/p\u003e\u003ch2 id=\"5ae0\"\u003eThe assetlinks.json file\u003c/h2\u003e\u003cp id=\"13c7\"\u003eThe publicly available file has to be served at /.well-known/assetlinks.json. In the demo project, you can find it in the public directory. Its format is as follows:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d606\"\u003eEdit \u003ccode\u003epackage_name\u003c/code\u003e and \u003ccode\u003esha256_cert_fingerprints\u003c/code\u003e to match your app. Note that the SHA-256 fingerprint has colon-separators. (\u003ca href=\"https://stackoverflow.com/a/75887954/2518722\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHow to find your app‚Äôs SHA-256 fingerprint\u003c/a\u003e.)\u003c/p\u003e\u003ch2 id=\"3097\"\u003eThe expected origin\u003c/h2\u003e\u003cp id=\"0288\"\u003eIn the demo project‚Äôs /src/simplewebauthn/index.ts file, we have:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9611\"\u003eWhat‚Äôs that weird format after \u003ccode\u003eandroid:apk-key-hash:\u003c/code\u003e!?!\u003c/p\u003e\u003cp id=\"1cb9\"\u003eIt turns out it‚Äôs the raw bytes of the SHA-256 hash, converted to \u003ca href=\"https://datatracker.ietf.org/doc/html/rfc4648#section-5\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ebase64url\u003c/a\u003e format. You can use \u003ca href=\"https://cryptii.com/pipes/hex-to-base64\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethis utility\u003c/a\u003e to do that, \u003cem\u003ebut make sure you select Base64url as the Base64 variant:\u003c/em\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eCryptii pipeline for converting raw hex bytes to base64url (credit: author)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"84e3\"\u003eEdit that line, then you‚Äôre good to go.\u003c/p\u003e\u003cp id=\"a0d9\"\u003eOK, now that we‚Äôve got an Android app set up and its ID is authorised, let‚Äôs create a new passkey in the front end.\u003c/p\u003e\u003ch2 id=\"745d\"\u003eRegistering a user\u003c/h2\u003e\u003cp id=\"b173\"\u003eLooking ahead, here‚Äôs an overview of how passkeys are created. You will need to keep this process in mind because without it the code is going to look pretty strange.\u003c/p\u003e\u003cp id=\"6426\"\u003eYou create a passkey like this:\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"96fc\"\u003eThose steps are:\u003c/p\u003e\u003col\u003e\u003cli id=\"e4b0\"\u003eThe client asks for information necessary to create a passkey for their account\u003c/li\u003e\u003cli id=\"56d0\"\u003eThe server responds with a small piece of JSON which contains, among other things, the user‚Äôs unique ID and some cryptographic details\u003c/li\u003e\u003cli id=\"c2ed\"\u003eThe client creates the passkey for the user and sends it to the server\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"7ef2\"\u003eSigning up a brand new user\u003c/h2\u003e\u003cp id=\"482e\"\u003eNote that the above \u003cstrong\u003e\u003cem\u003eassumes that the user already exists on the system\u003c/em\u003e\u003c/strong\u003e. That‚Äôs really important. If the user is brand new, they need to create an account first. From a UI perspective, you can make it look like it‚Äôs all happening in one, but actually you need to create an account first and assign a passkey to it after.\u003c/p\u003e\u003ch2 id=\"846d\"\u003eGetting the registration options\u003c/h2\u003e\u003cp id=\"ad0b\"\u003eThe client asks the server for /generate-registration-options, which contains the information it needs to create a passkey.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"6c1f\"\u003eNote: /generate-registration-options is what I‚Äôve called it in my back-end implementation. But note \u003cstrong\u003ethat there‚Äôs no particular naming convention defined\u003c/strong\u003e, so other back end implementations will probably call it something else. (This fact confused me during research because the back end documentation talked about different URLs than the front end documentation did.)\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"1080\"\u003eHere‚Äôs the code to get that, using OkHttp:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"772f\"\u003eThose registration options look like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0bd2\"\u003e// Registration Options retrieved from server\u003cbr/\u003e{\u003cbr/\u003e  \u0026#34;challenge\u0026#34;: \u0026#34;Fsfnx23eI0x07Dbd63QMDiqXH3WelwsVADSowKgninI\u0026#34;,\u003cbr/\u003e  \u0026#34;rp\u0026#34;: {\u003cbr/\u003e    \u0026#34;name\u0026#34;: \u0026#34;Tom\u0026#39;s secret site\u0026#34;,\u003cbr/\u003e    \u0026#34;id\u0026#34;: \u0026#34;auth.tomcolvin.co.uk\u0026#34;\u003cbr/\u003e  },\u003cbr/\u003e  \u0026#34;user\u0026#34;: {\u003cbr/\u003e    \u0026#34;id\u0026#34;: \u0026#34;9M0ZKXgNSaqpYkNm9vt9ay6RYwfa8Px7WZvvmcCTLC8\u0026#34;,\u003cbr/\u003e    \u0026#34;name\u0026#34;: \u0026#34;tomcolvin\u0026#34;,\u003cbr/\u003e    \u0026#34;displayName\u0026#34;: \u0026#34;tomcolvin\u0026#34;\u003cbr/\u003e  },\u003cbr/\u003e  \u0026#34;pubKeyCredParams\u0026#34;: [\u003cbr/\u003e    {\u003cbr/\u003e      \u0026#34;alg\u0026#34;: -7,\u003cbr/\u003e      \u0026#34;type\u0026#34;: \u0026#34;public-key\u0026#34;\u003cbr/\u003e    },\u003cbr/\u003e    {\u003cbr/\u003e      \u0026#34;alg\u0026#34;: -257,\u003cbr/\u003e      \u0026#34;type\u0026#34;: \u0026#34;public-key\u0026#34;\u003cbr/\u003e    }\u003cbr/\u003e  ],\u003cbr/\u003e  \u0026#34;timeout\u0026#34;: 60000,\u003cbr/\u003e  \u0026#34;attestation\u0026#34;: \u0026#34;none\u0026#34;,\u003cbr/\u003e  \u0026#34;excludeCredentials\u0026#34;: [],\u003cbr/\u003e  \u0026#34;authenticatorSelection\u0026#34;: {\u003cbr/\u003e    \u0026#34;residentKey\u0026#34;: \u0026#34;required\u0026#34;,\u003cbr/\u003e    \u0026#34;userVerification\u0026#34;: \u0026#34;preferred\u0026#34;,\u003cbr/\u003e    \u0026#34;requireResidentKey\u0026#34;: true\u003cbr/\u003e  },\u003cbr/\u003e  \u0026#34;extensions\u0026#34;: {\u003cbr/\u003e    \u0026#34;credProps\u0026#34;: true\u003cbr/\u003e  },\u003cbr/\u003e  \u0026#34;hints\u0026#34;: []\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2f82\"\u003eThis is like an ‚Äúoffer‚Äù to allow you, the client, to create a passkey. It tells you which user you can create the passkey for, when you can create it, and some security constraints. Specifically:\u003c/p\u003e\u003cul\u003e\u003cli id=\"24e5\"\u003e\u003ccode\u003echallenge\u003c/code\u003e: this is like a one-time passcode to ensure that this request can‚Äôt be reused to create another passkey at a later date\u003c/li\u003e\u003cli id=\"df89\"\u003e\u003ccode\u003erp\u003c/code\u003e: stands for ‚ÄúRelying Party‚Äù ‚Äî identification details for the server\u003c/li\u003e\u003cli id=\"6d59\"\u003e\u003ccode\u003euser\u003c/code\u003e: information on the user, according to the server. Importantly this contains the user ID as generated by the server\u003c/li\u003e\u003cli id=\"06a7\"\u003e\u003ccode\u003etimeout\u003c/code\u003e: the passkey needs to be created within this time\u003c/li\u003e\u003cli id=\"ca88\"\u003e\u003ccode\u003eattestation\u003c/code\u003e: allows the server to \u003ca href=\"https://www.w3.org/TR/webauthn-3/#sctn-attestation-types\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003erequest\u003c/a\u003e that the device creating the passkey \u003cem\u003eproves\u003c/em\u003e it‚Äôs of a certain type or has certain features. We set this to ‚Äúnone‚Äù because that‚Äôs better for privacy (otherwise, it potentially requires users to reveal hardware details and IDs).\u003c/li\u003e\u003cli id=\"9219\"\u003e\u003ccode\u003eauthenticatorSelection\u003c/code\u003e: allows the server to specify security properties of the passkey created. Can it be used across devices? Are biometrics required?\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"45b5\"\u003eQuestion: can‚Äôt the client just generate this registration options JSON itself? The answer is no: for security reasons, only the server should control whether a client is allowed to create a passkey for a given account. This registrations options response is like a ‚Äúticket‚Äù allowing the client to do so. The ‚Äúbarcode‚Äù on the ticket (the bit which gets scanned to allow you in) is the \u003ccode\u003echallenge\u003c/code\u003e element.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"e06c\"\u003eNow that we have the registration options, we have all the info we need to ask the user to create a passkey. Let‚Äôs get Jetpack Credential Manager to do that for us‚Ä¶\u003c/p\u003e\u003ch2 id=\"88f0\"\u003eGenerating the passkey\u003c/h2\u003e\u003cp id=\"9b70\"\u003eJetpack Credential Manager takes the registration options, maybe asks the user some questions, takes their biometrics or screenlock, then builds a passkey.\u003c/p\u003e\u003cp id=\"6561\"\u003eWe never get to see the passkey itself! It gets saved to whatever password manager we want, and obviously plays a part in the login phase, but the actual private key can never be seen by human eyes. That‚Äôs why passkeys are almost completely phishing-proof.\u003c/p\u003e\u003cp id=\"1760\"\u003eWe start by creating an instance of CredentialManager. Assuming you‚Äôre using Compose:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b773\"\u003eWe can then feed that CredentialManager our registration options JSON, and ask it to make a passkey:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"effc\"\u003eAnd that results in the following popup:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"d5eb\"\u003eNote that this popup is actually from Google Password Manager, not Jetpack Credential Manager. If you use a different password manager (which you can, because recent Android version support third-party ones) then you‚Äôll see a different UI.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"294c\"\u003eFollow that UI through and a passkey gets created by your password manager. It has a private key which gets encrypted and secured using your biometrics or PIN, and a public key which we have to pass to the server. Let‚Äôs do that bit next‚Ä¶\u003c/p\u003e\u003ch2 id=\"f7c3\"\u003ePassing the passkey back to the server\u003c/h2\u003e\u003cp id=\"0d2f\"\u003eThe createCredentialResponse that we get back from \u003ccode\u003ecredentialManager.createCredential()\u003c/code\u003e has a registrationResponseJson field, which we pass as-is to the server. That contains all it needs to know about the passkey we‚Äôve just created.\u003c/p\u003e\u003cp id=\"28f6\"\u003eThis process is what the passkey standard calls \u003cem\u003everifying\u003c/em\u003e a credential. My server accepts this JSON via an HTTP POST to /verify-registration. (Again, no formally-defined URLs, so your implementation will differ).\u003c/p\u003e\u003cp id=\"49cd\"\u003eHere‚Äôs the function for doing that POST:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"db2c\"\u003eAnd we use it in our sign up flow:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"178a\"\u003eThe server creates the user‚Äôs account at that point (if necessary ‚Äî the user might already be logged into an existing account using another authentication method). And it adds the passkey to the account.\u003c/p\u003e\u003ch2 id=\"c7f7\"\u003e\u003cstrong\u003eEven a server break-in won‚Äôt compromise your passkey\u003c/strong\u003e\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"c80c\"\u003eBy the way, we‚Äôve just seen another bit of passkey cleverness. That is, the data in this response JSON isn‚Äôt sufficient for someone else to figure out your passkey and use it for themselves.\u003c/p\u003e\u003cp id=\"b0f5\"\u003ePasskeys rely on public key cryptography, where you have a private and public key. The private key is needed for authentication. The public key is there to allow you to prove that you have the private key without revealing it.\u003c/p\u003e\u003cp id=\"2533\"\u003eOnly the public key gets sent to the server. So even if a bad guy broke into the server and stole all those public keys, they still couldn‚Äôt authenticate as you. They don‚Äôt have the private key, as it never left your device.\u003c/p\u003e\u003cp id=\"6eb8\"\u003eContrast this with pass\u003cstrong\u003ewords\u003c/strong\u003e where there has to be a shared secret. The reason I can authenticate with my password ‚Äúabc123‚Äù is because the server has stored ‚Äúabc123‚Äù in some form, and compares it to my input.\u003c/p\u003e\u003cp id=\"ed02\"\u003ePublic key cryptography is magic. \u003cem\u003eü™Ñüé©üêá\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"c287\"\u003eOK, now we have an account with a passkey. How do we authenticate next time?\u003c/p\u003e\u003ch2 id=\"b123\"\u003eAuthenticating with a passkey\u003c/h2\u003e\u003cp id=\"76dc\"\u003eThe process starts in the same way for authentication as it did for registration:\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"5af0\"\u003eTo start with, we need an ‚Äúoffer‚Äù from the server. This contains details of the credentials it‚Äôll accept, and a challenge for us to sign using one of them:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c8d0\"\u003eThe authentication options JSON looks like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6705\"\u003e{\u003cbr/\u003e  \u0026#34;rpId\u0026#34;: \u0026#34;auth.tomcolvin.co.uk\u0026#34;,\u003cbr/\u003e  \u0026#34;challenge\u0026#34;: \u0026#34;nL_rWyPqXhvnyo-6_C8V7FaJITnDg6uUa2KWAlrJpEM\u0026#34;,\u003cbr/\u003e  \u0026#34;allowCredentials\u0026#34;: [\u003cbr/\u003e    {\u003cbr/\u003e      \u0026#34;id\u0026#34;: \u0026#34;wsHlHo8rk1RjUpMZV4eLNw\u0026#34;,\u003cbr/\u003e      \u0026#34;type\u0026#34;: \u0026#34;public-key\u0026#34;,\u003cbr/\u003e      \u0026#34;transports\u0026#34;: [\u003cbr/\u003e        \u0026#34;hybrid\u0026#34;,\u003cbr/\u003e        \u0026#34;internal\u0026#34;\u003cbr/\u003e      ]\u003cbr/\u003e    }\u003cbr/\u003e  ],\u003cbr/\u003e  \u0026#34;timeout\u0026#34;: 60000,\u003cbr/\u003e  \u0026#34;userVerification\u0026#34;: \u0026#34;preferred\u0026#34;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7204\"\u003eThat \u003ccode\u003echallenge\u003c/code\u003e is all-important. In order to authenticate ourselves, we‚Äôll have to sign it (together with some other bits) with our private key. The passkey server then knows it‚Äôs us because it has our public key to verify that signature.\u003c/p\u003e\u003cp id=\"d15f\"\u003eAnd in order to get the private key, we have to ask the user for their biometrics and decrypt it out of the secure storage.\u003c/p\u003e\u003cp id=\"2a27\"\u003eBut we don‚Äôt have to worry about the complexity of any of the above! Because Credential Manager does everything we need, in just a single \u003ccode\u003ecredentialManager.getCredential()\u003c/code\u003e call:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7e92\"\u003eThat code pops up the following screen:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"333c\"\u003eThe \u003ccode\u003ecredential\u003c/code\u003e we get out of the code above has an \u003ccode\u003eauthenticationResponse\u003c/code\u003e field. This is a JSON object containing the proof of our identity, and it‚Äôs what needs to go up to the server.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9fdf\"\u003eOnce that‚Äôs all done, the server should respond that you‚Äôre authenticated correctly. And that‚Äôs all there is to it!\u003c/p\u003e\u003ch2 id=\"8896\"\u003eTo conclude\u003c/h2\u003e\u003cp id=\"820e\"\u003eMy aim in writing this article is just to get more apps to support passkeys. They are a win-win, being more secure than passwords, and more privacy-preserving than OAuth options. They are a little harder to implement, but I hope you‚Äôll agree now that it‚Äôs worth the effort.\u003c/p\u003e\u003cp id=\"0b18\"\u003eWe‚Äôve seen how to create passkeys in both the back- and front end. To do so, I introduced my \u003ca href=\"https://github.com/tdcolvin/PasskeyAuthDemoServer\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003epasskey server repo\u003c/a\u003e and \u003ca href=\"http://auth.tomcolvin.co.uk\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecloud-based demo\u003c/a\u003e. And we‚Äôve seen how to use those passkeys to authenticate users.\u003c/p\u003e\u003cp id=\"5a98\"\u003eHere are the repos we used in this article:\u003cbr/\u003e\u003cstrong\u003eAndroid app\u003c/strong\u003e: \u003ca href=\"https://github.com/tdcolvin/PasskeyAuthDemoAndroid\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.com/tdcolvin/PasskeyAuthDemoAndroid\u003c/a\u003e\u003cbr/\u003e\u003cstrong\u003eBack-end server (NodeJS)\u003c/strong\u003e: \u003ca href=\"https://github.com/tdcolvin/PasskeyAuthDemoServer\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.com/tdcolvin/PasskeyAuthDemoServer\u003c/a\u003e\u003c/p\u003e\u003cp id=\"38f5\"\u003eI hope this has been helpful! As ever please leave questions/comments below, or contact me directly.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"90d1\"\u003e\u003cem\u003eHi, I‚Äôm Tom Colvin; I help build and grow app businesses. I‚Äôm a Google Developer Expert in Android with experience launching literally hundreds of apps. I‚Äôm available as a software architect and mobile app strategist, with specialism in Android development. Engage me either \u003c/em\u003e\u003ca href=\"http://tomcolvin.co.uk/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003efreelance\u003c/em\u003e\u003c/a\u003e\u003cem\u003e or via the mobile app agency \u003c/em\u003e\u003ca href=\"http://apptaura.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eApptaura\u003c/em\u003e\u003c/a\u003e\u003cem\u003e which I co-founded. Find me on \u003c/em\u003e\u003ca href=\"https://www.linkedin.com/in/tdcolvin/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eLinkedIn\u003c/em\u003e\u003c/a\u003e\u003cem\u003e or \u003c/em\u003e\u003ca href=\"https://bsky.app/profile/tomcolvin.co.uk\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eBluesky\u003c/em\u003e\u003c/a\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2025-05-12T22:52:37.991Z",
  "modifiedTime": null
}
