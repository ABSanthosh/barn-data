{
  "id": "4c8d56be-4d00-4ffe-a949-7c5f81d69683",
  "title": "Comparing SupervisorScope with viewModelScope: Understanding Their Use Cases and Differences in…",
  "link": "https://proandroiddev.com/comparing-supervisorscope-with-viewmodelscope-understanding-their-use-cases-and-differences-in-ae2726a095bc?source=rss----c72404660798---4",
  "description": "",
  "author": "Leo N",
  "published": "Sat, 09 Nov 2024 00:47:12 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "kotlin",
    "coroutine",
    "android-app-development",
    "androiddev"
  ],
  "byline": "Leo N",
  "length": 9432,
  "excerpt": "When working with Kotlin coroutines in Android development, managing asynchronous tasks effectively is essential. Two coroutine scopes that Android developers frequently encounter are SupervisorScope…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Photo by Simon Berger on UnsplashWhen working with Kotlin coroutines in Android development, managing asynchronous tasks effectively is essential. Two coroutine scopes that Android developers frequently encounter are SupervisorScope and viewModelScope. While both help manage coroutines, their behavior and use cases differ significantly. In this blog post, we'll explore these differences, focusing on how they handle exceptions, manage child coroutines, and why choosing the right scope for each task is crucial for building efficient, error-resilient applications.Purpose and Use CasesSupervisorScopeSupervisorScope is designed for managing independent coroutines that should not affect each other if one of them fails. This scope is useful in scenarios where you want to run multiple concurrent tasks but don’t want the failure of one tasks to cancel all others. For instance, if your application needs to make multiple network requests to different APIs, and a failure in one request should not affect the others, SupervisorScope is the right choice.supervisorScope { launch { // Task 1: e.g., fetching user data } launch { // Task 2: e.g., fetching posts throw Exception(\"This will only cancel Task 2\") } // Task 1 will continue even if Task 2 fails}A common use of SupervisorScope is when managing concurrent operations that are loosely related, such as performing different network or data-fetching operations in parallel without each task being dependent on the success of the others.viewModelScopeviewModelScope on the other hand, is a lifecycle-aware scope tied to the lifecycle of the viewModel . When the viewModel is cleared (for example, when the UI is destroyed), all coroutines in viewModelScope are automatically canceled. THis scope is ideal for UI-bound operations, where tasks need to stop when the user navigates away from the screen.viewModelScope.launch { // Fetch data for the UI}if your UI is dependent on data-fetching or complex calculations, using viewModelScope ensures tat these tasks are automatically stopped when no longer needed, helping conserve resources and prevent memory leaks.Cancellation behaviorSupervisorScopeWithin a SupervisorScope , if one child coroutine throws an exception, it does not cancel the other sibling coroutines. This is different from a regular coroutine scope, where a failure in one child would cancel all siblings. This behavior is useful for operations that should remain unaffected by the failure of other tasks.However, if the SupervisorScope itself is canceled, all child coroutines are canceled regardless of individual status. Because all sibling coroutines are independent of each other. If one coroutine fails, the failure does not propagate to its siblings.It is specicically designed to avoid tis default failure propagation behavior, which is why it’s often used for tasks that should run independently, even if one of them encounters an error.viewModelScopeIn viewModelScope, cancellation is tied to the viewModel lifecycle. If the viewModel is cleared (e.g., when the user navigates away from a sceen), all coroutines in this scope are canceled automatically. This ensures that ongoing work does not continue if the related UI is no longer present.viewModelScope does not inherently prevent sibling coroutine cancellation like SupervisorScope . If a coroutine faileds within viewModelScope , it will typically propagate the failure inless managed explicitly.viewModelScope is created with a default job hierarchy, meaning it’s similar to a structured scope in that it automatically cancels all coroutines if a failure occurs in any sibling coroutine.ImplementationSupervisorScopeSupervisorScope is created using the supervisorScope function in Kotlin. It does not belong to any lifecycle component by default, so it’s often used inside custom coroutine builders or with lifecycle observers.supervisorScope { // launch multiple independent child coroutines here}viewModelScopeviewModelScope is automatically available within any viewModel that imports the lifecycle-viewmodel-ktx library. You simply call viewModelScope.launch to start a coroutine in this scope.viewModelScope.launch { // perform ViewModel-related tasks here}When working with viewModelScope , if you need to prevent one coroutine’s failure from canceling others, you would need to handle errors explicitly. This can be done by using try-catch blocks within each coroutine or by using CoroutineExceptionHandler to manage failures gracefully.Without explicit handling, a coroutine failure within viewModelScope will typically cancel all ongoing sibling coroutines due to its structured concurrency model, which is different from the failure-isolated behavior of SupervisorScope.// Using viewModelScopeviewModelScope.launch { launch { // Task 1 } launch { // Task 2 throw Exception(\"Task 2 failed\") // This will cancel Task 1 as well }}// Using SupervisorScopeviewModelScope.launch { supervisorScope { launch { // Task 1 } launch { // Task 2 throw Exception(\"Task 2 failed\") // Task 1 will continue running } }}Best Use CasesSupervisorScopeYou need independent coroutines that should not affect each other on failure.Tasks are loosely coupled and can run concurrently without being tightly tied to a lifecycle, like parallel data fetching in a repository.viewModelScopeYou need lifecycle-aware coroutines for UI-related tasks.Tasks are associated with a particular UI screen and should stop when the UI is no longer visible.UncaughtExceptionHandlerLet’s talk aboutUncaughtExceptionHandler , yesUncaughtExceptionHandler is relevant to how coroutine exceptions are handled, especially in coroutine scopes like viewModelScope or SupervisorScope. Here’s how it ties in:UncaughtExceptionHandler BasicsIn Java and Kotlin, UncaughtExceptionHandler is a handler that catches unhandled exceptions in threads. In coroutines, unhandled exceptions are managed differently depending on the coroutine’s context, scope, and parent-child relationships.Uncaught Exceptions in viewModelScopeviewModelScope uses structured concurrency, where all coroutines in the scope are linked to the ViewModel. If an exception is thrown in one coroutine and it’s uncaught (not managed by a try-catch), the exception will propagate to the scope’s parent, which is viewModelScope itself. This means all sibling coroutines will be canceled by default, unless the exception is handled explicitly within each coroutine.If an exception is not caught, it bubbles up to the default CoroutineExceptionHandler. However, since viewModelScope is lifecycle-aware, uncaught exceptions lead to a cleanup of the scope by canceling all coroutines, which makes an explicit CoroutineExceptionHandler particularly useful if you want to handle failures without propagating cancellation.SupervisorScope and Exception HandlingSupervisorScope allows coroutines to run independently. If one coroutine within SupervisorScope throws an uncaught exception, it doesn’t automatically cancel its siblings. This behavior is controlled by SupervisorJob, which essentially overrides the usual behavior of cascading cancellation within a structured concurrency model.With SupervisorScope, if you add an UncaughtExceptionHandler (through CoroutineExceptionHandler), you can manage exceptions without affecting other sibling coroutines, making it useful for tasks where partial failures are expected.Using CoroutineExceptionHandler with viewModelScope and SupervisorScopeCoroutineExceptionHandler can be attached to individual coroutines in both viewModelScope and SupervisorScope to manage uncaught exceptions gracefully. For example, you can log errors or perform specific actions when a coroutine fails without canceling the entire scope.val exceptionHandler = CoroutineExceptionHandler { _, throwable -\u003e Log.e(\"Error\", \"Caught exception: ${throwable.message}\")}viewModelScope.launch(exceptionHandler) { // Coroutine with exception handler throw Exception(\"Test exception\")}In this case, if an exception is thrown, it will be caught by the exceptionHandler rather than propagating up and canceling other coroutines in viewModelScope.In summary, SupervisorScope provides independent failure handling, making it useful for concurrent operations where failure in one shouldn’t impact others. viewModelScope, on the other hand, is ideal for managing coroutines tied to the lifecycle of a ViewModel, especially for tasks related to UI that need to stop when the screen is no longer in use.UncaughtExceptionHandler (via CoroutineExceptionHandler) plays a crucial role in managing unhandled exceptions in coroutines. In viewModelScope, unhandled exceptions typically cancel the entire scope, but by adding a CoroutineExceptionHandler, you can manage errors without canceling all coroutines. In SupervisorScope, this isolation is even more direct, as sibling coroutines are designed not to affect each other’s execution upon failure.ReferencesHere are some insightful articles that explore the differences between SupervisorScope and viewModelScope, particularly in terms of exception handling, structured concurrency, and testing:https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.htmlhttps://developer.android.com/topic/libraries/architecture/coroutines",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*BYCXwJSzmyv9jLsN",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://nphausg.medium.com/?source=post_page---byline--ae2726a095bc--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Leo N\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*Tb0dILXcghQeKPocCvlv6g.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--ae2726a095bc--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@8moments?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSimon Berger\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"b6c8\"\u003eWhen working with Kotlin coroutines in Android development, managing asynchronous tasks effectively is essential. Two coroutine scopes that Android developers frequently encounter are \u003ccode\u003eSupervisorScope\u003c/code\u003e and \u003ccode\u003eviewModelScope\u003c/code\u003e. While both help manage coroutines, their behavior and use cases differ significantly. In this blog post, we\u0026#39;ll explore these differences, focusing on how they handle exceptions, manage child coroutines, and why choosing the right scope for each task is crucial for building efficient, error-resilient applications.\u003c/p\u003e\u003ch2 id=\"634b\"\u003ePurpose and Use Cases\u003c/h2\u003e\u003ch2 id=\"316e\"\u003eSupervisorScope\u003c/h2\u003e\u003cul\u003e\u003cli id=\"089b\"\u003e\u003ccode\u003eSupervisorScope\u003c/code\u003e is designed for managing independent coroutines that should not affect each other if one of them fails. This scope is useful in scenarios where you want to run multiple concurrent tasks but don’t want the failure of one tasks to cancel all others. For instance, if your application needs to make multiple network requests to different APIs, and a failure in one request should not affect the others, \u003ccode\u003eSupervisorScope\u003c/code\u003e is the right choice.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"949e\"\u003esupervisorScope {\u003cbr/\u003e    launch {\u003cbr/\u003e        // Task 1: e.g., fetching user data\u003cbr/\u003e    }\u003cbr/\u003e    launch {\u003cbr/\u003e        // Task 2: e.g., fetching posts\u003cbr/\u003e        throw Exception(\u0026#34;This will only cancel Task 2\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    // Task 1 will continue even if Task 2 fails\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"5899\"\u003eA common use of \u003ccode\u003eSupervisorScope\u003c/code\u003e is when managing concurrent operations that are loosely related, such as performing different network or data-fetching operations in parallel without each task being dependent on the success of the others.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"8fc1\"\u003eviewModelScope\u003c/h2\u003e\u003cul\u003e\u003cli id=\"a887\"\u003e\u003ccode\u003eviewModelScope\u003c/code\u003e on the other hand, is a lifecycle-aware scope tied to the lifecycle of the \u003ccode\u003eviewModel\u003c/code\u003e . When the \u003ccode\u003eviewModel\u003c/code\u003e is cleared (for example, when the UI is destroyed), all coroutines in \u003ccode\u003eviewModelScope\u003c/code\u003e are automatically canceled. THis scope is ideal for UI-bound operations, where tasks need to stop when the user navigates away from the screen.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"2f97\"\u003eviewModelScope.launch {\u003cbr/\u003e    // Fetch data for the UI\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"c1c6\"\u003eif your UI is dependent on data-fetching or complex calculations, using \u003ccode\u003eviewModelScope\u003c/code\u003e ensures tat these tasks are automatically stopped when no longer needed, helping conserve resources and prevent memory leaks.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"42a1\"\u003eCancellation behavior\u003c/h2\u003e\u003cp id=\"5d41\"\u003e\u003ccode\u003eSupervisorScope\u003c/code\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"522e\"\u003eWithin a \u003ccode\u003eSupervisorScope\u003c/code\u003e , if one child coroutine throws an exception, it does not cancel the other sibling coroutines. This is different from a regular coroutine scope, where a failure in one child would cancel all siblings. This behavior is useful for operations that should remain unaffected by the failure of other tasks.\u003c/li\u003e\u003cli id=\"b923\"\u003eHowever, if the \u003ccode\u003eSupervisorScope\u003c/code\u003e itself is canceled, all child coroutines are canceled regardless of individual status. Because all sibling coroutines are independent of each other. If one coroutine fails, the failure does not propagate to its siblings.\u003c/li\u003e\u003cli id=\"4187\"\u003eIt is specicically designed to avoid tis default failure propagation behavior, which is why it’s often used for tasks that should run independently, even if one of them encounters an error.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"bbe1\"\u003e\u003ccode\u003eviewModelScope\u003c/code\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"a485\"\u003eIn \u003ccode\u003eviewModelScope\u003c/code\u003e, cancellation is tied to the \u003ccode\u003eviewModel\u003c/code\u003e lifecycle. If the \u003ccode\u003eviewModel\u003c/code\u003e is cleared (e.g., when the user navigates away from a sceen), all coroutines in this scope are canceled automatically. This ensures that ongoing work does not continue if the related UI is no longer present.\u003c/li\u003e\u003cli id=\"39ae\"\u003e\u003ccode\u003eviewModelScope\u003c/code\u003e does not inherently prevent sibling coroutine cancellation like \u003ccode\u003eSupervisorScope\u003c/code\u003e . If a coroutine faileds within \u003ccode\u003eviewModelScope\u003c/code\u003e , it will typically propagate the failure inless managed explicitly.\u003c/li\u003e\u003cli id=\"795d\"\u003e\u003ccode\u003eviewModelScope\u003c/code\u003e is created with a default job hierarchy, meaning it’s similar to a structured scope in that it automatically cancels all coroutines if a failure occurs in any sibling coroutine.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f9c3\"\u003eImplementation\u003c/h2\u003e\u003cp id=\"4885\"\u003e\u003ccode\u003eSupervisorScope\u003c/code\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"7bb9\"\u003e\u003ccode\u003eSupervisorScope\u003c/code\u003e is created using the \u003ccode\u003esupervisorScope\u003c/code\u003e function in Kotlin. It does not belong to any lifecycle component by default, so it’s often used inside custom coroutine builders or with lifecycle observers.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"460d\"\u003esupervisorScope {\u003cbr/\u003e    // launch multiple independent child coroutines here\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a38e\"\u003e\u003ccode\u003eviewModelScope\u003c/code\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"432c\"\u003e\u003ccode\u003eviewModelScope\u003c/code\u003e is automatically available within any \u003ccode\u003eviewModel\u003c/code\u003e that imports the \u003ccode\u003elifecycle-viewmodel-ktx\u003c/code\u003e library. You simply call \u003ccode\u003eviewModelScope.launch\u003c/code\u003e to start a coroutine in this scope.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"3a4e\"\u003eviewModelScope.launch {\u003cbr/\u003e    // perform ViewModel-related tasks here\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"57e1\"\u003eWhen working with \u003ccode\u003eviewModelScope\u003c/code\u003e , if you need to prevent one coroutine’s failure from canceling others, you would need to handle errors explicitly. This can be done by using \u003ccode\u003etry-catch\u003c/code\u003e blocks within each coroutine or by using \u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e to manage failures gracefully.\u003c/li\u003e\u003cli id=\"9391\"\u003eWithout explicit handling, a coroutine failure within \u003ccode\u003eviewModelScope\u003c/code\u003e will typically cancel all ongoing sibling coroutines due to its structured concurrency model, which is different from the failure-isolated behavior of \u003ccode\u003eSupervisorScope\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"4ca8\"\u003e// Using viewModelScope\u003cbr/\u003eviewModelScope.launch {\u003cbr/\u003e    launch {\u003cbr/\u003e        // Task 1\u003cbr/\u003e    }\u003cbr/\u003e    launch {\u003cbr/\u003e        // Task 2\u003cbr/\u003e        throw Exception(\u0026#34;Task 2 failed\u0026#34;) // This will cancel Task 1 as well\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e// Using SupervisorScope\u003cbr/\u003eviewModelScope.launch {\u003cbr/\u003e    supervisorScope {\u003cbr/\u003e        launch {\u003cbr/\u003e            // Task 1\u003cbr/\u003e        }\u003cbr/\u003e        launch {\u003cbr/\u003e            // Task 2\u003cbr/\u003e            throw Exception(\u0026#34;Task 2 failed\u0026#34;) // Task 1 will continue running\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"701d\"\u003eBest Use Cases\u003c/h2\u003e\u003cp id=\"1014\"\u003e\u003ccode\u003eSupervisorScope\u003c/code\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"ace7\"\u003eYou need independent coroutines that should not affect each other on failure.\u003c/li\u003e\u003cli id=\"a640\"\u003eTasks are loosely coupled and can run concurrently without being tightly tied to a lifecycle, like parallel data fetching in a repository.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"783b\"\u003e\u003ccode\u003eviewModelScope\u003c/code\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"14db\"\u003eYou need lifecycle-aware coroutines for UI-related tasks.\u003c/li\u003e\u003cli id=\"3c0a\"\u003eTasks are associated with a particular UI screen and should stop when the UI is no longer visible.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"6700\"\u003eUncaughtExceptionHandler\u003c/h2\u003e\u003cp id=\"4bf4\"\u003eLet’s talk about\u003ccode\u003eUncaughtExceptionHandler\u003c/code\u003e , yes\u003ccode\u003eUncaughtExceptionHandler\u003c/code\u003e is relevant to how coroutine exceptions are handled, especially in coroutine scopes like \u003ccode\u003eviewModelScope\u003c/code\u003e or \u003ccode\u003eSupervisorScope\u003c/code\u003e. Here’s how it ties in:\u003c/p\u003e\u003ch2 id=\"a056\"\u003e\u003cstrong\u003eUncaughtExceptionHandler Basics\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"9de5\"\u003eIn Java and Kotlin, \u003ccode\u003eUncaughtExceptionHandler\u003c/code\u003e is a handler that catches unhandled exceptions in threads. In coroutines, unhandled exceptions are managed differently depending on the coroutine’s context, scope, and parent-child relationships.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"d9a6\"\u003e\u003cstrong\u003eUncaught Exceptions in \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eviewModelScope\u003c/strong\u003e\u003c/code\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"6a04\"\u003e\u003ccode\u003eviewModelScope\u003c/code\u003e uses structured concurrency, where all coroutines in the scope are linked to the \u003ccode\u003eViewModel\u003c/code\u003e. If an exception is thrown in one coroutine and it’s uncaught (not managed by a \u003ccode\u003etry-catch\u003c/code\u003e), the exception will propagate to the scope’s parent, which is \u003ccode\u003eviewModelScope\u003c/code\u003e itself. This means all sibling coroutines will be canceled by default, unless the exception is handled explicitly within each coroutine.\u003c/li\u003e\u003cli id=\"af8d\"\u003eIf an exception is not caught, it bubbles up to the default \u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e. However, since \u003ccode\u003eviewModelScope\u003c/code\u003e is lifecycle-aware, uncaught exceptions lead to a cleanup of the scope by canceling all coroutines, which makes an explicit \u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e particularly useful if you want to handle failures without propagating cancellation.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"6efe\"\u003e\u003cstrong\u003eSupervisorScope and Exception Handling\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"7db5\"\u003e\u003ccode\u003eSupervisorScope\u003c/code\u003e allows coroutines to run independently. If one coroutine within \u003ccode\u003eSupervisorScope\u003c/code\u003e throws an uncaught exception, it doesn’t automatically cancel its siblings. This behavior is controlled by \u003ccode\u003eSupervisorJob\u003c/code\u003e, which essentially overrides the usual behavior of cascading cancellation within a structured concurrency model.\u003c/li\u003e\u003cli id=\"29bc\"\u003eWith \u003ccode\u003eSupervisorScope\u003c/code\u003e, if you add an \u003ccode\u003eUncaughtExceptionHandler\u003c/code\u003e (through \u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e), you can manage exceptions without affecting other sibling coroutines, making it useful for tasks where partial failures are expected.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"2bb5\"\u003e\u003cstrong\u003eUsing CoroutineExceptionHandler with viewModelScope and SupervisorScope\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"d8c0\"\u003e\u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e can be attached to individual coroutines in both \u003ccode\u003eviewModelScope\u003c/code\u003e and \u003ccode\u003eSupervisorScope\u003c/code\u003e to manage uncaught exceptions gracefully. For example, you can log errors or perform specific actions when a coroutine fails without canceling the entire scope.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"e007\"\u003eval exceptionHandler = CoroutineExceptionHandler { _, throwable -\u0026gt;\u003cbr/\u003e    Log.e(\u0026#34;Error\u0026#34;, \u0026#34;Caught exception: ${throwable.message}\u0026#34;)\u003cbr/\u003e}\u003cp\u003eviewModelScope.launch(exceptionHandler) {\u003cbr/\u003e    // Coroutine with exception handler\u003cbr/\u003e    throw Exception(\u0026#34;Test exception\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"76fa\"\u003eIn this case, if an exception is thrown, it will be caught by the \u003ccode\u003eexceptionHandler\u003c/code\u003e rather than propagating up and canceling other coroutines in \u003ccode\u003eviewModelScope\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"6a47\"\u003eIn summary, \u003ccode\u003eSupervisorScope\u003c/code\u003e provides independent failure handling, making it useful for concurrent operations where failure in one shouldn’t impact others. \u003ccode\u003eviewModelScope\u003c/code\u003e, on the other hand, is ideal for managing coroutines tied to the lifecycle of a \u003ccode\u003eViewModel\u003c/code\u003e, especially for tasks related to UI that need to stop when the screen is no longer in use.\u003c/p\u003e\u003cp id=\"c603\"\u003e\u003ccode\u003eUncaughtExceptionHandler\u003c/code\u003e (via \u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e) plays a crucial role in managing unhandled exceptions in coroutines. In \u003ccode\u003eviewModelScope\u003c/code\u003e, unhandled exceptions typically cancel the entire scope, but by adding a \u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e, you can manage errors without canceling all coroutines. In \u003ccode\u003eSupervisorScope\u003c/code\u003e, this isolation is even more direct, as sibling coroutines are designed not to affect each other’s execution upon failure.\u003c/p\u003e\u003ch2 id=\"24a8\"\u003eReferences\u003c/h2\u003e\u003cp id=\"28b8\"\u003eHere are some insightful articles that explore the differences between \u003ccode\u003eSupervisorScope\u003c/code\u003e and \u003ccode\u003eviewModelScope\u003c/code\u003e, particularly in terms of exception handling, structured concurrency, and testing:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3f0c\"\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html\u003c/a\u003e\u003c/li\u003e\u003cli id=\"5fd5\"\u003e\u003ca href=\"https://developer.android.com/topic/libraries/architecture/coroutines\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/topic/libraries/architecture/coroutines\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2024-11-09T00:47:11.94Z",
  "modifiedTime": null
}
