{
  "id": "101244da-1e31-4a27-a277-887625b72327",
  "title": "Exploring Jetpack Compose for Widgets with Glance",
  "link": "https://joebirch.co/android/exploring-jetpack-compose-for-widgets-with-glance/",
  "description": "Widgets on Android devices provide users with a way to access core pieces of information and functionality directly from the home screen of their device. As we continue to look for ways to improve our users experiences with our product and surface important information to them from outside of the app, widgets have been a... Continue reading →",
  "author": "hitherejoe",
  "published": "Sat, 17 May 2025 09:38:20 +0000",
  "source": "https://joebirch.co/feed",
  "categories": [
    "Android",
    "Jetpack Compose",
    "Android App Development",
    "Android Apps",
    "Android Development",
    "AndroidDev",
    "App Development",
    "jetpack compose",
    "jetpackcompose",
    "Mobile App Development"
  ],
  "byline": "by hitherejoe",
  "length": 13642,
  "excerpt": "Widgets on Android devices provide users with a way to access core pieces of information and functionality directly from the home screen of their device. As we continue to look for ways to improve our users experiences with our product and surface important information to them from outside of the app, widgets have been a great way for us to achieve this. With the availability of Jetpack Glance, we’re now able to create widgets using Composables – and if you’ve had to create widgets using RemoteViews, then you know how much easier this is going to be!",
  "siteName": "",
  "favicon": "",
  "text": "Widgets on Android devices provide users with a way to access core pieces of information and functionality directly from the home screen of their device. As we continue to look for ways to improve our users experiences with our product and surface important information to them from outside of the app, widgets have been a great way for us to achieve this. With the availability of Jetpack Glance, we’re now able to create widgets using Composables – and if you’ve had to create widgets using RemoteViews, then you know how much easier this is going to be! I recently worked on a new Widget for the Buffer Android app for a new feature we launched. Our streaks feature tracks the weekly posting streak for your account, helping you to keep track of how consistently you post on your social channels. As part of this feature, we felt that a widget would help to raise awareness of your streak directly from your device home screen. The streak itself is quite simple, which provides a great opportunity to share how to build widgets with Glance, without getting caught up too much in the UI details of Compose. Things are a little different from how we might usually work with Compose and in this blog post I want to share those details with you. Widget Hierarchy Before we get started with building a widget, it’s important to understand the hierarchy that makes up the widget. We won’t dive into the architecture of things under the hood, but it’s helpful to look at this at a higher level to better understand what we are building. When it comes to widgets with Glance, we have 4 main components that we need to think about: App Manifest – we use the manifest file to declare our widget and the configuration for it GlanceAppWidgetReceiver – this is the receiver which provides the instance of our GlanceAppWidget, along with receive any updates to refresh the contents of our widget GlanceAppWidget – this is the class that provides the composition of our widget Glance UI – this is the composable that is used to compose the UI for our widget As we work through this post, we’ll see how we need to work with these different components to construct and provide our Glance widget. Adding Dependencies Before we can get started, we need to add some dependencies to our project. For Glance there are a collection of dependencies available, and what you add for your project will depend on your needs. You’ll at least need to add the glance-appwidget and one of the material dependencies, with the preview dependencies being recommended as they’ll be helpful for creating previews of your widgets for viewing within the IDE. dependencies { implementation \"androidx.glance:glance-appwidget:1.1.1\" implementation \"androidx.glance:glance-material3:1.1.1\" implementation \"androidx.glance:glance-material:1.1.1\" implementation \"androidx.glance:glance-preview:1.1.1\" imlementation \"androidx.glance:glance-appwidget-preview:1.1.1\" } Creating the Widget Now that we have our dependencies in place, we’re ready to start building our widget. To create a widget that can be added to a users device, we need to provide an instance of the GlanceAppWidget class that will be used to compose the Glance widget. class StreaksWidget : GlanceAppWidget() { } With this class now in place we’re going to need to override the provideGlance function, this is what is going to be used to compose the widget UI. Within this function we’ll utilise the provideContent function which is where we will need to provide the composition for our UI – you can think of this as the setContent function that we use for composing UI inside of an activity class. override suspend fun provideGlance(context: Context, id: GlanceId) { provideContent { } } Inside of this block we’re now going to compose the UI for our widget, for which we’ll start by using the GlanceTheme function. This is similar to the MaterialTheme wrapper that we use in Jetpack Compose, but specifically built for Glance. We’re not going to be doing any customization here, but you can read more about this functionality if you need to override the default theme. provideContent { GlanceTheme { } } At this point, we’re now ready to compose the UI for our widget. As we previously saw, we’re creating a pretty simply UI for our widget – consisting of an image with some text. When it comes to composing this UI, we’re not going to dive into the specifics of building UI with compose as I want to focus on Glance itself, so we’ll be skipping over some details of the UI to simplify things here. For the main body of our widget UI, we’re going to see something like the following: import androidx.glance.layout.Column import androidx.glance.layout.Spacer import androidx.glance.layout.height @Composable fun Streak( modifier: GlanceModifier = GlanceModifier, content: WeeklyPostingStreak ) { Column(...) { Image(...) Spacer(modifier = GlanceModifier.height(12.dp)) Text(...) } } This is quite simply and is likely something similar to what you’ve build previously with Jetpack Compose. The main difference here is that the composables we are using are from the androidx.glance package and not the standard foundation package that we access for composables. This is because Glance widgets are restricted to the limitations of AppWidgets and RemoteViews, so we see a reduced set of composables available for building widgets with Glance. For example when it comes to layouts, we can use the Scaffold, Box, Row and Column composables and we still have composables such as the Image, Text and Spacer. However, when it comes to using this you may noticed reduce functionality, such as specific modifiers that you are used to using. For simpler widget UIs you should be fine in most cases, but there may be a few situations where you have to think slightly differently. You can read more here about what components are available. With our Streak widget in place, we’re not going to create a StreakWidgetContnet composable that will wrap this in a Box and display it over a background, allowing our widget to work in a responsive way. import androidx.glance.layout.Box import androidx.glance.layout.wrapContentSize import androidx.glance.layout.padding @Composable fun StreakWidgetContent( modifier: GlanceModifier = GlanceModifier, content: WeeklyPostingStreak ) { Box( modifier = modifier.background(...), contentAlignment = Alignment.Center ) { Streak( modifier = GlanceModifier.wrapContentSize().padding(16.dp), content = content ) } } Now that we have the UI of our widget in place, we can go ahead an compose it with the the GlanceTheme that we defined in a previous step. provideContent { GlanceTheme { StreakContent(content = ...) } } Dependency Injection One thing you may have noticed above is that we don’t have the data available to pass the required data to our widget composable. To get this data, we need access to the GetWeeklyPostingStreak use case class that will fetch this information from the network/cache. However, that class relies on dependency injection for its dependencies, so we’re going to need to find a way to inject this use case into our widget. There are two ways of doing this and we’re going to cover the first while we are in the code for the widget. In my app I am using Hilt and there isn’t an officially supported way of accessing dependencies inside of widgets yet, so we’re going to workaround this for now. We’ll start here by defining a new EntryPoint interface for our widget that defines the dependency that we need to access, just like we would for other entry points in our app. @EntryPoint @InstallIn(SingletonComponent::class) interface StreaksWidgetEntryPoint { fun getWeeklyPostingStreak(): GetWeeklyPostingStreak } Next, we’re going to go ahead an manually create the reference to the EntryPoint within our code For this we need to use the EntryPointAccessors along with a reference to the ApplicationContext, which will give us an instance of our EntryPoint along with the dependencies that have been declared. override suspend fun provideGlance(context: Context, id: GlanceId) { try { val hiltEntryPoint = EntryPointAccessors.fromApplication(context.applicationContext, StreaksWidgetEntryPoint::class.java) } catch (e: Exception) { } } Using this we can now execute our use case and store a reference to the result of the operation. override suspend fun provideGlance(context: Context, id: GlanceId) { var data: WeeklyPostingStreak? = null try { val hiltEntryPoint = EntryPointAccessors.fromApplication(context.applicationContext, StreaksWidgetEntryPoint::class.java) hiltEntryPoint.getWeeklyPostingStreak().run()?.let { data = it } } catch (e: Exception) { } } Now that we have this data available, we can pass it to our composable to satisfy the required data that we were previously missing. data?.let { streakData -\u003e StreakContent(content = streakData) } You may notice here though that the data we retrieve is nullable – this could be from an exception being thrown, or the data not being available from the network/cache. In these cases we still need to show something within our widget to handle this error case, so here we’ll simply display an error message to let the user know that we were unable to load the content. data?.let { streakData -\u003e StreakContent(content = streakData) } ?: run { Text(text = \"Unable to load Streak\") } Note: If you are looking to access string resources from within your Glance widget, then you need to utilise LocalContext.current to access the application resources. Launching Intents In some cases widgets will be for purely informative purposes, but in others we will want to trigger some kind of Intent when the user interacts with it. In the case of this widget, we want to link the Composer (used for creating social posts) when the widget is clicked, so for this we can use the actionStartActivity function. When it comes to a Streak, in some cases they are sharable – so for example if the user has hit their streak and they tap the widget, we pass the streak data and then the text/image for that streak are loaded into the composer, allowing the user to share their streak. In the case where the users streak is at risk, tapping the widget will open the Composer in a blank state so that they can create something to get their Streak back on track. data?.let { streakData -\u003e val streakModifier = GlanceModifier.clickable( if (streakData.canShareStreak) { actionStartActivity(Activities.Composer.intentForStreak(streakData)) } else { actionStartActivity(Activities.Composer.intent()) } ) StreakContent(modifier = streakModifier, content = streakData) } ?: run { Text(text = \"Unable to load Streak\") Registering the Widget At this point we’ve created our widget and enabled it to be interacted with by the user, we now just need to register it with the system. We need to start here by creating a new instance of the GlanceAppWidgetReceiver class, which is used to manage the lifecycle of the widget via broadcast recievers. class StreaksWidgetReceiver : GlanceAppWidgetReceiver() { override val glanceAppWidget: GlanceAppWidget = StreaksWidget() } With this class created, we’ll need to go ahead and declare a reference to this inside of our application manifest, declaring the APPWIDGET_UPDATE intent-filter action that that our widgets can be updated as required. \u003creceiver android:name=\".streaks.StreaksWidgetReceiver\" android:exported=\"true\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" /\u003e \u003c/intent-filter\u003e \u003cmeta-data android:name=\"android.appwidget.provider\" android:resource=\"@xml/streaks_widget_info\" /\u003e \u003c/receiver\u003e Next, we’ll go ahead and create a new metadata file for our widget, which allows us to declare some configuration properties for our widget. These values will depend on the use case for your widget, but for Glance you’ll need to at least provide the initialLayout value for what should be displayed before your widget has been loaded. \u003cappwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\" android:initialKeyguardLayout=\"@layout/glance_default_loading_layout\" android:initialLayout=\"@layout/glance_default_loading_layout\" android:minWidth=\"140dp\" android:minHeight=\"90dp\" android:previewImage=\"@drawable/streaks\" android:resizeMode=\"none\" android:widgetCategory=\"home_screen\" /\u003e The GlanceAppWidgetReceiver instance that we create here can have the Hilt AndroidEntryPoint annotation applied to it, allowing you to perform injection into your receiver to then be passed to the widget. However, these are not suspending functions, so you will need to ensure that you correctly manage the scopes to ensure threading is correctly handled. Wrapping Up Throughout this post we’ve learn how we can create app widgets using Glance and Jetpack Compose. This approach has provided us with an easier way to create app widgets, giving users access to core parts of our app directly from their home screens (and beyond!). If you’re looking to learn more about how to create widget with Glance then you can read more from the official guides here.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\t\n\u003cp\u003eWidgets on Android devices provide users with a way to access core pieces of information and functionality directly from the home screen of their device. As we continue to look for ways to improve our users experiences with our product and surface important information to them from outside of the app, widgets have been a great way for us to achieve this. With the availability of \u003ca href=\"https://developer.android.com/develop/ui/compose/glance\"\u003eJetpack Glance\u003c/a\u003e, we’re now able to create widgets using Composables – and if you’ve had to create widgets using RemoteViews, then you know how much easier this is going to be! \u003c/p\u003e\n\n\n\n\u003cp\u003eI recently worked on a new Widget for the \u003ca href=\"https://buffer.com/\"\u003eBuffer\u003c/a\u003e Android app for a new feature we launched. Our streaks feature tracks the weekly posting streak for your account, helping you to keep track of how consistently you post on your social channels.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1080\" height=\"607\" src=\"https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085545-1-edited.png\" alt=\"\" srcset=\"https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085545-1-edited.png 1080w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085545-1-edited-300x169.png 300w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085545-1-edited-1024x576.png 1024w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085545-1-edited-768x432.png 768w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085545-1-edited-500x281.png 500w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085545-1-edited-150x84.png 150w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085545-1-edited-400x225.png 400w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085545-1-edited-800x450.png 800w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085545-1-edited-200x112.png 200w\" sizes=\"(max-width: 1080px) 100vw, 1080px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAs part of this feature, we felt that a widget would help to raise awareness of your streak directly from your device home screen. The streak itself is quite simple, which provides a great opportunity to share how to build widgets with Glance, without getting caught up too much in the UI details of Compose. Things are a little different from how we might usually work with Compose and in this blog post I want to share those details with you.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eWidget Hierarchy\u003c/h2\u003e\n\n\n\n\u003cp\u003eBefore we get started with building a widget, it’s important to understand the hierarchy that makes up the widget. We won’t dive into the architecture of things under the hood, but it’s helpful to look at this at a higher level to better understand what we are building.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen it comes to widgets with Glance, we have 4 main components that we need to think about:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eApp Manifest\u003c/strong\u003e – we use the manifest file to declare our widget and the configuration for it\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eGlanceAppWidgetReceiver\u003c/strong\u003e – this is the receiver which provides the instance of our GlanceAppWidget, along with receive any updates to refresh the contents of our widget\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eGlanceAppWidget\u003c/strong\u003e – this is the class that provides the composition of our widget\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eGlance UI\u003c/strong\u003e – this is the composable that is used to compose the UI for our widget\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1024\" height=\"289\" src=\"https://joebirch.co/wp-content/uploads/2025/05/arch-1024x289.png\" alt=\"\" srcset=\"https://joebirch.co/wp-content/uploads/2025/05/arch-1024x289.png 1024w, https://joebirch.co/wp-content/uploads/2025/05/arch-300x85.png 300w, https://joebirch.co/wp-content/uploads/2025/05/arch-768x217.png 768w, https://joebirch.co/wp-content/uploads/2025/05/arch-1536x434.png 1536w, https://joebirch.co/wp-content/uploads/2025/05/arch-2048x578.png 2048w, https://joebirch.co/wp-content/uploads/2025/05/arch-500x141.png 500w, https://joebirch.co/wp-content/uploads/2025/05/arch-150x42.png 150w, https://joebirch.co/wp-content/uploads/2025/05/arch-1200x339.png 1200w, https://joebirch.co/wp-content/uploads/2025/05/arch-400x113.png 400w, https://joebirch.co/wp-content/uploads/2025/05/arch-800x226.png 800w, https://joebirch.co/wp-content/uploads/2025/05/arch-200x56.png 200w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAs we work through this post, we’ll see how we need to work with these different components to construct and provide our Glance widget.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eAdding Dependencies\u003c/h2\u003e\n\n\n\n\u003cp\u003eBefore we can get started, we need to add some dependencies to our project. For Glance there are a collection of dependencies available, and what you add for your project will depend on your needs. You’ll at least need to add the \u003cstrong\u003eglance-appwidget\u003c/strong\u003e and one of the \u003cstrong\u003ematerial\u003c/strong\u003e dependencies, with the \u003cstrong\u003epreview\u003c/strong\u003e dependencies being recommended as they’ll be helpful for creating previews of your widgets for viewing within the IDE.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003edependencies {\n    implementation \u0026#34;androidx.glance:glance-appwidget:1.1.1\u0026#34;\n\n    implementation \u0026#34;androidx.glance:glance-material3:1.1.1\u0026#34;\n\n    implementation \u0026#34;androidx.glance:glance-material:1.1.1\u0026#34;\n\n    implementation \u0026#34;androidx.glance:glance-preview:1.1.1\u0026#34;\n\n    imlementation \u0026#34;androidx.glance:glance-appwidget-preview:1.1.1\u0026#34;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eCreating the Widget\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow that we have our dependencies in place, we’re ready to start building our widget. To create a widget that can be added to a users device, we need to provide an instance of the \u003cstrong\u003eGlanceAppWidget\u003c/strong\u003e class that will be used to compose the Glance widget. \u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eclass StreaksWidget : GlanceAppWidget() {\n\n\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith this class now in place we’re going to need to override the \u003cstrong\u003eprovideGlance\u003c/strong\u003e function, this is what is going to be used to compose the widget UI. Within this function we’ll utilise the \u003cstrong\u003eprovideContent\u003c/strong\u003e function which is where we will need to provide the composition for our UI – you can think of this as the \u003cstrong\u003esetContent\u003c/strong\u003e function that we use for composing UI inside of an activity class.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eoverride suspend fun provideGlance(context: Context, id: GlanceId) {\n    provideContent {\n\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eInside of this block we’re now going to compose the UI for our widget, for which we’ll start by using the \u003cstrong\u003eGlanceTheme\u003c/strong\u003e function. This is similar to the MaterialTheme wrapper that we use in Jetpack Compose, but specifically built for Glance. We’re not going to be doing any customization here, but you can \u003ca href=\"https://developer.android.com/develop/ui/compose/glance/theme\"\u003eread more about this functionality\u003c/a\u003e if you need to override the default theme.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eprovideContent {\n    GlanceTheme {\n                    \n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAt this point, we’re now ready to compose the UI for our widget. As we previously saw, we’re creating a pretty simply UI for our widget – consisting of an image with some text.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"634\" src=\"https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085525-1024x634.png\" alt=\"\" srcset=\"https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085525-1024x634.png 1024w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085525-300x186.png 300w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085525-768x475.png 768w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085525-500x310.png 500w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085525-150x93.png 150w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085525-400x248.png 400w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085525-800x495.png 800w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085525-200x124.png 200w, https://joebirch.co/wp-content/uploads/2025/05/Screenshot_20250510_085525.png 1071w\" sizes=\"auto, (max-width: 1024px) 100vw, 1024px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWhen it comes to composing this UI, we’re not going to dive into the specifics of building UI with compose as I want to focus on Glance itself, so we’ll be skipping over some details of the UI to simplify things here.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor the main body of our widget UI, we’re going to see something like the following:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eimport androidx.glance.layout.Column\nimport androidx.glance.layout.Spacer\nimport androidx.glance.layout.height\n\n@Composable\nfun Streak(\n    modifier: GlanceModifier = GlanceModifier,\n    content: WeeklyPostingStreak\n) {\n    Column(...) {\n        Image(...)\n        Spacer(modifier = GlanceModifier.height(12.dp))\n        Text(...)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is quite simply and is likely something similar to what you’ve build previously with Jetpack Compose. The main difference here is that the composables we are using are from the \u003cstrong\u003eandroidx.glance\u003c/strong\u003e package and not the standard \u003cstrong\u003efoundation\u003c/strong\u003e package that we access for composables. This is because Glance widgets are restricted to the limitations of AppWidgets and RemoteViews, so we see a reduced set of composables available for building widgets with Glance. For example when it comes to layouts, we can use the Scaffold, Box, Row and Column composables and we still have composables such as the Image, Text and Spacer. However, when it comes to using this you may noticed reduce functionality, such as specific modifiers that you are used to using. For simpler widget UIs you should be fine in most cases, but there may be a few situations where you have to think slightly differently. You can read more \u003ca href=\"https://developer.android.com/develop/ui/compose/glance/build-ui\"\u003ehere\u003c/a\u003e about what components are available.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith our \u003cstrong\u003eStreak\u003c/strong\u003e widget in place, we’re not going to create a \u003cstrong\u003eStreakWidgetContnet\u003c/strong\u003e composable that will wrap this in a Box and display it over a background, allowing our widget to work in a responsive way.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eimport androidx.glance.layout.Box\nimport androidx.glance.layout.wrapContentSize\nimport androidx.glance.layout.padding\n\n@Composable\nfun StreakWidgetContent(\n    modifier: GlanceModifier = GlanceModifier,\n    content: WeeklyPostingStreak\n) {\n    Box(\n        modifier = modifier.background(...),\n        contentAlignment = Alignment.Center\n    ) {\n        Streak(\n            modifier = GlanceModifier.wrapContentSize().padding(16.dp),\n            content = content\n        )\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow that we have the UI of our widget in place, we can go ahead an compose it with the the \u003cstrong\u003eGlanceTheme\u003c/strong\u003e that we defined in a previous step.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eprovideContent {\n    GlanceTheme {\n        StreakContent(content = ...)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eDependency Injection\u003c/h2\u003e\n\n\n\n\u003cp\u003eOne thing you may have noticed above is that we don’t have the data available to pass the required data to our widget composable. To get this data, we need access to the \u003cstrong\u003eGetWeeklyPostingStreak\u003c/strong\u003e use case class that will fetch this information from the network/cache. However, that class relies on dependency injection for its dependencies, so we’re going to need to find a way to inject this use case into our widget. There are two ways of doing this and we’re going to cover the first while we are in the code for the widget.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn my app I am using Hilt and there isn’t an officially supported way of accessing dependencies inside of widgets yet, so we’re going to workaround this for now. We’ll start here by defining a new EntryPoint interface for our widget that defines the dependency that we need to access, just like we would for other entry points in our app.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e@EntryPoint\n@InstallIn(SingletonComponent::class)\ninterface StreaksWidgetEntryPoint {\n    fun getWeeklyPostingStreak(): GetWeeklyPostingStreak\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, we’re going to go ahead an manually create the reference to the EntryPoint within our code For this we need to use the \u003cstrong\u003eEntryPointAccessors\u003c/strong\u003e along with a reference to the \u003cstrong\u003eApplicationContext\u003c/strong\u003e, which will give us an instance of our EntryPoint along with the dependencies that have been declared.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eoverride suspend fun provideGlance(context: Context, id: GlanceId) {\n    try {\n        val hiltEntryPoint = EntryPointAccessors.fromApplication(context.applicationContext, StreaksWidgetEntryPoint::class.java)\n    } catch (e: Exception) { }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eUsing this we can now execute our use case and store a reference to the result of the operation.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eoverride suspend fun provideGlance(context: Context, id: GlanceId) {\n    var data: WeeklyPostingStreak? = null\n    try {\n        val hiltEntryPoint = EntryPointAccessors.fromApplication(context.applicationContext, StreaksWidgetEntryPoint::class.java)\n        hiltEntryPoint.getWeeklyPostingStreak().run()?.let { data = it }\n    } catch (e: Exception) { }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow that we have this data available, we can pass it to our composable to satisfy the required data that we were previously missing.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003edata?.let { streakData -\u0026gt;\n    StreakContent(content = streakData)\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou may notice here though that the data we retrieve is nullable – this could be from an exception being thrown, or the data not being available from the network/cache. In these cases we still need to show something within our widget to handle this error case, so here we’ll simply display an error message to let the user know that we were unable to load the content.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003edata?.let { streakData -\u0026gt;\n    StreakContent(content = streakData)\n} ?: run { Text(text = \u0026#34;Unable to load Streak\u0026#34;) }\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNote: If you are looking to access string resources from within your Glance widget, then you need to utilise \u003cstrong\u003eLocalContext.current\u003c/strong\u003e to access the application resources.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eLaunching Intents\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn some cases widgets will be for purely informative purposes, but in others we will want to trigger some kind of Intent when the user interacts with it. In the case of this widget, we want to link the Composer (used for creating social posts) when the widget is clicked, so for this we can use the \u003cstrong\u003eactionStartActivity\u003c/strong\u003e function. When it comes to a Streak, in some cases they are sharable – so for example if the user has hit their streak and they tap the widget, we pass the streak data and then the text/image for that streak are loaded into the composer, allowing the user to share their streak. In the case where the users streak is at risk, tapping the widget will open the Composer in a blank state so that they can create something to get their Streak back on track.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003edata?.let { streakData -\u0026gt;\n    val streakModifier = GlanceModifier.clickable(\n        if (streakData.canShareStreak) {\n            actionStartActivity(Activities.Composer.intentForStreak(streakData))\n        } else {\n            actionStartActivity(Activities.Composer.intent())\n        }\n    )\n    StreakContent(modifier = streakModifier, content = streakData)\n} ?: run { Text(text = \u0026#34;Unable to load Streak\u0026#34;) \u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eRegistering the Widget\u003c/h2\u003e\n\n\n\n\u003cp\u003eAt this point we’ve created our widget and enabled it to be interacted with by the user, we now just need to register it with the system. We need to start here by creating a new instance of the \u003cstrong\u003eGlanceAppWidgetReceiver\u003c/strong\u003e class, which is used to manage the lifecycle of the widget via broadcast recievers.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eclass StreaksWidgetReceiver : GlanceAppWidgetReceiver() {\n\n    override val glanceAppWidget: GlanceAppWidget = StreaksWidget()\n\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith this class created, we’ll need to go ahead and declare a reference to this inside of our application manifest, declaring the APPWIDGET_UPDATE intent-filter action that that our widgets can be updated as required.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"xml\"\u003e\u0026lt;receiver android:name=\u0026#34;.streaks.StreaksWidgetReceiver\u0026#34;\n    android:exported=\u0026#34;true\u0026#34;\u0026gt;\n    \u0026lt;intent-filter\u0026gt;\n        \u0026lt;action android:name=\u0026#34;android.appwidget.action.APPWIDGET_UPDATE\u0026#34; /\u0026gt;\n    \u0026lt;/intent-filter\u0026gt;\n    \u0026lt;meta-data\n        android:name=\u0026#34;android.appwidget.provider\u0026#34;\n        android:resource=\u0026#34;@xml/streaks_widget_info\u0026#34; /\u0026gt;\n\u0026lt;/receiver\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, we’ll go ahead and create a new metadata file for our widget, which allows us to declare some configuration properties for our widget. These values will depend on the use case for your widget, but for Glance you’ll need to at least provide the \u003cstrong\u003einitialLayout\u003c/strong\u003e value for what should be displayed before your widget has been loaded.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"xml\"\u003e\u0026lt;appwidget-provider xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\n    android:initialKeyguardLayout=\u0026#34;@layout/glance_default_loading_layout\u0026#34;\n    android:initialLayout=\u0026#34;@layout/glance_default_loading_layout\u0026#34;\n    android:minWidth=\u0026#34;140dp\u0026#34;\n    android:minHeight=\u0026#34;90dp\u0026#34;\n    android:previewImage=\u0026#34;@drawable/streaks\u0026#34;\n    android:resizeMode=\u0026#34;none\u0026#34;\n    android:widgetCategory=\u0026#34;home_screen\u0026#34; /\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003cstrong\u003eGlanceAppWidgetReceiver\u003c/strong\u003e instance that we create here can have the Hilt\u003cstrong\u003e AndroidEntryPoint\u003c/strong\u003e annotation applied to it, allowing you to perform injection into your receiver to then be passed to the widget. However, these are not suspending functions, so you will need to ensure that you correctly manage the scopes to ensure threading is correctly handled.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eWrapping Up\u003c/h2\u003e\n\n\n\n\u003cp\u003eThroughout this post we’ve learn how we can create app widgets using Glance and Jetpack Compose. This approach has provided us with an easier way to create app widgets, giving users access to core parts of our app directly from their home screens (and beyond!). If you’re looking to learn more about how to create widget with Glance then you can read more from the official guides \u003ca href=\"https://developer.android.com/develop/ui/compose/glance\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": null,
  "modifiedTime": null
}
