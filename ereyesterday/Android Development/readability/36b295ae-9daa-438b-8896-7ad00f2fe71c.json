{
  "id": "36b295ae-9daa-438b-8896-7ad00f2fe71c",
  "title": "Build AI-Powered Chatbot Apps for Android Using Firebase",
  "link": "https://proandroiddev.com/build-ai-powered-chatbot-apps-for-android-using-firebase-45cb22bcb972?source=rss----c72404660798---4",
  "description": "",
  "author": "Jaewoong Eum",
  "published": "Wed, 11 Dec 2024 15:53:48 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "chatbots",
    "realtime",
    "firebase",
    "kotlin",
    "android"
  ],
  "byline": "Jaewoong Eum",
  "length": 11054,
  "excerpt": "AI-powered chatbots are widely used across industries like education, food delivery, and now, even software development. Since the release of large language models (LLMs) from Google and OpenAI…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "AI-powered chatbots are widely used across industries like education, food delivery, and now, even software development. Since the release of large language models (LLMs) from Google and OpenAI, implementing AI-powered chatbots in projects has become much more accessible.Google’s Generative AI offers substantial benefits by enabling content creation, personalization, decision support, and simulation, which improve productivity and user engagement across various domains. Generative AI can streamline workflows, automate repetitive tasks, and allow professionals to focus on higher-level objectives, making it an ideal choice if you’re considering launching a chatbot service.In this article, we’ll guide you through implementing an AI-powered chatbot application for Android using Firebase’s Realtime Database, covering key components like chat channels and message screens.To get started, clone the AI Chat Android GitHub repository to your local machine using the command below. Once cloned, you can open the project in Android Studio for setup and exploration.https://github.com/GetStream/ai-chat-androidNext, let’s configure the secret properties needed before building the project.Configure Secret Properties With API KeysThe AI Chat Android project uses the secrets-gradle-plugin for secure API configuration, ensuring that sensitive information remains protected and is not exposed in public repositories. To start configuring API keys, create a file named secrets.properties in the root directory and add the following properties:GEMINI_API_KEY=REALTIME_DATABASE_URL=You’ll need the following API keys to build AI Chat Android locally:Google Cloud API Key: To access Google’s generative AI SDK, obtain a Google Cloud API key from Google AI Studio. This can be easily generated with your Google account.Firebase Realtime Database URL: Follow the Firebase setup guidelines and Realtime Database configuration instructions to set up your Realtime Database. Retrieve the Firebase Realtime Database URL as shown in the example image below.Build AI Chat Bot AppAfter completing the project build, you should see the following results:Now it’s time to build your own AI-powered chatbot, inspired by the AI Chat Android project! This post will guide you through the key features and implementation details of AI Chat Android, giving you the knowledge and tools to develop your own application.Firebase Realtime DatabaseFirebase Realtime Database is a cloud-hosted database that uses data synchronization instead of typical HTTP requests. This means every time data changes, connected devices receive updates within milliseconds, enabling collaborative and responsive experiences without complex networking code.In this project, Firebase Realtime Database is utilized for both remote storage and real-time communication, creating a responsive chatbot system powered by Gemini. The project uses the firebase-android-ktx library, which enables you to observe changes in the Realtime Database as a Flow, offering flexible and customizable serialization options.To get started with this library, add the following dependency to your app’s module.gradle.kts file:You can continuously observe changes in snapshot data as a Flow by applying the flow() method with a custom serialization approach to your DatabaseReference instance using kotlinx-serialization, as shown in the example below:Implement a Channel ListStart by implementing the channel list screen, which displays a list of channels, allowing users to select an existing thread to continue their conversation with the AI bot. Additionally, users should have the option to create a new channel for a fresh chat.RepositoryTo start, let’s outline the key functions needed for the channel list screen. You should implement the following three primary methods:fetchChannels: This method retrieves all existing channels from the Firebase Realtime Database to display them in the channel list.fetchChannel: Use this method to fetch details of a specific channel, particularly when navigating to a chatbot message screen.addChannel: This method allows users to add a new channel to the Firebase Realtime Database.You can implement the specifications outlined above in a class named ChannelsRepositoryImpl, as shown in the example code below:In the addChannel function, the entire existing list of channels is retrieved, and the new channel is added by setting the updated list. This approach addresses a limitation in Firebase Realtime Database, which doesn’t allow adding a single entry to a specific node directly. Due to its NoSQL structure, Firebase Realtime Database lacks native querying, so locating a specific node requires iterating through the list using a given index, as demonstrated in the fetchChannel method.ViewModelNow, it’s time to fetch channel data from the repository in the ViewModel and hold it as a state to be observed by the UI. You can achieve this by using various Flow extensions, such as mapLatest, filterNotNull, and converting it to StateFlow with the stateIn method, as shown in the example below:Let’s break down each operation one-by-one:mapLatest: Transforms elements from the original flow using the specified transform function. If a new value is emitted, any ongoing transformation for the previous value is canceled.filterNotNull: Filters the original flow to include only non-null values.stateIn: Converts a cold flow into a hot StateFlow that begins in the provided coroutine scope, sharing the most recent value emitted by the upstream flow with multiple subscribers.Compose UIIn the Channels composable function, you’ll find three main components: a top app bar, a body section, and a floating action button, as shown in the code example below:In the ChannelContentBody composable function, a LazyColumn is used to display a list of channels, with each item represented by the ChannelItem composable function, as shown in the example below:As a result, it will display the list of channels that are stored and updated by Firebase Realtime Database that is created by users like the screenshot below:Implement an AI Chat BotNow it’s time to implement the AI chatbot messaging screen, enabling users to type questions for the AI and receive responses in a streaming format.RepositoryFirst, let’s consider implementing the AI chat messaging screen. The two primary functions you’ll need are: fetching messages from Firebase in real-time and sending messages to Firebase. You can implement these features as shown in the methods below:fetchMessages: Retrieves messages from Firebase and displays updates in real-time, creating a live chat experience.sendMessage: Sends a message to Firebase, enabling message history storage so that past conversations are displayed when the user returns to the app.However, you’ve already implemented a similar approach with the fetchChannel method in the channels repository, where the response contains all message information. This illustrates the benefits of using the repository pattern, which promotes flexibility and reusability of domain logic.Implement these specifications in a class named MessagesRepositoryImpl will be simple, as shown in the example code below:ViewModelNext, implement the messages ViewModel, which fetches data from the repository and stores it as observable states for the UI layers. Additionally, retrieve the channel information containing all message data. You can implement these specifications as shown in the example code below:Next, handle events passed from the UI layers and send messages to the Firebase Realtime Database, as shown in the example code below:In the code above, the latestResponse property holds the generated text as a stream whenever the MessagesEvent.SendMessage event comes in. This allows you to display responses in a real-time, streaming format, with each response from the AI platform appearing chunk by chunk.Now, it’s time to set up the generative model and create a chat instance to request responses from Gemini using its Android SDK, as shown in the code below:As you can see in the code above, you can create an instance of GenerativeModel with the following details:Model name: Choose from gemini-1.5-flash, gemini-1.5-pro, or gemini-1.0-pro.API key: Use the API key generated from Google AI Studio.Optionally, you can define model parameters, setting values for properties like temperature, topK, topP, and the maximum number of output tokens.Compose UIFinally, implement the UI layer to display chat messages in real time. Start with the Messages composable function, which consists of three main parts: the top app bar, the messages list body, and the input text field, as shown in the code below:In this section, we won’t go into the details of the top app bar or messages list, as they are similar to the implementation in the channels screen. Instead, the focus is on creating a responsive message item that reflects chunked messages directly from Gemini in real time.To achieve this, you can use the latestResponse property you implemented in the MessagesViewModel, as shown in the code below:Finally, implement the responsive message box within the messages list, as demonstrated in the code below:After building the project, you’ll see the result below, where chat messages update in real-time as responses stream in from Gemini:Stream Chat AndroidThere are multiple ways to implement a cloud-based, real-time chat messaging system. While Firebase Realtime Database is a popular option, you could also create your own backend server to achieve similar functionality. However, building a custom solution from scratch involves significant costs, including setting up socket protocols, UI components, databases, and more.In this case, you could use the Stream Chat Android SDK , which enables seamless integration of real-time chat systems while offering fully customizable chat UI components, theming options, offline support, and additional features to enhance your app’s chat experience.A similar AI-powered chatbot project that leverages Gemini and a Stream Chat SDK, with additional features like photo reasoning and text summarization, is gemini-android, which you can explore on GitHub. For further insights, check out Build an AI Chat Android App With Google’s Generative AI.ConclusionIn this article, you’ve explored how to implement an AI-powered chatbot application for Android using Gemini and Firebase Realtime Database. As AI technology becomes essential rather than optional, it’s transforming user experiences across applications. For additional examples and insights, visit the GitHub repositories and an article linked below:AI Chat Android on GitHubGemini Android on GitHubBuild an AI Chat Android App With Google’s Generative AIIf you have any questions or feedback on this article, you can find the author on Twitter @github_skydoves or GitHub if you have any questions or feedback. If you’d like to stay up to date with Stream, follow us on Twitter @getstream_io for more great technical content.As always, happy coding!— Jaewoong",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*po0dLyNs8eGFxifr",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://skydoves.medium.com/?source=post_page---byline--45cb22bcb972--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Jaewoong Eum\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*to22-X47VSP4tZeElwVKKA.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--45cb22bcb972--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"38f0\"\u003eAI-powered chatbots are widely used across industries like education, food delivery, and now, even \u003ca href=\"https://getstream.io/blog/llm-chatbot-docs/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esoftware development\u003c/a\u003e. Since the release of \u003ca href=\"https://getstream.io/blog/reasoning-llms/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003elarge language models (LLMs)\u003c/a\u003e from Google and OpenAI, implementing \u003ca href=\"https://getstream.io/chat/solutions/ai-integration/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAI-powered chatbots\u003c/a\u003e in projects has become much more accessible.\u003c/p\u003e\u003cp id=\"085c\"\u003eGoogle’s \u003ca href=\"https://ai.google/discover/generativeai/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGenerative AI\u003c/a\u003e offers substantial benefits by enabling content creation, personalization, decision support, and simulation, which improve productivity and user engagement across various domains. Generative AI can streamline workflows, automate repetitive tasks, and allow professionals to focus on higher-level objectives, making it an ideal choice if you’re considering launching a chatbot service.\u003c/p\u003e\u003cp id=\"ed67\"\u003eIn this article, we’ll guide you through implementing an AI-powered chatbot application for Android using Firebase’s Realtime Database, covering key components like chat channels and message screens.\u003c/p\u003e\u003cp id=\"6257\"\u003eTo get started, clone the \u003ca href=\"https://github.com/GetStream/ai-chat-android\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAI Chat Android\u003c/a\u003e GitHub repository to your local machine using the command below. Once cloned, you can open the project in Android Studio for setup and exploration.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c268\"\u003ehttps://github.com/GetStream/ai-chat-android\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"25d9\"\u003eNext, let’s configure the secret properties needed before building the project.\u003c/p\u003e\u003ch2 id=\"6433\"\u003eConfigure Secret Properties With API Keys\u003c/h2\u003e\u003cp id=\"a705\"\u003eThe AI Chat Android project uses the \u003ca href=\"https://github.com/google/secrets-gradle-plugin\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esecrets-gradle-plugin\u003c/a\u003e for secure API configuration, ensuring that sensitive information remains protected and is not exposed in public repositories. To start configuring API keys, create a file named \u003ccode\u003esecrets.properties\u003c/code\u003e in the root directory and add the following properties:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3292\"\u003eGEMINI_API_KEY=\u003cbr/\u003eREALTIME_DATABASE_URL=\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7681\"\u003eYou’ll need the following API keys to build AI Chat Android locally:\u003c/p\u003e\u003col\u003e\u003cli id=\"fbdf\"\u003eGoogle Cloud API Key: To access Google’s generative AI SDK, obtain a Google Cloud API key from \u003ca href=\"https://aistudio.google.com/app/apikey\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGoogle AI Studio\u003c/a\u003e. This can be easily generated with your Google account.\u003c/li\u003e\u003cli id=\"547f\"\u003eFirebase Realtime Database URL: Follow the \u003ca href=\"https://firebase.google.com/docs/android/setup\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFirebase setup guidelines\u003c/a\u003e and \u003ca href=\"https://firebase.google.com/docs/database/android/start\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRealtime Database configuration instructions\u003c/a\u003e to set up your Realtime Database. Retrieve the Firebase Realtime Database URL as shown in the example image below.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"a4aa\"\u003eBuild AI Chat Bot App\u003c/h2\u003e\u003cp id=\"cf99\"\u003eAfter completing the project build, you should see the following results:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9a29\"\u003eNow it’s time to build your own AI-powered chatbot, inspired by the AI Chat Android project! This post will guide you through the key features and implementation details of AI Chat Android, giving you the knowledge and tools to develop your own application.\u003c/p\u003e\u003ch2 id=\"bc66\"\u003eFirebase Realtime Database\u003c/h2\u003e\u003cp id=\"81c9\"\u003e\u003ca href=\"https://firebase.google.com/docs/database\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFirebase Realtime Database\u003c/a\u003e is a cloud-hosted database that uses data synchronization instead of typical HTTP requests. This means every time data changes, connected devices receive updates within milliseconds, enabling collaborative and responsive experiences without complex networking code.\u003c/p\u003e\u003cp id=\"7c04\"\u003eIn this project, Firebase Realtime Database is utilized for both remote storage and real-time communication, creating a responsive chatbot system powered by Gemini. The project uses the \u003ca href=\"https://github.com/skydoves/firebase-android-ktx\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003efirebase-android-ktx\u003c/a\u003e library, which enables you to observe changes in the Realtime Database as a Flow, offering flexible and customizable serialization options.\u003c/p\u003e\u003cp id=\"6c28\"\u003eTo get started with this library, add the following dependency to your app’s \u003ccode\u003emodule.gradle.kts\u003c/code\u003e file:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"dbd5\"\u003eYou can continuously observe changes in snapshot data as a Flow by applying the \u003ccode\u003eflow()\u003c/code\u003e method with a custom serialization approach to your \u003ccode\u003eDatabaseReference\u003c/code\u003e instance using \u003ca href=\"https://github.com/Kotlin/kotlinx.serialization\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlinx-serialization\u003c/a\u003e, as shown in the example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"f5b0\"\u003eImplement a Channel List\u003c/h2\u003e\u003cp id=\"176b\"\u003eStart by implementing the channel list screen, which displays a list of channels, allowing users to select an existing thread to continue their conversation with the AI bot. Additionally, users should have the option to create a new channel for a fresh chat.\u003c/p\u003e\u003ch2 id=\"569d\"\u003eRepository\u003c/h2\u003e\u003cp id=\"589f\"\u003eTo start, let’s outline the key functions needed for the channel list screen. You should implement the following three primary methods:\u003c/p\u003e\u003cul\u003e\u003cli id=\"34ab\"\u003e\u003ccode\u003efetchChannels\u003c/code\u003e: This method retrieves all existing channels from the Firebase Realtime Database to display them in the channel list.\u003c/li\u003e\u003cli id=\"cd57\"\u003e\u003ccode\u003efetchChannel\u003c/code\u003e: Use this method to fetch details of a specific channel, particularly when navigating to a chatbot message screen.\u003c/li\u003e\u003cli id=\"d29d\"\u003e\u003ccode\u003eaddChannel\u003c/code\u003e: This method allows users to add a new channel to the Firebase Realtime Database.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5ea3\"\u003eYou can implement the specifications outlined above in a class named \u003ccode\u003eChannelsRepositoryImpl\u003c/code\u003e, as shown in the example code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2d9b\"\u003eIn the \u003ccode\u003eaddChannel\u003c/code\u003e function, the entire existing list of channels is retrieved, and the new channel is added by setting the updated list. This approach addresses a limitation in Firebase Realtime Database, which doesn’t allow adding a single entry to a specific node directly. Due to its \u003ca href=\"https://www.mongodb.com/resources/basics/databases/nosql-explained\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNoSQL structure\u003c/a\u003e, Firebase Realtime Database lacks native querying, so locating a specific node requires iterating through the list using a given index, as demonstrated in the \u003ccode\u003efetchChannel\u003c/code\u003e method.\u003c/p\u003e\u003ch2 id=\"2f70\"\u003eViewModel\u003c/h2\u003e\u003cp id=\"f559\"\u003eNow, it’s time to fetch channel data from the repository in the ViewModel and hold it as a state to be observed by the UI. You can achieve this by using various \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFlow\u003c/a\u003e extensions, such as \u003ccode\u003emapLatest\u003c/code\u003e, \u003ccode\u003efilterNotNull\u003c/code\u003e, and converting it to \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStateFlow\u003c/a\u003e with the \u003ccode\u003estateIn\u003c/code\u003e method, as shown in the example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2526\"\u003eLet’s break down each operation one-by-one:\u003c/p\u003e\u003cul\u003e\u003cli id=\"85b3\"\u003emapLatest: Transforms elements from the original flow using the specified transform function. If a new value is emitted, any ongoing transformation for the previous value is canceled.\u003c/li\u003e\u003cli id=\"d15e\"\u003efilterNotNull: Filters the original flow to include only non-null values.\u003c/li\u003e\u003cli id=\"4123\"\u003estateIn: Converts a cold flow into a hot \u003ccode\u003eStateFlow\u003c/code\u003e that begins in the provided coroutine scope, sharing the most recent value emitted by the upstream flow with multiple subscribers.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"cbec\"\u003eCompose UI\u003c/h2\u003e\u003cp id=\"a80c\"\u003eIn the \u003ccode\u003eChannels\u003c/code\u003e composable function, you’ll find three main components: a top app bar, a body section, and a floating action button, as shown in the code example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"039c\"\u003eIn the \u003ccode\u003eChannelContentBody\u003c/code\u003e composable function, a \u003ccode\u003eLazyColumn\u003c/code\u003e is used to display a list of channels, with each item represented by the \u003ccode\u003eChannelItem\u003c/code\u003e composable function, as shown in the example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"68e2\"\u003eAs a result, it will display the list of channels that are stored and updated by Firebase Realtime Database that is created by users like the screenshot below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"180c\"\u003eImplement an AI Chat Bot\u003c/h2\u003e\u003cp id=\"98a3\"\u003eNow it’s time to implement the AI chatbot messaging screen, enabling users to type questions for the AI and receive responses in a streaming format.\u003c/p\u003e\u003ch2 id=\"ffaf\"\u003eRepository\u003c/h2\u003e\u003cp id=\"59db\"\u003eFirst, let’s consider implementing the AI chat messaging screen. The two primary functions you’ll need are: fetching messages from Firebase in real-time and sending messages to Firebase. You can implement these features as shown in the methods below:\u003c/p\u003e\u003cul\u003e\u003cli id=\"d33c\"\u003e\u003ccode\u003efetchMessages\u003c/code\u003e: Retrieves messages from Firebase and displays updates in real-time, creating a live chat experience.\u003c/li\u003e\u003cli id=\"0cb3\"\u003e\u003ccode\u003esendMessage\u003c/code\u003e: Sends a message to Firebase, enabling message history storage so that past conversations are displayed when the user returns to the app.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4682\"\u003eHowever, you’ve already implemented a similar approach with the \u003ccode\u003efetchChannel\u003c/code\u003e method in the channels repository, where the response contains all message information. This illustrates the benefits of using the \u003ca href=\"https://martinfowler.com/eaaCatalog/repository.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003erepository pattern\u003c/a\u003e, which promotes flexibility and reusability of domain logic.\u003c/p\u003e\u003cp id=\"d7e5\"\u003eImplement these specifications in a class named \u003ccode\u003eMessagesRepositoryImpl\u003c/code\u003e will be simple, as shown in the example code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"fd34\"\u003eViewModel\u003c/h2\u003e\u003cp id=\"903b\"\u003eNext, implement the messages ViewModel, which fetches data from the repository and stores it as observable states for the UI layers. Additionally, retrieve the channel information containing all message data. You can implement these specifications as shown in the example code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3ed3\"\u003eNext, handle events passed from the UI layers and send messages to the Firebase Realtime Database, as shown in the example code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f28b\"\u003eIn the code above, the \u003ccode\u003elatestResponse\u003c/code\u003e property holds the generated text as a stream whenever the \u003ccode\u003eMessagesEvent.SendMessage\u003c/code\u003e event comes in. This allows you to display responses in a real-time, streaming format, with each response from the AI platform appearing chunk by chunk.\u003c/p\u003e\u003cp id=\"e618\"\u003eNow, it’s time to set up the generative model and create a chat instance to request responses from Gemini using its Android SDK, as shown in the code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7136\"\u003eAs you can see in the code above, you can create an instance of \u003ccode\u003eGenerativeModel\u003c/code\u003e with the following details:\u003c/p\u003e\u003cul\u003e\u003cli id=\"33e3\"\u003eModel name: Choose from \u003ccode\u003egemini-1.5-flash\u003c/code\u003e, \u003ccode\u003egemini-1.5-pro\u003c/code\u003e, or \u003ccode\u003egemini-1.0-pro\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"e735\"\u003eAPI key: Use the API key generated from Google AI Studio.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ddf9\"\u003eOptionally, you can define \u003ca href=\"https://ai.google.dev/gemini-api/docs/models/generative-models#model-parameters\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003emodel parameters\u003c/a\u003e, setting values for properties like temperature, topK, topP, and the maximum number of output tokens.\u003c/p\u003e\u003ch2 id=\"d442\"\u003eCompose UI\u003c/h2\u003e\u003cp id=\"8ec1\"\u003eFinally, implement the UI layer to display chat messages in real time. Start with the \u003ccode\u003eMessages\u003c/code\u003e composable function, which consists of three main parts: the top app bar, the messages list body, and the input text field, as shown in the code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"6246\"\u003eIn this section, we won’t go into the details of the top app bar or messages list, as they are similar to the implementation in the channels screen. Instead, the focus is on creating a responsive message item that reflects chunked messages directly from Gemini in real time.\u003c/p\u003e\u003cp id=\"4ec1\"\u003eTo achieve this, you can use the \u003ccode\u003elatestResponse\u003c/code\u003e property you implemented in the \u003ccode\u003eMessagesViewModel\u003c/code\u003e, as shown in the code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"4764\"\u003eFinally, implement the responsive message box within the messages list, as demonstrated in the code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"dc6f\"\u003eAfter building the project, you’ll see the result below, where chat messages update in real-time as responses stream in from Gemini:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"2206\"\u003eStream Chat Android\u003c/h2\u003e\u003cp id=\"a4f8\"\u003eThere are multiple ways to implement a cloud-based, real-time chat messaging system. While Firebase Realtime Database is a popular option, you could also create your own backend server to achieve similar functionality. However, building a custom solution from scratch involves significant costs, including setting up socket protocols, UI components, databases, and more.\u003c/p\u003e\u003cp id=\"449f\"\u003eIn this case, you could use the \u003ca href=\"https://getstream.io/chat/sdk/android/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStream Chat Android SDK\u003c/a\u003e , which enables seamless integration of real-time chat systems while offering fully customizable chat UI components, theming options, offline support, and additional features to enhance your app’s chat experience.\u003c/p\u003e\u003cp id=\"48ac\"\u003eA similar AI-powered chatbot project that leverages Gemini and a \u003ca href=\"https://getstream.io/chat/sdk/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStream Chat SDK\u003c/a\u003e, with additional features like photo reasoning and text summarization, is \u003ca href=\"https://github.com/skydoves/gemini-android\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003egemini-android\u003c/a\u003e, which you can explore on GitHub. For further insights, check out \u003ca href=\"https://getstream.io/blog/android-generative-ai/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBuild an AI Chat Android App With Google’s Generative AI\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"df35\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"2a29\"\u003eIn this article, you’ve explored how to implement an AI-powered chatbot application for Android using Gemini and Firebase Realtime Database. As AI technology becomes essential rather than optional, it’s transforming user experiences across applications. For additional examples and insights, visit the GitHub repositories and an article linked below:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7b6f\"\u003e\u003ca href=\"https://github.com/GetStream/ai-chat-android\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAI Chat Android on GitHub\u003c/a\u003e\u003c/li\u003e\u003cli id=\"1b20\"\u003e\u003ca href=\"https://github.com/skydoves/gemini-android\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGemini Android on GitHub\u003c/a\u003e\u003c/li\u003e\u003cli id=\"76a9\"\u003e\u003ca href=\"https://getstream.io/blog/android-generative-ai/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBuild an AI Chat Android App With Google’s Generative AI\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f15e\"\u003eIf you have any questions or feedback on this article, you can find the author on Twitter \u003ca href=\"https://twitter.com/github_skydoves\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@github_skydoves\u003c/a\u003e or \u003ca href=\"https://github.com/skydoves\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub\u003c/a\u003e if you have any questions or feedback. If you’d like to stay up to date with Stream, follow us on Twitter \u003ca href=\"https://twitter.com/getstream_io\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@getstream_io\u003c/a\u003e for more great technical content.\u003c/p\u003e\u003cp id=\"8588\"\u003eAs always, happy coding!\u003c/p\u003e\u003cp id=\"a4bd\"\u003e— \u003ca href=\"https://github.com/skydoves\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJaewoong\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2024-12-05T23:55:35.632Z",
  "modifiedTime": null
}
