{
  "id": "49a7be56-18f3-4c37-868b-f2cfc87279fa",
  "title": "Introducing Metro",
  "link": "https://www.zacsweers.dev/introducing-metro/",
  "description": "I'm excited to share something new I've been working on the past few months!",
  "author": "Zac Sweers",
  "published": "Thu, 03 Apr 2025 16:14:23 GMT",
  "source": "https://www.zacsweers.dev/rss/",
  "categories": [
    "Metro",
    "Kotlin",
    "Dependency Injection",
    "Anvil",
    "Dagger"
  ],
  "byline": "Zac Sweers",
  "length": 5083,
  "excerpt": "I'm excited to share something new I've been working on the past few months!",
  "siteName": "Zac Sweers",
  "favicon": "",
  "text": "03 Apr 2025 • 4 min read I'm excited to share something new I've been working on the past few months! Metro is a compile-time dependency injection framework that draws heavy inspiration from Dagger, Anvil, and Kotlin-Inject. It seeks to unify their best features in one, cohesive solution while adding a few new ones and implemented as a compiler plugin.For some time, it's felt like the Kotlin community has wanted for a library at the intersection of these different tools and features. Different tools exist for parts of these, but there’s not yet been a unified solution that ties them all together, leaves behind some of their limitations, and embraces newer features that compiler plugins offer. Metro tries to be that answer. It doesn’t try to reinvent the wheel, it does try to make those wheels work better together. In short, Metro stands on the shoulders of giants.InstallationMetro 0.1.1 is available today. Installation is simple!plugins { id(\"dev.zacsweers.metro\") version \"0.1.1\" }Apply the Gradle pluginDoc site: https://zacsweers.github.io/metro/Runtime API: https://zacsweers.github.io/metro/api/0.x/Repo: https://github.com/zacsweers/metroFeaturesIf you've ever worked with Dagger or kotlin-inject, you'll feel right at home with Metro.@DependencyGraph interface AppGraph { val httpClient: HttpClient } val graph = createGraph\u003cAppGraph\u003e()Graphs are interfaces or abstract classes annotated with @DependencyGraph.@DependencyGraph interface AppGraph { val httpClient: HttpClient @Provides private fun provideFileSystem(): FileSystem = FileSystem.SYSTEM } @Inject class HttpClient(private val fileSystem: FileSystem)Provide dependencies with JSR-330-style constructor injection or providers directly in your graphs.@DependencyGraph interface AppGraph { val cacheFactory: Cache.Factory @Provides private fun provideFileSystem(): FileSystem = FileSystem.SYSTEM } @Inject class Cache(@Assisted size: Long, fs: FileSystem) { @AssistedFactory interface Factory { fun create(size: Long): Cache } }Perform assisted injection with @Assisted and @AssistedFactory.@ContributesBinding(AppScope::class) @Inject class CacheImpl(...) : CacheContribute and aggregate bindings like Anvil.@Inject class Cache(fs: FileSystem = FileSystem.SYSTEM)Optional dependencies. If the dependency doesn't exist on the injecting graph, the default parameter value is used.@Inject @Composable fun App(circuit: Circuit) { ProvideCircuitCompositionLocals(circuit) { CircuitContent(HomeScreen) } }Top-level function injection.Detailed-yet-readable error messages and diagnostics.And much more!HighlightsCompile-time dependency graph validationCompile-time FIR/IR code genDagger-esque code gen and runtimeKotlin-Inject-esque APIAnvil-esque aggregationMultiplatformIDE IntegrationAdvanced interopPrivate providers and private member injectionOptional dependenciesTop-level function injectionDetailed-yet-readable error messages and diagnosticsHead over to the Features section of the project site to get a full overview and the Usage section for full documentation of all the APIs available.Build PerformanceBeing a compiler plugin, Metro runs significantly faster. When benchmarking my CatchUp app, build performance improved remarkably.- Mutators are changing a low-level library.- Project has ~35 modules, was previously using a combination of anvil-ksp and K2 kapt for dagger-compiler.- Still uses some KSP for Circuit code gen in a couple modules (including the large monolithic app module at the top).ABI: ABI breaking change.No-ABI: Non-ABI breaking change, allowing compilation avoidance to kick in.IC: Incremental compilationAverage improvementsABI – 47% fasterABI w/ no IC – 28% fasterNo-ABI – 56% fasterNo-ABI w/ no IC – 25.5% fasterFuture WorkMetro's still in active development. This is just the first release, there will be bugs and there are a few major features I want to build out next. Nullable bindings, @ContributesGraphExtension, and reporting unused bindings are just a few of these. Check out the issue tracker and discussions on the repo for more details.FAQIs your KSP fork of anvil still going to be maintained?It's in maintenance mode and I'm happy to look at bug reports or cut new releases as needed to keep up with the ecosystem, but I'm unlikely to add new features to it.Compiler plugins are an unstable API, is this safe to use?I maintain a few compiler plugins already and have a good routine of this. The most likely scenario is that Metro follows a pattern of doing companion releases for each Kotlin compiler version (as needed), while separately developing new features on top of them. New features are not likely to be backported to older versions, but I'm happy to reconsider if there's a strong community need.Is this affiliated with Slack?Nope! Metro is solely my project.Don't you think that \"Circuit\", a name about wiring, would've been a better name for this? And Circuit, ostensibly a navigation library, would've been better off named \"Metro\"?Thank you for your question.",
  "image": "https://www.zacsweers.dev/content/images/2025/03/metro2.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003cp\u003e\u003cspan\u003e03 Apr 2025\u003c/span\u003e\n    \u003ci\u003e•\u003c/i\u003e\n    \u003cspan\u003e4 min read\u003c/span\u003e\n  \u003c/p\u003e\n  \n    \u003cp\u003eI\u0026#39;m excited to share something new I\u0026#39;ve been working on the past few months!\u003c/p\u003e\n    \n    \u003cp\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/size/w1200/format/avif/2025/03/metro2.png\" data-src=\"/content/images/size/w1200/format/avif/2025/03/metro2.png\" alt=\"A metro diagra\"/\u003e\n\n      \u003cspan\u003e\u003c/span\u003e\n    \u003c/p\u003e\n\u003c/div\u003e\u003cdiv\u003e\n    \u003cp\u003e\u003ca href=\"https://zacsweers.github.io/metro/?ref=zacsweers.dev\" rel=\"noreferrer\"\u003e\u003cstrong\u003eMetro\u003c/strong\u003e\u003c/a\u003e is a compile-time dependency injection framework that draws heavy inspiration from \u003ca href=\"https://github.com/google/dagger?ref=zacsweers.dev\"\u003eDagger\u003c/a\u003e, \u003ca href=\"https://github.com/square/anvil?ref=zacsweers.dev\"\u003eAnvil\u003c/a\u003e, and \u003ca href=\"https://github.com/evant/kotlin-inject?ref=zacsweers.dev\"\u003eKotlin-Inject\u003c/a\u003e. It seeks to unify their best features in one, cohesive solution while adding a few new ones and implemented as a compiler plugin.\u003c/p\u003e\u003cp\u003eFor some time, it\u0026#39;s felt like the Kotlin community has wanted for a library at the intersection of these different tools and features. Different tools exist for parts of these, but there’s not yet been a unified solution that ties them all together, leaves behind some of their limitations, and embraces newer features that compiler plugins offer. Metro tries to be that answer. It doesn’t try to reinvent the wheel, it does try to make those wheels work better together. In short, Metro stands on the shoulders of giants.\u003c/p\u003e\u003ch2 id=\"installation\"\u003eInstallation\u003c/h2\u003e\u003cp\u003eMetro 0.1.1 is available today. Installation is simple!\u003c/p\u003e\u003cfigure\u003e\u003cpre\u003e\u003ccode\u003eplugins {\n  id(\u0026#34;dev.zacsweers.metro\u0026#34;) version \u0026#34;0.1.1\u0026#34;\n}\u003c/code\u003e\u003c/pre\u003e\u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003eApply the Gradle plugin\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003e\u003cstrong\u003eDoc site:\u003c/strong\u003e \u003ca href=\"https://zacsweers.github.io/metro/?ref=zacsweers.dev\"\u003ehttps://zacsweers.github.io/metro/\u003c/a\u003e\u003cbr/\u003e\u003cstrong\u003eRuntime API:\u003c/strong\u003e \u003ca href=\"https://zacsweers.github.io/metro/api/0.x/?ref=zacsweers.dev\"\u003ehttps://zacsweers.github.io/metro/api/0.x/\u003c/a\u003e\u003cbr/\u003e\u003cstrong\u003eRepo:\u003c/strong\u003e \u003ca href=\"https://github.com/zacsweers/metro?ref=zacsweers.dev\"\u003ehttps://github.com/zacsweers/metro\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"features\"\u003eFeatures\u003c/h2\u003e\u003cp\u003eIf you\u0026#39;ve ever worked with Dagger or kotlin-inject, you\u0026#39;ll feel right at home with Metro.\u003c/p\u003e\u003cfigure\u003e\u003cpre\u003e\u003ccode\u003e@DependencyGraph\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n\nval graph = createGraph\u0026lt;AppGraph\u0026gt;()\u003c/code\u003e\u003c/pre\u003e\u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003eGraphs are interfaces or abstract classes annotated with \u003c/span\u003e\u003ccode spellcheck=\"false\"\u003e\u003cspan\u003e@DependencyGraph\u003c/span\u003e\u003c/code\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cpre\u003e\u003ccode\u003e@DependencyGraph\ninterface AppGraph {\n  val httpClient: HttpClient\n\n  @Provides\n  private fun provideFileSystem(): FileSystem = FileSystem.SYSTEM\n}\n\n@Inject\nclass HttpClient(private val fileSystem: FileSystem)\u003c/code\u003e\u003c/pre\u003e\u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003eProvide dependencies with JSR-330-style constructor injection or providers directly in your graphs.\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cpre\u003e\u003ccode\u003e@DependencyGraph\ninterface AppGraph {\n  val cacheFactory: Cache.Factory\n\n  @Provides\n  private fun provideFileSystem(): FileSystem = FileSystem.SYSTEM\n}\n\n@Inject\nclass Cache(@Assisted size: Long, fs: FileSystem) {\n  @AssistedFactory\n  interface Factory {\n    fun create(size: Long): Cache\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003ePerform assisted injection with \u003c/span\u003e\u003ccode spellcheck=\"false\"\u003e\u003cspan\u003e@Assisted\u003c/span\u003e\u003c/code\u003e\u003cspan\u003e and \u003c/span\u003e\u003ccode spellcheck=\"false\"\u003e\u003cspan\u003e@AssistedFactory\u003c/span\u003e\u003c/code\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cpre\u003e\u003ccode\u003e@ContributesBinding(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\u003c/code\u003e\u003c/pre\u003e\u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003eContribute and aggregate bindings like Anvil.\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cpre\u003e\u003ccode\u003e@Inject\nclass Cache(fs: FileSystem = FileSystem.SYSTEM)\u003c/code\u003e\u003c/pre\u003e\u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003eOptional dependencies. If the dependency doesn\u0026#39;t exist on the injecting graph, the default parameter value is used.\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cpre\u003e\u003ccode\u003e@Inject\n@Composable\nfun App(circuit: Circuit) {\n  ProvideCircuitCompositionLocals(circuit) {\n    CircuitContent(HomeScreen)\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003eTop-level function injection.\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2025/04/image.png\" alt=\"A Kotlin interface ExampleGraph annotated with @DependencyGraph contains a property val int: Int and three @Provides functions: provideNumber(), provideInt() (qualified with @Named(\u0026#34;qualified\u0026#34;)), and provideIntIntoSet() (with @IntoSet). Below the code, a test failure message is shown, indicating that Metro cannot find a binding for kotlin.Int requested at test.ExampleGraph.int. It lists similar bindings, but none match the unqualified Int.\" loading=\"lazy\" width=\"1926\" height=\"1138\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2025/04/image.png 600w, https://www.zacsweers.dev/content/images/size/w1000/2025/04/image.png 1000w, https://www.zacsweers.dev/content/images/size/w1600/2025/04/image.png 1600w, https://www.zacsweers.dev/content/images/2025/04/image.png 1926w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003cfigcaption\u003e\u003cspan\u003eDetailed-yet-readable error messages and diagnostics.\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eAnd much more!\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eHighlights\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eCompile-time dependency graph validation\u003c/li\u003e\u003cli\u003eCompile-time FIR/IR code gen\u003c/li\u003e\u003cli\u003eDagger-esque code gen and runtime\u003c/li\u003e\u003cli\u003eKotlin-Inject-esque API\u003c/li\u003e\u003cli\u003eAnvil-esque aggregation\u003c/li\u003e\u003cli\u003eMultiplatform\u003c/li\u003e\u003cli\u003eIDE Integration\u003c/li\u003e\u003cli\u003eAdvanced interop\u003c/li\u003e\u003cli\u003ePrivate providers and private member injection\u003c/li\u003e\u003cli\u003eOptional dependencies\u003c/li\u003e\u003cli\u003eTop-level function injection\u003c/li\u003e\u003cli\u003eDetailed-yet-readable error messages and diagnostics\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eHead over to the \u003ca href=\"https://zacsweers.github.io/metro/features/?ref=zacsweers.dev\"\u003eFeatures\u003c/a\u003e section of the project site to get a full overview and the \u003ca href=\"https://zacsweers.github.io/metro/dependency-graphs/?ref=zacsweers.dev\"\u003eUsage\u003c/a\u003e section for full documentation of all the APIs available.\u003c/p\u003e\u003ch2 id=\"build-performance\"\u003eBuild Performance\u003c/h2\u003e\u003cp\u003eBeing a compiler plugin, Metro runs \u003cem\u003esignificantly faster\u003c/em\u003e. When benchmarking my \u003ca href=\"https://github.com/zacsweers/catchup?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eCatchUp\u003c/a\u003e app, build performance improved remarkably.\u003c/p\u003e\u003cblockquote\u003e- Mutators are changing a low-level library.\u003cbr/\u003e- Project has ~35 modules, was previously using a combination of anvil-ksp and K2 kapt for dagger-compiler.\u003cbr/\u003e- Still uses some KSP for Circuit code gen in a couple modules (including the large monolithic app module at the top).\u003cp\u003eABI: ABI breaking change.\u003cbr/\u003eNo-ABI: Non-ABI breaking change, allowing compilation avoidance to kick in.\u003cbr/\u003eIC: Incremental compilation\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cstrong\u003eAverage improvements\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eABI – 47% faster\u003c/li\u003e\u003cli\u003eABI w/ no IC – 28% faster\u003c/li\u003e\u003cli\u003eNo-ABI – 56% faster\u003c/li\u003e\u003cli\u003eNo-ABI w/ no IC – 25.5% faster\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2025/03/image--4-.png\" width=\"1172\" height=\"1100\" loading=\"lazy\" alt=\"\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2025/03/image--4-.png 600w, https://www.zacsweers.dev/content/images/size/w1000/2025/03/image--4-.png 1000w, https://www.zacsweers.dev/content/images/2025/03/image--4-.png 1172w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2025/03/image--5-.png\" width=\"1366\" height=\"1220\" loading=\"lazy\" alt=\"\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2025/03/image--5-.png 600w, https://www.zacsweers.dev/content/images/size/w1000/2025/03/image--5-.png 1000w, https://www.zacsweers.dev/content/images/2025/03/image--5-.png 1366w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2025/03/image--6-.png\" width=\"1352\" height=\"1210\" loading=\"lazy\" alt=\"\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2025/03/image--6-.png 600w, https://www.zacsweers.dev/content/images/size/w1000/2025/03/image--6-.png 1000w, https://www.zacsweers.dev/content/images/2025/03/image--6-.png 1352w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2025/03/image--7-.png\" width=\"1194\" height=\"1194\" loading=\"lazy\" alt=\"\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2025/03/image--7-.png 600w, https://www.zacsweers.dev/content/images/size/w1000/2025/03/image--7-.png 1000w, https://www.zacsweers.dev/content/images/2025/03/image--7-.png 1194w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/figure\u003e\u003ch2 id=\"future-work\"\u003eFuture Work\u003c/h2\u003e\u003cp\u003eMetro\u0026#39;s still in active development. This is just the first release, there will be bugs and there are a few major features I want to build out next. Nullable bindings, \u003ccode\u003e@ContributesGraphExtension\u003c/code\u003e, and reporting unused bindings are just a few of these. Check out the issue tracker and discussions on the repo for more details.\u003c/p\u003e\u003ch2 id=\"faq\"\u003eFAQ\u003c/h2\u003e\u003cblockquote\u003eIs your \u003ca href=\"https://github.com/zacsweers/anvil?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eKSP fork of anvil\u003c/a\u003e still going to be maintained?\u003c/blockquote\u003e\u003cp\u003eIt\u0026#39;s in maintenance mode and I\u0026#39;m happy to look at bug reports or cut new releases as needed to keep up with the ecosystem, but I\u0026#39;m unlikely to add new features to it.\u003c/p\u003e\u003cblockquote\u003eCompiler plugins are an unstable API, is this safe to use?\u003c/blockquote\u003e\u003cp\u003eI maintain a few compiler plugins already and have a good routine of this. The most likely scenario is that Metro follows a pattern of doing companion releases for each Kotlin compiler version (as needed), while separately developing new features on top of them. New features are not likely to be backported to older versions, but I\u0026#39;m happy to reconsider if there\u0026#39;s a strong community need.\u003c/p\u003e\u003cblockquote\u003eIs this affiliated with Slack?\u003c/blockquote\u003e\u003cp\u003eNope! Metro is solely my project.\u003c/p\u003e\u003cblockquote\u003eDon\u0026#39;t you think that \u0026#34;Circuit\u0026#34;, a name about wiring, would\u0026#39;ve been a better name for this? And \u003ca href=\"https://github.com/slackhq/circuit?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eCircuit\u003c/a\u003e, ostensibly a navigation library, would\u0026#39;ve been better off named \u0026#34;Metro\u0026#34;?\u003c/blockquote\u003e\u003cp\u003eThank you for your question.\u003c/p\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-04-03T16:14:23Z",
  "modifiedTime": "2025-04-04T05:09:46Z"
}
