{
  "id": "7ab331a7-b36c-4001-953b-02ce74904ca9",
  "title": "Understanding Coroutines Dispatchers",
  "link": "https://proandroiddev.com/understanding-coroutines-dispatchers-2578dc577851?source=rss----c72404660798---4",
  "description": "",
  "author": "Jaewoong Eum",
  "published": "Tue, 28 Jan 2025 00:30:56 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "coroutine",
    "android",
    "asynchronous",
    "dispatcher"
  ],
  "byline": "Jaewoong Eum",
  "length": 8122,
  "excerpt": "Since Kotlin Coroutines have been widely adopted in many Android projects, they have continued to evolve, inspiring creative solutions for handling asynchronous programming. Coroutines, a…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Unsplash@jeffashton_Since Kotlin Coroutines have been widely adopted in many Android projects, they have continued to evolve, inspiring creative solutions for handling asynchronous programming. Coroutines, a language-level feature in Kotlin, enable non-blocking code execution, simplifying tasks like network requests, file I/O, and other long-running operations by allowing functions to pause and resume seamlessly without blocking the underlying thread.However, this doesn’t mean you can entirely disregard the concept of threads. Coroutines still rely on threads under the hood to execute tasks; the key difference is that they manage to run these tasks without blocking the threads, offering a more efficient and streamlined approach to concurrency in Android development. That’s why, when using Coroutines, you can avoid dealing with the complexity of managing threads and related resources manually. Coroutines provide APIs, such as Dispatchers, that allow you to specify the thread or thread pool where the coroutine should execute.In this article, you’ll delve into the concept of Dispatchers, coroutine contexts, and relevant knowledges featured in Dove Letter. Dove Letter is a subscription repository where you can learn, discuss, and share new insights about Android and Kotlin with industrial Android developer interview questions, tips with code, articles, discussion, and trending news. If you’re interested in joining, be sure to check out “Learn Kotlin and Android With Dove Letter.”Understanding Coroutines DispatchersBefore exploring Dispatchers, it’s crucial to first understand the concept of Coroutine Context, as Dispatchers are one of the Coroutine Context Elements. The following code snippet illustrates this relationship:A Coroutine Context is an immutable collection of key-value pairs that defines various settings and behaviors for coroutine execution. It can include objects that handle threading policies, logging, security, transactions, coroutine identity, and names, making it a crucial tool for configuring the coroutine environment consistently and efficiently throughout its lifecycle.Now, what are Dispatchers? Coroutine Dispatchers determine the thread or thread pool where a coroutine executes. They play a critical role in managing how and where coroutines run, allowing for efficient background processing, UI updates, and computational tasks. Kotlin’s Coroutine library provides five types of Dispatchers to meet different requirements:Dispatchers.Main: Used for UI-related tasks, ensuring coroutines run on the main thread, primarily used for updating UI components in applications. On the JVM, it adapts to the appropriate main thread mechanism, such as the Android main thread, JavaFx, or Swing EDT, depending on the environment.Dispatchers.Main.immediate: A variant of Dispatchers.Main that runs coroutines immediately on the main thread, eliminating the need for additional dispatching. This optimization enhances performance by reducing unnecessary context switching, particularly beneficial for UI updates that originate from the main thread. For example, LifecycleOwner.lifecycleScope is bound to Dispatchers.Main.immediate.Dispatchers.IO: Optimized for offloading blocking I/O-intensive operations to a shared thread pool. By default, it can utilize up to 64 threads + a number equal to the available CPU cores according to JetBrains. This parallelism level can be adjusted using the kotlinx.coroutines.io.parallelism system property. Additionally, Dispatchers.IO supports elasticity through the limitedParallelism function, allowing the creation of custom dispatchers with specific thread limits that share resources with the default Dispatchers.IO pool.Dispatchers.Default: Optimized for CPU-intensive tasks such as data processing, complex calculations, or large data manipulations. This is a shared pool of background threads used by standard builders like launch and async when no specific dispatcher is provided. By default, it utilizes a number of threads equal to the available CPU cores, with a minimum of two threads, to efficiently manage concurrent tasks.Dispatchers.Unconfined: Starts coroutines in the calling thread but resumes them on the thread determined by the next suspending function. It’s useful for testing or lightweight tasks but should be used cautiously.You can select the appropriate Dispatcher based on your specific use case, as outlined in the table below for easy comparison:CPU-intensive tasks and I/O tasksNow that you’ve explored the different types of Dispatchers and learned which one you need to choose for launching coroutines properly, but you might still have lingering questions. For instance, what exactly constitutes a “CPU-intensive task”? How does it differ from an I/O task? At first glance, the term “intensive” may suggest that CPU tasks demand more threads than I/O tasks due to their focus on computation, but the reality is more nuanced. Let’s break it down further.Underststanding CPU-Intensive TasksCPU-intensive tasks demand computational power and are constrained by the number of available CPU cores. These tasks include operations like encryption, image processing, video encoding, or data analysis. Because these tasks rely entirely on the CPU, adding more threads than the number of available cores often results in thread contention rather than improved performance.For instance, the optimal number of threads for CPU-intensive tasks generally aligns with the number of CPU cores. On an 8-core system, using eight threads is ideal for such tasks. Overloading threads for CPU-bound operations can lead to excessive context switching, negatively impacting performance. The key takeaway is to carefully align thread usage with the system’s computational capacity.Underststanding I/O-Intensive TasksI/O-intensive tasks, on the other hand, involve waiting for external resources such as network responses, disk I/O, or database queries. Unlike CPU-bound tasks, I/O-bound tasks spend most of their time idle, waiting for data to be transferred, rather than actively utilizing the CPU.These tasks benefit from using more threads than there are CPU cores, as multiple I/O operations can run concurrently without causing CPU contention. For example, a system with 8 cores might efficiently manage dozens or even hundreds of I/O threads. Asynchronous programming models, like Kotlin Coroutines, further optimize resource utilization by enabling a smaller number of threads to handle numerous I/O-bound tasks. This approach significantly reduces resource overhead while improving scalability and efficiency.Thread BehaviorThread management strategies differ for CPU-intensive and I/O-intensive tasks. For CPU-bound tasks, thread counts should match the available cores for optimal performance. For I/O-bound tasks, leveraging more threads or using asynchronous programming (e.g., coroutines) ensures efficient resource utilization without overwhelming the CPU as you’ve seen in the illustration below:Now you have a clearer understanding of Dispatchers, especially when and how to choose the appropriate one for running specific coroutine tasks effectively.ConclusionIn this article, you’ve explored the concept of Dispatchers, coroutine contexts, and what are the differences between CPU-intensive tasks and I/O tasks. As always deeper understanding makes you decide more concise in many different situations, especially the solutions that you use friendly in your daily life. The internal mechanism of Coroutines is quite complex, so don’t need to rush, just keep learning the surfaces and learn one by one, and not be intimidated.This topic initially has been covered in Dove Letter, a private repository offering daily insights on Android and Kotlin, including topics like Compose, architecture, industry interview questions, and practical code tips. In just 20 weeks since its launch, Dove Letter has surpassed 400 individual subscribers and 12business/lifetime subscribers. If you’re eager to deepen your knowledge of Android, Kotlin, and Compose, be sure to check out ‘Learn Kotlin and Android With Dove Letter’.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*JdDVTZjzh-ZIrrZs",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003cfigcaption\u003eUnsplash@jeffashton_\u003c/figcaption\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://skydoves.medium.com/?source=post_page---byline--2578dc577851--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Jaewoong Eum\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*to22-X47VSP4tZeElwVKKA.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--2578dc577851--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"767a\"\u003eSince Kotlin \u003ca href=\"https://kotlinlang.org/docs/coroutines-overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoroutines\u003c/a\u003e have been widely adopted in many Android projects, they have continued to evolve, inspiring creative solutions for handling asynchronous programming. Coroutines, a language-level feature in Kotlin, enable non-blocking code execution, simplifying tasks like network requests, file I/O, and other long-running operations by allowing functions to pause and resume seamlessly without blocking the underlying thread.\u003c/p\u003e\u003cp id=\"6f75\"\u003eHowever, this doesn’t mean you can entirely disregard the concept of threads. Coroutines still rely on threads under the hood to execute tasks; the key difference is that they manage to run these tasks without blocking the threads, offering a more efficient and streamlined approach to concurrency in Android development. That’s why, when using Coroutines, you can avoid dealing with the complexity of managing threads and related resources manually. Coroutines provide APIs, such as \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDispatchers\u003c/a\u003e, that allow you to specify the thread or thread pool where the coroutine should execute.\u003c/p\u003e\u003cp id=\"dbd7\"\u003eIn this article, you’ll delve into the concept of Dispatchers, coroutine contexts, and relevant knowledges featured in \u003ca href=\"https://github.com/doveletter\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eDove Letter\u003c/em\u003e\u003c/a\u003e. \u003ca href=\"https://github.com/doveletter\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003eDove Letter\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e is a subscription repository where you can learn, discuss, and share new insights about Android and Kotlin with industrial Android developer interview questions, tips with code, articles, discussion, and trending news. If you’re interested in joining, be sure to check out “\u003ca href=\"https://medium.com/@skydoves/learn-kotlin-and-android-with-dove-letter-26265da11903\" rel=\"noopener\"\u003e\u003cstrong\u003eLearn Kotlin and Android With Dove Letter\u003c/strong\u003e\u003c/a\u003e.”\u003c/p\u003e\u003ch2 id=\"a0e1\"\u003eUnderstanding Coroutines Dispatchers\u003c/h2\u003e\u003cp id=\"f18b\"\u003eBefore exploring Dispatchers, it’s crucial to first understand the concept of Coroutine Context, as Dispatchers are one of the Coroutine Context Elements. The following code snippet illustrates this relationship:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"1c16\"\u003eA Coroutine Context is an immutable collection of key-value pairs that defines various settings and behaviors for coroutine execution. It can include objects that handle threading policies, logging, security, transactions, coroutine identity, and names, making it a crucial tool for configuring the coroutine environment consistently and efficiently throughout its lifecycle.\u003c/p\u003e\u003cp id=\"e9a6\"\u003eNow, what are \u003ccode\u003eDispatchers\u003c/code\u003e? \u003cstrong\u003eCoroutine Dispatchers\u003c/strong\u003e determine the thread or thread pool where a coroutine executes. They play a critical role in managing how and where coroutines run, allowing for efficient background processing, UI updates, and computational tasks. Kotlin’s Coroutine library provides five types of \u003ccode\u003eDispatchers\u003c/code\u003e to meet different requirements:\u003c/p\u003e\u003col\u003e\u003cli id=\"196f\"\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDispatchers.Main\u003c/strong\u003e\u003c/a\u003e: Used for UI-related tasks, ensuring coroutines run on the main thread, primarily used for updating UI components in applications. On the JVM, it adapts to the appropriate main thread mechanism, such as the Android main thread, JavaFx, or Swing EDT, depending on the environment.\u003c/li\u003e\u003cli id=\"7a8b\"\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-coroutine-dispatcher/immediate.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDispatchers.Main.immediate\u003c/strong\u003e\u003c/a\u003e: A variant of \u003ccode\u003eDispatchers.Main\u003c/code\u003e that runs coroutines \u003cstrong\u003eimmediately\u003c/strong\u003e on the main thread, eliminating the need for additional dispatching. This optimization enhances performance by reducing unnecessary context switching, particularly beneficial for UI updates that originate from the main thread. For example, \u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-common/src/commonMain/kotlin/androidx/lifecycle/LifecycleOwner.kt;l=44;bpv=1;bpt=1?q=Dispatchers.Main.immediate\u0026amp;start=81\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLifecycleOwner.lifecycleScope\u003c/a\u003e is bound to \u003ccode\u003eDispatchers.Main.immediate\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"18e1\"\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDispatchers.IO\u003c/strong\u003e\u003c/a\u003e: Optimized for offloading blocking I/O-intensive operations to a shared thread pool. By default, it can utilize \u003cstrong\u003eup to 64 threads + a number equal to the available CPU cores\u003c/strong\u003e \u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/issues/2272\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eaccording to JetBrains\u003c/a\u003e. This parallelism level can be adjusted using the \u003ccode\u003ekotlinx.coroutines.io.parallelism\u003c/code\u003e system property. Additionally, \u003ccode\u003eDispatchers.IO\u003c/code\u003e supports elasticity through the \u003ccode\u003elimitedParallelism\u003c/code\u003e function, allowing the creation of custom dispatchers with specific thread limits that share resources with the default \u003ccode\u003eDispatchers.IO\u003c/code\u003e pool.\u003c/li\u003e\u003cli id=\"2f12\"\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDispatchers.Default\u003c/strong\u003e\u003c/a\u003e: Optimized for CPU-intensive tasks such as data processing, complex calculations, or large data manipulations. This is a shared pool of background threads used by standard builders like \u003ccode\u003elaunch\u003c/code\u003e and \u003ccode\u003easync\u003c/code\u003e when no specific dispatcher is provided. By default, it utilizes a number of threads equal to the available CPU cores, with a minimum of two threads, to efficiently manage concurrent tasks.\u003c/li\u003e\u003cli id=\"d1d7\"\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDispatchers.Unconfined\u003c/strong\u003e\u003c/a\u003e: Starts coroutines in the calling thread but resumes them on the thread determined by the next suspending function. It’s useful for testing or lightweight tasks but should be used cautiously.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"f778\"\u003eYou can select the appropriate \u003ccode\u003eDispatcher\u003c/code\u003e based on your specific use case, as outlined in the table below for easy comparison:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"76dd\"\u003e\u003cstrong\u003eCPU-intensive tasks and I/O tasks\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"bb16\"\u003eNow that you’ve explored the different types of Dispatchers and learned which one you need to choose for launching coroutines properly, but you might still have lingering questions. For instance, what exactly constitutes a “CPU-intensive task”? How does it differ from an I/O task? At first glance, the term “intensive” may suggest that CPU tasks demand more threads than I/O tasks due to their focus on computation, but the reality is more nuanced. Let’s break it down further.\u003c/p\u003e\u003cp id=\"f3e4\"\u003e\u003cstrong\u003eUnderststanding CPU-Intensive Tasks\u003cbr/\u003e\u003c/strong\u003eCPU-intensive tasks demand computational power and are constrained by the number of available CPU cores. These tasks include operations like encryption, image processing, video encoding, or data analysis. Because these tasks rely entirely on the CPU, adding more threads than the number of available cores often results in thread contention rather than improved performance.\u003c/p\u003e\u003cp id=\"caab\"\u003eFor instance, the optimal number of threads for CPU-intensive tasks generally aligns with the number of CPU cores. On an 8-core system, using eight threads is ideal for such tasks. Overloading threads for CPU-bound operations can lead to excessive context switching, negatively impacting performance. The key takeaway is to carefully align thread usage with the system’s computational capacity.\u003c/p\u003e\u003cp id=\"39da\"\u003e\u003cstrong\u003eUnderststanding I/O-Intensive Tasks\u003cbr/\u003e\u003c/strong\u003eI/O-intensive tasks, on the other hand, involve waiting for external resources such as network responses, disk I/O, or database queries. Unlike CPU-bound tasks, I/O-bound tasks spend most of their time idle, waiting for data to be transferred, rather than actively utilizing the CPU.\u003c/p\u003e\u003cp id=\"960c\"\u003eThese tasks benefit from using more threads than there are CPU cores, as multiple I/O operations can run concurrently without causing CPU contention. For example, a system with 8 cores might efficiently manage dozens or even hundreds of I/O threads. Asynchronous programming models, like Kotlin Coroutines, further optimize resource utilization by enabling a smaller number of threads to handle numerous I/O-bound tasks. This approach significantly reduces resource overhead while improving scalability and efficiency.\u003c/p\u003e\u003cp id=\"8ace\"\u003e\u003cstrong\u003eThread Behavior\u003cbr/\u003e\u003c/strong\u003eThread management strategies differ for CPU-intensive and I/O-intensive tasks. For CPU-bound tasks, thread counts should match the available cores for optimal performance. For I/O-bound tasks, leveraging more threads or using asynchronous programming (e.g., coroutines) ensures efficient resource utilization without overwhelming the CPU as you’ve seen in the illustration below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b800\"\u003eNow you have a clearer understanding of Dispatchers, especially when and how to choose the appropriate one for running specific coroutine tasks effectively.\u003c/p\u003e\u003ch2 id=\"68ab\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"b272\"\u003eIn this article, you’ve explored the concept of Dispatchers, coroutine contexts, and what are the differences between CPU-intensive tasks and I/O tasks. As always deeper understanding makes you decide more concise in many different situations, especially the solutions that you use friendly in your daily life. The internal mechanism of Coroutines is quite complex, so don’t need to rush, just keep learning the surfaces and learn one by one, and not be intimidated.\u003c/p\u003e\u003cp id=\"c50a\"\u003eThis topic initially has been covered in \u003ca href=\"https://github.com/doveletter/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDove Letter\u003c/strong\u003e\u003c/a\u003e, a private repository offering daily insights on Android and Kotlin, including topics like Compose, architecture, industry interview questions, and practical code tips. \u003cstrong\u003eIn just 20 weeks since its launch, Dove Letter has surpassed 400 individual subscribers and 12business/lifetime subscribers\u003c/strong\u003e. If you’re eager to deepen your knowledge of Android, Kotlin, and Compose, be sure to check out ‘\u003ca href=\"https://medium.com/@skydoves/learn-kotlin-and-android-with-dove-letter-26265da11903\" rel=\"noopener\"\u003eLearn Kotlin and Android With Dove Letter\u003c/a\u003e’.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-01-24T11:08:23.605Z",
  "modifiedTime": null
}
