{
  "id": "499117df-2079-442a-83de-6e449c504800",
  "title": "Lint Be Gone: Speed Up Your Android Release APK Builds",
  "link": "https://proandroiddev.com/lint-be-gone-speed-up-your-android-release-apk-builds-aafb7cf430a7?source=rss----c72404660798---4",
  "description": "",
  "author": "Ademir Queiroga",
  "published": "Fri, 18 Apr 2025 20:34:44 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "gradle",
    "androiddev",
    "android-app-development",
    "build-automation",
    "android"
  ],
  "byline": "Ademir Queiroga",
  "length": 5991,
  "excerpt": "Speed up Your CI by Disabling Unnecessary Lint Tasks When Building Release APKs",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Enhance Your CI Efficiency by Disabling Unnecessary Lint Tasks When Building APKsPhoto by Elena Mozhvilo on UnsplashI've been exploring ways to speed up a white-label automated app-building system. After a deeper inspection, I realized that the Android Gradle build task could run much faster for assemble tasks, a.k.a. building APKs. Given the number of apps this system generates, even minor improvements can be highly valuable.These days, when you upload an Android app to Google Play or the Amazon Appstore, an Android App Bundle (AAB) is required*. When building AABs, the lint task doesn't run by default. If your only requirement is an AAB, this article won't be your recipe for speed. However, if you still need to generate APKs, whether for uploading to an automated test platform, easier distribution to QA teams, or other specific needs, keep reading.*Note: Amazon Appstore still accepts APKs.Gradle BuildThe Gradle build system provides many optimizations for completing tasks faster. It caches the inputs and outputs of the executed tasks, and if the inputs haven't changed, it skips the task and reuses the cached output. It is also capable of running independent tasks in parallel. You can learn more about Gradle caching here and parallel task execution here.However, our white-label system executes tasks in a fresh and clean workspace, similar to ephemeral CI environments, which prevents us from leveraging caching out of the box. Therefore, I aimed to prevent unnecessary tasks from running.I ran a clean release build with Gradle's --scan option and began exploring the Timeline. As its name suggests, the Timeline displays each executed task chronologically, showing how long it took to start and finish. After I ordered the tasks by duration, I noticed that lintVitalAnalyzeRelease, a task that runs by default for a release APK build consumed a significant portion of the overall execution time. This appeared to be a low-hanging fruit I could easily tackle.For demonstration purposes, I used the mozilla-mobile/fenix project to showcase the Gradle build scan results but the same idea applies to any Android project.Gradle Scan Timeline from mozilla-mobile/fenix Project.The lint task for the app module alone took 33.944 seconds to complete, accounting for approximately 15% of the entire execution time. It's important to note that the lint task runs for all Android modules the project depends on. Below, you'll find the Gradle Scan Timeline for android/nowinandroid, a project with 21 Android module dependencies for the assembleRelease task at the time of writing.Gradle Scan Timeline filtered by lint tasks from android/nowinandroid project.By filtering for tasks of type AndroidLintAnalysisTask, you can see how much time each module's code analysis took. To be fair, some of these tasks ran in parallel, so the report’s 5m 11s duration doesn’t reflect the actual time, as the overall execution finished in 4m 16s.Overall task execution duration for the android/nowinandroid project.Lint. The good, the bad, and the lintVitalRelease taskA linter is a tool that analyzes your code to identify syntax errors, potential bugs, vulnerabilities, and code smells, among other issues. In an Android project, the Android Gradle Plugin provides numerous lint rules that address a wide range of concerns, including accessibility, performance, usability, and security. If you're up for a challenge, you can also create custom lint checks for your specific needs.Out-of-the-box AGP lint rulesThe cost of these checks increases somewhat linearly with the size of your project, as larger codebases have more lines of code to be validated against lint rules. It's important to note that lint tasks, by default, are only executed for release APK builds. This means they won't run each time you deploy changes to a device during development or when you build an app bundle.Below is an overview of the impact of lint tasks in the assembleRelease task on projects of varying sizes. All tasks were executed on an M3 Pro Mac.Build times with lint on/off for the assembleRelease taskNote: The LOC's (Lines of Code) accounts for Java, Kotlin and XML files only.Disabling Lint in CI buildsLogs from successful builds, including lint task reports, are frequently overlooked in CI environments. This oversight means valuable processing time, and the money it represents can be wasted.If you're not actively using these lint reports and run multiple builds regularly, you can save time and money by disabling the execution of lint tasks. Add the following lines to your project's Gradle configuration file.You might not want lint tasks to be permanently disabled. Instead, you can control their execution by passing an extra parameter to Gradle tasks. For example, you can run ./gradlew assembleRelease -PdisableReleaseLint to disable lint only when this parameter is present. Here's how to set it up in your Gradle configuration file:These samples use the AGP Lint DSL. You can learn more about it in the official docs.Wrapping up!Optimizing CI build times by managing Android Gradle tasks is not just about increasing speed and saving costs, it's also about freeing up developer time for more critical tasks. Disabling the lint task was a low-hanging fruit that brought immediate benefits. While the advantages of this approach might seem minimal for smaller projects, dealing with hundreds or thousands of builds for each new app version can significantly reduce computing load. More importantly, it accelerates delivery, ensuring the latest version quickly get into users hands.For teams managing extensive build pipelines, these insights can serve as a foundation for exploring additional CI/CD process optimizations.Thank you!Please share your numbers if you've made it here and this post has helped you! I'm keen to see the lint impact in different projects.Do you have any other tips on how to improve build time? I would love to discuss!Feel free to connect with me on LinkedIn.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*ZMnD49RTcA_pOJHg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"db76\"\u003eEnhance Your CI Efficiency by Disabling Unnecessary Lint Tasks When Building APKs\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://admqueiroga.medium.com/?source=post_page---byline--aafb7cf430a7---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ademir Queiroga\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*xc2QwFHcpuH_QzF04DHwPA.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--aafb7cf430a7---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@miracleday?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eElena Mozhvilo\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"5548\"\u003eI\u0026#39;ve been exploring ways to speed up a white-label automated app-building system. After a deeper inspection, I realized that the Android Gradle build task could run much faster for \u003ccode\u003eassemble\u003c/code\u003e tasks, a.k.a. building APKs. Given the number of apps this system generates, even minor improvements can be highly valuable.\u003c/p\u003e\u003cp id=\"1635\"\u003eThese days, when you upload an Android app to Google Play or the Amazon Appstore, an Android App Bundle (AAB) is required\u003cstrong\u003e*\u003c/strong\u003e. When building AABs, the lint task doesn\u0026#39;t run by default. If your only requirement is an AAB, this article won\u0026#39;t be your recipe for speed. However, if you still need to generate APKs, whether for uploading to an automated test platform, easier distribution to QA teams, or other specific needs, keep reading.\u003c/p\u003e\u003cp id=\"ba3b\"\u003e\u003cstrong\u003e*Note\u003c/strong\u003e: Amazon Appstore still accepts APKs.\u003c/p\u003e\u003ch2 id=\"a679\"\u003eGradle Build\u003c/h2\u003e\u003cp id=\"0ce3\"\u003eThe Gradle build system provides many optimizations for completing tasks faster. It caches the inputs and outputs of the executed tasks, and if the inputs haven\u0026#39;t changed, it skips the task and reuses the cached output. It is also capable of running independent tasks in parallel. You can learn more about Gradle caching \u003ca href=\"https://docs.gradle.org/current/userguide/build_cache.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e and parallel task execution \u003ca href=\"https://docs.gradle.org/current/userguide/performance.html#parallel_execution\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"4977\"\u003eHowever, our white-label system executes tasks in a fresh and clean workspace, similar to ephemeral CI environments, which prevents us from leveraging caching out of the box. Therefore, I aimed to prevent unnecessary tasks from running.\u003c/p\u003e\u003cp id=\"cec6\"\u003eI ran a clean release build with Gradle\u0026#39;s \u003ccode\u003e--scan\u003c/code\u003e option and began exploring the Timeline. As its name suggests, the Timeline displays each executed task chronologically, showing how long it took to start and finish. After I ordered the tasks by duration, I noticed that \u003ccode\u003elintVitalAnalyzeRelease\u003c/code\u003e, a task that runs by default for a \u003ccode\u003erelease\u003c/code\u003e APK build consumed a significant portion of the overall execution time. This appeared to be a low-hanging fruit I could easily tackle.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"607a\"\u003eFor demonstration purposes, I used the \u003cstrong\u003emozilla-mobile/fenix\u003c/strong\u003e project to showcase the Gradle build scan results but the same idea applies to any Android project.\u003c/p\u003e\u003c/blockquote\u003e\u003cfigure\u003e\u003cfigcaption\u003eGradle Scan Timeline from mozilla-mobile/fenix Project.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"2212\"\u003eThe lint task for the \u003ccode\u003eapp\u003c/code\u003e module alone took \u003cstrong\u003e33.944\u003c/strong\u003e seconds to complete, accounting for approximately \u003cstrong\u003e15%\u003c/strong\u003e of the entire execution time. It\u0026#39;s important to note that the lint task runs for all Android modules the project depends on. Below, you\u0026#39;ll find the Gradle Scan Timeline for \u003ccode\u003eandroid/nowinandroid\u003c/code\u003e, a project with 21 Android module dependencies for the \u003ccode\u003eassembleRelease\u003c/code\u003e task at the time of writing.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eGradle Scan Timeline filtered by lint tasks from android/nowinandroid project.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ce8f\"\u003eBy filtering for tasks of type \u003ccode\u003eAndroidLintAnalysisTask\u003c/code\u003e, you can see how much time each module\u0026#39;s code analysis took. To be fair, some of these tasks ran in parallel, so the report’s \u003cstrong\u003e5m 11s\u003c/strong\u003e duration doesn’t reflect the actual time, as the overall execution finished in \u003cstrong\u003e4m 16s\u003c/strong\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eOverall task execution duration for the android/nowinandroid project.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"34b6\"\u003eLint. The good, the bad, and the lintVitalRelease task\u003c/h2\u003e\u003cp id=\"ad48\"\u003eA linter is a tool that analyzes your code to identify syntax errors, potential bugs, vulnerabilities, and code smells, among other issues. In an Android project, the Android Gradle Plugin provides numerous lint rules that address a wide range of concerns, including accessibility, performance, usability, and security. If you\u0026#39;re up for a challenge, you can also create custom lint checks for your specific needs.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eOut-of-the-box AGP lint rules\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"1951\"\u003eThe cost of these checks increases somewhat linearly with the size of your project, as larger codebases have more lines of code to be validated against lint rules. It\u0026#39;s important to note that lint tasks, by default, are only executed for \u003ccode\u003erelease\u003c/code\u003e APK builds. This means they won\u0026#39;t run each time you deploy changes to a device during development or when you build an app bundle.\u003c/p\u003e\u003cp id=\"80c1\"\u003eBelow is an overview of the impact of lint tasks in the \u003ccode\u003eassembleRelease\u003c/code\u003e task on projects of varying sizes. All tasks were executed on an M3 Pro Mac.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eBuild times with lint on/off for the assembleRelease task\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"2756\"\u003eNote: The LOC\u0026#39;s (Lines of Code) accounts for Java, Kotlin and XML files only.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"0739\"\u003eDisabling Lint in CI builds\u003c/h2\u003e\u003cp id=\"abd8\"\u003eLogs from successful builds, including \u003ccode\u003elint\u003c/code\u003e task reports, are frequently overlooked in CI environments. This oversight means valuable processing time, and the money it represents can be wasted.\u003c/p\u003e\u003cp id=\"aef4\"\u003eIf you\u0026#39;re not actively using these lint reports and run multiple builds regularly, you can save time and money by disabling the execution of \u003ccode\u003elint\u003c/code\u003e tasks. Add the following lines to your project\u0026#39;s Gradle configuration file.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"353d\"\u003eYou might not want lint tasks to be permanently disabled. Instead, you can control their execution by passing an extra parameter to Gradle tasks. For example, you can run \u003ccode\u003e./gradlew assembleRelease -PdisableReleaseLint\u003c/code\u003e to disable lint only when this parameter is present. Here\u0026#39;s how to set it up in your Gradle configuration file:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ef1a\"\u003eThese samples use the AGP Lint DSL. You can learn more about it in the \u003ca href=\"https://developer.android.com/reference/tools/gradle-api/8.6/com/android/build/api/dsl/Lint\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eofficial docs\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"3219\"\u003eWrapping up!\u003c/h2\u003e\u003cp id=\"f8e2\"\u003eOptimizing CI build times by managing Android Gradle tasks is not just about increasing speed and saving costs, it\u0026#39;s also about freeing up developer time for more critical tasks. Disabling the lint task was a low-hanging fruit that brought immediate benefits. While the advantages of this approach might seem minimal for smaller projects, dealing with hundreds or thousands of builds for each new app version can significantly reduce computing load. More importantly, it accelerates delivery, ensuring the latest version quickly get into users hands.\u003c/p\u003e\u003cp id=\"c97d\"\u003eFor teams managing extensive build pipelines, these insights can serve as a foundation for exploring additional CI/CD process optimizations.\u003c/p\u003e\u003ch2 id=\"640f\"\u003eThank you!\u003c/h2\u003e\u003cp id=\"5bc1\"\u003ePlease share your numbers if you\u0026#39;ve made it here and this post has helped you! I\u0026#39;m keen to see the lint impact in different projects.\u003c/p\u003e\u003cp id=\"d413\"\u003eDo you have any other tips on how to improve build time? I would love to discuss!\u003c/p\u003e\u003cp id=\"f980\"\u003eFeel free to connect with me on \u003ca href=\"https://linkedin.com/in/ademirqueiroga\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-04-18T02:02:06.091Z",
  "modifiedTime": null
}
