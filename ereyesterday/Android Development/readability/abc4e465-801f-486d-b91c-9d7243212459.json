{
  "id": "abc4e465-801f-486d-b91c-9d7243212459",
  "title": "Introducing Trio | Part III",
  "link": "https://medium.com/airbnb-engineering/introducing-trio-part-iii-033fbfe2171b?source=rss----53c7c27702d5--android",
  "description": "",
  "author": "Eli Hart",
  "published": "Thu, 11 Apr 2024 17:33:21 GMT",
  "source": "https://medium.com/feed/airbnb-engineering/tagged/android",
  "categories": [
    "android",
    "jetpack-compose",
    "mobile",
    "engineering",
    "mobile-app-development"
  ],
  "byline": "Eli Hart",
  "length": 14292,
  "excerpt": "Trio is Airbnb’s framework for Jetpack Compose screen architecture in Android. It’s built on top of Mavericks, Airbnb’s open source state management library for Jetpack. In this blog post series…",
  "siteName": "The Airbnb Tech Blog",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Introducing Trio | Part IIIPart three on how we built a Compose based architecture with Mavericks in the Airbnb Android appBy: Eli Hart, Ben Schwab, and Yvonne WongTrio is Airbnb’s framework for Jetpack Compose screen architecture in Android. It’s built on top of Mavericks, Airbnb’s open source state management library for Jetpack. In this blog post series, we’ve been breaking down how Trio works to help explain our design decisions, in the hopes that other teams might benefit from aspects of our approach.We recommend starting with Part 1, about Trio’s architecture, and then reading Part 2, about how navigation works in Trio, before you dive into this article. In this third and final part of our series, we’ll discuss how Props in Trio allow for simplified, type-safe communication between ViewModels. We’ll also share an update on the current adoption of Trio at Airbnb and what’s next.Trio PropsTo better understand Props, let’s look at an example of a simple Message Inbox screen, composed of two Trios side by side. There is a List Trio on the left, showing inbox messages, and a Details Trio on the right, showing the full text of a selected message.The two Trios are wrapped by a parent screen, which is responsible for instantiating the two children, passing along data to them, and positioning them in the UI. As you might recall from Part 2, Trios can be stored in State; the parent’s State includes both the message data as well as the child Trios.data class ParentState( val inboxMessages: List\u003cMessage\u003e, val selectedMessage: Message?, val messageListScreen: Trio\u003cListProps\u003e, val messageDetailScreen: Trio\u003cDetailsProps\u003e,} : MavericksStateThe parent’s UI decides how to display the children, which it accesses from the State. With Compose UI, it’s easy to apply custom layout logic: we show the screens side by side when the device is in landscape mode, and in portrait we show only a single screen, depending on whether a message has been selected.@Composable override fun TrioRenderScope.Content(state: ParentState) { if (LocalConfiguration.current.orientation == ORIENTATION_LANDSCAPE) { Row(Modifier.fillMaxSize()) { ShowTrio(state.listScreen, modifier = Modifier.weight(1f)) ShowTrio(state.detailScreen) } } else { if (state.selectedMessage == null) { ShowTrio(state.listScreen) } else { BackHandler { viewModel.clearMessageSelection() } ShowTrio(state.detailScreen) } }}Both child screens need access to the latest message state so they know which content to show. We can provide this with Props!Props are a collection of Kotlin properties, held in a data class and passed to a Trio by its parent.Unlike Arguments, Props can change over time, allowing a parent to provide updated data as needed throughout the lifetime of the Trio. Props can include Lambda expressions, allowing a screen to communicate back to its parent.A child Trio can only be shown in a parent that supports its Props type. This ensures compile-time correctness for navigation and communication between Trios.Defining PropsLet’s see how Props are used to pass message data from the parent Trio to the List and Details Trios. When a parent defines child Trios in its State, it must include the type of Props that those children require. For our example, the List and Details screen each have their own unique Props.The List screen needs to know the list of all Messages and whether one is selected. It also needs to be able to call back to the parent to tell it when a new message has been selected.data class ListProps( val selectedMessage: Message?, val inboxMessages: List\u003cMessage\u003e, val onMessageSelected: (Message) -\u003e Unit,)The Details screen just needs to know which message to display.data class DetailProps( val selectedMessage: Message?)The parent ViewModel holds the child instances in its State, and is responsible for passing the latest Props value to the children.Passing PropsSo, how does a parent Trio pass Props to its child? In its init block it must use the launchChildInitializer function — this function uses a lambda to select a Trio instance from the State, specifying which Trio is being targeted.class ParentViewModel: TrioViewModel { init { launchChildInitializer({ messageListScreen }) { state -\u003e ListProps( state.selectedMessage, state.inboxMessages, ::showMessageDetails ) } launchChildInitializer({ detailScreen }) { state -\u003e DetailProps(state.selectedMessage) } } fun showMessageDetails(message: Message?) ...}The second lambda argument receives a State value and returns a new Props instance to pass to the child. This function manages the lifecycle of the child, initializing it with a flow of Props when it is first created, and destroying it if it is ever removed from the parent’s state.The lambda to rebuild Props is re-invoked every time the Parent’s state changes, and any new value of Props is passed along to the child through its flow.A common pattern we use is to include function references in the Props, which point to functions on the parent ViewModel. This allows the child to call back to the parent for event handling. In the example above we do this with the showMessageDetails function. Props can also be used to pass along complex dependencies, which forms a dependency graph scoped to the parent.Note that we cannot pass Props to a Trio when it is created, like we do with Args. This is because Trios must be able to be restored after process death, and so the Trio class, as well as the Args used to create it, are Parcelable. Since Props can contain lambdas and other arbitrary objects that cannot be safely serialized, we must use the above pattern to establish a flow of Props from parent to child that can be reestablished even after process recreation. Navigation and inter-screen communication would be a lot simpler if we didn’t have to handle process recreation!Using PropsIn order for a child Trio to use Props data in its UI, it first needs to be copied to State.Child ViewModels override the function updateStateFromPropsChange to specify how to incorporate Prop values into State. The function is invoked every time the value of Props changes, and the new State value is updated on the ViewModel. This is how children stay up-to-date with the latest data from their parent.class ListViewModel : TrioViewModel\u003cListProps, ListState\u003e { override fun updateStateFromPropsChange( newProps: ListProps, thisState: ListState ): ListState { return thisState.copy( inboxMessages = newProps.inboxMessages, selectedMessage = newProps.selectedMessage ) } fun onMessageSelected(message: Message) { props.onMessageSelected(message) }}For non-state values in Props, such as dependencies or callbacks, the ViewModel can access the latest Props value at any time via the props property. For example, we do this in the onMessageSelected function in the sample code above. The List UI will invoke this function when a message is selected, and the event will be propagated to the parent through Props.There were a lot of complexities when implementing Props — for example, when handling edge cases around the Trio lifecycle and restoring state after process death. However, the internals of Trio hide most of the complexity from the end user. Overall, having an opinionated, codified system with type safety for how Compose screens communicate has helped improve standardization and productivity across our Android engineering team.Standardizing Screen Flow PropsOne of the most common UI patterns at Airbnb is to coordinate a stack of screens. These screens may share some common data, and follow similar navigation patterns such as pushing, popping, and removing all the screens of the backstack in tandem.Earlier, we showed how a Trio can manage a list of children in its State to accomplish this, but it’s tedious to do that manually. To help, Trio provides a standard “screen flow” implementation, which consists of a parent ScreenFlow Trio and related child Trio screens. The parent ScreenFlow automatically manages child transactions, and renders the top child in its UI. It also broadcasts a custom Props class to its children, giving access to shared state and navigation functions.Consider building a Todo app that has a TodoList screen, a TaskScreen, and an EditTaskScreen. These screens can all share a single network request that returns a TodoList model. In Trio terms, the TodoList data model could be the Props for these three screens.To manage these screens we use ScreenFlow infrastructure to create a TodoScreenFlow Trio. Its state extends ScreenFlowState and overrides a childScreenTransaction property to hold the transactions. In this example, the flow’s State was initialized to start with the TodoListScreen, so it will be rendered first. The flow’s State object also acts as the source of truth for other shared state, such as the TodoList data model.data class TodoFlowState( @PersistState override val childScreenTransactions: List\u003cScreenTransaction\u003cTodoFlowProps\u003e\u003e = listOf( ScreenTransaction(Router.TodoListScreen.createFullPaneTrio(NoArgs)) ), // shared state val todoListQuery: TodoList?,) : ScreenFlowState\u003cTodoFlowState, TodoFlowProps\u003eThis state is private to the TodoScreenFlow. However, the flow defines Props to share the TodoList data model, callbacks like a reloadList lambda, and a NavController with its children.data class TodoFlowProps( val navController: NavController\u003cTodoFlowProps\u003e, val todoListQuery: TodoList?, val reloadList: () -\u003e Unit,)The NavController prop can be used by the children screens to push another sibling screen in the flow. The ScreenFlowViewModel base class implements this NavController interface, managing the complexity of integrating the navigation actions into the screen flow’s state.interface NavController\u003cPropsT\u003e( fun push(router: TrioRouter\u003c*, in PropsT\u003e) fun pop())Lastly, the navigation and shared state is wired into a flow of Props when the TodoScreenFlowViewModel overrides createFlowProps. This function will be invoked anytime the internal state of TodoScreenFlowViewModel changes, meaning any update to TodoList model will be propagated to the children screens.class TodoScreenFlowViewModel( initializer: Initializer\u003cNavPopProps, TodoFlowState\u003e) : ScreenFlowViewModel\u003cNavPopProps, TodoFlowProps, TodoFlowState\u003e(initializer) { override fun createFlowProps( state: TodoFlowState, props: NavPopProps ): TodoFlowProps { return TodoFlowProps( navController = this, state.todoListQuery, ::reloadList, ) }}Inside one of the children screen’s ViewModels, we can see that it will receive the shared Props:class TodoListViewModel( initializer: Initializer\u003cTodoFlowProps, TodoListState\u003e) : TrioViewModel\u003cTodoFlowProps, TodoListState\u003e(initializer) { override fun updateStateFromPropsChange( newProps: TodoFlowProps, thisState: TodoTaskState ): TodoTaskState { // Incorporate the shared data model into this Trio’s private state passed to its UI: return thisState.copy(todoListQuery = newProps.todoListQuery) } fun navigateToTodoTask(task: TodoTask) { this.props.navController.push(Router.TodoTaskScreen, TodoTaskArgs(task.id)) }}In navigateToTodoTask, the NavController prepared by the flow parent is used to safely navigate to the next screen in the flow (guaranteeing it will receive the shared TodoFlowProps). Internally, the NavController updates the ScreenFlow’s childScreenTransactions triggering the ScreenFlow infra to provide the shared TodoFlowProps to the new screen, and render the new screen.Trio’s Success at AirbnbDevelopment history and launchWe started designing Trio in late 2021, with the first Trio screens seeing production traffic in mid 2022.As of March 2024, we now have over 230 Trio screens with significant production traffic at Airbnb.From surveying our developers, we’ve heard that many of them enjoy the overall Trio experience; they like having clear and opinionated patterns and are happy to be in a pure Compose environment. As one developer put it, “Props was a huge plus by allowing multiple screens to share callbacks, which simplified some of my code logic a lot.” Another said, “Trio makes you unlearn bad habits and adopt best practices that work for Airbnb based on our past learnings.” Overall, our team reports faster development cycles and cleaner code. “It makes Android development faster and more enjoyable,” is how one engineer summed it up.Dev ToolingTo support our engineers, we have invested in IDE tooling with an in-house Android Studio Plugin. It includes a Trio Generation tool that creates all of the files and boilerplate for a new Trio, including routing, mocks, and tests.The tool helps the user choose which Arguments and Props to use, and helps with other customization such as setting up custom Flows. It also allows us to embed educational experiences to help newcomers ramp up with Trio.One piece of feedback we heard from engineers was that it was tedious to change a Trio’s Args or Props types, since they are used across many different files.We leveraged our IDE plugin to provide a tool to automatically change these values, making this workflow much faster.Our team leans heavily on tooling like this, and we’ve found it to be very effective in improving the experience of engineers at Airbnb. We’ve adopted Compose Multiplatform for our Plugin UI development which we believe made building powerful developer tooling more feasible and enjoyable.ConclusionOverall, with more than 230 of our production screens implemented as Trios, Trio’s organic adoption at Airbnb has proven that many of our bets and design choices were worth the tradeoffs.One change we are anticipating, though, is to incorporate shared element transitions between screens once the Compose framework provides APIs to support that functionality. When Compose APIs for this are available, we’ll likely have to redesign our navigation APIs accordingly.Thanks for following along with the work we’ve been doing at Airbnb. Our Android Platform team works on a variety of complex and interesting projects like Trio, and we’re excited to share more in the future.If this kind of work sounds appealing to you, check out our open roles — we’re hiring!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*f5gDJHZdQ6lSewSKhZya-A.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"f63b\" data-testid=\"storyTitle\"\u003eIntroducing Trio | Part III\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"b12d\"\u003ePart three on how we built a Compose based architecture with Mavericks in the Airbnb Android app\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@konakid?source=post_page---byline--033fbfe2171b---------------------------------------\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Eli Hart\" src=\"https://miro.medium.com/v2/resize:fill:88:88/2*qR91fuLzUz5PI59hjTTcRQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/airbnb-engineering?source=post_page---byline--033fbfe2171b---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"The Airbnb Tech Blog\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*MlNQKg-sieBGW5prWoe9HQ.jpeg\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"11c1\"\u003eBy: \u003ca href=\"https://www.linkedin.com/in/eli-hart-54a4b975/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEli Hart\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/schwabben/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBen Schwab\u003c/a\u003e, and \u003ca href=\"https://www.linkedin.com/in/yvonnejwong\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eYvonne Wong\u003c/a\u003e\u003c/p\u003e\u003cp id=\"9f50\"\u003eTrio is Airbnb’s framework for Jetpack Compose screen architecture in Android. It’s built on top of \u003ca href=\"https://github.com/airbnb/mavericks\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMavericks\u003c/a\u003e, Airbnb’s open source state management library for Jetpack. In this blog post series, we’ve been breaking down how Trio works to help explain our design decisions, in the hopes that other teams might benefit from aspects of our approach.\u003c/p\u003e\u003cp id=\"ec2e\"\u003eWe recommend starting with \u003ca rel=\"noopener\" href=\"https://medium.com/p/7f5017a1a903\"\u003ePart 1\u003c/a\u003e, about Trio’s architecture, and then reading \u003ca rel=\"noopener\" href=\"https://medium.com/p/fe836013a798\"\u003ePart 2\u003c/a\u003e, about how navigation works in Trio, before you dive into this article. In this third and final part of our series, we’ll discuss how Props in Trio allow for simplified, type-safe communication between ViewModels. We’ll also share an update on the current adoption of Trio at Airbnb and what’s next.\u003c/p\u003e\u003ch2 id=\"adfc\"\u003eTrio Props\u003c/h2\u003e\u003cp id=\"1bd9\"\u003eTo better understand Props, let’s look at an example of a simple Message Inbox screen, composed of two Trios side by side. There is a List Trio on the left, showing inbox messages, and a Details Trio on the right, showing the full text of a selected message.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3211\"\u003eThe two Trios are wrapped by a parent screen, which is responsible for instantiating the two children, passing along data to them, and positioning them in the UI. As you might recall from Part 2, Trios can be stored in State; the parent’s State includes both the message data as well as the child Trios.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3300\"\u003edata class ParentState(\u003cbr/\u003e  val inboxMessages: List\u0026lt;Message\u0026gt;,\u003cbr/\u003e  val selectedMessage: Message?,\u003cbr/\u003e  val messageListScreen: Trio\u0026lt;ListProps\u0026gt;,\u003cbr/\u003e  val messageDetailScreen: Trio\u0026lt;DetailsProps\u0026gt;,\u003cbr/\u003e} : MavericksState\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c43d\"\u003eThe parent’s UI decides how to display the children, which it accesses from the State. With Compose UI, it’s easy to apply custom layout logic: we show the screens side by side when the device is in landscape mode, and in portrait we show only a single screen, depending on whether a message has been selected.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"954a\"\u003e@Composable \u003cbr/\u003eoverride fun TrioRenderScope.Content(state: ParentState) {\u003cbr/\u003e  if (LocalConfiguration.current.orientation == ORIENTATION_LANDSCAPE) {\u003cbr/\u003e    Row(Modifier.fillMaxSize()) {\u003cbr/\u003e      ShowTrio(state.listScreen, modifier = Modifier.weight(1f))\u003cbr/\u003e      ShowTrio(state.detailScreen)\u003cbr/\u003e    }\u003cbr/\u003e  } else {\u003cbr/\u003e    if (state.selectedMessage == null) {\u003cbr/\u003e      ShowTrio(state.listScreen)\u003cbr/\u003e    } else {\u003cbr/\u003e      BackHandler { viewModel.clearMessageSelection() }\u003cbr/\u003e      ShowTrio(state.detailScreen)\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"476d\"\u003eBoth child screens need access to the latest message state so they know which content to show. We can provide this with Props!\u003c/p\u003e\u003cp id=\"b043\"\u003eProps are a collection of Kotlin properties, held in a data class and passed to a Trio by its parent.\u003c/p\u003e\u003cp id=\"9e68\"\u003eUnlike Arguments, Props can change over time, allowing a parent to provide updated data as needed throughout the lifetime of the Trio. Props can include Lambda expressions, allowing a screen to communicate back to its parent.\u003c/p\u003e\u003cp id=\"595c\"\u003eA child Trio can only be shown in a parent that supports its Props type. This ensures compile-time correctness for navigation and communication between Trios.\u003c/p\u003e\u003ch2 id=\"960f\"\u003eDefining Props\u003c/h2\u003e\u003cp id=\"df92\"\u003eLet’s see how Props are used to pass message data from the parent Trio to the List and Details Trios. When a parent defines child Trios in its State, it must include the type of Props that those children require. For our example, the List and Details screen each have their own unique Props.\u003c/p\u003e\u003cp id=\"7f51\"\u003eThe List screen needs to know the list of all Messages and whether one is selected. It also needs to be able to call back to the parent to tell it when a new message has been selected.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d8d2\"\u003edata class ListProps(\u003cbr/\u003e  val selectedMessage: Message?,\u003cbr/\u003e  val inboxMessages: List\u0026lt;Message\u0026gt;,\u003cbr/\u003e  val onMessageSelected: (Message) -\u0026gt; Unit,\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e740\"\u003eThe Details screen just needs to know which message to display.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"050d\"\u003edata class DetailProps(\u003cbr/\u003e  val selectedMessage: Message?\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d08f\"\u003eThe parent ViewModel holds the child instances in its State, and is responsible for passing the latest Props value to the children.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"8cbb\"\u003ePassing Props\u003c/h2\u003e\u003cp id=\"a359\"\u003eSo, how does a parent Trio pass Props to its child? In its init block it must use the \u003ccode\u003elaunchChildInitializer\u003c/code\u003e function — this function uses a lambda to select a Trio instance from the State, specifying which Trio is being targeted.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"701f\"\u003eclass ParentViewModel: TrioViewModel {\u003cp\u003e  init {\u003cbr/\u003e    launchChildInitializer({ messageListScreen }) { state -\u0026gt;\u003cbr/\u003e      ListProps(\u003cbr/\u003e        state.selectedMessage,\u003cbr/\u003e        state.inboxMessages,\u003cbr/\u003e        ::showMessageDetails\u003cbr/\u003e      )\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e   launchChildInitializer({ detailScreen }) { state -\u0026gt;\u003cbr/\u003e      DetailProps(state.selectedMessage)\u003cbr/\u003e   }\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  fun showMessageDetails(message: Message?) ...\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f605\"\u003eThe second lambda argument receives a State value and returns a new Props instance to pass to the child. This function manages the lifecycle of the child, initializing it with a flow of Props when it is first created, and destroying it if it is ever removed from the parent’s state.\u003c/p\u003e\u003cp id=\"c35f\"\u003eThe lambda to rebuild Props is re-invoked every time the Parent’s state changes, and any new value of Props is passed along to the child through its flow.\u003c/p\u003e\u003cp id=\"2a76\"\u003eA common pattern we use is to include function references in the Props, which point to functions on the parent ViewModel. This allows the child to call back to the parent for event handling. In the example above we do this with the \u003ccode\u003eshowMessageDetails\u003c/code\u003e function. Props can also be used to pass along complex dependencies, which forms a dependency graph scoped to the parent.\u003c/p\u003e\u003cp id=\"4874\"\u003eNote that we cannot pass Props to a Trio when it is created, like we do with Args. This is because Trios must be able to be restored after process death, and so the Trio class, as well as the Args used to create it, are Parcelable. Since Props can contain lambdas and other arbitrary objects that cannot be safely serialized, we must use the above pattern to establish a flow of Props from parent to child that can be reestablished even after process recreation. Navigation and inter-screen communication would be a lot simpler if we didn’t have to handle process recreation!\u003c/p\u003e\u003ch2 id=\"e05e\"\u003eUsing Props\u003c/h2\u003e\u003cp id=\"f6c9\"\u003eIn order for a child Trio to use Props data in its UI, it first needs to be copied to State.\u003c/p\u003e\u003cp id=\"c47d\"\u003eChild ViewModels override the function \u003ccode\u003eupdateStateFromPropsChange\u003c/code\u003e to specify how to incorporate Prop values into State. The function is invoked every time the value of Props changes, and the new State value is updated on the ViewModel. This is how children stay up-to-date with the latest data from their parent.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"69a4\"\u003eclass ListViewModel : TrioViewModel\u0026lt;ListProps, ListState\u0026gt; {\u003cp\u003e  override fun updateStateFromPropsChange(\u003cbr/\u003e    newProps: ListProps,\u003cbr/\u003e    thisState: ListState\u003cbr/\u003e  ): ListState {\u003cbr/\u003e    return thisState.copy(\u003cbr/\u003e      inboxMessages = newProps.inboxMessages,\u003cbr/\u003e      selectedMessage = newProps.selectedMessage\u003cbr/\u003e    )\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  fun onMessageSelected(message: Message) {\u003cbr/\u003e    props.onMessageSelected(message)\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"34f5\"\u003eFor non-state values in Props, such as dependencies or callbacks, the ViewModel can access the latest Props value at any time via the \u003ccode\u003eprops\u003c/code\u003e property. For example, we do this in the \u003ccode\u003eonMessageSelected\u003c/code\u003e function in the sample code above. The List UI will invoke this function when a message is selected, and the event will be propagated to the parent through Props.\u003c/p\u003e\u003cp id=\"499a\"\u003eThere were a lot of complexities when implementing Props — for example, when handling edge cases around the Trio lifecycle and restoring state after process death. However, the internals of Trio hide most of the complexity from the end user. Overall, having an opinionated, codified system with type safety for how Compose screens communicate has helped improve standardization and productivity across our Android engineering team.\u003c/p\u003e\u003ch2 id=\"8f31\"\u003eStandardizing Screen Flow Props\u003c/h2\u003e\u003cp id=\"8935\"\u003eOne of the most common UI patterns at Airbnb is to coordinate a stack of screens. These screens may share some common data, and follow similar navigation patterns such as pushing, popping, and removing all the screens of the backstack in tandem.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"99bc\"\u003eEarlier, we showed how a Trio can manage a list of children in its State to accomplish this, but it’s tedious to do that manually. To help, Trio provides a standard “screen flow” implementation, which consists of a parent \u003ccode\u003eScreenFlow\u003c/code\u003e Trio and related child Trio screens. The parent \u003ccode\u003eScreenFlow\u003c/code\u003e automatically manages child transactions, and renders the top child in its UI. It also broadcasts a custom Props class to its children, giving access to shared state and navigation functions.\u003c/p\u003e\u003cp id=\"2123\"\u003eConsider building a Todo app that has a TodoList screen, a TaskScreen, and an EditTaskScreen. These screens can all share a single network request that returns a TodoList model. In Trio terms, the TodoList data model could be the Props for these three screens.\u003c/p\u003e\u003cp id=\"4ff1\"\u003eTo manage these screens we use ScreenFlow infrastructure to create a TodoScreenFlow Trio. Its state extends \u003ccode\u003eScreenFlowState\u003c/code\u003e and overrides a \u003ccode\u003echildScreenTransaction\u003c/code\u003e property to hold the transactions. In this example, the flow’s State was initialized to start with the TodoListScreen, so it will be rendered first. The flow’s State object also acts as the source of truth for other shared state, such as the TodoList data model.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0f12\"\u003edata class TodoFlowState(\u003cbr/\u003e  @PersistState\u003cbr/\u003e  override val childScreenTransactions: List\u0026lt;ScreenTransaction\u0026lt;TodoFlowProps\u0026gt;\u0026gt; = listOf(\u003cbr/\u003e    ScreenTransaction(Router.TodoListScreen.createFullPaneTrio(NoArgs))\u003cbr/\u003e  ),\u003cbr/\u003e  // shared state\u003cbr/\u003e  val todoListQuery: TodoList?,\u003cbr/\u003e) : ScreenFlowState\u0026lt;TodoFlowState, TodoFlowProps\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7299\"\u003eThis state is private to the TodoScreenFlow. However, the flow defines Props to share the TodoList data model, callbacks like a reloadList lambda, and a \u003ccode\u003eNavController\u003c/code\u003e with its children.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bd22\"\u003edata class TodoFlowProps(\u003cbr/\u003e  val navController: NavController\u0026lt;TodoFlowProps\u0026gt;,\u003cbr/\u003e  val todoListQuery: TodoList?,\u003cbr/\u003e  val reloadList: () -\u0026gt; Unit,\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f8c5\"\u003eThe \u003ccode\u003eNavController\u003c/code\u003e prop can be used by the children screens to push another sibling screen in the flow. The \u003ccode\u003eScreenFlowViewModel\u003c/code\u003e base class implements this \u003ccode\u003eNavController\u003c/code\u003e interface, managing the complexity of integrating the navigation actions into the screen flow’s state.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4da2\"\u003einterface NavController\u0026lt;PropsT\u0026gt;(\u003cbr/\u003e   fun push(router: TrioRouter\u0026lt;*, in PropsT\u0026gt;)\u003cbr/\u003e   fun pop()\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"71a5\"\u003eLastly, the navigation and shared state is wired into a flow of Props when the \u003ccode\u003eTodoScreenFlowViewModel\u003c/code\u003e overrides \u003ccode\u003ecreateFlowProps\u003c/code\u003e. This function will be invoked anytime the internal state of \u003ccode\u003eTodoScreenFlowViewModel\u003c/code\u003e changes, meaning any update to TodoList model will be propagated to the children screens.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"342a\"\u003eclass TodoScreenFlowViewModel(\u003cbr/\u003e  initializer: Initializer\u0026lt;NavPopProps, TodoFlowState\u0026gt;\u003cbr/\u003e) : ScreenFlowViewModel\u0026lt;NavPopProps, TodoFlowProps, TodoFlowState\u0026gt;(initializer) {\u003cp\u003e  override fun createFlowProps(\u003cbr/\u003e    state: TodoFlowState,\u003cbr/\u003e    props: NavPopProps\u003cbr/\u003e  ): TodoFlowProps {\u003cbr/\u003e    return TodoFlowProps(\u003cbr/\u003e      navController = this,\u003cbr/\u003e      state.todoListQuery,\u003cbr/\u003e      ::reloadList,\u003cbr/\u003e    )\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bf79\"\u003eInside one of the children screen’s ViewModels, we can see that it will receive the shared Props:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dd04\"\u003eclass TodoListViewModel(\u003cbr/\u003e  initializer: Initializer\u0026lt;TodoFlowProps, TodoListState\u0026gt;\u003cbr/\u003e) : TrioViewModel\u0026lt;TodoFlowProps, TodoListState\u0026gt;(initializer) {\u003cp\u003e  override fun updateStateFromPropsChange(\u003cbr/\u003e    newProps: TodoFlowProps, \u003cbr/\u003e    thisState: TodoTaskState\u003cbr/\u003e  ): TodoTaskState {\u003cbr/\u003e      // Incorporate the shared data model into this Trio’s private state passed to its UI:\u003cbr/\u003e      return thisState.copy(todoListQuery = newProps.todoListQuery)\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  fun navigateToTodoTask(task: TodoTask) {\u003cbr/\u003e    this.props.navController.push(Router.TodoTaskScreen, TodoTaskArgs(task.id))\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8ecf\"\u003eIn \u003ccode\u003enavigateToTodoTask\u003c/code\u003e, the \u003ccode\u003eNavController\u003c/code\u003e prepared by the flow parent is used to safely navigate to the next screen in the flow (guaranteeing it will receive the shared TodoFlowProps). Internally, the \u003ccode\u003eNavController\u003c/code\u003e updates the ScreenFlow’s \u003ccode\u003echildScreenTransactions\u003c/code\u003e triggering the ScreenFlow infra to provide the shared TodoFlowProps to the new screen, and render the new screen.\u003c/p\u003e\u003ch2 id=\"7e8b\"\u003eTrio’s Success at Airbnb\u003c/h2\u003e\u003ch2 id=\"bddd\"\u003eDevelopment history and launch\u003c/h2\u003e\u003cp id=\"a706\"\u003eWe started designing Trio in late 2021, with the first Trio screens seeing production traffic in mid 2022.\u003c/p\u003e\u003cp id=\"029d\"\u003eAs of March 2024, we now have over 230 Trio screens with significant production traffic at Airbnb.\u003c/p\u003e\u003cp id=\"5049\"\u003eFrom surveying our developers, we’ve heard that many of them enjoy the overall Trio experience; they like having clear and opinionated patterns and are happy to be in a pure Compose environment. As one developer put it, “Props was a huge plus by allowing multiple screens to share callbacks, which simplified some of my code logic a lot.” Another said, “Trio makes you unlearn bad habits and adopt best practices that work for Airbnb based on our past learnings.” Overall, our team reports faster development cycles and cleaner code. “It makes Android development faster and more enjoyable,” is how one engineer summed it up.\u003c/p\u003e\u003ch2 id=\"6333\"\u003eDev Tooling\u003c/h2\u003e\u003cp id=\"ed81\"\u003eTo support our engineers, we have invested in IDE tooling with an in-house Android Studio Plugin. It includes a Trio Generation tool that creates all of the files and boilerplate for a new Trio, including routing, mocks, and tests.\u003c/p\u003e\u003cp id=\"2ba0\"\u003eThe tool helps the user choose which Arguments and Props to use, and helps with other customization such as setting up custom Flows. It also allows us to embed educational experiences to help newcomers ramp up with Trio.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3f10\"\u003eOne piece of feedback we heard from engineers was that it was tedious to change a Trio’s Args or Props types, since they are used across many different files.\u003c/p\u003e\u003cp id=\"7c83\"\u003eWe leveraged our IDE plugin to provide a tool to automatically change these values, making this workflow much faster.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"902b\"\u003eOur team leans heavily on tooling like this, and we’ve found it to be very effective in improving the experience of engineers at Airbnb. We’ve adopted Compose Multiplatform for our Plugin UI development which we believe made building powerful developer tooling more feasible and enjoyable.\u003c/p\u003e\u003ch2 id=\"df11\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"58d6\"\u003eOverall, with more than 230 of our production screens implemented as Trios, Trio’s organic adoption at Airbnb has proven that many of our bets and design choices were worth the tradeoffs.\u003c/p\u003e\u003cp id=\"7e9f\"\u003eOne change we are anticipating, though, is to incorporate shared element transitions between screens once the Compose framework provides APIs to support that functionality. When Compose APIs for this are available, we’ll likely have to redesign our navigation APIs accordingly.\u003c/p\u003e\u003cp id=\"ab88\"\u003eThanks for following along with the work we’ve been doing at Airbnb. Our Android Platform team works on a variety of complex and interesting projects like Trio, and we’re excited to share more in the future.\u003c/p\u003e\u003cp id=\"64eb\"\u003eIf this kind of work sounds appealing to you, check out our \u003ca href=\"https://careers.airbnb.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eopen roles\u003c/a\u003e — we’re hiring!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2024-04-11T17:33:20.948Z",
  "modifiedTime": null
}
