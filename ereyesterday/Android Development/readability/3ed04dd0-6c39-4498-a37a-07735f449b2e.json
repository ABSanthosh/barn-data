{
  "id": "3ed04dd0-6c39-4498-a37a-07735f449b2e",
  "title": "Kotlin Multiplatform — How to improve the iOS development experience",
  "link": "https://proandroiddev.com/kotlin-multiplatform-how-to-improve-the-ios-development-experience-fa8cb2c1aa92?source=rss----c72404660798---4",
  "description": "",
  "author": "Guilherme Delgado",
  "published": "Fri, 01 Nov 2024 14:53:18 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "kotlin-multiplatform",
    "ios-app-development",
    "androiddev",
    "android"
  ],
  "byline": "Guilherme Delgado",
  "length": 18724,
  "excerpt": "Kotlin Multiplatform (KMP) is a key feature of the Kotlin language designed to facilitate code sharing between Android and iOS within the mobile development ecosystem.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Photo by Alex Rosario on UnsplashKotlin Multiplatform (KMP) is a key feature of the Kotlin language designed to facilitate code sharing between Android and iOS within the mobile development ecosystem. However, when focusing on the iOS side of development, there are specific challenges and considerations that can impact the overall experience for iOS developers.In this article, I will explore a range of helpful techniques aimed at improving the development workflow in KMP projects, particularly for iOS platform teams. By leveraging these insights, teams can achieve a more seamless integration between Kotlin and Swift, ultimately leading to more efficient and enjoyable development processes.I’ll use a sample project based on the Magic card game, to illustrate these approaches and apply the same architectural decisions.I’m also assuming the reader has knowledge about Kotlin, Swift and KMP.Golden ruleAlthough Kotlin and Swift share many syntactic similarities, their underlying architectures are different. We must keep in mind that adoption will always be more challenging for iOS, and therefore, we should be empathetic to the challenges this team may face. We must embrace these challenges as our own and be committed to find the best solutions.Starting pointOne key discussion was whether to opt for a single-module or multi-module approach and how to structure it.We chose a multi-module project structured by layers to ensure a clear separation of concerns across the UI, Domain (optional), and Data layers, which also highlights cross-platform similarities, enhancing collaboration and streamlining synchronised feature development across teams.The next discussion was about which layers would be shared. For example, should it be the Data Layer along with the UI Layer (state holders) or just the Data Layer? And which components within these layers — network, database, managers (repositories), models, view models, etc.?We chose to focus on sharing only the Data Layer. Perhaps the most commonly adopted approach and you’ll understand why.ArchitectureBy choosing to share only the Data Layer, it means that each platform will be fully responsible for implementing the UI and Domain Layers.*lightweight bridgeAlthough the Domain Layer could be optional, I will later explore the benefits of creating a lightweight Data Layer on iOS to align with the shared module’s Data Layer, where the Domain Layer will play an important role.Shared codeThe Data Layer of the applications will reside here, in the shared module. This is where we define our models, data providers (both local and remote) and data managers, which orchestrate these components.Each platform consumes this module just like they would with any other external dependency.Duplicated codeThe UI and Domain Layers of each application will reside within their respective modules. I’ll focus on the iOS implementation, and this will be its structure:Shared codeBased on our decisions, the shared module will also follow a gradle multi-module architecture. The modules data-models, core-database, and core-network are independent, while data-managers depends on all three. Each module is responsible for providing its own Dependency Injection (DI) logic, but the core-di module manages the root DI system, utilised by all platforms. This is why the core-di module depends on all other modules and will also contain the Objective-C framework settings.These five modules constitute the Data Layer.FacadeIt is important to ensure that the artefact each platform will consume is as optimised as possible in terms of size and content. To achieve this, there are several best practices available for this task. The CardsManager class implements the Facade design pattern to encapsulate and protect access to the internal core-database and core-network modules.Visibility ModifiersWe should leverage the internal modifier to ensure that functions, properties, classes, objects, and interfaces are only visible within the same module. In some cases, we may need to use the public modifier to make elements accessible to other Kotlin modules, but iOS doesn't necessarily need access to them. To exclude these from the iOS compilation, we can use the @HiddenFromObjC annotation which prevents a function or property from being exported.Framework settingsGiven that we’ve opted for a multi-module architecture with interdependencies between the modules, it’s crucial to apply specific techniques to ensure the final binary preserves these relationships in a readable manner. Currently, KMP has a limitation where each binary framework is compiled as a “closed world”. As a result, it’s impossible to pass custom types between two frameworks, even if they are identical in Kotlin.Let’s say I have two modules, shared and shared-models, each providing their own binary frameworks: Shared and SharedModels, respectively. The shared-models contains a data class Hello, and the shared module depends on shared-models with a public method that takes Hello as a parameter. When these modules are exported to Swift, we observe the following:Instead of:This means that the Shared framework includes all external dependencies from SharedModel and generates new types to reference those external types. As a result, we end up having Shared_modelsHello instead of just Hello.To address this limitation we need to bundle not only the classes from the current project but also the classes from its dependencies. To specify which dependencies to export to a binary, we use the export method. This ensures that the external types from dependent modules are correctly referenced, avoiding the duplication of types:Logically, this may increase the artefact size, which is why it’s crucial to take advantage of the techniques mentioned above. This is especially important considering that the core-database module uses the SQLDelight library, which generates all the database access code. The Facade pattern plays an important role preventing all of this code from being exported to the final binary.note: using export will also assist us with other tasks, I’ll elaborate on this as it becomes relevant in the following sections.KoinKoin is being used to manage DI in the project. As mentioned, core-di module unique responsibility is to manage the root DI system, utilised by all platforms, centralising its configuration and initialisation:By delegating each module the responsibility of providing its own DI setup through a public function — such as networkDiModule, databaseDiModule, and managersDiModule — we achieve a more lightweight Koin configuration. This approach allows us to access the DI of a specific module without needing to rely on the core-di module, which is particularly advantageous for testing scenarios where only certain dependencies are required.The previously mentioned framework technique of using export is also crucial for maintaining consistency between external types from dependent modules that will be used in iOS:dataManagers and dataModels will be accessible to the iosApp, so it is important to maintain type consistencyTestsWhen structuring our team, we can adopt a horizontal approach, where one team works on the shared module and another on the platforms, or we can take a vertical approach, where each team works on a feature from the shared module through to the platforms. Regardless of the chosen approach, it is imperative that the shared module is as thoroughly covered with (useful) tests as possible.As mentioned, each module is responsible for providing its own DI setup. Therefore, to test the core-database module, inside commonTest, I have the following:Which will be used:If I want to test my data-managers module, specifically the CardsManager class, one of its properties is a MagicDao instance. Although the data-managers module depends on the core-database module, we don’t have access to its commonTest folder, which prevents me from using the databaseDiTestModule() method in commonTest from data-managers. To work around this current limitation, I will replicate its initialisation in the commonMain folder, and as a result:With this approach, modules that depend on core-database can use databaseDiTestModule() and retrieve its test instance for use in theirs commonTest folders:all tests will be executed for each targetKotlin \u0026 Swift interoperabilitySince Kotlin primarily generates Objective-C code, Swift’s calls to Kotlin through Objective-C, can result in loss of critical Kotlin language features, such as:EnumsSealed classesCoroutines (concurrency)Default argsGenericsAndré Oriani wrote an excellent series of articles on this topic. Additionally, the Kotlin-Swift interopedia guide is also a valuable resource.Focusing on Coroutines, we have two brilliant community solutions: Rick Clephas’s KMP-NativeCoroutines (KMP-NC) library and the SKIE Gradle plugin from Touchlab. I’ll focus on the former, as it is the one I have used.Concurrency by KMP-NCKMP-NC solves two major limitations: lack of cancellation support for Kotlin suspend functions when converted to async function in Swift and the loss of generics on protocols in Objective-C. Since it generates code through KSP, the export configuration, as discussed previously, will play an important role in ensuring that the generated code uses the correct external types, thereby avoiding errors such as:Another thing to keep in mind are Exceptions. All Kotlin exceptions are unchecked, meaning that errors are caught at runtime. In contrast, Swift only has checked errors that must be handled at compile time. Therefore, if Swift or Objective-C code calls a Kotlin method that throws an exception, the Kotlin method should be marked with the @Throws annotation, specifying a list of \"expected\" exception classes.However, KMP-NC hides the original declaration and removes the @Throws from the generated functions since the generated functions are not designed to throw exceptions. The solution is straightforward: we create a public function that explicitly exposes the types of exceptions that may be thrown, thus adding them to the public API:Which will be converted to:Better ExceptionsIt is essential for platform teams to iterate over different error types and adjust their UI Layer logic accordingly. In Kotlin, it’s common practice to create a Result\u003cT\u003e sealed class, which represents either success or failure.When converted to Swift, we get:The problem with using Nothing as the error type is that it fails when attempting to retrieve the specific errors, such as in a Result\u003cNSArray\u003e:It occurs because ResultError and ResultSuccess\u003cNSArray\u003e do not share a direct inheritance or subtype relationship. To address this, we adapt Result to use a generic parameter for the error type too:The compiler will permit the conversion because both ResultError\u003cT\u003e and ResultSuccess\u003cT\u003e become generic instances of Result\u003cT\u003e. This establishes a more flexible relationship between the two types, enabling the cast to work correctly, making the following scenario possible:This way, the iOS team has access to the specific type of error returned by the Shared Data Layer, rather than simply handling a more generic Swift Error type in a do-catch statement.DocumentationTo provide the best development experience, documentation is also essential. We can leverage Kotlin’s documentation tool, KDoc, to streamline this. To export code documentation for iOS, simply add the following configuration to the iOS targets:Typical Javadoc’s block tag syntax:Will be exported to:It’s so simple that there’s really no excuse not to use it.So far, we have covered several techniques to enhance the iOS development experience, focusing on the development of the Shared Data Layer. Next, we will dive into specific techniques tailored for the iosApp, to fully leverage and benefit from what has been discussed up to this point.iosApp codeThe iOS app is also organised into layers. The App package serves as the entry point and includes the setup for DI. The Core defines the DI protocols and container. The Data acts as a bridge between the App’s Data Layer and the Shared Data Layer, where the implementation logic resides. The Domain contains the bridge protocols and data structures, and also the app protocols. Finally, the Presentation contains all the logic related to the UI Layer:package dependenciesDomainThis layer defines the protocols to be implemented by the Data Layer and used by the DI system, helping to minimize the reliance on concrete types from the Shared Data Layer. This approach establishes a clear boundary for communication with the MagicDataLayer, ensuring that it is concentrated within the Data Layer (acting as a bridge) and not spread across other layers of the application, such as the UI Layer.Inside the Domain package, there is a DomainProtocols library containing a DomainBridge file, where these “bridge protocols” are defined:DomainProtocols libraryThese protocols will be used as extensions, allowing concrete types to be referred to by their “domain types.” I’ll demonstrate this shortly.There is also a CardDomain library, which contains the protocols that will have concrete implementations:CardDomain libraryDataThis layer is responsible for implementing the Domain protocols and bridging them with the corresponding Shared Data Layer types. To achieve this, I’ve created a DataBridge file within a DataExtensions library, as shown bellow:DataExtensions libraryThe MagicDataLayer contains types such as KotlinThrowable, RateLimitException, Card, CardSet, and CardsManager. Swift’s ability to extend a class and make it conform to our “domain type” is incredibly useful. From now on, for instance, whenever we need to reference a Card, we’ll use its DomainCard alias type instead (interface).Lastly, we also have a CardData library, where we will implement the concrete versions of the protocols provided by CardDomain.The CardsManager will conform to the DomainCardsManagerProtocol to prevent direct access. Instead, the protocol should be used for interaction.The relationship established between the Domain, Data, and Shared Data Layers is crucial for ensuring that dependencies on Shared types are not scattered across all layers. It allows us to leverage a DI system to inject the necessary types where and when needed. For example, the platform team can continue developing the UI Layer using mocks, while the Shared team progresses with their work.If we think about it, this approach isn’t exclusive to KMP; it also applies to any Swift 3rd-party library we use, or even those we develop ourselves. It also provides a testable architecture.PresentationThe same philosophy applies to this layer: its classes will have dependencies built based on protocols from the Domain Layer, and the DI system will be responsible for providing the desired instances.The DomainCardManagerProtocol instance can be either mocked or real, as demonstrated in the following section.Dependency InjectionSo far, we’ve discussed the importance of layering our code to contain dependencies on shared types. Now, let’s delve into how we can efficiently utilize a DI system to provide the required instances.The Core package contains two libraries: the DI where a DIContainer is defined, and the FactoryProtocols with the following:The App will be responsible for creating factories for each type needed. For instance, CardsManagerFactory:This setup allows for easy switching between different types:Packages and Build PhasesThe project’s structure was established using Swift Package Manager (SPM) allowing us to have a package for each layer:The MagicDataLayer will be integrated by the app’s target Build Phase “Compile Kotlin Framework” script:But there’s a catch. SPM will try to resolve its dependencies before the Build Phase, which means that packages depending on the MagicDataLayer will fail, since the Build Phase will only run after. This situations arise when no build cache exists or if the Derived Data is cleared. We can solve this situation by replicating this Build Phase script in the app’s scheme Build step by adding a Pre-actions Run Script:This process ensures proper resolution of SPM packages.This concludes our exploration of techniques, from Shared code to iosApp code, aimed at enhancing the developer experience for iOS platform teams. However, before we wrap up, there’s an important point to mention regarding a key player in this process. The team as a whole.TeamThe technology behind KMP has already proven its worth. While it still has its specificities in certain cases, which will continue to improve, what will ultimately determine its success is how teams utilize it, and in turn, the experiences, benefits, and frustrations they derive from it.The iOS team’s buy-in is easier to achieve nowadays, and this article aims to share a few techniques to make that process even smoother.Our conclusion is that communication is the most critical factor for team success. The development process will need to be more rigorous, particularly regarding planning tasks and establishing clear contracts between teams. We can draw a parallel with what is already done (or should be done) between front-end and back-end teams. The difference now is that, since the mobile team has unified, this also needs to happen within the team itself, while continuing to maintain communication externally as well.I believe this will be the key to success.ConclusionIn this article, we’ve explored various strategies and techniques for improving the iOS developer experience when working with KMP. By focusing on key areas such as project architecture, dependency injection, and Kotlin-Swift interoperability, teams can overcome many of the common challenges encountered in KMP projects. The clear separation of layers and careful management of dependencies not only simplify the development process but also allow both iOS and Android teams to work more independently while maintaining shared functionality.Ultimately, the success of KMP hinges not only on the technology itself but on how effectively teams collaborate and communicate. A well-coordinated approach — fostering strong communication and defining clear boundaries — ensures that both platform-specific and shared modules work harmoniously together. With the continuous evolution of KMP, it’s clear that the potential for further improvements is vast, and adopting these practices will help teams create more streamlined and enjoyable workflows.I hope the insights shared here will help create a smoother integration process for your iOS teams.As always, I hope you find this article useful, thanks for reading. You can explore these strategies in the playground available here:",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*Bws7VrO8g4stQiCh",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://guidelgado.medium.com/?source=post_page---byline--fa8cb2c1aa92--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Guilherme Delgado\" src=\"https://miro.medium.com/v2/resize:fill:88:88/2*fWLrK3qpZDT_4-06Lq-xYw.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--fa8cb2c1aa92--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@samalex?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAlex Rosario\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"4f34\"\u003eKotlin Multiplatform (KMP) is a key feature of the Kotlin language designed to facilitate code sharing between Android and iOS within the mobile development ecosystem. However, when focusing on the iOS side of development, there are specific challenges and considerations that can impact the overall experience for iOS developers.\u003c/p\u003e\u003cp id=\"f83e\"\u003eIn this article, I will explore a range of helpful techniques aimed at improving the development workflow in KMP projects, particularly for iOS platform teams. By leveraging these insights, teams can achieve a more seamless integration between Kotlin and Swift, ultimately leading to more efficient and enjoyable development processes.\u003c/p\u003e\u003cp id=\"49e1\"\u003eI’ll use a sample project based on the \u003ca href=\"https://en.wikipedia.org/wiki/Magic:_The_Gathering\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMagic\u003c/a\u003e card game, to illustrate these approaches and apply the same architectural decisions.\u003c/p\u003e\u003cp id=\"a334\"\u003eI’m also assuming the reader has knowledge about \u003ca href=\"https://kotlinlang.org/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin\u003c/a\u003e\u003cem\u003e, \u003c/em\u003e\u003ca href=\"https://developer.apple.com/swift/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSwift\u003c/a\u003e and \u003ca href=\"https://www.jetbrains.com/kotlin-multiplatform/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKMP\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f28e\"\u003eGolden rule\u003c/h2\u003e\u003cp id=\"1309\"\u003eAlthough Kotlin and Swift share many syntactic similarities, their underlying architectures are different. We must keep in mind that adoption will always be more challenging for iOS, and therefore, we should be empathetic to the challenges this team may face. We must embrace these challenges as \u003cstrong\u003eour own\u003c/strong\u003e and be committed to find the best solutions.\u003c/p\u003e\u003ch2 id=\"c386\"\u003eStarting point\u003c/h2\u003e\u003cp id=\"4776\"\u003eOne key discussion was whether to opt for a single-module or multi-module approach and how to structure it.\u003c/p\u003e\u003cp id=\"6e81\"\u003eWe chose a multi-module project structured by layers to ensure a clear separation of concerns across the UI, Domain (optional), and Data layers, which also highlights cross-platform similarities, enhancing collaboration and streamlining synchronised feature development across teams.\u003c/p\u003e\u003cp id=\"4488\"\u003eThe next discussion was about which layers would be shared. For example, should it be the Data Layer along with the UI Layer (state holders) or just the Data Layer? And which components within these layers — network, database, managers (repositories), models, view models, etc.?\u003c/p\u003e\u003cp id=\"1126\"\u003eWe chose to focus on sharing \u003cstrong\u003eonly the Data Layer\u003c/strong\u003e. Perhaps the most commonly adopted approach and you’ll understand why.\u003c/p\u003e\u003ch2 id=\"d71e\"\u003eArchitecture\u003c/h2\u003e\u003cp id=\"5614\"\u003eBy choosing to share only the Data Layer, it means that each platform will be fully responsible for implementing the UI and Domain Layers.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e*lightweight bridge\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"1b0c\"\u003eAlthough the Domain Layer could be optional, I will later explore the benefits of creating a lightweight Data Layer on iOS to align with the shared module’s Data Layer, where the Domain Layer will play an important role.\u003c/p\u003e\u003ch2 id=\"6763\"\u003eShared code\u003c/h2\u003e\u003cp id=\"a78d\"\u003eThe Data Layer of the applications will reside here, in the \u003cstrong\u003eshared\u003c/strong\u003e module. This is where we define our models, data providers (both local and remote) and data managers, which orchestrate these components.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e824\"\u003eEach platform consumes this module just like they would with any other external dependency.\u003c/p\u003e\u003ch2 id=\"863e\"\u003eDuplicated code\u003c/h2\u003e\u003cp id=\"9e6f\"\u003eThe UI and Domain Layers of \u003cstrong\u003eeach application\u003c/strong\u003e will reside within \u003cstrong\u003etheir respective\u003c/strong\u003e modules. I’ll focus on the iOS implementation, and this will be its structure:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"5f3f\"\u003eShared code\u003c/h2\u003e\u003cp id=\"66d7\"\u003eBased on our decisions, the shared module will also follow a \u003ca href=\"https://docs.gradle.org/current/userguide/intro_multi_project_builds.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003egradle multi-module\u003c/a\u003e architecture. The modules \u003ccode\u003edata-models\u003c/code\u003e, \u003ccode\u003ecore-database\u003c/code\u003e, and \u003ccode\u003ecore-network\u003c/code\u003e are independent, while \u003ccode\u003edata-managers\u003c/code\u003e depends on all three. Each module is responsible for providing its own \u003ca href=\"https://en.wikipedia.org/wiki/Dependency_injection\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDependency Injection\u003c/a\u003e (DI) logic, but the \u003ccode\u003ecore-di\u003c/code\u003e module manages the root DI system, utilised by all platforms. This is why the \u003ccode\u003ecore-di\u003c/code\u003e module depends on all other modules and will also contain the Objective-C framework settings.\u003c/p\u003e\u003cp id=\"05c1\"\u003eThese five modules constitute the Data Layer.\u003c/p\u003e\u003ch2 id=\"b513\"\u003e\u003cstrong\u003eFacade\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"67a8\"\u003eIt is important to ensure that the artefact each platform will consume is as optimised as possible in terms of size and content. To achieve this, there are several best practices available for this task. The \u003ccode\u003eCardsManager\u003c/code\u003e class implements the \u003ca href=\"https://en.wikipedia.org/wiki/Facade_pattern\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFacade\u003c/a\u003e design pattern to encapsulate and protect access to the internal \u003ccode\u003ecore-database\u003c/code\u003e and \u003ccode\u003ecore-network\u003c/code\u003e modules.\u003c/p\u003e\u003ch2 id=\"f1f3\"\u003e\u003cstrong\u003eVisibility Modifiers\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"e2ba\"\u003eWe should leverage the \u003ccode\u003einternal\u003c/code\u003e \u003ca href=\"https://kotlinlang.org/docs/visibility-modifiers.html#class-members\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003emodifier\u003c/a\u003e to ensure that functions, properties, classes, objects, and interfaces are only visible within the same module. In some cases, we may need to use the \u003ccode\u003epublic\u003c/code\u003e modifier to make elements accessible to other Kotlin modules, but iOS doesn\u0026#39;t necessarily need access to them. To exclude these from the iOS compilation, we can use the \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/docs/native-objc-interop.html#hide-kotlin-declarations-from-objective-c-and-swift\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@HiddenFromObjC\u003c/a\u003e\u003c/code\u003e annotation which prevents a function or property from being exported.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"50f2\"\u003eFramework settings\u003c/h2\u003e\u003cp id=\"e442\"\u003eGiven that we’ve opted for a multi-module architecture with interdependencies between the modules, it’s crucial to apply specific techniques to ensure the final binary preserves these relationships in a readable manner. Currently, KMP has a limitation where each binary framework is compiled as a “closed world”. As a result, it’s impossible to pass custom types between two frameworks, even if they are identical in Kotlin.\u003c/p\u003e\u003cp id=\"f820\"\u003eLet’s say I have two modules, \u003ccode\u003eshared\u003c/code\u003e and \u003ccode\u003eshared-models\u003c/code\u003e, each providing their own binary frameworks: \u003cem\u003eShared\u003c/em\u003e and \u003cem\u003eSharedModels\u003c/em\u003e, respectively. The \u003ccode\u003eshared-models\u003c/code\u003e contains a \u003ccode\u003edata class Hello\u003c/code\u003e, and the \u003ccode\u003eshared\u003c/code\u003e module depends on \u003ccode\u003eshared-models\u003c/code\u003e with a public method that takes \u003ccode\u003eHello\u003c/code\u003e as a parameter. When these modules are exported to Swift, we observe the following:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"aaa2\"\u003eInstead of:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"47bf\"\u003eThis means that the \u003cem\u003eShared\u003c/em\u003e framework includes all external dependencies from \u003cem\u003eSharedModel\u003c/em\u003e and generates new types to reference those external types. As a result, we end up having \u003ccode\u003eShared_modelsHello\u003c/code\u003e instead of just \u003ccode\u003eHello\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"613a\"\u003eTo address this limitation we need to bundle not only the classes from the current project but also the classes from its dependencies. To specify which dependencies to \u003ca href=\"https://kotlinlang.org/docs/multiplatform-build-native-binaries.html#export-dependencies-to-binaries\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eexport to a binary\u003c/a\u003e, we use the \u003ccode\u003eexport\u003c/code\u003e method. This ensures that the external types from dependent modules are correctly referenced, avoiding the duplication of types:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e7e1\"\u003eLogically, this may increase the artefact size, which is why it’s crucial to take advantage of the techniques mentioned above. This is especially important considering that the \u003ccode\u003ecore-database\u003c/code\u003e module uses the \u003ca href=\"https://github.com/sqldelight/sqldelight\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSQLDelight\u003c/a\u003e library, which generates all the database access code. The Facade pattern plays an important role preventing all of this code from being exported to the final binary.\u003c/p\u003e\u003cp id=\"3e03\"\u003e\u003cstrong\u003enote:\u003c/strong\u003e using \u003ccode\u003eexport\u003c/code\u003e will also assist us with other tasks, I’ll elaborate on this as it becomes relevant in the following sections.\u003c/p\u003e\u003ch2 id=\"90c0\"\u003eKoin\u003c/h2\u003e\u003cp id=\"465d\"\u003e\u003ca href=\"https://github.com/InsertKoinIO/koin\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKoin\u003c/a\u003e is being used to manage DI in the project. As mentioned, \u003ccode\u003ecore-di\u003c/code\u003e module unique responsibility is to manage the root DI system, utilised by all platforms, centralising its configuration and initialisation:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"24ff\"\u003eBy delegating each module the responsibility of providing its own DI setup through a public function — such as \u003ccode\u003enetworkDiModule\u003c/code\u003e, \u003ccode\u003edatabaseDiModule\u003c/code\u003e, and \u003ccode\u003emanagersDiModule\u003c/code\u003e — we achieve a more lightweight Koin configuration. This approach allows us to access the DI of a specific module without needing to rely on the \u003ccode\u003ecore-di\u003c/code\u003e module, which is particularly advantageous for testing scenarios where only certain dependencies are required.\u003c/p\u003e\u003cp id=\"1d64\"\u003eThe previously mentioned framework technique of using \u003ccode\u003eexport\u003c/code\u003e is also crucial for maintaining consistency between external types from dependent modules that will be used in iOS:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ccode\u003edataManagers\u003c/code\u003e and \u003ccode\u003edataModels\u003c/code\u003e will be accessible to the \u003ccode\u003eiosApp\u003c/code\u003e, so it is important to maintain type consistency\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"032b\"\u003eTests\u003c/h2\u003e\u003cp id=\"6173\"\u003eWhen structuring our team, we can adopt a horizontal approach, where one team works on the shared module and another on the platforms, or we can take a vertical approach, where each team works on a feature from the shared module through to the platforms. Regardless of the chosen approach, it is imperative that the shared module is as thoroughly covered with (useful) tests as possible.\u003c/p\u003e\u003cp id=\"e1e1\"\u003eAs mentioned, each module is responsible for providing its own DI setup. Therefore, to test the \u003ccode\u003ecore-database\u003c/code\u003e module, inside \u003ccode\u003e\u003cstrong\u003ecommonTest\u003c/strong\u003e\u003c/code\u003e, I have the following:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"62b8\"\u003eWhich will be used:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0632\"\u003eIf I want to test my \u003ccode\u003edata-managers\u003c/code\u003e module, specifically the \u003ccode\u003eCardsManager\u003c/code\u003e class, one of its properties is a \u003ccode\u003eMagicDao\u003c/code\u003e instance. Although the \u003ccode\u003edata-managers\u003c/code\u003e module depends on the \u003ccode\u003ecore-database\u003c/code\u003e module, we don’t have access to its \u003ccode\u003e\u003cstrong\u003ecommonTest\u003c/strong\u003e\u003c/code\u003e folder, which prevents me from using the \u003ccode\u003edatabaseDiTestModule()\u003c/code\u003e method in \u003ccode\u003e\u003cstrong\u003ecommonTest\u003c/strong\u003e\u003c/code\u003e from \u003ccode\u003edata-managers\u003c/code\u003e. To work around this \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-63142/Add-support-for-Gradle-Test-Fixtures-in-non-JVM-platforms\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecurrent limitation\u003c/a\u003e, I will replicate its initialisation in the \u003ccode\u003e\u003cstrong\u003ecommonMain\u003c/strong\u003e\u003c/code\u003e folder, and as a result:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7ec7\"\u003eWith this approach, modules that depend on \u003ccode\u003ecore-database\u003c/code\u003e can use \u003ccode\u003edatabaseDiTestModule()\u003c/code\u003e and retrieve its test instance for use in theirs \u003ccode\u003e\u003cstrong\u003ecommonTest\u003c/strong\u003e\u003c/code\u003e folders:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003eall tests will be executed for each target\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"4587\"\u003eKotlin \u0026amp; Swift interoperability\u003c/h2\u003e\u003cp id=\"5733\"\u003eSince Kotlin primarily generates Objective-C code, Swift’s calls to Kotlin through Objective-C, can result in loss of critical Kotlin \u003ca href=\"https://kotlinlang.org/docs/native-objc-interop.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003elanguage features\u003c/a\u003e, such as:\u003c/p\u003e\u003cul\u003e\u003cli id=\"2693\"\u003eEnums\u003c/li\u003e\u003cli id=\"6297\"\u003eSealed classes\u003c/li\u003e\u003cli id=\"97d4\"\u003eCoroutines (concurrency)\u003c/li\u003e\u003cli id=\"e9aa\"\u003eDefault args\u003c/li\u003e\u003cli id=\"d7e0\"\u003eGenerics\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9a60\"\u003e\u003cspan\u003e\u003cspan aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/u/ff994e62abd3?source=post_page---user_mention--fa8cb2c1aa92--------------------------------\" rel=\"noopener\" target=\"_blank\"\u003eAndré Oriani\u003c/a\u003e\u003c/span\u003e\u003c/span\u003e wrote an excellent \u003ca href=\"https://medium.com/@aoriani/list/writing-swiftfriendly-kotlin-multiplatform-apis-c51c2b317fce\" rel=\"noopener\"\u003eseries of articles\u003c/a\u003e on this topic. Additionally, the \u003ca href=\"https://github.com/kotlin-hands-on/kotlin-swift-interopedia\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin-Swift interopedia\u003c/a\u003e guide is also a valuable resource.\u003c/p\u003e\u003cp id=\"8ebb\"\u003eFocusing on \u003ca href=\"https://kotlinlang.org/docs/coroutines-overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoroutines\u003c/a\u003e, we have two brilliant community solutions: \u003ca href=\"https://github.com/rickclephas\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRick Clephas’s\u003c/a\u003e \u003ca href=\"https://github.com/rickclephas/KMP-NativeCoroutines\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eKMP-NativeCoroutines\u003c/strong\u003e\u003c/a\u003e (KMP-NC) library and the \u003ca href=\"https://skie.touchlab.co/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eSKIE\u003c/strong\u003e\u003c/a\u003e Gradle plugin from \u003cspan\u003e\u003cspan aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/u/5452db97c933?source=post_page---user_mention--fa8cb2c1aa92--------------------------------\" rel=\"noopener\" target=\"_blank\"\u003eTouchlab\u003c/a\u003e\u003c/span\u003e\u003c/span\u003e. I’ll focus on the former, as it is the one I have used.\u003c/p\u003e\u003ch2 id=\"0490\"\u003eConcurrency by KMP-NC\u003c/h2\u003e\u003cp id=\"3952\"\u003eKMP-NC solves two major limitations: lack of cancellation support for Kotlin suspend functions when converted to async function in Swift and the loss of generics on protocols in Objective-C. Since it generates code through \u003ca href=\"https://kotlinlang.org/docs/ksp-overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKSP\u003c/a\u003e, the \u003ccode\u003eexport\u003c/code\u003e configuration, as discussed previously, will play an important role in ensuring that the generated code uses the correct external types, thereby avoiding errors such as:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"6e9b\"\u003eAnother thing to keep in mind are \u003ca href=\"https://kotlinlang.org/docs/native-objc-interop.html#errors-and-exceptions\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eExceptions\u003c/a\u003e. All Kotlin exceptions are unchecked, meaning that errors are caught at runtime. In contrast, Swift only has checked errors that must be handled at compile time. Therefore, if Swift or Objective-C code calls a Kotlin method that throws an exception, the Kotlin method should be marked with the \u003ccode\u003e@Throws\u003c/code\u003e annotation, specifying a list of \u0026#34;expected\u0026#34; exception classes.\u003c/p\u003e\u003cp id=\"8af7\"\u003eHowever, KMP-NC hides the original declaration and removes the \u003ccode\u003e@Throws\u003c/code\u003e from the generated functions since the generated functions are not designed to throw exceptions. The solution is straightforward: we create a public function that explicitly exposes the types of exceptions that may be thrown, thus adding them to the public API:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"04b1\"\u003eWhich will be converted to:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"a576\"\u003eBetter Exceptions\u003c/h2\u003e\u003cp id=\"d022\"\u003eIt is essential for platform teams to iterate over different error types and adjust their UI Layer logic accordingly. In Kotlin, it’s common practice to create a \u003ccode\u003eResult\u0026lt;T\u0026gt;\u003c/code\u003e \u003ca href=\"https://kotlinlang.org/docs/sealed-classes.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esealed class\u003c/a\u003e, which represents either success or failure.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a8ba\"\u003eWhen converted to Swift, we get:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"866d\"\u003eThe problem with using \u003ccode\u003eNothing\u003c/code\u003e as the error type is that it fails when attempting to retrieve the specific errors, such as in a \u003ccode\u003eResult\u0026lt;NSArray\u0026gt;\u003c/code\u003e:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ea4b\"\u003eIt occurs because \u003ccode\u003eResultError\u003c/code\u003e and \u003ccode\u003eResultSuccess\u0026lt;NSArray\u0026gt;\u003c/code\u003e do not share a direct inheritance or subtype relationship. To address this, we adapt \u003ccode\u003eResult\u003c/code\u003e to use a generic parameter for the error type too:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7cc1\"\u003eThe compiler will permit the conversion because both \u003ccode\u003eResultError\u0026lt;T\u0026gt;\u003c/code\u003e and \u003ccode\u003eResultSuccess\u0026lt;T\u0026gt;\u003c/code\u003e become generic instances of \u003ccode\u003eResult\u0026lt;T\u0026gt;\u003c/code\u003e. This establishes a more flexible relationship between the two types, enabling the cast to work correctly, making the following scenario possible:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7ad2\"\u003eThis way, the iOS team has access to the specific type of error returned by the Shared Data Layer, rather than simply handling a more generic Swift \u003ccode\u003eError\u003c/code\u003e type in a \u003ccode\u003edo-catch\u003c/code\u003e statement.\u003c/p\u003e\u003ch2 id=\"2997\"\u003eDocumentation\u003c/h2\u003e\u003cp id=\"31af\"\u003eTo provide the best development experience, documentation is also essential. We can leverage Kotlin’s documentation tool, \u003ca href=\"https://kotlinlang.org/docs/kotlin-doc.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKDoc\u003c/a\u003e, to streamline this. To export code documentation for iOS, simply add the following configuration to the iOS targets:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b05e\"\u003eTypical Javadoc’s block tag syntax:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"549a\"\u003eWill be exported to:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"4cdf\"\u003eIt’s so simple that there’s really no excuse not to use it.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"0627\"\u003eSo far, we have covered several techniques to enhance the iOS development experience, focusing on the development of the \u003cstrong\u003eShared Data Layer\u003c/strong\u003e. Next, we will dive into specific techniques tailored for the iosApp, to fully leverage and benefit from what has been discussed up to this point.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d26c\"\u003eiosApp code\u003c/h2\u003e\u003cp id=\"98e2\"\u003eThe iOS app is also organised into layers. The \u003ccode\u003eApp\u003c/code\u003e package serves as the entry point and includes the setup for DI. The \u003ccode\u003eCore\u003c/code\u003e defines the DI protocols and container. The \u003ccode\u003eData\u003c/code\u003e acts as a bridge between the App’s Data Layer and the Shared Data Layer, where the implementation logic resides. The \u003ccode\u003eDomain\u003c/code\u003e contains the bridge protocols and data structures, and also the app protocols. Finally, the \u003ccode\u003ePresentation\u003c/code\u003e contains all the logic related to the UI Layer:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003epackage dependencies\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"6f21\"\u003eDomain\u003c/h2\u003e\u003cp id=\"416b\"\u003eThis layer defines the protocols to be implemented by the Data Layer and used by the DI system, helping to minimize the reliance on concrete types from the Shared Data Layer. This approach establishes a clear boundary for communication with the \u003ccode\u003eMagicDataLayer\u003c/code\u003e, ensuring that it is concentrated within the Data Layer (acting as a bridge) and not spread across other layers of the application, such as the UI Layer.\u003c/p\u003e\u003cp id=\"91ac\"\u003eInside the \u003ccode\u003eDomain\u003c/code\u003e package, there is a \u003ccode\u003eDomainProtocols\u003c/code\u003e library containing a \u003ccode\u003eDomainBridge\u003c/code\u003e file, where these “bridge protocols” are defined:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ccode\u003eDomainProtocols\u003c/code\u003e library\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"06c7\"\u003eThese protocols will be used as \u003ccode\u003eextensions\u003c/code\u003e, allowing concrete types to be referred to by their “domain types.” I’ll demonstrate this shortly.\u003c/p\u003e\u003cp id=\"30ca\"\u003eThere is also a \u003ccode\u003eCardDomain\u003c/code\u003e library, which contains the protocols that will have concrete implementations:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ccode\u003eCardDomain\u003c/code\u003e library\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"0cf7\"\u003eData\u003c/h2\u003e\u003cp id=\"159e\"\u003eThis layer is responsible for implementing the \u003ccode\u003eDomain\u003c/code\u003e protocols and bridging them with the corresponding Shared Data Layer types. To achieve this, I’ve created a \u003ccode\u003eDataBridge\u003c/code\u003e file within a \u003ccode\u003eDataExtensions\u003c/code\u003e library, as shown bellow:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ccode\u003eDat\u003c/code\u003eaExtensions library\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"8bbd\"\u003eThe \u003ccode\u003eMagicDataLayer\u003c/code\u003e contains types such as \u003ccode\u003eKotlinThrowable\u003c/code\u003e, \u003ccode\u003eRateLimitException\u003c/code\u003e, \u003ccode\u003eCard\u003c/code\u003e, \u003ccode\u003eCardSet\u003c/code\u003e, and \u003ccode\u003eCardsManager\u003c/code\u003e. Swift’s ability to extend a class and make it conform to our “domain type” is incredibly useful. From now on, for instance, whenever we need to reference a \u003ccode\u003eCard\u003c/code\u003e, we’ll use its \u003ccode\u003eDomainCard\u003c/code\u003e alias type instead (interface).\u003c/p\u003e\u003cp id=\"77b1\"\u003eLastly, we also have a \u003ccode\u003eCardData\u003c/code\u003e library, where we will implement the concrete versions of the protocols provided by \u003ccode\u003eCardDomain\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003eThe \u003ccode\u003eCardsManager\u003c/code\u003e will conform to the \u003ccode\u003eDomainCardsManagerProtocol\u003c/code\u003e to prevent direct access. Instead, the protocol should be used for interaction.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"6ddf\"\u003eThe relationship established between the Domain, Data, and Shared Data Layers is crucial for ensuring that dependencies on Shared types are not scattered across all layers. It allows us to leverage a DI system to inject the necessary types where and when needed. For example, the platform team can continue developing the UI Layer using mocks, while the Shared team progresses with their work.\u003c/p\u003e\u003cp id=\"933b\"\u003eIf we think about it, this approach isn’t exclusive to KMP; it also applies to any Swift 3rd-party library we use, or even those we develop ourselves. It also provides a testable architecture.\u003c/p\u003e\u003ch2 id=\"23b6\"\u003ePresentation\u003c/h2\u003e\u003cp id=\"278d\"\u003eThe same philosophy applies to this layer: its classes will have dependencies built based on protocols from the Domain Layer, and the DI system will be responsible for providing the desired instances.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9b02\"\u003eThe \u003ccode\u003eDomainCardManagerProtocol\u003c/code\u003e instance can be either mocked or real, as demonstrated in the following section.\u003c/p\u003e\u003ch2 id=\"1525\"\u003eDependency Injection\u003c/h2\u003e\u003cp id=\"f093\"\u003eSo far, we’ve discussed the importance of layering our code to contain dependencies on shared types. Now, let’s delve into how we can efficiently utilize a DI system to provide the required instances.\u003c/p\u003e\u003cp id=\"6860\"\u003eThe \u003ccode\u003eCore\u003c/code\u003e package contains two libraries: the \u003ccode\u003eDI\u003c/code\u003e where a \u003ccode\u003eDIContainer\u003c/code\u003e is defined, and the \u003ccode\u003eFactoryProtocols\u003c/code\u003e with the following:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5ed4\"\u003eThe \u003ccode\u003eApp\u003c/code\u003e will be responsible for creating factories for each type needed. For instance, \u003ccode\u003eCardsManagerFactory\u003c/code\u003e:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ea37\"\u003eThis setup allows for easy switching between different types:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"59da\"\u003ePackages and Build Phases\u003c/h2\u003e\u003cp id=\"14ee\"\u003eThe project’s structure was established using \u003ca href=\"https://www.swift.org/documentation/package-manager/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSwift Package Manager\u003c/a\u003e (SPM) allowing us to have a package for each layer:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7ef3\"\u003eThe \u003ccode\u003eMagicDataLayer\u003c/code\u003e will be integrated by the app’s target \u003ca href=\"https://developer.apple.com/documentation/xcode/running-custom-scripts-during-a-build\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBuild Phase\u003c/a\u003e “Compile Kotlin Framework” script:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"6237\"\u003eBut there’s a catch. SPM will try to resolve its dependencies before the Build Phase, which means that packages depending on the \u003ccode\u003eMagicDataLayer\u003c/code\u003e will fail, since the Build Phase will only run after. This situations arise when no build cache exists or if the Derived Data is cleared. We can solve this situation by replicating this Build Phase script in the app’s scheme Build step by adding a Pre-actions Run Script:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"8409\"\u003eThis process ensures proper resolution of SPM packages.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"3961\"\u003eThis concludes our exploration of techniques, from Shared code to iosApp code, aimed at enhancing the developer experience for iOS platform teams. However, before we wrap up, there’s an important point to mention regarding a key player in this process. The team as a whole.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"fbd8\"\u003eTeam\u003c/h2\u003e\u003cp id=\"58dd\"\u003eThe technology behind KMP has already proven its worth. While it still has its specificities in certain cases, which will \u003ca href=\"https://blog.jetbrains.com/kotlin/2024/10/kotlin-multiplatform-development-roadmap-for-2025/#kotlin-to-swift-export\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003econtinue to improve\u003c/a\u003e, what will ultimately determine its success is how teams utilize it, and in turn, the experiences, benefits, and frustrations they derive from it.\u003c/p\u003e\u003cp id=\"6e37\"\u003eThe iOS team’s buy-in is easier to achieve nowadays, and this article aims to share a few techniques to make that process even smoother.\u003c/p\u003e\u003cp id=\"bacc\"\u003eOur conclusion is that communication is the most critical factor for team success. The development process will need to be more rigorous, particularly regarding planning tasks and establishing clear contracts between teams. We can draw a parallel with what is already done (or should be done) between front-end and back-end teams. The difference now is that, since the mobile team has unified, this also needs to happen within the team itself, while continuing to maintain communication externally as well.\u003c/p\u003e\u003cp id=\"0440\"\u003eI believe this will be the key to success.\u003c/p\u003e\u003ch2 id=\"eb76\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"30c9\"\u003eIn this article, we’ve explored various strategies and techniques for improving the iOS developer experience when working with KMP. By focusing on key areas such as project architecture, dependency injection, and \u003ca href=\"https://blog.jetbrains.com/kotlin/2024/10/kotlin-multiplatform-development-roadmap-for-2025/#kotlin-to-swift-export\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin-Swift interoperability\u003c/a\u003e, teams can overcome many of the common challenges encountered in KMP projects. The clear separation of layers and careful management of dependencies not only simplify the development process but also allow both iOS and Android teams to work more independently while maintaining shared functionality.\u003c/p\u003e\u003cp id=\"6c51\"\u003eUltimately, the success of KMP hinges not only on the technology itself but on how effectively teams collaborate and communicate. A well-coordinated approach — fostering strong communication and defining clear boundaries — ensures that both platform-specific and shared modules work harmoniously together. With the continuous evolution of KMP, it’s clear that the potential for further improvements is vast, and adopting these practices will help teams create more streamlined and enjoyable workflows.\u003c/p\u003e\u003cp id=\"40b4\"\u003eI hope the insights shared here will help create a smoother integration process for your iOS teams.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"0f61\"\u003eAs always, I hope you find this article useful, thanks for reading. You can explore these strategies in the playground available here:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2024-11-01T14:53:18.365Z",
  "modifiedTime": null
}
