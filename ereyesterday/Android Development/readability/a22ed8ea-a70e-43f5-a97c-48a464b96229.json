{
  "id": "a22ed8ea-a70e-43f5-a97c-48a464b96229",
  "title": "SnapshotFlow or collectAsState? How to pick the right tool for Jetpack Compose",
  "link": "https://proandroiddev.com/snapshotflow-or-collectasstate-how-to-pick-the-right-tool-for-jetpack-compose-d6f1cc9d2123?source=rss----c72404660798---4",
  "description": "",
  "author": "Dmitry Glazunov",
  "published": "Mon, 07 Jul 2025 15:37:04 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "jetpack-compose",
    "development",
    "tools",
    "software-engineering"
  ],
  "byline": "Dmitry Glazunov",
  "length": 4375,
  "excerpt": "Building UIs can feel easy until it’s time to subscribe to state changes and handle side-effects effectively. Many developers overuse collectAsState everywhere, leading to lags and unexpected…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Photo by Anton Savinov on UnsplashBuilding UIs can feel easy until it’s time to subscribe to state changes and handle side-effects effectively. Many developers overuse collectAsState everywhere, leading to lags and unexpected recompositions. Others have heard of snapshotFlow but don’t understand why it’s needed if StateFlow and collectAsState already exist.In this small article, I share my perspective on when it makes sense to use snapshotFlow and when collectAsState is a better fit by exploring short, practical examples from real projects, helping you avoid hidden bugs and performance issues in projects. Let’s break it down.What collectAsState doescollectAsState subscribes to a Flow within Compose and automatically exposes it as State for easy display in the UI:val uiState by viewModel.uiStateFlow.collectAsState()Text(uiState.text)Key points:Very easy to use.Automatically cancels and restarts collection on recomposition.Ideal for ViewModel → UI data binding.But:Triggers recomposition on every new emission, even if only a minor change occurs.Starts collecting as soon as the composable enters composition.Not suitable for observing Compose-specific states like scroll or gestures.What snapshotFlow doessnapshotFlow converts Compose states (e.g., LazyListState, derivedStateOf) into a cold Flow, allowing you to react to state changes without unnecessary recompositions:val listState = rememberLazyListState()LaunchedEffect(Unit) { snapshotFlow { listState.firstVisibleItemIndex } .distinctUntilChanged() .collect { index -\u003e analytics.logScrollPosition(index) }}Key points:Ideal for side-effects on Compose state changes.Does not trigger recompositions.Used within LaunchedEffect or coroutines.But:Does not expose State for direct UI rendering.Does not replace collectAsState for ViewModel → UI updates.When to use collectAsStateSubscribing to Flow or StateFlow from your ViewModel for the UI.Displaying data in the UI (text, loading states, fetched data).Low-frequency updates that the user needs to see.Avoid using for:High-frequency updates (scroll offsets, sensor data).Triggering side-effects that don’t require UI updates.When to use snapshotFlowReacting to Compose states (scroll, gestures, animations).Triggering side-effects without causing recompositions.Building Flow pipelines from Compose states (analytics, lazy loading triggers).Avoid using for:Direct UI data rendering.Replacing collectAsState for ViewModel → UI flows.Practical examples for snapshotFlowWrong: Using snapshotFlow.collectAsState for animation progressval progress by snapshotFlow { animationState.progress } .collectAsState(initial = 0f)Text(\"Progress: ${(progress * 100).toInt()}%\")Using snapshotFlow together with collectAsState to drive UI updates for animation progress causes recompositions on every frame, leading to jank and defeating the purpose of snapshotFlow.Correct: Using snapshotFlow for analytics during animationLaunchedEffect(Unit) { snapshotFlow { animationState.progress } .distinctUntilChanged { old, new -\u003e (old * 100).toInt() == (new * 100).toInt() } .collect { progress -\u003e analytics.logAnimationProgress(progress) }}This tracks animation progress for analytics or logging without triggering UI recompositions.Practical examples for collectAsStateWrong: Using collectAsState for high-frequency scroll dataval scrollOffset by viewModel.scrollOffsetFlow.collectAsState()Text(\"Offset: $scrollOffset\")This triggers recomposition on every pixel of scroll, overloading the CPU.Correct: Using collectAsState for meaningful UI dataval userName by viewModel.userNameFlow.collectAsState()Text(\"Hello, $userName!\")This is appropriate for displaying data that the user needs to see and that changes infrequently.ConclusioncollectAsState and snapshotFlow complement each other:Use collectAsState to display ViewModel data in the UI.Use snapshotFlow to react to Compose state changes for side-effects without triggering recompositions.Using them correctly will help you avoid unnecessary recompositions, improve your app’s responsiveness, and keep your Compose code clean, scalable, and predictable.If you found this breakdown helpful, let me know if you want a follow-up on advanced snapshotFlow patterns (debouncing, buffering, combining with Flows) in production Compose apps.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*P0darOG2IeBIDWdY",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@d_glazunov?source=post_page---byline--d6f1cc9d2123---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Dmitry Glazunov\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*dKOSY-bx7KXF8f2lVdocqw.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@tonchik?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAnton Savinov\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"2b8e\"\u003eBuilding UIs can feel easy until it’s time to subscribe to state changes and handle side-effects effectively. Many developers overuse \u003ccode\u003ecollectAsState\u003c/code\u003e everywhere, leading to lags and unexpected recompositions. Others have heard of \u003ccode\u003esnapshotFlow\u003c/code\u003e but don’t understand why it’s needed if \u003ccode\u003eStateFlow\u003c/code\u003e and \u003ccode\u003ecollectAsState\u003c/code\u003e already exist.\u003c/p\u003e\u003cp id=\"fa17\"\u003eIn this small article, I share my perspective on when it makes sense to use \u003ccode\u003esnapshotFlow\u003c/code\u003e and when \u003ccode\u003ecollectAsState\u003c/code\u003e is a better fit by exploring short, practical examples from real projects, helping you avoid hidden bugs and performance issues in projects. \u003cbr/\u003eLet’s break it down.\u003c/p\u003e\u003ch2 id=\"8f0b\"\u003eWhat \u003ccode\u003ecollectAsState\u003c/code\u003e does\u003c/h2\u003e\u003cp id=\"29c7\"\u003e\u003ccode\u003ecollectAsState\u003c/code\u003e subscribes to a \u003ccode\u003eFlow\u003c/code\u003e within Compose and automatically exposes it as \u003ccode\u003eState\u003c/code\u003e for easy display in the UI:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4d0a\"\u003eval uiState by viewModel.uiStateFlow.collectAsState()\u003cbr/\u003eText(uiState.text)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7333\"\u003e\u003cstrong\u003eKey points:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"b6f0\"\u003eVery easy to use.\u003c/li\u003e\u003cli id=\"27af\"\u003eAutomatically cancels and restarts collection on recomposition.\u003c/li\u003e\u003cli id=\"d242\"\u003eIdeal for ViewModel → UI data binding\u003cstrong\u003e.\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8c59\"\u003e\u003cstrong\u003eBut:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"e89c\"\u003eTriggers recomposition on every new emission, even if only a minor change occurs.\u003c/li\u003e\u003cli id=\"fbab\"\u003eStarts collecting as soon as the composable enters composition.\u003c/li\u003e\u003cli id=\"7816\"\u003eNot suitable for observing Compose-specific states like scroll or gestures.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"76bc\"\u003eWhat \u003ccode\u003esnapshotFlow\u003c/code\u003e does\u003c/h2\u003e\u003cp id=\"fffa\"\u003e\u003ccode\u003esnapshotFlow\u003c/code\u003e converts Compose states (e.g., \u003ccode\u003eLazyListState\u003c/code\u003e, \u003ccode\u003ederivedStateOf\u003c/code\u003e) into a cold \u003ccode\u003eFlow\u003c/code\u003e, allowing you to react to state changes without unnecessary recompositions:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5437\"\u003eval listState = rememberLazyListState()\u003cp\u003eLaunchedEffect(Unit) {\u003cbr/\u003e    snapshotFlow { listState.firstVisibleItemIndex }\u003cbr/\u003e        .distinctUntilChanged()\u003cbr/\u003e        .collect { index -\u0026gt;\u003cbr/\u003e            analytics.logScrollPosition(index)\u003cbr/\u003e        }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1d43\"\u003e\u003cstrong\u003eKey points:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"43fe\"\u003eIdeal for side-effects on Compose state changes\u003cstrong\u003e.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"638e\"\u003eDoes not trigger recompositions.\u003c/li\u003e\u003cli id=\"0053\"\u003eUsed within \u003ccode\u003eLaunchedEffect\u003c/code\u003e or coroutines.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"16bc\"\u003e\u003cstrong\u003eBut:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"b936\"\u003eDoes not expose \u003ccode\u003eState\u003c/code\u003e for direct UI rendering.\u003c/li\u003e\u003cli id=\"48da\"\u003eDoes not replace \u003ccode\u003ecollectAsState\u003c/code\u003e for ViewModel → UI updates.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"43d0\"\u003eWhen to use \u003ccode\u003ecollectAsState\u003c/code\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"f907\"\u003eSubscribing to \u003ccode\u003eFlow\u003c/code\u003e or \u003ccode\u003eStateFlow\u003c/code\u003e from your ViewModel for the UI.\u003c/li\u003e\u003cli id=\"25d4\"\u003eDisplaying data in the UI (text, loading states, fetched data).\u003c/li\u003e\u003cli id=\"b754\"\u003eLow-frequency updates that the user needs to see.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9d91\"\u003e\u003cstrong\u003eAvoid using for:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"bc6c\"\u003eHigh-frequency updates (scroll offsets, sensor data).\u003c/li\u003e\u003cli id=\"4571\"\u003eTriggering side-effects that don’t require UI updates.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"2177\"\u003eWhen to use \u003ccode\u003esnapshotFlow\u003c/code\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"c9af\"\u003eReacting to Compose states (scroll, gestures, animations).\u003c/li\u003e\u003cli id=\"e19b\"\u003eTriggering side-effects without causing recompositions.\u003c/li\u003e\u003cli id=\"22ce\"\u003eBuilding \u003ccode\u003eFlow\u003c/code\u003e pipelines from Compose states (analytics, lazy loading triggers).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6d40\"\u003e\u003cstrong\u003eAvoid using for:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"6a8e\"\u003eDirect UI data rendering.\u003c/li\u003e\u003cli id=\"9532\"\u003eReplacing \u003ccode\u003ecollectAsState\u003c/code\u003e for ViewModel → UI flows.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"4a73\"\u003ePractical examples for \u003ccode\u003esnapshotFlow\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"0d38\"\u003e\u003cstrong\u003eWrong:\u003c/strong\u003e Using \u003ccode\u003esnapshotFlow.collectAsState\u003c/code\u003e for animation progress\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a1ba\"\u003eval progress by snapshotFlow { animationState.progress }\u003cbr/\u003e    .collectAsState(initial = 0f)\u003cp\u003eText(\u0026#34;Progress: ${(progress * 100).toInt()}%\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"023f\"\u003eUsing \u003ccode\u003esnapshotFlow\u003c/code\u003e together with \u003ccode\u003ecollectAsState\u003c/code\u003e to drive UI updates for animation progress causes recompositions on every frame, leading to jank and defeating the purpose of \u003ccode\u003esnapshotFlow\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"11b4\"\u003e\u003cstrong\u003eCorrect:\u003c/strong\u003e Using \u003ccode\u003esnapshotFlow\u003c/code\u003e for analytics during animation\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aeac\"\u003eLaunchedEffect(Unit) {\u003cbr/\u003e    snapshotFlow { animationState.progress }\u003cbr/\u003e        .distinctUntilChanged { old, new -\u0026gt;\u003cbr/\u003e            (old * 100).toInt() == (new * 100).toInt()\u003cbr/\u003e        }\u003cbr/\u003e        .collect { progress -\u0026gt;\u003cbr/\u003e            analytics.logAnimationProgress(progress)\u003cbr/\u003e        }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4ba9\"\u003eThis tracks animation progress for analytics or logging without triggering UI recompositions.\u003c/p\u003e\u003ch2 id=\"5041\"\u003ePractical examples for \u003ccode\u003ecollectAsState\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"c319\"\u003e\u003cstrong\u003eWrong:\u003c/strong\u003e Using \u003ccode\u003ecollectAsState\u003c/code\u003e for high-frequency scroll data\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"16f7\"\u003eval scrollOffset by viewModel.scrollOffsetFlow.collectAsState()\u003cbr/\u003eText(\u0026#34;Offset: $scrollOffset\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8d2a\"\u003eThis triggers recomposition on every pixel of scroll, overloading the CPU.\u003c/p\u003e\u003cp id=\"7d77\"\u003e\u003cstrong\u003eCorrect:\u003c/strong\u003e Using \u003ccode\u003ecollectAsState\u003c/code\u003e for meaningful UI data\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bcab\"\u003eval userName by viewModel.userNameFlow.collectAsState()\u003cbr/\u003eText(\u0026#34;Hello, $userName!\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"74c7\"\u003eThis is appropriate for displaying data that the user needs to see and that changes infrequently.\u003c/p\u003e\u003ch2 id=\"2272\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"f74a\"\u003e\u003ccode\u003ecollectAsState\u003c/code\u003e and \u003ccode\u003esnapshotFlow\u003c/code\u003e complement each other:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7168\"\u003eUse collectAsState to display ViewModel data in the UI.\u003c/li\u003e\u003cli id=\"63b3\"\u003eUse snapshotFlow to react to Compose state changes for side-effects without triggering recompositions.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"cecd\"\u003eUsing them correctly will help you avoid unnecessary recompositions, improve your app’s responsiveness, and keep your Compose code clean, scalable, and predictable.\u003c/p\u003e\u003cp id=\"a1df\"\u003eIf you found this breakdown helpful, let me know if you want a follow-up on advanced snapshotFlow patterns (debouncing, buffering, combining with Flows) in production Compose apps.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-07-07T15:37:04.487Z",
  "modifiedTime": null
}
