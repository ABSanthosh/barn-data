{
  "id": "15f890c6-f048-4e00-8d84-d693ecf9faf5",
  "title": "Why Java Developers should stop using Java and start using Kotlin instead",
  "link": "https://blog.kotlin-academy.com/why-java-developers-should-stop-using-java-and-start-using-kotlin-instead-7e1d1aa4888a?source=rss----e57b304801ef---4",
  "description": "",
  "author": "Ilja Leyberman",
  "published": "Thu, 22 May 2025 13:10:43 GMT",
  "source": "https://blog.kotlin-academy.com/feed",
  "categories": [
    "spring-boot",
    "kotlin",
    "java",
    "enterprise-software"
  ],
  "byline": "Ilja Leyberman",
  "length": 34256,
  "excerpt": "Despite the AI hype, traditional software development remains crucial, and it needs a modern and powerful programming language as its foundation. The excellent Java ecosystem rightly enjoys great…",
  "siteName": "Kt. Academy",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*2grDGjzH0tfX8XiaF4Izaw.png",
  "text": "Despite the AI hype, traditional software development remains crucial, and it needs a modern and powerful programming language as its foundation. The excellent Java ecosystem rightly enjoys great trust, especially in the Enterprise environment. While this ecosystem has grown continuously and become increasingly efficient thanks to modern frameworks such as Spring, an active open source community and, last but not least, the central Maven repository with its wide range of libraries, the Java programming language itself has lagged behind this dynamic development. This is exactly where Kotlin comes in: modern, highly efficient and fully compatible with the existing Java stack. It enables companies and developers alike to seamlessly continue using their proven tools, frameworks, libs, existing code and know-how while taking software development to a new level.MotivationI have been developing software professionally for 25 years, mainly in the enterprise environment with a focus on web applications for B2B and B2E solutions. I have many years of experience with C#, Java and TypeScript (Angular, Node.js, NestJS). I have also implemented various requirements in the field of data analytics with Python and Jupyter. In the last two years, my focus has been on AI, where I am actively working on projects. I got to know Kotlin during a project work for a well-known German automobile manufacturer and implemented several projects with it over a period of about 3.5 years.I am neither a Java hater nor a Kotlin fanboy. I work with different technologies and would ultimately always make the choice of tech stack dependent on the respective context. What is used in the company, what are the team’s preferences, etc. What are the business and technical requirements?As far as Java is concerned, its strength for me clearly lies in its excellent ecosystem, especially in classic backend development. I have known Java since its beginnings and have actively accompanied the development of the language for over three decades. However, if you compare Java with more modern languages, it becomes clear that Java is no longer up to date at a language level. The first Kotlin project was a real eye-opener for me: many of Java’s weaknesses have been elegantly resolved. The switch is easy and productivity is noticeably higher. This is exactly why I want to share my perspective, because I am convinced that Kotlin will give the Java ecosystem a new boost and enable enterprise developers to write better software!Evolution of Programming languagesThe evolution of programming languages proceeded in steps towards ever greater abstraction: from assembler and punch cards in the 1940s to high-level languages such as FORTRAN and COBOL in the 1950s to object-oriented and functional concepts in languages such as C++, Java and Python. In the 2000s, Scala and C# merged object-oriented and functional approaches, later Kotlin, Rust and Swift brought modern features such as type inference and null safety. Today, the spectrum extends to low-code platforms and AI-supported tools that generate code directly from natural language, with the common goal of relieving developers of technical complexity and focusing on business logic.chronology of the programming languagesEven if complete abstraction from the code seems like the ultimate goal of language development at first glance, it has been shown that this approach is not particularly effective. The more you abstract, the more you lose control and flexibility. Software development is multi-layered and schould not be implemented exclusively at an extremely high level of abstraction. If you only work with no-code or AI-generated blackbox-code, you will quickly reach your limits. Especially when it comes to maintaining the existing code base. For many tasks, algorithmic fine control at a technical level remains indispensable. That is why a good balance is crucial. Modern programming languages should make it possible to concentrate on the technical logic and at the same time use classic programming concepts such as loops, conditions, filters or the targeted selection of libraries. The aim is to be able to work efficiently without having to deal with low-level details such as binary code or garbage collection, but still retain full control over code and runtime behavior at all times.Java’s strengths and weaknessesJava impresses above all with its proven stability and portability. Thanks to the JVM platform, the same bytecode runs on servers, desktops and embedded systems “Write Once, Run Anywhere”. Its statically typed system ensures early error catching, and garbage collection frees developers from manual memory management. A huge ecosystem of libraries, frameworks (especially Spring) and tools (Maven, Gradle, IDE support) covers almost every requirement in backend development. What’s more, Java has been taught at colleges and universities for decades, so companies benefit from a large talent pool of experienced developers who are already familiar with Java without having to undergo extensive training. These factors have helped Java to become extremely popular, making it the most widely used technology for business applications (B2B and B2E), particularly in the enterprise sector.Java’s current stateJava suffers from a rather cumbersome and verbose syntax that requires a lot of boilerplate, such as long getters/setters, overloaded class and package structures or the unwieldy implementation of generics, streams and lambdas. Even simple tasks such as concatenating strings require much more complex code than modern languages, also in the latest java version. For example String Concatination://javaString name = \"Alice\";return \"Hi I'm \" + name + \", how are you?\";//java 24/25 - current previewreturn STR.\"Hi I'm \\{name}, how are you?\";//kotlinval name = \"Alice\"return \"Hi I'm $name, how are you?\"Here you can follow the current status of the development of string templates feature.Another structural problem is the lack of a nullable type concept, which leads to one of the most common sources of errors: the infamous NullPointerException. Here too, Java lags behind modern type systems that minimize such risks at language level.There's no question: after a long stagnation since Java 8, things have been moving again since around 2010. Version 10 introduced `var` declarations, followed later by records, virtual threads, multi-line strings, pattern matching for `switch` and soon string templates. However, many of these features were launched over a period of more than 15 years, while languages such as C#, TypeScript or Kotlin were developed much more consistently and innovatively over the same period. For example, although Java Records offers a compact syntax for data classes, it still does not support default parameter values in methods or inheritance.Who exactly is driving the development of Java?Since the acquisition of Sun Microsystems in 2010, the further development of Java has been largely controlled by Oracle. As Java Language Architect, Brian Goetz has been shaping the language ever since, for example through projects such as Amber (records, pattern matching) or Loom (virtual threads). Proposals for new language features are made via the JEP process. Although companies such as Red Hat, Microsoft and SAP also contribute via the OpenJDK community, the central decision-making power ultimately lies with Oracle and above all with Brian Goetz.Brian Goetz is known as a cautious architect with a strong focus on stability. His mindset follows the principle “Don’t break the ecosystem”, Innovation yes, but only cautiously and with consistent backwards compatibility. This is why the further development of Java is often slower than that of more modern languages. Features such as records, var or pattern matching have been introduced gradually over many years, always with an eye on existing code bases and developer habits. This conservative thinking still characterizes the language today: appreciated by some as a strength, criticized by others as a brake on innovation.Oracle is not necessarily seen as a driver of innovation, unlike companies such as Google, OpenAI or Microsoft, which often take much braver paths. Stability is important, but when backwards compatibility becomes the top priority, the further development of the language inevitably suffers. The rapid development in the field of AI is largely ignored by Oracle in the context of Java development. Other platforms show that innovation and productivity are not mutually exclusive. Anyone who only defends Java today as a “secure foundation” must ask themselves whether it is not already on its way to becoming the COBOL of tomorrow.New Java Syntax features released in the last 15 versions/yearsThe following list refers to the real extensions of the language and the syntax, not to the extensions of the framework, the compiler, the JRE or the JVM:// ################ JDK 10 ################// local type inference (JEP 286)var number = 42;// ################ JDK 11 ################// var in lambda parameters (JEP 323)list.forEach((var item) -\u003e System.out.println(item));// ################ JDK 12 ################// switch expressions (JEP 325 - Preview)int result = switch (day) { case MONDAY, FRIDAY -\u003e 6; case TUESDAY -\u003e 7; default -\u003e 0;};// ################ JDK 13 ################// text blocks (JEP 355 - preview)var json = \"\"\" { \"name\": \"Max\", \"age\": 30 } \"\"\";// ################ JDK 14 ################// Records (JEP 359 - preview)record Person(String name, int age) {}Person p = new Person(\"Alice\", 30);// Pattern Matching für instanceof (JEP 305 – Preview)if (obj instanceof String s) { System.out.println(s.length());}// ################ JDK 15 ################// Sealed Classes (JEP 360 - Preview)public sealed class Shape permits Circle, Rectangle {}public final class Circle extends Shape {}public final class Rectangle extends Shape {}// ################ JDK 16 ################// Finalization of the already introduced // features JEP 395 and JEP 394. No new features.// ################ JDK 17 ################// Pattern Matching for switch (JEP 406 – Preview)return switch (obj) { case Integer i -\u003e \"int \" + i; case String s -\u003e \"string \" + s; default -\u003e \"unknown\"; };// ################ JDK 18 ################// No new features.// ################ JDK 19 ################// Record Patterns (Preview) - JEP 405if (obj instanceof Point(int x, int y)) { System.out.println(x + \", \" + y);}// ################ JDK 20 ################// No new features, just small enhancements // to existing previews(JEP 432, 433, 429)// ################ JDK 21 ################// No new features, just small enhancements // to existing previews(JEP 477, 448, 431)// ################ JDK 22 ################// Unnamed Variables and Patterns (JEP 456)map.computeIfAbsent(key, _ -\u003e new ArrayList\u003c\u003e()).add(value);// Statements Before super() or this() in Constructors (JEP 447)class MyClass extends BaseClass { MyClass(String data) { String processedData = process(data); super(processedData); }}// String Templates (Second Preview) (JEP 459)String name = \"Alice\";String msg = STR.\"Hi I'm \\{name}, how are you?\";// Implicitly Declared Classes and Instance // Main Methods (Second Preview) (JEP 463)void main() { System.out.println(\"Hello, World!\");}// Stream Gatherers (Preview) (JEP 461)// ################ JDK 23 ################// Markdown in JavaDoc (JEP 467)/** * # Heading * * - Item 1 * - Item 2 */// Module Import Declarations (JEP 476)import module java.util;// Structured Concurrency (JEP 480)try (var scope = StructuredTaskScope.shutdownOnFailure()) { Future\u003cString\u003e user = scope.fork(() -\u003e findUser()); Future\u003cInteger\u003e order = scope.fork(() -\u003e fetchOrder()); scope.join(); return user.resultNow() + order.resultNow();}// Scoped Values (JEP 481)ScopedValue\u003cString\u003e userId = ScopedValue.newInstance();ScopedValue.where(userId, \"user123\").run(() -\u003e {});// ################ JDK 24 ################// No essential new syntax features. Mainly further development // of already launched preview features from previous versions such // as Unnamed Variables and Patterns (JEP 456)// ################ JDK 24 ################// It is also unlikely that the JDK 25 will contain new syntax functions. In the latest Java versions, especially from JDK 22, there has been a noticeable number of new language features, significantly more than in previous years. This suggests that Java is under increasing pressure from modern languages, which score points for their expressive syntax and high productivity. It looks as if Oracle is trying to catch up and make Java more attractive again.Despite numerous new features, many Java teams stick to the tried and tested, often out of habit, a conservative java mindset or due to internal company structures and a lack of training. Language constructs such as record or var are rarely used, while Lombok is still considered the standard. Without frameworks such as Spring and Hibernate as well as tools such as Lombok, Gradle and the Maven ecosystem, Java would hardly be competitive as a language today. The real problem lies less in the strong ecosystem than in the language itself, and in an attitude that slows down rather than promotes innovation.Java’s mindsetMany Java developers even see modern language functions such as type inference, which have long been standard in other programming languages, as something evil.//java defaultArrayList\u003cInteger\u003e nums = new ArrayList\u003cInteger\u003e();//vs type inference since java 10var nums = new ArrayList\u003cInteger\u003e();For example, they believe that you have to write the data type everywhere because otherwise the code is difficult to read. However, type inference deliberately aims to do the opposite, namely to increase the readability of the code by avoiding the unnecessary writing of data types while at the same time ensuring strong typing at compile time. It can be quite frustrating to talk to a Java developer who has never seen anything other than Java. And although Oracle and also part of the Java community are trying very hard to develop the language further, this development is not really accepted, as you can see from the example of var and type inference.This is also the reason why more and more developers are opting for alternatives. Annual surveys such as the GitHub Octoverse, the Stack Overflow Developer Survey or the TIOBE Index clearly confirm this trend.While languages such as Python and TypeScript are growing steadily, the number of Java contributors has been falling for years. Source: https://github.blog/news-insights/octoverse/octoverse-2024/#the-most-popular-programming-languagesTIOBE Index from 2000 to May 2025. Source: https://www.tiobe.com/tiobe-index/Ultimately, all of this results in significantly more and more complex code in Java. This negatively affects readability, maintainability, development speed, developer happines and, in the end, overall costs. Companies like JetBrains, Google, Meta or Netflix identified this issue years ago and took appropriate action. They switched to Kotlin with minimal effort and without discarding their existing codebase or accumulated expertise!Why Kotlin?Kotlin was developed by JetBrains from 2010 onwards because, despite intensive use of Java, they were increasingly dissatisfied with its limitations, particularly its verbose syntax, lack of null-safety and slow language progress. The aim was to create a modern language that is more productive, secure and expressive, while remaining fully compatible with the existing Java ecosystem. Kotlin should allow developers to continue developing existing Java projects without breakage, only more elegant, shorter and less error-prone.In 2017 Android was already one of the world’s largest software ecosystems, with billions of devices and millions of apps, making it one of the main drivers of Java usage. Google declared Kotlin the official Android language in the same year because more and more developers were already using it voluntarily thanks to its better readability, null-safety and full Java compatibility. This was Google’s response to criticism of Java (particularly following legal disputes with Oracle) and the community’s desire for more modern tools. The decision was strategic: instead of inventing a new language itself, Google supported an already established, tried-and-tested alternative that made Android development much more convenient and efficient.The introduction of Kotlin at Google brought enormous efficiency gains: developers report up to 40% fewer lines of code for the same functionality, significantly fewer sources of error (e.g. due to null-safety) and a faster development time. As a result, Kotlin has not only established itself as a modern Java replacement, but also as a real productivity booster in the Android world. As a result, Kotlin became the fastest growing programming language of year 2018 according to GitHub Octoverse.Kotlin is no longer just the preferred language for Android. Today, many companies also use it successfully in the backend, especially in combination with Spring. Even the well-known developer portal Baeldung has been running its own Kotlin tutorial portal for years. The combination of Kotlin, Spring and the powerful Maven ecosystem acts as a real productivity booster, combining the strengths of an established framework with the modern, lean syntax of Kotlin and taking software development to a new level.It is no surprise that Kotlin is one of the fastest growing programming languages today, despite the Python, AI and Kubernetes hype, as the latest surveys show.Kotlin and the JVM form a perfect symbiosisKotlin and the JVM form a perfect symbiosis because Kotlin fits seamlessly into the established Java ecosystem while addressing the weaknesses of Java syntax. The platform-independent strength of the JVM remains fully intact, all proven libraries, frameworks and package ecosystems continue to function unchanged, while Kotlin’s modern language design ensures significantly less boilerplate, built-in null-safety and powerful features such as extension functions, data classes and coroutines. In everyday project work, you benefit equally from the stability and distribution of the JVM and from the expressiveness and productivity that Kotlin brings to the table.At the same time, the JVM itself is currently experiencing a phase of intensive further development, for example through projects such as Loom (Virtual Threads), Panama (Native Interop), Valhalla (Value Types) or the ongoing JIT and GC optimisations. These innovations increase performance, concurrency models and interoperability and also directly benefit Kotlin applications. As Kotlin does not replace the JVM, but is based on it, every language and platform improvement takes full effect, which makes the combination of Kotlin and JVM a future-proof basis for modern software development, not only today, but also in the future.Kotlin vs. JavaLet’s take a look at Kotlin and Java syntax in direct comparison.String concatinationThe concatenation of strings is one of the basic capabilities of a programming language. Java struggles with this, because even in the latest preview version, the code lacks any elegance.var name = \"Alice\";//javareturn \"Hi I'm \" + name + \", how are you?\";//java JDK 24/25 - current previewreturn STR.\"Hi I'm \\{name}, how are you?\";//kotlinreturn \"Hi I'm $name, how are you?\"MethodsThe aim of Kotlin is to use as little code as possible. Single-line methods in Kotlin do not require braces or semicolons and the return statement has also been minimised. Thanks to the type inference, the strong typing at compile time is retained. Of course, braces and return types are still accepted, but this is not Kotlin’s preferred way.//javapublic String greet() { return \"Hello World\";}public int sun(int a, int b) { return a + b;}//kotlinfun greet() = \"Hello World\"fun sum(a:Int, b:Int) = a + bClass declarationsGetters and setters are hardly ever written by hand in Java these days, this is usually done by Lombok. Records have also been available as a more compact alternative since Java 14, but very few Java developers use them. Kotlin has offered concise class declarations right from the start. With the data class construct, optionally useful functions such as copy, toString, equals and hashCode are generated automatically, flexibly and idiomatically.//java + lombok@Data@AllArgsConstructorclass Person { private String name; private int age; private String city;}//java JDK \u003e 14record Person (String name, int age, String address) {}//kotlinclass Person(val name: String, val age: Int, val city: String)// or data class automatically creates cleanly implemented methods // such as copy(), toString(), equals() and hashCode().data class Person(val name: String, val age: Int, val city: String)InstantiationWhen instantiating, kotlin follows its mission, less is more. That is why the new statement is completely omitted.//java Person person = new Person(\"Alice\", 20, \"Wonderland\");//kotlinvar person = Person(\"Alice\", 20, \"Wonderland\")//with named parameters you do not have to observe the order, //useful for constructors with many parametersval person = Person(age = 25, city = \"Hamburg\", name = \"Bob\")Stream/Collections processingStream processing, even if I find the term ‘streams’ somewhat inappropriate in this context, is basically the processing of collections. In Kotlin, this is solved extremely elegantly: you only need a fraction of the code compared to Java, and the language provides all the necessary constructs for filtering, mapping, grouping, reducing, etc. directly out of the box. Here is just a very small selection of the possibilities.//java ab jdk \u003e 16var uniqueCities = persons.stream() .map(Person::getCity) .distinct() .toList();//kotlinval uniqueCities = persons.map{ it.city }.distinct()// ############ sum operation ###############//java int totalAge = persons.stream() .mapToInt(Person::getAge) .sum();//kotlinval totalAge = persons.sumOf { it.age }// ############ get oldest person ###############//javaOptional\u003cPerson\u003e oldest = persons.stream() .max(Comparator.comparingInt(Person::getAge));//kotlinval oldest = persons.maxByOrNull { it.age }Null-Safety \u0026 Safe-Call OperatorKotlin’s null-safety features, such as the safe-call operator (?.) and the Elvis operator (?:), enable precise handling of null values, allowing potential NullPointerExceptions to be detected at compile time. This results in more robust, readable, and maintainable code.//javaString s = null;System.out.println(s != null? s.length : null);//kotlinval s: String? = nullprintln(s?.length)//###### nested complex types ######// Person -\u003e Address -\u003e Street -\u003e Number//javaString houseNumber = Optional.ofNullable(person) .map(Person::getAddress) .map(Address::getStreet) .map(Street::getNumber) .orElse(null);//kotlinvar houseNumber = person?.address?.street?.number;The naming of unit testsIn Kotlin, you can name unit tests with easily readable strings, which is especially helpful when you have many tests. This improves readability in test reports and makes evaluation simpler.//Javavoid should_correctly_add_two_numbers() { assertEquals(4, 2 + 2))}//Kotlin@Testfun `should correctly add two numbers 🦩`() { assertEquals(4, 2 + 2))}More Kotlin featuresListed here are language constructs that do not exist in Java or that can only be mapped with excessive effort.Extension Methods/PropertiesThanks to extension methods/properties, standard Kotlin classes or even any 3'rd party classes can be easily extended with your own domain-specific methods or properties and, if required, can also be equipped with an integrated null-safety check. A feature that has existed in many modern languages such as TypeScript, Swift, Rust and above all C# for years is of course a must in Kotlin.// Adds an additional method lastChar to the String classfun String.lastChar(): Char = this[this.length - 1]println(\"hello\".lastChar()) //-\u003e o// extension property incl. integrated null-safetyval String?.isTitle: Boolean get() = this?.startsWith(\"Once upon a time\") == trueprintln(\"hello world\".isTitle) // falseprintln(\"Once upon a time in Kotlin\".isTitle) // true println(null.isTitle) // falseDestructuring DeclarationsDestructuring declarations in Kotlin make it possible to assign several properties of an object to individual variables at the same time.data class Person(val name: String, val age: Int, val city: String)var person = Person(\"Alice\", 20, \"Wonderland\")//extracts name and age into separate variablesval (name, age) = personRangesRanges are useful if you want to iterate simple number ranges or check whether a number is already within a range.//Simple iteration from 0 to 3for(i in 0..3) { print(i)}//iteration from 2 to 8 with an increment of 2for(i in 2..8 step 2) { print(i)}//iteration through characters from a to dfor (c in 'a'..'d') { print(c)}//ranges can also be used in conditions to //check whether x is within 1 and 5if (x in 1..5) { print(\"x is in range!\")}Default \u0026 Named ArgumentsA function that no modern programming language should be without: default values in methods or constructor parameters. Enable lean and flexible instantiation of objects.data class Person( val name: String = \"Alice\", val age: Int = 20, val city: String = \"Nowhere\")var person = Person(city = \"Wonderland\")Asynchronous processingEven though Java has made progress in asynchronous processing, the new Virtual Threads syntax does not come close to the elegance and simplicity of Kotlin’s coroutines.//javapublic static void main(String[] args) throws InterruptedException { long start = System.currentTimeMillis(); List\u003cThread\u003e threads = new ArrayList\u003c\u003e(); // start 10 concurrent threads for (int i = 1; i \u003c= 10; i++) { int count = i; long delay = 3000L - count * 300L; Thread vt = Thread.startVirtualThread(() -\u003e { try { Thread.sleep(delay); } catch (InterruptedException ignored) { } System.out.println(\"Countdown: \" + count); }); threads.add(vt); } // wait for the end of all virtual threads for (Thread vt : threads) { vt.join(); } // continues when all virtual threads have finished float seconds = (System.currentTimeMillis() - start) / 1000F; System.out.println(\"done in \" + seconds + \" sec.\");}//kotlinsuspend fun main() { val start = System.currentTimeMillis() coroutineScope { for (i in 1..10) { launch { // start 10 concurrent tasks delay(3000L - i * 300) println(\"Countdown: $i\") } } } // continues when all coroutines in the scope have finished println(\"done in: ${(System.currentTimeMillis() - start)/1000F}sec.\")}Of course, Kotlin offers many more exciting features, but it wouldn’t make sense to list the entire documentation here. However, if you’re interested in exploring more, you can find additional syntax highlights at the following link.Kotlin can do more, much moreKotlin is much more than just Android or Spring backend development. The language is extremely versatile: Kotlin Multiplatform allows you to create shared codebases for Android, iOS, Windows, Unix, desktop and web. Kotlin/JS enables frontend development for web applications, Kotlin/Native allows development for platforms without JVM, such as iOS or embedded systems. Kotlin is also used for serverless, CLI tools, desktop apps (with Compose Multiplatform) or data analysis with Kotlin Notebooks. With this cross-platform approach, Kotlin deliberately targets modern software development and thus appeals to both beginners and experienced developers.KtorKtor is a lightweight, asynchronous framework from JetBrains for server and client applications in Kotlin. It uses coroutines for efficient, non-blocking programming and offers flexible DSLs for routing, HTTP and WebSockets. Ktor is a good alternative to Spring if you are looking for a lean, modular solution without a lot of overhead, ideal for lean microservices and APIs.Kotlin MultiplattformKotlin Multiplatform enables the development of cross-platform applications with a common code base for logic, network or data models for: Android, iOS, desktop and web. Platform-specific components can be added where necessary. Another exciting feature is Jetpack Compose Multiplatform, which allows joint UI development for Android, desktop (Windows, macOS, Linux) and even web (experimental) with just one UI code. iOS is currently still connected natively, but is in the works. Kotlin therefore offers a modern, versatile basis for cross-platform software development.Kotlin NativeKotlin/Native enables the development of applications without a JVM by compiling Kotlin directly into native machine code, e.g. for iOS, macOS, Windows, Linux or even embedded systems. This allows platform-oriented programs to be written, such as mobile apps (e.g. iOS parts in KMM), native CLIs or system tools. Interoperability with C is also possible, which facilitates integration into existing native environments. Kotlin/Native is a central component of Kotlin Multiplatform and allows Kotlin to be used where otherwise only C or C++ is used.Kotlin/JS and React wrapperKotlin/JS makes it possible to bring Kotlin code into the JavaScript ecosystem, both for browser applications and Node.js projects. This allows modern web applications to be developed with well-known JS frameworks such as React, for example via the official Kotlin React wrapper. The advantages are strong typing, common business logic with other platforms (multiplatform) and full interoperability with existing JavaScript code. In terms of maturity, Kotlin/JS is stable and ready for production, is being actively developed by JetBrains and is primarily used in multiplatform projects. Nevertheless, it is still less widespread than classic JavaScript or TypeScript stacks.Kotlin Kernel für Jupyter/ DataSpell IntelliJ PluginKotlin can be used in various ways for notebook-like work. On the one hand, there are Kotlin Jupyter notebooks that are directly compatible with the well-known Jupyter platform, here Kotlin is integrated as a separate kernel language, similar to Python or Julia. This allows code, visualizations and documentation to be combined in classic notebook form. On the other hand, JetBrains offers its own Kotlin Notebook plugin, IntelliJ IDEA, which enables similar functionality directly in the IDE i.e. block-by-block execution of code, interactive diagrams, tables and live data analyses.In addition, JetBrains provides its own cloud-based platform, Datalore, which hosts interactive Kotlin notebooks, similar to Google Colab for Python. In all variants, developers can access specialized Kotlin libraries for analytics and data science, including Kotlin DataFrame, Krangl, Multik, KMath or KotlinPlot. Interoperability with Java and some Python libraries (e.g. via GraalVM) also opens up many possibilities. This means that Kotlin is no longer just a language for classic application development, but also a serious tool for data-driven and explorative tasks.Kotlin \u0026 Spring AIKotlin in combination with Spring AI offers a strong entry point for AI developers into the Java ecosystem. Thanks to its modern, concise and reader-friendly syntax, Kotlin is particularly attractive for developers with a background in AI, Python or TypeScript. This makes collaboration between data scientists, AI experts and classic enterprise backend developers much easier, everyone can work in the same tech stack. Kotlin thus acts as a bridge between worlds and significantly lowers the barriers to entry into the enterprise environment.ConclusionOf course, every developer has their own personal preferences, that’s normal. But there is also such a thing as an objective view if you look at all the facts soberly. I have tried to incorporate my own views and experiences as well as current developments in the field of programming languages and, of course, many discussions with other developers. My conclusion: the current state of the Java language is simply no longer good enough. And it is very unlikely that anything will change in the short term. Even in the Java community there is uncertainty about the direction, and Oracle, as the driving force behind it, is not exactly famous for innovation or speed.On the other hand, Kotlin is a modern, highly efficient language that’s well established and proven in practice, already in productive use by many companies. It’s developed by JetBrains, the makers of IntelliJ, who’ve consistently shown they understand what software developers need. It’s just fun to develop in Kotlin, you get addicted to finding ever more elegant expression with the many possibilities the language offers. The biggest advantage: you don’t have to change the technology stack. Everything stays the same, only the syntax changes. The migration effort is minimal, but the productivity gains are enormous. This is the reason why many companies have already taken this step and many more are on their way.I am convinced that Java as a language has passed its zenith. And that is the reason why companies and developers should seriously consider switching to Kotlin.Useful sourcesKotlin — https://kotlinlang.org/Kotlin playground — https://play.kotlinlang.org/Ktor — https://ktor.io/Baeldung — https://www.baeldung.com/kotlin/Octoverse — https://octoverse.github.com/Stack Overflow Developer Survey — https://survey.stackoverflow.co/TIOBE -INDEX— https://www.tiobe.com/tiobe-index/Java JEP’s — https://openjdk.org/jeps/JAVA — https://www.oracle.com/java/technologies/downloads/History of Programming Languages — https://www.computer.org/publications/tech-news/insider-membership-news/timeline-of-programming-languagesJetBrains — https://www.jetbrains.com/",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*O_Tea9L6Ebqc2DzMULiWhA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@TheCodemonkey?source=post_page---byline--7e1d1aa4888a---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ilja Leyberman\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*8yORDGK_wTXrYYqyiMO91A@2x.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"f024\"\u003e\u003cem\u003eDespite the AI hype, traditional software development remains crucial, and it needs a modern and powerful programming language as its foundation. The excellent Java ecosystem rightly enjoys great trust, especially in the Enterprise environment. While this ecosystem has grown continuously and become increasingly efficient thanks to modern frameworks such as Spring, an active open source community and, last but not least, the central Maven repository with its wide range of libraries, the Java programming language itself has lagged behind this dynamic development. This is exactly where Kotlin comes in: modern, highly efficient and fully compatible with the existing Java stack. It enables companies and developers alike to seamlessly continue using their proven tools, frameworks, libs, existing code and know-how while taking software development to a new level.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"ec6f\"\u003eMotivation\u003c/h2\u003e\u003cp id=\"cbce\"\u003eI have been developing software professionally for 25 years, mainly in the enterprise environment with a focus on web applications for B2B and B2E solutions. I have many years of experience with C#, Java and TypeScript (Angular, Node.js, NestJS). I have also implemented various requirements in the field of data analytics with Python and Jupyter. In the last two years, my focus has been on AI, where I am actively working on projects. I got to know Kotlin during a project work for a well-known German automobile manufacturer and implemented several projects with it over a period of about 3.5 years.\u003c/p\u003e\u003cp id=\"832e\"\u003eI am neither a Java hater nor a Kotlin fanboy. I work with different technologies and would ultimately always make the choice of tech stack dependent on the respective context. What is used in the company, what are the team’s preferences, etc. What are the business and technical requirements?\u003c/p\u003e\u003cp id=\"b4a5\"\u003eAs far as Java is concerned, its strength for me clearly lies in its excellent ecosystem, especially in classic backend development. I have known Java since its beginnings and have actively accompanied the development of the language for over three decades. However, if you compare Java with more modern languages, it becomes clear that Java is no longer up to date at a language level. The first Kotlin project was a real eye-opener for me: many of Java’s weaknesses have been elegantly resolved. The switch is easy and productivity is noticeably higher. This is exactly why I want to share my perspective, because I am convinced that Kotlin will give the Java ecosystem a new boost and enable enterprise developers to write better software!\u003c/p\u003e\u003ch2 id=\"77a2\"\u003eEvolution of Programming languages\u003c/h2\u003e\u003cp id=\"9e5e\"\u003eThe evolution of programming languages proceeded in steps towards ever greater abstraction: from assembler and punch cards in the 1940s to high-level languages such as FORTRAN and COBOL in the 1950s to object-oriented and functional concepts in languages such as C++, Java and Python. In the 2000s, Scala and C# merged object-oriented and functional approaches, later Kotlin, Rust and Swift brought modern features such as type inference and null safety. Today, the spectrum extends to low-code platforms and AI-supported tools that generate code directly from natural language, with the common goal of relieving developers of technical complexity and focusing on business logic.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cfigure\u003e\u003cfigcaption\u003echronology of the programming languages\u003c/figcaption\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"0847\"\u003eEven if complete abstraction from the code seems like the ultimate goal of language development at first glance, it has been shown that this approach is not particularly effective. The more you abstract, the more you lose control and flexibility. Software development is multi-layered and schould not be implemented exclusively at an extremely high level of abstraction. If you only work with no-code or AI-generated blackbox-code, you will quickly reach your limits. Especially when it comes to maintaining the existing code base. For many tasks, algorithmic fine control at a technical level remains indispensable. That is why a good balance is crucial. Modern programming languages should make it possible to concentrate on the technical logic and at the same time use classic programming concepts such as loops, conditions, filters or the targeted selection of libraries. The aim is to be able to work efficiently without having to deal with low-level details such as binary code or garbage collection, but still retain full control over code and runtime behavior at all times.\u003c/p\u003e\u003ch2 id=\"0acf\"\u003eJava’s strengths and weaknesses\u003c/h2\u003e\u003cp id=\"3420\"\u003eJava impresses above all with its proven stability and portability. Thanks to the JVM platform, the same bytecode runs on servers, desktops and embedded systems “Write Once, Run Anywhere”. Its statically typed system ensures early error catching, and garbage collection frees developers from manual memory management. A huge ecosystem of libraries, frameworks (especially Spring) and tools (Maven, Gradle, IDE support) covers almost every requirement in backend development. What’s more, Java has been taught at colleges and universities for decades, so companies benefit from a large talent pool of experienced developers who are already familiar with Java without having to undergo extensive training. These factors have helped Java to become extremely popular, making it the most widely used technology for business applications (B2B and B2E), particularly in the enterprise sector.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d413\"\u003eJava’s current state\u003c/h2\u003e\u003cp id=\"8ae1\"\u003eJava suffers from a rather cumbersome and verbose syntax that requires a lot of boilerplate, such as long getters/setters, overloaded class and package structures or the unwieldy implementation of generics, streams and lambdas. Even simple tasks such as concatenating strings require much more complex code than modern languages, also in the latest java version. For example String Concatination:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e9f8\"\u003e//java\u003cp\u003eString name = \u0026#34;Alice\u0026#34;;\u003cbr/\u003ereturn \u0026#34;Hi I\u0026#39;m \u0026#34; + name + \u0026#34;, how are you?\u0026#34;;\u003c/p\u003e\u003cp\u003e//java 24/25 - current preview\u003cbr/\u003ereturn STR.\u0026#34;Hi I\u0026#39;m \\{name}, how are you?\u0026#34;;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"8dfd\"\u003e//kotlin\u003cp\u003eval name = \u0026#34;Alice\u0026#34;\u003cbr/\u003ereturn \u0026#34;Hi I\u0026#39;m $name, how are you?\u0026#34;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c6d9\"\u003e\u003ca href=\"https://openjdk.org/jeps/465\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eHere\u003c/em\u003e\u003c/a\u003e\u003cem\u003e you can follow the current status of the development of \u003c/em\u003e\u003ca href=\"https://openjdk.org/jeps/465\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003estring templates\u003c/em\u003e\u003c/a\u003e\u003cem\u003e feature.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"ebee\"\u003eAnother structural problem is the lack of a nullable type concept, which leads to one of the most common sources of errors: the infamous NullPointerException. Here too, Java lags behind modern type systems that minimize such risks at language level.\u003c/p\u003e\u003cp id=\"9cb5\"\u003eThere\u0026#39;s no question: after a long stagnation since Java 8, things have been moving again since around 2010. Version 10 introduced `var` declarations, followed later by records, virtual threads, multi-line strings, pattern matching for `switch` and soon string templates. However, many of these features were launched over a period of more than 15 years, while languages such as C#, TypeScript or Kotlin were developed much more consistently and innovatively over the same period. For example, although Java Records offers a compact syntax for data classes, it still does not support default parameter values in methods or inheritance.\u003c/p\u003e\u003ch2 id=\"fc75\"\u003eWho exactly is driving the development of Java?\u003c/h2\u003e\u003cp id=\"2eb8\"\u003eSince the acquisition of Sun Microsystems in 2010, the further development of Java has been largely controlled by Oracle. As Java Language Architect, Brian Goetz has been shaping the language ever since, for example through projects such as Amber (records, pattern matching) or Loom (virtual threads). Proposals for new language features are made via the JEP process. Although companies such as Red Hat, Microsoft and SAP also contribute via the OpenJDK community, the central decision-making power ultimately lies with Oracle and above all with \u003ca href=\"https://inside.java/u/BrianGoetz/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBrian Goetz\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"cf92\"\u003e\u003ca href=\"https://inside.java/u/BrianGoetz/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBrian Goetz\u003c/a\u003e is known as a cautious architect with a strong focus on stability. His mindset follows the principle “Don’t break the ecosystem”, Innovation yes, but only cautiously and with consistent backwards compatibility. This is why the further development of Java is often slower than that of more modern languages. Features such as records, var or pattern matching have been introduced gradually over many years, always with an eye on existing code bases and developer habits. This conservative thinking still characterizes the language today: appreciated by some as a strength, criticized by others as a brake on innovation.\u003c/p\u003e\u003cp id=\"0f93\"\u003eOracle is not necessarily seen as a driver of innovation, unlike companies such as Google, OpenAI or Microsoft, which often take much braver paths. Stability is important, but when backwards compatibility becomes the top priority, the further development of the language inevitably suffers. The rapid development in the field of AI is largely ignored by Oracle in the context of Java development. Other platforms show that innovation and productivity are not mutually exclusive. Anyone who only defends Java today as a “secure foundation” must ask themselves whether it is not already on its way to becoming the COBOL of tomorrow.\u003c/p\u003e\u003ch2 id=\"6ea6\"\u003eNew Java Syntax features released in the last 15 versions/years\u003c/h2\u003e\u003cp id=\"bb30\"\u003e\u003cem\u003eThe following list refers to the real extensions of the language and the syntax, not to the extensions of the framework, the compiler, the JRE or the JVM:\u003c/em\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8d00\"\u003e// ################ JDK 10  ################\u003cbr/\u003e// local type inference (JEP 286)\u003cbr/\u003evar number = 42;\u003cp\u003e// ################ JDK 11  ################\u003cbr/\u003e// var in lambda parameters (JEP 323)\u003cbr/\u003elist.forEach((var item) -\u0026gt; System.out.println(item));\u003c/p\u003e\u003cp\u003e// ################ JDK 12  ################\u003cbr/\u003e// switch expressions (JEP 325 - Preview)\u003cbr/\u003eint result = switch (day) {\u003cbr/\u003e  case MONDAY, FRIDAY -\u0026gt; 6;\u003cbr/\u003e  case TUESDAY        -\u0026gt; 7;\u003cbr/\u003e  default             -\u0026gt; 0;\u003cbr/\u003e};\u003c/p\u003e\u003cp\u003e// ################ JDK 13  ################\u003cbr/\u003e// text blocks (JEP 355 - preview)\u003cbr/\u003evar json = \u0026#34;\u0026#34;\u0026#34;\u003cbr/\u003e              {\u003cbr/\u003e                \u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;,\u003cbr/\u003e                \u0026#34;age\u0026#34;: 30\u003cbr/\u003e              }\u003cbr/\u003e           \u0026#34;\u0026#34;\u0026#34;;\u003c/p\u003e\u003cp\u003e// ################ JDK 14  ################\u003c/p\u003e\u003cp\u003e// Records (JEP 359 - preview)\u003cbr/\u003erecord Person(String name, int age) {}\u003cbr/\u003ePerson p = new Person(\u0026#34;Alice\u0026#34;, 30);\u003c/p\u003e\u003cp\u003e// Pattern Matching für instanceof (JEP 305 – Preview)\u003cbr/\u003eif (obj instanceof String s) {\u003cbr/\u003e    System.out.println(s.length());\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// ################ JDK 15  ################\u003cbr/\u003e// Sealed Classes (JEP 360 - Preview)\u003cbr/\u003epublic sealed class Shape permits Circle, Rectangle {}\u003cbr/\u003epublic final class Circle extends Shape {}\u003cbr/\u003epublic final class Rectangle extends Shape {}\u003c/p\u003e\u003cp\u003e// ################ JDK 16  ################\u003cbr/\u003e// Finalization of the already introduced \u003cbr/\u003e// features JEP 395 and JEP 394. No new features.\u003c/p\u003e\u003cp\u003e// ################ JDK 17  ################\u003cbr/\u003e// Pattern Matching for switch (JEP 406 – Preview)\u003cbr/\u003ereturn switch (obj) {\u003cbr/\u003e        case Integer i -\u0026gt; \u0026#34;int \u0026#34; + i;\u003cbr/\u003e        case String s -\u0026gt; \u0026#34;string \u0026#34; + s;\u003cbr/\u003e        default -\u0026gt; \u0026#34;unknown\u0026#34;;\u003cbr/\u003e    };\u003c/p\u003e\u003cp\u003e// ################ JDK 18  ################\u003cbr/\u003e// No new features.\u003c/p\u003e\u003cp\u003e// ################ JDK 19  ################\u003cbr/\u003e// Record Patterns (Preview) - JEP 405\u003cbr/\u003eif (obj instanceof Point(int x, int y)) {\u003cbr/\u003e    System.out.println(x + \u0026#34;, \u0026#34; + y);\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// ################ JDK 20  ################\u003cbr/\u003e// No new features, just small enhancements \u003cbr/\u003e// to existing previews(JEP 432, 433, 429)\u003c/p\u003e\u003cp\u003e// ################ JDK 21  ################\u003cbr/\u003e// No new features, just small enhancements \u003cbr/\u003e// to existing previews(JEP 477, 448, 431)\u003c/p\u003e\u003cp\u003e// ################ JDK 22  ################\u003c/p\u003e\u003cp\u003e// Unnamed Variables and Patterns (JEP 456)\u003cbr/\u003emap.computeIfAbsent(key, _ -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(value);\u003c/p\u003e\u003cp\u003e// Statements Before super() or this() in Constructors (JEP 447)\u003cbr/\u003eclass MyClass extends BaseClass {\u003cbr/\u003e    MyClass(String data) {\u003cbr/\u003e        String processedData = process(data);\u003cbr/\u003e        super(processedData);\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// String Templates (Second Preview) (JEP 459)\u003cbr/\u003eString name = \u0026#34;Alice\u0026#34;;\u003cbr/\u003eString msg = STR.\u0026#34;Hi I\u0026#39;m \\{name}, how are you?\u0026#34;;\u003c/p\u003e\u003cp\u003e// Implicitly Declared Classes and Instance \u003cbr/\u003e// Main Methods (Second Preview) (JEP 463)\u003cbr/\u003evoid main() {\u003cbr/\u003e    System.out.println(\u0026#34;Hello, World!\u0026#34;);\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Stream Gatherers (Preview) (JEP 461)\u003c/p\u003e\u003cp\u003e// ################ JDK 23  ################\u003c/p\u003e\u003cp\u003e// Markdown in JavaDoc (JEP 467)\u003cbr/\u003e/**\u003cbr/\u003e * # Heading\u003cbr/\u003e *\u003cbr/\u003e * - Item 1\u003cbr/\u003e * - Item 2\u003cbr/\u003e */\u003c/p\u003e\u003cp\u003e// Module Import Declarations (JEP 476)\u003cbr/\u003eimport module java.util;\u003c/p\u003e\u003cp\u003e// Structured Concurrency (JEP 480)\u003cbr/\u003etry (var scope = StructuredTaskScope.shutdownOnFailure()) {\u003cbr/\u003e    Future\u0026lt;String\u0026gt; user = scope.fork(() -\u0026gt; findUser());\u003cbr/\u003e    Future\u0026lt;Integer\u0026gt; order = scope.fork(() -\u0026gt; fetchOrder());\u003cbr/\u003e    scope.join();\u003cbr/\u003e    return user.resultNow() + order.resultNow();\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Scoped Values (JEP 481)\u003cbr/\u003eScopedValue\u0026lt;String\u0026gt; userId = ScopedValue.newInstance();\u003cbr/\u003eScopedValue.where(userId, \u0026#34;user123\u0026#34;).run(() -\u0026gt; {});\u003c/p\u003e\u003cp\u003e// ################ JDK 24  ################\u003c/p\u003e\u003cp\u003e// No essential new syntax features. Mainly further development \u003cbr/\u003e// of already launched preview features from previous versions such \u003cbr/\u003e// as Unnamed Variables and Patterns (JEP 456)\u003c/p\u003e\u003cp\u003e// ################ JDK 24  ################\u003cbr/\u003e// It is also unlikely that the JDK 25 will contain new syntax functions. \u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7201\"\u003eIn the latest Java versions, especially from JDK 22, there has been a noticeable number of new language features, significantly more than in previous years. This suggests that Java is under increasing pressure from modern languages, which score points for their expressive syntax and high productivity. It looks as if Oracle is trying to catch up and make Java more attractive again.\u003c/p\u003e\u003cp id=\"3546\"\u003eDespite numerous new features, many Java teams stick to the tried and tested, often out of habit, a conservative java mindset or due to internal company structures and a lack of training. Language constructs such as record or var are rarely used, while Lombok is still considered the standard. Without frameworks such as Spring and Hibernate as well as tools such as Lombok, Gradle and the Maven ecosystem, Java would hardly be competitive as a language today. The real problem lies less in the strong ecosystem than in the language itself, and in an attitude that slows down rather than promotes innovation.\u003c/p\u003e\u003ch2 id=\"b14c\"\u003eJava’s mindset\u003c/h2\u003e\u003cp id=\"0eec\"\u003eMany Java developers even see modern language functions such as type inference, which have long been standard in other programming languages, as something evil.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6075\"\u003e//java default\u003cbr/\u003eArrayList\u0026lt;Integer\u0026gt; nums = new ArrayList\u0026lt;Integer\u0026gt;();\u003cp\u003e//vs type inference since java 10\u003cbr/\u003evar nums = new ArrayList\u0026lt;Integer\u0026gt;();\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d14a\"\u003eFor example, they believe that you have to write the data type everywhere because otherwise the code is difficult to read. However, type inference deliberately aims to do the opposite, namely to increase the readability of the code by avoiding the unnecessary writing of data types while at the same time ensuring strong typing at compile time. It can be quite frustrating to talk to a Java developer who has never seen anything other than Java. And although Oracle and also part of the Java community are trying very hard to develop the language further, this development is not really accepted, as you can see from the example of var and type inference.\u003c/p\u003e\u003cp id=\"601b\"\u003eThis is also the reason why more and more developers are opting for alternatives. Annual surveys such as the \u003ca href=\"https://github.blog/news-insights/octoverse/octoverse-2024/#the-most-popular-programming-languages\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub Octoverse\u003c/a\u003e, the \u003ca href=\"https://survey.stackoverflow.co/2024/technology#2-programming-scripting-and-markup-languages\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStack Overflow Developer Survey\u003c/a\u003e or the \u003ca href=\"https://www.tiobe.com/tiobe-index/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTIOBE Index\u003c/a\u003e clearly confirm this trend.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eWhile languages such as Python and TypeScript are growing steadily, the number of Java contributors has been falling for years. Source: \u003ca href=\"https://github.blog/news-insights/octoverse/octoverse-2024/#the-most-popular-programming-languages\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.blog/news-insights/octoverse/octoverse-2024/#the-most-popular-programming-languages\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003eTIOBE Index from 2000 to May 2025. Source: \u003ca href=\"https://www.tiobe.com/tiobe-index/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://www.tiobe.com/tiobe-index/\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"3689\"\u003eUltimately, all of this results in significantly more and more complex code in Java. This negatively affects readability, maintainability, development speed, developer happines and, in the end, overall costs. Companies like JetBrains, Google, Meta or Netflix identified this issue years ago and took appropriate action. They switched to Kotlin with minimal effort and without discarding their existing codebase or accumulated expertise!\u003c/p\u003e\u003ch2 id=\"26e3\"\u003eWhy Kotlin?\u003c/h2\u003e\u003cp id=\"54bd\"\u003eKotlin was developed by JetBrains from 2010 onwards because, despite intensive use of Java, they were increasingly dissatisfied with its limitations, particularly its verbose syntax, lack of null-safety and slow language progress. The aim was to create a modern language that is more productive, secure and expressive, while remaining fully compatible with the existing Java ecosystem. Kotlin should allow developers to continue developing existing Java projects without breakage, only more elegant, shorter and less error-prone.\u003c/p\u003e\u003cp id=\"22e6\"\u003eIn 2017 Android was already one of the world’s largest software ecosystems, with billions of devices and millions of apps, making it one of the main drivers of Java usage. Google declared Kotlin the official Android language in the same year because more and more developers were already using it voluntarily thanks to its better readability, null-safety and full Java compatibility. This was Google’s response to criticism of Java (particularly following legal disputes with Oracle) and the community’s desire for more modern tools. The decision was strategic: instead of inventing a new language itself, Google supported an already established, tried-and-tested alternative that made Android development much more convenient and efficient.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"72d1\"\u003eThe introduction of Kotlin at Google brought enormous efficiency gains: developers report up to 40% fewer lines of code for the same functionality, significantly fewer sources of error (e.g. due to null-safety) and a faster development time. As a result, Kotlin has not only established itself as a modern Java replacement, but also as a real productivity booster in the Android world. As a result, Kotlin became the fastest growing programming language of year 2018 according to GitHub Octoverse.\u003c/p\u003e\u003cp id=\"ee37\"\u003eKotlin is no longer just the preferred language for Android. Today, many companies also use it successfully in the backend, especially in combination with Spring. Even the well-known developer portal \u003ca href=\"https://www.baeldung.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBaeldung \u003c/a\u003ehas been running its own \u003ca href=\"https://www.baeldung.com/kotlin/start-here\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin \u003c/a\u003etutorial portal for years. The combination of Kotlin, Spring and the powerful Maven ecosystem acts as a real productivity booster, combining the strengths of an established framework with the modern, lean syntax of Kotlin and taking software development to a new level.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"14c0\"\u003eIt is no surprise that Kotlin is one of the fastest growing programming languages today, despite the Python, AI and Kubernetes hype, as the latest surveys show.\u003c/p\u003e\u003ch2 id=\"3c49\"\u003eKotlin and the JVM form a perfect symbiosis\u003c/h2\u003e\u003cp id=\"92e1\"\u003eKotlin and the JVM form a perfect symbiosis because Kotlin fits seamlessly into the established Java ecosystem while addressing the weaknesses of Java syntax. The platform-independent strength of the JVM remains fully intact, all proven libraries, frameworks and package ecosystems continue to function unchanged, while Kotlin’s modern language design ensures significantly less boilerplate, built-in null-safety and powerful features such as extension functions, data classes and coroutines. In everyday project work, you benefit equally from the stability and distribution of the JVM and from the expressiveness and productivity that Kotlin brings to the table.\u003c/p\u003e\u003cp id=\"abdd\"\u003eAt the same time, the JVM itself is currently experiencing a phase of intensive further development, for example through projects such as Loom (Virtual Threads), Panama (Native Interop), Valhalla (Value Types) or the ongoing JIT and GC optimisations. These innovations increase performance, concurrency models and interoperability and also directly benefit Kotlin applications. As Kotlin does not replace the JVM, but is based on it, every language and platform improvement takes full effect, which makes the combination of Kotlin and JVM a future-proof basis for modern software development, not only today, but also in the future.\u003c/p\u003e\u003ch2 id=\"5ef6\"\u003eKotlin vs. Java\u003c/h2\u003e\u003cp id=\"4e7f\"\u003eLet’s take a look at Kotlin and Java syntax in direct comparison.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"67cd\"\u003eString concatination\u003c/h2\u003e\u003cp id=\"5688\"\u003eThe concatenation of strings is one of the basic capabilities of a programming language. Java struggles with this, because even in the latest preview version, the code lacks any elegance.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"500f\"\u003evar name = \u0026#34;Alice\u0026#34;;\u003cp\u003e//java\u003cbr/\u003ereturn \u0026#34;Hi I\u0026#39;m \u0026#34; + name + \u0026#34;, how are you?\u0026#34;;\u003c/p\u003e\u003cp\u003e//java JDK 24/25 - current preview\u003cbr/\u003ereturn STR.\u0026#34;Hi I\u0026#39;m \\{name}, how are you?\u0026#34;;\u003c/p\u003e\u003cp\u003e//kotlin\u003cbr/\u003ereturn \u0026#34;Hi I\u0026#39;m $name, how are you?\u0026#34;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1520\"\u003eMethods\u003c/h2\u003e\u003cp id=\"0c47\"\u003eThe aim of Kotlin is to use as little code as possible. Single-line methods in Kotlin do not require braces or semicolons and the return statement has also been minimised. Thanks to the type inference, the strong typing at compile time is retained. Of course, braces and return types are still accepted, but this is not Kotlin’s preferred way.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4d01\"\u003e//java\u003cbr/\u003epublic String greet() {\u003cbr/\u003e  return \u0026#34;Hello World\u0026#34;;\u003cbr/\u003e}\u003cp\u003epublic int sun(int a, int b) {\u003cbr/\u003e  return a + b;\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e//kotlin\u003cbr/\u003efun greet() = \u0026#34;Hello World\u0026#34;\u003c/p\u003e\u003cp\u003efun sum(a:Int, b:Int) = a + b\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4c18\"\u003eClass declarations\u003c/h2\u003e\u003cp id=\"d224\"\u003eGetters and setters are hardly ever written by hand in Java these days, this is usually done by Lombok. Records have also been available as a more compact alternative since Java 14, but very few Java developers use them. Kotlin has offered concise class declarations right from the start. With the data class construct, optionally useful functions such as copy, toString, equals and hashCode are generated automatically, flexibly and idiomatically.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f786\"\u003e//java + lombok\u003cbr/\u003e@Data\u003cbr/\u003e@AllArgsConstructor\u003cbr/\u003eclass Person {\u003cbr/\u003e    private String name;\u003cbr/\u003e    private int age;\u003cbr/\u003e    private String city;\u003cbr/\u003e}\u003cp\u003e//java JDK \u0026gt; 14\u003cbr/\u003erecord Person (String name, int age, String address) {}\u003c/p\u003e\u003cp\u003e//kotlin\u003cbr/\u003eclass Person(val name: String, val age: Int, val city: String)\u003c/p\u003e\u003cp\u003e// or data class automatically creates cleanly implemented methods \u003cbr/\u003e// such as copy(), toString(), equals() and hashCode().\u003cbr/\u003edata class Person(val name: String, val age: Int, val city: String)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"20ba\"\u003eInstantiation\u003c/h2\u003e\u003cp id=\"aa4d\"\u003eWhen instantiating, kotlin follows its mission, less is more. That is why the \u003cstrong\u003enew \u003c/strong\u003estatement is completely omitted.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b7c4\"\u003e//java \u003cbr/\u003ePerson person = new Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Wonderland\u0026#34;);\u003cp\u003e//kotlin\u003cbr/\u003evar person = Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Wonderland\u0026#34;)\u003cbr/\u003e//with named parameters you do not have to observe the order, \u003cbr/\u003e//useful for constructors with many parameters\u003cbr/\u003eval person = Person(age = 25, city = \u0026#34;Hamburg\u0026#34;, name = \u0026#34;Bob\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"528e\"\u003eStream/Collections processing\u003c/h2\u003e\u003cp id=\"c614\"\u003eStream processing, even if I find the term ‘streams’ somewhat inappropriate in this context, is basically the processing of collections. In Kotlin, this is solved extremely elegantly: you only need a fraction of the code compared to Java, and the language provides all the necessary constructs for filtering, mapping, grouping, reducing, etc. directly out of the box. Here is just a very small selection of the possibilities.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f917\"\u003e\u003cbr/\u003e//java ab jdk \u0026gt; 16\u003cbr/\u003evar uniqueCities = persons.stream()\u003cbr/\u003e    .map(Person::getCity)\u003cbr/\u003e    .distinct()\u003cbr/\u003e    .toList();\u003cp\u003e//kotlin\u003cbr/\u003eval uniqueCities = persons.map{ it.city }.distinct()\u003c/p\u003e\u003cp\u003e// ############ sum operation ###############\u003c/p\u003e\u003cp\u003e//java \u003cbr/\u003eint totalAge = persons.stream()\u003cbr/\u003e    .mapToInt(Person::getAge)\u003cbr/\u003e    .sum();\u003c/p\u003e\u003cp\u003e//kotlin\u003cbr/\u003eval totalAge = persons.sumOf { it.age }\u003c/p\u003e\u003cp\u003e// ############ get oldest person ###############\u003c/p\u003e\u003cp\u003e//java\u003cbr/\u003eOptional\u0026lt;Person\u0026gt; oldest = persons.stream()\u003cbr/\u003e    .max(Comparator.comparingInt(Person::getAge));\u003c/p\u003e\u003cp\u003e//kotlin\u003cbr/\u003eval oldest = persons.maxByOrNull { it.age }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"48c0\"\u003eNull-Safety \u0026amp; Safe-Call Operator\u003c/h2\u003e\u003cp id=\"8503\"\u003eKotlin’s null-safety features, such as the safe-call operator (?.) and the Elvis operator (?:), enable precise handling of null values, allowing potential NullPointerExceptions to be detected at compile time. This results in more robust, readable, and maintainable code.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"98e4\"\u003e//java\u003cbr/\u003eString s = null;\u003cbr/\u003eSystem.out.println(s != null? s.length : null);\u003cp\u003e//kotlin\u003cbr/\u003eval s: String? = null\u003cbr/\u003eprintln(s?.length)\u003c/p\u003e\u003cp\u003e//###### nested complex types ######\u003cbr/\u003e// Person -\u0026gt; Address -\u0026gt; Street -\u0026gt; Number\u003c/p\u003e\u003cp\u003e//java\u003cbr/\u003eString houseNumber = Optional.ofNullable(person)\u003cbr/\u003e            .map(Person::getAddress)\u003cbr/\u003e            .map(Address::getStreet)\u003cbr/\u003e            .map(Street::getNumber)\u003cbr/\u003e            .orElse(null);\u003c/p\u003e\u003cp\u003e//kotlin\u003cbr/\u003evar houseNumber = person?.address?.street?.number;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e9c8\"\u003eThe naming of unit tests\u003c/h2\u003e\u003cp id=\"a1b2\"\u003eIn Kotlin, you can name unit tests with easily readable strings, which is especially helpful when you have many tests. This improves readability in test reports and makes evaluation simpler.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d729\"\u003e//Java\u003cbr/\u003evoid should_correctly_add_two_numbers() {\u003cbr/\u003e    assertEquals(4, 2 + 2))\u003cbr/\u003e}\u003cp\u003e//Kotlin\u003cbr/\u003e@Test\u003cbr/\u003efun `should correctly add two numbers 🦩`() {\u003cbr/\u003e    assertEquals(4, 2 + 2))\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"5b38\"\u003eMore Kotlin features\u003c/h2\u003e\u003cp id=\"6fe9\"\u003eListed here are language constructs that do not exist in Java or that can only be mapped with excessive effort.\u003c/p\u003e\u003ch2 id=\"be4c\"\u003eExtension Methods/Properties\u003c/h2\u003e\u003cp id=\"e655\"\u003eThanks to extension methods/properties, standard Kotlin classes or even any 3\u0026#39;rd party classes can be easily extended with your own domain-specific methods or properties and, if required, can also be equipped with an integrated null-safety check. A feature that has existed in many modern languages such as TypeScript, Swift, Rust and above all C# for years is of course a must in Kotlin.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"520f\"\u003e// Adds an additional method lastChar to the String class\u003cbr/\u003efun String.lastChar(): Char = this[this.length - 1]\u003cbr/\u003eprintln(\u0026#34;hello\u0026#34;.lastChar()) \u003cbr/\u003e//-\u0026gt; o\u003cp\u003e// extension property incl. integrated null-safety\u003cbr/\u003eval String?.isTitle: Boolean\u003cbr/\u003e    get() = this?.startsWith(\u0026#34;Once upon a time\u0026#34;) == true\u003c/p\u003e\u003cp\u003eprintln(\u0026#34;hello world\u0026#34;.isTitle)                 // false\u003cbr/\u003eprintln(\u0026#34;Once upon a time in Kotlin\u0026#34;.isTitle)  // true \u003cbr/\u003eprintln(null.isTitle)                          // false\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"a2d8\"\u003eDestructuring Declarations\u003c/h2\u003e\u003cp id=\"7d6d\"\u003eDestructuring declarations in Kotlin make it possible to assign several properties of an object to individual variables at the same time.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e659\"\u003e\u003cbr/\u003edata class Person(val name: String, val age: Int, val city: String)\u003cp\u003evar person = Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Wonderland\u0026#34;)\u003c/p\u003e\u003cp\u003e//extracts name and age into separate variables\u003cbr/\u003eval (name, age) = person\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"9090\"\u003eRanges\u003c/h2\u003e\u003cp id=\"9d7c\"\u003eRanges are useful if you want to iterate simple number ranges or check whether a number is already within a range.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4f88\"\u003e//Simple iteration from 0 to 3\u003cbr/\u003efor(i in 0..3) {\u003cbr/\u003e    print(i)\u003cbr/\u003e}\u003cp\u003e//iteration from 2 to 8 with an increment of 2\u003cbr/\u003efor(i in 2..8 step 2) {\u003cbr/\u003e    print(i)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e//iteration through characters from a to d\u003cbr/\u003efor (c in \u0026#39;a\u0026#39;..\u0026#39;d\u0026#39;) {\u003cbr/\u003e    print(c)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e//ranges can also be used in conditions to \u003cbr/\u003e//check whether x is within 1 and 5\u003cbr/\u003eif (x in 1..5) {\u003cbr/\u003e    print(\u0026#34;x is in range!\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"0fa9\"\u003eDefault \u0026amp; Named Arguments\u003c/h2\u003e\u003cp id=\"4eaf\"\u003eA function that no modern programming language should be without: default values in methods or constructor parameters. Enable lean and flexible instantiation of objects.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"756b\"\u003edata class Person(\u003cbr/\u003e  val name: String = \u0026#34;Alice\u0026#34;, \u003cbr/\u003e  val age: Int = 20, \u003cbr/\u003e  val city: String = \u0026#34;Nowhere\u0026#34;\u003cbr/\u003e)\u003cp\u003evar person = Person(city = \u0026#34;Wonderland\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"50fe\"\u003eAsynchronous processing\u003c/h2\u003e\u003cp id=\"c25b\"\u003eEven though Java has made progress in asynchronous processing, the new Virtual Threads syntax does not come close to the elegance and simplicity of Kotlin’s coroutines.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0110\"\u003e//java\u003cbr/\u003epublic static void main(String[] args) throws InterruptedException {\u003cbr/\u003e    long start = System.currentTimeMillis();\u003cbr/\u003e    List\u0026lt;Thread\u0026gt; threads = new ArrayList\u0026lt;\u0026gt;();\u003cp\u003e    // start 10 concurrent threads\u003cbr/\u003e    for (int i = 1; i \u0026lt;= 10; i++) {\u003cbr/\u003e        int count = i;\u003cbr/\u003e        long delay = 3000L - count * 300L;\u003cbr/\u003e        Thread vt = Thread.startVirtualThread(() -\u0026gt; {\u003cbr/\u003e            try {\u003cbr/\u003e                Thread.sleep(delay);\u003cbr/\u003e            } catch (InterruptedException ignored) {\u003cbr/\u003e            }\u003cbr/\u003e            System.out.println(\u0026#34;Countdown: \u0026#34; + count);\u003cbr/\u003e        });\u003cbr/\u003e        threads.add(vt);\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // wait for the end of all virtual threads\u003cbr/\u003e    for (Thread vt : threads) {\u003cbr/\u003e        vt.join();\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // continues when all virtual threads have finished\u003cbr/\u003e    float seconds = (System.currentTimeMillis() - start) / 1000F;\u003cbr/\u003e    System.out.println(\u0026#34;done in \u0026#34; + seconds + \u0026#34; sec.\u0026#34;);\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e//kotlin\u003cbr/\u003esuspend fun main() {                                \u003cbr/\u003e  val start = System.currentTimeMillis()\u003cbr/\u003e  coroutineScope {                                \u003cbr/\u003e        for (i in 1..10) {\u003cbr/\u003e            launch {    // start 10 concurrent tasks\u003cbr/\u003e                delay(3000L - i * 300)      \u003cbr/\u003e                println(\u0026#34;Countdown: $i\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e      }\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e    // continues when all coroutines in the scope have finished\u003cbr/\u003e  println(\u0026#34;done in: ${(System.currentTimeMillis() - start)/1000F}sec.\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"373c\"\u003eOf course, Kotlin offers many more exciting features, but it wouldn’t make sense to list the entire documentation here. However, if you’re interested in exploring more, you can find additional syntax highlights at the following \u003ca href=\"https://play.kotlinlang.org/byExample/01_introduction/01_Hello%20world\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003elink\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"f32c\"\u003eKotlin can do more, much more\u003c/h2\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"63e5\"\u003eKotlin is much more than just Android or Spring backend development. The language is extremely versatile: Kotlin Multiplatform allows you to create shared codebases for Android, iOS, Windows, Unix, desktop and web. Kotlin/JS enables frontend development for web applications, Kotlin/Native allows development for platforms without JVM, such as iOS or embedded systems. Kotlin is also used for serverless, CLI tools, desktop apps (with Compose Multiplatform) or data analysis with Kotlin Notebooks. With this cross-platform approach, Kotlin deliberately targets modern software development and thus appeals to both beginners and experienced developers.\u003c/p\u003e\u003ch2 id=\"47b9\"\u003eKtor\u003c/h2\u003e\u003cp id=\"604c\"\u003e\u003ca href=\"https://ktor.io/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKtor\u003c/a\u003e is a lightweight, asynchronous framework from JetBrains for server and client applications in Kotlin. It uses coroutines for efficient, non-blocking programming and offers flexible DSLs for routing, HTTP and WebSockets. Ktor is a good alternative to Spring if you are looking for a lean, modular solution without a lot of overhead, ideal for lean microservices and APIs.\u003c/p\u003e\u003ch2 id=\"8e75\"\u003eKotlin Multiplattform\u003c/h2\u003e\u003cp id=\"c688\"\u003e\u003ca href=\"https://kotlinlang.org/docs/multiplatform.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Multiplatform\u003c/a\u003e enables the development of cross-platform applications with a common code base for logic, network or data models for: Android, iOS, desktop and web. Platform-specific components can be added where necessary. Another exciting feature is Jetpack Compose Multiplatform, which allows joint UI development for Android, desktop (Windows, macOS, Linux) and even web (experimental) with just one UI code. iOS is currently still connected natively, but is in the works. Kotlin therefore offers a modern, versatile basis for cross-platform software development.\u003c/p\u003e\u003ch2 id=\"74a6\"\u003eKotlin Native\u003c/h2\u003e\u003cp id=\"2ced\"\u003e\u003ca href=\"https://kotlinlang.org/docs/native-overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin/Native\u003c/a\u003e enables the development of applications without a JVM by compiling Kotlin directly into native machine code, e.g. for iOS, macOS, Windows, Linux or even embedded systems. This allows platform-oriented programs to be written, such as mobile apps (e.g. iOS parts in KMM), native CLIs or system tools. Interoperability with C is also possible, which facilitates integration into existing native environments. \u003ca href=\"https://kotlinlang.org/docs/native-overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin/Native\u003c/a\u003e is a central component of \u003ca href=\"https://kotlinlang.org/docs/multiplatform.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Multiplatform\u003c/a\u003e and allows Kotlin to be used where otherwise only C or C++ is used.\u003c/p\u003e\u003ch2 id=\"3612\"\u003eKotlin/JS and React wrapper\u003c/h2\u003e\u003cp id=\"88ab\"\u003e\u003ca href=\"https://kotlinlang.org/docs/js-overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin/JS\u003c/a\u003e makes it possible to bring Kotlin code into the JavaScript ecosystem, both for browser applications and Node.js projects. This allows modern web applications to be developed with well-known JS frameworks such as React, for example via the official \u003ca href=\"https://github.com/JetBrains/kotlin-wrappers/blob/master/docs/guide/react.md\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin React wrapper\u003c/a\u003e. The advantages are strong typing, common business logic with other platforms (multiplatform) and full interoperability with existing JavaScript code. In terms of maturity, Kotlin/JS is stable and ready for production, is being actively developed by JetBrains and is primarily used in multiplatform projects. Nevertheless, it is still less widespread than classic JavaScript or TypeScript stacks.\u003c/p\u003e\u003ch2 id=\"1346\"\u003eKotlin Kernel für Jupyter/ DataSpell IntelliJ Plugin\u003c/h2\u003e\u003cp id=\"1e39\"\u003eKotlin can be used in various ways for notebook-like work. On the one hand, there are \u003ca href=\"https://kotlinlang.org/docs/kotlin-notebook-overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Jupyter notebooks\u003c/a\u003e that are directly compatible with the well-known Jupyter platform, here Kotlin is integrated as a separate \u003ca href=\"https://github.com/Kotlin/kotlin-jupyter?tab=readme-ov-file#kotlin-kernel-for-ipythonjupyter\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekernel language\u003c/a\u003e, similar to Python or Julia. This allows code, visualizations and documentation to be combined in classic notebook form. On the other hand, JetBrains offers its own \u003ca href=\"https://www.jetbrains.com/help/idea/kotlin-notebook.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Notebook plugin\u003c/a\u003e, IntelliJ IDEA, which enables similar functionality directly in the IDE i.e. block-by-block execution of code, interactive diagrams, tables and live data analyses.\u003c/p\u003e\u003cp id=\"00ac\"\u003eIn addition, JetBrains provides its own cloud-based platform, \u003ca href=\"https://www.jetbrains.com/de-de/datalore/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDatalore\u003c/a\u003e, which hosts interactive Kotlin notebooks, similar to \u003ca href=\"https://colab.research.google.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGoogle Colab\u003c/a\u003e for Python. In all variants, developers can access specialized Kotlin libraries for analytics and data science, including \u003ca href=\"https://kotlin.github.io/dataframe/overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin DataFrame\u003c/a\u003e, \u003ca href=\"https://github.com/holgerbrandl/krangl?tab=readme-ov-file#documentation\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKrangl\u003c/a\u003e, \u003ca href=\"https://github.com/Kotlin/multik\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMultik\u003c/a\u003e, \u003ca href=\"https://github.com/SciProgCentre/kmath\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKMath\u003c/a\u003e or \u003ca href=\"https://kotlinlang.org/docs/lets-plot.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlinPlot\u003c/a\u003e. Interoperability with Java and some Python libraries (e.g. via \u003ca href=\"https://www.graalvm.org/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGraalVM\u003c/a\u003e) also opens up many possibilities. This means that Kotlin is no longer just a language for classic application development, but also a serious tool for data-driven and explorative tasks.\u003c/p\u003e\u003ch2 id=\"ea32\"\u003eKotlin \u0026amp; Spring AI\u003c/h2\u003e\u003cp id=\"4d12\"\u003eKotlin in combination with \u003ca href=\"https://spring.io/projects/spring-ai\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSpring AI\u003c/a\u003e offers a strong entry point for AI developers into the Java ecosystem. Thanks to its modern, concise and reader-friendly syntax, Kotlin is particularly attractive for developers with a background in AI, Python or TypeScript. This makes collaboration between data scientists, AI experts and classic enterprise backend developers much easier, everyone can work in the same tech stack. Kotlin thus acts as a bridge between worlds and significantly lowers the barriers to entry into the enterprise environment.\u003c/p\u003e\u003ch2 id=\"0c87\"\u003eConclusion\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0fd4\"\u003eOf course, every developer has their own personal preferences, that’s normal. But there is also such a thing as an objective view if you look at all the facts soberly. I have tried to incorporate my own views and experiences as well as current developments in the field of programming languages and, of course, many discussions with other developers. My conclusion: the current state of the Java language is simply no longer good enough. And it is very unlikely that anything will change in the short term. Even in the Java community there is uncertainty about the direction, and Oracle, as the driving force behind it, is not exactly famous for innovation or speed.\u003c/p\u003e\u003cp id=\"0332\"\u003eOn the other hand, Kotlin is a modern, highly efficient language that’s well established and proven in practice, already in productive use by many companies. It’s developed by JetBrains, the makers of IntelliJ, who’ve consistently shown they understand what software developers need. It’s just fun to develop in Kotlin, you get addicted to finding ever more elegant expression with the many possibilities the language offers. The biggest advantage: you don’t have to change the technology stack. Everything stays the same, only the syntax changes. The migration effort is minimal, but the productivity gains are enormous. This is the reason why many companies have already taken this step and many more are on their way.\u003c/p\u003e\u003cp id=\"ca32\"\u003eI am convinced that Java as a language has passed its zenith. And that is the reason why companies and developers should seriously consider switching to Kotlin.\u003c/p\u003e\u003ch2 id=\"94ad\"\u003eUseful sources\u003c/h2\u003e\u003cp id=\"b4d3\"\u003eKotlin — \u003ca href=\"https://kotlinlang.org/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://kotlinlang.org/\u003c/a\u003e\u003cbr/\u003eKotlin playground —\u003ca href=\"https://play.kotlinlang.org/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e \u003c/a\u003e\u003ca href=\"https://play.kotlinlang.org/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://play.kotlinlang.org/\u003c/a\u003e\u003cbr/\u003eKtor — \u003ca href=\"https://ktor.io/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://ktor.io/\u003c/a\u003e\u003c/p\u003e\u003cp id=\"8126\"\u003eBaeldung — \u003ca href=\"https://www.baeldung.com/kotlin/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://www.baeldung.com/kotlin/\u003c/a\u003e\u003c/p\u003e\u003cp id=\"5a57\"\u003eOctoverse — \u003ca href=\"https://octoverse.github.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://octoverse.github.com/\u003c/a\u003e\u003cbr/\u003eStack Overflow Developer Survey — \u003ca href=\"https://survey.stackoverflow.co/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://survey.stackoverflow.co/\u003c/a\u003e\u003cbr/\u003eTIOBE -INDEX— \u003ca href=\"https://www.tiobe.com/tiobe-index/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://www.tiobe.com/tiobe-index/\u003c/a\u003e\u003c/p\u003e\u003cp id=\"4640\"\u003eJava JEP’s — \u003ca href=\"https://openjdk.org/jeps/0\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://openjdk.org/jeps\u003c/a\u003e/\u003cbr/\u003eJAVA — \u003ca href=\"https://www.oracle.com/java/technologies/downloads/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://www.oracle.com/java/technologies/downloads/\u003c/a\u003e\u003c/p\u003e\u003cp id=\"fcec\"\u003eHistory of Programming Languages — \u003ca href=\"https://www.computer.org/publications/tech-news/insider-membership-news/timeline-of-programming-languages\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://www.computer.org/publications/tech-news/insider-membership-news/timeline-of-programming-languages\u003c/a\u003e\u003c/p\u003e\u003cp id=\"ec23\"\u003eJetBrains — \u003ca href=\"https://www.jetbrains.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://www.jetbrains.com/\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "36 min read",
  "publishedTime": "2025-05-22T13:10:43.362Z",
  "modifiedTime": null
}
