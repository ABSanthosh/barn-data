{
  "id": "df0d6a53-eab5-49ae-b401-b81d002cde28",
  "title": "Building a Space Flight News App with Compose Multiplatform for Android, iOS, and Desktop: Part 3",
  "link": "https://proandroiddev.com/building-a-space-flight-news-app-with-compose-multiplatform-for-android-ios-and-desktop-part-3-1efe6545f885?source=rss----c72404660798---4",
  "description": "",
  "author": "Domen Lanišnik",
  "published": "Fri, 04 Jul 2025 17:23:29 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "android-app-development",
    "ios-app-development",
    "androiddev",
    "kotlin-multiplatform"
  ],
  "byline": "Domen Lanišnik",
  "length": 25324,
  "excerpt": "The third part of building a Compose Multiplatform app: offline support with SQLDelight.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Building a Space News App with Compose Multiplatform for Android, iOS, and Desktop: Part 3 — Offline Support with SQLDelightThis is the third part of a series of articles focusing on Compose Multiplatform. We are building an app for Android, iOS, and Desktop that displays the latest Space Flight news.This part will focus on the following:adding loading state and error handling when fetching the data,and integrating a local cache using SQLDelight to make the app work even in offline mode.Showcase of the final app.Recap of the first two partsThis article continues from where the second part left off, so make sure to start there if you haven’t yet.So far, we’ve learned the following:how Kotlin Multiplatform workssharing UI using Compose Multiplatform on iOS, Android, and Desktoploading remote images with Coiladding network layer for fetching remote data with Ktoradding dependency injection with Koin.You can find the code after part 2, and what will be our starting point for this article, here:1. Add loading and error statesUser reported that the app currently crashes when there is no internet connection or a network error occurs. They went further and opened a pull request fixing the issue. I would like to publicly thank them for their contribution and describe the changes that have been added since the last update.Defining the error and loading statesFirst, let’s extend ArticleListViewState in the ArticleListViewModel class to support the loading and error states. To do that, we can replace the current data class with a sealed interface and define Loading, Success, and Error sub-classes. This will allow us to differentiate between states easily.sealed interface ArticleListViewState { data object Loading : ArticleListViewState data class Success(val articles: List\u003cArticle\u003e = emptyList()) : ArticleListViewState data class Error(val errorType: ErrorType) : ArticleListViewState}sealed class ErrorType { data object NoInternet : ErrorType() data object ServerError : ErrorType() data object Unknown : ErrorType()}Sending the new statesNow that we have our new states defined, let’s update ArticleListViewModel to use them. Update the MutableStateFlow definition to use the default value of ArticleListViewState.Loading. We want the app to display a loading state right from the start.private val _state = MutableStateFlow\u003cArticleListViewState\u003e(ArticleListViewState.Loading)Next, let’s update the init block where we are currently loading the data. Extract everything inside the init block to a new public function called fetchArticles(). Having a separate function will allow us to reuse it when retrying a failed request.We’re wrapping the whole request into a try/catch block to handle any exceptions and then update the state with either a Success or an Error state.init { fetchArticles()}fun fetchArticles() { viewModelScope.launch { _state.value = ArticleListViewState.Loading try { val articles = apiService.getArticles() .filter { it.imageUrl.isNotEmpty() } _state.value = ArticleListViewState.Success(articles) } catch (_: IOException) { _state.value = ArticleListViewState.Error(ErrorType.NoInternet) } catch (_: HttpException) { _state.value = ArticleListViewState.Error(ErrorType.ServerError) } catch (_: Exception) { _state.value = ArticleListViewState.Error(ErrorType.Unknown) } }}Add new stringsWe’ll need some new strings/texts for the error messages. Open the composeApp/commonMain/composeResources/values/strings.xml file and add the following new strings.\u003cresources\u003e \u003cstring name=\"retry\"\u003eRetry\u003c/string\u003e \u003cstring name=\"no_internet\"\u003eNo internet connection. Please try again\u003c/string\u003e \u003cstring name=\"server_error\"\u003eServer error. Please try again later\u003c/string\u003e \u003cstring name=\"something_went_wrong\"\u003eSomething went wrong. Please try again\u003c/string\u003e\u003c/resources\u003eUpdating the UI statesNow that we have our state models defined, we can update the UI layer. In ArticleListScreen class we currently have a ArticleListScreen() composable that is currently presenting the ArticleListContent(articles) composable. That is our success state, but we now need to add the loading and error states.Let’s use a when statement to check for the type of the state and then either draw a progress indicator, the existing ArticleListContent(article), or a new error layout that shows an error message and a retry button. When the retry button is clicked, we call viewModel.fetchArticles() to retry again.Box(modifier = Modifier.fillMaxSize()) { when (val currentState = state) { is ArticleListViewState.Loading -\u003e { CircularProgressIndicator(modifier = Modifier.align(Alignment.Center)) } is ArticleListViewState.Success -\u003e { val articles = currentState.articles ArticleListContent(articles = articles) } is ArticleListViewState.Error -\u003e { val errorMessage = when (currentState.errorType) { ErrorType.NoInternet -\u003e stringResource(Res.string.no_internet) ErrorType.ServerError -\u003e stringResource(Res.string.server_error) ErrorType.Unknown -\u003e stringResource(Res.string.something_went_wrong) } Column( horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.align(Alignment.Center) ) { Text( text = errorMessage, color = Color.Red, style = MaterialTheme.typography.bodyMedium, modifier = Modifier.padding(16.dp) ) Button(onClick = { viewModel.fetchArticles() }) { Text(text = stringResource(Res.string.retry)) } } } }}The result after launching the app without an internet connection is the following.Updated app showing the error and loading states.2. Add Local Cache using SQLDelightCurrently, if you open the app without an internet connection, you will see an error. We want to be able to use the app and see previously loaded news articles. To do that, we need a persistent local cache to which we will store the fetched articles.SQLDelight is a simple-to-use wrapper around an SQLite database that works with Kotlin Multiplatform.Add dependenciesAs a first step, we have to add the necessary SQLDelight dependencies to the project. Open the gradle/libs.versions.toml file and add the new libraries. Since we are supporting three different platforms, we have to add the database driver for each of them, alongside the core runtime dependency. Additionally, we will also be using the coroutines extensions library, which will allow us to observe changes using a Kotlin Flow.We also need to define a new plugin.[versions]sql-delight = \"2.1.0\"[libraries]sqldelight-android-driver = { module = \"app.cash.sqldelight:android-driver\", version.ref = \"sql-delight\" }sqldelight-desktop-driver = { module = \"app.cash.sqldelight:sqlite-driver\", version.ref = \"sql-delight\" }sqldelight-native-driver = { module = \"app.cash.sqldelight:native-driver\", version.ref = \"sql-delight\" }sqldelight-runtime = { module = \"app.cash.sqldelight:runtime\", version.ref = \"sql-delight\" }sqldelight-coroutines-ext = { module = \"app.cash.sqldelight:coroutines-extensions\", version.ref = \"sql-delight\" }[plugins]sqldelight = { id = \"app.cash.sqldelight\", version.ref = \"sql-delight\" }Next, let’s open the composeApp/build.gradle.kts file and add the new dependency to the supported source sets.androidMain.dependencies { implementation(libs.sqldelight.android.driver)}commonMain.dependencies { implementation(libs.sqldelight.runtime) implementation(libs.sqldelight.coroutines.ext)}iosMain.dependencies { implementation(libs.sqldelight.native.driver)}desktopMain.dependencies { implementation(libs.sqldelight.desktop.driver)}In the same file, scroll to the top where the plugins block is and add the SQLDelight plugin.plugins { alias(libs.plugins.sqldelight)}Perform a gradle sync, then add the following sqldelight block to the end of the file. It configures the name of the database. Do another sync afterwards.sqldelight { databases { create(\"AppDatabase\") { packageName.set(\"your.package.spaceflightnews.cache\") } }}Generate the database structureSQLDelight works by turning SQL queries that you write into a type-safe Kotlin database API.Create a new directory under the composeApp/commonMain directory named sqldelight. The commonMain directory should now have three folders: composeResources, kotlin, and sqldelight.Inside the new sqldelight directory, create additional packages so that they match the package name you added above: your.package.spaceflightnews.cache.Then, inside the new package, create a new file named AppDatabase.sq and open it.You might see a suggestion from Android Studio to install a plugin for working with SQLDelight files. Feel free to install it to get syntax highlighting, but is not necessary.First, we have to create a table into which we will store the articles. This will be a copy of our Article model, but written in SQL. We are using the id of the article as the primary key as it’s unique for every article. Other columns are of type TEXT, including the dates. We will serialize them to the ISO 8601 (2023–01–02T23:40:57.120Z) format for storing.CREATE TABLE Article ( id INTEGER NOT NULL PRIMARY KEY, title TEXT NOT NULL, url TEXT NOT NULL, imageUrl TEXT NOT NULL, newsSite TEXT NOT NULL, summary TEXT NOT NULL, publishedAt TEXT NOT NULL, updatedAt TEXT NOT NULL);Now that we have our table, we have to define the queries for storing and fetching the data from the table. In .sq files we do that by defining the name of the function and then the corresponding SQL query. SQLDelight will then generate a Kotlin function with that name.We need four queries for now to:insert an article,delete all stored articles,fetch all stored articles,fetch a specific stored article by id.selectNewestArticles:SELECT * FROM ArticleORDER BY id DESCLIMIT 10;selectArticleById:SELECT * FROM ArticleWHERE id = ?LIMIT 1;insertOrReplaceArticle:INSERT OR REPLACE INTO Article( id, title, url, imageUrl, newsSite, summary, publishedAt, updatedAt) VALUES (?, ?, ?, ?, ?, ?, ?, ?);removeAllArticles:DELETE FROM Article;What we have to do next is to generate the Kotlin code based on the queries. Open the terminal in Android Studio and run the following command: ./gradlew generateCommonMainAppDatabaseInterface.After it has finished, you will find the generated Kotlin code in the composeApp/build/generated/sqldelight directory. This will include the AppDatabase interface for interacting with the database, together with its implementation, and a AppDatabaseQueries class that contains the functions to query the database.Generated Kotlin code by the SQLDelight library.Anytime you change the .sq file, you must re-run the ./gradlew generateCommonMainAppDatabaseInterface command.Initializing the databaseIf we take a look at the AppDatabase interface, we see that it expects an instance of SqlDriver in the constructor. Since SQL drivers are platform-specific, we have to provide separate instances for each platform.Let’s start by creating a common interface for the driver factory in the composeApp/commonMain/your.package.spaceflightnews/cache directory.import app.cash.sqldelight.db.SqlDriverinterface DatabaseDriverFactory { fun createDriver(): SqlDriver}Next, let’s add the Android-specific implementation. Create a new AndroidDatabaseDriverFactory class in the composeApp/androidMain/your.package.spaceflightnews/cache directory that extends the DatabaseDriverFactory interface. It needs to accept an instance of Context as it’s required by the AndroidSqliteDriver.import android.content.Contextimport app.cash.sqldelight.db.SqlDriverimport app.cash.sqldelight.driver.android.AndroidSqliteDriverclass AndroidDatabaseDriverFactory(private val context: Context): DatabaseDriverFactory { override fun createDriver(): SqlDriver { return AndroidSqliteDriver(AppDatabase.Schema, context, \"articles.db\") }}In similar fashion, create a new IOSDatabaseDriverFactory in the composeApp/iosMain/your.package.spaceflightnews/cache directory. Here, we’re creating an instance of NativeSqliteDriver.import app.cash.sqldelight.db.SqlDriverimport app.cash.sqldelight.driver.native.NativeSqliteDriverclass IOSDatabaseDriverFactory: DatabaseDriverFactory { override fun createDriver(): SqlDriver { return NativeSqliteDriver(AppDatabase.Schema, \"articles.db\") }}And then finally, create one for the desktop in the composeApp/desktopMain/your.package.spaceflightnews/cache directory. The desktop driver is the most peculiar, as we need to create an instance of the JdbcSqliteDriver and pass in the database schema.import app.cash.sqldelight.db.SqlDriverimport app.cash.sqldelight.driver.jdbc.sqlite.JdbcSqliteDriverclass DesktopDatabaseDriverFactory: DatabaseDriverFactory { override fun createDriver(): SqlDriver { return JdbcSqliteDriver(\"jdbc:sqlite:articles.db\", Properties(), AppDatabase.Schema) }}Creating a database wrapperNow that we have our drivers, we can create a wrapper around the generated database code that will contain our own logic.Create a new Database class in the composeApp/commonMain/your.package.spaceflightnews/cache directory. It should accept an instance of DatabaseDriverFactory interface in the constructor. We use it to create an instance of the generated AppDatabase, which in turn gives us access to the generated database queries.internal class Database(databaseDriverFactory: DatabaseDriverFactory) { private val database = AppDatabase(databaseDriverFactory.createDriver()) private val dbQueries = database.appDatabaseQueries}Next, let’s add a new function insertArticles for storing the articles in the database. It accepts a list of the existing Article models and then inserts each of them into the Article table. Before that, we remove all existing articles so that we always have the latest ones stored.Note that we are doing this in a transaction to prevent data loss in case the delete query would be successful, but one of the insert queries would fail.fun insertArticles(articles: List\u003cArticle\u003e) { dbQueries.transaction { dbQueries.removeAllArticles() articles.forEach { article -\u003e dbQueries.insertOrReplaceArticle( id = article.id, title = article.title, url = article.url, imageUrl = article.imageUrl, newsSite = article.newsSite, summary = article.summary, publishedAt = article.publishedAt.toString(), updatedAt = article.updatedAt.toString(), ) } }}Now that we’ve inserted the data, we also need functions for fetching it. Create a new function getNewestArticles that returns all the stored data from newest to oldest.We can see that the generated query contains a mapper function, which we can use to map individual table columns into our Article object.We are using the .asFlow() extension function from the sqldelight-coroutines-extensions library to observe changes to the Article table. We will need this for easy offline mode.As the Article model uses the Instant type for its publishedAt and updatedAt fields, we have to serialize it to a string to be able to store it into the database. We are leveraging the Instant.toString() function for that, which returns an ISO 8601 representation of the date (2023–01–02T23:40:57.120Z). To then convert the string back to an Instant, we are using the Instant.parse(string) constructor.import app.cash.sqldelight.coroutines.asFlowimport app.cash.sqldelight.coroutines.mapToListimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.IOimport kotlinx.coroutines.flow.Flowimport kotlinx.datetime.Instantfun getNewestArticles(): Flow\u003cList\u003cArticle\u003e\u003e { return dbQueries.selectNewestArticles { id, title, url, imageUrl, newsSite, summary, publishedAt, updatedAt -\u003e Article( id = id, title = title, url = url, imageUrl = imageUrl, newsSite = newsSite, summary = summary, publishedAt = Instant.parse(publishedAt), updatedAt = Instant.parse(updatedAt), ) }.asFlow().mapToList(Dispatchers.IO)}And finally, we need one more function to fetch a specific article by id. We will use it on the new detail screen.fun getArticleById(id: Long): Article? { return dbQueries.selectArticleById(id) { id, title, url, imageUrl, newsSite, summary, publishedAt, updatedAt -\u003e Article( id = id, title = title, url = url, imageUrl = imageUrl, newsSite = newsSite, summary = summary, publishedAt = Instant.parse(publishedAt), updatedAt = Instant.parse(updatedAt), ) }.executeAsOneOrNull()}Create a RepositoryNow that we have our database set up, it’s time to use it. We are going to create a Repository that will contain logic for interaction between the network layer and the local layer, but hide it from the caller.Create a new ArticlesRepository class in the composeApp/commonMain/your.package.spaceflightnews/data directory. It should accept the DatabaseDriverFactory interface and the ApiService class as constructor parameters. We also need to initialize the Database class we created earlier and pass in the DatabaseDriverFactory instance.import com.landomen.spaceflightnews.cache.Databaseimport com.landomen.spaceflightnews.cache.DatabaseDriverFactoryimport com.landomen.spaceflightnews.network.ApiServiceinternal class ArticlesRepository( databaseDriverFactory: DatabaseDriverFactory, private val api: ApiService) { private val database = Database(databaseDriverFactory)}Next, let’s define two functions that we will call from the UI layer:getArticles(): tries to first fetch the latest data from the API, store it in the local database, and return it. If the network request fails, it will try to return the data from the local database. If the data is not yet cached (first run) or it fails, it will throw the original exception.getArticlyById(id: Long): returns a specific article or null if it’s not foundWe are using the local database as a fallback in case of an error for simplicity sake. Another potential solution would be to observe the articles table using a Kotlin Flow and then trigger a network request as a side-effect, storing data into the database, which in turn would re-emit the changes.suspend fun getArticles(): List\u003cArticle\u003e { try { return api.getArticles().also { database.insertArticles(it) } } catch (e: Exception) { try { val storedArticles = database.getNewestArticles() if (storedArticles.isNotEmpty()) { return storedArticles } throw e } catch (e: Exception) { throw e } }}fun getArticleById(id: Long): Article? { return database.getArticleById(id)}Update ViewModelNow that we have our repository set up as well as the database layer, let’s use it in the view model. Open ArticleListViewModel and replace the ApiService dependency with the new ArticlesRepository.internal class ArticleListViewModel(private val repository: ArticlesRepository) : ViewModel() {Next, update the fetchArticles() function and replace apiService.getArticles() call with repository.getArticles() call. And that’s it! Our View Model is now using both the network and local database to fetch articles and show them even when no internet connection.However, the app currently fails to build as we need to provide the new dependencies.3. Updating dependency injectionWe have everything set up; the only thing remaining is the dependency injection. We have to provide instances of the new classes with Koin.Update AppModuleLet’s start with the AppModule file. Let’s update the appModule property by providing the ArticlesRepository and then updating the ArticleListViewModel instance to pass in the new repository instead of the old service. Finally, make it public as we will need to access it outside of the class.val appModule = module { single\u003cApiService\u003e { ApiService() } single\u003cArticlesRepository\u003e { ArticlesRepository( databaseDriverFactory = get(), api = get() ) } viewModel { ArticleListViewModel(repository = get()) }}Next, delete the koinConfig: KoinAppDeclaration property, as we will need to create it directly at the call site later.And finally, we will declare a new platform-specific module that each platform will implement to provide the respective database driver.expect val platformModule: ModuleUpdate AppOpen the App file and update the App composable to accept an optional KoinAppDeclaration argument. We will use this to provide an Android-specific Context object through Koin.@Composablefun App(koinAppDeclaration: KoinAppDeclaration? = null) { ...}Next, update the call to the KoinApplication composable to not use the deleted koinConfig, but create an instance right there. In it, we will invoke the optional KoinAppDeclaration and provide the needed modules.@Composable@Previewfun App(koinAppDeclaration: KoinAppDeclaration? = null) { KoinApplication(application = { koinAppDeclaration?.invoke(this) modules(appModule, platformModule) }) { ... }}Update MainActivityThe Android database driver requires a Context object, which is only supported on Android. We need a way to provide it with Koin, and the only place where it’s accessible is in the composeApp/androidMain source set.Open MainActivity and update the call to the App() composable by passing in a new instance of KoinAppDeclaration and providing the Context object using the androidContext extension function.setContent { App({ androidContext(this@MainActivity.applicationContext) })}Koin can now provide the Context object whenever we need it.Implement platform-specific modulesOur setup is nearly complete. We just have to provide the actual implementation of the platformModule we declared earlier in AppModule.For Android, create a new AppModule.android.kt file under the composeApp/androidMain/your.package.spaceflightnews/di directory. Start typing the word actual and autocomplete should suggest the platformModule property. We need to return a new Module that provides an instance of the AndroidDatabaseDriverFactory as the implementation of DatabaseDriverFactory interface. Because we earlier provided Koin with the Context object, we can use the get() function inside single to access it.actual val platformModule: Module get() = module { single\u003cDatabaseDriverFactory\u003e { AndroidDatabaseDriverFactory(context = get()) } }For iOS, create a new AppModule.ios.kt file under the composeApp/iOSMain/your.package.spaceflightnews/di and similarly implement the platformModule property and provide an instance of IOSDatabaseDriverFactory.actual val platformModule: Module get() = module { single\u003cDatabaseDriverFactory\u003e { IOSDatabaseDriverFactory() } }And finally, for Desktop, create a new AppModule.desktop.kt file under the composeApp/desktopMain/your.package.spaceflightnews/di and implement the platformModule property and provide an instance of DesktopDatabaseDriverFactory.actual val platformModule: Module get() = module { single\u003cDatabaseDriverFactory\u003e { DesktopDatabaseDriverFactory() } }4. Run and test the appAfter a lot of setup, it’s finally time to run and test the app! The Android and Desktop apps should build and run with no issues. The iOS build requires an additional step to support the SQLite database.Android app running in offline mode.Desktop app running in offline mode.Fixing the iOS buildBefore we can run the iOS app, we have to add the dynamic linking flag for SQLDelight to Xcode build settings. This will allow the Xcode tooling to find the system-provided SQLite binary needed for the NativeDatabaseDriver to work.Open the iOS project in Xcode and double-click on the project name.In the settings, select the “Build Settings” tab and search for the “Other Linker Flags” property.Double-click on the empty property value, then press the “+” button, enter -lsqlite3, and press “Enter”.Run the project.Adding the necessary config to Xcode to support the SQLite database.iOS app running in offline mode.5. ConclusionIf you followed to the end, great job! This is the end of the third part of the series on Kotlin Multiplatform and Compose Multiplatform. We’ve improved our app by adding the loading state and handling errors gracefully. Then we’ve introduced offline mode support by adding a local database to our app with SQLDelight.In the next part of the series, we are going to:Add a detail screen showing the full article.Add the Compose Navigation library to navigate to the new detail screen.Add a system share functionality to share links to articles with different apps.Show how to open the article URL in a web browser.Stay tuned!Current state of the app.You can find the source code for this part here:",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*qxGtk56CGYdwZgPDmT_GJA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"6d95\" data-testid=\"storyTitle\"\u003eBuilding a Space News App with Compose Multiplatform for Android, iOS, and Desktop: Part 3 — Offline Support with SQLDelight\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@domen.lanisnik?source=post_page---byline--1efe6545f885---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Domen Lanišnik\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*CHMrHH5mrrGDp0Vsm-UtKw.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"97df\"\u003eThis is the third part of a series of articles focusing on Compose Multiplatform. We are building an app for Android, iOS, and Desktop that displays the latest Space Flight news.\u003c/p\u003e\u003cp id=\"a979\"\u003eThis part will focus on the following:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a787\"\u003eadding loading state and error handling when fetching the data,\u003c/li\u003e\u003cli id=\"0721\"\u003eand integrating a local cache using SQLDelight to make the app work even in offline mode.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003eShowcase of the final app.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"57d4\"\u003eRecap of the first two parts\u003c/h2\u003e\u003cp id=\"a28d\"\u003eThis article continues from where the second part left off, so make sure to start there if you haven’t yet.\u003c/p\u003e\u003cp id=\"609d\"\u003eSo far, we’ve learned the following:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b60f\"\u003ehow Kotlin Multiplatform works\u003c/li\u003e\u003cli id=\"4642\"\u003esharing UI using Compose Multiplatform on iOS, Android, and Desktop\u003c/li\u003e\u003cli id=\"2bc8\"\u003eloading remote images with Coil\u003c/li\u003e\u003cli id=\"7485\"\u003eadding network layer for fetching remote data with Ktor\u003c/li\u003e\u003cli id=\"82e9\"\u003eadding dependency injection with Koin.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"09c0\"\u003eYou can find the code after part 2, and what will be our starting point for this article, here:\u003c/p\u003e\u003ch2 id=\"f59b\"\u003e1. Add loading and error states\u003c/h2\u003e\u003cp id=\"8f8b\"\u003eUser \u003cspan\u003e\u003cspan aria-hidden=\"false\"\u003e\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e reported that the app currently crashes when there is no internet connection or a network error occurs. They went further and opened a pull request fixing the issue. I would like to publicly thank them for their contribution and describe the changes that have been added since the last update.\u003c/p\u003e\u003ch2 id=\"cefa\"\u003eDefining the error and loading states\u003c/h2\u003e\u003cp id=\"1845\"\u003eFirst, let’s extend \u003ccode\u003eArticleListViewState\u003c/code\u003e in the \u003ccode\u003eArticleListViewModel\u003c/code\u003e class to support the loading and error states. To do that, we can replace the current \u003ccode\u003edata class\u003c/code\u003e with a \u003ccode\u003esealed interface\u003c/code\u003e and define \u003ccode\u003eLoading\u003c/code\u003e, \u003ccode\u003eSuccess\u003c/code\u003e, and \u003ccode\u003eError\u003c/code\u003e sub-classes. This will allow us to differentiate between states easily.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"68ea\"\u003esealed interface ArticleListViewState {\u003cbr/\u003e    data object Loading : ArticleListViewState\u003cbr/\u003e    data class Success(val articles: List\u0026lt;Article\u0026gt; = emptyList()) : ArticleListViewState\u003cbr/\u003e    data class Error(val errorType: ErrorType) : ArticleListViewState\u003cbr/\u003e}\u003cp\u003esealed class ErrorType {\u003cbr/\u003e    data object NoInternet : ErrorType()\u003cbr/\u003e    data object ServerError : ErrorType()\u003cbr/\u003e    data object Unknown : ErrorType()\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"7ea1\"\u003eSending the new states\u003c/h2\u003e\u003cp id=\"2806\"\u003eNow that we have our new states defined, let’s update \u003ccode\u003eArticleListViewModel\u003c/code\u003e to use them. Update the \u003ccode\u003eMutableStateFlow\u003c/code\u003e definition to use the default value of \u003ccode\u003eArticleListViewState.Loading\u003c/code\u003e. We want the app to display a loading state right from the start.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8e54\"\u003eprivate val _state = MutableStateFlow\u0026lt;ArticleListViewState\u0026gt;(ArticleListViewState.Loading)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f2d1\"\u003eNext, let’s update the \u003ccode\u003einit\u003c/code\u003e block where we are currently loading the data. Extract everything inside the \u003ccode\u003einit\u003c/code\u003e block to a new public function called \u003ccode\u003efetchArticles()\u003c/code\u003e. Having a separate function will allow us to reuse it when retrying a failed request.\u003c/p\u003e\u003cp id=\"207e\"\u003eWe’re wrapping the whole request into a \u003ccode\u003etry/catch\u003c/code\u003e block to handle any exceptions and then update the state with either a \u003ccode\u003eSuccess\u003c/code\u003e or an \u003ccode\u003eError\u003c/code\u003e state.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5413\"\u003einit {\u003cbr/\u003e    fetchArticles()\u003cbr/\u003e}\u003cp\u003efun fetchArticles() {\u003cbr/\u003e    viewModelScope.launch {\u003cbr/\u003e        _state.value = ArticleListViewState.Loading\u003cbr/\u003e        try {\u003cbr/\u003e            val articles = apiService.getArticles()\u003cbr/\u003e                .filter { it.imageUrl.isNotEmpty() }\u003cbr/\u003e            _state.value = ArticleListViewState.Success(articles)\u003cbr/\u003e        } catch (_: IOException) {\u003cbr/\u003e            _state.value = ArticleListViewState.Error(ErrorType.NoInternet)\u003cbr/\u003e        } catch (_: HttpException) {\u003cbr/\u003e            _state.value = ArticleListViewState.Error(ErrorType.ServerError)\u003cbr/\u003e        } catch (_: Exception) {\u003cbr/\u003e            _state.value = ArticleListViewState.Error(ErrorType.Unknown)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"0d17\"\u003eAdd new strings\u003c/h2\u003e\u003cp id=\"f386\"\u003eWe’ll need some new strings/texts for the error messages. Open the \u003ccode\u003ecomposeApp/commonMain/composeResources/values/strings.xml\u003c/code\u003e file and add the following new strings.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bd5b\"\u003e\u0026lt;resources\u0026gt;\u003cbr/\u003e    \u0026lt;string name=\u0026#34;retry\u0026#34;\u0026gt;Retry\u0026lt;/string\u0026gt;\u003cbr/\u003e    \u0026lt;string name=\u0026#34;no_internet\u0026#34;\u0026gt;No internet connection. Please try again\u0026lt;/string\u0026gt;\u003cbr/\u003e    \u0026lt;string name=\u0026#34;server_error\u0026#34;\u0026gt;Server error. Please try again later\u0026lt;/string\u0026gt;\u003cbr/\u003e    \u0026lt;string name=\u0026#34;something_went_wrong\u0026#34;\u0026gt;Something went wrong. Please try again\u0026lt;/string\u0026gt;\u003cbr/\u003e\u0026lt;/resources\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3053\"\u003eUpdating the UI states\u003c/h2\u003e\u003cp id=\"fc7f\"\u003eNow that we have our state models defined, we can update the UI layer. In \u003ccode\u003eArticleListScreen\u003c/code\u003e class we currently have a \u003ccode\u003eArticleListScreen()\u003c/code\u003e composable that is currently presenting the \u003ccode\u003eArticleListContent(articles)\u003c/code\u003e composable. That is our success state, but we now need to add the loading and error states.\u003c/p\u003e\u003cp id=\"4883\"\u003eLet’s use a \u003ccode\u003ewhen\u003c/code\u003e statement to check for the type of the state and then either draw a progress indicator, the existing \u003ccode\u003eArticleListContent(article)\u003c/code\u003e, or a new error layout that shows an error message and a retry button. When the retry button is clicked, we call \u003ccode\u003eviewModel.fetchArticles()\u003c/code\u003e to retry again.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5ca3\"\u003eBox(modifier = Modifier.fillMaxSize()) {\u003cbr/\u003e    when (val currentState = state) {\u003cbr/\u003e        is ArticleListViewState.Loading -\u0026gt; {\u003cbr/\u003e            CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))\u003cbr/\u003e        }\u003cp\u003e        is ArticleListViewState.Success -\u0026gt; {\u003cbr/\u003e            val articles = currentState.articles\u003cbr/\u003e            ArticleListContent(articles = articles)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        is ArticleListViewState.Error -\u0026gt; {\u003cbr/\u003e            val errorMessage = when (currentState.errorType) {\u003cbr/\u003e                ErrorType.NoInternet -\u0026gt; stringResource(Res.string.no_internet)\u003cbr/\u003e                ErrorType.ServerError -\u0026gt; stringResource(Res.string.server_error)\u003cbr/\u003e                ErrorType.Unknown -\u0026gt; stringResource(Res.string.something_went_wrong)\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            Column(\u003cbr/\u003e                horizontalAlignment = Alignment.CenterHorizontally,\u003cbr/\u003e                modifier = Modifier.align(Alignment.Center)\u003cbr/\u003e            ) {\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = errorMessage,\u003cbr/\u003e                    color = Color.Red,\u003cbr/\u003e                    style = MaterialTheme.typography.bodyMedium,\u003cbr/\u003e                    modifier = Modifier.padding(16.dp)\u003cbr/\u003e                )\u003c/p\u003e\u003cp\u003e                Button(onClick = { viewModel.fetchArticles() }) {\u003cbr/\u003e                    Text(text = stringResource(Res.string.retry))\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"50ff\"\u003eThe result after launching the app without an internet connection is the following.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eUpdated app showing the error and loading states.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"2f34\"\u003e2. Add Local Cache using SQLDelight\u003c/h2\u003e\u003cp id=\"77b2\"\u003eCurrently, if you open the app without an internet connection, you will see an error. We want to be able to use the app and see previously loaded news articles. To do that, we need a persistent local cache to which we will store the fetched articles.\u003c/p\u003e\u003cp id=\"9538\"\u003e\u003ca href=\"https://github.com/sqldelight/sqldelight\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSQLDelight\u003c/a\u003e is a simple-to-use wrapper around an SQLite database that works with Kotlin Multiplatform.\u003c/p\u003e\u003ch2 id=\"43d7\"\u003eAdd dependencies\u003c/h2\u003e\u003cp id=\"0dde\"\u003eAs a first step, we have to add the necessary SQLDelight dependencies to the project. Open the \u003ccode\u003egradle/libs.versions.toml\u003c/code\u003e file and add the new libraries. Since we are supporting three different platforms, we have to add the database driver for each of them, alongside the core \u003ccode\u003eruntime\u003c/code\u003e dependency. Additionally, we will also be using the coroutines extensions library, which will allow us to observe changes using a Kotlin Flow.\u003c/p\u003e\u003cp id=\"1302\"\u003eWe also need to define a new plugin.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0914\"\u003e[versions]\u003cbr/\u003esql-delight = \u0026#34;2.1.0\u0026#34;\u003cp\u003e[libraries]\u003cbr/\u003esqldelight-android-driver = { module = \u0026#34;app.cash.sqldelight:android-driver\u0026#34;, version.ref = \u0026#34;sql-delight\u0026#34; }\u003cbr/\u003esqldelight-desktop-driver = { module = \u0026#34;app.cash.sqldelight:sqlite-driver\u0026#34;, version.ref = \u0026#34;sql-delight\u0026#34; }\u003cbr/\u003esqldelight-native-driver = { module = \u0026#34;app.cash.sqldelight:native-driver\u0026#34;, version.ref = \u0026#34;sql-delight\u0026#34; }\u003cbr/\u003esqldelight-runtime = { module = \u0026#34;app.cash.sqldelight:runtime\u0026#34;, version.ref = \u0026#34;sql-delight\u0026#34; }\u003cbr/\u003esqldelight-coroutines-ext = { module = \u0026#34;app.cash.sqldelight:coroutines-extensions\u0026#34;, version.ref = \u0026#34;sql-delight\u0026#34; }\u003c/p\u003e\u003cp\u003e[plugins]\u003cbr/\u003esqldelight = { id = \u0026#34;app.cash.sqldelight\u0026#34;, version.ref = \u0026#34;sql-delight\u0026#34; }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0d04\"\u003eNext, let’s open the \u003ccode\u003ecomposeApp/build.gradle.kts\u003c/code\u003e file and add the new dependency to the supported source sets.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e0c8\"\u003eandroidMain.dependencies {\u003cbr/\u003e    implementation(libs.sqldelight.android.driver)\u003cbr/\u003e}\u003cbr/\u003ecommonMain.dependencies {\u003cbr/\u003e    implementation(libs.sqldelight.runtime)\u003cbr/\u003e    implementation(libs.sqldelight.coroutines.ext)\u003cbr/\u003e}\u003cbr/\u003eiosMain.dependencies {\u003cbr/\u003e    implementation(libs.sqldelight.native.driver)\u003cbr/\u003e}\u003cbr/\u003edesktopMain.dependencies {\u003cbr/\u003e    implementation(libs.sqldelight.desktop.driver)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6c01\"\u003eIn the same file, scroll to the top where the \u003ccode\u003eplugins\u003c/code\u003e block is and add the SQLDelight plugin.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1867\"\u003eplugins {\u003cbr/\u003e    alias(libs.plugins.sqldelight)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"48cb\"\u003ePerform a gradle sync, then add the following \u003ccode\u003esqldelight\u003c/code\u003e block to the end of the file. It configures the name of the database. Do another sync afterwards.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6b29\"\u003esqldelight {\u003cbr/\u003e    databases {\u003cbr/\u003e        create(\u0026#34;AppDatabase\u0026#34;) {\u003cbr/\u003e            packageName.set(\u0026#34;your.package.spaceflightnews.cache\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"151f\"\u003eGenerate the database structure\u003c/h2\u003e\u003cp id=\"c617\"\u003eSQLDelight works by turning SQL queries that you write into a type-safe Kotlin database API.\u003c/p\u003e\u003cp id=\"3d17\"\u003eCreate a new directory under the \u003ccode\u003ecomposeApp/commonMain\u003c/code\u003e directory named \u003ccode\u003esqldelight\u003c/code\u003e. The \u003ccode\u003ecommonMain\u003c/code\u003e directory should now have three folders: \u003ccode\u003ecomposeResources\u003c/code\u003e, \u003ccode\u003ekotlin\u003c/code\u003e, and \u003ccode\u003esqldelight\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"4155\"\u003eInside the new \u003ccode\u003esqldelight\u003c/code\u003e directory, create additional packages so that they match the package name you added above: \u003ccode\u003eyour.package.spaceflightnews.cache\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"e24e\"\u003eThen, inside the new package, create a new file named \u003ccode\u003eAppDatabase.sq\u003c/code\u003e and open it.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"156d\"\u003eYou might see a suggestion from Android Studio to install a plugin for working with SQLDelight files. Feel free to install it to get syntax highlighting, but is not necessary.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"f25b\"\u003eFirst, we have to create a table into which we will store the articles. This will be a copy of our \u003ccode\u003eArticle\u003c/code\u003e model, but written in SQL. We are using the \u003ccode\u003eid\u003c/code\u003e of the article as the primary key as it’s unique for every article. Other columns are of type \u003ccode\u003eTEXT\u003c/code\u003e, including the dates. We will serialize them to the ISO 8601 (\u003ccode\u003e2023–01–02T23:40:57.120Z\u003c/code\u003e) format for storing.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6367\"\u003eCREATE TABLE Article (\u003cbr/\u003e    id INTEGER NOT NULL PRIMARY KEY,\u003cbr/\u003e    title TEXT NOT NULL,\u003cbr/\u003e    url TEXT NOT NULL,\u003cbr/\u003e    imageUrl TEXT NOT NULL,\u003cbr/\u003e    newsSite TEXT NOT NULL,\u003cbr/\u003e    summary TEXT NOT NULL,\u003cbr/\u003e    publishedAt TEXT NOT NULL,\u003cbr/\u003e    updatedAt TEXT NOT NULL\u003cbr/\u003e);\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f7e4\"\u003eNow that we have our table, we have to define the queries for storing and fetching the data from the table. In \u003ccode\u003e.sq\u003c/code\u003e files we do that by defining the name of the function and then the corresponding SQL query. SQLDelight will then generate a Kotlin function with that name.\u003c/p\u003e\u003cp id=\"bd05\"\u003eWe need four queries for now to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9b2e\"\u003einsert an article,\u003c/li\u003e\u003cli id=\"a586\"\u003edelete all stored articles,\u003c/li\u003e\u003cli id=\"c9ac\"\u003efetch all stored articles,\u003c/li\u003e\u003cli id=\"4000\"\u003efetch a specific stored article by id.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"7816\"\u003eselectNewestArticles:\u003cbr/\u003eSELECT * FROM Article\u003cbr/\u003eORDER BY id DESC\u003cbr/\u003eLIMIT 10;\u003cp\u003eselectArticleById:\u003cbr/\u003eSELECT * FROM Article\u003cbr/\u003eWHERE id = ?\u003cbr/\u003eLIMIT 1;\u003c/p\u003e\u003cp\u003einsertOrReplaceArticle:\u003cbr/\u003eINSERT OR REPLACE INTO Article(\u003cbr/\u003e    id,\u003cbr/\u003e    title,\u003cbr/\u003e    url,\u003cbr/\u003e    imageUrl,\u003cbr/\u003e    newsSite,\u003cbr/\u003e    summary,\u003cbr/\u003e    publishedAt,\u003cbr/\u003e    updatedAt\u003cbr/\u003e) VALUES (?, ?, ?, ?, ?, ?, ?, ?);\u003c/p\u003e\u003cp\u003eremoveAllArticles:\u003cbr/\u003eDELETE FROM Article;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7066\"\u003eWhat we have to do next is to generate the Kotlin code based on the queries. Open the terminal in Android Studio and run the following command: \u003ccode\u003e./gradlew generateCommonMainAppDatabaseInterface\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"6ed9\"\u003eAfter it has finished, you will find the generated Kotlin code in the \u003ccode\u003ecomposeApp/build/generated/sqldelight\u003c/code\u003e directory. This will include the \u003ccode\u003eAppDatabase\u003c/code\u003e interface for interacting with the database, together with its implementation, and a \u003ccode\u003eAppDatabaseQueries\u003c/code\u003e class that contains the functions to query the database.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eGenerated Kotlin code by the SQLDelight library.\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"bf1c\"\u003eAnytime you change the \u003ccode\u003e.sq\u003c/code\u003e file, you must re-run the \u003ccode\u003e./gradlew generateCommonMainAppDatabaseInterface\u003c/code\u003e command.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"ead2\"\u003eInitializing the database\u003c/h2\u003e\u003cp id=\"297f\"\u003eIf we take a look at the \u003ccode\u003eAppDatabase\u003c/code\u003e interface, we see that it expects an instance of \u003ccode\u003eSqlDriver\u003c/code\u003e in the constructor. Since SQL drivers are platform-specific, we have to provide separate instances for each platform.\u003c/p\u003e\u003cp id=\"e97a\"\u003eLet’s start by creating a common interface for the driver factory in the \u003ccode\u003ecomposeApp/commonMain/your.package.spaceflightnews/cache\u003c/code\u003e directory.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f9b0\"\u003eimport app.cash.sqldelight.db.SqlDriver\u003cp\u003einterface DatabaseDriverFactory {\u003cbr/\u003e    fun createDriver(): SqlDriver\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f054\"\u003eNext, let’s add the Android-specific implementation. Create a new \u003ccode\u003eAndroidDatabaseDriverFactory\u003c/code\u003e class in the \u003ccode\u003ecomposeApp/androidMain/your.package.spaceflightnews/cache\u003c/code\u003e directory that extends the \u003ccode\u003eDatabaseDriverFactory\u003c/code\u003e interface. It needs to accept an instance of \u003ccode\u003eContext\u003c/code\u003e as it’s required by the \u003ccode\u003eAndroidSqliteDriver\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fff0\"\u003eimport android.content.Context\u003cbr/\u003eimport app.cash.sqldelight.db.SqlDriver\u003cbr/\u003eimport app.cash.sqldelight.driver.android.AndroidSqliteDriver\u003cp\u003eclass AndroidDatabaseDriverFactory(private val context: Context): DatabaseDriverFactory {\u003c/p\u003e\u003cp\u003e    override fun createDriver(): SqlDriver {\u003cbr/\u003e        return AndroidSqliteDriver(AppDatabase.Schema, context, \u0026#34;articles.db\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1646\"\u003eIn similar fashion, create a new \u003ccode\u003eIOSDatabaseDriverFactory\u003c/code\u003e in the \u003ccode\u003ecomposeApp/iosMain/your.package.spaceflightnews/cache\u003c/code\u003e directory. Here, we’re creating an instance of \u003ccode\u003eNativeSqliteDriver\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5f4f\"\u003eimport app.cash.sqldelight.db.SqlDriver\u003cbr/\u003eimport app.cash.sqldelight.driver.native.NativeSqliteDriver\u003cp\u003eclass IOSDatabaseDriverFactory: DatabaseDriverFactory {\u003cbr/\u003e    override fun createDriver(): SqlDriver {\u003cbr/\u003e        return NativeSqliteDriver(AppDatabase.Schema, \u0026#34;articles.db\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"be40\"\u003eAnd then finally, create one for the desktop in the \u003ccode\u003ecomposeApp/desktopMain/your.package.spaceflightnews/cache\u003c/code\u003e directory. The desktop driver is the most peculiar, as we need to create an instance of the \u003ccode\u003eJdbcSqliteDriver\u003c/code\u003e and pass in the database schema.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"324f\"\u003eimport app.cash.sqldelight.db.SqlDriver\u003cbr/\u003eimport app.cash.sqldelight.driver.jdbc.sqlite.JdbcSqliteDriver\u003cp\u003eclass DesktopDatabaseDriverFactory: DatabaseDriverFactory {\u003c/p\u003e\u003cp\u003e    override fun createDriver(): SqlDriver {\u003cbr/\u003e        return JdbcSqliteDriver(\u0026#34;jdbc:sqlite:articles.db\u0026#34;, Properties(), AppDatabase.Schema)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"d295\"\u003eCreating a database wrapper\u003c/h2\u003e\u003cp id=\"2e70\"\u003eNow that we have our drivers, we can create a wrapper around the generated database code that will contain our own logic.\u003c/p\u003e\u003cp id=\"ca77\"\u003eCreate a new \u003ccode\u003eDatabase\u003c/code\u003e class in the \u003ccode\u003ecomposeApp/commonMain/your.package.spaceflightnews/cache\u003c/code\u003e directory. It should accept an instance of \u003ccode\u003eDatabaseDriverFactory\u003c/code\u003e interface in the constructor. We use it to create an instance of the generated \u003ccode\u003eAppDatabase\u003c/code\u003e, which in turn gives us access to the generated database queries.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3fae\"\u003einternal class Database(databaseDriverFactory: DatabaseDriverFactory) {\u003cbr/\u003e    private val database = AppDatabase(databaseDriverFactory.createDriver())\u003cbr/\u003e    private val dbQueries = database.appDatabaseQueries\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5dba\"\u003eNext, let’s add a new function \u003ccode\u003einsertArticles\u003c/code\u003e for storing the articles in the database. It accepts a list of the existing \u003ccode\u003eArticle\u003c/code\u003e models and then inserts each of them into the \u003ccode\u003eArticle\u003c/code\u003e table. Before that, we remove all existing articles so that we always have the latest ones stored.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"3a0e\"\u003eNote that we are doing this in a transaction to prevent data loss in case the delete query would be successful, but one of the insert queries would fail.\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"a86e\"\u003efun insertArticles(articles: List\u0026lt;Article\u0026gt;) {\u003cbr/\u003e    dbQueries.transaction {\u003cbr/\u003e        dbQueries.removeAllArticles()\u003cbr/\u003e        articles.forEach { article -\u0026gt;\u003cbr/\u003e            dbQueries.insertOrReplaceArticle(\u003cbr/\u003e                id = article.id,\u003cbr/\u003e                title = article.title,\u003cbr/\u003e                url = article.url,\u003cbr/\u003e                imageUrl = article.imageUrl,\u003cbr/\u003e                newsSite = article.newsSite,\u003cbr/\u003e                summary = article.summary,\u003cbr/\u003e                publishedAt = article.publishedAt.toString(),\u003cbr/\u003e                updatedAt = article.updatedAt.toString(),\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a67f\"\u003eNow that we’ve inserted the data, we also need functions for fetching it. Create a new function \u003ccode\u003egetNewestArticles\u003c/code\u003e that returns all the stored data from newest to oldest.\u003c/p\u003e\u003cp id=\"9890\"\u003eWe can see that the generated query contains a mapper function, which we can use to map individual table columns into our \u003ccode\u003eArticle\u003c/code\u003e object.\u003c/p\u003e\u003cp id=\"9049\"\u003eWe are using the \u003ccode\u003e.asFlow()\u003c/code\u003e extension function from the \u003ccode\u003esqldelight-coroutines-extensions\u003c/code\u003e library to observe changes to the \u003ccode\u003eArticle\u003c/code\u003e table. We will need this for easy offline mode.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"de98\"\u003eAs the \u003ccode\u003eArticle\u003c/code\u003e model uses the \u003ccode\u003eInstant\u003c/code\u003e type for its \u003ccode\u003epublishedAt\u003c/code\u003e and \u003ccode\u003eupdatedAt\u003c/code\u003e fields, we have to serialize it to a string to be able to store it into the database. We are leveraging the \u003ccode\u003eInstant.toString()\u003c/code\u003e function for that, which returns an ISO 8601 representation of the date (\u003ccode\u003e2023–01–02T23:40:57.120Z\u003c/code\u003e). To then convert the string back to an \u003ccode\u003eInstant\u003c/code\u003e, we are using the \u003ccode\u003eInstant.parse(string)\u003c/code\u003e constructor.\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"bfc6\"\u003eimport app.cash.sqldelight.coroutines.asFlow\u003cbr/\u003eimport app.cash.sqldelight.coroutines.mapToList\u003cbr/\u003eimport kotlinx.coroutines.Dispatchers\u003cbr/\u003eimport kotlinx.coroutines.IO\u003cbr/\u003eimport kotlinx.coroutines.flow.Flow\u003cbr/\u003eimport kotlinx.datetime.Instant\u003cp\u003efun getNewestArticles(): Flow\u0026lt;List\u0026lt;Article\u0026gt;\u0026gt; {\u003cbr/\u003e    return dbQueries.selectNewestArticles { id, title, url, imageUrl, newsSite, summary, publishedAt, updatedAt -\u0026gt;\u003cbr/\u003e        Article(\u003cbr/\u003e            id = id,\u003cbr/\u003e            title = title,\u003cbr/\u003e            url = url,\u003cbr/\u003e            imageUrl = imageUrl,\u003cbr/\u003e            newsSite = newsSite,\u003cbr/\u003e            summary = summary,\u003cbr/\u003e            publishedAt = Instant.parse(publishedAt),\u003cbr/\u003e            updatedAt = Instant.parse(updatedAt),\u003cbr/\u003e        )\u003cbr/\u003e    }.asFlow().mapToList(Dispatchers.IO)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d37a\"\u003eAnd finally, we need one more function to fetch a specific article by id. We will use it on the new detail screen.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"554c\"\u003efun getArticleById(id: Long): Article? {\u003cbr/\u003e    return dbQueries.selectArticleById(id) { id, title, url, imageUrl, newsSite, summary, publishedAt, updatedAt -\u0026gt;\u003cbr/\u003e        Article(\u003cbr/\u003e            id = id,\u003cbr/\u003e            title = title,\u003cbr/\u003e            url = url,\u003cbr/\u003e            imageUrl = imageUrl,\u003cbr/\u003e            newsSite = newsSite,\u003cbr/\u003e            summary = summary,\u003cbr/\u003e            publishedAt = Instant.parse(publishedAt),\u003cbr/\u003e            updatedAt = Instant.parse(updatedAt),\u003cbr/\u003e        )\u003cbr/\u003e    }.executeAsOneOrNull()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"371a\"\u003eCreate a Repository\u003c/h2\u003e\u003cp id=\"8ff3\"\u003eNow that we have our database set up, it’s time to use it. We are going to create a \u003ca href=\"https://medium.com/@pererikbergman/repository-design-pattern-e28c0f3e4a30\" rel=\"noopener\"\u003eRepository\u003c/a\u003e that will contain logic for interaction between the network layer and the local layer, but hide it from the caller.\u003c/p\u003e\u003cp id=\"5003\"\u003eCreate a new \u003ccode\u003eArticlesRepository\u003c/code\u003e class in the \u003ccode\u003ecomposeApp/commonMain/your.package.spaceflightnews/data\u003c/code\u003e directory. It should accept the \u003ccode\u003eDatabaseDriverFactory\u003c/code\u003e interface and the \u003ccode\u003eApiService\u003c/code\u003e class as constructor parameters. We also need to initialize the \u003ccode\u003eDatabase\u003c/code\u003e class we created earlier and pass in the \u003ccode\u003eDatabaseDriverFactory\u003c/code\u003e instance.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c6f0\"\u003eimport com.landomen.spaceflightnews.cache.Database\u003cbr/\u003eimport com.landomen.spaceflightnews.cache.DatabaseDriverFactory\u003cbr/\u003eimport com.landomen.spaceflightnews.network.ApiService\u003cp\u003einternal class ArticlesRepository(\u003cbr/\u003e    databaseDriverFactory: DatabaseDriverFactory,\u003cbr/\u003e    private val api: ApiService\u003cbr/\u003e) {\u003cbr/\u003e    private val database = Database(databaseDriverFactory)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dc4b\"\u003eNext, let’s define two functions that we will call from the UI layer:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0e51\"\u003e\u003ccode\u003egetArticles()\u003c/code\u003e: tries to first fetch the latest data from the API, store it in the local database, and return it. If the network request fails, it will try to return the data from the local database. If the data is not yet cached (first run) or it fails, it will throw the original exception.\u003c/li\u003e\u003cli id=\"1802\"\u003e\u003ccode\u003egetArticlyById(id: Long)\u003c/code\u003e: returns a specific article or null if it’s not found\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"bdc3\"\u003eWe are using the local database as a fallback in case of an error for simplicity sake. Another potential solution would be to observe the articles table using a Kotlin Flow and then trigger a network request as a side-effect, storing data into the database, which in turn would re-emit the changes.\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"fb09\"\u003esuspend fun getArticles(): List\u0026lt;Article\u0026gt; {\u003cbr/\u003e    try {\u003cbr/\u003e        return api.getArticles().also {\u003cbr/\u003e            database.insertArticles(it)\u003cbr/\u003e        }\u003cbr/\u003e    } catch (e: Exception) {\u003cbr/\u003e        try {\u003cbr/\u003e            val storedArticles = database.getNewestArticles()\u003cbr/\u003e            if (storedArticles.isNotEmpty()) {\u003cbr/\u003e                return storedArticles\u003cbr/\u003e            }\u003cbr/\u003e            throw e\u003cbr/\u003e        } catch (e: Exception) {\u003cbr/\u003e            throw e\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003efun getArticleById(id: Long): Article? {\u003cbr/\u003e    return database.getArticleById(id)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"306d\"\u003eUpdate ViewModel\u003c/h2\u003e\u003cp id=\"7795\"\u003eNow that we have our repository set up as well as the database layer, let’s use it in the view model. Open \u003ccode\u003eArticleListViewModel\u003c/code\u003e and replace the \u003ccode\u003eApiService\u003c/code\u003e dependency with the new \u003ccode\u003eArticlesRepository\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3fc5\"\u003einternal class ArticleListViewModel(private val repository: ArticlesRepository) : ViewModel() {\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a804\"\u003eNext, update the \u003ccode\u003efetchArticles()\u003c/code\u003e function and replace \u003ccode\u003eapiService.getArticles()\u003c/code\u003e call with \u003ccode\u003erepository.getArticles()\u003c/code\u003e call. And that’s it! Our View Model is now using both the network and local database to fetch articles and show them even when no internet connection.\u003c/p\u003e\u003cp id=\"4b2e\"\u003eHowever, the app currently fails to build as we need to provide the new dependencies.\u003c/p\u003e\u003ch2 id=\"b48e\"\u003e3. Updating dependency injection\u003c/h2\u003e\u003cp id=\"7c96\"\u003eWe have everything set up; the only thing remaining is the dependency injection. We have to provide instances of the new classes with Koin.\u003c/p\u003e\u003ch2 id=\"b8aa\"\u003eUpdate \u003ccode\u003eAppModule\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"b567\"\u003eLet’s start with the \u003ccode\u003eAppModule\u003c/code\u003e file. Let’s update the \u003ccode\u003eappModule\u003c/code\u003e property by providing the \u003ccode\u003eArticlesRepository\u003c/code\u003e and then updating the \u003ccode\u003eArticleListViewModel\u003c/code\u003e instance to pass in the new repository instead of the old service. Finally, make it public as we will need to access it outside of the class.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5e2a\"\u003eval appModule = module {\u003cbr/\u003e    single\u0026lt;ApiService\u0026gt; { ApiService() }\u003cbr/\u003e    single\u0026lt;ArticlesRepository\u0026gt; {\u003cbr/\u003e        ArticlesRepository(\u003cbr/\u003e            databaseDriverFactory = get(),\u003cbr/\u003e            api = get()\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e    viewModel { ArticleListViewModel(repository = get()) }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a84f\"\u003eNext, delete the \u003ccode\u003ekoinConfig: KoinAppDeclaration\u003c/code\u003e property, as we will need to create it directly at the call site later.\u003c/p\u003e\u003cp id=\"db84\"\u003eAnd finally, we will declare a new platform-specific module that each platform will implement to provide the respective database driver.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"006a\"\u003eexpect val platformModule: Module\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"bf38\"\u003eUpdate \u003ccode\u003eApp\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"633a\"\u003eOpen the \u003ccode\u003eApp\u003c/code\u003e file and update the \u003ccode\u003eApp\u003c/code\u003e composable to accept an optional \u003ccode\u003eKoinAppDeclaration\u003c/code\u003e argument. We will use this to provide an Android-specific Context object through Koin.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c8f2\"\u003e@Composable\u003cbr/\u003efun App(koinAppDeclaration: KoinAppDeclaration? = null) {\u003cbr/\u003e    ...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0ebe\"\u003eNext, update the call to the \u003ccode\u003eKoinApplication\u003c/code\u003e composable to not use the deleted \u003ccode\u003ekoinConfig\u003c/code\u003e, but create an instance right there. In it, we will invoke the optional \u003ccode\u003eKoinAppDeclaration\u003c/code\u003e and provide the needed modules.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6b9a\"\u003e@Composable\u003cbr/\u003e@Preview\u003cbr/\u003efun App(koinAppDeclaration: KoinAppDeclaration? = null) {\u003cbr/\u003e    KoinApplication(application = {\u003cbr/\u003e        koinAppDeclaration?.invoke(this)\u003cbr/\u003e        modules(appModule, platformModule)\u003cbr/\u003e    }) {\u003cbr/\u003e        ...\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"daa2\"\u003eUpdate MainActivity\u003c/h2\u003e\u003cp id=\"6fb5\"\u003eThe Android database driver requires a \u003ccode\u003eContext\u003c/code\u003e object, which is only supported on Android. We need a way to provide it with Koin, and the only place where it’s accessible is in the \u003ccode\u003ecomposeApp/androidMain\u003c/code\u003e source set.\u003c/p\u003e\u003cp id=\"2ec3\"\u003eOpen \u003ccode\u003eMainActivity\u003c/code\u003e and update the call to the \u003ccode\u003eApp()\u003c/code\u003e composable by passing in a new instance of \u003ccode\u003eKoinAppDeclaration\u003c/code\u003e and providing the \u003ccode\u003eContext\u003c/code\u003e object using the \u003ccode\u003eandroidContext\u003c/code\u003e extension function.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c512\"\u003esetContent {\u003cbr/\u003e    App({\u003cbr/\u003e        androidContext(this@MainActivity.applicationContext)\u003cbr/\u003e    })\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"98e0\"\u003eKoin can now provide the \u003ccode\u003eContext\u003c/code\u003e object whenever we need it.\u003c/p\u003e\u003ch2 id=\"68c2\"\u003eImplement platform-specific modules\u003c/h2\u003e\u003cp id=\"6906\"\u003eOur setup is nearly complete. We just have to provide the actual implementation of the \u003ccode\u003eplatformModule\u003c/code\u003e we declared earlier in \u003ccode\u003eAppModule\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"cc22\"\u003eFor \u003cstrong\u003eAndroid\u003c/strong\u003e, create a new \u003ccode\u003eAppModule.android.kt\u003c/code\u003e file under the \u003ccode\u003ecomposeApp/androidMain/your.package.spaceflightnews/di\u003c/code\u003e directory. Start typing the word \u003ccode\u003eactual\u003c/code\u003e and autocomplete should suggest the \u003ccode\u003eplatformModule\u003c/code\u003e property. We need to return a new \u003ccode\u003eModule\u003c/code\u003e that provides an instance of the \u003ccode\u003eAndroidDatabaseDriverFactory\u003c/code\u003e as the implementation of \u003ccode\u003eDatabaseDriverFactory\u003c/code\u003e interface. Because we earlier provided Koin with the \u003ccode\u003eContext\u003c/code\u003e object, we can use the \u003ccode\u003eget()\u003c/code\u003e function inside \u003ccode\u003esingle\u003c/code\u003e to access it.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"df8e\"\u003eactual val platformModule: Module\u003cbr/\u003e    get() = module {\u003cbr/\u003e        single\u0026lt;DatabaseDriverFactory\u0026gt; { AndroidDatabaseDriverFactory(context = get()) }\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8c7b\"\u003eFor \u003cstrong\u003eiOS\u003c/strong\u003e, create a new \u003ccode\u003eAppModule.ios.kt\u003c/code\u003e file under the \u003ccode\u003ecomposeApp/iOSMain/your.package.spaceflightnews/di\u003c/code\u003e and similarly implement the \u003ccode\u003eplatformModule\u003c/code\u003e property and provide an instance of \u003ccode\u003eIOSDatabaseDriverFactory\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2e44\"\u003eactual val platformModule: Module\u003cbr/\u003e    get() = module { single\u0026lt;DatabaseDriverFactory\u0026gt; { IOSDatabaseDriverFactory() } }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7eff\"\u003eAnd finally, for \u003cstrong\u003eDesktop\u003c/strong\u003e, create a new \u003ccode\u003eAppModule.desktop.kt\u003c/code\u003e file under the \u003ccode\u003ecomposeApp/desktopMain/your.package.spaceflightnews/di\u003c/code\u003e and implement the \u003ccode\u003eplatformModule\u003c/code\u003e property and provide an instance of \u003ccode\u003eDesktopDatabaseDriverFactory\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e31d\"\u003eactual val platformModule: Module\u003cbr/\u003e    get() = module { single\u0026lt;DatabaseDriverFactory\u0026gt; { DesktopDatabaseDriverFactory() } }\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4f78\"\u003e4. Run and test the app\u003c/h2\u003e\u003cp id=\"1297\"\u003eAfter a lot of setup, it’s finally time to run and test the app! The Android and Desktop apps should build and run with no issues. The iOS build requires an additional step to support the SQLite database.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eAndroid app running in offline mode.\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003eDesktop app running in offline mode.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"869c\"\u003eFixing the iOS build\u003c/h2\u003e\u003cp id=\"0101\"\u003eBefore we can run the iOS app, we have to add the \u003ca href=\"https://sqldelight.github.io/sqldelight/2.1.0/android_sqlite/gradle/#linksqlite\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edynamic linking flag for SQLDelight\u003c/a\u003e to Xcode build settings. This will allow the Xcode tooling to find the system-provided SQLite binary needed for the \u003ccode\u003eNativeDatabaseDriver\u003c/code\u003e to work.\u003c/p\u003e\u003col\u003e\u003cli id=\"a591\"\u003eOpen the iOS project in Xcode and double-click on the project name.\u003c/li\u003e\u003cli id=\"ff0f\"\u003eIn the settings, select the “Build Settings” tab and search for the “Other Linker Flags” property.\u003c/li\u003e\u003cli id=\"7bd7\"\u003eDouble-click on the empty property value, then press the “+” button, enter \u003ccode\u003e-lsqlite3\u003c/code\u003e, and press “Enter”.\u003c/li\u003e\u003cli id=\"e014\"\u003eRun the project.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003cfigcaption\u003eAdding the necessary config to Xcode to support the SQLite database.\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003eiOS app running in offline mode.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"9721\"\u003e5. Conclusion\u003c/h2\u003e\u003cp id=\"870f\"\u003eIf you followed to the end, great job! This is the end of the third part of the series on Kotlin Multiplatform and Compose Multiplatform. We’ve improved our app by adding the loading state and handling errors gracefully. Then we’ve introduced offline mode support by adding a local database to our app with SQLDelight.\u003c/p\u003e\u003cp id=\"a5aa\"\u003eIn the next part of the series, we are going to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9239\"\u003eAdd a detail screen showing the full article.\u003c/li\u003e\u003cli id=\"75e3\"\u003eAdd the Compose Navigation library to navigate to the new detail screen.\u003c/li\u003e\u003cli id=\"53fd\"\u003eAdd a system share functionality to share links to articles with different apps.\u003c/li\u003e\u003cli id=\"5cee\"\u003eShow how to open the article URL in a web browser.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"fc7c\"\u003e\u003cstrong\u003eStay tuned!\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eCurrent state of the app.\u003c/figcaption\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"f9b8\"\u003eYou can find the source code for this part here:\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "27 min read",
  "publishedTime": "2025-07-04T17:23:29.802Z",
  "modifiedTime": null
}
