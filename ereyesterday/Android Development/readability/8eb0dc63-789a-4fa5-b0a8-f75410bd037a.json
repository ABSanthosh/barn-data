{
  "id": "8eb0dc63-789a-4fa5-b0a8-f75410bd037a",
  "title": "How to implement Synchronization in Room Database in Kotlin",
  "link": "https://proandroiddev.com/how-to-implement-synchronization-in-room-database-in-kotlin-a7960bccb51d?source=rss----c72404660798---4",
  "description": "",
  "author": "Karishma Agrawal",
  "published": "Sun, 20 Oct 2024 18:29:30 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "database-synchronization",
    "synchronization",
    "programming",
    "kotlin",
    "android"
  ],
  "byline": "Karishma Agrawal",
  "length": 19350,
  "excerpt": "Synchronization is the process of coordinating access to shared resources among multiple threads to maintain data integrity and consistency. Synchronization in a Room database is crucial to ensure…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "What is Synchronization?Synchronization is the process of coordinating access to shared resources among multiple threads to maintain data integrity and consistency.Synchronization in a Room database is crucial to ensure data consistency and thread safety. When multiple threads access and modify the database simultaneously, synchronization mechanisms are necessary to prevent data corruption and ensure atomic operations.Consider an app that manages a list of tasks. Multiple users can add, update, or delete tasks. If two users try to update the same task simultaneously, synchronization ensures that one user’s changes are saved before the other begins, preventing data loss or corruption.In the same way in the database, if we are trying to update a value from multiple threads, and accessing it from multiple places without synchronization it can lead to inconsistency and data corruption.Why Synchronization is ImportantThread Safety: Multiple threads accessing the database can lead to race conditions, where the outcome depends on the sequence or timing of threads’ execution. Synchronization ensures that only one thread can modify the database at a time.Data Consistency: Without synchronization, concurrent modifications can leave the database in an inconsistent state, leading to crashes or incorrect data.Deadlock Prevention: Proper synchronization helps prevent deadlocks, where two or more threads are waiting for each other to release resources.First let’s understand diff synchronization and then we will implement them through one example.Synchronization Techniques in Kotlin:VolatilesThe volatile keyword is used to indicate that a variable's value will be modified by different threads. When a variable is declared as volatile, it ensures that:Visibility: Changes to the variable are immediately visible to all threads. This means that when one thread updates the value of a volatile variable, other threads will see the updated value immediately.Atomicity: For simple read and write operations, volatile guarantees that the operation is atomic. This means the read or write operation happens entirely or not at all, without any intermediate states visible to other threads.However, it’s important to note that volatile does not provide atomicity for compound operations (e.g., incrementing a variable).So it will work in the case@Volatileprivate var isRunning = truefun start() { Thread { while (isRunning) { // Do some work } }.start()}fun stop() { isRunning = false}But it will not work in compound operations like thisclass Counter { @Volatile private var count = 0 fun increment() { synchronized(this) { count++ } } fun getCount(): Int { return count }}For complex synchronization scenarios involving multiple variables or more complex operations, using volatile alone is insufficient. Proper locking mechanisms should be used to ensure consistency and avoid race conditions. That’s why it's not a good choice for us.Atomic PrimitivesAtomic primitives are special classes provided in the Java and Kotlin programming languages that support lock-free, thread-safe operations on single variables. These classes ensure that operations on these variables are atomic, meaning they are performed as a single, indivisible step. This atomicity is crucial for writing correct concurrent programs without explicit locking mechanisms.Let’s see the same counter problem with AtomicIntegerval counter = AtomicInteger()fun main() = runBlocking { withContext(Dispatchers.Default) { massiveRun { counter.incrementAndGet() } } println(\"Counter = $counter\")}This is the fastest solution for this particular problem. It works for plain counters, collections, queues and other standard data structures and basic operations on them. However, it does not easily scale to complex state or to complex operations that do not have ready-to-use thread-safe implementations.Implementing Synchronization in Room DatabaseLet’s implement a simple task management application using Room with Kotlin, demonstrating different synchronization approaches.Example ScenarioConsider an app that manages a list of tasks. Multiple users can add, update, or delete tasks. If two users try to update the same task simultaneously, synchronization ensures that one user’s changes are saved before the other begins, preventing data loss or corruption.1. Using synchronized BlockA synchronized block in Kotlin (similar to Java) is used to provide a mechanism for thread-safe execution of code. When a block of code is marked as synchronized, it ensures that only one thread can execute that block at a time, preventing race conditions and ensuring data consistency.How synchronized Block WorksWhen a thread enters a synchronized block, it acquires a lock on the specified object. Other threads that try to enter any synchronized block on the same object are blocked until the first thread releases the lock. This way, synchronized blocks help in ensuring that critical sections of code are not accessed concurrently by multiple threads.@Entity(tableName = \"tasks\")data class Task( @PrimaryKey(autoGenerate = true) val id: Int, val name: String, val completed: Boolean)@Daointerface TaskDao { @Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insert(task: Task) @Update suspend fun update(task: Task) @Delete suspend fun delete(task: Task) @Query(\"SELECT * FROM tasks\") suspend fun getAllTasks(): List\u003cTask\u003e}@Database(entities = [Task::class], version = 1)abstract class TaskDatabase : RoomDatabase() { abstract fun taskDao(): TaskDao}class TaskRepository(private val taskDao: TaskDao) { private val lock = Any() suspend fun addTask(task: Task) { synchronized(lock) { taskDao.insert(task) } } suspend fun updateTask(task: Task) { synchronized(lock) { taskDao.update(task) } } suspend fun deleteTask(task: Task) { synchronized(lock) { taskDao.delete(task) } } suspend fun getTasks(): List\u003cTask\u003e { return taskDao.getAllTasks() }}2. Using ReentrantLockThis approach uses ReentrantLock to manually lock and unlock critical sections of code.It provides methods to check if the lock is held by any thread and to get the list of waiting threads.import java.util.concurrent.locks.ReentrantLockclass TaskRepository(private val taskDao: TaskDao) { private val lock = ReentrantLock() suspend fun addTask(task: Task) { lock.lock() try { taskDao.insert(task) } finally { lock.unlock() } } suspend fun updateTask(task: Task) { lock.lock() try { taskDao.update(task) } finally { lock.unlock() } } suspend fun deleteTask(task: Task) { lock.lock() try { taskDao.delete(task) } finally { lock.unlock() } } suspend fun getTasks(): List\u003cTask\u003e { return taskDao.getAllTasks() }}3. Using Coroutines with MutexIn Kotlin, a Mutex (short for Mutual Exclusion) is a synchronization primitive that provides mutual exclusion for coroutines. It ensures that only one coroutine can execute a critical section of code at a time, preventing race conditions and ensuring thread safety. The Mutex class is part of the kotlinx.coroutines library, which provides facilities for asynchronous programming and concurrency.Key Points of MutexCoroutine Support: Unlike ReentrantLock or synchronized blocks, which are used for thread-based synchronization, Mutex is designed to work seamlessly with Kotlin coroutines.Suspend Functions: Mutex provides lock and unlock functions, where lock is a suspend function that can be safely called within coroutines.Fairness: Mutex can ensure that coroutines acquire the lock in the order they requested it, which can prevent starvation and ensure fairness.import kotlinx.coroutines.sync.Muteximport kotlinx.coroutines.sync.withLockclass TaskRepository(private val taskDao: TaskDao) { private val mutex = Mutex() suspend fun addTask(task: Task) { mutex.withLock { taskDao.insert(task) } } suspend fun updateTask(task: Task) { mutex.withLock { taskDao.update(task) } } suspend fun deleteTask(task: Task) { mutex.withLock { taskDao.delete(task) } } suspend fun getTasks(): List\u003cTask\u003e { return taskDao.getAllTasks() }}Each approach has its advantages, and the choice depends on the specific requirements and constraints of the application. Using Mutex is particularly beneficial in Kotlin coroutines, as it integrates well with coroutine scopes and suspension functions, providing a more idiomatic way to handle concurrency.Let’s understand few Concurrent classes for synchronization to handle multiple scenarios:Concurrent UtilitiesConcurrent utility classes in Java and Kotlin (from the java.util.concurrent package) provide a set of high-level APIs to handle synchronization, manage concurrent tasks, and simplify the development of multi-threaded applications. These utilities include various types of locks, atomic variables, thread pools, and data structures designed for concurrent access. When working with Room Database or any other database in a concurrent environment, these utilities can be extremely useful to manage access to shared resources efficiently and safely.1. Using CountDownLatch to Await Completion of Multiple Tasks:CountDownLatch can be used to wait for multiple database operations to complete before proceeding. Let’s take the same example where in task database we are trying to add multiple task using a for loop.class TaskRepository(private val taskDao: TaskDao) { private val coroutineScope = CoroutineScope(Dispatchers.IO) fun insertMultipleTasks(tasks: List\u003cTask\u003e, onComplete: () -\u003e Unit) { val latch = CountDownLatch(tasks.size) tasks.forEach { task -\u003e coroutineScope.launch { taskDao.insert(task) latch.countDown() } } coroutineScope.launch { latch.await() // Wait for all inserts to complete onComplete() } }}CountDownLatch Ensures that the onComplete callback is called only after all tasks have been inserted.2. SemaphoreA semaphore is a synchronization primitive that controls access to a shared resource by multiple threads. It uses a counter to keep track of how many permits are available for access to the resource. In Kotlin, semaphores can be used to manage concurrent access to resources such as a Room database, ensuring that only a specified number of threads can access the resource simultaneously.// Repository to handle task operationsclass TaskRepository(private val taskDao: TaskDao) { private val semaphore = Semaphore(2) // Limit concurrent access to 2 suspend fun insert(task: Task) { semaphore.acquire() try { taskDao.insert(task) } finally { semaphore.release() } } suspend fun update(task: Task) { semaphore.acquire() try { taskDao.update(task) } finally { semaphore.release() } } suspend fun delete(task: Task) { semaphore.acquire() try { taskDao.delete(task) } finally { semaphore.release() } } suspend fun getAllTasks(): List\u003cTask\u003e { semaphore.acquire() return try { taskDao.getAllTasks() } finally { semaphore.release() } }}3. Cyclic BarrierA CyclicBarrier is a synchronization aid in Java's concurrent utilities that allows a set of threads to wait for each other to reach a common barrier point. Once all threads have arrived at the barrier, they are released simultaneously. This is particularly useful for coordinating tasks that need to be executed in parallel but only proceed together after all tasks have been completed.import androidx.annotation.WorkerThreadimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.withContextimport java.util.concurrent.CyclicBarrierclass TaskRepository(private val taskDao: TaskDao) { private val numThreads = 3 // Number of threads to synchronize suspend fun performDatabaseOperations() { // Create a CyclicBarrier to synchronize threads val barrier = CyclicBarrier(numThreads) { // This will be executed when all threads reach the barrier println(\"All threads reached the barrier, performing final database operations.\") // You can perform additional operations here if needed } // Launch multiple threads to perform database operations val threads = List(numThreads) { threadNumber -\u003e Thread { runBlocking { performOperation(threadNumber, barrier) } } } // Start all threads threads.forEach { it.start() } // Wait for all threads to complete threads.forEach { it.join() } } private suspend fun performOperation(threadNumber: Int, barrier: CyclicBarrier) { withContext(Dispatchers.IO) { try { // Perform database operations val task = Task(description = \"Task from thread $threadNumber\") taskDao.insert(task) // Wait at the barrier barrier.await() } catch (e: Exception) { e.printStackTrace() } } }}This setup ensures that all threads perform their operations and synchronize at the barrier point before any further operations are carried out.Deadlockswhat is Deadlock?A deadlock is a situation in which two or more threads or processes are unable to proceed because each is waiting for the other to release a resource or complete an operation. In a deadlock scenario, each thread holds a resource and waits for another resource held by another thread, leading to a circular dependency where none of the threads can proceed.Deadlock Scenarios in AndroidIn Android, deadlocks can occur in various contexts, particularly when dealing with concurrency and database operations. Here are some common scenarios:Database Locking:Deadlocks can occur if multiple threads or transactions are trying to access or modify the same database records in different orders. For example, if Thread A locks Row 1 and waits for Row 2, while Thread B locks Row 2 and waits for Row 1, a deadlock occurs.UI Thread and Background Threads:If a background thread is waiting for a resource or result from the UI thread and the UI thread is blocked waiting for the background thread to complete, a deadlock can occur.Synchronized Blocks:Using synchronized blocks or locks improperly can lead to deadlocks if two or more threads are waiting on each other to release locks.Let’s say you have a Task entity with a priority field and you want to implement a method in your DAO that updates tasks based on their priority. Here’s a scenario that could lead to a deadlock:Two Threads Trying to Update Tasks in Different Orders:Thread A tries to update tasks with a higher priority first and then tasks with a lower priority.Thread B tries to update tasks with a lower priority first and then tasks with a higher priority.Creating a Deadlock ScenarioDefine Your Entity and DAOimport androidx.room.Entityimport androidx.room.PrimaryKey@Entity(tableName = \"tasks\")data class Task( @PrimaryKey val id: Long, val description: String, val priority: Int // Priority field for the deadlock scenario)import androidx.room.Daoimport androidx.room.Queryimport androidx.room.Update@Daointerface TaskDao { @Update suspend fun updateTask(task: Task) @Query(\"SELECT * FROM tasks WHERE priority = :priority\") suspend fun getTasksByPriority(priority: Int): List\u003cTask\u003e}2. Define Repository with Potential Deadlockimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.withContextclass TaskRepository(private val taskDao: TaskDao) { @WorkerThread suspend fun performPotentiallyDeadlockingOperations() { withContext(Dispatchers.IO) { try { // Simulate two threads performing operations on tasks with different priorities val highPriorityTasks = taskDao.getTasksByPriority(1) // High priority tasks val lowPriorityTasks = taskDao.getTasksByPriority(2) // Low priority tasks // Thread A: Update high-priority tasks first, then low-priority tasks updateTasksInOrder(highPriorityTasks, lowPriorityTasks) // Thread B: Update low-priority tasks first, then high-priority tasks // updateTasksInOrder(lowPriorityTasks, highPriorityTasks) // Uncomment to simulate deadlock } catch (e: Exception) { e.printStackTrace() } } } private suspend fun updateTasksInOrder(firstTasks: List\u003cTask\u003e, secondTasks: List\u003cTask\u003e) { firstTasks.forEach { task -\u003e taskDao.updateTask(task) } secondTasks.forEach { task -\u003e taskDao.updateTask(task) } }}Simulating DeadlockTo simulate the deadlock, you would uncomment the updateTasksInOrder(lowPriorityTasks, highPriorityTasks) call in one thread and execute the updateTasksInOrder(highPriorityTasks, lowPriorityTasks) in another thread. This setup may cause a deadlock because:Thread A holds locks on high-priority tasks and waits to acquire locks on low-priority tasks.Thread B holds locks on low-priority tasks and waits to acquire locks on high-priority tasks.Since each thread is holding locks that the other thread needs, they end up waiting indefinitely for each other, resulting in a deadlock.Resolving Deadlock1. Ensuring Consistent Lock OrderingTo prevent this deadlock, ensure that all threads acquire locks in a consistent order. For this, you need to control the order in which tasks are updated. Here’s how you can enforce consistent lock ordering:import kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.withContextclass TaskRepository(private val taskDao: TaskDao) { @WorkerThread suspend fun performDeadlockSafeOperations() { withContext(Dispatchers.IO) { try { // Retrieve tasks sorted by priority val allTasks = taskDao.getTasksByPriority(1) + taskDao.getTasksByPriority(2) // Perform updates in a single consistent order allTasks.forEach { task -\u003e taskDao.updateTask(task) } } catch (e: Exception) { e.printStackTrace() } } }}2. Using TransactionsEncapsulate the operations in a transaction to ensure atomicity. Room’s @Transaction annotation ensures that all operations within the transaction are executed as a single unit, preventing partial updates and reducing the chances of deadlock.import androidx.room.Daoimport androidx.room.Transaction@Daointerface TaskDao { @Update suspend fun updateTask(task: Task) @Transaction suspend fun updateTasksInTransaction(tasks: List\u003cTask\u003e) { tasks.forEach { updateTask(it) } } @Query(\"SELECT * FROM tasks\") suspend fun getAllTasks(): List\u003cTask\u003e}",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*rLvYiGPvzVVJCe-L4n9dtA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"1f7f\"\u003eWhat is Synchronization?\u003c/h2\u003e\u003cp id=\"3bcf\"\u003eSynchronization is the process of coordinating access to shared resources among multiple threads to maintain data integrity and consistency.\u003c/p\u003e\u003cp id=\"749e\"\u003eSynchronization in a Room database is crucial to ensure data consistency and thread safety. When multiple threads access and modify the database simultaneously, synchronization mechanisms are necessary to prevent data corruption and ensure atomic operations.\u003c/p\u003e\u003cp id=\"1720\"\u003eConsider an app that manages a list of tasks. Multiple users can add, update, or delete tasks. If two users try to update the same task simultaneously, synchronization ensures that one user’s changes are saved before the other begins, preventing data loss or corruption.\u003c/p\u003e\u003cp id=\"26dd\"\u003eIn the same way in the database, if we are trying to update a value from multiple threads, and accessing it from multiple places without synchronization it can lead to inconsistency and data corruption.\u003c/p\u003e\u003ch2 id=\"edbd\"\u003eWhy Synchronization is Important\u003c/h2\u003e\u003col\u003e\u003cli id=\"9982\"\u003e\u003cstrong\u003eThread Safety\u003c/strong\u003e: Multiple threads accessing the database can lead to race conditions, where the outcome depends on the sequence or timing of threads’ execution. Synchronization ensures that only one thread can modify the database at a time.\u003c/li\u003e\u003cli id=\"3314\"\u003e\u003cstrong\u003eData Consistency\u003c/strong\u003e: Without synchronization, concurrent modifications can leave the database in an inconsistent state, leading to crashes or incorrect data.\u003c/li\u003e\u003cli id=\"6a20\"\u003e\u003cstrong\u003eDeadlock Prevention\u003c/strong\u003e: Proper synchronization helps prevent deadlocks, where two or more threads are waiting for each other to release resources.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"b6cf\"\u003eFirst let’s understand diff synchronization and then we will implement them through one example.\u003c/p\u003e\u003ch2 id=\"3c46\"\u003eSynchronization Techniques in Kotlin:\u003c/h2\u003e\u003ch2 id=\"7a49\"\u003eVolatiles\u003c/h2\u003e\u003cp id=\"4287\"\u003eThe \u003ccode\u003evolatile\u003c/code\u003e keyword is used to indicate that a variable\u0026#39;s value will be modified by different threads. When a variable is declared as \u003ccode\u003evolatile\u003c/code\u003e, it ensures that:\u003c/p\u003e\u003col\u003e\u003cli id=\"56d3\"\u003e\u003cstrong\u003eVisibility\u003c/strong\u003e: Changes to the variable are immediately visible to all threads. This means that when one thread updates the value of a \u003ccode\u003evolatile\u003c/code\u003e variable, other threads will see the updated value immediately.\u003c/li\u003e\u003cli id=\"be3b\"\u003e\u003cstrong\u003eAtomicity\u003c/strong\u003e: For simple read and write operations, \u003ccode\u003evolatile\u003c/code\u003e guarantees that the operation is atomic. This means the read or write operation happens entirely or not at all, without any intermediate states visible to other threads.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"760e\"\u003eHowever, it’s important to note that \u003ccode\u003evolatile\u003c/code\u003e does not provide atomicity for compound operations (e.g., incrementing a variable).\u003c/p\u003e\u003cp id=\"ce05\"\u003eSo it will work in the case\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4857\"\u003e@Volatile\u003cbr/\u003eprivate var isRunning = true\u003cp\u003efun start() {\u003cbr/\u003e    Thread {\u003cbr/\u003e        while (isRunning) {\u003cbr/\u003e            // Do some work\u003cbr/\u003e        }\u003cbr/\u003e    }.start()\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efun stop() {\u003cbr/\u003e    isRunning = false\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7757\"\u003eBut it will not work in compound operations like this\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ed5f\"\u003eclass Counter {\u003cbr/\u003e    @Volatile\u003cbr/\u003e    private var count = 0\u003cp\u003e    fun increment() {\u003cbr/\u003e        synchronized(this) {\u003cbr/\u003e            count++\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun getCount(): Int {\u003cbr/\u003e        return count\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"11d0\"\u003eFor complex synchronization scenarios involving multiple variables or more complex operations, using \u003ccode\u003evolatile\u003c/code\u003e alone is insufficient. Proper locking mechanisms should be used to ensure consistency and avoid race conditions. That’s why it\u0026#39;s not a good choice for us.\u003c/p\u003e\u003ch2 id=\"b277\"\u003eAtomic Primitives\u003c/h2\u003e\u003cp id=\"6aa2\"\u003e\u003cstrong\u003eAtomic primitives\u003c/strong\u003e are special classes provided in the Java and Kotlin programming languages that support lock-free, thread-safe operations on single variables. These classes ensure that operations on these variables are atomic, meaning they are performed as a single, indivisible step. This atomicity is crucial for writing correct concurrent programs without explicit locking mechanisms.\u003c/p\u003e\u003cp id=\"a61b\"\u003eLet’s see the same counter problem with AtomicInteger\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ee81\"\u003eval counter = AtomicInteger()\u003cp\u003efun main() = runBlocking {\u003cbr/\u003e    withContext(Dispatchers.Default) {\u003cbr/\u003e        massiveRun {\u003cbr/\u003e            counter.incrementAndGet()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    println(\u0026#34;Counter = $counter\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c3f8\"\u003eThis is the fastest solution for this particular problem. It works for plain counters, collections, queues and other standard data structures and basic operations on them. However, it does not easily scale to complex state or to complex operations that do not have ready-to-use thread-safe implementations.\u003c/p\u003e\u003ch2 id=\"23ee\"\u003eImplementing Synchronization in Room Database\u003c/h2\u003e\u003cp id=\"d5f2\"\u003eLet’s implement a simple task management application using Room with Kotlin, demonstrating different synchronization approaches.\u003c/p\u003e\u003ch2 id=\"86de\"\u003eExample Scenario\u003c/h2\u003e\u003cp id=\"fd72\"\u003eConsider an app that manages a list of tasks. Multiple users can add, update, or delete tasks. If two users try to update the same task simultaneously, synchronization ensures that one user’s changes are saved before the other begins, preventing data loss or corruption.\u003c/p\u003e\u003ch2 id=\"0ae3\"\u003e1. Using \u003ccode\u003esynchronized\u003c/code\u003e Block\u003c/h2\u003e\u003cp id=\"4d05\"\u003eA \u003ccode\u003esynchronized\u003c/code\u003e block in Kotlin (similar to Java) is used to provide a mechanism for thread-safe execution of code. When a block of code is marked as \u003ccode\u003esynchronized\u003c/code\u003e, it ensures that only one thread can execute that block at a time, preventing race conditions and ensuring data consistency.\u003c/p\u003e\u003cp id=\"39e4\"\u003e\u003cstrong\u003eHow \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003esynchronized\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e Block Works\u003cbr/\u003e\u003c/strong\u003eWhen a thread enters a \u003ccode\u003esynchronized\u003c/code\u003e block, it acquires a lock on the specified object. Other threads that try to enter any \u003ccode\u003esynchronized\u003c/code\u003e block on the same object are blocked until the first thread releases the lock. This way, \u003ccode\u003esynchronized\u003c/code\u003e blocks help in ensuring that critical sections of code are not accessed concurrently by multiple threads.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"151a\"\u003e@Entity(tableName = \u0026#34;tasks\u0026#34;)\u003cbr/\u003edata class Task(\u003cbr/\u003e    @PrimaryKey(autoGenerate = true) val id: Int,\u003cbr/\u003e    val name: String,\u003cbr/\u003e    val completed: Boolean\u003cbr/\u003e)\u003cp\u003e@Dao\u003cbr/\u003einterface TaskDao {\u003cbr/\u003e    @Insert(onConflict = OnConflictStrategy.REPLACE)\u003cbr/\u003e    suspend fun insert(task: Task)\u003c/p\u003e\u003cp\u003e    @Update\u003cbr/\u003e    suspend fun update(task: Task)\u003c/p\u003e\u003cp\u003e    @Delete\u003cbr/\u003e    suspend fun delete(task: Task)\u003c/p\u003e\u003cp\u003e    @Query(\u0026#34;SELECT * FROM tasks\u0026#34;)\u003cbr/\u003e    suspend fun getAllTasks(): List\u0026lt;Task\u0026gt;\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Database(entities = [Task::class], version = 1)\u003cbr/\u003eabstract class TaskDatabase : RoomDatabase() {\u003cbr/\u003e    abstract fun taskDao(): TaskDao\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eclass TaskRepository(private val taskDao: TaskDao) {\u003c/p\u003e\u003cp\u003e    private val lock = Any()\u003c/p\u003e\u003cp\u003e    suspend fun addTask(task: Task) {\u003cbr/\u003e        synchronized(lock) {\u003cbr/\u003e            taskDao.insert(task)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun updateTask(task: Task) {\u003cbr/\u003e        synchronized(lock) {\u003cbr/\u003e            taskDao.update(task)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun deleteTask(task: Task) {\u003cbr/\u003e        synchronized(lock) {\u003cbr/\u003e            taskDao.delete(task)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun getTasks(): List\u0026lt;Task\u0026gt; {\u003cbr/\u003e        return taskDao.getAllTasks()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"7779\"\u003e2. Using \u003ccode\u003eReentrantLock\u003c/code\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"715c\"\u003eThis approach uses \u003ccode\u003eReentrantLock\u003c/code\u003e to manually lock and unlock critical sections of code.\u003c/li\u003e\u003cli id=\"c52d\"\u003eIt provides methods to check if the lock is held by any thread and to get the list of waiting threads.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"5d10\"\u003eimport java.util.concurrent.locks.ReentrantLock\u003cp\u003eclass TaskRepository(private val taskDao: TaskDao) {\u003c/p\u003e\u003cp\u003e    private val lock = ReentrantLock()\u003c/p\u003e\u003cp\u003e    suspend fun addTask(task: Task) {\u003cbr/\u003e        lock.lock()\u003cbr/\u003e        try {\u003cbr/\u003e            taskDao.insert(task)\u003cbr/\u003e        } finally {\u003cbr/\u003e            lock.unlock()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun updateTask(task: Task) {\u003cbr/\u003e        lock.lock()\u003cbr/\u003e        try {\u003cbr/\u003e            taskDao.update(task)\u003cbr/\u003e        } finally {\u003cbr/\u003e            lock.unlock()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun deleteTask(task: Task) {\u003cbr/\u003e        lock.lock()\u003cbr/\u003e        try {\u003cbr/\u003e            taskDao.delete(task)\u003cbr/\u003e        } finally {\u003cbr/\u003e            lock.unlock()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun getTasks(): List\u0026lt;Task\u0026gt; {\u003cbr/\u003e        return taskDao.getAllTasks()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"9a46\"\u003e3. Using Coroutines with Mutex\u003c/h2\u003e\u003cp id=\"082b\"\u003eIn Kotlin, a \u003ccode\u003eMutex\u003c/code\u003e (short for Mutual Exclusion) is a synchronization primitive that provides mutual exclusion for coroutines. It ensures that only one coroutine can execute a critical section of code at a time, preventing race conditions and ensuring thread safety. The \u003ccode\u003eMutex\u003c/code\u003e class is part of the \u003ccode\u003ekotlinx.coroutines\u003c/code\u003e library, which provides facilities for asynchronous programming and concurrency.\u003c/p\u003e\u003cp id=\"ffb8\"\u003e\u003cstrong\u003eKey Points of \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eMutex\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"0f86\"\u003e\u003cstrong\u003eCoroutine Support\u003c/strong\u003e: Unlike \u003ccode\u003eReentrantLock\u003c/code\u003e or \u003ccode\u003esynchronized\u003c/code\u003e blocks, which are used for thread-based synchronization, \u003ccode\u003eMutex\u003c/code\u003e is designed to work seamlessly with Kotlin coroutines.\u003c/li\u003e\u003cli id=\"348f\"\u003e\u003cstrong\u003eSuspend Functions\u003c/strong\u003e: \u003ccode\u003eMutex\u003c/code\u003e provides \u003ccode\u003elock\u003c/code\u003e and \u003ccode\u003eunlock\u003c/code\u003e functions, where \u003ccode\u003elock\u003c/code\u003e is a suspend function that can be safely called within coroutines.\u003c/li\u003e\u003cli id=\"170a\"\u003e\u003cstrong\u003eFairness\u003c/strong\u003e: \u003ccode\u003eMutex\u003c/code\u003e can ensure that coroutines acquire the lock in the order they requested it, which can prevent starvation and ensure fairness.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"467e\"\u003eimport kotlinx.coroutines.sync.Mutex\u003cbr/\u003eimport kotlinx.coroutines.sync.withLock\u003cp\u003eclass TaskRepository(private val taskDao: TaskDao) {\u003c/p\u003e\u003cp\u003e    private val mutex = Mutex()\u003c/p\u003e\u003cp\u003e    suspend fun addTask(task: Task) {\u003cbr/\u003e        mutex.withLock {\u003cbr/\u003e            taskDao.insert(task)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun updateTask(task: Task) {\u003cbr/\u003e        mutex.withLock {\u003cbr/\u003e            taskDao.update(task)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun deleteTask(task: Task) {\u003cbr/\u003e        mutex.withLock {\u003cbr/\u003e            taskDao.delete(task)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun getTasks(): List\u0026lt;Task\u0026gt; {\u003cbr/\u003e        return taskDao.getAllTasks()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"240c\"\u003eEach approach has its advantages, and the choice depends on the specific requirements and constraints of the application. Using \u003ccode\u003eMutex\u003c/code\u003e is particularly beneficial in Kotlin coroutines, as it integrates well with coroutine scopes and suspension functions, providing a more idiomatic way to handle concurrency.\u003c/p\u003e\u003cp id=\"006d\"\u003eLet’s understand few Concurrent classes for synchronization to handle multiple scenarios:\u003c/p\u003e\u003ch2 id=\"eb1d\"\u003eConcurrent Utilities\u003c/h2\u003e\u003cp id=\"4378\"\u003eConcurrent utility classes in Java and Kotlin (from the \u003ccode\u003ejava.util.concurrent\u003c/code\u003e package) provide a set of high-level APIs to handle synchronization, manage concurrent tasks, and simplify the development of multi-threaded applications. These utilities include various types of locks, atomic variables, thread pools, and data structures designed for concurrent access. When working with Room Database or any other database in a concurrent environment, these utilities can be extremely useful to manage access to shared resources efficiently and safely.\u003c/p\u003e\u003ch2 id=\"5e9a\"\u003e\u003cstrong\u003e1. Using \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e to Await Completion of Multiple Tasks\u003c/strong\u003e:\u003c/h2\u003e\u003cp id=\"e301\"\u003e\u003ccode\u003eCountDownLatch\u003c/code\u003e can be used to wait for multiple database operations to complete before proceeding. Let’s take the same example where in task database we are trying to add multiple task using a for loop.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e44d\"\u003eclass TaskRepository(private val taskDao: TaskDao) {\u003cbr/\u003e    private val coroutineScope = CoroutineScope(Dispatchers.IO)\u003cp\u003e    fun insertMultipleTasks(tasks: List\u0026lt;Task\u0026gt;, onComplete: () -\u0026gt; Unit) {\u003cbr/\u003e        val latch = CountDownLatch(tasks.size)\u003c/p\u003e\u003cp\u003e        tasks.forEach { task -\u0026gt;\u003cbr/\u003e            coroutineScope.launch {\u003cbr/\u003e                taskDao.insert(task)\u003cbr/\u003e                latch.countDown()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        coroutineScope.launch {\u003cbr/\u003e            latch.await() // Wait for all inserts to complete\u003cbr/\u003e            onComplete()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8478\"\u003e\u003ccode\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003eEnsures that the \u003ccode\u003eonComplete\u003c/code\u003e callback is called only after all tasks have been inserted.\u003c/p\u003e\u003ch2 id=\"8705\"\u003e2. Semaphore\u003c/h2\u003e\u003cp id=\"162e\"\u003eA semaphore is a synchronization primitive that controls access to a shared resource by multiple threads. It uses a counter to keep track of how many permits are available for access to the resource. In Kotlin, semaphores can be used to manage concurrent access to resources such as a Room database, ensuring that only a specified number of threads can access the resource simultaneously.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8571\"\u003e// Repository to handle task operations\u003cbr/\u003eclass TaskRepository(private val taskDao: TaskDao) {\u003cbr/\u003e    private val semaphore = Semaphore(2) // Limit concurrent access to 2\u003cp\u003e    suspend fun insert(task: Task) {\u003cbr/\u003e        semaphore.acquire()\u003cbr/\u003e        try {\u003cbr/\u003e            taskDao.insert(task)\u003cbr/\u003e        } finally {\u003cbr/\u003e            semaphore.release()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun update(task: Task) {\u003cbr/\u003e        semaphore.acquire()\u003cbr/\u003e        try {\u003cbr/\u003e            taskDao.update(task)\u003cbr/\u003e        } finally {\u003cbr/\u003e            semaphore.release()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun delete(task: Task) {\u003cbr/\u003e        semaphore.acquire()\u003cbr/\u003e        try {\u003cbr/\u003e            taskDao.delete(task)\u003cbr/\u003e        } finally {\u003cbr/\u003e            semaphore.release()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun getAllTasks(): List\u0026lt;Task\u0026gt; {\u003cbr/\u003e        semaphore.acquire()\u003cbr/\u003e        return try {\u003cbr/\u003e            taskDao.getAllTasks()\u003cbr/\u003e        } finally {\u003cbr/\u003e            semaphore.release()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"dccd\"\u003e\u003cstrong\u003e3. Cyclic Barrier\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"614b\"\u003eA \u003ccode\u003eCyclicBarrier\u003c/code\u003e is a synchronization aid in Java\u0026#39;s concurrent utilities that allows a set of threads to wait for each other to reach a common barrier point. Once all threads have arrived at the barrier, they are released simultaneously. This is particularly useful for coordinating tasks that need to be executed in parallel but only proceed together after all tasks have been completed.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1eb9\"\u003eimport androidx.annotation.WorkerThread\u003cbr/\u003eimport kotlinx.coroutines.Dispatchers\u003cbr/\u003eimport kotlinx.coroutines.withContext\u003cbr/\u003eimport java.util.concurrent.CyclicBarrier\u003cp\u003eclass TaskRepository(private val taskDao: TaskDao) {\u003c/p\u003e\u003cp\u003e    private val numThreads = 3 // Number of threads to synchronize\u003c/p\u003e\u003cp\u003e    suspend fun performDatabaseOperations() {\u003cbr/\u003e        // Create a CyclicBarrier to synchronize threads\u003cbr/\u003e        val barrier = CyclicBarrier(numThreads) {\u003cbr/\u003e            // This will be executed when all threads reach the barrier\u003cbr/\u003e            println(\u0026#34;All threads reached the barrier, performing final database operations.\u0026#34;)\u003cbr/\u003e            // You can perform additional operations here if needed\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        // Launch multiple threads to perform database operations\u003cbr/\u003e        val threads = List(numThreads) { threadNumber -\u0026gt;\u003cbr/\u003e            Thread {\u003cbr/\u003e                runBlocking {\u003cbr/\u003e                    performOperation(threadNumber, barrier)\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        // Start all threads\u003cbr/\u003e        threads.forEach { it.start() }\u003c/p\u003e\u003cp\u003e        // Wait for all threads to complete\u003cbr/\u003e        threads.forEach { it.join() }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private suspend fun performOperation(threadNumber: Int, barrier: CyclicBarrier) {\u003cbr/\u003e        withContext(Dispatchers.IO) {\u003cbr/\u003e            try {\u003cbr/\u003e                // Perform database operations\u003cbr/\u003e                val task = Task(description = \u0026#34;Task from thread $threadNumber\u0026#34;)\u003cbr/\u003e                taskDao.insert(task)\u003c/p\u003e\u003cp\u003e                // Wait at the barrier\u003cbr/\u003e                barrier.await()\u003cbr/\u003e            } catch (e: Exception) {\u003cbr/\u003e                e.printStackTrace()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dec4\"\u003eThis setup ensures that all threads perform their operations and synchronize at the barrier point before any further operations are carried out.\u003c/p\u003e\u003ch2 id=\"55f6\"\u003eDeadlocks\u003c/h2\u003e\u003ch2 id=\"dec3\"\u003e\u003cstrong\u003ewhat is Deadlock?\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"3411\"\u003eA deadlock is a situation in which two or more threads or processes are unable to proceed because each is waiting for the other to release a resource or complete an operation. In a deadlock scenario, each thread holds a resource and waits for another resource held by another thread, leading to a circular dependency where none of the threads can proceed.\u003c/p\u003e\u003ch2 id=\"f7b0\"\u003e\u003cstrong\u003eDeadlock Scenarios in Android\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"e1c8\"\u003eIn Android, deadlocks can occur in various contexts, particularly when dealing with concurrency and database operations. Here are some common scenarios:\u003c/p\u003e\u003col\u003e\u003cli id=\"903f\"\u003e\u003cstrong\u003eDatabase Locking\u003c/strong\u003e:\u003cbr/\u003eDeadlocks can occur if multiple threads or transactions are trying to access or modify the same database records in different orders. For example, if Thread A locks Row 1 and waits for Row 2, while Thread B locks Row 2 and waits for Row 1, a deadlock occurs.\u003c/li\u003e\u003cli id=\"768e\"\u003e\u003cstrong\u003eUI Thread and Background Threads\u003c/strong\u003e:\u003cbr/\u003eIf a background thread is waiting for a resource or result from the UI thread and the UI thread is blocked waiting for the background thread to complete, a deadlock can occur.\u003c/li\u003e\u003cli id=\"4ca4\"\u003e\u003cstrong\u003eSynchronized Blocks\u003c/strong\u003e:\u003cbr/\u003eUsing synchronized blocks or locks improperly can lead to deadlocks if two or more threads are waiting on each other to release locks.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"80ba\"\u003eLet’s say you have a \u003ccode\u003eTask\u003c/code\u003e entity with a \u003ccode\u003epriority\u003c/code\u003e field and you want to implement a method in your DAO that updates tasks based on their priority. Here’s a scenario that could lead to a deadlock:\u003c/p\u003e\u003col\u003e\u003cli id=\"d555\"\u003e\u003cstrong\u003eTwo Threads Trying to Update Tasks in Different Orders\u003c/strong\u003e:\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli id=\"437b\"\u003e\u003cstrong\u003eThread A\u003c/strong\u003e tries to update tasks with a higher priority first and then tasks with a lower priority.\u003c/li\u003e\u003cli id=\"3358\"\u003e\u003cstrong\u003eThread B\u003c/strong\u003e tries to update tasks with a lower priority first and then tasks with a higher priority.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"56e3\"\u003eCreating a Deadlock Scenario\u003c/h2\u003e\u003col\u003e\u003cli id=\"7616\"\u003eDefine Your Entity and DAO\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"93b1\"\u003eimport androidx.room.Entity\u003cbr/\u003eimport androidx.room.PrimaryKey\u003cp\u003e@Entity(tableName = \u0026#34;tasks\u0026#34;)\u003cbr/\u003edata class Task(\u003cbr/\u003e    @PrimaryKey val id: Long,\u003cbr/\u003e    val description: String,\u003cbr/\u003e    val priority: Int // Priority field for the deadlock scenario\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"b072\"\u003eimport androidx.room.Dao\u003cbr/\u003eimport androidx.room.Query\u003cbr/\u003eimport androidx.room.Update\u003cp\u003e@Dao\u003cbr/\u003einterface TaskDao {\u003cbr/\u003e    @Update\u003cbr/\u003e    suspend fun updateTask(task: Task)\u003c/p\u003e\u003cp\u003e    @Query(\u0026#34;SELECT * FROM tasks WHERE priority = :priority\u0026#34;)\u003cbr/\u003e    suspend fun getTasksByPriority(priority: Int): List\u0026lt;Task\u0026gt;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"af9e\"\u003e2. Define Repository with Potential Deadlock\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2996\"\u003eimport kotlinx.coroutines.Dispatchers\u003cbr/\u003eimport kotlinx.coroutines.withContext\u003cp\u003eclass TaskRepository(private val taskDao: TaskDao) {\u003c/p\u003e\u003cp\u003e    @WorkerThread\u003cbr/\u003e    suspend fun performPotentiallyDeadlockingOperations() {\u003cbr/\u003e        withContext(Dispatchers.IO) {\u003cbr/\u003e            try {\u003cbr/\u003e                // Simulate two threads performing operations on tasks with different priorities\u003cbr/\u003e                val highPriorityTasks = taskDao.getTasksByPriority(1) // High priority tasks\u003cbr/\u003e                val lowPriorityTasks = taskDao.getTasksByPriority(2) // Low priority tasks\u003c/p\u003e\u003cp\u003e                // Thread A: Update high-priority tasks first, then low-priority tasks\u003cbr/\u003e                updateTasksInOrder(highPriorityTasks, lowPriorityTasks)\u003c/p\u003e\u003cp\u003e                // Thread B: Update low-priority tasks first, then high-priority tasks\u003cbr/\u003e                // updateTasksInOrder(lowPriorityTasks, highPriorityTasks) // Uncomment to simulate deadlock\u003cbr/\u003e            } catch (e: Exception) {\u003cbr/\u003e                e.printStackTrace()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private suspend fun updateTasksInOrder(firstTasks: List\u0026lt;Task\u0026gt;, secondTasks: List\u0026lt;Task\u0026gt;) {\u003cbr/\u003e        firstTasks.forEach { task -\u0026gt;\u003cbr/\u003e            taskDao.updateTask(task)\u003cbr/\u003e        }\u003cbr/\u003e        secondTasks.forEach { task -\u0026gt;\u003cbr/\u003e            taskDao.updateTask(task)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"d56a\"\u003eSimulating Deadlock\u003c/h2\u003e\u003cp id=\"bf20\"\u003eTo simulate the deadlock, you would uncomment the \u003ccode\u003eupdateTasksInOrder(lowPriorityTasks, highPriorityTasks)\u003c/code\u003e call in one thread and execute the \u003ccode\u003eupdateTasksInOrder(highPriorityTasks, lowPriorityTasks)\u003c/code\u003e in another thread. This setup may cause a deadlock because:\u003c/p\u003e\u003col\u003e\u003cli id=\"44cc\"\u003e\u003cstrong\u003eThread A\u003c/strong\u003e holds locks on high-priority tasks and waits to acquire locks on low-priority tasks.\u003c/li\u003e\u003cli id=\"000c\"\u003e\u003cstrong\u003eThread B\u003c/strong\u003e holds locks on low-priority tasks and waits to acquire locks on high-priority tasks.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"ff80\"\u003eSince each thread is holding locks that the other thread needs, they end up waiting indefinitely for each other, resulting in a deadlock.\u003c/p\u003e\u003ch2 id=\"faaf\"\u003eResolving Deadlock\u003c/h2\u003e\u003cp id=\"f987\"\u003e\u003cstrong\u003e1. Ensuring Consistent Lock Ordering\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"3f5f\"\u003eTo prevent this deadlock, ensure that all threads acquire locks in a consistent order. For this, you need to control the order in which tasks are updated. Here’s how you can enforce consistent lock ordering:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"655c\"\u003eimport kotlinx.coroutines.Dispatchers\u003cbr/\u003eimport kotlinx.coroutines.withContext\u003cp\u003eclass TaskRepository(private val taskDao: TaskDao) {\u003c/p\u003e\u003cp\u003e    @WorkerThread\u003cbr/\u003e    suspend fun performDeadlockSafeOperations() {\u003cbr/\u003e        withContext(Dispatchers.IO) {\u003cbr/\u003e            try {\u003cbr/\u003e                // Retrieve tasks sorted by priority\u003cbr/\u003e                val allTasks = taskDao.getTasksByPriority(1) + taskDao.getTasksByPriority(2)\u003c/p\u003e\u003cp\u003e                // Perform updates in a single consistent order\u003cbr/\u003e                allTasks.forEach { task -\u0026gt;\u003cbr/\u003e                    taskDao.updateTask(task)\u003cbr/\u003e                }\u003cbr/\u003e            } catch (e: Exception) {\u003cbr/\u003e                e.printStackTrace()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a6b7\"\u003e\u003cstrong\u003e2. Using Transactions\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"6c68\"\u003eEncapsulate the operations in a transaction to ensure atomicity. Room’s \u003ccode\u003e@Transaction\u003c/code\u003e annotation ensures that all operations within the transaction are executed as a single unit, preventing partial updates and reducing the chances of deadlock.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"075c\"\u003eimport androidx.room.Dao\u003cbr/\u003eimport androidx.room.Transaction\u003cp\u003e@Dao\u003cbr/\u003einterface TaskDao {\u003cbr/\u003e    @Update\u003cbr/\u003e    suspend fun updateTask(task: Task)\u003c/p\u003e\u003cp\u003e    @Transaction\u003cbr/\u003e    suspend fun updateTasksInTransaction(tasks: List\u0026lt;Task\u0026gt;) {\u003cbr/\u003e        tasks.forEach { updateTask(it) }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    @Query(\u0026#34;SELECT * FROM tasks\u0026#34;)\u003cbr/\u003e    suspend fun getAllTasks(): List\u0026lt;Task\u0026gt;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "21 min read",
  "publishedTime": "2024-08-28T09:03:10.095Z",
  "modifiedTime": null
}
