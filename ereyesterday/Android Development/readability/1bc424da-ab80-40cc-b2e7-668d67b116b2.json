{
  "id": "1bc424da-ab80-40cc-b2e7-668d67b116b2",
  "title": "Improving the Modal Bottom Sheet API in Jetpack Compose",
  "link": "https://proandroiddev.com/improving-the-modal-bottom-sheet-api-in-jetpack-compose-5ca56901ada8?source=rss----c72404660798---4",
  "description": "",
  "author": "Joost Klitsie",
  "published": "Mon, 31 Mar 2025 00:26:16 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "jetpack-compose",
    "android",
    "material3",
    "programming"
  ],
  "byline": "Joost Klitsie",
  "length": 13576,
  "excerpt": "Using the Material3 ModalBottomSheet API can be a challenge. With inspiration from other Composables, like AnimatedVisibility, I created a reusable solution",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Have you ever wondered “I like modal bottom sheets, but hot damn, that is an annoying API”? Well fear that thought no more! Because boy, will I show you something.The Android wizard fixing the Modal Bottom Sheet API, courtesy of ChatGPTNow that that over-exaggerated first paragraph is in and I got your attention, let me show you the problem I was facing. Or should I say: mild inconvenience. It all starts, as with any problem in software development, when your UX designer wants to use nice looking features throughout the app, such as a modal bottom sheet. Now, for our use cases, we can use the sheets as a form of dismissable notification, or as a form of screen overlay to do actual stuff, so we do use them in multiple places.Technical setupWe are using the amazing Jetpack Compose framework with the Material3 library on top. As you may know, Material3 already includes the ModalBottomSheet, so we obviously want to use that. As you also may know, with Jetpack Compose, we basically eat state for breakfast, state for lunch and state for dinner, with a nice state as dessert to finish it all up. So naturally, I am inclined to make our usage of these bottom sheet state-based as well:@Composablefun OhMyGodIAmAComposable(viewModel: MyViewModel) { val viewState by viewModel.viewState.collectAsState() // \u003cBox with button\u003e if (viewState.showSheet) { ModalBottomSheet( onDismissRequest = viewModel::closeSheet, ) { Text(\"I am a sheet!\") Button(onClick = viewModel::closeSheet) { Text(\"Close\") } } }}Note that this code has been edited a bit to show only the essential parts! But what you can see is that when we want to show a sheet, the ModalBottomSheet is added to our composition, and when we no longer want to show the sheet, it is simply removed. When we run it, we can see the following behavior:Sheet slides in nicelyThat obviously raises the question: Where is my sliding out animation? Why does it slide in, but not out?Understanding Bottom Sheet internalsUnder the hood, a bottom sheet is a dialog. And this dialog will use the system's default dialog animations. When we make the dialog appear in our composition, the dialog is popped up and a slide-in animation is triggered by the Material library as well. When we take the element out of the composition, we naturally can not do a similar thing and slide it out: As soon as it leaves the composition, it is Bye Bye and no more animations!The obvious solutionSo we have a bottom sheet, and it takes a bottom sheet state. We could go the obvious way and create our own bottom sheet state every time we use the modal bottom sheet component. Then we can hide the sheet manually and make sure it leaves our composition after it is hidden:@Composablefun OhMyGodIAmAComposable(viewModel: MyViewModel) { val viewState by viewModel.viewState.collectAsState() val coroutineScope = rememberCoroutineScope() val bottomSheetState = rememberModalBottomSheetState() if (viewState.showSheet) { ModalBottomSheet( onDismissRequest = viewModel::closeSheet, sheetState = bottomSheetState, ) { Text(\"I am a sheet!\") Button( onClick = { coroutineScope.launch { bottomSheetState.hide() viewModel.closeSheet() } }, ) { Text(\"Close\") } } }}And here we can see that the sliding out animation is now working as one may expect:Now it slides out nicelyThe better solutionExisting components as inspirationOur components should reflect state in an easy and understandable way, and not worry about side effects. We should hide away all the logic of animating the bottom sheets, because our components should not be cluttered with this kind of behavior. Obviously, showing and hiding stuff with a nice animation isn’t exactly new. Therefore, we can take a look at existing composables like AnimatedVisibility, and what its API looks like:The AnimatedVisibility ComposableSo we can see that it simply defines a visible: Boolean parameter, and that triggers all the work! Now as an experiment, let's see how our fictional sheet behaves if we don’t use the sheet but put it inside an AnimatedVisibility:@Composablefun OhMyGodIAmAComposable(viewModel: MyViewModel) { val viewState by viewModel.viewState.collectAsState() AnimatedVisibility( viewState.showSheet, Modifier.align(Alignment.BottomCenter), enter = slideInVertically { fullHeight -\u003e fullHeight }, exit = slideOutVertically { fullHeight -\u003e fullHeight }, ) { Surface( modifier = Modifier.fillMaxWidth(), color = MaterialTheme.colorScheme.surfaceContainerLow, shape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp) ) { Column( modifier = Modifier.padding(24.dp), verticalArrangement = spacedBy(8.dp), ) { Text(\"I am a sheet!\") Button(onClick = viewModel::closeSheet) { Text(\"Hide me\") } } } }}It is not a real sheet, we don’t have the behavior we expect, BUT: We flip a boolean flag, and it nicely appears and disappears with an animation!Simple AnimatedVisibility with a slide in and outPutting it togetherNaming things is a shit business. I have no idea what would be a good name; it is a modal bottom sheet that has an easier API, while ensuring proper sliding animations. I could call it AnimatedModalBottomSheet, or whatever, but that is just a mouthful. The working name, therefore, during the rest of this article, will be a simple AnimatedBottomSheet. So now we have decided on this important matter, we can do the following:Create a AnimatedBottomSheet Composable which wraps around the ModalBottomSheet Composable.Add a visibility parameter: isVisibleAdd a little extra code that shows/hides the modal bottom sheet based on the visibility flag.Be in awe of our newfound solution@OptIn(ExperimentalMaterial3Api::class)@Composablefun AnimatedBottomSheet( isVisible: Boolean, onDismissRequest: () -\u003e Unit, modifier: Modifier = Modifier, sheetState: SheetState = rememberModalBottomSheetState(), sheetMaxWidth: Dp = BottomSheetDefaults.SheetMaxWidth, shape: Shape = BottomSheetDefaults.ExpandedShape, containerColor: Color = BottomSheetDefaults.ContainerColor, contentColor: Color = contentColorFor(containerColor), tonalElevation: Dp = 0.dp, scrimColor: Color = BottomSheetDefaults.ScrimColor, dragHandle: @Composable (() -\u003e Unit)? = { BottomSheetDefaults.DragHandle() }, contentWindowInsets: @Composable () -\u003e WindowInsets = { BottomSheetDefaults.windowInsets }, properties: ModalBottomSheetProperties = ModalBottomSheetDefaults.properties, content: @Composable ColumnScope.() -\u003e Unit,) { LaunchedEffect(isVisible) { if (isVisible) { sheetState.show() } else { sheetState.hide() onDismissRequest() } } // Make sure we dispose of the bottom sheet when it is no longer needed if (!sheetState.isVisible \u0026\u0026 !isVisible) { return } ModalBottomSheet( onDismissRequest = onDismissRequest, modifier = modifier, sheetState = sheetState, sheetMaxWidth = sheetMaxWidth, shape = shape, containerColor = containerColor, contentColor = contentColor, tonalElevation = tonalElevation, scrimColor = scrimColor, dragHandle = dragHandle, contentWindowInsets = contentWindowInsets, properties = properties, content = content, )}After we have our fancy new AnimatedBottomSheet, we can include it in our original composable:@Composablefun OhMyGodIAmAComposable(viewModel: MyViewModel) { val viewState by viewModel.viewState.collectAsState() Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button(onClick = viewModel::showSheet) { Text(\"Open sheet\") } } AnimatedBottomSheet( isVisible = viewState.showSheet, onDismissRequest = viewModel::closeSheet, ) { Column( modifier = Modifier.padding(24.dp), verticalArrangement = spacedBy(8.dp), ) { Text(\"I am a sheet!\") Button(onClick = viewModel::closeSheet) { Text(\"Close\") } } }}No we can toggle the open and close as we can see in the following GIF:Nicely animated modal bottom sheet with nice API1-upping the solutionLet’s say we do not just wish to show a bottom sheet based on a boolean flag, but we want to dynamically add content? Well, we can create a generic AnimatedBottomSheet, which can take a nullable value instead of a boolean flag. If the value is null, we hide the bottom sheet, if the value is something else, we can build our sheet with it! Let’s have a look at what that may look like:@Composablefun \u003cT\u003e AnimatedBottomSheet( value: T?, onDismissRequest: () -\u003e Unit, modifier: Modifier = Modifier, sheetState: SheetState = rememberModalBottomSheetState(), sheetMaxWidth: Dp = BottomSheetDefaults.SheetMaxWidth, shape: Shape = BottomSheetDefaults.ExpandedShape, containerColor: Color = BottomSheetDefaults.ContainerColor, contentColor: Color = contentColorFor(containerColor), tonalElevation: Dp = 0.dp, scrimColor: Color = BottomSheetDefaults.ScrimColor, dragHandle: @Composable (() -\u003e Unit)? = { BottomSheetDefaults.DragHandle() }, contentWindowInsets: @Composable () -\u003e WindowInsets = { BottomSheetDefaults.windowInsets }, properties: ModalBottomSheetProperties = ModalBottomSheetDefaults.properties, content: @Composable ColumnScope.(T \u0026 Any) -\u003e Unit,) { LaunchedEffect(value != null) { if (value != null) { sheetState.show() } else { sheetState.hide() onDismissRequest() } } if (!sheetState.isVisible \u0026\u0026 value == null) { return } ModalBottomSheet( onDismissRequest = onDismissRequest, modifier = modifier, sheetState = sheetState, sheetMaxWidth = sheetMaxWidth, shape = shape, containerColor = containerColor, contentColor = contentColor, tonalElevation = tonalElevation, scrimColor = scrimColor, dragHandle = dragHandle, contentWindowInsets = contentWindowInsets, properties = properties, ) { // Remember the last not null value: If our value becomes null and the sheet slides down, // we still need to show the last content during the exit animation. val notNullValue = lastNotNullValueOrNull(value) ?: return@ModalBottomSheet content(notNullValue) }}@Composablefun \u003cT\u003e lastNotNullValueOrNull(value: T?): T? { val lastNotNullValueOrNullRef = remember { Ref\u003cT\u003e() } return value?.also { lastNotNullValueOrNullRef.value = it } ?: lastNotNullValueOrNullRef.value}Now we can do some nice things! Let’s say, we have 2 different types of sheets:sealed interface SuperSpecialSheetContent { data class Simple( val title: String, ): SuperSpecialSheetContent data class WithButton( val buttonText: String, ): SuperSpecialSheetContent}We can now use this amazing sealed interface to show different sheets. We can even animate nicely between the different sheets, and once we nullify the content, the sheet slides away into oblivion.@Composablefun OhMyGodIAmAComposable(viewModel: MyViewModel) { val viewState by viewModel.viewState.collectAsState() AnimatedBottomSheet( value = viewState.sheetContent, onDismissRequest = viewModel::closeSheet, ) { sheetContent -\u003e Column( modifier = Modifier.padding(24.dp), verticalArrangement = spacedBy(8.dp), ) { AnimatedContent(sheetContent) { specialSheetContent -\u003e when (specialSheetContent) { is SuperSpecialSheetContent.Simple -\u003e Text(specialSheetContent.title) is SuperSpecialSheetContent.WithButton -\u003e Button(onClick = viewModel::onShowOtherSheet) { Text(specialSheetContent.buttonText) } } } Button(onClick = viewModel::closeSheet) { Text(\"Close\") } } }}And the result, a simple to use and state-based AnimatedBottomSheet! As you can see in the GIF below, it behaves like a normal Modal Bottom Sheet. It will slide in and out nicely, and you can still drag it to close as how you see fit!AnimatedBottomSheet with proper bottom sheet behaviorFinal thoughtsOur own AnimatedBottomSheet reuses most of the normal ModalBottomSheet API, including the onDismissRequest when the sheet is supposed to be dismissed. Al the side effects and animation logic are nicely incorporated into our custom Composable, meaning we don’t have to bother with that after the initial creation of the very reusable component. On top of this, you can also add your own default values for the parameters and perhaps add some more customization. In this way, you have 1 standardized modal bottom sheet which fits your needs and is very easy to use!Let me know what you think about this approach in the comments! And if you like what you saw, put those digital hands together. Joost out.",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*9gB0KHp-OLRvGOM-sWF9QQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@joostklitsie?source=post_page---byline--5ca56901ada8---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Joost Klitsie\" src=\"https://miro.medium.com/v2/resize:fill:88:88/0*7_baj1bWcyhiAYMp.\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--5ca56901ada8---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"101a\"\u003eHave you ever wondered “I like modal bottom sheets, but hot damn, that is an annoying API”? Well fear that thought no more! Because boy, will I show you something.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eThe Android wizard fixing the Modal Bottom Sheet API, courtesy of ChatGPT\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"68ba\"\u003eNow that that over-exaggerated first paragraph is in and I got your attention, let me show you the problem I was facing. Or should I say: mild inconvenience. It all starts, as with any problem in software development, when your UX designer wants to use nice looking features throughout the app, such as a modal bottom sheet. Now, for our use cases, we can use the sheets as a form of dismissable notification, or as a form of screen overlay to do actual stuff, so we do use them in multiple places.\u003c/p\u003e\u003ch2 id=\"eb38\"\u003eTechnical setup\u003c/h2\u003e\u003cp id=\"50e9\"\u003eWe are using the amazing Jetpack Compose framework with the Material3 library on top. As you may know, Material3 already includes the ModalBottomSheet, so we obviously want to use that. As you also may know, with Jetpack Compose, we basically eat state for breakfast, state for lunch and state for dinner, with a nice state as dessert to finish it all up. So naturally, I am inclined to make our usage of these bottom sheet state-based as well:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"280c\"\u003e@Composable\u003cbr/\u003efun OhMyGodIAmAComposable(viewModel: MyViewModel) {\u003cbr/\u003e    val viewState by viewModel.viewState.collectAsState()\u003cbr/\u003e    // \u0026lt;Box with button\u0026gt;\u003cbr/\u003e    if (viewState.showSheet) {\u003cbr/\u003e        ModalBottomSheet(\u003cbr/\u003e            onDismissRequest = viewModel::closeSheet,\u003cbr/\u003e        ) {\u003cbr/\u003e            Text(\u0026#34;I am a sheet!\u0026#34;)\u003cbr/\u003e            Button(onClick = viewModel::closeSheet) {\u003cbr/\u003e                Text(\u0026#34;Close\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8a40\"\u003eNote that this code has been edited a bit to show only the essential parts! But what you can see is that when we want to show a sheet, the ModalBottomSheet is added to our composition, and when we no longer want to show the sheet, it is simply removed. When we run it, we can see the following behavior:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSheet slides in nicely\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"a0aa\"\u003eThat obviously raises the question: Where is my sliding out animation? Why does it slide in, but not out?\u003c/p\u003e\u003ch2 id=\"9255\"\u003eUnderstanding Bottom Sheet internals\u003c/h2\u003e\u003cp id=\"ada5\"\u003eUnder the hood, a bottom sheet is a dialog. And this dialog will use the system\u0026#39;s default dialog animations. When we make the dialog appear in our composition, the dialog is popped up and a slide-in animation is triggered by the Material library as well. When we take the element out of the composition, we naturally can not do a similar thing and slide it out: As soon as it leaves the composition, it is Bye Bye and no more animations!\u003c/p\u003e\u003ch2 id=\"bbdc\"\u003eThe obvious solution\u003c/h2\u003e\u003cp id=\"ae58\"\u003eSo we have a bottom sheet, and it takes a bottom sheet state. We could go the obvious way and create our own bottom sheet state every time we use the modal bottom sheet component. Then we can hide the sheet manually and make sure it leaves our composition after it is hidden:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b5ca\"\u003e@Composable\u003cbr/\u003efun OhMyGodIAmAComposable(viewModel: MyViewModel) {\u003cbr/\u003e    val viewState by viewModel.viewState.collectAsState()\u003cbr/\u003e    val coroutineScope = rememberCoroutineScope()\u003cbr/\u003e    val bottomSheetState = rememberModalBottomSheetState()\u003cbr/\u003e    if (viewState.showSheet) {\u003cbr/\u003e        ModalBottomSheet(\u003cbr/\u003e            onDismissRequest = viewModel::closeSheet,\u003cbr/\u003e            sheetState = bottomSheetState,\u003cbr/\u003e        ) {\u003cbr/\u003e            Text(\u0026#34;I am a sheet!\u0026#34;)\u003cbr/\u003e            Button(\u003cbr/\u003e                onClick = {\u003cbr/\u003e                    coroutineScope.launch {\u003cbr/\u003e                        bottomSheetState.hide()\u003cbr/\u003e                        viewModel.closeSheet()\u003cbr/\u003e                    }\u003cbr/\u003e                },\u003cbr/\u003e            ) {\u003cbr/\u003e                Text(\u0026#34;Close\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a0e0\"\u003eAnd here we can see that the sliding out animation is now working as one may expect:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eNow it slides out nicely\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"cb6d\"\u003eThe better solution\u003c/h2\u003e\u003ch2 id=\"4ce6\"\u003eExisting components as inspiration\u003c/h2\u003e\u003cp id=\"31c9\"\u003eOur components should reflect state in an easy and understandable way, and not worry about side effects. We should hide away all the logic of animating the bottom sheets, because our components should not be cluttered with this kind of behavior. Obviously, showing and hiding stuff with a nice animation isn’t exactly new. Therefore, we can take a look at existing composables like AnimatedVisibility, and what its API looks like:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eThe AnimatedVisibility Composable\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ddf6\"\u003eSo we can see that it simply defines a \u003ccode\u003evisible: Boolean\u003c/code\u003e parameter, and that triggers all the work! Now as an experiment, let\u0026#39;s see how our fictional sheet behaves if we don’t use the sheet but put it inside an AnimatedVisibility:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"89a3\"\u003e@Composable\u003cbr/\u003efun OhMyGodIAmAComposable(viewModel: MyViewModel) {\u003cbr/\u003e    val viewState by viewModel.viewState.collectAsState()\u003cbr/\u003e    AnimatedVisibility(\u003cbr/\u003e       viewState.showSheet,\u003cbr/\u003e       Modifier.align(Alignment.BottomCenter),\u003cbr/\u003e       enter = slideInVertically { fullHeight -\u0026gt; fullHeight },\u003cbr/\u003e       exit = slideOutVertically { fullHeight -\u0026gt; fullHeight },\u003cbr/\u003e    ) {\u003cbr/\u003e        Surface(\u003cbr/\u003e            modifier = Modifier.fillMaxWidth(),\u003cbr/\u003e            color = MaterialTheme.colorScheme.surfaceContainerLow,\u003cbr/\u003e            shape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp)\u003cbr/\u003e        ) {\u003cbr/\u003e            Column(\u003cbr/\u003e                modifier = Modifier.padding(24.dp),\u003cbr/\u003e                verticalArrangement = spacedBy(8.dp),\u003cbr/\u003e            ) {\u003cbr/\u003e                Text(\u0026#34;I am a sheet!\u0026#34;)\u003cbr/\u003e                Button(onClick = viewModel::closeSheet) {\u003cbr/\u003e                    Text(\u0026#34;Hide me\u0026#34;)\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cdb9\"\u003eIt is not a real sheet, we don’t have the behavior we expect, BUT: We flip a boolean flag, and it nicely appears and disappears with an animation!\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSimple AnimatedVisibility with a slide in and out\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"af41\"\u003ePutting it together\u003c/h2\u003e\u003cp id=\"0832\"\u003eNaming things is a shit business. I have no idea what would be a good name; it is a modal bottom sheet that has an easier API, while ensuring proper sliding animations. I could call it AnimatedModalBottomSheet, or whatever, but that is just a mouthful. The working name, therefore, during the rest of this article, will be a simple \u003cstrong\u003eAnimatedBottomSheet\u003c/strong\u003e. So now we have decided on this important matter, we can do the following:\u003c/p\u003e\u003col\u003e\u003cli id=\"4c88\"\u003eCreate a AnimatedBottomSheet Composable which wraps around the ModalBottomSheet Composable.\u003c/li\u003e\u003cli id=\"82b1\"\u003eAdd a visibility parameter: \u003ccode\u003eisVisible\u003c/code\u003e\u003c/li\u003e\u003cli id=\"cd76\"\u003eAdd a little extra code that shows/hides the modal bottom sheet based on the visibility flag.\u003c/li\u003e\u003cli id=\"1629\"\u003eBe in awe of our newfound solution\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"7085\"\u003e@OptIn(ExperimentalMaterial3Api::class)\u003cbr/\u003e@Composable\u003cbr/\u003efun AnimatedBottomSheet(\u003cbr/\u003e    isVisible: Boolean,\u003cbr/\u003e    onDismissRequest: () -\u0026gt; Unit,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    sheetState: SheetState = rememberModalBottomSheetState(),\u003cbr/\u003e    sheetMaxWidth: Dp = BottomSheetDefaults.SheetMaxWidth,\u003cbr/\u003e    shape: Shape = BottomSheetDefaults.ExpandedShape,\u003cbr/\u003e    containerColor: Color = BottomSheetDefaults.ContainerColor,\u003cbr/\u003e    contentColor: Color = contentColorFor(containerColor),\u003cbr/\u003e    tonalElevation: Dp = 0.dp,\u003cbr/\u003e    scrimColor: Color = BottomSheetDefaults.ScrimColor,\u003cbr/\u003e    dragHandle: @Composable (() -\u0026gt; Unit)? = { BottomSheetDefaults.DragHandle() },\u003cbr/\u003e    contentWindowInsets: @Composable () -\u0026gt; WindowInsets = { BottomSheetDefaults.windowInsets },\u003cbr/\u003e    properties: ModalBottomSheetProperties = ModalBottomSheetDefaults.properties,\u003cbr/\u003e    content: @Composable ColumnScope.() -\u0026gt; Unit,\u003cbr/\u003e) {\u003cbr/\u003e    LaunchedEffect(isVisible) {\u003cbr/\u003e        if (isVisible) {\u003cbr/\u003e            sheetState.show()\u003cbr/\u003e        } else {\u003cbr/\u003e            sheetState.hide()\u003cbr/\u003e            onDismissRequest()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    // Make sure we dispose of the bottom sheet when it is no longer needed\u003cbr/\u003e    if (!sheetState.isVisible \u0026amp;\u0026amp; !isVisible) {\u003cbr/\u003e        return\u003cbr/\u003e    }\u003cbr/\u003e    ModalBottomSheet(\u003cbr/\u003e        onDismissRequest = onDismissRequest,\u003cbr/\u003e        modifier = modifier,\u003cbr/\u003e        sheetState = sheetState,\u003cbr/\u003e        sheetMaxWidth = sheetMaxWidth,\u003cbr/\u003e        shape = shape,\u003cbr/\u003e        containerColor = containerColor,\u003cbr/\u003e        contentColor = contentColor,\u003cbr/\u003e        tonalElevation = tonalElevation,\u003cbr/\u003e        scrimColor = scrimColor,\u003cbr/\u003e        dragHandle = dragHandle,\u003cbr/\u003e        contentWindowInsets = contentWindowInsets,\u003cbr/\u003e        properties = properties,\u003cbr/\u003e        content = content,\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1fab\"\u003eAfter we have our fancy new \u003cstrong\u003eAnimatedBottomSheet\u003c/strong\u003e, we can include it in our original composable:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fcdb\"\u003e@Composable\u003cbr/\u003efun OhMyGodIAmAComposable(viewModel: MyViewModel) {\u003cbr/\u003e    val viewState by viewModel.viewState.collectAsState()\u003cbr/\u003e    Box(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize(),\u003cbr/\u003e        contentAlignment = Alignment.Center\u003cbr/\u003e    ) {\u003cbr/\u003e        Button(onClick = viewModel::showSheet) {\u003cbr/\u003e            Text(\u0026#34;Open sheet\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    AnimatedBottomSheet(\u003cbr/\u003e        isVisible = viewState.showSheet,\u003cbr/\u003e        onDismissRequest = viewModel::closeSheet,\u003cbr/\u003e    ) {\u003cbr/\u003e        Column(\u003cbr/\u003e            modifier = Modifier.padding(24.dp),\u003cbr/\u003e            verticalArrangement = spacedBy(8.dp),\u003cbr/\u003e        ) {\u003cbr/\u003e            Text(\u0026#34;I am a sheet!\u0026#34;)\u003cbr/\u003e            Button(onClick = viewModel::closeSheet) {\u003cbr/\u003e                Text(\u0026#34;Close\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b65d\"\u003eNo we can toggle the open and close as we can see in the following GIF:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eNicely animated modal bottom sheet with nice API\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"efc2\"\u003e1-upping the solution\u003c/h2\u003e\u003cp id=\"6966\"\u003eLet’s say we do not just wish to show a bottom sheet based on a boolean flag, but we want to dynamically add content? Well, we can create a generic AnimatedBottomSheet, which can take a nullable value instead of a boolean flag. If the value is null, we hide the bottom sheet, if the value is something else, we can build our sheet with it! Let’s have a look at what that may look like:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1d99\"\u003e@Composable\u003cbr/\u003efun \u0026lt;T\u0026gt; AnimatedBottomSheet(\u003cbr/\u003e    value: T?,\u003cbr/\u003e    onDismissRequest: () -\u0026gt; Unit,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    sheetState: SheetState = rememberModalBottomSheetState(),\u003cbr/\u003e    sheetMaxWidth: Dp = BottomSheetDefaults.SheetMaxWidth,\u003cbr/\u003e    shape: Shape = BottomSheetDefaults.ExpandedShape,\u003cbr/\u003e    containerColor: Color = BottomSheetDefaults.ContainerColor,\u003cbr/\u003e    contentColor: Color = contentColorFor(containerColor),\u003cbr/\u003e    tonalElevation: Dp = 0.dp,\u003cbr/\u003e    scrimColor: Color = BottomSheetDefaults.ScrimColor,\u003cbr/\u003e    dragHandle: @Composable (() -\u0026gt; Unit)? = { BottomSheetDefaults.DragHandle() },\u003cbr/\u003e    contentWindowInsets: @Composable () -\u0026gt; WindowInsets = { BottomSheetDefaults.windowInsets },\u003cbr/\u003e    properties: ModalBottomSheetProperties = ModalBottomSheetDefaults.properties,\u003cbr/\u003e    content: @Composable ColumnScope.(T \u0026amp; Any) -\u0026gt; Unit,\u003cbr/\u003e) {\u003cbr/\u003e    LaunchedEffect(value != null) {\u003cbr/\u003e        if (value != null) {\u003cbr/\u003e            sheetState.show()\u003cbr/\u003e        } else {\u003cbr/\u003e            sheetState.hide()\u003cbr/\u003e            onDismissRequest()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    if (!sheetState.isVisible \u0026amp;\u0026amp; value == null) {\u003cbr/\u003e        return\u003cbr/\u003e    }\u003cbr/\u003e    ModalBottomSheet(\u003cbr/\u003e        onDismissRequest = onDismissRequest,\u003cbr/\u003e        modifier = modifier,\u003cbr/\u003e        sheetState = sheetState,\u003cbr/\u003e        sheetMaxWidth = sheetMaxWidth,\u003cbr/\u003e        shape = shape,\u003cbr/\u003e        containerColor = containerColor,\u003cbr/\u003e        contentColor = contentColor,\u003cbr/\u003e        tonalElevation = tonalElevation,\u003cbr/\u003e        scrimColor = scrimColor,\u003cbr/\u003e        dragHandle = dragHandle,\u003cbr/\u003e        contentWindowInsets = contentWindowInsets,\u003cbr/\u003e        properties = properties,\u003cbr/\u003e    ) {\u003cbr/\u003e        // Remember the last not null value: If our value becomes null and the sheet slides down,\u003cbr/\u003e        // we still need to show the last content during the exit animation.\u003cbr/\u003e        val notNullValue = lastNotNullValueOrNull(value) ?: return@ModalBottomSheet\u003cbr/\u003e        content(notNullValue)\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e@Composable\u003cbr/\u003efun \u0026lt;T\u0026gt; lastNotNullValueOrNull(value: T?): T? {\u003cbr/\u003e    val lastNotNullValueOrNullRef = remember { Ref\u0026lt;T\u0026gt;() }\u003cbr/\u003e    return value?.also {\u003cbr/\u003e        lastNotNullValueOrNullRef.value = it\u003cbr/\u003e    } ?: lastNotNullValueOrNullRef.value\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0e50\"\u003eNow we can do some nice things! Let’s say, we have 2 different types of sheets:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"faf8\"\u003esealed interface SuperSpecialSheetContent {\u003cbr/\u003e    data class Simple(\u003cbr/\u003e       val title: String,\u003cbr/\u003e    ): SuperSpecialSheetContent\u003cp\u003e    data class WithButton(\u003cbr/\u003e        val buttonText: String,\u003cbr/\u003e    ): SuperSpecialSheetContent\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d465\"\u003eWe can now use this amazing sealed interface to show different sheets. We can even animate nicely between the different sheets, and once we nullify the content, the sheet slides away into oblivion.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"029c\"\u003e@Composable\u003cbr/\u003efun OhMyGodIAmAComposable(viewModel: MyViewModel) {\u003cbr/\u003e    val viewState by viewModel.viewState.collectAsState()\u003cbr/\u003e    AnimatedBottomSheet(\u003cbr/\u003e        value = viewState.sheetContent,\u003cbr/\u003e        onDismissRequest = viewModel::closeSheet,\u003cbr/\u003e    ) { sheetContent -\u0026gt;\u003cbr/\u003e        Column(\u003cbr/\u003e            modifier = Modifier.padding(24.dp),\u003cbr/\u003e            verticalArrangement = spacedBy(8.dp),\u003cbr/\u003e        ) {\u003cbr/\u003e            AnimatedContent(sheetContent) { specialSheetContent -\u0026gt;\u003cbr/\u003e                when (specialSheetContent) {\u003cbr/\u003e                    is SuperSpecialSheetContent.Simple -\u0026gt; \u003cbr/\u003e                        Text(specialSheetContent.title)\u003cp\u003e                    is SuperSpecialSheetContent.WithButton -\u0026gt; \u003cbr/\u003e                        Button(onClick = viewModel::onShowOtherSheet) {\u003cbr/\u003e                            Text(specialSheetContent.buttonText)\u003cbr/\u003e                        }\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e            Button(onClick = viewModel::closeSheet) {\u003cbr/\u003e                Text(\u0026#34;Close\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c971\"\u003eAnd the result, a simple to use and state-based \u003cstrong\u003eAnimatedBottomSheet\u003c/strong\u003e! As you can see in the GIF below, it behaves like a normal Modal Bottom Sheet. It will slide in and out nicely, and you can still drag it to close as how you see fit!\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eAnimatedBottomSheet with proper bottom sheet behavior\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"83dd\"\u003eFinal thoughts\u003c/h2\u003e\u003cp id=\"e6e9\"\u003eOur own \u003cstrong\u003eAnimatedBottomSheet\u003c/strong\u003e reuses most of the normal ModalBottomSheet API, including the onDismissRequest when the sheet is supposed to be dismissed. Al the side effects and animation logic are nicely incorporated into our custom Composable, meaning we don’t have to bother with that after the initial creation of the very reusable component. On top of this, you can also add your own default values for the parameters and perhaps add some more customization. In this way, you have 1 standardized modal bottom sheet which fits your needs and is very easy to use!\u003c/p\u003e\u003cp id=\"9878\"\u003eLet me know what you think about this approach in the comments! And if you like what you saw, put those digital hands together. Joost out.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-03-31T00:26:16.581Z",
  "modifiedTime": null
}
