{
  "id": "0892c1b7-f627-440e-a711-2ecd991db1de",
  "title": "Mastering Scroll in Jetpack Compose — PART 1",
  "link": "https://proandroiddev.com/mastering-scroll-in-jetpack-compose-part-1-7bacefce436e?source=rss----c72404660798---4",
  "description": "",
  "author": "Karishma Agrawal",
  "published": "Tue, 12 Nov 2024 15:06:40 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "androiddev",
    "android-app-development",
    "learnwithkarishma",
    "android",
    "jetpack-compose"
  ],
  "byline": "Karishma Agrawal",
  "length": 11191,
  "excerpt": "Scrolling is a fundamental element of any mobile app, and Jetpack Compose provides powerful tools to create smooth and efficient scrolling experiences. This article dives into the world of scroll in…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Scrolling is a fundamental element of any mobile app, and Jetpack Compose provides powerful tools to create smooth and efficient scrolling experiences. This article dives into the world of scroll in Compose, starting with the foundational concepts and gradually progressing towards more complex scenarios.Compose offers two workhorses for creating scrollable lists: LazyColumn for vertical scrolling and LazyRow for horizontal scrolling. They behave similarly to RecyclerView in XML, efficiently rendering only the visible items while maintaining excellent performance.Lazy Column@Composablefun LazyColumnExample() { val items = listOf(\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\", \"Item 6\", \"Item 7\", \"Item 8\", \"Item 9\", \"Item 10\",\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\", \"Item 6\", \"Item 7\", \"Item 8\", \"Item 9\", \"Item 10\") LazyColumn( modifier = Modifier .fillMaxSize() .background(Color.LightGray) ) { items(items.size) { item -\u003e Box( modifier = Modifier .fillMaxWidth() .padding(16.dp), contentAlignment = Alignment.Center ) { Text( text = items.get(item), color = Color.Black ) } } }}@Preview@Composablefun Preview() { LazyColumnExample()}Lazy Row@Composablefun LazyRowExample() { val items = listOf(\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\", \"Item 6\", \"Item 7\", \"Item 8\", \"Item 9\", \"Item 10\",\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\", \"Item 6\", \"Item 7\", \"Item 8\", \"Item 9\", \"Item 10\") LazyRow( modifier = Modifier .fillMaxSize() .background(Color.LightGray) ) { items(items.size) { item -\u003e Box( modifier = Modifier .fillMaxWidth() .padding(16.dp), contentAlignment = Alignment.Center ) { Text( text = items.get(item), color = Color.Black ) } } }}@Preview@Composablefun Preview() { LazyRowExample()}While LazyColumn and LazyRow handle most scrolling needs, ScrollState offers finer control. It acts as a state holder, keeping track of the current scroll position for various scrollable components like Column or LazyColumn.Understanding Scroll StateIn Jetpack Compose, ScrollState is a state holder that keeps track of the current scroll position for scrollable components such as Column, LazyColumn, or other containers that support scrolling. ScrollState gives us:Position Tracking: You can use ScrollState to access the current scroll offset or position of a scrollable component.Smooth Scrolling: ScrollState allows you to control smooth scrolling to specific positions in a list.Listening to Scroll Events: You can observe changes in the scroll position, which is particularly useful for things like showing/hiding toolbar animations based on scroll offset.Important Properties and Methods of ScrollStateProperties:value: The current scroll offset in pixels.maxValue: The maximum scroll offset. This is helpful for detecting when the scroll has reached the end of a container.Methods:animateScrollTo(offset: Int): Smoothly animates scrolling to the given offset in pixels.scrollTo(offset: Int): Instantly scrolls to the given offset.Scroll State Types in ComposeThere are different types of scroll states depending on the type of container:ScrollState: Used for simple scrolling in containers like Column.LazyListState: Specifically used for LazyColumn and LazyRow, giving more control over items and visibility states.Example 1: Using ScrollState with ColumnTo start, let’s see a simple example where we use ScrollState to observe and control the scroll position of a Column that supports vertical scrolling.import androidx.compose.foundation.backgroundimport androidx.compose.foundation.layout.*import androidx.compose.foundation.rememberScrollStateimport androidx.compose.foundation.verticalScrollimport androidx.compose.material3.Textimport androidx.compose.runtime.*import androidx.compose.ui.Modifierimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.unit.dp@Composablefun ScrollableColumnExample() { // Initialize the scroll state val scrollState = rememberScrollState() Column( modifier = Modifier .fillMaxSize() .verticalScroll(scrollState) // Attach scroll state to Column ) { // Display some items with varying colors for (i in 1..50) { Box( modifier = Modifier .fillMaxWidth() .height(100.dp) .background(if (i % 2 == 0) Color.LightGray else Color.Gray), contentAlignment = Alignment.Center ) { Text(\"Item $i\") } } } // Observe the scroll offset and print it LaunchedEffect(scrollState.value) { println(\"Current scroll position: ${scrollState.value}\") }}ExplanationIn this example:We create a Column with a ScrollState that allows it to scroll vertically.verticalScroll(scrollState) attaches the scroll state to the column.Inside the LaunchedEffect, we print the current scroll position each time scrollState.value changes.This example demonstrates basic scroll behavior in a Column and how to observe the scroll position.Example 2: Smooth Scrolling with ScrollStateIf you want to programmatically scroll to a specific position, you can use scrollState.animateScrollTo(offset). This is helpful for features like \"scroll to top\" or \"scroll to a specific item.\"import androidx.compose.foundation.layout.*import androidx.compose.foundation.rememberScrollStateimport androidx.compose.foundation.verticalScrollimport androidx.compose.material3.Buttonimport androidx.compose.material3.Textimport androidx.compose.runtime.*import androidx.compose.ui.Modifierimport androidx.compose.ui.unit.dpimport kotlinx.coroutines.launch@Composablefun SmoothScrollingExample() { val scrollState = rememberScrollState() val coroutineScope = rememberCoroutineScope() Column(modifier = Modifier.fillMaxSize()) { Button( onClick = { // Smooth scroll to the top coroutineScope.launch { scrollState.animateScrollTo(0) } }, modifier = Modifier.fillMaxWidth() ) { Text(\"Scroll to Top\") } Spacer(modifier = Modifier.height(16.dp)) Column( modifier = Modifier .fillMaxSize() .verticalScroll(scrollState) ) { for (i in 1..50) { Text( text = \"Item $i\", modifier = Modifier .fillMaxWidth() .padding(16.dp), color = Color.White ) } } }}ExplanationWe use rememberCoroutineScope() to launch a coroutine that allows asynchronous scrolling.The button calls scrollState.animateScrollTo(0) to scroll smoothly to the top of the list.animateScrollTo() is an asynchronous function, making the scrolling smooth and animated.Nested ScrollingNested scrolling is a concept where multiple scrolling containers work together to create a single scroll gesture.Compose provides multiple ways of handling nested scrolling between composables. A typical example of nested scrolling is a list inside another list, and a more complex case is a collapsing toolbar.Let’s understand the basic nested scrolling with an example.Here we have a scrollable list, and each list has a child list which is also scrollable. we are also adding expand and collapse view to show and hide each list item’s child list.import androidx.compose.foundation.backgroundimport androidx.compose.foundation.clickableimport androidx.compose.foundation.layout.*import androidx.compose.foundation.rememberScrollStateimport androidx.compose.foundation.verticalScrollimport androidx.compose.material.icons.Iconsimport androidx.compose.material.icons.filled.ExpandLessimport androidx.compose.material.icons.filled.ExpandMoreimport androidx.compose.material3.*import androidx.compose.runtime.*import androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.tooling.preview.Previewimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.sp@Composablefun NestedScrollingExample() { // Parent scroll state val parentScrollState = rememberScrollState() // Sample list data val items = (1..10).toList() Column( modifier = Modifier .fillMaxSize() .verticalScroll(parentScrollState) .padding(16.dp) ) { items.forEach { item -\u003e ExpandableItem(item) } }}@Composablefun ExpandableItem(item: Int) { // State to track if the item is expanded var isExpanded by remember { mutableStateOf(false) } Column( modifier = Modifier .fillMaxWidth() .padding(vertical = 8.dp) .background(Color.LightGray) ) { // Header for the expandable item Row( modifier = Modifier .fillMaxWidth() .clickable { isExpanded = !isExpanded } .padding(16.dp), verticalAlignment = Alignment.CenterVertically ) { Text( text = \"Item $item\", fontSize = 18.sp, modifier = Modifier.weight(1f) ) Icon( imageVector = if (isExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore, contentDescription = \"Expand/Collapse\" ) } // Child scrollable list, visible only when expanded if (isExpanded) { val childScrollState = rememberScrollState() Column( modifier = Modifier .fillMaxWidth() .height(150.dp) // Fixed height for nested scrollable area .verticalScroll(childScrollState) .background(Color.White) .padding(8.dp) ) { // Nested list content (1..5).forEach { subItem -\u003e Text( text = \"Sub-item $subItem of Item $item\", fontSize = 16.sp, modifier = Modifier .fillMaxWidth() .padding(vertical = 4.dp) .background(Color(0xFFF0F0F0)) .padding(8.dp) ) } } } }}@Preview@Composablefun showPeview() { NestedScrollingExample()}How Nested Scrolling Works HereThe parent scroll (parentScrollState) allows the entire list of items to scroll vertically.Each child scroll (childScrollState) manages the scrolling within the expanded item independently.This approach avoids using LazyColumn or LazyRow, handling scrolling manually with ScrollState instead.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:420/1*aCXgpKg8i9cUEggreqZMeQ.gif",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp id=\"e62c\"\u003eScrolling is a fundamental element of any mobile app, and Jetpack Compose provides powerful tools to create smooth and efficient scrolling experiences. This article dives into the world of scroll in Compose, starting with the foundational concepts and gradually progressing towards more complex scenarios.\u003c/p\u003e\u003cp id=\"0e5d\"\u003eCompose offers two workhorses for creating scrollable lists: \u003ccode\u003eLazyColumn\u003c/code\u003e for vertical scrolling and \u003ccode\u003eLazyRow\u003c/code\u003e for horizontal scrolling. They behave similarly to \u003ccode\u003eRecyclerView\u003c/code\u003e in XML, efficiently rendering only the visible items while maintaining excellent performance.\u003c/p\u003e\u003ch2 id=\"8412\"\u003eLazy Column\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"e792\"\u003e@Composable\u003cbr/\u003efun LazyColumnExample() {\u003cbr/\u003e    val items = listOf(\u0026#34;Item 1\u0026#34;, \u0026#34;Item 2\u0026#34;, \u0026#34;Item 3\u0026#34;, \u0026#34;Item 4\u0026#34;, \u0026#34;Item 5\u0026#34;, \u0026#34;Item 6\u0026#34;, \u0026#34;Item 7\u0026#34;, \u0026#34;Item 8\u0026#34;, \u0026#34;Item 9\u0026#34;, \u0026#34;Item 10\u0026#34;,\u0026#34;Item 1\u0026#34;, \u0026#34;Item 2\u0026#34;, \u0026#34;Item 3\u0026#34;, \u0026#34;Item 4\u0026#34;, \u0026#34;Item 5\u0026#34;, \u0026#34;Item 6\u0026#34;, \u0026#34;Item 7\u0026#34;, \u0026#34;Item 8\u0026#34;, \u0026#34;Item 9\u0026#34;, \u0026#34;Item 10\u0026#34;)\u003cp\u003e    LazyColumn(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e            .background(Color.LightGray)\u003cbr/\u003e    ) {\u003cbr/\u003e        items(items.size) { item -\u0026gt;\u003cbr/\u003e            Box(\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .padding(16.dp),\u003cbr/\u003e                contentAlignment = Alignment.Center\u003cbr/\u003e            ) {\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = items.get(item),\u003cbr/\u003e                    color = Color.Black\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun Preview() {\u003cbr/\u003e    LazyColumnExample()\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2699\"\u003e\u003cstrong\u003eLazy Row\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d30e\"\u003e@Composable\u003cbr/\u003efun LazyRowExample() {\u003cbr/\u003e    val items = listOf(\u0026#34;Item 1\u0026#34;, \u0026#34;Item 2\u0026#34;, \u0026#34;Item 3\u0026#34;, \u0026#34;Item 4\u0026#34;, \u0026#34;Item 5\u0026#34;, \u0026#34;Item 6\u0026#34;, \u0026#34;Item 7\u0026#34;, \u0026#34;Item 8\u0026#34;, \u0026#34;Item 9\u0026#34;, \u0026#34;Item 10\u0026#34;,\u0026#34;Item 1\u0026#34;, \u0026#34;Item 2\u0026#34;, \u0026#34;Item 3\u0026#34;, \u0026#34;Item 4\u0026#34;, \u0026#34;Item 5\u0026#34;, \u0026#34;Item 6\u0026#34;, \u0026#34;Item 7\u0026#34;, \u0026#34;Item 8\u0026#34;, \u0026#34;Item 9\u0026#34;, \u0026#34;Item 10\u0026#34;)\u003cp\u003e    LazyRow(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e            .background(Color.LightGray)\u003cbr/\u003e    ) {\u003cbr/\u003e        items(items.size) { item -\u0026gt;\u003cbr/\u003e            Box(\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .padding(16.dp),\u003cbr/\u003e                contentAlignment = Alignment.Center\u003cbr/\u003e            ) {\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = items.get(item),\u003cbr/\u003e                    color = Color.Black\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun Preview() {\u003cbr/\u003e    LazyRowExample()\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e9e4\"\u003eWhile \u003ccode\u003eLazyColumn\u003c/code\u003e and \u003ccode\u003eLazyRow\u003c/code\u003e handle most scrolling needs, \u003ccode\u003eScrollState\u003c/code\u003e offers finer control. It acts as a state holder, keeping track of the current scroll position for various scrollable components like \u003ccode\u003eColumn\u003c/code\u003e or \u003ccode\u003eLazyColumn\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"add5\"\u003eUnderstanding Scroll State\u003c/h2\u003e\u003cp id=\"9d09\"\u003eIn Jetpack Compose, \u003ccode\u003eScrollState\u003c/code\u003e is a state holder that keeps track of the current scroll position for scrollable components such as \u003ccode\u003eColumn\u003c/code\u003e, \u003ccode\u003eLazyColumn\u003c/code\u003e, or other containers that support scrolling. \u003ccode\u003eScrollState\u003c/code\u003e gives us:\u003c/p\u003e\u003col\u003e\u003cli id=\"2fb7\"\u003e\u003cstrong\u003ePosition Tracking\u003c/strong\u003e: You can use \u003ccode\u003eScrollState\u003c/code\u003e to access the current scroll offset or position of a scrollable component.\u003c/li\u003e\u003cli id=\"8d21\"\u003e\u003cstrong\u003eSmooth Scrolling\u003c/strong\u003e: \u003ccode\u003eScrollState\u003c/code\u003e allows you to control smooth scrolling to specific positions in a list.\u003c/li\u003e\u003cli id=\"3ce9\"\u003e\u003cstrong\u003eListening to Scroll Events\u003c/strong\u003e: You can observe changes in the scroll position, which is particularly useful for things like showing/hiding toolbar animations based on scroll offset.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"7bed\"\u003eImportant Properties and Methods of \u003ccode\u003eScrollState\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"8b53\"\u003e\u003cstrong\u003eProperties\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a411\"\u003e\u003ccode\u003evalue\u003c/code\u003e: The current scroll offset in pixels.\u003c/li\u003e\u003cli id=\"d132\"\u003e\u003ccode\u003emaxValue\u003c/code\u003e: The maximum scroll offset. This is helpful for detecting when the scroll has reached the end of a container.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"29d6\"\u003e\u003cstrong\u003eMethods\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"da39\"\u003e\u003ccode\u003eanimateScrollTo(offset: Int)\u003c/code\u003e: Smoothly animates scrolling to the given offset in pixels.\u003c/li\u003e\u003cli id=\"5dbc\"\u003e\u003ccode\u003escrollTo(offset: Int)\u003c/code\u003e: Instantly scrolls to the given offset.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"cc29\"\u003eScroll State Types in Compose\u003c/h2\u003e\u003cp id=\"db31\"\u003eThere are different types of scroll states depending on the type of container:\u003c/p\u003e\u003cul\u003e\u003cli id=\"8964\"\u003e\u003cstrong\u003eScrollState\u003c/strong\u003e: Used for simple scrolling in containers like \u003ccode\u003eColumn\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"5e24\"\u003e\u003cstrong\u003eLazyListState\u003c/strong\u003e: Specifically used for \u003ccode\u003eLazyColumn\u003c/code\u003e and \u003ccode\u003eLazyRow\u003c/code\u003e, giving more control over items and visibility states.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"e0c8\"\u003eExample 1: Using ScrollState with Column\u003c/h2\u003e\u003cp id=\"41c4\"\u003eTo start, let’s see a simple example where we use \u003ccode\u003eScrollState\u003c/code\u003e to observe and control the scroll position of a \u003ccode\u003eColumn\u003c/code\u003e that supports vertical scrolling.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d067\"\u003eimport androidx.compose.foundation.background\u003cbr/\u003eimport androidx.compose.foundation.layout.*\u003cbr/\u003eimport androidx.compose.foundation.rememberScrollState\u003cbr/\u003eimport androidx.compose.foundation.verticalScroll\u003cbr/\u003eimport androidx.compose.material3.Text\u003cbr/\u003eimport androidx.compose.runtime.*\u003cbr/\u003eimport androidx.compose.ui.Modifier\u003cbr/\u003eimport androidx.compose.ui.graphics.Color\u003cbr/\u003eimport androidx.compose.ui.unit.dp\u003cp\u003e@Composable\u003cbr/\u003efun ScrollableColumnExample() {\u003cbr/\u003e    // Initialize the scroll state\u003cbr/\u003e    val scrollState = rememberScrollState()\u003c/p\u003e\u003cp\u003e    Column(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e            .verticalScroll(scrollState) // Attach scroll state to Column\u003cbr/\u003e    ) {\u003cbr/\u003e        // Display some items with varying colors\u003cbr/\u003e        for (i in 1..50) {\u003cbr/\u003e            Box(\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .height(100.dp)\u003cbr/\u003e                    .background(if (i % 2 == 0) Color.LightGray else Color.Gray),\u003cbr/\u003e                contentAlignment = Alignment.Center\u003cbr/\u003e            ) {\u003cbr/\u003e                Text(\u0026#34;Item $i\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // Observe the scroll offset and print it\u003cbr/\u003e    LaunchedEffect(scrollState.value) {\u003cbr/\u003e        println(\u0026#34;Current scroll position: ${scrollState.value}\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"5549\"\u003eExplanation\u003c/h2\u003e\u003cp id=\"efbf\"\u003eIn this example:\u003c/p\u003e\u003cul\u003e\u003cli id=\"88ac\"\u003eWe create a \u003ccode\u003eColumn\u003c/code\u003e with a \u003ccode\u003eScrollState\u003c/code\u003e that allows it to scroll vertically.\u003c/li\u003e\u003cli id=\"1ef0\"\u003e\u003ccode\u003everticalScroll(scrollState)\u003c/code\u003e attaches the scroll state to the column.\u003c/li\u003e\u003cli id=\"ea80\"\u003eInside the \u003ccode\u003eLaunchedEffect\u003c/code\u003e, we print the current scroll position each time \u003ccode\u003escrollState.value\u003c/code\u003e changes.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f5ae\"\u003eThis example demonstrates basic scroll behavior in a \u003ccode\u003eColumn\u003c/code\u003e and how to observe the scroll position.\u003c/p\u003e\u003ch2 id=\"5a3a\"\u003eExample 2: Smooth Scrolling with \u003ccode\u003eScrollState\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"126f\"\u003eIf you want to programmatically scroll to a specific position, you can use \u003ccode\u003escrollState.animateScrollTo(offset)\u003c/code\u003e. This is helpful for features like \u0026#34;scroll to top\u0026#34; or \u0026#34;scroll to a specific item.\u0026#34;\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6dba\"\u003eimport androidx.compose.foundation.layout.*\u003cbr/\u003eimport androidx.compose.foundation.rememberScrollState\u003cbr/\u003eimport androidx.compose.foundation.verticalScroll\u003cbr/\u003eimport androidx.compose.material3.Button\u003cbr/\u003eimport androidx.compose.material3.Text\u003cbr/\u003eimport androidx.compose.runtime.*\u003cbr/\u003eimport androidx.compose.ui.Modifier\u003cbr/\u003eimport androidx.compose.ui.unit.dp\u003cbr/\u003eimport kotlinx.coroutines.launch\u003cp\u003e@Composable\u003cbr/\u003efun SmoothScrollingExample() {\u003cbr/\u003e    val scrollState = rememberScrollState()\u003cbr/\u003e    val coroutineScope = rememberCoroutineScope()\u003c/p\u003e\u003cp\u003e    Column(modifier = Modifier.fillMaxSize()) {\u003cbr/\u003e        Button(\u003cbr/\u003e            onClick = {\u003cbr/\u003e                // Smooth scroll to the top\u003cbr/\u003e                coroutineScope.launch {\u003cbr/\u003e                    scrollState.animateScrollTo(0)\u003cbr/\u003e                }\u003cbr/\u003e            },\u003cbr/\u003e            modifier = Modifier.fillMaxWidth()\u003cbr/\u003e        ) {\u003cbr/\u003e            Text(\u0026#34;Scroll to Top\u0026#34;)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        Spacer(modifier = Modifier.height(16.dp))\u003c/p\u003e\u003cp\u003e        Column(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .fillMaxSize()\u003cbr/\u003e                .verticalScroll(scrollState)\u003cbr/\u003e        ) {\u003cbr/\u003e            for (i in 1..50) {\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = \u0026#34;Item $i\u0026#34;,\u003cbr/\u003e                    modifier = Modifier\u003cbr/\u003e                        .fillMaxWidth()\u003cbr/\u003e                        .padding(16.dp),\u003cbr/\u003e                    color = Color.White\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"da27\"\u003eExplanation\u003c/h2\u003e\u003cul\u003e\u003cli id=\"79f9\"\u003eWe use \u003ccode\u003erememberCoroutineScope()\u003c/code\u003e to launch a coroutine that allows asynchronous scrolling.\u003c/li\u003e\u003cli id=\"50db\"\u003eThe button calls \u003ccode\u003escrollState.animateScrollTo(0)\u003c/code\u003e to scroll smoothly to the top of the list.\u003c/li\u003e\u003cli id=\"54c4\"\u003e\u003ccode\u003eanimateScrollTo()\u003c/code\u003e is an asynchronous function, making the scrolling smooth and animated.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5156\"\u003eNested Scrolling\u003c/h2\u003e\u003cp id=\"aa63\"\u003eNested scrolling is a concept where multiple scrolling containers work together to create a single scroll gesture.\u003c/p\u003e\u003cp id=\"8511\"\u003eCompose provides multiple ways of handling nested scrolling between composables. A typical example of nested scrolling is a list inside another list, and a more complex case is a collapsing toolbar.\u003c/p\u003e\u003cp id=\"0bdb\"\u003eLet’s understand the basic nested scrolling with an example.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3b5b\"\u003eHere we have a scrollable list, and each list has a child list which is also scrollable. we are also adding expand and collapse view to show and hide each list item’s child list.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"eec7\"\u003eimport androidx.compose.foundation.background\u003cbr/\u003eimport androidx.compose.foundation.clickable\u003cbr/\u003eimport androidx.compose.foundation.layout.*\u003cbr/\u003eimport androidx.compose.foundation.rememberScrollState\u003cbr/\u003eimport androidx.compose.foundation.verticalScroll\u003cbr/\u003eimport androidx.compose.material.icons.Icons\u003cbr/\u003eimport androidx.compose.material.icons.filled.ExpandLess\u003cbr/\u003eimport androidx.compose.material.icons.filled.ExpandMore\u003cbr/\u003eimport androidx.compose.material3.*\u003cbr/\u003eimport androidx.compose.runtime.*\u003cbr/\u003eimport androidx.compose.ui.Alignment\u003cbr/\u003eimport androidx.compose.ui.Modifier\u003cbr/\u003eimport androidx.compose.ui.graphics.Color\u003cbr/\u003eimport androidx.compose.ui.tooling.preview.Preview\u003cbr/\u003eimport androidx.compose.ui.unit.dp\u003cbr/\u003eimport androidx.compose.ui.unit.sp\u003cp\u003e@Composable\u003cbr/\u003efun NestedScrollingExample() {\u003cbr/\u003e    // Parent scroll state\u003cbr/\u003e    val parentScrollState = rememberScrollState()\u003c/p\u003e\u003cp\u003e    // Sample list data\u003cbr/\u003e    val items = (1..10).toList()\u003c/p\u003e\u003cp\u003e    Column(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e            .verticalScroll(parentScrollState)\u003cbr/\u003e            .padding(16.dp)\u003cbr/\u003e    ) {\u003cbr/\u003e        items.forEach { item -\u0026gt;\u003cbr/\u003e            ExpandableItem(item)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun ExpandableItem(item: Int) {\u003cbr/\u003e    // State to track if the item is expanded\u003cbr/\u003e    var isExpanded by remember { mutableStateOf(false) }\u003c/p\u003e\u003cp\u003e    Column(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e            .padding(vertical = 8.dp)\u003cbr/\u003e            .background(Color.LightGray)\u003cbr/\u003e    ) {\u003cbr/\u003e        // Header for the expandable item\u003cbr/\u003e        Row(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .fillMaxWidth()\u003cbr/\u003e                .clickable { isExpanded = !isExpanded }\u003cbr/\u003e                .padding(16.dp),\u003cbr/\u003e            verticalAlignment = Alignment.CenterVertically\u003cbr/\u003e        ) {\u003cbr/\u003e            Text(\u003cbr/\u003e                text = \u0026#34;Item $item\u0026#34;,\u003cbr/\u003e                fontSize = 18.sp,\u003cbr/\u003e                modifier = Modifier.weight(1f)\u003cbr/\u003e            )\u003cbr/\u003e            Icon(\u003cbr/\u003e                imageVector = if (isExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,\u003cbr/\u003e                contentDescription = \u0026#34;Expand/Collapse\u0026#34;\u003cbr/\u003e            )\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        // Child scrollable list, visible only when expanded\u003cbr/\u003e        if (isExpanded) {\u003cbr/\u003e            val childScrollState = rememberScrollState()\u003c/p\u003e\u003cp\u003e            Column(\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .height(150.dp) // Fixed height for nested scrollable area\u003cbr/\u003e                    .verticalScroll(childScrollState)\u003cbr/\u003e                    .background(Color.White)\u003cbr/\u003e                    .padding(8.dp)\u003cbr/\u003e            ) {\u003cbr/\u003e                // Nested list content\u003cbr/\u003e                (1..5).forEach { subItem -\u0026gt;\u003cbr/\u003e                    Text(\u003cbr/\u003e                        text = \u0026#34;Sub-item $subItem of Item $item\u0026#34;,\u003cbr/\u003e                        fontSize = 16.sp,\u003cbr/\u003e                        modifier = Modifier\u003cbr/\u003e                            .fillMaxWidth()\u003cbr/\u003e                            .padding(vertical = 4.dp)\u003cbr/\u003e                            .background(Color(0xFFF0F0F0))\u003cbr/\u003e                            .padding(8.dp)\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun showPeview() {\u003cbr/\u003e    NestedScrollingExample()\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2a33\"\u003e\u003cstrong\u003eHow Nested Scrolling Works Here\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"e1d8\"\u003eThe \u003cstrong\u003eparent scroll\u003c/strong\u003e (\u003ccode\u003eparentScrollState\u003c/code\u003e) allows the entire list of items to scroll vertically.\u003c/li\u003e\u003cli id=\"6650\"\u003eEach \u003cstrong\u003echild scroll\u003c/strong\u003e (\u003ccode\u003echildScrollState\u003c/code\u003e) manages the scrolling within the expanded item independently.\u003c/li\u003e\u003cli id=\"bc90\"\u003eThis approach avoids using \u003ccode\u003eLazyColumn\u003c/code\u003e or \u003ccode\u003eLazyRow\u003c/code\u003e, handling scrolling manually with \u003ccode\u003eScrollState\u003c/code\u003e instead.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2024-11-09T07:33:08.217Z",
  "modifiedTime": null
}
