{
  "id": "f79a2d45-994a-460c-88ae-65c4621272ec",
  "title": "Exploring Jetpack Compose: SearchBar",
  "link": "https://joebirch.co/android/exploring-the-searchbar-composable/",
  "description": "The ability to search for content within an app is a common feature, in fact, you’ll find it somewhere within most applications on your device. On Android, a common UI component we see for this functionality is a floating search bar, placed in a prominent part of the screen. In some cases, this also provides... Continue reading →",
  "author": "hitherejoe",
  "published": "Thu, 20 Mar 2025 08:43:26 +0000",
  "source": "https://joebirch.co/feed",
  "categories": [
    "Android",
    "Jetpack Compose",
    "Android App Development",
    "Android Development",
    "AndroidDev",
    "App Development",
    "Mobile App Development"
  ],
  "byline": "by hitherejoe",
  "length": 8075,
  "excerpt": "The ability to search for content within an app is a common feature, in fact, you'll find it somewhere within most applications on your device. On Android, a common UI component we see for this functionality is a floating search bar, placed in a prominent part of the screen. In some cases, this also",
  "siteName": "Joe Birch",
  "favicon": "",
  "text": "The ability to search for content within an app is a common feature, in fact, you’ll find it somewhere within most applications on your device. On Android, a common UI component we see for this functionality is a floating search bar, placed in a prominent part of the screen. In some cases, this also provides search recommendations to the user to streamline the search process. The Jetpack Compose Material3 package provides access to a SearchBar composable that offers this exact functionality and in this blog post, we’re going to learn how to utilise it in our own apps. The SearchBar composable allows us to display a floating Search component, which expands to display selectable recommendations. As mentioned above, this is a common pattern that we see in many applications, with this composable offering an out-of-the-box solution. The SearchBar composable provides enough customisation to control the look and feel of the component, along with using a slot-based approach for us to provide the input field for use. @Composable fun SearchBar( inputField: @Composable () -\u003e Unit, expanded: Boolean, onExpandedChange: (Boolean) -\u003e Unit, modifier: Modifier = Modifier, shape: Shape = SearchBarDefaults.inputFieldShape, colors: SearchBarColors = SearchBarDefaults.colors(), tonalElevation: Dp = SearchBarDefaults.TonalElevation, shadowElevation: Dp = SearchBarDefaults.ShadowElevation, windowInsets: WindowInsets = SearchBarDefaults.windowInsets, content: @Composable ColumnScope.() -\u003e Unit, ) The component handles most of the internals for us – with two key parts needing to be provided by ourselves. inputField – this is the input composable that represents the search field for content input content – this is the content area used to display recommendations when the search bar is expanded Outside of these fields, there are a collection of other properties that are used to determine the current state of the SearchBar. For example, when the Search Bar is in an expanded state, the content of the composable will be displayed beneath the input field. To be able to manage this, we need to provide some arguments to the composable that will be used to manage this state. To start with, the expanded argument is used to depict whether the SearchBar is in an expanded state (which will decide whether the content area will be shown), along with the onExpandedChange argument which is used to provide the implementation with an updated value for the expanded state (which can then be used to reflect our own state implementation). var expanded by remember { mutableStateOf(false) } SearchBar( modifier = Modifier.fillMaxWidth(), expanded = expanded, onExpandedChange = { expanded = it } ) Alongside managing this expanded state, we need to provide the inputField that is to be used for the input area of the SearchBar. Outside of following the slot-based approach for composables, this allows the composable to follow the concepts of state hoisting, allowing us to completely manage the state concepts for the input field of the SearchBar. var expanded by remember { mutableStateOf(false) } var query by remember { mutableStateOf\u003cString?\u003e(null) } SearchBar( modifier = Modifier.fillMaxWidth(), expanded = expanded, onExpandedChange = { expanded = it }, inputField = { } ) To make this simpler, the SearchBarDefaults class provides us access to an InputField composable – this gives us access to a composable specifically implemented for use with the SearchBar. It is not required to utilise this specific composable, but it is provided as a convenience composable specifically for a search-based input field. This composable takes some key arguments that are used to configure it for use within the SearchBar: expanded and onExpandedChange – used to manage the expanded state of the field query and onQueryChange – used to manage the state of the query displayed in the field Alongside these core properties, you’ll also notice the support for standard field arguments such as the placeholder, leadingIcon and trailingIcon. Alongside these being used for informative purposes, we can see in the example below how I have used the trailingIcon to allow the SearchBar to revert back to the collapsed state when the cancel button is clicked. SearchBarDefaults.InputField( onSearch = { expanded = false }, expanded = expanded, onExpandedChange = { expanded = it }, placeholder = { Text(\"What are you looking for?\") }, leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) }, trailingIcon = { if (expanded) { IconButton(onClick = { expanded = false }) { Icon(Icons.Default.Close, contentDescription = null) } } }, query = query ?: \"\", onQueryChange = { query = it } ) The implementation for this InputField composable can then be slotted into the inputField argument for the SearchBar composable. var expanded by remember { mutableStateOf(false) } var query by remember { mutableStateOf\u003cString?\u003e(null) } SearchBar( modifier = Modifier.fillMaxWidth(), expanded = expanded, onExpandedChange = { expanded = it }, inputField = { SearchBarDefaults.InputField( onSearch = { expanded = false }, expanded = expanded, onExpandedChange = { expanded = it }, placeholder = { Text(\"What are you looking for?\") }, leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) }, trailingIcon = { if (expanded) { IconButton(onClick = { expanded = false }) { Icon(Icons.Default.Close, contentDescription = null) } } }, query = query ?: \"\", onQueryChange = { query = it } ) } ) At this point, we would be able to compose the SearchBar and see the floating component displayed within our UI. All that remains for us to implement at this point is the content of the SearchBar, this is the content that is displayed when the SearchBar is in an expanded state. This argument utilise the ColumnScope, so any composables that are provided here will be stacked vertically. The expected form for this content area is a list of recommendations that can be selected by the user, so we’ll go ahead and compose a few ListItem composables that will each used to display a search recommendation to the user. When any of these items are clicked, the query will be updated to the selected value and the expanded state of the SearchBar reset. var expanded by remember { mutableStateOf(false) } var query by remember { mutableStateOf\u003cString?\u003e(null) } SearchBar( ... ) { listOf(\"Result 1\", \"Result 2\", \"Result 3\", \"Result 4\").forEach { text -\u003e ListItem( headlineContent = { Text(text) }, colors = ListItemDefaults.colors(containerColor = Color.Transparent), modifier = Modifier.clickable { query = text expanded = false }.fillMaxWidth().padding(horizontal = 16.dp, vertical = 8.dp) ) } } With this in place, we’ll now be able to see recommendations being shown beneath the floating search bar when it comes into focus. With the above in place, we’ve been able to implement a floating search bar that displays search recommendations to the user. Using the Material3 SearchBar composable, it has been very little effort to implement such a composable that transitions between these two different states. Maybe you are already using the SearchBar in your app or have been looking for similar functionality, but either way, I’m looking forward to seeing more apps saving time from a wider support of components in Jetpack Compose!",
  "image": "https://joebirch.co/wp-content/uploads/2025/03/Group.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\t\n\u003cp\u003eThe ability to search for content within an app is a common feature, in fact, you’ll find it somewhere within most applications on your device. On Android, a common UI component we see for this functionality is a floating search bar, placed in a prominent part of the screen. In some cases, this also provides search recommendations to the user to streamline the search process. The Jetpack Compose Material3 package provides access to a SearchBar composable that offers this exact functionality and in this blog post, we’re going to learn how to utilise it in our own apps.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"736\" height=\"366\" src=\"https://joebirch.co/wp-content/uploads/2025/03/Group.png\" alt=\"\" srcset=\"https://joebirch.co/wp-content/uploads/2025/03/Group.png 736w, https://joebirch.co/wp-content/uploads/2025/03/Group-300x149.png 300w, https://joebirch.co/wp-content/uploads/2025/03/Group-500x249.png 500w, https://joebirch.co/wp-content/uploads/2025/03/Group-150x75.png 150w, https://joebirch.co/wp-content/uploads/2025/03/Group-400x199.png 400w, https://joebirch.co/wp-content/uploads/2025/03/Group-200x99.png 200w\" sizes=\"(max-width: 736px) 100vw, 736px\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eThe SearchBar composable allows us to display a floating Search component, which expands to display selectable recommendations. As mentioned above, this is a common pattern that we see in many applications, with this composable offering an out-of-the-box solution. The SearchBar composable provides enough customisation to control the look and feel of the component, along with using a slot-based approach for us to provide the input field for use. \u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e@Composable\nfun SearchBar(\n    inputField: @Composable () -\u0026gt; Unit,\n    expanded: Boolean,\n    onExpandedChange: (Boolean) -\u0026gt; Unit,\n    modifier: Modifier = Modifier,\n    shape: Shape = SearchBarDefaults.inputFieldShape,\n    colors: SearchBarColors = SearchBarDefaults.colors(),\n    tonalElevation: Dp = SearchBarDefaults.TonalElevation,\n    shadowElevation: Dp = SearchBarDefaults.ShadowElevation,\n    windowInsets: WindowInsets = SearchBarDefaults.windowInsets,\n    content: @Composable ColumnScope.() -\u0026gt; Unit,\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe component handles most of the internals for us – with two key parts needing to be provided by ourselves.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003einputField\u003c/strong\u003e – this is the input composable that represents the search field for content input\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003econtent\u003c/strong\u003e – this is the content area used to display recommendations when the search bar is expanded\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eOutside of these fields, there are a collection of other properties that are used to determine the current state of the SearchBar. For example, when the Search Bar is in an expanded state, the \u003cstrong\u003econtent\u003c/strong\u003e of the composable will be displayed beneath the input field. To be able to manage this, we need to provide some arguments to the composable that will be used to manage this state. To start with, the \u003cstrong\u003eexpanded\u003c/strong\u003e argument is used to depict whether the SearchBar is in an expanded state (which will decide whether the \u003cstrong\u003econtent\u003c/strong\u003e area will be shown), along with the \u003cstrong\u003eonExpandedChange\u003c/strong\u003e argument which is used to provide the implementation with an updated value for the expanded state (which can then be used to reflect our own state implementation).\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003evar expanded by remember { mutableStateOf(false) }\n\nSearchBar(\n    modifier = Modifier.fillMaxWidth(),\n    expanded = expanded,\n    onExpandedChange = {\n        expanded = it\n    }\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAlongside managing this expanded state, we need to provide the \u003cstrong\u003einputField\u003c/strong\u003e that is to be used for the input area of the SearchBar. Outside of following the slot-based approach for composables, this allows the composable to follow the concepts of state hoisting, allowing us to completely manage the state concepts for the input field of the SearchBar.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003evar expanded by remember { mutableStateOf(false) }\nvar query by remember { mutableStateOf\u0026lt;String?\u0026gt;(null) }\n\nSearchBar(\n    modifier = Modifier.fillMaxWidth(),\n    expanded = expanded,\n    onExpandedChange = {\n        expanded = it\n    },\n    inputField = {\n        \n    }\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTo make this simpler, the \u003cstrong\u003eSearchBarDefaults\u003c/strong\u003e class provides us access to an \u003cstrong\u003eInputField\u003c/strong\u003e composable – this gives us access to a composable specifically implemented for use with the SearchBar. It is not required to utilise this specific composable, but it is provided as a convenience composable specifically for a search-based input field. This composable takes some key arguments that are used to configure it for use within the SearchBar:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eexpanded\u003c/strong\u003e and \u003cstrong\u003eonExpandedChange\u003c/strong\u003e – used to manage the expanded state of the field\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003equery\u003c/strong\u003e and \u003cstrong\u003eonQueryChange\u003c/strong\u003e – used to manage the state of the query displayed in the field\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAlongside these core properties, you’ll also notice the support for standard field arguments such as the \u003cstrong\u003eplaceholder\u003c/strong\u003e, \u003cstrong\u003eleadingIcon\u003c/strong\u003e and \u003cstrong\u003etrailingIcon\u003c/strong\u003e. Alongside these being used for informative purposes, we can see in the example below how I have used the \u003cstrong\u003etrailingIcon\u003c/strong\u003e to allow the SearchBar to revert back to the collapsed state when the cancel button is clicked.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eSearchBarDefaults.InputField(\n    onSearch = { expanded = false },\n    expanded = expanded,\n    onExpandedChange = { expanded = it },\n    placeholder = { Text(\u0026#34;What are you looking for?\u0026#34;) },\n    leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },\n    trailingIcon = {\n        if (expanded) {\n            IconButton(onClick = {\n                expanded = false\n            }) {\n                Icon(Icons.Default.Close, contentDescription = null)\n            }\n        }\n    },\n    query = query ?: \u0026#34;\u0026#34;,\n    onQueryChange = {\n        query = it\n    }\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe implementation for this \u003cstrong\u003eInputField\u003c/strong\u003e composable can then be slotted into the \u003cstrong\u003einputField\u003c/strong\u003e argument for the \u003cstrong\u003eSearchBar\u003c/strong\u003e composable.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003evar expanded by remember { mutableStateOf(false) }\nvar query by remember { mutableStateOf\u0026lt;String?\u0026gt;(null) }\n\nSearchBar(\n    modifier = Modifier.fillMaxWidth(),\n    expanded = expanded,\n    onExpandedChange = {\n        expanded = it\n    },\n    inputField = {\n        SearchBarDefaults.InputField(\n            onSearch = { expanded = false },\n            expanded = expanded,\n            onExpandedChange = { expanded = it },\n            placeholder = { Text(\u0026#34;What are you looking for?\u0026#34;) },\n            leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },\n            trailingIcon = {\n                if (expanded) {\n                    IconButton(onClick = {\n                        expanded = false\n                    }) {\n                        Icon(Icons.Default.Close, contentDescription = null)\n                    }\n                }\n            },\n            query = query ?: \u0026#34;\u0026#34;,\n            onQueryChange = {\n                query = it\n            }\n        )\n    }\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAt this point, we would be able to compose the SearchBar and see the floating component displayed within our UI.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"736\" height=\"366\" src=\"https://joebirch.co/wp-content/uploads/2025/03/sea.png\" alt=\"\" srcset=\"https://joebirch.co/wp-content/uploads/2025/03/sea.png 736w, https://joebirch.co/wp-content/uploads/2025/03/sea-300x149.png 300w, https://joebirch.co/wp-content/uploads/2025/03/sea-500x249.png 500w, https://joebirch.co/wp-content/uploads/2025/03/sea-150x75.png 150w, https://joebirch.co/wp-content/uploads/2025/03/sea-400x199.png 400w, https://joebirch.co/wp-content/uploads/2025/03/sea-200x99.png 200w\" sizes=\"(max-width: 736px) 100vw, 736px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAll that remains for us to implement at this point is the \u003cstrong\u003econtent\u003c/strong\u003e of the \u003cstrong\u003eSearchBar\u003c/strong\u003e, this is the content that is displayed when the \u003cstrong\u003eSearchBar\u003c/strong\u003e is in an expanded state. This argument utilise the ColumnScope, so any composables that are provided here will be stacked vertically. The expected form for this content area is  a list of recommendations that can be selected by the user, so we’ll go ahead and compose a few \u003cstrong\u003eListItem\u003c/strong\u003e composables that will each used to display a search recommendation to the user. When any of these items are clicked, the \u003cstrong\u003equery\u003c/strong\u003e will be updated to the selected value and the \u003cstrong\u003eexpanded\u003c/strong\u003e state of the SearchBar reset.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003evar expanded by remember { mutableStateOf(false) }\nvar query by remember { mutableStateOf\u0026lt;String?\u0026gt;(null) }\n\nSearchBar(\n    ...\n) {\n    listOf(\u0026#34;Result 1\u0026#34;, \u0026#34;Result 2\u0026#34;, \u0026#34;Result 3\u0026#34;, \u0026#34;Result 4\u0026#34;).forEach { text -\u0026gt;\n        ListItem(\n            headlineContent = { Text(text) },\n            colors = ListItemDefaults.colors(containerColor = Color.Transparent),\n            modifier = Modifier.clickable {\n                query = text\n                expanded = false\n            }.fillMaxWidth().padding(horizontal = 16.dp, vertical = 8.dp)\n        )\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith this in place, we’ll now be able to see recommendations being shown beneath the floating search bar when it comes into focus.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"736\" height=\"366\" src=\"https://joebirch.co/wp-content/uploads/2025/03/recs.png\" alt=\"\" srcset=\"https://joebirch.co/wp-content/uploads/2025/03/recs.png 736w, https://joebirch.co/wp-content/uploads/2025/03/recs-300x149.png 300w, https://joebirch.co/wp-content/uploads/2025/03/recs-500x249.png 500w, https://joebirch.co/wp-content/uploads/2025/03/recs-150x75.png 150w, https://joebirch.co/wp-content/uploads/2025/03/recs-400x199.png 400w, https://joebirch.co/wp-content/uploads/2025/03/recs-200x99.png 200w\" sizes=\"(max-width: 736px) 100vw, 736px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eWith the above in place, we’ve been able to implement a floating search bar that displays search recommendations to the user. Using the Material3 SearchBar composable, it has been very little effort to implement such a composable that transitions between these two different states. Maybe you are already using the SearchBar in your app or have been looking for similar functionality, but either way, I’m looking forward to seeing more apps saving time from a wider support of components in Jetpack Compose!\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-03-20T08:43:26Z",
  "modifiedTime": "2025-03-20T08:47:40Z"
}
