{
  "id": "f58c3ef9-0281-4408-b174-e5f40f765220",
  "title": "How I Finally Memorized Modifier Ordering in Compose",
  "link": "https://zsmb.co/remembering-modifier-order/",
  "description": "For the longest time, I proudly had no idea of how Modifier ordering works, and would just guess and then guess again when something didn't look quite right. Here's how I finally ended up remembering how the ordering works.",
  "author": "Márton Braun",
  "published": "Tue, 04 Jun 2024 09:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "Márton Braun",
  "length": 6013,
  "excerpt": "For the longest time, I proudly had no idea of how Modifier ordering works, and would just guess and then guess again when something didn't look quite right. Here's how I finally ended up remembering how the ordering works.",
  "siteName": "zsmb.co",
  "favicon": "",
  "text": "For the longest time, I was a proud member of the “no idea how Modifier ordering works, just try it one way and flip it around if it doesn’t work” club. I’ve read and watched a bunch of content explaining how constraints are propagated up and down the chain of modifiers and the tree of layout nodes, and… None of that really stuck with me. I would still take a guess every single time I added a modifier, and just move it around if it didn’t immediately have the desired effect. However, I’ve recently realized that I accidentally learned how Modifier ordering works; perhaps the way I understand it now will help you too. The modifier parameter for components I’ve always been fascinated with how Compose makes excellent use of Kotlin’s advanced language features in its API design. One important guideline in Compose is that well-written @Composable UI component functions should take a modifier: Modifier parameter. This should default to the value Modifier, which represents an empty implementation, applying no customization to the component’s basic looks or behaviour. @Composable fun Greeting( name: String, modifier: Modifier = Modifier, // This one, here! ) It’s then the component’s responsibility to apply this modifier to the root node of whatever UI it emits: @Composable fun Greeting(..., modifier: Modifier = Modifier) { Column(modifier) { // ✅ Applied at the root // The rest of the component } } This is often done as shown above, by directly passing modifier to the root node. Components may also choose to add additional modifiers onto this using the usual chaining API, however – and this is the crucial part – they may only chain additional Modifiers after modifier, and never before it. This, for example, is a valid application of the parameter: @Composable fun Greeting(..., modifier: Modifier = Modifier) { Column(modifier.padding(8.dp)) { // ✅ Chaining after the parameter // The rest of the component } } But this is not valid: @Composable fun Greeting(..., modifier: Modifier = Modifier) { Column( Modifier.padding(8.dp).then(modifier)) // ❌ modifier must come first ) { // The rest of the component } } How to remember modifier ordering So, how does this help us understand modifier ordering? When you look at a component that has a Column as its root (sticking to our example here) as its user, that component is, essentially, a column of stuff to you. When you pass in a modifier to that Composable, you expect the modifier to be applied to the Column – because that’s what the component is. If you add padding, the padding should be added around the column. If you add a border, the border should be added around the column. Visually speaking, it makes sense that the component should always be decorated from the outside. Combining this with our knowledge that the modifier passed into a component always ends up at the beginning of a potential chain of modifiers, we arrive at the following conclusion: Modifiers are applied last-to-first, inside-to-outside. The further up the chain a Modifier is, the later it gets applied. The last modifier to be applied is the modifier which sits at the very front of the chain for components, as customization coming from the outside must be applied around what the component already contains. Show me the code Let’s say that our Greeting component is implemented like this, with a background colour and a padding chained onto the modifier parameter as it gets applied. @Composable fun Greeting(..., modifier: Modifier = Modifier) { Column( modifier .background(Color(0xFFD4B0FF)) .padding(28.dp), ... ) { // The rest of the component } } If we call the Greeting function without passing in a modifier, only these two modifiers declared inside the function get applied by default. Greeting(\"Kodee\") The complete modifier chain in this case, substituting just Modifier for the parameter is: Modifier .background(Color(0xFFD4B0FF)) .padding(28.dp) Reading the modifiers last-to-first, we can imagine that first the padding surrounds the column, and then the background colour fills that space. This is what our Composable component looks like out-of-the-box, with no customization passed in from the parameters. Now, let’s add a real modifier parameter, which will end up at the front of the chain, and customize the component from the outside. Greeting( \"Kodee\", modifier = Modifier .padding(48.dp) .border(4.dp, Color.Magenta) ) The effective Modifier chain here becomes: Modifier // \"External\" modifiers, from the parameter .padding(48.dp) .border(4.dp, Color.Magenta) // \"Internal\" modifiers, within the component .background(Color(0xFFD4B0FF)) .padding(28.dp) This means that we perform the same steps as before to get the component with its base looks, and then keep going last-to-first. We add the border, and then add some more padding. Conclusion That’s all! I hope that this explanation helps you with ordering your modifiers correctly. Remember, if a modifier needs to go around another modifier, it should be in front of it in the modifier chain. Last-to-first, inside-to-outside. Have fun coding Compose! I started learning Jetpack Compose this week. Two days into that adventure, here's a quick look at how a neat clock design can be built up in Compose, step-by-step.This article documents how I created my own custom screen saver for macOS, built almost entirely in Kotlin, using the powers of Kotlin Multiplatform compiled to macOS. Join me for a tale of Kotlin success and macOS failures.StateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.Another year over, a new one's almost begun. Here's a brief summary of what I've done in this one.",
  "image": "https://zsmb.co/images/remembering-modifier-order/meta.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \u003cp\u003eFor the longest time, I was a proud member of the “no idea how Modifier ordering works, just try it one way and flip it around if it doesn’t work” club.\u003c/p\u003e\n\u003cp\u003eI’ve read and watched a \u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/constraints-modifiers\"\u003ebunch of content\u003c/a\u003e explaining how constraints are propagated up and down the chain of modifiers and the tree of layout nodes, and… None of that really stuck with me. I would still take a guess every single time I added a modifier, and just move it around if it didn’t immediately have the desired effect.\u003c/p\u003e\n\u003cp\u003eHowever, I’ve recently realized that I accidentally learned how Modifier ordering works; perhaps the way I understand it now will help you too.\u003c/p\u003e\n\u003ch3 id=\"the-modifier-parameter-for-components\"\u003eThe \u003ccode\u003emodifier\u003c/code\u003e parameter for components\u003c/h3\u003e\n\u003cp\u003eI’ve always \u003ca href=\"https://zsmb.co/talks/composing-an-api-with-kotlin/\"\u003ebeen\u003c/a\u003e \u003ca href=\"https://zsmb.co/talks/composing-an-api-with-kotlin-vol-2/\"\u003efascinated\u003c/a\u003e with how Compose makes excellent use of Kotlin’s advanced language features in its API design.\u003c/p\u003e\n\u003cp\u003eOne important guideline in Compose is that well-written \u003ccode\u003e@Composable\u003c/code\u003e UI component functions should take a \u003ccode\u003emodifier: Modifier\u003c/code\u003e parameter. This should default to the value \u003ccode\u003eModifier\u003c/code\u003e, which represents an empty implementation, applying no customization to the component’s basic looks or behaviour.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Greeting(\n    name: String,\n    modifier: Modifier = Modifier, // This one, here!\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt’s then the component’s responsibility to apply this \u003ccode\u003emodifier\u003c/code\u003e to the root node of whatever UI it emits:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Greeting(..., modifier: Modifier = Modifier) {\n    Column(modifier) { // ✅ Applied at the root\n        // The rest of the component\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is often done as shown above, by directly passing \u003ccode\u003emodifier\u003c/code\u003e to the root node. Components may also choose to add additional modifiers onto this using the usual chaining API, however – and this is the crucial part – they may only chain additional Modifiers \u003cem\u003eafter\u003c/em\u003e \u003ccode\u003emodifier\u003c/code\u003e, and \u003cem\u003enever before\u003c/em\u003e it. This, for example, is a valid application of the parameter:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Greeting(..., modifier: Modifier = Modifier) {\n    Column(modifier.padding(8.dp)) { // ✅ Chaining after the parameter\n        // The rest of the component\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut this is \u003cstrong\u003enot\u003c/strong\u003e valid:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Greeting(..., modifier: Modifier = Modifier) {\n    Column(\n        Modifier.padding(8.dp).then(modifier)) // ❌ modifier must come first\n    ) {\n        // The rest of the component\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"how-to-remember-modifier-ordering\"\u003eHow to remember modifier ordering\u003c/h3\u003e\n\u003cp\u003eSo, how does this help us understand modifier ordering?\u003c/p\u003e\n\u003cp\u003eWhen you look at a component that has a \u003ccode\u003eColumn\u003c/code\u003e as its root (sticking to our example here) as its user, that component is, essentially, \u003cem\u003ea column of stuff\u003c/em\u003e to you. When you pass in a \u003ccode\u003emodifier\u003c/code\u003e to that Composable, you expect the \u003ccode\u003emodifier\u003c/code\u003e to be applied to the \u003ccode\u003eColumn\u003c/code\u003e – because that’s what the component is.\u003c/p\u003e\n\u003cp\u003eIf you add padding, the padding should be added \u003cem\u003earound the column\u003c/em\u003e. If you add a border, the border should be added \u003cem\u003earound the column\u003c/em\u003e. Visually speaking, it makes sense that the component should always be decorated from the outside.\u003c/p\u003e\n\u003cp\u003eCombining this with our knowledge that the \u003ccode\u003emodifier\u003c/code\u003e passed into a component always ends up at the beginning of a potential chain of modifiers, we arrive at the following conclusion:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eModifiers are applied last-to-first, inside-to-outside.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe further up the chain a Modifier is, the later it gets applied. The last modifier to be applied is the \u003ccode\u003emodifier\u003c/code\u003e which sits at the very front of the chain for components, as customization coming from the outside must be applied \u003cem\u003earound\u003c/em\u003e what the component already contains.\u003c/p\u003e\n\u003ch3 id=\"show-me-the-code\"\u003eShow me the code\u003c/h3\u003e\n\u003cp\u003eLet’s say that our \u003ccode\u003eGreeting\u003c/code\u003e component is implemented like this, with a background colour and a padding chained onto the \u003ccode\u003emodifier\u003c/code\u003e parameter as it gets applied.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Greeting(..., modifier: Modifier = Modifier) {\n    Column(\n        modifier\n            .background(Color(0xFFD4B0FF))\n            .padding(28.dp),\n        ...\n    ) {\n        // The rest of the component\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we call the \u003ccode\u003eGreeting\u003c/code\u003e function without passing in a modifier, only these two modifiers declared inside the function get applied by default.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGreeting(\u0026#34;Kodee\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe complete modifier chain in this case, substituting just \u003ccode\u003eModifier\u003c/code\u003e for the parameter is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eModifier\n    .background(Color(0xFFD4B0FF))\n    .padding(28.dp)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReading the modifiers last-to-first, we can imagine that first the padding surrounds the column, and then the background colour fills that space.\u003c/p\u003e\n\u003cvideo autoplay=\"\" controls=\"\" loop=\"\" muted=\"\" width=\"100%\"\u003e\n    \u003csource src=\"https://zsmb.co/images/remembering-modifier-order/two.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003cp\u003eThis is what our Composable component looks like out-of-the-box, with no customization passed in from the parameters.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eNow, let’s add a real modifier parameter, which will end up at the \u003cem\u003efront\u003c/em\u003e of the chain, and customize the component from the \u003cem\u003eoutside\u003c/em\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGreeting(\n    \u0026#34;Kodee\u0026#34;,\n    modifier = Modifier\n        .padding(48.dp)\n        .border(4.dp, Color.Magenta)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe effective Modifier chain here becomes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eModifier\n    // \u0026#34;External\u0026#34; modifiers, from the parameter\n    .padding(48.dp)\n    .border(4.dp, Color.Magenta)\n    // \u0026#34;Internal\u0026#34; modifiers, within the component\n    .background(Color(0xFFD4B0FF))\n    .padding(28.dp)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis means that we perform the same steps as before to get the component with its base looks, and then keep going last-to-first. We add the border, and then add some more padding.\u003c/p\u003e\n\u003cvideo autoplay=\"\" controls=\"\" loop=\"\" muted=\"\" width=\"100%\"\u003e\n    \u003csource src=\"https://zsmb.co/images/remembering-modifier-order/four.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\u003cp\u003eThat’s all! I hope that this explanation helps you with ordering your modifiers correctly. Remember, if a modifier needs to go \u003cem\u003earound\u003c/em\u003e another modifier, it should be \u003cem\u003ein front of\u003c/em\u003e it in the modifier chain. Last-to-first, inside-to-outside.\u003c/p\u003e\n\u003cp\u003eHave fun coding Compose!\u003c/p\u003e\n\n\u003c/div\u003e\u003cp\u003eI started learning Jetpack Compose this week. Two days into that adventure, here\u0026#39;s a quick look at how a neat clock design can be built up in Compose, step-by-step.\u003c/p\u003e\u003cp\u003eThis article documents how I created my own custom screen saver for macOS, built almost entirely in Kotlin, using the powers of Kotlin Multiplatform compiled to macOS. Join me for a tale of Kotlin success and macOS failures.\u003c/p\u003e\u003cp\u003eStateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.\u003c/p\u003e\u003cp\u003eAnother year over, a new one\u0026#39;s almost begun. Here\u0026#39;s a brief summary of what I\u0026#39;ve done in this one.\u003c/p\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
