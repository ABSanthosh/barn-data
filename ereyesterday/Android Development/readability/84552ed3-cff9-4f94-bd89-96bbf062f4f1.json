{
  "id": "84552ed3-cff9-4f94-bd89-96bbf062f4f1",
  "title": "Lint Revisit: TODO Detector v2",
  "link": "https://zarah.dev/2024/07/22/todo-detector-v2.html",
  "description": "A few years ago, I wrote about writing a Lint rule to validate the format of TODO comments. Whilst I find that Lint is still difficult to grok, I have since learnt a little bit more that I feel a revisit of this rule is warranted.",
  "author": "Zarah Dominguez",
  "published": "2024-07-22T00:00:00+00:00",
  "source": "https://zarah.dev/feed.xml",
  "categories": [
    "android",
    "lint"
  ],
  "byline": "",
  "length": 13492,
  "excerpt": "A few years ago, I wrote about writing a Lint rule to validate the format of TODO comments. Whilst I find that Lint is still difficult to grok, I have since ...",
  "siteName": "",
  "favicon": "https://zarah.dev/assets/images/apple-touch-icon.png",
  "text": "A few years ago, I wrote about writing a Lint rule to validate the format of TODO comments. Whilst I find that Lint is still difficult to grok, I have since learnt a little bit more that I feel a revisit of this rule is warranted. To recap, the rule enforces that all TODOs must follow the format: // TODO-[ASSIGNEE] (DATE_TODAY): Some comments The RegEx to check if a TODO is valid or not is a bit loosey-goosey, and just checks for a very generic pattern: /* Comment should follow the pattern: // = Two backward slashes \\\\s+ = one or more whitespaces TODO- = literal \"TODO-\" \\\\w* = zero or more word characters \\\\s+ = one or more whitespaces \\\\( = an open parentheses d{8} = eight numeric characters \\\\) = a close parentheses : = literal \":\" .* = zero or more of any character */ Regex(\"//\\\\s+TODO-\\\\w*\\\\s+\\\\(\\\\d{8}\\\\):.*\") In addition, the auto-fixes in the current version of the rule is a bit naive. For one, it assumes that any TODO does not have an assignee and the auto-fix will blindly tack on the assignee and today‚Äôs date. For this iteration, the rule will be expanded to: do separate checks for the assignee and the date, change the date format to yyyy-MM-dd to make it easier to read, re-use either field if it already exists, update tests to include LintFixes I had some new tricks up my sleeve this time, including named MatchGroups in RegEx (read more about that here). Being more specific üìç As a developer, nothing annoys me more than a very vague error message. They are unhelpful and provide no feedback on what actually caused the error, nor steps on how to fix it. One change in this version is to split out the checks for the assignee and the date. This allows us to provide a more specific error message to the user: First up is an update to the Regex to check for the complete pattern: /* Comment should follow the pattern: .* = zero or more of any character TODO- = literal \"TODO-\" (?\u003cMATCH_KEY_ASSIGNEE\u003e[^:\\(\\s-]+) = assignee capturing group [^:\\(\\s-]+ = one or more of any character that is not a \":\", \"(\", whitespace, or \"-\" = literal \" \" \\( = an open parenthesis (?\u003c$MATCH_KEY_DATE\u003e20[0-9]{2}-[01][0-9]-[0-3][0-9]) = date capturing group 20[0-9]{2}-[01][0-9]-[0-3][0-9] = accepts a four-digit year, a two-digit month, and a two-digit day (yes technically it will allow a month value of \"00\" but let's deal with that next time) \\) = a close parenthesis : = literal \":\" .* = zero or more of any character */ val COMPLETE_PATTERN_REGEX = \"\"\".*TODO-(?\u003cMATCH_KEY_ASSIGNEE\u003e[^:\\(\\s-]+) \\((?\u003c$MATCH_KEY_DATE\u003e20[0-9]{2}-[01][0-9]-[0-3][0-9])\\):.*\"\"\".toRegex() If for one reason or another the comment does not match the pattern, a cascading set of checks are done and any issue reported as soon as they are encountered: // MISSING_DATE: Date is totally absent, or in the wrong place var issueFound = reportDateIssue(context, comment) if (issueFound) return // MISSING_ASSIGNEE: Assignee is totally absent issueFound = reportAssigneeIssue(context, comment) if (issueFound) return // All other issues fall through to here, like if all elements are there but in the wrong order val incident = Incident() .issue(IMPROPER_FORMAT) .location(context.getLocation(comment)) .message(\"Improper format\") // Only suggest the fix for non-block comments // Block comments are trickier to figure out, something to implement for the future! if (comment.sourcePsi.elementType != KtTokens.BLOCK_COMMENT) { incident.fix(createFix(comment)) } context.report(incident) Each kind of error is differentiated via individual Issue definitions shown here. Reporting date issues üóìÔ∏è Instead of a simple validation for eight consecutive digits, we now do a three-part check: if there is nothing enclosed in parentheses, report missing date if there are empty parentheses (i.e. ()), report missing date if there are values in parentheses, check if it is a valid date and report if not First, we verify if there is anything at all enclosed in parentheses: // Capture everything between the first opening parenthesis and the // last closing parenthesis val inParensPattern = \"\"\".*TODO.*\\((?\u003c$MATCH_KEY_DATE\u003e[^\\)]*)\\).*\"\"\".toRegex() val allInParentheses = inParensPattern.find(commentText)?.groups // If there is nothing at all, we can conclude the date is missing if (allInParentheses == null) { val incident = Incident() .issue(MISSING_OR_INVALID_DATE) .location(context.getLocation(comment)) .message(\"Missing date\") context.report(incident) } If the comment does have parentheses, we check the value contained within via the named capturing group MATCH_KEY_DATE. val dateMatch = inParensMatches[MATCH_KEY_DATE] val parensValue = requireNotNull(dateMatch).value val message = when { parensValue == \"\" -\u003e \"Missing date\" !isValidDate(parensValue) -\u003e \"Invalid date\" else -\u003e null } In the snippet above, isValidDate checks if the value in parentheses follows the date format required and is within the range defined in COMPLETE_PATTERN_REGEX: private fun isValidDate(dateString: String): Boolean { try { val providedDate = LocalDate.parse(dateString, DateTimeFormatter.ofPattern(DATE_PATTERN)) val providedYear = providedDate.year return providedYear in 2024..2099 } catch (e: DateTimeParseException) { return false } } If there is an error, we can use the IntRange contained in dateMatch to show the red squiggly lines over the specific error, like so: To do this, we need to figure out the exact Location that we want to highlight. We can calculate this from two pieces of information we already know: the Location of the comment within the file the IntRange of the value in parentheses within the comment val commentStartOffset = context.getLocation(comment).start?.offset ?: 0 val startLocation = commentStartOffset + dateMatch.range.first val endLocation = commentStartOffset + dateMatch.range.last // The actual `Location` of the date value val dateLocation = Location.create( file = context.file, contents = context.getContents(), startOffset = startLocation, endOffset = endLocation + 1, ) // The `Location` to highlight, including the parentheses val problemLocation = Location.create( file = context.file, contents = context.getContents(), startOffset = startLocation - 1, endOffset = endLocation + 2, ) // Construct the `LintFix` to put in today's date val dateFix = LintFix.create() .name(\"Update date\") .replace() .range(dateLocation) .with(LocalDate.now().format(DateTimeFormatter.ofPattern(DATE_PATTERN))) .build() // Report the `Incident` val incident = Incident() .issue(MISSING_OR_INVALID_DATE) .location(problemLocation) .message(message) // Whether the date is missing or invalid .fix(dateFix) context.report(incident) Reporting assignee issues üôã‚Äç‚ôÄÔ∏è Reporting assignee issues is largely similar to reporting date issues. We first check if there is any assignee at all, i.e., if there is word attached to the TODO with a dash: // Capture everything after an optional dash // until the first open parenthesis or whitespace val assigneePattern = \"\"\".*TODO-*(?\u003c$MATCH_KEY_ASSIGNEE\u003e[^:\\(\\s-]+).*\\(.*\\)\"\"\".toRegex() If there is no value in MATCH_KEY_ASSIGNEE, the Incident is reported and an auto-fix suggested: Unlike the date auto-fix, however, we do not have any delimiters that would contain the assignee. We thus need to do a bit of work to figure out what part of the current TODO should be replaced: // Find where the word \"TODO\" is inside the comment, and if there is a dash present // We want to handle comments like \"// TODO- \" for example var nextCharIndex = commentText.indexOf(\"TODO\", ignoreCase = true) + 4 // length of \"TODO if (commentText[nextCharIndex] == '-') { ++nextCharIndex } // Figure out the `Location` to be updated val commentStartOffset = context.getLocation(comment).start?.offset ?: 0 val endLocation = commentStartOffset + nextCharIndex val addAssigneeFix = LintFix.create() .name(\"Assign this TODO\") .replace() .range(Location.create( file = context.file, contents = context.getContents(), startOffset = commentStartOffset, endOffset = endLocation )) .with(\"// TODO-${getUserName()}\") .build() val incident = Incident() .issue(MISSING_ASSIGNEE) .location(context.getLocation(comment)) .message(\"Missing assignee\") .fix(addAssigneeFix) context.report(incident) Reporting disordered issues ü§π The last type of error we want to fix are those that have all the elements in it, but are in the incorrect order such as: // TODO-Zarah: Some comments (2024-07-20) // TODO-Zarah: (2024-07-20) Some comments In this scenario, constructing the LintFix is a bit more involved. We grab elements from the current comment and reconstruct them: var replacementText = \"// TODO\" // We are going to manipulate the existing comment text // Drop anything before the word \"TODO\" // There may or may not be a colon, so remove that separately var commentText = comment.text .substringAfter(\"TODO\") .substringAfter(\"todo\") .removePrefix(\":\") .trimStart() Grab assignee value: // Find any assignee if available and re-use it var currentAssignee = getUserName() if (commentText.startsWith(\"-\")) { val assigneeMatches = ASSIGNEE_CAPTURE_START_REGEX.find(commentText) if (assigneeMatches != null) { val assigneeMatchGroup = requireNotNull(assigneeMatches.groups[MATCH_KEY_ASSIGNEE]) val assigneeRange = assigneeMatchGroup.range commentText = commentText.removeRange(assigneeRange).trimStart().removePrefix(\"-\") .removePrefix(\":\").trimStart() currentAssignee = assigneeMatchGroup.value.trim() } } replacementText += \"-$currentAssignee\" Grab the date: // Find the string enclosed in parentheses var dateReplacementValue = LocalDate.now().format(DateTimeFormatter.ofPattern(DATE_PATTERN)) val dateMatches = DATE_CAPTURE_REGEX.find(commentText) if (dateMatches != null) { val dateMatchGroup = requireNotNull(dateMatches.groups[MATCH_KEY_DATE]) commentText = commentText.removeRange(dateMatches.groups.first()!!.range).trimStart() dateReplacementValue = dateMatchGroup.value } replacementText += \" ($dateReplacementValue)\" Follow the convention of adding a colon: // Add a colon if the remaining text does not have it yet if (!commentText.startsWith(\":\")) { replacementText += \": \" } And then do a direct replacement of the whole comment: val fix = LintFix.create() .name(message) .replace() .text(comment.text) .with(replacementText) .build() Testing all the things üß™ There have been so many changes in this rule, which means a whole ton of new tests! I have added a whole bunch of test scenarios to cover the different iterations I can think of. The tests look mostly the same as before (see this post for reference), other than the addition of testing the LintFixes. Let‚Äôs take this TODO for example: // TODO (2024-07-20): Some comments Since we know what the comment should look like after our fix is applied, we can use that information to construct our assertion: .expectFixDiffs( \"\"\" Fix for src/test/pkg/TestClass1.kt line 3: Assign this TODO: @@ -3 +3 - // TODO (2024-07-20): Some comments + // TODO-$assignee (2024-07-20): Some comments \"\"\".trimIndent() ) And that‚Äôs pretty much it! All changes for both the detector and the tests are in GitHub. To read my past posts on this topic, check out the posts tagged with Lint, some of which are linked below: Anatomy of a Lint issue Detectors Unit Testing Multi-module rules Multi-module Testing As always, here are some first-party resources for Lint: Lint API Guide Lint User Guide Lint sample project Framework rules Issue definitions: private const val REQUIRED_FORMAT = \"All TODOs must follow the format `TODO-Assignee (DATE_TODAY): Additional comments`\" val IMPROPER_FORMAT: Issue = Issue.create( id = \"ImproperTodoFormat\", briefDescription = \"TODO has improper format\", explanation = \"\"\" $REQUIRED_FORMAT The assignee and the date are required information. \"\"\", category = Category.CORRECTNESS, priority = 3, severity = Severity.ERROR, implementation = IMPLEMENTATION ).setAndroidSpecific(true) val MISSING_ASSIGNEE: Issue = Issue.create( id = \"MissingTodoAssignee\", briefDescription = \"TODO with no assignee\", explanation = \"\"\" $REQUIRED_FORMAT Please put your name against this TODO. Assignees should be a camel-cased word, for example `ZarahDominguez`. \"\"\", category = Category.CORRECTNESS, priority = 3, severity = Severity.ERROR, implementation = IMPLEMENTATION ).setAndroidSpecific(true) val MISSING_OR_INVALID_DATE: Issue = Issue.create( id = \"MissingTodoDate\", briefDescription = \"TODO with no date\", explanation = \"\"\" $REQUIRED_FORMAT Please put today's date in the yyyy-MM-dd format enclosed in parentheses, for example `(2024-07-20)`. \"\"\", category = Category.CORRECTNESS, priority = 3, severity = Severity.ERROR, implementation = IMPLEMENTATION ).setAndroidSpecific(true)",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003eA few years ago, I wrote about writing \u003ca href=\"https://zarah.dev/2020/11/19/todo-detector.html\"\u003ea Lint rule\u003c/a\u003e to validate the format of \u003ccode\u003eTODO\u003c/code\u003e comments. Whilst I find that \nLint is still difficult to grok, I have since learnt a little bit more that I feel a revisit of this rule is\nwarranted.\u003c/p\u003e\n\n\u003cp\u003eTo recap, the rule enforces that all \u003ccode\u003eTODO\u003c/code\u003es must follow the format:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// TODO-[ASSIGNEE] (DATE_TODAY): Some comments\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe RegEx to check if a \u003ccode\u003eTODO\u003c/code\u003e is valid or not is a bit loosey-goosey, and just checks for a very\ngeneric pattern:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e/*\n Comment should follow the pattern:\n    // = Two backward slashes\n    \\\\s+ = one or more whitespaces\n    TODO- = literal \u0026#34;TODO-\u0026#34;\n    \\\\w* = zero or more word characters\n    \\\\s+ = one or more whitespaces\n    \\\\( = an open parentheses\n    d{8} = eight numeric characters\n    \\\\) = a close parentheses\n    : = literal \u0026#34;:\u0026#34;\n    .* = zero or more of any character\n*/\u003c/span\u003e\n\u003cspan\u003eRegex\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;//\\\\s+TODO-\\\\w*\\\\s+\\\\(\\\\d{8}\\\\):.*\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIn addition, the auto-fixes in the current version of the rule is a bit naive. For one, it assumes \nthat any \u003ccode\u003eTODO\u003c/code\u003e does not have an assignee and the auto-fix will blindly tack on the assignee and \ntoday‚Äôs date.\u003c/p\u003e\n\n\u003cp\u003eFor this iteration, the rule will be expanded to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003edo separate checks for the assignee and the date,\u003c/li\u003e\n  \u003cli\u003echange the date format to \u003ccode\u003eyyyy-MM-dd\u003c/code\u003e to make it easier to read,\u003c/li\u003e\n  \u003cli\u003ere-use either field if it already exists,\u003c/li\u003e\n  \u003cli\u003eupdate tests to include \u003ccode\u003eLintFix\u003c/code\u003ees\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eI had some new tricks up my sleeve this time, including named \u003ccode\u003eMatchGroup\u003c/code\u003es in RegEx (read more about that\n\u003ca href=\"https://zarah.dev/2024/07/21/regex-groups.html\"\u003ehere\u003c/a\u003e).\u003c/p\u003e\n\n\u003ch3 id=\"being-more-specific-\"\u003eBeing more specific üìç\u003c/h3\u003e\n\n\u003cp\u003eAs a developer, nothing annoys me more than a very vague error message. They are unhelpful and provide\nno feedback on what actually caused the error, nor steps on how to fix it.\u003c/p\u003e\n\n\u003cp\u003eOne change in this version is to split out the checks for the assignee and the date. This allows\nus to provide a more specific error message to the user:\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://imgur.com/T5I3TKZ\"\u003e\u003cimg src=\"https://i.imgur.com/T5I3TKZ.png\" width=\"400\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eFirst up is an update to the Regex to check for the complete pattern:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e/*\n Comment should follow the pattern:\n    .* = zero or more of any character\n    TODO- = literal \u0026#34;TODO-\u0026#34;\n    (?\u0026lt;MATCH_KEY_ASSIGNEE\u0026gt;[^:\\(\\s-]+) = assignee capturing group\n        [^:\\(\\s-]+ = one or more of any character that is not a \u0026#34;:\u0026#34;, \u0026#34;(\u0026#34;, whitespace, or \u0026#34;-\u0026#34;\n     = literal \u0026#34; \u0026#34;\n    \\( = an open parenthesis\n    (?\u0026lt;$MATCH_KEY_DATE\u0026gt;20[0-9]{2}-[01][0-9]-[0-3][0-9]) = date capturing group\n        20[0-9]{2}-[01][0-9]-[0-3][0-9] = accepts a four-digit year, a two-digit month, and a two-digit day\n                (yes technically it will allow a month value of \u0026#34;00\u0026#34; but let\u0026#39;s deal with that next time)\n    \\) = a close parenthesis\n    : = literal \u0026#34;:\u0026#34;\n    .* = zero or more of any character\n */\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eCOMPLETE_PATTERN_REGEX\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;.*TODO-(?\u0026lt;MATCH_KEY_ASSIGNEE\u0026gt;[^:\\(\\s-]+) \\((?\u0026lt;$MATCH_KEY_DATE\u0026gt;20[0-9]{2}-[01][0-9]-[0-3][0-9])\\):.*\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoRegex\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIf for one reason or another the comment does not match the pattern, a cascading set of checks are\ndone and any issue reported as soon as they are encountered:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// MISSING_DATE: Date is totally absent, or in the wrong place\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eissueFound\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereportDateIssue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eissueFound\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e\n\n\u003cspan\u003e// MISSING_ASSIGNEE: Assignee is totally absent\u003c/span\u003e\n\u003cspan\u003eissueFound\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereportAssigneeIssue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eissueFound\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e\n\n\u003cspan\u003e// All other issues fall through to here, like if all elements are there but in the wrong order\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eincident\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIncident\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eissue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eIMPROPER_FORMAT\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Improper format\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003e// Only suggest the fix for non-block comments\u003c/span\u003e\n\u003cspan\u003e// Block comments are trickier to figure out, something to implement for the future!\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esourcePsi\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eelementType\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003eKtTokens\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eBLOCK_COMMENT\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eincident\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efix\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecreateFix\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ereport\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eincident\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eEach kind of error is differentiated via individual \u003ccode\u003eIssue\u003c/code\u003e definitions \u003ca href=\"#issue-definitions\"\u003eshown here\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch3 id=\"reporting-date-issues-Ô∏è\"\u003eReporting date issues üóìÔ∏è\u003c/h3\u003e\n\n\u003cp\u003eInstead of a simple validation for eight consecutive digits, we now do a three-part check:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eif there is nothing enclosed in parentheses, report missing date\u003c/li\u003e\n  \u003cli\u003eif there are empty parentheses (i.e. \u003ccode\u003e()\u003c/code\u003e), report missing date\u003c/li\u003e\n  \u003cli\u003eif there are values in parentheses, check if it is a valid date and report if not\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eFirst, we verify if there is anything at all enclosed in parentheses:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Capture everything between the first opening parenthesis and the \u003c/span\u003e\n\u003cspan\u003e// last closing parenthesis\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003einParensPattern\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;.*TODO.*\\((?\u0026lt;$MATCH_KEY_DATE\u0026gt;[^\\)]*)\\).*\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoRegex\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eallInParentheses\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003einParensPattern\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efind\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecommentText\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e?.\u003c/span\u003e\u003cspan\u003egroups\u003c/span\u003e\n\n\u003cspan\u003e// If there is nothing at all, we can conclude the date is missing\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eallInParentheses\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\n    \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eincident\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIncident\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eissue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eMISSING_OR_INVALID_DATE\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Missing date\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \n    \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ereport\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eincident\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIf the comment \u003cem\u003edoes\u003c/em\u003e have parentheses, we check the value contained within via the named\ncapturing group \u003ccode\u003eMATCH_KEY_DATE\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edateMatch\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003einParensMatches\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eMATCH_KEY_DATE\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eparensValue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erequireNotNull\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edateMatch\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003emessage\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ewhen\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eparensValue\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026#34;Missing date\u0026#34;\u003c/span\u003e\n    \u003cspan\u003e!\u003c/span\u003e\u003cspan\u003eisValidDate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparensValue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026#34;Invalid date\u0026#34;\u003c/span\u003e\n    \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIn the snippet above, \u003ccode\u003eisValidDate\u003c/code\u003e checks if the value in parentheses follows the date format required\nand is within the range defined in \u003ccode\u003eCOMPLETE_PATTERN_REGEX\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eisValidDate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edateString\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e \u003cspan\u003eBoolean\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eprovidedDate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eLocalDate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eparse\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edateString\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eDateTimeFormatter\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eofPattern\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDATE_PATTERN\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eprovidedYear\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eprovidedDate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eyear\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eprovidedYear\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e2024\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003e2099\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003ecatch\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDateTimeParseException\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIf there is an error, we can use the \u003ccode\u003eIntRange\u003c/code\u003e contained in \u003ccode\u003edateMatch\u003c/code\u003e to show the red squiggly lines\nover the specific error, like so:\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://imgur.com/yPGU7eX\"\u003e\u003cimg src=\"https://i.imgur.com/yPGU7eX.png\" width=\"400\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eTo do this, we need to figure out the exact \u003ca href=\"https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-api/src/main/java/com/android/tools/lint/detector/api/Location.kt\"\u003e\u003ccode\u003eLocation\u003c/code\u003e\u003c/a\u003e\nthat we want to highlight. We can calculate this from two pieces of information we already know:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003ethe \u003ccode\u003eLocation\u003c/code\u003e of the comment within the file\u003c/li\u003e\n  \u003cli\u003ethe \u003ccode\u003eIntRange\u003c/code\u003e of the value in parentheses within the comment\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ecommentStartOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e?.\u003c/span\u003e\u003cspan\u003eoffset\u003c/span\u003e \u003cspan\u003e?:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003estartLocation\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecommentStartOffset\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003edateMatch\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erange\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efirst\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eendLocation\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecommentStartOffset\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003edateMatch\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erange\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elast\u003c/span\u003e\n\n\u003cspan\u003e// The actual `Location` of the date value\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edateLocation\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eLocation\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecreate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003efile\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efile\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003econtents\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetContents\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e\n    \u003cspan\u003estartOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estartLocation\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eendOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eendLocation\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003e// The `Location` to highlight, including the parentheses\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eproblemLocation\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eLocation\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecreate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003efile\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efile\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003econtents\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetContents\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e\n    \u003cspan\u003estartOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estartLocation\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eendOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eendLocation\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003e// Construct the `LintFix` to put in today\u0026#39;s date\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edateFix\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eLintFix\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecreate\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Update date\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ereplace\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erange\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edateLocation\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eLocalDate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enow\u003c/span\u003e\u003cspan\u003e().\u003c/span\u003e\u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDateTimeFormatter\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eofPattern\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDATE_PATTERN\u003c/span\u003e\u003cspan\u003e)))\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebuild\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \n\u003cspan\u003e// Report the `Incident`\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eincident\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIncident\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eissue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eMISSING_OR_INVALID_DATE\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eproblemLocation\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e   \u003cspan\u003e// Whether the date is missing or invalid\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efix\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edateFix\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ereport\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eincident\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3 id=\"reporting-assignee-issues-Ô∏è\"\u003eReporting assignee issues üôã‚Äç‚ôÄÔ∏è\u003c/h3\u003e\n\n\u003cp\u003eReporting assignee issues is largely similar to reporting date issues. We first check\nif there is any assignee at all, i.e., if there is word attached to the \u003ccode\u003eTODO\u003c/code\u003e with a dash:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Capture everything after an optional dash\u003c/span\u003e\n\u003cspan\u003e// until the first open parenthesis or whitespace\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eassigneePattern\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;.*TODO-*(?\u0026lt;$MATCH_KEY_ASSIGNEE\u0026gt;[^:\\(\\s-]+).*\\(.*\\)\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoRegex\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIf there is no value in \u003ccode\u003eMATCH_KEY_ASSIGNEE\u003c/code\u003e, the \u003ccode\u003eIncident\u003c/code\u003e is reported and an auto-fix suggested:\n\u003ca href=\"https://imgur.com/cAUifq3\"\u003e\u003cimg src=\"https://i.imgur.com/cAUifq3.png\" width=\"400\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eUnlike the date auto-fix, however, we do not have any delimiters that would contain the assignee.\nWe thus need to do a bit of work to figure out what part of the current \u003ccode\u003eTODO\u003c/code\u003e should be replaced:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Find where the word \u0026#34;TODO\u0026#34; is inside the comment, and if there is a dash present\u003c/span\u003e\n\u003cspan\u003e// We want to handle comments like \u0026#34;// TODO- \u0026#34; for example\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e \u003cspan\u003enextCharIndex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecommentText\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eindexOf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;TODO\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eignoreCase\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e \u003cspan\u003e// length of \u0026#34;TODO\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecommentText\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003enextCharIndex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;-\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e++\u003c/span\u003e\u003cspan\u003enextCharIndex\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003e// Figure out the `Location` to be updated\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ecommentStartOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e?.\u003c/span\u003e\u003cspan\u003eoffset\u003c/span\u003e \u003cspan\u003e?:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eendLocation\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecommentStartOffset\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003enextCharIndex\u003c/span\u003e\n\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eaddAssigneeFix\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eLintFix\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecreate\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Assign this TODO\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ereplace\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erange\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eLocation\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecreate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n        \u003cspan\u003efile\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efile\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003econtents\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetContents\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e\n        \u003cspan\u003estartOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecommentStartOffset\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003eendOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eendLocation\u003c/span\u003e\n    \u003cspan\u003e))\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;// TODO-${getUserName()}\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebuild\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eincident\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIncident\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eissue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eMISSING_ASSIGNEE\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Missing assignee\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efix\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eaddAssigneeFix\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003econtext\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ereport\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eincident\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3 id=\"reporting-disordered-issues-\"\u003eReporting disordered issues ü§π\u003c/h3\u003e\n\n\u003cp\u003eThe last type of error we want to fix are those that have all the elements in it, but are in the\nincorrect order such as:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// TODO-Zarah: Some comments (2024-07-20)\u003c/span\u003e\n\n\u003cspan\u003e// TODO-Zarah: (2024-07-20) Some comments\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIn this scenario, constructing the \u003ccode\u003eLintFix\u003c/code\u003e is a bit more involved. We grab elements from the \ncurrent comment and reconstruct them:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ereplacementText\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;// TODO\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003e// We are going to manipulate the existing comment text\u003c/span\u003e\n\u003cspan\u003e// Drop anything before the word \u0026#34;TODO\u0026#34;\u003c/span\u003e\n\u003cspan\u003e// There may or may not be a colon, so remove that separately\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ecommentText\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etext\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esubstringAfter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;TODO\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esubstringAfter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;todo\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eremovePrefix\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;:\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etrimStart\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eGrab assignee value:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e// Find any assignee if available and re-use it\nvar currentAssignee = getUserName()\n\nif (commentText.startsWith(\u0026#34;-\u0026#34;)) {\n    val assigneeMatches = ASSIGNEE_CAPTURE_START_REGEX.find(commentText)\n    if (assigneeMatches != null) {\n        val assigneeMatchGroup = requireNotNull(assigneeMatches.groups[MATCH_KEY_ASSIGNEE])\n        val assigneeRange = assigneeMatchGroup.range\n        commentText = commentText.removeRange(assigneeRange).trimStart().removePrefix(\u0026#34;-\u0026#34;)\n            .removePrefix(\u0026#34;:\u0026#34;).trimStart()\n        currentAssignee = assigneeMatchGroup.value.trim()\n    }\n}\nreplacementText += \u0026#34;-$currentAssignee\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eGrab the date:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e// Find the string enclosed in parentheses\nvar dateReplacementValue = LocalDate.now().format(DateTimeFormatter.ofPattern(DATE_PATTERN))\n\nval dateMatches = DATE_CAPTURE_REGEX.find(commentText)\nif (dateMatches != null) {\n    val dateMatchGroup = requireNotNull(dateMatches.groups[MATCH_KEY_DATE])\n    commentText = commentText.removeRange(dateMatches.groups.first()!!.range).trimStart()\n    dateReplacementValue = dateMatchGroup.value\n}\nreplacementText += \u0026#34; ($dateReplacementValue)\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eFollow the convention of adding a colon:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Add a colon if the remaining text does not have it yet\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(!\u003c/span\u003e\u003cspan\u003ecommentText\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estartsWith\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;:\u0026#34;\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ereplacementText\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e\u0026#34;: \u0026#34;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAnd then do a direct replacement of the whole comment:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003efix\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eLintFix\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecreate\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ereplace\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etext\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etext\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ereplacementText\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebuild\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3 id=\"testing-all-the-things-\"\u003eTesting all the things üß™\u003c/h3\u003e\n\n\u003cp\u003eThere have been so many changes in this rule, which means a whole ton of new tests! I have added a whole\nbunch of test scenarios to cover the different iterations I can think of.\u003c/p\u003e\n\n\u003cp\u003eThe tests look mostly the same as before (see \u003ca href=\"https://zarah.dev/2020/11/20/todo-test.html\"\u003ethis post\u003c/a\u003e for reference), other than the addition of testing the \u003ccode\u003eLintFix\u003c/code\u003ees. Let‚Äôs take \nthis \u003ccode\u003eTODO\u003c/code\u003e for example:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e// TODO (2024-07-20): Some comments\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eSince we know what the comment should look like after our fix is applied, we can use that information\nto construct our assertion:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e.expectFixDiffs(\n    \u0026#34;\u0026#34;\u0026#34;\n        Fix for src/test/pkg/TestClass1.kt line 3: Assign this TODO:\n        @@ -3 +3\n        -     // TODO (2024-07-20): Some comments\n        +     // TODO-$assignee (2024-07-20): Some comments\n    \u0026#34;\u0026#34;\u0026#34;.trimIndent()\n)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAnd that‚Äôs pretty much it!\u003c/p\u003e\n\n\u003cp\u003eAll changes for both the \u003ca href=\"https://github.com/zmdominguez/lint-rule-samples/blob/f51654a2e6f4697a58da9b4414d8c0d6eca87274/lint-checks/src/main/java/dev/zarah/lint/checks/TodoDetector.kt\"\u003edetector\u003c/a\u003e \nand the \u003ca href=\"https://github.com/zmdominguez/lint-rule-samples/blob/f51654a2e6f4697a58da9b4414d8c0d6eca87274/lint-checks/src/test/java/dev/zarah/lint/checks/TodoDetectorTest.kt\"\u003etests\u003c/a\u003e\nare in GitHub.\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003eTo read my past posts on this topic, check out the posts \u003ca href=\"https://zarah.dev/tags/\"\u003etagged with Lint\u003c/a\u003e, some\nof which are linked below:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://zarah.dev/2020/11/18/todo-lint.html\"\u003eAnatomy of a Lint issue\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://zarah.dev/2020/11/20/todo-test.html\"\u003eDetectors Unit Testing\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://zarah.dev/2021/10/04/multi-module-lint.html\"\u003eMulti-module rules\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://zarah.dev/2021/10/05/multi-module-lint-test.html\"\u003eMulti-module Testing\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAs always, here are some first-party resources for Lint:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://googlesamples.github.io/android-custom-lint-rules/api-guide.md.html\"\u003eLint API Guide\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"http://googlesamples.github.io/android-custom-lint-rules/user-guide.html\"\u003eLint User Guide\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/googlesamples/android-custom-lint-rules\"\u003eLint sample project\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/\"\u003eFramework rules\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch3 id=\"issue-definitions\"\u003eIssue definitions:\u003c/h3\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eREQUIRED_FORMAT\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;All TODOs must follow the format `TODO-Assignee (DATE_TODAY): Additional comments`\u0026#34;\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eIMPROPER_FORMAT\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eIssue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIssue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecreate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003eid\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;ImproperTodoFormat\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003ebriefDescription\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;TODO has improper format\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eexplanation\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;\n        $REQUIRED_FORMAT\n        \n        The assignee and the date are required information.\n    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003ecategory\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eCategory\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eCORRECTNESS\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003epriority\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eseverity\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eSeverity\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eERROR\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eimplementation\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIMPLEMENTATION\u003c/span\u003e\n\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003esetAndroidSpecific\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eMISSING_ASSIGNEE\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eIssue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIssue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecreate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003eid\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;MissingTodoAssignee\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003ebriefDescription\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;TODO with no assignee\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eexplanation\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;\n        $REQUIRED_FORMAT\n        \n        Please put your name against this TODO. Assignees should be a camel-cased word, for example `ZarahDominguez`.\n    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003ecategory\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eCategory\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eCORRECTNESS\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003epriority\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eseverity\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eSeverity\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eERROR\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eimplementation\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIMPLEMENTATION\u003c/span\u003e\n\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003esetAndroidSpecific\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eMISSING_OR_INVALID_DATE\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eIssue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIssue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecreate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003eid\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;MissingTodoDate\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003ebriefDescription\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;TODO with no date\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eexplanation\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;\n        $REQUIRED_FORMAT\n        \n        Please put today\u0026#39;s date in the yyyy-MM-dd format enclosed in parentheses, for example `(2024-07-20)`.\n    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003ecategory\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eCategory\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eCORRECTNESS\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003epriority\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eseverity\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eSeverity\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eERROR\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eimplementation\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIMPLEMENTATION\u003c/span\u003e\n\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003esetAndroidSpecific\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": null,
  "modifiedTime": null
}
