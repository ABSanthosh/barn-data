{
  "id": "abfaf1aa-b7b3-4928-8f98-3f8eab8f0802",
  "title": "Fan-in to a single required GitHub Action",
  "link": "https://jakewharton.com/fan-in-to-a-single-required-github-action/",
  "description": "",
  "author": "",
  "published": "2025-05-07T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "",
  "length": 2235,
  "excerpt": "07 May 2025",
  "siteName": "Jake Wharton",
  "favicon": "",
  "text": "Fan-in to a single required GitHub Action 07 May 2025 It doesn’t take long for a project to spawn multiple jobs in their GitHub Actions. Parallelization can lead to huge speedups for PRs. Job grouping makes it easier to conditionally enable or disable multiple steps. Each time you add a new job, however, you have to mark it as required in branch protection to prevent failing PRs from accidentally merging. Being a clever person, you might create a final job which lists all the other jobs as required, and then mark that as the single required job. jobs: # … final-status: needs: - build - unit-tests - emulator-tests - screenshot-tests # … Unfortunately, this does not work in practice. GitHub will skip the ‘final-status’ job if any of its ‘needs’ fail, and skipped jobs are treated as passing according to the docs: A job that is skipped will report its status as “Success”. It will not prevent a pull request from merging, even if it is a required check. To work around this undesirable behavior, first, change the job to always run: final-status: + if: always() needs: - build - unit-tests - emulator-tests - screenshot-tests … Next, add a step which ensures the status of each ‘needs’ job was successful: steps: - name: Check run: | results=$(tr -d '\\n' \u003c\u003c\u003c '${{ toJSON(needs.*.result) }}') if ! grep -q -v -E '(failure|cancelled)' \u003c\u003c\u003c \"$results\"; then echo \"One or more required jobs failed\" exit 1 fi Finally, you can mark this job the only required one. It will now successfully reflect the status of all jobs. You can also hang additional steps on it, or even entire subsequent jobs (provided they aren’t needed for PRs). I’m using this setup on a few repos such as Mosaic where you can also see a downstream ‘publish’ job which only runs on the integration branch. An alternative is to have a final job which only runs when one of its ‘needs’ fails and then to fail itself. An example of this strategy was posted on the Actions issue tracker. This approach is simpler, but precludes any additional steps or jobs. — Jake Wharton",
  "image": "https://jakewharton.com/static/default_image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003ch2\u003eFan-in to a single required GitHub Action\u003c/h2\u003e\n      \u003cp\u003e07 May 2025\u003c/p\u003e\n\n      \u003cp\u003eIt doesn’t take long for a project to spawn multiple jobs in their GitHub Actions.\nParallelization can lead to huge speedups for PRs.\nJob grouping makes it easier to conditionally enable or disable multiple steps.\nEach time you add a new job, however, you have to mark it as required in branch protection to prevent failing PRs from accidentally merging.\u003c/p\u003e\n\n\u003cp\u003eBeing a clever person, you might create a final job which lists all the other jobs as required, and then mark that as the single required job.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003ejobs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n  \u003cspan\u003e# …\u003c/span\u003e\n\n  \u003cspan\u003efinal-status\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003eneeds\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n      \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003ebuild\u003c/span\u003e\n      \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003eunit-tests\u003c/span\u003e\n      \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003eemulator-tests\u003c/span\u003e\n      \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003escreenshot-tests\u003c/span\u003e\n    \u003cspan\u003e# …\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eUnfortunately, this does not work in practice.\u003c/p\u003e\n\n\u003cp\u003eGitHub will skip the ‘final-status’ job if any of its ‘needs’ fail, and skipped jobs are treated as passing \u003ca href=\"https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/using-conditions-to-control-job-execution\"\u003eaccording to the docs\u003c/a\u003e:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eA job that is skipped will report its status as “Success”. It will not prevent a pull request from merging, even if it is a required check.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eTo work around this undesirable behavior, first, change the job to always run:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e   final-status:\n\u003cspan\u003e+    if: always()\n\u003c/span\u003e     needs:\n       - build\n       - unit-tests\n       - emulator-tests\n       - screenshot-tests\n     …\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eNext, add a step which ensures the status of each ‘needs’ job was successful:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e    \u003cspan\u003esteps\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n      \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCheck\u003c/span\u003e\n        \u003cspan\u003erun\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e\n          \u003cspan\u003eresults=$(tr -d \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt;\u0026lt; \u0026#39;${{ toJSON(needs.*.result) }}\u0026#39;)\u003c/span\u003e\n          \u003cspan\u003eif ! grep -q -v -E \u0026#39;(failure|cancelled)\u0026#39; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$results\u0026#34;; then\u003c/span\u003e\n            \u003cspan\u003eecho \u0026#34;One or more required jobs failed\u0026#34;\u003c/span\u003e\n            \u003cspan\u003eexit 1\u003c/span\u003e\n          \u003cspan\u003efi\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eFinally, you can mark this job the only required one.\nIt will now successfully reflect the status of all jobs. \nYou can also hang additional steps on it, or even entire subsequent jobs (provided they aren’t needed for PRs).\u003c/p\u003e\n\n\u003cp\u003eI’m using this setup on a few repos \u003ca href=\"https://github.com/JakeWharton/mosaic/blob/54f2183bf8757fe941433c824771272e20d35673/.github/workflows/build.yaml#L299-L321\"\u003esuch as Mosaic\u003c/a\u003e where you can also see a downstream ‘publish’ job which only runs on the integration branch.\u003c/p\u003e\n\n\u003cp\u003eAn alternative is to have a final job which only runs when one of its ‘needs’ fails and then to fail itself.\n\u003ca href=\"https://github.com/actions/runner/issues/2566#issuecomment-1523814835\"\u003eAn example of this strategy\u003c/a\u003e was posted on the Actions issue tracker.\nThis approach is simpler, but precludes any additional steps or jobs.\u003c/p\u003e\n\n\n      \u003cp\u003e— Jake Wharton\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2025-05-07T00:00:00Z",
  "modifiedTime": null
}
