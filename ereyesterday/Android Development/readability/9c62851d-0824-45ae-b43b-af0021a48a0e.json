{
  "id": "9c62851d-0824-45ae-b43b-af0021a48a0e",
  "title": "Kotlin Tips and Tricks You May Not Know: #7 — Goodbye try-catch, Hello runCatching!",
  "link": "https://proandroiddev.com/kotlin-tips-and-tricks-you-may-not-know-7-goodbye-try-catch-hello-trycatching-7135cb382609?source=rss----c72404660798---4",
  "description": "",
  "author": "Elena van Engelen - Maslova",
  "published": "Sun, 02 Mar 2025 19:10:52 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin-beginners",
    "kotlin",
    "error-handling",
    "java",
    "functional-programming"
  ],
  "byline": "Elena van Engelen - Maslova",
  "length": 15644,
  "excerpt": "Learn how runCatching can replace try-catch in Kotlin, making error handling more structured, readable, and maintainable.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Kotlin Tips and Tricks You May Not Know: #7 — Goodbye try-catch, Hello runCatching!IntroductionException handling is a key aspect of building robust applications. However, there is no one-size-fits-all solution when it comes to handling errors. Different paradigms and use cases require different approaches.Roman Elizarov, a key figure in Kotlin’s design, has emphasized that we should not catch exceptions unnecessarily, especially in structured applications, and instead let the framework handle them where possible [1].However, in JVM-based applications that integrate with Java libraries, avoiding exception catching is often impractical. Unlike Kotlin, Java uses checked exceptions, which do not always indicate programming errors but rather recoverable conditions. In Kotlin, it is generally preferred to handle recoverable failures explicitly by returning a value, such as using Result\u003cT\u003e, rather than throwing exceptions. This makes failure handling clearer and avoids unexpected disruptions in execution flow. A popular functional programming library, Arrow [2], provides Either, which similarly encapsulates success and failure. Arrow offers more functional constructs for working with errors in a type-safe way.In addition, even when an exception should be propagated, the platform you are running on may not handle it exactly as you want. For example, some platforms may fail to log the error with the necessary context, such as custom dimensions for monitoring and alerting. In such cases, catching exceptions explicitly and handling them in a structured way can provide better control over logging and monitoring.To simplify exception handling, Kotlin’s standard library offers the runCatching function, which automatically catches exceptions and wraps them in a Result.In this article, we will explore how runCatching integrates with Result by automatically catching exceptions and wrapping them in a Failure state. We will also look at some of the side effects of using runCatching.Note: For clarity, the examples provided in this article are simplified representations of common scenarios.Returning a Result for Safer CodeSince all exceptions in Kotlin are unchecked, when you throw exceptions from a function instead of returning a result, the caller may not know what to expect and is not forced to handle exceptions. This can lead to unpredictable behavior and uncaught failures at runtime. By always returning a Result\u003cT\u003e, you can ensure that error handling is explicit and enforced, leading to safer and more maintainable code.Instead of throwing an exception, we wrap the operation in runCatching:fun parseNumber(input: String): Result\u003cInt\u003e { return runCatching { input.toInt() }}Now, the caller can handle the result explicitly:val result = parseNumber(\"123\")result.onSuccess { println(\"Parsed number: $it\") } .onFailure { println(\"Failed to parse number: ${it.message}\") }This ensures that callers are always aware of possible failures and handle them accordingly.runCatching as a Scope FunctionKotlin provides various scope functions (run, let, apply, etc.) that allow concise and readable operations on objects. runCatching is a specialized version of run that wraps the execution result in a Result object, making error handling more structured.Unlike a standard run block, which returns the result directly, runCatching ensures that if an exception occurs, it is captured inside a Result.Failure instead of propagating as an unhandled exception.Example:data class Order(val id: String, val quantity: Int)val order = Order(id = \"123\", quantity = 0)val result = order.runCatching { 100 / quantity // This will cause a division by zero}.onFailure { e -\u003e println(\"An error occurred: ${e.message}\")}.onSuccess { value -\u003e println(\"Computation successful: $value\")}println(\"Result object: $result\")Using runCatching as a scope function encapsulates both computation and error handling within a single block, reducing boilerplate. Instead of throwing exceptions, failures can be handled safely using onFailure, recover, or getOrElse, making error management more predictable. This approach also improves readability by eliminating explicit try-catch blocks, allowing the focus to remain on the actual logic. Since runCatching integrates seamlessly with other scope functions, it fits well into a functional-style error-handling approach while maintaining idiomatic Kotlin syntax.Replacing Try-Catch with an Empty Catch BlockBeyond just returning results, runCatching can replace try-catch in many cases, even when you want the behaviour to remain unchanged. It allows handling failures cleanly while keeping code more readable and concise.Consider an example where we would like to ignore an exception whereby the try-catch contains an empty catch block, which suppresses exceptions:fun fireAndForget() { try { riskyFunction() } catch (t: Throwable) { // Ignore }}Using runCatching, we can achieve the same result more concisely:fun fireAndForget() { runCatching { riskyFunction() }}Falling Back to a Default ValueA common pattern in traditional try-catch blocks is providing a default value when an exception occurs:fun parseNumberWithDefault(input: String): Int { return try { input.toInt() } catch (t: Throwable) { 0 // Default value for invalid numbers }}With runCatching, this can be simplified using getOrElse, which provides a default value in case of failure:fun parseNumberWithDefault(input: String): Int { return runCatching { input.toInt() }.getOrElse { 0 }}This removes the need for explicit try-catch blocks while ensuring a fallback value is returned in case of failure.Rethrow Original Exceptions with a getOrThrowIn some scenarios, you still may want to throw exceptions. For example, within some libraries, frameworks, or serverless cloud functionality, exceptions result in automated error handling mechanisms, such as retries and dead lettering. Another example is when refactoring an application from try-catch to runCatching, but you want to keep the existing error handling unchanged. In these cases you can use getOrThrow.Before:fun parseNumberWithExceptions(input: String): Int { return try { input.toInt() } catch (e: NumberFormatException) { logger.error(e){\"Failed parsing integer\"} // Log error throw e // Unexpected exceptions are rethrown }}After:fun parseNumberWithExceptions(input: String): Int { return runCatching { input.toInt() } .onFailure { e -\u003e logger.error(e){\"Failed parsing integer\"}} // Log error .getOrThrow()}Handling Nested Exceptions with runCatchingIn many applications, multiple dependent operations can fail in different ways. Reading a file may fail if the file is missing, parsing its content may fail if the format is invalid, and processing the parsed data may fail if required values are missing. Handling these errors with nested try-catch blocks often leads to unreadable and hard-to-maintain code.Before: Nested try-catchfun processFile(path: String): ProcessedData { return try { val content = File(path).readText() try { val json = parseJson(content) try { processData(json) } catch (e: Exception) { logger.error(e) { \"Failed to process data\" } throw e } } catch (e: Exception) { logger.error(e) { \"Failed to parse JSON\" } throw e } } catch (e: Exception) { logger.error(e) { \"Failed to read file: $path\" } throw e }}Before: Refactored nested to verbose try-catchfun processFile(path: String): ProcessedData { val content = try { File(path).readText() } catch (e: Exception) { logger.error(e) { \"Failed to read file: $path\" } throw e } val json = try { parseJson(content) } catch (e: Exception) { logger.error(e) { \"Failed to parse JSON\" } throw e } return try { processData(json) } catch (e: Exception) { logger.error(e) { \"Failed to process data\" } throw e }}After: Concise with runCatchingfun processFile(path: String): ProcessedData { return runCatching { File(path).readText() } .onFailure { e -\u003e logger.error(e) { \"Failed to read file: $path\" } } .mapCatching { content -\u003e parseJson(content) } .onFailure { e -\u003e logger.error(e) { \"Failed to parse JSON\" } } .mapCatching { json -\u003e processData(json) } .onFailure { e -\u003e logger.error(e) { \"Failed to process data\" } } .getOrThrow()}With runCatchingin combination with mapCatching error handling is more structured and concise.Handling Multiple Exception TypesIn some cases, different exceptions require different handling, which is typically done using multiple catch blocks in a try-catch structure. runCatching does not provide built-in syntax for multiple exceptions, but you can achieve the same logic combining runCatching with when .Before:fun readFile(path: String): String { return try { File(path).readText() } catch (e: FileNotFoundException) { logger.error(e) { \"File not found: $path\" } throw e } catch (e: IOException) { logger.error(e) { \"Failed to read file: $path\" } throw e }}After:fun readFile(path: String): String { return runCatching { File(path).readText() } .onFailure { e -\u003e when (e) { is FileNotFoundException -\u003e logger.error(e) { \"File not found: $path\" } is IOException -\u003e logger.error(e) { \"Failed to read file: $path\" } } }.getOrThrow()}Replacing Try-Catch-Finally BlocksIf we need to execute cleanup code regardless of success or failure, a traditional try-catch-finally block will execute code in finally block. Just like handling multiple exceptions, runCatching does not provide built-in support for this. However, we can use Kotlin’s built-in use function for cleaning up closable resources.For resources like files, streams, or database connections, use is preferred as it automatically closes the resource. Traditional try-catch-finally looks like this:fun readFileWithTryCatch(path: String): String { val reader = File(path).bufferedReader() return try { reader.readText() } catch (e: Exception) { logger.error(e){\"Failed to read file: ${e.message}\"} throw e } finally { reader.close() // Must be manually closed }}Utilize runCatching with use instead to eliminate manual resource management:fun readFileWithUse(path: String): String { return runCatching { File(path).bufferedReader().use { it.readText() } // Auto-closes reader }.onFailure { logger.error(it){\"Failed to read file: ${it.message}\" }} .getOrThrow()}Handling Coroutines and Errors with runCatchingWhile runCatching simplifies error handling, it is important to be aware that it catches all Throwable, including both exceptions (Exception) and errors (Error). This includes CancellationException, which is used by coroutines to signal cancellations. Catching it unintentionally can prevent proper coroutine cancellation, leading to side effects such as unresponsive UI, or resource leaks.Avoiding Cancellation Issues in CoroutinesValerii Popov [3] has pointed out that runCatching catches CancellationException, which may unintentionally suppress coroutine cancellations. Since CancellationException is not a typical failure but a control mechanism, it should be rethrown to allow proper coroutine behavior.To ensure CancellationException is correctly propagated while still handling other exceptions, you can use a custom extension function:inline fun \u003creified E : Throwable, T\u003e Result\u003cT\u003e.onFailureOrRethrow(action: (Throwable) -\u003e Unit): Result\u003cT\u003e { return onFailure { if (it is E) throw it else action(it) }}inline fun \u003cT\u003e Result\u003cT\u003e.onFailureIgnoreCancellation(action: (Throwable) -\u003e Unit): Result\u003cT\u003e { return onFailureOrRethrow\u003cCancellationException, T\u003e(action)}You can then apply it to runCatching as follows:val result = runCatching { apiService.fetchDataFromServer()}.onFailureIgnoreCancellation { println(\"Handled non-cancellation error: ${it.message}\")}This ensures that CancellationException is properly propagated, allowing coroutines to cancel as expected while still handling other failures. For more details on handling coroutines correctly with runCatching, see [3].Avoiding System-Level ErrorsIn most applications, you only need to catch recoverable exceptions (Exception) rather than system-level errors (Error). If you are catching and not propogating, then you want to ensure that runCatching does not suppress critical failures, you can filter them out in the same way as CancellationException, for example:inline fun \u003cT\u003e Result\u003cT\u003e.onFailureIgnoreErrors(action: (Throwable) -\u003e Unit): Result\u003cT\u003e { return onFailureOrRethrow\u003cError, T\u003e(action)}Usage:val result = runCatching { riskyOperation()}.onFailureIgnoreErrors { println(\"Handled exception: ${it.message}\")}Static Analysis for Better Exception HandlingTo ensure best practices in exception handling, static analysis tools like Detekt [4] can help catch problematic patterns. The coroutines ruleset can flag incorrect handling of CancellationException, and the exceptions ruleset can warn against swallowing exceptions. Configuring Detekt to suit your project needs helps you avoid common pitfalls.By keeping these considerations in mind, you can use runCatching effectively while maintaining proper coroutine behavior and avoiding unintended suppression of system-level errors.ConclusionrunCatching is a powerful tool when you want to always return a result—whether success or failure—without unexpected exceptions disrupting execution. However, its benefits go beyond just returning results. In many cases, it can also replace traditional try-catch and try-catch-finally blocks, making error handling more structured, concise, and easier to follow.By using runCatching, we maintain a consistent error-handling pattern across our codebase, whether we need to always return a result, handle multiple exceptions, or still propagate exceptions when necessary. This approach leads to cleaner, more readable, and maintainable code.⚠️ Caution: When using runCatching, be aware that it catches Throwable, including Error and CancellationException. Consider using techniques such as rethrowing exceptions where relevant, as suggested by Valerii Popov [3].Tip Recap:By replacing traditional try-catch-finally blocks with runCatching, you can make your code more structured and predictable:Use runCatching when you want your functions to always return a meaningful result instead of throwing exceptions.Replace empty catch blocks with a more concise runCatching.Use getOrElse to provide default values in case of failure.Use getOrThrow when you need to rethrow exceptions while still keeping structured error handling.Handle multiple exception types using when inside recover, recoverCatching or onFailure.Utilize use to properly handle resource cleanup, replacing finally blocks effectively.If used within coroutines, ensure proper handling to avoid unintended suppression of cancellations.For more Kotlin tips and tricks, visit my Medium blog homepage.References[1] Kotlin and Exceptions, Roman Elizarov https://elizarov.medium.com/kotlin-and-exceptions-8062f589d07[2] Arrow, https://arrow-kt.io/[3] Mastering runCatching in Kotlin: How to Avoid Coroutine Cancellation Issues, Valerii Popov, https://dev.to/1noshishi/mastering-runcatching-in-kotlin-how-to-avoid-coroutine-cancellation-issues-5go2[4] Detekt, https://detekt.dev/docs/intro",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*DloPba5iqFbVqE2ZLaqaVg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"5a88\" data-testid=\"storyTitle\"\u003eKotlin Tips and Tricks You May Not Know: #7 — Goodbye try-catch, Hello runCatching!\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@elenavanengelen?source=post_page---byline--7135cb382609---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Elena van Engelen - Maslova\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*N-t_FroIxVl5WDVcCO45jw@2x.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--7135cb382609---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"b33e\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"3a54\"\u003eException handling is a key aspect of building robust applications. However, there is no one-size-fits-all solution when it comes to handling errors. Different paradigms and use cases require different approaches.\u003c/p\u003e\u003cp id=\"5267\"\u003eRoman Elizarov, a key figure in Kotlin’s design, has emphasized that we should not catch exceptions unnecessarily, especially in structured applications, and instead let the framework handle them where possible [1].\u003c/p\u003e\u003cp id=\"0931\"\u003eHowever, in JVM-based applications that integrate with Java libraries, avoiding exception catching is often impractical. Unlike Kotlin, Java uses checked exceptions, which do not always indicate programming errors but rather \u003cstrong\u003erecoverable conditions\u003c/strong\u003e. In Kotlin, it is generally preferred to handle recoverable failures explicitly by returning a value, such as using \u003ccode\u003eResult\u0026lt;T\u0026gt;\u003c/code\u003e, rather than throwing exceptions. This makes failure handling clearer and avoids unexpected disruptions in execution flow. A popular functional programming library, \u003cstrong\u003eArrow\u003c/strong\u003e [2], provides \u003ccode\u003eEither\u003c/code\u003e, which similarly encapsulates success and failure. Arrow offers more functional constructs for working with errors in a type-safe way.\u003c/p\u003e\u003cp id=\"a654\"\u003eIn addition, even when an exception \u003cstrong\u003eshould\u003c/strong\u003e be propagated, the platform you are running on may not handle it exactly as you want. For example, some platforms may fail to log the error with the necessary context, such as \u003cstrong\u003ecustom dimensions for monitoring and alerting\u003c/strong\u003e. In such cases, catching exceptions explicitly and handling them in a structured way can provide better control over logging and monitoring.\u003c/p\u003e\u003cp id=\"5f7c\"\u003eTo simplify exception handling, Kotlin’s standard library offers the \u003ccode\u003erunCatching\u003c/code\u003e function, which automatically catches exceptions and wraps them in a \u003ccode\u003eResult\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"3102\"\u003eIn this article, we will explore how \u003ccode\u003erunCatching\u003c/code\u003e integrates with \u003ccode\u003eResult\u003c/code\u003e by automatically catching exceptions and wrapping them in a \u003ccode\u003eFailure\u003c/code\u003e state. We will also look at some of the side effects of using \u003ccode\u003erunCatching\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"a189\"\u003e\u003cstrong\u003e\u003cem\u003eNote:\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e For clarity, the examples provided in this article are simplified representations of common scenarios.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"b744\"\u003eReturning a Result for Safer Code\u003c/h2\u003e\u003cp id=\"e972\"\u003eSince \u003cstrong\u003eall exceptions in Kotlin are unchecked\u003c/strong\u003e, when you throw exceptions from a function instead of returning a result, the caller \u003cstrong\u003emay not know what to expect\u003c/strong\u003e and is \u003cstrong\u003enot forced to handle exceptions\u003c/strong\u003e. This can lead to unpredictable behavior and uncaught failures at runtime. By always returning a \u003ccode\u003eResult\u0026lt;T\u0026gt;\u003c/code\u003e, you can ensure that error handling is \u003cstrong\u003eexplicit and enforced\u003c/strong\u003e, leading to safer and more maintainable code.\u003c/p\u003e\u003cp id=\"2a0a\"\u003eInstead of throwing an exception, we wrap the operation in \u003ccode\u003erunCatching\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"98e1\"\u003efun parseNumber(input: String): Result\u0026lt;Int\u0026gt; {\u003cbr/\u003e    return runCatching { input.toInt() }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d149\"\u003eNow, the caller can handle the result explicitly:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"55f1\"\u003eval result = parseNumber(\u0026#34;123\u0026#34;)\u003cbr/\u003eresult.onSuccess { println(\u0026#34;Parsed number: $it\u0026#34;) }\u003cbr/\u003e      .onFailure { println(\u0026#34;Failed to parse number: ${it.message}\u0026#34;) }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5494\"\u003eThis ensures that \u003cstrong\u003ecallers are always aware of possible failures\u003c/strong\u003e and handle them accordingly.\u003c/p\u003e\u003ch2 id=\"7fe5\"\u003erunCatching as a Scope Function\u003c/h2\u003e\u003cp id=\"f210\"\u003eKotlin provides various scope functions (\u003ccode\u003erun\u003c/code\u003e, \u003ccode\u003elet\u003c/code\u003e, \u003ccode\u003eapply\u003c/code\u003e, etc.) that allow concise and readable operations on objects. \u003ccode\u003erunCatching\u003c/code\u003e is a specialized version of \u003ccode\u003erun\u003c/code\u003e that wraps the execution result in a \u003ccode\u003eResult\u003c/code\u003e object, making error handling more structured.\u003c/p\u003e\u003cp id=\"920c\"\u003eUnlike a standard \u003ccode\u003erun\u003c/code\u003e block, which returns the result directly, \u003ccode\u003erunCatching\u003c/code\u003e ensures that if an exception occurs, it is captured inside a \u003ccode\u003eResult.Failure\u003c/code\u003e instead of propagating as an unhandled exception.\u003c/p\u003e\u003cp id=\"ccb9\"\u003eExample:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9f12\"\u003edata class Order(val id: String, val quantity: Int)\u003cbr/\u003eval order = Order(id = \u0026#34;123\u0026#34;, quantity = 0)\u003cp\u003eval result = order.runCatching {\u003cbr/\u003e    100 / quantity // This will cause a division by zero\u003cbr/\u003e}.onFailure { e -\u0026gt;\u003cbr/\u003e    println(\u0026#34;An error occurred: ${e.message}\u0026#34;)\u003cbr/\u003e}.onSuccess { value -\u0026gt;\u003cbr/\u003e    println(\u0026#34;Computation successful: $value\u0026#34;)\u003cbr/\u003e}\u003cbr/\u003eprintln(\u0026#34;Result object: $result\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a744\"\u003eUsing \u003ccode\u003erunCatching\u003c/code\u003e as a scope function encapsulates both computation and error handling within a single block, reducing boilerplate. Instead of throwing exceptions, failures can be handled safely using \u003ccode\u003eonFailure\u003c/code\u003e, \u003ccode\u003erecover\u003c/code\u003e, or \u003ccode\u003egetOrElse\u003c/code\u003e, making error management more predictable. This approach also improves readability by eliminating explicit \u003ccode\u003etry-catch\u003c/code\u003e blocks, allowing the focus to remain on the actual logic. Since \u003ccode\u003erunCatching\u003c/code\u003e integrates seamlessly with other scope functions, it fits well into a functional-style error-handling approach while maintaining idiomatic Kotlin syntax.\u003c/p\u003e\u003ch2 id=\"ee97\"\u003eReplacing Try-Catch with an Empty Catch Block\u003c/h2\u003e\u003cp id=\"dad4\"\u003eBeyond just returning results, \u003ccode\u003erunCatching\u003c/code\u003e can replace \u003ccode\u003etry-catch\u003c/code\u003e in many cases, even when you want the behaviour to remain unchanged. It allows handling failures cleanly while keeping code more readable and concise.\u003c/p\u003e\u003cp id=\"9c2e\"\u003eConsider an example where we would like to ignore an exception whereby the \u003ccode\u003etry-catch\u003c/code\u003e contains an empty \u003ccode\u003ecatch\u003c/code\u003e block, which suppresses exceptions:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2b49\"\u003efun fireAndForget() {\u003cbr/\u003e    try {\u003cbr/\u003e        riskyFunction()\u003cbr/\u003e    } catch (t: Throwable) {\u003cbr/\u003e        // Ignore\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5ac2\"\u003eUsing \u003ccode\u003erunCatching\u003c/code\u003e, we can achieve the same result more concisely:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3f89\"\u003efun fireAndForget() {\u003cbr/\u003e    runCatching { riskyFunction() }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"6c61\"\u003eFalling Back to a Default Value\u003c/h2\u003e\u003cp id=\"3ef3\"\u003eA common pattern in traditional \u003ccode\u003etry-catch\u003c/code\u003e blocks is providing a default value when an exception occurs:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f1b4\"\u003efun parseNumberWithDefault(input: String): Int {\u003cbr/\u003e    return try {\u003cbr/\u003e        input.toInt()\u003cbr/\u003e    } catch (t: Throwable) {\u003cbr/\u003e        0 // Default value for invalid numbers\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e9e0\"\u003eWith \u003ccode\u003erunCatching\u003c/code\u003e, this can be simplified using \u003ccode\u003egetOrElse\u003c/code\u003e, which provides a default value in case of failure:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"eaca\"\u003efun parseNumberWithDefault(input: String): Int {\u003cbr/\u003e    return runCatching { input.toInt() }.getOrElse { 0 }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"71d6\"\u003eThis removes the need for explicit \u003ccode\u003etry-catch\u003c/code\u003e blocks while ensuring a fallback value is returned in case of failure.\u003c/p\u003e\u003ch2 id=\"7a2a\"\u003eRethrow Original Exceptions with a getOrThrow\u003c/h2\u003e\u003cp id=\"183e\"\u003eIn some scenarios, you still may want to throw exceptions. For example, within some libraries, frameworks, or serverless cloud functionality, exceptions result in automated error handling mechanisms, such as retries and dead lettering. Another example is when refactoring an application from \u003ccode\u003etry-catch\u003c/code\u003e to \u003ccode\u003erunCatching\u003c/code\u003e, but you want to keep the existing error handling unchanged. In these cases you can use \u003ccode\u003egetOrThrow\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"dcef\"\u003eBefore:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b58e\"\u003efun parseNumberWithExceptions(input: String): Int {\u003cbr/\u003e    return try {\u003cbr/\u003e        input.toInt()\u003cbr/\u003e    } catch (e: NumberFormatException) {\u003cbr/\u003e        logger.error(e){\u0026#34;Failed parsing integer\u0026#34;} // Log error\u003cbr/\u003e        throw e // Unexpected exceptions are rethrown\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"88e8\"\u003eAfter:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"08c0\"\u003efun parseNumberWithExceptions(input: String): Int {\u003cbr/\u003e    return runCatching { input.toInt() }\u003cbr/\u003e        .onFailure { e -\u0026gt; logger.error(e){\u0026#34;Failed parsing integer\u0026#34;}} // Log error\u003cbr/\u003e        .getOrThrow()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"8901\"\u003eHandling Nested Exceptions with \u003ccode\u003erunCatching\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"b81b\"\u003eIn many applications, multiple dependent operations can fail in different ways. Reading a file may fail if the file is missing, parsing its content may fail if the format is invalid, and processing the parsed data may fail if required values are missing. Handling these errors with nested try-catch blocks often leads to unreadable and hard-to-maintain code.\u003c/p\u003e\u003cp id=\"28d9\"\u003eBefore: Nested try-catch\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7b4b\"\u003efun processFile(path: String): ProcessedData {\u003cbr/\u003e    return try {\u003cbr/\u003e        val content = File(path).readText()\u003cbr/\u003e        try {\u003cbr/\u003e            val json = parseJson(content)\u003cbr/\u003e            try {\u003cbr/\u003e                processData(json)\u003cbr/\u003e            } catch (e: Exception) {\u003cbr/\u003e                logger.error(e) { \u0026#34;Failed to process data\u0026#34; }\u003cbr/\u003e                throw e\u003cbr/\u003e            }\u003cbr/\u003e        } catch (e: Exception) {\u003cbr/\u003e            logger.error(e) { \u0026#34;Failed to parse JSON\u0026#34; }\u003cbr/\u003e            throw e\u003cbr/\u003e        }\u003cbr/\u003e    } catch (e: Exception) {\u003cbr/\u003e        logger.error(e) { \u0026#34;Failed to read file: $path\u0026#34; }\u003cbr/\u003e        throw e\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2a16\"\u003eBefore: Refactored nested to verbose try-catch\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0a92\"\u003efun processFile(path: String): ProcessedData {\u003cbr/\u003e    val content = try {\u003cbr/\u003e        File(path).readText()\u003cbr/\u003e    } catch (e: Exception) {\u003cbr/\u003e        logger.error(e) { \u0026#34;Failed to read file: $path\u0026#34; }\u003cbr/\u003e        throw e\u003cbr/\u003e    }\u003cp\u003e    val json = try {\u003cbr/\u003e        parseJson(content)\u003cbr/\u003e    } catch (e: Exception) {\u003cbr/\u003e        logger.error(e) { \u0026#34;Failed to parse JSON\u0026#34; }\u003cbr/\u003e        throw e\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    return try {\u003cbr/\u003e        processData(json)\u003cbr/\u003e    } catch (e: Exception) {\u003cbr/\u003e        logger.error(e) { \u0026#34;Failed to process data\u0026#34; }\u003cbr/\u003e        throw e\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8fad\"\u003eAfter: Concise with \u003ccode\u003erunCatching\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"20ac\"\u003efun processFile(path: String): ProcessedData {\u003cbr/\u003e    return runCatching { File(path).readText() }\u003cbr/\u003e        .onFailure { e -\u0026gt; logger.error(e) { \u0026#34;Failed to read file: $path\u0026#34; } }\u003cbr/\u003e        .mapCatching { content -\u0026gt; parseJson(content) }\u003cbr/\u003e        .onFailure { e -\u0026gt; logger.error(e) { \u0026#34;Failed to parse JSON\u0026#34; } }\u003cbr/\u003e        .mapCatching { json -\u0026gt; processData(json) }\u003cbr/\u003e        .onFailure { e -\u0026gt; logger.error(e) { \u0026#34;Failed to process data\u0026#34; } }\u003cbr/\u003e        .getOrThrow()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c484\"\u003eWith \u003ccode\u003erunCatching\u003c/code\u003ein combination with \u003ccode\u003emapCatching\u003c/code\u003e error handling is more structured and concise.\u003c/p\u003e\u003ch2 id=\"d433\"\u003eHandling Multiple Exception Types\u003c/h2\u003e\u003cp id=\"0ef8\"\u003eIn some cases, different exceptions require different handling, which is typically done using multiple \u003ccode\u003ecatch\u003c/code\u003e blocks in a \u003ccode\u003etry-catch\u003c/code\u003e structure. \u003ccode\u003e\u003cstrong\u003erunCatching\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e does not provide built-in syntax for multiple exceptions\u003c/strong\u003e, but you can achieve the same logic combining \u003ccode\u003erunCatching\u003c/code\u003e with \u003ccode\u003ewhen\u003c/code\u003e .\u003c/p\u003e\u003cp id=\"f79c\"\u003eBefore:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f0c4\"\u003efun readFile(path: String): String {\u003cbr/\u003e    return try {\u003cbr/\u003e        File(path).readText()\u003cbr/\u003e    } catch (e: FileNotFoundException) {\u003cbr/\u003e        logger.error(e) { \u0026#34;File not found: $path\u0026#34; }\u003cbr/\u003e        throw e\u003cbr/\u003e    } catch (e: IOException) {\u003cbr/\u003e        logger.error(e) { \u0026#34;Failed to read file: $path\u0026#34; }\u003cbr/\u003e        throw e\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7ed7\"\u003eAfter:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9b8b\"\u003e\u003cbr/\u003efun readFile(path: String): String {\u003cbr/\u003e    return runCatching { File(path).readText() }\u003cbr/\u003e        .onFailure { e -\u0026gt;\u003cbr/\u003e            when (e) {\u003cbr/\u003e                is FileNotFoundException -\u0026gt; logger.error(e) { \u0026#34;File not found: $path\u0026#34; }\u003cbr/\u003e                is IOException -\u0026gt; logger.error(e) { \u0026#34;Failed to read file: $path\u0026#34; }\u003cbr/\u003e            }\u003cbr/\u003e        }.getOrThrow()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"67bd\"\u003eReplacing Try-Catch-Finally Blocks\u003c/h2\u003e\u003cp id=\"a6ef\"\u003eIf we need to execute cleanup code regardless of success or failure, a traditional \u003ccode\u003etry-catch-finally\u003c/code\u003e block will execute code in \u003ccode\u003efinally\u003c/code\u003e block. Just like handling multiple exceptions, \u003ccode\u003erunCatching\u003c/code\u003e does not provide built-in support for this. However, we can use Kotlin’s built-in \u003ccode\u003euse\u003c/code\u003e function for cleaning up closable resources.\u003c/p\u003e\u003cp id=\"23be\"\u003eFor resources like files, streams, or database connections, \u003ccode\u003euse\u003c/code\u003e is preferred as it \u003cstrong\u003eautomatically closes the resource\u003c/strong\u003e. Traditional \u003ccode\u003etry-catch-finally\u003c/code\u003e looks like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aa8e\"\u003efun readFileWithTryCatch(path: String): String {\u003cbr/\u003e    val reader = File(path).bufferedReader()\u003cbr/\u003e    return try {\u003cbr/\u003e        reader.readText()\u003cbr/\u003e    } catch (e: Exception) {\u003cbr/\u003e        logger.error(e){\u0026#34;Failed to read file: ${e.message}\u0026#34;}\u003cbr/\u003e        throw e\u003cbr/\u003e    } finally {\u003cbr/\u003e        reader.close() // Must be manually closed\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e552\"\u003eUtilize \u003ccode\u003erunCatching\u003c/code\u003e with \u003ccode\u003euse\u003c/code\u003e instead to eliminate manual resource management:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"378b\"\u003efun readFileWithUse(path: String): String {\u003cbr/\u003e    return runCatching {\u003cbr/\u003e        File(path).bufferedReader().use { it.readText() } // Auto-closes reader\u003cbr/\u003e    }.onFailure { logger.error(it){\u0026#34;Failed to read file: ${it.message}\u0026#34; }}\u003cbr/\u003e    .getOrThrow()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"eeb6\"\u003eHandling Coroutines and Errors with \u003ccode\u003erunCatching\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"9cbb\"\u003eWhile \u003ccode\u003erunCatching\u003c/code\u003e simplifies error handling, it is important to be aware that it catches all \u003ccode\u003eThrowable\u003c/code\u003e, including both exceptions (\u003ccode\u003eException\u003c/code\u003e) and errors (\u003ccode\u003eError\u003c/code\u003e). This includes \u003ccode\u003eCancellationException\u003c/code\u003e, which is used by coroutines to signal cancellations. Catching it unintentionally can prevent proper coroutine cancellation, leading to side effects such as unresponsive UI, or resource leaks.\u003c/p\u003e\u003ch2 id=\"98cf\"\u003eAvoiding Cancellation Issues in Coroutines\u003c/h2\u003e\u003cp id=\"38dc\"\u003eValerii Popov [3] has pointed out that \u003ccode\u003erunCatching\u003c/code\u003e catches \u003ccode\u003eCancellationException\u003c/code\u003e, which may unintentionally suppress coroutine cancellations. Since \u003ccode\u003eCancellationException\u003c/code\u003e is not a typical failure but a control mechanism, it should be rethrown to allow proper coroutine behavior.\u003c/p\u003e\u003cp id=\"2797\"\u003eTo ensure \u003ccode\u003eCancellationException\u003c/code\u003e is correctly propagated while still handling other exceptions, you can use a custom extension function:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4a18\"\u003einline fun \u0026lt;reified E : Throwable, T\u0026gt; Result\u0026lt;T\u0026gt;.onFailureOrRethrow(action: (Throwable) -\u0026gt; Unit): Result\u0026lt;T\u0026gt; {\u003cbr/\u003e    return onFailure { if (it is E) throw it else action(it) }\u003cbr/\u003e}\u003cp\u003einline fun \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt;.onFailureIgnoreCancellation(action: (Throwable) -\u0026gt; Unit): Result\u0026lt;T\u0026gt; {\u003cbr/\u003e    return onFailureOrRethrow\u0026lt;CancellationException, T\u0026gt;(action)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6acc\"\u003eYou can then apply it to \u003ccode\u003erunCatching\u003c/code\u003e as follows:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"eb1a\"\u003eval result = runCatching {\u003cbr/\u003e    apiService.fetchDataFromServer()\u003cbr/\u003e}.onFailureIgnoreCancellation {\u003cbr/\u003e    println(\u0026#34;Handled non-cancellation error: ${it.message}\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a2c6\"\u003eThis ensures that \u003ccode\u003eCancellationException\u003c/code\u003e is properly propagated, allowing coroutines to cancel as expected while still handling other failures. For more details on handling coroutines correctly with \u003ccode\u003erunCatching\u003c/code\u003e, see [3].\u003c/p\u003e\u003ch2 id=\"09e6\"\u003eAvoiding System-Level Errors\u003c/h2\u003e\u003cp id=\"a25f\"\u003eIn most applications, you only need to catch recoverable exceptions (\u003ccode\u003eException\u003c/code\u003e) rather than system-level errors (\u003ccode\u003eError\u003c/code\u003e). If you are catching and not propogating, then you want to ensure that \u003ccode\u003erunCatching\u003c/code\u003e does not suppress critical failures, you can filter them out in the same way as \u003ccode\u003eCancellationException\u003c/code\u003e, for example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b78c\"\u003einline fun \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt;.onFailureIgnoreErrors(action: (Throwable) -\u0026gt; Unit): Result\u0026lt;T\u0026gt; {\u003cbr/\u003e    return onFailureOrRethrow\u0026lt;Error, T\u0026gt;(action)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"80d0\"\u003eUsage:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0fc4\"\u003eval result = runCatching {\u003cbr/\u003e    riskyOperation()\u003cbr/\u003e}.onFailureIgnoreErrors {\u003cbr/\u003e    println(\u0026#34;Handled exception: ${it.message}\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e91c\"\u003e\u003cstrong\u003eStatic Analysis for Better Exception Handling\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"052d\"\u003eTo ensure best practices in exception handling, static analysis tools like \u003cstrong\u003eDetekt\u003c/strong\u003e [4] can help catch problematic patterns. The \u003cstrong\u003ecoroutines ruleset\u003c/strong\u003e can flag incorrect handling of \u003ccode\u003eCancellationException\u003c/code\u003e, and the \u003cstrong\u003eexceptions ruleset\u003c/strong\u003e can warn against swallowing exceptions. Configuring Detekt to suit your project needs helps you avoid common pitfalls.\u003c/p\u003e\u003cp id=\"42dc\"\u003eBy keeping these considerations in mind, you can use \u003ccode\u003erunCatching\u003c/code\u003e effectively while maintaining proper coroutine behavior and avoiding unintended suppression of system-level errors.\u003c/p\u003e\u003ch2 id=\"9eee\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"d9fd\"\u003e\u003ccode\u003erunCatching\u003c/code\u003e is a powerful tool when you want to \u003cstrong\u003ealways return a result\u003c/strong\u003e—whether success or failure—without unexpected exceptions disrupting execution. However, its benefits go beyond just returning results. In many cases, it can also \u003cstrong\u003ereplace traditional \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003etry-catch\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e and \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003etry-catch-finally\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e blocks\u003c/strong\u003e, making error handling more structured, concise, and easier to follow.\u003c/p\u003e\u003cp id=\"8159\"\u003eBy using \u003ccode\u003erunCatching\u003c/code\u003e, we maintain a \u003cstrong\u003econsistent error-handling pattern\u003c/strong\u003e across our codebase, whether we need to always return a result, handle multiple exceptions, or still propagate exceptions when necessary. This approach leads to \u003cstrong\u003ecleaner, more readable, and maintainable code\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"343a\"\u003e\u003cstrong\u003e⚠️ Caution:\u003c/strong\u003e When using \u003ccode\u003erunCatching\u003c/code\u003e, be aware that it catches \u003ccode\u003eThrowable\u003c/code\u003e, including \u003ccode\u003eError\u003c/code\u003e and \u003ccode\u003eCancellationException\u003c/code\u003e. Consider using techniques such as rethrowing exceptions where relevant, as suggested by Valerii Popov [3].\u003c/p\u003e\u003ch2 id=\"9859\"\u003eTip Recap:\u003c/h2\u003e\u003cp id=\"f2d0\"\u003eBy replacing traditional \u003ccode\u003etry-catch-finally\u003c/code\u003e blocks with \u003ccode\u003erunCatching\u003c/code\u003e, you can make your code \u003cstrong\u003emore structured and predictable\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1707\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003erunCatching\u003c/strong\u003e\u003c/code\u003e when you want your functions to always return a meaningful result instead of throwing exceptions.\u003c/li\u003e\u003cli id=\"1e86\"\u003e\u003cstrong\u003eReplace empty \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecatch\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e blocks\u003c/strong\u003e with a more concise \u003ccode\u003erunCatching\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"72bb\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003egetOrElse\u003c/strong\u003e\u003c/code\u003e to provide default values in case of failure.\u003c/li\u003e\u003cli id=\"e2d1\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003egetOrThrow\u003c/strong\u003e\u003c/code\u003e when you need to rethrow exceptions while still keeping structured error handling.\u003c/li\u003e\u003cli id=\"19a4\"\u003e\u003cstrong\u003eHandle multiple exception types\u003c/strong\u003e using \u003ccode\u003ewhen\u003c/code\u003e inside \u003ccode\u003erecover\u003c/code\u003e, \u003ccode\u003erecoverCatching\u003c/code\u003e or \u003ccode\u003eonFailure\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"b4ca\"\u003e\u003cstrong\u003eUtilize \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003euse\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003eto properly handle resource cleanup, replacing \u003ccode\u003efinally\u003c/code\u003e blocks effectively.\u003c/li\u003e\u003cli id=\"a721\"\u003e\u003cstrong\u003eIf used within coroutines\u003c/strong\u003e, ensure proper handling to avoid unintended suppression of cancellations.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5223\"\u003eFor more Kotlin tips and tricks, visit my \u003ca href=\"https://medium.com/@elenavanengelen\" rel=\"noopener\"\u003eMedium blog homepage\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"092b\"\u003eReferences\u003c/h2\u003e\u003cp id=\"852e\"\u003e[1] Kotlin and Exceptions, Roman Elizarov \u003ca href=\"https://elizarov.medium.com/kotlin-and-exceptions-8062f589d07\" rel=\"noopener\"\u003ehttps://elizarov.medium.com/kotlin-and-exceptions-8062f589d07\u003c/a\u003e\u003c/p\u003e\u003cp id=\"2555\"\u003e[2] Arrow, \u003ca href=\"https://arrow-kt.io/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://arrow-kt.io/\u003c/a\u003e\u003c/p\u003e\u003cp id=\"e849\"\u003e[3] Mastering runCatching in Kotlin: How to Avoid Coroutine Cancellation Issues, Valerii Popov, \u003ca href=\"https://dev.to/1noshishi/mastering-runcatching-in-kotlin-how-to-avoid-coroutine-cancellation-issues-5go2\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://dev.to/1noshishi/mastering-runcatching-in-kotlin-how-to-avoid-coroutine-cancellation-issues-5go2\u003c/a\u003e\u003c/p\u003e\u003cp id=\"1f27\"\u003e[4] Detekt, \u003ca href=\"https://detekt.dev/docs/intro\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://detekt.dev/docs/intro\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2025-02-27T20:35:11.307Z",
  "modifiedTime": null
}
