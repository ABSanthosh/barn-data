{
  "id": "40165739-dde3-4713-959b-df88a34ceb29",
  "title": "How I Made a Game Engine Using MVI in Kotlin",
  "link": "https://proandroiddev.com/how-i-made-a-game-engine-using-mvi-in-kotlin-4472d758ad05?source=rss----c72404660798---4",
  "description": "",
  "author": "Nek.12",
  "published": "Sun, 22 Dec 2024 20:32:21 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "kotlin",
    "mvi",
    "software-architecture",
    "mvvm"
  ],
  "byline": "Nek.12",
  "length": 22631,
  "excerpt": "In this article, Nikita will tell you a story about how he created a multiplatform game engine using MVI architecture, fully in Kotlin!",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Generated with deepai.orgIn this article, I’ll tell you a story about how our team has created a multiplatform, full-fledged game engine using MVI architecture, fully in Kotlin! You will also learn a lot about how I implemented some insane requirements from our customer when working on said engine. So let’s jump right in!So, I’m working on an app called Overplay. It is similar to TikTok, but the videos you see are actually games that you can play as you scroll. One day, I was just painting another button when the customer came to me to discuss the app’s performance and the experience of starting and finishing a game. In short, the problem we had for years was the legacy game engine.It was still using XML on Android and contained 7 thousand lines of legacy code, most of which was dead but still executed, tanking the performance. The experience was not fluid, the game loaded slowly (20 seconds to load a game was a regular occurrence for us), and it was laggy. We also had a lot of nasty crashes related to concurrency and state management because dozens of different parts of the engine wanted to send events and update the game state simultaneously… The team had no idea how to solve those issues — our current simple MVVM architecture was not holding up at all. Only the ViewModel contained 2000 lines of code, and any change exploded something else.So the customer said — time to make the game engine great again. But the new requirements he wanted to be implemented were just bonkers:The game engine must be embedded directly into the feed of games to let the user scroll away once they finish the game. It means it has to be inside another page and bring all the logic with it!The game engine must start games in less than 2 seconds flat. This means that everything has to be managed in parallel and in the background as the user scrolls!If the user replays or restarts the game, the loading must be instant. Thus, we have to keep the engine running and manage the resources dynamically.Every single action of the user must be covered by analytics to keep improving it in the future.The game engine must support all sorts of videos, including local ones for when someone wants to make their own game and play it.Since the user scrolls through videos like on TikTok, we need to efficiently free and reuse our media codecs and video players to seamlessly jump back and forth between playing a game video and other items of the feed.All errors must always be handled, reported, and recovered from to ensure we no longer ruin the users’ experience with crashes.I’m gonna be honest, I thought I was gonna get fired.“There’s no way to implement this crazy logic” — I thought. Half of the app must be easily embeddable and the state must always be consistent, with hundreds of state updates going on at the same time: the device sensors, our graphic engine, the video player, and more. Everything has to be reused everywhere and loaded in parallel. To put the last nail in the coffin, the amount of code has to be kept small as well to let the team make future changes to the engine without shooting themselves in the foot.But I had to do it, there was no way to avoid it this time. Of course, I couldn’t have done this alone. Huge props to the team:One member took our graphics engine and made it compatible with Compose since there was no way we were doing that without Compose.Another developer spent time making a module for the Game Loop which sends events and orchestrates the graphics engine.PreparationsSo I was responsible for game loading and overall integration in the end. And I thought — well, these requirements are not about features, they are about architecture. My task was to implement the architecture that supports all of those. Easier said than done though…Here’s a simplified diagram of what my final architecture looked like:An important thing to understand before we begin is that to implement the new architecture, I got inspired by Ktor and their amazing system of “Plug-Ins” that form a chain of responsibility and intercept any incoming and outgoing events. Why not use this for any business logic, I thought? This is a new approach to app architecture because we used to only do this kind of thing with CQRS on the backend or in networking code.Luckily, this was already implemented in the architectural framework we were using — FlowMVI — so I didn’t need to write any new code for this, I just needed to use the plugin system creatively now. But the framework was meant for UI, not game engines! I had to make some changes to it if I didn’t want to get fired.So over the next two weeks, I spent time implementing the supporting infrastructure:I added a bunch of new plug-ins, that will allow me to inject any code into any place in the game engine’s lifecycle. We’ll talk about those in a moment.I ran benchmarks hundreds of times, comparing the performance with the fastest solutions to ensure we get maximum performance. I worked on the code until I optimized the library to the point that it became top-5 in performance among 35+ frameworks benchmarked, and as fast as using a simple Channel (from coroutines).I implemented a new system for watching over the chain of plugin invocations which allowed me to monitor processes in any business logic transparently, which I very creatively named “Decorators.I also set a requirement for myself — ANY piece of logic must be a separate thing in the engine’s code that can be removed and modified on demand. The code must not be placed in the same class. My goal was — I’m gonna keep the engine’s code less than 400 lines long.This felt like arming myself to the teeth as some secret ops dude from a movie. I was ready to crush this.Let’s go.Getting Started — ContractFirst of all, let’s define a simple family of MVI states, intents and side-effects for our engine. I used FlowMVI’s IDE plugin, typed fmvim in a new file, and got this:internal sealed interface GameEngineState : MVIState { data object Stopped : GameEngineState data class Error(val e: Exception?) : GameEngineState data class Loading(val progress: Float = 0f): GameEngineState data class Running( override val game: GameInstance, override val player: MediaPlayer, override val isBuffering: Boolean = false, ) : GameEngineState}internal sealed interface GameEngineIntent : MVIIntent { // later added lots of...}internal sealed interface GameEngineAction : MVIAction { data object GoBack : GameEngineAction}I also added a Stopped state (since our engine can exist even when not playing), and a progress value to the loading state.Configuring our EngineI started by creating a singleton called Container, which will host the dependencies. We have to keep it as a singleton and start/stop all its operations on demand to support instant replay of games and caching. We’re going to try and install a bunch of plugins in it to manage our logic. So, to create it, I typed fmvic in an empty file and then added some configuration:internal class GameEngineContainer( private val appScope: ApplicationScope, userRepo: UserRepository, configuration: StoreConfiguration, pool: PlayerPool, // ...a bunch of other stuff) : Container\u003cGameEngineState, GameEngineIntent, GameEngineAction\u003e, GameLauncher { override val store by lazyStore(GameEngineState.Stopped) { configure(configuration, \"GameEngine\") // (1) configure { stateStrategy = Atomic(reentrant = false) // (2) allowIdleSubscriptions = true parallelIntents = true // (3) } }}This way, we can easily inject the dependencies here. The “Store” is the object that will host our GameState, respond to GameIntents, and send events to the UI (GameActions).Here I am transparently injecting some stuff into the store using DI, more on that in a bit.During my benchmarks, I found out that reentrant state transactions (which I discussed in my previous article) were tanking performance. They are 15x slower than non-reentrant ones! The time is still measured in microseconds so it makes sense to use them for simple UI, but we had to squeeze every last drop of CPU power for the engine. I added support for those in the latest update, which reduced the time to nanoseconds per event!Everything had to be parallel for the game engine to keep it fast, so I enabled parallel processing. But if we don’t synchronize state access, we’ll have the same race conditions we had before! By enabling this flag while keeping atomic state transactions, I achieved the best of both worlds: speed, and safety!We got ourselves so far:SpeedThread-safetyAbility to keep resources loaded on demandAnalytics and Crash reporting.“Wait”, you may ask, “but there isn’t a single line of analytics code in the snippet!”, and I will answer — the magic is in the injected configuration parameter.It installs a bunch of plug-ins transparently. We can add any logic to any container using the concept of plug-ins, so why not use those with DI? That function installs an error handler plugin that catches and sends exceptions to analytics without affecting the rest of the engine’s code, tracks user actions (Intents), and events of visiting and leaving the game engine screen as well. Having the huge game engine polluted by analytics junk is a no-no for us because we had this problem with MVVM — all of the stuff just gets piled on and on and on until it becomes unmaintainable. No more.Starting and Stopping the EngineOkay, so we created our Container lazily. How do we clean up and keep track of resources now?The thing about FlowMVI is that it’s the only framework I know that allows you to stop and restart the business logic component (Store) on demand. Each store has a StoreLifecycle which can let you control and observe the store using a CoroutineScope. If the scope is canceled - the store is, but the store can also be stopped separately, ensuring our parent-child hierarchy is always respected.My colleagues were skeptical about this feature at first, and for a while, I thought it was useless, but this time it literally saved my ass from getting fired: we can just use the global application scope to run our logic, and stop the engine when we don’t need it to keep consuming resources!For the implementation, we’re just going to let the Container implement an interface called GameLauncher that will access the lifecycle for us:override suspend fun awaitShutdown() = store.awaitUntilClosed()override fun shutdown() = store.close()override suspend fun start(params: GameParameters) { val old = this.parameters.getAndUpdate { params } when { !store.isActive -\u003e store.start(appScope).awaitStartup() // start fresh old == params -\u003e store.intent(ReplayedGame) // reuse running engine else -\u003e { // restart if incompatible store.closeAndWait() store.start(appScope).awaitStartup() } }}Then the code from other modules will just use the interface to stop the engine when it doesn’t need the game to keep running (e.g. the user has scrolled away, left the app, etc.), and call start each time the clients want us to play the game. But this feature would only be marginally usable for us if the store didn’t have a way to do something when it is shut down. So let’s talk about resource management next.Managing ResourcesWe have a lot of stuff to initialize upon the game start in parallel:Remote configuration for feature flagsGame assets like textures need to be downloaded and cachedGame Configuration and the game JSON dataMedia codec initializationVideo file buffering and cachingAnd more…And almost everything here cannot be simply garbage collected. We need to close file handles, unload codecs, release resources held by native code, and return the video player to the pool to reuse it, as player creation is a very heavy process.And some stuff actually depends on the other, like the video file depends on the game configuration where it comes from. How do we do that?Well, for starters, I created a plug-in that will use the callback mentioned above to create a value when the engine starts, and clean the value up when the engine stops (simplified code):public fun \u003cT\u003e cached( init: suspend PipelineContext.() -\u003e T,): CachedValue\u003cT\u003e = CachedValue(init)fun \u003cT\u003e cachePlugin( value: CachedValue\u003cT\u003e,) = plugin { onStart { value.init() } onStop { value.clear() }}A CachedValue is just like lazy but with thread-safe control of when to clear and init the value. In our case, it calls init when the store starts, and clears the reference when the store stops. Super simple!But that plugin still has a problem because it pauses the entire store until the initialization is complete, which means our loading would be sequential instead of parallel. To fix that, we can simply use Deferred and run the initialization in a separate coroutine:inline fun \u003cT\u003e asyncCached( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.UNDISPATCHED, crossinline init: suspend PipelineContext.() -\u003e T,): CachedValue\u003cDeferred\u003cT\u003e\u003e = cached { async(context, start) { init() } }Then we just pass our asyncCached instead of the regular one when installing the cache plugin. Sprinkle some DSL on top of that, and we get the following game-loading logic:override val store by lazyStore(GameEngineState.Stopped) { configure { /* ... */ } val gameClock by cache { GameClock(coroutineScope = this) // (1) } val player by cache { playerPool.borrow(requireParameters.playerType) } val remoteConfig by asyncCache { remoteConfigRepo.updateAndGet() } val graphicsEngine by asyncCache { GraphicsEngine(GraphicsRemoteConfig(from = remoteConfig()) // (2) } val gameData by asyncCache { gameRepository.getGameData(requireParameters().gameId) } val game by asyncCache { GameLoop( graphics = graphicsEngine(), remoteConfig = remoteConfig(), clock = gameClock, data = gameData(), params = requireParameters(), ).let { GameInstance(it) } } // ... more ... asyncInit { // (3) updateState { Loading() } player.loadVideo(gameData().videoUrl) updateState { GameEngineState.Running( game = game(), player = player, ) } clock.start() } deinit { // (4) graphicsEngine.release() player.stop() playerPool.return(player) }}Our game clock runs an event loop and synchronizes game time with video time. Unfortunately, it requires a coroutine scope where it runs the loop that should only be active during the game. Luckily, we already have one! PipelineContext, which is the context of the Store‘s execution, is provided with plugins and implements CoroutineScope. We can just use it in our cache plugin and start the game clock, which will automatically stop when we shut down the engine.You can see we used a bunch of asyncCaches to parallelize loading, and with the Graphics Engine, we also were able to depend on remote config inside (as an example, in reality it depends on lots of stuff). This greatly simplifies our logic, because the dependencies between components are implicit now, and the requesting party who wants just the graphics engine doesn’t have to manage the dependencies of it! The operator invoke (parentheses) is a shorthand for Deferred.await() for that extra sweet taste.We have also used an asyncInit which essentially launches a background job in the current game engine’s gameplay scope to load the game. Inside the job, we do final preparations, wait for all of the dependencies, and start the game clock.We have used the built-in deinit plugin to put all of our cleanup logic in the callback that is invoked as soon as the game engine is stopped (and its scope is canceled). It will be run before our cached values are cleaned up (because it was installed later), but after our jobs have been canceled, so that we can do what we want, and the cache plugin will then garbage-collect the rest of the stuff without us worrying about leaks.Overall, these 50 lines of code have replaced 1.5 thousand lines of our old game engine’s implementation! I had to pick up my jaw from the floor when I realized how powerful these patterns are for business logic.But we’re still lacking one thing.Error HandlingA lot of things in the engine can go wrong during gameplay:Some game-author forgot to add a frame to an animation,A person lost their connection during the game,The shaders failed rendering due to a platform bug, and more…Usually, only the main errors for API calls are handled in apps with wrappers like ApiResult or some kind of try/catch. But imagine wrapping every single line of the Game Engine’s code in a try-catch… That would mean hundreds of lines of try-catch-finally garbage!Well, you probably know what will happen. Since we can intercept any event now, let’s make an error-handling plug-in! I named it recover, and now our code looks like this:override val store by lazyStore(GameEngineState.Stopped) { configure { /* ... */ } val player by cache { /* ... */ } // ... recover { e -\u003e if (config.debuggable) updateState { // (1) GameEngineState.Error(e) } else when(e) { // (2) is StoreTimeoutException, is GLException -\u003e Unit // just report to analytics is MediaPlaybackException -\u003e player.retry() is AssetCorruptedException -\u003e assetManager.refreshAssetsSync() is BufferingTimeoutException -\u003e action(ShowSlowInternetMessage) // ... more ... else -\u003e shutdown() // (3) } null // swallow the exception }}If our store is configured to be debuggable (config is available in store plug-ins), we can show a full-screen overlay with the stack trace to let our QA team easily report errors to devs before they get to production. Fail Fast principle in action.In production, however, we will handle some errors by retrying, skipping an animation, or warning the user about their connection without interrupting the gameplay.If we can’t handle an error and cannot recover, then we shut down the engine and let the user try to play the game again, without crashing the app or showing obscure messages (those go to crashlytics).With this, we’ve got ourselves error-handling for any existing and new code a developer may ever add to our game engine, with 0 try-catches.Final touchesWe’re almost done! This article is getting long, so I’ll blitz through some additional plug-ins I had to install to support our use cases:override val store by lazyStore(GameEngineState.Stopped) { configure { /* ... */ } // ... val subs = awaitSubscribers() // (1) val jobs = manageJobs\u003cGameJobs\u003e() // (2) initTimeout(5.seconds) { // (3) subs.await() } whileSubscribed { // (4) assetManager.loadingProgress.collect { progress -\u003e updateState\u003cLoading, _\u003e { copy(progress = progress) } } } install( autoStopPlugin(jobs), // (5) resetStatePlugin(), // (6) )}Since a developer can make the mistake of starting the game, but never displaying the actual gameplay experience (user left, a bug, plans changed, etc…), I am using the pre-made awaitSubscribers plugin in snippet (3) to see if they appear within 5 seconds of starting the game, and if not, close the store and auto-cleanup the held resources to prevent leaks. Boom!I’m using another plug-in — JobManager, to run some long-running operations in the background. Code that uses it didn’t fit, but essentially it’s needed to track whether the user is currently playing.InitTimeout is a custom plugin that verifies whether the game has finished loading within 5 seconds, and if not, we pass an error to our recover plugin to decide what to do and report the issue to analytics.The whileSubscribed plugin launches a job that is only active when subscribers (in our case, UI) are present, where we update the visuals of the loading progress only when the user is actually seeing the loading screen. It allows us to easily avoid resource leaks if the game engine is covered up by something or hidden.The autoStopPlugin uses our job manager to watch for game load progress and gameplay progress. It looks at whether we have subscribers to pause the game when the user leaves, then stop it once the engine is not used for a while, eliminating the risk of leaking memory.The resetStatePlugin is a built-in one I had to install to auto-cleanup state when the game ends. By default, stores will not have their state reset when they stop. This is good for regular UI but not in our case - we want the engine to go back to the Stopped state when the game ends.All of those plugins were already in the library, so using them was a piece of cake.ConclusionIt was a wild ride, but after all this, I not only managed to keep my job, but I think that the overall solution has turned out pretty great. The engine went from 7+k to just 400 lines of readable, linear, structured, performant, extensible code, and the users are already enjoying the results:Loading time went from ~20 seconds to just 1.75 seconds!Crashed games fell from 8% to 0.01%!We improved the throughput of the game event processing by 1700%Video buffering occurrences during games went from ~31% to \u003c10% due to our cachingBattery consumption during gameplay was reduced by orders of magnitudeANRs during gameplay fell to being statistically 0GC pressure decreased by 40% during gameplayHopefully, by this point, I’ve shown why the patterns we used to hate like Decorators, Interceptors, and Chain of Responsibility can be insanely helpful when building not just some backend service, networking code, or a specialized use-case, but also implementing the regular application logic, including UI and state management.With the power that Kotlin gives when building DSLs, we can turn the fundamental patterns (used in software development for decades) from a mess of boilerplate, inheritance, and complicated delegation into a fast, straightforward, compact, linear code that is fun and efficient to work with. I encourage you to build something like this for your own app’s architecture and reap the benefits.And if you don’t want to dive into that and want something already available, or are curious to learn more, then consider checking out the original library where I implemented everything mentioned here on GitHub, or dive right into the quickstart guide to try it in 10 minutes.",
  "image": "https://miro.medium.com/v2/resize:fit:768/1*LvnZiSaT9GOSVhvO2P4Dwg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@Nek.12?source=post_page---byline--4472d758ad05--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Nek.12\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*gePnHp9xU72kzCxZYMRNUw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--4472d758ad05--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eGenerated with deepai.org\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ca0f\"\u003eIn this article, I’ll tell you a story about how our team has created a multiplatform, full-fledged game engine using MVI architecture, fully in Kotlin! You will also learn a lot about how I implemented some \u003cem\u003einsane\u003c/em\u003e requirements from our customer when working on said engine. So let’s jump right in!\u003c/p\u003e\u003cp id=\"2736\"\u003eSo, I’m working on an app called \u003ca href=\"http://overplay.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eOverplay\u003c/a\u003e. It is similar to TikTok, but the videos you see are actually games that you can play as you scroll. One day, I was just painting another button when the customer came to me to discuss the app’s performance and the experience of starting and finishing a game. In short, the problem we had for years was the legacy game engine.\u003c/p\u003e\u003cp id=\"e885\"\u003eIt was still using XML on Android and contained\u003cstrong\u003e 7\u003c/strong\u003e \u003cstrong\u003ethousand\u003c/strong\u003e lines of legacy code, most of which was dead but still executed, tanking the performance. The experience was not fluid, the game loaded slowly (20 seconds to load a game was a regular occurrence for us), and it was laggy. We also had a lot of nasty crashes related to concurrency and \u003cstrong\u003estate management\u003c/strong\u003e because dozens of different parts of the engine wanted to send events and update the game state simultaneously… The team had \u003cstrong\u003eno idea how to solve\u003c/strong\u003e those issues — our current simple \u003cstrong\u003eMVVM architecture was not holding up\u003c/strong\u003e at all. Only the ViewModel contained 2000 lines of code, and any change exploded something else.\u003c/p\u003e\u003cp id=\"ee33\"\u003eSo the customer said — time to make the game engine great again. But the new requirements he wanted to be implemented were just \u003cstrong\u003ebonkers\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e1a3\"\u003eThe game engine must be \u003cstrong\u003eembedded directly\u003c/strong\u003e into the feed of games to let the user scroll away once they finish the game. It means it has to be inside another page and bring all the logic with it!\u003c/li\u003e\u003cli id=\"74e2\"\u003eThe game engine must \u003cstrong\u003estart games\u003c/strong\u003e in less than \u003cstrong\u003e2 seconds flat\u003c/strong\u003e. This means that \u003cstrong\u003eeverything\u003c/strong\u003e has to be managed in parallel and in the background as the user scrolls!\u003c/li\u003e\u003cli id=\"440c\"\u003eIf the user replays or restarts the game, the loading must be \u003cstrong\u003einstant.\u003c/strong\u003e Thus, we have to keep the engine running and manage the resources dynamically.\u003c/li\u003e\u003cli id=\"83ad\"\u003eEvery single action of the user must be \u003cstrong\u003ecovered by analytics\u003c/strong\u003e to keep improving it in the future.\u003c/li\u003e\u003cli id=\"bbda\"\u003eThe game engine must support all sorts of videos, including local ones for when someone wants to make their own game and play it.\u003c/li\u003e\u003cli id=\"510d\"\u003eSince the user scrolls through videos like on TikTok, we need to efficiently free and\u003cstrong\u003e reuse our media codecs\u003c/strong\u003e and video players to seamlessly jump back and forth between playing a game video and other items of the feed.\u003c/li\u003e\u003cli id=\"1f61\"\u003e\u003cstrong\u003eAll\u003c/strong\u003e errors must \u003cstrong\u003ealways\u003c/strong\u003e be handled, reported, and recovered from to ensure we no longer ruin the users’ experience with crashes.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4876\"\u003eI’m gonna be honest, I thought I was gonna get fired.\u003c/p\u003e\u003cp id=\"4082\"\u003e“There’s no way to implement this crazy logic” — I thought. Half of the app must be easily embeddable and the state must always be consistent, with \u003cstrong\u003ehundreds\u003c/strong\u003e of state updates going on at the same time: the device sensors, our graphic engine, the video player, and more. Everything has to be reused everywhere and loaded in parallel. To put the last nail in the coffin, the amount of code has to be kept small as well to let the team make future changes to the engine without shooting themselves in the foot.\u003c/p\u003e\u003cp id=\"cd83\"\u003eBut I had to do it, there was no way to avoid it this time. Of course, I couldn’t have done this alone. Huge props to the team:\u003c/p\u003e\u003cul\u003e\u003cli id=\"19bf\"\u003eOne member took our graphics engine and made it compatible with Compose since there was no way we were doing that without Compose.\u003c/li\u003e\u003cli id=\"b7b7\"\u003eAnother developer spent time making a module for the Game Loop which sends events and orchestrates the graphics engine.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"27f5\"\u003ePreparations\u003c/h2\u003e\u003cp id=\"62f4\"\u003eSo I was responsible for game loading and overall integration in the end. And I thought — well, these requirements are not about features, they are about \u003cstrong\u003earchitecture.\u003c/strong\u003e My task was to implement the \u003cstrong\u003earchitecture\u003c/strong\u003e that supports all of those. Easier said than done though…\u003c/p\u003e\u003cp id=\"84a1\"\u003eHere’s a simplified diagram of what my final architecture looked like:\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"c82e\"\u003eAn important thing to understand before we begin is that to implement the new architecture, I got inspired by Ktor and their amazing system of “Plug-Ins” that form a chain of responsibility and intercept any incoming and outgoing events. Why not use this for \u003cstrong\u003eany business logic,\u003c/strong\u003e I thought? This is a new approach to app architecture because we used to only do this kind of thing with CQRS on the backend or in networking code.\u003c/p\u003e\u003cp id=\"8e83\"\u003eLuckily, this was already implemented in the architectural framework we were using — \u003ca href=\"https://github.com/respawn-app/FlowMVI\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFlowMVI\u003c/a\u003e — so I didn’t need to write any new code for this, I just needed to use the plugin system creatively now. But the framework was meant for UI, not game engines! I had to make some changes to it if I didn’t want to get fired.\u003c/p\u003e\u003cp id=\"803d\"\u003eSo over the next two weeks, I spent time implementing the supporting infrastructure:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b2d2\"\u003eI added a bunch of new plug-ins, that will allow me to inject any code into any place in the game engine’s lifecycle. We’ll talk about those in a moment.\u003c/li\u003e\u003cli id=\"bb61\"\u003eI ran benchmarks hundreds of times, comparing the performance with the fastest solutions to ensure we get maximum performance. I worked on the code until I optimized the library to the point that it became top-5 in performance among 35+ frameworks benchmarked, and as fast as using a simple Channel (from coroutines).\u003c/li\u003e\u003cli id=\"6de1\"\u003eI implemented a new system for watching over the chain of plugin invocations which allowed me to monitor processes in any business logic transparently, which I very creatively named “Decorators.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d1f6\"\u003eI also set a requirement for myself — ANY piece of logic must be a separate thing in the engine’s code that can be removed and modified on demand. The code must not be placed in the same class. My goal was — I’m gonna keep the engine’s code \u003cstrong\u003eless than 400 lines long.\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"a19a\"\u003eThis felt like arming myself to the teeth as some secret ops dude from a movie. I was ready to \u003cstrong\u003ecrush this\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"ba8e\"\u003e\u003cstrong\u003eLet’s go.\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"99e3\"\u003eGetting Started — Contract\u003c/h2\u003e\u003cp id=\"61e8\"\u003eFirst of all, let’s define a simple family of MVI states, intents and side-effects for our engine. I used FlowMVI’s IDE plugin, typed \u003ccode\u003efmvim\u003c/code\u003e in a new file, and got this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"646f\"\u003einternal sealed interface GameEngineState : MVIState {\u003cp\u003e    data object Stopped : GameEngineState\u003cbr/\u003e    data class Error(val e: Exception?) : GameEngineState\u003cbr/\u003e    data class Loading(val progress: Float = 0f): GameEngineState\u003c/p\u003e\u003cp\u003e    data class Running(\u003cbr/\u003e        override val game: GameInstance,\u003cbr/\u003e        override val player: MediaPlayer,\u003cbr/\u003e        override val isBuffering: Boolean = false,\u003cbr/\u003e    ) : GameEngineState\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003einternal sealed interface GameEngineIntent : MVIIntent {\u003cbr/\u003e    // later added lots of...\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003einternal sealed interface GameEngineAction : MVIAction {\u003cbr/\u003e    data object GoBack : GameEngineAction\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a4f5\"\u003eI also added a \u003ccode\u003eStopped\u003c/code\u003e state (since our engine can exist even when not playing), and a progress value to the loading state.\u003c/p\u003e\u003ch2 id=\"7eca\"\u003eConfiguring our Engine\u003c/h2\u003e\u003cp id=\"7d96\"\u003eI started by creating a singleton called Container, which will host the dependencies. We have to keep it as a singleton and start/stop all its operations on demand to support instant replay of games and caching. We’re going to try and install a bunch of plugins in it to manage our logic. So, to create it, I typed \u003ccode\u003efmvic\u003c/code\u003e in an empty file and then added some configuration:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8905\"\u003einternal class GameEngineContainer(\u003cbr/\u003e    private val appScope: ApplicationScope,\u003cbr/\u003e    userRepo: UserRepository,\u003cbr/\u003e    configuration: StoreConfiguration,\u003cbr/\u003e    pool: PlayerPool,\u003cbr/\u003e    // ...a bunch of other stuff\u003cbr/\u003e) : Container\u0026lt;GameEngineState, GameEngineIntent, GameEngineAction\u0026gt;, GameLauncher {\u003cp\u003e    override val store by lazyStore(GameEngineState.Stopped) {\u003cbr/\u003e        configure(configuration, \u0026#34;GameEngine\u0026#34;) // (1)\u003cbr/\u003e        configure {\u003cbr/\u003e            stateStrategy = Atomic(reentrant = false) // (2)\u003cbr/\u003e            allowIdleSubscriptions = true \u003cbr/\u003e            parallelIntents = true // (3)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ec37\"\u003eThis way, we can easily inject the dependencies here. The “Store” is the object that will host our \u003ccode\u003eGameState\u003c/code\u003e, respond to \u003ccode\u003eGameIntents\u003c/code\u003e, and send events to the UI (\u003ccode\u003eGameActions\u003c/code\u003e).\u003c/p\u003e\u003col\u003e\u003cli id=\"2e64\"\u003eHere I am transparently injecting some stuff into the store using DI, more on that in a bit.\u003c/li\u003e\u003cli id=\"d1e6\"\u003eDuring my benchmarks, I found out that \u003cstrong\u003ereentrant\u003c/strong\u003e state transactions (which I discussed in my \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/how-to-safely-update-state-in-your-kotlin-apps-bf51ccebe2ef\"\u003eprevious article\u003c/a\u003e) were tanking performance. They are \u003cstrong\u003e15x slower\u003c/strong\u003e than non-reentrant ones! The time is still measured in microseconds so it makes sense to use them for simple UI, but we had to squeeze every last drop of CPU power for the engine. I added support for those in the latest update, which reduced the time to nanoseconds per event!\u003c/li\u003e\u003cli id=\"c21c\"\u003eEverything had to be parallel for the game engine to keep it fast, so I enabled parallel processing. But if we don’t synchronize state access, we’ll have the same race conditions we had before! By enabling this flag while keeping atomic state transactions, I achieved the best of both worlds: speed\u003cstrong\u003e, and\u003c/strong\u003e safety!\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"0d10\"\u003eWe got ourselves so far:\u003c/p\u003e\u003cul\u003e\u003cli id=\"5fa5\"\u003eSpeed\u003c/li\u003e\u003cli id=\"9eb6\"\u003eThread-safety\u003c/li\u003e\u003cli id=\"636d\"\u003eAbility to keep resources loaded on demand\u003c/li\u003e\u003cli id=\"87ab\"\u003eAnalytics and Crash reporting.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ae05\"\u003e“Wait”, you may ask, “but there isn’t a single line of analytics code in the snippet!”, and I will answer — the magic is in the injected \u003ccode\u003econfiguration\u003c/code\u003e parameter.\u003c/p\u003e\u003cp id=\"6c97\"\u003eIt installs a bunch of plug-ins transparently. We can add any logic to any container using the concept of plug-ins, so why not use those \u003cstrong\u003ewith DI\u003c/strong\u003e? That function installs an error handler plugin that catches and sends exceptions to analytics without affecting the rest of the engine’s code, tracks user actions (Intents), and events of visiting and leaving the game engine screen as well. Having the huge game engine polluted by analytics junk is a no-no for us because we had this problem with MVVM — all of the stuff just gets piled on and on and on until it becomes unmaintainable. \u003cstrong\u003eNo more.\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"a312\"\u003eStarting and Stopping the Engine\u003c/h2\u003e\u003cp id=\"7f7c\"\u003eOkay, so we created our Container lazily. How do we clean up and keep track of resources now?\u003c/p\u003e\u003cp id=\"6169\"\u003eThe thing about FlowMVI is that it’s the only framework I know that allows you to \u003cstrong\u003estop\u003c/strong\u003e and \u003cstrong\u003erestart\u003c/strong\u003e the business logic component (\u003ccode\u003eStore\u003c/code\u003e) on demand. Each store has a \u003ccode\u003eStoreLifecycle\u003c/code\u003e which can let you control and observe the store using a \u003ccode\u003eCoroutineScope\u003c/code\u003e\u003cstrong\u003e.\u003c/strong\u003e If the scope is canceled - the store is, but the store can also be stopped separately, ensuring our parent-child hierarchy is always respected.\u003c/p\u003e\u003cp id=\"6ee2\"\u003eMy colleagues were skeptical about this feature at first, and for a while, I thought it was useless, but this time it literally saved my ass from getting fired: we can just use the global application scope to run our logic, and stop the engine when we don’t need it to keep consuming resources!\u003c/p\u003e\u003cp id=\"fc19\"\u003eFor the implementation, we’re just going to let the Container implement an interface called \u003ccode\u003eGameLauncher\u003c/code\u003e that will access the lifecycle for us:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b67c\"\u003eoverride suspend fun awaitShutdown() = store.awaitUntilClosed()\u003cbr/\u003eoverride fun shutdown() = store.close()\u003cbr/\u003eoverride suspend fun start(params: GameParameters) {\u003cbr/\u003e    val old = this.parameters.getAndUpdate { params }\u003cbr/\u003e    when {\u003cbr/\u003e        !store.isActive -\u0026gt; store.start(appScope).awaitStartup() // start fresh\u003cbr/\u003e        old == params -\u0026gt; store.intent(ReplayedGame) // reuse running engine\u003cbr/\u003e        else -\u0026gt; { // restart if incompatible\u003cbr/\u003e            store.closeAndWait() \u003cbr/\u003e            store.start(appScope).awaitStartup()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6237\"\u003eThen the code from other modules will just use the interface to stop the engine when it doesn’t need the game to keep running (e.g. the user has scrolled away, left the app, etc.), and call \u003ccode\u003estart\u003c/code\u003e each time the clients want us to play the game. But this feature would only be marginally usable for us if the store didn’t have a way to do something when it is shut down. So let’s talk about resource management next.\u003c/p\u003e\u003ch2 id=\"67a0\"\u003eManaging Resources\u003c/h2\u003e\u003cp id=\"59a6\"\u003eWe have \u003cstrong\u003ea lot\u003c/strong\u003e of stuff to initialize upon the game start in parallel:\u003c/p\u003e\u003cul\u003e\u003cli id=\"ea70\"\u003eRemote configuration for feature flags\u003c/li\u003e\u003cli id=\"0887\"\u003eGame assets like textures need to be downloaded and cached\u003c/li\u003e\u003cli id=\"4454\"\u003eGame Configuration and the game JSON data\u003c/li\u003e\u003cli id=\"3d1d\"\u003eMedia codec initialization\u003c/li\u003e\u003cli id=\"1349\"\u003eVideo file buffering and caching\u003c/li\u003e\u003cli id=\"2599\"\u003eAnd more…\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6ba6\"\u003eAnd almost everything here cannot be simply garbage collected. We need to close file handles, unload codecs, release resources held by native code, and return the video player to the pool to reuse it, as player creation is a very heavy process.\u003c/p\u003e\u003cp id=\"91db\"\u003eAnd some stuff actually depends on the other, like the video file depends on the game configuration where it comes from. How do we do that?\u003c/p\u003e\u003cp id=\"198e\"\u003eWell, for starters, I created a plug-in that will use the callback mentioned above to \u003cstrong\u003ecreate a value \u003c/strong\u003ewhen the engine\u003cstrong\u003e starts, and clean the value up\u003c/strong\u003e when the engine \u003cstrong\u003estops\u003c/strong\u003e (simplified code):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"475b\"\u003epublic fun \u0026lt;T\u0026gt; cached(\u003cbr/\u003e    init: suspend PipelineContext.() -\u0026gt; T,\u003cbr/\u003e): CachedValue\u0026lt;T\u0026gt; = CachedValue(init)\u003cp\u003efun \u0026lt;T\u0026gt; cachePlugin(\u003cbr/\u003e    value: CachedValue\u0026lt;T\u0026gt;,\u003cbr/\u003e) = plugin {\u003cbr/\u003e    onStart { value.init() }\u003cbr/\u003e    onStop { value.clear() }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8ff1\"\u003eA \u003ccode\u003eCachedValue\u003c/code\u003e is just like \u003ccode\u003elazy\u003c/code\u003e but with thread-safe control of when to clear and init the value. In our case, it calls \u003ccode\u003einit\u003c/code\u003e when the store starts, and clears the reference when the store stops. Super simple!\u003c/p\u003e\u003cp id=\"0b91\"\u003eBut that plugin still has a problem because it \u003cstrong\u003epauses the entire store\u003c/strong\u003e until the initialization is complete, which means our loading would be sequential instead of parallel. To fix that, we can simply use \u003ccode\u003eDeferred\u003c/code\u003e and run the initialization in a separate coroutine:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c81d\"\u003einline fun \u0026lt;T\u0026gt; asyncCached(\u003cbr/\u003e    context: CoroutineContext = EmptyCoroutineContext,\u003cbr/\u003e    start: CoroutineStart = CoroutineStart.UNDISPATCHED,\u003cbr/\u003e    crossinline init: suspend PipelineContext.() -\u0026gt; T,\u003cbr/\u003e): CachedValue\u0026lt;Deferred\u0026lt;T\u0026gt;\u0026gt; = cached { async(context, start) { init() } }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0a82\"\u003eThen we just pass our \u003ccode\u003easyncCached\u003c/code\u003e instead of the regular one when installing the \u003ccode\u003ecache\u003c/code\u003e plugin. Sprinkle some DSL on top of that, and we get the following game-loading logic:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"375b\"\u003eoverride val store by lazyStore(GameEngineState.Stopped) {\u003cbr/\u003e    configure { /* ... */ }\u003cbr/\u003e    val gameClock by cache {\u003cbr/\u003e        GameClock(coroutineScope = this) // (1)\u003cbr/\u003e    }\u003cbr/\u003e    val player by cache {\u003cbr/\u003e        playerPool.borrow(requireParameters.playerType)\u003cbr/\u003e    }\u003cbr/\u003e    val remoteConfig by asyncCache { \u003cbr/\u003e        remoteConfigRepo.updateAndGet()\u003cbr/\u003e    }\u003cbr/\u003e    val graphicsEngine by asyncCache {\u003cbr/\u003e        GraphicsEngine(GraphicsRemoteConfig(from = remoteConfig()) // (2)\u003cbr/\u003e    }\u003cbr/\u003e    val gameData by asyncCache {\u003cbr/\u003e        gameRepository.getGameData(requireParameters().gameId)\u003cbr/\u003e    }\u003cbr/\u003e    val game by asyncCache {\u003cbr/\u003e         GameLoop(\u003cbr/\u003e             graphics = graphicsEngine(),\u003cbr/\u003e             remoteConfig = remoteConfig(),\u003cbr/\u003e             clock = gameClock,\u003cbr/\u003e             data = gameData(),\u003cbr/\u003e             params = requireParameters(),\u003cbr/\u003e         ).let { GameInstance(it) }\u003cbr/\u003e    }\u003cbr/\u003e    // ... more ... \u003cp\u003e    asyncInit { // (3)\u003cbr/\u003e        updateState { Loading() }\u003cbr/\u003e        player.loadVideo(gameData().videoUrl)\u003cbr/\u003e        updateState {\u003cbr/\u003e            GameEngineState.Running(\u003cbr/\u003e                game = game(),\u003cbr/\u003e                player = player,\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e        clock.start()\u003cbr/\u003e    }\u003cbr/\u003e    deinit { // (4)\u003cbr/\u003e        graphicsEngine.release()\u003cbr/\u003e        player.stop()\u003cbr/\u003e        playerPool.return(player)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003col\u003e\u003cli id=\"dfc7\"\u003eOur game clock runs an event loop and synchronizes game time with video time. Unfortunately, it requires a coroutine scope where it runs the loop that should only be active during the game. Luckily, we already have one! \u003ccode\u003ePipelineContext\u003c/code\u003e, which is the context of the \u003ccode\u003eStore\u003c/code\u003e‘s execution, is provided with plugins and implements \u003ccode\u003eCoroutineScope\u003c/code\u003e. We can just use it in our \u003ccode\u003ecache\u003c/code\u003e plugin and start the game clock, which will automatically stop when we shut down the engine.\u003c/li\u003e\u003cli id=\"2101\"\u003eYou can see we used a bunch of \u003ccode\u003easyncCache\u003c/code\u003es to \u003cstrong\u003eparallelize loading\u003c/strong\u003e, and with the Graphics Engine, we also were able to depend on remote config inside (as an example, in reality it depends on lots of stuff). This greatly simplifies our logic, because the \u003cstrong\u003edependencies between components are implicit\u003c/strong\u003e now, and the requesting party who wants just the graphics engine doesn’t have to manage the dependencies of it! The operator invoke (parentheses) is a shorthand for \u003ccode\u003eDeferred.await()\u003c/code\u003e for that extra sweet taste.\u003c/li\u003e\u003cli id=\"aa99\"\u003eWe have also used an \u003ccode\u003easyncInit\u003c/code\u003e which essentially launches a background job in the current game engine’s gameplay scope to load the game. Inside the job, we do final preparations, wait for all of the dependencies, and start the game clock.\u003c/li\u003e\u003cli id=\"c451\"\u003eWe have used the built-in \u003ccode\u003edeinit\u003c/code\u003e plugin to put all of our cleanup logic in the callback that is invoked as soon as the game engine is stopped (and its scope is canceled). It will be run \u003cstrong\u003ebefore\u003c/strong\u003e our cached values are cleaned up (because it was installed \u003cstrong\u003elater\u003c/strong\u003e), but \u003cstrong\u003eafter\u003c/strong\u003e our \u003cstrong\u003ejobs\u003c/strong\u003e have been \u003cstrong\u003ecanceled\u003c/strong\u003e, so that we can do what we want, and the \u003ccode\u003ecache\u003c/code\u003e plugin will then garbage-collect the rest of the stuff without us worrying about leaks.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"db77\"\u003eOverall, these 50 lines of code have replaced 1.5 thousand lines of our old game engine’s implementation! I had to pick up my jaw from the floor when I realized how powerful these patterns are for business logic.\u003c/p\u003e\u003cp id=\"ef5a\"\u003eBut we’re still lacking one thing.\u003c/p\u003e\u003ch2 id=\"6294\"\u003eError Handling\u003c/h2\u003e\u003cp id=\"7291\"\u003eA lot of things in the engine can go wrong during gameplay:\u003c/p\u003e\u003cul\u003e\u003cli id=\"00e4\"\u003eSome game-author forgot to add a frame to an animation,\u003c/li\u003e\u003cli id=\"c0a7\"\u003eA person lost their connection during the game,\u003c/li\u003e\u003cli id=\"6454\"\u003eThe shaders failed rendering due to a platform bug, and more…\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"fbef\"\u003eUsually, only the main errors for API calls are handled in apps with wrappers like \u003ccode\u003e\u003ca href=\"https://github.com/respawn-app/ApiResult\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eApiResult\u003c/a\u003e\u003c/code\u003e or some kind of try/catch. But imagine wrapping every single line of the Game Engine’s code in a try-catch… That would mean hundreds of lines of try-catch-finally garbage!\u003c/p\u003e\u003cp id=\"45b6\"\u003eWell, you probably know what will happen. Since we can intercept any event now, let’s make an \u003cstrong\u003eerror-handling plug-in! \u003c/strong\u003eI named it \u003cem\u003erecover\u003c/em\u003e, and now our code looks like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2327\"\u003eoverride val store by lazyStore(GameEngineState.Stopped) {\u003cbr/\u003e   configure { /* ... */ } \u003cbr/\u003e   val player by cache { /* ... */ }\u003cp\u003e      // ...\u003c/p\u003e\u003cp\u003e   recover { e -\u0026gt;\u003cbr/\u003e       if (config.debuggable) updateState { // (1)\u003cbr/\u003e           GameEngineState.Error(e) \u003cbr/\u003e       } else when(e) { // (2)\u003cbr/\u003e           is StoreTimeoutException, is GLException -\u0026gt; Unit // just report to analytics\u003cbr/\u003e           is MediaPlaybackException -\u0026gt; player.retry()\u003cbr/\u003e           is AssetCorruptedException -\u0026gt; assetManager.refreshAssetsSync()\u003cbr/\u003e           is BufferingTimeoutException -\u0026gt; action(ShowSlowInternetMessage)\u003cbr/\u003e           // ... more ...\u003cbr/\u003e           else -\u0026gt; shutdown() // (3)\u003cbr/\u003e       }\u003cbr/\u003e       null // swallow the exception\u003cbr/\u003e   }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003col\u003e\u003cli id=\"14c6\"\u003eIf our store is configured to be debuggable (\u003ccode\u003econfig\u003c/code\u003e is available in store plug-ins), we can show a full-screen overlay with the stack trace to let our QA team easily report errors to devs before they get to production. \u003ca href=\"https://en.wikipedia.org/wiki/Fail-fast_system\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFail Fast\u003c/a\u003e principle in action.\u003c/li\u003e\u003cli id=\"caef\"\u003eIn production, however, we will handle some errors by retrying, skipping an animation, or warning the user about their connection without interrupting the gameplay.\u003c/li\u003e\u003cli id=\"ad89\"\u003eIf we can’t handle an error and cannot recover, then we shut down the engine and let the user try to play the game again, without crashing the app or showing obscure messages (those go to crashlytics).\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"11ee\"\u003eWith this, we’ve got ourselves error-handling for any existing and new code a developer may ever add to our game engine, with 0 try-catches.\u003c/p\u003e\u003ch2 id=\"1142\"\u003eFinal touches\u003c/h2\u003e\u003cp id=\"def9\"\u003eWe’re almost done! This article is getting long, so I’ll blitz through some additional plug-ins I had to install to support our use cases:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"65a5\"\u003eoverride val store by lazyStore(GameEngineState.Stopped) {\u003cbr/\u003e    configure { /* ... */ }\u003cp\u003e    // ...\u003cbr/\u003e    val subs = awaitSubscribers() // (1)\u003cbr/\u003e    val jobs = manageJobs\u0026lt;GameJobs\u0026gt;() // (2)\u003cbr/\u003e    initTimeout(5.seconds) { // (3)\u003cbr/\u003e        subs.await()\u003cbr/\u003e    }\u003cbr/\u003e    whileSubscribed { // (4)\u003cbr/\u003e        assetManager.loadingProgress.collect { progress -\u0026gt;\u003cbr/\u003e            updateState\u0026lt;Loading, _\u0026gt; {\u003cbr/\u003e                copy(progress = progress)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    install(\u003cbr/\u003e        autoStopPlugin(jobs), // (5)\u003cbr/\u003e        resetStatePlugin(), // (6)\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003col\u003e\u003cli id=\"f674\"\u003eSince a developer can make the mistake of starting the game, but never displaying the actual gameplay experience (user left, a bug, plans changed, etc…), I am using the pre-made \u003ccode\u003eawaitSubscribers\u003c/code\u003e plugin in snippet (3) to see if they appear within 5 seconds of starting the game, and if not, close the store and \u003cstrong\u003eauto-cleanup the held resources\u003c/strong\u003e to prevent leaks. Boom!\u003c/li\u003e\u003cli id=\"df3b\"\u003eI’m using another plug-in — \u003ccode\u003eJobManager\u003c/code\u003e, to run some long-running operations in the background. Code that uses it didn’t fit, but essentially it’s needed to track whether the user is currently playing.\u003c/li\u003e\u003cli id=\"ea5b\"\u003e\u003ccode\u003eInitTimeout\u003c/code\u003e is a custom plugin that verifies whether the game has finished loading within 5 seconds, and if not, we pass an error to our \u003ccode\u003erecover\u003c/code\u003e plugin to decide what to do and report the issue to analytics.\u003c/li\u003e\u003cli id=\"db9e\"\u003eThe \u003ccode\u003ewhileSubscribed\u003c/code\u003e plugin launches \u003cstrong\u003ea job that is only active when subscribers\u003c/strong\u003e (in our case, UI) \u003cstrong\u003eare present\u003c/strong\u003e, where we update the visuals of the loading progress only when the user is actually seeing the loading screen. It allows us to easily \u003cstrong\u003eavoid resource leaks\u003c/strong\u003e if the game engine is covered up by something or hidden.\u003c/li\u003e\u003cli id=\"1d37\"\u003eThe \u003ccode\u003eautoStopPlugin\u003c/code\u003e uses our job manager to watch for game load progress and gameplay progress. It looks at whether we have subscribers to pause the game when the user leaves, then \u003cstrong\u003estop it once the engine is not used for a while\u003c/strong\u003e, eliminating the risk of leaking memory.\u003c/li\u003e\u003cli id=\"b957\"\u003eThe \u003ccode\u003eresetStatePlugin\u003c/code\u003e is a built-in one I had to install to auto-cleanup state when the game ends. By default, \u003cstrong\u003estores will not have their state reset\u003c/strong\u003e when they stop. This is good for regular UI but not in our case - we want the engine to go back to the Stopped state when the game ends.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"e758\"\u003eAll of those plugins were already in the library, so using them was a piece of cake.\u003c/p\u003e\u003ch2 id=\"9e78\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"81bb\"\u003eIt was a wild ride, but after all this, I not only managed to keep my job, but I think that the overall solution has turned out pretty great. The engine went from 7+k to just 400 lines of readable, linear, structured, performant, extensible code, and the users are already enjoying the results:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e58c\"\u003e\u003cstrong\u003eLoading time\u003c/strong\u003e went from ~20 seconds to just 1.75 seconds!\u003c/li\u003e\u003cli id=\"c9dd\"\u003e\u003cstrong\u003eCrashed\u003c/strong\u003e games fell from 8% to 0.01%!\u003c/li\u003e\u003cli id=\"c62d\"\u003eWe improved the \u003cstrong\u003ethroughput\u003c/strong\u003e of the game event processing by 1700%\u003c/li\u003e\u003cli id=\"36a5\"\u003eVideo \u003cstrong\u003ebuffering\u003c/strong\u003e occurrences during games went from ~31% to \u0026lt;10% due to our caching\u003c/li\u003e\u003cli id=\"3482\"\u003e\u003cstrong\u003eBattery\u003c/strong\u003e \u003cstrong\u003econsumption\u003c/strong\u003e during gameplay was reduced by orders of magnitude\u003c/li\u003e\u003cli id=\"8d4d\"\u003e\u003cstrong\u003eANRs\u003c/strong\u003e during gameplay fell to being statistically 0\u003c/li\u003e\u003cli id=\"9e56\"\u003e\u003cstrong\u003eGC pressure\u003c/strong\u003e decreased by 40% during gameplay\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"93db\"\u003eHopefully, by this point, I’ve shown why the patterns we used to hate like Decorators, Interceptors, and Chain of Responsibility can be insanely helpful when building not just some backend service, networking code, or a specialized use-case, but also implementing the regular application logic, including UI and state management.\u003c/p\u003e\u003cp id=\"4bde\"\u003eWith the power that Kotlin gives when building DSLs, we can turn the fundamental patterns (used in software development for decades) from a mess of boilerplate, inheritance, and complicated delegation into a fast, straightforward, compact, linear code that is fun and efficient to work with. I encourage you to build something like this for your own app’s architecture and reap the benefits.\u003c/p\u003e\u003cp id=\"f258\"\u003eAnd if you don’t want to dive into that and want something already available, or are curious to learn more, then consider checking out the original library where I implemented everything mentioned here on \u003ca href=\"https://github.com/respawn-app/FlowMVI\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub\u003c/a\u003e, or dive right into the \u003ca href=\"https://opensource.respawn.pro/FlowMVI/#/quickstart\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003equickstart\u003c/a\u003e guide to try it in 10 minutes.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "24 min read",
  "publishedTime": "2024-12-22T20:32:20.919Z",
  "modifiedTime": null
}
