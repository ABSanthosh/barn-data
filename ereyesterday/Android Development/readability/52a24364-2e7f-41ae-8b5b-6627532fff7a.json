{
  "id": "52a24364-2e7f-41ae-8b5b-6627532fff7a",
  "title": "Building a Space Flight News App with Compose Multiplatform for Android, iOS, and Desktop: Part 1",
  "link": "https://proandroiddev.com/building-a-space-flight-news-app-with-compose-multiplatform-for-android-ios-and-desktop-part-1-2b93ad3c0271?source=rss----c72404660798---4",
  "description": "",
  "author": "Domen Lanišnik",
  "published": "Wed, 19 Feb 2025 21:21:10 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "compose-multiplatform",
    "androiddev",
    "android-app-development",
    "kotlin-multiplatform",
    "ios-development"
  ],
  "byline": "Domen Lanišnik",
  "length": 30589,
  "excerpt": "The first part of a series of articles focusing on building a Compose Multiplatform app. for Android, iOS, and Desktop that displays the latest Space News.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Building a Space Flight News App with Compose Multiplatform for Android, iOS, and Desktop: Part 1 — Getting Started with KMPThis is the first part of a series of articles focusing on Compose Multiplatform. Over the next few parts, we’ll be building an app for Android, iOS, and Desktop that displays the latest Space Flight news.Screenshot showing the home screen of the final app.As an Android developer, the idea of being able to write “Android” code and also have it run on iOS, Desktop, and Web almost sounds too good. But JetBrains is promising exactly that with Compose Multiplatform, a “declarative framework for sharing UIs across multiple platforms, based on Kotlin Multiplatform and Jetpack Compose”.This article will give an overview of the framework and setting up the project, while next parts will focus on:building UI with Compose and Material3,sharing view models across platforms,navigating between screens using Navigation Compose,adding dependency injection using Koin,integrating a network layer using Ktor,integrating a database layer using SQLDelight to support offline mode,displaying remote images using Coil,opening an URL in an external web browser,and opening the system share sheet.The project we’ll be buildingA simple app that displays a list of Space Flight-related news, from newest to oldest. Users can scroll through the list and click on the news to open its details.The news is fetched from the https://spaceflightnewsapi.net/ API and cached locally on the device to support offline mode.Users can then read the full article in an external web browser and share the article through a native share sheet.You can see the final product in the video below. However, in this part, we are going to start with the basics.Showcase of the final app.RequirementsHave an Android development environment set up. This includes Android Studio, Android SDK, emulator, or physical device.Have basic knowledge of Android development and Jetpack Compose.If you also wish to run the iOS app, you need a Mac and Xcode. No previous knowledge of iOS development is needed.Creating a new Compose Multiplatform projectUse the Kotlin Multiplatform Wizard to generate a new project KMP project. Enter desired project name (“SpaceFlightNews” for example), your project ID and check Android, iOS and Desktop. Make sure that “Share UI” is selected for iOS to be able to leverage Compose Multiplatform.Generating a new starter project using the Kotlin Multiplatform Wizard.Leave the Web and Server options unchecked and click “Download” to download the starter project.Next, unzip the downloaded archive and open the project in Android Studio through File -\u003e Open -\u003e Select folder. Make sure to select the entire KMP project folder and hit “Open”.Selecting the entire KMP project folder in Android Studio.The project should now be opened in Android Studio. Make sure to switch the sidebar project view from Android to Project to see the typical KMP structure.Opened project with the side bar view in Project mode.Running the app on different platformsWe’ll explore the structure a bit later, but first, let’s try to run the app on different platforms.Running the Android appTo run the Android app, make sure that you have an emulator running or a physical device connected and that “composeApp” is selected in the run menu. Then, press the green run button to build and deploy the Android app.Run configuration selection.If you have the IDE set up correctly, the app should be built and installed successfully. Once deployed, you will see an empty screen with a single button. Pressing it will display an image and write the platform name and version, in this case, “Android” and “35” (API level).Sample app running on Android.Running the iOS appNote: This part requires a Mac OS with Xcode installed and set up. You can not build an iOS app on Windows or Linux even when developing a KMP app.To run the iOS app, ensure that you have Xcode installed on your Mac OS, have downloaded the iOS SDK, and set up the simulator and command-line tools. All of this should be required when installing Xcode for the first time.Through Android StudioThe simplest way to run the iOS app is to run it directly from Android Studio. Change the run configuration in the toolbar to “iosApp” and hit the run button.This will use the command line to trigger a build of the iOS app using Xcode, like so:/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -project /path_to_project/SpaceFlightNews/iosApp/iosApp.xcodeproj -scheme iosApp -configuration Debug OBJROOT=/path_to_project/SpaceFlightNews/build/ios SYMROOT=/path_to_project/SpaceFlightNews/build/ios -destination id=SOME-ID -allowProvisioningDeviceRegistration -allowProvisioningUpdatesIf everything is working okay, your default iOS simulator should start up, and the app should be launched. If the build fails, double-check your Xcode configuration and make sure that everything is correctly installed, and you can launch an iOS simulator without issues.After pressing the button, you should see “iOS” and OS version (“18.2”).Sample app running on iOS.With XcodeIt’s also possible to run the iOS app with Xcode by opening the project in Xcode. To do that, open Xcode and choose either “Open Existing Project…” if you don’t currently have a project opened or File -\u003e Open if you do.Then, navigate to the project folder and select the entire “iosApp” folder. Make sure that you select the root “iosApp” folder and not the nested one. Click Open, and if asked, select to trust the project.Opening the iosApp project in Xcode.You should now see the whole iOS app project in Xcode. To run it, simply click the big run/arrow button at the top, and the app should be deployed.iOS app project opened in Xcode.You will also need to use Xcode if you want to write iOS-specific code or SwiftUI views.Running the Desktop appAnd last but not least, we need to try out the desktop app. First, we need to set up the run configuration. You can click Run -\u003e Edit Configurations in the menu or click “composeApp” or “iosApp” next to the run button in the toolbar and then “Edit Configurations”.In the window that opens up, click the plus button and select Gradle from the list. Then, write composeApp:run in the “Tasks and arguments” input field. Hit OK and run the app.Creating a run configuration for the desktop app.Gradle will start building the app and shortly a new app will open showing the same UI as the Android and iOS apps. The only difference is that the platform is Java, and the version equals the Java SDK version (21).Sample app running on desktop (Mac).Project structure and code explorationWe’ve successfully ran the app on all three platforms, now let’s check the project structure and code to understand how everything works underneath.You can find a more detailed description of the project structure on the JetBrains official website, including graphics on how the modules are related.Exploring the project modules, we can see there are two main modules:composeApp is the main Kotlin module that contains the shared code.iosApp is an Xcode project for building the iOS app. It uses the code from the composeApp module to compile into an iOS app.Project structure in Android Studio.The composeApp module is then split into four source sets:androidMain contains the Android-specific code that is needed to build the Android app. This includes the AndroidManifest, activities and so on.commonMain contains the shared code that is used for all platforms, including Composable functions and models. You should write as much code as possible in this module to avoid duplication on platforms.desktopMain contains the desktop-specific code that is needed to build the Mac/Windows/Linux JVM app.iosMain contains the iOS-specific code that is needed to build the iOS app. This includes view controllers and so on.Exploring the codeNext, let’s take a look at the files in our project. In the composeApp module, we find a single build.gradle.kts file that tells Gradle how to build the app. It’s also where we declare the common dependencies for all platforms (inside the commonMain.dependencies{} block) and platform-specific dependencies.Dependency declaration in the composeApp/build.gradle.kts file.commonMain source set There are three files in the commonMain source set within the composeApp module: App.kt, Greeting and Platform.kt.The App.kt file contains a single composable function App() that draws the UI we saw before using Compose. If you’ve used Jetpack Compose before on Android, this will all look familiar. It creates an instance of the Greeting class.Composable function rendering the app UI.The Greeting class is a simple Kotlin class that has a single function greet(): String that returns a message. It calls the getPlatform() function to get an instance of the Platform interface declared in the Platform.kt file.The getPlatform() function is an expected function. An expected function is declared using the expect keyword and is just a declaration of the function. The actual implementation of the function is done for each platform. Next to the function, we can see an orange square with an “A” in the middle (“A” for actual). Clicking on it reveals a list of all the implementations of this function in iosMain, desktopMain and main/androidMain.Declaration of an expected function and a list of its implementations.androidMain source setAndroid-specific source set contains a few files worth noting: MainActivity.kt, Platform.android.kt and AndroidManifest.xml. Additionally, there are resource files for launcher icons and strings, but we’ll skip over those.MainActivity.kt is the entry point into the Android app and simply sets the content of the activity to be the App() composable function we saw earlier in commonMain source set. It also contains a preview composable function to visualize the UI.Contents of the MainActivity.kt file.Platform.android.kt contains the actual declaration of the getPlatform() expected function we saw in the commonMain source sets’ Greeting file. As mentioned before, expected and actual functions allow us to implement platform-specific logic by accessing native APIs. In this case, this is the Android OS SDK version.Next to the function, there is an orange square with an “E” in the middle (“E” for expect), and clicking it will jump to the expected declaration.Contents of the Platform.android.kt file with the implementation of the getPlatform() function.AndroidManifest.xml contains the metadata of the Android application, including its name, icon, theme, and default activity.desktopMain source setDesktop-specific source set containing code to run the desktop JVM app on Windows, Mac, and Linux operating systems. It contains two files: main.kt and Platform.jvm.kt.The main.kt file is the entry point into the app and has a runnable main() function. It creates a Compose application entry point using the application() function and then creates a new Window that draws the App() composable function.Contents of the main.kt file.The Platform.jvm.kt file contains the actual implementation of the getPlatform() function, similar to what we saw in the Android-specific file. In this case, it prints the Java version used on the operating system.Contents of the Platform.jvm.kt file.iosMain source setiOS-specific source set containing two files: MainViewController.kt and Platform.ios.kt.The MainViewController.kt is the entry point into the iOS app. It creates a new Compose-based UIViewController and renders the App() composable function. A UIViewController on iOS is an object that manages the view hierarchy, similar to an Activity or Fragment on Android.Contents of the MainViewController.kt file.The Platform.ios.kt file contains the actual implementation of the getPlatform() function, similar to what we saw in the Android-specific and the Desktop-specific file. In this case, it prints the name of the current device and the system version, which are both iOS-only APIs.Contents of the Platform.ios.kt file.So far, we’ve taken a look at how a typical KMP project is structured and ran the apps. Now comes the fun part: implementing our Space Flight news app. The end goal is to fetch a list of articles from an API and display them in the app.Adding a new SpaceFlightArticle modelWe need a way to represent an individual space flight article. Taking a look at the SpaceFlightNews API, we can see what the response JSON looks like. We need to create a Kotlin class representing this to map the API response to our local model.Create a new Kotlin data class inside the /composeApp/commonMain source set and name it Article. Then, declare the following fields from the JSON: title, url, image_url, news_site, summary, published_at and updated_at. We’ll omit a few fields we don’t need to render the UI. The result should look something like this:data class Article( val id: Long, val title: String, val url: String, val imageUrl: String, val newsSite: String, val summary: String, val publishedAt: String, val updatedAt: String,)Adding a new dependencyWe’ve declared the published and updated timestamps as strings since that’s what we get in the response (2025-01-04T02:04:26Z). However, at some point, we’ll want to render them in a more human-readable way. To do that, we have to represent them as a date/time object. The easiest way is to use the kotlinx-datetime library, so let’s add it.First, let’s declare the version and dependency in the Gradle Version Catalog file. Open the gradle/libs.versions.toml file and add the following definitions to the versions and libraries sections. Using a version catalog makes it easier to manage dependencies since they are all declared in one place. Perform a gradle sync to generate references the new dependency.[versions]...kotlinx-datetime = \"0.6.1\"[libraries]...kotlinx-datetime = { module = \"org.jetbrains.kotlinx:kotlinx-datetime\", version.ref = \"kotlinx-datetime\" }Next, we have to actually use the dependency. Open the composeApp/build.gradle.kts file and add the following line inside the commonMain.dependencies {} block:implementation(libs.kotlinx.datetime)Run the gradle sync again and then go back to the Article class we created earlier. Update the publishedAt and updatedAt properties to be of type Instant instead of String. This will later allow us to parse the string timestamp from the response (\"2025-01-04T02:04:26Z”) and convert it to an Instant.import kotlinx.datetime.Instantdata class Article( val id: Long, val title: String, val url: String, val imageUrl: String, val newsSite: String, val summary: String, val publishedAt: Instant, val updatedAt: Instant,)Creating the article list screenSince we’re building a news app, the main screen will show a list of articles. For now, we’re going to build the UI with mocked data.Switching to Material3The UI is currently built on top of the Material 2 design. However, Google’s official recommendation is to use Material 3 for all new apps. We are going to migrate our app to use Material 3 before we start building our UI.Open the composeApp/build.gradle.kts file and find the following line inside the commonMain.dependencies {} block:implementation(compose.material)Then simply replace it with this one:implementation(compose.material3)Perform a gradle sync to apply the changes. If we try to run the app, we’ll notice that the build fails because of errors in the App file. This is because our app is importing the Material2 versions of Button and Text components, and not the Material3 versions. To fix this, open the App.kt file and replace the following imports:import androidx.compose.material.Buttonimport androidx.compose.material.MaterialThemeimport androidx.compose.material.Textwith their Material3 equivalents:import androidx.compose.material3.Buttonimport androidx.compose.material3.MaterialThemeimport androidx.compose.material3.TextAnd that’s it! If we run the app now, we will see that the button is in the Material3 style.Sample app using Material 3 design system, running on iOS.Removing old sample codeSince we’re going to be building our own UI, let’s delete the old sample code from the wizard. It served its purpose of allowing us to examine the structure of a KMP app and how expect/actual declarations work.Start by going to the composeApp/commonMain/App.kt and delete everything inside the MaterialTheme {} block and remove all unused imports. You should be left with this:@Composable@Previewfun App() { MaterialTheme { }}Next, let’s delete the composeApp/commonMain/Greeting and the composeApp/commonMain/Platform.kt files. Make sure to also delete the composeApp/androidMain/Platform.android.kt, composeApp/desktopMain/Platform.jvm.kt and composeApp/iOS/Platform.ios.kt files.Finally, delete the composeApp/commonMain/composeResources/compose-multiplatform.xml file that displayed the Compose Multiplatform logo in the app.Running the app should still work. You will just see an empty screen. We now have a blank slate to add our own code.Creating a scaffoldLet’s create the UI structure for our app. To do that, we’ll use a Scaffold, which allows us to construct a typical Compose screen.@Composable@Previewfun App() { MaterialTheme { Scaffold { innerPadding -\u003e // TODO Add content } }}We want to have a top bar with the name of the app at the top that will also later serve as a way to navigate back from the article details screen. To do that, we can provide a TopAppBar composable to the topBar argument of the Scaffold component. The TopAppBar composable expects a single title composable, which is typically a Text component.Because many of the Material3 components are still considered experimental, we have to apply the @OptIn(ExperimentalMaterial3Api::class) annotation to our composable functions.@OptIn(ExperimentalMaterial3Api::class)@Composable@Previewfun App() { MaterialTheme { Scaffold( topBar = { TopAppBar( title = { Text(text = \"Space Flight News\") } ) } ) { innerPadding -\u003e // TODO } }}If we run the app, we see that we now display the app title at the top of the screen.Empty scaffold with top bar.Adding a new app themeThis is great, but you’ll notice that our background is a shade of pink and no longer white as before. That is because we are using the default MaterialTheme theme and Scaffold uses the MaterialTheme.colorScheme.background color for its containerColor property.We could fix this by setting the Scaffold.containerColor to Color.White. However, while that would fix the background color for this specific screen, we would need to do this everytime we use a Scaffold or any composable that references the MaterialTheme.colorScheme.background color. Additionaly, the background would remain white even when dark theme is enabled.Instead, to address this properly, let’s create a new AppTheme that we will use in our app instead of the default MaterialTheme. Create a new file Theme.kt inside the spaceflightnews/ui/theme package and add a new AppTheme composable function:private val LightColorScheme = lightColorScheme( background = Color.White, surface = Color.White,)private val DarkColorScheme = darkColorScheme()@Composablefun AppTheme( darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable() () -\u003e Unit) { val colorScheme = if (darkTheme) DarkColorScheme else LightColorScheme MaterialTheme( colorScheme = colorScheme, content = content )}We’ve first defined our own colors for the light color scheme and kept the default dark color scheme. Next, we pass those schemes to the default MaterialTheme. To use the new theme, we simply replace the MaterialTheme wrapper in the App file with AppTheme:@OptIn(ExperimentalMaterial3Api::class)@Composable@Previewfun App() { AppTheme { Scaffold( topBar = { TopAppBar( title = { Text(text = \"Space Flight News\") } ) } ) { innerPadding -\u003e // TODO } }}If we run the app now, we see a white background. And switching to dark mode on the device correctly renders a black background.Empty scaffold with correct background.Using string resourcesYou’ll notice we hardcoded the title of the app in the top bar, which is not a good practice. Resources like images and strings are usually placed in the composeResources folder and referenced in the code. This approach is similar to how we declare resources on Android and enables good localization support.Create a new values folder inside the composeApp/commonMain/composeResources folder. Then, create a new file named strings.xml inside the new folder. Declare the app name like so:\u003cresources\u003e \u003cstring name=\"app_name\"\u003eSpace Flight News\u003c/string\u003e\u003c/resources\u003eTo be able to reference the newly added string from the code, we have to rebuild or re-run our project. This allows KMP to generate a static accessor for it. Now, we can go back to our TopAppBar composable in the App file and replace the hard-coded string with stringResource(Res.string.app_name). We also need to import the Res and app_name references.You can find more information on how to use multiplatform resources here.Defining a new article list screenWe’ve created our scaffold; now it’s time to create the landing screen that will show a list of articles. Let’s start by creating a new folder named ui next to the existing App.kt file that will contain all our UI-related code. Then, create a new file named ArticleListScreen.kt inside it. It’s good practice to extract screen-level code to new files and not have a single large App file.Next, we’re going to define a new Composable function named ArticleListContent() inside the ArticleListScreen.kt that will be responsible for rendering a list of articles it receives.@Composableprivate fun ArticleListContent( articles: List\u003cArticle\u003e,){ // TODO}A scrollable list of items in Compose is typically represented with a LazyColumn component that is optimized to only layout the items that are visible on screen. We are going to use it to show our list of articles.@Composableprivate fun ArticleListContent( articles: List\u003cArticle\u003e,){ LazyColumn( contentPadding = PaddingValues(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp), modifier = Modifier.fillMaxSize() ) { items(articles) { article -\u003e // TODO } }}Next, we need a Composable to draw an individual article. Let’s create a new composable function ArticleItem() that accepts a single article and renders a Card with the article title, summary, and publication date.We are using a Column to vertically position the texts, with a 8.dp spacing between them.The publication date requires a bit of manual formatting to display it in a human-readable format. If you remember, we’ve represented the date as an Instant, which will print the date in the following format: “2023–01–02T23:40:57.120Z”. To format it as yyyy-MM-dd at HH:mm we have to first convert it to a LocalDateTime using the device timezone, then build our datetime pattern.@Composableprivate fun ArticleItem( article: Article,) { Card( modifier = Modifier.fillMaxWidth() ) { Column( verticalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxSize().padding(16.dp) ) { Text( text = article.title, style = MaterialTheme.typography.titleMedium, maxLines = 2, overflow = TextOverflow.Ellipsis, ) Text( text = article.summary, style = MaterialTheme.typography.bodyMedium, maxLines = 2, overflow = TextOverflow.Ellipsis ) Text( text = article.publishedAt.toLocalDateTime(TimeZone.currentSystemDefault()).format( LocalDateTime.Format { year() char('-') monthNumber() char('-') dayOfMonth() chars(\" at \") hour() char(':') minute() }), style = MaterialTheme.typography.bodySmall, ) } }}Now that we have our article composable, we can go back to the ArticleListContent composable and add it to the composition.@Composableprivate fun ArticleListContent( articles: List\u003cArticle\u003e,) { LazyColumn( contentPadding = PaddingValues(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp), modifier = Modifier.fillMaxSize() ) { items(articles) { article -\u003e ArticleItem( article = article, ) } }}We have our scrollable list, but we need to use it somewhere. Let’s create a new composable function at the top of the file named ArticleListScreen() and add the ArticleListContent() composable to the composition. There is one issue, though: we need to pass a list of articles to it, which we don’t have.We’ll integrate fetching articles from a remote service in later parts. For now, we’ll simply hardcode a few articles to be able to run the app and visualize our UI.@Composableinternal fun ArticleListScreen() { val articles = remember { listOf( Article( id = 28392, title = \"SpaceX launches UAE’s Thuraya-4 mobile connectivity satellite\", url = \"https://spacenews.com/spacex-launches-uaes-thuraya-4-mobile-connectivity-satellite/\", imageUrl = \"https://i0.wp.com/spacenews.com/wp-content/uploads/2025/01/Thuraya-4-scaled.jpg?fit=1024%2C635\u0026quality=89\u0026ssl=1\", newsSite = \"SpaceNews\", summary = \"SpaceX launched the Thuraya-4 voice and data connectivity satellite Jan. 3 for Space42, the United Arab Emirates’ recently formed AI-powered space technology champion.\\r\\nThe post SpaceX launches UAE’s Thuraya-4 mobile connectivity satellite appeared first on SpaceNews.\", publishedAt = Instant.parse(\"2025-01-04T02:04:26Z\"), updatedAt = Instant.parse(\"2025-01-04T08:35:00.677975Z\"), ), Article( id = 28391, title = \"NASA sees strong support for strategy to maintain continuous human presence in LEO\", url = \"https://spacenews.com/nasa-sees-strong-support-for-strategy-to-maintain-continuous-human-presence-in-leo/\", imageUrl = \"https://i0.wp.com/spacenews.com/wp-content/uploads/2024/12/54209298773_f912740933_k.jpg?fit=1024%2C683\u0026quality=89\u0026ssl=1\", newsSite = \"SpaceNews\", summary = \"NASA’s deputy administrator says there is nearly unanimous support for its LEO microgravity strategy that endorses keeping humans in orbit continuously.\\nThe post NASA sees strong support for strategy to maintain continuous human presence in LEO appeared first on SpaceNews.\", publishedAt = Instant.parse(\"2025-01-03T23:54:59Z\"), updatedAt = Instant.parse(\"2025-01-04T00:00:25.390033Z\"), ), Article( id = 28390, title = \"SpaceX achieves record-breaking 2024, looks ahead to 2025\", url = \"https://www.nasaspaceflight.com/2025/01/spacex-roundup-2024/\", imageUrl = \"https://www.nasaspaceflight.com/wp-content/uploads/2025/01/SpaceX-in-2024-collage.png\", newsSite = \"NASASpaceflight\", summary = \"SpaceX is gearing up for another record-breaking year in 2025 after surpassing all previous record-breaking…\\nThe post SpaceX achieves record-breaking 2024, looks ahead to 2025 appeared first on NASASpaceFlight.com.\", publishedAt = Instant.parse(\"2025-01-03T22:24:00Z\"), updatedAt = Instant.parse(\"2025-01-03T23:20:12.779937Z\"), ), ) } ArticleListContent( articles = articles, )}Finally, let’s go back to the App.kt file and add the ArticleListScreen() composable to the Scaffold content. We’re using a Box here to apply innerPadding, which makes sure that the content is not drawn underneath the system or navigation bars.@OptIn(ExperimentalMaterial3Api::class)@Composable@Previewfun App() { AppTheme { Scaffold( topBar = { TopAppBar( title = { Text(text = stringResource(Res.string.app_name)) } ) } ) { innerPadding -\u003e Box(modifier = Modifier.padding(innerPadding)) { ArticleListScreen() } } }}And that’s it! Let’s run the app and see the result.Final app running on Android, iOS, and Desktop.Bonus challengeWouldn’t it be great to add visualization to the app and display a cover image next to each article? It certainly would. The challenge is for you to add loading and displaying of images in the app from an URL.You can use the Coil image loading library to simplify the process. If you get stuck, feel free to follow this guide that I’ve prepared: Loading Images with Coil in Compose Multiplatform.Updated app with cover images for each article.ConclusionIf you followed all the way to the end, congratulations and thank you! This is the end of the first part of the series on Kotlin Multiplatform and Compose Multiplatform. We’ve built a simple (for now) news app, and during the process, we took a look at how:to create a new KMP project with shared UI using Compose Multiplatform,to run the app on different platforms,the project is structured with shared modules, source sets, and a separate iOS project,to enable the Material3 design system and create a custom theme,to add new string resources,to use the kotlix-datetime library,and to build and display a list of items with Compose.In the next part of the series, we are going to load the most recent news from the API service. To do that, we will add the following to our project:a shared ViewModel library to follow MVVM architecture on all platforms,Ktor network library to execute network requests using Kotlin coroutines,Coil image loading library to load article images from the network,and Koin dependency injection framework to tie everything together.Stay tuned!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*SGFz3yIIJXlKvfJXaen_9A.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"b71e\" data-testid=\"storyTitle\"\u003eBuilding a Space Flight News App with Compose Multiplatform for Android, iOS, and Desktop: Part 1 — Getting Started with KMP\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@domen.lanisnik?source=post_page---byline--2b93ad3c0271---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Domen Lanišnik\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*CHMrHH5mrrGDp0Vsm-UtKw.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--2b93ad3c0271---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"dd43\"\u003eThis is the first part of a series of articles focusing on Compose Multiplatform. Over the next few parts, we’ll be building an app for Android, iOS, and Desktop that displays the latest Space Flight news.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eScreenshot showing the home screen of the final app.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"c562\"\u003eAs an Android developer, the idea of being able to write “Android” code and also have it run on iOS, Desktop, and Web almost sounds too good. But \u003ca href=\"https://www.jetbrains.com/compose-multiplatform/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetBrains\u003c/a\u003e is promising exactly that with Compose Multiplatform, a \u003cem\u003e“declarative framework for sharing UIs across multiple platforms,\u003c/em\u003e \u003cem\u003ebased on Kotlin Multiplatform and Jetpack Compose”.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"b545\"\u003eThis article will give an overview of the framework and setting up the project, while next parts will focus on:\u003c/p\u003e\u003cul\u003e\u003cli id=\"8c6f\"\u003ebuilding UI with Compose and Material3,\u003c/li\u003e\u003cli id=\"4ac1\"\u003esharing view models across platforms,\u003c/li\u003e\u003cli id=\"715e\"\u003enavigating between screens using Navigation Compose,\u003c/li\u003e\u003cli id=\"d64a\"\u003eadding dependency injection using Koin,\u003c/li\u003e\u003cli id=\"7572\"\u003eintegrating a network layer using Ktor,\u003c/li\u003e\u003cli id=\"b4f8\"\u003eintegrating a database layer using SQLDelight to support offline mode,\u003c/li\u003e\u003cli id=\"cad0\"\u003edisplaying remote images using Coil,\u003c/li\u003e\u003cli id=\"80e0\"\u003eopening an URL in an external web browser,\u003c/li\u003e\u003cli id=\"726b\"\u003eand opening the system share sheet.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"dfae\"\u003eThe project we’ll be building\u003c/h2\u003e\u003cp id=\"b0f5\"\u003eA simple app that displays a list of Space Flight-related news, from newest to oldest. Users can scroll through the list and click on the news to open its details.\u003c/p\u003e\u003cp id=\"352f\"\u003eThe news is fetched from the \u003ca href=\"https://spaceflightnewsapi.net/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://spaceflightnewsapi.net/\u003c/a\u003e API and cached locally on the device to support offline mode.\u003c/p\u003e\u003cp id=\"3f40\"\u003eUsers can then read the full article in an external web browser and share the article through a native share sheet.\u003c/p\u003e\u003cp id=\"9f08\"\u003eYou can see the final product in the video below. However, in this part, we are going to start with the basics.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eShowcase of the final app.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"8c47\"\u003eRequirements\u003c/h2\u003e\u003cul\u003e\u003cli id=\"11cf\"\u003eHave an Android development environment set up. This includes Android Studio, Android SDK, emulator, or physical device.\u003c/li\u003e\u003cli id=\"f93f\"\u003eHave basic knowledge of Android development and Jetpack Compose.\u003c/li\u003e\u003cli id=\"1e01\"\u003eIf you also wish to run the iOS app, you need a Mac and Xcode. No previous knowledge of iOS development is needed.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"9595\"\u003eCreating a new Compose Multiplatform project\u003c/h2\u003e\u003cp id=\"efc0\"\u003eUse the \u003ca href=\"https://kmp.jetbrains.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Multiplatform Wizard\u003c/a\u003e to generate a new project KMP project. Enter desired project name (“SpaceFlightNews” for example), your project ID and check Android, iOS and Desktop. Make sure that “Share UI” is selected for iOS to be able to leverage Compose Multiplatform.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eGenerating a new starter project using the Kotlin Multiplatform Wizard.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"a0f0\"\u003eLeave the Web and Server options unchecked and click “Download” to download the starter project.\u003c/p\u003e\u003cp id=\"fac8\"\u003eNext, unzip the downloaded archive and open the project in Android Studio through File -\u0026gt; Open -\u0026gt; Select folder. Make sure to select the entire KMP project folder and hit “Open”.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSelecting the entire KMP project folder in Android Studio.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"66dd\"\u003eThe project should now be opened in Android Studio. Make sure to switch the sidebar project view from Android to Project to see the typical KMP structure.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eOpened project with the side bar view in Project mode.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"3b4e\"\u003eRunning the app on different platforms\u003c/h2\u003e\u003cp id=\"03bc\"\u003eWe’ll explore the structure a bit later, but first, let’s try to run the app on different platforms.\u003c/p\u003e\u003ch2 id=\"fa16\"\u003eRunning the Android app\u003c/h2\u003e\u003cp id=\"c83c\"\u003eTo run the Android app, make sure that you have an emulator running or a physical device connected and that “composeApp” is selected in the run menu. Then, press the green run button to build and deploy the Android app.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eRun configuration selection.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"8b29\"\u003eIf you have the IDE set up correctly, the app should be built and installed successfully. Once deployed, you will see an empty screen with a single button. Pressing it will display an image and write the platform name and version, in this case, “Android” and “35” (API level).\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSample app running on Android.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"5e97\"\u003eRunning the iOS app\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"791a\"\u003eNote: This part requires a Mac OS with Xcode installed and set up. You can not build an iOS app on Windows or Linux even when developing a KMP app.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"2a5f\"\u003eTo run the iOS app, ensure that you have Xcode installed on your Mac OS, have downloaded the iOS SDK, and set up the simulator and command-line tools. All of this should be required when installing Xcode for the first time.\u003c/p\u003e\u003cp id=\"ffb4\"\u003e\u003cstrong\u003eThrough Android Studio\u003cbr/\u003e\u003c/strong\u003eThe simplest way to run the iOS app is to run it directly from Android Studio. Change the run configuration in the toolbar to “iosApp” and hit the run button.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"91fd\"\u003eThis will use the command line to trigger a build of the iOS app using Xcode, like so:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c530\"\u003e/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -project /path_to_project/SpaceFlightNews/iosApp/iosApp.xcodeproj -scheme iosApp -configuration Debug OBJROOT=/path_to_project/SpaceFlightNews/build/ios SYMROOT=/path_to_project/SpaceFlightNews/build/ios -destination id=SOME-ID -allowProvisioningDeviceRegistration -allowProvisioningUpdates\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6e26\"\u003eIf everything is working okay, your default iOS simulator should start up, and the app should be launched. If the build fails, double-check your Xcode configuration and make sure that everything is correctly installed, and you can launch an iOS simulator without issues.\u003c/p\u003e\u003cp id=\"69f5\"\u003eAfter pressing the button, you should see “iOS” and OS version (“18.2”).\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSample app running on iOS.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"d128\"\u003e\u003cstrong\u003eWith Xcode\u003cbr/\u003e\u003c/strong\u003eIt’s also possible to run the iOS app with Xcode by opening the project in Xcode. To do that, open Xcode and choose either “Open Existing Project…” if you don’t currently have a project opened or File -\u0026gt; Open if you do.\u003c/p\u003e\u003cp id=\"1ed0\"\u003eThen, navigate to the project folder and select the entire “iosApp” folder. Make sure that you select the root “iosApp” folder and not the nested one. Click Open, and if asked, select to trust the project.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eOpening the iosApp project in Xcode.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"42ce\"\u003eYou should now see the whole iOS app project in Xcode. To run it, simply click the big run/arrow button at the top, and the app should be deployed.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eiOS app project opened in Xcode.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"d0d0\"\u003eYou will also need to use Xcode if you want to write iOS-specific code or SwiftUI views.\u003c/p\u003e\u003ch2 id=\"3291\"\u003eRunning the Desktop app\u003c/h2\u003e\u003cp id=\"131d\"\u003eAnd last but not least, we need to try out the desktop app. First, we need to set up the run configuration. You can click Run -\u0026gt; Edit Configurations in the menu or click “composeApp” or “iosApp” next to the run button in the toolbar and then “Edit Configurations”.\u003c/p\u003e\u003cp id=\"80e1\"\u003eIn the window that opens up, click the plus button and select Gradle from the list. Then, write \u003ccode\u003ecomposeApp:run\u003c/code\u003e in the “Tasks and arguments” input field. Hit OK and run the app.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eCreating a run configuration for the desktop app.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"60f9\"\u003eGradle will start building the app and shortly a new app will open showing the same UI as the Android and iOS apps. The only difference is that the platform is Java, and the version equals the Java SDK version (21).\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSample app running on desktop (Mac).\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"df16\"\u003eProject structure and code exploration\u003c/h2\u003e\u003cp id=\"7189\"\u003eWe’ve successfully ran the app on all three platforms, now let’s check the project structure and code to understand how everything works underneath.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"201b\"\u003eYou can find a more detailed description of the project structure on the \u003ca href=\"https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-create-first-app.html#examine-the-project-structure\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetBrains official website\u003c/a\u003e, including graphics on how the modules are related.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"dd46\"\u003eExploring the project modules, we can see there are two main modules:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1cab\"\u003e\u003ccode\u003ecomposeApp\u003c/code\u003e is the main Kotlin module that contains the shared code.\u003c/li\u003e\u003cli id=\"f43f\"\u003e\u003ccode\u003eiosApp\u003c/code\u003e is an Xcode project for building the iOS app. It uses the code from the \u003ccode\u003ecomposeApp\u003c/code\u003e module to compile into an iOS app.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003eProject structure in Android Studio.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"7aaf\"\u003eThe \u003ccode\u003ecomposeApp\u003c/code\u003e module is then split into four source sets:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3e6e\"\u003e\u003ccode\u003eandroidMain\u003c/code\u003e contains the Android-specific code that is needed to build the Android app. This includes the \u003ccode\u003eAndroidManifest\u003c/code\u003e, activities and so on.\u003c/li\u003e\u003cli id=\"3609\"\u003e\u003ccode\u003ecommonMain\u003c/code\u003e contains the shared code that is used for all platforms, including Composable functions and models. You should write as much code as possible in this module to avoid duplication on platforms.\u003c/li\u003e\u003cli id=\"d85f\"\u003e\u003ccode\u003edesktopMain\u003c/code\u003e contains the desktop-specific code that is needed to build the Mac/Windows/Linux JVM app.\u003c/li\u003e\u003cli id=\"2fd9\"\u003e\u003ccode\u003eiosMain\u003c/code\u003e contains the iOS-specific code that is needed to build the iOS app. This includes view controllers and so on.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"3ae1\"\u003eExploring the code\u003c/h2\u003e\u003cp id=\"586a\"\u003eNext, let’s take a look at the files in our project. In the \u003ccode\u003ecomposeApp\u003c/code\u003e module, we find a single \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e file that tells Gradle how to build the app. It’s also where we declare the common dependencies for all platforms (inside the \u003ccode\u003ecommonMain.dependencies{}\u003c/code\u003e block) and platform-specific dependencies.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eDependency declaration in the composeApp/build.gradle.kts file.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"e76c\"\u003e\u003ccode\u003e\u003cstrong\u003ecommonMain\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e source set \u003cbr/\u003e\u003c/strong\u003eThere are three files in the \u003ccode\u003ecommonMain\u003c/code\u003e source set within the \u003ccode\u003ecomposeApp\u003c/code\u003e module: \u003ccode\u003eApp.kt\u003c/code\u003e, \u003ccode\u003eGreeting\u003c/code\u003e and \u003ccode\u003ePlatform.kt\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"430a\"\u003eThe \u003ccode\u003eApp.kt\u003c/code\u003e file contains a single composable function \u003ccode\u003eApp()\u003c/code\u003e that draws the UI we saw before using Compose. If you’ve used Jetpack Compose before on Android, this will all look familiar. It creates an instance of the \u003ccode\u003eGreeting\u003c/code\u003e class.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eComposable function rendering the app UI.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"d390\"\u003eThe \u003ccode\u003eGreeting\u003c/code\u003e class is a simple Kotlin class that has a single function \u003ccode\u003egreet(): String\u003c/code\u003e that returns a message. It calls the \u003ccode\u003egetPlatform()\u003c/code\u003e function to get an instance of the \u003ccode\u003ePlatform\u003c/code\u003e interface declared in the \u003ccode\u003ePlatform.kt\u003c/code\u003e file.\u003c/p\u003e\u003cp id=\"2e31\"\u003eThe \u003ccode\u003egetPlatform()\u003c/code\u003e function is an \u003cem\u003eexpected\u003c/em\u003e function. An \u003ca href=\"https://kotlinlang.org/docs/multiplatform-expect-actual.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eexpected function\u003c/a\u003e is declared using the \u003ccode\u003eexpect\u003c/code\u003e keyword and is just a declaration of the function. The actual implementation of the function is done for each platform. Next to the function, we can see an orange square with an “A” in the middle (“A” for \u003ccode\u003eactual\u003c/code\u003e). Clicking on it reveals a list of all the implementations of this function in \u003ccode\u003eiosMain\u003c/code\u003e, \u003ccode\u003edesktopMain\u003c/code\u003e and \u003ccode\u003emain/androidMain\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eDeclaration of an expected function and a list of its implementations.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"b997\"\u003e\u003ccode\u003e\u003cstrong\u003eandroidMain\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e source set\u003cbr/\u003e\u003c/strong\u003eAndroid-specific source set contains a few files worth noting: \u003ccode\u003eMainActivity.kt\u003c/code\u003e, \u003ccode\u003ePlatform.android.kt\u003c/code\u003e and \u003ccode\u003eAndroidManifest.xml\u003c/code\u003e. Additionally, there are resource files for launcher icons and strings, but we’ll skip over those.\u003c/p\u003e\u003cp id=\"049b\"\u003e\u003ccode\u003eMainActivity.kt\u003c/code\u003e is the entry point into the Android app and simply sets the content of the activity to be the \u003ccode\u003eApp()\u003c/code\u003e composable function we saw earlier in \u003ccode\u003ecommonMain\u003c/code\u003e source set. It also contains a preview composable function to visualize the UI.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eContents of the MainActivity.kt file.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"81a3\"\u003e\u003ccode\u003ePlatform.android.kt\u003c/code\u003e contains the \u003cem\u003eactual \u003c/em\u003edeclaration of the \u003ccode\u003egetPlatform()\u003c/code\u003e expected function we saw in the \u003ccode\u003ecommonMain\u003c/code\u003e source sets’ \u003ccode\u003eGreeting\u003c/code\u003e file. As mentioned before, \u003ca href=\"https://kotlinlang.org/docs/multiplatform-expect-actual.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eexpected and actual functions\u003c/a\u003e allow us to implement platform-specific logic by accessing native APIs. In this case, this is the Android OS SDK version.\u003c/p\u003e\u003cp id=\"7938\"\u003eNext to the function, there is an orange square with an “E” in the middle (“E” for \u003ccode\u003eexpect\u003c/code\u003e), and clicking it will jump to the expected declaration.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eContents of the Platform.android.kt file with the implementation of the getPlatform() function.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"f214\"\u003e\u003ccode\u003eAndroidManifest.xml\u003c/code\u003e contains the metadata of the Android application, including its name, icon, theme, and default activity.\u003c/p\u003e\u003cp id=\"fb9d\"\u003e\u003ccode\u003e\u003cstrong\u003edesktopMain\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e source set\u003cbr/\u003e\u003c/strong\u003eDesktop-specific source set containing code to run the desktop JVM app on Windows, Mac, and Linux operating systems. It contains two files: \u003ccode\u003emain.kt\u003c/code\u003e and \u003ccode\u003ePlatform.jvm.kt\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"918b\"\u003eThe \u003ccode\u003emain.kt\u003c/code\u003e file is the entry point into the app and has a runnable \u003ccode\u003emain()\u003c/code\u003e function. It creates a Compose application entry point using the \u003ccode\u003eapplication()\u003c/code\u003e function and then creates a new \u003ccode\u003eWindow\u003c/code\u003e that draws the \u003ccode\u003eApp()\u003c/code\u003e composable function.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eContents of the main.kt file.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"c14b\"\u003eThe \u003ccode\u003ePlatform.jvm.kt\u003c/code\u003e file contains the actual implementation of the \u003ccode\u003egetPlatform()\u003c/code\u003e function, similar to what we saw in the Android-specific file. In this case, it prints the Java version used on the operating system.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eContents of the Platform.jvm.kt file.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"8d09\"\u003e\u003ccode\u003e\u003cstrong\u003eiosMain\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e source set\u003cbr/\u003e\u003c/strong\u003eiOS-specific source set containing two files: \u003ccode\u003eMainViewController.kt\u003c/code\u003e and \u003ccode\u003ePlatform.ios.kt\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"0a87\"\u003eThe \u003ccode\u003eMainViewController.kt\u003c/code\u003e is the entry point into the iOS app. It creates a new Compose-based \u003ccode\u003eUIViewController\u003c/code\u003e and renders the \u003ccode\u003eApp()\u003c/code\u003e composable function. A \u003ccode\u003e\u003ca href=\"https://developer.apple.com/documentation/uikit/uiviewcontroller\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUIViewController\u003c/a\u003e\u003c/code\u003e\u003ca href=\"https://developer.apple.com/documentation/uikit/uiviewcontroller\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e on iOS\u003c/a\u003e is an object that manages the view hierarchy, similar to an Activity or Fragment on Android.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eContents of the MainViewController.kt file.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"4c7e\"\u003eThe \u003ccode\u003ePlatform.ios.kt\u003c/code\u003e file contains the actual implementation of the \u003ccode\u003egetPlatform()\u003c/code\u003e function, similar to what we saw in the Android-specific and the Desktop-specific file. In this case, it prints the name of the current device and the system version, which are both iOS-only APIs.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eContents of the Platform.ios.kt file.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"cf0c\"\u003eSo far, we’ve taken a look at how a typical KMP project is structured and ran the apps. Now comes the fun part: implementing our Space Flight news app. The end goal is to fetch a list of articles from an API and display them in the app.\u003c/p\u003e\u003ch2 id=\"4f8b\"\u003eAdding a new SpaceFlightArticle model\u003c/h2\u003e\u003cp id=\"0912\"\u003eWe need a way to represent an individual space flight article. Taking a look at the SpaceFlightNews API, we can see what the response JSON looks like. We need to create a Kotlin class representing this to map the API response to our local model.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"3794\"\u003eCreate a new Kotlin data class inside the \u003ccode\u003e/composeApp/commonMain\u003c/code\u003e source set and name it \u003ccode\u003eArticle\u003c/code\u003e. Then, declare the following fields from the JSON: \u003ccode\u003etitle\u003c/code\u003e, \u003ccode\u003eurl\u003c/code\u003e, \u003ccode\u003eimage_url\u003c/code\u003e, \u003ccode\u003enews_site\u003c/code\u003e, \u003ccode\u003esummary\u003c/code\u003e, \u003ccode\u003epublished_at\u003c/code\u003e and \u003ccode\u003eupdated_at\u003c/code\u003e. We’ll omit a few fields we don’t need to render the UI. The result should look something like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c424\"\u003edata class Article(\u003cbr/\u003e    val id: Long,\u003cbr/\u003e    val title: String,\u003cbr/\u003e    val url: String,\u003cbr/\u003e    val imageUrl: String,\u003cbr/\u003e    val newsSite: String,\u003cbr/\u003e    val summary: String,\u003cbr/\u003e    val publishedAt: String,\u003cbr/\u003e    val updatedAt: String,\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"a970\"\u003eAdding a new dependency\u003c/h2\u003e\u003cp id=\"1f41\"\u003eWe’ve declared the published and updated timestamps as strings since that’s what we get in the response (\u003ccode\u003e2025-01-04T02:04:26Z\u003c/code\u003e). However, at some point, we’ll want to render them in a more human-readable way. To do that, we have to represent them as a date/time object. The easiest way is to use the \u003ca href=\"https://github.com/Kotlin/kotlinx-datetime\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlinx-datetime\u003c/a\u003e library, so let’s add it.\u003c/p\u003e\u003cp id=\"eda9\"\u003eFirst, let’s declare the version and dependency in the \u003ca href=\"https://developer.android.com/build/migrate-to-catalogs\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGradle Version Catalog\u003c/a\u003e file. Open the \u003ccode\u003egradle/libs.versions.toml\u003c/code\u003e file and add the following definitions to the versions and libraries sections. Using a version catalog makes it easier to manage dependencies since they are all declared in one place. Perform a gradle sync to generate references the new dependency.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b5d6\"\u003e[versions]\u003cbr/\u003e...\u003cbr/\u003ekotlinx-datetime = \u0026#34;0.6.1\u0026#34;\u003cp\u003e[libraries]\u003cbr/\u003e...\u003cbr/\u003ekotlinx-datetime = { module = \u0026#34;org.jetbrains.kotlinx:kotlinx-datetime\u0026#34;, version.ref = \u0026#34;kotlinx-datetime\u0026#34; }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"00a8\"\u003eNext, we have to actually use the dependency. Open the \u003ccode\u003ecomposeApp/build.gradle.kts\u003c/code\u003e file and add the following line inside the \u003ccode\u003ecommonMain.dependencies {}\u003c/code\u003e block:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fe72\"\u003eimplementation(libs.kotlinx.datetime)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8924\"\u003eRun the gradle sync again and then go back to the \u003ccode\u003eArticle\u003c/code\u003e class we created earlier. Update the \u003ccode\u003epublishedAt\u003c/code\u003e and \u003ccode\u003eupdatedAt\u003c/code\u003e properties to be of type \u003ccode\u003eInstant\u003c/code\u003e instead of \u003ccode\u003eString\u003c/code\u003e. This will later allow us to parse the string timestamp from the response (\u003ccode\u003e\u0026#34;2025-01-04T02:04:26Z”\u003c/code\u003e) and convert it to an \u003ccode\u003eInstant\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"44f0\"\u003eimport kotlinx.datetime.Instant\u003cp\u003edata class Article(\u003cbr/\u003e    val id: Long,\u003cbr/\u003e    val title: String,\u003cbr/\u003e    val url: String,\u003cbr/\u003e    val imageUrl: String,\u003cbr/\u003e    val newsSite: String,\u003cbr/\u003e    val summary: String,\u003cbr/\u003e    val publishedAt: Instant,\u003cbr/\u003e    val updatedAt: Instant,\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"250f\"\u003eCreating the article list screen\u003c/h2\u003e\u003cp id=\"9034\"\u003eSince we’re building a news app, the main screen will show a list of articles. For now, we’re going to build the UI with mocked data.\u003c/p\u003e\u003cp id=\"627c\"\u003e\u003cstrong\u003eSwitching to Material3\u003cbr/\u003e\u003c/strong\u003eThe UI is currently built on top of the \u003ca href=\"https://developer.android.com/develop/ui/compose/designsystems/material\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMaterial 2 design\u003c/a\u003e. However, Google’s official recommendation is to use Material 3 for all new apps. We are going to migrate our app to use Material 3 before we start building our UI.\u003c/p\u003e\u003cp id=\"5eee\"\u003eOpen the \u003ccode\u003ecomposeApp/build.gradle.kts\u003c/code\u003e file and find the following line inside the \u003ccode\u003ecommonMain.dependencies {}\u003c/code\u003e block:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"82a7\"\u003eimplementation(compose.material)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dc8c\"\u003eThen simply replace it with this one:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c383\"\u003eimplementation(compose.material3)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bb2c\"\u003ePerform a gradle sync to apply the changes. If we try to run the app, we’ll notice that the build fails because of errors in the \u003ccode\u003eApp\u003c/code\u003e file. This is because our app is importing the Material2 versions of \u003ccode\u003eButton\u003c/code\u003e and \u003ccode\u003eText\u003c/code\u003e components, and not the Material3 versions. To fix this, open the \u003ccode\u003eApp.kt\u003c/code\u003e file and replace the following imports:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2819\"\u003eimport androidx.compose.material.Button\u003cbr/\u003eimport androidx.compose.material.MaterialTheme\u003cbr/\u003eimport androidx.compose.material.Text\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f7a1\"\u003ewith their Material3 equivalents:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"280b\"\u003eimport androidx.compose.material3.Button\u003cbr/\u003eimport androidx.compose.material3.MaterialTheme\u003cbr/\u003eimport androidx.compose.material3.Text\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d1d0\"\u003eAnd that’s it! If we run the app now, we will see that the button is in the Material3 style.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSample app using Material 3 design system, running on iOS.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"e160\"\u003e\u003cstrong\u003eRemoving old sample code\u003cbr/\u003e\u003c/strong\u003eSince we’re going to be building our own UI, let’s delete the old sample code from the wizard. It served its purpose of allowing us to examine the structure of a KMP app and how expect/actual declarations work.\u003c/p\u003e\u003cp id=\"d4b9\"\u003eStart by going to the \u003ccode\u003ecomposeApp/commonMain/App.kt\u003c/code\u003e and delete everything inside the \u003ccode\u003eMaterialTheme {}\u003c/code\u003e block and remove all unused imports. You should be left with this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"30dc\"\u003e@Composable\u003cbr/\u003e@Preview\u003cbr/\u003efun App() {\u003cbr/\u003e    MaterialTheme {\u003cp\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8505\"\u003eNext, let’s delete the \u003ccode\u003ecomposeApp/commonMain/Greeting\u003c/code\u003e and the \u003ccode\u003ecomposeApp/commonMain/Platform.kt\u003c/code\u003e files. Make sure to also delete the \u003ccode\u003ecomposeApp/androidMain/Platform.android.kt\u003c/code\u003e, \u003ccode\u003ecomposeApp/desktopMain/Platform.jvm.kt\u003c/code\u003e and \u003ccode\u003ecomposeApp/iOS/Platform.ios.kt\u003c/code\u003e files.\u003c/p\u003e\u003cp id=\"9c8d\"\u003eFinally, delete the \u003ccode\u003ecomposeApp/commonMain/composeResources/compose-multiplatform.xml\u003c/code\u003e file that displayed the Compose Multiplatform logo in the app.\u003c/p\u003e\u003cp id=\"1bab\"\u003eRunning the app should still work. You will just see an empty screen. We now have a blank slate to add our own code.\u003c/p\u003e\u003cp id=\"cad4\"\u003e\u003cstrong\u003eCreating a scaffold\u003cbr/\u003e\u003c/strong\u003eLet’s create the UI structure for our app. To do that, we’ll use a \u003ccode\u003eScaffold\u003c/code\u003e, which allows us to construct a typical Compose screen.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3373\"\u003e@Composable\u003cbr/\u003e@Preview\u003cbr/\u003efun App() {\u003cbr/\u003e    MaterialTheme {\u003cbr/\u003e        Scaffold { innerPadding -\u0026gt;\u003cbr/\u003e            // TODO Add content\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"be50\"\u003eWe want to have a top bar with the name of the app at the top that will also later serve as a way to navigate back from the article details screen. To do that, we can provide a \u003ccode\u003eTopAppBar\u003c/code\u003e composable to the \u003ccode\u003etopBar\u003c/code\u003e argument of the \u003ccode\u003eScaffold\u003c/code\u003e component. The \u003ccode\u003eTopAppBar\u003c/code\u003e composable expects a single \u003ccode\u003etitle\u003c/code\u003e composable, which is typically a \u003ccode\u003eText\u003c/code\u003e component.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"e4f2\"\u003eBecause many of the Material3 components are still considered experimental, we have to apply the \u003ccode\u003e@OptIn(ExperimentalMaterial3Api::class)\u003c/code\u003e annotation to our composable functions.\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"d7bd\"\u003e@OptIn(ExperimentalMaterial3Api::class)\u003cbr/\u003e@Composable\u003cbr/\u003e@Preview\u003cbr/\u003efun App() {\u003cbr/\u003e    MaterialTheme {\u003cbr/\u003e        Scaffold(\u003cbr/\u003e            topBar = {\u003cbr/\u003e                TopAppBar(\u003cbr/\u003e                    title = {\u003cbr/\u003e                        Text(text = \u0026#34;Space Flight News\u0026#34;)\u003cbr/\u003e                    }\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        ) { innerPadding -\u0026gt;\u003cbr/\u003e            // TODO\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"813b\"\u003eIf we run the app, we see that we now display the app title at the top of the screen.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eEmpty scaffold with top bar.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"9358\"\u003e\u003cstrong\u003eAdding a new app theme\u003cbr/\u003e\u003c/strong\u003eThis is great, but you’ll notice that our background is a shade of pink and no longer white as before. That is because we are using the default \u003ccode\u003eMaterialTheme\u003c/code\u003e theme and \u003ccode\u003eScaffold\u003c/code\u003e uses the \u003ccode\u003eMaterialTheme.colorScheme.background\u003c/code\u003e color for its \u003ccode\u003econtainerColor\u003c/code\u003e property.\u003c/p\u003e\u003cp id=\"662f\"\u003eWe could fix this by setting the \u003ccode\u003eScaffold.containerColor\u003c/code\u003e to \u003ccode\u003eColor.White\u003c/code\u003e. However, while that would fix the background color for this specific screen, we would need to do this everytime we use a \u003ccode\u003eScaffold\u003c/code\u003e or any composable that references the \u003ccode\u003eMaterialTheme.colorScheme.background\u003c/code\u003e color. Additionaly, the background would remain white even when dark theme is enabled.\u003c/p\u003e\u003cp id=\"1c6b\"\u003eInstead, to address this properly, let’s create a new \u003ccode\u003eAppTheme\u003c/code\u003e that we will use in our app instead of the default \u003ccode\u003eMaterialTheme\u003c/code\u003e. Create a new file \u003ccode\u003eTheme.kt\u003c/code\u003e inside the \u003ccode\u003espaceflightnews/ui/theme\u003c/code\u003e package and add a new \u003ccode\u003eAppTheme\u003c/code\u003e composable function:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a912\"\u003eprivate val LightColorScheme = lightColorScheme(\u003cbr/\u003e    background = Color.White,\u003cbr/\u003e    surface = Color.White,\u003cbr/\u003e)\u003cp\u003eprivate val DarkColorScheme = darkColorScheme()\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun AppTheme(\u003cbr/\u003e    darkTheme: Boolean = isSystemInDarkTheme(),\u003cbr/\u003e    content: @Composable() () -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    val colorScheme = if (darkTheme) DarkColorScheme else LightColorScheme\u003c/p\u003e\u003cp\u003e    MaterialTheme(\u003cbr/\u003e        colorScheme = colorScheme,\u003cbr/\u003e        content = content\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9b9a\"\u003eWe’ve first defined our own colors for the light color scheme and kept the default dark color scheme. Next, we pass those schemes to the default \u003ccode\u003eMaterialTheme\u003c/code\u003e. To use the new theme, we simply replace the \u003ccode\u003eMaterialTheme\u003c/code\u003e wrapper in the \u003ccode\u003eApp\u003c/code\u003e file with \u003ccode\u003eAppTheme\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"69b7\"\u003e@OptIn(ExperimentalMaterial3Api::class)\u003cbr/\u003e@Composable\u003cbr/\u003e@Preview\u003cbr/\u003efun App() {\u003cbr/\u003e    AppTheme {\u003cbr/\u003e        Scaffold(\u003cbr/\u003e            topBar = {\u003cbr/\u003e                TopAppBar(\u003cbr/\u003e                    title = {\u003cbr/\u003e                        Text(text = \u0026#34;Space Flight News\u0026#34;)\u003cbr/\u003e                    }\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        ) { innerPadding -\u0026gt;\u003cbr/\u003e            // TODO\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fbf1\"\u003eIf we run the app now, we see a white background. And switching to dark mode on the device correctly renders a black background.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eEmpty scaffold with correct background.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"a583\"\u003e\u003cstrong\u003eUsing string resources\u003cbr/\u003e\u003c/strong\u003eYou’ll notice we hardcoded the title of the app in the top bar, which is not a good practice. Resources like images and strings are usually placed in the \u003ccode\u003ecomposeResources\u003c/code\u003e folder and referenced in the code. This approach is similar to how we declare resources on Android and enables good localization support.\u003c/p\u003e\u003cp id=\"84be\"\u003eCreate a new \u003ccode\u003evalues\u003c/code\u003e folder inside the \u003ccode\u003ecomposeApp/commonMain/composeResources\u003c/code\u003e folder. Then, create a new file named \u003ccode\u003estrings.xml\u003c/code\u003e inside the new folder. Declare the app name like so:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"603b\"\u003e\u0026lt;resources\u0026gt;\u003cbr/\u003e    \u0026lt;string name=\u0026#34;app_name\u0026#34;\u0026gt;Space Flight News\u0026lt;/string\u0026gt;\u003cbr/\u003e\u0026lt;/resources\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"29f3\"\u003eTo be able to reference the newly added string from the code, we have to rebuild or re-run our project. This allows \u003ca href=\"https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-resources-usage.html#strings\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKMP to generate a static accessor\u003c/a\u003e for it. Now, we can go back to our \u003ccode\u003eTopAppBar\u003c/code\u003e composable in the \u003ccode\u003eApp\u003c/code\u003e file and replace the hard-coded string with \u003ccode\u003estringResource(Res.string.app_name)\u003c/code\u003e. We also need to import the \u003ccode\u003eRes\u003c/code\u003e and \u003ccode\u003eapp_name\u003c/code\u003e references.\u003c/p\u003e\u003cp id=\"0669\"\u003eYou can find more information on how to use multiplatform resources \u003ca href=\"https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-resources-usage.html#strings\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"238a\"\u003e\u003cstrong\u003eDefining a new article list screen\u003cbr/\u003e\u003c/strong\u003eWe’ve created our scaffold; now it’s time to create the landing screen that will show a list of articles. Let’s start by creating a new folder named \u003ccode\u003eui\u003c/code\u003e next to the existing \u003ccode\u003eApp.kt\u003c/code\u003e file that will contain all our UI-related code. Then, create a new file named \u003ccode\u003eArticleListScreen.kt\u003c/code\u003e inside it. It’s good practice to extract screen-level code to new files and not have a single large \u003ccode\u003eApp\u003c/code\u003e file.\u003c/p\u003e\u003cp id=\"18ae\"\u003eNext, we’re going to define a new Composable function named \u003ccode\u003eArticleListContent()\u003c/code\u003e inside the \u003ccode\u003eArticleListScreen.kt\u003c/code\u003e that will be responsible for rendering a list of articles it receives.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b6df\"\u003e@Composable\u003cbr/\u003eprivate fun ArticleListContent(\u003cbr/\u003e    articles: List\u0026lt;Article\u0026gt;,\u003cbr/\u003e){\u003cbr/\u003e    // TODO\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3263\"\u003eA scrollable list of items in Compose is typically represented with a \u003ccode\u003eLazyColumn\u003c/code\u003e component that is \u003ca href=\"https://developer.android.com/develop/ui/compose/lists\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eoptimized\u003c/a\u003e to only layout the items that are visible on screen. We are going to use it to show our list of articles.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8e9c\"\u003e@Composable\u003cbr/\u003eprivate fun ArticleListContent(\u003cbr/\u003e    articles: List\u0026lt;Article\u0026gt;,\u003cbr/\u003e){\u003cbr/\u003e    LazyColumn(\u003cbr/\u003e        contentPadding = PaddingValues(16.dp),\u003cbr/\u003e        verticalArrangement = Arrangement.spacedBy(16.dp),\u003cbr/\u003e        modifier = Modifier.fillMaxSize()\u003cbr/\u003e    ) {\u003cbr/\u003e        items(articles) { article -\u0026gt;\u003cbr/\u003e            // TODO\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"07fe\"\u003eNext, we need a Composable to draw an individual article. Let’s create a new composable function \u003ccode\u003eArticleItem()\u003c/code\u003e that accepts a single article and renders a \u003ccode\u003eCard\u003c/code\u003e with the article title, summary, and publication date.\u003c/p\u003e\u003cp id=\"8c77\"\u003eWe are using a \u003ccode\u003eColumn\u003c/code\u003e to vertically position the texts, with a \u003ccode\u003e8.dp\u003c/code\u003e spacing between them.\u003c/p\u003e\u003cp id=\"ef40\"\u003eThe publication date requires a bit of manual formatting to display it in a human-readable format. If you remember, we’ve represented the date as an \u003ccode\u003eInstant\u003c/code\u003e, which will print the date in the following format: “2023–01–02T23:40:57.120Z”. To format it as \u003ccode\u003eyyyy-MM-dd at HH:mm\u003c/code\u003e we have to first convert it to a \u003ccode\u003eLocalDateTime\u003c/code\u003e using the device timezone, then build our datetime pattern.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"427c\"\u003e@Composable\u003cbr/\u003eprivate fun ArticleItem(\u003cbr/\u003e    article: Article,\u003cbr/\u003e) {\u003cbr/\u003e    Card(\u003cbr/\u003e        modifier = Modifier.fillMaxWidth()\u003cbr/\u003e    ) {\u003cbr/\u003e        Column(\u003cbr/\u003e            verticalArrangement = Arrangement.spacedBy(8.dp),\u003cbr/\u003e            modifier = Modifier.fillMaxSize().padding(16.dp)\u003cbr/\u003e        ) {\u003cbr/\u003e            Text(\u003cbr/\u003e                text = article.title,\u003cbr/\u003e                style = MaterialTheme.typography.titleMedium,\u003cbr/\u003e                maxLines = 2,\u003cbr/\u003e                overflow = TextOverflow.Ellipsis,\u003cbr/\u003e            )\u003cp\u003e            Text(\u003cbr/\u003e                text = article.summary,\u003cbr/\u003e                style = MaterialTheme.typography.bodyMedium,\u003cbr/\u003e                maxLines = 2,\u003cbr/\u003e                overflow = TextOverflow.Ellipsis\u003cbr/\u003e            )\u003c/p\u003e\u003cp\u003e            Text(\u003cbr/\u003e                text = article.publishedAt.toLocalDateTime(TimeZone.currentSystemDefault()).format(\u003cbr/\u003e                    LocalDateTime.Format {\u003cbr/\u003e                        year()\u003cbr/\u003e                        char(\u0026#39;-\u0026#39;)\u003cbr/\u003e                        monthNumber()\u003cbr/\u003e                        char(\u0026#39;-\u0026#39;)\u003cbr/\u003e                        dayOfMonth()\u003c/p\u003e\u003cp\u003e                        chars(\u0026#34; at \u0026#34;)\u003c/p\u003e\u003cp\u003e                        hour()\u003cbr/\u003e                        char(\u0026#39;:\u0026#39;)\u003cbr/\u003e                        minute()\u003cbr/\u003e                    }),\u003cbr/\u003e                style = MaterialTheme.typography.bodySmall,\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"86ec\"\u003eNow that we have our article composable, we can go back to the \u003ccode\u003eArticleListContent\u003c/code\u003e composable and add it to the composition.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fd87\"\u003e@Composable\u003cbr/\u003eprivate fun ArticleListContent(\u003cbr/\u003e    articles: List\u0026lt;Article\u0026gt;,\u003cbr/\u003e) {\u003cbr/\u003e    LazyColumn(\u003cbr/\u003e        contentPadding = PaddingValues(16.dp),\u003cbr/\u003e        verticalArrangement = Arrangement.spacedBy(16.dp),\u003cbr/\u003e        modifier = Modifier.fillMaxSize()\u003cbr/\u003e    ) {\u003cbr/\u003e        items(articles) { article -\u0026gt;\u003cbr/\u003e            ArticleItem(\u003cbr/\u003e                article = article,\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fe89\"\u003eWe have our scrollable list, but we need to use it somewhere. Let’s create a new composable function at the top of the file named \u003ccode\u003eArticleListScreen()\u003c/code\u003e and add the \u003ccode\u003eArticleListContent()\u003c/code\u003e composable to the composition. There is one issue, though: we need to pass a list of articles to it, which we don’t have.\u003c/p\u003e\u003cp id=\"e9da\"\u003eWe’ll integrate fetching articles from a remote service in later parts. For now, we’ll simply hardcode a few articles to be able to run the app and visualize our UI.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d0a1\"\u003e@Composable\u003cbr/\u003einternal fun ArticleListScreen() {\u003cbr/\u003e    val articles = remember {\u003cbr/\u003e        listOf(\u003cbr/\u003e            Article(\u003cbr/\u003e                id = 28392,\u003cbr/\u003e                title = \u0026#34;SpaceX launches UAE’s Thuraya-4 mobile connectivity satellite\u0026#34;,\u003cbr/\u003e                url = \u0026#34;https://spacenews.com/spacex-launches-uaes-thuraya-4-mobile-connectivity-satellite/\u0026#34;,\u003cbr/\u003e                imageUrl = \u0026#34;https://i0.wp.com/spacenews.com/wp-content/uploads/2025/01/Thuraya-4-scaled.jpg?fit=1024%2C635\u0026amp;quality=89\u0026amp;ssl=1\u0026#34;,\u003cbr/\u003e                newsSite = \u0026#34;SpaceNews\u0026#34;,\u003cbr/\u003e                summary = \u0026#34;SpaceX launched the Thuraya-4 voice and data connectivity satellite Jan. 3 for Space42, the United Arab Emirates’ recently formed AI-powered space technology champion.\\r\\nThe post SpaceX launches UAE’s Thuraya-4 mobile connectivity satellite appeared first on SpaceNews.\u0026#34;,\u003cbr/\u003e                publishedAt = Instant.parse(\u0026#34;2025-01-04T02:04:26Z\u0026#34;),\u003cbr/\u003e                updatedAt = Instant.parse(\u0026#34;2025-01-04T08:35:00.677975Z\u0026#34;),\u003cbr/\u003e            ),\u003cbr/\u003e            Article(\u003cbr/\u003e                id = 28391,\u003cbr/\u003e                title = \u0026#34;NASA sees strong support for strategy to maintain continuous human presence in LEO\u0026#34;,\u003cbr/\u003e                url = \u0026#34;https://spacenews.com/nasa-sees-strong-support-for-strategy-to-maintain-continuous-human-presence-in-leo/\u0026#34;,\u003cbr/\u003e                imageUrl = \u0026#34;https://i0.wp.com/spacenews.com/wp-content/uploads/2024/12/54209298773_f912740933_k.jpg?fit=1024%2C683\u0026amp;quality=89\u0026amp;ssl=1\u0026#34;,\u003cbr/\u003e                newsSite = \u0026#34;SpaceNews\u0026#34;,\u003cbr/\u003e                summary = \u0026#34;NASA’s deputy administrator says there is nearly unanimous support for its LEO microgravity strategy that endorses keeping humans in orbit continuously.\\nThe post NASA sees strong support for strategy to maintain continuous human presence in LEO appeared first on SpaceNews.\u0026#34;,\u003cbr/\u003e                publishedAt = Instant.parse(\u0026#34;2025-01-03T23:54:59Z\u0026#34;),\u003cbr/\u003e                updatedAt = Instant.parse(\u0026#34;2025-01-04T00:00:25.390033Z\u0026#34;),\u003cbr/\u003e            ),\u003cbr/\u003e            Article(\u003cbr/\u003e                id = 28390,\u003cbr/\u003e                title = \u0026#34;SpaceX achieves record-breaking 2024, looks ahead to 2025\u0026#34;,\u003cbr/\u003e                url = \u0026#34;https://www.nasaspaceflight.com/2025/01/spacex-roundup-2024/\u0026#34;,\u003cbr/\u003e                imageUrl = \u0026#34;https://www.nasaspaceflight.com/wp-content/uploads/2025/01/SpaceX-in-2024-collage.png\u0026#34;,\u003cbr/\u003e                newsSite = \u0026#34;NASASpaceflight\u0026#34;,\u003cbr/\u003e                summary = \u0026#34;SpaceX is gearing up for another record-breaking year in 2025 after surpassing all previous record-breaking…\\nThe post SpaceX achieves record-breaking 2024, looks ahead to 2025 appeared first on NASASpaceFlight.com.\u0026#34;,\u003cbr/\u003e                publishedAt = Instant.parse(\u0026#34;2025-01-03T22:24:00Z\u0026#34;),\u003cbr/\u003e                updatedAt = Instant.parse(\u0026#34;2025-01-03T23:20:12.779937Z\u0026#34;),\u003cbr/\u003e            ),\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cp\u003e        ArticleListContent(\u003cbr/\u003e        articles = articles,\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6145\"\u003eFinally, let’s go back to the \u003ccode\u003eApp.kt\u003c/code\u003e file and add the \u003ccode\u003eArticleListScreen()\u003c/code\u003e composable to the \u003ccode\u003eScaffold\u003c/code\u003e content. We’re using a \u003ccode\u003eBox\u003c/code\u003e here to apply \u003ccode\u003einnerPadding\u003c/code\u003e, which makes sure that the content is not drawn underneath the system or navigation bars.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"329f\"\u003e@OptIn(ExperimentalMaterial3Api::class)\u003cbr/\u003e@Composable\u003cbr/\u003e@Preview\u003cbr/\u003efun App() {\u003cbr/\u003e    AppTheme {\u003cbr/\u003e        Scaffold(\u003cbr/\u003e            topBar = {\u003cbr/\u003e                TopAppBar(\u003cbr/\u003e                    title = {\u003cbr/\u003e                        Text(text = stringResource(Res.string.app_name))\u003cbr/\u003e                    }\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        ) { innerPadding -\u0026gt;\u003cbr/\u003e            Box(modifier = Modifier.padding(innerPadding)) {\u003cbr/\u003e                ArticleListScreen()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0ddc\"\u003eAnd that’s it! Let’s run the app and see the result.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eFinal app running on Android, iOS, and Desktop.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"d9b7\"\u003eBonus challenge\u003c/h2\u003e\u003cp id=\"dcc3\"\u003eWouldn’t it be great to add visualization to the app and display a cover image next to each article? It certainly would. The challenge is for you to add loading and displaying of images in the app from an URL.\u003c/p\u003e\u003cp id=\"1c1b\"\u003eYou can use the \u003ca href=\"https://coil-kt.github.io/coil/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoil\u003c/a\u003e image loading library to simplify the process. If you get stuck, feel free to follow this guide that I’ve prepared: \u003ca href=\"https://medium.com/@domen.lanisnik/loading-images-with-coil-in-compose-multiplatform-4c94e16a06d7\" rel=\"noopener\"\u003eLoading Images with Coil in Compose Multiplatform\u003c/a\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eUpdated app with cover images for each article.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"fc13\"\u003e\u003cstrong\u003eConclusion\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"5d9d\"\u003eIf you followed all the way to the end, congratulations and thank you! This is the end of the first part of the series on Kotlin Multiplatform and Compose Multiplatform. We’ve built a simple (for now) news app, and during the process, we took a look at how:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9af1\"\u003eto create a new KMP project with shared UI using Compose Multiplatform,\u003c/li\u003e\u003cli id=\"6fcb\"\u003eto run the app on different platforms,\u003c/li\u003e\u003cli id=\"9c52\"\u003ethe project is structured with shared modules, source sets, and a separate iOS project,\u003c/li\u003e\u003cli id=\"d0d3\"\u003eto enable the Material3 design system and create a custom theme,\u003c/li\u003e\u003cli id=\"3d33\"\u003eto add new string resources,\u003c/li\u003e\u003cli id=\"a2f8\"\u003eto use the \u003ccode\u003ekotlix-datetime\u003c/code\u003e library,\u003c/li\u003e\u003cli id=\"b9ee\"\u003eand to build and display a list of items with Compose.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"12b9\"\u003eIn the next part of the series, we are going to load the most recent news from the API service. To do that, we will add the following to our project:\u003c/p\u003e\u003cul\u003e\u003cli id=\"87ee\"\u003ea shared ViewModel library to follow MVVM architecture on all platforms,\u003c/li\u003e\u003cli id=\"2c52\"\u003eKtor network library to execute network requests using Kotlin coroutines,\u003c/li\u003e\u003cli id=\"0b5d\"\u003eCoil image loading library to load article images from the network,\u003c/li\u003e\u003cli id=\"84ff\"\u003eand Koin dependency injection framework to tie everything together.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"42eb\"\u003e\u003cstrong\u003eStay tuned!\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "32 min read",
  "publishedTime": "2025-02-11T19:59:46.736Z",
  "modifiedTime": null
}
