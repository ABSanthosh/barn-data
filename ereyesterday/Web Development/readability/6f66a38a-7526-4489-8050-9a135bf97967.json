{
  "id": "6f66a38a-7526-4489-8050-9a135bf97967",
  "title": "Fancy Menu Navigation Using Anchor Positioning",
  "link": "https://css-tricks.com/fancy-menu-navigation-using-anchor-positioning/",
  "description": "Anchor positioning can be great for little interactive effects — as Temani Afif shows off with this clever idea for a menu hover. Fancy Menu Navigation Using Anchor Positioning originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Temani Afif",
  "published": "Fri, 17 Jan 2025 14:57:39 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "anchor positioning",
    "Links \u0026 URLs"
  ],
  "byline": "Temani Afif",
  "length": 10047,
  "excerpt": "Anchor positioning can be great for little interactive effects — as Temani Afif shows off with this clever idea for a menu hover.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "You have for sure heard about the new CSS Anchor Positioning, right? It’s a feature that allows you to link any element from the page to another one, i.e., the anchor. It’s useful for all the tooltip stuff, but it can also create a lot of other nice effects. In this article, we will study menu navigation where I rely on anchor positioning to create a nice hover effect on links. Cool, right? We have a sliding effect where the blue rectangle adjusts to fit perfectly with the text content over a nice transition. If you are new to anchor positioning, this example is perfect for you because it’s simple and allows you to discover the basics of this new feature. We will also study another example so stay until the end! Note that only Chromium-based browsers fully support anchor positioning at the time I’m writing this. You’ll want to view the demos in a browser like Chrome or Edge until the feature is more widely supported in other browsers. The initial configuration Let’s start with the HTML structure which is nothing but a nav element containing an unordered list of links: \u003cnav\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"#\"\u003eHome\u003c/a\u003e\u003c/li\u003e \u003cli class=\"active\"\u003e\u003ca href=\"#\"\u003eAbout\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003eProjects\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003eBlog\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003eContact\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e We will not spend too much time explaining this structure because it can be different if your use case is different. Simply ensure the semantic is relevant to what you are trying to do. As for the CSS part, we will start with some basic styling to create a horizontal menu navigation. ul { padding: 0; margin: 0; list-style: none; display: flex; gap: .5rem; font-size: 2.2rem; } ul li a { color: #000; text-decoration: none; font-weight: 900; line-height: 1.5; padding-inline: .2em; display: block; } Nothing fancy so far. We remove some default styling and use Flexbox to align the elements horizontally. Sliding effect First off, let’s understand how the effect works. At first glance, it looks like we have one rectangle that shrinks to a small height, moves to the hovered element, and then grows to full height. That’s the visual effect, but in reality, more than one element is involved! Here is the first demo where I am using different colors to better see what is happening. Each menu item has its own “element” that shrinks or grows. Then we have a common “element” (the one in red) that slides between the different menu items. The first effect is done using a background animation and the second one is where anchor positioning comes into play! The background animation We will animate the height of a CSS gradient for this first part: /* 1 */ ul li { background: conic-gradient(lightblue 0 0) bottom/100% 0% no-repeat; transition: .2s; } /* 2 */ ul li:is(:hover,.active) { background-size: 100% 100%; transition: .2s .2s; } /* 3 */ ul:has(li:hover) li.active:not(:hover) { background-size: 100% 0%; transition: .2s; } We’ve defined a gradient with a 100% width and 0% height, placed at the bottom. The gradient syntax may look strange, but it’s the shortest one that allows me to have a single-color gradient. Related: “How to correctly define a one-color gradient” Then, if the menu item is hovered or has the .active class, we make the height equal to 100%. Note the use of the delay here to make sure the growing happens after the shrinking. Finally, we need to handle a special case with the .active item. If we hover any item (that is not the active one), then the .active item gets the shirking effect (the gradient height is equal to 0%). That’s the purpose of the third selector in the code. Our first animation is done! Notice how the growing begins after the shrinking completes because of the delay we defined in the second selector. The anchor positioning animation The first animation was quite easy because each item had its own background animation, meaning we didn’t have to care about the text content since the background automatically fills the whole space. We will use one element for the second animation that slides between all the menu items while adapting its width to fit the text of each item. This is where anchor positioning can help us. Let’s start with the following code: ul:before { content:\"\"; position: absolute; position-anchor: --li; background: red; transition: .2s; } ul li:is(:hover, .active) { anchor-name: --li; } ul:has(li:hover) li.active:not(:hover) { anchor-name: none; } To avoid adding an extra element, I will prefer using a pseudo-element on the ul. It should be absolutely-positioned and we will rely on two properties to activate the anchor positioning. We define the anchor with the anchor-name property. When a menu item is hovered or has the .active class, it becomes the anchor element. We also have to remove the anchor from the .active item if another item is in a hovered state (hence, the last selector in the code). In other words, only one anchor is defined at a time. Then we use the position-anchor property to link the pseudo-element to the anchor. Notice how both use the same notation --li. It’s similar to how, for example, we define @keyframes with a specific name and later use it inside an animation property. Keep in mind that you have to use the \u003cdashed-indent\u003e syntax, meaning the name must always start with two dashes (--). The pseudo-element is correctly placed but nothing is visible because we didn’t define any dimension! Let’s add the following code: ul:before { bottom: anchor(bottom); left: anchor(left); right: anchor(right); height: .2em; } The height property is trivial but the anchor() is a newcomer. Here’s how Juan Diego describes it in the Almanac: The CSS anchor() function takes an anchor element’s side and resolves to the \u003clength\u003e where it is positioned. It can only be used in inset properties (e.g. top, bottom, bottom, left, right, etc.), normally to place an absolute-positioned element relative to an anchor. Let’s check the MDN page as well: The anchor() CSS function can be used within an anchor-positioned element’s inset property values, returning a length value relative to the position of the edges of its associated anchor element. Usually, we use left: 0 to place an absolute element at the left edge of its containing block (i.e., the nearest ancestor having position: relative). The left: anchor(left) will do the same but instead of the containing block, it will consider the associated anchor element. That’s all — we are done! Hover the menu items in the below demo and see how the pseudo-element slides between them. Each time you hover over a menu item it becomes the new anchor for the pseudo-element (the ul:before). This also means that the anchor(...) values will change creating the sliding effect! Let’s not forget the use of the transition which is important otherwise, we will have an abrupt change. We can also write the code differently like this: ul:before { content:\"\"; position: absolute; inset: auto anchor(right, --li) anchor(bottom, --li) anchor(left, --li); height: .2em; background: red; transition: .2s; } In other words, we can rely on the inset shorthand instead of using physical properties like left, right, and bottom, and instead of defining position-anchor, we can include the anchor’s name inside the anchor() function. We are repeating the same name three times which is probably not optimal here but in some situations, you may want your element to consider multiple anchors, and in such cases, this syntax will make sense. Combining both effects Now, we combine both effects and, tada, the illusion is perfect! Pay attention to the transition values where the delay is important: ul:before { transition: .2s .2s; } ul li { transition: .2s; } ul li:is(:hover,.active) { transition: .2s .4s; } ul:has(li:hover) li.active:not(:hover) { transition: .2s; } We have a sequence of three animations — shrink the height of the gradient, slide the pseudo-element, and grow the height of the gradient — so we need to have delays between them to pull everything together. That’s why for the sliding of the pseudo-element we have a delay equal to the duration of one animation (transition: .2 .2s) and for the growing part the delay is equal to twice the duration (transition: .2s .4s). Bouncy effect? Why not?! Let’s try another fancy animation in which the highlight rectangle morphs into a small circle, jumps to the next item, and transforms back into a rectangle again! I won’t explain too much for this example as it’s your homework to dissect the code! I’ll offer a few hints so you can unpack what’s happening. Like the previous effect, we have a combination of two animations. For the first one, I will use the pseudo-element of each menu item where I will adjust the dimension and the border-radius to simulate the morphing. For the second animation, I will use the ul pseudo-element to create a small circle that I move between the menu items. Here is another version of the demo with different coloration and a slower transition to better visualize each animation: The tricky part is the jumping effect where I am using a strange cubic-bezier() but I have a detailed article where I explain the technique in my CSS-Tricks article “Advanced CSS Animation Using cubic-bezier()”. Conclusion I hope you enjoyed this little experimentation using the anchor positioning feature. We only looked at three properties/values but it’s enough to prepare you for this new feature. The anchor-name and position-anchor properties are the mandatory pieces for linking one element (often called a “target” element in this context) to another element (what we call an “anchor” element in this context). From there, you have the anchor() function to control the position. Related: CSS Anchor Positioning Guide",
  "image": "https://css-tricks.com/wp-json/social-image-generator/v1/image/383518",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eYou have for sure heard about the new \u003ca href=\"https://css-tricks.com/css-anchor-positioning-guide/\"\u003eCSS Anchor Positioning\u003c/a\u003e, right? It’s a feature that allows you to link any element from the page to another one, i.e., the anchor. It’s useful \u003ca href=\"https://css-tricks.com/the-little-triangle-in-the-tooltip/\"\u003efor all the tooltip stuff\u003c/a\u003e, but it can also create a lot of other nice effects.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this article, we will study menu navigation where I rely on anchor positioning to create a nice hover effect on links.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eCool, right? We have a sliding effect where the blue rectangle adjusts to fit perfectly with the text content over a nice transition. If you are new to anchor positioning, this example is perfect for you because it’s simple and allows you to discover the basics of this new feature. We will also study another example so stay until the end!\u003c/p\u003e\n\n\n\n\u003cp\u003eNote that only Chromium-based browsers fully support \u003ca href=\"https://css-tricks.com/css-anchor-positioning-guide/\"\u003eanchor positioning\u003c/a\u003e at the time I’m writing this. You’ll want to view the demos in a browser like Chrome or Edge until the feature is more widely supported in other browsers.\u003c/p\u003e\n\n\n\n\n\u003cbaseline-status featureid=\"anchor-positioning\"\u003e\u003c/baseline-status\u003e\n\n\n\u003ch3 id=\"the-initial-configuration\"\u003eThe initial configuration\u003c/h3\u003e\n\n\n\u003cp\u003eLet’s start with the HTML structure which is nothing but a \u003ccode\u003enav\u003c/code\u003e element containing an unordered list of links:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;nav\u0026gt;\n  \u0026lt;ul\u0026gt;\n    \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n    \u0026lt;li class=\u0026#34;active\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n    \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Projects\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n    \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Blog\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n    \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Contact\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n\u0026lt;/nav\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe will not spend too much time explaining this structure because it can be different if your use case is different. Simply ensure the semantic is relevant to what you are trying to do. As for the CSS part, we will start with some basic styling to create a horizontal menu navigation.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eul {\n  padding: 0;\n  margin: 0;\n  list-style: none;\n  display: flex;\n  gap: .5rem;\n  font-size: 2.2rem;\n}\n\nul li a {\n  color: #000;\n  text-decoration: none;\n  font-weight: 900;\n  line-height: 1.5;\n  padding-inline: .2em;\n  display: block;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNothing fancy so far. We remove some default styling and use Flexbox to align the elements horizontally.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"sliding-effect\"\u003eSliding effect\u003c/h3\u003e\n\n\n\u003cp\u003eFirst off, let’s understand how the effect works. At first glance, it looks like we have one rectangle that shrinks to a small height, moves to the hovered element, and then grows to full height. That’s the visual effect, but in reality, more than one element is involved!\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is the first demo where I am using different colors to better see what is happening.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eEach menu item has its own “element” that shrinks or grows. Then we have a common “element” (the one in red) that slides between the different menu items. The first effect is done using a background animation and the second one is where anchor positioning comes into play!\u003c/p\u003e\n\n\n\u003ch4 id=\"the-background-animation\"\u003eThe background animation\u003c/h4\u003e\n\n\n\u003cp\u003eWe will animate the height of a CSS gradient for this first part:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* 1 */\nul li {\n  background: \n    conic-gradient(lightblue 0 0)\n    bottom/100% 0% no-repeat;\n  transition: .2s;\n}\n\n/* 2 */\nul li:is(:hover,.active) {\n  background-size: 100% 100%;\n  transition: .2s .2s;\n}\n\n/* 3 */\nul:has(li:hover) li.active:not(:hover) {\n  background-size: 100% 0%;\n  transition: .2s;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe’ve defined a gradient with a \u003ccode\u003e100%\u003c/code\u003e width and \u003ccode\u003e0%\u003c/code\u003e height, placed at the bottom. The gradient syntax may look strange, but it’s the shortest one that allows me to have a single-color gradient.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eRelated:\u003c/strong\u003e \u003ca href=\"https://css-tip.com/one-color-gradient/\" rel=\"noopener\"\u003e“How to correctly define a one-color gradient”\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eThen, if the menu item is hovered or has the \u003ccode\u003e.active\u003c/code\u003e class, we make the height equal to \u003ccode\u003e100%\u003c/code\u003e. Note the use of the delay here to make sure the growing happens after the shrinking.\u003c/p\u003e\n\n\n\n\u003cp\u003eFinally, we need to handle a special case with the \u003ccode\u003e.active\u003c/code\u003e item. If we hover any item (that is \u003cem\u003enot\u003c/em\u003e the active one), then the \u003ccode\u003e.active\u003c/code\u003e item gets the shirking effect (the gradient height is equal to \u003ccode\u003e0%\u003c/code\u003e). That’s the purpose of the third selector in the code.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eOur first animation is done! Notice how the growing begins \u003cem\u003eafter\u003c/em\u003e the shrinking completes because of the delay we defined in the second selector.\u003c/p\u003e\n\n\n\u003ch4 id=\"the-anchor-positioning-animation\"\u003eThe anchor positioning animation\u003c/h4\u003e\n\n\n\u003cp\u003eThe first animation was quite easy because each item had its own background animation, meaning we didn’t have to care about the text content since the background automatically fills the whole space.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe will use one element for the second animation that slides between all the menu items while adapting its width to fit the text of each item. This is where anchor positioning can help us.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s start with the following code:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eul:before {\n  content:\u0026#34;\u0026#34;;\n  position: absolute;\n  position-anchor: --li;\n  background: red;\n  transition: .2s;\n}\n\nul li:is(:hover, .active) {\n  anchor-name: --li;\n}\n\nul:has(li:hover) li.active:not(:hover) {\n  anchor-name: none;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTo avoid adding an extra element, I will prefer using a pseudo-element on the \u003ccode\u003eul\u003c/code\u003e. It should be absolutely-positioned and we will rely on two properties to activate the anchor positioning.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe define the anchor with the \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/properties/a/anchor-name/\"\u003eanchor-name\u003c/a\u003e\u003c/code\u003e property. When a menu item is hovered or has the \u003ccode\u003e.active\u003c/code\u003e class, it becomes the anchor element. We also have to remove the anchor from the \u003ccode\u003e.active\u003c/code\u003e item if another item is in a hovered state (hence, the last selector in the code). In other words, only one anchor is defined at a time.\u003c/p\u003e\n\n\n\n\u003cp\u003eThen we use the \u003ca href=\"https://css-tricks.com/almanac/properties/p/position-anchor/\"\u003e\u003ccode\u003eposition-anchor\u003c/code\u003e\u003c/a\u003e property to link the pseudo-element to the anchor. Notice how both use the same notation \u003ccode\u003e--li\u003c/code\u003e. It’s similar to how, for example, we define \u003ccode\u003e@keyframes\u003c/code\u003e with a specific name and later use it inside an \u003ccode\u003eanimation\u003c/code\u003e property. Keep in mind that you have to use \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/dashed-ident\" rel=\"noopener\"\u003ethe \u003ccode\u003e\u0026lt;dashed-indent\u0026gt;\u003c/code\u003e syntax\u003c/a\u003e, meaning the name must always start with two dashes (\u003ccode\u003e--\u003c/code\u003e).\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThe pseudo-element is correctly placed but nothing is visible because we didn’t define any dimension! Let’s add the following code:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eul:before {\n  bottom: anchor(bottom);\n  left: anchor(left);\n  right: anchor(right);\n  height: .2em;  \n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eheight\u003c/code\u003e property is trivial but the \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/functions/a/anchor/\"\u003eanchor()\u003c/a\u003e\u003c/code\u003e is a newcomer. Here’s how Juan Diego describes it in the Almanac:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eThe CSS \u003ccode\u003eanchor()\u003c/code\u003e function takes an \u003ca href=\"https://css-tricks.com/almanac/properties/p/position-anchor/\"\u003eanchor element’s\u003c/a\u003e side and resolves to the \u003ccode\u003e\u0026lt;length\u0026gt;\u003c/code\u003e where it is positioned. It can only be used in inset properties (e.g. \u003ccode\u003etop\u003c/code\u003e, \u003ccode\u003ebottom\u003c/code\u003e, \u003ccode\u003ebottom\u003c/code\u003e, \u003ccode\u003eleft\u003c/code\u003e, \u003ccode\u003eright\u003c/code\u003e, etc.), normally to place an absolute-positioned element relative to an anchor.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eLet’s check \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/anchor\" rel=\"noopener\"\u003ethe MDN page\u003c/a\u003e as well:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eThe \u003ccode\u003eanchor()\u003c/code\u003e \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS\" rel=\"noopener\"\u003eCSS\u003c/a\u003e \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions\" rel=\"noopener\"\u003efunction\u003c/a\u003e can be used within an anchor-positioned element’s \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/anchor#properties_that_accept_anchor_function_values\" rel=\"noopener\"\u003einset property\u003c/a\u003e values, returning a length value relative to the position of the edges of its associated anchor element.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eUsually, we use \u003ccode\u003eleft: 0\u003c/code\u003e to place an absolute element at the left edge of its containing block (i.e., the nearest ancestor having \u003ccode\u003eposition: relative\u003c/code\u003e). The \u003ccode\u003eleft: anchor(left)\u003c/code\u003e will do the same but instead of the containing block, it will consider the associated anchor element.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat’s all — we are done! Hover the menu items in the below demo and see how the pseudo-element slides between them.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eEach time you hover over a menu item it becomes the new anchor for the pseudo-element (the \u003ccode\u003eul:before\u003c/code\u003e). This also means that the \u003ccode\u003eanchor(...)\u003c/code\u003e values will change creating the sliding effect! Let’s not forget the use of the transition which is important otherwise, we will have an abrupt change.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can also write the code differently like this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eul:before {\n  content:\u0026#34;\u0026#34;;\n  position: absolute;\n  inset: auto anchor(right, --li) anchor(bottom, --li) anchor(left, --li);\n  height: .2em;  \n  background: red;\n  transition: .2s;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn other words, we can rely on the \u003ccode\u003einset\u003c/code\u003e shorthand instead of using physical properties like \u003ccode\u003eleft\u003c/code\u003e, \u003ccode\u003eright\u003c/code\u003e, and \u003ccode\u003ebottom\u003c/code\u003e, and instead of defining \u003ccode\u003eposition-anchor\u003c/code\u003e, we can include the anchor’s name inside the \u003ccode\u003eanchor()\u003c/code\u003e function. We are repeating the same name three times which is probably not optimal here but in some situations, you may want your element to consider multiple anchors, and in such cases, this syntax will make sense.\u003c/p\u003e\n\n\n\u003ch4 id=\"combining-both-effects\"\u003eCombining both effects\u003c/h4\u003e\n\n\n\u003cp\u003eNow, we combine both effects and, \u003cem\u003etada\u003c/em\u003e, the illusion is perfect!\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003ePay attention to the transition values where the delay is important:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"2,10\"\u003e\u003ccode markup=\"tt\"\u003eul:before {\n  transition: .2s .2s;\n}\n\nul li {\n  transition: .2s;\n}\n\nul li:is(:hover,.active) {\n  transition: .2s .4s;\n}\n\nul:has(li:hover) li.active:not(:hover) {\n  transition: .2s;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe have a sequence of three animations — shrink the height of the gradient, slide the pseudo-element, and grow the height of the gradient — so we need to have delays between them to pull everything together. That’s why for the sliding of the pseudo-element we have a delay equal to the duration of one animation (\u003ccode\u003etransition: .2 .2s\u003c/code\u003e) and for the growing part the delay is equal to twice the duration (\u003ccode\u003etransition: .2s .4s\u003c/code\u003e).\u003c/p\u003e\n\n\n\u003ch3 id=\"bouncy-effect-why-not-\"\u003eBouncy effect? Why not?!\u003c/h3\u003e\n\n\n\u003cp\u003eLet’s try another fancy animation in which the highlight rectangle morphs into a small circle, jumps to the next item, and transforms back into a rectangle again!\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eI won’t explain too much for this example as it’s your homework to dissect the code! I’ll offer a few hints so you can unpack what’s happening.\u003c/p\u003e\n\n\n\n\u003cp\u003eLike the previous effect, we have a combination of two animations. For the first one, I will use the pseudo-element of each menu item where I will adjust the dimension and the \u003ccode\u003eborder-radius\u003c/code\u003e to simulate the morphing. For the second animation, I will use the \u003ccode\u003eul\u003c/code\u003e pseudo-element to create a small circle that I move between the menu items.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is another version of the demo with different coloration and a slower transition to better visualize each animation:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThe tricky part is the jumping effect where I am using a strange \u003ccode\u003ecubic-bezier()\u003c/code\u003e but I have a detailed article where I explain the technique in my CSS-Tricks article \u003ca href=\"https://css-tricks.com/advanced-css-animation-using-cubic-bezier/\"\u003e“Advanced CSS Animation Using \u003ccode\u003ecubic-bezier()\u003c/code\u003e”\u003c/a\u003e.\u003c/p\u003e\n\n\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\n\n\u003cp\u003eI hope you enjoyed this little experimentation using the anchor positioning feature. We only looked at three properties/values but it’s enough to prepare you for this new feature. The \u003ccode\u003eanchor-name\u003c/code\u003e and \u003ccode\u003eposition-anchor\u003c/code\u003e properties are the mandatory pieces for linking one element (often called a “target” element in this context) to another element (what we call an “anchor” element in this context). From there, you have the \u003ccode\u003eanchor()\u003c/code\u003e function to control the position.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eRelated:\u003c/strong\u003e \u003ca href=\"https://css-tricks.com/css-anchor-positioning-guide/\"\u003eCSS Anchor Positioning Guide\u003c/a\u003e\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-01-17T07:57:39-07:00",
  "modifiedTime": "2025-01-17T07:57:52-07:00"
}
