{
  "id": "9a88e30b-eb1f-4481-bbb6-e3ee90247b59",
  "title": "So, You Want to Give Up CSS Pre- and Post-Processors…",
  "link": "https://css-tricks.com/so-you-want-to-give-up-css-pre-and-post-processors/",
  "description": "There was once upon a time when native CSS lacked many essential features, leaving developers to come up with all sorts of ways to make CSS easier to write over the years. So, You Want to Give Up CSS Pre- and Post-Processors… originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Zell Liew",
  "published": "Thu, 17 Apr 2025 12:38:05 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "css preprocessors",
    "postcss",
    "tailwind"
  ],
  "byline": "Zell Liew",
  "length": 7029,
  "excerpt": "There was once upon a time when native CSS lacked many essential features, leaving developers to come up with all sorts of ways to make CSS easier to write over the years.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "There was once upon a time when native CSS lacked many essential features, leaving developers to come up with all sorts of ways to make CSS easier to write over the years. These ways can mostly be categorized into two groups: Pre-processors Post-processors Pre-processors include tools like Sass, Less, and Stylus. Like what the category’s name suggests, these tools let you write CSS in their syntax before compiling your code into valid CSS. Post-processors work the other way — you write non-valid CSS syntax into a CSS file, then post-processors will change those values into valid CSS. There are two major post-processors today: PostCSS LightningCSS PostCSS is the largest kid on the block while Lightning CSS is a new and noteworthy one. We’ll talk about them both in a bit. I think post-processors have won the compiling game Post-processors have always been on the verge of winning since PostCSS has always been a necessary tool in the toolchain. The most obvious (and most useful) PostCSS plugin for a long time is Autoprefixer — it creates vendor prefixes for you so you don’t have to deal with them. /* Input */ .selector { transform: /* ... */; } .selector { -webkit-transform: /* ... */; transform: /* ... */; } Arguably, we don’t need Autoprefixer much today because browsers are more interopable, but nobody wants to go without Autoprefixer because it eliminates our worries about vendor prefixing. What has really tilted the balance towards post-processors includes: Native CSS gaining essential features Tailwind removing support for pre-processors Lightning CSS Let me expand on each of these. Native CSS gaining essential features CSS pre-processors existed in the first place because native CSS lacked features that were critical for most developers, including: CSS variables Nesting capabilities Allowing users to break CSS into multiple files without additional fetch requests Conditionals like if and for Mixins and functions Native CSS has progressed a lot over the years. It has gained great browser support for the first two features: CSS Variables Nesting With just these two features, I suspect a majority of CSS users won’t even need to fire up pre-processors or post-processors. What’s more, The if() function is coming to CSS in the future too. But, for the rest of us who needs to make maintenance and loading performance a priority, we still need the third feature — the ability to break CSS into multiple files. This can be done with Sass’s use feature or PostCSS’s import feature (provided by the postcss-import plugin). PostCSS also contains plugins that can help you create conditionals, mixins, and functions should you need them. Although, from my experience, mixins can be better replaced with Tailwind’s @apply feature. This brings us to Tailwind. Tailwind removing support for pre-processors Tailwind 4 has officially removed support for pre-processors. From Tailwind’s documentation: Tailwind CSS v4.0 is a full-featured CSS build tool designed for a specific workflow, and is not designed to be used with CSS pre-processors like Sass, Less, or Stylus. Think of Tailwind CSS itself as your pre-processor — you shouldn’t use Tailwind with Sass for the same reason you wouldn’t use Sass with Stylus. Since Tailwind is designed for modern browsers, you actually don’t need a pre-processor for things like nesting or variables, and Tailwind itself will do things like bundle your imports and add vendor prefixes. If you included Tailwind 4 via its most direct installation method, you won’t be able to use pre-processors with Tailwind. @import `tailwindcss` That’s because this one import statement makes Tailwind incompatible with Sass, Less, and Stylus. But, (fortunately), Sass lets you import CSS files if the imported file contains the .css extension. So, if you wish to use Tailwind with Sass, you can. But it’s just going to be a little bit wordier. @layer theme, base, components, utilities; @import \"tailwindcss/theme.css\" layer(theme); @import \"tailwindcss/preflight.css\" layer(base); @import \"tailwindcss/utilities.css\" layer(utilities); Personally, I dislike Tailwind’s preflight styles so I exclude them from my files. @layer theme, base, components, utilities; @import 'tailwindcss/theme.css' layer(theme); @import 'tailwindcss/utilities.css' layer(utilities); Either way, many people won’t know you can continue to use pre-processors with Tailwind. Because of this, I suspect pre-processors will get less popular as Tailwind gains more momentum. Now, beneath Tailwind is a CSS post-processor called Lightning CSS, so this brings us to talking about that. Lightning CSS Lightning CSS is a post-processor can do many things that a modern developer needs — so it replaces most of the PostCSS tool chain including: postcss-import postcss-preset-env autoprefixer Besides having a decent set of built-in features, it wins over PostCSS because it’s incredibly fast. Lightning CSS is over 100 times faster than comparable JavaScript-based tools. It can minify over 2.7 million lines of code per second on a single thread. Speed helps Lightning CSS win since many developers are speed junkies who don’t mind switching tools to achieve reduced compile times. But, Lightning CSS also wins because it has great distribution. It can be used directly as a Vite plugin (that many frameworks support). Ryan Trimble has a step-by-step article on setting it up with Vite if you need help. // vite.config.mjs export default { css: { transformer: 'lightningcss' }, build: { cssMinify: 'lightningcss' } }; If you need other PostCSS plugins, you can also include that as part of the PostCSS tool chain. // postcss.config.js // Import other plugins... import lightning from 'postcss-lightningcss' export default { plugins: [lightning, /* Other plugins */], } Many well-known developers have switched to Lightning CSS and didn’t look back. Chris Coyier says he’ll use a “super basic CSS processing setup” so you can be assured that you are probably not stepping in any toes if you wish to switch to Lightning, too. If you wanna ditch pre-processors today You’ll need to check the features you need. Native CSS is enough for you if you need: CSS Variables Nesting capabilities Lightning CSS is enough for you if you need: CSS Variables Nesting capabilities import statements to break CSS into multiple files Tailwind (with @apply) is enough for you if you need: all of the above Mixins If you still need conditionals like if, for and other functions, it’s still best to stick with Sass for now. (I’ve tried and encountered interoperability issues between postcss-for and Lightning CSS that I shall not go into details here). That’s all I want to share with you today. I hope it helps you if you have been thinking about your CSS toolchain.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2019/09/sass-logo.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eThere was once upon a time when native CSS lacked many essential features, leaving developers to come up with all sorts of ways to make CSS easier to write over the years.\u003c/p\u003e\n\n\n\n\u003cp\u003eThese ways can mostly be categorized into two groups:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003ePre-processors\u003c/li\u003e\n\n\n\n\u003cli\u003ePost-processors\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003ePre-processors include tools like Sass, Less, and Stylus. Like what the category’s name suggests, these tools let you write CSS in their syntax before compiling your code into valid CSS.\u003c/p\u003e\n\n\n\n\u003cp\u003ePost-processors work the other way — you write non-valid CSS syntax into a CSS file, then post-processors will change those values into valid CSS.\u003c/p\u003e\n\n\n\n\u003cp\u003eThere are two major post-processors today:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003ePostCSS\u003c/li\u003e\n\n\n\n\u003cli\u003eLightningCSS\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003ePostCSS is the largest kid on the block while Lightning CSS is a new and noteworthy one. We’ll talk about them both in a bit.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"i-think-post-processors-have-won-the-compiling-game\"\u003eI think post-processors have won the compiling game\u003c/h3\u003e\n\n\n\u003cp\u003ePost-processors have always been on the verge of winning since PostCSS has always been a necessary tool in the toolchain.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe most obvious (and most useful) PostCSS plugin for a long time is Autoprefixer — it creates vendor prefixes for you so you don’t have to deal with them.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Input */\n.selector {\n  transform: /* ... */; \n}\n\n.selector {\n  -webkit-transform: /* ... */;\n  transform: /* ... */;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eArguably, we don’t need Autoprefixer much today because browsers are more interopable, but nobody wants to go without Autoprefixer because it eliminates our worries about vendor prefixing.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat has really tilted the balance towards post-processors includes:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eNative CSS gaining essential features\u003c/li\u003e\n\n\n\n\u003cli\u003eTailwind removing support for pre-processors\u003c/li\u003e\n\n\n\n\u003cli\u003eLightning CSS\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eLet me expand on each of these.\u003c/p\u003e\n\n\n\u003ch3 id=\"native-css-gaining-essential-features\"\u003eNative CSS gaining essential features\u003c/h3\u003e\n\n\n\u003cp\u003eCSS pre-processors existed in the first place because native CSS lacked features that were critical for most developers, including:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCSS variables\u003c/li\u003e\n\n\n\n\u003cli\u003eNesting capabilities\u003c/li\u003e\n\n\n\n\u003cli\u003eAllowing users to break CSS into multiple files without additional fetch requests\u003c/li\u003e\n\n\n\n\u003cli\u003eConditionals like \u003ccode\u003eif\u003c/code\u003e and \u003ccode\u003efor\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eMixins and functions\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eNative CSS has progressed a lot over the years. It has gained great browser support for the first two features:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCSS Variables\u003c/li\u003e\n\n\n\n\u003cli\u003eNesting\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWith just these two features, I suspect a majority of CSS users won’t even need to fire up pre-processors or post-processors. What’s more, \u003ca href=\"https://css-tricks.com/if-css-gets-inline-conditionals/\"\u003eThe \u003ccode\u003eif()\u003c/code\u003e function is coming to CSS\u003c/a\u003e in the future too.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut, for the rest of us who needs to make maintenance and loading performance a priority, we still need the third feature — the ability to break CSS into multiple files. This can be done with Sass’s \u003ccode\u003euse\u003c/code\u003e feature or PostCSS’s \u003ccode\u003eimport\u003c/code\u003e feature (provided by the \u003ccode\u003epostcss-import\u003c/code\u003e plugin).\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003ePostCSS\u003c/code\u003e also contains plugins that can help you create conditionals, mixins, and functions should you need them.\u003c/p\u003e\n\n\n\n\u003cp\u003eAlthough, from my experience, mixins can be better replaced with \u003ca href=\"https://css-tricks.com/tailwinds-apply-feature-is-better-than-it-sounds/\"\u003eTailwind’s \u003ccode\u003e@apply\u003c/code\u003e feature\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis brings us to Tailwind.\u003c/p\u003e\n\n\n\u003ch3 id=\"tailwind-removing-support-for-pre-processors\"\u003eTailwind removing support for pre-processors\u003c/h3\u003e\n\n\n\u003cp\u003eTailwind 4 has officially removed support for pre-processors. From Tailwind’s \u003ca href=\"https://tailwindcss.com/docs/compatibility\" rel=\"noopener\"\u003edocumentation\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eTailwind CSS v4.0 is a full-featured CSS build tool designed for a specific workflow, and is not designed to be used with CSS pre-processors like Sass, Less, or Stylus. \u003cstrong\u003eThink of Tailwind CSS itself as your pre-processor\u003c/strong\u003e — you shouldn’t use Tailwind with Sass for the same reason you wouldn’t use Sass with Stylus. Since Tailwind is designed for modern browsers, you actually don’t need a pre-processor for things like nesting or variables, and Tailwind itself will do things like bundle your imports and add vendor prefixes.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eIf you included Tailwind 4 via its most direct installation method, you won’t be able to use pre-processors with Tailwind.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@import `tailwindcss`\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThat’s because this one import statement makes Tailwind incompatible with Sass, Less, and Stylus.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut, (fortunately), Sass lets you import CSS files if the imported file contains the \u003ccode\u003e.css\u003c/code\u003e extension. So, if you wish to use Tailwind with Sass, you can. But it’s just going to be a little bit wordier.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SCSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@layer theme, base, components, utilities;\n\n@import \u0026#34;tailwindcss/theme.css\u0026#34; layer(theme);\n@import \u0026#34;tailwindcss/preflight.css\u0026#34; layer(base);\n@import \u0026#34;tailwindcss/utilities.css\u0026#34; layer(utilities);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003ePersonally, I dislike Tailwind’s preflight styles so I exclude them from my files.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@layer theme, base, components, utilities;\n@import \u0026#39;tailwindcss/theme.css\u0026#39; layer(theme);\n@import \u0026#39;tailwindcss/utilities.css\u0026#39; layer(utilities);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eEither way, many people won’t know you can continue to use pre-processors with Tailwind. Because of this, I suspect pre-processors will get less popular as Tailwind gains more momentum.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow, beneath Tailwind is a CSS post-processor called Lightning CSS, so this brings us to talking about that.\u003c/p\u003e\n\n\n\u003ch3 id=\"lightning-css\"\u003eLightning CSS\u003c/h3\u003e\n\n\n\u003cp\u003eLightning CSS is a post-processor can do many things that a modern developer needs — so it replaces most of the PostCSS tool chain including:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.npmjs.com/package/postcss-import\" rel=\"noopener\"\u003e\u003ccode\u003epostcss-import\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.npmjs.com/package/postcss-preset-env\" rel=\"noopener\"\u003e\u003ccode\u003epostcss-preset-env\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.npmjs.com/package/autoprefixer\" rel=\"noopener\"\u003e\u003ccode\u003eautoprefixer\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eBesides having a decent set of built-in features, it wins over PostCSS because it’s incredibly fast.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eLightning CSS is over 100 times faster than comparable JavaScript-based tools.\u003c/strong\u003e It can minify over 2.7 million lines of code per second on a single thread.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"966\" height=\"320\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/lightning.png?resize=966%2C320\u0026amp;ssl=1\" alt=\"Comparing build times for CSS Nano (544 milliseconds), ES Build (17 milliseconds), and Lightning CSS (4 milliseconds).\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/lightning.png?w=966\u0026amp;ssl=1 966w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/lightning.png?resize=300%2C99\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/lightning.png?resize=768%2C254\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eSpeed helps Lightning CSS win since many developers are speed junkies who don’t mind switching tools to achieve reduced compile times. But, Lightning CSS also wins because it has great distribution.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt can be used directly as a Vite plugin (that many frameworks support). Ryan Trimble has a step-by-step article on \u003ca href=\"https://css-tricks.com/compiling-css-with-vite-and-lightning-css/\"\u003esetting it up with Vite\u003c/a\u003e if you need help.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// vite.config.mjs\nexport default {\n  css: {\n    transformer: \u0026#39;lightningcss\u0026#39;\n  },\n  build: {\n    cssMinify: \u0026#39;lightningcss\u0026#39;\n  }\n};\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf you need other PostCSS plugins, you can also include that as part of the PostCSS tool chain.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// postcss.config.js\n// Import other plugins...\nimport lightning from \u0026#39;postcss-lightningcss\u0026#39;\n\nexport default {\n  plugins: [lightning, /* Other plugins */],\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eMany well-known developers have switched to Lightning CSS and didn’t look back. Chris Coyier \u003ca href=\"https://frontendmasters.com/blog/fine-ill-use-a-super-basic-css-processing-setup/\" rel=\"noopener\"\u003esays\u003c/a\u003e he’ll use a “super basic CSS processing setup” so you can be assured that you are probably not stepping in any toes if you wish to switch to Lightning, too.\u003c/p\u003e\n\n\n\u003ch3 id=\"if-you-wanna-ditch-pre-processors-today\"\u003eIf you wanna ditch pre-processors today\u003c/h3\u003e\n\n\n\u003cp\u003eYou’ll need to check the features you need. Native CSS is enough for you if you need:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCSS Variables\u003c/li\u003e\n\n\n\n\u003cli\u003eNesting capabilities\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eLightning CSS is enough for you if you need:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCSS Variables\u003c/li\u003e\n\n\n\n\u003cli\u003eNesting capabilities\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eimport\u003c/code\u003e statements to break CSS into multiple files\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eTailwind (\u003ca href=\"https://css-tricks.com/tailwinds-apply-feature-is-better-than-it-sounds/\"\u003ewith \u003ccode\u003e@apply\u003c/code\u003e\u003c/a\u003e) is enough for you if you need:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eall of the above\u003c/li\u003e\n\n\n\n\u003cli\u003eMixins\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIf you still need conditionals like \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e and other functions, it’s still best to stick with Sass for now. (I’ve tried and encountered interoperability issues between \u003ccode\u003epostcss-for\u003c/code\u003e and Lightning CSS that I shall not go into details here).\u003c/p\u003e\n\n\n\n\u003cp\u003eThat’s all I want to share with you today. I hope it helps you if you have been thinking about your CSS toolchain.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-04-17T06:38:05-06:00",
  "modifiedTime": "2025-04-17T06:38:08-06:00"
}
