{
  "id": "09503452-71ac-496e-86da-47d19b9c5120",
  "title": "Organizing Design System Component Patterns With CSS Cascade Layers",
  "link": "https://css-tricks.com/organizing-design-system-component-patterns-with-css-cascade-layers/",
  "description": "I enjoy organizing code and find cascade layers a fantastic way to organize code explicitly as the cascade looks at it. The neat part is, that as much as it helps with \"top-level\" organization, cascade layers can be nested, which allows us to author more precise styles based on the cascade and inheritance. Organizing Design System Component Patterns With CSS Cascade Layers originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Ryan Trimble",
  "published": "Mon, 10 Feb 2025 14:06:52 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "cascade layers",
    "design systems"
  ],
  "byline": "Ryan Trimble",
  "length": 14748,
  "excerpt": "I enjoy organizing code and find cascade layers a fantastic way to organize code explicitly as the cascade looks at it. The neat part is, that as much as it helps with \"top-level\" organization, cascade layers can be nested, which allows us to author more precise styles based on the cascade and inheritance.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "I’m trying to come up with ways to make components more customizable, more efficient, and easier to use and understand, and I want to describe a pattern I’ve been leaning into using CSS Cascade Layers. I enjoy organizing code and find cascade layers a fantastic way to organize code explicitly as the cascade looks at it. The neat part is, that as much as it helps with “top-level” organization, cascade layers can be nested, which allows us to author more precise styles based on the cascade. The only downside here is your imagination, nothing stops us from over-engineering CSS. And to be clear, you may very well consider what I’m about to show you as a form of over-engineering. I think I’ve found a balance though, keeping things simple yet organized, and I’d like to share my findings. The anatomy of a CSS component pattern Let’s explore a pattern for writing components in CSS using a button as an example. Buttons are one of the more popular components found in just about every component library. There’s good reason for that popularity because buttons can be used for a variety of use cases, including: performing actions, like opening a drawer, navigating to different sections of the UI, and holding some form of state, such as focus or hover. And buttons come in several different flavors of markup, like \u003cbutton\u003e, input[type=\"button\"], and \u003ca class=\"button\"\u003e. There are even more ways to make buttons than that, if you can believe it. On top of that, different buttons perform different functions and are often styled accordingly so that a button for one type of action is distinguished from another. Buttons also respond to state changes, such as when they are hovered, active, and focused. If you have ever written CSS with the BEM syntax, we can sort of think along those lines within the context of cascade layers. .button {} .button-primary {} .button-secondary {} .button-warning {} /* etc. */ Okay, now, let’s write some code. Specifically, let’s create a few different types of buttons. We’ll start with a .button class that we can set on any element that we want to be styled as, well, a button! We already know that buttons come in different flavors of markup, so a generic .button class is the most reusable and extensible way to select one or all of them. .button { /* Styles common to all buttons */ } Using a cascade layer This is where we can insert our very first cascade layer! Remember, the reason we want a cascade layer in the first place is that it allows us to set the CSS Cascade’s reading order when evaluating our styles. We can tell CSS to evaluate one layer first, followed by another layer, then another — all according to the order we want. This is an incredible feature that grants us superpower control over which styles “win” when applied by the browser. We’ll call this layer components because, well, buttons are a type of component. What I like about this naming is that it is generic enough to support other components in the future as we decide to expand our design system. It scales with us while maintaining a nice separation of concerns with other styles we write down the road that maybe aren’t specific to components. /* Components top-level layer */ @layer components { .button { /* Styles common to all buttons */ } } Nesting cascade layers Here is where things get a little weird. Did you know you can nest cascade layers inside classes? That’s totally a thing. So, check this out, we can introduce a new layer inside the .button class that’s already inside its own layer. Here’s what I mean: /* Components top-level layer */ @layer components { .button { /* Component elements layer */ @layer elements { /* Styles */ } } } This is how the browser interprets that layer within a layer at the end of the day: @layer components { @layer elements { .button { /* button styles... */ } } } This isn’t a post just on nesting styles, so I’ll just say that your mileage may vary when you do it. Check out Andy Bell’s recent article about using caution with nested styles. Structuring styles So far, we’ve established a .button class inside of a cascade layer that’s designed to hold any type of component in our design system. Inside that .button is another cascade layer, this one for selecting the different types of buttons we might encounter in the markup. We talked earlier about buttons being \u003cbutton\u003e, \u003cinput\u003e, or \u003ca\u003e and this is how we can individually select style each type. We can use the :is() pseudo-selector function as that is akin to saying, “If this .button is an \u003ca\u003e element, then apply these styles.” /* Components top-level layer */ @layer components { .button { /* Component elements layer */ @layer elements { /* styles common to all buttons */ \u0026:is(a) { /* \u003ca\u003e specific styles */ } \u0026:is(button) { /* \u003cbutton\u003e specific styles */ } /* etc. */ } } } Defining default button styles I’m going to fill in our code with the common styles that apply to all buttons. These styles sit at the top of the elements layer so that they are applied to any and all buttons, regardless of the markup. Consider them default button styles, so to speak. /* Components top-level layer */ @layer components { .button { /* Component elements layer */ @layer elements { background-color: darkslateblue; border: 0; color: white; cursor: pointer; display: grid; font-size: 1rem; font-family: inherit; line-height: 1; margin: 0; padding-block: 0.65rem; padding-inline: 1rem; place-content: center; width: fit-content; } } } Defining button state styles What should our default buttons do when they are hovered, clicked, or in focus? These are the different states that the button might take when the user interacts with them, and we need to style those accordingly. I’m going to create a new cascade sub-layer directly under the elements sub-layer called, creatively, states: /* Components top-level layer */ @layer components { .button { /* Component elements layer */ @layer elements { /* Styles common to all buttons */ } /* Component states layer */ @layer states { /* Styles for specific button states */ } } } Pause and reflect here. What states should we target? What do we want to change for each of these states? Some states may share similar property changes, such as :hover and :focus having the same background color. Luckily, CSS gives us the tools we need to tackle such problems, using the :where() function to group property changes based on the state. Why :where() instead of :is()? :where() comes with zero specificity, meaning it’s a lot easier to override than :is(), which takes the specificity of the element with the highest specificity score in its arguments. Maintaining low specificity is a virtue when it comes to writing scalable, maintainable CSS. /* Component states layer */ @layer states { \u0026:where(:hover, :focus-visible) { /* button hover and focus state styles */ } } But how do we update the button’s styles in a meaningful way? What I mean by that is how do we make sure that the button looks like it’s hovered or in focus? We could just slap a new background color on it, but ideally, the color should be related to the background-color set in the elements layer. So, let’s refactor things a bit. Earlier, I set the .button element’s background-color to darkslateblue. I want to reuse that color, so it behooves us to make that into a CSS variable so we can update it once and have it apply everywhere. Relying on variables is yet another virtue of writing scalable and maintainable CSS. I’ll create a new variable called --button-background-color that is initially set to darkslateblue and then set it on the default button styles: /* Component elements layer */ @layer elements { --button-background-color: darkslateblue; background-color: var(--button-background-color); border: 0; color: white; cursor: pointer; display: grid; font-size: 1rem; font-family: inherit; line-height: 1; margin: 0; padding-block: 0.65rem; padding-inline: 1rem; place-content: center; width: fit-content; } Now that we have a color stored in a variable, we can set that same variable on the button’s hovered and focused states in our other layer, using the relatively new color-mix() function to convert darkslateblue to a lighter color when the button is hovered or in focus. Back to our states layer! We’ll first mix the color in a new CSS variable called --state-background-color: /* Component states layer */ @layer states { \u0026:where(:hover, :focus-visible) { /* custom property only used in state */ --state-background-color: color-mix( in srgb, var(--button-background-color), white 10% ); } } We can then apply that color as the background color by updating the background-color property. /* Component states layer */ @layer states { \u0026:where(:hover, :focus-visible) { /* custom property only used in state */ --state-background-color: color-mix( in srgb, var(--button-background-color), white 10% ); /* applying the state background-color */ background-color: var(--state-background-color); } } Defining modified button styles Along with elements and states layers, you may be looking for some sort of variation in your components, such as modifiers. That’s because not all buttons are going to look like your default button. You might want one with a green background color for the user to confirm a decision. Or perhaps you want a red one to indicate danger when clicked. So, we can take our existing default button styles and modify them for those specific use cases If we think about the order of the cascade — always flowing from top to bottom — we don’t want the modified styles to affect the styles in the states layer we just made. So, let’s add a new modifiers layer in between elements and states: /* Components top-level layer */ @layer components { .button { /* Component elements layer */ @layer elements { /* etc. */ } /* Component modifiers layer */ @layer modifiers { /* new layer! */ } /* Component states layer */ @layer states { /* etc. */ } } Similar to how we handled states, we can now update the --button-background-color variable for each button modifier. We could modify the styles further, of course, but we’re keeping things fairly straightforward to demonstrate how this system works. We’ll create a new class that modifies the background-color of the default button from darkslateblue to darkgreen. Again, we can rely on the :is() selector because we want the added specificity in this case. That way, we override the default button style with the modifier class. We’ll call this class .success (green is a “successful” color) and feed it to :is(): /* Component modifiers layer */ @layer modifiers { \u0026:is(.success) { --button-background-color: darkgreen; } } If we add the .success class to one of our buttons, it becomes darkgreen instead darkslateblue which is exactly what we want. And since we already do some color-mix()-ing in the states layer, we’ll automatically inherit those hover and focus styles, meaning darkgreen is lightened in those states. /* Components top-level layer */ @layer components { .button { /* Component elements layer */ @layer elements { --button-background-color: darkslateblue; background-color: var(--button-background-color); /* etc. */ /* Component modifiers layer */ @layer modifiers { \u0026:is(.success) { --button-background-color: darkgreen; } } /* Component states layer */ @layer states { \u0026:where(:hover, :focus) { --state-background-color: color-mix( in srgb, var(--button-background-color), white 10% ); background-color: var(--state-background-color); } } } } Putting it all together We can refactor any CSS property we need to modify into a CSS custom property, which gives us a lot of room for customization. /* Components top-level layer */ @layer components { .button { /* Component elements layer */ @layer elements { --button-background-color: darkslateblue; --button-border-width: 1px; --button-border-style: solid; --button-border-color: transparent; --button-border-radius: 0.65rem; --button-text-color: white; --button-padding-inline: 1rem; --button-padding-block: 0.65rem; background-color: var(--button-background-color); border: var(--button-border-width) var(--button-border-style) var(--button-border-color); border-radius: var(--button-border-radius); color: var(--button-text-color); cursor: pointer; display: grid; font-size: 1rem; font-family: inherit; line-height: 1; margin: 0; padding-block: var(--button-padding-block); padding-inline: var(--button-padding-inline); place-content: center; width: fit-content; } /* Component modifiers layer */ @layer modifiers { \u0026:is(.success) { --button-background-color: darkgreen; } \u0026:is(.ghost) { --button-background-color: transparent; --button-text-color: black; --button-border-color: darkslategray; --button-border-width: 3px; } } /* Component states layer */ @layer states { \u0026:where(:hover, :focus) { --state-background-color: color-mix( in srgb, var(--button-background-color), white 10% ); background-color: var(--state-background-color); } } } } P.S. Look closer at that demo and check out how I’m adjusting the button’s background using light-dark() — then go read Sara Joy’s “Come to the light-dark() Side” for a thorough rundown of how that works! What do you think? Is this something you would use to organize your styles? I can see how creating a system of cascade layers could be overkill for a small project with few components. But even a little toe-dipping into things like we just did illustrates how much power we have when it comes to managing — and even taming — the CSS Cascade. Buttons are deceptively complex but we saw how few styles it takes to handle everything from the default styles to writing the styles for their states and modified versions.",
  "image": "https://css-tricks.com/wp-json/social-image-generator/v1/image/384306",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eI’m trying to come up with ways to make components more customizable, more efficient, and easier to use and understand, and I want to describe a pattern I’ve been leaning into using \u003ca href=\"https://css-tricks.com/css-cascade-layers/\"\u003eCSS Cascade Layers\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eI enjoy organizing code and find cascade layers a fantastic way to organize code explicitly as the cascade looks at it. The neat part is, that as much as it helps with “top-level” organization, cascade layers can be nested, which allows us to author more precise styles based on the cascade.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe only downside here is your imagination, nothing stops us from over-engineering CSS. And to be clear, you may very well consider what I’m about to show you as a form of over-engineering. I think I’ve found a balance though, keeping things simple yet organized, and I’d like to share my findings.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"the-anatomy-of-a-css-component-pattern\"\u003eThe anatomy of a CSS component pattern\u003c/h2\u003e\n\n\n\u003cp\u003eLet’s explore a pattern for writing components in CSS using a button as an example. Buttons are one of the more popular components found in just about every component library. There’s good reason for that popularity because buttons can be used for a variety of use cases, including:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eperforming actions, like opening a drawer,\u003c/li\u003e\n\n\n\n\u003cli\u003enavigating to different sections of the UI, and\u003c/li\u003e\n\n\n\n\u003cli\u003eholding some form of state, such as \u003ccode\u003efocus\u003c/code\u003e or \u003ccode\u003ehover\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAnd buttons come in several different flavors of markup, like \u003ccode\u003e\u0026lt;button\u0026gt;\u003c/code\u003e, \u003ccode\u003einput[type=\u0026#34;button\u0026#34;]\u003c/code\u003e, and \u003ccode\u003e\u0026lt;a class=\u0026#34;button\u0026#34;\u0026gt;\u003c/code\u003e. There are even more ways to make buttons than that, if you can believe it.\u003c/p\u003e\n\n\n\n\u003cp\u003eOn top of that, different buttons perform different functions and are often styled accordingly so that a button for one type of action is distinguished from another. Buttons also respond to state changes, such as when they are hovered, active, and focused. If you have ever written CSS with the \u003ca href=\"https://css-tricks.com/bem-101/\"\u003eBEM syntax\u003c/a\u003e, we can sort of think \u003cem\u003ealong those lines\u003c/em\u003e within the context of cascade layers.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.button {}\n.button-primary {}\n.button-secondary {}\n.button-warning {}\n/* etc. */\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOkay, now, let’s write some code. Specifically, let’s create a few different types of buttons. We’ll start with a \u003ccode\u003e.button\u003c/code\u003e class that we can set on any element that we want to be styled as, well, a button! We already know that buttons come in different flavors of markup, so a generic \u003ccode\u003e.button\u003c/code\u003e class is the most reusable and extensible way to select one or all of them.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.button {\n  /* Styles common to all buttons */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"using-a-cascade-layer\"\u003eUsing a cascade layer\u003c/h3\u003e\n\n\n\u003cp\u003eThis is where we can insert our very first cascade layer! Remember, the reason we want a cascade layer in the first place is that it allows us to set the CSS Cascade’s reading order when evaluating our styles. We can tell CSS to evaluate one layer first, followed by another layer, then another — all according to the order we want. This is an incredible feature that grants us superpower control over which styles “win” when applied by the browser.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe’ll call this layer \u003ccode\u003ecomponents\u003c/code\u003e because, well, buttons are a type of component. What I like about this naming is that it is generic enough to support other components in the future as we decide to expand our design system. It scales with us while maintaining a nice separation of concerns with other styles we write down the road that maybe aren’t specific to components.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Components top-level layer */\n@layer components {\n  .button {\n    /* Styles common to all buttons */\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"nesting-cascade-layers\"\u003eNesting cascade layers\u003c/h3\u003e\n\n\n\u003cp\u003eHere is where things get a little weird. Did you know you can \u003cem\u003enest\u003c/em\u003e cascade layers \u003cem\u003einside\u003c/em\u003e classes? That’s totally a thing. So, check this out, we can introduce a new layer \u003cem\u003einside the \u003ccode\u003e.button\u003c/code\u003e class that’s already inside its own layer\u003c/em\u003e. Here’s what I mean:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Components top-level layer */\n@layer components {\n\n  .button {\n    /* Component elements layer */\n    @layer elements {\n      /* Styles */\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is how the browser interprets that layer within a layer at the end of the day:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@layer components {\n  @layer elements {\n    .button {\n      /* button styles... */\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis isn’t a post just on nesting styles, so I’ll just say that your mileage may vary when you do it. Check out \u003ca href=\"https://piccalil.li/blog/css-nesting-use-with-caution/\" rel=\"noopener\"\u003eAndy Bell’s recent article about using caution with nested styles\u003c/a\u003e.\u003c/p\u003e\n\n\n\u003ch3 id=\"structuring-styles\"\u003eStructuring styles\u003c/h3\u003e\n\n\n\u003cp\u003eSo far, we’ve established a \u003ccode\u003e.button\u003c/code\u003e class inside of a cascade layer that’s designed to hold any type of \u003ccode\u003ecomponent\u003c/code\u003e in our design system. Inside that \u003ccode\u003e.button\u003c/code\u003e is another cascade layer, this one for selecting the different types of buttons we might encounter in the markup. We talked earlier about buttons being \u003ccode\u003e\u0026lt;button\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;input\u0026gt;\u003c/code\u003e, or \u003ccode\u003e\u0026lt;a\u0026gt;\u003c/code\u003e and this is how we can individually select style each type.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can use the \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/pseudo-selectors/i/is/\"\u003e:is()\u003c/a\u003e\u003c/code\u003e pseudo-selector function as that is akin to saying, “If this \u003ccode\u003e.button\u003c/code\u003e \u003cem\u003eis\u003c/em\u003e an \u003ccode\u003e\u0026lt;a\u0026gt;\u003c/code\u003e element, then apply these styles.”\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Components top-level layer */\n@layer components {\n  .button {\n    /* Component elements layer */\n    @layer elements {\n      /* styles common to all buttons */\n\n      \u0026amp;:is(a) {\n        /* \u0026lt;a\u0026gt; specific styles */\n      }\n\n      \u0026amp;:is(button) {\n        /* \u0026lt;button\u0026gt; specific styles */\n      }\n\n      /* etc. */\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"defining-default-button-styles\"\u003eDefining default button styles\u003c/h3\u003e\n\n\n\u003cp\u003eI’m going to fill in our code with the common styles that apply to all buttons. These styles sit at the top of the \u003ccode\u003eelements\u003c/code\u003e layer so that they are applied to any and all buttons, regardless of the markup. Consider them default button styles, so to speak.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Components top-level layer */\n@layer components {\n  .button {\n    /* Component elements layer */\n    @layer elements {\n      background-color: darkslateblue;\n      border: 0;\n      color: white;\n      cursor: pointer;\n      display: grid;\n      font-size: 1rem;\n      font-family: inherit;\n      line-height: 1;\n      margin: 0;\n      padding-block: 0.65rem;\n      padding-inline: 1rem;\n      place-content: center;\n      width: fit-content;\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"defining-button-state-styles\"\u003eDefining button state styles\u003c/h3\u003e\n\n\n\u003cp\u003eWhat should our default buttons do when they are hovered, clicked, or in focus? These are the different \u003cem\u003estates\u003c/em\u003e that the button might take when the user interacts with them, and we need to style those accordingly.\u003c/p\u003e\n\n\n\n\u003cp\u003eI’m going to create a new cascade sub-layer directly under the \u003ccode\u003eelements\u003c/code\u003e sub-layer called, creatively, \u003ccode\u003estates\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Components top-level layer */\n@layer components {\n  .button {\n    /* Component elements layer */\n    @layer elements {\n      /* Styles common to all buttons */\n    }\n\n    /* Component states layer */\n    @layer states {\n      /* Styles for specific button states */\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003ePause and reflect here. What states should we target? What do we want to change for each of these states?\u003c/p\u003e\n\n\n\n\u003cp\u003eSome states may share similar property changes, such as \u003ccode\u003e:hover\u003c/code\u003e and \u003ccode\u003e:focus\u003c/code\u003e having the same background color. Luckily, CSS gives us the tools we need to tackle such problems, using the \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/pseudo-selectors/w/where/\"\u003e:where()\u003c/a\u003e\u003c/code\u003e function to group property changes based on the state. Why \u003ccode\u003e:where()\u003c/code\u003e instead of \u003ccode\u003e:is()\u003c/code\u003e? \u003cstrong\u003e\u003ccode\u003e:where()\u003c/code\u003e comes with zero specificity\u003c/strong\u003e, meaning it’s a lot easier to override than \u003ccode\u003e:is()\u003c/code\u003e, which takes the specificity of the element with the highest specificity score in its arguments. Maintaining low specificity is a virtue when it comes to writing scalable, maintainable CSS.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Component states layer */\n@layer states {\n  \u0026amp;:where(:hover, :focus-visible) {\n    /* button hover and focus state styles */\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBut how do we update the button’s styles in a \u003cem\u003emeaningful\u003c/em\u003e way? What I mean by that is how do we make sure that the button \u003cem\u003elooks\u003c/em\u003e like it’s hovered or in focus? We could just slap a new background color on it, but ideally, the color should be related to the \u003ccode\u003ebackground-color\u003c/code\u003e set in the \u003ccode\u003eelements\u003c/code\u003e layer.\u003c/p\u003e\n\n\n\n\u003cp\u003eSo, let’s refactor things a bit. Earlier, I set the \u003ccode\u003e.button\u003c/code\u003e element’s \u003ccode\u003ebackground-color\u003c/code\u003e to \u003ccode\u003edarkslateblue\u003c/code\u003e. I want to reuse that color, so it behooves us to make that into a CSS variable so we can update it once and have it apply everywhere. Relying on variables is yet another virtue of writing scalable and maintainable CSS.\u003c/p\u003e\n\n\n\n\u003cp\u003eI’ll create a new variable called \u003ccode\u003e--button-background-color\u003c/code\u003e that is initially set to \u003ccode\u003edarkslateblue\u003c/code\u003e and then set it on the default button styles:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"3,5\"\u003e\u003ccode markup=\"tt\"\u003e/* Component elements layer */\n@layer elements {\n  --button-background-color: darkslateblue;\n\n  background-color: var(--button-background-color);\n  border: 0;\n  color: white;\n  cursor: pointer;\n  display: grid;\n  font-size: 1rem;\n  font-family: inherit;\n  line-height: 1;\n  margin: 0;\n  padding-block: 0.65rem;\n  padding-inline: 1rem;\n  place-content: center;\n  width: fit-content;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow that we have a color stored in a variable, we can set that same variable on the button’s hovered and focused states in our other layer, using the relatively new \u003ca href=\"https://css-tricks.com/color-mixing-with-animation-composition/\"\u003e\u003ccode\u003ecolor-mix()\u003c/code\u003e function\u003c/a\u003e to convert \u003ccode\u003edarkslateblue\u003c/code\u003e to a lighter color when the button is hovered or in focus.\u003c/p\u003e\n\n\n\n\u003cp\u003eBack to our \u003ccode\u003estates\u003c/code\u003e layer! We’ll first mix the color in a new CSS variable called \u003ccode\u003e--state-background-color\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Component states layer */\n@layer states {\n  \u0026amp;:where(:hover, :focus-visible) {\n    /* custom property only used in state */\n    --state-background-color: color-mix(\n      in srgb, \n      var(--button-background-color), \n      white 10%\n    );\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe can then apply that color as the background color by updating the \u003ccode\u003ebackground-color\u003c/code\u003e property.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"12\"\u003e\u003ccode markup=\"tt\"\u003e/* Component states layer */\n@layer states {\n  \u0026amp;:where(:hover, :focus-visible) {\n    /* custom property only used in state */\n    --state-background-color: color-mix(\n      in srgb, \n      var(--button-background-color), \n      white 10%\n    );\n\n    /* applying the state background-color */\n    background-color: var(--state-background-color);\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"defining-modified-button-styles\"\u003eDefining modified button styles\u003c/h3\u003e\n\n\n\u003cp\u003eAlong with \u003ccode\u003eelements\u003c/code\u003e and \u003ccode\u003estates\u003c/code\u003e layers, you may be looking for some sort of variation in your components, such as \u003ccode\u003emodifiers\u003c/code\u003e. That’s because not all buttons are going to look like your default button. You might want one with a green background color for the user to confirm a decision. Or perhaps you want a red one to indicate danger when clicked. So, we can take our existing default button styles and modify them for those specific use cases \u003c/p\u003e\n\n\n\n\u003cp\u003eIf we think about the order of the cascade — always flowing from top to bottom — we don’t want the modified styles to affect the styles in the states layer we just made. So, let’s add a new \u003ccode\u003emodifiers\u003c/code\u003e layer in between \u003ccode\u003eelements\u003c/code\u003e and \u003ccode\u003estates\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"10,11,12,13\"\u003e\u003ccode markup=\"tt\"\u003e/* Components top-level layer */\n@layer components {\n\n  .button {\n  /* Component elements layer */\n  @layer elements {\n    /* etc. */\n  }\n\n  /* Component modifiers layer */\n  @layer modifiers {\n    /* new layer! */\n  }\n\n  /* Component states layer */\n  @layer states {\n    /* etc. */\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSimilar to how we handled \u003ccode\u003estates\u003c/code\u003e, we can now update the \u003ccode\u003e--button-background-color\u003c/code\u003e variable for each button modifier. We could modify the styles further, of course, but we’re keeping things fairly straightforward to demonstrate how this system works.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe’ll create a new class that modifies the \u003ccode\u003ebackground-color\u003c/code\u003e of the default button from \u003ccode\u003edarkslateblue\u003c/code\u003e to \u003ccode\u003edarkgreen\u003c/code\u003e. Again, we can rely on the \u003ccode\u003e:is()\u003c/code\u003e selector because we want the added specificity in this case. That way, we override the default button style with the modifier class. We’ll call this class \u003ccode\u003e.success\u003c/code\u003e (green is a “successful” color) and feed it to \u003ccode\u003e:is()\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Component modifiers layer */\n@layer modifiers {\n  \u0026amp;:is(.success) {\n    --button-background-color: darkgreen;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf we add the \u003ccode\u003e.success\u003c/code\u003e class to one of our buttons, it becomes \u003ccode\u003edarkgreen\u003c/code\u003e instead \u003ccode\u003edarkslateblue\u003c/code\u003e which is exactly what we want. And since we already do some \u003ccode\u003ecolor-mix()\u003c/code\u003e-ing in the \u003ccode\u003estates\u003c/code\u003e layer, we’ll automatically inherit those hover and focus styles, meaning \u003ccode\u003edarkgreen\u003c/code\u003e is lightened in those states.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Components top-level layer */\n@layer components {\n  .button {\n    /* Component elements layer */\n    @layer elements {\n      --button-background-color: darkslateblue;\n\n      background-color: var(--button-background-color);\n      /* etc. */\n\n    /* Component modifiers layer */\n    @layer modifiers {\n      \u0026amp;:is(.success) {\n        --button-background-color: darkgreen;\n      }\n    }\n\n    /* Component states layer */\n    @layer states {\n      \u0026amp;:where(:hover, :focus) {\n        --state-background-color: color-mix(\n          in srgb,\n          var(--button-background-color),\n          white 10%\n        );\n\n        background-color: var(--state-background-color);\n      }\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"putting-it-all-together\"\u003ePutting it all together\u003c/h3\u003e\n\n\n\u003cp\u003eWe can refactor any CSS property we need to modify into a CSS custom property, which gives us a lot of room for customization.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Components top-level layer */\n@layer components {\n  .button {\n    /* Component elements layer */\n    @layer elements {\n      --button-background-color: darkslateblue;\n\n      --button-border-width: 1px;\n      --button-border-style: solid;\n      --button-border-color: transparent;\n      --button-border-radius: 0.65rem;\n\n      --button-text-color: white;\n\n      --button-padding-inline: 1rem;\n      --button-padding-block: 0.65rem;\n\n      background-color: var(--button-background-color);\n      border: \n        var(--button-border-width) \n        var(--button-border-style) \n        var(--button-border-color);\n      border-radius: var(--button-border-radius);\n      color: var(--button-text-color);\n      cursor: pointer;\n      display: grid;\n      font-size: 1rem;\n      font-family: inherit;\n      line-height: 1;\n      margin: 0;\n      padding-block: var(--button-padding-block);\n      padding-inline: var(--button-padding-inline);\n      place-content: center;\n      width: fit-content;\n    }\n\n    /* Component modifiers layer */\n    @layer modifiers {\n      \u0026amp;:is(.success) {\n        --button-background-color: darkgreen;\n      }\n\n      \u0026amp;:is(.ghost) {\n        --button-background-color: transparent;\n        --button-text-color: black;\n        --button-border-color: darkslategray;\n        --button-border-width: 3px;\n      }\n    }\n\n    /* Component states layer */\n    @layer states {\n      \u0026amp;:where(:hover, :focus) {\n        --state-background-color: color-mix(\n          in srgb,\n          var(--button-background-color),\n          white 10%\n        );\n\n        background-color: var(--state-background-color);\n      }\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eP.S. Look closer at that demo and check out how I’m adjusting the button’s background using \u003ccode\u003elight-dark()\u003c/code\u003e — then go read Sara Joy’s \u003ca href=\"https://css-tricks.com/come-to-the-light-dark-side/\"\u003e“Come to the \u003ccode\u003elight-dark()\u003c/code\u003e Side”\u003c/a\u003e for a thorough rundown of how that works!\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eWhat do you think? Is this something you would use to organize your styles? I can see how creating a system of cascade layers could be overkill for a small project with few components. But even a little toe-dipping into things like we just did illustrates how much power we have when it comes to managing — and even taming — the CSS Cascade. Buttons are deceptively complex but we saw how few styles it takes to handle everything from the default styles to writing the styles for their states and modified versions.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2025-02-10T07:06:52-07:00",
  "modifiedTime": "2025-02-10T07:06:53-07:00"
}
