{
  "id": "f2c05ee9-260c-4f9b-8987-c9d6ddb0c3a1",
  "title": "Memory safety for web fonts",
  "link": "https://developer.chrome.com/blog/memory-safety-fonts?hl=en",
  "description": "Learn how and why the Chrome team has replaced FreeType with Skrifa.",
  "author": "",
  "published": "Wed, 19 Mar 2025 07:00:00 GMT",
  "source": "https://developer.chrome.com/static/blog/feed.xml",
  "categories": null,
  "byline": "GitHub",
  "length": 12586,
  "excerpt": "Learn how and why the Chrome team has replaced FreeType with Skrifa.",
  "siteName": "Chrome for Developers",
  "favicon": "https://www.gstatic.com/devrel-devsite/prod/v1c43259e491a2af2272be031aab6f7713a1b5287c753937874e72435623bc692/chrome/images/favicon.png",
  "text": "Skip to main content Memory safety for web fonts Stay organized with collections Save and categorize content based on your preferences. Published: March 19, 2025 Skrifa is written in Rust, and created as a replacement for FreeType to make font processing in Chrome secure for all our users. Skifra takes advantage of Rust's memory safety, and lets us iterate faster on font technology improvements in Chrome. Moving from FreeType to Skrifa allows us to be both agile and fearless when making changes to our font code. We now spend far less time fixing security bugs, resulting in faster updates, and better code quality. This post shares why Chrome has moved away from FreeType, and some interesting technical details of the improvements this move has enabled. Why replace FreeType? The web is unique in that it allows users to fetch untrusted resources from a wide variety of untrusted sources with the expectation that things will just work, and that they are safe in doing so. This assumption is generally correct, but keeping that promise to users comes at a cost. For example, to use a web font safely (a font delivered over the network) Chrome employs several security mitigations: Font processing is sandboxed per the rule of two: they are untrustworthy and the consuming code is unsafe. Fonts are passed through the OpenType Sanitizer prior to processing. All the libraries involved in decompressing and processing fonts are fuzz tested. Chrome ships with FreeType and makes use of it as the primary font processing library on Android, ChromeOS, and Linux. That means a lot of users are exposed if there is a vulnerability in FreeType. The FreeType library is used by Chrome to compute metrics and load hinted outlines from fonts. Overall, use of FreeType has been a huge win for Google. It does a complex job, and does it well, we rely on it extensively and contribute back to it. However, it is written in unsafe code and has its origins in a time when malicious inputs were less likely. Merely keeping up with the stream of issues found by fuzzing costs Google at least 0.25 full time software engineers. Worse, we observably don't find everything or find things only after the code has shipped to users. This pattern of problems is not unique to FreeType, we observe that other unsafe libraries admit issues even when we use the best software engineers we can find, code review every change, and require tests. Why issues keep sneaking in When we evaluated FreeType's security, we observed three main classes of issue to occur (non-exhaustive): Use of an unsafe language Pattern/Issue Example Manual memory management CVE-2014-9661, use after free, identified by Project Zero, Project Zero tracker CVE-2020-15999, heap overflow identified to be actively exploited by Project Zero Unchecked array access CVE-2022-27404 Integer overflows During execution of embedded virtual machines for TrueType hinting of CFF drawing and hinting https://issues.oss-fuzz.com/issues?q=FreeType%20Integer-overflow Incorrect use of zeroing versus non-zeroing allocation Discussion in https://gitlab.freedesktop.org/freetype/freetype/-/merge_requests/94, 8 fuzzer issues found afterwards Invalid casts See the following row on macro usage Project specific issues Pattern/Issue Example Macros obscure lack of explicit size typing Macros such as FT_READ_* and FT_PEEK_* obscure what integer types are being used, hiding that C99 types with explicit sizes (int16_t, etc) are not used Fix reading s32 when long is s64 New code consistently adds bugs, even when written defensively. COLRv1 and OT-SVG support both produced issues Fuzzing finds some, but not necessarily all, #32421, #52404 Lack of tests Crafting test fonts is time consuming and difficult For example, the fix for CVE-2020-15999 adds no test Dependency issues Fuzzing has repeatedly identified issues in libraries FreeType depends on, such as bzip2, libpng, and zlib. As an example, compare freetype_bdf_fuzzer: Use-of-uninitialized-value in inflate. Fuzzing isn't enough Fuzzing–automated testing with a wide range of inputs, including randomized invalid ones–is meant to find many of the types of issues that get into the stable release of Chrome. We fuzz FreeType as part of Google's oss-fuzz project. It does find issues, but fonts have proven somewhat resistant to fuzzing, for the following reasons. Font files are complex, comparable to video files as they contain multiple different types of information. Font files are a container format for multiple tables, where each table serves a different purpose in processing text and fonts together to produce a correctly positioned glyph on the screen. In a font file you will find: Static metadata such as font names and parameters for variable fonts. Mappings from Unicode characters to glyphs. A complex ruleset and grammar for screen layout of glyphs. Visual information: Glyph shapes and image information describing what the glyphs placed on the screen look like. The visual tables can in turn include TrueType hinting programs, which are mini programs executed to change the glyph shape. Char strings in the CFF or CFF2 tables which are imperative curve drawing and hinting instructions executed in the CFF rendering engine. There is complexity in font files equivalent to having its own programming language and state machine processing, requiring specific virtual machines to execute them. Because of the complexity of the format, fuzzing has shortcomings in finding issues in font files. Good code coverage or fuzzer progress is difficult to achieve for the following reasons: Fuzzing TrueType hinting programs, CFF char strings and OpenType layout using simple bit-flipping/shift/insertion/deletion-style mutators struggles to reach all combinations of states. Fuzzing needs to at least produce partially valid structures. Random mutation rarely does so, making good coverage hard to achieve, particularly for deeper levels of code. The current fuzzing efforts in ClusterFuzz and oss-fuzz are not yet using structure-aware mutation. Use of grammar- or structure-aware mutators might help avoid production of variants that are rejected early, at the cost of taking more time to develop, and introducing chances which miss parts of the search space. Data in multiple tables needs to be in sync for fuzzing to make progress: The usual mutation patterns of fuzzers don't produce partially valid data so many iterations get rejected and progress becomes slow. The glyph mapping, the OpenType layout tables and glyph drawing are connected and depend on each other, forming a combinatorial space whose corners are hard to reach with fuzzing. For example, the high-severity tt_face_get_paint COLRv1 vulnerability took more than 10 months to find. Despite our best efforts, font security issues have repeatedly reached end users. Replacing FreeType with a Rust alternative will prevent multiple entire classes of vulnerability. Skrifa in Chrome Skia is the graphics library used by Chrome. Skia relies on FreeType to load metadata and letterforms from fonts. Skrifa is a Rust library, part of the Fontations family of libraries, that provides a safe replacement for the parts of FreeType used by Skia. To transition FreeType to Skia the Chrome team developed a new Skia font backend based on Skrifa and gradually rolled out the change to users: In Chrome 128 (August 2024) we enabled Fontations for use in less commonly used font formats, such as for color fonts and CFF2, as a safe trial run. In Chrome 133 (February 2025) we enabled Fontations for all web fonts usage on Linux, Android and ChromeOS, and for web fonts usage as fallback on Windows and Mac—in cases where the system does not support a font format but Chrome needs to display it. For the integration into Chrome, we rely on the smooth integration of Rust into the codebase introduced by the Chrome security team. In the future we'll switch to Fontations for operating system fonts as well, starting with Linux and ChromeOS, then on Android. Safety, first and foremost Our primary goal is to reduce (or ideally, eliminate!) security vulnerabilities that are caused by out of bounds access to memory. Rust provides this out of the box as long as you avoid any unsafe code blocks. Our performance goals require us to perform one operation that is currently unsafe: reinterpretation of arbitrary bytes as a strongly typed data structure. This allows us to read the data from a font file without performing unnecessary copies and is essential for producing a fast font parser. To avoid our own unsafe code, we've chosen to outsource this responsibility to bytemuck which is a Rust library designed specifically for this purpose and is widely tested and used across the ecosystem. Concentrating raw data reinterpretation in bytemuck ensures we have this functionality in one place and audited, and avoid repeating unsafe code for the purpose. The safe transmute project aims to incorporate this functionality directly into the Rust compiler and we will make the switch as soon as it is available. Correctness matters Skrifa is built out of independent components where most data structures are designed to be immutable. This improves readability, maintainability and multithreading. It also makes the code more amenable to unit testing. We've taken advantage of this opportunity and have produced a suite of roughly 700 unit tests that cover our full stack from low level parsing routines to high level hinting virtual machines. Correctness also implies fidelity and FreeType is highly regarded for its generation of high quality outlines. We must match this quality to be a suitable replacement. To that end, we have built a bespoke tool called fauntlet that compares the output of Skrifa and FreeType for batches of font files across a wide range of configurations. This affords us some assurance that we can avoid regressions in quality. In addition, before the integration into Chromium, we ran a wide set of pixel comparisons in Skia, comparing FreeType rendering to Skrifa and Skia rendering to ensure the pixel differences are absolutely minimal, in all required rendering modes (across different antialiasing and hinting modes). Fuzz testing is an important tool for determining how a piece of software will react to malformed and malicious inputs. We've been continuously fuzzing our new code since June of 2024. This covers the Rust libraries itself and the integration code. While the fuzzer has found (as of this writing) 39 bugs, it's worth noting that none of these have been security critical. They may cause undesired visual results or even controlled crashes, but won't lead to exploitable vulnerabilities. Onward! We are very pleased with the results of our efforts to use Rust for text. Delivering safer code to users and gaining developer productivity is a huge win for us. We plan to continue to seek opportunities to use Rust in our text stacks. If you'd like to know more, Oxidize outlines some of Google Fonts future plans. Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates. Last updated 2025-03-19 UTC. [[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-03-19 UTC.\"],[],[]]",
  "image": "https://developer.chrome.com/static/blog/memory-safety-fonts/image/hero.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\n    \u003cdevsite-progress type=\"indeterminate\" id=\"app-progress\"\u003e\u003c/devsite-progress\u003e\n  \n    \u003ca href=\"#main-content\"\u003e\n      \n      Skip to main content\n    \u003c/a\u003e\n    \u003csection\u003e\n      \u003cdevsite-cookie-notification-bar\u003e\u003c/devsite-cookie-notification-bar\u003e\u003cdevsite-header role=\"banner\"\u003e\n  \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\u003c/devsite-header\u003e\n      \n      \u003csection id=\"gc-wrapper\"\u003e\n        \u003cmain role=\"main\" id=\"main-content\" has-sidebar=\"\"\u003e\n          \n          \n          \n          \u003cdevsite-content\u003e\n            \n              \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003carticle\u003e\n  \n  \n  \n  \n  \n\n  \n  \n    \u003ch2 tabindex=\"-1\"\u003e\n      Memory safety for web fonts\n      \n  \u003cp data-nosnippet=\"\"\u003e\n    \u003cdevsite-feature-tooltip ack-key=\"AckCollectionsBookmarkTooltipDismiss\" analytics-category=\"Site-Wide Custom Events\" analytics-action-show=\"Callout Profile displayed\" analytics-action-close=\"Callout Profile dismissed\" analytics-label=\"Create Collection Callout\" dismiss-button=\"true\" id=\"devsite-collections-dropdown\" dismiss-button-text=\"Dismiss\" close-button-text=\"Got it\"\u003e\n\n    \n    \u003cdevsite-bookmark\u003e\u003c/devsite-bookmark\u003e\n\n    \u003cspan slot=\"popout-heading\"\u003e\n      \n      Stay organized with collections\n    \u003c/span\u003e\n    \u003cspan slot=\"popout-contents\"\u003e\n      \n      Save and categorize content based on your preferences.\n    \u003c/span\u003e\n  \u003c/devsite-feature-tooltip\u003e\n  \u003c/p\u003e\n  \n    \u003c/h2\u003e\n  \n  \n\n  \u003cdevsite-toc depth=\"2\" devsite-toc-embedded=\"\"\u003e\n  \u003c/devsite-toc\u003e\n  \n    \n  \n\n  \n\n\n\n\n\n\n\u003cdiv\u003e\n\n  \n    \n\n\n\n\n\n\n\u003cp\u003e\n  Published: March 19, 2025\n\u003c/p\u003e\n\n\n\u003cp\u003e\u003ca href=\"https://github.com/googlefonts/fontations/tree/main/skrifa\"\u003eSkrifa\u003c/a\u003e\nis written in\nRust,\nand created as a replacement for FreeType to make font processing in Chrome\nsecure for all our users.\nSkifra takes advantage of Rust\u0026#39;s memory safety,\nand lets us iterate faster on font technology improvements in Chrome.\nMoving from FreeType to Skrifa allows us to be both agile and fearless when\nmaking changes to our font code. We now spend far less time fixing security bugs,\nresulting in faster updates, and better code quality.\u003c/p\u003e\n\n\u003cp\u003eThis post shares why Chrome has moved away from FreeType,\nand some interesting technical details of the improvements this move has enabled.\u003c/p\u003e\n\n\u003ch2 id=\"why_replace_freetype\" data-text=\"Why replace FreeType?\" tabindex=\"-1\"\u003eWhy replace FreeType?\u003c/h2\u003e\n\n\u003cp\u003eThe web is unique in that it allows users to fetch untrusted resources from a\nwide variety of untrusted sources with the expectation that things will just\nwork, and that they are safe in doing so. This assumption is generally correct,\nbut keeping that promise to users comes at a cost. For example, to use a web\nfont safely (a font delivered over the network) Chrome employs several security\nmitigations:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eFont processing is\n\u003ca href=\"https://chromium.googlesource.com/chromium/src/+/HEAD/docs/design/sandbox.md\"\u003esandboxed\u003c/a\u003e\nper the \u003ca href=\"https://chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2.md\"\u003erule of\ntwo\u003c/a\u003e:\nthey are untrustworthy and the consuming code is unsafe.\u003c/li\u003e\n\u003cli\u003eFonts are passed through the \u003ca href=\"https://github.com/khaledhosny/ots\"\u003eOpenType\nSanitizer\u003c/a\u003e prior to processing.\u003c/li\u003e\n\u003cli\u003eAll the libraries involved in decompressing and processing fonts are \u003ca href=\"https://en.wikipedia.org/wiki/Fuzzing\"\u003efuzz\ntested\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eChrome ships with FreeType and makes use of it as the primary font processing\nlibrary on Android, ChromeOS, and Linux. That means a \u003cstrong\u003elot\u003c/strong\u003e of users are\nexposed if there is a vulnerability in FreeType.\u003c/p\u003e\n\n\u003cp\u003eThe FreeType library is used by Chrome to compute metrics and load hinted\noutlines from fonts. Overall, use of FreeType has been a huge win for Google. It\ndoes a complex job, and does it well, we rely on it extensively and contribute\nback to it. However, it is written in unsafe code and has its origins in a time\nwhen malicious inputs were less likely. Merely keeping up with the stream of\nissues found by fuzzing costs Google at least 0.25 full time software\nengineers. Worse, we observably don\u0026#39;t find everything or find things only after\nthe code has shipped to users.\u003c/p\u003e\n\n\u003cp\u003eThis pattern of problems is not unique to FreeType, we observe that other unsafe\nlibraries admit issues even when we use the best software engineers we can find,\ncode review every change, and require tests.\u003c/p\u003e\n\n\u003ch3 id=\"why_issues_keep_sneaking_in\" data-text=\"Why issues keep sneaking in\" tabindex=\"-1\"\u003eWhy issues keep sneaking in\u003c/h3\u003e\n\n\u003cp\u003eWhen we evaluated FreeType\u0026#39;s security, we observed three main classes of issue\nto occur (non-exhaustive):\u003c/p\u003e\n\n\u003ch4 id=\"use_of_an_unsafe_language\" data-text=\"Use of an unsafe language\" tabindex=\"-1\"\u003eUse of an unsafe language\u003c/h4\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003ePattern/Issue\u003c/th\u003e\n      \u003cth\u003eExample\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eManual memory management\u003c/td\u003e\n      \u003ctd\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://nvd.nist.gov/vuln/detail/CVE-2014-9661\"\u003eCVE-2014-9661\u003c/a\u003e, use after free, identified by Project Zero, \u003ca href=\"https://project-zero.issues.chromium.org/issues/42450955\"\u003eProject Zero tracker\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://nvd.nist.gov/vuln/detail/cve-2020-15999\"\u003eCVE-2020-15999\u003c/a\u003e, heap overflow identified to be \u003ca href=\"https://googleprojectzero.blogspot.com/2021/03/in-wild-series-october-2020-0-day.html\"\u003eactively exploited\u003c/a\u003e by Project Zero\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eUnchecked array access\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-27404\"\u003eCVE-2022-27404\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eInteger overflows\u003c/td\u003e\n      \u003ctd\u003eDuring execution of embedded virtual machines for TrueType hinting of CFF drawing and hinting\u003cbr/\u003e\n\u003ca href=\"https://issues.oss-fuzz.com/issues?q=FreeType%20Integer-overflow\"\u003ehttps://issues.oss-fuzz.com/issues?q=FreeType%20Integer-overflow\u003c/a\u003e  \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eIncorrect use of zeroing versus non-zeroing allocation\u003c/td\u003e\n      \u003ctd\u003eDiscussion in \u003ca href=\"https://gitlab.freedesktop.org/freetype/freetype/-/merge_requests/94\"\u003ehttps://gitlab.freedesktop.org/freetype/freetype/-/merge_requests/94\u003c/a\u003e, \u003ca href=\"http://issues.chromium.org/issues?q=id:(40055682%20%7C%2040055692%20%7C%2040057647%20%7C%2040057647%20%7C%2040057653%20%7C%2040057656%20%7C%2040057666%20%7C%2040057667)\"\u003e8 fuzzer issues found\u003c/a\u003e afterwards \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eInvalid casts\u003c/td\u003e\n      \u003ctd\u003eSee the following row on macro usage\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch4 id=\"project_specific_issues\" data-text=\"Project specific issues\" tabindex=\"-1\"\u003eProject specific issues\u003c/h4\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003ePattern/Issue\u003c/th\u003e\n      \u003cth\u003eExample\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eMacros obscure lack of explicit size typing\u003c/td\u003e\n      \u003ctd\u003e\u003cul\u003e\n\u003cli\u003eMacros such as \u003ccode translate=\"no\" dir=\"ltr\"\u003eFT_READ_*\u003c/code\u003e and \u003ccode translate=\"no\" dir=\"ltr\"\u003eFT_PEEK_*\u003c/code\u003e obscure what integer types are being used, hiding that C99 types with explicit sizes (int16_t, etc) are not used\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://gitlab.freedesktop.org/freetype/freetype/-/merge_requests/175\"\u003eFix reading s32 when long is s64\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eNew code consistently adds bugs, even when written defensively.\u003c/td\u003e\n      \u003ctd\u003e\u003cul\u003e\n\u003cli\u003eCOLRv1 and OT-SVG support both produced issues\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003eFuzzing finds some, but not necessarily all, \u003ca href=\"https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=32421\"\u003e#32421\u003c/a\u003e, \u003ca href=\"https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=52404\"\u003e#52404\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eLack of tests\u003c/td\u003e\n      \u003ctd\u003e\u003cul\u003e\n\u003cli\u003eCrafting test fonts is time consuming and difficult\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003eFor example, the \u003ca href=\"https://gitlab.freedesktop.org/freetype/freetype/-/commit/a3bab162b2ae616074c8877a04556932998aeacd\"\u003efix\u003c/a\u003e for \u003ca href=\"https://nvd.nist.gov/vuln/detail/cve-2020-15999\"\u003eCVE-2020-15999\u003c/a\u003e adds no test \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch4 id=\"dependency_issues\" data-text=\"Dependency issues\" tabindex=\"-1\"\u003eDependency issues\u003c/h4\u003e\n\n\u003cp\u003eFuzzing has repeatedly identified issues in libraries FreeType depends on, such\nas bzip2, libpng, and zlib. As an example, compare \u003ca href=\"https://issues.chromium.org/issues/40055682\"\u003efreetype_bdf_fuzzer:\nUse-of-uninitialized-value in\ninflate\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch4 id=\"fuzzing_isnt_enough\" data-text=\"Fuzzing isn\u0026#39;t enough\" tabindex=\"-1\"\u003eFuzzing isn\u0026#39;t enough\u003c/h4\u003e\n\n\u003cp\u003eFuzzing–automated testing with a wide range of inputs, including randomized\ninvalid ones–is meant to find many of the types of issues that get into the\nstable release of Chrome. We fuzz FreeType as part of Google\u0026#39;s\n\u003ca href=\"https://github.com/google/oss-fuzz\"\u003eoss-fuzz\u003c/a\u003e project. It does find issues, but\nfonts have proven somewhat resistant to fuzzing, for the following reasons.\u003c/p\u003e\n\n\u003cp\u003eFont files are complex, comparable to video files as they contain multiple\ndifferent types of information. Font files are a container format for multiple\ntables, where each table serves a different purpose in processing text and fonts\ntogether to produce a correctly positioned glyph on the screen. In a font file\nyou will find:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eStatic metadata such as font names and parameters for variable fonts.\u003c/li\u003e\n\u003cli\u003eMappings from Unicode characters to glyphs.\u003c/li\u003e\n\u003cli\u003eA complex ruleset and grammar for screen layout of glyphs.\u003c/li\u003e\n\u003cli\u003eVisual information: Glyph shapes and image information describing what the\nglyphs placed on the screen look like.\n\u003cul\u003e\n\u003cli\u003eThe visual tables can in turn include TrueType hinting programs, which\nare mini programs executed to change the glyph shape.\u003c/li\u003e\n\u003cli\u003eChar strings in the CFF or CFF2 tables which are imperative curve\ndrawing and hinting instructions executed in the CFF rendering engine.\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThere is complexity in font files equivalent to having its own programming\nlanguage and state machine processing, requiring specific virtual machines to\nexecute them.\u003c/p\u003e\n\n\u003cp\u003eBecause of the complexity of the format, fuzzing has shortcomings in finding\nissues in font files.\u003c/p\u003e\n\n\u003cp\u003eGood code coverage or fuzzer progress is difficult to achieve for the following\nreasons:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eFuzzing TrueType hinting programs, CFF char strings and OpenType layout\nusing simple bit-flipping/shift/insertion/deletion-style mutators struggles\nto reach all combinations of states.\u003c/li\u003e\n\u003cli\u003eFuzzing needs to at least produce partially valid structures. Random\nmutation rarely does so, making good coverage hard to achieve, particularly\nfor deeper levels of code.\u003c/li\u003e\n\u003cli\u003eThe current fuzzing efforts in ClusterFuzz and oss-fuzz are not yet using\nstructure-aware mutation. Use of grammar- or structure-aware mutators might\nhelp avoid production of variants that are rejected early, at the cost of\ntaking more time to develop, and introducing chances which miss parts of the\nsearch space.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eData in multiple tables needs to be in sync for fuzzing to make progress:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eThe usual mutation patterns of fuzzers don\u0026#39;t produce partially valid data\nso many iterations get rejected and progress becomes slow.\u003c/li\u003e\n\u003cli\u003eThe glyph mapping, the OpenType layout tables and glyph drawing are\nconnected and depend on each other, forming a combinatorial space whose\ncorners are hard to reach with fuzzing.\u003c/li\u003e\n\u003cli\u003eFor example, the high-severity \u003ca href=\"https://issues.chromium.org/40055587\"\u003ett_face_get_paint\nCOLRv1\u003c/a\u003e vulnerability took more than\n10 months to find.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eDespite our best efforts, font security issues have repeatedly reached end\nusers. Replacing FreeType with a Rust alternative will prevent multiple entire\nclasses of vulnerability.\u003c/p\u003e\n\n\u003ch2 id=\"skrifa_in_chrome\" data-text=\"Skrifa in Chrome\" tabindex=\"-1\"\u003eSkrifa in Chrome\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://skia.org/\"\u003eSkia\u003c/a\u003e is the graphics library used by Chrome. Skia relies on\nFreeType to load metadata and letterforms from fonts.\n\u003ca href=\"https://github.com/googlefonts/fontations/tree/main/skrifa\"\u003eSkrifa\u003c/a\u003e is a Rust\nlibrary, part of the \u003ca href=\"https://github.com/googlefonts/fontations\"\u003eFontations\u003c/a\u003e\nfamily of libraries, that provides a safe replacement for the parts of FreeType\nused by Skia.\u003c/p\u003e\n\n\u003cp\u003eTo transition FreeType to Skia the Chrome team developed a new Skia font backend\nbased on \u003ca href=\"https://github.com/googlefonts/fontations/tree/main/skrifa\"\u003eSkrifa\u003c/a\u003e\nand gradually rolled out the change to users:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eIn \u003ca href=\"https://chromiumdash.appspot.com/commit/6df58d58e667f19490acc1c51095aaf08842bea7\"\u003eChrome 128 (August 2024) we enabled\nFontations\u003c/a\u003e\nfor use in less commonly used font formats, such as for color fonts and\nCFF2, as a safe trial run.\u003c/li\u003e\n\u003cli\u003eIn \u003ca href=\"https://chromestatus.com/feature/5717358869217280\"\u003eChrome 133 (February 2025) we enabled\nFontations\u003c/a\u003e for all web\nfonts usage on Linux, Android and ChromeOS, and for web fonts usage as\nfallback on Windows and Mac—in cases where the system does not support a\nfont format but Chrome needs to display it.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eFor the integration into Chrome, we rely on the smooth integration of Rust into\nthe codebase introduced by the \u003ca href=\"https://security.googleblog.com/2023/01/supporting-use-of-rust-in-chromium.html\"\u003eChrome security\nteam\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eIn the future we\u0026#39;ll switch to Fontations for operating system fonts as well,\nstarting with Linux and ChromeOS, then on Android.\u003c/p\u003e\n\n\u003ch3 id=\"safety_first_and_foremost\" data-text=\"Safety, first and foremost\" tabindex=\"-1\"\u003eSafety, first and foremost\u003c/h3\u003e\n\n\u003cp\u003eOur primary goal is to reduce (or ideally, eliminate!) security vulnerabilities\nthat are caused by out of bounds access to memory. Rust provides this out of the\nbox as long as you avoid any \u003cem\u003eunsafe\u003c/em\u003e code blocks.\u003c/p\u003e\n\n\u003cp\u003eOur performance goals require us to perform one operation that is currently\nunsafe: reinterpretation of arbitrary bytes as a strongly typed data structure.\nThis allows us to read the data from a font file without performing \u003ca href=\"https://en.wikipedia.org/wiki/Zero-copy\"\u003eunnecessary\ncopies\u003c/a\u003e and is essential for producing\na fast font parser.\u003c/p\u003e\n\n\u003cp\u003eTo avoid our own unsafe code, we\u0026#39;ve chosen to outsource this responsibility to\n\u003ca href=\"https://crates.io/crates/bytemuck\"\u003ebytemuck\u003c/a\u003e which is a Rust library designed\nspecifically for this purpose and is widely tested and used across the\necosystem. Concentrating raw data reinterpretation in bytemuck ensures we have\nthis functionality in one place and audited, and avoid repeating unsafe code for\nthe purpose. The \u003ca href=\"https://rust-lang.github.io/rfcs/2835-project-safe-transmute.html\"\u003esafe transmute\nproject\u003c/a\u003e aims\nto incorporate this functionality directly into the Rust compiler and we will\nmake the switch as soon as it is available.\u003c/p\u003e\n\n\u003ch3 id=\"correctness_matters\" data-text=\"Correctness matters\" tabindex=\"-1\"\u003eCorrectness matters\u003c/h3\u003e\n\n\u003cp\u003eSkrifa is built out of independent components where most data structures are\ndesigned to be immutable. This improves readability, maintainability and\nmultithreading. It also makes the code more amenable to unit testing. We\u0026#39;ve\ntaken advantage of this opportunity and have produced a suite of roughly 700\nunit tests that cover our full stack from low level parsing routines to high\nlevel hinting virtual machines.\u003c/p\u003e\n\n\u003cp\u003eCorrectness also implies fidelity and FreeType is highly regarded for its\ngeneration of high quality outlines. We must match this quality to be a suitable\nreplacement. To that end, we have built a bespoke tool called\n\u003ca href=\"https://github.com/googlefonts/fontations/tree/main/fauntlet\"\u003efauntlet\u003c/a\u003e that\ncompares the output of Skrifa and FreeType for batches of font files across a\nwide range of configurations. This affords us some assurance that we can avoid\nregressions in quality.\u003c/p\u003e\n\n\u003cp\u003eIn addition, before the integration into Chromium, we ran a \u003ca href=\"https://source.chromium.org/chromium/chromium/src/+/main:third_party/skia/gm/fontations_ft_compare.cpp\"\u003ewide set of pixel\ncomparisons\u003c/a\u003e\nin Skia, comparing FreeType rendering to Skrifa and Skia rendering to ensure the\npixel differences are absolutely minimal, in all required rendering modes\n(across different antialiasing and hinting modes).\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Fuzzing\"\u003eFuzz testing\u003c/a\u003e is an important tool for\ndetermining how a piece of software will react to malformed and malicious\ninputs. We\u0026#39;ve been continuously fuzzing our new code since June of 2024. This\ncovers the Rust libraries itself and the integration code. While the fuzzer has\nfound (as of this writing) 39 bugs, it\u0026#39;s worth noting that \u003cstrong\u003enone of these have\nbeen security critical\u003c/strong\u003e. They may cause undesired visual results or even\ncontrolled crashes, but won\u0026#39;t lead to exploitable vulnerabilities.\u003c/p\u003e\n\n\u003ch2 id=\"onward\" data-text=\"Onward!\" tabindex=\"-1\"\u003eOnward!\u003c/h2\u003e\n\n\u003cp\u003eWe are very pleased with the results of our efforts to use Rust for text.\nDelivering safer code to users \u003cem\u003eand\u003c/em\u003e gaining developer productivity is a huge\nwin for us. We plan to continue to seek opportunities to use Rust in our text\nstacks. If you\u0026#39;d like to know more,\n\u003ca href=\"https://github.com/googlefonts/oxidize\"\u003eOxidize\u003c/a\u003e outlines some of Google Fonts\nfuture plans.\u003c/p\u003e\n\n  \n\n  \n\u003c/div\u003e\n\n  \n\n  \n    \n    \n      \n    \u003cdevsite-thumb-rating position=\"footer\"\u003e\n    \u003c/devsite-thumb-rating\u003e\n  \n       \n    \n    \n  \n\n  \n  \n\u003c/article\u003e\n\n\n\u003cdevsite-content-footer\u003e\n  \u003cp\u003eExcept as otherwise noted, the content of this page is licensed under the \u003ca href=\"https://creativecommons.org/licenses/by/4.0/\"\u003eCreative Commons Attribution 4.0 License\u003c/a\u003e, and code samples are licensed under the \u003ca href=\"https://www.apache.org/licenses/LICENSE-2.0\"\u003eApache 2.0 License\u003c/a\u003e. For details, see the \u003ca href=\"https://developers.google.com/site-policies\"\u003eGoogle Developers Site Policies\u003c/a\u003e. Java is a registered trademark of Oracle and/or its affiliates.\u003c/p\u003e\n  \u003cp\u003eLast updated 2025-03-19 UTC.\u003c/p\u003e\n\u003c/devsite-content-footer\u003e\n\n\n\u003cdevsite-notification\u003e\n\u003c/devsite-notification\u003e\n\n\n  \n\u003cp\u003e\n  \n  \n    \u003ctemplate\u003e\n      [[[\u0026#34;Easy to understand\u0026#34;,\u0026#34;easyToUnderstand\u0026#34;,\u0026#34;thumb-up\u0026#34;],[\u0026#34;Solved my problem\u0026#34;,\u0026#34;solvedMyProblem\u0026#34;,\u0026#34;thumb-up\u0026#34;],[\u0026#34;Other\u0026#34;,\u0026#34;otherUp\u0026#34;,\u0026#34;thumb-up\u0026#34;]],[[\u0026#34;Missing the information I need\u0026#34;,\u0026#34;missingTheInformationINeed\u0026#34;,\u0026#34;thumb-down\u0026#34;],[\u0026#34;Too complicated / too many steps\u0026#34;,\u0026#34;tooComplicatedTooManySteps\u0026#34;,\u0026#34;thumb-down\u0026#34;],[\u0026#34;Out of date\u0026#34;,\u0026#34;outOfDate\u0026#34;,\u0026#34;thumb-down\u0026#34;],[\u0026#34;Samples / code issue\u0026#34;,\u0026#34;samplesCodeIssue\u0026#34;,\u0026#34;thumb-down\u0026#34;],[\u0026#34;Other\u0026#34;,\u0026#34;otherDown\u0026#34;,\u0026#34;thumb-down\u0026#34;]],[\u0026#34;Last updated 2025-03-19 UTC.\u0026#34;],[],[]]\n    \u003c/template\u003e\n  \n\u003c/p\u003e\n            \n          \u003c/devsite-content\u003e\n        \u003c/main\u003e\n        \n        \n        \n        \u003cdevsite-panel\u003e\u003c/devsite-panel\u003e\n        \n      \u003c/section\u003e\u003c/section\u003e\n    \u003cdevsite-sitemask\u003e\u003c/devsite-sitemask\u003e\n    \u003cdevsite-snackbar\u003e\u003c/devsite-snackbar\u003e\n    \u003cdevsite-tooltip\u003e\u003c/devsite-tooltip\u003e\n    \u003cdevsite-heading-link\u003e\u003c/devsite-heading-link\u003e\n    \u003cdevsite-analytics\u003e\n      \n        \n\n      \n    \u003c/devsite-analytics\u003e\n    \n      \u003cdevsite-badger\u003e\u003c/devsite-badger\u003e\n    \n    \n    \n\n\n    \u003cdevsite-a11y-announce\u003e\u003c/devsite-a11y-announce\u003e\n  \n\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
