{
  "id": "a08a2073-ce70-4faf-ae23-2c01eb3e71fb",
  "title": "Compiling CSS With Vite and Lightning CSS",
  "link": "https://css-tricks.com/compiling-css-with-vite-and-lightning-css/",
  "description": "Are partials the only thing keeping you writing CSS in Sass? With a little configuration, it's possible to compile partial CSS files without a Sass dependency. Ryan Trimble has the details. Compiling CSS With Vite and Lightning CSS originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Ryan Trimble",
  "published": "Mon, 03 Feb 2025 15:23:37 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "deployment",
    "DevTools",
    "Sass"
  ],
  "byline": "Ryan Trimble",
  "length": 16273,
  "excerpt": "Are partials the only thing keeping you writing CSS in Sass? With a little configuration, it's possible to compile partial CSS files without a Sass dependency. Ryan Trimble has the details.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "Suppose you follow CSS feature development as closely as we do here at CSS-Tricks. In that case, you may be like me and eager to use many of these amazing tools but find browser support sometimes lagging behind what might be considered “modern” CSS (whatever that means). Even if browser vendors all have a certain feature released, users might not have the latest versions! We can certainly plan for this a number of ways: feature detection with @supports progressively enhanced designs polyfills For even extra help, we turn to build tools. Chances are, you’re already using some sort of build tool in your projects today. CSS developers are most likely familiar with CSS pre-processors (such as Sass or Less), but if you don’t know, these are tools capable of compiling many CSS files into one stylesheet. CSS pre-processors help make organizing CSS a lot easier, as you can move parts of CSS into related folders and import things as needed. Pre-processors do not just provide organizational superpowers, though. Sass gave us a crazy list of features to work with, including: extends functions loops mixins nesting variables …more, probably! For a while, this big feature set provided a means of filling gaps missing from CSS, making Sass (or whatever preprocessor you fancy) feel like a necessity when starting a new project. CSS has evolved a lot since the release of Sass — we have so many of those features in CSS today — so it doesn’t quite feel that way anymore, especially now that we have native CSS nesting and custom properties. Along with CSS pre-processors, there’s also the concept of post-processing. This type of tool usually helps transform compiled CSS in different ways, like auto-prefixing properties for different browser vendors, code minification, and more. PostCSS is the big one here, giving you tons of ways to manipulate and optimize your code, another step in the build pipeline. In many implementations I’ve seen, the build pipeline typically runs roughly like this: Generate static assets Build application files Bundle for deployment CSS is usually handled in that first part, which includes running CSS pre- and post-processors (though post-processing might also happen after Step 2). As mentioned, the continued evolution of CSS makes it less necessary for a tool such as Sass, so we might have an opportunity to save some time. Vite for CSS Awarded “Most Adopted Technology” and “Most Loved Library” from the State of JavaScript 2024 survey, Vite certainly seems to be one of the more popular build tools available. Vite is mainly used to build reactive JavaScript front-end frameworks, such as Angular, React, Svelte, and Vue (made by the same developer, of course). As the name implies, Vite is crazy fast and can be as simple or complex as you need it, and has become one of my favorite tools to work with. Vite is mostly thought of as a JavaScript tool for JavaScript projects, but you can use it without writing any JavaScript at all. Vite works with Sass, though you still need to install Sass as a dependency to include it in the build pipeline. On the other hand, Vite also automatically supports compiling CSS with no extra steps. We can organize our CSS code how we see fit, with no or very minimal configuration necessary. Let’s check that out. We will be using Node and npm to install Node packages, like Vite, as well as commands to run and build the project. If you do not have node or npm installed, please check out the download page on their website. Navigate a terminal to a safe place to create a new project, then run: npm create vite@latest The command line interface will ask a few questions, you can keep it as simple as possible by choosing Vanilla and JavaScript which will provide you with a starter template including some no-frameworks-attached HTML, CSS, and JavaScript files to help get you started. Before running other commands, open the folder in your IDE (integrated development environment, such as VSCode) of choice so that we can inspect the project files and folders. If you would like to follow along with me, delete the following files that are unnecessary for demonstration: assets/ public/ src/ .gitignore We should only have the following files left in out project folder: index.html package.json Let’s also replace the contents of index.html with an empty HTML template: \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eCSS Only Vite Project\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- empty for now --\u003e \u003c/body\u003e \u003c/html\u003e One last piece to set up is Vite’s dependencies, so let’s run the npm installation command: npm install A short sequence will occur in the terminal. Then we’ll see a new folder called node_modules/ and a package-lock.json file added in our file viewer. node_modules is used to house all package files installed through node package manager, and allows us to import and use installed packages throughout our applications. package-lock.json is a file usually used to make sure a development team is all using the same versions of packages and dependencies. We most likely won’t need to touch these things, but they are necessary for Node and Vite to process our code during the build. Inside the project’s root folder, we can create a styles/ folder to contain the CSS we will write. Let’s create one file to begin with, main.css, which we can use to test out Vite. ├── public/ ├── styles/ | └── main.css └──index.html In our index.html file, inside the \u003chead\u003e section, we can include a \u003clink\u003e tag pointing to the CSS file: \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003clink rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eCSS Only Vite Project\u003c/title\u003e \u003c!-- Main CSS --\u003e \u003clink rel=\"stylesheet\" href=\"styles/main.css\"\u003e \u003c/head\u003e Let’s add a bit of CSS to main.css: body { background: green; } It’s not much, but it’s all we’ll need at the moment! In our terminal, we can now run the Vite build command using npm: npm run build With everything linked up properly, Vite will build things based on what is available within the index.html file, including our linked CSS files. The build will be very fast, and you’ll be returned to your terminal prompt. Vite will provide a brief report, showcasing the file sizes of the compiled project. The newly generated dist/ folder is Vite’s default output directory, which we can open and see our processed files. Checking out assets/index.css (the filename will include a unique hash for cache busting), and you’ll see the code we wrote, minified here. Now that we know how to make Vite aware of our CSS, we will probably want to start writing more CSS for it to compile. As quick as Vite is with our code, constantly re-running the build command would still get very tedious. Luckily, Vite provides its own development server, which includes a live environment with hot module reloading, making changes appear instantly in the browser. We can start the Vite development server by running the following terminal command: npm run dev Vite uses the default network port 5173 for the development server. Opening the http://localhost:5137/ address in your browser will display a blank screen with a green background. Adding any HTML to the index.html or CSS to main.css, Vite will reload the page to display changes. To stop the development server, use the keyboard shortcut CTRL+C or close the terminal to kill the process. At this point, you pretty much know all you need to know about how to compile CSS files with Vite. Any CSS file you link up will be included in the built file. Organizing CSS into Cascade Layers One of the items on my 2025 CSS Wishlist is the ability to apply a cascade layer to a link tag. To me, this might be helpful to organize CSS in a meaningful ways, as well as fine control over the cascade, with the benefits cascade layers provide. Unfortunately, this is a rather difficult ask when considering the way browsers paint styles in the viewport. This type of functionality is being discussed between the CSS Working Group and TAG, but it’s unclear if it’ll move forward. With Vite as our build tool, we can replicate the concept as a way to organize our built CSS. Inside the main.css file, let’s add the @layer at-rule to set the cascade order of our layers. I’ll use a couple of layers here for this demo, but feel free to customize this setup to your needs. /* styles/main.css */ @layer reset, layouts; This is all we’ll need inside our main.css, let’s create another file for our reset. I’m a fan of my friend Mayank‘s modern CSS reset, which is available as a Node package. We can install the reset by running the following terminal command: npm install @acab/reset.css Now, we can import Mayank’s reset into our newly created reset.css file, as a cascade layer: /* styles/reset.css */ @import '@acab/reset.css' layer(reset); If there are any other reset layer stylings we want to include, we can open up another @layer reset block inside this file as well. /* styles/reset.css */ @import '@acab/reset.css' layer(reset); @layer reset { /* custom reset styles */ } This @import statement is used to pull packages from the node_modules folder. This folder is not generally available in the built, public version of a website or application, so referencing this might cause problems if not handled properly. Now that we have two files (main.css and reset.css), let’s link them up in our index.html file. Inside the \u003chead\u003e tag, let’s add them after \u003ctitle\u003e: \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003clink rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eCSS Only Vite Project\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"styles/main.css\"\u003e \u003clink rel=\"stylesheet\" href=\"styles/reset.css\"\u003e \u003c/head\u003e The idea here is we can add each CSS file, in the order we need them parsed. In this case, I’m planning to pull in each file named after the cascade layers setup in the main.css file. This may not work for every setup, but it is a helpful way to keep in mind the precedence of how cascade layers affect computed styles when rendered in a browser, as well as grouping similarly relevant files. Since we’re in the index.html file, we’ll add a third CSS \u003clink\u003e for styles/layouts.css. \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003clink rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eCSS Only Vite Project\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"styles/main.css\"\u003e \u003clink rel=\"stylesheet\" href=\"styles/reset.css\"\u003e \u003clink rel=\"stylesheet\" href=\"styles/layouts.css\"\u003e \u003c/head\u003e Create the styles/layouts.css file with the new @layer layouts declaration block, where we can add layout-specific stylings. /* styles/layouts.css */ @layer layouts { /* layouts styles */ } For some quick, easy, and awesome CSS snippets, I tend to refer to Stephanie Eckles‘ SmolCSS project. Let’s grab the “Smol intrinsic container” code and include it within the layouts cascade layer: /* styles/layouts.css */ @layer layouts { .smol-container { width: min(100% - 3rem, var(--container-max, 60ch)); margin-inline: auto; } } This powerful little, two-line container uses the CSS min() function to provide a responsive width, with margin-inline: auto; set to horizontally center itself and contain its child elements. We can also dynamically adjust the width using the --container-max custom property. Now if we re-run the build command npm run build and check the dist/ folder, our compiled CSS file should contain: Our cascade layer declarations from main.css Mayank’s CSS reset fully imported from reset.css The .smol-container class added from layouts.csss As you can see, we can get quite far with Vite as our build tool without writing any JavaScript. However, if we choose to, we can extend our build’s capabilities even further by writing just a little bit of JavaScript. Post-processing with LightningCSS Lightning CSS is a CSS parser and post-processing tool that has a lot of nice features baked into it to help with cross-compatibility among browsers and browser versions. Lightning CSS can transform a lot of modern CSS into backward-compatible styles for you. We can install Lightning CSS in our project with npm: npm install --save-dev lightningcss The --save-dev flag means the package will be installed as a development dependency, as it won’t be included with our built project. We can include it within our Vite build process, but first, we will need to write a tiny bit of JavaScript, a configuration file for Vite. Create a new file called: vite.config.mjs and inside add the following code: // vite.config.mjs export default { css: { transformer: 'lightningcss' }, build: { cssMinify: 'lightningcss' } }; Vite will now use LightningCSS to transform and minify CSS files. Now, let’s give it a test run using an oklch color. Inside main.css let’s add the following code: /* main.css */ body { background-color: oklch(51.98% 0.1768 142.5); } Then re-running the Vite build command, we can see the background-color property added in the compiled CSS: /* dist/index.css */ body { background-color: green; background-color: color(display-p3 0.216141 0.494224 0.131781); background-color: lab(46.2829% -47.5413 48.5542); } Lightning CSS converts the color white providing fallbacks available for browsers which might not support newer color types. Following the Lightning CSS documentation for using it with Vite, we can also specify browser versions to target by installing the browserslist package. Browserslist will give us a way to specify browsers by matching certain conditions (try it out online!) npm install -D browserslist Inside our vite.config.mjs file, we can configure Lightning CSS further. Let’s import the browserslist package into the Vite configuration, as well as a module from the Lightning CSS package to help us use browserlist in our config: // vite.config.mjs import browserslist from 'browserslist'; import { browserslistToTargets } from 'lightningcss'; We can add configuration settings for lightningcss, containing the browser targets based on specified browser versions to Vite’s css configuration: // vite.config.mjs import browserslist from 'browserslist'; import { browserslistToTargets } from 'lightningcss'; export default { css: { transformer: 'lightningcss', lightningcss: { targets: browserslistToTargets(browserslist('\u003e= 0.25%')), } }, build: { cssMinify: 'lightningcss' } }; There are lots of ways to extend Lightning CSS with Vite, such as enabling specific features, excluding features we won’t need, or writing our own custom transforms. // vite.config.mjs import browserslist from 'browserslist'; import { browserslistToTargets, Features } from 'lightningcss'; export default { css: { transformer: 'lightningcss', lightningcss: { targets: browserslistToTargets(browserslist('\u003e= 0.25%')), // Including `light-dark()` and `colors()` functions include: Features.LightDark | Features.Colors, } }, build: { cssMinify: 'lightningcss' } }; For a full list of the Lightning CSS features, check out their documentation on feature flags. Is any of this necessary? Reading through all this, you may be asking yourself if all of this is really necessary. The answer: absolutely not! But I think you can see the benefits of having access to partialized files that we can compile into unified stylesheets. I doubt I’d go to these lengths for smaller projects, however, if building something with more complexity, such as a design system, I might reach for these tools for organizing code, cross-browser compatibility, and thoroughly optimizing compiled CSS.",
  "image": "https://css-tricks.com/wp-json/social-image-generator/v1/image/384050",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eSuppose you follow CSS feature development as closely as we do here at CSS-Tricks. In that case, you may be like me and eager to use many of these amazing tools but find browser support sometimes lagging behind what might be considered “modern” CSS (\u003ca href=\"https://geoffgraham.me/what-exactly-is-modern-css/\" rel=\"noopener\"\u003ewhatever that means\u003c/a\u003e).\u003c/p\u003e\n\n\n\n\u003cp\u003eEven if browser vendors all have a certain feature released, users might not have the latest versions!\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can certainly plan for this a number of ways:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003efeature detection with \u003ccode\u003e@supports\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cem\u003eprogressively enhanced\u003c/em\u003e designs\u003c/li\u003e\n\n\n\n\u003cli\u003epolyfills\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eFor even extra help, we turn to build tools. Chances are, you’re already using some sort of build tool in your projects today. CSS developers are \u003cem\u003emost likely\u003c/em\u003e familiar with CSS pre-processors (such as \u003ca href=\"https://sass-lang.com/\" rel=\"noopener\"\u003eSass\u003c/a\u003e or \u003ca href=\"https://lesscss.org/\" rel=\"noopener\"\u003eLess\u003c/a\u003e), but if you don’t know, these are tools capable of compiling many CSS files into one stylesheet. CSS pre-processors help make organizing CSS a lot easier, as you can move parts of CSS into related folders and import things as needed.\u003c/p\u003e\n\n\n\n\u003cp\u003ePre-processors do not \u003cem\u003ejust\u003c/em\u003e provide organizational superpowers, though. Sass gave us a crazy list of features to work with, including:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eextends\u003c/li\u003e\n\n\n\n\u003cli\u003efunctions\u003c/li\u003e\n\n\n\n\u003cli\u003eloops\u003c/li\u003e\n\n\n\n\u003cli\u003emixins\u003c/li\u003e\n\n\n\n\u003cli\u003enesting\u003c/li\u003e\n\n\n\n\u003cli\u003evariables\u003c/li\u003e\n\n\n\n\u003cli\u003e…more, probably!\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eFor a while, this big feature set provided a means of filling gaps missing from CSS, making Sass (or whatever preprocessor you fancy) feel like a necessity when starting a new project. CSS has evolved a lot since the release of Sass — we have so many of those features in CSS today — so it doesn’t quite feel that way anymore, especially now that we have native \u003ca href=\"https://css-tricks.com/css-selectors/#aa-nesting-selectors\"\u003eCSS nesting\u003c/a\u003e and \u003ca href=\"https://css-tricks.com/a-complete-guide-to-custom-properties/\"\u003ecustom properties\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eAlong with CSS pre-processors, there’s also the concept of \u003cem\u003epost\u003c/em\u003e-processing. This type of tool usually helps transform compiled CSS in different ways, like auto-prefixing properties for different browser vendors, code minification, and more. \u003ca href=\"https://postcss.org/\" rel=\"noopener\"\u003ePostCSS\u003c/a\u003e is the big one here, giving you tons of ways to manipulate and optimize your code, another step in the build pipeline.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn many implementations I’ve seen, the build pipeline typically runs roughly like this:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eGenerate static assets\u003c/li\u003e\n\n\n\n\u003cli\u003eBuild application files\u003c/li\u003e\n\n\n\n\u003cli\u003eBundle for deployment\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eCSS is usually handled in that first part, which includes running CSS pre- and post-processors (though post-processing might also happen after Step 2). As mentioned, the continued evolution of CSS makes it less necessary for a tool such as Sass, so we might have an opportunity to save some time.\u003c/p\u003e\n\n\n\u003ch3 id=\"vite-for-css\"\u003eVite for CSS\u003c/h3\u003e\n\n\n\u003cp\u003eAwarded “\u003cem\u003eMost Adopted Technology\u003c/em\u003e” and “\u003cem\u003eMost Loved Library\u003c/em\u003e” from the \u003ca href=\"https://2024.stateofjs.com/en-US/awards/\" rel=\"noopener\"\u003eState of JavaScript 2024\u003c/a\u003e survey, \u003ca href=\"https://vite.dev/\" rel=\"noopener\"\u003eVite\u003c/a\u003e certainly seems to be one of the more popular build tools available. Vite is mainly used to build reactive JavaScript front-end frameworks, such as Angular, React, Svelte, and Vue (made by the same developer, of course). As the name implies, Vite is crazy fast and can be as simple or complex as you need it, and has become one of my favorite tools to work with.\u003c/p\u003e\n\n\n\n\u003cp\u003eVite is mostly thought of as a \u003cem\u003eJavaScript\u003c/em\u003e tool for \u003cem\u003eJavaScript\u003c/em\u003e projects, but you can use it without writing any JavaScript at all. Vite works with Sass, though you still need to install Sass as a dependency to include it in the build pipeline. On the other hand, Vite also automatically supports compiling CSS with no extra steps. We can organize our CSS code how we see fit, with no or very minimal configuration necessary. Let’s check that out.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe will be using Node and npm to install Node packages, like Vite, as well as commands to run and build the project. If you do not have \u003ccode\u003enode\u003c/code\u003e or \u003ccode\u003enpm\u003c/code\u003e installed, please check out \u003ca href=\"https://nodejs.org/en/download\" rel=\"noopener\"\u003ethe download page on their website\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eNavigate a terminal to a safe place to create a new project, then run:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"Terminal\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003enpm create vite@latest\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe command line interface will ask a few questions, you can keep it as simple as possible by choosing \u003ccode\u003eVanilla\u003c/code\u003e and \u003ccode\u003eJavaScript\u003c/code\u003e which will provide you with a starter template including some no-frameworks-attached HTML, CSS, and JavaScript files to help get you started.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"612\" height=\"455\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/vite-install.png?resize=612%2C455\u0026amp;ssl=1\" alt=\"terminal displaying the output of running the command npm create vite@latest\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/vite-install.png?w=612\u0026amp;ssl=1 612w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/vite-install.png?resize=300%2C223\u0026amp;ssl=1 300w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eBefore running other commands, open the folder in your IDE (integrated development environment, such as \u003ca href=\"https://code.visualstudio.com/\" rel=\"noopener\"\u003eVSCode\u003c/a\u003e) of choice so that we can inspect the project files and folders.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you would like to follow along with me, \u003cem\u003edelete\u003c/em\u003e the following files that are unnecessary for demonstration:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eassets/\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003epublic/\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003esrc/\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e.gitignore\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWe should only have the following files left in out project folder:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eindex.html\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003epackage.json\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"668\" height=\"161\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-1.png?resize=668%2C161\u0026amp;ssl=1\" alt=\"VSCode file browser display two files: index.html and package.json\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-1.png?w=668\u0026amp;ssl=1 668w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-1.png?resize=300%2C72\u0026amp;ssl=1 300w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eLet’s also replace the contents of \u003ccode\u003eindex.html\u003c/code\u003e with an empty HTML template:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;!doctype html\u0026gt;\n\n\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\n  \u0026lt;head\u0026gt;\n    \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt;\n    \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt;\n\t\n    \u0026lt;title\u0026gt;CSS Only Vite Project\u0026lt;/title\u0026gt;\n  \u0026lt;/head\u0026gt;\n  \u0026lt;body\u0026gt;\n    \u0026lt;!-- empty for now --\u0026gt;\n  \u0026lt;/body\u0026gt;\n\u0026lt;/html\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOne last piece to set up is Vite’s dependencies, so let’s run the npm installation command:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"Terminal\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003enpm install\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"945\" height=\"392\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-2.png?resize=945%2C392\u0026amp;ssl=1\" alt=\"terminal displaying the output of running the command npm install\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-2.png?w=945\u0026amp;ssl=1 945w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-2.png?resize=300%2C124\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-2.png?resize=768%2C319\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eA short sequence will occur in the terminal. Then we’ll see a new folder called \u003ccode\u003enode_modules/\u003c/code\u003e and a \u003ccode\u003epackage-lock.json\u003c/code\u003e file added in our file viewer.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enode_modules\u003c/code\u003e is used to house all package files installed through node package manager, and allows us to import and use installed packages throughout our applications.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003epackage-lock.json\u003c/code\u003e is a file usually used to make sure a development team is all using the same versions of packages and dependencies.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"587\" height=\"245\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-3.png?resize=587%2C245\u0026amp;ssl=1\" alt=\"VSCode file browser displaying a node_modules folder, index.html file, package-lock.json file, and a package.json file\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-3.png?w=587\u0026amp;ssl=1 587w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-3.png?resize=300%2C125\u0026amp;ssl=1 300w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWe most likely won’t need to touch these things, but they are necessary for Node and Vite to process our code during the build. Inside the project’s root folder, we can create a \u003ccode\u003estyles/\u003c/code\u003e folder to contain the CSS we will write. Let’s create one file to begin with, \u003ccode\u003emain.css\u003c/code\u003e, which we can use to test out Vite.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e├── public/\n├── styles/\n|   └── main.css\n└──index.html\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn our \u003ccode\u003eindex.html\u003c/code\u003e file, inside the \u003ccode\u003e\u0026lt;head\u0026gt;\u003c/code\u003e section, we can include a \u003ccode\u003e\u0026lt;link\u0026gt;\u003c/code\u003e tag pointing to the CSS file:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"9\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;head\u0026gt;\n  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt;\n  \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/svg+xml\u0026#34; href=\u0026#34;/vite.svg\u0026#34; /\u0026gt;\n  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt;\n\t\n  \u0026lt;title\u0026gt;CSS Only Vite Project\u0026lt;/title\u0026gt;\n\n  \u0026lt;!-- Main CSS --\u0026gt;\n  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles/main.css\u0026#34;\u0026gt;\n\u0026lt;/head\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s add a bit of CSS to \u003ccode\u003emain.css\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebody {\n  background: green;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIt’s not much, but it’s all we’ll need at the moment! In our terminal, we can now run the Vite build command using \u003ccode\u003enpm\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"Terminal\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003enpm run build\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith everything linked up properly, Vite will build things based on what is available within the \u003ccode\u003eindex.html\u003c/code\u003e file, including our linked CSS files. The build will be \u003cem\u003every\u003c/em\u003e fast, and you’ll be returned to your terminal prompt.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1043\" height=\"462\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-4.png?resize=1043%2C462\u0026amp;ssl=1\" alt=\"Terminal displaying the output of the command npm run build, including the filesizes of compiled files\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-4.png?w=1043\u0026amp;ssl=1 1043w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-4.png?resize=300%2C133\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-4.png?resize=1024%2C454\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-4.png?resize=768%2C340\u0026amp;ssl=1 768w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003cfigcaption\u003eVite will provide a brief report, showcasing the file sizes of the compiled project.\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe newly generated \u003ccode\u003edist/\u003c/code\u003e folder is Vite’s default output directory, which we can open and see our processed files. Checking out \u003ccode\u003eassets/index.css\u003c/code\u003e (the filename will include a unique hash for \u003ca href=\"https://www.keycdn.com/support/what-is-cache-busting\" rel=\"noopener\"\u003ecache busting\u003c/a\u003e), and you’ll see the code we wrote, minified here.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"713\" height=\"221\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-5.png?resize=713%2C221\u0026amp;ssl=1\" alt=\"VSCode editor displaying a minified CSS file\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-5.png?w=713\u0026amp;ssl=1 713w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-5.png?resize=300%2C93\u0026amp;ssl=1 300w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNow that we know how to make Vite aware of our CSS, we will probably want to start writing more CSS for it to compile.\u003c/p\u003e\n\n\n\n\u003cp\u003eAs quick as Vite is with our code, constantly re-running the build command would still get very tedious. Luckily, Vite provides its own development server, which includes a live environment with hot module reloading, making changes appear instantly in the browser. We can start the Vite development server by running the following terminal command:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"Terminal\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003enpm run dev\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"504\" height=\"196\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-6.png?resize=504%2C196\u0026amp;ssl=1\" alt=\"Vite development server running in a terminal\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-6.png?w=504\u0026amp;ssl=1 504w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-6.png?resize=300%2C117\u0026amp;ssl=1 300w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eVite uses the default network port \u003ccode\u003e5173\u003c/code\u003e for the development server. Opening the \u003ccode\u003ehttp://localhost:5137/\u003c/code\u003e address in your browser will display a blank screen with a green background.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"657\" height=\"341\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-7.png?resize=657%2C341\u0026amp;ssl=1\" alt=\"Arc browser window, navigated to http://localhost:5173, a blank page with a green background\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-7.png?w=657\u0026amp;ssl=1 657w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-7.png?resize=300%2C156\u0026amp;ssl=1 300w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAdding any HTML to the \u003ccode\u003eindex.html\u003c/code\u003e or CSS to \u003ccode\u003emain.css\u003c/code\u003e, Vite will reload the page to display changes. To stop the development server, use the keyboard shortcut \u003ckbd\u003eCTRL\u003c/kbd\u003e+\u003ckbd\u003eC\u003c/kbd\u003e or close the terminal to kill the process.\u003c/p\u003e\n\n\n\n\u003cp\u003eAt this point, you pretty much know all you need to know about how to compile CSS files with Vite. Any CSS file you link up will be included in the built file.\u003c/p\u003e\n\n\n\u003ch3 id=\"organizing-css-into-cascade-layers\"\u003eOrganizing CSS into Cascade Layers\u003c/h3\u003e\n\n\n\u003cp\u003eOne of the items on my \u003ca href=\"https://css-tricks.com/a-css-wishlist-for-2025/\"\u003e2025 CSS Wishlist\u003c/a\u003e is the ability to \u003ca href=\"https://css-tricks.com/a-css-wishlist-for-2025/#aa-7-adding-a-layer-attribute-to-link-tags\"\u003eapply a cascade layer\u003c/a\u003e to a \u003ccode\u003elink\u003c/code\u003e tag. To me, this might be helpful to organize CSS in a meaningful ways, as well as fine control over the cascade, with the benefits cascade layers provide. Unfortunately, this is a rather difficult ask when considering the way browsers paint styles in the viewport. This type of functionality is being discussed between the \u003ca href=\"https://github.com/w3c/csswg-drafts/issues/5853\" rel=\"noopener\"\u003eCSS Working Group\u003c/a\u003e and \u003ca href=\"https://github.com/w3ctag/design-reviews/issues/970\" rel=\"noopener\"\u003eTAG\u003c/a\u003e, but it’s unclear if it’ll move forward.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith Vite as our build tool, we can replicate the concept as a way to organize our built CSS. Inside the \u003ccode\u003emain.css\u003c/code\u003e file, let’s add the @layer at-rule to set the cascade order of our layers. I’ll use a couple of layers here for this demo, but feel free to customize this setup to your needs.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* styles/main.css */\n@layer reset, layouts;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is all we’ll need inside our \u003ccode\u003emain.css\u003c/code\u003e, let’s create another file for our reset. I’m a fan of my friend \u003ca href=\"https://mayank.co/\" rel=\"noopener\"\u003eMayank\u003c/a\u003e‘s modern CSS reset, which is available as a \u003ca href=\"https://www.npmjs.com/package/@acab/reset.css\" rel=\"noopener\"\u003eNode package\u003c/a\u003e. We can install the reset by running the following terminal command:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003enpm install @acab/reset.css\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"940\" height=\"377\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-8.png?resize=940%2C377\u0026amp;ssl=1\" alt=\"Terminal displaying the output of running npm install @acab/reset.css\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-8.png?w=940\u0026amp;ssl=1 940w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-8.png?resize=300%2C120\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/01/css-only-vite-8.png?resize=768%2C308\u0026amp;ssl=1 768w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNow, we can import Mayank’s reset into our newly created \u003ccode\u003ereset.css\u003c/code\u003e file, as a cascade layer:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"3\"\u003e\u003ccode markup=\"tt\"\u003e/* styles/reset.css */\n@import \u0026#39;@acab/reset.css\u0026#39; layer(reset);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf there are any other reset layer stylings we want to include, we can open up another \u003ccode\u003e@layer reset\u003c/code\u003e block inside this file as well.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"5-7\"\u003e\u003ccode markup=\"tt\"\u003e/* styles/reset.css */\n@import \u0026#39;@acab/reset.css\u0026#39; layer(reset);\n\n@layer reset {\n  /* custom reset styles */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis \u003ccode\u003e@import\u003c/code\u003e statement is used to pull packages from the \u003ccode\u003enode_modules\u003c/code\u003e folder. This folder is not \u003cem\u003egenerally\u003c/em\u003e available in the built, public version of a website or application, so referencing this might cause problems if not handled properly.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow that we have two files (\u003ccode\u003emain.css\u003c/code\u003e and \u003ccode\u003ereset.css\u003c/code\u003e), let’s link them up in our \u003ccode\u003eindex.html\u003c/code\u003e file. Inside the \u003ccode\u003e\u0026lt;head\u0026gt;\u003c/code\u003e tag, let’s add them after \u003ccode\u003e\u0026lt;title\u0026gt;\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"8,9\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;head\u0026gt;\n  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt;\n  \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/svg+xml\u0026#34; href=\u0026#34;/vite.svg\u0026#34; /\u0026gt;\n  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt;\n\t\n  \u0026lt;title\u0026gt;CSS Only Vite Project\u0026lt;/title\u0026gt;\n\t\n  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles/main.css\u0026#34;\u0026gt;\n  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles/reset.css\u0026#34;\u0026gt;\n\u0026lt;/head\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe idea here is we can add each CSS file, in the order we need them parsed. In this case, I’m planning to pull in each file named after the cascade layers setup in the main.css file. This may not work for every setup, but it is a helpful way to keep in mind the precedence of how cascade layers affect computed styles when rendered in a browser, as well as grouping similarly relevant files.\u003c/p\u003e\n\n\n\n\u003cp\u003eSince we’re in the \u003ccode\u003eindex.html\u003c/code\u003e file, we’ll add a third CSS \u003ccode\u003e\u0026lt;link\u0026gt;\u003c/code\u003e for \u003ccode\u003estyles/layouts.css\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"10\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;head\u0026gt;\n  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt;\n  \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/svg+xml\u0026#34; href=\u0026#34;/vite.svg\u0026#34; /\u0026gt;\n  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt;\n\t\n  \u0026lt;title\u0026gt;CSS Only Vite Project\u0026lt;/title\u0026gt;\n\t\n  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles/main.css\u0026#34;\u0026gt;\n  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles/reset.css\u0026#34;\u0026gt;\n  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles/layouts.css\u0026#34;\u0026gt;\n\u0026lt;/head\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eCreate the \u003ccode\u003estyles/layouts.css\u003c/code\u003e file with the new \u003ccode\u003e@layer layouts\u003c/code\u003e declaration block, where we can add layout-specific stylings.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* styles/layouts.css */\n@layer layouts {\n  /* layouts styles */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFor some quick, easy, and awesome CSS snippets, I tend to refer to \u003ca href=\"https://thinkdobecreate.com/\" rel=\"noopener\"\u003eStephanie Eckles\u003c/a\u003e‘ \u003ca href=\"https://smolcss.dev/\" rel=\"noopener\"\u003eSmolCSS\u003c/a\u003e project. Let’s grab the “Smol intrinsic container” code and include it within the \u003ccode\u003elayouts\u003c/code\u003e cascade layer:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* styles/layouts.css */\n@layer layouts {\n  .smol-container {\n    width: min(100% - 3rem, var(--container-max, 60ch));\n    margin-inline: auto;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis powerful little, two-line container uses the CSS \u003ccode\u003emin()\u003c/code\u003e function to provide a responsive width, with \u003ccode\u003emargin-inline: auto;\u003c/code\u003e set to horizontally center itself and contain its child elements. We can also dynamically adjust the width using the \u003ccode\u003e--container-max\u003c/code\u003e custom property.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow if we re-run the build command \u003ccode\u003enpm run build\u003c/code\u003e and check the \u003ccode\u003edist/\u003c/code\u003e folder, our compiled CSS file should contain:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eOur cascade layer declarations from \u003ccode\u003emain.css\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eMayank’s CSS reset fully imported from \u003ccode\u003ereset.css\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003ccode\u003e.smol-container\u003c/code\u003e class added from \u003ccode\u003elayouts.csss\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAs you can see, we can get quite far with Vite as our build tool without writing any JavaScript. However, if we choose to, we can extend our build’s capabilities even further by writing just a \u003cem\u003elittle bit\u003c/em\u003e of JavaScript.\u003c/p\u003e\n\n\n\u003ch3 id=\"postprocessing-with-lightningcss\"\u003ePost-processing with LightningCSS\u003c/h3\u003e\n\n\n\u003cp\u003e\u003ca href=\"https://lightningcss.dev/\" rel=\"noopener\"\u003eLightning CSS\u003c/a\u003e is a CSS parser and post-processing tool that has a lot of nice features baked into it to help with cross-compatibility among browsers and browser versions. Lightning CSS can transform a lot of modern CSS into backward-compatible styles \u003cem\u003efor\u003c/em\u003e you.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can install Lightning CSS in our project with \u003ccode\u003enpm\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"Terminal\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003enpm install --save-dev lightningcss\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003e--save-dev\u003c/code\u003e flag means the package will be installed as a development dependency, as it won’t be included with our built project. We can include it within our Vite build process, but first, we will need to write a tiny bit of JavaScript, a configuration file for Vite. Create a new file called: \u003ccode\u003evite.config.mjs\u003c/code\u003e and inside add the following code:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// vite.config.mjs\nexport default {\n  css: {\n    transformer: \u0026#39;lightningcss\u0026#39;\n  },\n  build: {\n    cssMinify: \u0026#39;lightningcss\u0026#39;\n  }\n};\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eVite will now use LightningCSS to transform and minify CSS files. Now, let’s give it a test run using an \u003ccode\u003eoklch\u003c/code\u003e color. Inside \u003ccode\u003emain.css\u003c/code\u003e let’s add the following code:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* main.css */\nbody {\n  background-color: oklch(51.98% 0.1768 142.5);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThen re-running the Vite build command, we can see the \u003ccode\u003ebackground-color\u003c/code\u003e property added in the compiled CSS:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* dist/index.css */\nbody {\n  background-color: green;\n  background-color: color(display-p3 0.216141 0.494224 0.131781);\n  background-color: lab(46.2829% -47.5413 48.5542);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLightning CSS converts the color white providing fallbacks available for browsers which might not support newer color types. Following the Lightning CSS \u003ca href=\"https://lightningcss.dev/docs.html#with-vite\" rel=\"noopener\"\u003edocumentation for using it with Vite\u003c/a\u003e, we can also specify \u003ca href=\"https://lightningcss.dev/transpilation.html#browser-targets\" rel=\"noopener\"\u003ebrowser versions to target\u003c/a\u003e by installing the \u003ccode\u003ebrowserslist\u003c/code\u003e package.\u003c/p\u003e\n\n\n\n\u003cp\u003eBrowserslist will give us a way to specify browsers by matching certain conditions (\u003ca href=\"https://lightningcss.dev/transpilation.html#browser-targets\" rel=\"noopener\"\u003etry it out online\u003c/a\u003e!)\u003c/p\u003e\n\n\n\n\u003cpre rel=\"Terminal\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003enpm install -D browserslist\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eInside our \u003ccode\u003evite.config.mjs\u003c/code\u003e file, we can configure Lightning CSS further. Let’s import the \u003ccode\u003ebrowserslist\u003c/code\u003e package into the Vite configuration, as well as a module from the Lightning CSS package to help us use \u003ccode\u003ebrowserlist\u003c/code\u003e in our config:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// vite.config.mjs\nimport browserslist from \u0026#39;browserslist\u0026#39;;\nimport { browserslistToTargets } from \u0026#39;lightningcss\u0026#39;;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe can add configuration settings for \u003ccode\u003elightningcss\u003c/code\u003e, containing the browser targets based on specified browser versions to Vite’s \u003ccode\u003ecss\u003c/code\u003e configuration:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// vite.config.mjs\nimport browserslist from \u0026#39;browserslist\u0026#39;;\nimport { browserslistToTargets } from \u0026#39;lightningcss\u0026#39;;\n\nexport default {\n  css: {\n    transformer: \u0026#39;lightningcss\u0026#39;,\n    lightningcss: {\n      targets: browserslistToTargets(browserslist(\u0026#39;\u0026gt;= 0.25%\u0026#39;)),\n    }\n  },\n  build: {\n    cssMinify: \u0026#39;lightningcss\u0026#39;\n  }\n};\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThere are lots of ways to extend Lightning CSS with Vite, such as enabling specific features, excluding features we won’t need, or writing our own custom transforms.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"12-13\"\u003e\u003ccode markup=\"tt\"\u003e// vite.config.mjs\nimport browserslist from \u0026#39;browserslist\u0026#39;;\nimport { browserslistToTargets, Features } from \u0026#39;lightningcss\u0026#39;;\n\nexport default {\n  css: {\n    transformer: \u0026#39;lightningcss\u0026#39;,\n    lightningcss: {\n      targets: browserslistToTargets(browserslist(\u0026#39;\u0026gt;= 0.25%\u0026#39;)),\n      // Including `light-dark()` and `colors()` functions\n      include: Features.LightDark | Features.Colors,\n    }\n  },\n  build: {\n    cssMinify: \u0026#39;lightningcss\u0026#39;\n  }\n};\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFor a full list of the Lightning CSS features, check out their \u003ca href=\"https://lightningcss.dev/transpilation.html#feature-flags\" rel=\"noopener\"\u003edocumentation on feature flags\u003c/a\u003e.\u003c/p\u003e\n\n\n\u003ch2 id=\"is-any-of-this-necessary\"\u003eIs any of this necessary?\u003c/h2\u003e\n\n\n\u003cp\u003eReading through all this, you may be asking yourself if all of this is really necessary. The answer: \u003cstrong\u003eabsolutely not!\u003c/strong\u003e But I think you can see the benefits of having access to partialized files that we can compile into unified stylesheets.\u003c/p\u003e\n\n\n\n\u003cp\u003eI doubt I’d go to these lengths for smaller projects, however, if building something with more complexity, such as a design system, I might reach for these tools for organizing code, cross-browser compatibility, and thoroughly optimizing compiled CSS.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2025-02-03T08:23:37-07:00",
  "modifiedTime": "2025-02-03T08:24:24-07:00"
}
