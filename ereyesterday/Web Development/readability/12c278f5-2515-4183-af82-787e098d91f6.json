{
  "id": "12c278f5-2515-4183-af82-787e098d91f6",
  "title": "Solved by CSS: Donuts Scopes",
  "link": "https://css-tricks.com/solved-by-css-donuts-scopes/",
  "description": "Donut scoping addresses the challenge of preventing parent styles from leaking to nested content. Originating from a 2011 concept by Nicole Sullivan, the issue has evolved, culminating in 2024's @scope at-rule. This allows for more precise CSS styling, safeguarding content from unwanted inheritance while managing global CSS complexities. Solved by CSS: Donuts Scopes originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Juan Diego Rodr√≠guez",
  "published": "Fri, 22 Nov 2024 13:50:55 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "at-rules",
    "specificity"
  ],
  "byline": "Juan Diego Rodr√≠guez",
  "length": 7546,
  "excerpt": "Donut scoping addresses the challenge of preventing parent styles from leaking to nested content. Originating from a 2011 concept by Nicole Sullivan, the issue has evolved, culminating in 2024's @scope at-rule. This allows for more precise CSS styling, safeguarding content from unwanted inheritance while managing global CSS complexities.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "Imagine you have a web component that can show lots of different content. It will likely have a slot somewhere where other components can be injected. The parent component also has its own styles unrelated to the styles of the content components it may hold. This makes a challenging situation: how can we prevent the parent component styles from leaking inwards? This isn‚Äôt a new problem ‚Äî Nicole Sullivan described it way back in 2011! The main problem is writing CSS so that it doesn‚Äôt affect the content, and she accurately coined it as donut scoping. ‚ÄúWe need a way of saying, not only where scope starts, but where it ends. Thus, the scope donut‚Äù. Even if donut scoping is an ancient issue in web years, if you do a quick search on ‚ÄúCSS Donut Scope‚Äù in your search engine of choice, you may notice two things: Most of them talk about the still recent @scope at-rule. Almost every result is from 2021 onwards. We get similar results even with a clever ‚ÄúCSS Donut Scope ‚Äì@scope‚Äù query, and going year by year doesn‚Äôt seem to bring anything new to the donut scope table. It seems like donut scopes stayed at the back of our minds as just another headache of the ol‚Äô CSS global scope until @scope. And (spoiler!), while the @scope at-rule brings an easier path for donut scoping, I feel there must have been more attempted solutions over the years. We will venture through each of them, making a final stop at today‚Äôs solution, @scope. It‚Äôs a nice exercise in CSS history! Take, for example, the following game screen. We have a .parent element with a tab set and a .content slot, in which an .inventory component is injected. If we change the .parent color, then so does the color inside .content. How can we stop this from happening? I want to prevent the text inside of .content from inheriting the .parent‚Äòs color. Just ignore it! The first solution is no solution at all! This may be the most-used approach since most developers can live their lives without the joys of donut scoping (crazy, right?). Let‚Äôs be more tangible here, it isn‚Äôt just blatantly ignoring it, but rather accepting CSS‚Äôs global scope and writing styles with that in mind. Back to our first example, we assume we can‚Äôt stop the parent‚Äôs styles from leaking inwards to the content component, so we write our parent‚Äôs styles with less specificity, so they can be overridden by the content styles. body { color: blue; } .parent { color: orange; /* Initial background */ } .content { color: blue; /* Overrides parent's background */ } While this approach is sufficient for now, managing styles just by their specificity as a project grows larger becomes tedious, at best, and chaotic at worst. Components may behave differently depending on where they are slotted and changing our CSS or HTML can break other styles in unexpected ways. Two CSS properties walk into a bar. A barstool in a completely different bar falls over. Thomas Fuchs You can see how in this small example we have to override the styles twice: Shallow donuts scopes with :not() Our goal then it‚Äôs to only scope the .parent, leaving out whatever may be inserted into the .content slot. So, not the .content but the rest of .parent‚Ä¶ not the .content‚Ä¶ :not()! We can use the :not() selector to scope only the direct descendants of .parent that aren‚Äôt .content. body { color: blue; } .parent \u003e :not(.content) { color: orange; } This way the .content styles won‚Äôt be bothered by the styles defined in their .parent: You can see an immense difference when we open the DevTools for each example: As good as an improvement, the last example has a shallow reach. So, if there were another slot nested deeper in, we wouldn‚Äôt be able to reach it unless we know beforehand where it is going to be slotted. This is because we are using the direct descendant selector (\u003e), but I couldn‚Äôt find a way to make it work without it. Even using a combination of complex selectors inside :not() doesn‚Äôt seem to lead anywhere useful. For example, back in 2021, Dr. Lea Verou mentioned donut scoping with :not() using the following selector cocktail: .container:not(.content *) { /* Donut Scoped styles (?) */ } However, this snippet appears to match the .container/.parent class instead of its descendants, and it‚Äôs noted that it still would be shallow donut scoping: TIL that all modern browsers now support complex selectors in :not()! üòçTest: https://t.co/rHSJARDvSWSo you can do things like:‚Äì .foo :not(.foo .foo *) to match things inside one .foo wrapper but not two ‚Äì .container :not(.content *) to get simple (shallow) ‚Äúdonut scope‚Äù‚Äî Dr Lea Verou (@LeaVerou) January 28, 2021 Donut scoping with @scope So our last step for donut scoping completion is being able to go beyond one DOM layer. Luckily, last year we were gifted the @scope at-rule (you can read more about it in its Almanac entry). In a nutshell, it lets us select a subtree in the DOM where our styles will be scoped, so no more global scope! @scope (.parent) { /* Styles written here will only affect .parent */ } What‚Äôs better, we can leave slots inside the subtree we selected (usually called the scope root). In this case, we would want to style the .parent element without scoping .content: @scope (.parent) to (.content) { /* Styles written here will only affect .parent but skip .content*/ } And what‚Äôs better, it detects every .content element inside .parent, no matter how nested it may be. So we don‚Äôt need to worry about where we are writing our slots. In the last example, we could instead write the following style to change the text color of the element in .parent without touching .content: body { color: blue; } @scope (.parent) to (.content) { h2, p, span, a { color: orange; } } While it may seem inconvenient to list all the elements we are going to change, we can‚Äôt use something like the universal selector (*) since it would mess up the scoping of nested slots. In this example, it would leave the nested .content out of scope, but not its container. Since the color property inherits, the nested .content would change colors regardless! And voil√†! Both .content slots are inside our scoped donut holes: Shallow scoping is still possible with this method, we would just have to rewrite our slot selector so that only direct .content descendants of .parent are left out of the scope. However, we have to use the :scope selector, which refers back to the scoping root, or .parent in this case: @scope (.parent) to (:scope \u003e .content) { * { color: orange; } } We can use the universal selector in this instance since it‚Äôs shallow scoping. Conclusion Donut scoping, a wannabe feature coined back in 2011 has finally been brought to life in the year 2024. It‚Äôs still baffling how it appeared to sit in the back of our minds until recently, as just another consequence of CSS Global Scope, while it had so many quirks by itself. It would be unfair, however, to say that it went under everyone‚Äôs radars since the CSSWG (the people behind writing the spec for new CSS features) clearly had the intention to address it when writing the spec for the @scope at-rule. Whatever it may be, I am grateful we can have true donut scoping in our CSS. To some degree, we still have to wait for Firefox to support it. üòâ DesktopChromeFirefoxIEEdgeSafari118NoNo11817.4Mobile / TabletAndroid ChromeAndroid FirefoxAndroidiOS Safari131No13117.4",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/donut-scope.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eImagine you have a web component that can show lots of different content. It will likely have a \u003ccode\u003eslot\u003c/code\u003e somewhere where other components can be injected. The parent component also has its own styles unrelated to the styles of the content components it may hold.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis makes a challenging situation: \u003cstrong\u003ehow can we prevent the parent component styles from leaking inwards?\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eThis isn‚Äôt a new problem ‚Äî \u003ca href=\"https://www.stubbornella.org/2011/10/08/scope-donuts/\" rel=\"noopener\"\u003eNicole Sullivan described it\u003c/a\u003e way back in 2011! The main problem is writing CSS so that it doesn‚Äôt affect the content, and she accurately coined it as \u003cstrong\u003edonut scoping\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e‚ÄúWe need a way of saying, not only where scope starts, but where it ends. Thus, the scope donut‚Äù.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"1920\" height=\"1080\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/donut-scope-2.png?resize=1920%2C1080\u0026amp;ssl=1\" alt=\"Diagram showing a rectangle colored salmon inside another rectangle colored dark red. The larger rectangle is the donut and the smaller rectangle is the hole.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/donut-scope-2.png?w=1920\u0026amp;ssl=1 1920w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/donut-scope-2.png?resize=300%2C169\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/donut-scope-2.png?resize=1024%2C576\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/donut-scope-2.png?resize=768%2C432\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/donut-scope-2.png?resize=1536%2C864\u0026amp;ssl=1 1536w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eEven if donut scoping is an ancient issue in web years, if you do a quick search on ‚ÄúCSS Donut Scope‚Äù in your search engine of choice, you may notice two things:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eMost of them talk about the still recent \u003ca href=\"https://css-tricks.com/almanac/rules/s/scope/\"\u003e\u003ccode\u003e@scope\u003c/code\u003e\u003c/a\u003e at-rule.\u003c/li\u003e\n\n\n\n\u003cli\u003eAlmost every result is from 2021 onwards.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eWe get similar results even with a clever ‚ÄúCSS Donut Scope ‚Äì\u003ccode\u003e@scope\u003c/code\u003e‚Äù query, and going year by year doesn‚Äôt seem to bring anything new to the \u003cem\u003edonut scope\u003c/em\u003e table. It seems like donut scopes stayed at the back of our minds as just another headache of the ol‚Äô \u003ca href=\"https://css-tricks.com/regarding-css-global-scope/\"\u003eCSS global scope\u003c/a\u003e until \u003ccode\u003e@scope\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnd (spoiler!), while the \u003ccode\u003e@scope\u003c/code\u003e at-rule brings an easier path for donut scoping, I feel there must have been more attempted solutions over the years. We will venture through each of them, making a final stop at today‚Äôs solution, \u003ccode\u003e@scope\u003c/code\u003e. It‚Äôs a nice exercise in CSS history!\u003c/p\u003e\n\n\n\n\u003cp\u003eTake, for example, the following game screen. We have a \u003ccode\u003e.parent\u003c/code\u003e element with a tab set and a \u003ccode\u003e.content\u003c/code\u003e slot, in which an \u003ccode\u003e.inventory\u003c/code\u003e component is injected. If we change the \u003ccode\u003e.parent\u003c/code\u003e color, then so does the color inside \u003ccode\u003e.content\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eHow can we stop this from happening? I want to prevent the text inside of \u003ccode\u003e.content\u003c/code\u003e from inheriting the \u003ccode\u003e.parent\u003c/code\u003e‚Äòs color.\u003c/p\u003e\n\n\n\u003ch3 id=\"just-ignore-it-\"\u003eJust ignore it!\u003c/h3\u003e\n\n\n\u003cp\u003e\u003cstrong\u003eThe first solution is no solution at all!\u003c/strong\u003e This may be the most-used approach since most developers can live their lives without the joys of donut scoping (crazy, right?). Let‚Äôs be more tangible here, it isn‚Äôt just blatantly ignoring it, but rather accepting CSS‚Äôs global scope and writing styles with that in mind. Back to our first example, we assume we can‚Äôt stop the parent‚Äôs styles from leaking inwards to the content component, so we write our parent‚Äôs styles with less specificity, so they can be overridden by the content styles.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebody {\n  color: blue;\n}\n\n.parent {\n  color: orange; /* Initial background */\n}\n\n.content {\n  color: blue; /* Overrides parent\u0026#39;s background */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWhile this approach is sufficient for now, managing styles just by their specificity as a project grows larger becomes tedious, at best, and chaotic at worst. Components may behave differently depending on where they are slotted and changing our CSS or HTML can break other styles in unexpected ways.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eTwo CSS properties walk into a bar. A barstool in a completely different bar falls over.\u003c/p\u003e\n\u003ccite\u003eThomas Fuchs\u003c/cite\u003e\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eYou can see how in this small example we have to override the styles twice:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"1920\" height=\"1080\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/ignoring-it-dev-tools.png?resize=1920%2C1080\u0026amp;ssl=1\" alt=\"Dev Tools showing the body styles getting overridden twice\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/ignoring-it-dev-tools.png?w=1920\u0026amp;ssl=1 1920w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/ignoring-it-dev-tools.png?resize=300%2C169\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/ignoring-it-dev-tools.png?resize=1024%2C576\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/ignoring-it-dev-tools.png?resize=768%2C432\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/ignoring-it-dev-tools.png?resize=1536%2C864\u0026amp;ssl=1 1536w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\u003ch3 id=\"shallow-donuts-scopes-with-not-\"\u003eShallow donuts scopes with \u003ccode\u003e:not()\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003eOur goal then it‚Äôs to only scope the \u003ccode\u003e.parent\u003c/code\u003e, leaving out whatever may be inserted into the \u003ccode\u003e.content\u003c/code\u003e slot. So, not the \u003ccode\u003e.content\u003c/code\u003e but the rest of \u003ccode\u003e.parent\u003c/code\u003e‚Ä¶ not the .\u003ccode\u003econtent\u003c/code\u003e‚Ä¶ \u003cem\u003e\u003ccode\u003e:not()\u003c/code\u003e!\u003c/em\u003e We can use the \u003ca href=\"https://css-tricks.com/almanac/pseudo-selectors/n/not/\"\u003e\u003ccode\u003e:not()\u003c/code\u003e\u003c/a\u003e selector to scope only the direct descendants of \u003ccode\u003e.parent\u003c/code\u003e that aren‚Äôt \u003ccode\u003e.content\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebody {\n  color: blue;\n}\n\n.parent \u0026gt; :not(.content) {\n  color: orange;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis way the \u003ccode\u003e.content\u003c/code\u003e styles won‚Äôt be bothered by the styles defined in their \u003ccode\u003e.parent\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eYou can see an immense difference when we open the DevTools for each example:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"576\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/dev-tools-comparison.png?resize=1024%2C576\u0026amp;ssl=1\" alt=\"Dev Tools Comparison between specificity overrides and donut scopes\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/dev-tools-comparison.png?resize=1024%2C576\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/dev-tools-comparison.png?resize=300%2C169\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/dev-tools-comparison.png?resize=768%2C432\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/dev-tools-comparison.png?resize=1536%2C864\u0026amp;ssl=1 1536w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/11/dev-tools-comparison.png?w=1920\u0026amp;ssl=1 1920w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAs good as an improvement, the last example has a shallow reach. So, if there were another slot nested deeper in, we wouldn‚Äôt be able to reach it unless we know beforehand where it is going to be slotted.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThis is because we are using the \u003ca href=\"https://css-tricks.com/almanac/selectors/c/child/\"\u003edirect descendant selector (\u003ccode\u003e\u0026gt;\u003c/code\u003e)\u003c/a\u003e, but I couldn‚Äôt find a way to make it work without it. Even using a combination of complex selectors inside \u003ccode\u003e:not()\u003c/code\u003e doesn‚Äôt seem to lead anywhere useful. For example, back in 2021, Dr. Lea Verou mentioned donut scoping with \u003ccode\u003e:not()\u003c/code\u003e using the following selector cocktail:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.container:not(.content *) {\n  /* Donut Scoped styles (?) */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eHowever, this snippet appears to match the \u003ccode\u003e.container\u003c/code\u003e/\u003ccode\u003e.parent\u003c/code\u003e class instead of its descendants, and it‚Äôs noted that it still would be shallow donut scoping:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\u003cdiv lang=\"en\" dir=\"ltr\"\u003e\u003cp\u003eTIL that all modern browsers now support complex selectors in :not()! üòç\u003c/p\u003e\u003cp\u003eTest: \u003ca href=\"https://t.co/rHSJARDvSW\"\u003ehttps://t.co/rHSJARDvSW\u003c/a\u003e\u003c/p\u003e\u003cp\u003eSo you can do things like:\u003cbr/\u003e‚Äì .foo :not(.foo .foo *) to match things inside one .foo wrapper but not two \u003cbr/\u003e‚Äì .container :not(.content *) to get simple (shallow) ‚Äúdonut scope‚Äù\u003c/p\u003e\u003c/div\u003e‚Äî Dr Lea Verou (@LeaVerou) \u003ca href=\"https://twitter.com/LeaVerou/status/1354760561087676416?ref_src=twsrc%5Etfw\" rel=\"noopener\"\u003eJanuary 28, 2021\u003c/a\u003e\u003c/blockquote\u003e \n\n\n\n\u003cblockquote\u003e\n\n\u003c/blockquote\u003e\n\n\n\u003ch3 id=\"donut-scoping-with-scope\"\u003eDonut scoping with @scope\u003c/h3\u003e\n\n\n\n\u003cbaseline-status featureid=\"scope\"\u003e\u003c/baseline-status\u003e\n\n\n\n\u003cp\u003eSo our last step for donut scoping completion is being able to go beyond one DOM layer. Luckily, last year we were gifted the \u003ccode\u003e@scope\u003c/code\u003e at-rule (you can \u003ca href=\"https://css-tricks.com/almanac/rules/s/scope/\"\u003eread more about it in its Almanac entry\u003c/a\u003e). In a nutshell, it lets us select a subtree in the DOM where our styles will be scoped, so no more global scope!\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@scope (.parent) {\n /* Styles written here will only affect .parent */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhat‚Äôs better, we can leave slots inside the subtree we selected (usually called the scope root). In this case, we would want to style the \u003ccode\u003e.parent\u003c/code\u003e element without scoping \u003ccode\u003e.content\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@scope (.parent) to (.content) {\n  /* Styles written here will only affect .parent but skip .content*/\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd what‚Äôs better, it detects every \u003ccode\u003e.content\u003c/code\u003e element inside \u003ccode\u003e.parent\u003c/code\u003e, no matter how nested it may be. So we don‚Äôt need to worry about where we are writing our slots. In the last example, we could instead write the following style to change the text color of the element in \u003ccode\u003e.parent\u003c/code\u003e without touching \u003ccode\u003e.content\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebody {\n  color: blue;\n}\n\n@scope (.parent) to (.content) {\n  h2,\n  p,\n  span,\n  a {\n    color: orange;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhile it may seem inconvenient to list all the elements we are going to change, we can‚Äôt use something like the \u003ca href=\"https://css-tricks.com/css-selectors/#aa-universal-selector\"\u003euniversal selector\u003c/a\u003e (\u003ccode\u003e*\u003c/code\u003e) since it would mess up the scoping of nested slots. In this example, it would leave the nested \u003ccode\u003e.content\u003c/code\u003e out of scope, but not its container. Since the \u003ccode\u003ecolor\u003c/code\u003e property inherits, the nested \u003ccode\u003e.content\u003c/code\u003e would change colors regardless!\u003c/p\u003e\n\n\n\n\u003cp\u003eAnd voil√†! Both \u003ccode\u003e.content\u003c/code\u003e slots are inside our scoped donut holes:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eShallow scoping is still possible with this method, we would just have to rewrite our slot selector so that only direct \u003ccode\u003e.content\u003c/code\u003e descendants of .parent are left out of the scope. However, we have to use the \u003ccode\u003e:scope\u003c/code\u003e selector, which refers back to the scoping root, or \u003ccode\u003e.parent\u003c/code\u003e in this case:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@scope (.parent) to (:scope \u0026gt; .content) {\n  * {\n    color: orange;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e We can use the universal selector in this instance since it‚Äôs shallow scoping.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\n\n\u003cp\u003eDonut scoping, a wannabe feature coined back in 2011 has finally been brought to life in the year 2024. It‚Äôs still baffling how it appeared to sit in the back of our minds until recently, as just another consequence of CSS Global Scope, while it had so many quirks by itself. It would be unfair, however, to say that it went under everyone‚Äôs radars since the CSSWG (the people behind writing the spec for new CSS features) clearly had the intention to address it when writing the spec for the \u003ccode\u003e@scope\u003c/code\u003e at-rule.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhatever it may be, I am grateful we can have true donut scoping in our CSS. To some degree, we still have to wait for Firefox to support it. üòâ\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cdiv\u003e\u003ch4\u003eDesktop\u003c/h4\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003cspan\u003eChrome\u003c/span\u003e\u003c/th\u003e\u003cth\u003e\u003cspan\u003eFirefox\u003c/span\u003e\u003c/th\u003e\u003cth\u003e\u003cspan\u003eIE\u003c/span\u003e\u003c/th\u003e\u003cth\u003e\u003cspan\u003eEdge\u003c/span\u003e\u003c/th\u003e\u003cth\u003e\u003cspan\u003eSafari\u003c/span\u003e\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd title=\"Chrome - \"\u003e\u003cspan\u003e118\u003c/span\u003e\u003c/td\u003e\u003ctd title=\"Firefox - \"\u003e\u003cspan\u003eNo\u003c/span\u003e\u003c/td\u003e\u003ctd title=\"IE - \"\u003e\u003cspan\u003eNo\u003c/span\u003e\u003c/td\u003e\u003ctd title=\"Edge - \"\u003e\u003cspan\u003e118\u003c/span\u003e\u003c/td\u003e\u003ctd title=\"Safari - \"\u003e\u003cspan\u003e17.4\u003c/span\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch4\u003eMobile / Tablet\u003c/h4\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003cspan\u003eAndroid Chrome\u003c/span\u003e\u003c/th\u003e\u003cth\u003e\u003cspan\u003eAndroid Firefox\u003c/span\u003e\u003c/th\u003e\u003cth\u003e\u003cspan\u003eAndroid\u003c/span\u003e\u003c/th\u003e\u003cth\u003e\u003cspan\u003eiOS Safari\u003c/span\u003e\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd title=\"Android Chrome - \"\u003e\u003cspan\u003e131\u003c/span\u003e\u003c/td\u003e\u003ctd title=\"Android Firefox - \"\u003e\u003cspan\u003eNo\u003c/span\u003e\u003c/td\u003e\u003ctd title=\"Android - \"\u003e\u003cspan\u003e131\u003c/span\u003e\u003c/td\u003e\u003ctd title=\"iOS Safari - \"\u003e\u003cspan\u003e17.4\u003c/span\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\u003c/div\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-11-22T06:50:55-07:00",
  "modifiedTime": "2024-11-22T06:50:59-07:00"
}
