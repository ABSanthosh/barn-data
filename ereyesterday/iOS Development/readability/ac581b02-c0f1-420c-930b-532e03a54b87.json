{
  "id": "ac581b02-c0f1-420c-930b-532e03a54b87",
  "title": "How to Implement a Decentralised CLI Tool Manager",
  "link": "https://albertodebortoli.com/2025/07/13/how-to-implement-a-decentralised-cli-tool-manager/",
  "description": "A design to implement a simple, generic and decentralised manager for CLI tools from the perspective of a Swift dev.",
  "author": "Alberto De Bortoli",
  "published": "Sun, 13 Jul 2025 23:15:31 GMT",
  "source": "https://albertodebortoli.com/rss/",
  "categories": [
    "CLI manager",
    "tool",
    "executable",
    "manager",
    "swift",
    "cli"
  ],
  "byline": "Alberto De Bortoli",
  "length": 17491,
  "excerpt": "A design to implement a simple, generic and decentralised manager for CLI tools from the perspective of a Swift dev.",
  "siteName": "Alberto De Bortoli",
  "favicon": "",
  "text": "OverviewIt's common for iOS teams to rely on various CLI tools such as SwiftLint, Tuist, and Fastlane. These tools are often installed in different ways. The most common way is to use Homebrew, which is known to lack version pinning and, as Pedro puts it:Homebrew is not able to install and activate multiple versions of the same toolI also fundamentally dislike the tap system for installing dependencies from third-party repositories. Although I don't have concrete data, I feel that most development teams profoundly dislike Homebrew when used beyond the simple installation of individual tools from the command line and the brew taps system is cumbersome and bizarre enough to often discourage developers from using it.Alternatives to manage sets of CLI tools that got traction in the past couple of years are Mint and Mise. As Pedro again says in his article about Mise:The first and most core feature of Mise is the ability to install and activate dev tools. Note that we say \"activate\" because, unlike Homebrew, Mise differentiates between installing a tool and making a specific version of it available. While beyond the scope of this article, I recommend a great article about installing Swift executables from source with Mise by Natan Rolnik.In this article I describe a CLI tool manager very similar to what I've implemented for my team. I'll simply call it \"ToolManager\". The tool is designed to:Support installing any external CLI tool distributed in zip archivesSupport activating specific versions per projectBe decentralised (requiring no registry)I believe the decentralisation is an interesting aspect and makes the tool reusable in any development environment. Also, differently from the design of mise and mint, ToolManager doesn't build from source and rather relies on pre-built executables.In the age of GenAI, it's more important than ever to develop critical thinking and learn how to solve problems. For this reason, I won't show the implementation of ToolManager, as it's more important to understand how it's meant to work. The code you'll see in this article supports the overarching design, not the nitty-gritty details of how ToolManager's commands are implemented.If, by the end of the article, you understand how the system should work and are interested in implementing it (perhaps using GenAI), you should be able to convert the design to code fairly easily—hopefully, without losing the joy of coding.I myself am considering implementing ToolManager as an open source project later, as I believe it might be very helpful to many teams, just as its incarnation was (and continues to be) for the platform team at JET. There doesn't seem to be an existing tool with the design described in this article.A different title could have reasonably placed this article in \"The easiest X\" \"series\" (1, 2, 3, 4), if I may say so.DesignThe point here is to learn what implementing a tool manager entails. I'll therefore describe the MVP of ToolManager, leaving out details that would make the design too straightforward to implement.The tool itself is a CLI and it's reasonably implemented in Swift using ArgumentParser like all modern Swift CLI tools are.In its simplest form, ToolManager exposes 3 commands:install:download and installs the tools defined in a spec file (Toolfile.yml) at ~/.toolManager/tools optionally validating the checksumcreates symlinks to the installed versions at $(PWD)/.toolManager/activeuninstall:clears the entire or partial content of ~/.toolManager/tools clears the content of $(PWD)/.toolManager/activeversion:returns the version of the toolThe install commands allows to specify the location of the spec file using the --spec flag, which defaults to Toolfile.yml in the current directory.The installation of ToolManager should be done in the most raw way, i.e. via a remote script. It'd be quite laughable to rely on Brew, wouldn't it?This practice is commonly used by a variety of tools, for example originally by Tuist (before the introduction of Mise) and... you guessed it... by Brew. We'll see below a basic script to achieve so that you could host on something lik AWS S3 with the desired public permissions.The installation command would be:curl -Ls 'https://my-bucket.s3.eu-west-1.amazonaws.com/install_toolmanager.sh' | bashThe version of ToolManager must be defined in the .toolmanager-version file in order for the installation script of the repo to work:echo \"1.2.0\" \u003e .toolmanager-versionToolManager manages versions of CLI tools but it's not in the business of managing its own versions. Back in the day, Tuist used to use tuistenv to solve this problem. I simply avoid it and have single version of ToolManager available at /usr/local/bin/ that the installation script overrides with the version defined for the project. The version command is used by the script to decide if a download is needed.There will be only one version of ToolManager in the system at a given time, and that's absolutely OK.At this point, it's time to show an example of installation script:#!/bin/bash set -euo pipefail # Fail fast if essential commands are missing. command -v curl \u003e/dev/null || { echo \"curl not found, please install it.\"; exit 1; } command -v unzip \u003e/dev/null || { echo \"unzip not found, please install it.\"; exit 1; } readonly EXEC_NAME=\"ToolManager\" readonly INSTALL_DIR=\"/usr/local/bin\" readonly EXEC_PATH=\"$INSTALL_DIR/$EXEC_NAME\" readonly HOOK_DIR=\"$HOME/.toolManager\" readonly REQUIRED_VERSION=$(cat .toolmanager-version) # Exit if the version file is missing or empty. if [[ -z \"$REQUIRED_VERSION\" ]]; then echo \"Error: .toolmanager-version not found or is empty.\" \u003e\u00262 exit 1 fi # Exit if the tool is already installed and up to date. if [[ -f \"$EXEC_PATH\" ]] \u0026\u0026 [[ \"$($EXEC_PATH version)\" == \"$REQUIRED_VERSION\" ]]; then echo \"$EXEC_NAME version $REQUIRED_VERSION is already installed.\" exit 0 fi # Determine OS and the corresponding zip filename. case \"$(uname -s)\" in Darwin) ZIP_FILENAME=\"$EXEC_NAME-macOS.zip\" ;; Linux) ZIP_FILENAME=\"$EXEC_NAME-Linux.zip\" ;; *) echo \"Unsupported OS: $(uname -s)\" \u003e\u00262; exit 1 ;; esac # Download and install in a temporary directory. TMP_DIR=$(mktemp -d) trap 'rm -rf \"$TMP_DIR\"' EXIT # Ensure cleanup on script exit. echo \"Downloading $EXEC_NAME ($REQUIRED_VERSION)...\" DOWNLOAD_URL=\"https://github.com/MyOrg/$EXEC_NAME/releases/download/$REQUIRED_VERSION/$ZIP_FILENAME\" curl -LSsf --output \"$TMP_DIR/$ZIP_FILENAME\" \"$DOWNLOAD_URL\" unzip -o -qq \"$TMP_DIR/$ZIP_FILENAME\" -d \"$TMP_DIR\" # Use sudo only when the install directory is not writable. SUDO_CMD=\"\" if [[ ! -w \"$INSTALL_DIR\" ]]; then SUDO_CMD=\"sudo\" fi echo \"Installing $EXEC_NAME to $INSTALL_DIR...\" $SUDO_CMD mkdir -p \"$INSTALL_DIR\" $SUDO_CMD mv \"$TMP_DIR/$EXEC_NAME\" \"$EXEC_PATH\" $SUDO_CMD chmod +x \"$EXEC_PATH\" # Download and source the shell hook to complete installation. echo \"Installing shell hook...\" mkdir -p \"$HOOK_DIR\" curl -LSsf --output \"$HOOK_DIR/shell_hook.sh\" \"https://my-bucket.s3.eu-west-1.amazonaws.com/shell_hook.sh\" # shellcheck source=/dev/null source \"$HOOK_DIR/shell_hook.sh\" echo \"Installation complete.\"You might have noticed that:the required version of ToolManager (defined in .toolmanager-version) is downloaded from the release from the corresponding GitHub repository if missing locally. The ToolManager repo should have a GHA workflow in place to build, archive and upload the version.a shell_hook script is downloaded and run to insert the following line in the shell profile: [[ -s \"$HOME/.toolManager/shell_hook.sh\" ]] \u0026\u0026 source \"$HOME/.toolManager/shell_hook.sh\". This allows switching location in the terminal and loading the active tools for the current project.Showing an example of shell_hook.sh is in order:#!/bin/bash # Overrides 'cd' to update PATH when entering a directory with a local tool setup. # Add the project-specific bin directory to PATH if it exists. update_tool_path() { local tool_bin_dir=\"$PWD/.toolManager/active\" if [[ -d \"$tool_bin_dir\" ]]; then export PATH=\"$tool_bin_dir:$PATH\" fi } # Redefine 'cd' to trigger the path update after changing directories. cd() { builtin cd \"$@\" || return update_tool_path } # --- Installation Logic --- # The following function only runs when this script is sourced by an installer. install_hook() { local rc_file case \"${SHELL##*/}\" in bash) rc_file=\"$HOME/.bashrc\" ;; zsh) rc_file=\"$HOME/.zshrc\" ;; *) echo \"Unsupported shell for hook installation: $SHELL\" \u003e\u00262 return 1 ;; esac # The line to add to the shell's startup file. local hook_line=\"[[ -s \\\"$HOME/.toolManager/shell_hook.sh\\\" ]] \u0026\u0026 source \\\"$HOME/.toolManager/shell_hook.sh\\\"\" # Add the hook if it's not already present. if ! grep -Fxq \"$hook_line\" \"$rc_file\" \u0026\u003e/dev/null; then printf \"\\n%s\\n\" \"$hook_line\" \u003e\u003e \"$rc_file\" echo \"Shell hook installed in $rc_file. Restart your shell to apply changes.\" fi } # This check ensures 'install_hook' only runs when sourced, not when executed. if [[ \"${BASH_SOURCE[0]}\" != \"$0\" ]]; then install_hook fiNow that we have a working installation of ToolManager, let define our Toolfile.yml in our project folder:--- tools: - name: PackageGenerator binaryPath: PackageGenerator version: 3.3.0 zipUrl: https://github.com/justeattakeaway/PackageGenerator/releases/download/3.3.0/PackageGenerator-macOS.zip - name: SwiftLint binaryPath: swiftlint version: 0.57.0 zipUrl: https://github.com/realm/SwiftLint/releases/download/0.58.2/portable_swiftlint.zip - name: ToggleGen binaryPath: ToggleGen version: 1.0.0 zipUrl: https://github.com/TogglesPlatform/ToggleGen/releases/download/1.0.0/ToggleGen-macOS-universal-binary.zip - name: Tuist binaryPath: tuist version: 4.48.0 zipUrl: https://github.com/tuist/tuist/releases/download/4.54.3/tuist.zip - name: Sourcery binaryPath: bin/sourcery version: 2.2.5 zipUrl: https://github.com/krzysztofzablocki/Sourcery/releases/download/2.2.5/sourcery-2.2.5.zipThe install command of ToolManager loads the Toolfile at the root of the repo and for each defined dependency, performs the following:checks if the version of the dependency already exists on the machineif it doesn’t exist, downloads it, unzips it, and places the binary at ~/.toolManager/tools/ (e.g. ~/.toolManager/tools/PackageGenerator/3.3.0/PackageGenerator)creates a symlink to the binary in the project directory from .toolManager/active (e.g. .toolManager/active/PackageGenerator)After running ToolManager install (or ToolManager install --spec=Toolfile.yml), ToolManager should produce the following structure ~ tree ~/.toolManager/tools -L 2 ├── PackageGenerator │   └── 3.3.0 ├── Sourcery │   └── 2.2.5 ├── SwiftLint │   └── 0.57.0 ├── ToggleGen │   └── 1.0.0 └── Tuist    └── 4.48.0and from the project folderls -la .toolManager/active \u003credacted\u003e PackageGenerator -\u003e /Users/alberto/.toolManager/tools/PackageGenerator/3.3.0/PackageGenerator \u003credacted\u003e Sourcery -\u003e /Users/alberto/.toolManager/tools/Sourcery/2.2.5/Sourcery \u003credacted\u003e SwiftLint -\u003e /Users/alberto/.toolManager/tools/SwiftLint/0.57.0/SwiftLint \u003credacted\u003e ToggleGen -\u003e /Users/alberto/.toolManager/tools/ToggleGen/1.0.0/ToggleGen \u003credacted\u003e Tuist -\u003e /Users/alberto/.toolManager/tools/Tuist/4.48.0/TuistBumping the versions of some tools in the Toolfile, for example SwiftLint and Tuist, and re-running the install command, should result in the following:~ tree ~/.toolManager/tools -L 2 ├── PackageGenerator │   └── 3.3.0 ├── Sourcery │   └── 2.2.5 ├── SwiftLint │   ├── 0.57.0 │   └── 0.58.2 ├── ToggleGen │   └── 1.0.0 └── Tuist    ├── 4.48.0    └── 4.54.3ls -la .toolManager/active \u003credacted\u003e PackageGenerator -\u003e /Users/alberto/.toolManager/tools/PackageGenerator/3.3.0/PackageGenerator \u003credacted\u003e Sourcery -\u003e /Users/alberto/.toolManager/tools/Sourcery/2.2.5/Sourcery \u003credacted\u003e SwiftLint -\u003e /Users/alberto/.toolManager/tools/SwiftLint/0.58.2/SwiftLint \u003credacted\u003e ToggleGen -\u003e /Users/alberto/.toolManager/tools/ToggleGen/1.0.0/ToggleGen \u003credacted\u003e Tuist -\u003e /Users/alberto/.toolManager/tools/Tuist/4.54.3/TuistCI SetupOn CI, the setup is quite simple. It involves 2 steps:install ToolManagerinstall the toolsThe commands can be wrapped in GitHub composite actions:name: Install ToolManager runs: using: composite steps: - name: Install ToolManager shell: bash run: curl -Ls 'https://my-bucket.s3.eu-west-1.amazonaws.com/install_toolmanager.sh' | bashname: Install tools inputs: spec: description: The name of the ToolManager spec file required: false default: Toolfile.yml runs: using: composite steps: - name: Install tools shell: bash run: | ToolManager install --spec=${{ inputs.spec }} echo \"$PWD/.toolManager/active\" \u003e\u003e $GITHUB_PATH simply used in workflows:- name: Install ToolManager uses: ./.github/actions/install-toolmanager - name: Install tools uses: ./.github/actions/install-tools with: spec: Toolfile.ymlCLI tools conformanceToolManager can install tools that are made available in zip files, without the need of implementing any particular spec. Depending on the CLI tool, the executable can be at the root of the zip archive or in a subfolder. Sourcery for example places the executable in the bin folder.- name: Sourcery binaryPath: bin/sourcery version: 2.2.5 zipUrl: https://github.com/krzysztofzablocki/Sourcery/releases/download/2.2.5/sourcery-2.2.5.zipGitHub releases are great to host releases as zip files and that's all we need. Ideally, one should decorate the repositories with appropriate release workflows.Following is a simple example that builds a macOS binary. It could be extended to also create a Linux binary.name: Publish Release on: push: tags: - '*' env: CLI_NAME: my-awesome-cli-tool permissions: contents: write jobs: build-and-archive: name: Build and Archive macOS Binary runs-on: macos-latest steps: - name: Checkout repository uses: actions/checkout@v4 - name: Setup Xcode uses: maxim-lobanov/setup-xcode@v1 with: xcode-version: '16.4' - name: Build universal binary run: swift build -c release --arch arm64 --arch x86_64 - name: Archive the binary run: | cd .build/apple/Products/Release/ zip -r \"${{ env.CLI_NAME }}-macOS.zip\" \"${{ env.CLI_NAME }}\" - name: Upload artifact for release uses: actions/upload-artifact@v4 with: name: cli-artifact path: .build/apple/Products/Release/${{ env.CLI_NAME }}-macOS.zip create-release: name: Create GitHub Release needs: [build-and-archive] runs-on: ubuntu-latest steps: - name: Download CLI artifact uses: actions/download-artifact@v4 with: name: cli-artifact - name: Create Release and Upload Asset uses: softprops/action-gh-release@v2 with: files: \"${{ env.CLI_NAME }}-macOS.zip\"A note on version pinningDependency management systems tend to use a lock file (like Package.resolved in Swift Package manager, Podfile.lock in the old days of CocoaPods, yarn.lock/package-lock.json in JavaScript, etc.).The benefits of using a lock file are mainly 2:ReproducibilityIt locks the exact versions (including transitive dependencies) so that every team member, CI server, or production environment installs the same versions.Faster installsDependency managers can skip version resolution if a lock file is present, using it directly to fetch the exact versions, improving speed.We can remove the need for lock files if we pin the versions in the spec (the file defining the tools). If version range operators like the CocoaPods' optimistic operator ~\u003e and the SPM's .upToNextMajor and similar one didn't exist, usages of lock files would lose its utility.While useful, lock files are generally annoying and can create that odd feeling of seeing unexpected updates in pull requests made by others. ToolManager doesn't use a lock file; instead, it requires teams to pin their tools' versions, which I strongly believe is a good practice.This approach comes at the cost of teams having to keep an eye out for patch releases and not leaving updates to the machine, which risks pulling in dependencies that don't respect Semantic Versioning (SemVer).Support for different architecturesThis design allows to support different architectures. Some CI workflows might only need a Linux runner to reduce the burden on precious macOS instances. Both macOS and Linux can be supported with individual Toolfile that can be specified when running the install command.# on macOS ToolManager install --spec=Toolfile_macOS # on Linux ToolManager install --spec=Toolfile_LinuxConclusionThe design described in this article powers the solution implemented at JET and has served our teams successfully since October 2023. JET has always preferred to implement in-house solutions where possible and sensible, and I can say that moving away from Homebrew was a blessing.With this design, the work usually done by a package manager and a central spec repository is shifted to individual components that are only required to publish releases in zip archives, ideally via a release workflow.By decentralising and requiring version pinning, we made ToolManager a simple yet powerful system for managing the installation of CLI tools.",
  "image": "https://albertodebortoli.com/content/images/size/w1200/2025/07/ChatGPT-Image-Jul-14--2025--12_07_43-AM.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n        \u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\u003cp\u003eIt\u0026#39;s common for iOS teams to rely on various CLI tools such as SwiftLint, Tuist, and Fastlane. These tools are often installed in different ways. The most common way is to use \u003ca href=\"https://brew.sh/?ref=albertodebortoli.com\"\u003eHomebrew\u003c/a\u003e, which is known to lack version pinning and, as Pedro \u003ca href=\"https://tuist.dev/blog/2023/12/15/rtx-default/?ref=albertodebortoli.com\"\u003eputs it\u003c/a\u003e:\u003c/p\u003e\u003cblockquote\u003eHomebrew is not able to install and activate multiple versions of the same tool\u003c/blockquote\u003e\u003cp\u003eI also fundamentally dislike the \u003ccode\u003etap\u003c/code\u003e system for installing dependencies from third-party repositories. Although I don\u0026#39;t have concrete data, I feel that most development teams profoundly dislike Homebrew when used beyond the simple installation of individual tools from the command line and the \u003ca href=\"https://docs.brew.sh/Taps?ref=albertodebortoli.com\"\u003ebrew taps\u003c/a\u003e system is cumbersome and bizarre enough to often discourage developers from using it.\u003c/p\u003e\u003cp\u003eAlternatives to manage sets of CLI tools that got traction in the past couple of years are \u003ca href=\"https://github.com/yonaskolb/Mint?ref=albertodebortoli.com\"\u003eMint\u003c/a\u003e and \u003ca href=\"https://mise.jdx.dev/lang/swift.html?ref=albertodebortoli.com\"\u003eMise\u003c/a\u003e. As Pedro again says in \u003ca href=\"https://tuist.dev/blog/2025/02/04/mise?ref=albertodebortoli.com\"\u003ehis article about Mise\u003c/a\u003e:\u003c/p\u003e\u003cblockquote\u003eThe first and most core feature of Mise is the ability to install and activate \u003ca href=\"https://mise.jdx.dev/dev-tools/?ref=albertodebortoli.com\"\u003edev tools\u003c/a\u003e. Note that we say \u0026#34;activate\u0026#34; because, unlike Homebrew, Mise differentiates between installing a tool and making a specific version of it available. \u003c/blockquote\u003e\u003cp\u003eWhile beyond the scope of this article, I recommend a great article about \u003ca href=\"https://swifttoolkit.dev/posts/mise-swift?ref=albertodebortoli.com\"\u003einstalling Swift executables from source with Mise\u003c/a\u003e by  \u003ca href=\"https://x.com/natanrolnik?ref=albertodebortoli.com\"\u003eNatan Rolnik\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIn this article I describe a CLI tool manager very similar to what I\u0026#39;ve implemented for my team. I\u0026#39;ll simply call it \u0026#34;ToolManager\u0026#34;. The tool is designed to:\u003c/p\u003e\u003col\u003e\u003cli\u003eSupport installing any external CLI tool distributed in zip archives\u003c/li\u003e\u003cli\u003eSupport activating specific versions per project\u003c/li\u003e\u003cli\u003eBe decentralised (requiring no registry)\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eI believe the decentralisation is an interesting aspect and makes the tool reusable in any development environment. Also, differently from the design of mise and mint, ToolManager doesn\u0026#39;t build from source and rather relies on pre-built executables.\u003c/p\u003e\u003cp\u003eIn the age of GenAI, it\u0026#39;s more important than ever to develop critical thinking and learn how to solve problems. For this reason, I won\u0026#39;t show the implementation of ToolManager, as it\u0026#39;s more important to understand how it\u0026#39;s meant to work. The code you\u0026#39;ll see in this article supports the overarching design, not the nitty-gritty details of how ToolManager\u0026#39;s commands are implemented.\u003c/p\u003e\u003cp\u003eIf, by the end of the article, you understand how the system should work and are interested in implementing it (perhaps using GenAI), you should be able to convert the design to code fairly easily—hopefully, without losing the \u003ca href=\"https://annievella.com/posts/the-software-engineering-identity-crisis/?ref=albertodebortoli.com\"\u003ejoy of coding\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eI myself am considering implementing ToolManager as an open source project later, as I believe it might be very helpful to many teams, just as its incarnation was (and continues to be) for the platform team at JET. There doesn\u0026#39;t seem to be an existing tool with the design described in this article.\u003c/p\u003e\u003cp\u003eA different title could have reasonably placed this article in \u0026#34;The easiest X\u0026#34; \u0026#34;series\u0026#34; (\u003ca href=\"https://albertodebortoli.com/2023/03/26/toggles/\"\u003e1\u003c/a\u003e, \u003ca href=\"https://albertodebortoli.com/2018/02/12/the-easiest-promises-in-swift/\"\u003e2\u003c/a\u003e, \u003ca href=\"https://albertodebortoli.com/2018/12/16/the-easiest-state-machine-in-swift/\"\u003e3\u003c/a\u003e, \u003ca href=\"https://albertodebortoli.com/2016/08/05/the-easiest-core-data/\"\u003e4\u003c/a\u003e), if I may say so.\u003c/p\u003e\u003ch2 id=\"design\"\u003eDesign\u003c/h2\u003e\u003cp\u003eThe point here is to learn what implementing a tool manager entails. I\u0026#39;ll therefore describe the MVP of ToolManager, leaving out details that would make the design too straightforward to implement.\u003c/p\u003e\u003cp\u003eThe tool itself is a CLI and it\u0026#39;s reasonably implemented in Swift using \u003ca href=\"https://github.com/apple/swift-argument-parser?ref=albertodebortoli.com\"\u003eArgumentParser\u003c/a\u003e like all modern Swift CLI tools are.\u003c/p\u003e\u003cp\u003eIn its simplest form, ToolManager exposes 3 commands:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003einstall\u003c/code\u003e:\u003cul\u003e\u003cli\u003edownload and installs the tools defined in a spec file (\u003ccode\u003eToolfile.yml\u003c/code\u003e) at \u003ccode\u003e~/.toolManager/tools\u003c/code\u003e optionally validating the checksum\u003c/li\u003e\u003cli\u003ecreates symlinks to the installed versions at \u003ccode\u003e$(PWD)/.toolManager/active\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003euninstall\u003c/code\u003e:\u003cul\u003e\u003cli\u003eclears the entire or partial content of \u003ccode\u003e~/.toolManager/tools\u003c/code\u003e \u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cul\u003e\u003cli\u003eclears the content of \u003ccode\u003e$(PWD)/.toolManager/active\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cli\u003e\u003ccode\u003eversion\u003c/code\u003e:\u003cul\u003e\u003cli\u003ereturns the version of the tool\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe \u003ccode\u003einstall\u003c/code\u003e commands allows to specify the location of the spec file using the \u003ccode\u003e--spec\u003c/code\u003e flag, which defaults to \u003ccode\u003eToolfile.yml\u003c/code\u003e in the current directory.\u003c/p\u003e\u003cp\u003eThe installation of ToolManager should be done in the most raw way, i.e. via a remote script. It\u0026#39;d be quite laughable to rely on Brew, wouldn\u0026#39;t it?\u003c/p\u003e\u003cp\u003eThis practice is commonly used by a variety of tools, for example originally by Tuist (before the introduction of Mise) and... you guessed it... by Brew. We\u0026#39;ll see below a basic script to achieve so that you could host on something lik AWS S3 with the desired public permissions.\u003c/p\u003e\u003cp\u003eThe installation command would be:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ecurl -Ls \u0026#39;https://my-bucket.s3.eu-west-1.amazonaws.com/install_toolmanager.sh\u0026#39; | bash\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe version of ToolManager must be defined in the \u003ccode\u003e.toolmanager-version\u003c/code\u003e file in order for the installation script of the repo to work:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eecho \u0026#34;1.2.0\u0026#34; \u0026gt; .toolmanager-version\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eToolManager manages versions of CLI tools but it\u0026#39;s not in the business of managing its own versions. Back in the day, Tuist used to use \u003ca href=\"https://tuist.dev/blog/2023/12/15/rtx-default?ref=albertodebortoli.com\"\u003etuistenv\u003c/a\u003e to solve this problem. I simply avoid it and have single version of ToolManager available at \u003ccode\u003e/usr/local/bin/\u003c/code\u003e that the installation script overrides with the version defined for the project. The \u003ccode\u003eversion\u003c/code\u003e command is used by the script to decide if a download is needed.\u003c/p\u003e\u003cblockquote\u003eThere will be only one version of ToolManager in the system at a given time, and that\u0026#39;s absolutely OK.\u003c/blockquote\u003e\u003cp\u003eAt this point, it\u0026#39;s time to show an example of installation script:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e#!/bin/bash\nset -euo pipefail\n\n# Fail fast if essential commands are missing.\ncommand -v curl \u0026gt;/dev/null || { echo \u0026#34;curl not found, please install it.\u0026#34;; exit 1; }\ncommand -v unzip \u0026gt;/dev/null || { echo \u0026#34;unzip not found, please install it.\u0026#34;; exit 1; }\n\nreadonly EXEC_NAME=\u0026#34;ToolManager\u0026#34;\nreadonly INSTALL_DIR=\u0026#34;/usr/local/bin\u0026#34;\nreadonly EXEC_PATH=\u0026#34;$INSTALL_DIR/$EXEC_NAME\u0026#34;\nreadonly HOOK_DIR=\u0026#34;$HOME/.toolManager\u0026#34;\nreadonly REQUIRED_VERSION=$(cat .toolmanager-version)\n\n# Exit if the version file is missing or empty.\nif [[ -z \u0026#34;$REQUIRED_VERSION\u0026#34; ]]; then\n  echo \u0026#34;Error: .toolmanager-version not found or is empty.\u0026#34; \u0026gt;\u0026amp;2\n  exit 1\nfi\n\n# Exit if the tool is already installed and up to date.\nif [[ -f \u0026#34;$EXEC_PATH\u0026#34; ]] \u0026amp;\u0026amp; [[ \u0026#34;$($EXEC_PATH version)\u0026#34; == \u0026#34;$REQUIRED_VERSION\u0026#34; ]]; then\n  echo \u0026#34;$EXEC_NAME version $REQUIRED_VERSION is already installed.\u0026#34;\n  exit 0\nfi\n\n# Determine OS and the corresponding zip filename.\ncase \u0026#34;$(uname -s)\u0026#34; in\n  Darwin) ZIP_FILENAME=\u0026#34;$EXEC_NAME-macOS.zip\u0026#34; ;;\n  Linux)  ZIP_FILENAME=\u0026#34;$EXEC_NAME-Linux.zip\u0026#34; ;;\n  *)      echo \u0026#34;Unsupported OS: $(uname -s)\u0026#34; \u0026gt;\u0026amp;2; exit 1 ;;\nesac\n\n# Download and install in a temporary directory.\nTMP_DIR=$(mktemp -d)\ntrap \u0026#39;rm -rf \u0026#34;$TMP_DIR\u0026#34;\u0026#39; EXIT # Ensure cleanup on script exit.\n\necho \u0026#34;Downloading $EXEC_NAME ($REQUIRED_VERSION)...\u0026#34;\nDOWNLOAD_URL=\u0026#34;https://github.com/MyOrg/$EXEC_NAME/releases/download/$REQUIRED_VERSION/$ZIP_FILENAME\u0026#34;\ncurl -LSsf --output \u0026#34;$TMP_DIR/$ZIP_FILENAME\u0026#34; \u0026#34;$DOWNLOAD_URL\u0026#34;\nunzip -o -qq \u0026#34;$TMP_DIR/$ZIP_FILENAME\u0026#34; -d \u0026#34;$TMP_DIR\u0026#34;\n\n# Use sudo only when the install directory is not writable.\nSUDO_CMD=\u0026#34;\u0026#34;\nif [[ ! -w \u0026#34;$INSTALL_DIR\u0026#34; ]]; then\n  SUDO_CMD=\u0026#34;sudo\u0026#34;\nfi\n\necho \u0026#34;Installing $EXEC_NAME to $INSTALL_DIR...\u0026#34;\n$SUDO_CMD mkdir -p \u0026#34;$INSTALL_DIR\u0026#34;\n$SUDO_CMD mv \u0026#34;$TMP_DIR/$EXEC_NAME\u0026#34; \u0026#34;$EXEC_PATH\u0026#34;\n$SUDO_CMD chmod +x \u0026#34;$EXEC_PATH\u0026#34;\n\n# Download and source the shell hook to complete installation.\necho \u0026#34;Installing shell hook...\u0026#34;\nmkdir -p \u0026#34;$HOOK_DIR\u0026#34;\ncurl -LSsf --output \u0026#34;$HOOK_DIR/shell_hook.sh\u0026#34; \u0026#34;https://my-bucket.s3.eu-west-1.amazonaws.com/shell_hook.sh\u0026#34;\n# shellcheck source=/dev/null\nsource \u0026#34;$HOOK_DIR/shell_hook.sh\u0026#34;\n\necho \u0026#34;Installation complete.\u0026#34;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou might have noticed that:\u003c/p\u003e\u003cul\u003e\u003cli\u003ethe required version of ToolManager (defined in \u003ccode\u003e.toolmanager-version\u003c/code\u003e) is downloaded from the release from the corresponding GitHub repository if missing locally. The ToolManager repo should have a GHA workflow in place to build, archive and upload the version.\u003c/li\u003e\u003cli\u003ea \u003ccode\u003eshell_hook\u003c/code\u003e script is downloaded and run to insert the following line in the shell profile: \u003ccode\u003e[[ -s \u0026#34;$HOME/.toolManager/shell_hook.sh\u0026#34; ]] \u0026amp;\u0026amp; source \u0026#34;$HOME/.toolManager/shell_hook.sh\u0026#34;\u003c/code\u003e. This allows switching location in the terminal and loading the active tools for the current project.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eShowing an example of \u003ccode\u003eshell_hook.sh\u003c/code\u003e is in order:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e#!/bin/bash\n# Overrides \u0026#39;cd\u0026#39; to update PATH when entering a directory with a local tool setup.\n\n# Add the project-specific bin directory to PATH if it exists.\nupdate_tool_path() {\n  local tool_bin_dir=\u0026#34;$PWD/.toolManager/active\u0026#34;\n  if [[ -d \u0026#34;$tool_bin_dir\u0026#34; ]]; then\n    export PATH=\u0026#34;$tool_bin_dir:$PATH\u0026#34;\n  fi\n}\n\n# Redefine \u0026#39;cd\u0026#39; to trigger the path update after changing directories.\ncd() {\n  builtin cd \u0026#34;$@\u0026#34; || return\n  update_tool_path\n}\n\n# --- Installation Logic ---\n# The following function only runs when this script is sourced by an installer.\n\ninstall_hook() {\n  local rc_file\n  case \u0026#34;${SHELL##*/}\u0026#34; in\n    bash) rc_file=\u0026#34;$HOME/.bashrc\u0026#34; ;;\n    zsh)  rc_file=\u0026#34;$HOME/.zshrc\u0026#34; ;;\n    *)\n      echo \u0026#34;Unsupported shell for hook installation: $SHELL\u0026#34; \u0026gt;\u0026amp;2\n      return 1\n      ;;\n  esac\n\n  # The line to add to the shell\u0026#39;s startup file.\n  local hook_line=\u0026#34;[[ -s \\\u0026#34;$HOME/.toolManager/shell_hook.sh\\\u0026#34; ]] \u0026amp;\u0026amp; source \\\u0026#34;$HOME/.toolManager/shell_hook.sh\\\u0026#34;\u0026#34;\n\n  # Add the hook if it\u0026#39;s not already present.\n  if ! grep -Fxq \u0026#34;$hook_line\u0026#34; \u0026#34;$rc_file\u0026#34; \u0026amp;\u0026gt;/dev/null; then\n    printf \u0026#34;\\n%s\\n\u0026#34; \u0026#34;$hook_line\u0026#34; \u0026gt;\u0026gt; \u0026#34;$rc_file\u0026#34;\n    echo \u0026#34;Shell hook installed in $rc_file. Restart your shell to apply changes.\u0026#34;\n  fi\n}\n\n# This check ensures \u0026#39;install_hook\u0026#39; only runs when sourced, not when executed.\nif [[ \u0026#34;${BASH_SOURCE[0]}\u0026#34; != \u0026#34;$0\u0026#34; ]]; then\n  install_hook\nfi\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow that we have a working installation of ToolManager, let define our \u003ccode\u003eToolfile.yml\u003c/code\u003e in our project folder:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e---\ntools:\n  - name: PackageGenerator\n    binaryPath: PackageGenerator\n    version: 3.3.0\n    zipUrl: https://github.com/justeattakeaway/PackageGenerator/releases/download/3.3.0/PackageGenerator-macOS.zip\n  - name: SwiftLint\n    binaryPath: swiftlint\n    version: 0.57.0\n    zipUrl: https://github.com/realm/SwiftLint/releases/download/0.58.2/portable_swiftlint.zip\n  - name: ToggleGen\n    binaryPath: ToggleGen\n    version: 1.0.0\n    zipUrl: https://github.com/TogglesPlatform/ToggleGen/releases/download/1.0.0/ToggleGen-macOS-universal-binary.zip\n  - name: Tuist\n    binaryPath: tuist\n    version: 4.48.0\n    zipUrl: https://github.com/tuist/tuist/releases/download/4.54.3/tuist.zip\n  - name: Sourcery\n    binaryPath: bin/sourcery\n    version: 2.2.5\n    zipUrl: https://github.com/krzysztofzablocki/Sourcery/releases/download/2.2.5/sourcery-2.2.5.zip\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003einstall\u003c/code\u003e command of ToolManager loads the Toolfile at the root of the repo and for each defined dependency, performs the following:\u003c/p\u003e\u003cul\u003e\u003cli\u003echecks if the version of the dependency already exists on the machine\u003c/li\u003e\u003cli\u003eif it doesn’t exist, downloads it, unzips it, and places the binary at \u003ccode\u003e~/.toolManager/tools/\u003c/code\u003e (e.g. \u003ccode\u003e~/.toolManager/tools/PackageGenerator/3.3.0/PackageGenerator\u003c/code\u003e)\u003c/li\u003e\u003cli\u003ecreates a symlink to the binary in the project directory from \u003ccode\u003e.toolManager/active\u003c/code\u003e (e.g. \u003ccode\u003e.toolManager/active/PackageGenerator\u003c/code\u003e)\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAfter running \u003ccode\u003eToolManager install\u003c/code\u003e (or \u003ccode\u003eToolManager install --spec=Toolfile.yml\u003c/code\u003e), ToolManager should produce the following structure \u003c/p\u003e\u003cpre\u003e\u003ccode\u003e~ tree ~/.toolManager/tools -L 2\n├── PackageGenerator\n│   └── 3.3.0\n├── Sourcery\n│   └── 2.2.5\n├── SwiftLint\n│   └── 0.57.0\n├── ToggleGen\n│   └── 1.0.0\n└── Tuist\n    └── 4.48.0\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eand from the project folder\u003c/p\u003e\u003cpre\u003e\u003ccode\u003els -la .toolManager/active\n\u0026lt;redacted\u0026gt; PackageGenerator -\u0026gt; /Users/alberto/.toolManager/tools/PackageGenerator/3.3.0/PackageGenerator\n\u0026lt;redacted\u0026gt; Sourcery -\u0026gt; /Users/alberto/.toolManager/tools/Sourcery/2.2.5/Sourcery\n\u0026lt;redacted\u0026gt; SwiftLint -\u0026gt; /Users/alberto/.toolManager/tools/SwiftLint/0.57.0/SwiftLint\n\u0026lt;redacted\u0026gt; ToggleGen -\u0026gt; /Users/alberto/.toolManager/tools/ToggleGen/1.0.0/ToggleGen\n\u0026lt;redacted\u0026gt; Tuist -\u0026gt; /Users/alberto/.toolManager/tools/Tuist/4.48.0/Tuist\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBumping the versions of some tools in the Toolfile, for example SwiftLint and Tuist, and re-running the install command, should result in the following:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e~ tree ~/.toolManager/tools -L 2\n├── PackageGenerator\n│   └── 3.3.0\n├── Sourcery\n│   └── 2.2.5\n├── SwiftLint\n│   ├── 0.57.0\n│   └── 0.58.2\n├── ToggleGen\n│   └── 1.0.0\n└── Tuist\n    ├── 4.48.0\n    └── 4.54.3\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003els -la .toolManager/active\n\u0026lt;redacted\u0026gt; PackageGenerator -\u0026gt; /Users/alberto/.toolManager/tools/PackageGenerator/3.3.0/PackageGenerator\n\u0026lt;redacted\u0026gt; Sourcery -\u0026gt; /Users/alberto/.toolManager/tools/Sourcery/2.2.5/Sourcery\n\u0026lt;redacted\u0026gt; SwiftLint -\u0026gt; /Users/alberto/.toolManager/tools/SwiftLint/0.58.2/SwiftLint\n\u0026lt;redacted\u0026gt; ToggleGen -\u0026gt; /Users/alberto/.toolManager/tools/ToggleGen/1.0.0/ToggleGen\n\u0026lt;redacted\u0026gt; Tuist -\u0026gt; /Users/alberto/.toolManager/tools/Tuist/4.54.3/Tuist\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"ci-setup\"\u003eCI Setup\u003c/h3\u003e\u003cp\u003eOn CI, the setup is quite simple. It involves 2 steps:\u003c/p\u003e\u003cul\u003e\u003cli\u003einstall ToolManager\u003c/li\u003e\u003cli\u003einstall the tools\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe commands can be wrapped in GitHub composite actions:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ename: Install ToolManager\n\nruns:\n  using: composite\n  steps:\n    - name: Install ToolManager\n      shell: bash\n      run: curl -Ls \u0026#39;https://my-bucket.s3.eu-west-1.amazonaws.com/install_toolmanager.sh\u0026#39; | bash\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003ename: Install tools\n\ninputs:\n  spec:\n    description: The name of the ToolManager spec file\n    required: false\n    default: Toolfile.yml\n\nruns:\n  using: composite\n  steps:\n    - name: Install tools\n      shell: bash\n      run: |\n        ToolManager install --spec=${{ inputs.spec }}\n        echo \u0026#34;$PWD/.toolManager/active\u0026#34; \u0026gt;\u0026gt; $GITHUB_PATH\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003esimply used in workflows:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e- name: Install ToolManager\n  uses: ./.github/actions/install-toolmanager\n\n- name: Install tools\n  uses: ./.github/actions/install-tools\n  with:\n    spec: Toolfile.yml\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"cli-tools-conformance\"\u003eCLI tools conformance\u003c/h3\u003e\u003cp\u003eToolManager can install tools that are made available in zip files, without the need of implementing any particular spec. Depending on the CLI tool, the executable can be at the root of the zip archive or in a subfolder. Sourcery for example places the executable in the bin folder.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e- name: Sourcery\n  binaryPath: bin/sourcery\n  version: 2.2.5\n  zipUrl: https://github.com/krzysztofzablocki/Sourcery/releases/download/2.2.5/sourcery-2.2.5.zip\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGitHub releases are great to host releases as zip files and that\u0026#39;s all we need. Ideally, one should decorate the repositories with appropriate release workflows.\u003c/p\u003e\u003cp\u003eFollowing is a simple example that builds a macOS binary. It could be extended to also create a Linux binary.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ename: Publish Release\n\non:\n  push:\n    tags:\n      - \u0026#39;*\u0026#39;\n\nenv:\n  CLI_NAME: my-awesome-cli-tool\n\npermissions:\n  contents: write\n\njobs:\n  build-and-archive:\n    name: Build and Archive macOS Binary\n    \n    runs-on: macos-latest\n    \n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n\n      - name: Setup Xcode\n        uses: maxim-lobanov/setup-xcode@v1\n        with:\n          xcode-version: \u0026#39;16.4\u0026#39;\n\n      - name: Build universal binary\n        run: swift build -c release --arch arm64 --arch x86_64\n      \n      - name: Archive the binary\n        run: |\n          cd .build/apple/Products/Release/\n          zip -r \u0026#34;${{ env.CLI_NAME }}-macOS.zip\u0026#34; \u0026#34;${{ env.CLI_NAME }}\u0026#34;\n      \n      - name: Upload artifact for release\n        uses: actions/upload-artifact@v4\n        with:\n          name: cli-artifact\n          path: .build/apple/Products/Release/${{ env.CLI_NAME }}-macOS.zip\n\n  create-release:\n    name: Create GitHub Release\n    \n    needs: [build-and-archive]\n    \n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Download CLI artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: cli-artifact\n\n      - name: Create Release and Upload Asset\n        uses: softprops/action-gh-release@v2\n        with:\n          files: \u0026#34;${{ env.CLI_NAME }}-macOS.zip\u0026#34;\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"a-note-on-version-pinning\"\u003eA note on version pinning\u003c/h3\u003e\u003cp\u003eDependency management systems tend to use a lock file (like \u003ccode\u003ePackage.resolved\u003c/code\u003e in Swift Package manager, \u003ccode\u003ePodfile.lock\u003c/code\u003e in the old days of CocoaPods, \u003ccode\u003eyarn.lock\u003c/code\u003e/\u003ccode\u003epackage-lock.json\u003c/code\u003e in JavaScript, etc.).\u003c/p\u003e\u003cp\u003eThe benefits of using a lock file are mainly 2:\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eReproducibility\u003c/strong\u003e\u003cbr/\u003eIt locks the exact versions (including transitive dependencies) so that every team member, CI server, or production environment installs the same versions.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eFaster installs\u003c/strong\u003e\u003cbr/\u003eDependency managers can skip version resolution if a lock file is present, using it directly to fetch the exact versions, improving speed.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eWe can remove the need for lock files if we pin the versions in the spec (the file defining the tools). If version range operators like the CocoaPods\u0026#39; optimistic operator \u003ccode\u003e~\u0026gt;\u003c/code\u003e and the SPM\u0026#39;s \u003ccode\u003e.upToNextMajor\u003c/code\u003e and similar one didn\u0026#39;t exist, usages of lock files would lose its utility.\u003c/p\u003e\u003cp\u003eWhile useful, lock files are generally annoying and can create that odd feeling of seeing unexpected updates in pull requests made by others. ToolManager doesn\u0026#39;t use a lock file; \u003cstrong\u003einstead\u003c/strong\u003e, it requires teams to pin their tools\u0026#39; versions, which I strongly believe is a good practice.\u003c/p\u003e\u003cp\u003eThis approach comes at the cost of teams having to keep an eye out for patch releases and not leaving updates to the machine, which risks pulling in dependencies that don\u0026#39;t respect Semantic Versioning (\u003ca href=\"https://semver.org/?ref=albertodebortoli.com\"\u003eSemVer\u003c/a\u003e).\u003c/p\u003e\u003ch3 id=\"support-for-different-architectures\"\u003eSupport for different architectures\u003c/h3\u003e\u003cp\u003eThis design allows to support different architectures. Some CI workflows might only need a Linux runner to reduce the burden on precious macOS instances. Both macOS and Linux can be supported with individual Toolfile that can be specified when running the \u003ccode\u003einstall\u003c/code\u003e command.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e# on macOS\nToolManager install --spec=Toolfile_macOS\n\n# on Linux\nToolManager install --spec=Toolfile_Linux\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eThe design described in this article powers the solution implemented at JET and has served our teams successfully since October 2023. JET has always preferred to implement in-house solutions where possible and sensible, and I can say that moving away from Homebrew was a blessing.\u003c/p\u003e\u003cp\u003eWith this design, the work usually done by a package manager and a central spec repository is shifted to individual components that are only required to publish releases in zip archives, ideally via a release workflow.\u003c/p\u003e\u003cp\u003eBy \u003cu\u003edecentralising\u003c/u\u003e and requiring \u003cu\u003eversion pinning\u003c/u\u003e, we made ToolManager a simple yet powerful system for managing the installation of CLI tools.\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "19 min read",
  "publishedTime": "2025-07-13T23:15:31Z",
  "modifiedTime": "2025-07-15T07:57:07Z"
}
