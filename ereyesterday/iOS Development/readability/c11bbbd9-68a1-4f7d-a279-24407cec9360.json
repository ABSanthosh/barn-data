{
  "id": "c11bbbd9-68a1-4f7d-a279-24407cec9360",
  "title": "SwiftData Expressions",
  "link": "https://useyourloaf.com/blog/swiftdata-expressions/",
  "description": "SwiftData gained support for predicate expression in iOS 18. How does it compare to the expressions we can use with Core Data? Core Data Queries with NSExpression When Apple launched SwiftData with iOS 17 there were some gaps compared to Core Data. A big one for me was the ability to create an aggregate query (FB12292503). For example, to fetch the minimum, maximum, sum, or average of a property. I first wrote about using a Core Data expression to query for min and max values back in 2012. Here’s an updated example with a Core Data log entity that contains a set of markers: public final class CDLog: NSManagedObject { @NSManaged public var name: String? @NSManaged public var timestamp: Date? @NSManaged public var markers: NSSet? ... } The markers also contain a timestamp: public final class CDMarker: NSManagedObject { @NSManaged public var timestamp: Date? @NSManaged public var log: CDLog? ... } I want to know the range (min…max) of timestamps for the markers in a log entry. One way would be to fetch the markers, sorted by timestamp, and return the timestamps of the first, and last markers. A better way is to have SQLite calculate and directly return the values. Core Data has long supported creating fetch requests and predicates with the Foundation type NSExpression. It takes a lot of code but here’s a request that fetches the minimum (earliest) and maximum (latest) dates of markers in a log entry: public class func boundsRequest( _ timeline: NSManagedObjectID ) -\u003e NSFetchRequest\u003cNSFetchRequestResult\u003e { let request = NSFetchRequest\u003cNSFetchRequestResult\u003e( entityName: CDMarker.entityName) request.predicate = CDMarker.inTimeline(timeline) request.resultType = .dictionaryResultType let keyPathExpression = NSExpression(forKeyPath: \\CDMarker.timestamp) let earliestDescription = NSExpressionDescription() earliestDescription.name = \"earliestDate\" earliestDescription.expression = NSExpression(forFunction: \"min:\", arguments: [keyPathExpression]) earliestDescription.expressionResultType = .dateAttributeType let latestDescription = NSExpressionDescription() latestDescription.name = \"latestDate\" latestDescription.expression = NSExpression(forFunction: \"max:\", arguments: [keyPathExpression]) latestDescription.expressionResultType = .dateAttributeType request.propertiesToFetch = [ earliestDescription, latestDescription ] return request } The two NSExpression properties apply a function (min or max) to a keypath returning the two values in a dictionary. Core Data translates the expressions to an SQLite statement performing the work at the database level. SwiftData Predicate Expressions In iOS 18, SwiftData can make use of Foundation’s new #Expression macro to make it easier to build more complex predicates. From the WWDC session: Expressions allow for reference values that do not produce true or false but instead allow for arbitrary types. You can then evaluate the expression as part of more complex predicate. Let’s see an example. I have an Item model class that can contain one or more Record items: @Model final class Item { var name: String var timestamp: Date var record: [Record] } The Record model includes a score: @Model final class Record { var score: Int ... } Suppose I want to find all items with three or more records of which at least two are a passing score of 90 or more. We can write an expression that counts the number of passing records: let passingScore = #Expression\u003c[Record], Int\u003e { records in records.filter { $0.score \u003e= 90 }.count } Note: The body of the expression is restricted to a single expression. We can then evaluate this expression in a compound item predicate: let highScoring = #Predicate\u003cItem\u003e { item in item.records.count \u003e 2 \u0026\u0026 passingScore.evaluate(item.records) \u003e 1 } The resulting SQL query: CoreData: sql: SELECT 0, t0.Z_PK, t0.Z_OPT, t0.ZNAME, t0.ZTIMESTAMP FROM ZITEM t0 WHERE ( (SELECT COUNT(t1.Z_PK) FROM ZRECORD t1 WHERE ( t0.Z_PK = t1.Z1RECORDS) ) \u003e ? AND (SELECT COUNT(t2.Z_PK) FROM ZRECORD t2 WHERE ( t0.Z_PK = t2.Z1RECORDS AND ( t2.ZSCORE \u003e= ?)) ) \u003e ? ) This look promising but I could already write this predicate without the expression: let highScoring = #Predicate\u003cItem\u003e { item in item.records.count \u003e 2 \u0026\u0026 item.records.filter { $0.score \u003e= 90 }.count \u003e 1 } If you expand the expression macro or check the Expression documentation you’ll see it’s creating PredicateExpressions which appear to support a wide range of methods. Unfortunately I can’t seem to get most of them to work either in predicates or expressions. For example, similar to my earlier Core Data example, here’s an expression to return the maximum score in a collection of records: let maxScore = #Expression\u003c[Record], Int\u003e { records in records.map { $0.score }.max() ?? 0 } That fails to compile: The map() function is not supported in this expression So maybe this will improve in future updates but right now I’m not sure I’m gaining anything from using expressions? Let me know if you’ve had more success. Learn More What’s new in SwiftData SwiftData Expressions was originally posted 09 Sep 2024 on useyourloaf.com. Want this direct to your inbox? Sign up and get my free WWDC viewing guide PDF.",
  "author": "",
  "published": "Mon, 09 Sep 2024 13:03:47 +0100",
  "source": "https://useyourloaf.com/blog/rss.xml",
  "categories": null,
  "byline": "",
  "length": 5165,
  "excerpt": "SwiftData adds predicate expressions in iOS 18.",
  "siteName": "Use Your Loaf - iOS Development News \u0026 Tips",
  "favicon": "https://useyourloaf.com/apple-touch-icon.png",
  "text": "SwiftData gained support for predicate expression in iOS 18. How does it compare to the expressions we can use with Core Data? Core Data Queries with NSExpression When Apple launched SwiftData with iOS 17 there were some gaps compared to Core Data. A big one for me was the ability to create an aggregate query (FB12292503). For example, to fetch the minimum, maximum, sum, or average of a property. I first wrote about using a Core Data expression to query for min and max values back in 2012. Here’s an updated example with a Core Data log entity that contains a set of markers: public final class CDLog: NSManagedObject { @NSManaged public var name: String? @NSManaged public var timestamp: Date? @NSManaged public var markers: NSSet? ... } The markers also contain a timestamp: public final class CDMarker: NSManagedObject { @NSManaged public var timestamp: Date? @NSManaged public var log: CDLog? ... } I want to know the range (min…max) of timestamps for the markers in a log entry. One way would be to fetch the markers, sorted by timestamp, and return the timestamps of the first, and last markers. A better way is to have SQLite calculate and directly return the values. Core Data has long supported creating fetch requests and predicates with the Foundation type NSExpression. It takes a lot of code but here’s a request that fetches the minimum (earliest) and maximum (latest) dates of markers in a log entry: public class func boundsRequest( _ timeline: NSManagedObjectID ) -\u003e NSFetchRequest\u003cNSFetchRequestResult\u003e { let request = NSFetchRequest\u003cNSFetchRequestResult\u003e( entityName: CDMarker.entityName) request.predicate = CDMarker.inTimeline(timeline) request.resultType = .dictionaryResultType let keyPathExpression = NSExpression(forKeyPath: \\CDMarker.timestamp) let earliestDescription = NSExpressionDescription() earliestDescription.name = \"earliestDate\" earliestDescription.expression = NSExpression(forFunction: \"min:\", arguments: [keyPathExpression]) earliestDescription.expressionResultType = .dateAttributeType let latestDescription = NSExpressionDescription() latestDescription.name = \"latestDate\" latestDescription.expression = NSExpression(forFunction: \"max:\", arguments: [keyPathExpression]) latestDescription.expressionResultType = .dateAttributeType request.propertiesToFetch = [ earliestDescription, latestDescription ] return request } The two NSExpression properties apply a function (min or max) to a keypath returning the two values in a dictionary. Core Data translates the expressions to an SQLite statement performing the work at the database level. SwiftData Predicate Expressions In iOS 18, SwiftData can make use of Foundation’s new #Expression macro to make it easier to build more complex predicates. From the WWDC session: Expressions allow for reference values that do not produce true or false but instead allow for arbitrary types. You can then evaluate the expression as part of more complex predicate. Let’s see an example. I have an Item model class that can contain one or more Record items: @Model final class Item { var name: String var timestamp: Date var record: [Record] } The Record model includes a score: @Model final class Record { var score: Int ... } Suppose I want to find all items with three or more records of which at least two are a passing score of 90 or more. We can write an expression that counts the number of passing records: let passingScore = #Expression\u003c[Record], Int\u003e { records in records.filter { $0.score \u003e= 90 }.count } Note: The body of the expression is restricted to a single expression. We can then evaluate this expression in a compound item predicate: let highScoring = #Predicate\u003cItem\u003e { item in item.records.count \u003e 2 \u0026\u0026 passingScore.evaluate(item.records) \u003e 1 } The resulting SQL query: CoreData: sql: SELECT 0, t0.Z_PK, t0.Z_OPT, t0.ZNAME, t0.ZTIMESTAMP FROM ZITEM t0 WHERE ( (SELECT COUNT(t1.Z_PK) FROM ZRECORD t1 WHERE ( t0.Z_PK = t1.Z1RECORDS) ) \u003e ? AND (SELECT COUNT(t2.Z_PK) FROM ZRECORD t2 WHERE ( t0.Z_PK = t2.Z1RECORDS AND ( t2.ZSCORE \u003e= ?)) ) \u003e ? ) This look promising but I could already write this predicate without the expression: let highScoring = #Predicate\u003cItem\u003e { item in item.records.count \u003e 2 \u0026\u0026 item.records.filter { $0.score \u003e= 90 }.count \u003e 1 } If you expand the expression macro or check the Expression documentation you’ll see it’s creating PredicateExpressions which appear to support a wide range of methods. Unfortunately I can’t seem to get most of them to work either in predicates or expressions. For example, similar to my earlier Core Data example, here’s an expression to return the maximum score in a collection of records: let maxScore = #Expression\u003c[Record], Int\u003e { records in records.map { $0.score }.max() ?? 0 } That fails to compile: The map() function is not supported in this expression So maybe this will improve in future updates but right now I’m not sure I’m gaining anything from using expressions? Let me know if you’ve had more success. Learn More What’s new in SwiftData",
  "image": "https://useyourloaf.com/blog/swiftdata-expressions/cover.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eSwiftData gained support for predicate expression in iOS 18. How does it compare to the expressions we can use with Core Data?\u003c/p\u003e\n\u003ch3 id=\"core-data-queries-with-nsexpression\"\u003eCore Data Queries with NSExpression\u003c/h3\u003e\n\u003cp\u003eWhen Apple launched SwiftData with iOS 17 there were some gaps compared to Core Data. A big one for me was the ability to create an \u003cstrong\u003eaggregate query\u003c/strong\u003e (FB12292503). For example, to fetch the minimum, maximum, sum, or average of a property.\u003c/p\u003e\n\u003cp\u003eI first wrote about using a \u003ca href=\"https://useyourloaf.com/blog/core-data-queries-using-expressions/\"\u003eCore Data expression to query for min and max values\u003c/a\u003e back in 2012. Here’s an updated example with a Core Data log entity that contains a set of markers:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eCDLog\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eNSManagedObject\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e@NSManaged\u003c/span\u003e \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e@NSManaged\u003c/span\u003e \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003etimestamp\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDate\u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e@NSManaged\u003c/span\u003e \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003emarkers\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eNSSet\u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe markers also contain a timestamp:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eCDMarker\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eNSManagedObject\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e@NSManaged\u003c/span\u003e \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003etimestamp\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDate\u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e@NSManaged\u003c/span\u003e \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCDLog\u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI want to know the range (min…max) of timestamps for the markers in a log entry. One way would be to fetch the markers, sorted by timestamp, and return the timestamps of the first, and last markers. A better way is to have SQLite calculate and directly return the values.\u003c/p\u003e\n\u003cp\u003eCore Data has long supported creating fetch requests and predicates with the Foundation type \u003ccode\u003eNSExpression\u003c/code\u003e. It takes \u003cstrong\u003ea lot of code\u003c/strong\u003e but here’s a request that fetches the minimum (earliest) and maximum (latest) dates of markers in a log entry:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eboundsRequest\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e_\u003c/span\u003e \u003cspan\u003etimeline\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eNSManagedObjectID\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eNSFetchRequest\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eNSFetchRequestResult\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003erequest\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNSFetchRequest\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eNSFetchRequestResult\u003c/span\u003e\u003cspan\u003e\u0026gt;(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eentityName\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCDMarker\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eentityName\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003erequest\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epredicate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eCDMarker\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einTimeline\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etimeline\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003erequest\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresultType\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edictionaryResultType\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ekeyPathExpression\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNSExpression\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eforKeyPath\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e\\\u003c/span\u003e\u003cspan\u003eCDMarker\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etimestamp\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eearliestDescription\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNSExpressionDescription\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eearliestDescription\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;earliestDate\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eearliestDescription\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpression\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eNSExpression\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eforFunction\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;min:\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                   \u003cspan\u003earguments\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ekeyPathExpression\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eearliestDescription\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpressionResultType\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edateAttributeType\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003elatestDescription\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNSExpressionDescription\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elatestDescription\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;latestDate\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elatestDescription\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpression\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eNSExpression\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eforFunction\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;max:\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                   \u003cspan\u003earguments\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ekeyPathExpression\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elatestDescription\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpressionResultType\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edateAttributeType\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003erequest\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epropertiesToFetch\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eearliestDescription\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003elatestDescription\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003erequest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe two \u003ccode\u003eNSExpression\u003c/code\u003e properties apply a function (min or max) to a keypath returning the two values in a dictionary. Core Data translates the expressions to an SQLite statement performing the work at the database level.\u003c/p\u003e\n\u003ch3 id=\"swiftdata-predicate-expressions\"\u003eSwiftData Predicate Expressions\u003c/h3\u003e\n\u003cp\u003eIn iOS 18, SwiftData can make use of Foundation’s new \u003ccode\u003e#Expression\u003c/code\u003e macro to make it easier to build more complex predicates. From the WWDC session:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eExpressions allow for reference values that do not produce true or false but instead allow for arbitrary types.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eYou can then evaluate the expression as part of more complex predicate. Let’s see an example.\u003c/p\u003e\n\u003cp\u003eI have an Item model class that can contain one or more Record items:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eModel\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eItem\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e   \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003etimestamp\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDate\u003c/span\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003erecord\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eRecord\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe \u003ccode\u003eRecord\u003c/code\u003e model includes a score:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eModel\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eRecord\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003escore\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e   \u003cspan\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSuppose I want to find all items with three or more records of which at least two are a passing score of 90 or more. We can write an expression that counts the number of passing records:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003epassingScore\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eExpression\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eRecord\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003erecords\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003erecords\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efilter\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e$0\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escore\u003c/span\u003e \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e90\u003c/span\u003e \u003cspan\u003e}.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNote: The body of the expression is restricted to a single expression.\u003c/p\u003e\n\u003cp\u003eWe can then evaluate this expression in a compound item predicate:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ehighScoring\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003ePredicate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eItem\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erecords\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003epassingScore\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eevaluate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erecords\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe resulting SQL query:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eCoreData\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esql\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSELECT\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003et0\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eZ_PK\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003et0\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eZ_OPT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003et0\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eZNAME\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003et0\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eZTIMESTAMP\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e \u003cspan\u003eFROM\u003c/span\u003e \u003cspan\u003eZITEM\u003c/span\u003e \u003cspan\u003et0\u003c/span\u003e \u003cspan\u003eWHERE\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eSELECT\u003c/span\u003e \u003cspan\u003eCOUNT\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et1\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eZ_PK\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003eFROM\u003c/span\u003e \u003cspan\u003eZRECORD\u003c/span\u003e \u003cspan\u003et1\u003c/span\u003e \u003cspan\u003eWHERE\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e   \u003cspan\u003et0\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eZ_PK\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et1\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eZ1RECORDS\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003eAND\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eSELECT\u003c/span\u003e \u003cspan\u003eCOUNT\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et2\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eZ_PK\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003eFROM\u003c/span\u003e \u003cspan\u003eZRECORD\u003c/span\u003e \u003cspan\u003et2\u003c/span\u003e \u003cspan\u003eWHERE\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e   \u003cspan\u003et0\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eZ_PK\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et2\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eZ1RECORDS\u003c/span\u003e \u003cspan\u003eAND\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e \u003cspan\u003et2\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eZSCORE\u003c/span\u003e \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e?))\u003c/span\u003e \u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e \u003cspan\u003e)\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis look promising but I could already write this predicate without the expression:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ehighScoring\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003ePredicate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eItem\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erecords\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erecords\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efilter\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e$0\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escore\u003c/span\u003e \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e90\u003c/span\u003e \u003cspan\u003e}.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf you expand the expression macro or check the \u003ca href=\"https://developer.apple.com/documentation/foundation/expression\"\u003eExpression documentation\u003c/a\u003e you’ll see it’s creating \u003ca href=\"https://developer.apple.com/documentation/foundation/predicateexpression\"\u003ePredicateExpressions\u003c/a\u003e which appear to support a wide range of methods. Unfortunately I can’t seem to get most of them to work either in predicates or expressions.\u003c/p\u003e\n\u003cp\u003eFor example, similar to my earlier Core Data example, here’s an expression to return the maximum score in a collection of records:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emaxScore\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eExpression\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eRecord\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003erecords\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003erecords\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e$0\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escore\u003c/span\u003e \u003cspan\u003e}.\u003c/span\u003e\u003cspan\u003emax\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e??\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThat fails to compile:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe map() function is not supported in this expression\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSo maybe this will improve in future updates but right now I’m not sure I’m gaining anything from using expressions? Let me know if you’ve had more success.\u003c/p\u003e\n\u003ch3 id=\"learn-more\"\u003eLearn More\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.apple.com/wwdc24/10137?time=618\"\u003eWhat’s new in SwiftData\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-09-09T13:03:47+01:00",
  "modifiedTime": "2024-09-09T14:35:42+01:00"
}
