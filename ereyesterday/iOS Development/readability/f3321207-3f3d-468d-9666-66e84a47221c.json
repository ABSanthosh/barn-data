{
  "id": "f3321207-3f3d-468d-9666-66e84a47221c",
  "title": "Tips and tricks for when using SwiftUI’s ViewBuilder",
  "link": "https://www.swiftbysundell.com/articles/swiftui-viewbuilder-tips-and-tricks",
  "description": "Let’s explore how we can use SwiftUI’s ViewBuilder within our own code, and a few things that can be good to keep in mind when doing so.",
  "author": "",
  "published": "Fri, 30 May 2025 14:25:00 +0200",
  "source": "https://www.swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 13674,
  "excerpt": "Let’s explore how we can use SwiftUI’s ViewBuilder within our own code, and a few things that can be good to keep in mind when doing so.",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "SwiftUI’s ViewBuilder type is a key part of the library’s overall API design, in that it’s what enables multiple view expressions to be declared within a given scope (such as a body property implementation, or a closure passed to containers such as HStack or VStack) without requiring any manual grouping or wrapping at each call site.For example, within the following VStack, we can simply place each subview within the closure we pass to it, and ViewBuilder will take care of collecting those views and building them into the final content that then gets rendered within the stack:VStack { Image(systemName: \"star\") Text(\"Hello, world!\") }What’s interesting about ViewBuilder is that it’s completely possible to use SwiftUI for a significant amount of time before even discovering that it exists. After all, we don’t have to reference it explicitly in most situations, as SwiftUI’s various closures and protocols have already been annotated with the corresponding @ViewBuilder attribute out of the box.For example, the View protocol that we use every time we want to define a custom view uses ViewBuilder implicitly, since the definition for the body property requirement looks like this:@MainActor @preconcurrency public protocol View { associatedtype Body : View @ViewBuilder @MainActor @preconcurrency var body: Self.Body { get } }That’s what makes it possible to use things like control flow within our view body implementations, even when each branch within such a flow returns different types, and even when we don’t explicitly mark our property with @ViewBuilder ourselves:struct RootView: View { @State private var user: User? var body: some View { if let user { HomeView(user: user) } else { LoginView(user: $user) } } }The way our views automatically get annotated with @ViewBuilder works the same way as why we don’t have to manually mark our views as @MainActor to run them on the main thread — our custom view types automatically inherit those attributes from the View protocol declaration.But there are situations in which using ViewBuilder directly can be incredibly useful — so let’s go ahead and explore a few such examples, along with some tips and tricks that can be good to keep in mind when writing that kind of code.Custom containersAny property, function, or closure can be marked with the @ViewBuilder attribute, which opts that code into getting the same “DSL-like” capabilities as SwiftUI’s built-in APIs. For example, let’s say that we’re building a custom Container view, which renders a header on top of a content view, while also applying some default styling to those two components:struct Container\u003cHeader: View, Content: View\u003e: View { var header: Header var content: Content var body: some View { VStack(spacing: 0) { header .frame(maxWidth: .infinity) .padding() .foregroundStyle(.white) .background(Color.blue) ScrollView { content.padding() } } } }As our Container view is currently defined, we’re limited to using just a single view for both the header and content properties, and we’d pass them just like we’d pass any other Swift initializer values — for example like this:Container(header: Text(\"Welcome\"), content: ContentView())Now, let’s go ahead and mark both header and content with the @ViewBuilder attribute, to see how that affects our view’s API:struct Container\u003cHeader: View, Content: View\u003e: View { @ViewBuilder var header: Header @ViewBuilder var content: Content var body: some View { ... } }What’s interesting is that, even though we haven’t redefined either of the above properties as being closures (they still both just store a single view value), their values must now be passed as closures when we initialize our Container view. ViewBuilder will then take any closure that we passed, and apply its view building logic to it, resulting in a single output view, which is then stored within each property.What that means is that we’re now able to use the same SwiftUI syntax as when interacting with the library’s built-in APIs when defining either our header or content. Let’s use that new capability to update our RootView from before to use our new Container implementation, as we’re now able to use an if statement with separate view branches to declare our view’s content:struct RootView: View { @State private var user: User? var body: some View { Container(header: { Text(\"Welcome\") }, content: { if let user { HomeView(user: user) } else { LoginView(user: $user) } }) } }Neat! Next, let’s take a look at how we might handle situations when we want to omit a specific component from a custom container view.Making view builder properties optionalFor example, let’s say that we want to make our Container view’s header optional. One way to get that done would be to write an extension on Container with a generic constraint on SwiftUI’s EmptyView type, which allows us to then pass that type’s initializer as a closure when calling our view’s member-wise initializer:extension Container where Header == EmptyView { init(@ViewBuilder content: () -\u003e Content) { self.init(header: EmptyView.init, content: content) } }Note that we have to use a closure for our content property above, rather than just a Content value. That’s because the automatic conversion from view builder closure to single view value that we utilized before only works for stored properties, not for function arguments. Our closure doesn’t need to be @escaping, though, since SwiftUI will still evaluate it directly and automatically convert it into a single view, just like when using our view’s member-wise initializer.With the above in place, we could now update our RootView to no longer use a header, which in turn enables us to use trailing closure syntax to achieve a call site that looks exactly like when using SwiftUI’s built in containers (like HStack or VStack):struct RootView: View { @State private var user: User? var body: some View { Container { if let user { HomeView(user: user) } else { LoginView(user: $user) } } } }While the above works great, there’s an alternative approach that we can take if we don’t want to define a constrained Container extension, but rather just use a custom initializer with default argument values instead.What’s cool about using ViewBuilder is that, unlike when accepting separate view values directly, the compiler will automatically infer the concrete types for Header and Content if we use default arguments for their corresponding values.So, if we specify EmptyView.init as the default value for our header property argument, then we can achieve the exact same result as when using the extension-based approach, while also giving us the option to keep adding more default values and convenience APIs in the future — all without having to define multiple extensions:struct Container\u003cHeader: View, Content: View\u003e: View { var header: Header var content: Content init(@ViewBuilder header: () -\u003e Header = EmptyView.init, @ViewBuilder content: () -\u003e Content) { self.header = header() self.content = content() } var body: some View { ... } }Note that we no longer need to add the @ViewBuilder attribute to our properties, since we now perform the closure-to-view conversion ourselves (by simply calling those closures within our view’s initializer).An alternative approach would’ve been to instead store references to our closures within the header and content properties, and to then call those closures within our view’s body. Doing so wouldn’t make much of a difference in this particular case (besides requiring those closures to be @escaping, which most of SwiftUI’s own view builder closures aren’t), however, in some situations, taking that approach can significantly hurt performance — since we’ll end up re-evaluating those closures every time our view’s body gets re-evaluated. So, when possible, resolving each view builder closure up-front gives us the most predictable and consistent results.Handling multiple view expressionsJust like when using SwiftUI’s built-in containers, it’s also now possible to place multiple view expressions within either our header or content closures. For example, if we bring back the header within our RootView, we might use this capability to add a NavigationLink below our welcome text — like this:struct RootView: View { ... var body: some View { Container(header: { Text(\"Welcome\") NavigationLink(\"Info\") { InfoView() } }, content: { ... }) } }However, call sites like the one above might not always produce the result we’d expect, since when processed by ViewBuilder, multiple view expressions will essentially be treated the same way as if they were added to a SwiftUI Group — in that they’ll each be independently styled, sized, and positioned according to the current context.So, in the above example, we’re not actually adding a combined header to our view, but rather two separate headers — each with its own layout within the enclosing VStack, and each with its own set of modifiers applied to it.To resolve that, it might be a good idea to wrap both our header and content views within explicit containers, so that their layout will always be predictable, even when multiple view expressions are used at a specific call site:struct Container\u003cHeader: View, Content: View\u003e: View { ... var body: some View { VStack(spacing: 0) { VStack { header } .frame(maxWidth: .infinity) .padding() .foregroundStyle(.white) .background(Color.blue) ScrollView { VStack { content } .padding() } } } }Whether to take the above approach (and enforce a specific layout within the container in question), or leave it up to each call site to define its own layout, will likely come down to a combination of personal/team preference and the specific container (and layout behaviors) that we’re implementing.There are cases, though, where it’s arguably best to add an explicit container at the call site, in order to make our code more clear and easier to maintain. For example, here we’re using @ViewBuilder as a sort of code organization tool, in that we’re applying it to private functions that we’re using to build separate parts of our view — which in general is a really great way to structure increasingly complex SwiftUI view implementations, rather than allowing our body properties to grow too large in scope:struct RootView: View { @State private var user: User? var body: some View { Container(header: header, content: content) } } private extension RootView { @ViewBuilder func header() -\u003e some View { Text(\"Welcome\") NavigationLink(\"Info\") { InfoView() } } @ViewBuilder func content() -\u003e some View { if let user { HomeView(user: user) } else { LoginView(user: $user) } } }However, while our above code is now very neatly organized, the semantics of our new header function are arguably a bit odd — since it doesn’t really return a header, but rather multiple view expressions that will be built into a header. It might be a nitpicky detail in the grand scheme of things, but aiming to write code to be as clear as possible does often really help when it comes to future maintainability.A rule of thumb that can be good to follow is that a function or computed property should never return multiple root view expressions (since that gives us an implicit group, just like before). Instead, it would arguably be better if our header function didn’t actually use ViewBuilder, but rather just returned an explicit VStack which in turn contains our header view’s content. That way, it’ll become crystal clear how our header will be rendered, even if we end up changing how our Container view works in the future:private extension RootView { func header() -\u003e some View { VStack(spacing: 20) { Text(\"Welcome\") NavigationLink(\"Info\") { InfoView() } } } @ViewBuilder func content() -\u003e some View { if let user { HomeView(user: user) } else { LoginView(user: $user) } } }We still want to keep using @ViewBuilder for our content function, though, since it returns just a single (albeit conditional) root view expression.Swift by Sundell is brought to you by the Genius Scan SDK — Add a powerful document scanner to any mobile app, and turn scans into high-quality PDFs with one line of code. Try it today.ConclusionSwiftUI’s ViewBuilder is a really powerful tool, and the fact that we can opt our own code into using it gives us a lot of flexibility when it comes to how we want to structure and reuse our UI code. By adopting it within our own custom containers, we can really craft APIs that feel right at home alongside SwiftUI’s own features, which in turn should help us improve the consistency and clarity of the UI code that we write.I hope you enjoyed this article. If you have any questions, comments, or feedback, then feel free to reach out via either Mastodon or Bluesky.Thanks for reading!",
  "image": "https://www.swiftbysundell.com/images/social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eSwiftUI’s \u003ccode\u003eViewBuilder\u003c/code\u003e type is a key part of the library’s overall API design, in that it’s what enables multiple view expressions to be declared within a given scope (such as a \u003ccode\u003ebody\u003c/code\u003e property implementation, or a closure passed to containers such as \u003ccode\u003eHStack\u003c/code\u003e or \u003ccode\u003eVStack\u003c/code\u003e) without requiring any manual grouping or wrapping at each call site.\u003c/p\u003e\u003cp\u003eFor example, within the following \u003ccode\u003eVStack\u003c/code\u003e, we can simply place each subview within the closure we pass to it, and \u003ccode\u003eViewBuilder\u003c/code\u003e will take care of collecting those views and \u003cem\u003ebuilding\u003c/em\u003e them into the final content that then gets rendered within the stack:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eVStack\u003c/span\u003e {\n    \u003cspan\u003eImage\u003c/span\u003e(systemName: \u003cspan\u003e\u0026#34;star\u0026#34;\u003c/span\u003e)\n    \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Hello, world!\u0026#34;\u003c/span\u003e)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat’s interesting about \u003ccode\u003eViewBuilder\u003c/code\u003e is that it’s completely possible to use SwiftUI for a significant amount of time before even discovering that it exists. After all, we don’t have to reference it explicitly in most situations, as SwiftUI’s various closures and protocols have already been annotated with the corresponding \u003ccode\u003e@ViewBuilder\u003c/code\u003e attribute out of the box.\u003c/p\u003e\u003cp\u003eFor example, the \u003ccode\u003eView\u003c/code\u003e protocol that we use every time we want to define a custom view uses \u003ccode\u003eViewBuilder\u003c/code\u003e implicitly, since the definition for the \u003ccode\u003ebody\u003c/code\u003e property requirement looks like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e@MainActor @preconcurrency public protocol\u003c/span\u003e View {\n    \u003cspan\u003eassociatedtype\u003c/span\u003e Body : \u003cspan\u003eView\u003c/span\u003e\n\n    \u003cspan\u003e\u003cspan\u003e@ViewBuilder\u003c/span\u003e\u003c/span\u003e \u003cspan\u003e@MainActor @preconcurrency var\u003c/span\u003e body: \u003cspan\u003eSelf\u003c/span\u003e.\u003cspan\u003eBody\u003c/span\u003e { \u003cspan\u003eget\u003c/span\u003e }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat’s what makes it possible to use things like control flow within our view \u003ccode\u003ebody\u003c/code\u003e implementations, even when each branch within such a flow returns different types, and even when we don’t explicitly mark our property with \u003ccode\u003e@ViewBuilder\u003c/code\u003e ourselves:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e RootView: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e@State private var\u003c/span\u003e user: \u003cspan\u003eUser\u003c/span\u003e?\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003e\u003cspan\u003eif let\u003c/span\u003e user {\n    \u003cspan\u003eHomeView\u003c/span\u003e(user: user)\n} \u003cspan\u003eelse\u003c/span\u003e {\n    \u003cspan\u003eLoginView\u003c/span\u003e(user: \u003cspan\u003e$user\u003c/span\u003e)\n}\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp\u003eThe way our views automatically get annotated with \u003ccode\u003e@ViewBuilder\u003c/code\u003e works the same way as why we don’t have to manually mark our views as \u003ccode\u003e@MainActor\u003c/code\u003e to run them on the main thread — our custom view types automatically inherit those attributes from the \u003ccode\u003eView\u003c/code\u003e protocol declaration.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eBut there \u003cem\u003eare\u003c/em\u003e situations in which using \u003ccode\u003eViewBuilder\u003c/code\u003e directly can be incredibly useful — so let’s go ahead and explore a few such examples, along with some tips and tricks that can be good to keep in mind when writing that kind of code.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"custom-containers\" href=\"#custom-containers\"\u003eCustom containers\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAny property, function, or closure can be marked with the \u003ccode\u003e@ViewBuilder\u003c/code\u003e attribute, which opts that code into getting the same \u003cem\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Domain-specific_language\"\u003e“DSL-like”\u003c/a\u003e\u003c/em\u003e capabilities as SwiftUI’s built-in APIs. For example, let’s say that we’re building a custom \u003ccode\u003eContainer\u003c/code\u003e view, which renders a \u003ccode\u003eheader\u003c/code\u003e on top of a \u003ccode\u003econtent\u003c/code\u003e view, while also applying some default styling to those two components:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e Container\u0026lt;Header: \u003cspan\u003eView\u003c/span\u003e, Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e header: \u003cspan\u003eHeader\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e content: \u003cspan\u003eContent\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eVStack\u003c/span\u003e(spacing: \u003cspan\u003e0\u003c/span\u003e) {\n            header\n                .\u003cspan\u003eframe\u003c/span\u003e(maxWidth: .\u003cspan\u003einfinity\u003c/span\u003e)\n                .\u003cspan\u003epadding\u003c/span\u003e()\n                .\u003cspan\u003eforegroundStyle\u003c/span\u003e(.\u003cspan\u003ewhite\u003c/span\u003e)\n                .\u003cspan\u003ebackground\u003c/span\u003e(\u003cspan\u003eColor\u003c/span\u003e.\u003cspan\u003eblue\u003c/span\u003e)\n\n            \u003cspan\u003eScrollView\u003c/span\u003e {\n                content.\u003cspan\u003epadding\u003c/span\u003e()\n            }\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs our \u003ccode\u003eContainer\u003c/code\u003e view is currently defined, we’re limited to using just a single view for both the \u003ccode\u003eheader\u003c/code\u003e and \u003ccode\u003econtent\u003c/code\u003e properties, and we’d pass them just like we’d pass any other Swift initializer values — for example like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eContainer\u003c/span\u003e(header: \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Welcome\u0026#34;\u003c/span\u003e), content: \u003cspan\u003eContentView\u003c/span\u003e())\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, let’s go ahead and mark both \u003ccode\u003eheader\u003c/code\u003e and \u003ccode\u003econtent\u003c/code\u003e with the \u003ccode\u003e@ViewBuilder\u003c/code\u003e attribute, to see how that affects our view’s API:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e Container\u0026lt;Header: \u003cspan\u003eView\u003c/span\u003e, Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003e@ViewBuilder\u003c/span\u003e\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e header: \u003cspan\u003eHeader\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003e@ViewBuilder\u003c/span\u003e\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e content: \u003cspan\u003eContent\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat’s interesting is that, even though we haven’t redefined either of the above properties as being closures (they still both just store a single view value), their values must now be \u003cem\u003epassed\u003c/em\u003e as closures when we initialize our \u003ccode\u003eContainer\u003c/code\u003e view. \u003ccode\u003eViewBuilder\u003c/code\u003e will then take any closure that we passed, and apply its view building logic to it, resulting in a single output view, which is then stored within each property.\u003c/p\u003e\u003cp\u003eWhat that means is that we’re now able to use the same SwiftUI syntax as when interacting with the library’s built-in APIs when defining either our \u003ccode\u003eheader\u003c/code\u003e or \u003ccode\u003econtent\u003c/code\u003e. Let’s use that new capability to update our \u003ccode\u003eRootView\u003c/code\u003e from before to use our new \u003ccode\u003eContainer\u003c/code\u003e implementation, as we’re now able to use an \u003ccode\u003eif\u003c/code\u003e statement with separate view branches to declare our view’s \u003ccode\u003econtent\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e RootView: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e@State private var\u003c/span\u003e user: \u003cspan\u003eUser\u003c/span\u003e?\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eContainer\u003c/span\u003e(header: {\n            \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Welcome\u0026#34;\u003c/span\u003e)\n        }, content: {\n            \u003cspan\u003e\u003cspan\u003eif let\u003c/span\u003e user {\n    \u003cspan\u003eHomeView\u003c/span\u003e(user: user)\n} \u003cspan\u003eelse\u003c/span\u003e {\n    \u003cspan\u003eLoginView\u003c/span\u003e(user: \u003cspan\u003e$user\u003c/span\u003e)\n}\u003c/span\u003e\n        })\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNeat! Next, let’s take a look at how we might handle situations when we want to omit a specific component from a custom container view.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"making-view-builder-properties-optional\" href=\"#making-view-builder-properties-optional\"\u003eMaking view builder properties optional\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFor example, let’s say that we want to make our \u003ccode\u003eContainer\u003c/code\u003e view’s \u003ccode\u003eheader\u003c/code\u003e optional. One way to get that done would be to write an extension on \u003ccode\u003eContainer\u003c/code\u003e with a generic constraint on SwiftUI’s \u003ccode\u003eEmptyView\u003c/code\u003e type, which allows us to then pass that type’s initializer as a closure when calling our view’s member-wise initializer:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eContainer\u003c/span\u003e \u003cspan\u003e\u003cspan\u003ewhere\u003c/span\u003e \u003cspan\u003eHeader\u003c/span\u003e == \u003cspan\u003eEmptyView\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003e@ViewBuilder\u003c/span\u003e content: () -\u0026gt; \u003cspan\u003eContent\u003c/span\u003e) {\n        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003einit\u003c/span\u003e(header: \u003cspan\u003e\u003cspan\u003eEmptyView\u003c/span\u003e.\u003cspan\u003einit\u003c/span\u003e\u003c/span\u003e, content: content)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that we have to use a closure for our \u003ccode\u003econtent\u003c/code\u003e property above, rather than just a \u003ccode\u003eContent\u003c/code\u003e value. That’s because the automatic conversion from view builder closure to single view value that we utilized before only works for stored properties, not for function arguments. Our closure doesn’t need to be \u003ccode\u003e@escaping\u003c/code\u003e, though, since SwiftUI will still evaluate it directly and automatically convert it into a single view, just like when using our view’s member-wise initializer.\u003c/p\u003e\u003cp\u003eWith the above in place, we could now update our \u003ccode\u003eRootView\u003c/code\u003e to no longer use a header, which in turn enables us to use trailing closure syntax to achieve a call site that looks exactly like when using SwiftUI’s built in containers (like \u003ccode\u003eHStack\u003c/code\u003e or \u003ccode\u003eVStack\u003c/code\u003e):\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e RootView: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e@State private var\u003c/span\u003e user: \u003cspan\u003eUser\u003c/span\u003e?\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eContainer\u003c/span\u003e {\n            \u003cspan\u003eif let\u003c/span\u003e user {\n                \u003cspan\u003eHomeView\u003c/span\u003e(user: user)\n            } \u003cspan\u003eelse\u003c/span\u003e {\n                \u003cspan\u003eLoginView\u003c/span\u003e(user: \u003cspan\u003e$user\u003c/span\u003e)\n            }\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhile the above works great, there’s an alternative approach that we can take if we don’t want to define a constrained \u003ccode\u003eContainer\u003c/code\u003e extension, but rather just use a custom initializer with default argument values instead.\u003c/p\u003e\u003cp\u003eWhat’s cool about using \u003ccode\u003eViewBuilder\u003c/code\u003e is that, unlike when accepting separate view values directly, the compiler will automatically infer the concrete types for \u003ccode\u003eHeader\u003c/code\u003e and \u003ccode\u003eContent\u003c/code\u003e if we use default arguments for their corresponding values.\u003c/p\u003e\u003cp\u003eSo, if we specify \u003ccode\u003eEmptyView.init\u003c/code\u003e as the default value for our \u003ccode\u003eheader\u003c/code\u003e property argument, then we can achieve the exact same result as when using the extension-based approach, while also giving us the option to keep adding more default values and convenience APIs in the future — all without having to define multiple extensions:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e Container\u0026lt;Header: \u003cspan\u003eView\u003c/span\u003e, Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e header: \u003cspan\u003eHeader\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e content: \u003cspan\u003eContent\u003c/span\u003e\n\n    \u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003e@ViewBuilder\u003c/span\u003e header: () -\u0026gt; \u003cspan\u003eHeader\u003c/span\u003e = \u003cspan\u003e\u003cspan\u003eEmptyView\u003c/span\u003e.\u003cspan\u003einit\u003c/span\u003e\u003c/span\u003e,\n         \u003cspan\u003e@ViewBuilder\u003c/span\u003e content: () -\u0026gt; \u003cspan\u003eContent\u003c/span\u003e) {\n        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003eheader\u003c/span\u003e = \u003cspan\u003eheader\u003c/span\u003e()\n        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003econtent\u003c/span\u003e = \u003cspan\u003econtent\u003c/span\u003e()\n    }\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that we no longer need to add the \u003ccode\u003e@ViewBuilder\u003c/code\u003e attribute to our properties, since we now perform the closure-to-view conversion ourselves (by simply calling those closures within our view’s initializer).\u003c/p\u003e\u003cp\u003eAn alternative approach would’ve been to instead store references to our closures within the \u003ccode\u003eheader\u003c/code\u003e and \u003ccode\u003econtent\u003c/code\u003e properties, and to then call those closures within our view’s \u003ccode\u003ebody\u003c/code\u003e. Doing so wouldn’t make much of a difference in this particular case (besides requiring those closures to be \u003ccode\u003e@escaping\u003c/code\u003e, which most of SwiftUI’s own view builder closures aren’t), however, in some situations, taking that approach can significantly hurt performance — since we’ll end up re-evaluating those closures every time our view’s \u003ccode\u003ebody\u003c/code\u003e gets re-evaluated. So, when possible, resolving each view builder closure up-front gives us the most predictable and consistent results.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"handling-multiple-view-expressions\" href=\"#handling-multiple-view-expressions\"\u003eHandling multiple view expressions\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eJust like when using SwiftUI’s built-in containers, it’s also now possible to place multiple view expressions within either our \u003ccode\u003eheader\u003c/code\u003e or \u003ccode\u003econtent\u003c/code\u003e closures. For example, if we bring back the header within our \u003ccode\u003eRootView\u003c/code\u003e, we might use this capability to add a \u003ccode\u003eNavigationLink\u003c/code\u003e below our welcome text — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e RootView: \u003cspan\u003eView\u003c/span\u003e {\n    ...\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eContainer\u003c/span\u003e(header: {\n            \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Welcome\u0026#34;\u003c/span\u003e)\n            \u003cspan\u003e\u003cspan\u003eNavigationLink\u003c/span\u003e(\u003cspan\u003e\u0026#34;Info\u0026#34;\u003c/span\u003e) {\n    \u003cspan\u003eInfoView\u003c/span\u003e()\n}\u003c/span\u003e\n        }, content: {\n            ...\n        })\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, call sites like the one above might not always produce the result we’d expect, since when processed by \u003ccode\u003eViewBuilder\u003c/code\u003e, multiple view expressions will essentially be treated the same way as if they were added to a SwiftUI \u003ccode\u003eGroup\u003c/code\u003e — in that they’ll each be independently styled, sized, and positioned according to the current context.\u003c/p\u003e\u003cp\u003eSo, in the above example, we’re not actually adding a \u003cem\u003ecombined header\u003c/em\u003e to our view, but rather \u003cem\u003etwo separate headers\u003c/em\u003e — each with its own layout within the enclosing \u003ccode\u003eVStack\u003c/code\u003e, and each with its own set of modifiers applied to it.\u003c/p\u003e\u003cp\u003eTo resolve that, it might be a good idea to wrap both our \u003ccode\u003eheader\u003c/code\u003e and \u003ccode\u003econtent\u003c/code\u003e views within explicit containers, so that their layout will always be predictable, even when multiple view expressions are used at a specific call site:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e Container\u0026lt;Header: \u003cspan\u003eView\u003c/span\u003e, Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    ...\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eVStack\u003c/span\u003e(spacing: \u003cspan\u003e0\u003c/span\u003e) {\n            \u003cspan\u003e\u003cspan\u003eVStack\u003c/span\u003e { header }\u003c/span\u003e\n                .\u003cspan\u003eframe\u003c/span\u003e(maxWidth: .\u003cspan\u003einfinity\u003c/span\u003e)\n                .\u003cspan\u003epadding\u003c/span\u003e()\n                .\u003cspan\u003eforegroundStyle\u003c/span\u003e(.\u003cspan\u003ewhite\u003c/span\u003e)\n                .\u003cspan\u003ebackground\u003c/span\u003e(\u003cspan\u003eColor\u003c/span\u003e.\u003cspan\u003eblue\u003c/span\u003e)\n\n            \u003cspan\u003eScrollView\u003c/span\u003e {\n                \u003cspan\u003e\u003cspan\u003eVStack\u003c/span\u003e { content }\u003c/span\u003e\n                    .\u003cspan\u003epadding\u003c/span\u003e()\n            }\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhether to take the above approach (and enforce a specific layout within the container in question), or leave it up to each call site to define its own layout, will likely come down to a combination of personal/team preference and the specific container (and layout behaviors) that we’re implementing.\u003c/p\u003e\u003cp\u003eThere are cases, though, where it’s arguably best to add an explicit container at the call site, in order to make our code more clear and easier to maintain. For example, here we’re using \u003ccode\u003e@ViewBuilder\u003c/code\u003e as a sort of code organization tool, in that we’re applying it to private functions that we’re using to build separate parts of our view — which in general is a really great way to structure increasingly complex SwiftUI view implementations, rather than allowing our \u003ccode\u003ebody\u003c/code\u003e properties to grow too large in scope:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e RootView: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e@State private var\u003c/span\u003e user: \u003cspan\u003eUser\u003c/span\u003e?\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eContainer\u003c/span\u003e(header: header, content: content)\n    }\n}\n\n\u003cspan\u003eprivate extension\u003c/span\u003e \u003cspan\u003eRootView\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003e@ViewBuilder func\u003c/span\u003e header()\u003c/span\u003e -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Welcome\u0026#34;\u003c/span\u003e)\n        \u003cspan\u003eNavigationLink\u003c/span\u003e(\u003cspan\u003e\u0026#34;Info\u0026#34;\u003c/span\u003e) {\n            \u003cspan\u003eInfoView\u003c/span\u003e()\n        }\n    }\n\n    \u003cspan\u003e\u003cspan\u003e@ViewBuilder func\u003c/span\u003e content()\u003c/span\u003e -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eif let\u003c/span\u003e user {\n            \u003cspan\u003eHomeView\u003c/span\u003e(user: user)\n        } \u003cspan\u003eelse\u003c/span\u003e {\n            \u003cspan\u003eLoginView\u003c/span\u003e(user: \u003cspan\u003e$user\u003c/span\u003e)\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, while our above code is now very neatly organized, the semantics of our new \u003ccode\u003eheader\u003c/code\u003e function are arguably a bit odd — since it doesn’t really return \u003cem\u003ea header\u003c/em\u003e, but rather multiple view expressions that will be \u003cem\u003ebuilt into a header\u003c/em\u003e. It might be a nitpicky detail in the grand scheme of things, but aiming to write code to be as clear as possible does often really help when it comes to future maintainability.\u003c/p\u003e\u003cp\u003eA rule of thumb that can be good to follow is that a function or computed property should never return multiple root view expressions (since that gives us an implicit group, just like before). Instead, it would arguably be better if our \u003ccode\u003eheader\u003c/code\u003e function didn’t actually use \u003ccode\u003eViewBuilder\u003c/code\u003e, but rather just returned an explicit \u003ccode\u003eVStack\u003c/code\u003e which in turn contains our header view’s content. That way, it’ll become crystal clear how our header will be rendered, even if we end up changing how our \u003ccode\u003eContainer\u003c/code\u003e view works in the future:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprivate extension\u003c/span\u003e \u003cspan\u003eRootView\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e header()\u003c/span\u003e -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eVStack\u003c/span\u003e(spacing: \u003cspan\u003e20\u003c/span\u003e) {\n            \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Welcome\u0026#34;\u003c/span\u003e)\n            \u003cspan\u003eNavigationLink\u003c/span\u003e(\u003cspan\u003e\u0026#34;Info\u0026#34;\u003c/span\u003e) {\n                \u003cspan\u003eInfoView\u003c/span\u003e()\n            }\n        }\n    }\n\n    \u003cspan\u003e@ViewBuilder func\u003c/span\u003e content() -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eif let\u003c/span\u003e user {\n            \u003cspan\u003eHomeView\u003c/span\u003e(user: user)\n        } \u003cspan\u003eelse\u003c/span\u003e {\n            \u003cspan\u003eLoginView\u003c/span\u003e(user: \u003cspan\u003e$user\u003c/span\u003e)\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe still want to keep using \u003ccode\u003e@ViewBuilder\u003c/code\u003e for our \u003ccode\u003econtent\u003c/code\u003e function, though, since it returns just a single (albeit conditional) root view expression.\u003c/p\u003e\u003ca href=\"https://geniusscansdk.com/swiftbysundell?utm_content=inline_ad\" rel=\"nofollow\" target=\"_blank\"\u003e\u003cimg src=\"https://www.swiftbysundell.com/images/supporters/geniusScan-image.png\" alt=\"Genius Scan SDK\"/\u003e\u003cp\u003eSwift by Sundell is brought to you by the \u003cstrong\u003eGenius Scan SDK\u003c/strong\u003e — Add a powerful document scanner to any mobile app, and turn scans into high-quality PDFs with one line of code. \u003cu\u003eTry it today\u003c/u\u003e.\u003c/p\u003e\u003c/a\u003e\u003ch2\u003e\u003ca id=\"conclusion\" href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSwiftUI’s \u003ccode\u003eViewBuilder\u003c/code\u003e is a really powerful tool, and the fact that we can opt our own code into using it gives us a lot of flexibility when it comes to how we want to structure and reuse our UI code. By adopting it within our own custom containers, we can really craft APIs that feel right at home alongside SwiftUI’s own features, which in turn should help us improve the consistency and clarity of the UI code that we write.\u003c/p\u003e\u003cp\u003eI hope you enjoyed this article. If you have any questions, comments, or feedback, then feel free to reach out via either \u003ca href=\"https://mastodon.social/@johnsundell\"\u003eMastodon\u003c/a\u003e or \u003ca href=\"https://bsky.app/profile/johnsundell.bsky.social\"\u003eBluesky\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": null,
  "modifiedTime": null
}
