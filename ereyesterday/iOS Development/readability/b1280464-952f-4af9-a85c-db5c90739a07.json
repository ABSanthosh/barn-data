{
  "id": "b1280464-952f-4af9-a85c-db5c90739a07",
  "title": "How the Swift compiler knows that DispatchQueue.main implies @MainActor",
  "link": "https://oleb.net/2024/dispatchqueue-mainactor/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2024-02-29T18:54:47Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann …",
  "length": 4477,
  "excerpt": "I found the place in the compiler’s source code where it applies a special attribute to DispatchQueue.main.async closures. Plus, a rant about how Xcode presents Swift concurrency context to the programmer.",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "You may have noticed that the Swift compiler automatically treats the closure of a DispatchQueue.main.async call as @MainActor. In other words, we can call a main-actor-isolated function in the closure: import Dispatch @MainActor func mainActorFunc() { } DispatchQueue.main.async { // The compiler lets us call this because // it knows we're on the main actor. mainActorFunc() } This behavior is welcome and very convenient, but it bugs me that it’s so hidden. As far as I know it isn’t documented, and neither Xcode nor any other editor/IDE I’ve used do a good job of showing me the actor context a function or closure will run in, even though the compiler has this information. I’ve written about a similar case before in Where View.task gets its main-actor isolation from, where Swift/Xcode hide essential information from the programmer by not showing certain attributes in declarations or the documentation. It’s a syntax check So how is the magic behavior for DispatchQueue.main.async implemented? It can’t be an attribute or other annotation on the closure parameter of the DispatchQueue.async method because the actual queue instance isn’t known at that point. A bit of experimentation reveals that it is in fact a relatively coarse source-code-based check that singles out invocations on DispatchQueue.main, in exactly that spelling. For example, the following variations do produce warnings/errors (in Swift 5.10/6.0, respectively), even though they are just as safe as the previous code snippet. This is because we aren’t using the “correct” DispatchQueue.main.async spelling: let queue = DispatchQueue.main queue.async { // Error: Call to main actor-isolated global function // 'mainActorFunc()' in a synchronous nonisolated context mainActorFunc() // ❌ } typealias DP = DispatchQueue DP.main.async { // Error: Call to main actor-isolated global function // 'mainActorFunc()' in a synchronous nonisolated context mainActorFunc() // ❌ } I found the place in the Swift compiler source code where the check happens. In the compiler’s semantic analysis stage (called “Sema”; this is the phase right after parsing), the type checker calls a function named adjustFunctionTypeForConcurrency, passing in a Boolean it obtained from isMainDispatchQueueMember, which returns true if the source code literally references DispatchQueue.main. In that case, the type checker adds the @_unsafeMainActor attribute to the function type. Good to know. Fun fact: since this is a purely syntax-based check, if you define your own type named DispatchQueue, give it a static main property and a function named async that takes a closure, the compiler will apply the same “fix” to it. This is NOT recommended: // Define our own `DispatchQueue.main.async` struct DispatchQueue { static let main: Self = .init() func async(_ work: @escaping () -\u003e Void) {} } // This calls our DispatchQueue.main.async { // No error! Compiler has inserted `@_unsafeMainActor` mainActorFunc() } Perplexity through obscurity I love that this automatic @MainActor inference for DispatchQueue.main exists. I do not love that it’s another piece of hidden, implicit behavior that makes Swift concurrency harder to learn. I want to see all the @_unsafeMainActor and @_unsafeInheritExecutor and @_inheritActorContext annotations! I believe Apple is doing the community a disservice by hiding these in Xcode. The biggest benefit of Swift’s concurrency model over what we had before is that so many things are statically known at compile time. It’s a shame that the compiler knows on which executor a particular line of code will run, but none of the tools seem to be able to show me this. Instead, I’m forced to hunt for @MainActor annotations and hidden attributes in superclasses, protocols, etc. This feels especially problematic during the Swift 5-to-6 transition phase we’re currently in where it’s so easy to misuse concurrency and not get a compiler error (and sometimes not even a warning if you forget to enable strict concurrency checking). The most impactful change Apple can make to make Swift concurrency less confusing is to show the inferred executor context for each line of code in Xcode. Make it really obvious what code runs on the main actor, some other actor, or the global cooperative pool. Use colors or whatnot! (Other Swift IDEs should do this too, of course. I’m just picking on Xcode because Apple has the most leverage.)",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003eYou may have noticed that the Swift compiler automatically treats the closure of a \u003ccode\u003eDispatchQueue.main.async\u003c/code\u003e call as \u003ca href=\"https://developer.apple.com/documentation/swift/mainactor\"\u003e\u003ccode\u003e@MainActor\u003c/code\u003e\u003c/a\u003e. In other words, we can call a main-actor-isolated function in the closure:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eDispatch\u003c/span\u003e\n\n\u003cspan\u003e@MainActor\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003emainActorFunc\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003eDispatchQueue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e// The compiler lets us call this because\u003c/span\u003e\n    \u003cspan\u003e// it knows we\u0026#39;re on the main actor.\u003c/span\u003e\n    \u003cspan\u003emainActorFunc\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis behavior is welcome and very convenient, but it bugs me that it’s so hidden. As far as I know it isn’t documented, and neither Xcode nor any other editor/IDE I’ve used do a good job of showing me the actor context a function or closure will run in, even though the compiler has this information. I’ve written about a similar case before in \u003ca href=\"https://oleb.net/2022/swiftui-task-mainactor/\"\u003e\u003cem\u003eWhere \u003ccode\u003eView.task\u003c/code\u003e gets its main-actor isolation from\u003c/em\u003e\u003c/a\u003e, where Swift/Xcode hide essential information from the programmer by not showing certain attributes in declarations or the documentation.\u003c/p\u003e\n\n\u003ch2 id=\"its-a-syntax-check\"\u003eIt’s a syntax check\u003c/h2\u003e\n\n\u003cp\u003eSo how is the magic behavior for \u003ccode\u003eDispatchQueue.main.async\u003c/code\u003e implemented? It can’t be an attribute or other annotation on the closure parameter of the \u003ca href=\"https://developer.apple.com/documentation/dispatch/dispatchqueue/2016098-async\"\u003e\u003ccode\u003eDispatchQueue.async\u003c/code\u003e\u003c/a\u003e method because the actual queue instance isn’t known at that point.\u003c/p\u003e\n\n\u003cp\u003eA bit of experimentation reveals that it is in fact a relatively coarse source-code-based check that singles out invocations on \u003ccode\u003eDispatchQueue.main\u003c/code\u003e, \u003cem\u003ein exactly that spelling\u003c/em\u003e. For example, the following variations do produce warnings/errors (in Swift 5.10/6.0, respectively), even though they are just as safe as the previous code snippet. This is because we aren’t using the “correct” \u003ccode\u003eDispatchQueue.main.async\u003c/code\u003e spelling:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003equeue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eDispatchQueue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emain\u003c/span\u003e\n\u003cspan\u003equeue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e// Error: Call to main actor-isolated global function\u003c/span\u003e\n    \u003cspan\u003e// \u0026#39;mainActorFunc()\u0026#39; in a synchronous nonisolated context\u003c/span\u003e\n    \u003cspan\u003emainActorFunc\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e// ❌\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003etypealias\u003c/span\u003e \u003cspan\u003eDP\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eDispatchQueue\u003c/span\u003e\n\u003cspan\u003eDP\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e// Error: Call to main actor-isolated global function\u003c/span\u003e\n    \u003cspan\u003e// \u0026#39;mainActorFunc()\u0026#39; in a synchronous nonisolated context\u003c/span\u003e\n    \u003cspan\u003emainActorFunc\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e// ❌\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eI found the place in the Swift compiler source code where the check happens. In the compiler’s semantic analysis stage (called “Sema”; this is the phase right after parsing), the type checker \u003ca href=\"https://github.com/apple/swift/blob/8d5cd5a47d6a01e9d65865482eb2984a2defac6f/lib/Sema/ConstraintSystem.cpp#L2615-L2617\"\u003ecalls a function named \u003ccode\u003eadjustFunctionTypeForConcurrency\u003c/code\u003e\u003c/a\u003e, passing in a Boolean it obtained from \u003ca href=\"https://github.com/apple/swift/blob/8d5cd5a47d6a01e9d65865482eb2984a2defac6f/lib/Sema/ConstraintSystem.cpp#L2023-L2025\"\u003e\u003ccode\u003eisMainDispatchQueueMember\u003c/code\u003e\u003c/a\u003e, which returns \u003ccode\u003etrue\u003c/code\u003e if the source code literally references \u003ccode\u003eDispatchQueue.main\u003c/code\u003e. In that case, the type checker \u003ca href=\"https://github.com/apple/swift/blob/8d5cd5a47d6a01e9d65865482eb2984a2defac6f/lib/Sema/TypeCheckConcurrency.cpp#L5594-L5600\"\u003eadds\u003c/a\u003e the \u003ca href=\"https://github.com/apple/swift/blob/main/docs/ReferenceGuides/UnderscoredAttributes.md#_unsafemainactor-_unsafesendable\"\u003e\u003ccode\u003e@_unsafeMainActor\u003c/code\u003e\u003c/a\u003e attribute to the function type. Good to know.\u003c/p\u003e\n\n\u003cp\u003eFun fact: since this is a purely syntax-based check, if you define your own type named \u003ccode\u003eDispatchQueue\u003c/code\u003e, give it a static \u003ccode\u003emain\u003c/code\u003e property and a function named \u003ccode\u003easync\u003c/code\u003e that takes a closure, the compiler will apply the same “fix” to it. This is NOT recommended:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Define our own `DispatchQueue.main.async`\u003c/span\u003e\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eDispatchQueue\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSelf\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ework\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e@escaping\u003c/span\u003e \u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eVoid\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003e// This calls our \u003c/span\u003e\n\u003cspan\u003eDispatchQueue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e// No error! Compiler has inserted `@_unsafeMainActor`\u003c/span\u003e\n    \u003cspan\u003emainActorFunc\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"perplexity-through-obscurity\"\u003ePerplexity through obscurity\u003c/h2\u003e\n\n\u003cp\u003eI love that this automatic \u003ccode\u003e@MainActor\u003c/code\u003e inference for \u003ccode\u003eDispatchQueue.main\u003c/code\u003e exists. I do \u003cem\u003enot\u003c/em\u003e love that it’s another piece of hidden, implicit behavior that makes Swift concurrency harder to learn. I want to see all the \u003ccode\u003e@_unsafeMainActor\u003c/code\u003e and \u003ca href=\"https://github.com/apple/swift/blob/main/docs/ReferenceGuides/UnderscoredAttributes.md#_unsafeinheritexecutor\"\u003e\u003ccode\u003e@_unsafeInheritExecutor\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://github.com/apple/swift/blob/main/docs/ReferenceGuides/UnderscoredAttributes.md#_inheritactorcontext\"\u003e\u003ccode\u003e@_inheritActorContext\u003c/code\u003e\u003c/a\u003e annotations! I believe Apple is doing the community a disservice by hiding these in Xcode.\u003c/p\u003e\n\n\u003cp\u003eThe biggest benefit of Swift’s concurrency model over what we had before is that so many things are statically known at compile time. It’s a shame that the compiler \u003cem\u003eknows\u003c/em\u003e on which executor a particular line of code will run, but none of the tools seem to be able to show me this. Instead, I’m forced to hunt for \u003ccode\u003e@MainActor\u003c/code\u003e annotations and hidden attributes in superclasses, protocols, etc. This feels especially problematic during the Swift 5-to-6 transition phase we’re currently in where it’s so easy to misuse concurrency and \u003cem\u003enot\u003c/em\u003e get a compiler error (and sometimes not even a warning if you forget to enable strict concurrency checking).\u003c/p\u003e\n\n\u003cp\u003eThe most impactful change Apple can make to make Swift concurrency less confusing is to show the inferred executor context for \u003cem\u003eeach line of code\u003c/em\u003e in Xcode. Make it \u003cem\u003ereally\u003c/em\u003e obvious what code runs on the main actor, some other actor, or the global cooperative pool. Use colors or whatnot! (Other Swift IDEs should do this too, of course. I’m just picking on Xcode because Apple has the most leverage.)\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-02-29T18:54:47Z",
  "modifiedTime": "2024-04-09T16:07:39Z"
}
