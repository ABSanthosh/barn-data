{
  "id": "e475a6cc-5974-4908-a8ab-48163c0bab7c",
  "title": "What’s new in Git 2.50.0?",
  "link": "https://about.gitlab.com/blog/what-s-new-in-git-2-50-0/",
  "description": "",
  "author": "Justin Tobler",
  "published": "2025-06-16T00:00:00.000Z",
  "source": "https://about.gitlab.com/atom.xml",
  "categories": null,
  "byline": "Justin Tobler",
  "length": 16174,
  "excerpt": "Here are contributions from GitLab's Git team and the Git community such as the git-diff-pairs(1) command and git-rev-list(1) option to perform batched reference updates.",
  "siteName": "GitLab",
  "favicon": "https://about.gitlab.com/images/ico/favicon-192x192.png",
  "text": "The Git project recently released Git Version 2.50.0. Let's look at a few notable highlights from this release, which includes contributions from the Git team at GitLab and also the wider Git community. New git-diff-pairs(1) command Diffs are at the heart of every code review and show all the changes made between two revisions. GitLab shows diffs in various places, but the most common place is a merge request's \"Changes\" tab. Behind the scenes, diff generation is powered by git-diff(1). For example: $ git diff HEAD~1 HEAD This command returns the full diff for all changed files. This might pose a scalability challenge because the number of files changed between a set of revisions could be very large and cause the command to reach self-imposed timeouts for the GitLab backend. For large change sets, it would be better if there were a way to break diff computation into smaller, more digestible chunks. One way this can be achieved is by using git-diff-tree(1) to retrieve info about all the changed files: $ git diff-tree -r -M --abbrev HEAD~ HEAD :100644 100644 c9adfed339 99acf81487 M Documentation/RelNotes/2.50.0.adoc :100755 100755 1047b8d11d 208e91a17f M GIT-VERSION-GEN Git refers to this output as the \"raw\" format. In short, each line of output lists filepairs and the accompanying metadata about what has changed between the start and end revisions. Compared to generating the \"patch\" output for large changes, this process is relatively quick and provides a summary of everything that changed. This command can optionally perform rename detection by appending the -M flag to check if identified changes were due to a file rename. With this information, we could use git-diff(1) to compute each of the filepair diffs individually. For example, we can provide the blob IDs directly: $ git diff 1047b8d11de767d290170979a9a20de1f5692e26 208e91a17f04558ca66bc19d73457ca64d5385f We can repeat this process for each of the filepairs, but spinning up a separate Git process for each individual file diff is not very efficient. Furthermore, when using blob IDs, the diff loses some contextual information such as the change status, and file modes which are stored in with the parent tree object. What we really want is a mechanism to feed \"raw\" filepair info and generate the corresponding patch output. With the 2.50 release, Git has a new built-in command named git-diff-pairs(1). This command accepts \"raw\" formatted filepair info as input on stdin to determine exactly which patches to output. The following example showcases how this command could be used: $ git diff-tree -r -z -M HEAD~ HEAD | git diff-pairs -z When used in this manner, the resulting output is identical to using git-diff(1). By having a separate command to generate patch output, the \"raw\" output from git-diff-tree(1) can be broken up into smaller batches of filepairs and fed to separate git-diff-pairs(1) processes. This solves the previously mentioned scalability concern because diffs no longer have to be computed all at once. Future GitLab releases could build upon this mechanism to improve diff generation performance, especially in cases where large change sets are concerned. For more information on this change, check out the corresponding mailing-list thread. This project was led by Justin Tobler. Batched reference updates Git provides the git-update-ref(1) command to perform reference updates. When used with the --stdin flag, multiple reference updates can be batched together in a single transaction by specifying instructions for each reference update to be performed on stdin. Bulk updating references in this manner also provides atomic behavior whereby a single reference update failure results in an aborted transaction and no references being updated. Here is an example showcasing this behavior: # Create repository with three empty commits and branch named \"foo\" $ git init $ git commit --allow-empty -m 1 $ git commit --allow-empty -m 2 $ git commit --allow-empty -m 3 $ git branch foo # Print out the commit IDs $ git rev-list HEAD cf469bdf5436ea1ded57670b5f5a0797f72f1afc 5a74cd330f04b96ce0666af89682d4d7580c354c 5a6b339a8ebffde8c0590553045403dbda831518 # Attempt to create a new reference and update existing reference in transaction. # Update is expected to fail because the specified old object ID doesn’t match. $ git update-ref --stdin \u003c\u003cEOF \u003e create refs/heads/bar cf469bdf5436ea1ded57670b5f5a0797f72f1afc \u003e update refs/heads/foo 5a6b339a8ebffde8c0590553045403dbda831518 5a74cd330f04b96ce0666af89682d4d7580c354c \u003e EOF fatal: cannot lock ref 'refs/heads/foo': is at cf469bdf5436ea1ded57670b5f5a0797f72f1afc but expected 5a74cd330f04b96ce0666af89682d4d7580c354c # The \"bar\" reference was not created. $ git switch bar fatal: invalid reference: bar Compared to updating many references individually, updating in bulk is also much more efficient. While this works well, there might be certain circumstances where it is okay for a subset of the requested reference updates to fail, but we still want to take advantage of the efficiency gains of bulk updates. With this release, git-update-ref(1) has the new --batch-updates option, which allows the updates to proceed even when one or more reference updates fails. In this mode, individual failures are reported in the following format: rejected SP (\u003cold-oid\u003e | \u003cold-target\u003e) SP (\u003cnew-oid\u003e | \u003cnew-target\u003e) SP \u003crejection-reason\u003e LF This allows successful reference updates to proceed while providing context to which updates were rejected and for what reason. Using the same example repository from the previous example: # Attempt to create a new reference and update existing reference in transaction. $ git update-ref --stdin --batch-updates \u003c\u003cEOF \u003e create refs/heads/bar cf469bdf5436ea1ded57670b5f5a0797f72f1afc \u003e update refs/heads/foo 5a6b339a8ebffde8c0590553045403dbda831518 5a74cd330f04b96ce0666af89682d4d7580c354c \u003e EOF rejected refs/heads/foo 5a6b339a8ebffde8c0590553045403dbda831518 5a74cd330f04b96ce0666af89682d4d7580c354c incorrect old value provided # The \"bar\" reference was created even though the update to \"foo\" was rejected. $ git switch bar Switched to branch 'bar' This time, with the --batch-updates option, the reference creation succeeded even though the update didn't work. This patch series lays the groundwork for future performance improvements in git-fetch(1) and git-receive-pack(1) when references are updated in bulk. For more information, check the mailing-list thread This project was led by Karthik Nayak. New filter option for git-cat-file(1) With git-cat-file(1), it is possible to print info for all objects contained in the repository via the --batch–all-objects option. For example: # Setup simple repository. $ git init $ echo foo \u003efoo $ git add foo $ git commit -m init # Create an unreachable object. $ git commit --amend --no-edit # Use git-cat-file(1) to print info about all objects including unreachable objects. $ git cat-file --batch-all-objects --batch-check='%(objecttype) %(objectname)' commit 0b07e71d14897f218f23d9a6e39605b466454ece tree 205f6b799e7d5c2524468ca006a0131aa57ecce7 blob 257cc5642cb1a054f08cc83f2d943e56fd3ebe99 commit c999f781fd7214b3caab82f560ffd079ddad0115 In some situations, a user might want to search through all objects in the repository, but only output a subset based on some specified attribute. For example, if we wanted to see only the objects that are commits, we could use grep(1): $ git cat-file --batch-all-objects --batch-check='%(objecttype) %(objectname)' | grep ^commit commit 0b07e71d14897f218f23d9a6e39605b466454ece commit c999f781fd7214b3caab82f560ffd079ddad0115 While this works, one downside with filtering the output is that git-cat-file(1) still has to traverse all the objects in the repository, even the ones that the user is not interested in. This can be rather inefficient. With this release, git-cat-file(1) now has the --filter option, which only shows objects matching the specified criteria. This is similar to the option of the same name for git-rev-list(1), but with only a subset of the filters supported. The supported filters are blob:none, blob:limit=, as well as object:type=. Similar to the previous example, objects can be filtered by type with Git directly: $ git cat-file --batch-all-objects --batch-check='%(objecttype) %(objectname)' --filter='object:type=commit' commit 0b07e71d14897f218f23d9a6e39605b466454ece commit c999f781fd7214b3caab82f560ffd079ddad0115 Not only is it convenient for Git to handle the processing, for large repositories with many objects, it is also potentially more efficient. If a repository has bitmap indices, it becomes possible for Git to efficiently lookup objects of a specific type, and thus avoid scanning through the packfile, which leads to a significant speedup. Benchmarks conducted on the Chromium repository show significant improvements: Benchmark 1: git cat-file --batch-check --batch-all-objects --unordered --buffer --no-filter Time (mean ± σ): 82.806 s ± 6.363 s [User: 30.956 s, System: 8.264 s] Range (min … max): 73.936 s … 89.690 s 10 runs Benchmark 2: git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=tag Time (mean ± σ): 20.8 ms ± 1.3 ms [User: 6.1 ms, System: 14.5 ms] Range (min … max): 18.2 ms … 23.6 ms 127 runs Benchmark 3: git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=commit Time (mean ± σ): 1.551 s ± 0.008 s [User: 1.401 s, System: 0.147 s] Range (min … max): 1.541 s … 1.566 s 10 runs Benchmark 4: git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=tree Time (mean ± σ): 11.169 s ± 0.046 s [User: 10.076 s, System: 1.063 s] Range (min … max): 11.114 s … 11.245 s 10 runs Benchmark 5: git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=blob Time (mean ± σ): 67.342 s ± 3.368 s [User: 20.318 s, System: 7.787 s] Range (min … max): 62.836 s … 73.618 s 10 runs Benchmark 6: git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=blob:none Time (mean ± σ): 13.032 s ± 0.072 s [User: 11.638 s, System: 1.368 s] Range (min … max): 12.960 s … 13.199 s 10 runs Summary git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=tag 74.75 ± 4.61 times faster than git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=commit 538.17 ± 33.17 times faster than git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=tree 627.98 ± 38.77 times faster than git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=blob:none 3244.93 ± 257.23 times faster than git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=blob 3990.07 ± 392.72 times faster than git cat-file --batch-check --batch-all-objects --unordered --buffer --no-filter Interestingly, these results indicate that the computation time now scales with the number of objects for a given type instead of the number of total objects in the packfile. The original mailing-list thread can be found here. This project was led by Patrick Steinhardt. Improved performance when generating bundles Git provides a means to generate an archive of a repository which contains a specified set of references and accompanying reachable objects via the git-bundle(1) command. This operation is used by GitLab to generate repository backups and also as part of the bundle-URI mechanism. For large repositories containing millions of references, this operation can take hours or even days. For example, with the main GitLab repository (gitlab-org/gitlab), backup times were around 48 hours. Investigation revealed there was a performance bottleneck due to how Git was performing a check to avoid duplicated references being included in the bundle. The implementation used a nested for loop to iterate and compare all listed references, leading to O(N^2) time complexity. This scales very poorly as the number of references in a repository increases. In this release, this issue was addressed by replacing the nested loops with a map data structure leading to a significant speedup. The following benchmark the performance improvement for creating a bundle with a repository containing 100,000 references: Benchmark 1: bundle (refcount = 100000, revision = master) Time (mean ± σ): 14.653 s ± 0.203 s [User: 13.940 s, System: 0.762 s] Range (min … max): 14.237 s … 14.920 s 10 runs Benchmark 2: bundle (refcount = 100000, revision = HEAD) Time (mean ± σ): 2.394 s ± 0.023 s [User: 1.684 s, System: 0.798 s] Range (min … max): 2.364 s … 2.425 s 10 runs Summary bundle (refcount = 100000, revision = HEAD) ran 6.12 ± 0.10 times faster than bundle (refcount = 100000, revision = master) To learn more, check out our blog post How we decreased GitLab repo backup times from 48 hours to 41 minutes. You can also find the original mailing list thread here. This project was led by Karthik Nayak. Better bundle URI unbundling Through the bundle URI mechanism in Git, locations to fetch bundles from can be provided to clients with the goal to help speed up clones and fetches. When a client downloads a bundle, references under refs/heads/* are copied from the bundle into the repository along with their accompanying objects. A bundle might contain additional references outside of refs/heads/* such as refs/tags/*, which are simply ignored when using bundle URI on clone. In Git 2.50, this restriction is lifted, and all references matching refs/* contained in the downloaded bundle are copied. Scott Chacon, who contributed this functionality, demonstrates the difference when cloning gitlab-org/gitlab-foss: $ git-v2.49 clone --bundle-uri=gitlab-base.bundle https://gitlab.com/gitlab-org/gitlab-foss.git gl-2.49 Cloning into 'gl2.49'... remote: Enumerating objects: 1092703, done. remote: Counting objects: 100% (973405/973405), done. remote: Compressing objects: 100% (385827/385827), done. remote: Total 959773 (delta 710976), reused 766809 (delta 554276), pack-reused 0 (from 0) Receiving objects: 100% (959773/959773), 366.94 MiB | 20.87 MiB/s, done. Resolving deltas: 100% (710976/710976), completed with 9081 local objects. Checking objects: 100% (4194304/4194304), done. Checking connectivity: 959668, done. Updating files: 100% (59972/59972), done. $ git-v2.50 clone --bundle-uri=gitlab-base.bundle https://gitlab.com/gitlab-org/gitlab-foss.git gl-2.50 Cloning into 'gl-2.50'... remote: Enumerating objects: 65538, done. remote: Counting objects: 100% (56054/56054), done. remote: Compressing objects: 100% (28950/28950), done. remote: Total 43877 (delta 27401), reused 25170 (delta 13546), pack-reused 0 (from 0) Receiving objects: 100% (43877/43877), 40.42 MiB | 22.27 MiB/s, done. Resolving deltas: 100% (27401/27401), completed with 8564 local objects. Updating files: 100% (59972/59972), done. Comparing these results, we see that Git 2.50 fetches 43,887 objects (40.42 MiB) after the bundle was extracted whereas Git 2.49 fetches a total of 959,773 objects (366.94 MiB). Git 2.50 fetches roughly 95% fewer objects and 90% less data, which benefits both the client and the server. The server needs to process a lot less data to the client and the client needs to download and extract less data. In the example provided by Scott this led to a speedup of 25%. To learn more, check out the corresponding mailing-list thread. This patch series was contributed by Scott Chacon. Read more This article highlighted just a few of the contributions made by GitLab and the wider Git community for this latest release. You can learn about these from the official release announcement of the Git project. Also, check out our previous Git release blog posts to see other past highlights of contributions from GitLab team members.",
  "image": "https://about.gitlab.com/images/open-graph/open-graph-gitlab.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-v-d90b052d=\"\" data-v-3f3ac235=\"\" data-v-b7392a61=\"\"\u003e\u003cp\u003eThe Git project recently released \u003ca href=\"https://lore.kernel.org/git/xmqq1prj1umb.fsf@gitster.g/T/#u\"\u003eGit Version 2.50.0\u003c/a\u003e. Let\u0026#39;s look at a few notable highlights from this release, which includes contributions from the Git team at GitLab and also the wider Git community.\u003c/p\u003e\n\u003ch2 id=\"new-git-diff-pairs(1)-command\" tabindex=\"-1\"\u003e\u003ca href=\"#new-git-diff-pairs(1)-command\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e New git-diff-pairs(1) command\u003c/h2\u003e\n\u003cp\u003eDiffs are at the heart of every code review and show all the changes made\nbetween two revisions. GitLab shows diffs in various places, but the most\ncommon place is a merge request\u0026#39;s \u003ca href=\"https://docs.gitlab.com/user/project/merge_requests/changes/\"\u003e\u0026#34;Changes\u0026#34; tab\u003c/a\u003e.\nBehind the scenes, diff generation is powered by\n\u003ca href=\"https://git-scm.com/docs/git-diff\"\u003e\u003ccode\u003egit-diff(1)\u003c/code\u003e\u003c/a\u003e. For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git diff HEAD~1 HEAD\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis command returns the full diff for all changed files. This might pose a scalability challenge because the number of files changed between a set of revisions could be very large and cause the command to reach self-imposed timeouts for the GitLab backend. For large change sets, it would be better if\nthere were a way to break diff computation into smaller, more digestible chunks.\u003c/p\u003e\n\u003cp\u003eOne way this can be achieved is by using\n\u003ca href=\"https://git-scm.com/docs/git-diff-tree\"\u003e\u003ccode\u003egit-diff-tree(1)\u003c/code\u003e\u003c/a\u003e to retrieve info\nabout all the changed files:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git diff-tree -r -M --abbrev HEAD~ HEAD\n:100644 100644 c9adfed339 99acf81487 M      Documentation/RelNotes/2.50.0.adoc\n:100755 100755 1047b8d11d 208e91a17f M      GIT-VERSION-GEN\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGit refers to this output as the \u003ca href=\"https://git-scm.com/docs/git-diff-tree#_raw_output_format\"\u003e\u0026#34;raw\u0026#34; format\u003c/a\u003e.\nIn short, each line of output lists filepairs and the accompanying metadata\nabout what has changed between the start and end revisions. Compared to\ngenerating the \u0026#34;patch\u0026#34; output for large changes, this process is relatively\nquick and provides a summary of everything that changed. This command can optionally perform rename detection by  appending the \u003ccode\u003e-M\u003c/code\u003e flag to check if identified changes were due to a file rename.\u003c/p\u003e\n\u003cp\u003eWith this information, we could use \u003ccode\u003egit-diff(1)\u003c/code\u003e to compute each of the\nfilepair diffs individually. For example, we can provide the blob IDs\ndirectly:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git diff 1047b8d11de767d290170979a9a20de1f5692e26 208e91a17f04558ca66bc19d73457ca64d5385f\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can repeat this process for each of the filepairs, but spinning up a\nseparate Git process for each individual file diff is not very efficient.\nFurthermore, when using blob IDs, the diff loses some contextual information\nsuch as the change status, and file modes which are stored in with the parent\ntree object. What we really want is a mechanism to feed \u0026#34;raw\u0026#34; filepair info and\ngenerate the corresponding patch output.\u003c/p\u003e\n\u003cp\u003eWith the 2.50 release, Git has a new built-in command named\n\u003ca href=\"https://git-scm.com/docs/git-diff-pairs\"\u003e\u003ccode\u003egit-diff-pairs(1)\u003c/code\u003e\u003c/a\u003e. This command\naccepts \u0026#34;raw\u0026#34; formatted filepair info as input on stdin to determine exactly which patches to output. The following example showcases how this command could be\nused:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git diff-tree -r -z -M HEAD~ HEAD | git diff-pairs -z\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen used in this manner, the resulting output is identical to using \u003ccode\u003egit-diff(1)\u003c/code\u003e.\nBy having a separate command to generate patch output, the \u0026#34;raw\u0026#34; output from\n\u003ccode\u003egit-diff-tree(1)\u003c/code\u003e can be broken up into smaller batches of filepairs and fed to separate\n\u003ccode\u003egit-diff-pairs(1)\u003c/code\u003e processes. This solves the previously mentioned scalability\nconcern because diffs no longer have to be computed all at once. Future GitLab\nreleases could build upon this mechanism to improve diff\ngeneration performance, especially in cases where large change sets are\nconcerned. For more information on this change, check out the corresponding\n\u003ca href=\"https://lore.kernel.org/git/20250228213346.1335224-1-jltobler@gmail.com/\"\u003emailing-list thread\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThis project was led by \u003ca href=\"https://gitlab.com/justintobler\"\u003eJustin Tobler\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"batched-reference-updates\" tabindex=\"-1\"\u003e\u003ca href=\"#batched-reference-updates\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e Batched reference updates\u003c/h2\u003e\n\u003cp\u003eGit provides the \u003ca href=\"https://git-scm.com/docs/git-update-ref\"\u003e\u003ccode\u003egit-update-ref(1)\u003c/code\u003e\u003c/a\u003e\ncommand to perform reference updates. When used with the \u003ccode\u003e--stdin\u003c/code\u003e flag,\nmultiple reference updates can be batched together in a single transaction by\nspecifying instructions for each reference update to be performed on stdin.\nBulk updating references in this manner also provides atomic behavior whereby a\nsingle reference update failure results in an aborted transaction and no\nreferences being updated. Here is an example showcasing this behavior:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Create repository with three empty commits and branch named \u0026#34;foo\u0026#34;\n$ git init\n$ git commit --allow-empty -m 1\n$ git commit --allow-empty -m 2\n$ git commit --allow-empty -m 3\n$ git branch foo\n\n# Print out the commit IDs\n$ git rev-list HEAD\ncf469bdf5436ea1ded57670b5f5a0797f72f1afc\n5a74cd330f04b96ce0666af89682d4d7580c354c\n5a6b339a8ebffde8c0590553045403dbda831518\n\n# Attempt to create a new reference and update existing reference in transaction.\n# Update is expected to fail because the specified old object ID doesn’t match.\n$ git update-ref --stdin \u0026lt;\u0026lt;EOF\n\u0026gt; create refs/heads/bar cf469bdf5436ea1ded57670b5f5a0797f72f1afc\n\u0026gt; update refs/heads/foo 5a6b339a8ebffde8c0590553045403dbda831518 5a74cd330f04b96ce0666af89682d4d7580c354c\n\u0026gt; EOF\nfatal: cannot lock ref \u0026#39;refs/heads/foo\u0026#39;: is at cf469bdf5436ea1ded57670b5f5a0797f72f1afc but expected 5a74cd330f04b96ce0666af89682d4d7580c354c\n\n# The \u0026#34;bar\u0026#34; reference was not created.\n$ git switch bar\nfatal: invalid reference: bar\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCompared to updating many references individually, updating in bulk is also\nmuch more efficient. While this works well, there might be certain\ncircumstances where it is okay for a subset of the requested reference updates\nto fail, but we still want to take advantage of the efficiency gains of bulk\nupdates.\u003c/p\u003e\n\u003cp\u003eWith this release, \u003ccode\u003egit-update-ref(1)\u003c/code\u003e has the new \u003ccode\u003e--batch-updates\u003c/code\u003e option,\nwhich allows the updates to proceed even when one or more reference updates\nfails. In this mode, individual failures are reported in the following format:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003erejected SP (\u0026lt;old-oid\u0026gt; | \u0026lt;old-target\u0026gt;) SP (\u0026lt;new-oid\u0026gt; | \u0026lt;new-target\u0026gt;) SP \u0026lt;rejection-reason\u0026gt; LF\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis allows successful reference updates to proceed while providing context to\nwhich updates were rejected and for what reason. Using the same example\nrepository from the previous example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Attempt to create a new reference and update existing reference in transaction.\n$ git update-ref --stdin --batch-updates \u0026lt;\u0026lt;EOF\n\u0026gt; create refs/heads/bar cf469bdf5436ea1ded57670b5f5a0797f72f1afc\n\u0026gt; update refs/heads/foo 5a6b339a8ebffde8c0590553045403dbda831518 5a74cd330f04b96ce0666af89682d4d7580c354c\n\u0026gt; EOF\nrejected refs/heads/foo 5a6b339a8ebffde8c0590553045403dbda831518 5a74cd330f04b96ce0666af89682d4d7580c354c incorrect old value provided\n\n# The \u0026#34;bar\u0026#34; reference was created even though the update to \u0026#34;foo\u0026#34; was rejected.\n$ git switch bar\nSwitched to branch \u0026#39;bar\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis time, with the \u003ccode\u003e--batch-updates\u003c/code\u003e option, the reference creation succeeded\neven though the update didn\u0026#39;t work. This patch series lays the groundwork for\nfuture performance improvements in \u003ccode\u003egit-fetch(1)\u003c/code\u003e and \u003ccode\u003egit-receive-pack(1)\u003c/code\u003e\nwhen references are updated in bulk. For more information, check the\n\u003ca href=\"https://lore.kernel.org/git/20250408085120.614893-1-karthik.188@gmail.com/\"\u003emailing-list thread\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThis project was led by \u003ca href=\"https://gitlab.com/knayakgl\"\u003eKarthik Nayak\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"new-filter-option-for-git-cat-file(1)\" tabindex=\"-1\"\u003e\u003ca href=\"#new-filter-option-for-git-cat-file(1)\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e New filter option for git-cat-file(1)\u003c/h2\u003e\n\u003cp\u003eWith \u003ca href=\"https://git-scm.com/docs/git-cat-file\"\u003e\u003ccode\u003egit-cat-file(1)\u003c/code\u003e\u003c/a\u003e, it is possible\nto print info for all objects contained in the repository via the\n\u003ccode\u003e--batch–all-objects\u003c/code\u003e option. For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Setup simple repository.\n$ git init\n$ echo foo \u0026gt;foo\n$ git add foo\n$ git commit -m init\n\n# Create an unreachable object.\n$ git commit --amend --no-edit\n\n# Use git-cat-file(1) to print info about all objects including unreachable objects.\n$ git cat-file --batch-all-objects --batch-check=\u0026#39;%(objecttype) %(objectname)\u0026#39;\ncommit 0b07e71d14897f218f23d9a6e39605b466454ece\ntree 205f6b799e7d5c2524468ca006a0131aa57ecce7\nblob 257cc5642cb1a054f08cc83f2d943e56fd3ebe99\ncommit c999f781fd7214b3caab82f560ffd079ddad0115\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn some situations, a user might want to search through all objects in the\nrepository, but only output a subset based on some specified attribute. For\nexample, if we wanted to see only the objects that are commits, we could use\n\u003ccode\u003egrep(1)\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git cat-file --batch-all-objects --batch-check=\u0026#39;%(objecttype) %(objectname)\u0026#39; | grep ^commit\ncommit 0b07e71d14897f218f23d9a6e39605b466454ece\ncommit c999f781fd7214b3caab82f560ffd079ddad0115\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhile this works, one downside with filtering the output is that\n\u003ccode\u003egit-cat-file(1)\u003c/code\u003e still has to traverse all the objects in the repository, even\nthe ones that the user is not interested in. This can be rather inefficient.\u003c/p\u003e\n\u003cp\u003eWith this release, \u003ccode\u003egit-cat-file(1)\u003c/code\u003e now has the \u003ccode\u003e--filter\u003c/code\u003e option, which only\nshows objects matching the specified criteria. This is similar to the option of\nthe same name for \u003ccode\u003egit-rev-list(1)\u003c/code\u003e, but with only a subset of the filters\nsupported. The supported filters are \u003ccode\u003eblob:none\u003c/code\u003e, \u003ccode\u003eblob:limit=\u003c/code\u003e, as well as\n\u003ccode\u003eobject:type=\u003c/code\u003e. Similar to the previous example, objects can be filtered by\ntype with Git directly:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git cat-file --batch-all-objects --batch-check=\u0026#39;%(objecttype) %(objectname)\u0026#39; --filter=\u0026#39;object:type=commit\u0026#39;\ncommit 0b07e71d14897f218f23d9a6e39605b466454ece\ncommit c999f781fd7214b3caab82f560ffd079ddad0115\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNot only is it convenient for Git to handle the processing, for large\nrepositories with many objects, it is also potentially more efficient. If a\nrepository has bitmap indices, it becomes possible for Git to efficiently\nlookup objects of a specific type, and thus avoid scanning through the\npackfile, which leads to a significant speedup. Benchmarks conducted on the\n\u003ca href=\"https://github.com/chromium/chromium.git\"\u003eChromium repository\u003c/a\u003e show\nsignificant improvements:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBenchmark 1: git cat-file --batch-check --batch-all-objects --unordered --buffer --no-filter\n   Time (mean ± σ):     82.806 s ±  6.363 s    [User: 30.956 s, System: 8.264 s]\n   Range (min … max):   73.936 s … 89.690 s    10 runs\n\nBenchmark 2: git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=tag\n   Time (mean ± σ):      20.8 ms ±   1.3 ms    [User: 6.1 ms, System: 14.5 ms]\n   Range (min … max):    18.2 ms …  23.6 ms    127 runs\n\nBenchmark 3: git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=commit\n   Time (mean ± σ):      1.551 s ±  0.008 s    [User: 1.401 s, System: 0.147 s]\n   Range (min … max):    1.541 s …  1.566 s    10 runs\n\nBenchmark 4: git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=tree\n   Time (mean ± σ):     11.169 s ±  0.046 s    [User: 10.076 s, System: 1.063 s]\n   Range (min … max):   11.114 s … 11.245 s    10 runs\n\nBenchmark 5: git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=blob\n   Time (mean ± σ):     67.342 s ±  3.368 s    [User: 20.318 s, System: 7.787 s]\n   Range (min … max):   62.836 s … 73.618 s    10 runs\n\nBenchmark 6: git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=blob:none\n   Time (mean ± σ):     13.032 s ±  0.072 s    [User: 11.638 s, System: 1.368 s]\n   Range (min … max):   12.960 s … 13.199 s    10 runs\n\nSummary\n   git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=tag\n    74.75 ± 4.61 times faster than git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=commit\n   538.17 ± 33.17 times faster than git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=tree\n   627.98 ± 38.77 times faster than git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=blob:none\n  3244.93 ± 257.23 times faster than git cat-file --batch-check --batch-all-objects --unordered --buffer --filter=object:type=blob\n  3990.07 ± 392.72 times faster than git cat-file --batch-check --batch-all-objects --unordered --buffer --no-filter\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eInterestingly, these results indicate that the computation time now scales with\nthe number of objects for a given type instead of the number of total objects\nin the packfile. The original mailing-list thread can be found\n\u003ca href=\"https://lore.kernel.org/git/20250221-pks-cat-file-object-type-filter-v1-0-0852530888e2@pks.im/\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThis project was led by \u003ca href=\"https://gitlab.com/pks-gitlab\"\u003ePatrick Steinhardt\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"improved-performance-when-generating-bundles\" tabindex=\"-1\"\u003e\u003ca href=\"#improved-performance-when-generating-bundles\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e Improved performance when generating bundles\u003c/h2\u003e\n\u003cp\u003eGit provides a means to generate an archive of a repository which contains a\nspecified set of references and accompanying reachable objects via the\n\u003ca href=\"https://git-scm.com/docs/git-bundle\"\u003e\u003ccode\u003egit-bundle(1)\u003c/code\u003e\u003c/a\u003e command. This operation\nis used by GitLab to generate repository backups and also as part of the\n\u003ca href=\"https://git-scm.com/docs/bundle-uri\"\u003ebundle-URI\u003c/a\u003e mechanism.\u003c/p\u003e\n\u003cp\u003eFor large repositories containing millions of references, this operation can\ntake hours or even days. For example, with the main GitLab repository\n(\u003ca href=\"https://gitlab.com/gitlab-org/gitlab\"\u003egitlab-org/gitlab\u003c/a\u003e), backup times were\naround 48 hours. Investigation revealed there was a performance bottleneck due\nto how Git was performing a check to avoid duplicated references being included\nin the bundle. The implementation used a nested \u003ccode\u003efor\u003c/code\u003e loop to iterate and\ncompare all listed references, leading to O(N^2) time complexity. This scales\nvery poorly as the number of references in a repository increases.\u003c/p\u003e\n\u003cp\u003eIn this release, this issue was addressed by replacing the nested loops with a\nmap data structure leading to a significant speedup. The following benchmark\nthe performance improvement for creating a bundle with a repository containing\n100,000 references:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBenchmark 1: bundle (refcount = 100000, revision = master)\n  Time (mean ± σ):     14.653 s ±  0.203 s    [User: 13.940 s, System: 0.762 s]\n  Range (min … max):   14.237 s … 14.920 s    10 runs\n\nBenchmark 2: bundle (refcount = 100000, revision = HEAD)\n  Time (mean ± σ):      2.394 s ±  0.023 s    [User: 1.684 s, System: 0.798 s]\n  Range (min … max):    2.364 s …  2.425 s    10 runs\n\nSummary\n  bundle (refcount = 100000, revision = HEAD) ran\n    6.12 ± 0.10 times faster than bundle (refcount = 100000, revision = master)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo learn more, check out our blog post\n\u003ca href=\"https://about.gitlab.com/blog/how-we-decreased-gitlab-repo-backup-times-from-48-hours-to-41-minutes/\"\u003eHow we decreased GitLab repo backup times from 48 hours to 41 minutes\u003c/a\u003e.\nYou can also find the original mailing list thread\n\u003ca href=\"https://lore.kernel.org/git/20250401-488-generating-bundles-with-many-references-has-non-linear-performance-v1-0-6d23b2d96557@gmail.com/\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThis project was led by \u003ca href=\"https://gitlab.com/knayakgl\"\u003eKarthik Nayak\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"better-bundle-uri-unbundling\" tabindex=\"-1\"\u003e\u003ca href=\"#better-bundle-uri-unbundling\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e Better bundle URI unbundling\u003c/h2\u003e\n\u003cp\u003eThrough the \u003ca href=\"https://git-scm.com/docs/bundle-uri\"\u003ebundle URI\u003c/a\u003e mechanism in Git,\nlocations to fetch bundles from can be provided to clients with the goal to\nhelp speed up clones and fetches. When a client downloads a bundle, references\nunder \u003ccode\u003erefs/heads/*\u003c/code\u003e are copied from the bundle into the repository along with\ntheir accompanying objects. A bundle might contain additional references\noutside of \u003ccode\u003erefs/heads/*\u003c/code\u003e such as \u003ccode\u003erefs/tags/*\u003c/code\u003e, which are simply ignored when\nusing bundle URI on clone.\u003c/p\u003e\n\u003cp\u003eIn Git 2.50, this restriction is lifted, and all references\nmatching \u003ccode\u003erefs/*\u003c/code\u003e contained in the downloaded bundle are copied.\n\u003ca href=\"https://github.com/schacon\"\u003eScott Chacon\u003c/a\u003e, who contributed this functionality,\ndemonstrates the difference when cloning\n\u003ca href=\"https://gitlab.com/gitlab-org/gitlab-foss\"\u003egitlab-org/gitlab-foss\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git-v2.49 clone --bundle-uri=gitlab-base.bundle https://gitlab.com/gitlab-org/gitlab-foss.git gl-2.49\nCloning into \u0026#39;gl2.49\u0026#39;...\nremote: Enumerating objects: 1092703, done.\nremote: Counting objects: 100% (973405/973405), done.\nremote: Compressing objects: 100% (385827/385827), done.\nremote: Total 959773 (delta 710976), reused 766809 (delta 554276), pack-reused 0 (from 0)\nReceiving objects: 100% (959773/959773), 366.94 MiB | 20.87 MiB/s, done.\nResolving deltas: 100% (710976/710976), completed with 9081 local objects.\nChecking objects: 100% (4194304/4194304), done.\nChecking connectivity: 959668, done.\nUpdating files: 100% (59972/59972), done.\n\n$ git-v2.50 clone --bundle-uri=gitlab-base.bundle https://gitlab.com/gitlab-org/gitlab-foss.git gl-2.50\nCloning into \u0026#39;gl-2.50\u0026#39;...\nremote: Enumerating objects: 65538, done.\nremote: Counting objects: 100% (56054/56054), done.\nremote: Compressing objects: 100% (28950/28950), done.\nremote: Total 43877 (delta 27401), reused 25170 (delta 13546), pack-reused 0 (from 0)\nReceiving objects: 100% (43877/43877), 40.42 MiB | 22.27 MiB/s, done.\nResolving deltas: 100% (27401/27401), completed with 8564 local objects.\nUpdating files: 100% (59972/59972), done.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eComparing these results, we see that Git 2.50 fetches 43,887 objects\n(40.42 MiB) after the bundle was extracted whereas Git 2.49 fetches a\ntotal of 959,773 objects (366.94 MiB). Git 2.50 fetches roughly 95% fewer\nobjects and 90% less data, which benefits both the client and the server. The\nserver needs to process a lot less data to the client and the client needs to\ndownload and extract less data. In the example provided by Scott this led to a\nspeedup of 25%.\u003c/p\u003e\n\u003cp\u003eTo learn more, check out the corresponding\n\u003ca href=\"https://lore.kernel.org/git/pull.1897.git.git.1740489585344.gitgitgadget@gmail.com/\"\u003emailing-list thread\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThis patch series was contributed by \u003ca href=\"https://github.com/schacon\"\u003eScott Chacon\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"read-more\" tabindex=\"-1\"\u003e\u003ca href=\"#read-more\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e Read more\u003c/h2\u003e\n\u003cp\u003eThis article highlighted just a few of the contributions made by GitLab and\nthe wider Git community for this latest release. You can learn about these from\nthe \u003ca href=\"https://lore.kernel.org/git/xmqq1prj1umb.fsf@gitster.g/\"\u003eofficial release announcement\u003c/a\u003e of the Git project. Also, check\nout our \u003ca href=\"https://about.gitlab.com/blog/tags/git/\"\u003eprevious Git release blog posts\u003c/a\u003e\nto see other past highlights of contributions from GitLab team members.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2025-06-16T00:00:00Z",
  "modifiedTime": null
}
