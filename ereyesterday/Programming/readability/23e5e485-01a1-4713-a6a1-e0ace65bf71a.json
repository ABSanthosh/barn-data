{
  "id": "23e5e485-01a1-4713-a6a1-e0ace65bf71a",
  "title": "Highlights from Git 2.50",
  "link": "https://github.blog/open-source/git/highlights-from-git-2-50/",
  "description": "The open source Git project just released Git 2.50. Here is GitHub‚Äôs look at some of the most interesting features and changes introduced since last time. The post Highlights from Git 2.50 appeared first on The GitHub Blog.",
  "author": "Taylor Blau",
  "published": "Mon, 16 Jun 2025 17:12:27 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Git",
    "Open Source"
  ],
  "byline": "Taylor Blau",
  "length": 19193,
  "excerpt": "The open source Git project just released Git 2.50. Here is GitHub‚Äôs look at some of the most interesting features and changes introduced since last time.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "The open source Git project just released Git 2.50 with features and bug fixes from 98 contributors, 35 of them new. We last caught up with you on the latest in Git back when 2.49 was released. üí° Before we get into the details of this latest release, we wanted to remind you that Git Merge, the conference for Git users and developers is back this year on September 29-30, in San Francisco. Git Merge will feature talks from developers working on Git, and in the Git ecosystem. Tickets are on sale now; check out the website to learn more. With that out of the way, let‚Äôs take a look at some of the most interesting features and changes from Git 2.50. Improvements for multiple cruft packs When we covered Git 2.43, we talked about newly added support for multiple cruft packs. Git 2.50 improves on that with better command-line ergonomics, and some important bugfixes. In case you‚Äôre new to the series, need a refresher, or aren‚Äôt familiar with cruft packs, here‚Äôs a brief overview:Git objects may be either reachable or unreachable. The set of reachable objects is everything you can walk to starting from one of your repository‚Äôs references: traversing from commits to their parent(s), trees to their sub-tree(s), and so on. Any object that you didn‚Äôt visit by repeating that process over all of your references is unreachable. In Git 2.37, Git introduced cruft packs, a new way to store your repository‚Äôs unreachable objects. A cruft pack looks like an ordinary packfile with the addition of an .mtimes file, which is used to keep track of when each object was most recently written in order to determine when it is safe1 to discard it.However, updating the cruft pack could be cumbersome‚Äìparticularly in repositories with many unreachable objects‚Äìsince a repository‚Äôs cruft pack must be rewritten in order to add new objects. Git 2.43 began to address this through a new command-line option: git repack --max-cruft-size. This option was designed to split unreachable objects across multiple packs, each no larger than the value specified by --max-cruft-size. But there were a couple of problems: If you‚Äôre familiar with git repack‚Äôs --max-pack-size option, --max-cruft-size‚Äôs behavior is quite confusing. The former option specifies the maximum size an individual pack can be, while the latter involves how and when to move objects between multiple packs. The feature was broken to begin with! Since --max-cruft-size also imposes on cruft packs the same pack-size constraints as --max-pack-size does on non-cruft packs, it is often impossible to get the behavior you want. For example, suppose you had two 100 MiB cruft packs and ran git repack --max-cruft-size=200M. You might expect Git to merge them into a single 200 MiB pack. But since --max-cruft-size also dictates the maximum size of the output pack, Git will refuse to combine them, or worse: rewrite the same pack repeatedly. Git 2.50 addresses both of these issues with a new option: --combine-cruft-below-size. Instead of specifying the maximum size of the output pack, it determines which existing cruft pack(s) are eligible to be combined. This is particularly helpful for repositories that have accumulated many unreachable objects spread across multiple cruft packs. With this new option, you can gradually reduce the number of cruft packs in your repository over time by combining existing ones together. With the introduction of --combine-cruft-below-size, Git 2.50 repurposed --max-cruft-size to behave as a cruft pack-specific override for --max-pack-size. Now --max-cruft-size only determines the size of the outgoing pack, not which packs get combined into it. Along the way, a bug was uncovered that prevented objects stored in multiple cruft packs from being ‚Äúfreshened‚Äù in certain circumstances. In other words, some unreachable objects don‚Äôt have their modification times updated when they are rewritten, leading to them being removed from the repository earlier than they otherwise would have been. Git 2.50 squashes this bug, meaning that you can now efficiently manage multiple cruft packs and freshen their objects to your heart‚Äôs content. [source, source] Incremental multi-pack reachability bitmaps ‚Äã‚ÄãBack in our coverage of Git 2.47, we talked about preliminary support for incremental multi-pack indexes. Multi-pack indexes (MIDXs) act like a single pack *.idx file for objects spread across multiple packs. Multi-pack indexes are extremely useful to accelerate object lookup performance in large repositories by binary searching through a single index containing most of your repository‚Äôs contents, rather than repeatedly searching through each individual packfile. But multi-pack indexes aren‚Äôt just useful for accelerating object lookups. They‚Äôre also the basis for multi-pack reachability bitmaps, the MIDX-specific analogue of classic single-pack reachability bitmaps. If neither of those are familiar to you, don‚Äôt worry; here‚Äôs a brief refresher. Single-pack reachability bitmaps store a collection of bitmaps corresponding to a selection of commits. Each bit position in a pack bitmap refers to one object in that pack. In each individual commit‚Äôs bitmap, the set bits correspond to objects that are reachable from that commit, and the unset bits represent those that are not. Multi-pack bitmaps were introduced to take advantage of the substantial performance increase afforded to us by reachability bitmaps. Instead of having bitmaps whose bit positions correspond to the set of objects in a single pack, a multi-pack bitmap‚Äôs bit positions correspond to the set of objects in a multi-pack index, which may include objects from arbitrarily many individual packs. If you‚Äôre curious to learn more about how multi-pack bitmaps work, you can read our earlier post Scaling monorepo maintenance. However, like cruft packs above, multi-pack indexes can be cumbersome to update as your repository grows larger, since each update requires rewriting the entire multi-pack index and its corresponding bitmap, regardless of how many objects or packs are being added. In Git 2.47, the file format for multi-pack indexes became incremental, allowing multiple multi-pack index layers to be layered on top of one another forming a chain of MIDXs. This made it much easier to add objects to your repository‚Äôs MIDX, but the incremental MIDX format at the time did not yet have support for multi-pack bitmaps. Git 2.50 brings support for the multi-pack reachability format to incremental MIDX chains, with each MIDX layer having its own *.bitmap file. These bitmap layers can be used in conjunction with one another to provide reachability information about selected commits at any layer of the MIDX chain. In effect, this allows extremely large repositories to quickly and efficiently add new reachability bitmaps as new commits are pushed to the repository, regardless of how large the repository is. This feature is still considered highly experimental, and support for repacking objects into incremental multi-pack indexes and bitmaps is still fairly bare-bones. This is an active area of development, so we‚Äôll make sure to cover any notable developments to incremental multi-pack reachability bitmaps in this series in the future.[source] The ORT merge engine replaces recursive This release also saw some exciting updates related to merging. Way back when Git 2.33 was released, we talked about a new merge engine called ‚ÄúORT‚Äù (standing for ‚ÄúOstensibly Recursive‚Äôs Twin‚Äù).ORT is a from-scratch rewrite of Git‚Äôs old merging engine, called ‚Äúrecursive.‚Äù ORT is significantly faster, more maintainable, and has many new features that were difficult to implement on top of its predecessor.One of those features is the ability for Git to determine whether or not two things are mergeable without actually persisting any new objects necessary to construct the merge in the repository. Previously, the only way to tell whether two things are mergeable was to run git merge-tree --write-tree on them. That works, but in this example merge-tree wrote any new objects generated by the merge into the repository. Over time, these can accumulate and cause performance issues. In Git 2.50, you can make the same determination without writing any new objects by using merge-tree‚Äôs new --quiet mode and relying on its exit code.Most excitingly in this release is that ORT has entirely superseded recursive, and recursive is no longer part of Git‚Äôs source code. When ORT was first introduced, it was only accessible through git merge‚Äôs -s option to select a strategy. In Git 2.34, ORT became the default choice over recursive, though the latter was still available in case there were bugs or behavior differences between the two. Now, 16 versions and two and a half years later, recursive has been completely removed from Git, with its author, Elijah Newren, writing: As a wise man once told me, ‚ÄúDeleted code is debugged code!‚Äù As of Git 2.50, recursive has been completely debugged deleted. For more about ORT‚Äôs internals and its development, check out this five part series from Elijah here, here, here, here, and here.[source, source, source] If you‚Äôve ever scripted around your repository‚Äôs objects, you are likely familiar with git cat-file, Git‚Äôs purpose-built tool to list objects and print their contents. git cat-file has many modes, like --batch (for printing out the contents of objects), or --batch-check (for printing out certain information about objects without printing their contents).Oftentimes it is useful to dump the set of all objects of a certain type in your repository. For commits, git rev-list can easily enumerate a set of commits. But what about, say, trees? In the past, to filter down to just the tree objects from a list of objects, you might have written something like:$ git cat-file --batch-check='%(objecttype) %(objectname)' \\¬† ¬† --buffer \u003cin | perl -ne 'print \"$1\\n\" if /^tree ([0-9a-f]+)/'Git 2.50 brings Git‚Äôs object filtering mechanism used in partial clones to git cat-file, so the above can be rewritten a little more concisely like:$ git cat-file --batch-check='%(objectname)' --filter='object:type=tree' \u003cin [source] While we‚Äôre on the topic, let‚Äôs discuss a little-known git cat-file command-line option: --allow-unknown-type. This arcane option was used with objects that have a type other than blob, tree, commit, or tag. This is a quirk dating back a little more than a decade ago that allows git hash-object to write objects with arbitrary types. In the time since, this feature has gotten very little use. In fact, git cat-file -p --allow-unknown-type can‚Äôt even print out the contents of one of these objects! $ oid=\"$(git hash-object -w -t notatype --literally /dev/null)\" $ git cat-file -p $oid fatal: invalid object type This release makes the --allow-unknown-type option silently do nothing, and removes support from git hash-object to write objects with unknown types in the first place. [source] The git maintenance command learned a number of new tricks this release as well. It can now perform a few new different kinds of tasks, like worktree-prune, rerere-gc, and reflog-expire. worktree-prune mirrors git gc‚Äôs functionality to remove stale or broken Git worktrees. rerere-gc also mirrors existing functionality exposed via¬†git gc to expire old rerere entries from previously recorded merge conflict resolutions. Finally, reflog-expire can be used to remove stale unreachable objects from out of the reflog.git maintenance also ships with new configuration for the existing loose-objects task. This task removes lingering loose objects that have since been packed away, and then makes new pack(s) for any loose objects that remain. The size of those packs was previously fixed at a maximum of 50,000, and can now be configured by the maintenance.loose-objects.batchSize configuration. [source, source, source] If you‚Äôve ever needed to recover some work you lost, you may be familiar with Git‚Äôs reflog feature, which allows you to track changes to a reference over time. For example, you can go back and revisit earlier versions of your repository‚Äôs main branch by doing git show main@{2} (to show main prior to the two most recent updates) or main@{1.week.ago} (to show where your copy of the branch was at a week ago).Reflog entries can accumulate over time, and you can reach for git reflog expire in the event you need to clean them up. But how do you delete the entirety of a branch‚Äôs reflog? If you‚Äôre not yet running Git 2.50 and thought ‚Äúsurely it‚Äôs git reflog delete‚Äù, you‚Äôd be wrong! Prior to Git 2.50, the only way to delete a branch‚Äôs entire reflog was to do git reflog expire $BRANCH --expire=all.In Git 2.50, a new delete sub-command was introduced, so you can accomplish the same as above with the much more natural git reflog delete $BRANCH. [source] Speaking of references, Git 2.50 also received some attention to how references are processed and used throughout its codebase. When using the low-level git update-ref command, Git used to spend time checking whether or not the proposed refname could also be a valid object ID, making its lookups ambiguous. Since update-ref is such a low-level command, this check is no longer done, delivering some performance benefits to higher-level commands that rely on update-ref for their functionality.Git 2.50 also learned how to cache whether or not any prefix of a proposed reference name already exists (for example, you can‚Äôt create a reference ref/heads/foo/bar/baz if either refs/heads/foo/bar or refs/heads/foo already exists).Finally, in order to make those checks, Git used to create a new reference iterator for each individual prefix. Git 2.50‚Äôs reference backends learned how to ‚Äúseek‚Äù existing iterators, saving time by being able to reuse the same iterator when checking each possible prefix.[source] If you‚Äôve ever had to tinker with Git‚Äôs low-level curl configuration, you may be familiar with Git‚Äôs configuration options for tuning HTTP connections, like http.lowSpeedLimit and http.lowSpeedTime which are used to terminate an HTTP connection that is transferring data too slowly.These options can be useful when fine-tuning Git to work in complex networking environments. But what if you want to tweak Git‚Äôs TCP Keepalive behavior? This can be useful to control when and how often to send keepalive probes, as well as how many to send, before terminating a connection that hasn‚Äôt sent data recently.Prior to Git 2.50, this wasn‚Äôt possible, but this version introduces three new configuration options: http.keepAliveIdle, http.keepAliveInterval, and http.keepAliveCount which can be used to control the fine-grained behavior of curl‚Äôs TCP probing (provided your operating system supports it).[source] Git is famously portable and runs on a wide variety of operating systems and environments with very few dependencies. Over the years, various parts of Git have been written in Perl, including some commands like the original implementation of git add -i . These days, very few remaining Git commands are written in Perl.This version reduces Git‚Äôs usage of Perl by removing it as a dependency of the test suite and documentation toolchain. Many Perl one-liners from Git‚Äôs test suite were rewritten to use other Shell functions or builtins, and some were rewritten as tiny C programs. For the handful of remaining hard dependencies on Perl, those tests will be skipped on systems that don‚Äôt have a working Perl. [source, source] This release also shipped a minor cosmetic update to git rebase -i. When starting a rebase, your $EDITOR might appear with contents that look something like: pick c108101daa foo pick d2a0730acf bar pick e5291f9321 baz You can edit that list to break, reword, or exec (among many others), and Git will happily execute your rebase. But if you change the commit message in your rebase‚Äôs TODO script, they won‚Äôt actually change!That‚Äôs because the commit messages shown in the TODO script are just meant to help you identify which commits you‚Äôre rebasing. (If you want to rewrite any commit messages along the way, you can use the reword command instead). To clarify that these messages are cosmetic, Git will now prefix them with a # comment character like so: pick c108101daa # foo pick d2a0730acf # bar pick e5291f9321 # baz [source] Long time readers of this series will recall our coverage of Git‚Äôs bundle feature (when Git added support for partial bundles), though we haven‚Äôt covered Git‚Äôs bundle-uri feature. Git bundles are a way to package your repositories contents: both its objects and the references that point at them into a single *.bundle file.While Git has had support for bundles since as early as v1.5.1 (nearly 18 years ago!), its bundle-uri feature is much newer. In short, the bundle-uri feature allows a server to serve part of a clone by first directing the client to download a *.bundle file. After the client does so, it will try to perform a fill-in fetch to gather any missing data advertised by the server but not part of the bundle.To speed up this fill-in fetch, your Git client will advertise any references that it picked up from the *.bundle itself. But in previous versions of Git, this could sometimes result in slower clones overall! That‚Äôs because up until Git 2.50, Git would only advertise the branches in refs/heads/* when asking the server to send the remaining set of objects.Git 2.50 now includes advertises all references it knows about from the *.bundle when doing a fill-in fetch on the server, making bundle-uri-enabled clones much faster.For more details about these changes, you can check out this blog post from Scott Chacon.[source] Last but not least, git add -p (and git add -i) now work much more smoothly in sparse checkouts by no longer having to expand the sparse index. This follows in a long line of work that has been gradually adding sparse-index compatibility to Git commands that interact with the index.Now you can interactively stage parts of your changes before committing in a sparse checkout without having to wait for Git to populate the sparsified parts of your repository‚Äôs index. Give it a whirl on your local sparse checkout today![source] The rest of the iceberg That‚Äôs just a sample of changes from the latest release. For more, check out the release notes for 2.50, or any previous version in the Git repository. üéâ Git turned 20 this year! Celebrate by watching our interview of Linus Torvalds, where we discuss how it forever changed software development. 1¬†It‚Äôs never truly safe to remove an unreachable object from a Git repository that is accepting incoming writes, because marking an object as unreachable can race with incoming reference updates, pushes, etc. At GitHub, we use Git‚Äôs ‚Äìexpire-to feature (which we wrote about in our coverage of Git 2.39) in something we call ‚Äúlimbo repositories‚Äù to quickly recover objects that shouldn‚Äôt have been deleted, before deleting them for good. ¬†‚Ü©Ô∏è Written by Taylor Blau is a Staff Software Engineer at GitHub where he works on Git.",
  "image": "https://github.blog/wp-content/uploads/2025/06/git-250.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eThe open source Git project just \u003ca href=\"https://lore.kernel.org/git/xmqq1prj1umb.fsf@gitster.g/T/#u\"\u003ereleased Git 2.50\u003c/a\u003e with features and bug fixes from 98 contributors, 35 of them new. We last caught up with you on the latest in Git back when \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-49/\"\u003e2.49 was released\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cp\u003eüí° Before we get into the details of this latest release, we wanted to remind you that \u003ca href=\"https://git-merge.com\"\u003eGit Merge\u003c/a\u003e, the conference for Git users and developers is back this year on September 29-30, in San Francisco. Git Merge will feature talks from developers working on Git, and in the Git ecosystem. Tickets are on sale now; check out \u003ca href=\"https://git-merge.com\"\u003ethe website\u003c/a\u003e to learn more.\u003c/p\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWith that out of the way, let‚Äôs take a look at some of the most interesting features and changes from Git 2.50.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-improvements-for-multiple-cruft-packs\"\u003eImprovements for multiple cruft packs\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen we covered \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-43/#multiple-cruft-packs\"\u003eGit 2.43\u003c/a\u003e, we talked about newly added support for \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-43/#multiple-cruft-packs\"\u003emultiple cruft packs\u003c/a\u003e. Git 2.50 improves on that with better command-line ergonomics, and some important bugfixes. In case you‚Äôre new to the series, need a refresher, or aren‚Äôt familiar with \u003ca href=\"https://github.blog/2022-09-13-scaling-gits-garbage-collection/\"\u003ecruft packs\u003c/a\u003e, here‚Äôs a brief overview:\u003c/p\u003e\u003cp\u003eGit \u003ca href=\"https://git-scm.com/book/en/v2/Git-Internals-Git-Objects\"\u003eobjects\u003c/a\u003e may be either reachable or unreachable. The set of reachable objects is everything you can walk to starting from one of your repository‚Äôs \u003ca href=\"https://git-scm.com/book/en/v2/Git-Internals-Git-References\"\u003ereferences\u003c/a\u003e: traversing from commits to their parent(s), trees to their sub-tree(s), and so on. Any object that you didn‚Äôt visit by repeating that process over all of your references is unreachable.\u003c/p\u003e\n\n\n\n\u003cp id=\"return\"\u003eIn \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-37/\"\u003eGit 2.37\u003c/a\u003e, Git introduced \u003ca href=\"https://git-scm.com/docs/cruft-packs/2.37.0\"\u003ecruft packs\u003c/a\u003e, a new way to store your repository‚Äôs unreachable objects. A cruft pack looks like an ordinary \u003ca href=\"https://git-scm.com/book/en/v2/Git-Internals-Packfiles\"\u003epackfile\u003c/a\u003e with the addition of an \u003ccode\u003e.mtimes\u003c/code\u003e file, which is used to keep track of when each object was most recently written in order to determine when it is safe\u003csup\u003e\u003ca href=\"#footnote\"\u003e1\u003c/a\u003e\u003c/sup\u003e to discard it.\u003c/p\u003e\u003cp\u003eHowever, updating the cruft pack could be cumbersome‚Äìparticularly in repositories with many unreachable objects‚Äìsince a repository‚Äôs cruft pack must be rewritten in order to add new objects. Git 2.43 began to address this through a new command-line option: \u003ccode\u003egit repack --max-cruft-size\u003c/code\u003e. This option was designed to split unreachable objects across multiple packs, each no larger than the value specified by \u003ccode\u003e--max-cruft-size\u003c/code\u003e. But there were a couple of problems:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIf you‚Äôre familiar with \u003ccode\u003egit repack\u003c/code\u003e‚Äôs \u003ccode\u003e--max-pack-size\u003c/code\u003e option, \u003ccode\u003e--max-cruft-size\u003c/code\u003e‚Äôs behavior is quite confusing. The former option specifies the maximum size an individual pack can be, while the latter involves how and when to move objects between multiple packs.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe feature was broken to begin with! Since \u003ccode\u003e--max-cruft-size\u003c/code\u003e \u003cem\u003ealso\u003c/em\u003e imposes on cruft packs the same pack-size constraints as \u003ccode\u003e--max-pack-size\u003c/code\u003e does on non-cruft packs, it is often impossible to get the behavior you want.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eFor example, suppose you had two 100 MiB cruft packs and ran \u003ccode\u003egit repack --max-cruft-size=200M\u003c/code\u003e. You might expect Git to merge them into a single 200 MiB pack. But since \u003ccode\u003e--max-cruft-size\u003c/code\u003e also dictates the maximum size of the output pack, Git will refuse to combine them, or worse: rewrite the same pack repeatedly.\u003c/p\u003e\n\n\n\n\u003cp\u003eGit 2.50 addresses both of these issues with a new option: \u003ccode\u003e--combine-cruft-below-size\u003c/code\u003e. Instead of specifying the maximum size of the output pack, it determines which existing cruft pack(s) are eligible to be combined. This is particularly helpful for repositories that have accumulated many unreachable objects spread across multiple cruft packs. With this new option, you can gradually reduce the number of cruft packs in your repository over time by combining existing ones together.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith the introduction of \u003ccode\u003e--combine-cruft-below-size\u003c/code\u003e, Git 2.50 repurposed \u003ccode\u003e--max-cruft-size\u003c/code\u003e to behave as a cruft pack-specific override for \u003ccode\u003e--max-pack-size\u003c/code\u003e. Now \u003ccode\u003e--max-cruft-size\u003c/code\u003e only determines the size of the outgoing pack, not which packs get combined into it.\u003c/p\u003e\n\n\n\n\u003cp\u003eAlong the way, a bug was uncovered that prevented objects stored in multiple cruft packs from being ‚Äúfreshened‚Äù in \u003ca href=\"https://lore.kernel.org/git/c0c926adde2b7c8f4b53b7a274d5b8c040f77e62.1740680964.git.me@ttaylorr.com/\"\u003ecertain circumstances\u003c/a\u003e. In other words, some unreachable objects don‚Äôt have their modification times updated when they are rewritten, leading to them being removed from the repository earlier than they otherwise would have been. Git 2.50 squashes this bug, meaning that you can now efficiently manage multiple cruft packs and freshen their objects to your heart‚Äôs content.\u003c/p\u003e\n\n\n\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/6a9e1c3507818fc7a7c301c16fda5ceecb82ae72...484d7adcdadbb72a3e0106c4fa49260cf1099b9a\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/f3db666cca0170a43ed602e7130c705882ce7574...08f612ba7000bf181ef6d8baed9ece322e567efd\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-incremental-multi-pack-reachability-bitmaps\"\u003eIncremental multi-pack reachability bitmaps\u003c/h2\u003e\n\n\n\n\u003cp\u003e‚Äã‚ÄãBack in \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-47\"\u003eour coverage of Git 2.47\u003c/a\u003e, we talked about preliminary support for \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-47/#incremental-multi-pack-indexes\"\u003eincremental multi-pack indexes\u003c/a\u003e. Multi-pack indexes (MIDXs) act like a single pack \u003ccode\u003e*.idx\u003c/code\u003e file for objects spread across multiple packs.\u003c/p\u003e\n\n\n\n\u003cp\u003eMulti-pack indexes are extremely useful to accelerate object lookup performance in large repositories by binary searching through a single index containing most of your repository‚Äôs contents, rather than repeatedly searching through each individual packfile. But multi-pack indexes aren‚Äôt just useful for accelerating object lookups. They‚Äôre also the basis for multi-pack reachability bitmaps, the MIDX-specific analogue of classic single-pack reachability bitmaps. If neither of those are familiar to you, don‚Äôt worry; here‚Äôs a brief refresher. Single-pack \u003ca href=\"https://git-scm.com/docs/bitmap-format/2.50.0\"\u003ereachability bitmaps\u003c/a\u003e store a collection of \u003ca href=\"https://en.wikipedia.org/wiki/Bit_array\"\u003ebitmaps\u003c/a\u003e corresponding to a selection of commits. Each bit position in a pack bitmap refers to one object in that pack. In each individual commit‚Äôs bitmap, the set bits correspond to objects that are reachable from that commit, and the unset bits represent those that are not.\u003c/p\u003e\n\n\n\n\u003cp\u003eMulti-pack bitmaps were introduced to take advantage of the substantial performance increase afforded to us by reachability bitmaps. Instead of having bitmaps whose bit positions correspond to the set of objects in a single pack, a multi-pack bitmap‚Äôs bit positions correspond to the set of objects in a multi-pack index, which may include objects from arbitrarily many individual packs. If you‚Äôre curious to learn more about how multi-pack bitmaps work, you can read our earlier post \u003ca href=\"https://github.blog/2021-04-29-scaling-monorepo-maintenance/\"\u003e\u003cem\u003eScaling monorepo maintenance\u003c/em\u003e\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eHowever, like cruft packs above, multi-pack indexes can be cumbersome to update as your repository grows larger, since each update requires rewriting the entire multi-pack index and its corresponding bitmap, regardless of how many objects or packs are being added. In Git 2.47, the file format for multi-pack indexes became incremental, allowing multiple multi-pack index layers to be layered on top of one another forming a chain of MIDXs. This made it much easier to add objects to your repository‚Äôs MIDX, but the incremental MIDX format at the time did not yet have support for multi-pack bitmaps.\u003c/p\u003e\n\n\n\n\u003cp\u003eGit 2.50 brings support for the multi-pack reachability format to incremental MIDX chains, with each MIDX layer having its own \u003ccode\u003e*.bitmap\u003c/code\u003e file. These bitmap layers can be used in conjunction with one another to provide reachability information about selected commits at any layer of the MIDX chain. In effect, this allows extremely large repositories to quickly and efficiently add new reachability bitmaps as new commits are pushed to the repository, regardless of how large the repository is.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis feature is still considered highly experimental, and support for repacking objects into incremental multi-pack indexes and bitmaps is still fairly bare-bones. This is an active area of development, so we‚Äôll make sure to cover any notable developments to incremental multi-pack reachability bitmaps in this series in the future.\u003c/p\u003e\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/6e2a3b8ae0e07c0c31f2247fec49b77b5d903a83...27afc272c49137460fe9e58e1fcbe4c1d377b304\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-the-ort-merge-engine-replaces-recursive\"\u003eThe \u003ccode\u003eORT\u003c/code\u003e merge engine replaces \u003ccode\u003erecursive\u003c/code\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eThis release also saw some exciting updates related to merging. Way back when Git 2.33 was released, we talked about a new merge engine called ‚ÄúORT‚Äù (standing for ‚ÄúOstensibly Recursive‚Äôs Twin‚Äù).\u003c/p\u003e\u003cp\u003eORT is a from-scratch rewrite of Git‚Äôs old merging engine, called ‚Äúrecursive.‚Äù ORT is significantly faster, more maintainable, and has many new features that were difficult to implement on top of its predecessor.\u003c/p\u003e\u003cp\u003eOne of those features is the ability for Git to determine whether or not two things are mergeable without actually persisting any new objects necessary to construct the merge in the repository. Previously, the only way to tell whether two things are mergeable was to run \u003ccode\u003egit merge-tree --write-tree\u003c/code\u003e on them. That works, but in this example \u003ccode\u003emerge-tree\u003c/code\u003e wrote any new objects generated by the merge into the repository. Over time, these can accumulate and cause performance issues. In Git 2.50, you can make the same determination without writing any new objects by using \u003ccode\u003emerge-tree\u003c/code\u003e‚Äôs new \u003ccode\u003e--quiet\u003c/code\u003e mode and relying on its exit code.\u003c/p\u003e\u003cp\u003eMost excitingly in this release is that ORT has entirely superseded recursive, and recursive is no longer part of Git‚Äôs source code. When ORT was first introduced, it was only accessible through \u003ccode\u003egit merge\u003c/code\u003e‚Äôs \u003ccode\u003e-s\u003c/code\u003e option to select a strategy. In Git 2.34, ORT became \u003ca href=\"http://recursive\"\u003ethe default choice\u003c/a\u003e over \u003ccode\u003erecursive\u003c/code\u003e, though the latter was still available in case there were bugs or behavior differences between the two. Now, 16 versions and two and a half years later, recursive has been completely removed from Git, with its author, Elijah Newren, \u003ca href=\"https://lore.kernel.org/git/pull.1898.git.1743436279.gitgitgadget@gmail.com/\"\u003ewriting\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eAs a wise man once told me, ‚ÄúDeleted code is debugged code!‚Äù\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eAs of Git 2.50, recursive has been completely \u003cs\u003edebugged\u003c/s\u003e deleted. For more about ORT‚Äôs internals and its development, check out this five part series from Elijah \u003ca href=\"https://blog.palantir.com/optimizing-gits-merge-machinery-1-127ceb0ef2a1\"\u003ehere\u003c/a\u003e, \u003ca href=\"https://blog.palantir.com/optimizing-gits-merge-machinery-2-d81391b97878\"\u003ehere\u003c/a\u003e, \u003ca href=\"https://blog.palantir.com/optimizing-gits-merge-machinery-3-2dc7c7436978\"\u003ehere\u003c/a\u003e, \u003ca href=\"https://blog.palantir.com/optimizing-gits-merge-machinery-part-iv-5bbc4703d050\"\u003ehere\u003c/a\u003e, and \u003ca href=\"https://blog.palantir.com/optimizing-gits-merge-machinery-part-v-46ff3710633e\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/17d9dbd3c270aaa33487f6a03d128c47aea6b309...29d7bf19512d8ca97be5cf708ca2e0bcc29408ab\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/8d6413a1bef7876b9c17a79358bd70b764ffacba...947e219fb6b1acc3d276d0b50ebf411c252a40bd\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/fe7ae3b87ef866e4818a106e8ce6e3d821ed76d7...170e30d6957e1f7b8d88046ae122f98d57dca988\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cul\u003e\n\n\u003cli\u003e\u003cp\u003eIf you‚Äôve ever scripted around your repository‚Äôs objects, you are likely familiar with \u003ccode\u003egit cat-file\u003c/code\u003e, Git‚Äôs purpose-built tool to list objects and print their contents. \u003ccode\u003egit cat-file\u003c/code\u003e has many modes, like \u003ccode\u003e--batch\u003c/code\u003e (for printing out the contents of objects), or \u003ccode\u003e--batch-check\u003c/code\u003e (for printing out certain information about objects without printing their contents).\u003c/p\u003e\u003cp\u003eOftentimes it is useful to dump the set of all objects of a certain type in your repository. For commits, \u003ccode\u003egit rev-list\u003c/code\u003e can easily enumerate a set of commits. But what about, say, trees? In the past, to filter down to just the tree objects from a list of objects, you might have written something like:\u003c/p\u003e\u003cpre\u003e$ git cat-file --batch-check=\u0026#39;%(objecttype) %(objectname)\u0026#39; \\\u003cbr/\u003e¬† ¬† --buffer \u0026lt;in | perl -ne \u0026#39;print \u0026#34;$1\\n\u0026#34; if /^tree ([0-9a-f]+)/\u0026#39;\u003c/pre\u003eGit 2.50 brings Git‚Äôs object filtering mechanism used in partial clones to \u003ccode\u003egit cat-file\u003c/code\u003e, so the above can be rewritten a little more concisely like:\u003cpre\u003e$ git cat-file --batch-check=\u0026#39;%(objectname)\u0026#39; --filter=\u0026#39;object:type=tree\u0026#39; \u0026lt;in\u003c/pre\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/9bdd7ecf7ec90433fc1803bf5d608d08857b3b49...8002e8ee1829f0c727aa2f7d9c18ad706cb63565\"\u003esource\u003c/a\u003e]\n\u003c/p\u003e\n\u003c/li\u003e\n\n\n\u003cli\u003eWhile we‚Äôre on the topic, let‚Äôs discuss a little-known \u003ccode\u003egit cat-file\u003c/code\u003e command-line option: \u003ccode\u003e--allow-unknown-type\u003c/code\u003e. This arcane option was used with objects that have a type other than \u003ccode\u003eblob\u003c/code\u003e, \u003ccode\u003etree\u003c/code\u003e, \u003ccode\u003ecommit\u003c/code\u003e, or \u003ccode\u003etag\u003c/code\u003e. This is a quirk dating back a little more than \u003ca href=\"https://github.com/git/git/compare/13f4f046929de00a8c16171c5e08cdcae887b54d...5ba9a93b39bef057be54ecf7933386a582981625\"\u003ea decade ago\u003c/a\u003e that allows \u003ccode\u003egit hash-object\u003c/code\u003e to write objects with arbitrary types. In the time since, this feature has gotten very little use. In fact, \u003ccode\u003egit cat-file -p --allow-unknown-type\u003c/code\u003e can‚Äôt even print out the contents of one of these objects!\n\n\u003cpre\u003e$ oid=\u0026#34;$(git hash-object -w -t notatype --literally /dev/null)\u0026#34;\n$ git cat-file -p $oid\nfatal: invalid object type\n\u003c/pre\u003e\n\n\n\u003cp\u003eThis release makes the \u003ccode\u003e--allow-unknown-type\u003c/code\u003e option silently do nothing, and removes support from git hash-object to write objects with unknown types in the first place.\u003c/p\u003e\n\n\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/b6fa7fbcd1b6791675c0b36636745e467419a522...141f8c8c0535004fa5432d9a6d57bf08129a7dd8\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\n\u003c/li\u003e\n\n\n\u003cli\u003e\u003cp\u003eThe \u003ccode\u003egit maintenance\u003c/code\u003e command learned a number of new tricks this release as well. It can now perform a few new different kinds of tasks, like \u003ccode\u003eworktree-prune\u003c/code\u003e, \u003ccode\u003ererere-gc\u003c/code\u003e, and \u003ccode\u003ereflog-expire\u003c/code\u003e. \u003ccode\u003eworktree-prune\u003c/code\u003e mirrors \u003ccode\u003egit gc\u003c/code\u003e‚Äôs functionality to remove stale or broken Git \u003ca href=\"https://git-scm.com/docs/git-worktree/2.50.0\"\u003eworktrees\u003c/a\u003e. \u003ccode\u003ererere-gc\u003c/code\u003e also mirrors existing functionality exposed via¬†\u003ccode\u003egit gc\u003c/code\u003e to expire old \u003ccode\u003ererere\u003c/code\u003e entries from previously recorded \u003ca href=\"https://git-scm.com/docs/git-rerere/2.50.0\"\u003emerge conflict resolutions\u003c/a\u003e. Finally, \u003ccode\u003ereflog-expire\u003c/code\u003e can be used to remove stale unreachable objects from out of the \u003ca href=\"https://git-scm.com/docs/git-reflog/2.50.0\"\u003ereflog\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003ccode\u003egit maintenance\u003c/code\u003e also ships with new configuration for the existing \u003ccode\u003eloose-objects\u003c/code\u003e task. This task removes lingering loose objects that have since been packed away, and then makes new pack(s) for any loose objects that remain. The size of those packs was previously fixed at a maximum of 50,000, and can now be configured by the \u003ccode\u003emaintenance.loose-objects.batchSize\u003c/code\u003e configuration.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/1d01042e314c0965845cae1fbcd0bc7e21f1b608...283621a553b60b26f14b9cf7e8b8c852ddba55d9\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/1a1661bd41697a106481e9e2467d0f5a0697349a...8e0a1ec0762405e045d924eed68b872fd29844c9\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/7b7fe0a898978618c36432f1f89b29cd412c7a23...6540560fd6c91091f6cf1eaedd034bc1827e1506\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\n\n\u003cli\u003e\u003cp\u003eIf you‚Äôve ever needed to recover some work you lost, you may be familiar with Git‚Äôs \u003ca href=\"https://git-scm.com/docs/git-reflog/2.50.0\"\u003ereflog\u003c/a\u003e feature, which allows you to track changes to a reference over time. For example, you can go back and revisit earlier versions of your repository‚Äôs main branch by doing \u003ccode\u003egit show main@{2}\u003c/code\u003e (to show \u003ccode\u003emain\u003c/code\u003e prior to the two most recent updates) or \u003ccode\u003emain@{1.week.ago}\u003c/code\u003e (to show where your copy of the branch was at a week ago).\u003c/p\u003e\u003cp\u003eReflog entries can accumulate over time, and you can reach for \u003ccode\u003egit reflog expire\u003c/code\u003e in the event you need to clean them up. But how do you delete the entirety of a branch‚Äôs reflog? If you‚Äôre not yet running Git 2.50 and thought ‚Äúsurely it‚Äôs \u003ccode\u003egit reflog delete\u003c/code\u003e‚Äù, you‚Äôd be wrong! Prior to Git 2.50, the only way to delete a branch‚Äôs entire reflog was to do \u003ccode\u003egit reflog expire $BRANCH --expire=all\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eIn Git 2.50, a new \u003ccode\u003edelete\u003c/code\u003e sub-command was introduced, so you can accomplish the same as above with the much more natural \u003ccode\u003egit reflog delete $BRANCH\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/ee847e0034dbfde11f901fbfb74d210c1edad496...d1270689a11e1e0dcf19d0257ce773a1d63d02d8\"\u003esource\u003c/a\u003e]\u003c/p\u003e\u003c/li\u003e\n\n\n\u003cli\u003e\u003cp\u003eSpeaking of references, Git 2.50 also received some attention to how references are processed and used throughout its codebase. When using the low-level \u003ccode\u003egit update-ref\u003c/code\u003e command, Git used to spend time checking whether or not the proposed refname could also be a valid object ID, making its lookups ambiguous. Since \u003ccode\u003eupdate-ref\u003c/code\u003e is such a low-level command, this check is no longer done, delivering some performance benefits to higher-level commands that rely on \u003ccode\u003eupdate-ref\u003c/code\u003e for their functionality.\u003c/p\u003e\u003cp\u003eGit 2.50 also learned how to cache whether or not any prefix of a proposed reference name already exists (for example, you can‚Äôt create a reference \u003ccode\u003eref/heads/foo/bar/baz\u003c/code\u003e if either \u003ccode\u003erefs/heads/foo/bar\u003c/code\u003e or \u003ccode\u003erefs/heads/foo\u003c/code\u003e already exists).\u003c/p\u003e\u003cp\u003eFinally, in order to make those checks, Git used to create a new reference iterator for each individual prefix. Git 2.50‚Äôs reference backends learned how to ‚Äúseek‚Äù existing iterators, saving time by being able to reuse the same iterator when checking each possible prefix.\u003c/p\u003e\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/01d17c05305edefbbe62926f5a5425207324a87f...87d297f48367737444810f8c3e76ef88cb6aa4e3\"\u003esource\u003c/a\u003e]\u003c/p\u003e\u003c/li\u003e\n\n\n\u003cli\u003e\u003cp\u003eIf you‚Äôve ever had to tinker with Git‚Äôs low-level \u003ca href=\"https://curl.se/\"\u003ecurl\u003c/a\u003e configuration, you may be familiar with Git‚Äôs \u003ca href=\"https://git-scm.com/docs/git-config/2.49.0#Documentation/git-config.txt-httplowSpeedLimithttplowSpeedTime\"\u003econfiguration options\u003c/a\u003e for tuning HTTP connections, like \u003ccode\u003ehttp.lowSpeedLimit\u003c/code\u003e and \u003ccode\u003ehttp.lowSpeedTime\u003c/code\u003e which are used to terminate an HTTP connection that is transferring data too slowly.\u003c/p\u003e\u003cp\u003eThese options can be useful when fine-tuning Git to work in complex networking environments. But what if you want to tweak Git‚Äôs \u003ca href=\"https://en.wikipedia.org/wiki/Keepalive#TCP_keepalive\"\u003eTCP Keepalive\u003c/a\u003e behavior? This can be useful to control when and how often to send keepalive probes, as well as how many to send, before terminating a connection that hasn‚Äôt sent data recently.\u003c/p\u003e\u003cp\u003ePrior to Git 2.50, this wasn‚Äôt possible, but this version introduces three new configuration options: \u003ccode\u003ehttp.keepAliveIdle\u003c/code\u003e, \u003ccode\u003ehttp.keepAliveInterval\u003c/code\u003e, and \u003ccode\u003ehttp.keepAliveCount\u003c/code\u003e which can be used to control the fine-grained behavior of curl‚Äôs TCP probing (provided your operating system supports it).\u003c/p\u003e\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/c6b3824a193bc263a764d17def7df7f09ef82a2d...46e6f9af3ec063529738f4b5b0b97c28c005c365\"\u003esource\u003c/a\u003e]\u003c/p\u003e\u003c/li\u003e\n\n\n\u003cli\u003e\u003cp\u003eGit is famously portable and runs on a wide variety of operating systems and environments with very few dependencies. Over the years, various parts of Git have been written in Perl, including some commands like \u003ca href=\"https://github.com/git/git/blob/5cde71d64aff03d305099b4d239552679ecfaab6/git-add--interactive.perl\"\u003ethe original implementation\u003c/a\u003e of \u003ccode\u003egit add -i\u003c/code\u003e . These days, very few remaining Git commands are written in Perl.\u003c/p\u003e\u003cp\u003eThis version reduces Git‚Äôs usage of Perl by removing it as a dependency of the test suite and documentation toolchain. Many Perl one-liners from Git‚Äôs test suite were rewritten to use other Shell functions or builtins, and some were rewritten as tiny C programs. For the handful of remaining hard dependencies on Perl, those tests will be skipped on systems that don‚Äôt have a working Perl.\u003c/p\u003e\n\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/8f490db4e200edd22e247ec07fb1349a26c155b2...7a7b6022670c7946afea73a1eeb2ddc32d756624\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/a819a3da85655031a23abae0f75d0910697fb92c...a7fa5b2f0ccb567a5a6afedece113f207902fa6f\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\n\u003c/li\u003e\n\n\n\u003cli\u003e\n\u003cp\u003eThis release also shipped a minor cosmetic update to \u003ccode\u003egit rebase -i\u003c/code\u003e. When starting a rebase, your \u003ccode\u003e$EDITOR\u003c/code\u003e might appear with contents that look something like:\n\u003c/p\u003e\u003cpre\u003epick c108101daa foo\npick d2a0730acf bar\npick e5291f9321 baz\n\u003c/pre\u003e\n\n\u003cp\u003eYou can edit that list to \u003ccode\u003ebreak\u003c/code\u003e, \u003ccode\u003ereword\u003c/code\u003e, or \u003ccode\u003eexec\u003c/code\u003e (among many others), and Git will happily execute your rebase. But if you change the commit message in your rebase‚Äôs TODO script, they won‚Äôt actually change!\u003c/p\u003e\u003cp\u003eThat‚Äôs because the commit messages shown in the TODO script are just meant to help you identify which commits you‚Äôre rebasing. (If you want to rewrite any commit messages along the way, you can use the \u003ccode\u003ereword\u003c/code\u003e command instead). To clarify that these messages are cosmetic, Git will now prefix them with a \u003ccode\u003e#\u003c/code\u003e comment character like so:\n\u003c/p\u003e\u003cpre\u003epick c108101daa # foo\npick d2a0730acf # bar\npick e5291f9321 # baz\n\u003c/pre\u003e\n\n\n\n\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/f9cdaa2860e20f3f36595646b7a82082aa772df8...e42667241de12840ef58c0ba1c060b86c850bae0\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\n\n\u003c/li\u003e\n\n\n\u003cli\u003e\u003cp\u003eLong time readers of this series will recall \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-36/\"\u003eour coverage\u003c/a\u003e of Git‚Äôs \u003ccode\u003ebundle\u003c/code\u003e \u003ca href=\"https://git-scm.com/book/en/v2/Git-Tools-Bundling\"\u003efeature\u003c/a\u003e (when Git added support for partial bundles), though we haven‚Äôt covered Git‚Äôs \u003ccode\u003ebundle-uri\u003c/code\u003e \u003ca href=\"https://git-scm.com/docs/bundle-uri/2.50.0\"\u003efeature\u003c/a\u003e. Git bundles are a way to package your repositories contents: both its objects and the references that point at them into a single \u003ccode\u003e*.bundle\u003c/code\u003e file.\u003c/p\u003e\u003cp\u003eWhile Git has had support for bundles since as early as \u003ca href=\"https://github.com/git/git/compare/1db8b60b2a6ef0cc0f7cc7d0783b7cda2ce894ca...64d99e9c5a4a3fb35d803894992764a6e288de5d\"\u003ev1.5.1\u003c/a\u003e (nearly 18 years ago!), its \u003ccode\u003ebundle-uri\u003c/code\u003e feature is \u003ca href=\"https://github.com/git/git/compare/83937e9592832408670da38bfe6e96c90ad63521...89c6e450fe4a919ecb6fa698005a935531c732cf\"\u003emuch newer\u003c/a\u003e. In short, the \u003ccode\u003ebundle-uri\u003c/code\u003e feature allows a server to serve part of a clone by first directing the client to download a \u003ccode\u003e*.bundle\u003c/code\u003e file. After the client does so, it will try to perform a fill-in fetch to gather any missing data advertised by the server but not part of the bundle.\u003c/p\u003e\u003cp\u003eTo speed up this fill-in fetch, your Git client will advertise any references that it picked up from the \u003ccode\u003e*.bundle\u003c/code\u003e itself. But in previous versions of Git, this could sometimes result in \u003cem\u003eslower\u003c/em\u003e clones overall! That‚Äôs because up until Git 2.50, Git would only advertise the branches in \u003ccode\u003erefs/heads/*\u003c/code\u003e when asking the server to send the remaining set of objects.\u003c/p\u003e\u003cp\u003eGit 2.50 now includes advertises all references it knows about from the \u003ccode\u003e*.bundle\u003c/code\u003e when doing a fill-in fetch on the server, making \u003ccode\u003ebundle-uri\u003c/code\u003e-enabled clones much faster.\u003c/p\u003e\u003cp\u003eFor more details about these changes, you can check out \u003ca href=\"https://blog.gitbutler.com/going-down-the-rabbit-hole-of-gits-new-bundle-uri/\"\u003ethis blog post\u003c/a\u003e from Scott Chacon.\u003c/p\u003e\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/0b8d22fd4030832fa64933721fa162feaa9c69d9...435b076ceb6e42c2c4c66422c036a02982b36bd4\"\u003esource\u003c/a\u003e]\u003c/p\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cp\u003eLast but not least, \u003ccode\u003egit add -p\u003c/code\u003e (and \u003ccode\u003egit add -i\u003c/code\u003e) now work much more smoothly in \u003ca href=\"https://github.blog/open-source/git/bring-your-monorepo-down-to-size-with-sparse-checkout/\"\u003esparse checkouts\u003c/a\u003e by no longer having to expand the \u003ca href=\"https://github.blog/open-source/git/make-your-monorepo-feel-small-with-gits-sparse-index/\"\u003esparse index\u003c/a\u003e. This follows in a long line of work that has been gradually adding sparse-index compatibility to Git commands that interact with the index.\u003c/p\u003e\u003cp\u003eNow you can interactively stage parts of your changes before committing in a sparse checkout without having to wait for Git to populate the sparsified parts of your repository‚Äôs index. Give it a whirl on your local sparse checkout today!\u003c/p\u003e\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/6b6c366e79a1e688526ece01cd1d6a2fa46d0071...ecf9ba20e35ded94d6b1f44f83bb9f7c32162654\"\u003esource\u003c/a\u003e]\u003c/p\u003e\u003c/li\u003e\n\n\n\u003c/ul\u003e\n\n\n\u003chr/\u003e\n\n\n\u003ch3 id=\"h-the-rest-of-the-iceberg\"\u003eThe rest of the iceberg\u003c/h3\u003e\n\n\n\u003cp\u003eThat‚Äôs just a sample of changes from the latest release. For more, check out the release notes for \u003ca href=\"https://github.com/git/git/blob/v2.50.0/Documentation/RelNotes/2.50.0.adoc\"\u003e2.50\u003c/a\u003e, or \u003ca href=\"https://github.com/git/git/tree/v2.50.0/Documentation/RelNotes\"\u003eany previous version\u003c/a\u003e in \u003ca href=\"https://github.com/git/git\"\u003ethe Git repository\u003c/a\u003e.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cp\u003e\u003cstrong\u003eüéâ Git turned 20 this year!\u003c/strong\u003e Celebrate by watching \u003ca href=\"https://github.blog/open-source/git/git-turns-20-a-qa-with-linus-torvalds/\"\u003eour interview of Linus Torvalds\u003c/a\u003e, where we discuss how it forever changed software development.\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003cp id=\"footnote\"\u003e\u003csup\u003e1\u003c/sup\u003e¬†It‚Äôs never \u003ca href=\"https://github.blog/engineering/scaling-gits-garbage-collection/#mitigating-object-deletion-raciness\"\u003etruly safe\u003c/a\u003e to remove an unreachable object from a Git repository that is accepting incoming writes, because marking an object as unreachable can race with incoming reference updates, pushes, etc. At GitHub, we use Git‚Äôs ‚Äìexpire-to feature (which we wrote about in our \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-39/\"\u003ecoverage of Git 2.39\u003c/a\u003e) in something we call ‚Äú\u003ca href=\"https://github.blog/engineering/scaling-gits-garbage-collection/#limbo-repositories\"\u003elimbo repositories\u003c/a\u003e‚Äù to quickly recover objects that shouldn‚Äôt have been deleted, before deleting them for good. ¬†\u003ca href=\"#return\"\u003e‚Ü©Ô∏è\u003c/a\u003e\u003c/p\u003e\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/443245?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/443245?v=4\u0026amp;s=200\" alt=\"Taylor Blau\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eTaylor Blau is a Staff Software Engineer at GitHub where he works on Git.\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "21 min read",
  "publishedTime": "2025-06-16T17:12:27Z",
  "modifiedTime": "2025-06-16T17:12:29Z"
}
