{
  "id": "fe6ae226-7ca8-449c-83c8-d0270660d0e0",
  "title": "The Story Behind K2 Mode and How It Works",
  "link": "https://blog.jetbrains.com/idea/2025/04/the-story-behind-k2-mode-and-how-it-works/",
  "description": "I‚Äôm Yan Zhulanow, and I lead the Kotlin Analysis API team. Last year, we made a series of announcements about Kotlin K2 mode in IntelliJ IDEA. Now, as K2 mode is about to become the default, I am thrilled to tell you more about everything we had to go through to make this release happen. [‚Ä¶]",
  "author": "Yan Zhulanow",
  "published": "Mon, 14 Apr 2025 13:32:31 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "eap",
    "kotlin",
    "releases",
    "intellij-idea",
    "k2-mode"
  ],
  "byline": "",
  "length": 18679,
  "excerpt": "I'm Yan Zhulanow, and I lead the Kotlin Analysis API team. Last year, we made a series of announcements about Kotlin K2 mode in IntelliJ IDEA. Now, as K2 mode is about to become the default, I am thri",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA ‚Äì the IDE for Professional Development in Java and Kotlin Early Access Program Kotlin ReleasesThe Story Behind K2 Mode and How It Works I‚Äôm Yan Zhulanow, and I lead the Kotlin Analysis API team. Last year, we made a series of announcements about Kotlin K2 mode in IntelliJ IDEA. Now, as K2 mode is about to become the default, I am thrilled to tell you more about everything we had to go through to make this release happen. Even before the Kotlin language got its name, we had already started to work on the compiler. But we wouldn‚Äôt be JetBrains if we didn‚Äôt think ahead about how to support a new programming language in an IDE. It was clear from day one that Kotlin should have a proper IntelliJ IDEA plugin. Easy to say, hard to achieve. For everything to work correctly, both the compiler and the IDE need to understand the programming language perfectly. Those who haven‚Äôt worked much with compilers or language tooling may assume it‚Äôs all about sharing a parser. In fact, parsers for a statically-typed language are usually the simplest components. Type and call resolution, type inference of various kinds, countless static checks ‚Äì these are just some of the interesting things that happen inside a semantic code analyzer on top of the produced AST. By semantic information, I mean all knowledge about declarations that isn‚Äôt explicitly stated in the source code. When you declare the String return type, you assume it‚Äôs just a String from the Kotlin standard library. But the compiler doesn‚Äôt make assumptions ‚Äì it analyzes any declarations and imports to find that the reference indeed points to kotlin.String. Similarly, when you call println(), it‚Äôs a relatively straightforward affair for the user, but the compiler needs to search high and low to collect all candidates and choose the most suitable overload. So, a semantic analyzer is quite a sophisticated piece of software. What makes implementing it even more challenging is supporting myriad corner cases that are barely present in the language specification. This exact reason makes undertaking two separate (but consistent) analyzer implementations, for the compiler and the IDE, much more than ‚Äújust‚Äù double work. Furthermore, it‚Äôs not just a one-time effort ‚Äì as the language evolves, its new features must be supported exactly in the same way. Otherwise, the IDE might show errors on compilable code, or vice versa. We had to create semantic analyzers for languages such as Java or Rust for IntelliJ IDEA by ourselves, as embedding compilers of those was impossible (or, at least, impractical). However, with Kotlin, it was different. Being the language designers, we had the ability to build the semantic analyzer from scratch to make it work both in the compiler and the IDE. To make supporting languages easier, IntelliJ IDEA offers a handy framework for generic code analysis. We tore it off, together with the Java code analyzer (to make Java/Kotlin cross-referencing possible), built a compiler on top, and used it as a core of the Kotlin IDE plugin. This approach worked incredibly well for us. We instantly had new language features supported in the IDE, so that we could focus on inspections, refactorings, and other neat features you now use every day. The team actively experimented with various language features, deciding on the ideal feature combo. That sometimes caused a bit of turbulence in the compiler codebase. At the same time, features of the IDE plugin often requested more and more sacred knowledge about the code, so the compiler had to offer a way to get it. But, as we developed those in the same repository, cross-refactorings rarely were a problem. Instead, people on both ends could improve the code analyzer as everyone was dealing with the same API. Efficient collaboration was priceless, as back then, in 2014, we barely had 20 people working on the whole Kotlin project. Over time, more and more IDE functionality became dependent on the compiler‚Äôs internals. There could have been a turning point where we decided to build a stricter API. But when the compiler became stable enough, the IDE support was full of features, too. On top of that, we had no issues with the existing code at the time, so making such a huge refactoring sounded unreasonable. The appearance of the K2 Kotlin compiler turned the tables, though. K2 brings a drastically more robust and performant analysis engine, so we were tempted to incorporate it into the IDE as early as possible. However, as we heavily depended on the old compiler, all IDE features needed to be rewritten or at least get a good shake-up. Of course, the fact that we would need to actively develop K2 didn‚Äôt come as a surprise to us. We were eager to improve performance and fix numerous bugs on the IDE side, but our hands were often tied owing to the shortcomings of the old compiler‚Äôs architecture. While the transition to K2 entailed an overwhelming amount of work, we were rather looking forward to it. In any case, we didn‚Äôt have much in the way of alternatives, as all emerging Kotlin language features were only developed for K2. Sharing is hard When we talk about ‚Äúsharing an analysis engine‚Äù, it might conjure images of a black box that does some magic with the AST and outputs the results. In reality, use cases between the compiler and IDE are so different that efficient analysis of the code requires fine-grained control over the process. For example, let‚Äôs see how code is analyzed in them. The compiler has a rather linear flow ‚Äì it takes the module sources, analyzes them together, and produces some output (i.e. .class files). On the other hand, in the IDE, code is usually analyzed on demand. Say, the user activates an autocompletion popup, and to show parameter types for the suggested functions, the IDE will trigger parameter resolution. However, function bodies won‚Äôt be analyzed, as the IDE doesn‚Äôt need them for autocompletion. Then, the compiler analyzes all the files in a module. However, it never works with multiple modules at once because module dependencies are handled by a build system. In the IDE, though, all files in a project are visible at once, and the programmer can freely navigate around. Not to mention, the IDE needs to be fast, so it caches as many analysis results as possible. Each time the programmer types a letter, parts of that collected information might have to be discarded. These were just a couple of conceptual differences between code analysis in compilers and in IDEs ‚Äì there are many more. Still, the point is clear: the compiler needs quick batch processing, while the IDE typically wants to analyze as little code as possible. How things worked before In the now-obsolete compiler, we wrapped parts of the compiler logic into lazy blocks to make code analysis in the IDE efficient. It sounded natural at the time ‚Äì when the IDE requests semantic information for a declaration, it will be automatically computed and cached. Lazy blocks could depend on other blocks, creating a sophisticated graph. To simplify the initial implementation, all the laziness happened under a single shared lock. Even that simple solution seemed quick enough in practice. At the same time, we understood we could decide to improve that part, so we introduced StorageManager, an abstraction layer for deferred computations. A close analogy will be a custom lazy property delegate that accepts an executor for the passed lambdas. Well, performance issues started to appear years later as Kotlin projects became larger and IntelliJ IDEA got lots of new features. But we‚Äôve got a fancy API, StorageManager, so we can build a better, multi-threaded implementation of it, right? Well, not quite ‚Äì too many places throughout the compiler means that no more than one thread can reach those places at the same time. By replacing the caching, we only got sporadic errors instead of a performance boost. Essentially, we got an abstraction that nobody respected. In addition, implicit laziness might look elegant at first sight, but it made the compiler code much less friendly when it came to debugging and optimization. When you can‚Äôt precisely track what‚Äôs resolved and what isn‚Äôt, it‚Äôs harder to understand why the analyzer ended up being in some weird inconsistent state. And, as underlying logic is uncontrollable, covering it with tests also becomes challenging. Could we have done better from the very beginning? Yes, for sure we could have. Still, the old compiler served us faithfully for more than 10 years. During that time, the Kotlin team gathered a lot of experience on how to share the code analyzer for our language efficiently. We knew what worked well ‚Äì and what didn‚Äôt ‚Äì and were fully prepared for the hard work that lay ahead. A new approach We spent a great deal of time ensuring that the new code analyzer works both in the compiler and the IDE in the best way possible. In the K2 compiler, we dropped all implicit laziness. Instead, we split code analysis into a sequence of phases, each analyzing a specific part of source code. For example, the SUPER_TYPES phase computes supertypes of classes, and TYPES handles signature types (such as parameter and explicit return types of functions). Each phase gradually enriches the AST with chunks of semantic information. Clear separation between phases greatly simplifies the compiler architecture. But it‚Äôs the IDE where the new architecture really shines. A phase may run not only on a file, but also on individual declarations. So, when the IDE requests some semantic data, the declaration is simply resolved up to the phase that provides that data. A declaration usually doesn‚Äôt come alone ‚Äì it depends on other declarations. In the following example, the compiler needs to resolve Array and String classes, as well as getOrNull and println library calls: fun main(args: Array\u003cString\u003e) { val name = args.getOrNull(0) ?: \"Anonymous\" println(\"Hello, $name!\") } We‚Äôre on a happy path here, as all these declarations come from a library, and for library declarations, we can get all semantic information straight away. But if any of those happened to be in sources, we would also have to analyze them. This would have resulted in an avalanche of implicit computations in the old compiler. In K2 mode, again, we simply instruct the compiler to resolve the dependent declaration to a specific phase, after which we have all the semantic information we need. For declarations with a specified return type, it would be CONTRACTS. In other words, a declaration can only be in one of a few fixed states ‚Äì either unresolved or resolved up to a specific phase. Such an approach secures the on-demand behavior for the IDE, but provides much more predictability than the old solution. Furthermore, seeing as we can now keep track of all resolution operations, we can precisely cover lazy resolution in tests. The new laziness architecture isn‚Äôt the only plausible change we made. The K2 compiler still uses a single thread, as in complex projects, parallel compilation of different modules often makes use of multiple cores anyway. However, all resolution logic is concurrency-tolerant now, so we can finally analyze multiple declarations simultaneously. The global lock is no more! At this point, a curious reader might ask: how can we resolve two declarations that point to each other in parallel? Well, in most cases, nothing special really happens. Say we have two functions that call each other; body analysis of both functions will require analysis of the other function‚Äôs signature (as we need to know parameter types for call resolution), but the bodies themselves are not interconnected. However, in a few phases, a loop may indeed happen. Let‚Äôs assume we have two functions with implicit return types, and those functions point to each other: fun foo() = bar() fun bar() = foo() This is obviously an invalid piece of code ‚Äì but the IDE still needs to understand it correctly to report the recursion in type checking! If we request full analysis for both functions at the same time, one worker will have to wait until the other declaration analysis is complete. Still, such loops are not so common, and in most cases, code analysis happens fully in parallel, including the most expensive BODY_RESOLVE phase. Parallel code analysis doesn‚Äôt simply make the IDE faster ‚Äì it enables new behaviors. For example, if you ran Find Usages on a really huge codebase, it could take quite some time to collect all the results. With the old K1 Kotlin plugin, you could barely use the IDE ‚Äì code highlighting didn‚Äôt work, the completion popup was sluggish, etc. Now you understand that all this happened because Find Usages held a global resolution lock. With K2 mode, no matter what features you activate, all of them will be able to run simultaneously. The Analysis API Switching to the K2 compiler brought us huge benefits, some of which we have yet to use fully. However, migrating existing features wasn‚Äôt easy at all ‚Äì remember, all of them were built on top of the old compiler‚Äôs internals. Ultimately, we had to rewrite code highlighting entirely, auto-completion, numerous refactorings and inspections, and many more parts of Kotlin support in IntelliJ IDEA. But even if we forget the K2 transition story for a second, the situation we were in was far from ideal. Compiler abstractions leaked too many things that were only needed for code analysis. At the same time, simple data retrieval was clunky. The compiler carried the semantic parts of AST around, but the IDE had to fetch chunks of it explicitly. Also, because of implicit laziness, even more ceremony was sometimes required to force everything to be calculated. Historically, the Kotlin compiler heavily embraced the idea ‚Äúcode is the documentation‚Äù. It was rare to find comments explaining use cases of methods and classes, let alone any relevant formal contracts. Some time ago, the Kotlin plugin moved to the IntelliJ IDEA repository and became a natural part of the IDE. It greatly helped us in the development of new IDE features, but then we lost an easy way to refactor the compiler. Indeed, we now had to change the code in two products with different release cycles. Thankfully, the compiler team was already busy with K2 at the time, so changes in the obsolete compiler were limited. Besides the Kotlin support itself, IntelliJ IDEA bundles various plugins that depend on Kotlin, such as Spring, DevKit, or Ktor. All those also required migration, but we could either do that ourselves or provide in-house guidance. But there are also hundreds of brave developers from the Kotlin community who built their plugins on top of the chaotic compiler APIs. For us, the mentioned issues were rather an inconvenience, but for a person who doesn‚Äôt work with Kotlin on a daily basis, it was a nightmare. So, together with Kotlin K2 mode, we developed a library designed specifically for on-demand code analysis ‚Äì the Kotlin Analysis API. It encapsulates all complex resolution logic and provides documented abstractions with clear and predictable behavior. As a user, you only request pieces of semantic code information you‚Äôre interested in, and the library takes care of all lazy and parallel analysis, together with caching the results. For instance, to get an expression type, you only need to call the KtExpression.expressionType extension property provided by the library. If the type isn‚Äôt yet known, the body of the containing declaration will be automatically analyzed. fun KtExpression.hasStringType(): Boolean { analyze(this) { return expressionType == builtinTypes.string } } Before, you needed to specify explicitly which declaration to resolve, get an opaque container with all semantic information that was collected during code analysis, and fetch an expression type from it. You could also find nothing there if lazy resolution avoided computing that type for some reason. The¬†Migrating from K1¬†documentation article tells more on the API differences. Today, the Analysis API offers backward compatibility for its core API, which is aligned with IntelliJ IDEA‚Äôs policies. We also built a documentation website with guides on using the library and how to migrate your existing code from the legacy API. Furthermore, we approached maintainers of all plugins on JetBrains Marketplace that used the old Kotlin compiler, and we‚Äôre happy to see that almost all plugins already migrated to the Analysis API. Thank you! What‚Äôs next? Together with IntelliJ IDEA 2025.1, we are making Kotlin K2 mode the default one, but our work doesn‚Äôt stop here. Even though the code is well-tested, there‚Äôs still a lot of new code that needs to be battle-tested in production. So, if you find that something works incorrectly, don‚Äôt hesitate to contact us: YouTrack: Create a KTIJ ticket to report an issue or a bug. The most efficient way to get the problem fixed Slack: #intellij channel in Kotlin Slack to ask your questions Email: k2-mode-feedback@jetbrains.com to provide more general feedback. ¬†We are eager for feedback and will try our best to make the Kotlin IDE experience as pleasurable as the laws of physics allow us to! üöÄ Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/04/ij-social_share_blog_1280x720_en-2.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA ‚Äì the IDE for Professional Development in Java and Kotlin\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/category/eap/\"\u003eEarly Access Program\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/idea/category/kotlin/\"\u003eKotlin\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/idea/category/releases/\"\u003eReleases\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eThe Story Behind K2 Mode and How It Works\u003c/h2\u003e                    \u003cdiv\u003e\n                            \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/C5DAF4C6-3354-43AB-9E8B-8623EFA76A17_1_105_c-e1744638346613-200x200.jpeg\" width=\"200\" height=\"200\" alt=\"Yan Zhulanow\" loading=\"lazy\"/\u003e\n                                                                                                                    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2024/08/photo_2024-08-02-14.40.26.jpeg\" width=\"200\" height=\"200\" alt=\"Teodor Irkhin\" loading=\"lazy\"/\u003e\n                                                                                                \u003c/p\u003e\n                            \n                        \u003c/div\u003e\n                    \n\u003cp\u003eI‚Äôm Yan Zhulanow, and I lead the Kotlin Analysis API team. Last year, we made a series of announcements about Kotlin K2 mode in IntelliJ IDEA. Now, as K2 mode is about to become the default, I am thrilled to tell you more about everything we had to go through to make this release happen.\u003c/p\u003e\n\n\n\n\u003cp\u003eEven before the Kotlin language got its name, we had already started to work on the compiler. But we wouldn‚Äôt be JetBrains if we didn‚Äôt think ahead about how to support a new programming language in an IDE. It was clear from day one that Kotlin should have a proper IntelliJ IDEA plugin.\u003c/p\u003e\n\n\n\n\u003cp\u003eEasy to say, hard to achieve. For everything to work correctly, both the compiler and the IDE need to understand the programming language perfectly. Those who haven‚Äôt worked much with compilers or language tooling may assume it‚Äôs all about sharing a parser. In fact, parsers for a statically-typed language are usually the simplest components. Type and call resolution, type inference of various kinds, countless static checks ‚Äì these are just some of the interesting things that happen inside a semantic code analyzer on top of the produced AST.\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1700\" height=\"776\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfd4JERTFBvMsxyoNqI_VPgJGHqOq41hwze3knVzgDumQUyp9HIaVmpBqLMGFXEAodkvcaWd1BuICMbqOVhkTITTycmCY_oM1DSb0A2SqKAZFDLIwgtnI0gkhTHtIJFWVKdcKZocg?key=A-mVJc9gNU3n4-H8pjS7GCmz\"/\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eBy semantic information, I mean all knowledge about declarations that isn‚Äôt explicitly stated in the source code. When you declare the \u003ccode\u003eString\u003c/code\u003e return type, you assume it‚Äôs just a \u003ccode\u003eString\u003c/code\u003e from the Kotlin standard library. But the compiler doesn‚Äôt make assumptions ‚Äì it analyzes any declarations and imports to find that the reference indeed points to \u003ccode\u003ekotlin.String\u003c/code\u003e. Similarly, when you call \u003ccode\u003eprintln()\u003c/code\u003e, it‚Äôs a relatively straightforward affair for the user, but the compiler needs to search high and low to collect all candidates and choose the most suitable overload.\u003c/p\u003e\n\n\n\n\u003cp\u003eSo, a semantic analyzer is quite a sophisticated piece of software. What makes implementing it even more challenging is supporting myriad corner cases that are barely present in the language specification. This exact reason makes undertaking two separate (but consistent) analyzer implementations, for the compiler and the IDE, much more than ‚Äújust‚Äù double work. Furthermore, it‚Äôs not just a one-time effort ‚Äì as the language evolves, its new features must be supported exactly in the same way. Otherwise, the IDE might show errors on compilable code, or vice versa.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe had to create semantic analyzers for languages such as Java or Rust for IntelliJ IDEA by ourselves, as embedding compilers of those was impossible (or, at least, impractical). However, with Kotlin, it was different. Being the language designers, we had the ability to build the semantic analyzer from scratch to make it work both in the compiler and the IDE.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo make supporting languages easier, IntelliJ IDEA offers a handy framework for generic code analysis. We tore it off, together with the Java code analyzer (to make Java/Kotlin cross-referencing possible), built a compiler on top, and used it as a core of the Kotlin IDE plugin. This approach worked incredibly well for us. We instantly had new language features supported in the IDE, so that we could focus on inspections, refactorings, and other neat features you now use every day.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe team actively experimented with various language features, deciding on the ideal feature combo. That sometimes caused a bit of turbulence in the compiler codebase. At the same time, features of the IDE plugin often requested more and more sacred knowledge about the code, so the compiler had to offer a way to get it. But, as we developed those in the same repository, cross-refactorings rarely were a problem. Instead, people on both ends could improve the code analyzer as everyone was dealing with the same API. Efficient collaboration was priceless, as back then, in 2014, we barely had 20 people working on the whole Kotlin project.\u003c/p\u003e\n\n\n\n\u003cp\u003eOver time, more and more IDE functionality became dependent on the compiler‚Äôs internals. There could have been a turning point where we decided to build a stricter API. But when the compiler became stable enough, the IDE support was full of features, too. On top of that, we had no issues with the existing code at the time, so making such a huge refactoring sounded unreasonable.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe appearance of the K2 Kotlin compiler turned the tables, though. K2 brings a drastically more robust and performant analysis engine, so we were tempted to incorporate it into the IDE as early as possible. However, as we heavily depended on the old compiler, all IDE features needed to be rewritten or at least get a good shake-up.\u003c/p\u003e\n\n\n\n\u003cp\u003eOf course, the fact that we would need to actively develop K2 didn‚Äôt come as a surprise to us. We were eager to improve performance and fix numerous bugs on the IDE side, but our hands were often tied owing to the shortcomings of the old compiler‚Äôs architecture. While the transition to K2 entailed an overwhelming amount of work, we were rather looking forward to it. In any case, we didn‚Äôt have much in the way of alternatives, as all emerging Kotlin language features were only developed for K2.\u003c/p\u003e\n\n\n\n\u003ch2\u003eSharing is hard\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen we talk about ‚Äúsharing an analysis engine‚Äù, it might conjure images of a black box that does some magic with the AST and outputs the results. In reality, use cases between the compiler and IDE are so different that efficient analysis of the code requires fine-grained control over the process.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor example, let‚Äôs see how code is analyzed in them. The compiler has a rather linear flow ‚Äì it takes the module sources, analyzes them together, and produces some output (i.e. \u003ccode\u003e.class\u003c/code\u003e files). On the other hand, in the IDE, code is usually analyzed on demand. Say, the user activates an autocompletion popup, and to show parameter types for the suggested functions, the IDE will trigger parameter resolution. However, function bodies won‚Äôt be analyzed, as the IDE doesn‚Äôt need them for autocompletion.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1600\" height=\"681\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/image-11.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThen, the compiler analyzes all the files in a module. However, it never works with multiple modules at once because module dependencies are handled by a build system. In the IDE, though, all files in a project are visible at once, and the programmer can freely navigate around. Not to mention, the IDE needs to be fast, so it caches as many analysis results as possible. Each time the programmer types a letter, parts of that collected information might have to be discarded.\u003c/p\u003e\n\n\n\n\u003cp\u003eThese were just a couple of conceptual differences between code analysis in compilers and in IDEs ‚Äì there are many more. Still, the point is clear: the compiler needs quick batch processing, while the IDE typically wants to analyze as little code as possible.\u003c/p\u003e\n\n\n\n\u003ch2\u003eHow things worked before\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn the now-obsolete compiler, we wrapped parts of the compiler logic into lazy blocks to make code analysis in the IDE efficient. It sounded natural at the time ‚Äì when the IDE requests semantic information for a declaration, it will be automatically computed and cached. Lazy blocks could depend on other blocks, creating a sophisticated graph.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo simplify the initial implementation, all the laziness happened under a single shared lock. Even that simple solution seemed quick enough in practice. At the same time, we understood we could decide to improve that part, so we introduced \u003ca href=\"https://github.com/JetBrains/kotlin/blob/02c617468fa29c3e242ac0ba342cd1fafd0467ad/core/util.runtime/src/org/jetbrains/kotlin/storage/StorageManager.kt#L21\" target=\"_blank\" rel=\"noopener\"\u003eStorageManager\u003c/a\u003e, an abstraction layer for deferred computations. A close analogy will be a custom \u003ccode\u003elazy\u003c/code\u003e property delegate that accepts an executor for the passed lambdas.\u003c/p\u003e\n\n\n\n\u003cp\u003eWell, performance issues started to appear years later as Kotlin projects became larger and IntelliJ IDEA got lots of new features. But we‚Äôve got a fancy API, \u003ccode\u003eStorageManager\u003c/code\u003e, so we can build a better, multi-threaded implementation of it, right? Well, not quite ‚Äì too many places throughout the compiler means that no more than one thread can reach those places at the same time. By replacing the caching, we only got sporadic errors instead of a performance boost. Essentially, we got an abstraction that nobody respected.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn addition, implicit laziness might look elegant at first sight, but it made the compiler code much less friendly when it came to debugging and optimization. When you can‚Äôt precisely track what‚Äôs resolved and what isn‚Äôt, it‚Äôs harder to understand why the analyzer ended up being in some weird inconsistent state. And, as underlying logic is uncontrollable, covering it with tests also becomes challenging.\u003c/p\u003e\n\n\n\n\u003cp\u003eCould we have done better from the very beginning? Yes, for sure we could have. Still, the old compiler served us faithfully for more than 10 years. During that time, the Kotlin team gathered a lot of experience on how to share the code analyzer for our language efficiently. We knew what worked well ‚Äì and what didn‚Äôt ‚Äì and were fully prepared for the hard work that lay ahead.\u003c/p\u003e\n\n\n\n\u003ch2\u003eA new approach\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe spent a great deal of time ensuring that the new code analyzer works both in the compiler and the IDE in the best way possible.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn the K2 compiler, we dropped all implicit laziness. Instead, we split code analysis into a sequence of phases, each analyzing a specific part of source code. For example, the \u003ca href=\"https://github.com/JetBrains/kotlin/blob/100d3cd87bad77cd05db946ae2ba6635e7379a56/compiler/fir/tree/src/org/jetbrains/kotlin/fir/declarations/FirResolvePhase.kt#L122\" target=\"_blank\" rel=\"noopener\"\u003eSUPER_TYPES\u003c/a\u003e phase computes supertypes of classes, and \u003ca href=\"https://github.com/JetBrains/kotlin/blob/100d3cd87bad77cd05db946ae2ba6635e7379a56/compiler/fir/tree/src/org/jetbrains/kotlin/fir/declarations/FirResolvePhase.kt#L144\" target=\"_blank\" rel=\"noopener\"\u003eTYPES\u003c/a\u003e handles signature types (such as parameter and explicit return types of functions). Each phase gradually enriches the AST with chunks of semantic information.\u003c/p\u003e\n\n\n\n\u003cp\u003eClear separation between phases greatly simplifies the compiler architecture. But it‚Äôs the IDE where the new architecture really shines. A phase may run not only on a file, but also on individual declarations. So, when the IDE requests some semantic data, the declaration is simply resolved up to the phase that provides that data.\u003c/p\u003e\n\n\n\n\u003cp\u003eA declaration usually doesn‚Äôt come alone ‚Äì it depends on other declarations. In the following example, the compiler needs to resolve \u003ccode\u003eArray\u003c/code\u003e and \u003ccode\u003eString\u003c/code\u003e classes, as well as \u003ccode\u003egetOrNull\u003c/code\u003e and \u003ccode\u003eprintln\u003c/code\u003e library calls:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun main(args: Array\u0026lt;String\u0026gt;) {\n    val name = args.getOrNull(0) ?: \u0026#34;Anonymous\u0026#34;\n    println(\u0026#34;Hello, $name!\u0026#34;)\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe‚Äôre on a happy path here, as all these declarations come from a library, and for library declarations, we can get all semantic information straight away. But if any of those happened to be in sources, we would also have to analyze them. This would have resulted in an avalanche of implicit computations in the old compiler. In K2 mode, again, we simply instruct the compiler to resolve the dependent declaration to a specific phase, after which we have all the semantic information we need. For declarations with a specified return type, it would be \u003ca href=\"https://github.com/JetBrains/kotlin/blob/100d3cd87bad77cd05db946ae2ba6635e7379a56/compiler/fir/tree/src/org/jetbrains/kotlin/fir/declarations/FirResolvePhase.kt#L167\" target=\"_blank\" rel=\"noopener\"\u003eCONTRACTS\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn other words, a declaration can only be in one of a few fixed states ‚Äì either unresolved or resolved up to a specific phase. Such an approach secures the on-demand behavior for the IDE, but provides much more predictability than the old solution. Furthermore, seeing as we can now keep track of all resolution operations, we can precisely cover lazy resolution in tests.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe new laziness architecture isn‚Äôt the only plausible change we made. The K2 compiler still uses a single thread, as in complex projects, parallel compilation of different modules often makes use of multiple cores anyway. However, all resolution logic is concurrency-tolerant now, so we can finally analyze multiple declarations simultaneously. The global lock is no more!\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1600\" height=\"681\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/image-11.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAt this point, a curious reader might ask: how can we resolve two declarations that point to each other in parallel? Well, in most cases, nothing special really happens. Say we have two functions that call each other; body analysis of both functions will require analysis of the other function‚Äôs signature (as we need to know parameter types for call resolution), but the bodies themselves are not interconnected.\u003c/p\u003e\n\n\n\n\u003cp\u003eHowever, in a few phases, a loop may indeed happen. Let‚Äôs assume we have two functions with implicit return types, and those functions point to each other:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun foo() = bar()\n\nfun bar() = foo()\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is obviously an invalid piece of code ‚Äì but the IDE still needs to understand it correctly to report the recursion in type checking! If we request full analysis for both functions at the same time, one worker will have to wait until the other declaration analysis is complete. Still, such loops are not so common, and in most cases, code analysis happens fully in parallel, including the most expensive \u003ca href=\"https://github.com/JetBrains/kotlin/blob/100d3cd87bad77cd05db946ae2ba6635e7379a56/compiler/fir/tree/src/org/jetbrains/kotlin/fir/declarations/FirResolvePhase.kt#L217\" target=\"_blank\" rel=\"noopener\"\u003eBODY_RESOLVE\u003c/a\u003e phase.\u003c/p\u003e\n\n\n\n\u003cp\u003eParallel code analysis doesn‚Äôt simply make the IDE faster ‚Äì it enables new behaviors. For example, if you ran \u003cem\u003eFind Usages\u003c/em\u003e on a really huge codebase, it could take quite some time to collect all the results. With the old K1 Kotlin plugin, you could barely use the IDE ‚Äì code highlighting didn‚Äôt work, the completion popup was sluggish, etc. Now you understand that all this happened because \u003cem\u003eFind Usages\u003c/em\u003e held a global resolution lock. With K2 mode, no matter what features you activate, all of them will be able to run simultaneously.\u003c/p\u003e\n\n\n\n\u003ch2\u003eThe Analysis API\u003c/h2\u003e\n\n\n\n\u003cp\u003eSwitching to the K2 compiler brought us huge benefits, some of which we have yet to use fully. However, migrating existing features wasn‚Äôt easy at all ‚Äì remember, all of them were built on top of the old compiler‚Äôs internals. Ultimately, we had to rewrite code highlighting entirely, auto-completion, numerous refactorings and inspections, and many more parts of Kotlin support in IntelliJ IDEA.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut even if we forget the K2 transition story for a second, the situation we were in was far from ideal.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCompiler abstractions leaked too many things that were only needed for code analysis. At the same time, simple data retrieval was clunky. The compiler carried the semantic parts of AST around, but the IDE had to fetch chunks of it explicitly. Also, because of implicit laziness, even more ceremony was sometimes required to force everything to be calculated.\u003c/li\u003e\n\n\n\n\u003cli\u003eHistorically, the Kotlin compiler heavily embraced the idea ‚Äúcode is the documentation‚Äù. It was rare to find comments explaining use cases of methods and classes, let alone any relevant formal contracts.\u003c/li\u003e\n\n\n\n\u003cli\u003eSome time ago, the Kotlin plugin moved to the IntelliJ IDEA repository and became a natural part of the IDE. It greatly helped us in the development of new IDE features, but then we lost an easy way to refactor the compiler. Indeed, we now had to change the code in two products with different release cycles. Thankfully, the compiler team was already busy with K2 at the time, so changes in the obsolete compiler were limited.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eBesides the Kotlin support itself, IntelliJ IDEA bundles various plugins that depend on Kotlin, such as Spring, DevKit, or Ktor. All those also required migration, but we could either do that ourselves or provide in-house guidance. But there are also hundreds of brave developers from the Kotlin community who built their plugins on top of the chaotic compiler APIs. For us, the mentioned issues were rather an inconvenience, but for a person who doesn‚Äôt work with Kotlin on a daily basis, it was a nightmare.\u003c/p\u003e\n\n\n\n\u003cp\u003eSo, together with Kotlin K2 mode, we developed a library designed specifically for on-demand code analysis ‚Äì the Kotlin Analysis API. It encapsulates all complex resolution logic and provides documented abstractions with clear and predictable behavior. As a user, you only request pieces of semantic code information you‚Äôre interested in, and the library takes care of all lazy and parallel analysis, together with caching the results.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor instance, to get an expression type, you only need to call the \u003ccode\u003eKtExpression.expressionType\u003c/code\u003e extension property provided by the library. If the type isn‚Äôt yet known, the body of the containing declaration will be automatically analyzed.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun KtExpression.hasStringType(): Boolean {\n    analyze(this) {\n        return expressionType == builtinTypes.string\n    }\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eBefore, you needed to specify explicitly which declaration to resolve, get an opaque container with all semantic information that was collected during code analysis, and fetch an expression type from it. You could also find nothing there if lazy resolution avoided computing that type for some reason. The¬†\u003ca href=\"https://kotlin.github.io/analysis-api/migrating-from-k1.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eMigrating from K1\u003c/a\u003e¬†documentation article tells more on the API differences.\u003c/p\u003e\n\n\n\n\u003cp\u003eToday, the Analysis API offers backward compatibility for its core API, which is aligned with IntelliJ IDEA‚Äôs policies. We also built a \u003ca href=\"https://kotl.in/analysis-api\" target=\"_blank\" rel=\"noopener\"\u003edocumentation website\u003c/a\u003e with guides on using the library and how to migrate your existing code from the legacy API. Furthermore, we approached maintainers of all plugins on JetBrains Marketplace that used the old Kotlin compiler, and we‚Äôre happy to see that almost all plugins already migrated to the Analysis API. Thank you!\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhat‚Äôs next?\u003c/h2\u003e\n\n\n\n\u003cp\u003eTogether with IntelliJ IDEA 2025.1, we are making Kotlin K2 mode the default one, but our work doesn‚Äôt stop here. Even though the code is well-tested, there‚Äôs still a lot of new code that needs to be battle-tested in production. So, if you find that something works incorrectly, don‚Äôt hesitate to contact us:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eYouTrack\u003c/strong\u003e: Create a \u003ca href=\"https://youtrack.jetbrains.com/newIssue?draftId=25-6414130\" target=\"_blank\" rel=\"noopener\"\u003eKTIJ ticket\u003c/a\u003e to report an issue or a bug. The most efficient way to get the problem fixed\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eSlack\u003c/strong\u003e: \u003ca href=\"https://kotlinlang.slack.com/archives/C0B8H786P\" target=\"_blank\" rel=\"noopener\"\u003e#intellij\u003c/a\u003e channel in Kotlin Slack to ask your questions\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eEmail\u003c/strong\u003e: \u003ca href=\"mailto:k2-mode-feedback@jetbrains.com\"\u003ek2-mode-feedback@jetbrains.com\u003c/a\u003e to provide more general feedback.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e¬†We are eager for feedback and will try our best to make the Kotlin IDE experience as pleasurable as the laws of physics allow us to! üöÄ\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": null,
  "modifiedTime": null
}
