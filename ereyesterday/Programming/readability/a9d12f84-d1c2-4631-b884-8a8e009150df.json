{
  "id": "a9d12f84-d1c2-4631-b884-8a8e009150df",
  "title": "LLMs bring new nature of abstraction",
  "link": "https://martinfowler.com/articles/2025-nature-abstraction.html",
  "description": "",
  "author": "",
  "published": "2025-06-24T10:02:00-04:00",
  "source": "https://martinfowler.com/feed.atom",
  "categories": null,
  "byline": "Martin Fowler",
  "length": 3356,
  "excerpt": "A long-form article entitled: \"LLMs bring new nature of abstraction\"",
  "siteName": "martinfowler.com",
  "favicon": "",
  "text": "Like most loudmouths in this field, I've been paying a lot of attention to the role that generative AI systems may play in software development. I think the appearance of LLMs will change software development to a similar degree as the change from assembler to the first high-level programming languages. The further development of languages and frameworks increased our abstraction level and productivity, but didn't have that kind of impact on the nature of programming. LLMs are making that degree of impact, but with the distinction that it isn't just raising the level of abstraction, but also forcing us to consider what it means to program with non-deterministic tools. High-Level Languages (HLLs) introduced a radically new level of abstraction. With assembler I'm thinking about the instruction set of a particular machine. I have to figure out how to do even simple actions by moving data into the right registers to invoke those specific actions. HLLs meant I could now think in terms of sequences of statements, conditionals to choose between alternatives, and iteration to repeatedly apply statements to collections of data values. I can introduce names into many aspects of my code, making it clear what values are supposed to represent. Early languages certainly had their limitations. My first professional programming was in Fortran IV, where “IF” statements didn't have an “ELSE” clause, and I had to remember to name my integer variables so they started with the letters “I” through “N”. Relaxing such restrictions and gaining block structure (“I can have more than one statement after my IF”) made my programming easier (and more fun) but are the same kind of thing. Now I hardly ever write loops, I instinctively pass functions as data - but I'm still talking to the machine in a similar way than I did all those days ago on the Dorset moors with Fortran. Ruby is a far more sophisticated language than Fortran, but it has the same ambiance, in a way that Fortran and PDP-11 machine instructions do not. Thus far I've not had the opportunity to do more than dabble with the best Gen-AI tools, but I'm fascinated as I listen to friends and colleagues share their experiences. I'm convinced that this is another fundamental change: talking to the machine in prompts is as different to Ruby as Fortran to assembler. But this is more than a huge jump in abstraction. When I wrote a Fortran function, I could compile it a hundred times, and the result still manifested the exact same bugs. Large Language Models introduce a non-deterministic abstraction, so I can't just store my prompts in git and know that I'll get the same behavior each time. As my colleague Birgitta put it, we're not just moving up the abstraction levels, we're moving sideways into non-determinism at the same time. illustration: Birgitta Böckeler As we learn to use LLMs in our work, we have to figure out how to live with this non-determinism. This change is dramatic, and rather excites me. I'm sure I'll be sad at some things we'll lose, but there will also things we'll gain that few of us understand yet. This evolution in non-determinism is unprecedented in the history of our profession.",
  "image": "https://martinfowler.com/logo-sq.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eLike most loudmouths in this field, I\u0026#39;ve been paying a lot of attention\n    to the role that generative AI systems may play in software development. I\n    think the appearance of LLMs will change software development to a similar\n    degree as the change from assembler to the first high-level programming\n    languages. The further development of languages and frameworks increased our\n    abstraction level and productivity, but didn\u0026#39;t have that kind of impact on\n    the \u003ci\u003enature\u003c/i\u003e of programming. LLMs are making that degree of impact, but with\n    the distinction that it isn\u0026#39;t just raising the level of abstraction, but\n    also forcing us to consider what it means to program with non-deterministic\n    tools.\u003c/p\u003e\n\n\u003cp\u003eHigh-Level Languages (HLLs) introduced a radically new level of abstraction. With assembler I\u0026#39;m\n    thinking about the instruction set of a particular machine. I have to figure\n    out how to do even simple actions by moving data into the right registers to\n    invoke those specific actions. HLLs meant I could now think in terms of\n    sequences of statements, conditionals to choose between alternatives, and\n    iteration to repeatedly apply statements to collections of data values. I\n    can introduce names into many aspects of my code, making it clear what\n    values are supposed to represent. Early languages certainly had their\n    limitations. My first professional programming was in Fortran IV, where “IF”\n    statements didn\u0026#39;t have an “ELSE” clause, and I had to remember to name my\n    integer variables so they started with the letters “I” through “N”. \u003c/p\u003e\n\n\u003cp\u003eRelaxing such restrictions and gaining block structure (“I can have more\n    than one statement after my IF”) made my programming easier (and more fun)\n    but are the same kind of thing. Now I hardly ever write loops, I\n    instinctively pass functions as data - but I\u0026#39;m still talking to the machine\n    in a similar way than I did all those days ago on the Dorset moors with\n    Fortran. Ruby is a far more sophisticated language than Fortran, but it has\n    the same ambiance, in a way that Fortran and PDP-11 machine instructions do\n    not.\u003c/p\u003e\n\n\u003cp\u003eThus far I\u0026#39;ve not had the opportunity to do more than dabble with the\n    best Gen-AI tools, but I\u0026#39;m fascinated as I listen to \u003ca href=\"https://martinfowler.com/articles/exploring-gen-ai.html\"\u003efriends and\n    colleagues\u003c/a\u003e share their experiences. I\u0026#39;m convinced that this is another\n    fundamental change: talking to the machine in prompts is as different to\n    Ruby as Fortran to assembler. But this is more than a huge jump in\n    abstraction. When I wrote a Fortran function, I could compile it a hundred\n    times, and the result still manifested the exact same bugs. Large Language Models introduce a\n    non-deterministic abstraction, so I can\u0026#39;t just store my prompts in git and\n    know that I\u0026#39;ll get the same behavior each time. As my \u003ca href=\"https://martinfowler.com/articles/exploring-gen-ai/07-how-is-this-different.html\"\u003ecolleague\n    Birgitta put it\u003c/a\u003e, we\u0026#39;re not just moving \u003ci\u003eup\u003c/i\u003e the abstraction levels,\n    we\u0026#39;re moving \u003ci\u003esideways\u003c/i\u003e into non-determinism at the same time.\u003c/p\u003e\n\n\u003cdiv id=\"_articles_exploring-gen-ai_abstraction-levels-with-genai.png\"\u003e\u003cp\u003e\u003cimg alt=\"Previous improvements raise the level of abstraction, but LLMs go sideways\" src=\"https://martinfowler.com/articles/exploring-gen-ai/abstraction-levels-with-genai.png\"/\u003e\u003c/p\u003e\u003cp\u003eillustration: Birgitta Böckeler\u003c/p\u003e\n\n\n\u003c/div\u003e\n\n\n\n\u003cp\u003eAs we learn to use LLMs in our work, we have to figure out how to\n    live with this non-determinism. This change is dramatic, and rather excites\n    me. I\u0026#39;m sure I\u0026#39;ll be sad at some things we\u0026#39;ll lose, but there will also\n    things we\u0026#39;ll gain that few of us understand yet. This evolution in\n    non-determinism is unprecedented in the history of our profession. \u003c/p\u003e\n\n\u003chr/\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": null,
  "modifiedTime": "2025-06-24T00:00:00Z"
}
