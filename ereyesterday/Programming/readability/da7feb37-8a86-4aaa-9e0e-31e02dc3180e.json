{
  "id": "da7feb37-8a86-4aaa-9e0e-31e02dc3180e",
  "title": "Present and Future of Kotlin for Web",
  "link": "https://blog.jetbrains.com/kotlin/2025/05/present-and-future-kotlin-for-web/",
  "description": "TL;DR: We remain committed to empowering Kotlin developers with robust and seamless support in Kotlin Multiplatform for web development. To achieve this, we are working on several key areas: Kotlin Multiplatform (KMP) aims to help developers share code across different platforms, significantly reducing development time and effort. The web plays a crucial role in this […]",
  "author": "Artem Kobzar",
  "published": "Thu, 08 May 2025 16:03:32 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "multiplatform",
    "kotlin-js",
    "kotlin-wasm"
  ],
  "byline": "",
  "length": 12252,
  "excerpt": "We've been focused on enhancing Kotlin Multiplatform for web, and a lot has been going on behind the scenes. Now, we're ready to share it!",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "A concise multiplatform language developed by JetBrains MultiplatformPresent and Future of Kotlin for Web TL;DR: We remain committed to empowering Kotlin developers with robust and seamless support in Kotlin Multiplatform for web development. To achieve this, we are working on several key areas: Improving IDE support for web targets. Promoting Kotlin/Wasm and Compose Multiplatform for web to Beta. Providing a compatibility mode for Compose Multiplatform in older browsers. Eliminating most limitations of interop in Kotlin/JS. Targeting the latest JavaScript standard in Kotlin/JS. Kotlin Multiplatform (KMP) aims to help developers share code across different platforms, significantly reducing development time and effort. The web plays a crucial role in this ecosystem, being the most widely used client-side platform. While we haven’t published an update in a while, a lot has been happening, and now we’re ready to share the latest developments. Current landscape: JavaScript and Wasm Kotlin Multiplatform is a production-ready technology that targets many platforms via four compiler backends: Kotlin/JVM, Kotlin/JS, Kotlin/Native, and Kotlin/Wasm.When it comes to the web, KMP offers two different solutions: compiling to JavaScript (Kotlin/JS) and WebAssembly (Kotlin/Wasm). Let us explain why we have both of them. Why two web targets? Kotlin Multiplatform provides a unique approach for sharing code and is built around flexibility. Depending on your project’s needs, you might want to: Share only the business logic and keep the UI native. Share both the business logic and the UI across all platforms. These two cases have different technical requirements, and JS and Wasm targets serve them accordingly. Sharing business logic If your goal is to share business logic on the web, you may have a few requirements, like the ability to: Provide a complex business logic to the native UI, which is predominantly based on JS. Load only the required business logic for a specific web page to reduce network load. Interact between JavaScript and Kotlin parts without extra performance costs. In this case, Kotlin/JS is the better fit because it provides a better interop experience. Sharing both logic and UI If you want to share the entire application, including the UI, across platforms, this is where Compose Multiplatform comes into play. With it, your requirements for web rendering and performance naturally change: You want the same UI rendered consistently on every platform, including the web. Smooth animations and responsive transitions become critical. Here, Kotlin/Wasm shines. According to our benchmarks, WebAssembly performs much better (almost 3 times faster) in the UI-sharing scenario. See our detailed recommendation on which target to choose for your application. What updates are coming soon? In the sections that follow, we’ll walk you through the most important updates and initiatives, from IDE tooling and interoperability improvements to the evolution of Compose Multiplatform for web. Let’s take a closer look at those areas. Better IDE support for web targets As part of our broader effort to provide an excellent Kotlin Multiplatform developer experience, we’re actively working on better KMP support in IntelliJ IDEA and Android Studio. This also includes improving the experience for JavaScript and Wasm targets. While code functionality is available in both IDEs, certain features, like debugging of JavaScript and Wasm targets, are currently available only in IntelliJ IDEA.We’ve started this journey by taking the following steps: Adding a wizard for creating a new KMP project targeting web platforms. Integrating a platform debugger to debug your KMP project on both web targets easily. Adding gutter icons for application entry points and tests to run them easily, without thinking about which Gradle task you should use. Promoting our Wasm target and Compose Multiplatform for web to Beta We understand that the web is an important platform for many Compose Multiplatform users, and we are committed to enhancing the development experience for those targeting it. Continued improvements in Compose Multiplatform for web Since moving to Alpha, Compose Multiplatform for web has received major updates, reducing the feature gap with other platforms. For example, text input handling was significantly improved, especially on mobile devices. The next big things we are working on are accessibility and interoperability with native HTML elements.  Kotlin/Wasm: Now in all modern versions of major browsers WebAssembly (Wasm) has also matured. As of December 11, 2024, all major browsers, including Safari, support WebAssembly Garbage Collection (WasmGC). This means Kotlin/Wasm applications can now run across all modern major browsers. Improving the Wasm development experience Over the last few years, improving the development experience for Wasm target has been our top priority. To that end, we’ve:  Introduced incremental compilation, making builds up to twice as fast. Enhanced debugging support for browsers, providing better stepping functionality and an improved variable view. In the next few months, we will focus more on enhancing stability to make targeting Wasm in KMP projects as smooth as possible and reduce breaking changes in the future.  Overall, we aim to make both technologies feature-complete (as close as possible) and promote them to Beta this year. Providing a compatibility mode for Compose Multiplatform As we already mentioned, we recommend targeting Wasm when you want an application with a multiplatform UI. However, there are some limitations to consider. The Wasm target relies on browser support for WasmGC, which may cause Kotlin applications targeting Wasm to be incompatible with older browsers that lack this support – see this guide for more details.To address this, we’re introducing a compatibility mode in Compose Multiplatform. With a new common source set called webMain, you will now have a single source for the `actual` declarations for both JavaScript and Wasm targets.  Using a special DSL in the CMP Gradle plugin, your application will be compiled to run the Wasm version of the app in modern browsers, taking full advantage of the Wasm target’s performance. For older browsers, the JavaScript version will run automatically, preventing a blank screen and maintaining usability. Note: Compose Multiplatform still relies on WebAssembly on the rendering engine side. However, this part uses WebAssembly features that have been available in all major browsers since 2017. Eliminate most of the limitations of interop in Kotlin/JS Today’s approach to interop with JavaScript in Kotlin is based on the experimental @JsExport annotation, which has constraints that make it challenging to use in enterprise applications.We are working on removing those limitations to provide a more seamless interop experience with JavaScript. Once this work is complete, you can mark the majority of Kotlin declarations with the @JsExport annotation, which will be stabilized. For cases where you can’t mark a declaration with this annotation, like when you don’t own sources of the used libraries but still want to export some declarations from there to JavaScript, there will be a DSL inside the multiplatform Gradle plugin, which helps to export all the needed declarations from those libraries. Targeting the latest JavaScript standard in Kotlin/JS Historically, the only available KMP JS target was ES5, which is now quite outdated. For the last two years, we’ve worked on introducing experimental support for compiling with modern JavaScript features like classes, generators, and arrow functions. This new support reduces bundle size and improves performance in some cases, which is why we aim to stabilize it and add more modern features like BigInt and dynamic import. We aim to target only the latest version of the JavaScript specification, thereby achieving even further reductions in bundle size and performance improvements. If you need to target older browsers, we’re integrating Babel inside our Gradle plugin. It will lower the generated JavaScript for compatibility with older browsers, so you still have the same range of platform support. The road ahead for Kotlin for web These aren’t the only improvements planned for Kotlin’s web targets. Several important initiatives are already underway.Here’s what’s coming next: Multithreading support in the Wasm target. To take advantage of modern multi-core processors and provide the best performance, we are going to prototype multithreading support for the Kotlin/Wasm compiler. Our goal is to make multithreaded development on the web as easy as it is on the JVM, elevating the development of high-performance web applications to a new level. Per-module compilation in the Wasm target. To improve development round-trip time and program modularity, we are working on generating multiple WebAssembly modules. This approach complements the recently introduced incremental compilation by allowing the recompilation of only the changed Kotlin modules. It also enables loading program parts on demand, which can significantly improve application startup time and reduce network load. In addition, it is a building block for supporting plugin systems in Kotlin applications targeting Wasm. Modern JavaScript tooling integration. To speed up the compilation cycle, we want to add an alternative to the Webpack integration we have today inside the Gradle plugin. We aim to decouple the Webpack integration to enable integration with any modern JavaScript bundler, like esbuild, repack, Vite, or bun. Automatic generation of Kotlin wrappers from TypeScript typings. To remove the frustration of writing Kotlin wrappers to consume a JavaScript/TypeScript library, we’ve come back to the integration of an automatic external-declarations generator for the multiplatform Gradle plugin. For each NPM dependency declared in your project, you will automatically get ready-to-consume Kotlin declarations describing the available API from the library. Final thoughts Thanks to recent surveys, YouTrack tickets, questions, and suggestions from across our channels, we’ve gathered a wealth of valuable feedback and built a clear direction for Kotlin on the web. We couldn’t have done it without you! To share more feedback or questions, please join our Slack community. There, you will find specific channels on various topics you might be interested in, like #webassembly, #compose-web, #javascript, and #multiplatform. We appreciate all your support, and we are committed to providing you with a great experience as you build with Kotlin across platforms. Subscribe to Kotlin Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/05/kt-social_share_blog_1280x720_en-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/kotlin/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/Kotlin-5.svg\" alt=\"Kotlin logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eA concise multiplatform language developed by JetBrains\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/kotlin/category/multiplatform/\"\u003eMultiplatform\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003ePresent and Future of Kotlin for Web\u003c/h2\u003e                    \u003cdiv\u003e\n                            \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/05/54137951823_1d633212ff_o-e1746697092840-200x200.jpg\" width=\"200\" height=\"200\" alt=\"Artem Kobzar\" loading=\"lazy\"/\u003e\n                                                                                                                    \u003cimg src=\"https://secure.gravatar.com/avatar/822a2c4ee71c2382f6dc7bd9eb75b3ce?s=200\u0026amp;r=g\" width=\"200\" height=\"200\" alt=\"Zalim Bashorov\" loading=\"lazy\"/\u003e\n                                                                                                \u003c/p\u003e\n                            \n                        \u003c/div\u003e\n                    \n\u003cp\u003e\u003cstrong\u003eTL;DR: \u003c/strong\u003eWe remain committed to empowering Kotlin developers with robust and seamless support in Kotlin Multiplatform for web development. To achieve this, we are working on several key areas:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eImproving IDE support for web targets.\u003c/li\u003e\n\n\n\n\u003cli\u003ePromoting Kotlin/Wasm and Compose Multiplatform for web to Beta.\u003c/li\u003e\n\n\n\n\u003cli\u003eProviding a compatibility mode for Compose Multiplatform in older browsers.\u003c/li\u003e\n\n\n\n\u003cli\u003eEliminating most limitations of interop in Kotlin/JS.\u003c/li\u003e\n\n\n\n\u003cli\u003eTargeting the latest JavaScript standard in Kotlin/JS.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://www.jetbrains.com/kotlin-multiplatform/\" data-type=\"link\" data-id=\"https://www.jetbrains.com/kotlin-multiplatform/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eKotlin Multiplatform (KMP)\u003c/a\u003e aims to help developers share code across different platforms, significantly reducing development time and effort. The web plays a crucial role in this ecosystem, being the most widely used client-side platform.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhile we haven’t published an update in a while, a lot has been happening, and now we’re ready to share the latest developments.\u003c/p\u003e\n\n\n\n\u003ch2\u003eCurrent landscape: JavaScript and Wasm\u003c/h2\u003e\n\n\n\n\u003cdiv\u003e\u003cp\u003eKotlin Multiplatform is a production-ready technology that targets many platforms via four compiler backends: Kotlin/JVM, Kotlin/JS, Kotlin/Native, and Kotlin/Wasm.\u003c/p\u003e\u003cp\u003eWhen it comes to the web, KMP offers two different solutions: compiling to JavaScript (Kotlin/JS) and WebAssembly (Kotlin/Wasm). Let us explain why we have both of them.\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003ch3\u003eWhy two web targets?\u003c/h3\u003e\n\n\n\n\u003cp\u003eKotlin Multiplatform provides a unique approach for sharing code and is built around flexibility. Depending on your project’s needs, you might want to:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eShare only the business logic and keep the UI native.\u003c/li\u003e\n\n\n\n\u003cli\u003eShare both the business logic and the UI across all platforms.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThese two cases have different technical requirements, and JS and Wasm targets serve them accordingly.\u003c/p\u003e\n\n\n\n\u003ch3\u003eSharing business logic\u003c/h3\u003e\n\n\n\n\u003cp\u003eIf your goal is to share business logic on the web, you may have a few requirements, like the ability to:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eProvide a complex business logic to the native UI, which is predominantly based on JS. \u003c/li\u003e\n\n\n\n\u003cli\u003eLoad only the required business logic for a specific web page to reduce network load.\u003c/li\u003e\n\n\n\n\u003cli\u003eInteract between JavaScript and Kotlin parts without extra performance costs.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIn this case, Kotlin/JS is the better fit because it provides a better interop experience.\u003c/p\u003e\n\n\n\n\u003ch3\u003eSharing both logic and UI\u003c/h3\u003e\n\n\n\n\u003cp\u003eIf you want to share the entire application, including the UI, across platforms, this is where Compose Multiplatform comes into play. With it, your requirements for web rendering and performance naturally change:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eYou want the same UI rendered consistently on every platform, including the web.\u003c/li\u003e\n\n\n\n\u003cli\u003eSmooth animations and responsive transitions become critical.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eHere, Kotlin/Wasm shines. According to our benchmarks, \u003ca href=\"https://kotlinlang.org/docs/wasm-overview.html#kotlin-wasm-performance\" target=\"_blank\" data-type=\"link\" data-id=\"https://kotlinlang.org/docs/wasm-overview.html#kotlin-wasm-performance\" rel=\"noreferrer noopener\"\u003eWebAssembly performs much better\u003c/a\u003e (almost 3 times faster) in the UI-sharing scenario.\u003c/p\u003e\n\n\n\n\u003cp\u003eSee our \u003ca href=\"https://www.jetbrains.com/help/kotlin-multiplatform-dev/choosing-web-target.html\" target=\"_blank\" data-type=\"link\" data-id=\"https://www.jetbrains.com/help/kotlin-multiplatform-dev/choosing-web-target.html\" rel=\"noreferrer noopener\"\u003edetailed recommendation\u003c/a\u003e on which target to choose for your application.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhat updates are coming soon?\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn the sections that follow, we’ll walk you through the most important updates and initiatives, from IDE tooling and interoperability improvements to the evolution of Compose Multiplatform for web.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s take a closer look at those areas.\u003c/p\u003e\n\n\n\n\u003ch3\u003eBetter IDE support for web targets\u003c/h3\u003e\n\n\n\n\u003cp\u003eAs part of our broader effort to provide an excellent Kotlin Multiplatform developer experience, we’re actively working on better KMP support in IntelliJ IDEA and Android Studio.\u003c/p\u003e\n\n\n\n\u003cdiv\u003e\u003cp\u003eThis also includes improving the experience for JavaScript and Wasm targets. While code functionality is available in both IDEs, certain features, like debugging of JavaScript and Wasm targets, are currently available only in IntelliJ IDEA.\u003c/p\u003e\u003cp\u003eWe’ve started this journey by taking the following steps:\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eAdding a wizard for creating a new KMP project targeting web platforms.\u003c/li\u003e\n\n\n\n\u003cli\u003eIntegrating a platform debugger to debug your KMP project on both web targets easily.\u003c/li\u003e\n\n\n\n\u003cli\u003eAdding gutter icons for application entry points and tests to run them easily, without thinking about which Gradle task you should use.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch3\u003ePromoting our Wasm target and Compose Multiplatform for web to Beta\u003c/h3\u003e\n\n\n\n\u003cp\u003eWe understand that the web is an important platform for many Compose Multiplatform users, and we are committed to enhancing the development experience for those targeting it.\u003c/p\u003e\n\n\n\n\u003ch4\u003eContinued improvements in Compose Multiplatform for web\u003c/h4\u003e\n\n\n\n\u003cp\u003eSince moving to Alpha, Compose Multiplatform for web has received major updates, reducing the feature gap with other platforms. For example, text input handling was significantly improved, especially on mobile devices. The next big things we are working on are accessibility and interoperability with native HTML elements. \u003c/p\u003e\n\n\n\n\u003ch4\u003eKotlin/Wasm: Now in all modern versions of major browsers\u003c/h4\u003e\n\n\n\n\u003cp\u003eWebAssembly (Wasm) has also matured. As of December 11, 2024, all major browsers, including Safari, \u003ca href=\"https://web.dev/blog/wasmgc-wasm-tail-call-optimizations-baseline#webassembly_garbage_collection_wasmgc\" data-type=\"link\" data-id=\"https://web.dev/blog/wasmgc-wasm-tail-call-optimizations-baseline#webassembly_garbage_collection_wasmgc\" target=\"_blank\" rel=\"noreferrer noopener\"\u003esupport WebAssembly Garbage Collection (WasmGC)\u003c/a\u003e. This means Kotlin/Wasm applications can now run across all modern major browsers.\u003c/p\u003e\n\n\n\n\u003ch4\u003eImproving the Wasm development experience\u003c/h4\u003e\n\n\n\n\u003cp\u003eOver the last few years, improving the development experience for Wasm target has been our top priority. To that end, we’ve: \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://kotlinlang.org/docs/whatsnew21.html#support-for-incremental-compilation\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eIntroduced incremental compilation\u003c/a\u003e, making builds up to twice as fast.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://kotlinlang.org/docs/whatsnew21.html#improved-debugging-experience-for-kotlin-wasm\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eEnhanced debugging support for browsers\u003c/a\u003e, providing better stepping functionality and an improved variable view.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIn the next few months, we will focus more on enhancing stability to make targeting Wasm in KMP projects as smooth as possible and reduce breaking changes in the future. \u003c/p\u003e\n\n\n\n\u003cp\u003eOverall, we aim to make both technologies feature-complete (as close as possible) and promote them to Beta this year.\u003c/p\u003e\n\n\n\n\u003ch3\u003eProviding a compatibility mode for Compose Multiplatform\u003c/h3\u003e\n\n\n\n\u003cdiv\u003e\u003cp\u003eAs we already mentioned, we recommend targeting Wasm when you want an application with a multiplatform UI. However, there are some limitations to consider. The Wasm target relies on browser support for WasmGC, which may cause Kotlin applications targeting Wasm to be incompatible with older browsers that lack this support – \u003ca href=\"https://kotlinlang.org/docs/wasm-troubleshooting.html#chromium-based\" target=\"_blank\" rel=\"noreferrer noopener\"\u003esee this guide for more details\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eTo address this, we’re introducing a compatibility mode in Compose Multiplatform.\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eWith \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-75480/Add-shared-source-set-for-js-and-wasmJs-target\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ea new common source set called \u003ccode\u003ewebMain\u003c/code\u003e\u003c/a\u003e, you will now have a single source for the `actual` declarations for both JavaScript and Wasm targets. \u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eUsing \u003ca href=\"https://youtrack.jetbrains.com/issue/CMP-7674\" target=\"_blank\" rel=\"noopener\"\u003ea special DSL in the CMP Gradle plugin\u003c/a\u003e, your application will be compiled to run the Wasm version of the app in modern browsers, taking full advantage of the Wasm target’s performance. For older browsers, the JavaScript version will run automatically, preventing a blank screen and maintaining usability.\u003cbr/\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eNote: Compose Multiplatform still relies on WebAssembly on the rendering engine side. However, this part uses WebAssembly features that have been available \u003c/em\u003e\u003ca href=\"https://caniuse.com/wasm\" target=\"_blank\" rel=\"noreferrer noopener\"\u003e\u003cem\u003ein all major browsers since 2017\u003c/em\u003e\u003c/a\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch3\u003eEliminate most of the limitations of interop in Kotlin/JS\u003c/h3\u003e\n\n\n\n\u003cdiv\u003e\u003cp\u003eToday’s approach to interop with JavaScript in Kotlin is based on the experimental \u003ca href=\"https://kotlinlang.org/docs/js-to-kotlin-interop.html#jsexport-annotation\" target=\"_blank\" rel=\"noreferrer noopener\"\u003e\u003ccode\u003e@JsExport\u003c/code\u003e\u003c/a\u003e annotation, which has constraints that make it challenging to use in enterprise applications.\u003c/p\u003e\u003cp\u003eWe are working on removing those limitations to provide a more seamless interop experience with JavaScript. Once this work is complete, you can mark the majority of Kotlin declarations with the \u003ccode\u003e@JsExport\u003c/code\u003e annotation, which will be stabilized.\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003cp\u003eFor cases where you can’t mark a declaration with this annotation, like when you don’t own sources of the used libraries but still want to export some declarations from there to JavaScript, there will be a DSL inside the multiplatform Gradle plugin, which helps to export all the needed declarations from those libraries.\u003c/p\u003e\n\n\n\n\u003ch3\u003eTargeting the latest JavaScript standard in Kotlin/JS\u003c/h3\u003e\n\n\n\n\u003cp\u003eHistorically, the only available KMP JS target was ES5, which is now quite outdated. For the last two years, we’ve worked on introducing experimental support for compiling with modern JavaScript features like classes, generators, and arrow functions.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis new support reduces bundle size and improves performance in some cases, which is why we aim to stabilize it and add more modern features like BigInt and dynamic import.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe aim to target only the latest version of the JavaScript specification, thereby achieving even further reductions in bundle size and performance improvements. If you need to target older browsers, we’re integrating \u003ca href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eBabel\u003c/a\u003e inside our Gradle plugin. It will lower the generated JavaScript for compatibility with older browsers, so you still have the same range of platform support.\u003c/p\u003e\n\n\n\n\u003ch2\u003eThe road ahead for Kotlin for web\u003c/h2\u003e\n\n\n\n\u003cdiv\u003e\u003cp\u003eThese aren’t the only improvements planned for Kotlin’s web targets. Several important initiatives are already underway.\u003c/p\u003e\u003cp\u003eHere’s what’s coming next:\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMultithreading support in the Wasm target.\u003c/strong\u003e To take advantage of modern multi-core processors and provide the best performance, we are going to prototype \u003ca href=\"https://github.com/WebAssembly/shared-everything-threads\" target=\"_blank\" rel=\"noreferrer noopener\"\u003emultithreading support\u003c/a\u003e for the Kotlin/Wasm compiler. Our goal is to make multithreaded development on the web as easy as it is on the JVM, elevating the development of high-performance web applications to a new level.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePer-module compilation in the Wasm target.\u003c/strong\u003e To improve development round-trip time and program modularity, we are working on generating multiple WebAssembly modules. This approach complements the \u003ca href=\"https://kotlinlang.org/docs/whatsnew21.html#support-for-incremental-compilation\" target=\"_blank\" rel=\"noreferrer noopener\"\u003erecently introduced incremental compilation\u003c/a\u003e by allowing the recompilation of only the changed Kotlin modules. It also enables loading program parts on demand, which can significantly improve application startup time and reduce network load. In addition, it is a building block for supporting plugin systems in Kotlin applications targeting Wasm.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eModern JavaScript tooling integration.\u003c/strong\u003e To speed up the compilation cycle, we want to add an alternative to the Webpack integration we have today inside the Gradle plugin. We aim to decouple the Webpack integration to enable integration with any modern JavaScript bundler, like esbuild, repack, Vite, or bun.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAutomatic generation of Kotlin wrappers from TypeScript typings. \u003c/strong\u003eTo remove the frustration of writing Kotlin wrappers to consume a JavaScript/TypeScript library, we’ve come back to the integration of an automatic \u003ca href=\"https://kotlinlang.org/docs/js-interop.html#external-modifier\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eexternal-declarations\u003c/a\u003e generator for the multiplatform Gradle plugin. For each \u003ca href=\"https://kotlinlang.org/docs/using-packages-from-npm.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eNPM dependency\u003c/a\u003e declared in your project, you will automatically get ready-to-consume Kotlin declarations describing the available API from the library.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eFinal thoughts\u003c/h2\u003e\n\n\n\n\u003cp\u003eThanks to recent surveys, YouTrack tickets, questions, and suggestions from across our channels, we’ve gathered a wealth of valuable feedback and built a clear direction for Kotlin on the web. We couldn’t have done it without you!\u003c/p\u003e\n\n\n\n\u003cp\u003eTo share more feedback or questions, please join our \u003ca href=\"https://slack-chats.kotlinlang.org/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eSlack community\u003c/a\u003e. There, you will find specific channels on various topics you might be interested in, like #webassembly, #compose-web, #javascript, and #multiplatform.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe appreciate all your support, and we are committed to providing you with a great experience as you build with Kotlin across platforms.\u003c/p\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to Kotlin Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
