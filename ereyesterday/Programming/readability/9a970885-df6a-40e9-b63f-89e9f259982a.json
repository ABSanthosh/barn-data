{
  "id": "9a970885-df6a-40e9-b63f-89e9f259982a",
  "title": "C# Language Support in ReSharper and Rider 2025.1",
  "link": "https://blog.jetbrains.com/dotnet/2025/04/10/csharp-language-support-in-resharper-and-rider-2025-1/",
  "description": "Our release for ReSharper and Rider 2025.1 is just around the corner, and we have lots of exciting features shipping for the current and next version of C#! This will be a really long post (blame our awesome devs!), so make sure to use the table of contents on the right. Oh, and of course… […]",
  "author": "Matthias Koch",
  "published": "Thu, 10 Apr 2025 16:51:03 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "net-tools",
    "how-tos",
    "net",
    "c",
    "formatting",
    "generation-and-templates",
    "inspections",
    "quick-fixes"
  ],
  "byline": "Matthias Koch",
  "length": 14172,
  "excerpt": "Our release for ReSharper and Rider 2025.1 is just around the corner, and we have lots of exciting features shipping for the current and next version of C#! This will be a really long post (blame our",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "Essential productivity kit for .NET and game developers .NET Tools How-To'sC# Language Support in ReSharper and Rider 2025.1 Our release for ReSharper and Rider 2025.1 is just around the corner, and we have lots of exciting features shipping for the current and next version of C#! This will be a really long post (blame our awesome devs!), so make sure to use the table of contents on the right. Oh, and of course… For many of the inspections and quick fixes discussed in this post, we recommend using either find in scope or fix in scope to effectively use them in your codebases. Now, let’s talk about new features! Structured Logging Support In ReSharper and Rider 2025.1, we enhanced support for structured and high-performance logging using the Microsoft.Extensions.Logging APIs. Similar to how formatting arguments are highlighted in string.Format using the {0} syntax, we now highlight the corresponding type arguments in the Logger.Define and LoggerMessageAttribute API. Additionally, missing type arguments are now reported with diagnostics to catch issues early, along with quick-fixes and context actions to add or remove them as needed: Structured and High-Performance Logging Support String Construction Context Actions Our .NET IDEs offer a wide range of suggestions and context actions for working with C# string literals, interpolated strings, string.Format, and StringBuilder constructs. You can convert nearly any string-related expression into various other forms to enhance readability or to better parameterize string construction. However, some conversion directions were still missing. For example, while it’s been easy to convert a concatenated string like \"Id = \" + someId into either an interpolated string $\"Id = {someId}\" or a format string string.Format(\"Id = {0}\", someId), there hasn’t been a way to reverse this — i.e., to convert interpolated or formatted strings back into concatenation. In certain scenarios, such a transformation can actually result in more concise or readable code: Convert Interpolation to Concatenation Context Action Improved Multiline To-Do Comments In the previous release, we introduced support for multiline to-do comments, where subsequent lines were considered part of the same item based on their indentation. In the 2025.1 release, we’ve enhanced this feature by making indentation optional. Now, lines following a to-do comment are automatically treated as part of the same item, even without indentation, making multiline comments more intuitive and seamless. However, if indentation is used, it will be strictly enforced: Improved Multiline To-Do Comments Language Injection in Return Values Language injection made its debut in ReSharper around 10 years ago with support for regular expressions. Since then, it has been brought to Rider, expanded to other languages, and updated to work with new language and runtime features. Previously, the LanguageInjection attribute (from JetBrains.Annotations) could only be applied to parameters, fields, and properties. Now you can annotate methods to specify that their returned strings represent an embedded code of another language: Language Injection in Return Values Redundant Duplicated Code In the previous two versions, we introduced inspections for more specific scenarios of code duplication — common code in if and switch statements and duplicated switch section bodies. In this 2025.1 release, we deliver three new inspections to help you eliminate unintentional duplications and improve readability and maintainability in your codebase. Our first inspection detects duplicated statements that appear both within conditional branches of if and switch statements ending with jump statements and again immediately afterward: Duplicated Statements in Conditional Branches Inspection and Quick-Fix Another inspection detects redundant arms in switch expressions — specifically, arms that return the same value as the default one. Removing these redundancies simplifies your code and improves readability: Redundant switch Expression Arms Inspection and Quick-Fix The last inspection detects when multiple if branches execute identical code and provides a handy quick-fix to merge them: Duplicated if Bodies Inspection and Quick-Fix Misuse of CancellationToken When working with asynchronous methods, it’s common to pass a CancellationToken through parameters of local functions or lambda expressions. Accidentally using a method-level token instead of a more specific, locally scoped one can lead to unintended behavior, such as tasks not being canceled when expected. ReSharper and Rider 2025.1 introduce a new inspection that detects when a broader-scoped cancellation token is mistakenly used instead of a more appropriate local token available within a local function or lambda. You can choose from two corresponding quick-fixes to either a) replace the mistakenly used token with the correct local token, or b) link both tokens into one using CancellationTokenSource.CreateLinkedTokenSource: Possibly Mistaken Use of CancellationToken Inspection Injection Postfix Template Primary constructors in C# 12 greatly simplify constructor dependency injection patterns. You only need to mention a dependency once in the constructor parameter list, and it automatically becomes available across all instance members of the class without the need to define and assign a field explicitly. In ReSharper and Rider 2025.1, we introduce a new inject postfix template available for type names. When you realize you need to add a dependency on IService, select it from the completion list, append .inject, and hit your completion key: Inject Postfix Template Transform Parameters Refactoring The transform parameters refactoring makes it easy to change a method’s signature by modifying its parameters — for example, removing out parameters, wrapping them in a tuple or a new class, and more — while automatically updating all usages of the method across your solution. With ReSharper and Rider 2025.1, we reworked the refactoring to support modern language features (including tuple types, record classes, and primary constructors), treat tuple elements as multiple return values, transform ref parameters into both input and output values, and handle lots of deconstruction usages. Bring up the dialog, select the parameters you want to transform, and choose your desired target types: Transform Parameters Refactoring Dialog Context Highlighters for Extended Types One of the very subtle features in ReSharper and Rider is the highlighting of matching code elements (for instance, check out Matching of control flow keywords). From 2025.1, we will help you to visually identify members that extend the base class or implement some concrete interface type. Just place the caret over the type name in the base types clause: Context Highlighters for Extended and Implemented Members Chop Formatting Context Action Our built-in formatter helps you to align your code with your preferred code formatting style settings. It can be invoked manually, through an “on-save” action, or before committing changes. Sometimes, though, you may want more control without triggering widespread formatting. A new context action lets you apply chop formatting to various C# constructs directly without needing to make a selection: Chop Parameters List Context Action Modification in Debug.Assert When writing code assertions using APIs like Debug.Assert, it’s easy to forget that these calls are stripped out in RELEASE builds. This is because methods marked with attributes like [Conditional(\"DEBUG\")] are only compiled when the DEBUG symbol is defined in the project. As a result, if the assertion condition includes side effects — such as assignments or collection mutations — those side effects will not occur in RELEASE builds. These conditional side effects are hard to spot and reason about, and they can lead to subtle bugs or unexpected behavior. Our new 2025.1 code inspection detects and warns you about such cases automatically: Modifications in Debug.Assert Inspection Inexact Stream Reads A common mistake when working with .NET’s Stream class is misusing the Read and ReadAsync methods. These methods accept a buffer (an array or a Span\u003cbyte\u003e) and are often assumed to fill it completely — but they are not guaranteed to do so. Crucially, Stream implementations are allowed to return partial data and will report the actual number of bytes read, which may be less than the buffer size. That’s why it’s essential to handle the return value from Read and ReadAsync properly and continue reading until the desired amount of data is received. Starting with our 2025.1 IDEs, incorrect usage patterns of Read and ReadAsync are automatically detected, with suggestions to replace them with the safer ReadExactly API: Inexact Stream Reads Inspection and Quick-Fix Tuple Component Names Tuple types allow you to use both explicit and generic component names. Sometimes, it is overlooked that a component can be referenced by its explicit name, e.g., MyComponent, rather than ItemN. Our new IDE hint and corresponding quick-fix help you to get rid of generic names in favor of explicit names to make your code more readable: Prefer Explicit Name for Tuple Component Inspection and Quick-Fix Referencing Enum Member Names The nameof operator was introduced in C# 6 — another case of “10 years today”! Since then, many have embraced it extensively to reference variable, type, and member names as string constants instead of using magic strings. ReSharper and Rider continue to spot situations [1, 2] in which you can make better use of them. Referencing an enum member through ToString introduces unnecessary runtime overhead due to reflection and additional processing. In 2025.1, we are adding a new inspection Use nameof expression to reference enum member name that targets such cases and provides a quick-fix to convert to nameof as a compile-time language feature that is faster, safer, and clearer: Use nameof for Reference Inspection and Quick-Fix Nameof with Unbound Generics Another new feature in C# 14 now allows using the nameof operator with unbound generics. Previously, to get List as a compile-time constant, you had to provide generic arguments — e.g., nameof(List\u003cDontCare\u003e) — even though they are not included in the final name. This friction is now removed, and you can use the open generic as in nameof(List\u003c\u003e). ReSharper and Rider identify places where generic types in nameof operators can be simplified and provide a quick-fix to remove redundancies: Redundant Type Arguments in nameof Inspection and Quick-Fix First-Class Span Types In recent years, the BCL and many other libraries have extensively adopted Span\u003cT\u003e and ReadOnlySpan\u003cT\u003e to provide more performant APIs. With C# 14, first-class support for span types is introduced through new implicit conversions between ReadOnlySpan\u003cT\u003e, Span\u003cT\u003e, and T[], which are now applied in more scenarios. This makes working with spans more intuitive and seamless. ReSharper and Rider 2025.1 fully support these updated conversion rules: Span Type Conversion Simple Lambda Parameters with Modifiers The next C# update simplifies writing lambda signatures. Previously, using parameter modifiers like ref, out, in, ref readonly, or scoped in lambdas required explicitly specifying the parameter type — for no particular reason. Starting with C# 14, this restriction has been lifted, allowing you to use these modifiers without redundant type annotations. As you’d expect, ReSharper and Rider 2025.1 offer a quick-fix to remove the now-redundant type specifications: Redundant Lambda Parameters Inspection and Quick-Fix Default Literal Suggestions C# is well-known for offering multiple ways to express the same concept (looking at you, null checks!). While flexibility has its merits, this kind of redundancy is generally not a good thing. It’s exactly why IDE tooling plays a crucial role in helping developers standardize and streamline code — ensuring consistency and reducing ambiguity. Using the default literal in non-generic contexts to represent trivial values like 0 or false can make code harder to reason about. ReSharper and Rider now help you catch such cases and offer recommendations to clarify the intent: Default Literal Inspection and Quick-Fix Conclusion Wow — that was a lot to cover! One thing’s clear: our team has poured serious effort into not just flashy new language features but also refining older ones, making them shine in fresh ways. We’d love to hear from you. Do you spot any issues or have ideas for ReSharper and Rider vNextNext? Drop them in the comments! Subscribe to a monthly digest curated from the .NET Tools blog: Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/04/csharp-language-support-in-20251-social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/dotnet/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/Frame-1321314548.svg\" alt=\"Dotnet logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eEssential productivity kit for .NET and game developers\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/dotnet/category/net-tools/\"\u003e.NET Tools\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/dotnet/category/how-tos/\"\u003eHow-To\u0026#39;s\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eC# Language Support in ReSharper and Rider 2025.1\u003c/h2\u003e                    \n                    \n\u003cp\u003eOur release for ReSharper and Rider 2025.1 is just around the corner, and we have lots of exciting features shipping for the current and next version of C#! This will be a really long post (blame our awesome devs!), so make sure to use the table of contents on the right. Oh, and of course…\u003c/p\u003e\n\n\n\n\n\n\u003cp\u003eFor many of the inspections and quick fixes discussed in this post, we recommend using either \u003ca href=\"https://www.jetbrains.com/help/rider/Inspecting_Code_in_Specific_Scope.html\" target=\"_blank\" rel=\"noopener\"\u003e\u003cem\u003efind in scope\u003c/em\u003e\u003c/a\u003e or \u003ca href=\"https://www.jetbrains.com/help/rider/Code_Analysis__Fix_in_Scope.html\" target=\"_blank\" rel=\"noopener\"\u003e\u003cem\u003efix in scope\u003c/em\u003e\u003c/a\u003e to effectively use them in your codebases. Now, let’s talk about new features!\u003c/p\u003e\n\n\n\n\u003ch2\u003eStructured Logging Support\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn ReSharper and Rider 2025.1, we enhanced support for structured and \u003ca href=\"https://learn.microsoft.com/en-us/dotnet/core/extensions/high-performance-logging\" target=\"_blank\" rel=\"noopener\"\u003ehigh-performance logging\u003c/a\u003e using the \u003ccode\u003eMicrosoft.Extensions.Logging\u003c/code\u003e APIs. Similar to how formatting arguments are highlighted in \u003ccode\u003estring.Format\u003c/code\u003e using the \u003ccode\u003e{0}\u003c/code\u003e syntax, we now highlight the corresponding type arguments in the \u003ccode\u003eLogger.Define\u003c/code\u003e and \u003ccode\u003eLoggerMessageAttribute\u003c/code\u003e API. Additionally, missing type arguments are now reported with diagnostics to catch issues early, along with quick-fixes and context actions to add or remove them as needed:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/structured-and-high-performance-logging-support.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/structured-and-high-performance-logging-support.gif\" alt=\"Structured and High-Performance Logging Support\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eStructured and High-Performance Logging Support\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eString Construction Context Actions\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eOur .NET IDEs offer a wide range of suggestions and context actions for working with C# string literals, interpolated strings, \u003ccode\u003estring.Format\u003c/code\u003e, and \u003ccode\u003eStringBuilder\u003c/code\u003e constructs. You can convert nearly any string-related expression into various other forms to enhance readability or to better parameterize string construction.\u003c/p\u003e\n\n\n\n\u003cp\u003eHowever, some conversion directions were still missing. For example, while it’s been easy to convert a concatenated string like \u003ccode\u003e\u0026#34;Id = \u0026#34; + someId\u003c/code\u003e into either an interpolated string \u003ccode\u003e$\u0026#34;Id = {someId}\u0026#34;\u003c/code\u003e or a format string \u003ccode\u003estring.Format(\u0026#34;Id = {0}\u0026#34;, someId)\u003c/code\u003e, there hasn’t been a way to reverse this — i.e., to convert interpolated or formatted strings back into concatenation. In certain scenarios, such a transformation can actually result in more concise or readable code:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/convert-interpolation-to-concatenation-context-action.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/convert-interpolation-to-concatenation-context-action.gif\" alt=\"Convert Interpolation to Concatenation Context Action\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eConvert Interpolation to Concatenation Context Action\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eImproved Multiline To-Do Comments\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn the previous release, we introduced support for multiline to-do comments, where subsequent lines were considered part of the same item based on their indentation. In the 2025.1 release, we’ve enhanced this feature by making indentation optional. Now, lines following a to-do comment are automatically treated as part of the same item, even without indentation, making multiline comments more intuitive and seamless. However, if indentation is used, it will be strictly enforced:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/improved-multiline-to-do-comments.png\" alt=\"Improved Multiline To-Do Comments\" width=\"660\"/\u003e\n   \u003cfigcaption\u003eImproved Multiline To-Do Comments\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eLanguage Injection in Return Values\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eLanguage injection made its debut in ReSharper around 10 years ago with \u003ca href=\"https://blog.jetbrains.com/dotnet/2014/10/27/regular-expression-support-in-resharper-9/\"\u003esupport for regular expressions\u003c/a\u003e. Since then, it has been \u003ca href=\"https://blog.jetbrains.com/dotnet/2017/03/21/language-injections-rider/\"\u003ebrought to Rider, expanded to other languages\u003c/a\u003e, and \u003ca href=\"https://blog.jetbrains.com/dotnet/2023/01/12/language-injection-improvements-in-rider-2022-3/#better-with-c-11\"\u003eupdated to work with new language and runtime features\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003ePreviously, the \u003ccode\u003eLanguageInjection\u003c/code\u003e attribute (from \u003ca href=\"https://blog.jetbrains.com/dotnet/2018/05/03/what-are-jetbrains-annotations/\"\u003e\u003ccode\u003eJetBrains.Annotations\u003c/code\u003e\u003c/a\u003e) could only be applied to parameters, fields, and properties. Now you can annotate methods to specify that their returned strings represent an embedded code of another language:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/language-injection-in-return-values.png\" alt=\"Language Injection in Return Values\" width=\"660\"/\u003e\n   \u003cfigcaption\u003eLanguage Injection in Return Values\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003eRedundant Duplicated Code\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn the previous two versions, we introduced inspections for more specific scenarios of code duplication — \u003ca href=\"https://blog.jetbrains.com/dotnet/2024/08/07/escape-character-extract-common-code-params-modifier-out-vars-csharp-language-support-in-2024-2/#extract-common-code\"\u003ecommon code in \u003ccode\u003eif\u003c/code\u003e and \u003ccode\u003eswitch\u003c/code\u003e statements\u003c/a\u003e and \u003ca href=\"https://blog.jetbrains.com/dotnet/2024/11/12/csharp-language-support-in-resharper-and-rider-2024-3/#merge-switch-case-sections\"\u003eduplicated \u003ccode\u003eswitch\u003c/code\u003e section bodies\u003c/a\u003e. In this 2025.1 release, we deliver three new inspections to help you eliminate unintentional duplications and improve readability and maintainability in your codebase.\u003c/p\u003e\n\n\n\n\u003cp\u003eOur first inspection detects duplicated statements that appear both within conditional branches of \u003ccode\u003eif\u003c/code\u003e and \u003ccode\u003eswitch\u003c/code\u003e statements ending with jump statements and again immediately afterward:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/duplicated-statements-in-conditional-branches-inspection-and-quick-fix.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/duplicated-statements-in-conditional-branches-inspection-and-quick-fix.gif\" alt=\"Duplicated Statements in Conditional Branches Inspection and Quick-Fix\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eDuplicated Statements in Conditional Branches Inspection and Quick-Fix\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003eAnother inspection detects redundant arms in switch expressions — specifically, arms that return the same value as the default one. Removing these redundancies simplifies your code and improves readability:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/redundant-switch-expression-arms-inspection-and-quick-fix.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/redundant-switch-expression-arms-inspection-and-quick-fix.gif\" alt=\"Redundant switch Expression Arms Inspection and Quick-Fix\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eRedundant switch Expression Arms Inspection and Quick-Fix\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe last inspection detects when multiple \u003ccode\u003eif\u003c/code\u003e branches execute identical code and provides a handy quick-fix to merge them:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/duplicated-if-bodies-inspection-and-quick-fix.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/duplicated-if-bodies-inspection-and-quick-fix.gif\" alt=\"Duplicated if Bodies Inspection and Quick-Fix\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eDuplicated if Bodies Inspection and Quick-Fix\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003eMisuse of CancellationToken\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen working with asynchronous methods, it’s common to pass a \u003ccode\u003eCancellationToken\u003c/code\u003e through parameters of local functions or lambda expressions. Accidentally using a method-level token instead of a more specific, locally scoped one can lead to unintended behavior, such as tasks not being canceled when expected.\u003c/p\u003e\n\n\n\n\u003cp\u003eReSharper and Rider 2025.1 introduce a new inspection that detects when a broader-scoped cancellation token is mistakenly used instead of a more appropriate local token available within a local function or lambda. You can choose from two corresponding quick-fixes to either a) replace the mistakenly used token with the correct local token, or b) link both tokens into one using \u003ccode\u003eCancellationTokenSource.CreateLinkedTokenSource\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/possibly-mistaken-use-of-cancellationtoken-inspection.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/possibly-mistaken-use-of-cancellationtoken-inspection.gif\" alt=\"Possibly Mistaken Use of CancellationToken Inspection\" width=\"660\"/\u003e\n    \u003cfigcaption\u003ePossibly Mistaken Use of CancellationToken Inspection\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eInjection Postfix Template\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003ePrimary constructors in C# 12 greatly simplify constructor dependency injection patterns. You only need to mention a dependency once in the constructor parameter list, and it automatically becomes available across all instance members of the class without the need to define and assign a field explicitly.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn ReSharper and Rider 2025.1, we introduce a new \u003ccode\u003einject\u003c/code\u003e postfix template available for type names. When you realize you need to add a dependency on \u003ccode\u003eIService\u003c/code\u003e, select it from the completion list, append \u003ccode\u003e.inject\u003c/code\u003e, and hit your completion key:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/inject-postfix-template.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/inject-postfix-template.gif\" alt=\"Inject Postfix Template\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eInject Postfix Template\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003eTransform Parameters Refactoring\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe \u003ca href=\"https://www.jetbrains.com/help/rider/Refactorings_Transform_Parameters.html\" target=\"_blank\" rel=\"noopener\"\u003etransform parameters refactoring\u003c/a\u003e makes it easy to change a method’s signature by modifying its parameters — for example, removing \u003ccode\u003eout\u003c/code\u003e parameters, wrapping them in a tuple or a new class, and more — while automatically updating all usages of the method across your solution.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith ReSharper and Rider 2025.1, we reworked the refactoring to support modern language features (including tuple types, record classes, and primary constructors), treat tuple elements as multiple return values, transform \u003ccode\u003eref\u003c/code\u003e parameters into both input and output values, and handle lots of deconstruction usages. Bring up the dialog, select the parameters you want to transform, and choose your desired target types:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/transform-parameters-refactoring-dialog.png\" alt=\"Transform Parameters Refactoring Dialog\" width=\"686\"/\u003e\n   \u003cfigcaption\u003eTransform Parameters Refactoring Dialog\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eContext Highlighters for Extended Types\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eOne of the very subtle features in ReSharper and Rider is the \u003ca href=\"https://www.jetbrains.com/help/rider/Coding_Assistance__Matching_Delimiters.html\" target=\"_blank\" rel=\"noopener\"\u003ehighlighting of matching code elements\u003c/a\u003e (for instance, check out \u003cem\u003eMatching of control flow keywords\u003c/em\u003e). From 2025.1, we will help you to visually identify members that extend the base class or implement some concrete interface type. Just place the caret over the type name in the base types clause:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/context-highlighters-for-extended-and-implemented-members.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/context-highlighters-for-extended-and-implemented-members.gif\" alt=\"Context Highlighters for Extended and Implemented Members\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eContext Highlighters for Extended and Implemented Members\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eChop Formatting Context Action\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eOur built-in formatter helps you to align your code with your preferred code formatting style settings. It can be invoked manually, through an \u003ca href=\"https://www.jetbrains.com/help/rider/Enforcing_Code_Formatting_Rules.html#run-code-cleanup-automatically-on-save\" target=\"_blank\" rel=\"noopener\"\u003e“on-save” action\u003c/a\u003e, or \u003ca href=\"https://www.jetbrains.com/help/rider/Enforcing_Code_Formatting_Rules.html#reformat_before_commit\" target=\"_blank\" rel=\"noopener\"\u003ebefore committing changes\u003c/a\u003e. Sometimes, though, you may want more control without triggering widespread formatting. A new context action lets you apply chop formatting to various C# constructs directly without needing to make a selection:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/chop-parameters-list-context-action.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/chop-parameters-list-context-action.gif\" alt=\"Chop Parameters List Context Action\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eChop Parameters List Context Action\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eModification in Debug.Assert\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen writing code assertions using APIs like \u003ccode\u003eDebug.Assert\u003c/code\u003e, it’s easy to forget that these calls are stripped out in \u003ccode\u003eRELEASE\u003c/code\u003e builds. This is because methods marked with attributes like \u003ccode\u003e[Conditional(\u0026#34;DEBUG\u0026#34;)]\u003c/code\u003e are only compiled when the \u003ccode\u003eDEBUG\u003c/code\u003e symbol is defined in the project. As a result, if the assertion condition includes side effects — such as assignments or collection mutations — those side effects will \u003cem\u003enot\u003c/em\u003e occur in \u003ccode\u003eRELEASE\u003c/code\u003e builds. These conditional side effects are hard to spot and reason about, and they can lead to subtle bugs or unexpected behavior.\u003c/p\u003e\n\n\n\n\u003cp\u003eOur new 2025.1 code inspection detects and warns you about such cases automatically:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/modifications-in-debugassert-inspection.png\" alt=\"Modifications in Debug.Assert Inspection\" width=\"660\"/\u003e\n   \u003cfigcaption\u003eModifications in Debug.Assert Inspection\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eInexact Stream Reads\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eA common mistake when working with .NET’s \u003ccode\u003eStream\u003c/code\u003e class is misusing the \u003ccode\u003eRead\u003c/code\u003e and \u003ccode\u003eReadAsync\u003c/code\u003e methods. These methods accept a buffer (an array or a \u003ccode\u003eSpan\u0026lt;byte\u0026gt;\u003c/code\u003e) and are often assumed to fill it \u003cem\u003ecompletely \u003c/em\u003e— but they are not guaranteed to do so. Crucially, \u003ccode\u003eStream\u003c/code\u003e implementations are allowed to return partial data and will report the actual number of bytes read, which may be less than the buffer size. That’s why it’s essential to handle the return value from \u003ccode\u003eRead\u003c/code\u003e and \u003ccode\u003eReadAsync\u003c/code\u003e properly and continue reading until the desired amount of data is received.\u003c/p\u003e\n\n\n\n\u003cp\u003eStarting with our 2025.1 IDEs, incorrect usage patterns of \u003ccode\u003eRead\u003c/code\u003e and \u003ccode\u003eReadAsync\u003c/code\u003e are automatically detected, with suggestions to replace them with the safer \u003ccode\u003eReadExactly\u003c/code\u003e API:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/inexact-stream-reads-inspection-and-quick-fix.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/inexact-stream-reads-inspection-and-quick-fix.gif\" alt=\"Inexact Stream Reads Inspection and Quick-Fix\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eInexact Stream Reads Inspection and Quick-Fix\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eTuple Component Names\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eTuple types allow you to use both explicit and generic component names. Sometimes, it is overlooked that a component can be referenced by its explicit name, e.g., \u003ccode\u003eMyComponent\u003c/code\u003e, rather than \u003ccode\u003eItemN\u003c/code\u003e. Our new IDE hint and corresponding quick-fix help you to get rid of generic names in favor of explicit names to make your code more readable:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/prefer-explicit-name-for-tuple-component-inspection-and-quick-fix.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/prefer-explicit-name-for-tuple-component-inspection-and-quick-fix.gif\" alt=\"Prefer Explicit Name for Tuple Component Inspection and Quick-Fix\" width=\"660\"/\u003e\n    \u003cfigcaption\u003ePrefer Explicit Name for Tuple Component Inspection and Quick-Fix\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eReferencing Enum Member Names\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe \u003ca href=\"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/nameof\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003enameof\u003c/code\u003e operator was introduced in C# 6\u003c/a\u003e — another case of “10 years today”! Since then, many have embraced it extensively to reference variable, type, and member names as string constants instead of using magic strings. ReSharper and Rider continue to spot situations [\u003ca href=\"https://blog.jetbrains.com/dotnet/2015/04/15/c-6-0-support-in-resharper-9-1/\"\u003e1\u003c/a\u003e, \u003ca href=\"https://blog.jetbrains.com/dotnet/2023/03/06/required-keyword-checked-operators-nameof-operator-scope-using-csharp-11-in-rider-and-resharper/#nameof-operator-scope\"\u003e2\u003c/a\u003e] in which you can make better use of them. Referencing an enum member through \u003ccode\u003eToString\u003c/code\u003e introduces unnecessary runtime overhead due to reflection and additional processing.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn 2025.1, we are adding a new inspection \u003cem\u003eUse \u003ccode\u003enameof\u003c/code\u003e expression to reference enum member name\u003c/em\u003e that targets such cases and provides a quick-fix to convert to \u003ccode\u003enameof\u003c/code\u003e as a compile-time language feature that is faster, safer, and clearer:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/use-nameof-for-reference-inspection-and-quick-fix.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/use-nameof-for-reference-inspection-and-quick-fix.gif\" alt=\"Use nameof for Reference Inspection and Quick-Fix\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eUse nameof for Reference Inspection and Quick-Fix\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eNameof with Unbound Generics\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eAnother new feature in C# 14 now allows using the \u003ca href=\"https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-14#unbound-generic-types-and-nameof\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003enameof\u003c/code\u003e operator with unbound generics\u003c/a\u003e. Previously, to get \u003ccode\u003eList\u003c/code\u003e as a compile-time constant, you had to provide generic arguments — e.g., \u003ccode\u003enameof(List\u0026lt;DontCare\u0026gt;)\u003c/code\u003e — even though they are not included in the final name. This friction is now removed, and you can use the open generic as in \u003ccode\u003enameof(List\u0026lt;\u0026gt;)\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eReSharper and Rider identify places where generic types in \u003ccode\u003enameof\u003c/code\u003e operators can be simplified and provide a quick-fix to remove redundancies:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/redundant-type-arguments-in-nameof-inspection-and-quick-fix.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/redundant-type-arguments-in-nameof-inspection-and-quick-fix.gif\" alt=\"Redundant Type Arguments in nameof Inspection and Quick-Fix\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eRedundant Type Arguments in nameof Inspection and Quick-Fix\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eFirst-Class Span Types\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn recent years, the BCL and many other libraries have extensively adopted \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e and \u003ccode\u003eReadOnlySpan\u0026lt;T\u0026gt;\u003c/code\u003e to provide more performant APIs. With C# 14, \u003ca href=\"https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-14#implicit-span-conversions\" target=\"_blank\" rel=\"noopener\"\u003efirst-class support for span types is introduced through new implicit conversions\u003c/a\u003e between \u003ccode\u003eReadOnlySpan\u0026lt;T\u0026gt;\u003c/code\u003e, \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e, and \u003ccode\u003eT[]\u003c/code\u003e, which are now applied in more scenarios. This makes working with spans more intuitive and seamless. ReSharper and Rider 2025.1 fully support these updated conversion rules:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/span-type-conversion.png\" alt=\"Span Type Conversion\" width=\"660\"/\u003e\n   \u003cfigcaption\u003eSpan Type Conversion\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eSimple Lambda Parameters with Modifiers\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe next C# update \u003ca href=\"https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-14#simple-lambda-parameters-with-modifiers\" target=\"_blank\" rel=\"noopener\"\u003esimplifies writing lambda signatures\u003c/a\u003e. Previously, using parameter modifiers like \u003ccode\u003eref\u003c/code\u003e, \u003ccode\u003eout\u003c/code\u003e, \u003ccode\u003ein\u003c/code\u003e, \u003ccode\u003eref readonly\u003c/code\u003e, or \u003ccode\u003escoped\u003c/code\u003e in lambdas required explicitly specifying the parameter type — for no particular reason. Starting with C# 14, this restriction has been lifted, allowing you to use these modifiers without redundant type annotations.\u003c/p\u003e\n\n\n\n\u003cp\u003eAs you’d expect, ReSharper and Rider 2025.1 offer a quick-fix to remove the now-redundant type specifications:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/redundant-lambda-parameters-inspection-and-quick-fix.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/redundant-lambda-parameters-inspection-and-quick-fix.gif\" alt=\"Redundant Lambda Parameters Inspection and Quick-Fix\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eRedundant Lambda Parameters Inspection and Quick-Fix\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cb\u003eDefault Literal Suggestions\u003c/b\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eC# is well-known for offering multiple ways to express the same concept (looking at you, null checks!). While flexibility has its merits, this kind of redundancy is generally not a good thing. It’s exactly why IDE tooling plays a crucial role in helping developers standardize and streamline code — ensuring consistency and reducing ambiguity.\u003c/p\u003e\n\n\n\n\u003cp\u003eUsing the \u003ccode\u003edefault\u003c/code\u003e literal in non-generic contexts to represent trivial values like \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e can make code harder to reason about. ReSharper and Rider now help you catch such cases and offer recommendations to clarify the intent:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/default-literal-inspection-and-quick-fix.jpg\" data-gif-src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/default-literal-inspection-and-quick-fix.gif\" alt=\"Default Literal Inspection and Quick-Fix\" width=\"660\"/\u003e\n    \u003cfigcaption\u003eDefault Literal Inspection and Quick-Fix\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eWow — that was a lot to cover! One thing’s clear: our team has poured serious effort into not just flashy new language features but also refining older ones, making them shine in fresh ways.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe’d love to hear from you. Do you spot any issues or have ideas for ReSharper and Rider \u003ccode\u003evNextNext\u003c/code\u003e? Drop them in the comments!\u003c/p\u003e\n\n\n\n\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to a monthly digest curated from the .NET Tools blog:\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": null,
  "modifiedTime": null
}
