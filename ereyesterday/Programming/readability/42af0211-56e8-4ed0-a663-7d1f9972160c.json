{
  "id": "42af0211-56e8-4ed0-a663-7d1f9972160c",
  "title": "Module Import Declarations: No More Import Hell",
  "link": "https://blog.jetbrains.com/idea/2025/07/module-import-declarations-no-more-import-hell/",
  "description": "Imagine you are proud of yourself for creating an amazing Java application, framework, or a library. You open one of its source files to make some changes and this is what you see: While looking at this long list of imports, are you wondering why you need to know the name of every single class […]",
  "author": "Mala Gupta",
  "published": "Tue, 01 Jul 2025 11:05:32 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "tutorials",
    "java25",
    "module-import-declarations"
  ],
  "byline": "Mala Gupta",
  "length": 17532,
  "excerpt": "Find out how Module Import Declarations can help address the import hell for you.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA – the IDE for Professional Development in Java and Kotlin TutorialsModule Import Declarations: No More Import Hell  Imagine you are proud of yourself for creating an amazing Java application, framework, or a library. You open one of its source files to make some changes and this is what you see: import java.lang.reflect.*; import java.nio.file.Path; import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.List; import java.util.stream.Collector; import java.util.concurrent.CompletableFuture; import java.util.concurrent.locks.ReadWiteLock; import java.time.LocalDateTime; // more import statements While looking at this long list of imports, are you wondering why you need to know the name of every single class or interface used in your class (apart from its configuration)? It seems like a cognitive load to me. Most of the developers I know collapse this section in their IDE and don’t bother expanding it. The business logic in this source file probably starts after line twenty. Can you do something about it because importing packages won’t help much. Don’t worry, Module Import Declarations can help address this import hell for you. What is ‘Module Import Declarations’? Introduced as a preview feature in Java 23 and a production feature in Java 25, Module import declarations enable you to import an entire module using a single import statement. In the above example, you can replace all the import statements with the following line of code, since all those packages are defined as part of the java.base module: import module java.base.*; Yes, just one line of code. The source file can now use List, Map, Stream, Path, and many more classes. As a developer, you no longer need to think about which package they live in. With this single statement, you can import all of the packages exported by the module java.base. Why should you care about this feature? Apart from the obvious benefits of concise code and escaping from the import hell, this feature helps us developers focus on solving business problems rather than finding the fully qualified names for classes or interfaces to use. Do you think it is worth your time to find out whether the interface Function is defined in the package java.util.function or java.util?. An intelligent IDE such as IntelliJ IDEA helps you to get around it by adding the relevant imports as soon as you use a type in your code (more about it in a later section in this blog post). It offers convenience for new developers. Imagine you are a new Java developer. Would you prefer having an umbrella import statement so that you need not be bothered about knowing which package defines the commonly used data structures, such as List, Map, or Stream? If you are teaching Java, talking about importing classes interfaces from packages before folks get comfortable using basic data structures could make them lose focus. It would be better for them to get started writing programs that use List and Stream, rather than having them figure out which Java package defines them. Module import declarations help beginners focus on learning Java without getting confused or frustrated by things they don’t need to worry about yet. It enables faster prototyping. When we are prototyping, we try to get things to work as quickly as possible. In such cases, an umbrella import statement, such as the import module declaration, lets us jump straight into coding. It also keeps the code concise, cleaner and easier to read when we are using large APIs. But this doesn’t imply that you should define your code in a module to use a module import statement. Before moving forward, let’s cover the IntelliJ IDEA configurations for using this feature. IntelliJ IDEA Configuration Import Module declaration was introduced as a preview feature in Java 23 and IntelliJ IDEA has supported this feature since version 2024.3. In soon to be released Java 25, it becomes a production feature (it is now a permanent language feature, and safe to use in your production code).  Java 25 is scheduled to be released in September 2025. To use this feature as a production feature (without needing the --enable-preview flag during compilation and runtime), you should download the early access version of JDK. You can also do this from IntelliJ IDEA’s settings dialog (Yes! IntelliJ IDEA allows you to download and configure EA versions of the JDK): In your Project Settings, set the SDK to Java 25. For the language level, select ‘X – Experimental features’ on both the Project and Modules tabs. This enables you to use all Java 25 features, including those currently under review. Java 25 is due to be released in September 2025, and we at JetBrains are working on adding more support. New language options will be accessible in IntelliJ IDEA soon. More about Module Import Declarations Knowing why we need a feature is the first step to using it. Let’s look at how to use it and also answer some frequently asked questions from developers about this feature. Syntax of Module Import Declarations The syntax is simple. It starts with the keyword import, followed by module and the name of the module (without a wildcard, that is, *): import module java.base.*; This feature doesn’t work with unnamed modules. Revisit the syntax of this feature: it requires you to name the module you want to import. The example in this section imports the java.base module. How to determine the fully qualified name of types in your source code? Are you wondering how to determine the fully qualified name of a type or variable in your source code when using import module declarations? This was one of the main reasons for using individual imports in source files. This applies to all types of imports, including wildcard and static imports. Move your cursor to the type in a variable declaration and use the Quick Documentation feature (Ctrl+Q for Win/Linux, or F1 on macOS) to view a documentation popup that shows the package name at the top, followed by the name and its documentation—without having to open another source file in your editor window. You can also use the Quick Definition feature (Ctrl+Shift+I) to view the fully qualified name, along with the definitions of its members, in a popup window. Alternatively, you can hover over the type using your mouse to view the fully qualified name. On a separate note, if you don’t like showing Quick Documentation popups on mouse hover, you can clear the ‘Show quick documentation on hover’ checkbox in the settings (find it using Shift+Shift). If you want to browse the source code of the used type, use the ‘Go to Declaration or Usages’ feature (Ctrl+B / Cmd+B), which opens the source code in a new editor window. In the next section, let’s see how to use the import module statement with different libraries or APIs. How to import JUnit 3.8.1 using import module declaration? I know it is an old version, but it is still around and in use. How would you import classes and interfaces defined in JUnit 3.8.1 (if you had to) in your source files? To import it using an import module declaration, you must use its module name. The short answer is you cannot because there is no module name for it. JUnit 3.8.1 was created before Java 9 introduced modules. What about other libraries? How do we find their module names? We usually use build tools, such as Maven, to import dependencies as jar files. If a dependency supports modules, its jar file includes module-info.class (mandatory for modules), which contains the module name. You’ll notice that the JUnit 3.8.1 jar doesn’t include module-info.class. IntelliJ IDEA users can view module info in External libraries, in the Project Structure window, as  shown below: Of course, you could ask the AI Chat window in IntelliJ IDEA how to find these module names. Which packages are exported by the modules you import? Each module defines a module-info.java file that includes information about the packages that module exports to all modules or to specific other modules.  Let’s try to understand this by checking out what happens when you import the module java.base using IntelliJ IDEA. Click on the module name in the editor or use the relevant shortcut (Go to Declaration or Usages) and you could view the definition of this module to find out all the modules exported by this module. This is shown in the following gif: The public API in these packages are available to source files that import these modules. What do you mean by on-demand import? Developers often argue about importing a single class or interface versus importing all public entities by importing a package using a wildcard character. Which of these do you think is better? When you import a module or a package using a wildcard (*), you import types on demand. This means you can use any public class, interface, or entity from a package or module without importing each one individually. Often, developers ask if importing a full module increases the size of their .class files. The short answer is no. On-demand imports make all public classes and interfaces in the module available to use in a source file, but the compiler includes only those that are actually used in your code. Name conflicts (compilation error) When you import one or more modules, it is possible that packages within the same module or across modules define classes with the same name. For an example, in the example code below, code at line number 5 (Date date;) won’t compile because importing java.base module makes java.util.Date class available, and importing the java.sql module makes java.sql.Date available: 1.    import module java.base;  // Makes available java.util.Date 2.    import module java.sql;   // Makes available java.sql.Date 3.  4.    public class NameConflicts { 5.        Date date;  // compilation error 6.    } Let’s assume you want to use the Date class from module java.sql. To address this issue, you could either add a single import statement, as follows: 1.    import module java.base;  // Makes available java.util.Date 2.    import module java.sql;   // Makes available java.sql.Date 3.    import java.sql.Date; 4.     5.    public class NameConflicts { 6.        Date date;   7.    } You could also resolve it by using a fully qualified class name, as follows: 1.    import module java.base;  // Makes available java.util.Date 2.    import module java.sql;   // Makes available java.sql.Date 3.  4.    public class NameConflicts { 5.        java.sql.Date date;   6.    } IntelliJ IDEA can highlight name conflicts as you type your code. Invoke context actions to view a list of qualified class names (package name + class name) to choose from, as shown below: If you are wondering whether it is a good idea to import modules since it could lead to namespace conflicts, these issues can occur with importing packages too. Don’t worry; it results in a compilation error and can be fixed easily. Also, a module and one of the packages it includes can have the same name. Notice that the module java.sql contains a package java.sql. The fully qualified name of a class or an interface includes its package name, not the name of the module the package is defined in. Compact Source Files integration Gavin Bierman mentioned that the idea of this Import Module Declarations came up while the Java team was working on JEP Compact Source Files and Instance main Methods, which aim to reduce the ceremony to learning Java.  Compact source files implicitly import the module java.base. It implies that the new developers can use any public class or interface from the multiple packages exported by the java.base module, without explicit import statements. JShell Integration One of the main benefits of using JShell is that it allows you to quickly evaluate expressions, execute code statements or snippets (and much more) without the ceremony of defining classes. Prior to Import Module Declarations, JShell automatically imported the ten most used packages (and java.lang) so that developers could easily use those classes or interfaces without explicit import statements. However, you still need import statements for classes or interfaces not defined in these packages, such as the LocalDateTime class from the package java.time: With import module declarations, JShell automatically imports the module java.base. This helps developers use many more classes (such as LocalDateTime), without needing explicit import statement, as shown in the following image: One import statement to use the entire standard Java API By importing the java.se module you can use the entire standard Java API in your source file. Here’s the module information for this module: The java.se module is an aggregator module. It does not export any package, but requires other modules transitively. In other words, source files importing java.se import the packages exported by modules that are marked required transitive in java.se. Interview with creators of this feature We also interviewed the owner of this feature, Gavin Bierman, Programming Language Designer at Oracle. Gavin mentioned that this feature was co-developed with the JEP Compact Source Files and Instance Main Methods. He covered the differences between single-type imports and type-import-on-demand declarations, explaining what they are and why individuals and organizations prefer one style over the other. He also talked about how the “Module Import Declarations” feature automatically imports on demand from transitive dependencies of modules. He discussed ambiguous imports and how to deal with them, name ambiguity, and how to submit relevant feedback on this feature to the teams at OpenJDK. Practical Tips Practical tips and wisdom are always useful when using a feature. Migrating your codebases to use import module declarations I’d recommend not replacing all the individual import statements or package statements with import module statements in your codebase. Try module imports in new files or when you’re already touching existing code. This feature is syntactic sugar; it makes your code more readable but doesn’t offer any performance benefits. The folks who maintain your code are more important than using the latest shiny features in your codebase. If they understand the code in its existing format, respect that. Group Your Imports With module imports, Java offers multiple types of imports, such as, importing modules, importing packages, importing classes/interfaces, and static imports of fields or methods. Grouping imports could make them more readable. IntelliJ IDEA supports importing types as you type them Whether you are copy-pasting code or typing it, IntelliJ IDEA adds the relevant imports to your codebase, either automatically or by prompting you to select the correct version to import, as shown in the following gif: Just in case, the preceding settings don’t work for you, ensure you have enabled the relevant import settings in ‘Intentions’ (use IntelliJ IDEA Settings), as follows: If you haven’t been using this feature in IntelliJ IDEA, you are missing out on a great user experience. Summary Introduced as a preview feature in Java 23 and a production feature in Java 25, Module Import Declarations allow importing an entire module with a single import statement. Apart from the obvious benefits of replacing multiple import statements with a single import, this feature helps us developers escape import hell. It works only with named modules, not unnamed ones or older libraries without module definitions (such as JUnit 3.8.1). Classes and interfaces are imported on demand. Importing a module makes its public classes/interfaces available, but only those actually used are included by the compiler. Importing multiple modules might lead to class name conflicts, requiring specific imports or fully qualified names. JShell and compact source files automatically import java.base with this feature. If you want to extend it, try importing the java.se module, which provides access to the entire standard Java API. The release of Java 25 is scheduled for September, but IntelliJ IDEA already supports this feature. Try it out and let us know your feedback. Happy coding. Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/06/IJ-social-BlogSocialShare-1280x720-2x-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA – the IDE for Professional Development in Java and Kotlin\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/category/tutorials/\"\u003eTutorials\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eModule Import Declarations: No More Import Hell \u003c/h2\u003e                    \n                    \n\u003cp\u003eImagine you are proud of yourself for creating an amazing Java application, framework, or a library. You open one of its source files to make some changes and this is what you see:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport java.lang.reflect.*;\nimport java.nio.file.Path;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collector;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.locks.ReadWiteLock;\nimport java.time.LocalDateTime;\n// more import statements\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhile looking at this long list of imports, are you wondering why you need to know the name of every single class or interface used in your class (apart from its configuration)? It seems like a cognitive load to me. Most of the developers I know collapse this section in their IDE and don’t bother expanding it.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe business logic in this source file probably starts after line twenty. Can you do something about it because importing packages won’t help much. Don’t worry, \u003ca href=\"https://openjdk.org/jeps/511\" target=\"_blank\" rel=\"noopener\"\u003eModule Import Declarations\u003c/a\u003e can help address this import hell for you.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhat is ‘Module Import Declarations’?\u003c/h2\u003e\n\n\n\n\u003cp\u003eIntroduced as a preview feature in Java 23 and a production feature in Java 25, \u003ca href=\"https://openjdk.org/jeps/511\" target=\"_blank\" rel=\"noopener\"\u003eModule import declarations\u003c/a\u003e enable you to import an entire module using a single import statement. In the above example, you can replace all the import statements with the following line of code, since all those packages are defined as part of the \u003ccode\u003ejava.base\u003c/code\u003e module:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport module java.base.*;\u003c/pre\u003e\n\n\n\n\u003cp\u003eYes, just one line of code. The source file can now use \u003ccode\u003eList\u003c/code\u003e, \u003ccode\u003eMap\u003c/code\u003e, \u003ccode\u003eStream\u003c/code\u003e, \u003ccode\u003ePath\u003c/code\u003e, and many more classes. As a developer, you no longer need to think about which package they live in. With this single statement, you can import all of the packages exported by the module \u003ccode\u003ejava.base\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhy should you care about this feature?\u003c/h2\u003e\n\n\n\n\u003cp\u003eApart from the obvious benefits of concise code and escaping from the import hell, this feature helps us developers focus on \u003ci\u003esolving business problems\u003c/i\u003e rather than finding the fully qualified names for classes or interfaces to use. Do you think it is worth your time to find out whether the interface \u003ccode\u003eFunction\u003c/code\u003e is defined in the package \u003ccode\u003ejava.util.function\u003c/code\u003e or \u003ccode\u003ejava.util\u003c/code\u003e?. An intelligent IDE such as IntelliJ IDEA helps you to get around it by adding the relevant imports as soon as you use a type in your code (more about it in a later section in this blog post).\u003c/p\u003e\n\n\n\n\u003cp\u003eIt offers \u003ci\u003econvenience\u003c/i\u003e for new developers. Imagine you are a new Java developer. Would you prefer having an umbrella import statement so that you need not be bothered about knowing which package defines the commonly used data structures, such as List, Map, or Stream? If you are teaching Java, talking about importing classes interfaces from packages before folks get comfortable using basic data structures could make them lose focus. It would be better for them to get started writing programs that use List and Stream, rather than having them figure out which Java package defines them. Module import declarations help beginners focus on learning Java without getting confused or frustrated by things they don’t need to worry about yet.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt enables \u003ci\u003efaster prototyping\u003c/i\u003e. When we are prototyping, we try to get things to work as quickly as possible. In such cases, an umbrella import statement, such as the import module declaration, lets us jump straight into coding. It also keeps the code concise, cleaner and easier to read when we are using large APIs. But this doesn’t imply that you should define your code in a module to use a module import statement.\u003c/p\u003e\n\n\n\n\u003cp\u003eBefore moving forward, let’s cover the IntelliJ IDEA configurations for using this feature.\u003c/p\u003e\n\n\n\n\u003ch2\u003eIntelliJ IDEA Configuration\u003c/h2\u003e\n\n\n\n\u003cp\u003eImport Module declaration was introduced as a preview feature in Java 23 and IntelliJ IDEA has supported this feature since version 2024.3. In soon to be released Java 25, it becomes a production feature (it is now a permanent language feature, and safe to use in your production code). \u003c/p\u003e\n\n\n\n\u003cp\u003eJava 25 is scheduled to be released in September 2025. To use this feature as a production feature (without needing the \u003ccode\u003e--enable-preview\u003c/code\u003e flag during compilation and runtime), you should download the early access version of JDK. You can also do this from IntelliJ IDEA’s settings dialog (Yes! IntelliJ IDEA allows you to download and configure EA versions of the JDK):\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1600\" height=\"742\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/07/image.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn your Project Settings, set the SDK to Java 25. For the language level, select ‘X – Experimental features’ on both the Project and Modules tabs. This enables you to use all Java 25 features, including those currently under review. Java 25 is due to be released in September 2025, and we at JetBrains are working on adding more support. New language options will be accessible in IntelliJ IDEA soon.\u003c/p\u003e\n\n\n\n\u003ch2\u003eMore about Module Import Declarations\u003c/h2\u003e\n\n\n\n\u003cp\u003eKnowing why we need a feature is the first step to using it. Let’s look at how to use it and also answer some frequently asked questions from developers about this feature.\u003c/p\u003e\n\n\n\n\u003ch3\u003eSyntax of Module Import Declarations\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe syntax is simple. It starts with the keyword \u003ccode\u003eimport\u003c/code\u003e, followed by module and the name of the module (without a wildcard, that is, \u003ccode\u003e*\u003c/code\u003e):\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport module java.base.*;\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis feature doesn’t work with unnamed modules. Revisit the syntax of this feature: it requires you to name the module you want to import. The example in this section imports the \u003ccode\u003ejava.base\u003c/code\u003e module. \u003c/p\u003e\n\n\n\n\u003ch3\u003eHow to determine the fully qualified name of types in your source code?\u003c/h3\u003e\n\n\n\n\u003cp\u003eAre you wondering how to determine the fully qualified name of a type or variable in your source code when using import module declarations? This was one of the main reasons for using individual imports in source files. This applies to all types of imports, including wildcard and static imports.\u003c/p\u003e\n\n\n\n\u003cp\u003eMove your cursor to the type in a variable declaration and use the Quick Documentation feature (Ctrl+Q for Win/Linux, or F1 on macOS) to view a documentation popup that shows the package name at the top, followed by the name and its documentation—without having to open another source file in your editor window. You can also use the Quick Definition feature (Ctrl+Shift+I) to view the fully qualified name, along with the definitions of its members, in a popup window. Alternatively, you can hover over the type using your mouse to view the fully qualified name.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"3228\" height=\"1866\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/fully-qualified-name.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOn a separate note, if you don’t like showing Quick Documentation popups on mouse hover, you can clear the ‘Show quick documentation on hover’ checkbox in the settings (find it using Shift+Shift). If you want to browse the source code of the used type, use the ‘Go to Declaration or Usages’ feature (Ctrl+B / Cmd+B), which opens the source code in a new editor window.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn the next section, let’s see how to use the import module statement with different libraries or APIs.\u003c/p\u003e\n\n\n\n\u003ch3\u003eHow to import JUnit 3.8.1 using import module declaration?\u003c/h3\u003e\n\n\n\n\u003cp\u003eI know it is an old version, but it is still around and in use. How would you import classes and interfaces defined in JUnit 3.8.1 (if you had to) in your source files? To import it using an import module declaration, you must use its module name. The short answer is you cannot because there is no module name for it. JUnit 3.8.1 was created before Java 9 introduced modules.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat about other libraries? How do we find their module names? We usually use build tools, such as Maven, to import dependencies as jar files. If a dependency supports modules, its jar file includes module-info.class (mandatory for modules), which contains the module name. You’ll notice that the JUnit 3.8.1 jar doesn’t include module-info.class.\u003c/p\u003e\n\n\n\n\u003cp\u003eIntelliJ IDEA users can view module info in \u003cem\u003eExternal libraries\u003c/em\u003e, in the \u003cem\u003eProject Structure \u003c/em\u003ewindow, as  shown below:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1600\" height=\"1268\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/07/image-3.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOf course, you could ask the AI Chat window in IntelliJ IDEA how to find these module names.\u003c/p\u003e\n\n\n\n\u003ch3\u003eWhich packages are exported by the modules you import?\u003c/h3\u003e\n\n\n\n\u003cp\u003eEach module defines a module-info.java file that includes information about the packages that module exports to all modules or to specific other modules. \u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s try to understand this by checking out what happens when you import the module \u003ccode\u003ejava.base\u003c/code\u003e using IntelliJ IDEA. Click on the module name in the editor or use the relevant shortcut (\u003cem\u003eGo to Declaration\u003c/em\u003e or \u003cem\u003eUsages\u003c/em\u003e) and you could view the definition of this module to find out all the modules exported by this module. This is shown in the following gif:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"1162\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/07/image-2.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe public API in these packages are available to source files that import these modules.\u003c/p\u003e\n\n\n\n\u003ch3\u003eWhat do you mean by on-demand import?\u003c/h3\u003e\n\n\n\n\u003cp\u003eDevelopers often argue about importing a single class or interface versus importing all public entities by importing a package using a wildcard character. Which of these do you think is better?\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen you import a module or a package using a wildcard (*), you import types \u003cem\u003eon demand\u003c/em\u003e. This means you can use any public class, interface, or entity from a package or module without importing each one individually.\u003c/p\u003e\n\n\n\n\u003cp\u003eOften, developers ask if importing a full module increases the size of their .class files. The short answer is no. On-demand imports make all public classes and interfaces in the module available to use in a source file, but the compiler includes only those that are actually used in your code.\u003c/p\u003e\n\n\n\n\u003ch3\u003eName conflicts (compilation error)\u003c/h3\u003e\n\n\n\n\u003cp\u003eWhen you import one or more modules, it is possible that packages within the same module or across modules define classes with the same name. For an example, in the example code below, code at line number 5 (Date date;) won’t compile because importing \u003ccode\u003ejava.base\u003c/code\u003e module makes \u003ccode\u003ejava.util.Date\u003c/code\u003e class available, and importing the java.sql module makes java.sql.Date available:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e1.    import module java.base;  // Makes available java.util.Date\n2.    import module java.sql;   // Makes available java.sql.Date\n3. \n4.    public class NameConflicts {\n5.        Date date;  // compilation error\n6.    }\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s assume you want to use the Date class from module \u003cem\u003ejava.sql\u003c/em\u003e. To address this issue, you could either add a single import statement, as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e1.    import module java.base;  // Makes available java.util.Date\n2.    import module java.sql;   // Makes available java.sql.Date\n3.    import java.sql.Date;\n4.    \n5.    public class NameConflicts {\n6.        Date date;  \n7.    }\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou could also resolve it by using a fully qualified class name, as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e1.    import module java.base;  // Makes available java.util.Date\n2.    import module java.sql;   // Makes available java.sql.Date\n3. \n4.    public class NameConflicts {\n5.        java.sql.Date date;  \n6.    }\u003c/pre\u003e\n\n\n\n\u003cp\u003eIntelliJ IDEA can highlight name conflicts as you type your code. Invoke context actions to view a list of qualified class names (package name + class name) to choose from, as shown below:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/07/image.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIf you are wondering whether it is a good idea to import modules since it could lead to namespace conflicts, these issues can occur with importing packages too. Don’t worry; it results in a compilation error and can be fixed easily.\u003c/p\u003e\n\n\n\n\u003cp\u003eAlso, a module and one of the packages it includes can have the same name. Notice that the module java.sql contains a package java.sql. The fully qualified name of a class or an interface includes its package name, not the name of the module the package is defined in.\u003c/p\u003e\n\n\n\n\u003ch3\u003eCompact Source Files integration\u003c/h3\u003e\n\n\n\n\u003cp\u003eGavin Bierman mentioned that the idea of this Import Module Declarations came up while the Java team was working on JEP \u003ca href=\"https://openjdk.org/jeps/512\" target=\"_blank\" rel=\"noopener\"\u003eCompact Source Files and Instance main Methods\u003c/a\u003e, which aim to reduce the ceremony to learning Java. \u003c/p\u003e\n\n\n\n\u003cp\u003eCompact source files implicitly import the module \u003ccode\u003ejava.base\u003c/code\u003e. It implies that the new developers can use any public class or interface from the multiple packages exported by the java.base module, without explicit import statements.\u003c/p\u003e\n\n\n\n\u003ch3\u003eJShell Integration\u003c/h3\u003e\n\n\n\n\u003cp\u003eOne of the main benefits of using JShell is that it allows you to quickly evaluate expressions, execute code statements or snippets (and much more) without the ceremony of defining classes.\u003c/p\u003e\n\n\n\n\u003cp\u003ePrior to Import Module Declarations, JShell automatically imported the ten most used packages (and java.lang) so that developers could easily use those classes or interfaces without explicit import statements. However, you still need import statements for classes or interfaces not defined in these packages, such as the \u003ccode\u003eLocalDateTime\u003c/code\u003e class from the \u003ccode\u003epackage java.time\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"1080\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/07/image.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWith import module declarations, JShell automatically imports the module java.base. This helps developers use many more classes (such as \u003ccode\u003eLocalDateTime\u003c/code\u003e), without needing explicit import statement, as shown in the following image:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"1080\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/07/image.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eOne import statement to use the entire standard Java API\u003c/h3\u003e\n\n\n\n\u003cp\u003eBy importing the java.se module you can use the entire standard Java API in your source file. Here’s the module information for this module:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1281\" height=\"1600\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/07/image-1.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe java.se module is an aggregator module. It does not export any package, but requires other modules transitively. In other words, source files importing java.se import the packages exported by modules that are marked required transitive in \u003ca href=\"http://java.se\" target=\"_blank\" rel=\"noopener\"\u003ejava.se\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch3\u003eInterview with creators of this feature\u003c/h3\u003e\n\n\n\n\u003cp\u003eWe also \u003ca href=\"https://youtu.be/mSYA3cZ5o6c\" target=\"_blank\" rel=\"noopener\"\u003einterviewed\u003c/a\u003e the owner of this feature, \u003ca href=\"https://x.com/GavinBierman\" target=\"_blank\"\u003eGavin Bierman\u003c/a\u003e, Programming Language Designer at Oracle.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cp\u003e\n\u003ciframe loading=\"lazy\" title=\"JEP Explained. JEP 476: Module Import Declarations\" width=\"500\" height=\"281\" src=\"https://www.youtube.com/embed/mSYA3cZ5o6c?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen=\"\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\u003c/figure\u003e\n\n\n\n\n\n\n\n\u003cp\u003eGavin mentioned that this feature was co-developed with the JEP \u003ca href=\"https://openjdk.org/jeps/512\" target=\"_blank\" rel=\"noopener\"\u003eCompact Source Files and Instance Main Methods\u003c/a\u003e. He covered the differences between single-type imports and type-import-on-demand declarations, explaining what they are and why individuals and organizations prefer one style over the other. He also talked about how the “Module Import Declarations” feature automatically imports on demand from transitive dependencies of modules. He discussed ambiguous imports and how to deal with them, name ambiguity, and how to submit relevant feedback on this feature to the teams at OpenJDK.\u003c/p\u003e\n\n\n\n\u003ch2\u003ePractical Tips\u003c/h2\u003e\n\n\n\n\u003cp\u003ePractical tips and wisdom are always useful when using a feature.\u003c/p\u003e\n\n\n\n\u003ch3\u003eMigrating your codebases to use import module declarations\u003c/h3\u003e\n\n\n\n\u003cp\u003eI’d recommend not replacing all the individual import statements or package statements with import module statements in your codebase. Try module imports in new files or when you’re already touching existing code.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis feature is syntactic sugar; it makes your code more readable but doesn’t offer any performance benefits. The folks who maintain your code are more important than using the latest shiny features in your codebase. If they understand the code in its existing format, respect that.\u003c/p\u003e\n\n\n\n\u003ch3\u003eGroup Your Imports\u003c/h3\u003e\n\n\n\n\u003cp\u003eWith module imports, Java offers multiple types of imports, such as, importing modules, importing packages, importing classes/interfaces, and static imports of fields or methods. Grouping imports could make them more readable.\u003c/p\u003e\n\n\n\n\u003ch3\u003eIntelliJ IDEA supports importing types as you type them\u003c/h3\u003e\n\n\n\n\u003cp\u003eWhether you are copy-pasting code or typing it, IntelliJ IDEA adds the relevant imports to your codebase, either automatically or by prompting you to select the correct version to import, as shown in the following gif:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"1047\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/07/image-1.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eJust in case, the preceding settings don’t work for you, ensure you have enabled the relevant import settings in ‘\u003cem\u003eIntentions\u003c/em\u003e’ (use IntelliJ IDEA \u003cem\u003eSettings\u003c/em\u003e), as follows:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/07/image.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIf you haven’t been using this feature in IntelliJ IDEA, you are missing out on a great user experience.\u003c/p\u003e\n\n\n\n\u003ch2\u003eSummary\u003c/h2\u003e\n\n\n\n\u003cp\u003eIntroduced as a preview feature in Java 23 and a production feature in Java 25, \u003ca href=\"https://openjdk.org/jeps/511\" target=\"_blank\" rel=\"noopener\"\u003eModule Import Declarations\u003c/a\u003e allow importing an entire module with a single import statement.\u003c/p\u003e\n\n\n\n\u003cp\u003eApart from the obvious benefits of replacing multiple import statements with a single import, this feature helps us developers escape import hell. It works only with named modules, not unnamed ones or older libraries without module definitions (such as JUnit 3.8.1). Classes and interfaces are imported on demand. Importing a module makes its public classes/interfaces available, but only those actually used are included by the compiler. Importing multiple modules might lead to class name conflicts, requiring specific imports or fully qualified names.\u003c/p\u003e\n\n\n\n\u003cp\u003eJShell and compact source files automatically import java.base with this feature. If you want to extend it, try importing the java.se module, which provides access to the entire standard Java API. The release of Java 25 is scheduled for September, but IntelliJ IDEA already supports this feature. Try it out and let us know your feedback.\u003c/p\u003e\n\n\n\n\u003cp\u003eHappy coding.\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "19 min read",
  "publishedTime": null,
  "modifiedTime": null
}
