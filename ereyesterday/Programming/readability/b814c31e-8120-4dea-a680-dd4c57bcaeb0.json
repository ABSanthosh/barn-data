{
  "id": "b814c31e-8120-4dea-a680-dd4c57bcaeb0",
  "title": "How to Build a CRUD REST API Using Spring Boot",
  "link": "https://blog.jetbrains.com/idea/2024/10/how-to-build-a-crud-rest-api-using-spring-boot/",
  "description": "Spring Boot is an application framework for the Java platform designed to make it easy to build Spring-powered applications. Its opinionated convention-over-configuration approach to building Spring applications improves developer productivity. IntelliJ IDEA provides extensive coding assistance for Spring, including a dedicated project wizard, code highlighting, intelligent context actions, embedded documentation, navigation, and highly customizable run […]",
  "author": "Siva Katamreddy",
  "published": "Tue, 29 Oct 2024 09:42:10 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "idea",
    "java",
    "intellij-idea",
    "jpa",
    "jpabuddy",
    "rest-api",
    "spring-boot",
    "springdata"
  ],
  "byline": "Siva Katamreddy",
  "length": 21335,
  "excerpt": "Spring Boot is an application framework for the Java platform designed to make it easy to build Spring-powered applications. Its opinionated convention-over-configuration approach to building Spring a",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA – the Leading Java and Kotlin IDE, by JetBrains IntelliJ IDEA JavaHow to Build a CRUD REST API Using Spring Boot Spring Boot is an application framework for the Java platform designed to make it easy to build Spring-powered applications. Its opinionated convention-over-configuration approach to building Spring applications improves developer productivity. IntelliJ IDEA provides extensive coding assistance for Spring, including a dedicated project wizard, code highlighting, intelligent context actions, embedded documentation, navigation, and highly customizable run configurations. For a detailed description of the supported features, refer to IntelliJ IDEA for Spring Developers. We are going to build a REST API to manage bookmarks using Spring Boot and PostgreSQL database by implementing CRUD (Create, Read, Update, Delete) API endpoints. In this article, we are going to cover the following: Create a Spring Boot project from IntelliJ IDEA Run a PostgreSQL database instance Connect to the database using IntelliJ IDEA’s database tools support Database setup using an SQL script Generate entities from the database Create a Spring Data JPA repository Add custom finder methods to the repository Using Spring Data JPA projection Invoke the repository methods using the JPA console Implement API endpoint handler methods Test API endpoints using the HTTP Client While building the CRUD REST API using Spring Boot, we are going to use various features offered by IntelliJ IDEA Ultimate. If you haven’t already installed it, please download and install IntelliJ IDEA Ultimate. Download IntelliJ IDEA If you are using IntelliJ IDEA Community Edition, you can manually create the classes using the code snippets in this article. Create a Spring Boot project Let’s start with creating a new Spring Boot project. When you open the IntelliJ IDEA New Project wizard, you can see there is dedicated support for creating Spring Boot projects. Select Java as the language and provide values for Group, Artifact, and Package name. We are going to use Gradle – Groovy as the build tool in this article, but you can choose other alternatives if you prefer. We are going to use Java 21 and Jar packaging. Click Next, select the following dependencies, and then click the Create button. Spring Web Validation Spring Data JPA PostgreSQL Driver Now, the project will be created and opened in the IDE. Run a PostgreSQL database instance We need a PostgreSQL database instance for running our application. You can download and install the PostgreSQL database from https://www.postgresql.org/download/. If you have Docker installed, you can use Docker to run a PostgreSQL database container using the following command: docker run -p 5432:5432 \\ -e POSTGRES_PASSWORD=postgres \\ -e POSTGRES_USER=postgres \\ -e POSTGRES_DB=postgres \\ postgres:17 The above command will pull the Docker image postgres:17 from Docker Hub, if not already pulled, start a Postgres container, and map container port 5432 to host port 5432. The username, password, and database values are passed using environment variables. You can check whether Postgres is running by running the docker ps command as follows: Connect to PostgreSQL using IntelliJ IDEA’s database tools support Now that the PostgreSQL database is running, let’s connect to it using IntelliJ IDEA’s database tools support and the following connection parameters: Host: localhost Port: 5432 Username: postgres Password: postgres Database: postgres You can open the Database tool window either by clicking on the database icon on the right-hand side toolbar or by going to View | Tool Windows | Database. Create a new data source of type PostgreSQL by providing the following information: You can click on Test Connection to verify whether the database connection can be established successfully or not. Database setup using an SQL script Select the PostgreSQL datasource from the Database tool window and open the query console. Now, let’s create a database table called bookmarks and then populate some sample data by running the following SQL script: create sequence bookmark_id_seq start with 1 increment by 50; create table bookmarks ( id bigint not null default nextval('bookmark_id_seq'), title varchar(200) not null, url varchar(500) not null, created_at timestamp not null default now(), updated_at timestamp, primary key (id) ); insert into bookmarks(title, url, created_at) values ('IntelliJ IDEA documentation', 'https://www.jetbrains.com/help/idea/getting-started.html', '2021-06-26'), ('IntelliJ IDEA YouTube channel', 'https://www.youtube.com/intellijidea', '2021-10-10'), ('JetBrains Guide', 'https://www.jetbrains.com/guide/', '2023-12-05'), ('Java Guide', 'https://www.jetbrains.com/guide/java/', '2024-08-15'); Now, let’s configure the database connection properties in the src/main/resources/application.properties file as follows: spring.datasource.url=jdbc:postgresql://localhost:5432/postgres spring.datasource.username=postgres spring.datasource.password=postgres When we start our Spring Boot application, a database connection pool will be created connecting to the configured Postgres database. Generate entities from the database JPA (Jakarta Persistence API) is a standard Jakarta EE API for ORM (Object Relational Mapping) frameworks. JPA allows you to map the relational data model with an object model, providing an object-oriented way to work with databases. IntelliJ IDEA Ultimate provides support for working with JPA, code assistance, etc. From IntelliJ IDEA, we can generate JPA entities from an existing database schema.IntelliJ IDEA provides Reverse Engineering capabilities for generating JPA entities from an existing database out of the box. However, we will use the JPA Buddy plugin, which provides a lot more features that make working with JPA and Spring Data JPA much easier. Go to Settings | Plugins | Marketplace, search for “jpa buddy”, and install the JPA Buddy plugin. Now, you can generate JPA entities from a database by right-clicking on a Java package in the Project tool window and selecting New | JPA Entities from DB from the context menu. Now, you will have a Bookmark JPA entity generated as follows: package com.jetbrains.bookmarks; import jakarta.persistence.*; import jakarta.validation.constraints.NotNull; import jakarta.validation.constraints.Size; import org.hibernate.annotations.ColumnDefault; import java.time.Instant; @Entity @Table(name = \"bookmarks\") public class Bookmark { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"bookmarks_id_gen\") @SequenceGenerator(name = \"bookmarks_id_gen\", sequenceName = \"bookmark_id_seq\") @Column(name = \"id\", nullable = false) private Long id; @Size(max = 200) @NotNull @Column(name = \"title\", nullable = false, length = 200) private String title; @Size(max = 500) @NotNull @Column(name = \"url\", nullable = false, length = 500) private String url; @NotNull @ColumnDefault(\"now()\") @Column(name = \"created_at\", nullable = false) private Instant createdAt; @Column(name = \"updated_at\") private Instant updatedAt; // setters \u0026 getters } Create Spring Data JPA repository The JPA Buddy plugin also makes it easy to create a Spring Data JPA repository for a JPA entity. Right-click on a Java package and then select New | Spring Data JPA Repository. Select Bookmark as Entity and click OK. The BookmarkRepository will be created as follows: package com.jetbrains.bookmarks; import org.springframework.data.jpa.repository.JpaRepository; public interface BookmarkRepository extends JpaRepository\u003cBookmark, Long\u003e { } To get all the bookmarks in reverse chronological order of their creation, we can use the inherited findAll(Sort sort) method as follows: Sort sort = Sort.by(Sort.Direction.DESC, \"createdAt\"); List\u003cBookmark\u003e bookmarks = bookmarkRepository.findAll(sort); Alternatively, we can also leverage Spring Data JPA’s derived query method feature and create the following method to achieve the same: public interface BookmarkRepository extends JpaRepository\u003cBookmark, Long\u003e { List\u003cBookmark\u003e findAllByOrderByCreatedAtDesc(); } With the findAllByOrderByCreatedAtDesc() method name, Spring Data JPA automatically prepares the SQL query that uses the order by created_at desc clause. While this works fine, it is not recommended to return JPA entities as HTTP API responses. Instead, we can return Spring Data JPA interface-based projections. Assuming we just want to return only the id, title, url, and createdAt fields of Bookmark, we can create a Spring Data JPA projection using the JPA Buddy plugin as follows:Right-click on Bookmark.java and select New | Other | Spring Data Projection. Now, you can change the Projection class name if needed, select the desired fields, and then click OK. The BookmarkInfo.java interface will be generated as follows: package com.jetbrains.bookmarks; import java.time.Instant; /** * Projection for {@link Bookmark} */ public interface BookmarkInfo { Long getId(); String getTitle(); String getUrl(); Instant getCreatedAt(); } Now, let’s update the BookmarkRepository to return the projection as follows: public interface BookmarkRepository extends JpaRepository\u003cBookmark, Long\u003e { List\u003cBookmarkInfo\u003e findAllByOrderByCreatedAtDesc(); } Let’s also add a method to find a bookmark for the given id as follows: package com.jetbrains.bookmarks; import org.springframework.data.jpa.repository.JpaRepository; import java.util.List; import java.util.Optional; public interface BookmarkRepository extends JpaRepository\u003cBookmark, Long\u003e { List\u003cBookmarkInfo\u003e findAllByOrderByCreatedAtDesc(); Optional\u003cBookmarkInfo\u003e findBookmarkById(Long id); } We are returning Optional\u003cBookmarkInfo\u003e because a bookmark with the given id may or may not exist. IntelliJ IDEA provides the ability to invoke Spring Data JPA repository methods using the JPA console. So, we can call the repository methods and check whether they are returning the expected result or not. Click on the gutter icon to run the query in the JPA console: If you are using Gradle, you’ll need to select a persistence unit from the ones available. Select the bookmarks.main Persistence Unit. Now, provide inputs to the method if required, and then you’ll see the results as follows: NOTE: In a typical three-layered architecture, there will be the Web, Service, and Persistence layers. In the Service layer, we usually implement business logic as a unit of work, which might involve multiple database operations, as a transactional operation. In our sample application, as we don’t have any complex business logic, the controller will directly talk to the repository. Implement Controller API handler methods Let’s implement the API endpoint handlers for performing CRUD operations. First, let’s create a BookmarkNotFoundException, which we will throw when the requested bookmark is not found. package com.jetbrains.bookmarks; public class BookmarkNotFoundException extends RuntimeException { public BookmarkNotFoundException(String message) { super(message); } } Now, let’s create BookmarkController as follows: package com.jetbrains.bookmarks; import org.springframework.web.bind.annotation.*; @RestController @RequestMapping(\"/api/bookmarks\") class BookmarkController { private final BookmarkRepository bookmarkRepository; BookmarkController(BookmarkRepository bookmarkRepository) { this.bookmarkRepository = bookmarkRepository; } //CRUD API handler methods } TIP: With IntelliJ IDEA, you don’t need to manually define and inject the dependencies before using them. When you need to use another Spring bean, you can start typing the dependent bean name, and IntelliJ IDEA will show the matching beans. When you select a bean, IntelliJ IDEA will automatically define and autowire the dependent bean using a constructor. Let’s implement API handler methods to get all bookmarks (GET /api/bookmarks) and get bookmark by id( GET /api/bookmarks/{id}) as follows: package com.jetbrains.bookmarks; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(\"/api/bookmarks\") public class BookmarkController { //... @GetMapping List\u003cBookmarkInfo\u003e getBookmarks() { return bookmarkRepository.findAllByOrderByCreatedAtDesc(); } @GetMapping(\"/{id}\") ResponseEntity\u003cBookmarkInfo\u003e getBookmarkById(@PathVariable Long id) { var bookmark = bookmarkRepository.findBookmarkById(id) .orElseThrow(()-\u003e new BookmarkNotFoundException(\"Bookmark not found\")); return ResponseEntity.ok(bookmark); } } NOTE: For the GET /api/bookmarks API, we are returning all the bookmarks, but in a real-world application, we would recommend using pagination. Next, let’s implement the create bookmark (POST /api/bookmarks) handler method. package com.jetbrains.bookmarks; import jakarta.validation.Valid; import jakarta.validation.constraints.NotEmpty; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.support.ServletUriComponentsBuilder; import java.time.Instant; import java.util.List; @RestController @RequestMapping(\"/api/bookmarks\") public class BookmarkController { //... record CreateBookmarkPayload( @NotEmpty(message = \"Title is required\") String title, @NotEmpty(message = \"Url is required\") String url) {} @PostMapping ResponseEntity\u003cVoid\u003e createBookmark( @Valid @RequestBody CreateBookmarkPayload payload) { var bookmark = new Bookmark(); bookmark.setTitle(payload.title()); bookmark.setUrl(payload.url()); bookmark.setCreatedAt(Instant.now()); var savedBookmark = bookmarkRepository.save(bookmark); var url = ServletUriComponentsBuilder.fromCurrentRequest() .path(\"/{id}\") .build(savedBookmark.getId()); return ResponseEntity.created(url).build(); } } We have created a local record CreateBookmarkPayload to represent the request payload and used the Jakarta Bean Validation API to validate the required fields. If the request payload is valid, then we create the Bookmark object and persist it in the database. Then, we construct the URL for the newly created bookmark and send it as the Location header. If the request payload is invalid, then by default, Spring Boot will handle this error by returning the HTTP status code 400 - BAD_REQUEST with the default error response. Next, let’s implement Update (PUT /api/bookmarks/{id}) and delete the bookmark (DELETE /api/bookmarks/{id}) handler methods. package com.jetbrains.bookmarks; //imports @RestController @RequestMapping(\"/api/bookmarks\") public class BookmarkController { //... record UpdateBookmarkPayload( @NotEmpty(message = \"Title is required\") String title, @NotEmpty(message = \"Url is required\") String url) { } @PutMapping(\"/{id}\") ResponseEntity\u003cVoid\u003e updateBookmark( @PathVariable Long id, @Valid @RequestBody UpdateBookmarkPayload payload) { var bookmark = bookmarkRepository.findById(id) .orElseThrow(()-\u003e new BookmarkNotFoundException(\"Bookmark not found\")); bookmark.setTitle(payload.title()); bookmark.setUrl(payload.url()); bookmark.setUpdatedAt(Instant.now()); bookmarkRepository.save(bookmark); return ResponseEntity.noContent().build(); } @DeleteMapping(\"/{id}\") void deleteBookmark(@PathVariable Long id) { var bookmark = bookmarkRepository.findById(id) .orElseThrow(()-\u003e new BookmarkNotFoundException(\"Bookmark not found\")); bookmarkRepository.delete(bookmark); } } We have created a local record UpdateBookmarkPayload to represent the update request payload and used the Jakarta Bean Validation API to validate the required fields. If the request payload is valid, then we try to load the Bookmark object from the database. If the bookmark doesn’t exist, the code will throw a BookmarkNotFoundException. Otherwise, we will update the bookmark data in the database. Similarly, for the delete bookmark API endpoint, we try to delete the bookmark if it exists. Otherwise, a BookmarkNotFoundException is thrown. When we throw a BookmarkNotFoundException from our handler methods, by default, Spring is going to handle it and return a response with the HTTP status code 500 - INTERNAL_SERVER_ERROR. But when the bookmark is not found, it makes sense to send the 404 - NOT_FOUND status code. So, let’s implement an ExceptionHandler as follows: package com.jetbrains.bookmarks; //imports @RestController @RequestMapping(\"/api/bookmarks\") public class BookmarkController { //... @ExceptionHandler(BookmarkNotFoundException.class) ResponseEntity\u003cVoid\u003e handle(BookmarkNotFoundException e) { return ResponseEntity.notFound().build(); } } Now, when any handler method in BookmarkController throws a BookmarkNotFoundException, it will be handled by the ExceptionHandler and return the HTTP status code 404 - NOT_FOUND. When you create a Spring Boot application in IntelliJ IDEA, it automatically creates a Spring Boot run configuration. Now run/debug the application using the BookmarksApplication run configuration, which should start the application on port 8080. Test API endpoints using the HTTP Client IntelliJ IDEA provides a built-in HTTP Client, which we can use to invoke our API endpoints and assert the responses. You can open the HTTP Client by selecting Tools | HTTP Client | Create request in HTTP Client. Alternatively, you can also click on the API gutter icon on the API handler methods in BookmarkController. IntelliJ IDEA will open a .http file. Once the application is started, you can invoke the GET /api/bookmarks endpoint and assert the response status code as follows: ### Get all bookmarks GET http://localhost:8080/api/bookmarks \u003e {% client.test(\"Should get bookmarks successfully\", function () { client.assert(response.status === 200, \"Response status is not 200\"); }); %} You can click on the Run icon in the gutter to execute the API call. Similarly, you can invoke other API endpoints as follows: ### Get bookmark by id GET http://localhost:8080/api/bookmarks/1 \u003e {% client.test(\"Should get bookmark successfully\", function () { client.assert(response.status === 200, \"Response status is not 200\"); }); %} ### Create bookmark successfully POST http://localhost:8080/api/bookmarks Content-Type: application/json { \"title\": \"bookmark title\", \"url\": \"https://bookmark.com\" } \u003e {% client.test(\"Should create bookmark successfully\", function () { client.assert(response.status === 201, \"Response status is not 201\"); }); %} I will leave the rest of the API call invocations as an exercise for you. To learn more about the HTTP Client, you can refer to the documentation or watch The New HTTP Client presentation. Summary In this article, we learned how to create a REST API performing CRUD operations using Spring Boot talking to a PostgreSQL database. We have verified whether the application is working as expected or not using the HTTP Client. You can find the complete code in this GitHub repository. As we have seen, IntelliJ IDEA Ultimate supports Spring in a way that makes it easy to build Spring Boot applications. Also, the JPA Buddy plugin makes developers more productive while using JPA and Spring Data JPA-based applications. Download IntelliJ IDEA To learn more about JPA Buddy, you can watch this presentation or read the official documentation. Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2024/10/ij-social_share_blog_1280x720_en-7.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA – the Leading Java and Kotlin IDE, by JetBrains\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/category/idea/\"\u003eIntelliJ IDEA\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/idea/category/java/\"\u003eJava\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eHow to Build a CRUD REST API Using Spring Boot\u003c/h2\u003e                    \n                    \n\u003cp\u003e\u003ca href=\"https://spring.io/projects/spring-boot\" target=\"_blank\" rel=\"noopener\"\u003eSpring Boot\u003c/a\u003e is an application framework for the Java platform designed to make it easy to build Spring-powered applications. Its opinionated convention-over-configuration approach to building Spring applications improves developer productivity.\u003c/p\u003e\n\n\n\n\u003cp\u003eIntelliJ IDEA provides extensive coding assistance for Spring, including a dedicated project wizard, code highlighting, intelligent context actions, embedded documentation, navigation, and highly customizable run configurations. For a detailed description of the supported features, refer to \u003ca href=\"https://www.jetbrains.com/idea/spring/\" target=\"_blank\" rel=\"noopener\"\u003eIntelliJ IDEA for Spring Developers\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe are going to build a REST API to manage bookmarks using Spring Boot and PostgreSQL database by implementing CRUD (\u003cstrong\u003eC\u003c/strong\u003ereate, \u003cstrong\u003eR\u003c/strong\u003eead, \u003cstrong\u003eU\u003c/strong\u003epdate, \u003cstrong\u003eD\u003c/strong\u003eelete) API endpoints.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this article, we are going to cover the following:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCreate a Spring Boot project from IntelliJ IDEA\u003c/li\u003e\n\n\n\n\u003cli\u003eRun a PostgreSQL database instance\u003c/li\u003e\n\n\n\n\u003cli\u003eConnect to the database using IntelliJ IDEA’s database tools support\u003c/li\u003e\n\n\n\n\u003cli\u003eDatabase setup using an SQL script\u003c/li\u003e\n\n\n\n\u003cli\u003eGenerate entities from the database\u003c/li\u003e\n\n\n\n\u003cli\u003eCreate a Spring Data JPA repository\u003c/li\u003e\n\n\n\n\u003cli\u003eAdd custom finder methods to the repository\u003c/li\u003e\n\n\n\n\u003cli\u003eUsing Spring Data JPA projection\u003c/li\u003e\n\n\n\n\u003cli\u003eInvoke the repository methods using the JPA console\u003c/li\u003e\n\n\n\n\u003cli\u003eImplement API endpoint handler methods\u003c/li\u003e\n\n\n\n\u003cli\u003eTest API endpoints using the HTTP Client\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWhile building the CRUD REST API using Spring Boot, we are going to use various features offered by IntelliJ IDEA Ultimate. If you haven’t already installed it, please \u003ca href=\"https://www.jetbrains.com/idea/download/\" target=\"_blank\" rel=\"noopener\"\u003edownload\u003c/a\u003e and install IntelliJ IDEA Ultimate.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://www.jetbrains.com/idea/\" target=\"_blank\" rel=\"noopener\" data-test=\"blog-article-cta\"\u003eDownload IntelliJ IDEA\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you are using IntelliJ IDEA Community Edition, you can manually create the classes using the code snippets in this article.\u003c/p\u003e\n\n\n\n\u003ch2\u003eCreate a Spring Boot project\u003c/h2\u003e\n\n\n\n\u003cp\u003eLet’s start with creating a new Spring Boot project. When you open the IntelliJ IDEA New Project wizard, you can see there is dedicated support for creating \u003cstrong\u003eSpring Boot\u003c/strong\u003e projects.\u003c/p\u003e\n\n\n\n\u003cp\u003eSelect \u003cstrong\u003eJava\u003c/strong\u003e as the language and provide values for \u003cstrong\u003eGroup\u003c/strong\u003e, \u003cstrong\u003eArtifact\u003c/strong\u003e, and \u003cstrong\u003ePackage name\u003c/strong\u003e. We are going to use \u003cstrong\u003eGradle – Groovy\u003c/strong\u003e as the build tool in this article, but you can choose other alternatives if you prefer. We are going to use \u003cstrong\u003eJava 21\u003c/strong\u003e and \u003cstrong\u003eJar\u003c/strong\u003e packaging.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"898\" height=\"881\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/1-ij-create-spring-boot-project.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick \u003cstrong\u003eNext\u003c/strong\u003e, select the following dependencies, and then click the \u003cstrong\u003eCreate\u003c/strong\u003e button.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eSpring Web\u003c/li\u003e\n\n\n\n\u003cli\u003eValidation\u003c/li\u003e\n\n\n\n\u003cli\u003eSpring Data JPA\u003c/li\u003e\n\n\n\n\u003cli\u003ePostgreSQL Driver\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"898\" height=\"884\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/2-ij-spring-boot-starters.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNow, the project will be created and opened in the IDE.\u003c/p\u003e\n\n\n\n\u003ch2\u003eRun a PostgreSQL database instance\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe need a PostgreSQL database instance for running our application. You can download and install the PostgreSQL database from \u003ca href=\"https://www.postgresql.org/download/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://www.postgresql.org/download/\u003c/a\u003e. If you have \u003ca href=\"https://docs.docker.com/engine/install/\" target=\"_blank\" rel=\"noopener\"\u003eDocker\u003c/a\u003e installed, you can use Docker to run a PostgreSQL database container using the following command:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"bash\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003edocker run -p 5432:5432 \\\n -e POSTGRES_PASSWORD=postgres \\\n -e POSTGRES_USER=postgres \\\n -e POSTGRES_DB=postgres \\\n postgres:17\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe above command will pull the Docker image \u003ca href=\"https://hub.docker.com/_/postgres\" target=\"_blank\" rel=\"noopener\"\u003epostgres:17\u003c/a\u003e from Docker Hub, if not already pulled, start a Postgres container, and map container port 5432 to host port 5432. The username, password, and database values are passed using environment variables. You can check whether Postgres is running by running the \u003ccode\u003edocker ps\u003c/code\u003e command as follows:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1362\" height=\"100\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/3-docker-ps-output.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003eConnect to PostgreSQL using IntelliJ IDEA’s database tools support\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow that the PostgreSQL database is running, let’s connect to it using IntelliJ IDEA’s database tools support and the following connection parameters:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eHost: localhost\nPort: 5432\nUsername: postgres\nPassword: postgres\nDatabase: postgres\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou can open the \u003cem\u003eDatabase\u003c/em\u003e tool window either by clicking on the database icon on the right-hand side toolbar or by going to \u003cstrong\u003eView | Tool Windows | Database\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1279\" height=\"871\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/4-ij-db-tools-window.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eCreate a new data source of type \u003cstrong\u003ePostgreSQL\u003c/strong\u003e by providing the following information:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"941\" height=\"757\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/5-ij-db-postgres-connection.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou can click on \u003cstrong\u003eTest Connection\u003c/strong\u003e to verify whether the database connection can be established successfully or not.\u003c/p\u003e\n\n\n\n\u003ch2\u003eDatabase setup using an SQL script\u003c/h2\u003e\n\n\n\n\u003cp\u003eSelect the PostgreSQL datasource from the Database tool window and open the query console. Now, let’s create a database table called \u003ccode\u003ebookmarks\u003c/code\u003e and then populate some sample data by running the following SQL script:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"sql\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003ecreate sequence bookmark_id_seq start with 1 increment by 50;\n\ncreate table bookmarks\n(\n    id         bigint       not null default nextval(\u0026#39;bookmark_id_seq\u0026#39;),\n    title      varchar(200) not null,\n    url        varchar(500) not null,\n    created_at timestamp    not null default now(),\n    updated_at timestamp,\n    primary key (id)\n);\n\ninsert into bookmarks(title, url, created_at) values\n(\u0026#39;IntelliJ IDEA documentation\u0026#39;, \u0026#39;https://www.jetbrains.com/help/idea/getting-started.html\u0026#39;, \u0026#39;2021-06-26\u0026#39;),\n(\u0026#39;IntelliJ IDEA YouTube channel\u0026#39;, \u0026#39;https://www.youtube.com/intellijidea\u0026#39;, \u0026#39;2021-10-10\u0026#39;),\n(\u0026#39;JetBrains Guide\u0026#39;, \u0026#39;https://www.jetbrains.com/guide/\u0026#39;, \u0026#39;2023-12-05\u0026#39;),\n(\u0026#39;Java Guide\u0026#39;, \u0026#39;https://www.jetbrains.com/guide/java/\u0026#39;, \u0026#39;2024-08-15\u0026#39;);\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow, let’s configure the database connection properties in the \u003ccode\u003esrc/main/resources/application.properties\u003c/code\u003e file as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003espring.datasource.url=jdbc:postgresql://localhost:5432/postgres\nspring.datasource.username=postgres\nspring.datasource.password=postgres\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen we start our Spring Boot application, a database connection pool will be created connecting to the configured Postgres database.\u003c/p\u003e\n\n\n\n\u003ch2\u003eGenerate entities from the database\u003c/h2\u003e\n\n\n\n\u003cp\u003eJPA (Jakarta Persistence API) is a standard Jakarta EE API for ORM (Object Relational Mapping) frameworks. JPA allows you to map the relational data model with an object model, providing an object-oriented way to work with databases.\u003c/p\u003e\n\n\n\n\u003cdiv\u003e\u003cp\u003eIntelliJ IDEA Ultimate provides support for working with JPA, code assistance, etc. From IntelliJ IDEA, we can generate JPA entities from an existing database schema.\u003c/p\u003e\u003cp\u003eIntelliJ IDEA provides \u003ca href=\"https://www.jetbrains.com/help/idea/jpa-buddy-reverse-engineering.html\" target=\"_blank\" rel=\"noopener\"\u003eReverse Engineering\u003c/a\u003e capabilities for generating JPA entities from an existing database out of the box. However, we will use the \u003ca href=\"https://plugins.jetbrains.com/plugin/15075-jpa-buddy\" target=\"_blank\" rel=\"noopener\"\u003eJPA Buddy plugin\u003c/a\u003e, which provides a lot more features that make working with JPA and Spring Data JPA much easier.\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003cp\u003eGo to \u003cstrong\u003eSettings | Plugins | Marketplace\u003c/strong\u003e, search for “jpa buddy”, and install the \u003cstrong\u003eJPA Buddy\u003c/strong\u003e plugin.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow, you can generate JPA entities from a database by right-clicking on a Java package in the Project tool window and selecting \u003cstrong\u003eNew | JPA Entities from DB \u003c/strong\u003efrom the context menu.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"968\" height=\"805\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/6-ij-generate-jpa-entity.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNow, you will have a \u003ccode\u003eBookmark\u003c/code\u003e JPA entity generated as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epackage com.jetbrains.bookmarks;\n\nimport jakarta.persistence.*;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.Size;\nimport org.hibernate.annotations.ColumnDefault;\nimport java.time.Instant;\n\n@Entity\n@Table(name = \u0026#34;bookmarks\u0026#34;)\npublic class Bookmark {\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \u0026#34;bookmarks_id_gen\u0026#34;)\n    @SequenceGenerator(name = \u0026#34;bookmarks_id_gen\u0026#34;, sequenceName = \u0026#34;bookmark_id_seq\u0026#34;)\n    @Column(name = \u0026#34;id\u0026#34;, nullable = false)\n    private Long id;\n\n    @Size(max = 200)\n    @NotNull\n    @Column(name = \u0026#34;title\u0026#34;, nullable = false, length = 200)\n    private String title;\n\n    @Size(max = 500)\n    @NotNull\n    @Column(name = \u0026#34;url\u0026#34;, nullable = false, length = 500)\n    private String url;\n\n    @NotNull\n    @ColumnDefault(\u0026#34;now()\u0026#34;)\n    @Column(name = \u0026#34;created_at\u0026#34;, nullable = false)\n    private Instant createdAt;\n\n    @Column(name = \u0026#34;updated_at\u0026#34;)\n    private Instant updatedAt;\n\n    // setters \u0026amp; getters\n}\u003c/pre\u003e\n\n\n\n\u003ch2\u003eCreate Spring Data JPA repository\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe JPA Buddy plugin also makes it easy to create a Spring Data JPA repository for a JPA entity.\u003c/p\u003e\n\n\n\n\u003cp\u003eRight-click on a Java package and then select \u003cstrong\u003eNew | Spring Data JPA Repository\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eSelect Bookmark as \u003cstrong\u003eEntity\u003c/strong\u003e and click \u003cstrong\u003eOK\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"723\" height=\"412\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/7-ij-gen-jpa-repository.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eBookmarkRepository\u003c/code\u003e will be created as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epackage com.jetbrains.bookmarks;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface BookmarkRepository extends JpaRepository\u0026lt;Bookmark, Long\u0026gt; {\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eTo get all the bookmarks in reverse chronological order of their creation, we can use the inherited \u003ccode\u003efindAll(Sort sort)\u003c/code\u003e method as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eSort sort = Sort.by(Sort.Direction.DESC, \u0026#34;createdAt\u0026#34;);\nList\u0026lt;Bookmark\u0026gt; bookmarks = bookmarkRepository.findAll(sort);\u003c/pre\u003e\n\n\n\n\u003cp\u003eAlternatively, we can also leverage Spring Data JPA’s derived query method feature and create the following method to achieve the same:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epublic interface BookmarkRepository extends JpaRepository\u0026lt;Bookmark, Long\u0026gt; {\n    List\u0026lt;Bookmark\u0026gt; findAllByOrderByCreatedAtDesc();\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith the \u003ccode\u003efindAllByOrderByCreatedAtDesc()\u003c/code\u003e method name, Spring Data JPA automatically prepares the SQL query that uses the \u003ccode\u003eorder by created_at desc\u003c/code\u003e clause.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhile this works fine, it is not recommended to return JPA entities as HTTP API responses. Instead, we can return \u003ca href=\"https://docs.spring.io/spring-data/jpa/reference/repositories/projections.html\" target=\"_blank\" rel=\"noopener\"\u003eSpring Data JPA interface-based projections\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cdiv\u003e\u003cp\u003eAssuming we just want to return only the \u003ccode\u003eid\u003c/code\u003e, \u003ccode\u003etitle\u003c/code\u003e, \u003ccode\u003eurl\u003c/code\u003e, and \u003ccode\u003ecreatedAt\u003c/code\u003e fields of \u003ccode\u003eBookmark\u003c/code\u003e, we can create a Spring Data JPA projection using the JPA Buddy plugin as follows:\u003c/p\u003e\u003cp\u003eRight-click on \u003ccode\u003eBookmark.java\u003c/code\u003e and select\u003cstrong\u003e New | Other | Spring Data Projection\u003c/strong\u003e.\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"740\" height=\"501\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/8-ij-jpa-data-projection.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNow, you can change the Projection class name if needed, select the desired fields, and then click \u003cstrong\u003eOK\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eBookmarkInfo.java\u003c/code\u003e interface will be generated as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epackage com.jetbrains.bookmarks;\n\nimport java.time.Instant;\n\n/**\n * Projection for {@link Bookmark}\n */\npublic interface BookmarkInfo {\n    Long getId();\n\n    String getTitle();\n\n    String getUrl();\n\n    Instant getCreatedAt();\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow, let’s update the \u003ccode\u003eBookmarkRepository\u003c/code\u003e to return the projection as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epublic interface BookmarkRepository extends JpaRepository\u0026lt;Bookmark, Long\u0026gt; {\n    List\u0026lt;BookmarkInfo\u0026gt; findAllByOrderByCreatedAtDesc();\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s also add a method to find a bookmark for the given \u003ccode\u003eid\u003c/code\u003e as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epackage com.jetbrains.bookmarks;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic interface BookmarkRepository extends JpaRepository\u0026lt;Bookmark, Long\u0026gt; {\n    List\u0026lt;BookmarkInfo\u0026gt; findAllByOrderByCreatedAtDesc();\n\n    Optional\u0026lt;BookmarkInfo\u0026gt; findBookmarkById(Long id);\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe are returning \u003ccode\u003eOptional\u0026lt;BookmarkInfo\u0026gt;\u003c/code\u003e because a bookmark with the given \u003ccode\u003eid\u003c/code\u003e may or may not exist.\u003c/p\u003e\n\n\n\n\u003cp\u003eIntelliJ IDEA provides the ability to invoke Spring Data JPA repository methods using the \u003ca href=\"https://www.jetbrains.com/help/idea/using-jpa-console.html\" target=\"_blank\" rel=\"noopener\"\u003eJPA console\u003c/a\u003e. So, we can call the repository methods and check whether they are returning the expected result or not.\u003c/p\u003e\n\n\n\n\u003cp\u003eClick on the gutter icon to run the query in the JPA console:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1286\" height=\"214\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/9-ij-call-jpa-repo-methods.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIf you are using Gradle, you’ll need to select a persistence unit from the ones available. Select the \u003ccode\u003ebookmarks.main\u003c/code\u003e Persistence Unit.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow, provide inputs to the method if required, and then you’ll see the results as follows:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1768\" height=\"388\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/10-ij-jpa-console-results.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNOTE:\u003c/strong\u003e In a typical three-layered architecture, there will be the \u003cstrong\u003eWeb\u003c/strong\u003e, \u003cstrong\u003eService\u003c/strong\u003e, and \u003cstrong\u003ePersistence\u003c/strong\u003e layers. In the Service layer, we usually implement business logic as a unit of work, which might involve multiple database operations, as a transactional operation. In our sample application, as we don’t have any complex business logic, the controller will directly talk to the repository.\u003c/p\u003e\n\n\n\n\u003ch2\u003eImplement Controller API handler methods\u003c/h2\u003e\n\n\n\n\u003cp\u003eLet’s implement the API endpoint handlers for performing CRUD operations.\u003c/p\u003e\n\n\n\n\u003cp\u003eFirst, let’s create a \u003ccode\u003eBookmarkNotFoundException\u003c/code\u003e, which we will throw when the requested bookmark is not found.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epackage com.jetbrains.bookmarks;\n\npublic class BookmarkNotFoundException extends RuntimeException {\n    public BookmarkNotFoundException(String message) {\n        super(message);\n    }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow, let’s create \u003ccode\u003eBookmarkController\u003c/code\u003e as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epackage com.jetbrains.bookmarks;\n\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\u0026#34;/api/bookmarks\u0026#34;)\nclass BookmarkController {\n    private final BookmarkRepository bookmarkRepository;\n\n    BookmarkController(BookmarkRepository bookmarkRepository) {\n        this.bookmarkRepository = bookmarkRepository;\n    }\n\n    //CRUD API handler methods\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eTIP:\u003c/strong\u003e With IntelliJ IDEA, you don’t need to manually define and inject the dependencies before using them. When you need to use another Spring bean, you can start typing the dependent bean name, and IntelliJ IDEA will show the matching beans. When you select a bean, IntelliJ IDEA will automatically define and autowire the dependent bean using a constructor.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1920\" height=\"1080\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/11-Intellij-auto-inject-on-use.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eLet’s implement API handler methods to get all bookmarks (\u003ccode\u003eGET /api/bookmarks\u003c/code\u003e) and get bookmark by id( \u003ccode\u003eGET /api/bookmarks/{id}\u003c/code\u003e) as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epackage com.jetbrains.bookmarks;\n\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(\u0026#34;/api/bookmarks\u0026#34;)\npublic class BookmarkController {\n    //...\n\n    @GetMapping\n    List\u0026lt;BookmarkInfo\u0026gt; getBookmarks() {\n        return bookmarkRepository.findAllByOrderByCreatedAtDesc();\n    }\n\n    @GetMapping(\u0026#34;/{id}\u0026#34;)\n    ResponseEntity\u0026lt;BookmarkInfo\u0026gt; getBookmarkById(@PathVariable Long id) {\n        var bookmark = \n             bookmarkRepository.findBookmarkById(id)\n             .orElseThrow(()-\u0026gt; new BookmarkNotFoundException(\u0026#34;Bookmark not found\u0026#34;));\n        return ResponseEntity.ok(bookmark);\n    }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNOTE:\u003c/strong\u003e For the \u003ccode\u003eGET /api/bookmarks\u003c/code\u003e API, we are returning all the bookmarks, but in a real-world application, we would recommend using \u003ca href=\"https://docs.spring.io/spring-data/jpa/reference/repositories/query-methods-details.html#repositories.special-parameters\" target=\"_blank\" rel=\"noopener\"\u003epagination\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eNext, let’s implement the create bookmark (\u003ccode\u003ePOST /api/bookmarks\u003c/code\u003e) handler method.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epackage com.jetbrains.bookmarks;\n\nimport jakarta.validation.Valid;\nimport jakarta.validation.constraints.NotEmpty;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.servlet.support.ServletUriComponentsBuilder;\n\nimport java.time.Instant;\nimport java.util.List;\n\n@RestController\n@RequestMapping(\u0026#34;/api/bookmarks\u0026#34;)\npublic class BookmarkController {\n    //...\n    record CreateBookmarkPayload(\n            @NotEmpty(message = \u0026#34;Title is required\u0026#34;)\n            String title,\n            @NotEmpty(message = \u0026#34;Url is required\u0026#34;)\n            String url) {}\n\n    @PostMapping\n    ResponseEntity\u0026lt;Void\u0026gt; createBookmark(\n            @Valid @RequestBody CreateBookmarkPayload payload) {\n        var bookmark = new Bookmark();\n        bookmark.setTitle(payload.title());\n        bookmark.setUrl(payload.url());\n        bookmark.setCreatedAt(Instant.now());\n        var savedBookmark = bookmarkRepository.save(bookmark);\n        var url = ServletUriComponentsBuilder.fromCurrentRequest()\n                .path(\u0026#34;/{id}\u0026#34;)\n                .build(savedBookmark.getId());\n        return ResponseEntity.created(url).build();\n    }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe have created a local record \u003ccode\u003eCreateBookmarkPayload\u003c/code\u003e to represent the request payload and used the Jakarta Bean Validation API to validate the required fields. If the request payload is valid, then we create the Bookmark object and persist it in the database. Then, we construct the URL for the newly created bookmark and send it as the \u003ccode\u003eLocation\u003c/code\u003e header. If the request payload is invalid, then by default, Spring Boot will handle this error by returning the HTTP status code \u003ccode\u003e400 - BAD_REQUEST\u003c/code\u003e with the default error response.\u003c/p\u003e\n\n\n\n\u003cp\u003eNext, let’s implement Update (\u003ccode\u003ePUT /api/bookmarks/{id}\u003c/code\u003e) and delete the bookmark (\u003ccode\u003eDELETE /api/bookmarks/{id}\u003c/code\u003e) handler methods.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epackage com.jetbrains.bookmarks;\n//imports\n\n@RestController\n@RequestMapping(\u0026#34;/api/bookmarks\u0026#34;)\npublic class BookmarkController {\n    //...\n    record UpdateBookmarkPayload(\n            @NotEmpty(message = \u0026#34;Title is required\u0026#34;)\n            String title,\n            @NotEmpty(message = \u0026#34;Url is required\u0026#34;)\n            String url) {\n    }\n\n    @PutMapping(\u0026#34;/{id}\u0026#34;)\n    ResponseEntity\u0026lt;Void\u0026gt; updateBookmark(\n            @PathVariable Long id,\n            @Valid @RequestBody UpdateBookmarkPayload payload) {\n        var bookmark =\n              bookmarkRepository.findById(id)\n                .orElseThrow(()-\u0026gt; new BookmarkNotFoundException(\u0026#34;Bookmark not found\u0026#34;));\n        bookmark.setTitle(payload.title());\n        bookmark.setUrl(payload.url());\n        bookmark.setUpdatedAt(Instant.now());\n        bookmarkRepository.save(bookmark);\n        return ResponseEntity.noContent().build();\n    }\n\n    @DeleteMapping(\u0026#34;/{id}\u0026#34;)\n    void deleteBookmark(@PathVariable Long id) {\n        var bookmark =\n             bookmarkRepository.findById(id)\n             .orElseThrow(()-\u0026gt; new BookmarkNotFoundException(\u0026#34;Bookmark not found\u0026#34;));\n        bookmarkRepository.delete(bookmark);\n    }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe have created a local record \u003ccode\u003eUpdateBookmarkPayload\u003c/code\u003e to represent the update request payload and used the Jakarta Bean Validation API to validate the required fields. If the request payload is valid, then we try to load the Bookmark object from the database. If the bookmark doesn’t exist, the code will throw a \u003ccode\u003eBookmarkNotFoundException\u003c/code\u003e. Otherwise, we will update the bookmark data in the database.\u003c/p\u003e\n\n\n\n\u003cp\u003eSimilarly, for the delete bookmark API endpoint, we try to delete the bookmark if it exists. Otherwise, a \u003ccode\u003eBookmarkNotFoundException\u003c/code\u003e is thrown.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen we throw a \u003ccode\u003eBookmarkNotFoundException\u003c/code\u003e from our handler methods, by default, Spring is going to handle it and return a response with the HTTP status code \u003ccode\u003e500 - INTERNAL_SERVER_ERROR\u003c/code\u003e. But when the bookmark is not found, it makes sense to send the \u003ccode\u003e404 - NOT_FOUND\u003c/code\u003e status code. So, let’s implement an \u003ccode\u003eExceptionHandler\u003c/code\u003e as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epackage com.jetbrains.bookmarks;\n//imports\n\n@RestController\n@RequestMapping(\u0026#34;/api/bookmarks\u0026#34;)\npublic class BookmarkController {\n    //...\n    \n    @ExceptionHandler(BookmarkNotFoundException.class)\n    ResponseEntity\u0026lt;Void\u0026gt; handle(BookmarkNotFoundException e) {\n        return ResponseEntity.notFound().build();\n    }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow, when any handler method in \u003ccode\u003eBookmarkController\u003c/code\u003e throws a \u003ccode\u003eBookmarkNotFoundException\u003c/code\u003e, it will be handled by the \u003ccode\u003eExceptionHandler\u003c/code\u003e and return the HTTP status code \u003ccode\u003e404 - NOT_FOUND\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen you create a Spring Boot application in IntelliJ IDEA, it automatically creates a Spring Boot run configuration. Now run/debug the application using the \u003ccode\u003eBookmarksApplication\u003c/code\u003e run configuration, which should start the application on port 8080.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"877\" height=\"499\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/12-ij-spring-run-config.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003eTest API endpoints using the HTTP Client\u003c/h2\u003e\n\n\n\n\u003cp\u003eIntelliJ IDEA provides a built-in HTTP Client, which we can use to invoke our API endpoints and assert the responses.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou can open the HTTP Client by selecting \u003cstrong\u003eTools | HTTP Client | Create request in HTTP Client\u003c/strong\u003e. Alternatively, you can also click on the API gutter icon on the API handler methods in \u003ccode\u003eBookmarkController\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1186\" height=\"177\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/13-ij-open-http-client.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIntelliJ IDEA will open a \u003ccode\u003e.http\u003c/code\u003e file. Once the application is started, you can invoke the \u003ccode\u003eGET /api/bookmarks\u003c/code\u003e endpoint and assert the response status code as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e### Get all bookmarks\nGET http://localhost:8080/api/bookmarks\n\n\u0026gt; {%\nclient.test(\u0026#34;Should get bookmarks successfully\u0026#34;, function () {\nclient.assert(response.status === 200, \u0026#34;Response status is not 200\u0026#34;);\n});\n%}\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou can click on the \u003cstrong\u003eRun\u003c/strong\u003e icon in the gutter to execute the API call.\u003c/p\u003e\n\n\n\n\u003cp\u003eSimilarly, you can invoke other API endpoints as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e### Get bookmark by id\nGET http://localhost:8080/api/bookmarks/1\n\n\u0026gt; {%\nclient.test(\u0026#34;Should get bookmark successfully\u0026#34;, function () {\nclient.assert(response.status === 200, \u0026#34;Response status is not 200\u0026#34;);\n});\n%}\n\n\n### Create bookmark successfully\nPOST http://localhost:8080/api/bookmarks\nContent-Type: application/json\n\n{\n  \u0026#34;title\u0026#34;: \u0026#34;bookmark title\u0026#34;,\n  \u0026#34;url\u0026#34;: \u0026#34;https://bookmark.com\u0026#34;\n}\n\n\u0026gt; {%\nclient.test(\u0026#34;Should create bookmark successfully\u0026#34;, function () {\nclient.assert(response.status === 201, \u0026#34;Response status is not 201\u0026#34;);\n});\n%}\u003c/pre\u003e\n\n\n\n\u003cp\u003eI will leave the rest of the API call invocations as an exercise for you. To learn more about the HTTP Client, you can refer to the \u003ca href=\"https://www.jetbrains.com/help/idea/http-client-in-product-code-editor.html\" target=\"_blank\" rel=\"noopener\"\u003edocumentation\u003c/a\u003e or watch \u003ca href=\"https://www.youtube.com/watch?v=mwiHAukbWjM\" target=\"_blank\" rel=\"noopener\"\u003eThe New HTTP Client\u003c/a\u003e presentation.\u003c/p\u003e\n\n\n\n\u003ch2\u003eSummary\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn this article, we learned how to create a REST API performing CRUD operations using Spring Boot talking to a PostgreSQL database. We have verified whether the application is working as expected or not using the HTTP Client.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou can find the complete code in this \u003ca href=\"https://github.com/sivaprasadreddy/bookmarks\" target=\"_blank\" rel=\"noopener\"\u003eGitHub repository\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eAs we have seen, IntelliJ IDEA Ultimate supports Spring in a way that makes it easy to build Spring Boot applications. Also, the JPA Buddy plugin makes developers more productive while using JPA and Spring Data JPA-based applications.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://www.jetbrains.com/idea/\" target=\"_blank\" rel=\"noopener\" data-test=\"blog-article-cta\"\u003eDownload IntelliJ IDEA\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eTo learn more about JPA Buddy, you can watch \u003ca href=\"https://www.youtube.com/watch?v=TpD6bT9M1CE\" target=\"_blank\" rel=\"noopener\"\u003ethis presentation\u003c/a\u003e or read the official \u003ca href=\"https://jpa-buddy.com/documentation/\" target=\"_blank\" rel=\"noopener\"\u003edocumentation\u003c/a\u003e.\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "23 min read",
  "publishedTime": null,
  "modifiedTime": null
}
