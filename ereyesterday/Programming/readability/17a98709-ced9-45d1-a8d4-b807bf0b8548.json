{
  "id": "17a98709-ced9-45d1-a8d4-b807bf0b8548",
  "title": "10 Remote Development Best Practices",
  "link": "https://blog.jetbrains.com/codecanvas/2025/07/10-remote-development-best-practices/",
  "description": "The concept of remote development is deceptively simple: spin up your development environment somewhere that’s not your local machine. The perks range from freeing up local resources to not panicking when your laptop gets stolen. Yet, there are plenty of pitfalls, including flaky setups, poor visibility, and lousy monitoring. Let’s look at some best practices […]",
  "author": "Sergei Petunin",
  "published": "Tue, 01 Jul 2025 09:42:03 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "articles-2",
    "best-practices",
    "cloud-development-environments",
    "codecanvas",
    "remote-development",
    "cde-orchestration"
  ],
  "byline": "Sergei Petunin",
  "length": 6994,
  "excerpt": "The concept of remote development is deceptively simple: spin up your development environment somewhere that’s not your local machine. The perks range from freeing up local resources to not panicking",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "The ultimate platform for managing cloud development environments Articles Best Practices Cloud Development Environments CodeCanvas Remote Development The concept of remote development is deceptively simple: spin up your development environment somewhere that’s not your local machine. The perks range from freeing up local resources to not panicking when your laptop gets stolen. Yet, there are plenty of pitfalls, including flaky setups, poor visibility, and lousy monitoring. Let’s look at some best practices of remote development and see what JetBrains has to offer. 1. Get rid of RDP/VNC/VDS If you’re still “remote developing” by pixel-streaming, you’re wasting your time. Real remote development feels local, handles flaky networks gracefully, and scales far beyond your laptop. Reality check: Streaming your whole desktop is like lugging a cinema projector over SSH. Every keystroke triggers massive pixel redraws, your IDE becomes sluggish, and one lost packet freezes everything. Why move video frames instead of code diffs? Modern remote protocols only send keystrokes and UI deltas. Latency plunges, and your IDE snaps back to life. 2. Stay online, even when you’re not Flaky Wi-Fi isn’t an excuse anymore. A proper remote development client buffers your edits locally, shows a “reconnecting” notice, and pushes your changes when you’re back online. Linting, inspections, breakpoints – they pick up seamlessly. You keep context, and your work never vanishes into thin air. 3. Enterprise-grade orchestration One VM or container remotely? Sure, great for demos. But ten teams? A dozen projects? Manual SSH scripts crumble fast. You need a Cloud Dev Environment (CDE) orchestrator that addresses the following pain points: Paint PointHand-Rolled SSH/Docker/VMCDE Orchestrator (e.g., CodeCanvas)Resource scalingStatic, brittleAuto-scale, auto-stop, snapshotsEnvironment drift“Works on my machine”Versioned templates, pre-built imagesProvisioningManual installsPre-warmed toolchains, secrets, pluginsSecurityOpen SSH risksZero-trust relays, jump servers, air-gapped lockdownVisibilityDark – no metricsDashboards for usage, health, failures If you’re not automating this stuff, you’re putting your team at a disadvantage. 4. CodeCanvas: JetBrains’ answer We built CodeCanvas to cover every base: Dev environment templates: Versioned, shareable, based on Docker images (build your own if needed), IDE backends included. Auto-provisioning: Plugins, VS Code extensions, secrets – everything installs itself. Cost control: Idle workspaces auto-stop, warm-up snapshots and standby pools minimize startup delays. Zero-trust security: WebSocket relays (no inbound pods), SSH jump servers as needed, and strict clipboard restrictions. Observability: Real-time dashboards to monitor environment creation, adoption rates, crashes, and idle times. 5. Borrow, don’t reinvent – follow the leaders GitHub Codespaces: Uses devcontainer.json, spins up on GitHub’s infrastructure. Gitpod: Declares workspace configuration via .gitpod.yml, provides consistent branch environments. AWS Cloud9: Automates EC2 provisioning and Docker setup via AWS APIs, browser-based and fully scriptable. CodeCanvas: Scalable Kubernetes-based environments (EKS, AKS, GKE, or your bare-metal clusters) designed for distributed teams. If you’re building your own, ask yourself: what do these platforms handle that I’m missing? 6. Workflow orchestration beats task automation Creating a VM is just a task. Combining container builds, secret management, post-hooks, health checks, and cleanup – that’s orchestration. True CDE platforms handle this complexity gracefully. If you’re still scripting “docker run” in shell scripts, you’re reinventing the wheel. 7. Short-lived environments are mandatory If you try to cram everything into a single long-living environment, you’ll just be stuck twiddling your thumbs during branch switches and rebuilds. When environments spin up in seconds, they become disposable. This allows a fresh environment for each feature or code review, tossed away as soon as you’re done with it. Warm-up snapshots and standby pools have turned “cold start” into a thing of the past. Short-lived CDEs ensure consistency, security, and predictable costs. 8. Security and compliance: don’t get pwned Zero trust: Authenticate and authorize every single IDE connection. Network isolation: Use per-cluster relays and jump servers with no direct SSH. Restrict clipboard actions to prevent data leaks. Policy enforcement: Align your practices with security benchmarks – development environments are vulnerable if left unguarded. 9. Metrics that actually matter Dashboards aren’t just window dressing – they drive optimization. Get an overview of: Startup latency: From spin-up to first build or indexing. Resource utilization: CPU, memory, and I/O per workspace. Idle time: Triggers for auto-shutdown. Failure rates: Backend crashes, reconnections. Use tools like Prometheus/Grafana, Dynatrace, or cloud-native monitoring to correlate developer efficiency with infrastructure health. 10. AI agent support – no longer optional Your CDE orchestration now has to treat AI agents like first-class citizens, not just humans. That means clean APIs, bulletproof permissions, and tight resource controls. Mistakes here mean you’ll find yourself quickly outdated in a landscape where AI isn’t optional anymore. Bottom line If you’re clinging to RDP, VDI, manual SSH hacks, or one-off VMs, you’re consciously choosing friction over productivity. Embrace protocol-smart remote dev clients, short-lived environment orchestration, zero-trust security, and meaningful metrics. Whether you adopt CodeCanvas, Codespaces, Gitpod, or AWS Cloud9 – these patterns aren’t optional if you care about scale, security, and developer velocity. Subscribe to CodeCanvas Blog Updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/07/CC-social-BlogSocialShare-1280x720-2x-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/codecanvas/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/CodeCanvas.svg\" alt=\"Codecanvas logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eThe ultimate platform for managing cloud development environments\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/codecanvas/category/articles-2/\"\u003eArticles\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/codecanvas/category/best-practices/\"\u003eBest Practices\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/codecanvas/category/cloud-development-environments/\"\u003eCloud Development Environments\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/codecanvas/category/codecanvas/\"\u003eCodeCanvas\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/codecanvas/category/remote-development/\"\u003eRemote Development\u003c/a\u003e\u003c/p\u003e                    \n                    \n\u003cp\u003e\u003cspan\u003eThe concept of remote development is deceptively simple: spin up your development environment somewhere that’s not your local machine. The perks range from freeing up local resources to not panicking when your laptop gets stolen.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eYet, there are plenty of pitfalls, including flaky setups, poor visibility, and lousy monitoring. Let’s look at some best practices of remote development and see what JetBrains has to offer.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003e1. Get rid of RDP/VNC/VDS\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eIf you’re still “remote developing” by pixel-streaming, you’re wasting your time. Real remote development feels local, handles flaky networks gracefully, and scales far beyond your laptop.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cb\u003eReality check:\u003c/b\u003e\u003cspan\u003e Streaming your whole desktop is like lugging a cinema projector over SSH. Every keystroke triggers massive pixel redraws, your IDE becomes sluggish, and one lost packet freezes everything. Why move video frames instead of code diffs? Modern remote protocols only send keystrokes and UI deltas. Latency plunges, and your IDE snaps back to life.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003e2. Stay online, even when you’re not\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eFlaky Wi-Fi isn’t an excuse anymore. A proper remote development client buffers your edits locally, shows a “reconnecting” notice, and pushes your changes when you’re back online. Linting, inspections, breakpoints – they pick up seamlessly. You keep context, and your work never vanishes into thin air.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003e3. Enterprise-grade orchestration\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eOne VM or container remotely? Sure, great for demos. But ten teams? A dozen projects? Manual SSH scripts crumble fast. You need a Cloud Dev Environment (CDE) orchestrator that addresses the following pain points:\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003ePaint Point\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eHand-Rolled SSH/Docker/VM\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e\u003cstrong\u003eCDE Orchestrator (e.g., CodeCanvas)\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eResource scaling\u003c/td\u003e\u003ctd\u003eStatic, brittle\u003c/td\u003e\u003ctd\u003eAuto-scale, auto-stop, snapshots\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eEnvironment drift\u003c/td\u003e\u003ctd\u003e“Works on my machine”\u003c/td\u003e\u003ctd\u003eVersioned templates, pre-built images\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eProvisioning\u003c/td\u003e\u003ctd\u003eManual installs\u003c/td\u003e\u003ctd\u003ePre-warmed toolchains, secrets, plugins\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSecurity\u003c/td\u003e\u003ctd\u003eOpen SSH risks\u003c/td\u003e\u003ctd\u003eZero-trust relays, jump servers, air-gapped lockdown\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eVisibility\u003c/td\u003e\u003ctd\u003eDark – no metrics\u003c/td\u003e\u003ctd\u003eDashboards for usage, health, failures\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eIf you’re not automating this stuff, you’re putting your team at a disadvantage.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003e4. CodeCanvas: JetBrains’ answer\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe built CodeCanvas to cover every base:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDev environment templates:\u003c/strong\u003e Versioned, shareable, based on Docker images (build your own if needed), IDE backends included.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eAuto-provisioning:\u003c/strong\u003e Plugins, VS Code extensions, secrets – everything installs itself.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eCost control:\u003c/strong\u003e Idle workspaces auto-stop, warm-up snapshots and standby pools minimize startup delays.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eZero-trust security:\u003c/strong\u003e WebSocket relays (no inbound pods), SSH jump servers as needed, and strict clipboard restrictions.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eObservability:\u003c/strong\u003e Real-time dashboards to monitor environment creation, adoption rates, crashes, and idle times.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003e5. Borrow, don’t reinvent – follow the leaders\u003c/h2\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cb\u003eGitHub Codespaces:\u003c/b\u003e\u003cspan\u003e Uses devcontainer.json, spins up on GitHub’s infrastructure.\u003c/span\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cb\u003eGitpod:\u003c/b\u003e\u003cspan\u003e Declares workspace configuration via .gitpod.yml, provides consistent branch environments.\u003c/span\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cb\u003eAWS Cloud9:\u003c/b\u003e\u003cspan\u003e Automates EC2 provisioning and Docker setup via AWS APIs, browser-based and fully scriptable.\u003c/span\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cb\u003eCodeCanvas:\u003c/b\u003e\u003cspan\u003e Scalable Kubernetes-based environments (EKS, AKS, GKE, or your bare-metal clusters) designed for distributed teams.\u003c/span\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eIf you’re building your own, ask yourself: what do these platforms handle that I’m missing?\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003e6. Workflow orchestration beats task automation\u003c/h2\u003e\n\n\n\n\u003cp\u003eCreating a VM is just a task. Combining container builds, secret management, post-hooks, health checks, and cleanup – that’s orchestration. True CDE platforms handle this complexity gracefully. If you’re still scripting “docker run” in shell scripts, you’re reinventing the wheel.\u003c/p\u003e\n\n\n\n\u003ch2\u003e7. Short-lived environments are mandatory\u003c/h2\u003e\n\n\n\n\u003cp\u003eIf you try to cram everything into a single long-living environment, you’ll just be stuck twiddling your thumbs during branch switches and rebuilds. When environments spin up in seconds, they become disposable. This allows a fresh environment for each feature or code review, tossed away as soon as you’re done with it. Warm-up snapshots and standby pools have turned “cold start” into a thing of the past. Short-lived CDEs ensure consistency, security, and predictable costs.\u003c/p\u003e\n\n\n\n\u003ch2\u003e8. Security and compliance: don’t get pwned\u003c/h2\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eZero trust:\u003c/strong\u003e Authenticate and authorize every single IDE connection.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eNetwork isolation:\u003c/strong\u003e Use per-cluster relays and jump servers with no direct SSH. Restrict clipboard actions to prevent data leaks.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003ePolicy enforcement:\u003c/strong\u003e Align your practices with security benchmarks – development environments are vulnerable if left unguarded.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003e9. Metrics that actually matter\u003c/h2\u003e\n\n\n\n\u003cp\u003eDashboards aren’t just window dressing – they drive optimization. Get an overview of:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eStartup latency:\u003c/strong\u003e From spin-up to first build or indexing.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eResource utilization:\u003c/strong\u003e CPU, memory, and I/O per workspace.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eIdle time:\u003c/strong\u003e Triggers for auto-shutdown.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eFailure rates:\u003c/strong\u003e Backend crashes, reconnections.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eUse tools like Prometheus/Grafana, Dynatrace, or cloud-native monitoring to correlate developer efficiency with infrastructure health.\u003c/p\u003e\n\n\n\n\u003ch2\u003e10. AI agent support – no longer optional\u003c/h2\u003e\n\n\n\n\u003cp\u003eYour CDE orchestration now has to treat AI agents like first-class citizens, not just humans. That means clean APIs, bulletproof permissions, and tight resource controls. Mistakes here mean you’ll find yourself quickly outdated in a landscape where AI isn’t optional anymore.\u003c/p\u003e\n\n\n\n\u003ch2\u003eBottom line\u003c/h2\u003e\n\n\n\n\u003cp\u003eIf you’re clinging to RDP, VDI, manual SSH hacks, or one-off VMs, you’re consciously choosing friction over productivity. Embrace protocol-smart remote dev clients, short-lived environment orchestration, zero-trust security, and meaningful metrics. Whether you adopt CodeCanvas, Codespaces, Gitpod, or AWS Cloud9 – these patterns aren’t optional if you care about scale, security, and developer velocity.\u003c/p\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to CodeCanvas Blog Updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
