{
  "id": "a3a805b3-89b1-439d-aff9-72edd4d2543f",
  "title": "Sources, Bytecode, Debugging",
  "link": "https://blog.jetbrains.com/idea/2025/05/sources-bytecode-debugging/",
  "description": "When debugging Java programs, developers are often under the impression that they’re interacting directly with the source code. This isn’t surprising – Java’s tooling does such an excellent job of hiding the complexity that it almost feels as if the source code exists at runtime. If you’re just starting with Java, you likely remember those […]",
  "author": "Igor Kulakov",
  "published": "Mon, 26 May 2025 12:18:20 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "idea",
    "internals",
    "java",
    "tips-tricks",
    "debug",
    "debugger"
  ],
  "byline": "Igor Kulakov",
  "length": 16939,
  "excerpt": "When debugging Java programs, developers are often under the impression that they're interacting directly with the source code. This isn’t surprising – Java’s tooling does such an excellent job of hid",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA – the IDE for Professional Development in Java and Kotlin IntelliJ IDEA Internals Java Tips \u0026 TricksSources, Bytecode, Debugging When debugging Java programs, developers are often under the impression that they’re interacting directly with the source code. This isn’t surprising – Java’s tooling does such an excellent job of hiding the complexity that it almost feels as if the source code exists at runtime. If you’re just starting with Java, you likely remember those diagrams showing how the compiler transforms source code into bytecode, which is then executed by the JVM. You might also wonder: if that’s the case, why do we examine and step through the source code rather than the bytecode? How does the JVM know anything about our sources? This article is a little different from my previous posts on debugging. Instead of focusing on how to debug a specific problem, such as an unresponsive app or a memory leak, it explores how Java and debuggers work behind the scenes. Stick around – as always, a couple of handy tricks are included. Bytecode Let’s start with a quick recap. The diagrams found in Java books and guides are indeed correct – the JVM executes bytecode. Consider the following class as an example: package dev.flounder; public class Calculator { int sum(int a, int b) { return a + b; } } When compiled, the sum() method will turn into the following bytecode: int sum(int, int); descriptor: (II)I flags: (0x0000) Code: stack=2, locals=3, args_size=3 0: iload_1 1: iload_2 2: iadd 3: ireturn Tip: You can inspect the bytecode of your classes using the javap -v command included with the JDK. If you are using IntelliJ IDEA, you can also do this from the IDE: after building your project, select a class, and then click View | Show Bytecode. Note: Since class files are binary, citing their raw contents would not be informative. For readability, the examples in this article follow the format of javap -v output. Bytecode consists of a series of compact platform-independent instructions. In the example above: iload_1 and iload_2 load the variables onto the operand stack. iadd adds the contents of the operand stack, leaving a single result value on it. ireturn returns the value from the operand stack. In addition to instructions, bytecode files also include information on the constants, the number of parameters, local variables, and the depth of the operand stack. This is all the JVM needs to execute a program written in a JVM language, such as Java, Kotlin, or Scala. Debug information Since bytecode looks completely different from your source code, referring to it while debugging would be inefficient. For this reason, the interfaces of Java debuggers – such as the JDB (the console debugger bundled with the JDK) or the one in IntelliJ IDEA – display the source code rather than bytecode. This allows you to debug the code that you wrote without having to think about the underlying bytecode being executed. For example, your interaction with the JDB might look like this: Initializing jdb ... \u003e stop at dev.flounder.Calculator:5 Deferring breakpoint dev.flounder.Calculator:5. It will be set after the class is loaded. \u003e run run dev/flounder/Main Set uncaught java.lang.Throwable Set deferred uncaught java.lang.Throwable VM Started: Set deferred breakpoint dev.flounder.Calculator:5 Breakpoint hit: \"thread=main\", dev.flounder.Calculator.sum(), line=5 bci=0 \u003e locals Method arguments: a = 1 b = 2 IntelliJ IDEA will display the debug-related information in the editor and in the Debug tool window: As you can see, both debuggers use the correct variable names and reference valid lines from our code snippet above. Since the runtime doesn’t have access to the source files, it must collect this data elsewhere. This is where debug information comes into play. Debug information (also referred to as debug symbols) is compact data that links the bytecode to the application’s sources. It is included in the .class files during compilation. There are three types of debug information: Line numbers Variable names Source file names In the following chapters, I’ll briefly explain each type of debug information and how the debugger uses it. Line numbers Line number information is stored in the LineNumberTable attribute within the bytecode file, and it looks like this: LineNumberTable: line 5: 0 line 6: 2 The table above tells the debugger the following: Line 5 contains the instruction at offset 0 Line 6 contains the instruction at offset 2 This type of debug information helps external tools, such as debuggers or profilers, trace the exact line where the program executes in the source code. Importantly, line number information is also used for source references in exception stack traces. In the following example, I compiled code from my other tutorial without line number information: Exception in thread \"main\" java.lang.NumberFormatException: For input string: \"\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67) at java.base/java.lang.Integer.parseInt(Integer.java:672) at java.base/java.lang.Integer.parseInt(Integer.java:778) at dev.flounder.Airports.parse(Airports.java) at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197) at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133) at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1939) at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509) at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499) at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596) at dev.flounder.Airports.main(Airports.java) The executable compiled without line number information produced a stack trace that lacks line numbers for the calls corresponding to my project code. The calls from the standard library and dependencies still include line numbers because they have been compiled separately and weren’t affected. Besides stack traces, you may encounter a similar situation where line numbers are involved, for example, in IntelliJ IDEA’s Frames tab: So, if you see -1 instead of actual line numbers and want to avoid this, make sure your program is compiled with line number information. Tip: You can view bytecode offset right in IntelliJ IDEA’s Frames tab. For this, add the following registry key: debugger.stack.frame.show.code.index=true. Variable names Like line number information, variable names are stored in class files. The variable table for our example looks as follows: LocalVariableTable: Start Length Slot Name Signature 0 4 0 this Ldev/flounder/Calculator; 0 4 1 a I 0 4 2 b I It contains the following information: Start: The bytecode offset where the scope of this variable begins. Length: The number of instructions during which this variable remains in scope. Slot: The index at which this variable is stored for reference. Name: The variable’s name as it appears in the source code. Signature: The variable’s data type, expressed in Java’s type signature notation. If variables are missing from the debug information, some debugger functionality might not work as expected, and you will see slot_1, slot_2, etc. instead of the actual variable names. Source file names This type of debug information indicates which source file was used to compile the class. Like line number information, its presence in the class files affects not only external tooling, but also the stack traces that your program generates: Exception in thread \"main\" java.lang.NumberFormatException: For input string: \"\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67) at java.base/java.lang.Integer.parseInt(Integer.java:672) at java.base/java.lang.Integer.parseInt(Integer.java:778) at dev.flounder.Airports.parse(Unknown Source) at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197) at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133) at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1939) at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509) at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499) at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596) at dev.flounder.Airports.main(Unknown Source) Without source file names, the corresponding stack trace calls will be marked as Unknown Source. Compiler flags As a developer, you have control over whether to include debug information in your executables and, if so, which types to include. You can manage this by using the -g compiler argument, like this: javac -g:lines,vars,source Here is the syntax: Command Result javac Compiles the application with line numbers and source file names (default for most compilers) javac -g Compiles the application with all available debug information: line numbers, variables, and source file names javac -g:lines,source Compiles the application with the specified types of debug information – line numbers and source file names in this example javac -g:none Compiles the application without the debug information Note: Defaults might vary between compilers. Some of them completely exclude debug information unless instructed otherwise. If you are using a build system, such as Maven or Gradle, you can pass the same options through compiler arguments. Maven example: \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cversion\u003e3.11.0\u003c/version\u003e \u003cconfiguration\u003e \u003ccompilerArgs\u003e \u003carg\u003e-g:vars,lines\u003c/arg\u003e \u003c/compilerArgs\u003e \u003c/configuration\u003e \u003c/plugin\u003e Gradle example: tasks.compileJava { options.compilerArgs.add(\"-g:vars,lines\") } Why remove debug information? As we’ve just seen, debug symbols enable the debugging process, which is convenient during development. For this reason, debug symbols are usually included in development builds. In production builds, they are often excluded; However, this ultimately depends on the type of project you are working on. Here are a couple of things you may want to consider: Security Since a debugger can be used to tamper with your program, including debug information makes your application slightly more vulnerable to hacking and reverse engineering, which may be undesirable for some applications. Although the absence of debug symbols might make it somewhat more difficult to interfere with your program using a debugger, it does not fully protect it. Debugging remains possible even with partial or missing debug information, so this alone will not prevent a determined individual from accessing your program’s internals. Therefore, if you are concerned about the risk of reverse engineering, you should employ additional measures, such as code obfuscation. Executable size The more information an executable contains, the larger it becomes. Exactly how much larger depends on various factors. The size of a particular class file might easily be dominated by the number of instructions and the size of the constant pool, making it impractical to provide a universal estimate. Still, to demonstrate that the difference can be substantial, I experimented with Airports.java, which we used earlier to compare stack traces. The results are 4,460 bytes without debug information compared to 5,664 bytes with it. In most cases, including debug symbols won’t hurt. However, if executable size is a concern, as is often the case with embedded systems, you might want to exclude debug symbols from your binaries. Adding sources for debugging Typically, the required sources reside within your project, so the IDE will have no trouble finding them. However, there are less common situations – for example, when the source code needed for debugging is outside your project, such as when stepping into a library used by your code. In this case, you need to add source files manually: either by placing them under a sources root or by specifying them as a dependency. During debugging, IntelliJ IDEA will automatically detect and match these files with the classes executed by the JVM. When the project is missing In most cases, you would build, launch, and debug an application in the same IDE, using the original project. But what if you have only a few source files, and the project itself is missing? Here’s a bare-bones debugging setup that will do the trick: Create an empty Java project. Add the source files under a sources root or specify them as a dependency. Launch the target application with the debug agent. In Java, this is typically done by adding a VM option, such as: -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005. Create a Remote JVM Debug run configuration with the correct connection details. Use this run configuration to attach the debugger to the target application. With this setup, you can debug a program without accessing the original project. IntelliJ IDEA will match the available sources with the runtime classes and let you use them in a debugging session. This way, even a single project or library class gives you an entry point for debugging. For a hands-on example, check out Debugger.godMode() – Hacking JVM Applications With the Debugger, where we use this technique to change a program’s behavior without accessing its source code. Source mismatch One confusing situation you might encounter during debugging is when your application appears suspended at a blank line or when the line numbers in the Frames tab don’t match those in the editor: This occurs when debugging decompiled code (which we’ll discuss in another article) or when the source code doesn’t fully match the bytecode that the JVM is executing. Since the only link between bytecode and a particular source file is the name of the file and its classes, the debugger has to rely on this information, assisted by some heuristics. This works well for most situations. However, the version of the file on disk may differ from the one used to compile the application. In the case of a partial match, the debugger will identify the discrepancies and attempt to reconcile them rather than failing fast. Depending on the extent of the differences, this might be useful, for example, if the only source that you have isn’t the closest match. Fortunately, if you have the exact version of the sources elsewhere, you can fix this issue by adding them to the project and re-running the debug session. Conclusion In this article, we’ve explored the connection between source files, bytecode, and the debugger. While not strictly required for day-to-day coding, having a clearer picture of what happens under the hood can give you a stronger grasp of the ecosystem and may occasionally help you out of non-standard situations and configuration problems. I hope you found the theory and tips useful! There are still many more topics to come in this series, so stay tuned for the next one. If there’s anything specific you’d like to see covered, or if you have ideas and feedback, we’d love to hear from you! Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/05/IJ-social-BlogSocialShare-1280x720-2x-2.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA – the IDE for Professional Development in Java and Kotlin\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/category/idea/\"\u003eIntelliJ IDEA\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/idea/category/internals/\"\u003eInternals\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/idea/category/java/\"\u003eJava\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/idea/category/tips-tricks/\"\u003eTips \u0026amp; Tricks\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eSources, Bytecode, Debugging\u003c/h2\u003e                    \n                    \u003cp\u003eWhen debugging Java programs, developers are often under the impression that they’re interacting directly with the source code. This isn’t surprising – Java’s tooling does such an excellent job of hiding the complexity that it almost feels as if the source code exists at runtime.\u003c/p\u003e\n\u003cp\u003eIf you’re just starting with Java, you likely remember those diagrams showing how the compiler transforms source code into bytecode, which is then executed by the JVM. You might also wonder: if that’s the case, why do we examine and step through the source code rather than the bytecode? How does the JVM know anything about our sources?\u003c/p\u003e\n\u003cp\u003eThis article is a little different from my \u003ca href=\"https://blog.jetbrains.com/author/igor-kulakov-jetbrains-com/\"\u003eprevious posts\u003c/a\u003e on debugging. Instead of focusing on how to debug a specific problem, such as an unresponsive app or a memory leak, it explores how Java and debuggers work behind the scenes. Stick around – as always, a couple of handy tricks are included.\u003c/p\u003e\n\u003ch2\u003eBytecode\u003c/h2\u003e\n\u003cp\u003eLet’s start with a quick recap. The diagrams found in Java books and guides are indeed correct – the JVM executes bytecode.\u003c/p\u003e\n\u003cp\u003eConsider the following class as an example:\u003c/p\u003e\n\u003cpre data-enlighter-language=\"\"\u003epackage dev.flounder;\n\npublic class Calculator {\n    int sum(int a, int b) {\n        return a + b;\n    }\n}\u003c/pre\u003e\n\u003cp\u003eWhen compiled, the \u003ccode\u003esum()\u003c/code\u003e method will turn into the following bytecode:\u003c/p\u003e\n\u003cpre\u003e\u003ccode lang=\"plain\"\u003eint sum(int, int);\n    descriptor: (II)I\n    flags: (0x0000)\n    Code:\n      stack=2, locals=3, args_size=3\n         0: iload_1\n         1: iload_2\n         2: iadd\n         3: ireturn\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cb\u003eTip\u003c/b\u003e: You can inspect the bytecode of your classes using the \u003ccode\u003ejavap -v\u003c/code\u003e command included with the JDK. If you are using IntelliJ IDEA, you can also do this from the IDE: after building your project, select a class, and then click \u003ci\u003eView\u003c/i\u003e | \u003ci\u003eShow Bytecode\u003c/i\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eNote\u003c/b\u003e: Since class files are binary, citing their raw contents would not be informative. For readability, the examples in this article follow the format of \u003ccode\u003ejavap -v\u003c/code\u003e output.\u003c/p\u003e\n\u003cp\u003eBytecode consists of a series of compact platform-independent instructions. In the example above:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eiload_1\u003c/code\u003e and \u003ccode\u003eiload_2\u003c/code\u003e load the variables onto the operand stack.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eiadd\u003c/code\u003e adds the contents of the operand stack, leaving a single result value on it.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eireturn\u003c/code\u003e returns the value from the operand stack.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIn addition to instructions, bytecode files also include information on the constants, the number of parameters, local variables, and the depth of the operand stack. This is all the JVM needs to execute a program written in a JVM language, such as Java, Kotlin, or Scala.\u003c/p\u003e\n\u003ch2\u003eDebug information\u003c/h2\u003e\n\u003cp\u003eSince bytecode looks completely different from your source code, referring to it while debugging would be inefficient. For this reason, the interfaces of Java debuggers – such as the JDB (the console debugger bundled with the JDK) or the one in IntelliJ IDEA – display the source code rather than bytecode. This allows you to debug the code that you wrote without having to think about the underlying bytecode being executed.\u003c/p\u003e\n\u003cp\u003eFor example, your interaction with the JDB might look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode lang=\"plain\"\u003eInitializing jdb ...\n\n\u0026gt; stop at dev.flounder.Calculator:5\n\nDeferring breakpoint dev.flounder.Calculator:5.\nIt will be set after the class is loaded.\n\n\u0026gt; run\n\nrun dev/flounder/Main\nSet uncaught java.lang.Throwable\nSet deferred uncaught java.lang.Throwable\nVM Started: Set deferred breakpoint dev.flounder.Calculator:5\nBreakpoint hit: \u0026#34;thread=main\u0026#34;, dev.flounder.Calculator.sum(), line=5 bci=0\n\n\u0026gt; locals\n\nMethod arguments:\na = 1\nb = 2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIntelliJ IDEA will display the debug-related information in the editor and in the \u003ci\u003eDebug\u003c/i\u003e tool window:\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/05/idea.png\" alt=\"IntelliJ IDEA shows the executed line and variable values during a debugging session\" width=\"903px\"/\u003e\u003c/p\u003e\n\u003cp\u003eAs you can see, both debuggers use the correct variable names and reference valid lines from our code snippet above.\u003c/p\u003e\n\u003cp\u003eSince the runtime doesn’t have access to the source files, it must collect this data elsewhere. This is where debug information comes into play. Debug information (also referred to as debug symbols) is compact data that links the bytecode to the application’s sources. It is included in the \u003ccode\u003e.class\u003c/code\u003e files during compilation.\u003c/p\u003e\n\u003cp\u003eThere are three types of debug information:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#line-numbers\"\u003eLine numbers\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#variable-names\"\u003eVariable names\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#source-file-names\"\u003eSource file names\u003c/a\u003e\u003c/li\u003e\u003ca href=\"#source-file-names\"\u003e\n\u003c/a\u003e\u003c/ul\u003e\u003ca href=\"#source-file-names\"\u003e\n\u003cp\u003eIn the following chapters, I’ll briefly explain each type of debug information and how the debugger uses it.\u003c/p\u003e\n\u003ch3\u003eLine numbers\u003c/h3\u003e\n\u003cp\u003eLine number information is stored in the \u003ccode\u003eLineNumberTable\u003c/code\u003e attribute within the bytecode file, and it looks like this:\u003c/p\u003e\n\u003cpre data-enlighter-language=\"\"\u003eLineNumberTable:\nline 5: 0\nline 6: 2\u003c/pre\u003e\n\u003cp\u003eThe table above tells the debugger the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLine \u003ccode\u003e5\u003c/code\u003e contains the instruction at offset \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eLine \u003ccode\u003e6\u003c/code\u003e contains the instruction at offset \u003ccode\u003e2\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis type of debug information helps external tools, such as debuggers or profilers, trace the exact line where the program executes in the source code.\u003c/p\u003e\n\u003c/a\u003e\u003cp\u003e\u003ca href=\"#source-file-names\"\u003eImportantly, line number information is also used for source references in exception stack traces. In the following example, I compiled code from \u003c/a\u003e\u003ca href=\"https://flounder.dev/posts/efficient-debugging-exceptions\" target=\"_blank\" rel=\"noopener\"\u003emy other tutorial\u003c/a\u003e without line number information:\u003c/p\u003e\n\u003cpre\u003e\u003ccode lang=\"plain\"\u003eException in thread \u0026#34;main\u0026#34; java.lang.NumberFormatException: For input string: \u0026#34;\u0026#34;\nat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\nat java.base/java.lang.Integer.parseInt(Integer.java:672)\nat java.base/java.lang.Integer.parseInt(Integer.java:778)\nat dev.flounder.Airports.parse(Airports.java)\nat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\nat java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)\nat java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1939)\nat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\nat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\nat java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\nat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\nat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\nat java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)\nat dev.flounder.Airports.main(Airports.java)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe executable compiled without line number information produced a stack trace that lacks line numbers for the calls corresponding to my project code. The calls from the standard library and dependencies still include line numbers because they have been compiled separately and weren’t affected.\u003c/p\u003e\n\u003cp\u003eBesides stack traces, you may encounter a similar situation where line numbers are involved, for example, in IntelliJ IDEA’s \u003ci\u003eFrames\u003c/i\u003e tab:\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/05/frames-without-line-numbers.png\" alt=\"IntelliJ IDEA\u0026#39;s Frames tab showing -1 instead of line numbers\" width=\"490px\"/\u003e\u003c/p\u003e\n\u003cp\u003eSo, if you see \u003ccode\u003e-1\u003c/code\u003e instead of actual line numbers and want to avoid this, make sure your program is compiled with line number information.\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eTip\u003c/b\u003e: You can view bytecode offset right in IntelliJ IDEA’s \u003ci\u003eFrames\u003c/i\u003e tab. For this, add the following \u003ca href=\"https://youtrack.jetbrains.com/articles/SUPPORT-A-1030/How-to-edit-IntelliJ-IDE-registry\" target=\"_blank\" rel=\"noopener\"\u003eregistry key\u003c/a\u003e: \u003ccode\u003edebugger.stack.frame.show.code.index=true\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/05/idea-bytecode-offset.png\" alt=\"IntelliJ IDEA shows bytecode offset next to line numbers in the Frames tab\" width=\"616px\"/\u003e\u003c/p\u003e\n\u003ch3\u003eVariable names\u003c/h3\u003e\n\u003cp\u003eLike line number information, variable names are stored in class files. The variable table for our example looks as follows:\u003c/p\u003e\n\u003cpre data-enlighter-language=\"\"\u003eLocalVariableTable:\nStart  Length  Slot  Name   Signature\n    0       4     0  this   Ldev/flounder/Calculator;\n    0       4     1     a   I\n    0       4     2     b   I\u003c/pre\u003e\n\u003cp\u003eIt contains the following information:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cb\u003eStart\u003c/b\u003e: The bytecode offset where the scope of this variable begins.\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eLength\u003c/b\u003e: The number of instructions during which this variable remains in scope.\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eSlot\u003c/b\u003e: The index at which this variable is stored for reference.\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eName\u003c/b\u003e: The variable’s name as it appears in the source code.\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eSignature\u003c/b\u003e: The variable’s data type, expressed in Java’s type signature notation.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIf variables are missing from the debug information, some debugger functionality might not work as expected, and you will see \u003ccode\u003eslot_1\u003c/code\u003e, \u003ccode\u003eslot_2\u003c/code\u003e, etc. instead of the actual variable names.\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/05/idea-without-variables.png\" alt=\"IntelliJ IDEA displays slot_1, slot_2, etc. instead of variable names in the Debug tool window\" width=\"665px\"/\u003e\u003c/p\u003e\n\u003ch3\u003eSource file names\u003c/h3\u003e\n\u003cp\u003eThis type of debug information indicates which source file was used to compile the class. Like line number information, its presence in the class files affects not only external tooling, but also the stack traces that your program generates:\u003c/p\u003e\n\u003cpre\u003e\u003ccode lang=\"plain\"\u003eException in thread \u0026#34;main\u0026#34; java.lang.NumberFormatException: For input string: \u0026#34;\u0026#34;\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:672)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:778)\n\tat dev.flounder.Airports.parse(Unknown Source)\n\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n\tat java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)\n\tat java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1939)\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n\tat java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)\n\tat dev.flounder.Airports.main(Unknown Source)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWithout source file names, the corresponding stack trace calls will be marked as \u003ccode\u003eUnknown Source\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eCompiler flags\u003c/h2\u003e\n\u003cp\u003eAs a developer, you have control over whether to include debug information in your executables and, if so, which types to include. You can manage this by using the \u003ccode\u003e-g\u003c/code\u003e compiler argument, like this:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ejavac -g:lines,vars,source\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eHere is the syntax:\u003c/p\u003e\n\u003ctable\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eCommand\u003c/td\u003e\n\u003ctd\u003eResult\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejavac\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eCompiles the application with line numbers and source file names (default for most compilers)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejavac -g\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eCompiles the application with all available debug information:\u003cbr/\u003e\nline numbers, variables, and source file names\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejavac -g:lines,source\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eCompiles the application with the specified types of debug information –\u003cbr/\u003e\nline numbers and source file names in this example\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejavac -g:none\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eCompiles the application without the debug information\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cb\u003eNote\u003c/b\u003e: Defaults might vary between compilers. Some of them completely exclude debug information unless instructed otherwise.\u003c/p\u003e\n\u003cp\u003eIf you are using a build system, such as Maven or Gradle, you can pass the same options through compiler arguments.\u003c/p\u003e\n\u003cp\u003eMaven example:\u003c/p\u003e\n\u003cpre data-enlighter-language=\"\"\u003e\u0026lt;plugin\u0026gt;\n    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n    \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt;\n    \u0026lt;version\u0026gt;3.11.0\u0026lt;/version\u0026gt;\n    \u0026lt;configuration\u0026gt;\n        \u0026lt;compilerArgs\u0026gt;\n            \u0026lt;arg\u0026gt;-g:vars,lines\u0026lt;/arg\u0026gt;\n        \u0026lt;/compilerArgs\u0026gt;\n    \u0026lt;/configuration\u0026gt;\n\u0026lt;/plugin\u0026gt;\u003c/pre\u003e\n\u003cp\u003eGradle example:\u003c/p\u003e\n\u003cpre data-enlighter-language=\"\"\u003etasks.compileJava {\n    options.compilerArgs.add(\u0026#34;-g:vars,lines\u0026#34;)\n}\u003c/pre\u003e\n\u003ch2\u003eWhy remove debug information?\u003c/h2\u003e\n\u003cp\u003eAs we’ve just seen, debug symbols enable the debugging process, which is convenient during development. For this reason, debug symbols are usually included in development builds. In production builds, they are often excluded; However, this ultimately depends on the type of project you are working on.\u003c/p\u003e\n\u003cp\u003eHere are a couple of things you may want to consider:\u003c/p\u003e\n\u003ch3\u003eSecurity\u003c/h3\u003e\n\u003cp\u003eSince a debugger can be used to tamper with your program, including debug information makes your application slightly more vulnerable to hacking and reverse engineering, which may be undesirable for some applications.\u003c/p\u003e\n\u003cp\u003eAlthough the absence of debug symbols might make it somewhat more difficult to interfere with your program using a debugger, it does not fully protect it. Debugging remains possible even with partial or missing debug information, so this alone will not prevent a determined individual from accessing your program’s internals. Therefore, if you are concerned about the risk of reverse engineering, you should employ additional measures, such as code obfuscation.\u003c/p\u003e\n\u003ch3\u003eExecutable size\u003c/h3\u003e\n\u003cp\u003eThe more information an executable contains, the larger it becomes. Exactly how much larger depends on various factors. The size of a particular class file might easily be dominated by the number of instructions and the size of the constant pool, making it impractical to provide a universal estimate. Still, to demonstrate that the difference can be substantial, I experimented with \u003ca href=\"https://flounder.dev/posts/efficient-debugging-exceptions\" target=\"_blank\" rel=\"noopener\"\u003eAirports.java\u003c/a\u003e, which we used earlier to compare stack traces. The results are \u003cb\u003e4,460\u003c/b\u003e bytes without debug information compared to \u003cb\u003e5,664\u003c/b\u003e bytes with it.\u003c/p\u003e\n\u003cp\u003eIn most cases, including debug symbols won’t hurt. However, if executable size is a concern, as is often the case with embedded systems, you might want to exclude debug symbols from your binaries.\u003c/p\u003e\n\u003ch2\u003eAdding sources for debugging\u003c/h2\u003e\n\u003cp\u003eTypically, the required sources reside within your project, so the IDE will have no trouble finding them. However, there are less common situations – for example, when the source code needed for debugging is outside your project, such as when stepping into a library used by your code.\u003c/p\u003e\n\u003cp\u003eIn this case, you need to add source files manually: either by placing them under a \u003ca href=\"https://www.jetbrains.com/help/idea/content-roots.html\" target=\"_blank\" rel=\"noopener\"\u003esources root\u003c/a\u003e or by specifying them as a dependency. During debugging, IntelliJ IDEA will automatically detect and match these files with the classes executed by the JVM.\u003c/p\u003e\n\u003ch3\u003eWhen the project is missing\u003c/h3\u003e\n\u003cp\u003eIn most cases, you would build, launch, and debug an application in the same IDE, using the original project. But what if you have only a few source files, and the project itself is missing?\u003c/p\u003e\n\u003cp\u003eHere’s a bare-bones debugging setup that will do the trick:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCreate an empty Java project.\u003c/li\u003e\n\u003cli\u003eAdd the source files under a sources root or specify them as a dependency.\u003c/li\u003e\n\u003cli\u003eLaunch the target application with the debug agent. In Java, this is typically done by adding a VM option, such as: \u003ccode\u003e-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eCreate a \u003ca href=\"https://www.jetbrains.com/help/idea/attach-to-process.html#create-rc\" target=\"_blank\" rel=\"noopener\"\u003eRemote JVM Debug\u003c/a\u003e run configuration with the correct connection details. Use this run configuration to attach the debugger to the target application.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWith this setup, you can debug a program without accessing the original project. IntelliJ IDEA will match the available sources with the runtime classes and let you use them in a debugging session. This way, even a single project or library class gives you an entry point for debugging.\u003c/p\u003e\n\u003cp\u003eFor a hands-on example, check out \u003ca href=\"https://flounder.dev/posts/debugger-god-mode\" target=\"_blank\" rel=\"noopener\"\u003eDebugger.godMode() – Hacking JVM Applications With the Debugger\u003c/a\u003e, where we use this technique to change a program’s behavior without accessing its source code.\u003c/p\u003e\n\u003ch2\u003eSource mismatch\u003c/h2\u003e\n\u003cp\u003eOne confusing situation you might encounter during debugging is when your application appears suspended at a blank line or when the line numbers in the \u003ci\u003eFrames\u003c/i\u003e tab don’t match those in the editor:\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/05/bytecode-mismatch.png\" alt=\"IntelliJ IDEA highlights a blank line as if it were executed\" width=\"606px\"/\u003e\u003c/p\u003e\n\u003cp\u003eThis occurs when debugging decompiled code (which we’ll discuss in another article) or when the source code doesn’t fully match the bytecode that the JVM is executing.\u003c/p\u003e\n\u003cp\u003eSince the only link between bytecode and a particular source file is the name of the file and its classes, the debugger has to rely on this information, assisted by some heuristics. This works well for most situations. However, the version of the file on disk may differ from the one used to compile the application. In the case of a partial match, the debugger will identify the discrepancies and attempt to reconcile them rather than failing fast. Depending on the extent of the differences, this might be useful, for example, if the only source that you have isn’t the closest match.\u003c/p\u003e\n\u003cp\u003eFortunately, if you have the exact version of the sources elsewhere, you can fix this issue by adding them to the project and re-running the debug session.\u003c/p\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eIn this article, we’ve explored the connection between source files, bytecode, and the debugger. While not strictly required for day-to-day coding, having a clearer picture of what happens under the hood can give you a stronger grasp of the ecosystem and may occasionally help you out of non-standard situations and configuration problems. I hope you found the theory and tips useful!\u003c/p\u003e\n\u003cp\u003eThere are still many more topics to come in this series, so stay tuned for the next one. If there’s anything specific you’d like to see covered, or if you have ideas and feedback, we’d love to hear from you!\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": null,
  "modifiedTime": null
}
