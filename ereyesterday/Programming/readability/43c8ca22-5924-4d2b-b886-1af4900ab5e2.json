{
  "id": "43c8ca22-5924-4d2b-b886-1af4900ab5e2",
  "title": "Documenting and explaining legacy code with GitHub Copilot: Tips and examples",
  "link": "https://github.blog/ai-and-ml/github-copilot/documenting-and-explaining-legacy-code-with-github-copilot-tips-and-examples/",
  "description": "Learn how to document and explain legacy code with GitHub Copilot with real-world examples. The post Documenting and explaining legacy code with GitHub Copilot: Tips and examples appeared first on The GitHub Blog.",
  "author": "Christopher Harrison",
  "published": "Wed, 15 Jan 2025 18:00:00 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "AI \u0026 ML",
    "GitHub Copilot"
  ],
  "byline": "Christopher Harrison",
  "length": 17757,
  "excerpt": "Learn how to document and explain legacy code with GitHub Copilot with real-world examples.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "Why did the developer bring a flashlight to the legacy codebase? Because every time they tried to refactor it, they found more bugs hiding in the dark corners. The thing is, working with legacy code can also be bad‚Äîworse than that joke even! Whether you‚Äôve inherited a decades-old codebase or are revisiting your own past work, working with a legacy codebase can be a time-consuming and overwhelming process‚Äîespecially if there‚Äôs no documentation. Having well-documented code, legacy or otherwise, is critical for maintaining software quality and informing future development work. This is where GitHub Copilot can help. While conversations around Copilot often focus on writing new code, it‚Äôs equally valuable for making sense of existing code. By using its natural language processing capabilities, you can work with Copilot to document complex logic, explain obscure functions, and even suggest improvements to enhance readability. In this blog post, we‚Äôll explore practical tips and examples for using GitHub Copilot to document and explain legacy code effectively‚Äîand all these features are available in our Copilot Free tier plan, which is included with every personal GitHub account. Whether you‚Äôre dealing with a monolithic application, cryptic comments, or no documentation at all, these techniques will help you bring clarity to your codebase and set it up for long-term success. Oh, and if you‚Äôre curious, I powered GitHub Copilot with Anthropic‚Äôs Claude 3.5 Sonnet model to run the examples below‚Äîbut you can also use models from OpenAI, too. Are you a visual learner? We have you covered üí° Why legacy code can be so challenging to work with Let‚Äôs start with the basics: Legacy code can often be hard to work with (here‚Äôs looking at you COBOL), and typically comes with a unique set of challenges that can slow down progress and frustrate even the most experienced developers. In my experience, I see five main causes: A lack of developer expertise in older technologies: If you‚Äôve been in the industry for less than a decade, you may have had little exposure to older languages like COBOL, Fortran, or even certain versions of C++. Yet these languages continue to power critical infrastructure such as financial service systems. This creates a gap in expertise, because fewer developers know how to work with them. If you‚Äôre learning COBOL today‚Äîwell, let us know, because you‚Äôre a rare breed. A lack of documentation: One of the most common challenges with legacy code is the absence of documentation. In many cases, the code was written under tight deadlines, leaving little time to create clear and thorough documentation. Over the years, the situation often worsens: Developers move on to new projects or companies, taking critical context with them. Documentation becomes outdated as patches and features are added without proper updates. This leaves teams to decipher the code‚Äôs intent and functionality through guesswork, adding unnecessary delays and complexity. The code itself: Legacy code often suffers from what‚Äôs colloquially called ‚Äúspaghetti code.‚Äù Over time, repeated updates, bug fixes, and feature grafting‚Äîoften done in a hurry‚Äîturn otherwise well-structured code into an unmaintainable tangle. This makes it: Hard to read: The logic can be deeply nested, nonlinear, and full of workarounds. Hard to improve: Without cleaning up the underlying structure, even simple changes can feel risky. Outdated practices and technologies: Legacy code reflects the tools, best practices, and architectures of the era in which it was built. Many of these are now outdated or incompatible with modern systems. If you‚Äôre reaching into an older codebase, you‚Äôll likely encounter unfamiliar frameworks, obsolete libraries, or rigid coding patterns that don‚Äôt align with today‚Äôs standards. Fear of breaking things: Perhaps the most nerve-wracking challenge is the fear of really messing things up. Legacy systems often lack robust test coverage, and dependencies can be brittle. Even small changes might cause ripple effects, introducing bugs or breaking critical functionality elsewhere. It‚Äôs normal to feel hesitant‚Äîbut that shouldn‚Äôt stop you. Let‚Äôs talk a little about comments in code. It‚Äôs often said that clean code doesn‚Äôt need comments as it‚Äôs inherently readable. While we should always strive towards writing the most readable code possible (good names, avoiding single letter variables‚Ä¶), a couple of well-placed comments can ensure the next person who comes along, including future you, can better understand what was written and why it was done that way. And those comments can help Copilot better understand the code via additional context, improving the quality of its suggestions. Remember, we don‚Äôt know how far into the future we‚Äôre talking. Prior versions of modern frameworks can be tricky to understand for current developers, let alone working with legacy languages like COBOL. How GitHub Copilot helps you when working with legacy code Ever open an old codebase and say ‚ÄúWhat‚Äôs even going on here?‚Äù Same. In those situations‚Äîor when dealing with any unfamiliar code‚ÄîGitHub Copilot can be a super helpful tool. By analyzing the context of the code you‚Äôre working on, Copilot can generate meaningful comments and explanations to help you understand complex logic and hidden dependencies. For instance, if you‚Äôre working on a cryptic function, Copilot can suggest concise summaries of what the code is doing, which is a huge time saver in my own workflows. Here are a few areas I find Copilot to be exceptionally helpful when working with legacy code: Explaining what code does: One of the biggest challenges of working with legacy code is deciphering what it does, especially if you‚Äôre unfamiliar with the older language or framework. If you‚Äôre a Python developer faced with an unfamiliar COBOL or C++ function, you can prompt Copilot by saying, ‚ÄúExplain this code to me like I‚Äôm a Python developer.‚Äù This ability to bridge knowledge gaps saves hours of manual interpretation. Translate code into a language you understand: While Copilot isn‚Äôt a magic wand for perfectly translating legacy code, it can assist in converting older languages or syntaxes into more modern equivalents. Think of it like translating idioms with Google Translate‚Äîit can handle the raw translation but may require human input for context, nuance, or outdated libraries. Just like you might need a bit more finessing to really translate a piece of text with Google Translate, you might need to do the same with code and GitHub Copilot. Modernizing legacy code often involves not just syntax changes, but structural updates to align with today‚Äôs standards, frameworks, and libraries. Copilot provides a starting point, helping automate parts of the process. Refactor for readability and maintainability: Introducing new features and patching old bugs often clutters up legacy code, making it that much more difficult to work with. Copilot can assist in refactoring the code to make it cleaner and more maintainable by: Suggesting cleaner logic and structure. Adding inline comments and docstrings. Breaking down large, complex functions into smaller, modular components. Generate documentation: Legacy systems often lack proper documentation, leaving you to rely on guesswork. GitHub Copilot can help by generating: Docstrings for functions and methods. Inline comments to clarify complex logic. Summaries for cryptic or deeply nested code blocks. You can also use Copilot to build clearer documentation alongside your improvements, which can be a huge help to future you and your teammates. How to document and explain legacy code with GitHub Copilot Documenting and understanding legacy code often go hand in hand. Like I said earlier, the old axiom that ‚Äúwell-written code doesn‚Äôt need comments‚Äù is a big fallacy in my eyes‚Äîespecially with legacy systems. After all, if you‚Äôre asking Copilot to explain a block of code, that‚Äôs a clear sign it isn‚Äôt readable to you and needs better documentation. Here‚Äôs how GitHub Copilot can help: Use Copilot to explain code: When you encounter unclear or cryptic code, GitHub Copilot can generate explanations to demystify its purpose. Simply highlight the code block and ask Copilot to explain it. For example, you can prompt Copilot to: ‚ÄúExplain what this function does.‚Äù ‚ÄúSummarize this code for me.‚Äù ‚ÄúWhat is the purpose of this block?‚Äù By providing concise explanations, Copilot can help give you a clearer understanding of what the code is doing and why. Document code with Copilot: Once you understand the code, the next step is documenting it for clarity and future maintainability. With GitHub Copilot, you can: Generate inline comments to explain individual lines or logic paths. Add docstrings to summarize function inputs, outputs, and purposes. Create block comments to describe what larger chunks of code do. To get the best results, be explicit with your prompts. For example: ‚ÄúAdd inline comments to explain this code.‚Äù ‚ÄúGenerate a docstring for this function.‚Äù ‚ÄúDocument this block with a summary comment.‚Äù The more context you provide, the more accurate and useful Copilot‚Äôs suggestions will be. And that leads us into the next tip‚Ä¶ Improve Copilot‚Äôs suggestions with comments: Comments don‚Äôt just help humans, they help Copilot, too. The more your code is documented, the better Copilot can understand it and provide relevant suggestions. If you have two similar code blocks, one with comments and one without, Copilot will generally work more effectively with the documented version. At the end of the day, better documentation leads to clearer code, which makes future refactoring and development faster and more reliable. Copilot can help you tackle the initial challenge of understanding cryptic code and makes it easier to leave the codebase in a cleaner, more maintainable state for the next dev to tackle. A step-by-step guide to documenting and explaining legacy code Working with legacy code doesn‚Äôt have to be intimidating. With GitHub Copilot, you can transform old, unclear code into a well-documented, maintainable resource. Here‚Äôs how to get started: Step 1: Get the big picture Skim the codebase to map out its structure and find the areas that need the most attention. No need to sweat every line‚Äîstart with the essentials. üí° Pro tip: Use GitHub Copilot Chat to ask: ‚ÄúWhat does this module do?‚Äù ‚ÄúCan you summarize this function?‚Äù Step 2: Add function and class summaries Select a function or class and use Copilot to generate comments: Highlight the code and ask: ‚ÄúWrite a docstring for this function.‚Äù Refine Copilot‚Äôs response to make sure it‚Äôs accurate and detailed. Step 3: Clarify tricky logic For complex code, use inline comments to explain what‚Äôs going on: Highlight the block and ask: ‚ÄúExplain this loop.‚Äù or ‚ÄúWhat‚Äôs this condition checking?‚Äù Validate Copilot‚Äôs suggestions and adjust for any nuances in the code. Step 4: Document edge cases Legacy code often hides assumptions and edge cases. Identify these and ask Copilot: ‚ÄúWhat edge cases does this handle?‚Äù ‚ÄúExplain the assumptions in this logic.‚Äù And make sure to add comments or external notes to capture this info for your team to reference (or yourself!). Step 5: Create a high-level README Use Copilot to help craft a README that explains the system‚Äôs purpose, architecture, and quirks: Ask: ‚ÄúWrite a README section for this codebase.‚Äù Include diagrams or examples if possible for extra clarity. Step 6: Refactor as you go While documenting, you‚Äôll spot opportunities for cleaner code. Use Copilot to suggest improvements: ‚ÄúSimplify this function.‚Äù ‚ÄúSuggest a better way to handle this loop.‚Äù Add comments or commit messages to explain your changes. Step 7: Review and collaborate Share your work with your team and encourage collaboration. Copilot makes it easy for everyone to contribute comments or refine documentation. By making documentation part of your workflow (and letting Copilot do the heavy lifting), you‚Äôll untangle even the messiest legacy code‚Äîand set your team up for smoother development in the future. Documenting and explaining legacy with GitHub Copilot: A practical example with Python 2 Ok, we‚Äôve talked a lot about documenting and explaining legacy code with GitHub Copilot. Now it‚Äôs time to jump into a real-world example. While we offer documentation with examples of documenting and explaining COBOL code with Copilot, I‚Äôll be honest: I‚Äôm too young to be a COBOL expert. So for this example, I‚Äôm going to walk you through a common use case I see in my day-to-day work: documenting and explaining Python 2 code in preparation to modernize it into Python 3 code. Let‚Äôs start with a basic block of code: import urllib2 import cStringIO import ConfigParser def fetch_url(url): response = urllib2.urlopen(url) return response.read() def parse_ini(content): config = ConfigParser.ConfigParser() config.readfp(cStringIO.StringIO(content)) return config url = 'http://example.com/config.ini' content = fetch_url(url) print content config = parse_ini(content) print config.sections() Right off the bat, I have a rough idea of what this does‚Äîbut not an exact idea. Here‚Äôs where GitHub Copilot comes in. First, I highlight the code block above in my editor, use the slash command /explain, and then tailor it with the following prompt: I‚Äôm a Python 3 developer. Help me understand this code. Copilot then responds with the following: This code fetches an INI configuration file from a specified URL and parses its content to extract configuration sections. It then prints the raw content of the INI file and the list of sections found in the parsed configuration. Well, that‚Äôs helpful. It looks like the code above is using a few import modules to make HTTP requests and handling the parsing of INI configuration files with a few simple functions. So, now that I understand what the code above is doing, it‚Äôs time to document it with comments. To do that, I follow up on my original Copilot prompt with the following: Add comments to document this code. From there, Copilot returns the following code with comments: import urllib2 # Library to open and read URLs (Python 2) import cStringIO # Library to handle string as file-like objects (Python 2) import ConfigParser # Library to parse INI configuration files (Python 2) def fetch_url(url): # Open the URL and read its content response = urllib2.urlopen(url) return response.read() def parse_ini(content): # Create a ConfigParser object config = ConfigParser.ConfigParser() # Read the INI content from the string config.readfp(cStringIO.StringIO(content)) return config # URL of the INI file to fetch url = 'http://example.com/config.ini' # Fetch the content of the INI file from the URL content = fetch_url(url) # Print the fetched content print content # Parse the fetched INI content config = parse_ini(content) # Print the sections of the parsed INI configuration print config.sections() Not only is this an incredibly quick process, but it‚Äôs a simple example to show how useful Copilot can be in these types of instances. I went from having a vague sense of what some legacy Python 2 code does to having a deeper understanding of it‚Äîand I was able to document that for myself and others on my team. Once you have the above information, it‚Äôs easy to direct Copilot to rewrite the above code in Python 3‚Äîthat‚Äôs a lesson for another article, although you should try it yourself. Here are a few best practices to keep in mind when you‚Äôre documenting and explaining legacy code: Tell Copilot who you are: By telling Copilot your background (e.g., ‚ÄúI‚Äôm a Python developer‚Äù), it will tailor its explanations and suggestions to your level of expertise and preferred coding style. Use the /explain slash command: The /explain command in Copilot Chat helps you understand the intent or functionality of legacy code. This is especially useful when refactoring older codebases or debugging unclear logic. Ask Copilot for targeted suggestions: Copilot can be more effective if you provide specific instructions for what you‚Äôre trying to achieve, like ‚Äúmodernize‚Äù or ‚Äúreplace deprecated methods.‚Äù Iterate with feedback: Copilot‚Äôs suggestions improve when you interact with it. After receiving a suggestion, refine it by adding details or asking follow-up questions. Take this with you Working with legacy code doesn‚Äôt have to be your worst nightmare (although COBOL does scare me, if I‚Äôm being honest). While it often presents unique challenges‚Äîlike outdated technologies, a lack of documentation, and tangled logic‚Äîtools like GitHub Copilot make the process of understanding and documenting old code far more manageable. Remember, good documentation isn‚Äôt just about understanding the past‚Äîit‚Äôs an investment in your team‚Äôs future. With clear, well-documented code you reduce the risk of errors, accelerate development, and make your systems easier to maintain and modernize over time. And with GitHub Copilot Free, these powerful features are readily available to every developer, no matter the size of the codebase you‚Äôre working with. So, next time you find yourself navigating the dark corners of a legacy codebase, don‚Äôt forget to bring your flashlight‚Äîand GitHub Copilot. Your future self (and team) will thank you. Start using GitHub Copilot for free Our free version of GitHub Copilot is included by default in personal GitHub accounts and VS Code to help you start new projects, manage existing repositories, and more. Start using GitHub Copilot \u003e Written by Senior Developer Advocate, GitHub",
  "image": "https://github.blog/wp-content/uploads/2025/01/copilot-header-2.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eWhy did the developer bring a flashlight to the legacy codebase? Because every time they tried to refactor it, they found more bugs hiding in the dark corners.\u003c/p\u003e\n\u003cp\u003eThe thing is, working with legacy code can also be bad‚Äîworse than that joke even! Whether you‚Äôve inherited a decades-old codebase or are revisiting your own past work, working with a legacy codebase can be a time-consuming and overwhelming process‚Äîespecially if there‚Äôs no documentation. Having well-documented code, legacy or otherwise, is critical for maintaining software quality and informing future development work.\u003c/p\u003e\n\u003cp\u003eThis is where GitHub Copilot can help. While conversations around Copilot often focus on writing new code, it‚Äôs equally valuable for making sense of existing code. By using its natural language processing capabilities, you can work with Copilot to document complex logic, explain obscure functions, and even suggest improvements to enhance readability.\u003c/p\u003e\n\u003cp\u003eIn this blog post, we‚Äôll explore practical tips and examples for using GitHub Copilot to document and explain legacy code effectively‚Äîand all these features are available in our Copilot Free tier plan, which is included with every personal GitHub account. Whether you‚Äôre dealing with a monolithic application, cryptic comments, or no documentation at all, these techniques will help you bring clarity to your codebase and set it up for long-term success.\u003c/p\u003e\n\u003cp\u003eOh, and if you‚Äôre curious, I powered GitHub Copilot with Anthropic‚Äôs Claude 3.5 Sonnet model to run the examples below‚Äîbut you can also use models from OpenAI, too.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAre you a visual learner? We have you covered üí°\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\n\t\t\t\u003ciframe loading=\"lazy\" src=\"https://www.youtube.com/embed/XIXzU-5aYrw?feature=oembed\" title=\"YouTube video player\" allow=\"accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" frameborder=\"0\"\u003e\u003c/iframe\u003e\n\t\t\u003c/p\u003e\n\n\u003ch2 id=\"why-legacy-code-can-be-so-challenging-to-work-with\" id=\"why-legacy-code-can-be-so-challenging-to-work-with\"\u003eWhy legacy code can be so challenging to work with\u003ca href=\"#why-legacy-code-can-be-so-challenging-to-work-with\" aria-label=\"Why legacy code can be so challenging to work with\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLet‚Äôs start with the basics: Legacy code can often be hard to work with (here‚Äôs looking at you COBOL), and typically comes with a unique set of challenges that can slow down progress and frustrate even the most experienced developers.\u003c/p\u003e\n\u003cp\u003eIn my experience, I see five main causes:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eA lack of developer expertise in older technologies\u003c/strong\u003e: If you‚Äôve been in the industry for less than a decade, you may have had little exposure to older languages like COBOL, Fortran, or even certain versions of C++. Yet these languages continue to power critical infrastructure such as financial service systems. This creates a gap in expertise, because fewer developers know how to work with them. If you‚Äôre learning COBOL today‚Äîwell, let us know, because you‚Äôre a rare breed.\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eA lack of documentation\u003c/strong\u003e: One of the most common challenges with legacy code is the absence of documentation. In many cases, the code was written under tight deadlines, leaving little time to create clear and thorough documentation. Over the years, the situation often worsens:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDevelopers move on to new projects or companies, taking critical context with them.  \u003c/li\u003e\n\u003cli\u003eDocumentation becomes outdated as patches and features are added without proper updates. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis leaves teams to decipher the code‚Äôs intent and functionality through guesswork, adding unnecessary delays and complexity.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eThe code itself\u003c/strong\u003e: Legacy code often suffers from what‚Äôs colloquially called ‚Äúspaghetti code.‚Äù Over time, repeated updates, bug fixes, and feature grafting‚Äîoften done in a hurry‚Äîturn otherwise well-structured code into an unmaintainable tangle. This makes it:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eHard to read\u003c/strong\u003e: The logic can be deeply nested, nonlinear, and full of workarounds.  \u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHard to improve\u003c/strong\u003e: Without cleaning up the underlying structure, even simple changes can feel risky.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOutdated practices and technologies:\u003c/strong\u003e Legacy code reflects the tools, best practices, and architectures of the era in which it was built. Many of these are now outdated or incompatible with modern systems. If you‚Äôre reaching into an older codebase, you‚Äôll likely encounter unfamiliar frameworks, obsolete libraries, or rigid coding patterns that don‚Äôt align with today‚Äôs standards.\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eFear of breaking things\u003c/strong\u003e: Perhaps the most nerve-wracking challenge is the fear of really messing things up. Legacy systems often lack robust test coverage, and dependencies can be brittle. Even small changes might cause ripple effects, introducing bugs or breaking critical functionality elsewhere. It‚Äôs normal to feel hesitant‚Äîbut that shouldn‚Äôt stop you.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eLet‚Äôs talk a little about comments in code. It‚Äôs often said that clean code doesn‚Äôt need comments as it‚Äôs inherently readable. While we should always strive towards writing the most readable code possible (good names, avoiding single letter variables‚Ä¶), a couple of well-placed comments can ensure the next person who comes along, including future you, can better understand what was written and \u003cem\u003ewhy\u003c/em\u003e it was done that way. And those comments can help Copilot better understand the code via additional context, improving the quality of its suggestions.\u003c/p\u003e\n\u003cp\u003eRemember, we don‚Äôt know how far into the future we‚Äôre talking. Prior versions of modern frameworks can be tricky to understand for current developers, let alone working with legacy languages like COBOL.\u003c/p\u003e\n\u003ch2 id=\"how-github-copilot-helps-you-when-working-with-legacy-code\" id=\"how-github-copilot-helps-you-when-working-with-legacy-code\"\u003eHow GitHub Copilot helps you when working with legacy code\u003ca href=\"#how-github-copilot-helps-you-when-working-with-legacy-code\" aria-label=\"How GitHub Copilot helps you when working with legacy code\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eEver open an old codebase and say ‚ÄúWhat‚Äôs even going on here?‚Äù\u003c/p\u003e\n\u003cp\u003eSame.\u003c/p\u003e\n\u003cp\u003eIn those situations‚Äîor when dealing with any unfamiliar code‚ÄîGitHub Copilot can be a super helpful tool. By analyzing the context of the code you‚Äôre working on, Copilot can generate meaningful comments and explanations to help you understand complex logic and hidden dependencies.\u003c/p\u003e\n\u003cp\u003eFor instance, if you‚Äôre working on a cryptic function, Copilot can suggest concise summaries of what the code is doing, which is a huge time saver in my own workflows.\u003c/p\u003e\n\u003cp\u003eHere are a few areas I find Copilot to be exceptionally helpful when working with legacy code:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eExplaining what code does:\u003c/strong\u003e One of the biggest challenges of working with legacy code is deciphering what it does, especially if you‚Äôre unfamiliar with the older language or framework. If you‚Äôre a Python developer faced with an unfamiliar COBOL or C++ function, you can prompt Copilot by saying, ‚ÄúExplain this code to me like I‚Äôm a Python developer.‚Äù This ability to bridge knowledge gaps saves hours of manual interpretation.\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eTranslate code into a language you understand:\u003c/strong\u003e While Copilot isn‚Äôt a magic wand for perfectly translating legacy code, it can assist in converting older languages or syntaxes into more modern equivalents. Think of it like translating idioms with Google Translate‚Äîit can handle the raw translation but may require human input for context, nuance, or outdated libraries. Just like you might need a bit more finessing to really translate a piece of text with Google Translate, you might need to do the same with code and GitHub Copilot. Modernizing legacy code often involves not just syntax changes, but structural updates to align with today‚Äôs standards, frameworks, and libraries. Copilot provides a starting point, helping automate parts of the process.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eRefactor for readability and maintainability:\u003c/strong\u003e Introducing new features and patching old bugs often clutters up legacy code, making it that much more difficult to work with. Copilot can assist in refactoring the code to make it cleaner and more maintainable by:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSuggesting cleaner logic and structure.  \u003c/li\u003e\n\u003cli\u003eAdding inline comments and docstrings.  \u003c/li\u003e\n\u003cli\u003eBreaking down large, complex functions into smaller, modular components.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGenerate documentation:\u003c/strong\u003e Legacy systems often lack proper documentation, leaving you to rely on guesswork. GitHub Copilot can help by generating:\n\u003cul\u003e\n\u003cli\u003eDocstrings for functions and methods.  \u003c/li\u003e\n\u003cli\u003eInline comments to clarify complex logic.  \u003c/li\u003e\n\u003cli\u003eSummaries for cryptic or deeply nested code blocks.  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can also use Copilot to build clearer documentation alongside your improvements, which can be a huge help to future you and your teammates.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"how-to-document-and-explain-legacy-code-with-github-copilot\" id=\"how-to-document-and-explain-legacy-code-with-github-copilot\"\u003eHow to document and explain legacy code with GitHub Copilot\u003ca href=\"#how-to-document-and-explain-legacy-code-with-github-copilot\" aria-label=\"How to document and explain legacy code with GitHub Copilot\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eDocumenting and understanding legacy code often go hand in hand. Like I said earlier, the old axiom that ‚Äúwell-written code doesn‚Äôt need comments‚Äù is a big fallacy in my eyes‚Äîespecially with legacy systems. After all, if you‚Äôre asking Copilot to explain a block of code, that‚Äôs a clear sign it isn‚Äôt readable to you and needs better documentation.\u003c/p\u003e\n\u003cp\u003eHere‚Äôs how GitHub Copilot can help:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eUse Copilot to explain code:\u003c/strong\u003e When you encounter unclear or cryptic code, GitHub Copilot can generate explanations to demystify its purpose. Simply highlight the code block and ask Copilot to explain it. For example, you can prompt Copilot to:\n\u003cul\u003e\n\u003cli\u003e‚ÄúExplain what this function does.‚Äù  \u003c/li\u003e\n\u003cli\u003e‚ÄúSummarize this code for me.‚Äù  \u003c/li\u003e\n\u003cli\u003e‚ÄúWhat is the purpose of this block?‚Äù  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBy providing concise explanations, Copilot can help give you a clearer understanding of what the code is doing and why.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eDocument code with Copilot:\u003c/strong\u003e Once you understand the code, the next step is documenting it for clarity and future maintainability. With GitHub Copilot, you can:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGenerate \u003cstrong\u003einline comments\u003c/strong\u003e to explain individual lines or logic paths.  \u003c/li\u003e\n\u003cli\u003eAdd \u003cstrong\u003edocstrings\u003c/strong\u003e to summarize function inputs, outputs, and purposes.  \u003c/li\u003e\n\u003cli\u003eCreate \u003cstrong\u003eblock comments\u003c/strong\u003e to describe what larger chunks of code do.  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo get the best results, be explicit with your prompts. For example:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e‚ÄúAdd inline comments to explain this code.‚Äù  \u003c/li\u003e\n\u003cli\u003e‚ÄúGenerate a docstring for this function.‚Äù  \u003c/li\u003e\n\u003cli\u003e‚ÄúDocument this block with a summary comment.‚Äù  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe more context you provide, the more accurate and useful Copilot‚Äôs suggestions will be. And that leads us into the next tip‚Ä¶\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eImprove Copilot‚Äôs suggestions with comments:\u003c/strong\u003e Comments don‚Äôt just help humans, they help Copilot, too. The more your code is documented, the better Copilot can understand it and provide relevant suggestions. If you have two similar code blocks, one with comments and one without, Copilot will generally work more effectively with the documented version.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAt the end of the day, better documentation leads to clearer code, which makes future refactoring and development faster and more reliable. Copilot can help you tackle the initial challenge of understanding cryptic code and makes it easier to leave the codebase in a cleaner, more maintainable state for the next dev to tackle.\u003c/p\u003e\n\u003ch2 id=\"a-step-by-step-guide-to-documenting-and-explaining-legacy-code\" id=\"a-step-by-step-guide-to-documenting-and-explaining-legacy-code\"\u003eA step-by-step guide to documenting and explaining legacy code\u003ca href=\"#a-step-by-step-guide-to-documenting-and-explaining-legacy-code\" aria-label=\"A step-by-step guide to documenting and explaining legacy code\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWorking with legacy code doesn‚Äôt have to be intimidating. With GitHub Copilot, you can transform old, unclear code into a well-documented, maintainable resource. Here‚Äôs how to get started:\u003c/p\u003e\n\u003ch3 id=\"step-1-get-the-big-picture\" id=\"step-1-get-the-big-picture\"\u003eStep 1: Get the big picture\u003ca href=\"#step-1-get-the-big-picture\" aria-label=\"Step 1: Get the big picture\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSkim the codebase to map out its structure and find the areas that need the most attention. No need to sweat every line‚Äîstart with the essentials.\u003c/p\u003e\n\u003cp\u003eüí° \u003cstrong\u003ePro tip:\u003c/strong\u003e Use GitHub Copilot Chat to ask:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003e‚ÄúWhat does this module do?‚Äù\u003c/em\u003e  \u003c/li\u003e\n\u003cli\u003e\u003cem\u003e‚ÄúCan you summarize this function?‚Äù\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"step-2-add-function-and-class-summaries\" id=\"step-2-add-function-and-class-summaries\"\u003eStep 2: Add function and class summaries\u003ca href=\"#step-2-add-function-and-class-summaries\" aria-label=\"Step 2: Add function and class summaries\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSelect a function or class and use Copilot to generate comments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHighlight the code and ask: \u003cem\u003e‚ÄúWrite a docstring for this function.‚Äù\u003c/em\u003e  \u003c/li\u003e\n\u003cli\u003eRefine Copilot‚Äôs response to make sure it‚Äôs accurate and detailed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"step-3-clarify-tricky-logic\" id=\"step-3-clarify-tricky-logic\"\u003eStep 3: Clarify tricky logic\u003ca href=\"#step-3-clarify-tricky-logic\" aria-label=\"Step 3: Clarify tricky logic\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eFor complex code, use inline comments to explain what‚Äôs going on:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHighlight the block and ask: \u003cem\u003e‚ÄúExplain this loop.‚Äù\u003c/em\u003e or \u003cem\u003e‚ÄúWhat‚Äôs this condition checking?‚Äù\u003c/em\u003e  \u003c/li\u003e\n\u003cli\u003eValidate Copilot‚Äôs suggestions and adjust for any nuances in the code.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"step-4-document-edge-cases\" id=\"step-4-document-edge-cases\"\u003eStep 4: Document edge cases\u003ca href=\"#step-4-document-edge-cases\" aria-label=\"Step 4: Document edge cases\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLegacy code often hides assumptions and edge cases. Identify these and ask Copilot:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003e‚ÄúWhat edge cases does this handle?‚Äù\u003c/em\u003e  \u003c/li\u003e\n\u003cli\u003e\u003cem\u003e‚ÄúExplain the assumptions in this logic.‚Äù\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAnd make sure to add comments or external notes to capture this info for your team to reference (or yourself!).\u003c/p\u003e\n\u003ch3 id=\"step-5-create-a-high-level-readme\" id=\"step-5-create-a-high-level-readme\"\u003eStep 5: Create a high-level README\u003ca href=\"#step-5-create-a-high-level-readme\" aria-label=\"Step 5: Create a high-level README\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eUse Copilot to help craft a README that explains the system‚Äôs purpose, architecture, and quirks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAsk: \u003cem\u003e‚ÄúWrite a README section for this codebase.‚Äù\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eInclude diagrams or examples if possible for extra clarity.\u003c/p\u003e\n\u003ch3 id=\"step-6-refactor-as-you-go\" id=\"step-6-refactor-as-you-go\"\u003eStep 6: Refactor as you go\u003ca href=\"#step-6-refactor-as-you-go\" aria-label=\"Step 6: Refactor as you go\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWhile documenting, you‚Äôll spot opportunities for cleaner code. Use Copilot to suggest improvements:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003e‚ÄúSimplify this function.‚Äù\u003c/em\u003e  \u003c/li\u003e\n\u003cli\u003e\u003cem\u003e‚ÄúSuggest a better way to handle this loop.‚Äù\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdd comments or commit messages to explain your changes.\u003c/p\u003e\n\u003ch3 id=\"step-7-review-and-collaborate\" id=\"step-7-review-and-collaborate\"\u003eStep 7: Review and collaborate\u003ca href=\"#step-7-review-and-collaborate\" aria-label=\"Step 7: Review and collaborate\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eShare your work with your team and encourage collaboration. Copilot makes it easy for everyone to contribute comments or refine documentation.\u003c/p\u003e\n\u003cp\u003eBy making documentation part of your workflow (and letting Copilot do the heavy lifting), you‚Äôll untangle even the messiest legacy code‚Äîand set your team up for smoother development in the future.\u003c/p\u003e\n\u003ch2 id=\"documenting-and-explaining-legacy-with-github-copilot-a-practical-example-with-python-2\" id=\"documenting-and-explaining-legacy-with-github-copilot-a-practical-example-with-python-2\"\u003eDocumenting and explaining legacy with GitHub Copilot: A practical example with Python 2\u003ca href=\"#documenting-and-explaining-legacy-with-github-copilot-a-practical-example-with-python-2\" aria-label=\"Documenting and explaining legacy with GitHub Copilot: A practical example with Python 2\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eOk, we‚Äôve talked a lot about documenting and explaining legacy code with GitHub Copilot. Now it‚Äôs time to jump into a real-world example.\u003c/p\u003e\n\u003cp\u003eWhile we offer documentation with examples of \u003ca href=\"https://docs.github.com/en/copilot/example-prompts-for-github-copilot-chat/documenting-code/documenting-legacy-code\"\u003edocumenting\u003c/a\u003e and \u003ca href=\"https://docs.github.com/en/copilot/example-prompts-for-github-copilot-chat/documenting-code/explaining-legacy-code\"\u003eexplaining\u003c/a\u003e COBOL code with Copilot, I‚Äôll be honest: I‚Äôm too young to be a COBOL expert. So for this example, I‚Äôm going to walk you through a common use case I see in my day-to-day work: documenting and explaining Python 2 code in preparation to modernize it into Python 3 code.\u003c/p\u003e\n\u003cp\u003eLet‚Äôs start with a basic block of code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport urllib2\nimport cStringIO\nimport ConfigParser\n\ndef fetch_url(url):\n    response = urllib2.urlopen(url)\n    return response.read()\n\ndef parse_ini(content):\n    config = ConfigParser.ConfigParser()\n    config.readfp(cStringIO.StringIO(content))\n    return config\n\nurl = \u0026#39;http://example.com/config.ini\u0026#39;\ncontent = fetch_url(url)\nprint content\n\nconfig = parse_ini(content)\nprint config.sections()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRight off the bat, I have a rough idea of what this does‚Äîbut not an exact idea.\u003c/p\u003e\n\u003cp\u003eHere‚Äôs where GitHub Copilot comes in. First, I highlight the code block above in my editor, use the slash command \u003ccode\u003e/explain\u003c/code\u003e, and then tailor it with the following prompt: \u003ccode\u003eI‚Äôm a Python 3 developer. Help me understand this code.\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eCopilot then responds with the following:\u003c/p\u003e\n\u003cblockquote\u003e\u003cp\u003e\n  This code fetches an INI configuration file from a specified URL and parses its content to extract configuration sections. It then prints the raw content of the INI file and the list of sections found in the parsed configuration.\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eWell, that‚Äôs helpful. It looks like the code above is using a few import modules to make HTTP requests and handling the parsing of INI configuration files with a few simple functions.\u003c/p\u003e\n\u003cp\u003eSo, now that I understand what the code above is doing, it‚Äôs time to document it with comments. To do that, I follow up on my original Copilot prompt with the following: \u003ccode\u003eAdd comments to document this code.\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eFrom there, Copilot returns the following code with comments:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport urllib2  # Library to open and read URLs (Python 2)\nimport cStringIO  # Library to handle string as file-like objects (Python 2)\nimport ConfigParser  # Library to parse INI configuration files (Python 2)\n\ndef fetch_url(url):\n    # Open the URL and read its content\n    response = urllib2.urlopen(url)\n    return response.read()\n\ndef parse_ini(content):\n    # Create a ConfigParser object\n    config = ConfigParser.ConfigParser()\n    # Read the INI content from the string\n    config.readfp(cStringIO.StringIO(content))\n    return config\n\n# URL of the INI file to fetch\nurl = \u0026#39;http://example.com/config.ini\u0026#39;\n# Fetch the content of the INI file from the URL\ncontent = fetch_url(url)\n# Print the fetched content\nprint content\n\n# Parse the fetched INI content\nconfig = parse_ini(content)\n# Print the sections of the parsed INI configuration\nprint config.sections()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNot only is this an incredibly quick process, but it‚Äôs a simple example to show how useful Copilot can be in these types of instances. I went from having a vague sense of what some legacy Python 2 code does to having a deeper understanding of it‚Äîand I was able to document that for myself and others on my team.\u003c/p\u003e\n\u003cp\u003eOnce you have the above information, it‚Äôs easy to direct Copilot to rewrite the above code in Python 3‚Äîthat‚Äôs a lesson for another article, although you should try it yourself.\u003c/p\u003e\n\u003ch4 id=\"here-are-a-few-best-practices-to-keep-in-mind-when-youre-documenting-and-explaining-legacy-code\" id=\"here-are-a-few-best-practices-to-keep-in-mind-when-youre-documenting-and-explaining-legacy-code\"\u003eHere are a few best practices to keep in mind when you‚Äôre documenting and explaining legacy code:\u003ca href=\"#here-are-a-few-best-practices-to-keep-in-mind-when-youre-documenting-and-explaining-legacy-code\" aria-label=\"Here are a few best practices to keep in mind when you‚Äôre documenting and explaining legacy code:\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eTell Copilot who you are:\u003c/strong\u003e By telling Copilot your background (e.g., ‚ÄúI‚Äôm a Python developer‚Äù), it will tailor its explanations and suggestions to your level of expertise and preferred coding style.  \u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse the /explain slash command:\u003c/strong\u003e The /explain command in Copilot Chat helps you understand the intent or functionality of legacy code. This is especially useful when refactoring older codebases or debugging unclear logic.  \u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAsk Copilot for targeted suggestions:\u003c/strong\u003e Copilot can be more effective if you provide specific instructions for what you‚Äôre trying to achieve, like ‚Äúmodernize‚Äù or ‚Äúreplace deprecated methods.‚Äù  \u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIterate with feedback:\u003c/strong\u003e Copilot‚Äôs suggestions improve when you interact with it. After receiving a suggestion, refine it by adding details or asking follow-up questions. \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"take-this-with-you\" id=\"take-this-with-you\"\u003eTake this with you\u003ca href=\"#take-this-with-you\" aria-label=\"Take this with you\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWorking with legacy code doesn‚Äôt have to be your worst nightmare (although COBOL does scare me, if I‚Äôm being honest). While it often presents unique challenges‚Äîlike outdated technologies, a lack of documentation, and tangled logic‚Äîtools like GitHub Copilot make the process of understanding and documenting old code far more manageable.\u003c/p\u003e\n\u003cp\u003eRemember, good documentation isn‚Äôt just about understanding the past‚Äîit‚Äôs an investment in your team‚Äôs future. With clear, well-documented code you reduce the risk of errors, accelerate development, and make your systems easier to maintain and modernize over time. And with GitHub Copilot Free, these powerful features are readily available to every developer, no matter the size of the codebase you‚Äôre working with.\u003c/p\u003e\n\u003cp\u003eSo, next time you find yourself navigating the dark corners of a legacy codebase, don‚Äôt forget to bring your flashlight‚Äîand GitHub Copilot. Your future self (and team) will thank you.\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cstrong\u003eStart using GitHub Copilot for free\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOur free version of GitHub Copilot is included by default in personal GitHub accounts and VS Code to help you start new projects, manage existing repositories, and more.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/features/copilot?utm_source=documenting_code_blog\u0026amp;utm_medium=github_blog\u0026amp;utm_campaign=copilot_free\u0026amp;utm_content=end_CTA\"\u003eStart using GitHub Copilot \u0026gt;\u003c/a\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\t\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/6109729?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/6109729?v=4\u0026amp;s=200\" alt=\"Christopher Harrison\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eSenior Developer Advocate, GitHub\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "19 min read",
  "publishedTime": "2025-01-15T18:00:00Z",
  "modifiedTime": "2025-01-15T19:47:03Z"
}
