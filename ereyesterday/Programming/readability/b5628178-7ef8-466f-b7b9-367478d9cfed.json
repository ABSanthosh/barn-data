{
  "id": "b5628178-7ef8-466f-b7b9-367478d9cfed",
  "title": "Highlighting Text Input with Jetpack Compose",
  "link": "https://buffer.com/resources/highlighting-text-input-with-jetpack-compose/",
  "description": "We recently launched a new feature at Buffer, called Ideas. With Ideas, you can store all your best ideas, tweak them until they’re ready, and drop them straight into your Buffer queue. Now that Ideas has launched in our web and mobile apps, we have some time to",
  "author": "Joe Birch",
  "published": "Tue, 13 Dec 2022 18:32:36 GMT",
  "source": "https://buffer.com/resources/overflow/rss/",
  "categories": [
    "Overflow"
  ],
  "byline": "Joe Birch",
  "length": 9924,
  "excerpt": "Buffer is an intuitive social media management platform trusted by brands, businesses, agencies, and individuals to help drive social media results.",
  "siteName": "Buffer: All-you-need social media toolkit for small businesses",
  "favicon": "https://buffer.com/static/icons/apple-touch-icon.png",
  "text": "We recently launched a new feature at Buffer, called Ideas. With Ideas, you can store all your best ideas, tweak them until they’re ready, and drop them straight into your Buffer queue. Now that Ideas has launched in our web and mobile apps, we have some time to share some learnings from the development of this feature. In this blog post, we’ll dive into how we added support for URL highlighting to the Ideas Composer on Android, using Jetpack Compose.We started adopting Jetpack Compose into our app in 2021 - using it as standard to build all our new features, while gradually adopting it into existing parts of our application. We built the whole of the Ideas feature using Jetpack Compose - so alongside faster feature development and greater predictability within the state of our UI, we had plenty of opportunities to further explore Compose and learn more about how to achieve certain requirements in our app.Within the Ideas composer, we support dynamic link highlighting. This means that if you type a URL into the text area, then the link will be highlighted - tapping on this link will then show an “Open link” pop-up, which will launch the link in the browser when clicked.In this blog post, we’re going to focus on the link highlighting implementation and how this can be achieved in Jetpack Compose using the TextField composable.For the Ideas composer, we’re utilising the TextField composable to support text entry. This composable contains an argument, visualTransformation, which is used to apply visual changes to the entered text.TextField( ... visualTransformation = ... )This argument requires a VisualTransformation implementation which is used to apply the visual transformation to the entered text. If we look at the source code for this interface, we’ll notice a filter function which takes the content of the TextField and returns a TransformedText reference that contains the modified text.@Immutable fun interface VisualTransformation { fun filter(text: AnnotatedString): TransformedText }When it comes to this modified text, we are required to provide the implementation that creates a new AnnotatedString reference with our applied changes. This changed content then gets bundled in the TransformedText type and returned back to the TextField for composition.So that we can define and apply transformations to the content of our TextField, we need to start by creating a new implementation of the VisualTransformation interface for which we’ll create a new class, UrlTransformation. This class will implement the VisualTransformation argument, along with taking a single argument in the form of a Color. We define this argument so that we can pass a theme color reference to be applied within our logic, as we are going to be outside of composable scope and won’t have access to our composable theme.class UrlTransformation( val color: Color ) : VisualTransformation { }With this class defined, we now need to implement the filter function from the VisualTransformation interface. Within this function we’re going to return an instance of the TransformedText class - we can jump into the source code for this class and see that there are two properties required when instantiating this class./** * The transformed text with offset offset mapping */ class TransformedText( /** * The transformed text */ val text: AnnotatedString, /** * The map used for bidirectional offset mapping from original to transformed text. */ val offsetMapping: OffsetMapping )Both of these arguments are required, so we’re going to need to provide a value for each when instantiating the TransformedText class.text - this will be the modified version of the text that is provided to the filter functionoffsetMapping - as per the documentation, this is the map used for bidirectional offset mapping from original to transformed textclass UrlTransformation( val color: Color ) : VisualTransformation { override fun filter(text: AnnotatedString): TransformedText { return TransformedText( ..., OffsetMapping.Identity ) } }For the offsetMapping argument, we simply pass the OffsetMapping.Identity value - this is the predefined default value used for the OffsetMapping interface, used for when that can be used for the text transformation that does not change the character count. When it comes to the text argument we’ll need to write some logic that will take the current content, apply the highlighting and return it as a new AnnotatedString reference to be passed into our TransformedText reference. For this logic, we’re going to create a new function, buildAnnotatedStringWithUrlHighlighting. This is going to take two arguments - the text that is to be highlighted, along with the color to be used for the highlighting.fun buildAnnotatedStringWithUrlHighlighting( text: String, color: Color ): AnnotatedString { }From this function, we need to return an AnnotatedString reference, which we’ll create using buildAnnotatedString. Within this function, we’ll start by using the append operation to set the textual content of the AnnotatedString.fun buildAnnotatedStringWithUrlHighlighting( text: String, color: Color ): AnnotatedString { return buildAnnotatedString { append(text) } }Next, we’ll need to take the contents of our string and apply highlighting to any URLs that are present. Before we can do this, we need to identify the URLs in the string. URL detection might vary depending on the use case, so to keep things simple let’s write some example code that will find the URLs in a given piece of text. This code will take the given string and filter the URLs, providing a list of URL strings as the result.text?.split(\"\\\\s+\".toRegex())?.filter { word -\u003e Patterns.WEB_URL.matcher(word).matches() }Now that we know what URLs are in the string, we’re going to need to apply highlighting to them. This is going to be in the form of an annotated string style, which is applied using the addStyle operation.fun addStyle(style: SpanStyle, start: Int, end: Int)When calling this function, we need to pass the SpanStyle that we wish to apply, along with the start and end index that this styling should be applied to. We’re going to start by calculating this start and end index  - to keep things simple, we’re going to assume there are only unique URLs in our string.text?.split(\"\\\\s+\".toRegex())?.filter { word -\u003e Patterns.WEB_URL.matcher(word).matches() }.forEach { val startIndex = text.indexOf(it) val endIndex = startIndex + it.length }Here we locate the start index by using the indexOf function, which will give us the starting index of the given URL. We’ll then use this start index and the length of the URL to calculate the end index. We can then pass these values to the corresponding arguments for the addStyle function.text?.split(\"\\\\s+\".toRegex())?.filter { word -\u003e Patterns.WEB_URL.matcher(word).matches() }.forEach { val startIndex = text.indexOf(it) val endIndex = startIndex + it.length addStyle( start = startIndex, end = endIndex ) }Next, we need to provide the SpanStyle that we want to be applied to the given index range. Here we want to simply highlight the text using the provided color, so we’ll pass the color value from our function arguments as the color argument for the SpanStyle function.text?.split(\"\\\\s+\".toRegex())?.filter { word -\u003e Patterns.WEB_URL.matcher(word).matches() }.forEach { val startIndex = text.indexOf(it) val endIndex = startIndex + it.length addStyle( style = SpanStyle( color = color ), start = startIndex, end = endIndex ) } With this in place, we now have a complete function that will take the provided text and highlight any URLs using the provided Color reference.fun buildAnnotatedStringWithUrlHighlighting( text: String, color: Color ): AnnotatedString { return buildAnnotatedString { append(text) text?.split(\"\\\\s+\".toRegex())?.filter { word -\u003e Patterns.WEB_URL.matcher(word).matches() }.forEach { val startIndex = text.indexOf(it) val endIndex = startIndex + it.length addStyle( style = SpanStyle( color = color, textDecoration = TextDecoration.None ), start = startIndex, end = endIndex ) } } }We’ll then need to hop back into our UrlTransformation class and pass the result of the buildAnnotatedStringWithUrlHighlighting function call for the TransformedText argument.class UrlTransformation( val color: Color ) : VisualTransformation { override fun filter(text: AnnotatedString): TransformedText { return TransformedText( buildAnnotatedStringWithUrlHighlighting(text, color), OffsetMapping.Identity ) } }Now that our UrlTransformation implementation is complete, we can instantiate this and pass the reference for the visualTransformation  argument of the TextField composable. Here we are using the desired color from our MaterialTheme reference, which will be used when highlighting the URLs in our TextField content.TextField( ... visualTransformation = UrlTransformation( MaterialTheme.colors.secondary) )With the above in place, we now have dynamic URL highlighting support within our TextField composable. This means that now whenever the user inserts a URL into the composer for an Idea, we identify this as a URL by highlighting it using a the secondary color from our theme.In this post, we’ve learnt how we can apply dynamic URL highlighting to the contents of a TextField composable. In the next post, we’ll explore how we added the “Open link” pop-up when a URL is tapped within the composer input area.",
  "image": "https://buffer.com/resources/content/images/2022/12/aaron-burden-Hzi7U2SZ2GE-unsplash.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eWe recently launched a new feature at Buffer, called \u003ca href=\"https://buffer.com/ideas\" rel=\"noreferrer nofollow noopener\"\u003eIdeas\u003c/a\u003e. With Ideas, you can store all your best ideas, tweak them until they’re ready, and drop them straight into your Buffer queue. Now that Ideas has launched in our web and mobile apps, we have some time to share some learnings from the development of this feature. In this blog post, we’ll dive into how we added support for URL highlighting to the Ideas Composer on Android, using Jetpack Compose.\u003c/p\u003e\u003chr/\u003e\u003cp\u003eWe started adopting Jetpack Compose into our app in 2021 - using it as standard to build all our new features, while gradually adopting it into existing parts of our application. We built the whole of the Ideas feature using Jetpack Compose - so alongside faster feature development and greater predictability within the state of our UI, we had plenty of opportunities to further explore Compose and learn more about how to achieve certain requirements in our app.\u003c/p\u003e\u003cp\u003e\u003cbr/\u003eWithin the Ideas composer, we support dynamic link highlighting. This means that if you type a URL into the text area, then the link will be highlighted - tapping on this link will then show an “Open link” pop-up, which will launch the link in the browser when clicked.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://paper-attachments.dropboxusercontent.com/s_70CDC5BFE3F8A083A9AA9227345C1F454192F224108DA4223901379386BD986B_1670334086472_ezgif-1-1b6718525f.gif\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cp\u003eIn this blog post, we’re going to focus on the link highlighting implementation and how this can be achieved in Jetpack Compose using the \u003ccode\u003eTextField\u003c/code\u003e composable.\u003c/p\u003e\u003chr/\u003e\u003cp\u003eFor the Ideas composer, we’re utilising the \u003ccode\u003eTextField\u003c/code\u003e composable to support text entry. This composable contains an argument, \u003ccode\u003evisualTransformation\u003c/code\u003e, which is used to apply visual changes to the entered text.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eTextField(\n    ...\n    visualTransformation = ...\n)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis argument requires a \u003ccode\u003eVisualTransformation\u003c/code\u003e implementation which is used to apply the visual transformation to the entered text. If we look at the source code for this interface, we’ll notice a filter function which takes the content of the TextField and returns a \u003ccode\u003eTransformedText\u003c/code\u003e reference that contains the modified text.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@Immutable\nfun interface VisualTransformation {\n    fun filter(text: AnnotatedString): TransformedText\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen it comes to this modified text, we are required to provide the implementation that creates a new \u003ccode\u003eAnnotatedString\u003c/code\u003e reference with our applied changes. This changed content then gets bundled in the \u003ccode\u003eTransformedText\u003c/code\u003e type and returned back to the \u003ccode\u003eTextField\u003c/code\u003e for composition.\u003c/p\u003e\u003cp\u003e\u003cbr/\u003eSo that we can define and apply transformations to the content of our \u003ccode\u003eTextField\u003c/code\u003e, we need to start by creating a new implementation of the \u003ccode\u003eVisualTransformation\u003c/code\u003e interface for which we’ll create a new class, \u003ccode\u003eUrlTransformation\u003c/code\u003e. This class will implement the \u003ccode\u003eVisualTransformation\u003c/code\u003e argument, along with taking a single argument in the form of a \u003ccode\u003eColor\u003c/code\u003e. We define this argument so that we can pass a theme color reference to be applied within our logic, as we are going to be outside of composable scope and won’t have access to our composable theme.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass UrlTransformation(\n    val color: Color\n) : VisualTransformation {\n\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith this class defined, we now need to implement the filter function from the \u003ccode\u003eVisualTransformation\u003c/code\u003e interface. Within this function we’re going to return an instance of the \u003ccode\u003eTransformedText\u003c/code\u003e class - we can jump into the source code for this class and see that there are two properties required when instantiating this class.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/**\n * The transformed text with offset offset mapping\n */\nclass TransformedText(\n    /**\n     * The transformed text\n     */\n    val text: AnnotatedString,\n\n    /**\n     * The map used for bidirectional offset mapping from original to transformed text.\n     */\n    val offsetMapping: OffsetMapping\n)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBoth of these arguments are required, so we’re going to need to provide a value for each when instantiating the \u003ccode\u003eTransformedText\u003c/code\u003e class.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003etext\u003c/strong\u003e - this will be the modified version of the text that is provided to the filter function\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eoffsetMapping\u003c/strong\u003e - as per the documentation, this is the map used for bidirectional offset mapping from original to transformed text\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003eclass UrlTransformation(\n    val color: Color\n) : VisualTransformation {\n    override fun filter(text: AnnotatedString): TransformedText {\n        return TransformedText(\n            ...,\n            OffsetMapping.Identity\n        )\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor the \u003ccode\u003eoffsetMapping\u003c/code\u003e argument, we simply pass the \u003ccode\u003eOffsetMapping.Identity\u003c/code\u003e value - this is the predefined default value used for the \u003ccode\u003eOffsetMapping\u003c/code\u003e interface, used for when that can be used for the text transformation that does not change the character count. When it comes to the text argument we’ll need to write some logic that will take the current content, apply the highlighting and return it as a new \u003ccode\u003eAnnotatedString\u003c/code\u003e reference to be passed into our \u003ccode\u003eTransformedText\u003c/code\u003e reference. For this logic, we’re going to create a new function, \u003ccode\u003ebuildAnnotatedStringWithUrlHighlighting\u003c/code\u003e. This is going to take two arguments - the text that is to be highlighted, along with the color to be used for the highlighting.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efun buildAnnotatedStringWithUrlHighlighting(\n    text: String, \n    color: Color\n): AnnotatedString {\n    \n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFrom this function, we need to return an \u003ccode\u003eAnnotatedString\u003c/code\u003e reference, which we’ll create using \u003ccode\u003ebuildAnnotatedString\u003c/code\u003e. Within this function, we’ll start by using the append operation to set the textual content of the \u003ccode\u003eAnnotatedString\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efun buildAnnotatedStringWithUrlHighlighting(\n    text: String, \n    color: Color\n): AnnotatedString {\n    return buildAnnotatedString {\n        append(text)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNext, we’ll need to take the contents of our string and apply highlighting to any URLs that are present. Before we can do this, we need to identify the URLs in the string. URL detection might vary depending on the use case, so to keep things simple let’s write some example code that will find the URLs in a given piece of text. This code will take the given string and filter the URLs, providing a list of URL strings as the result.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etext?.split(\u0026#34;\\\\s+\u0026#34;.toRegex())?.filter { word -\u0026gt;\n    Patterns.WEB_URL.matcher(word).matches()\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow that we know what URLs are in the string, we’re going to need to apply highlighting to them. This is going to be in the form of an annotated string style, which is applied using the addStyle operation.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efun addStyle(style: SpanStyle, start: Int, end: Int)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen calling this function, we need to pass the \u003ccode\u003eSpanStyle\u003c/code\u003e that we wish to apply, along with the start and end index that this styling should be applied to. We’re going to start by calculating this start and end index  - to keep things simple, we’re going to assume there are only unique URLs in our string.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etext?.split(\u0026#34;\\\\s+\u0026#34;.toRegex())?.filter { word -\u0026gt;\n    Patterns.WEB_URL.matcher(word).matches()\n}.forEach {\n    val startIndex = text.indexOf(it)\n    val endIndex = startIndex + it.length\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere we locate the start index by using the \u003ccode\u003eindexOf\u003c/code\u003e function, which will give us the starting index of the given URL. We’ll then use this start index and the length of the URL to calculate the end index. We can then pass these values to the corresponding arguments for the \u003ccode\u003eaddStyle\u003c/code\u003e function.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etext?.split(\u0026#34;\\\\s+\u0026#34;.toRegex())?.filter { word -\u0026gt;\n    Patterns.WEB_URL.matcher(word).matches()\n}.forEach {\n    val startIndex = text.indexOf(it)\n    val endIndex = startIndex + it.length\n    addStyle(\n        start = startIndex, \n        end = endIndex\n    )\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNext, we need to provide the \u003ccode\u003eSpanStyle\u003c/code\u003e that we want to be applied to the given index range. Here we want to simply highlight the text using the provided color, so we’ll pass the color value from our function arguments as the color argument for the \u003ccode\u003eSpanStyle\u003c/code\u003e function.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etext?.split(\u0026#34;\\\\s+\u0026#34;.toRegex())?.filter { word -\u0026gt;\n    Patterns.WEB_URL.matcher(word).matches()\n}.forEach {\n    val startIndex = text.indexOf(it)\n    val endIndex = startIndex + it.length\n    addStyle(\n        style = SpanStyle(\n            color = color\n        ),\n        start = startIndex, \n        end = endIndex\n    )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith this in place, we now have a complete function that will take the provided text and highlight any URLs using the provided \u003ccode\u003eColor\u003c/code\u003e reference.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efun buildAnnotatedStringWithUrlHighlighting(\n    text: String, \n    color: Color\n): AnnotatedString {\n    return buildAnnotatedString {\n        append(text)\n        text?.split(\u0026#34;\\\\s+\u0026#34;.toRegex())?.filter { word -\u0026gt;\n            Patterns.WEB_URL.matcher(word).matches()\n        }.forEach {\n            val startIndex = text.indexOf(it)\n            val endIndex = startIndex + it.length\n            addStyle(\n                style = SpanStyle(\n                    color = color,\n                    textDecoration = TextDecoration.None\n                ),\n                start = startIndex, end = endIndex\n            )\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe’ll then need to hop back into our \u003ccode\u003eUrlTransformation\u003c/code\u003e class and pass the result of the \u003ccode\u003ebuildAnnotatedStringWithUrlHighlighting\u003c/code\u003e function call for the \u003ccode\u003eTransformedText\u003c/code\u003e argument.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass UrlTransformation(\n    val color: Color\n) : VisualTransformation {\n    override fun filter(text: AnnotatedString): TransformedText {\n        return TransformedText(\n            buildAnnotatedStringWithUrlHighlighting(text, color),\n            OffsetMapping.Identity\n        )\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow that our \u003ccode\u003eUrlTransformation\u003c/code\u003e implementation is complete, we can instantiate this and pass the reference for the \u003ccode\u003evisualTransformation\u003c/code\u003e  argument of the \u003ccode\u003eTextField\u003c/code\u003e composable. Here we are using the desired color from our \u003ccode\u003eMaterialTheme\u003c/code\u003e reference, which will be used when highlighting the URLs in our \u003ccode\u003eTextField\u003c/code\u003e content.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eTextField(\n    ...\n    visualTransformation = UrlTransformation(\n        MaterialTheme.colors.secondary)\n)\u003c/code\u003e\u003c/pre\u003e\u003chr/\u003e\u003cp\u003eWith the above in place, we now have dynamic URL highlighting support within our \u003ccode\u003eTextField\u003c/code\u003e composable. This means that now whenever the user inserts a URL into the composer for an Idea, we identify this as a URL by highlighting it using a the secondary color from our theme.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://paper-attachments.dropboxusercontent.com/s_70CDC5BFE3F8A083A9AA9227345C1F454192F224108DA4223901379386BD986B_1670334086472_ezgif-1-1b6718525f.gif\" alt=\"\" loading=\"lazy\" width=\"600\" height=\"259\"/\u003e\u003c/figure\u003e\u003cp\u003eIn this post, we’ve learnt how we can apply dynamic URL highlighting to the contents of a \u003ccode\u003eTextField\u003c/code\u003e composable. In the next post, we’ll explore how we added the “Open link” pop-up when a URL is tapped within the composer input area.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": null,
  "modifiedTime": null
}
