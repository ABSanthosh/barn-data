{
  "id": "ec87a62b-5f1c-459a-b16f-fb185fcccebb",
  "title": "When SQL Meets Lambda Expressions",
  "link": "https://blog.jooq.org/when-sql-meets-lambda-expressions/",
  "description": "ARRAY types are a part of the ISO/IEC 9075 SQL standard. The standard specifies how to: But it is very unopinionated when it comes to function support. The ISO/IEC 9075-2:2023(E) 6.47 specifies concatenation of arrays, whereas the 6.48 section lists a not extremely useful TRIM_ARRAY function, exclusively (using which … Continue reading When SQL Meets Lambda Expressions →",
  "author": "lukaseder",
  "published": "Thu, 27 Mar 2025 13:04:44 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "sql",
    "array",
    "array types",
    "clickhouse",
    "databricks",
    "duckdb",
    "Snowflake",
    "Trino"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 2411,
  "excerpt": "A few forward looking SQL dialects have started introducing lambda expressions to be used with functions operating on arrays",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "ARRAY types are a part of the ISO/IEC 9075 SQL standard. The standard specifies how to: Construct arrays Nest data into arrays (e.g. by means of aggregation or subqueries) Unnest data from arrays into tables But it is very unopinionated when it comes to function support. The ISO/IEC 9075-2:2023(E) 6.47 \u003carray value expression\u003e specifies concatenation of arrays, whereas the 6.48 \u003carray value function\u003e section lists a not extremely useful TRIM_ARRAY function, exclusively (using which you can remove the last N elements of an array, something I have yet to encounter a use-case for) The implementations fare better. Many of them have a ton of useful functions, and since recently , there are a couple of more modern SQL dialects out there who have started experimenting with lambda expressions in SQL, when working with ARRAY types. These dialects include, mostly: ClickHouse Databricks DuckDB Snowflake Trino Take the ARRAY_FILTER function, for example. With jOOQ you might write something like this, where you apply a filter that keeps only even numbers in an array: arrayFilter(array(1, 2, 2, 3), e -\u003e e.mod(2).eq(0)) The corresponding jOOQ API is simply: public static \u003cT\u003e Field\u003cT[]\u003e arrayFilter( Field\u003cT[]\u003e array, Function1\u003c? super Field\u003cT\u003e, ? extends Condition\u003e predicate ) { ... } So, jOOQ can simply map Java (or Kotlin, Scala) lambda expressions to a SQL lambda expression, without any magic. You just construct an expression of the right type, as always with jOOQ. The result of such an expression might look like this: +--------------+ | array_filter | +--------------+ | [ 2, 2 ] | +--------------+ In DuckDB, for example, the above is translated to: array_filter( ARRAY[1, 2, 2, 3], e -\u003e (e % 2) = 0 ) If the dialect doesn’t support the lambda style syntax, the function can easily be emulated using a subquery that unnests the array, applies a WHERE clause corresponding to the lambda, and collects the results back into an array, e.g. in PostgreSQL: ( SELECT coalesce( array_agg(e), CAST(ARRAY[] AS int[]) ) FROM UNNEST(ARRAY[1, 2, 2, 3]) t (e) WHERE mod(e, 2) = 0 ) This works just the same way when the array isn’t just a static array literal, but an array expression, e.g. TABLE.ARRAY_FIELD. Related functions include: ARRAY_MAP ARRAY_ALL_MATCH ARRAY_ANY_MATCH ARRAY_NONE_MATCH",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-12995\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003e\u003ccode\u003eARRAY\u003c/code\u003e types are a part of the ISO/IEC 9075 SQL standard. The standard specifies how to:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eConstruct arrays\u003c/li\u003e\n\n\n\n\u003cli\u003eNest data into arrays (e.g. by means of aggregation or subqueries)\u003c/li\u003e\n\n\n\n\u003cli\u003eUnnest data from arrays into tables\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eBut it is very unopinionated when it comes to function support. The ISO/IEC 9075-2:2023(E) 6.47 \u003ccode\u003e\u0026lt;array value expression\u0026gt;\u003c/code\u003e specifies concatenation of arrays, whereas the 6.48 \u003ccode\u003e\u0026lt;array value function\u0026gt;\u003c/code\u003e section lists a not extremely useful \u003ccode\u003eTRIM_ARRAY\u003c/code\u003e function, exclusively (using which you can remove the last \u003ccode\u003eN\u003c/code\u003e elements of an array, something I have yet to encounter a use-case for)\u003c/p\u003e\n\n\n\n\u003cp\u003eThe implementations fare better. Many of them have a ton of useful functions, and since recently , there are a couple of more modern SQL dialects out there who have started experimenting with lambda expressions in SQL, when working with \u003ccode\u003eARRAY\u003c/code\u003e types. These dialects include, mostly:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eClickHouse\u003c/li\u003e\n\n\n\n\u003cli\u003eDatabricks\u003c/li\u003e\n\n\n\n\u003cli\u003eDuckDB\u003c/li\u003e\n\n\n\n\u003cli\u003eSnowflake\u003c/li\u003e\n\n\n\n\u003cli\u003eTrino\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eTake the \u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/array-functions/array-filter-function/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/array-functions/array-filter-function/\"\u003eARRAY_FILTER\u003c/a\u003e\u003c/code\u003e function, for example. With jOOQ you might write something like this, where you apply a filter that keeps only even numbers in an array:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003earrayFilter(array(1, 2, 2, 3), e -\u0026gt; e.mod(2).eq(0))\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThe \u003ca href=\"https://www.jooq.org/javadoc/dev/org.jooq/org/jooq/impl/DSL.html#arrayFilter(org.jooq.Field,org.jooq.Function1)\" data-type=\"link\" data-id=\"https://www.jooq.org/javadoc/dev/org.jooq/org/jooq/impl/DSL.html#arrayFilter(org.jooq.Field,org.jooq.Function1)\"\u003ecorresponding jOOQ API\u003c/a\u003e is simply:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003epublic static \u0026lt;T\u0026gt; Field\u0026lt;T[]\u0026gt; arrayFilter(\n    Field\u0026lt;T[]\u0026gt; array, \n    Function1\u0026lt;? super Field\u0026lt;T\u0026gt;, ? extends Condition\u0026gt; predicate\n) { ... }\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eSo, jOOQ can simply map Java (or Kotlin, Scala) lambda expressions to a SQL lambda expression, without any magic. You just construct an expression of the right type, as always with jOOQ.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe result of such an expression might look like this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e+--------------+\n| array_filter |\n+--------------+\n| [ 2, 2 ]     |\n+--------------+\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIn DuckDB, for example, the above is translated to:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003earray_filter(\n  ARRAY[1, 2, 2, 3],\n  e -\u0026gt; (e % 2) = 0\n)\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIf the dialect doesn’t support the lambda style syntax, the function can easily be emulated using a subquery that unnests the array, applies a \u003ccode\u003eWHERE\u003c/code\u003e clause corresponding to the lambda, and collects the results back into an array, e.g. in PostgreSQL:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e(\n  SELECT coalesce(\n    array_agg(e),\n    CAST(ARRAY[] AS int[])\n  )\n  FROM UNNEST(ARRAY[1, 2, 2, 3]) t (e)\n  WHERE mod(e, 2) = 0\n)\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis works just the same way when the array isn’t just a static array literal, but an array expression, e.g. \u003ccode\u003eTABLE.ARRAY_FIELD\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eRelated functions include:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/array-functions/array-map-function/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/array-functions/array-map-function/\"\u003eARRAY_MAP\u003c/a\u003e\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/array-functions/array-all-match-function/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/array-functions/array-all-match-function/\"\u003eARRAY_ALL_MATCH\u003c/a\u003e\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/array-functions/array-any-match-function/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/array-functions/array-any-match-function/\"\u003eARRAY_ANY_MATCH\u003c/a\u003e\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/array-functions/array-none-match-function/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/array-functions/array-none-match-function/\"\u003eARRAY_NONE_MATCH\u003c/a\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2025-03-27T13:04:44Z",
  "modifiedTime": "2025-03-27T13:04:44Z"
}
