{
  "id": "a1286b27-4765-41e6-a2ff-bfd9a659019b",
  "title": "CI/CD inputs: Secure and preferred method to pass parameters to a pipeline",
  "link": "https://about.gitlab.com/blog/ci-cd-inputs-secure-and-preferred-method-to-pass-parameters-to-a-pipeline/",
  "description": "",
  "author": "Dov Hershkovitch",
  "published": "2025-07-07T00:00:00.000Z",
  "source": "https://about.gitlab.com/atom.xml",
  "categories": null,
  "byline": "Dov Hershkovitch",
  "length": 19935,
  "excerpt": "Learn how CI/CD inputs provide type-safe parameter passing with validation, replacing error-prone variables for more reliable pipelines.",
  "siteName": "GitLab",
  "favicon": "https://about.gitlab.com/images/ico/favicon-192x192.png",
  "text": "GitLab CI/CD inputs represent the future of pipeline parameter passing. As a purpose-built feature designed specifically for typed parameters with validation, clear contracts, and enhanced security, inputs solve the fundamental challenges that teams have been working around with variables for years. While CI/CD variables have served as the traditional method for passing parameters to pipelines, they were originally designed for storing configuration settings — not as a sophisticated parameter-passing mechanism for complex workflows. This fundamental mismatch has created reliability issues, security concerns, and maintenance overhead that inputs elegantly eliminate. This article demonstrates why CI/CD inputs should be your preferred approach for pipeline parameters. You'll discover how inputs provide type safety, prevent common pipeline failures, eliminate variable collision issues, and create more maintainable automation. You'll also see practical examples of inputs in action and how they solve real-world challenges, which we hope will encourage you to transition from variable-based workarounds to input-powered reliability. The problems with using variables for parameter passing are numerous and frustrating. No type validation Variables are strings. There is no type validation, meaning a pipeline expecting a boolean or a number, but accidentally receives a string. This leads to unexpected failures deep into the pipeline execution. In the case of a deployment workflow for example, hours after it was started a critical production deployment fails because a boolean check in a variable was not passed as expected. Runtime mutability Variables can be modified throughout the pipeline runtime, creating unpredictable behavior when multiple jobs attempt to change the same values. For example, deploy_job_a sets DEPLOY_ENV=staging, but deploy_job_b changes the DEPLOY_ENV value to production. Security risks Security concerns arise because variables intended as simple parameters often receive the same access permissions as sensitive secrets. There's no clear contract defining what parameters a pipeline expects, their types, or their default values. A simple BUILD_TYPE parameter, that seems innocuous at first glance, suddenly has access to production secrets simply because variables do not inherently distinguish between parameters and sensitive data. Perhaps most problematically, error detection happens too late in the process. A misconfigured variable might not cause a failure until minutes or even hours into a pipeline run, wasting valuable CI/CD resources and developer time. Teams have developed elaborate workarounds such as custom validation scripts, extensive documentation, and complex naming conventions just to make variable-based parameter passing somewhat reliable. Many users have requested local debugging capabilities to test pipeline configurations before deployment. While this seems like an obvious solution, it quickly breaks down in practice. Enterprise CI/CD workflows integrate with dozens of external systems — cloud providers, artifact repositories, security scanners, deployment targets — that simply can't be replicated locally. Even if they could, the complexity would make local testing environments nearly impossible to maintain. This mismatch forced us to reframe the problem entirely. Instead of asking \"How can we test pipelines locally?\" we started asking \"How can we prevent configuration issues caused by variable-based parameter passing before users run a CI/CD automation workflow?\" Understanding variable precedence GitLab's variable system includes multiple precedence levels to provide flexibility for different use cases. While this system serves many valid scenarios like allowing administrators to set instance- or group-wide defaults while letting individual projects override them when needed, it can create challenges when building reusable pipeline components. When creating components or templates that will be used across different projects and groups, the variable precedence hierarchy can make behavior less predictable. For example, a template that works perfectly in one project might behave differently in another due to group- or instance-level variable overrides that aren't visible in a pipeline configuration. When including multiple templates, it also can be challenging to track which variables are being set where and how they might interact. In addition, components authors need to document not just what variables their template uses, but also potential conflicts with variables that might be defined at higher precedence levels. Variable precedence examples Main pipeline file (.gitlab-ci.yml): variables: ENVIRONMENT: production # Top-level default for all jobs DATABASE_URL: prod-db.example.com include: - local: 'templates/test-template.yml' - local: 'templates/deploy-template.yml' Test template (templates/test-template.yml): run-tests: variables: ENVIRONMENT: test # Job-level variable overrides the default script: - echo \"Running tests in $ENVIRONMENT environment\" - echo \"Database URL is $DATABASE_URL\" # Still inherits prod-db.example.com! - run-integration-tests --env=$ENVIRONMENT --db=$DATABASE_URL `# Issue: Tests run in \"test\" environment but against production database` Deploy template (templates/deploy-template.yml): deploy-app: script: - echo \"Deploying to $ENVIRONMENT\" # Uses production (top-level default) - echo \"Database URL is $DATABASE_URL\" # Uses prod-db.example.com - deploy --target=$ENVIRONMENT --db=$DATABASE_URL # This will deploy to production as intended The challenges in this example: Partial inheritance: The test job gets ENVIRONMENT=test but still inherits DATABASE_URL=prod-db.example.com. Coordination complexity: Template authors must know what top-level variables exist and might conflict. Override behavior: Job-level variables with the same name override defaults, but this isn't always obvious. Hidden dependencies: Templates become dependent on the main pipeline's variable names. GitLab recognized these pain points and introduced CI/CD inputs as a purpose-built solution for passing parameters to pipelines, offering typed parameters with built-in validation that occurs at pipeline creation time rather than during execution. CI/CD inputs fundamentals Inputs provide typed parameters for reusable pipeline configuration with built-in validation at pipeline creation time, designed specifically for defining values when the pipeline runs. They create a clear contract between the pipeline consumer and the configuration, explicitly defining what parameters are expected, their types, and constraints. Configuration flexibility and scope One of the advantages of inputs is their configuration-time flexibility. Inputs are evaluated and interpolated during pipeline creation using the interpolation format $[[ inputs.input-id ]], meaning they can be used anywhere in your pipeline configuration — including job names, rules conditions, images, and any other YAML configuration element. This eliminates the long-standing limitation of variable interpolation in certain contexts. One common use case we've seen is that users define their job names like test-$[[ inputs.environment ]]-deployment. When using inputs in job names, you can prevent naming conflicts when the same component is included multiple times in a single pipeline. Without this capability, including the same component twice would result in job name collisions, with the second inclusion overwriting the first. Input-based job names ensure each inclusion creates uniquely named jobs. Before inputs: test-service: variables: SERVICE_NAME: auth-service ENVIRONMENT: staging script: - run-tests-for $SERVICE_NAME in $ENVIRONMENT With inputs: spec: inputs: environment: type: string service_name: type: string test-$[[ inputs.service_name ]]-$[[ inputs.environment ]]: script: - run-tests-for $[[ inputs.service_name ]] in $[[ inputs.environment ]] When included multiple times with different inputs, this creates jobs like test-auth-service-staging, test-payment-service-production, and test-notification-service-development. Each job has a unique, meaningful name that clearly indicates its purpose, making pipeline visualization much clearer than having multiple jobs with identical names that would overwrite each other. Now let's go back to the first example in the top of this blog and use inputs, one immediate benefit is that instead of maintaining multiple templates file we can use one reusable template with different input values: spec: inputs: environment: type: string database_url: type: string action: type: string --- $[[ inputs.action ]]-$[[ inputs.environment ]]: script: - echo \"Running $[[ inputs.action ]] in $[[ inputs.environment ]] environment\" - echo \"Database URL is $[[ inputs.database_url ]]\" - run-$[[ inputs.action ]] --env=$[[ inputs.environment ]] --db=$[[ inputs.database_url ]] And in the main gitlab-ci.yml file we can include it twice (or more) with different values, making sure we avoid naming collisions include: - local: 'templates/environment-template.yml' inputs: environment: test database_url: test-db.example.com action: tests - local: 'templates/environment-template.yml' inputs: environment: production database_url: prod-db.example.com action: deploy The result: Instead of maintaining separate YAML files for testing and deployment jobs, you now have a single reusable template that handles both use cases safely. This approach scales to any number of environments or job types — reducing maintenance overhead, eliminating code duplication, and ensuring consistency across your entire pipeline configuration. One template to maintain instead of many, with zero risk of variable collision or configuration drift. Validation and type safety Another key difference between variables and inputs lies in validation capabilities. Inputs support different value types, including strings, numbers, booleans, and arrays, with validation occurring immediately when the pipeline is created. If you define an input as a boolean but pass a string, GitLab will reject the pipeline before any jobs execute, saving time and resources. Here is an example of the enormous benefit of type validation. Without type validation (variables): variables: ENABLE_TESTS: \"true\" # Always a string MAX_RETRIES: \"3\" # Always a string deploy_job: script: - if [ \"$ENABLE_TESTS\" = true ]; then # This fails! echo \"Running tests\" fi - retry_count=$((MAX_RETRIES + 1)) # String concatenation: \"31\" Problem: The boolean check fails because “true” (string) is not equal to true, (boolean). With type validation (inputs): spec: inputs: enable_tests: type: boolean default: true max_retries: type: number default: 3 deploy_job: script: - if [ \"$[[ inputs.enable_tests ]]\" = true ]; then # Works correctly echo \"Running tests\" fi - retry_count=$(($[[ inputs.max_retries ]] + 1)) # Math works: 4 Real-world impact for variable type validation failure: A developer or a process triggers a GitLab CI/CD pipeline with ENABLE_TESTS = yes instead of true. Assuming it takes on average 30 minutes before the deployment job starts, then finally when this job kicks off, 30 minutes or longer into the pipeline run, the deployment script tries to evaluate the boolean and fails. Imagine the impact in terms of time-to-market and, of course. developer time trying to debug why a seemingly basic deploy job failed. With type inputs, GitLab CI/CD will immediately throw an error and provide an explicit error message regarding the type mismatch. Security and access control Inputs provide enhanced security through controlled parameter passing with explicit contracts that define exactly what values are expected and allowed, creating clear boundaries between parameter passing to the pipeline, In addition. inputs are immutable. Once the pipeline starts, they cannot be modified during execution, providing predictable behavior throughout the pipeline lifecycle and eliminating the security risks that come from runtime variable manipulation. Scope and lifecycle When you define variables using the variables: keyword at the top level of your .gitlab-ci.yml file, these variables become defaults for all jobs in your entire pipeline. When you include templates, you must consider what variables you've defined globally, as they can interact with the template's expected behavior through GitLab's variable precedence order. Inputs are defined in CI configuration files (e.g. components or templates) and assigned values when a pipeline is triggered, allowing you to customize reusable CI configurations. They exist solely for pipeline creation and configuration time, scoped to the CI configuration file where they're defined, and become immutable references once the pipeline begins execution. Since each component maintains its own inputs, there is no risk of inputs interfering with other components or templates in your pipeline, eliminating variable collision and override issues that can occur with variable-based approaches. Working with variables and inputs together We recognize that teams have extensive investments in their variable-based workflows, and migration to inputs doesn't happen overnight. That's why we've developed capabilities that allow inputs and variables to work seamlessly together, providing a bridge between existing variables and the benefits of inputs while overcoming some key challenges in variable expansion. Let's look at this real-world example. Variable expansion in rules conditions A common challenge occurs when using variables that contain other variable references in rules:if conditions. GitLab only expands variables one level deep during rule evaluation, which can lead to unexpected behavior: # This doesn't work as expected variables: TARGET_ENV: value: \"${CI_COMMIT_REF_SLUG}\" deploy-job: rules: - if: '$TARGET_ENV == \"production\"' # Compares \"${CI_COMMIT_REF_SLUG}\" != \"production\" variables: DEPLOY_MODE: \"blue-green\" The expand_vars function solves this by forcing proper variable expansion in inputs: spec: inputs: target_environment: description: \"Target deployment environment\" default: \"${CI_COMMIT_REF_SLUG}\" --- deploy-job: rules: - if: '\"$[[ inputs.target_environment | expand_vars ]]\" == \"production\"' variables: DEPLOY_MODE: \"blue-green\" APPROVAL_REQUIRED: \"true\" - when: always variables: DEPLOY_MODE: \"rolling\" APPROVAL_REQUIRED: \"false\" script: - echo \"Target: $[[ inputs.target_environment | expand_vars ]]\" - echo \"Deploy mode: ${DEPLOY_MODE}\" Why this matters Without expand_vars, rule conditions evaluate against the literal variable reference (like \"${CI_COMMIT_REF_SLUG}\") rather than the expanded value (like \"production\"). This leads to rules that never match when you expect them to, breaking conditional pipeline logic. Important notes about expand_vars: Only variables that can be used with the include keyword are supported Variables must be unmasked (not marked as protected/masked) Nested variable expansion is not supported Rule conditions using expand_vars must be properly quoted: '\"$[[ inputs.name | expand_vars ]]\" == \"value\"' This pattern solves the single-level variable expansion limitation, working for any conditional logic that requires comparing fully resolved variable values. Function chaining for advanced processing Along with expand_vars, you can use functions like truncate to shorten values for compliance with naming restrictions (such as Kubernetes resource names), creating sophisticated parameter processing pipelines while maintaining input safety and predictability. spec: inputs: service_identifier: default: 'service-$CI_PROJECT_NAME-$CI_COMMIT_REF_SLUG' --- create-resource: script: - resource_name=$[[ inputs.service_identifier | expand_vars | truncate(0,50) ]] This integration capability allows you to adopt inputs gradually while leveraging your existing variable infrastructure, making the migration path much smoother. From components only to CI pipelines Up until GitLab 17.11, GitLab users were able to use inputs only in components and templates through the include: syntax. This limited their use to reusable CI/CD configurations, but didn't address the broader need for dynamic pipeline customization. Pipeline-wide inputs support Starting with GitLab 17.11, GitLab users can now use inputs to safely modify pipeline behavior across all pipeline execution contexts, replacing the traditional reliance on pipeline variables. This expanded support includes: Scheduled pipelines: Define inputs with defaults for automated pipeline runs while allowing manual override when needed. Downstream pipelines: Pass structured inputs to child and multi-project pipelines with proper validation and type safety. Manual pipelines: Present users with a clean, validated form interface. Those enhancements, with more to follow, allow teams to modernize their pipelines while maintaining backward compatibility gradually. Once inputs are fully adopted, users can disable pipeline variables to ensures a more secure and predictable CI/CD environment. Summary The transition from variables to inputs represents more than just a technical upgrade — it's a shift toward more maintainable, predictable, and secure CI/CD pipelines. While variables continue to serve important purposes for configuration, inputs provide the parameter-passing capabilities that teams have been working around for years. We understand that variables are deeply embedded in existing workflows, which is why we've built bridges between the two systems. The expand_vars function and other input capabilities allow you to adopt inputs gradually while leveraging your existing variable infrastructure. By starting with new components and templates, then gradually migrating high-impact workflows, you'll quickly see the benefits of clearer contracts, earlier error detection, and more reliable automation that scales across your organization. Additionally, moving to inputs creates an excellent foundation for leveraging GitLab's CI/CD Catalog, where reusable components with typed interfaces become powerful building blocks for your DevOps workflows but more on that in our next blog post. Your future self and your teammates will thank you for the clarity and reliability that inputs bring to your CI/CD workflows, while still being able to work with the variable systems you've already invested in. What's next Looking ahead, we're expanding inputs to solve two key challenges: enhancing pipeline triggering with cascading options that dynamically adjust based on user selections, and providing job-level inputs that allow users to retry individual jobs with different parameter values. We encourage you to follow these discussions, share your feedback, and contribute to shaping these features. You can also provide general feedback on CI/CD inputs through our feedback issue. Read more How to include file references in your CI/CD components CI/CD inputs documentation CI/CD Catalog goes GA: No more building pipelines from scratch GitLab environment variables demystified",
  "image": "https://about.gitlab.com/images/open-graph/open-graph-gitlab.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-v-c4ab8db4=\"\" data-v-69df7a1a=\"\" data-v-b7392a61=\"\"\u003e\u003cp\u003eGitLab CI/CD inputs represent the future of pipeline parameter passing. As\na purpose-built feature designed specifically for typed parameters with\nvalidation, clear contracts, and enhanced security, inputs solve the\nfundamental challenges that teams have been working around with variables\nfor years.\u003c/p\u003e\n\u003cp\u003eWhile CI/CD variables have served as the traditional method for passing parameters to pipelines, they were originally designed for storing configuration settings — not as a sophisticated parameter-passing mechanism for complex workflows. This fundamental mismatch has created reliability issues, security concerns, and maintenance overhead that inputs elegantly eliminate.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates why CI/CD inputs should be your preferred approach for pipeline parameters. You\u0026#39;ll discover how inputs provide type safety, prevent common pipeline failures, eliminate variable collision issues, and create more maintainable automation. You\u0026#39;ll also see practical examples of inputs in action and how they solve real-world challenges, which we hope will encourage you to transition from variable-based workarounds to input-powered reliability.\u003c/p\u003e\n\n\u003cp\u003eThe problems with using variables for parameter passing are numerous and frustrating.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNo type validation\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eVariables are strings. There is no type validation, meaning a pipeline expecting a boolean or a number, but accidentally receives a string. This leads to unexpected failures deep into the pipeline execution. In the case of a deployment workflow for example, hours after it was started  a critical production deployment fails because a boolean check in a variable was not passed as expected.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRuntime mutability\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eVariables can be modified throughout the pipeline runtime, creating unpredictable behavior when multiple jobs attempt to change the same values. For example, deploy_job_a sets \u003ccode\u003eDEPLOY_ENV=staging\u003c/code\u003e, but deploy_job_b changes the \u003ccode\u003eDEPLOY_ENV\u003c/code\u003e value to \u003ccode\u003eproduction\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSecurity risks\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eSecurity concerns arise because variables intended as simple parameters often receive the same access permissions as sensitive secrets. There\u0026#39;s no clear contract defining what parameters a pipeline expects, their types, or their default values. A simple \u003ccode\u003eBUILD_TYPE\u003c/code\u003e parameter, that seems innocuous at first glance, suddenly has access to production secrets simply because variables do not inherently distinguish between parameters and sensitive data.\u003c/p\u003e\n\u003cp\u003ePerhaps most problematically, error detection happens too late in the process. A misconfigured variable might not cause a failure until minutes or even hours into a pipeline run, wasting valuable CI/CD resources and developer time. Teams have developed elaborate workarounds such as custom validation scripts, extensive documentation, and complex naming conventions just to make variable-based parameter passing somewhat reliable.\u003c/p\u003e\n\u003cp\u003eMany users have requested local debugging capabilities to test pipeline configurations before deployment. While this seems like an obvious solution, it quickly breaks down in practice. Enterprise CI/CD workflows integrate with dozens of external systems — cloud providers, artifact repositories, security scanners, deployment targets — that simply can\u0026#39;t be replicated locally. Even if they could, the complexity would make local testing environments nearly impossible to maintain. This mismatch forced us to reframe the problem entirely. Instead of asking \u0026#34;How can we test pipelines locally?\u0026#34; we started asking \u0026#34;How can we prevent configuration issues caused by variable-based parameter passing before users run a CI/CD automation workflow?\u0026#34;\u003c/p\u003e\n\u003ch2 id=\"understanding-variable-precedence\" tabindex=\"-1\"\u003eUnderstanding variable precedence \u003ca href=\"#understanding-variable-precedence\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGitLab\u0026#39;s variable system includes multiple \u003ca href=\"https://docs.gitlab.com/ci/variables/#cicd-variable-precedence\"\u003eprecedence levels\u003c/a\u003e to provide flexibility for different use cases. While this system serves many valid scenarios like allowing administrators to set instance- or group-wide defaults while letting individual projects override them when needed, it can create challenges when building reusable pipeline components.\u003c/p\u003e\n\u003cp\u003eWhen creating components or templates that will be used across different projects and groups, the variable precedence hierarchy can make behavior less predictable. For example, a template that works perfectly in one project might behave differently in another due to group- or instance-level variable overrides that aren\u0026#39;t visible in a pipeline configuration.\u003c/p\u003e\n\u003cp\u003eWhen including multiple templates, it also can be challenging to track which variables are being set where and how they might interact.\u003c/p\u003e\n\u003cp\u003eIn addition, components authors need to document not just what variables their template uses, but also potential conflicts with variables that might be defined at higher precedence levels.\u003c/p\u003e\n\u003ch3 id=\"variable-precedence-examples\" tabindex=\"-1\"\u003eVariable precedence examples \u003ca href=\"#variable-precedence-examples\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eMain pipeline file (\u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nvariables:\n\n  ENVIRONMENT: production  # Top-level default for all jobs\n\n  DATABASE_URL: prod-db.example.com\n\ninclude:\n\n  - local: \u0026#39;templates/test-template.yml\u0026#39;\n\n  - local: \u0026#39;templates/deploy-template.yml\u0026#39;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eTest template (\u003ccode\u003etemplates/test-template.yml\u003c/code\u003e):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nrun-tests:\n\n  variables:\n\n    ENVIRONMENT: test  # Job-level variable overrides the default\n\n  script:\n\n    - echo \u0026#34;Running tests in $ENVIRONMENT environment\u0026#34;  \n\n    - echo \u0026#34;Database URL is $DATABASE_URL\u0026#34;  # Still inherits prod-db.example.com!\n\n    - run-integration-tests --env=$ENVIRONMENT --db=$DATABASE_URL\n\n    `# Issue: Tests run in \u0026#34;test\u0026#34; environment but against production database`\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eDeploy template (\u003ccode\u003etemplates/deploy-template.yml\u003c/code\u003e):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\ndeploy-app:\n\n  script:\n\n    - echo \u0026#34;Deploying to $ENVIRONMENT\u0026#34;  # Uses production (top-level default)\n\n    - echo \u0026#34;Database URL is $DATABASE_URL\u0026#34;  # Uses prod-db.example.com\n\n    - deploy --target=$ENVIRONMENT --db=$DATABASE_URL\n\n    # This will deploy to production as intended\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eThe challenges in this example:\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003ePartial inheritance: The test job gets \u003ccode\u003eENVIRONMENT=test\u003c/code\u003e but still inherits \u003ccode\u003eDATABASE_URL=prod-db.example.com\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCoordination complexity: Template authors must know what top-level variables exist and might conflict.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOverride behavior: Job-level variables with the same name override defaults, but this isn\u0026#39;t always obvious.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHidden dependencies: Templates become dependent on the main pipeline\u0026#39;s variable names.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eGitLab recognized these pain points and introduced \u003ca href=\"https://docs.gitlab.com/ee/ci/inputs/\"\u003eCI/CD inputs\u003c/a\u003e as a purpose-built solution for passing parameters to pipelines, offering typed parameters with built-in validation that occurs at pipeline creation time rather than during execution.\u003c/p\u003e\n\u003ch2 id=\"cicd-inputs-fundamentals\" tabindex=\"-1\"\u003eCI/CD inputs fundamentals \u003ca href=\"#cicd-inputs-fundamentals\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eInputs provide typed parameters for reusable pipeline configuration with built-in validation at pipeline creation time, designed specifically for defining values when the pipeline runs. They create a clear contract between the pipeline consumer and the configuration, explicitly defining what parameters are expected, their types, and constraints.\u003c/p\u003e\n\u003ch3 id=\"configuration-flexibility-and-scope\" tabindex=\"-1\"\u003eConfiguration flexibility and scope \u003ca href=\"#configuration-flexibility-and-scope\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eOne of the advantages of inputs is their configuration-time flexibility. Inputs are evaluated and interpolated during pipeline creation using the interpolation format \u003ccode\u003e$[[ inputs.input-id ]]\u003c/code\u003e, meaning they can be used anywhere in your pipeline configuration — including job names, rules conditions, images, and any other YAML configuration element. This eliminates the long-standing limitation of variable interpolation in certain contexts.\u003c/p\u003e\n\u003cp\u003eOne common use case we\u0026#39;ve seen is that users define their job names like \u003ccode\u003etest-$[[ inputs.environment ]]-deployment\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhen using inputs in job names, you can prevent naming conflicts when the same component is included multiple times in a single pipeline. Without this capability, including the same component twice would result in job name collisions, with the second inclusion overwriting the first. Input-based job names ensure each inclusion creates uniquely named jobs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBefore inputs:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\ntest-service:\n\n  variables:\n\n    SERVICE_NAME: auth-service\n\n    ENVIRONMENT: staging\n\n  script:\n\n    - run-tests-for $SERVICE_NAME in $ENVIRONMENT\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eWith inputs:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nspec:\n\n  inputs:\n\n    environment:\n\n      type: string\n\n    service_name:\n\n      type: string\n\ntest-$[[ inputs.service_name ]]-$[[ inputs.environment ]]:\n\n  script:\n\n    - run-tests-for $[[ inputs.service_name ]] in $[[ inputs.environment ]]\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen included multiple times with different inputs, this creates jobs like \u003ccode\u003etest-auth-service-staging\u003c/code\u003e, \u003ccode\u003etest-payment-service-production\u003c/code\u003e, and \u003ccode\u003etest-notification-service-development\u003c/code\u003e. Each job has a unique, meaningful name that clearly indicates its purpose, making pipeline visualization much clearer than having multiple jobs with identical names that would overwrite each other.\u003c/p\u003e\n\u003cp\u003eNow let\u0026#39;s go back to the first example in the top of this blog and use inputs, one immediate benefit is that instead of maintaining multiple templates file we can use one reusable template with different input values:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nspec:\n\n  inputs:\n\n    environment:\n\n      type: string\n\n    database_url:\n\n      type: string\n\n    action:\n\n      type: string\n\n---\n\n\n$[[ inputs.action ]]-$[[ inputs.environment ]]:\n\n  script:\n\n    - echo \u0026#34;Running $[[ inputs.action ]] in $[[ inputs.environment ]] environment\u0026#34;\n\n    - echo \u0026#34;Database URL is $[[ inputs.database_url ]]\u0026#34;\n\n    - run-$[[ inputs.action ]] --env=$[[ inputs.environment ]] --db=$[[ inputs.database_url ]]\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd in the main \u003ccode\u003egitlab-ci.yml\u003c/code\u003e file we can include it twice (or more) with different values, making sure we avoid naming collisions\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\ninclude:\n\n  - local: \u0026#39;templates/environment-template.yml\u0026#39;\n\n    inputs:\n\n      environment: test\n\n      database_url: test-db.example.com\n\n      action: tests\n\n  - local: \u0026#39;templates/environment-template.yml\u0026#39;\n\n    inputs:\n\n      environment: production\n\n      database_url: prod-db.example.com\n\n      action: deploy\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eThe result:\u003c/strong\u003e Instead of maintaining separate YAML files for testing and deployment jobs, you now have a single reusable template that handles both use cases safely. This approach scales to any number of environments or job types — reducing maintenance overhead, eliminating code duplication, and ensuring consistency across your entire pipeline configuration. One template to maintain instead of many, with zero risk of variable collision or configuration drift.\u003c/p\u003e\n\u003ch3 id=\"validation-and-type-safety\" tabindex=\"-1\"\u003eValidation and type safety \u003ca href=\"#validation-and-type-safety\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAnother key difference between variables and inputs lies in validation capabilities. Inputs support different value types, including strings, numbers, booleans, and arrays, with validation occurring immediately when the pipeline is created. If you define an input as a boolean but pass a string, GitLab will reject the pipeline before any jobs execute, saving time and resources.\u003c/p\u003e\n\u003cp\u003eHere is an example of the enormous benefit of type validation.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWithout type validation (variables):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nvariables:\n  ENABLE_TESTS: \u0026#34;true\u0026#34;  # Always a string\n  MAX_RETRIES: \u0026#34;3\u0026#34;      # Always a string\n\n  \ndeploy_job:\n  script:\n    - if [ \u0026#34;$ENABLE_TESTS\u0026#34; = true ]; then  # This fails!\n        echo \u0026#34;Running tests\u0026#34;\n      fi\n    - retry_count=$((MAX_RETRIES + 1))      # String concatenation: \u0026#34;31\u0026#34;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eProblem:\u003c/strong\u003e  The boolean check fails because “\u003ccode\u003etrue\u003c/code\u003e” (string) is not equal to \u003ccode\u003etrue\u003c/code\u003e, (boolean).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWith type validation (inputs):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nspec:\n  inputs:\n    enable_tests:\n      type: boolean\n      default: true\n    max_retries:\n      type: number\n      default: 3\n\n      \ndeploy_job:\n  script:\n    - if [ \u0026#34;$[[ inputs.enable_tests ]]\u0026#34; = true ]; then  # Works correctly\n        echo \u0026#34;Running tests\u0026#34;\n      fi\n    - retry_count=$(($[[ inputs.max_retries ]] + 1))    # Math works: 4\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eReal-world impact for variable type validation failure\u003c/strong\u003e: A developer or a process triggers a GitLab CI/CD pipeline with \u003ccode\u003eENABLE_TESTS = yes\u003c/code\u003e instead of \u003ccode\u003etrue\u003c/code\u003e. Assuming it takes on average 30 minutes before the deployment job starts, then finally when this job kicks off, 30 minutes or longer into the pipeline run, the deployment script tries to evaluate the boolean and fails.\u003c/p\u003e\n\u003cp\u003eImagine the impact in terms of time-to-market and, of course. developer time trying to debug why a seemingly basic deploy job failed.\u003c/p\u003e\n\u003cp\u003eWith type inputs, GitLab CI/CD will immediately throw an error and provide an explicit error message regarding the type mismatch.\u003c/p\u003e\n\u003ch3 id=\"security-and-access-control\" tabindex=\"-1\"\u003eSecurity and access control \u003ca href=\"#security-and-access-control\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eInputs provide enhanced security through controlled parameter passing with explicit contracts that define exactly what values are expected and allowed, creating clear boundaries between parameter passing to the pipeline, In addition. inputs are immutable. Once the pipeline starts, they cannot be modified during execution, providing predictable behavior throughout the pipeline lifecycle and eliminating the security risks that come from runtime variable manipulation.\u003c/p\u003e\n\u003ch3 id=\"scope-and-lifecycle\" tabindex=\"-1\"\u003eScope and lifecycle \u003ca href=\"#scope-and-lifecycle\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWhen you define variables using the \u003ccode\u003evariables:\u003c/code\u003e keyword at the top level of your \u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e file, these variables become defaults for all jobs in your entire pipeline. When you include templates, you must consider what variables you\u0026#39;ve defined globally, as they can interact with the template\u0026#39;s expected behavior through GitLab\u0026#39;s variable precedence order.\u003c/p\u003e\n\u003cp\u003eInputs are defined in CI configuration files (e.g. components or templates) and assigned values when a pipeline is triggered, allowing you to customize reusable CI configurations. They exist solely for pipeline creation and configuration time, scoped to the CI configuration file where they\u0026#39;re defined, and become immutable references once the pipeline begins execution. Since each component maintains its own inputs, there is no risk of inputs interfering with other components or templates in your pipeline, eliminating variable collision and override issues that can occur with variable-based approaches.\u003c/p\u003e\n\u003ch2 id=\"working-with-variables-and-inputs-together\" tabindex=\"-1\"\u003eWorking with variables and inputs together \u003ca href=\"#working-with-variables-and-inputs-together\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe recognize that teams have extensive investments in their variable-based workflows, and migration to inputs doesn\u0026#39;t happen overnight. That\u0026#39;s why we\u0026#39;ve developed capabilities that allow inputs and variables to work seamlessly together, providing a bridge between existing variables and the benefits of inputs while overcoming some key challenges in variable expansion.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s look at this real-world example.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eVariable expansion in rules conditions\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eA common challenge occurs when using variables that contain other variable references in \u003ccode\u003erules:if\u003c/code\u003e conditions. GitLab only expands variables one level deep during rule evaluation, which can lead to unexpected behavior:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# This doesn\u0026#39;t work as expected\n\nvariables:\n  TARGET_ENV:\n    value: \u0026#34;${CI_COMMIT_REF_SLUG}\u0026#34;\n\ndeploy-job:\n  rules:\n    - if: \u0026#39;$TARGET_ENV == \u0026#34;production\u0026#34;\u0026#39;  # Compares \u0026#34;${CI_COMMIT_REF_SLUG}\u0026#34; != \u0026#34;production\u0026#34;\n      variables:\n        DEPLOY_MODE: \u0026#34;blue-green\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eexpand_vars\u003c/code\u003e function solves this by forcing proper variable expansion in inputs:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003espec:\n  inputs:\n    target_environment:\n      description: \u0026#34;Target deployment environment\u0026#34;\n      default: \u0026#34;${CI_COMMIT_REF_SLUG}\u0026#34;\n---\n\n\ndeploy-job:\n  rules:\n    - if: \u0026#39;\u0026#34;$[[ inputs.target_environment | expand_vars ]]\u0026#34; == \u0026#34;production\u0026#34;\u0026#39;\n      variables:\n        DEPLOY_MODE: \u0026#34;blue-green\u0026#34;\n        APPROVAL_REQUIRED: \u0026#34;true\u0026#34;\n    - when: always\n      variables:\n        DEPLOY_MODE: \u0026#34;rolling\u0026#34;\n        APPROVAL_REQUIRED: \u0026#34;false\u0026#34;\n  script:\n    - echo \u0026#34;Target: $[[ inputs.target_environment | expand_vars ]]\u0026#34;\n    - echo \u0026#34;Deploy mode: ${DEPLOY_MODE}\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"why-this-matters\" tabindex=\"-1\"\u003eWhy this matters \u003ca href=\"#why-this-matters\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWithout \u003ccode\u003eexpand_vars\u003c/code\u003e, rule conditions evaluate against the literal variable reference (like \u003ccode\u003e\u0026#34;${CI_COMMIT_REF_SLUG}\u0026#34;\u003c/code\u003e) rather than the expanded value (like \u003ccode\u003e\u0026#34;production\u0026#34;\u003c/code\u003e). This leads to rules that never match when you expect them to, breaking conditional pipeline logic.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eImportant notes about expand_vars:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eOnly variables that can be used with the include keyword are supported\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVariables must be unmasked (not marked as protected/masked)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNested variable expansion is not supported\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRule conditions using \u003ccode\u003eexpand_vars\u003c/code\u003e must be properly quoted: \u003ccode\u003e\u0026#39;\u0026#34;$[[ inputs.name | expand_vars ]]\u0026#34; == \u0026#34;value\u0026#34;\u0026#39;\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis pattern solves the single-level variable expansion limitation, working for any conditional logic that requires comparing fully resolved variable values.\u003c/p\u003e\n\u003ch3 id=\"function-chaining-for-advanced-processing\" tabindex=\"-1\"\u003eFunction chaining for advanced processing \u003ca href=\"#function-chaining-for-advanced-processing\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAlong with \u003ccode\u003eexpand_vars\u003c/code\u003e, you can use functions like \u003ccode\u003etruncate\u003c/code\u003e to shorten values for compliance with naming restrictions (such as Kubernetes resource names), creating sophisticated parameter processing pipelines while maintaining input safety and predictability.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n\nspec:  \n\n  inputs:\n\n    service_identifier:\n\n      default: \u0026#39;service-$CI_PROJECT_NAME-$CI_COMMIT_REF_SLUG\u0026#39;\n\n---\n\n\ncreate-resource:\n\n  script:\n\n    - resource_name=$[[ inputs.service_identifier | expand_vars | truncate(0,50) ]]\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis integration capability allows you to adopt inputs gradually while leveraging your existing variable infrastructure, making the migration path much smoother.\u003c/p\u003e\n\u003ch3 id=\"from-components-only-to-ci-pipelines\" tabindex=\"-1\"\u003eFrom components only to CI pipelines \u003ca href=\"#from-components-only-to-ci-pipelines\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eUp until GitLab 17.11, GitLab users were able to use inputs only in components and templates through the \u003ccode\u003einclude:\u003c/code\u003e syntax. This limited their use to reusable CI/CD configurations, but didn\u0026#39;t address the broader need for dynamic pipeline customization.\u003c/p\u003e\n\u003ch3 id=\"pipeline-wide-inputs-support\" tabindex=\"-1\"\u003ePipeline-wide inputs support \u003ca href=\"#pipeline-wide-inputs-support\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eStarting with GitLab 17.11, GitLab users can now use inputs to safely modify pipeline behavior across all pipeline execution contexts, replacing the traditional reliance on pipeline variables. This expanded support includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eScheduled pipelines: Define inputs with defaults for automated pipeline runs while allowing manual override when needed.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDownstream pipelines: Pass structured inputs to child and multi-project pipelines with proper validation and type safety.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eManual pipelines: Present users with a clean, validated form interface.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThose enhancements, with more to follow, allow teams to modernize their pipelines while maintaining backward compatibility gradually. Once inputs are fully adopted, users can disable pipeline variables to ensures a more secure and predictable CI/CD environment.\u003c/p\u003e\n\u003ch2 id=\"summary\" tabindex=\"-1\"\u003eSummary \u003ca href=\"#summary\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe transition from variables to inputs represents more than just a technical upgrade — it\u0026#39;s a shift toward more maintainable, predictable, and secure CI/CD pipelines. While variables continue to serve important purposes for configuration, inputs provide the parameter-passing capabilities that teams have been working around for years.\u003c/p\u003e\n\u003cp\u003eWe understand that variables are deeply embedded in existing workflows, which is why we\u0026#39;ve built bridges between the two systems. The \u003ccode\u003eexpand_vars\u003c/code\u003e function and other input capabilities allow you to adopt inputs gradually while leveraging your existing variable infrastructure.\u003c/p\u003e\n\u003cp\u003eBy starting with new components and templates, then gradually migrating high-impact workflows, you\u0026#39;ll quickly see the benefits of clearer contracts, earlier error detection, and more reliable automation that scales across your organization. Additionally, moving to inputs creates an excellent foundation for leveraging \u003ca href=\"https://gitlab.com/explore/catalog\"\u003eGitLab\u0026#39;s CI/CD Catalog\u003c/a\u003e, where reusable components with typed interfaces become powerful building blocks for your DevOps workflows but more on that in our next blog post.\u003c/p\u003e\n\u003cp\u003eYour future self and your teammates will thank you for the clarity and reliability that inputs bring to your CI/CD workflows, while still being able to work with the variable systems you\u0026#39;ve already invested in.\u003c/p\u003e\n\u003ch2 id=\"what\u0026#39;s-next\" tabindex=\"-1\"\u003eWhat\u0026#39;s next \u003ca href=\"#what\u0026#39;s-next\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLooking ahead, we\u0026#39;re expanding inputs to solve two key challenges: enhancing pipeline triggering with cascading options that \u003ca href=\"https://gitlab.com/gitlab-org/gitlab/-/issues/520094\"\u003edynamically adjust based on user selections\u003c/a\u003e, and providing job-level inputs that allow users to \u003ca href=\"https://gitlab.com/groups/gitlab-org/-/epics/17833\"\u003eretry individual jobs with different parameter values\u003c/a\u003e. We encourage you to follow these discussions, share your feedback, and contribute to shaping these features. You can also provide general feedback on CI/CD inputs through our \u003ca href=\"https://gitlab.com/gitlab-org/gitlab/-/issues/407556\"\u003efeedback issue\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"read-more\" tabindex=\"-1\"\u003eRead more \u003ca href=\"#read-more\"\u003e\n          \u003csvg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\n        \u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://about.gitlab.com/blog/how-to-include-file-references-in-your-ci-cd-components/\"\u003eHow to include file references in your CI/CD components\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.gitlab.com/ci/inputs/\"\u003eCI/CD inputs documentation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://about.gitlab.com/blog/ci-cd-catalog-goes-ga-no-more-building-pipelines-from-scratch/\"\u003eCI/CD Catalog goes GA: No more building pipelines from scratch\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://about.gitlab.com/blog/demystifying-ci-cd-variables/\"\u003eGitLab environment variables demystified\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "21 min read",
  "publishedTime": "2025-07-07T00:00:00Z",
  "modifiedTime": null
}
