{
  "id": "6707835b-2e00-412b-820b-cb3a9b9ec6b5",
  "title": "How Netflix Accurately Attributes eBPF Flow Logs",
  "link": "https://netflixtechblog.com/how-netflix-accurately-attributes-ebpf-flow-logs-afe6d644a3bc?source=rss----2615bd06b42e---4",
  "description": "",
  "author": "Netflix Technology Blog",
  "published": "Tue, 08 Apr 2025 17:50:58 GMT",
  "source": "https://netflixtechblog.com/feed",
  "categories": [
    "ebpf",
    "networking",
    "observability",
    "linux",
    "containers"
  ],
  "byline": "Netflix Technology Blog",
  "length": 14702,
  "excerpt": "In a previous blog post, we described how Netflix uses eBPF to capture TCP flow logs at scale for enhanced cloud network insights. In this post, we delve deeper into how Netflix solved a core…",
  "siteName": "Netflix TechBlog",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "How Netflix Accurately Attributes eBPF Flow LogsBy Cheng Xie, Bryan Shultz, and Christine XuIn a previous blog post, we described how Netflix uses eBPF to capture TCP flow logs at scale for enhanced cloud network insights. In this post, we delve deeper into how Netflix solved a core problem: accurately attributing flow IP addresses to workload identities.A Brief RecapFlowExporter is a sidecar that runs alongside all Netflix workloads in the AWS Cloud. It uses eBPF and TCP tracepoints to monitor TCP socket state changes. When a TCP socket closes, FlowExporter generates a flow log record that includes the IP addresses, ports, timestamps, and additional socket statistics. On average, 5 million records are produced per second.In cloud environments, IP addresses are reassigned to different workloads as workload instances are created and terminated, so IP addresses alone cannot provide insights on which workloads are communicating. To make the flow logs useful, each IP address must be attributed to its corresponding workload identity. FlowCollector, a backend service, collects flow logs from FlowExporter instances across the fleet, attributes the IP addresses, and sends these attributed flows to Netflix’s Data Mesh for subsequent stream and batch processing.The eBPF flow logs provide a comprehensive view of service topology and network health across Netflix’s extensive microservices fleet, regardless of the programming language, RPC mechanism, or application-layer protocol used by individual workloads. This is especially useful for reaching the corners where our Service Mesh does not yet have coverage.The Problem with MisattributionAccurately attributing flow IP addresses to workload identities has been a significant challenge since our eBPF flow logs were introduced.As noted in our previous blog post, our initial attribution approach relied on Sonar, an internal IP address tracking service that emits an event whenever an IP address in Netflix’s AWS VPCs is assigned or unassigned to a workload. FlowCollector consumes a stream of IP address change events from Sonar and uses this information to attribute flow IP addresses in real-time.The fundamental drawback of this method is that it can lead to misattribution. Delays and failures are inevitable in distributed systems, which may delay IP address change events from reaching FlowCollector. For instance, an IP address may initially be assigned to workload X but later reassigned to workload Y. However, if the change event for this reassignment is delayed, FlowCollector will continue to assume that the IP address belongs to workload X, resulting in misattributed flows. Additionally, event timestamps may be inaccurate depending on how they are captured.Misattribution rendered the flow data unreliable for decision-making. Users often depend on flow logs to validate workload dependencies, but misattribution creates confusion. Without expert knowledge of expected dependencies, users would struggle to identify or confirm misattribution. Moreover, misattribution occurred frequently for critical services with a large footprint due to frequent IP address changes. Overall, misattribution makes fleet-wide dependency analysis impractical.As a workaround, we made FlowCollector hold received flows for 15 minutes before attribution, allowing time for delayed IP address change events. While this approach reduced misattribution, it did not eliminate it. Moreover, the waiting period made the data less fresh, reducing its utility for real-time analysis.Fully eliminating misattribution is crucial because it only takes a single misattributed flow to produce an incorrect workload dependency. Solving this problem required a complete rethinking of our approach. Over the past year, Netflix developed a new attribution method that has finally eliminated misattribution, as detailed in the rest of this post.Attributing Local IP AddressesEach socket has two IP addresses: a local IP address and a remote IP address. Previously, we used the same method to attribute both. However, attributing the local IP address should be a simpler task since the local IP address belongs to the instance where FlowExporter captures the socket. Therefore, FlowExporter should determine the local workload identity from its environment and attribute the local IP address before sending the flow to FlowCollector.This is straightforward for workloads running directly on EC2 instances, as Netflix’s Metatron provisions workload identity certificates to each EC2 instance at boot time. FlowExporter can simply read these certificates from the local disk to determine the local workload identity.Attributing local IP addresses for container workloads running on Netflix’s container platform, Titus, is more challenging. FlowExporter runs at the container host level, where each host manages multiple container workloads with different identities. When FlowExporter’s eBPF programs receive a socket event from TCP tracepoints in the kernel, the socket may have been created by one of the container workloads or by the host itself. Therefore, FlowExporter must determine which workload to attribute the socket’s local IP address to. To solve this problem, we leveraged IPMan, Netflix’s container IP address assignment service. IPManAgent, a daemon running on every container host, is responsible for assigning and unassigning IP addresses. As container workloads are launched, IPManAgent writes an IP-address-to-workload-ID mapping to an eBPF map, which FlowExporter’s eBPF programs can then use to look up the workload ID associated with a socket local IP address.Another challenge was to accommodate Netflix’s IPv6 to IPv4 translation mechanism on Titus. To facilitate IPv6 migration, Netflix developed a mechanism that enables IPv6-only containers to communicate with IPv4 destinations without incurring NAT64 overhead. This mechanism intercepts connect syscalls and replaces the underlying socket with one that uses a shared IPv4 address assigned to the container host. This confuses FlowExporter because the kernel reports the same local IPv4 address for sockets created by different container workloads. To disambiguate, local port information is additionally required. We modified Titus to write a mapping of (local IPv4 address, local port) to the workload ID into an eBPF map whenever a connect syscall is intercepted. FlowExporter’s eBPF programs then use this map to correctly attribute sockets created by the translation mechanism.With these problems solved, we can now accurately attribute the local IP address of every flow.Attributing Remote IP AddressesOnce the local IP address attribution problem is solved, accurately attributing remote IP addresses becomes feasible. Now, each flow reported by FlowExporter includes the local IP address, the local workload identity, and connection start/end timestamps. As FlowCollector receives these flows, it can learn the time ranges during which each workload owns a given IP address. For instance, if FlowCollector sees a flow with local IP address 10.0.0.1 associated with workload X that starts at t1 and ends at t2, it can deduce that 10.0.0.1 belonged to workload X from t1 to t2. Since Netflix uses Amazon Time Sync across its fleet, the timestamps (captured by FlowExporter) are reliable.The FlowCollector service cluster consists of many nodes. Every node must be capable of attributing arbitrary remote IP addresses and, therefore, requires knowledge of all workload IP addresses and their recent ownership records. To represent this knowledge, each node maintains an in-memory hashmap that maps an IP address to a list of time ranges, as illustrated by the following Go structs:type IPAddressTracker struct { ipToTimeRanges map[netip.Addr]timeRanges}type timeRanges []timeRangetype timeRange struct { workloadID string start time.Time end time.Time}To populate the hashmap, FlowCollector extracts the local IP address, local workload identity, start time, and end time from each received flow and creates/extends the corresponding time ranges in the map. The time ranges for each IP address are sorted in ascending order, and they are non-overlapping since an IP address cannot belong to two different workloads simultaneously.Since each flow is only sent to one FlowCollector node, each node must share the time ranges it learned from received flows with other nodes. We implemented a broadcasting mechanism using Kafka, where each node publishes learned time ranges to all other nodes. Although more efficient broadcasting implementations exist, the Kafka-based approach is simple and has worked well for us.Now, FlowCollector can attribute remote IP addresses by looking them up in the populated map, which returns a list of time ranges. It then uses the flow’s start timestamp to determine the corresponding time range and associated workload identity. If the start time does not fall within any time range, FlowCollector will retry after a delay, eventually giving up if the retry fails. Such failures may occur when flows are lost or broadcast messages are delayed. For our use cases, it is acceptable to leave a small percentage of flows unattributed, but any misattribution is unacceptable.This new method achieves accurate attribution thanks to the continuous heartbeats, each associated with a reliable time range of IP address ownership. It handles transient issues gracefully — a few delayed or lost heartbeats do not lead to misattribution. In contrast, the previous method relied solely on discrete IP address assignment and unassignment events. Lacking heartbeats, it had to presume an IP address remained assigned until notified otherwise (which can be hours or days later), making it vulnerable to misattribution when the notifications were delayed.One detail is that when FlowCollector receives a flow, it cannot attribute its remote IP address right away because it requires the latest observed time ranges for the remote IP address. Since FlowExporter reports flows in batches every minute, FlowCollector must wait until it receives the flow batch from the remote workload FlowExporter for the last minute, which may not have arrived yet. To address this, FlowCollector temporarily stores received flows on disk for one minute before attributing their remote IP addresses. This introduces a 1-minute delay, but it is much shorter than the 15-minute delay with the previous approach.In addition to producing accurate attribution, the new method is also cost-effective thanks to its simplicity and in-memory lookups. Because the in-memory state can be quickly rebuilt when a FlowCollector node starts up, no persistent storage is required. With 30 c7i.2xlarge instances, we can process 5 million flows per second for the entire Netflix fleet.Attributing Cross-Regional IP AddressesFor simplicity, we have so far glossed over one topic: regionalization. Netflix’s cloud microservices operate across multiple AWS regions. To optimize flow reporting and minimize cross-regional traffic, a FlowCollector cluster runs in each major region, and FlowExporter agents send flows to their corresponding regional FlowCollector. When FlowCollector receives a flow, its local IP address is guaranteed to be within the region.To minimize cross-region traffic, the broadcasting mechanism is limited to FlowCollector nodes within the same region. Consequently, the IP address time ranges map contains only IP addresses from that region. However, cross-regional flows have a remote IP address in a different region. To attribute these flows, the receiving FlowCollector node forwards them to nodes in the corresponding region. FlowCollector determines the region for a remote IP address by looking up a trie built from all Netflix VPC CIDRs. This approach is more efficient than broadcasting IP address time range updates across all regions, as only 1% of Netflix flows are cross-regional.Attributing Non-Workload IP AddressesSo far, FlowCollector can accurately attribute IP addresses belonging to Netflix’s cloud workloads. However, not all flow IP addresses fall into this category. For instance, a significant portion of flows goes through AWS ELBs. For these flows, their remote IP addresses are associated with the ELBs, where we cannot run FlowExporter. Consequently, FlowCollector cannot determine their identities by simply observing the received flows. To attribute these remote IP addresses, we continue to use IP address change events from Sonar, which crawls AWS resources to detect changes in IP address assignments. Although this data stream may contain inaccurate timestamps and be delayed, misattribution is not a main concern since ELB IP address reassignment occurs very infrequently.Verifying CorrectnessVerifying that the new method has eliminated misattribution is challenging due to the lack of a definitive source of truth for workload dependencies to validate flow logs against; the flow logs themselves are intended to serve as this source of truth, after all. To build confidence, we analyzed the flow logs of a large service with well-understood dependencies. A large footprint is necessary, as misattribution is more prevalent in services with numerous instances, and there must be a reliable method to determine the dependencies for this service without relying on flow logs.Netflix’s cloud gateway, Zuul, served this purpose perfectly due to its extensive footprint (handling all cloud ingress traffic), its large number of downstream dependencies, and our ability to derive its dependencies from its routing configurations as the source of truth for comparison with flow logs. We found no misattribution for flows through Zuul over a two-week window. This provided strong confidence that the new attribution method has eliminated misattribution. In the previous approach, approximately 40% of Zuul’s dependencies reported by the flow logs were misattributed.ConclusionWith misattribution solved, eBPF flow logs now deliver dependable, fleet-wide insights into Netflix’s service topology and network health. This advancement unlocks numerous exciting opportunities in areas such as service dependency auditing, security analysis, and incident triage, while helping Netflix engineers develop a better understanding of our ever-evolving distributed systems.AcknowledgmentsWe would like to thank Martin Dubcovsky, Joanne Koong, Taras Roshko, Nabil Schear, Jacob Meyers, Parsha Pourkhomami, Hechao Li, Donavan Fritz, Rob Gulewich, Amanda Li, John Salem, Hariharan Ananthakrishnan, Keerti Lakshminarayan, and other stunning colleagues for their feedback, inspiration, and contributions to the success of this effort.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*o8tJzaxRlWDBIYBS",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"ccc4\" data-testid=\"storyTitle\"\u003eHow Netflix Accurately Attributes eBPF Flow Logs\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://netflixtechblog.medium.com/?source=post_page---byline--afe6d644a3bc---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Netflix Technology Blog\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*BJWRqfSMf9Da9vsXG9EBRQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://netflixtechblog.com/?source=post_page---byline--afe6d644a3bc---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Netflix TechBlog\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*ty4NvNrGg4ReETxqU2N3Og.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"84ec\"\u003eBy \u003ca href=\"https://www.linkedin.com/in/chengxie90/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCheng Xie\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/bryan-shultz-85983829/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBryan Shultz\u003c/a\u003e, and \u003ca href=\"https://www.linkedin.com/in/christine-xu-1b77191b/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eChristine Xu\u003c/a\u003e\u003c/p\u003e\u003cp id=\"be87\"\u003eIn a previous \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://netflixtechblog.com/how-netflix-uses-ebpf-flow-logs-at-scale-for-network-insight-e3ea997dca96\"\u003eblog post\u003c/a\u003e, we described how Netflix uses eBPF to capture TCP flow logs at scale for enhanced cloud network insights. In this post, we delve deeper into how Netflix solved a core problem: accurately attributing flow IP addresses to workload identities.\u003c/p\u003e\u003ch2 id=\"3fde\"\u003eA Brief Recap\u003c/h2\u003e\u003cp id=\"9147\"\u003e\u003cstrong\u003eFlowExporter\u003c/strong\u003e is a sidecar that runs alongside all Netflix workloads in the AWS Cloud. It uses eBPF and \u003ca href=\"https://www.brendangregg.com/blog/2018-03-22/tcp-tracepoints.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTCP tracepoints\u003c/a\u003e to monitor TCP socket state changes. When a TCP socket closes, FlowExporter generates a flow log record that includes the IP addresses, ports, timestamps, and additional socket statistics. On average, 5 million records are produced per second.\u003c/p\u003e\u003cp id=\"4fce\"\u003eIn cloud environments, IP addresses are reassigned to different workloads as workload instances are created and terminated, so IP addresses alone cannot provide insights on which workloads are communicating. To make the flow logs useful, each IP address must be attributed to its corresponding workload identity. \u003cstrong\u003eFlowCollector\u003c/strong\u003e, a backend service, collects flow logs from FlowExporter instances across the fleet, attributes the IP addresses, and sends these attributed flows to Netflix’s \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://netflixtechblog.com/data-mesh-a-data-movement-and-processing-platform-netflix-1288bcab2873\"\u003eData Mesh\u003c/a\u003e for subsequent stream and batch processing.\u003c/p\u003e\u003cp id=\"6fbd\"\u003eThe eBPF flow logs provide a comprehensive view of service topology and network health across Netflix’s extensive microservices fleet, regardless of the programming language, RPC mechanism, or application-layer protocol used by individual workloads. This is especially useful for reaching the corners where our \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://netflixtechblog.com/zero-configuration-service-mesh-with-on-demand-cluster-discovery-ac6483b52a51\"\u003eService Mesh\u003c/a\u003e does not yet have coverage.\u003c/p\u003e\u003ch2 id=\"a716\"\u003eThe Problem with Misattribution\u003c/h2\u003e\u003cp id=\"21b9\"\u003eAccurately attributing flow IP addresses to workload identities has been a significant challenge since our eBPF flow logs were introduced.\u003c/p\u003e\u003cp id=\"413b\"\u003eAs noted in our previous blog post, our initial attribution approach relied on \u003ca href=\"https://youtu.be/8C9xNVYbCVk?si=Mqic7typcyB-v3JR\u0026amp;t=1687\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSonar\u003c/a\u003e, an internal IP address tracking service that emits an event whenever an IP address in Netflix’s AWS VPCs is assigned or unassigned to a workload. FlowCollector consumes a stream of IP address change events from Sonar and uses this information to attribute flow IP addresses in real-time.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"fd88\"\u003eThe fundamental drawback of this method is that it can lead to misattribution. Delays and failures are inevitable in distributed systems, which may delay IP address change events from reaching FlowCollector. For instance, an IP address may initially be assigned to workload X but later reassigned to workload Y. However, if the change event for this reassignment is delayed, FlowCollector will continue to assume that the IP address belongs to workload X, resulting in misattributed flows. Additionally, event timestamps may be inaccurate depending on how they are captured.\u003c/p\u003e\u003cp id=\"7a27\"\u003eMisattribution rendered the flow data unreliable for decision-making. Users often depend on flow logs to validate workload dependencies, but misattribution creates confusion. Without expert knowledge of expected dependencies, users would struggle to identify or confirm misattribution. Moreover, misattribution occurred frequently for critical services with a large footprint due to frequent IP address changes. Overall, misattribution makes fleet-wide dependency analysis impractical.\u003c/p\u003e\u003cp id=\"29df\"\u003eAs a workaround, we made FlowCollector hold received flows for 15 minutes before attribution, allowing time for delayed IP address change events. While this approach reduced misattribution, it did not eliminate it. Moreover, the waiting period made the data less fresh, reducing its utility for real-time analysis.\u003c/p\u003e\u003cp id=\"200e\"\u003eFully eliminating misattribution is crucial because it only takes a single misattributed flow to produce an incorrect workload dependency. Solving this problem required a complete rethinking of our approach. Over the past year, Netflix developed a new attribution method that has finally eliminated misattribution, as detailed in the rest of this post.\u003c/p\u003e\u003ch2 id=\"276f\"\u003eAttributing Local IP Addresses\u003c/h2\u003e\u003cp id=\"994e\"\u003eEach socket has two IP addresses: a local IP address and a remote IP address. Previously, we used the same method to attribute both. However, attributing the local IP address should be a simpler task since the local IP address belongs to the instance where FlowExporter captures the socket. Therefore, FlowExporter should determine the local workload identity from its environment and attribute the local IP address before sending the flow to FlowCollector.\u003c/p\u003e\u003cp id=\"da55\"\u003eThis is straightforward for workloads running directly on EC2 instances, as Netflix’s \u003ca href=\"https://www.youtube.com/watch?v=-mmOT9I6JlY\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMetatron\u003c/a\u003e provisions workload identity certificates to each EC2 instance at boot time. FlowExporter can simply read these certificates from the local disk to determine the local workload identity.\u003c/p\u003e\u003cp id=\"81e0\"\u003eAttributing local IP addresses for container workloads running on Netflix’s container platform, \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://netflixtechblog.com/titus-the-netflix-container-management-platform-is-now-open-source-f868c9fb5436\"\u003eTitus\u003c/a\u003e, is more challenging. FlowExporter runs at the container host level, where each host manages multiple container workloads with different identities. When FlowExporter’s eBPF programs receive a socket event from TCP tracepoints in the kernel, the socket may have been created by one of the container workloads or by the host itself. Therefore, FlowExporter must determine which workload to attribute the socket’s local IP address to. To solve this problem, we leveraged \u003ca href=\"https://www.youtube.com/watch?v=fmUM9bMoCNE\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eIPMan\u003c/a\u003e, Netflix’s container IP address assignment service. IPManAgent, a daemon running on every container host, is responsible for assigning and unassigning IP addresses. As container workloads are launched, IPManAgent writes an IP-address-to-workload-ID mapping to an eBPF map, which FlowExporter’s eBPF programs can then use to look up the workload ID associated with a socket local IP address.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9514\"\u003eAnother challenge was to accommodate Netflix’s \u003ca href=\"https://lpc.events/event/11/contributions/932/attachments/908/1764/LPC%202021_%20Talking%20IPv6%20to%20IPv4%20Without%20NAT_2.pdf\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eIPv6 to IPv4 translation mechanism\u003c/a\u003e on Titus. To facilitate IPv6 migration, Netflix developed a mechanism that enables IPv6-only containers to communicate with IPv4 destinations without incurring NAT64 overhead. This mechanism intercepts connect syscalls and replaces the underlying socket with one that uses a shared IPv4 address assigned to the container host. This confuses FlowExporter because the kernel reports the same local IPv4 address for sockets created by different container workloads. To disambiguate, local port information is additionally required. We modified Titus to write a mapping of (local IPv4 address, local port) to the workload ID into an eBPF map whenever a connect syscall is intercepted. FlowExporter’s eBPF programs then use this map to correctly attribute sockets created by the translation mechanism.\u003c/p\u003e\u003cp id=\"9cd6\"\u003eWith these problems solved, we can now accurately attribute the local IP address of every flow.\u003c/p\u003e\u003ch2 id=\"d60f\"\u003eAttributing Remote IP Addresses\u003c/h2\u003e\u003cp id=\"0edb\"\u003eOnce the local IP address attribution problem is solved, accurately attributing remote IP addresses becomes feasible. Now, each flow reported by FlowExporter includes the local IP address, the local workload identity, and connection start/end timestamps. As FlowCollector receives these flows, it can learn the time ranges during which each workload owns a given IP address. For instance, if FlowCollector sees a flow with local IP address 10.0.0.1 associated with workload X that starts at t1 and ends at t2, it can deduce that 10.0.0.1 belonged to workload X from t1 to t2. Since Netflix uses \u003ca href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAmazon Time Sync\u003c/a\u003e across its fleet, the timestamps (captured by FlowExporter) are reliable.\u003c/p\u003e\u003cp id=\"7cd7\"\u003eThe FlowCollector service cluster consists of many nodes. Every node must be capable of attributing arbitrary remote IP addresses and, therefore, requires knowledge of all workload IP addresses and their recent ownership records. To represent this knowledge, each node maintains an in-memory hashmap that maps an IP address to a list of time ranges, as illustrated by the following Go structs:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"94fb\"\u003etype IPAddressTracker struct {\u003cbr/\u003e    ipToTimeRanges map[netip.Addr]timeRanges\u003cbr/\u003e}\u003cp\u003etype timeRanges []timeRange\u003c/p\u003e\u003cp\u003etype timeRange struct {\u003cbr/\u003e    workloadID   string\u003cbr/\u003e    start        time.Time\u003cbr/\u003e    end          time.Time\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5dda\"\u003eTo populate the hashmap, FlowCollector extracts the local IP address, local workload identity, start time, and end time from each received flow and creates/extends the corresponding time ranges in the map. The time ranges for each IP address are sorted in ascending order, and they are non-overlapping since an IP address cannot belong to two different workloads simultaneously.\u003c/p\u003e\u003cp id=\"c274\"\u003eSince each flow is only sent to one FlowCollector node, each node must share the time ranges it learned from received flows with other nodes. We implemented a broadcasting mechanism using Kafka, where each node publishes learned time ranges to all other nodes. Although more efficient broadcasting implementations exist, the Kafka-based approach is simple and has worked well for us.\u003c/p\u003e\u003cp id=\"68ab\"\u003eNow, FlowCollector can attribute remote IP addresses by looking them up in the populated map, which returns a list of time ranges. It then uses the flow’s start timestamp to determine the corresponding time range and associated workload identity. If the start time does not fall within any time range, FlowCollector will retry after a delay, eventually giving up if the retry fails. Such failures may occur when flows are lost or broadcast messages are delayed. For our use cases, it is acceptable to leave a small percentage of flows unattributed, but any misattribution is unacceptable.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"8fcd\"\u003eThis new method achieves accurate attribution thanks to the continuous heartbeats, each associated with a reliable time range of IP address ownership. It handles transient issues gracefully — a few delayed or lost heartbeats do not lead to misattribution. In contrast, the previous method relied solely on discrete IP address assignment and unassignment events. Lacking heartbeats, it had to presume an IP address remained assigned until notified otherwise (which can be hours or days later), making it vulnerable to misattribution when the notifications were delayed.\u003c/p\u003e\u003cp id=\"704c\"\u003eOne detail is that when FlowCollector receives a flow, it cannot attribute its remote IP address right away because it requires the latest observed time ranges for the remote IP address. Since FlowExporter reports flows in batches every minute, FlowCollector must wait until it receives the flow batch from the remote workload FlowExporter for the last minute, which may not have arrived yet. To address this, FlowCollector temporarily stores received flows on disk for one minute before attributing their remote IP addresses. This introduces a 1-minute delay, but it is much shorter than the 15-minute delay with the previous approach.\u003c/p\u003e\u003cp id=\"827b\"\u003eIn addition to producing accurate attribution, the new method is also cost-effective thanks to its simplicity and in-memory lookups. Because the in-memory state can be quickly rebuilt when a FlowCollector node starts up, no persistent storage is required. With 30 c7i.2xlarge instances, we can process 5 million flows per second for the entire Netflix fleet.\u003c/p\u003e\u003ch2 id=\"7687\"\u003eAttributing Cross-Regional IP Addresses\u003c/h2\u003e\u003cp id=\"26ad\"\u003eFor simplicity, we have so far glossed over one topic: regionalization. Netflix’s cloud microservices operate across multiple AWS regions. To optimize flow reporting and minimize cross-regional traffic, a FlowCollector cluster runs in each major region, and FlowExporter agents send flows to their corresponding regional FlowCollector. When FlowCollector receives a flow, its local IP address is guaranteed to be within the region.\u003c/p\u003e\u003cp id=\"cdfc\"\u003eTo minimize cross-region traffic, the broadcasting mechanism is limited to FlowCollector nodes within the same region. Consequently, the IP address time ranges map contains only IP addresses from that region. However, cross-regional flows have a remote IP address in a different region. To attribute these flows, the receiving FlowCollector node forwards them to nodes in the corresponding region. FlowCollector determines the region for a remote IP address by looking up a trie built from all Netflix VPC CIDRs. This approach is more efficient than broadcasting IP address time range updates across all regions, as only 1% of Netflix flows are cross-regional.\u003c/p\u003e\u003ch2 id=\"f8f3\"\u003eAttributing Non-Workload IP Addresses\u003c/h2\u003e\u003cp id=\"5a96\"\u003eSo far, FlowCollector can accurately attribute IP addresses belonging to Netflix’s cloud workloads. However, not all flow IP addresses fall into this category. For instance, a significant portion of flows goes through AWS ELBs. For these flows, their remote IP addresses are associated with the ELBs, where we cannot run FlowExporter. Consequently, FlowCollector cannot determine their identities by simply observing the received flows. To attribute these remote IP addresses, we continue to use IP address change events from Sonar, which crawls AWS resources to detect changes in IP address assignments. Although this data stream may contain inaccurate timestamps and be delayed, misattribution is not a main concern since ELB IP address reassignment occurs very infrequently.\u003c/p\u003e\u003ch2 id=\"4953\"\u003eVerifying Correctness\u003c/h2\u003e\u003cp id=\"6cc9\"\u003eVerifying that the new method has eliminated misattribution is challenging due to the lack of a definitive source of truth for workload dependencies to validate flow logs against; the flow logs themselves are intended to serve as this source of truth, after all. To build confidence, we analyzed the flow logs of a large service with well-understood dependencies. A large footprint is necessary, as misattribution is more prevalent in services with numerous instances, and there must be a reliable method to determine the dependencies for this service without relying on flow logs.\u003c/p\u003e\u003cp id=\"c413\"\u003eNetflix’s cloud gateway, \u003ca href=\"https://github.com/Netflix/zuul\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZuul\u003c/a\u003e, served this purpose perfectly due to its extensive footprint (handling all cloud ingress traffic), its large number of downstream dependencies, and our ability to derive its dependencies from its routing configurations as the source of truth for comparison with flow logs. We found no misattribution for flows through Zuul over a two-week window. This provided strong confidence that the new attribution method has eliminated misattribution. In the previous approach, approximately 40% of Zuul’s dependencies reported by the flow logs were misattributed.\u003c/p\u003e\u003ch2 id=\"57d4\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"bb9c\"\u003eWith misattribution solved, eBPF flow logs now deliver dependable, fleet-wide insights into Netflix’s service topology and network health. This advancement unlocks numerous exciting opportunities in areas such as service dependency auditing, security analysis, and incident triage, while helping Netflix engineers develop a better understanding of our ever-evolving distributed systems.\u003c/p\u003e\u003ch2 id=\"4224\"\u003eAcknowledgments\u003c/h2\u003e\u003cp id=\"28be\"\u003eWe would like to thank \u003ca href=\"https://www.linkedin.com/in/mdubcovsky/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMartin Dubcovsky\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/joannekoong/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJoanne Koong\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/troshko/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTaras Roshko\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/nabilschear/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNabil Schear\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/jacobmeyers35/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJacob Meyers\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/parshap/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eParsha Pourkhomami\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/hechaoli/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHechao Li\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/donavanfritz/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDonavan Fritz\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/rob-gulewich-0335b52/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRob Gulewich\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/amanda-li-410286166/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAmanda Li\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/jdsalem/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJohn Salem\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/haananth/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHariharan Ananthakrishnan\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/joshmachine/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKeerti Lakshminarayan\u003c/a\u003e, and other stunning colleagues for their feedback, inspiration, and contributions to the success of this effort.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2025-04-08T17:50:57.936Z",
  "modifiedTime": null
}
