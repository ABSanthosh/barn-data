{
  "id": "2430734d-bdb3-471d-af92-d85dfd9d3914",
  "title": "RSC for Astro Developers",
  "link": "https://overreacted.io/rsc-for-astro-developers/",
  "description": "Islands, but make it fractal.",
  "author": "",
  "published": "Tue, 06 May 2025 00:00:00 GMT",
  "source": "https://overreacted.io/rss.xml",
  "categories": null,
  "byline": "",
  "length": 11014,
  "excerpt": "Islands, but make it fractal.",
  "siteName": "",
  "favicon": "https://overreacted.io/icon.png?e0852c1e2c7f0e65",
  "text": "Okay, so in Astro you have two things: Astro Components: They have the .astro extension. They execute exclusively on the server or during the build. In other words, their code is never shipped to the client. So they can do things that client code cannot do—read from the filesystem, hit the internal services, even read from a database. But they can’t do interactive things aside from whatever exists natively in the HTML or your own \u003cscript\u003e. Astro Components can render either other Astro Components or Client Islands. Client Islands: Components written for React, Vue, and so on. This is your typical frontend stuff. That’s where it’s convenient to add the interactive bits. These Client Islands can then render other components for the same framework using that framework’s own mechanism. So, a React component can render another React component, as you would expect. But you can’t render an Astro Component from a Client Island. That wouldn’t make sense—by that point, Astro already ran. Here’s a PostPreview.astro Astro Component rendering a LikeButton Island: --- import { readFile } from 'fs/promises'; import { LikeButton } from './LikeButton'; const { slug } = Astro.props; const title = await readFile(`./posts/${slug}/title.txt`, 'utf8'); --- \u003carticle\u003e \u003ch1\u003e{title}\u003c/h1\u003e \u003cLikeButton client:load /\u003e \u003c/article\u003e import { useState } from 'react'; export function LikeButton() { const [liked, setLiked] = useState(false); return ( \u003cbutton onClick={() =\u003e setLiked(!liked)}\u003e {liked ? '❤️' : '🤍'} Like \u003c/button\u003e ); } Notice how Astro Components and Client Islands essentially live in two different “worlds”, and the data only ever flows down. Astro Components are where all the preprocessing happens; they “hand off” the interactive bits to the Client Islands. Now let’s look at React Server Components (RSC). In RSC, the same two things are called Server Components and Client Components. Here is how you’d write the above Astro Component as a React Server Component: import { readFile } from 'fs/promises'; import { LikeButton } from './LikeButton'; async function PostPreview({ slug }) { const title = await readFile(`./posts/${slug}/title.txt`, 'utf8'); return ( \u003carticle\u003e \u003ch1\u003e{title}\u003c/h1\u003e \u003cLikeButton /\u003e \u003c/article\u003e ); } 'use client'; import { useState } from 'react'; export function LikeButton() { const [liked, setLiked] = useState(false); return ( \u003cbutton onClick={() =\u003e setLiked(!liked)}\u003e {liked ? '❤️' : '🤍'} Like \u003c/button\u003e ); } The mental model behind these two are remarkably similar! If you know Astro, you already have 80% of the mental model for React Server Components. (Even if you think React Server Components are a terrible idea, Astro is worth learning.) Let’s note a few syntactic differences you might have noticed above: Unlike Astro Components, React Server Components are regular JavaScript functions. They are not “single-file”. The props are coming from the function argument rather than from Astro.props, and there is no separate “template”. In Astro, the separation between Astro Components and Client Islands is achieved by writing the former as .astro files. Once you import a Client Island, you’re not in an .astro file anymore and thus you’re “leaving” the Astro world. In RSC, the same purpose is achieved by the 'use client' directive. The 'use client' directive marks where the Server world “ends”—it is a door between the worlds. In Astro, there are directives like client:load that let you treat Islands either as static HTML or as hydratable on the client. React Server Components does not expose this distinction to the user code. From React’s perspective, if a component was written to be interactive, it would be a mistake to remove this interactivity. If a component truly does not require interactivity, just remove 'use client' from it, and then importing it from the Server world would already keep it Server-only. The last point is interesting. In Astro, the different syntax (.astro files vs Client Islands) creates a sharp and obvious visual distinction between the two worlds. The same component can’t act as both an Astro Component and a Client Island depending on the context—they’re two distinct things with distinct syntaxes. But in RSC, the “Astro” part is also “just React”. So if you have a component that doesn’t use any client-specific or server-specific features, it could play either role. Consider a \u003cMarkdown /\u003e component that does its own parsing. Since it doesn’t use any client features (no State) or any server features (no reading DB), it could be imported on either side. So if you import it from a Server world, it’ll act like an “Astro Component”, but if you import it from a Client world, it’ll act like a “Client Island”. This isn’t some new concept, it’s just how importing functions works! In RSC, stuff imported from the Server world will run in the Server world; stuff that’s imported from the Client world will run in the Client world; and stuff that’s not supported in either world (e.g. DB on the Client or useState on the Server) will cause a build error so you’ll be forced to “cut a door” with 'use client'. This is both a blessing and a curse. It is a curse because it makes learning to wield RSC rather unintuitive. You keep worrying about “which world you’re in”. It takes practice to embrace that it doesn’t matter because you can always reason locally. You can use server features like DB in files that need them, use client features like State in files that need them, and rely on build-time assertions causing errors if something is wrong. Then you look at the module stack trace and decide where to “cut a new door” for your “islands”. This is a curse, but it is also a blessing. By embracing React on both sides, the RSC model solves some Astro limitations that you might encounter along the way: Sometimes, you might write a bunch of Astro Components and later realize that you’re gonna need to move that UI into Client Islands (tweaking the syntax along the way) or even duplicate it because some dynamic UI also wants to drive them. With RSC, you can extract the shared parts and import them from both sides. It is less important to think through “this part will mostly be dynamic” or “this part will mostly be static” for every piece of UI because you can always add or remove 'use client' and/or move it up or down the import chain with little friction. You do decide where to “cut the door”, but there’s no “converting” back and forth. In Astro, you can nest Astro Components inside Client Islands, but if those include more Client Islands, they’ll still be seen as separate roots by your framework (e.g. React). This is why nesting interactive behavior doesn’t compose as naturally as in client apps, e.g. React or Vue context can’t be passed between Astro islands. In RSC, this is not a problem—the entire UI is a single React tree under the hood. You can have a Client context provider above some Server subtree, and then a bunch of Client components reading that context anywhere below. RSC is fractal islands. Astro Components can ultimately produce only HTML. This is why clicking links on an Astro site requires the browser to fully reload the page. If that seems like acceptable UX for your use case, that’s great! You can improve it with manual logic and with View Transitions but fundamentally, the page’s HTML does get replaced. If you want a SPA-like navigation that always keeps the state of the nav chrome, whether any React state or DOM state like inputs and scroll positions, then RSC can fill that gap. RSC uses a JSON-like format for React trees—which can be turned into HTML (for the first paint) but also gets refetched as JSON on navigations. In other words, RSC lets you think in an MPA mental model—but it feels like a SPA. This also means that unlike with Astro, the Server parts of RSC UI are refreshable in-place. If you do actually run a server (and not just running RSC during the build like I do for my blog), RSC lets you “refresh” the screen at any time to let the fresh server props flow into your already existing stateful client-side tree. For example, if some Astro Component needs to refresh in response to an interaction, you would have to choose between a full page refresh or moving logic to a Client Island. In RSC, you can just ask the fresh JSX from the server to get merged into the tree. In Astro, the fundamental output format is HTML. Since frontend frameworks don’t fundamentally operate the HTML itself (they operate a stateful DOM that can be initialized with HTML), Astro follows a “one-time handoff” model. This makes it arguably easier to learn but limits server features to what the “first render” (to HTML) needs and mostly leaves you on your own with the interactive bits. As you make more things interactive, you might feel yourself running into Astro model’s limitations, possibly choosing to move more logic to SPA-like but isolated Islands. In RSC, the fundamental output format is a React tree (which can be turned to HTML, but can also be (re)fetched as JSON). Since RSC uses React on both sides with no visual distinction between the two worlds, it is more challenging to learn to wield it. The upside is that once you get the hang of moving the boundaries, they become very fluid and solve the problem where you have to move code “into Astro” or “back into Islands” because something ended up more static or dynamic than expected. You also can retain the same “just map the data to UI” mental model whether the UI is read-only or needs to refetch in response to mutations. The Server parts grow deeper into the tree—interleaved with their Client parts. And because it’s React on both sides, all React features are integrated end-to-end: for example, a \u003cSuspense\u003e declarative loading state on the Client will “know” to wait for async data (from the Server), JS and CSS (as the Client loads them), fonts and images (with reasonable timeouts), and even trigger the View Transitions (see here). In React, every feature is designed so that the Server and Client pieces are arbitrarily nestable, composable, and refreshable in-place. It’s a single tree. The downside is that buying into RSC means buying into React. RSC is full-stack React. Finally, it is worth noting that Astro is a framework, but RSC itself is lower-level—think of it as a building block for a framework, or a standard that a framework can implement. The two officially supported implementations of RSC right now include Next.js App Router (a framework) and Parcel RSC (not a framework). Personally, I think that the developer experience with RSC is still somewhat raw, but I also think you might want to learn it anyway. It has some interesting ideas. Also, if you’ve never used Astro, give it a try! If RSC is giving you a hard time, Astro might offer a gentler onramp to the same ideas. And if you’ve only ever used client-side React, Astro might solve some problems you never realized you had.",
  "image": "https://overreacted.io/rsc-for-astro-developers/opengraph-image?5b0b970dfd19bb8c",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eOkay, so in \u003ca target=\"_blank\" href=\"https://docs.astro.build/en/getting-started/\"\u003eAstro\u003c/a\u003e you have two things:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" href=\"https://docs.astro.build/en/basics/astro-components/\"\u003eAstro Components:\u003c/a\u003e They have the \u003ccode\u003e.astro\u003c/code\u003e extension. They execute exclusively on the server or during the build. In other words, their code is never shipped to the client. So they can do things that client code cannot do—read from the filesystem, hit the internal services, even read from a database. But they can’t do interactive things aside from whatever exists natively in the HTML or your own \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e. Astro Components can render either other Astro Components or Client Islands.\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" href=\"https://docs.astro.build/en/concepts/islands/\"\u003eClient Islands:\u003c/a\u003e Components written for React, Vue, and so on. This is your typical frontend stuff. That’s where it’s convenient to add the interactive bits. These Client Islands can then render other components for the same framework using that framework’s own mechanism. So, a React component can render another React component, as you would expect. But you can’t render an Astro Component from a Client Island. That wouldn’t make sense—by that point, Astro already ran.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHere’s a \u003ccode\u003ePostPreview.astro\u003c/code\u003e Astro Component rendering a \u003ccode\u003eLikeButton\u003c/code\u003e Island:\u003c/p\u003e\n\u003cdiv\u003e\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"astro\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"astro\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e---\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e { readFile } \u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003efs/promises\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e { LikeButton } \u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e./LikeButton\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003econst { \u003c/span\u003e\u003cspan\u003eslug\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e Astro\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprops\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e await \u003c/span\u003e\u003cspan\u003ereadFile\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`./posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003eslug\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e/title.txt`\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003eutf8\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e---\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u0026lt;\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e{title}\u0026lt;/h1\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u0026lt;\u003c/span\u003e\u003cspan\u003eLikeButton\u003c/span\u003e\u003cspan\u003e client:load /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e\u0026lt;/\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e useState \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003ereact\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e LikeButton\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const [\u003c/span\u003e\u003cspan\u003eliked\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e setLiked\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e useState\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003ebutton\u003c/span\u003e\u003cspan\u003e onClick={() \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e setLiked\u003c/span\u003e\u003cspan\u003e(!\u003c/span\u003e\u003cspan\u003eliked\u003c/span\u003e\u003cspan\u003e)}\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      {\u003c/span\u003e\u003cspan\u003eliked \u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e❤️\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e :\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e🤍\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e Like\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003ebutton\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\u003c/div\u003e\n\u003cp\u003eNotice how Astro Components and Client Islands essentially live in two different “worlds”, and the data only ever flows down. Astro Components are where all the preprocessing happens; they “hand off” the interactive bits to the Client Islands.\u003c/p\u003e\n\u003cp\u003eNow let’s look at React Server Components (RSC).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIn RSC, the same two things are called \u003cem\u003eServer Components\u003c/em\u003e and \u003cem\u003eClient Components\u003c/em\u003e.\u003c/strong\u003e Here is how you’d write the above Astro Component as a React Server Component:\u003c/p\u003e\n\u003cdiv\u003e\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e readFile \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003efs/promises\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e LikeButton \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e./LikeButton\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e PostPreview\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ slug }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const \u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e await \u003c/span\u003e\u003cspan\u003ereadFile\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`./posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003eslug\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e/title.txt`\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003eutf8\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eLikeButton\u003c/span\u003e\u003cspan\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003euse client\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e useState \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003ereact\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e LikeButton\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const [\u003c/span\u003e\u003cspan\u003eliked\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e setLiked\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e useState\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003ebutton\u003c/span\u003e\u003cspan\u003e onClick={() \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e setLiked\u003c/span\u003e\u003cspan\u003e(!\u003c/span\u003e\u003cspan\u003eliked\u003c/span\u003e\u003cspan\u003e)}\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      {\u003c/span\u003e\u003cspan\u003eliked \u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e❤️\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e :\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e🤍\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e Like\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003ebutton\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\u003c/div\u003e\n\u003cp\u003eThe mental model behind these two are remarkably similar! If you know Astro, you already have 80% of the mental model for React Server Components. (Even if you think React Server Components are a terrible idea, Astro is worth learning.)\u003c/p\u003e\n\u003cp\u003eLet’s note a few syntactic differences you might have noticed above:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUnlike Astro Components, React Server Components are regular JavaScript functions. They are not “single-file”. The props are coming from the function argument rather than from \u003ccode\u003eAstro.props\u003c/code\u003e, and there is no separate “template”.\u003c/li\u003e\n\u003cli\u003eIn Astro, the separation between Astro Components and Client Islands is achieved by writing the former as \u003ccode\u003e.astro\u003c/code\u003e files. Once you import a Client Island, you’re not in an \u003ccode\u003e.astro\u003c/code\u003e file anymore and thus you’re “leaving” the Astro world. In RSC, the same purpose is achieved by the \u003ccode\u003e\u0026#39;use client\u0026#39;\u003c/code\u003e directive. The \u003ccode\u003e\u0026#39;use client\u0026#39;\u003c/code\u003e directive marks where the Server world “ends”—\u003ca href=\"https://overreacted.io/what-does-use-client-do/#two-worlds-two-doors\"\u003eit is a door between the worlds.\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eIn Astro, there are directives like \u003ccode\u003eclient:load\u003c/code\u003e that let you treat Islands either as static HTML or as hydratable on the client. React Server Components does not expose this distinction to the user code. From React’s perspective, if a component was written to be interactive, it would be a \u003cem\u003emistake\u003c/em\u003e to remove this interactivity. If a component truly does not \u003cem\u003erequire\u003c/em\u003e interactivity, just remove \u003ccode\u003e\u0026#39;use client\u0026#39;\u003c/code\u003e from it, and then importing it from the Server world would \u003cem\u003ealready\u003c/em\u003e keep it Server-only.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe last point is interesting. In Astro, the different syntax (\u003ccode\u003e.astro\u003c/code\u003e files vs Client Islands) creates a sharp and obvious visual distinction between the two worlds. The same component can’t act as both an Astro Component \u003cem\u003eand\u003c/em\u003e a Client Island depending on the context—they’re two distinct things with distinct syntaxes.\u003c/p\u003e\n\u003cp\u003eBut in RSC, the “Astro” part is also “just React”. So if you have a component that doesn’t use any client-specific \u003cem\u003eor\u003c/em\u003e server-specific features, it could play either role.\u003c/p\u003e\n\u003cp\u003eConsider a \u003ccode\u003e\u0026lt;Markdown /\u0026gt;\u003c/code\u003e component that does its own parsing. Since it doesn’t use any client features (no State) or any server features (no reading DB), it could be imported on either side. So if you import it from a Server world, it’ll act like an “Astro Component”, but if you import it from a Client world, it’ll act like a “Client Island”. This isn’t some new concept, it’s just how importing functions works!\u003c/p\u003e\n\u003cp\u003eIn RSC, stuff imported from the Server world will run in the Server world; stuff that’s imported from the Client world will run in the Client world; and stuff that’s not supported in either world (e.g. DB on the Client or \u003ccode\u003euseState\u003c/code\u003e on the Server) will cause a build error so you’ll be \u003cem\u003eforced\u003c/em\u003e to “cut a door” with \u003ccode\u003e\u0026#39;use client\u0026#39;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis is both a blessing and a curse.\u003c/p\u003e\n\u003cp\u003eIt is a curse because it makes learning to wield RSC rather unintuitive. You keep worrying about “which world you’re in”. It takes practice to embrace that it \u003cem\u003edoesn’t matter\u003c/em\u003e because you can always reason locally. You can use server features like DB in files that need them, use client features like State in files that need them, and rely on build-time assertions causing errors if something is wrong. Then you look at the module stack trace and decide where to “cut a new door” for your “islands”.\u003c/p\u003e\n\u003cp\u003eThis \u003cem\u003eis\u003c/em\u003e a curse, but it is also a blessing. By embracing React on both sides, the RSC model solves some Astro limitations that you might encounter along the way:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSometimes, you might write a bunch of Astro Components and later realize that you’re gonna need to move that UI into Client Islands (tweaking the syntax along the way) or even duplicate it because some dynamic UI \u003cem\u003ealso\u003c/em\u003e wants to drive them. With RSC, you can extract the shared parts and import them from both sides. It is less important to think through “this part will mostly be dynamic” or “this part will mostly be static” for every piece of UI because you can always add or remove \u003ccode\u003e\u0026#39;use client\u0026#39;\u003c/code\u003e and/or move it up or down the import chain with little friction. You do decide where to “cut the door”, but there’s no “converting” back and forth.\u003c/li\u003e\n\u003cli\u003eIn Astro, you \u003cem\u003ecan\u003c/em\u003e nest Astro Components inside Client Islands, but if those include \u003cem\u003emore\u003c/em\u003e Client Islands, they’ll still be seen as separate roots by your framework (e.g. React). This is why \u003cem\u003enesting interactive behavior\u003c/em\u003e doesn’t compose as naturally as in client apps, e.g. \u003ca target=\"_blank\" href=\"https://docs.astro.build/en/recipes/sharing-state-islands/\"\u003eReact or Vue context can’t be passed between Astro islands.\u003c/a\u003e In RSC, this is not a problem—the entire UI is a single React tree under the hood. You can have a Client context provider above some Server subtree, and then a bunch of Client components reading that context anywhere below. RSC is \u003cem\u003efractal\u003c/em\u003e islands.\u003c/li\u003e\n\u003cli\u003eAstro Components can ultimately produce only HTML. This is why clicking links on an Astro site requires the browser to fully reload the page. If that seems like acceptable UX for your use case, that’s great! You can \u003ca target=\"_blank\" href=\"https://docs.astro.build/en/guides/view-transitions/\"\u003eimprove it with manual logic and with View Transitions\u003c/a\u003e but fundamentally, the page’s HTML \u003cem\u003edoes\u003c/em\u003e get replaced. If you want a SPA-like navigation that always keeps the state of the nav chrome, whether any React state or DOM state like inputs and scroll positions, then RSC can fill that gap. RSC \u003ca href=\"https://overreacted.io/functional-html/#objects\"\u003euses a JSON-like\u003c/a\u003e format for React trees—which can be \u003cem\u003eturned into\u003c/em\u003e HTML (for the first paint) but also gets refetched as JSON on navigations. In other words, RSC lets you \u003cem\u003ethink\u003c/em\u003e in an \u003ca target=\"_blank\" href=\"https://docs.astro.build/en/concepts/why-astro/#server-first\"\u003eMPA\u003c/a\u003e mental model—but it \u003cem\u003efeels\u003c/em\u003e like a SPA.\u003c/li\u003e\n\u003cli\u003eThis also means that unlike with Astro, the Server parts of RSC UI are \u003cem\u003erefreshable in-place\u003c/em\u003e. If you do actually run a server (and not just running RSC during the build like I do for my blog), RSC lets you “refresh” the screen at any time to let the \u003cem\u003efresh server props flow into your already existing stateful client-side tree\u003c/em\u003e. For example, if some Astro Component needs to refresh in response to an interaction, you would have to choose between a full page refresh or moving logic to a Client Island. In RSC, you can just ask the fresh JSX from the server to get merged into the tree.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn Astro, the fundamental output format is HTML. Since frontend frameworks don’t fundamentally operate the HTML itself (they operate a stateful DOM that can be \u003cem\u003einitialized\u003c/em\u003e with HTML), Astro follows a “one-time handoff” model. This makes it arguably easier to learn but limits server features to what the “first render” (to HTML) needs and mostly leaves you on your own with the interactive bits. As you make more things interactive, you might feel yourself running into Astro model’s limitations, possibly choosing to move more logic to SPA-like but isolated Islands.\u003c/p\u003e\n\u003cp\u003eIn RSC, the fundamental output format is a React tree (which can be turned to HTML, but can also be (re)fetched as JSON). Since RSC uses React on both sides with no visual distinction between the two worlds, it is more challenging to learn to wield it. The upside is that once you get the hang of moving the boundaries, they become very fluid and solve the problem where you have to move code “into Astro” or “back into Islands” because something ended up more static or dynamic than expected. You also can retain the same “just map the data to UI” mental model whether the UI is read-only or needs to refetch in response to mutations. The Server parts grow deeper into the tree—\u003ca href=\"https://overreacted.io/impossible-components/#a-sortable-list-of-previews\"\u003einterleaved\u003c/a\u003e with \u003cem\u003etheir\u003c/em\u003e Client parts.\u003c/p\u003e\n\u003cp\u003eAnd because it’s React on both sides, all React features are integrated end-to-end: for example, a \u003ca target=\"_blank\" href=\"https://react.dev/reference/react/Suspense\"\u003e\u003ccode\u003e\u0026lt;Suspense\u0026gt;\u003c/code\u003e\u003c/a\u003e declarative loading state on the Client will “know” to wait for async data (from the Server), JS and CSS (as the Client loads them), fonts and images (with reasonable timeouts), and even trigger the View Transitions (see \u003ca target=\"_blank\" href=\"https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more#animating-suspense-boundaries\"\u003ehere\u003c/a\u003e). In React, every feature is designed so that the Server and Client pieces are arbitrarily nestable, composable, and refreshable in-place. It’s a single tree. The downside is that buying into RSC means buying into React. RSC \u003cem\u003eis\u003c/em\u003e full-stack React.\u003c/p\u003e\n\u003cp\u003eFinally, it is worth noting that Astro is a framework, but RSC itself is lower-level—think of it as a building block for a framework, or a standard that a framework can implement. The two officially supported implementations of RSC right now include \u003ca target=\"_blank\" href=\"https://nextjs.org/\"\u003eNext.js App Router\u003c/a\u003e (a framework) and \u003ca target=\"_blank\" href=\"https://parceljs.org/recipes/rsc/\"\u003eParcel RSC\u003c/a\u003e (not a framework).\u003c/p\u003e\n\u003cp\u003ePersonally, I think that the developer experience with RSC is still somewhat raw, but I also think you might want to learn it anyway. It has some interesting ideas.\u003c/p\u003e\n\u003cp\u003eAlso, if you’ve never used Astro, give it a try! If RSC is giving you a hard time, Astro might offer a gentler onramp to the same ideas. And if you’ve only ever used client-side React, Astro might solve some problems you never realized you had.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": null,
  "modifiedTime": null
}
