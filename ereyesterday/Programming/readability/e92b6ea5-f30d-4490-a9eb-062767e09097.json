{
  "id": "e92b6ea5-f30d-4490-a9eb-062767e09097",
  "title": "First Steps in Game Development With Rust and Bevy",
  "link": "https://blog.jetbrains.com/rust/2025/02/04/first-steps-in-game-development-with-rust-and-bevy/",
  "description": "Some of us might remember this 15-year-old Abstruse Goose comic about our choices in life. Learning the theory of computations might not be the most direct path to video game development. However, you still need to learn programming, some math (at least geometry), and mechanics – or as it’s often somewhat erroneously labeled – physics. […]",
  "author": "Vitaly Bragilevsky",
  "published": "Tue, 04 Feb 2025 13:44:27 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": null,
  "byline": "Vitaly Bragilevsky",
  "length": 32468,
  "excerpt": "Some of us might remember this 15-year-old Abstruse Goose comic about our choices in life. Learning the theory of computations might not be the most direct path to video game development. However, you",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "Focus on what matters First Steps in Game Development With Rust and Bevy Some of us might remember this 15-year-old Abstruse Goose comic about our choices in life. Learning the theory of computations might not be the most direct path to video game development. However, you still need to learn programming, some math (at least geometry), and mechanics – or as it’s often somewhat erroneously labeled – physics. Many years ago, I did a course on rigid body dynamics that was definitely a part of the theoretical mechanics curriculum, not physics! Then, you’ll probably also need a bit of materials science, optics, and a smattering of other subjects. The good news is you’ll have loads of fun along the way. And while you’re still learning, game development engines and libraries can help you keep on top of some of the accidental complexity and give you enough functionality to implement the things you want, albeit at a fairly basic level. In this blog post, I’ll try to give you enough knowledge to kick off your journey in game development with the Rust programming language, the Bevy game engine, and RustRover, a dedicated JetBrains IDE for Rust developers. We’ll start with a tiny example and develop it a bit further, discussing the most important concepts and ideas along the way. You’ll also find some tips on where to find additional resources to help you continue on your learning journey. Why use an engine? Why choose Bevy? Let’s start with the first question: Why do we need an engine at all? Well, creating even the smallest and simplest game imaginable requires implementing many things. You need a game loop, some game data, and a place to store everything. Some sort of UI, whether textual or graphical, will also be required so that we can render our game data. The game state will also need to change in reaction to human player inputs. At some point, you’ll need to render a 3D object, and this will force you to consider light, shadows, and reflection. It’s even possible that two geometrically complex bodies will collide, an action that will then need to be detected and processed. All these tasks are important game components, and some sort of system should be in place to make sure they’re available. Implementing a full-fledged game engine or certain parts thereof from scratch is an extremely popular use case. While this is an interesting topic in its own right, this blog post will focus on Bevy, the most popular Rust game development engine. Bevy is full-featured, so we can do a lot of different things. It’s flexible, so we can do whatever we want without constraint. It’s also extendable, so we can add external plugins to get new functionality. Bevy is a project under active development, so we should expect many changes to come with every release. Still, it’s crucial to have a basic grasp of its core concepts and features if we want to be able to follow its future progress. Your first Bevy application Let’s look at our first Bevy application: use bevy::prelude::*; fn main() { App::new() .add_plugins(DefaultPlugins) .run(); } Even in this tiny example, we create an application, add some default plugins, and then run it. The App::run method runs the main game loop, even though we haven’t asked it to do anything yet. Nonetheless, some of the plugins will run their own internal processes. If you create an empty project in RustRover and paste this code into main.rs, you’ll immediately see a suggestion to add a dependency for the bevy crate to your Cargo.toml file: [package] name = \"bevy-first-steps\" version = \"0.1.0\" edition = \"2021\" [dependencies] bevy = \"0.15\" You can also get a sneak peek of what is included in the set of default plugins: For example, there’s WindowPlugin, which creates an empty application window: With TimePlugin, we get time-measuring functionality, and LogPlugin adds the ability to write logs. The documentation popup also mentions the bevy crate features. Plugins and features allow Bevy to be flexible: We can easily switch features on and off and add or remove plugins to get the desired set of functionality. You can read more about the default set of features in the documentation: If you want to customize a set of enabled features, just start typing in the Cargo.toml file, where you’ll get full editing and completion support from RustRover: Bevy has excellent documentation, and the sections you might need are easily accessible from RustRover. You can read sections in popups, follow links, or even open the dedicated Documentation tool window: Now that we know how to get help in case of emergency, we’re ready to implement our first game element. So without further ado, let’s create our first object in the game world and make it jump! Time to jump Before we get to the technical part, we’ll begin by considering what it actually means for a game object to jump. There are several key points that we need to keep in mind: We need an object with geometrical parameters (width, height, and initial position within the graphical window). Jumping means changing an object’s position in time, but not its size in our case (in contrast to a jumping ball, for example, which does change its size when it meets the ground – it’s not a rigid body!). Just like in real life, an initial force should be applied to an object to change its velocity and, consequently, its position.  In games, it’s usually up to a player to decide when to apply that force. Hence, we need to wait for and process user input (for example, when a user presses the space button). Right after an object gets its initial velocity, gravity influences it and works to return it to the ground. For smooth visualization, we must ensure that our jumping object is rendered in various positions above the ground.  So, as it turns out, jumping is not that easy after all! And we haven’t even started to implement all these things in Bevy. Now, let’s talk about the concepts and actions from the list above in the direct context of Bevy: A game object is an entity, but it’s not the only entity we need in this program. For example, we need an entity for a camera to see something rendered in the graphical window. The ground can be represented with an entity as well. At least, we’ll need to render it. An entity is just an ID of an object (our jumping object or something coming from the engine), not an object itself. We need IDs to refer to and manipulate objects. To use the language of Bevy, we spawn entities. To specify an object’s parameters, we use components and bundles of components. For example, an object’s velocity is a component (a 3D vector, as we’ll see soon). The marker structure we’ll use to associate a spawned entity with a jumping object is also a component. An object’s position is a component. This component is used for rendering an object. Bevy’s camera is a complex bundle of components (fortunately, we don’t have to analyze them in detail).  When we spawn entities, we also associate them with their related components. Later, we’ll be able to query the actual values of components (for example, to change them or to render the corresponding game objects). User input is represented in Bevy as a stream of events. We need to read those events and act accordingly. All changes and visualizations in the game world are represented by systems, Rust functions that spawn entities, query the values of components, mutate them, read event streams, delete entities, and much more. In Bevy, systems are responsible for doing virtually everything. Bevy’s core functionality and anything provided by a plugin also take the form of systems. In this tutorial, you’ll see how we can implement our own systems. Bevy doesn’t run systems chaotically. Instead, it uses schedules to decide what to run and when. Some systems need to be run only once at launch, while others run repeatedly on every frame. The game is structured around frames: Any game is a sequence of frames that follow one another. The App::run method we saw in our first code sample generates frames by calling a variety of our own systems and other internal ones on every frame.  Now, we are ready to create the following mental model of any Bevy application: We first set up entities with components and then change them into systems run by Bevy that are then rendered frame after frame. Bevy is an ECS (entity, component, system) framework, and everything we do with Bevy follows this pattern. I know you’re waiting for the code, so let’s go right ahead and spawn our first entities for the example of a jumping object: const GROUND_LEVEL: f32 = -100.0; const PLAYER_X: f32 = -300.0; #[derive(Component)] struct Player; #[derive(Component)] struct Velocity(Vec3); fn setup(mut commands: Commands) { commands.spawn(Camera2d::default()); // Player commands .spawn(( Player, Sprite { color: Color::srgb(0.5, 1.0, 0.5), custom_size: Some(Vec2::new(30.0, 50.0)), anchor: Anchor::BottomCenter, ..default() }, Transform::from_xyz(PLAYER_X, GROUND_LEVEL, 0.0), Velocity(Vec3::ZERO) )); // Ground commands.spawn(( Sprite { color: Color::srgb(0.5, 0.5, 0.5), custom_size: Some(Vec2::new(800.0, 10.0)), anchor: Anchor::TopLeft, ..default() }, Transform::from_xyz(-400.0, GROUND_LEVEL, 0.0) )); } The setup function is a system. In this system, we are spawning three entities: One entity for Bevy’s camera. Another entity for a jumping object (a player). Note that we represent a player with a bundle of components: A marker struct Player. A sprite – Bevy’s concept that allows us to specify the visual identity of an object including color, size, and potentially many other parameters – even your own graphics. A transform – Bevy’s concept for an object’s position, used by Bevy to render our object in a correct place in the graphical window. A velocity. The third entity represents the ground – we need it to see when jumping starts. The setup system takes Commands as an argument. Commands are used to change the structure of the game world, such as by spawning or deleting entities. As we’ll see later, we don’t need them to read or change the values of components. We’ll use queries for that.  Look at the anchor and transform components associated with the last two entities. We want the object (a rectangle) to stand on the ground. These two objects share the same y-coordinate in their initial positions but use different anchors. As a result, the player’s bottom side is the same as the ground’s top side. Nothing will be rendered even if you copy this code to the example. Why? Because we need to run this system as part of our game loop. To do that, we register it within the application: fn main() { App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .run(); } Note the Startup schedule. Our entities only need to be set up once during startup. Once this is done, we can see our amazing game object standing on the ground! Hey, but that’s not jumping, right? Right, just bear with me. We’re almost there. We simply need to process user input and change the player’s velocity and position by applying the jumping force and gravity. As opposed to just being launched at startup, this behavior needs to be applied to every frame. To implement it, we’ll need to write three systems: The jump system, which applies a jump force to the game object and sets the player’s velocity to a positive value when requested by a user. The apply_gravity system, which slows the object down by decreasing its velocity. This requires checking the time that passes between consecutive frames. In Bevy terms, time is a resource, a global value that exists independently of entities and any components associated with them. Remember the TimePlugin that was added along with the other default plugins? This is the plugin that provides us with access to this resource.  The player_movement system, which is responsible for recalculating the player’s position. This system also needs to know the actual time because the more time that has passed, the further the player has been moved. These systems run between frame updates, hence the Update schedule that we use to register them within the application: fn main() { App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .add_systems(Update, (jump, apply_gravity, player_movement)) .run(); } These three systems don’t manipulate entities. Instead, they read events (user input), query and mutate the components, and consult the time. In Bevy, we give them access to all this information by specifying system parameters: EventReader, Query, or Res for resources.  Let’s look at the jump system first. We start by checking the event stream, and if we see a user pressing the space key, we apply a jump force: const JUMP_FORCE: f32 = 600.0; fn jump( mut events: EventReader\u003cKeyboardInput\u003e, mut query: Query\u003c(\u0026mut Velocity, \u0026Transform), With\u003cPlayer\u003e\u003e ) { for e in events.read() { if let Ok((mut velocity, transform)) = query.get_single_mut() { if e.state.is_pressed() \u0026\u0026 e.key_code == KeyCode::Space \u0026\u0026 transform.translation.y \u003c= GROUND_LEVEL { velocity.0.y = JUMP_FORCE; } } } } Sometimes it can be helpful to read the list of parameters out loud: We’re getting an event reader with keyboard input. We’re querying velocity and transform (position) for entities marked as Player. The velocity is expected to be a mutable reference because we’re going to change it. With Bevy, it doesn’t take long to start parsing complex query types. Query types specify what we are looking for in the entities and associated components. Bevy will then call these functions and supply them with the requested parameters. In the system’s code, we check for all the unprocessed events that are available when Bevy runs this system. We get the queried components for every event, ensure the space key has been pressed, check that the player is on the ground (it’s a bit difficult to jump in the middle of another jump!), and finally make the jump happen by setting the velocity’s y-coordinate to some positive value. And we’re off! Here’s an essential consideration: With Bevy, we never attempt to do many things at once in a single system. It’s much easier to reason about game logic when we have multiple systems, each responsible for its own thing. Jumping is not about changing positions, it’s about applying the initial force. We’ll deal with changing positions in a system responsible specifically for that, namely player_movement:  fn player_movement( time: Res\u003cTime\u003e, mut query: Query\u003c(\u0026mut Transform, \u0026mut Velocity), With\u003cPlayer\u003e\u003e ) { for (mut transform, mut velocity) in query.iter_mut() { transform.translation.y += velocity.0.y * time.delta_secs(); if transform.translation.y \u003c= GROUND_LEVEL { transform.translation.y = GROUND_LEVEL; velocity.0.y = 0.0; } } } In this system, we request access to time, player position, and velocity. In the code snippet, we simply iterate through all of the query results to find the one we need, even though we know there’s only one player. But imagine having many players. We need to be prepared! We update the player’s y-coordinate for every transform and velocity according to the time that has passed between frame updates. We also ensure that our player never gets below the ground level by ensuring velocity is zeroed when ground level is reached. While it would be nice to be able to fly like a bird, in our game world, we need gravity. const GRAVITY: f32 = -800.0; fn apply_gravity( time: Res\u003cTime\u003e, mut query: Query\u003c\u0026mut Velocity, With\u003cPlayer\u003e\u003e ) { for mut velocity in query.iter_mut() { velocity.0.y += GRAVITY * time.delta_secs(); } } Gravity is a force that decreases the player’s velocity when jumping. Note that, once again, there is no need to recalculate position here. We need to apply gravity, so we apply gravity and nothing more. I recommend exploring this example’s code in RustRover. Play with the declared constants and initial values of components, run the application many times, explore Bevy’s types and methods, and check their signatures and documentation. There’s a whole world of stuff happening behind the scenes.   When you’re ready, we’ll turn this game into an endless runner: Our player will jump over randomly emerging obstacles, crash into them, lose health points, and eventually die, effectively putting an end to our game. For an endless run! Here’s our plan for this section: Spawn and despawn entities, and move them to mimic horizontal movement. Implement a simplified collision detection system. Organize a method to count health points and end the game when all the health points have been lost due to collisions. In RustRover, we can use either the Structure tool window or the Collapse All action (Folding | Collapse All in the popup menu) to get a quick view of the final result: I realize the gameplay is far from rivetting, but hopefully you can enjoy playing it for a few seconds at least! From here on out, we’ll show more code examples and provide fewer explanations. The goal is to focus on introducing new Bevy parts without carefully analyzing what’s happening. Don’t forget to consult the documentation! Dealing with obstacles: more timers and random numbers The idea is to spawn a new obstacle every second. We already know how to consider times between frame updates with Res\u003cTime\u003e. Those times are smaller than a second, so we need another way to work with this specific time interval. Let’s create another resource for measuring one-second intervals. This requires a couple of changes. First, we need to define a constant and a structure with a timer: const SPAWN_INTERVAL: f32 = 1.0; #[derive(Resource)] struct ObstacleSpawningTimer(Timer); Second, we initialize the timer and register it within the application: App::new() .add_plugins(DefaultPlugins) .add_systems(Startup, setup) .insert_resource(ObstacleSpawningTimer( Timer::from_seconds(SPAWN_INTERVAL, TimerMode::Repeating))) Now we can advance this timer with every frame update and spawn a new obstacle once the timer has counted down to zero: fn spawn_obstacles( mut commands: Commands, time: Res\u003cTime\u003e, mut spawn_timer: ResMut\u003cObstacleSpawningTimer\u003e, ) { spawn_timer.0.tick(time.delta()); // Advancing if spawn_timer.0.finished() { // Spawn the obstacle // ... } } Thanks to TimerMode::Repeating, our timer repeats after finishing, so we get an infinite sequence of obstacles. There’s one issue, though. We want obstacles to have random positions. So, how do we get random numbers? One common solution would be to use the well-known rand crate, but the problem here is that we’re not in complete control of our application: Bevy is. What we need is a random number generator. But how do we make one available in our systems? When working with Bevy, it’s best to look for crates that implement the required functionality but are also integrated with Bevy and its ECS framework. Fortunately, we have the bevy_rand crate that provides everything we need. I recommend reading the tutorial, as quite a few things should be considered when working with randomization in Bevy. To introduce random numbers to our project, we add the following dependencies to our Cargo.toml file: rand_core = \"0.6.4\" bevy_rand = \"0.9\" bevy_prng = { version = \"0.9.0\", features = [\"wyrand\"] } Then, we add a plugin to the application: App::new() .add_plugins(DefaultPlugins) .add_plugins(EntropyPlugin::\u003cWyRand\u003e::default()) // ... Finally, we’ll add a random number generator to the required system using the usual Bevy approach as follows: fn spawn_obstacles( mut commands: Commands, time: Res\u003cTime\u003e, mut spawn_timer: ResMut\u003cObstacleSpawningTimer\u003e, mut rng: GlobalEntropy\u003cWyRand\u003e, ) { spawn_timer.0.tick(time.delta()); if spawn_timer.0.finished() { let obstacle_x = GROUND_EDGE; let obstacle_y = GROUND_LEVEL + (rng.next_u32() % 50) as f32; commands.spawn(( Obstacle, Sprite { color: OBSTACLE_COLOR, custom_size: Some(OBSTACLE_SIZE), anchor: Anchor::BottomCenter, ..default() }, Transform::from_xyz(obstacle_x, obstacle_y, 0.0), )); } } The movement of obstacles is implemented by decreasing their x-coordinates. Thus, users feel like the player is moving forward (from left to right): fn move_obstacles( time: Res\u003cTime\u003e, mut commands: Commands, mut query: Query\u003c(Entity, \u0026mut Transform), With\u003cObstacle\u003e\u003e, ) { for (entity, mut transform) in query.iter_mut() { transform.translation.x -= GAME_SPEED * time.delta_secs(); // Remove obstacles once they're off-screen if transform.translation.x \u003c -GROUND_EDGE { commands.entity(entity).despawn(); } } } One interesting thing about the system above is that we can easily despawn entities once they are off the screen. We use Commands and the entity method to access the entity we’re interested in. We use the time between frame updates to recalculate current positions, just as before. By playing with the GAME_SPEED value, we can make the game slower or faster, for example, to increase or decrease the difficulty level. To do that at run time, we must make this constant a resource and access its value as needed. Health points, collision detection, and text rendering Now we want to implement health points, set them to some initial value at the beginning of the game, and then decrease them with every collision. In other approaches, we need to add a heath field to some structure containing other information about the player. But that’s not the approach we use in Bevy. Instead, we define a new component: #[derive(Component)] struct Health(usize); Then we associate it with the player’s entity at spawning: // Player commands .spawn(( Player, Sprite { ... }, Transform::from_xyz(PLAYER_X, GROUND_LEVEL, 0.0), Velocity(Vec3::ZERO), Health(initial_health) )); Now we can access the health value in order to read or mutate it depending on our use case. When we detect a collision, we decrease it. To render health information on the screen, we only require read access to the data. Let’s look at this simplistic implementation of collision detection: fn detect_collision( mut commands: Commands, mut player_query: Query\u003c(\u0026Transform, \u0026mut Health), With\u003cPlayer\u003e\u003e, obstacle_query: Query\u003c(Entity, \u0026Transform), With\u003cObstacle\u003e\u003e, ) { if let Ok((player_transform, mut health)) = player_query.get_single_mut() { for (entity, obstacle_transform) in obstacle_query.iter() { let collision = player_transform.translation.distance( obstacle_transform.translation) \u003c 50.0; if collision { health.0 -= 1; commands.entity(entity).despawn(); // Remove obstacle } } } } We just compare the player’s position with that of obstacles, and if the player is close enough, then we count the situation as a collision and decrease the health points accordingly. The obstacle entity is despawned immediately. We also need to render health information on the screen. To use the language of Bevy, we need to define a component, and then spawn and render a corresponding entity: #[derive(Component)] struct HealthInfo; fn setup(mut commands: Commands) { // ... commands.spawn(( HealthInfo, Text::new(format!(\"Health: {}\", initial_health)) ) ); // ... } fn render_health_info( player_query: Query\u003c\u0026mut Health, With\u003cPlayer\u003e\u003e, mut health_info_query: Query\u003c\u0026mut Text, With\u003cHealthInfo\u003e\u003e, ) { if let Ok(mut health_info) = health_info_query.get_single_mut() { if let Ok(health) = player_query.get_single() { health_info.0 = format!(\"Health: {}\", health.0); } } } In the render_health_info system, we access the player’s health and info components and then update the text node with the actual data. Follow the documentation on the Text component to learn how to position the corresponding UI node and change its properties, such as font, size, color, etc.  Game states and advanced system scheduling What should we do when a player loses all their health points? In other words, how should we implement the game over situation? The problem is that some systems need to stop being executed while others should start executing right when we reach this state. For example, we must prevent obstacles from moving and the player from jumping, while also displaying the “Game Over” text on the screen. To implement the desired behavior, we’ll apply Bevy’s states and use its additional scheduling features. We need to introduce two states into our gameplay: InGame, which corresponds to the time we are playing. GameOver, which means that the game is over. We might have more states in more advanced games, for example, for pausing the game or navigating a menu. In Bevy, we define the following structure with states and derive the required definitions: #[derive(States, Debug, Clone, PartialEq, Eq, Hash)] enum GameState { InGame, GameOver, } Then we register our initial state within the application: App::new() // ... .insert_state(InGame) // ... While in the game, we should consult the player’s health and then switch to GameOver if there are no health points left: fn check_health( player_query: Query\u003c\u0026Health, With\u003cPlayer\u003e\u003e, mut game_state: ResMut\u003cNextState\u003cGameState\u003e\u003e ) { if let Ok(Health(health)) = player_query.get_single() { if *health == 0 { game_state.set(GameOver); } } } When the game is over, we display a huge banner in the center of the window: fn game_over(mut commands: Commands) { commands.spawn((Node { position_type: PositionType::Absolute, left: Val::Percent(10.), right: Val::Percent(10.), top: Val::Percent(15.), bottom: Val::Percent(15.), justify_content: JustifyContent::Center, ..default() },)) .with_children(|builder| { builder.spawn(( Text(\"GAME OVER\".to_string()), TextFont::from_font_size(160.0), TextLayout::new_with_justify(JustifyText::Center) .with_no_wrap(), TextColor(Color::srgb(1.0, 0.0, 0.0)), )); }); } Of course, we also need to specify when any given system should and should not be executed. We do that using the run_if schedule modifier and the OnEnter(GameOver) schedule as follows: App::new() // ... .add_systems(Update, (jump, apply_gravity, player_movement) .run_if(in_state(InGame))) .add_systems(Update, (spawn_obstacles, move_obstacles, detect_collision, render_health_info, check_health) .run_if(in_state(InGame))) .add_systems(OnEnter(GameOver), game_over) .run(); So, if the current state is InGame, we have eight systems to execute within the Update schedule (meaning on every frame update) and a single game_over system when we enter the GameOver state (meaning it is executed only once).  I encourage you to play with the final implementation and try implementing many more features, for example: Spawning stars. Giving rewards for collecting stars. Using more advanced graphics for game objects instead of boring rectangles. Implementing game levels. And beyond It takes a lot of time to master game development and Bevy, which means it’s crucial to start applying your knowledge as early as possible. Make your own game right now! To help flatten the learning curve, I’ve composed the following list of helpful resources: Bevy’s website is a great resource: You can find links to the documentation, community links, and official examples (make sure you check them out!), as well as a collection of third-party assets, learning resources, crates, and apps. Bevy GameDev Meetups host a wide selection of general talks about Bevy as well as numerous deep-dives into specific features. The Bevy Cheat Book can prove very helpful when you need to implement some highly specific functionalities. Migration guides like this one are also must-reads. Things in Bevy change frequently, so be prepared. It’s also highly advisable that you learn about at least one physics engine for Bevy (e.g. avian), and I would recommend following Chris Biscardi and his This Week in Bevy project for valuable insights. The fast pace of Bevy development creates many issues for both content creators and AI assistants. Materials on the internet and any AI-generated suggestions can easily be outdated. You should always keep in mind the Bevy version you are targeting and check the migration guides if you encounter any issues. Conclusion Game development with Rust and Bevy is an exciting journey that requires a combination of creativity, problem-solving, and technical skills. From setting up your first Bevy project to implementing core game mechanics, every step reveals the power and flexibility of this ecosystem. Bevy’s entity-component-system (ECS) architecture might initially seem challenging, but its logic and elegance become increasingly apparent as you practice, enabling you to create scalable and maintainable games. While this blog post provides a solid foundation, learning begins when you start experimenting. Don’t hesitate to dive deeper into advanced topics like collision detection, procedural generation, or physics integration. Bevy’s vibrant community and extensive resources, including documentation, meetups, and third-party assets, will prove invaluable as you continue your educational journey. Remember, game development isn’t just about writing code but crafting experiences. Challenge yourself to create something unique, whether it’s a simple platformer or a complex simulation. Each project will teach you new concepts, spark new ideas, and bring you closer to mastering this craft. Bevy’s rapid development pace is both an opportunity and a challenge. Stay informed about new updates, consult migration guides, and engage with the community to keep your skills sharp and your projects up to date. Whether exploring game design for fun or building a career in the industry, the combination of Rust, Bevy, and your creativity is a recipe for success.Now it’s time to roll up your sleeves, launch RustRover, start coding, and bring your game ideas to life. Good luck, and happy coding! Subscribe to Rust Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/02/rr-social_share_blog_1280x720_en-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/rust/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2020/07/RustRover.svg\" alt=\"Rust logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eFocus on what matters\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                                        \u003ch2 id=\"major-updates\"\u003eFirst Steps in Game Development With Rust and Bevy\u003c/h2\u003e                    \n                    \n\u003cp\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"561\" height=\"595\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/unnamed.png\" alt=\"Game Development vs Computer Science\"/\u003eSome of us might remember this \u003ca href=\"https://web.archive.org/web/20091108094709/http://www.abstrusegoose.com/206\" target=\"_blank\" rel=\"noopener\"\u003e15-year-old \u003cem\u003eAbstruse Goose\u003c/em\u003e comic\u003c/a\u003e about our choices in life. Learning the theory of computations might not be the most direct path to video game development. However, you still need to learn programming, some math (at least geometry), and mechanics – or as it’s often somewhat erroneously labeled – physics. Many years ago, I did a course on rigid body dynamics that was definitely a part of the theoretical mechanics curriculum, not physics! Then, you’ll probably also need a bit of materials science, optics, and a smattering of other subjects. The good news is you’ll have loads of fun along the way. And while you’re still learning, game development engines and libraries can help you keep on top of some of the accidental complexity and give you enough functionality to implement the things you want, albeit at a fairly basic level.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this blog post, I’ll try to give you enough knowledge to kick off your journey in game development with the Rust programming language, the Bevy game engine, and \u003ca href=\"https://www.jetbrains.com/rust\" target=\"_blank\" rel=\"noopener\"\u003eRustRover\u003c/a\u003e, a dedicated JetBrains IDE for Rust developers. We’ll start with a tiny example and develop it a bit further, discussing the most important concepts and ideas along the way. You’ll also find some tips on where to find additional resources to help you continue on your learning journey.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhy use an engine? Why choose Bevy?\u003c/h2\u003e\n\n\n\n\u003cp\u003eLet’s start with the first question: Why do we need an engine at all? Well, creating even the smallest and simplest game imaginable requires implementing many things. You need a game loop, some game data, and a place to store everything. Some sort of UI, whether textual or graphical, will also be required so that we can render our game data. The game state will also need to change in reaction to human player inputs. At some point, you’ll need to render a 3D object, and this will force you to consider light, shadows, and reflection. It’s even possible that two geometrically complex bodies will collide, an action that will then need to be detected and processed. All these tasks are important game components, and some sort of system should be in place to make sure they’re available.\u003c/p\u003e\n\n\n\n\u003cp\u003eImplementing a full-fledged game engine or certain parts thereof from scratch is an extremely popular use case. While this is an interesting topic in its own right, this blog post will focus on Bevy, the most popular Rust game development engine. Bevy is full-featured, so we can do a lot of different things. It’s flexible, so we can do whatever we want without constraint. It’s also extendable, so we can add external plugins to get new functionality. Bevy is a project under active development, so we should expect many changes to come with every release. Still, it’s crucial to have a basic grasp of its core concepts and features if we want to be able to follow its future progress.\u003c/p\u003e\n\n\n\n\u003ch2\u003eYour first Bevy application\u003c/h2\u003e\n\n\n\n\u003cp\u003eLet’s look at our first Bevy application:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003euse bevy::prelude::*;\n\nfn main() {\n   App::new()\n       .add_plugins(DefaultPlugins)\n       .run();\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eEven in this tiny example, we create an application, add some default plugins, and then run it. The \u003ccode\u003eApp::run\u003c/code\u003e method runs the main game loop, even though we haven’t asked it to do anything yet. Nonetheless, some of the plugins will run their own internal processes.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you \u003ca href=\"https://www.jetbrains.com/help/rust/quick-start-guide-rustrover.html#create-new-rust-cargo-project\" target=\"_blank\" rel=\"noopener\"\u003ecreate\u003c/a\u003e an empty project in RustRover and paste this code into \u003ckbd\u003emain.rs\u003c/kbd\u003e, you’ll immediately see a suggestion to add a dependency for the \u003ckbd\u003ebevy\u003c/kbd\u003e crate to your \u003ckbd\u003eCargo.toml\u003c/kbd\u003e file:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"raw\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e[package]\nname = \u0026#34;bevy-first-steps\u0026#34;\nversion = \u0026#34;0.1.0\u0026#34;\nedition = \u0026#34;2021\u0026#34;\n\n[dependencies]\nbevy = \u0026#34;0.15\u0026#34;\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou can also get a sneak peek of what is included in the set of default plugins:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1600\" height=\"1000\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/image-1.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eFor example, there’s \u003ccode\u003eWindowPlugin\u003c/code\u003e, which creates an empty application window:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1600\" height=\"988\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/image-2.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWith \u003ccode\u003eTimePlugin\u003c/code\u003e, we get time-measuring functionality, and \u003ccode\u003eLogPlugin\u003c/code\u003e adds the ability to write logs. The documentation popup also mentions the \u003ckbd\u003ebevy\u003c/kbd\u003e crate features. Plugins and features allow Bevy to be flexible: We can easily switch features on and off and add or remove plugins to get the desired set of functionality. You can read more about the default set of features in the documentation:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1442\" height=\"1600\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/image-3.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIf you want to customize a set of enabled features, just start typing in the \u003ckbd\u003eCargo.toml\u003c/kbd\u003e file, where you’ll get full editing and completion support from RustRover:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"378\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/image-4.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"740\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/image-5.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eBevy has excellent documentation, and the sections you might need are easily accessible from RustRover. You can read sections in popups, follow links, or even open the dedicated \u003cem\u003eDocumentation\u003c/em\u003e tool window:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"900\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/image-6.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNow that we know how to get help in case of emergency, we’re ready to implement our first game element. So without further ado, let’s create our first object in the game world and make it jump!\u003c/p\u003e\n\n\n\n\u003ch2\u003eTime to jump\u003c/h2\u003e\n\n\n\n\u003cp\u003eBefore we get to the technical part, we’ll begin by considering what it actually means for a game object to jump. There are several key points that we need to keep in mind:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eWe need an object with geometrical parameters (width, height, and initial position within the graphical window).\u003c/li\u003e\n\n\n\n\u003cli\u003eJumping means changing an object’s position in time, but not its size in our case (in contrast to a jumping ball, for example, which does change its size when it meets the ground – it’s not a rigid body!).\u003c/li\u003e\n\n\n\n\u003cli\u003eJust like in real life, an initial force should be applied to an object to change its velocity and, consequently, its position. \u003c/li\u003e\n\n\n\n\u003cli\u003eIn games, it’s usually up to a player to decide when to apply that force. Hence, we need to wait for and process user input (for example, when a user presses the space button).\u003c/li\u003e\n\n\n\n\u003cli\u003eRight after an object gets its initial velocity, gravity influences it and works to return it to the ground.\u003c/li\u003e\n\n\n\n\u003cli\u003eFor smooth visualization, we must ensure that our jumping object is rendered in various positions above the ground. \u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eSo, as it turns out, jumping is not that easy after all! And we haven’t even started to implement all these things in Bevy. Now, let’s talk about the concepts and actions from the list above in the direct context of Bevy:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eA game object is an \u003cem\u003eentity\u003c/em\u003e, but it’s not the only entity we need in this program. For example, we need an entity for a camera to see something rendered in the graphical window. The ground can be represented with an entity as well. At least, we’ll need to render it. An entity is just an ID of an object (our jumping object or something coming from the engine), not an object itself. We need IDs to refer to and manipulate objects. To use the language of Bevy, we \u003cem\u003espawn\u003c/em\u003e entities.\u003c/li\u003e\n\n\n\n\u003cli\u003eTo specify an object’s parameters, we use \u003cem\u003ecomponents\u003c/em\u003e and \u003cem\u003ebundles of components\u003c/em\u003e. For example, an object’s velocity is a component (a 3D vector, as we’ll see soon). The marker structure we’ll use to associate a spawned entity with a jumping object is also a component. An object’s position is a component. This component is used for rendering an object. Bevy’s camera is a complex bundle of components (fortunately, we don’t have to analyze them in detail). \u003c/li\u003e\n\n\n\n\u003cli\u003eWhen we spawn entities, we also associate them with their related components. Later, we’ll be able to \u003cem\u003equery\u003c/em\u003e the actual values of components (for example, to change them or to render the corresponding game objects).\u003c/li\u003e\n\n\n\n\u003cli\u003eUser input is represented in Bevy as a stream of \u003cem\u003eevents\u003c/em\u003e. We need to read those events and act accordingly.\u003c/li\u003e\n\n\n\n\u003cli\u003eAll changes and visualizations in the game world are represented by \u003cem\u003esystems\u003c/em\u003e, Rust functions that spawn entities, query the values of components, mutate them, read event streams, delete entities, and much more. In Bevy, systems are responsible for doing virtually everything. Bevy’s core functionality and anything provided by a plugin also take the form of systems. In this tutorial, you’ll see how we can implement our own systems.\u003c/li\u003e\n\n\n\n\u003cli\u003eBevy doesn’t run systems chaotically. Instead, it uses \u003cem\u003eschedules\u003c/em\u003e to decide what to run and when. Some systems need to be run only once at launch, while others run repeatedly on every frame.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe game is structured around \u003cem\u003eframes\u003c/em\u003e: Any game is a sequence of frames that follow one another. The \u003ccode\u003eApp::run\u003c/code\u003e method we saw in our first code sample generates frames by calling a variety of our own systems and other internal ones on every frame. \u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eNow, we are ready to create the following mental model of any Bevy application: We first set up entities with components and then change them into systems run by Bevy that are then rendered frame after frame. Bevy is an ECS (entity, component, system) framework, and everything we do with Bevy follows this pattern.\u003c/p\u003e\n\n\n\n\u003cp\u003eI know you’re waiting for the code, so let’s go right ahead and spawn our first entities for the example of a jumping object:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003econst GROUND_LEVEL: f32 = -100.0;\nconst PLAYER_X: f32 = -300.0;\n\n#[derive(Component)]\nstruct Player;\n\n#[derive(Component)]\nstruct Velocity(Vec3);\n\nfn setup(mut commands: Commands) {\n   commands.spawn(Camera2d::default());\n  \n   // Player\n   commands\n       .spawn((\n           Player,\n           Sprite {\n               color: Color::srgb(0.5, 1.0, 0.5),\n               custom_size: Some(Vec2::new(30.0, 50.0)),\n               anchor: Anchor::BottomCenter,\n               ..default()\n           },\n           Transform::from_xyz(PLAYER_X, GROUND_LEVEL, 0.0),\n           Velocity(Vec3::ZERO)\n       ));\n  \n   // Ground\n   commands.spawn((\n       Sprite {\n           color: Color::srgb(0.5, 0.5, 0.5),\n           custom_size: Some(Vec2::new(800.0, 10.0)),\n           anchor: Anchor::TopLeft,\n           ..default()\n       },\n       Transform::from_xyz(-400.0, GROUND_LEVEL, 0.0)\n   ));\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003esetup\u003c/code\u003e function is a system. In this system, we are spawning three entities:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eOne entity for Bevy’s camera.\u003c/li\u003e\n\n\n\n\u003cli\u003eAnother entity for a jumping object (a player). Note that we represent a player with a bundle of components:\n\u003cul\u003e\n\u003cli\u003eA marker struct \u003ccode\u003ePlayer\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eA sprite – Bevy’s concept that allows us to specify the visual identity of an object including color, size, and potentially many other parameters – even your own graphics.\u003c/li\u003e\n\n\n\n\u003cli\u003eA transform – Bevy’s concept for an object’s position, used by Bevy to render our object in a correct place in the graphical window.\u003c/li\u003e\n\n\n\n\u003cli\u003eA velocity.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003eThe third entity represents the ground – we need it to see when jumping starts.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003esetup\u003c/code\u003e system takes \u003ccode\u003eCommands\u003c/code\u003e as an argument. \u003ccode\u003eCommands\u003c/code\u003e are used to change the structure of the game world, such as by spawning or deleting entities. As we’ll see later, we don’t need them to read or change the values of components. We’ll use \u003cem\u003equeries\u003c/em\u003e for that. \u003c/p\u003e\n\n\n\n\u003cp\u003eLook at the \u003ccode\u003eanchor\u003c/code\u003e and \u003ccode\u003etransform\u003c/code\u003e components associated with the last two entities. We want the object (a rectangle) to stand on the ground. These two objects share the same y-coordinate in their initial positions but use different anchors. As a result, the player’s bottom side is the same as the ground’s top side.\u003c/p\u003e\n\n\n\n\u003cp\u003eNothing will be rendered even if you copy this code to the example. Why? Because we need to run this system as part of our game loop. To do that, we \u003cem\u003eregister\u003c/em\u003e it within the application:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efn main() {\n   App::new()\n       .add_plugins(DefaultPlugins)\n       .add_systems(Startup, setup)\n       .run();\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eNote the \u003ccode\u003eStartup\u003c/code\u003e schedule. Our entities only need to be set up once during startup. Once this is done, we can see our amazing game object standing on the ground!\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"988\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/image-7.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eHey, but that’s not jumping, right? Right, just bear with me. We’re almost there. We simply need to process user input and change the player’s velocity and position by applying the jumping force and gravity. As opposed to just being launched at startup, this behavior needs to be applied to every frame. To implement it, we’ll need to write three systems:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThe \u003ccode\u003ejump\u003c/code\u003e system, which applies a jump force to the game object and sets the player’s velocity to a positive value when requested by a user.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003ccode\u003eapply_gravity\u003c/code\u003e system, which slows the object down by decreasing its velocity. This requires checking the time that passes between consecutive frames. In Bevy terms, time is a \u003cem\u003eresource\u003c/em\u003e, a global value that exists independently of entities and any components associated with them. Remember the \u003ccode\u003eTimePlugin\u003c/code\u003e that was added along with the other default plugins? This is the plugin that provides us with access to this resource. \u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003ccode\u003eplayer_movement\u003c/code\u003e system, which is responsible for recalculating the player’s position. This system also needs to know the actual time because the more time that has passed, the further the player has been moved.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThese systems run between frame updates, hence the \u003ccode\u003eUpdate\u003c/code\u003e schedule that we use to register them within the application:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efn main() {\n   App::new()\n       .add_plugins(DefaultPlugins)\n       .add_systems(Startup, setup)\n       .add_systems(Update, (jump, apply_gravity, player_movement))\n       .run();\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThese three systems don’t manipulate entities. Instead, they read events (user input), query and mutate the components, and consult the time. In Bevy, we give them access to all this information by specifying system parameters: \u003ccode\u003eEventReader\u003c/code\u003e, \u003ccode\u003eQuery\u003c/code\u003e, or \u003ccode\u003eRes\u003c/code\u003e for resources. \u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s look at the \u003ccode\u003ejump\u003c/code\u003e system first. We start by checking the event stream, and if we see a user pressing the space key, we apply a jump force:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003econst JUMP_FORCE: f32 = 600.0;\nfn jump(\n   mut events: EventReader\u0026lt;KeyboardInput\u0026gt;,\n   mut query: Query\u0026lt;(\u0026amp;mut Velocity, \u0026amp;Transform), With\u0026lt;Player\u0026gt;\u0026gt;\n) {\n   for e in events.read() {\n       if let Ok((mut velocity, transform)) =\n               query.get_single_mut() {\n           if e.state.is_pressed() \u0026amp;\u0026amp; e.key_code == KeyCode::Space\n               \u0026amp;\u0026amp; transform.translation.y \u0026lt;= GROUND_LEVEL {\n               velocity.0.y = JUMP_FORCE;\n           }\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eSometimes it can be helpful to read the list of parameters out loud:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eWe’re getting an event reader with keyboard input.\u003c/li\u003e\n\n\n\n\u003cli\u003eWe’re querying velocity and transform (position) for entities marked as \u003ccode\u003ePlayer\u003c/code\u003e. The velocity is expected to be a mutable reference because we’re going to change it.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWith Bevy, it doesn’t take long to start parsing complex query types. Query types specify what we are looking for in the entities and associated components. Bevy will then call these functions and supply them with the requested parameters.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn the system’s code, we check for all the unprocessed events that are available when Bevy runs this system. We get the queried components for every event, ensure the space key has been pressed, check that the player is on the ground (it’s a bit difficult to jump in the middle of another jump!), and finally make the jump happen by setting the velocity’s y-coordinate to some positive value. And we’re off!\u003c/p\u003e\n\n\n\n\u003cp\u003eHere’s an essential consideration: With Bevy, we never attempt to do many things at once in a single system. It’s much easier to reason about game logic when we have multiple systems, each responsible for its own thing. Jumping is not about changing positions, it’s about applying the initial force. We’ll deal with changing positions in a system responsible specifically for that, namely \u003ccode\u003eplayer_movement\u003c/code\u003e: \u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efn player_movement(\n   time: Res\u0026lt;Time\u0026gt;,\n   mut query: Query\u0026lt;(\u0026amp;mut Transform, \u0026amp;mut Velocity), With\u0026lt;Player\u0026gt;\u0026gt;\n) {\n   for (mut transform, mut velocity)\n           in query.iter_mut() {\n       transform.translation.y += velocity.0.y * time.delta_secs();\n       if transform.translation.y \u0026lt;= GROUND_LEVEL {\n           transform.translation.y = GROUND_LEVEL;\n           velocity.0.y = 0.0;\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn this system, we request access to time, player position, and velocity. In the code snippet, we simply iterate through all of the query results to find the one we need, even though we know there’s only one player. But imagine having many players. We need to be prepared!\u003c/p\u003e\n\n\n\n\u003cp\u003eWe update the player’s y-coordinate for every transform and velocity according to the time that has passed between frame updates. We also ensure that our player never gets below the ground level by ensuring velocity is zeroed when ground level is reached.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhile it would be nice to be able to fly like a bird, in our game world, we need gravity.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003econst GRAVITY: f32 = -800.0;\nfn apply_gravity(\n   time: Res\u0026lt;Time\u0026gt;,\n   mut query: Query\u0026lt;\u0026amp;mut Velocity, With\u0026lt;Player\u0026gt;\u0026gt;\n) {\n   for mut velocity in query.iter_mut() {\n       velocity.0.y += GRAVITY * time.delta_secs();\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eGravity is a force that decreases the player’s velocity when jumping. Note that, once again, there is no need to recalculate position here. We need to apply gravity, so we apply gravity and nothing more.\u003c/p\u003e\n\n\n\n\u003cp\u003eI recommend exploring this example’s code in RustRover. Play with the declared constants and initial values of components, run the application many times, explore Bevy’s types and methods, and check their signatures and documentation. There’s a whole world of stuff happening behind the scenes.  \u003c/p\u003e\n\n\n\n\u003cp\u003eWhen you’re ready, we’ll turn this game into an \u003cem\u003eendless runner\u003c/em\u003e: Our player will jump over randomly emerging obstacles, crash into them, lose health points, and eventually die, effectively putting an end to our game.\u003c/p\u003e\n\n\n\n\u003ch2\u003eFor an endless run!\u003c/h2\u003e\n\n\n\n\u003cp\u003eHere’s our plan for this section:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eSpawn and despawn entities, and move them to mimic horizontal movement.\u003c/li\u003e\n\n\n\n\u003cli\u003eImplement a simplified collision detection system.\u003c/li\u003e\n\n\n\n\u003cli\u003eOrganize a method to count health points and end the game when all the health points have been lost due to collisions.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eIn RustRover, we can use either the \u003cem\u003eStructure \u003c/em\u003etool window or the \u003cem\u003eCollapse All\u003c/em\u003e action (\u003cem\u003eFolding | Collapse All\u003c/em\u003e in the popup menu) to get a quick view of the \u003ca href=\"https://github.com/bravit/bevy-first-steps/\" target=\"_blank\" rel=\"noopener\"\u003efinal result\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"900\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/image-8.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eI realize the gameplay is far from rivetting, but hopefully you can enjoy playing it for a few seconds at least!\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"900\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/image.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eFrom here on out, we’ll show more code examples and provide fewer explanations. The goal is to focus on introducing new Bevy parts without carefully analyzing what’s happening. Don’t forget to consult the documentation!\u003c/p\u003e\n\n\n\n\u003ch3\u003eDealing with obstacles: more timers and random numbers\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe idea is to spawn a new obstacle every second. We already know how to consider times between frame updates with Res\u0026lt;Time\u0026gt;. Those times are smaller than a second, so we need another way to work with this specific time interval. Let’s create another resource for measuring one-second intervals. This requires a couple of changes. First, we need to define a constant and a structure with a timer:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003econst SPAWN_INTERVAL: f32 = 1.0;\n\n#[derive(Resource)]\nstruct ObstacleSpawningTimer(Timer);\u003c/pre\u003e\n\n\n\n\u003cp\u003eSecond, we initialize the timer and register it within the application:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eApp::new()\n   .add_plugins(DefaultPlugins)\n   .add_systems(Startup, setup)\n   .insert_resource(ObstacleSpawningTimer(\n                       Timer::from_seconds(SPAWN_INTERVAL, \n                                  TimerMode::Repeating)))\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow we can advance this timer with every frame update and spawn a new obstacle once the timer has counted down to zero:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efn spawn_obstacles(\n   mut commands: Commands,\n   time: Res\u0026lt;Time\u0026gt;,\n   mut spawn_timer: ResMut\u0026lt;ObstacleSpawningTimer\u0026gt;,\n) {\n   spawn_timer.0.tick(time.delta()); // Advancing\n   if spawn_timer.0.finished() {\n       // Spawn the obstacle\n       // ...\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThanks to \u003ccode\u003eTimerMode::Repeating\u003c/code\u003e, our timer repeats after finishing, so we get an infinite sequence of obstacles. There’s one issue, though. We want obstacles to have random positions. So, how do we get random numbers? One common solution would be to use the well-known \u003ckbd\u003erand\u003c/kbd\u003e crate, but the problem here is that we’re not in complete control of our application: Bevy is. What we need is a random number generator. But how do we make one available in our systems? When working with Bevy, it’s best to look for crates that implement the required functionality but are also integrated with Bevy and its ECS framework. Fortunately, we have the \u003ckbd\u003ebevy_rand\u003c/kbd\u003e crate that provides everything we need. I recommend reading the \u003ca href=\"https://docs.rs/bevy_rand/latest/bevy_rand/tutorial/index.html\" target=\"_blank\" rel=\"noopener\"\u003etutorial\u003c/a\u003e, as quite a few things should be considered when working with randomization in Bevy.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo introduce random numbers to our project, we add the following dependencies to our \u003ckbd\u003eCargo.toml\u003c/kbd\u003e file:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"raw\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003erand_core = \u0026#34;0.6.4\u0026#34;\nbevy_rand = \u0026#34;0.9\u0026#34;\nbevy_prng = { version = \u0026#34;0.9.0\u0026#34;, features = [\u0026#34;wyrand\u0026#34;] }\u003c/pre\u003e\n\n\n\n\u003cp\u003eThen, we add a plugin to the application:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eApp::new()\n   .add_plugins(DefaultPlugins)\n   .add_plugins(EntropyPlugin::\u0026lt;WyRand\u0026gt;::default())\n   // ...\u003c/pre\u003e\n\n\n\n\u003cp\u003eFinally, we’ll add a random number generator to the required system using the usual Bevy approach as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efn spawn_obstacles(\n   mut commands: Commands,\n   time: Res\u0026lt;Time\u0026gt;,\n   mut spawn_timer: ResMut\u0026lt;ObstacleSpawningTimer\u0026gt;,\n   mut rng: GlobalEntropy\u0026lt;WyRand\u0026gt;,\n) {\n   spawn_timer.0.tick(time.delta());\n   if spawn_timer.0.finished() {\n       let obstacle_x = GROUND_EDGE;\n       let obstacle_y = GROUND_LEVEL + (rng.next_u32() % 50) as f32;\n       commands.spawn((\n           Obstacle,\n           Sprite {\n               color: OBSTACLE_COLOR,\n               custom_size: Some(OBSTACLE_SIZE),\n               anchor: Anchor::BottomCenter,\n               ..default()\n           },\n           Transform::from_xyz(obstacle_x, obstacle_y, 0.0),\n       ));\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe movement of obstacles is implemented by decreasing their x-coordinates. Thus, users feel like the player is moving forward (from left to right):\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efn move_obstacles(\n   time: Res\u0026lt;Time\u0026gt;,\n   mut commands: Commands,\n   mut query: Query\u0026lt;(Entity, \u0026amp;mut Transform), With\u0026lt;Obstacle\u0026gt;\u0026gt;,\n) {\n   for (entity, mut transform) in query.iter_mut() {\n       transform.translation.x -= GAME_SPEED * time.delta_secs();\n\n\n       // Remove obstacles once they\u0026#39;re off-screen\n       if transform.translation.x \u0026lt; -GROUND_EDGE {\n           commands.entity(entity).despawn();\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eOne interesting thing about the system above is that we can easily despawn entities once they are off the screen. We use \u003ccode\u003eCommands\u003c/code\u003e and the \u003ccode\u003eentity\u003c/code\u003e method to access the \u003ccode\u003eentity\u003c/code\u003e we’re interested in. We use the time between frame updates to recalculate current positions, just as before. By playing with the \u003ccode\u003eGAME_SPEED\u003c/code\u003e value, we can make the game slower or faster, for example, to increase or decrease the difficulty level. To do that at run time, we must make this constant a resource and access its value as needed.\u003c/p\u003e\n\n\n\n\u003ch3\u003eHealth points, collision detection, and text rendering\u003c/h3\u003e\n\n\n\n\u003cp\u003eNow we want to implement health points, set them to some initial value at the beginning of the game, and then decrease them with every collision. In other approaches, we need to add a heath field to some structure containing other information about the player. But that’s not the approach we use in Bevy. Instead, we define a new component:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e#[derive(Component)]\nstruct Health(usize);\nThen we associate it with the player’s entity at spawning:\n// Player\ncommands\n   .spawn((\n       Player,\n       Sprite {\n           ...\n       },\n       Transform::from_xyz(PLAYER_X, GROUND_LEVEL, 0.0),\n       Velocity(Vec3::ZERO),\n       Health(initial_health)\n   ));\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow we can access the health value in order to read or mutate it depending on our use case. When we detect a collision, we decrease it. To render health information on the screen, we only require read access to the data.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s look at this simplistic implementation of collision detection:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efn detect_collision(\n   mut commands: Commands,\n   mut player_query: Query\u0026lt;(\u0026amp;Transform, \u0026amp;mut Health), With\u0026lt;Player\u0026gt;\u0026gt;,\n   obstacle_query: Query\u0026lt;(Entity, \u0026amp;Transform), With\u0026lt;Obstacle\u0026gt;\u0026gt;,\n) {\n   if let Ok((player_transform, mut health)) =\n                               player_query.get_single_mut() {\n       for (entity, obstacle_transform) in obstacle_query.iter() {\n           let collision = player_transform.translation.distance(\n                                obstacle_transform.translation) \u0026lt; 50.0;\n           if collision {\n               health.0 -= 1;\n               commands.entity(entity).despawn(); // Remove obstacle\n           }\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe just compare the player’s position with that of obstacles, and if the player is close enough, then we count the situation as a collision and decrease the health points accordingly. The obstacle entity is despawned immediately.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe also need to render health information on the screen. To use the language of Bevy, we need to define a component, and then spawn and render a corresponding entity:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e#[derive(Component)]\nstruct HealthInfo;\n\nfn setup(mut commands: Commands) {\n   // ...\n   commands.spawn((\n           HealthInfo,\n           Text::new(format!(\u0026#34;Health: {}\u0026#34;, initial_health))\n       )\n   );\n   // ...\n}\n\nfn render_health_info(\n   player_query: Query\u0026lt;\u0026amp;mut Health, With\u0026lt;Player\u0026gt;\u0026gt;,\n   mut health_info_query: Query\u0026lt;\u0026amp;mut Text, With\u0026lt;HealthInfo\u0026gt;\u0026gt;,\n) {\n   if let Ok(mut health_info) = health_info_query.get_single_mut() {\n       if let Ok(health) = player_query.get_single() {\n           health_info.0 = format!(\u0026#34;Health: {}\u0026#34;, health.0);\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn the \u003ccode\u003erender_health_info\u003c/code\u003e system, we access the player’s health and info components and then update the text node with the actual data. Follow the documentation on the \u003ccode\u003eText\u003c/code\u003e component to learn how to position the corresponding UI node and change its properties, such as font, size, color, etc. \u003c/p\u003e\n\n\n\n\u003ch3\u003eGame states and advanced system scheduling\u003c/h3\u003e\n\n\n\n\u003cp\u003eWhat should we do when a player loses all their health points? In other words, how should we implement the \u003cem\u003egame over\u003c/em\u003e situation? The problem is that some systems need to stop being executed while others should start executing right when we reach this state. For example, we must prevent obstacles from moving and the player from jumping, while also displaying the “Game Over” text on the screen. To implement the desired behavior, we’ll apply Bevy’s \u003cem\u003estates\u003c/em\u003e and use its additional scheduling features.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe need to introduce two states into our gameplay:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eInGame\u003c/code\u003e, which corresponds to the time we are playing.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eGameOver\u003c/code\u003e, which means that the game is over.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWe might have more states in more advanced games, for example, for pausing the game or navigating a menu. In Bevy, we define the following structure with states and derive the required definitions:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e#[derive(States, Debug, Clone, PartialEq, Eq, Hash)]\nenum GameState {\n   InGame,\n   GameOver,\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThen we register our initial state within the application:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eApp::new()\n   // ...\n   .insert_state(InGame)\n   // ...\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhile in the game, we should consult the player’s health and then switch to \u003ccode\u003eGameOver\u003c/code\u003e if there are no health points left:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efn check_health(\n   player_query: Query\u0026lt;\u0026amp;Health, With\u0026lt;Player\u0026gt;\u0026gt;,\n   mut game_state: ResMut\u0026lt;NextState\u0026lt;GameState\u0026gt;\u0026gt;\n) {\n   if let Ok(Health(health)) = player_query.get_single() {\n       if *health == 0 {\n           game_state.set(GameOver);\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen the game is over, we display a huge banner in the center of the window:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"rust\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efn game_over(mut commands: Commands) {\n   commands.spawn((Node {\n       position_type: PositionType::Absolute,\n       left: Val::Percent(10.),\n       right: Val::Percent(10.),\n       top: Val::Percent(15.),\n       bottom: Val::Percent(15.),\n       justify_content: JustifyContent::Center,\n       ..default()\n   },))\n       .with_children(|builder| {\n           builder.spawn((\n               Text(\u0026#34;GAME OVER\u0026#34;.to_string()),\n               TextFont::from_font_size(160.0),\n               TextLayout::new_with_justify(JustifyText::Center)\n                    .with_no_wrap(),\n               TextColor(Color::srgb(1.0, 0.0, 0.0)),\n           ));\n       });\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eOf course, we also need to specify when any given system should and should not be executed. We do that using the \u003ccode\u003erun_if\u003c/code\u003e schedule modifier and the \u003ccode\u003eOnEnter(GameOver)\u003c/code\u003e schedule as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eApp::new()\n   // ...\n   .add_systems(Update, (jump, apply_gravity, player_movement)\n       .run_if(in_state(InGame)))\n   .add_systems(Update, (spawn_obstacles, move_obstacles,\n                         detect_collision, render_health_info,\n                         check_health)\n       .run_if(in_state(InGame)))\n   .add_systems(OnEnter(GameOver), game_over)\n   .run();\u003c/pre\u003e\n\n\n\n\u003cp\u003eSo, if the current state is \u003ccode\u003eInGame\u003c/code\u003e, we have eight systems to execute within the \u003ccode\u003eUpdate\u003c/code\u003e schedule (meaning on every frame update) and a single \u003ccode\u003egame_over\u003c/code\u003e system when we enter the \u003ccode\u003eGameOver\u003c/code\u003e state (meaning it is executed only once). \u003c/p\u003e\n\n\n\n\u003cp\u003eI encourage you to play with the \u003ca href=\"https://github.com/bravit/bevy-first-steps/\" target=\"_blank\" rel=\"noopener\"\u003efinal\u003c/a\u003e implementation and try implementing many more features, for example:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eSpawning stars.\u003c/li\u003e\n\n\n\n\u003cli\u003eGiving rewards for collecting stars.\u003c/li\u003e\n\n\n\n\u003cli\u003eUsing more advanced graphics for game objects instead of boring rectangles.\u003c/li\u003e\n\n\n\n\u003cli\u003eImplementing game levels.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eAnd beyond\u003c/h2\u003e\n\n\n\n\u003cp\u003eIt takes a lot of time to master game development and Bevy, which means it’s crucial to start applying your knowledge as early as possible. Make your own game right now! To help flatten the learning curve, I’ve composed the following list of helpful resources:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://bevyengine.org/\" target=\"_blank\" rel=\"noopener\"\u003eBevy’s website\u003c/a\u003e is a great resource: You can find links to the documentation, community links, and official examples (make sure you \u003ca href=\"https://bevyengine.org/examples/\" target=\"_blank\" rel=\"noopener\"\u003echeck\u003c/a\u003e them out!), as well as a \u003ca href=\"https://bevyengine.org/assets/\" target=\"_blank\" rel=\"noopener\"\u003ecollection of third-party assets\u003c/a\u003e, learning resources, crates, and apps.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/@rustunit_com/playlists\" target=\"_blank\" rel=\"noopener\"\u003eBevy GameDev Meetups\u003c/a\u003e host a wide selection of general talks about Bevy as well as numerous deep-dives into specific features.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003ca href=\"https://bevy-cheatbook.github.io/\" target=\"_blank\" rel=\"noopener\"\u003eBevy Cheat Book\u003c/a\u003e can prove very helpful when you need to implement some highly specific functionalities.\u003c/li\u003e\n\n\n\n\u003cli\u003eMigration guides \u003ca href=\"https://bevyengine.org/learn/migration-guides/0-14-to-0-15/\" target=\"_blank\" rel=\"noopener\"\u003elike this one\u003c/a\u003e are also must-reads. Things in Bevy change frequently, so be prepared.\u003c/li\u003e\n\n\n\n\u003cli\u003eIt’s also highly advisable that you learn about at least one physics engine for Bevy (e.g. \u003ca href=\"https://github.com/Jondolf/avian\" target=\"_blank\" rel=\"noopener\"\u003eavian\u003c/a\u003e), and I would recommend following \u003ca href=\"https://www.youtube.com/@chrisbiscardi\" target=\"_blank\" rel=\"noopener\"\u003eChris Biscardi\u003c/a\u003e and his \u003ca href=\"https://thisweekinbevy.com/\" target=\"_blank\" rel=\"noopener\"\u003eThis Week in Bevy\u003c/a\u003e project for valuable insights.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe fast pace of Bevy development creates many issues for both content creators and AI assistants. Materials on the internet and any AI-generated suggestions can easily be outdated. You should always keep in mind the Bevy version you are targeting and check the migration guides if you encounter any issues.\u003c/p\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eGame development with Rust and Bevy is an exciting journey that requires a combination of creativity, problem-solving, and technical skills. From setting up your first Bevy project to implementing core game mechanics, every step reveals the power and flexibility of this ecosystem. Bevy’s entity-component-system (ECS) architecture might initially seem challenging, but its logic and elegance become increasingly apparent as you practice, enabling you to create scalable and maintainable games.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhile this blog post provides a solid foundation, learning begins when you start experimenting. Don’t hesitate to dive deeper into advanced topics like collision detection, procedural generation, or physics integration. Bevy’s vibrant community and extensive resources, including documentation, meetups, and third-party assets, will prove invaluable as you continue your educational journey.\u003c/p\u003e\n\n\n\n\u003cp\u003eRemember, game development isn’t just about writing code but crafting experiences. Challenge yourself to create something unique, whether it’s a simple platformer or a complex simulation. Each project will teach you new concepts, spark new ideas, and bring you closer to mastering this craft.\u003c/p\u003e\n\n\n\n\u003cp\u003eBevy’s rapid development pace is both an opportunity and a challenge. Stay informed about new updates, consult migration guides, and engage with the community to keep your skills sharp and your projects up to date. Whether exploring game design for fun or building a career in the industry, the combination of Rust, Bevy, and your creativity is a recipe for success.Now it’s time to roll up your sleeves, launch \u003ca href=\"https://www.jetbrains.com/rust/\" target=\"_blank\" rel=\"noopener\"\u003eRustRover\u003c/a\u003e, start coding, and bring your game ideas to life. Good luck, and happy coding!\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to Rust Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "34 min read",
  "publishedTime": null,
  "modifiedTime": null
}
