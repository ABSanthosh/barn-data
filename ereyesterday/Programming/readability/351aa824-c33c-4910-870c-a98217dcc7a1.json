{
  "id": "351aa824-c33c-4910-870c-a98217dcc7a1",
  "title": "How to catch GitHub Actions workflow injections before attackers do",
  "link": "https://github.blog/security/vulnerability-research/how-to-catch-github-actions-workflow-injections-before-attackers-do/",
  "description": "Strengthen your repositories against actions workflow injections — one of the most common vulnerabilities. The post How to catch GitHub Actions workflow injections before attackers do appeared first on The GitHub Blog.",
  "author": "Dylan Birtolo",
  "published": "Wed, 16 Jul 2025 16:00:00 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Security",
    "Vulnerability research",
    "code scanning",
    "CodeQL"
  ],
  "byline": "Dylan Birtolo",
  "length": 11179,
  "excerpt": "Strengthen your repositories against actions workflow injections — one of the most common vulnerabilities.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "You already know that security is important to keep in mind when creating code and maintaining projects. Odds are, you also know that it’s much easier to think about security from the ground up rather than trying to squeeze it in at the end of a project. But did you know that GitHub Actions injections are one of the most common vulnerabilities in projects stored in GitHub repositories? Thankfully, this is a relatively easy vulnerability to address, and GitHub has some tools to make it even easier. From the 2024 Octoverse report detailing the most common types of OWASP-classified vulnerabilities identified by CodeQL in 2024. Our latest data shows a similar trend, highlighting the continued risks of injection attacks despite continued warnings for several decades. Embracing a security mindset The truth is that security is not something that is ever “done.” It’s a continuous process, one that you need to keep focusing on to help keep your code safe and secure. While automated tools are a huge help, they’re not an all-in-one, fire-and-forget solution. This is why it’s important to understand the causes behind security vulnerabilities as well as how to address them. No tool will be 100% effective, but by increasing your understanding and deepening your knowledge, you will be better able to respond to threats.  With that in mind, let’s talk about one of the most common vulnerabilities found in GitHub repositories. Explaining actions workflow injections So what exactly is a GitHub Actions workflow injection? This is when a malicious attacker is able to submit a command that is run by a workflow in your repository. This can happen when an attacker controls the data, such as when they create an issue title or a branch name, and you execute that untrusted input. For example, you might execute it in the run portion of your workflow. One of the most common causes of this is with the ${{}} syntax in your code. In the preprocessing step, this syntax will automatically expand. That expansion may alter your code by inserting new commands. Then, when the system executes the code, these malicious commands are executed too. Consider the following workflow as an example: - name: print title run: echo \"${{ github.event.issue.title }}\" Let’s assume that this workflow is triggered whenever a user creates an issue. Then an attacker can create an issue with malicious code in the title, and the code will be executed when this workflow runs. The attacker only needs to do a small amount of trickery such as adding backtick characters to the title: touch pwned.txt. Furthermore, this code will run using the permissions granted to the workflow, permissions the attacker is otherwise unlikely to have. This is the root of the actions workflow injection. The biggest issues with actions workflow injections are awareness that this is a problem and finding all the instances that could lead to this vulnerability. How to proactively protect your code As stated earlier, it’s easier to prevent a vulnerability from appearing than it is to catch it after the fact. To that end, there are a few things that you should keep in mind while writing your code to help protect yourself from actions workflow injections. While these are valuable tips, remember that even if you follow all of these guidelines, it doesn’t guarantee that you’re completely protected. Use environment variables Remember that the actions workflow injections happen as a result of expanding what should be treated as untrusted input. When it is inserted into your workflow, if it contains malicious code, it changes the intended behavior. Then when the workflow triggers and executes, the attacker’s code runs.One solution is to avoid using the ${{}} syntax in workflow sections like run. Instead, expand the untrusted data into an environment variable and then use the environment variable when you are running the workflow. If you consider our example above, this would change to the following. - name: print title env: TITLE: ${{ github.event.issue.title }} run: echo \"$TITLE\" This won’t make the input trusted, but it will help to protect you from some of the ways attackers could take advantage of this vulnerability. We encourage you to do this, but still remember that this data is untrusted and could be a potential risk. The principle of least privilege is your best friend When an actions workflow injection triggers, it runs with the permissions granted to the workflow. You can specify what permissions workflows have by setting the permissions for the workflow’s GITHUB_TOKEN. For this reason, it’s important to make sure that your workflows are only running with the lowest privilege levels they need in order to perform duties. Otherwise, you might be giving an attacker permissions you didn’t intend if they manage to inject their code into your workflow. Be cautious with pull_request_target The impact is usually much more devastating when injection happens in a workflow that is triggered on pull_request_target than on pull_request. There is a significant difference between the pull_request and pull_request_target workflow triggers. The pull_request workflow trigger prevents write permissions and secrets access on the target repository by default when it’s triggered from a fork. Note that when the workflow is triggered from a branch in the same repository, it has access to secrets and potentially has write permissions. It does this in order to help prevent unauthorized access and protect your repository. By contrast, the pull_request_target workflow trigger gives the workflow writer the ability to release some of the restrictions. While this is important for some scenarios, it does mean that by using pull_request_target instead of pull_request, you are potentially putting your repository at a greater risk. This means you should be using the pull_request trigger unless you have a very specific need to use pull_request_target. And if you are using the latter, you want to take extra care with the workflow given the additional permissions. The problem’s not just on main It’s not uncommon to create several branches while developing your code, often for various features or bug fixes. This is a normal part of the software development cycle. And sometimes we’re not the best at remembering to close and delete those branches after merging or after we’ve finished working with them. Unfortunately, these branches are still a potential vulnerability if you’re using the pull_request_target trigger. An attacker can target a workflow that runs on a pull request in a branch, and still take advantage of this exploit. This means that you can’t just assume your repository is safe because the workflows against your main branch are secure. You need to review all of the branches that are publicly visible in your repository. What CodeQL brings to the table CodeQL is GitHub’s code analysis tool that provides automated security checks against your code. The specific feature of CodeQL that is most relevant here is the code scanning feature, which can provide feedback on your code and help identify potential security vulnerabilities. We recently made the ability to scan GitHub Actions workflow files generally available, and you can use this feature to look for several types of vulnerabilities, such as potential actions workflow injection risks.  One of the reasons CodeQL is so good at finding where untrusted data might be used is because of taint tracking. We added taint tracking to CodeQL for actions late last year. With taint tracking, CodeQL tracks where untrusted data flows through your code and identifies potential risks that might not be as obvious as the previous examples. Enabling CodeQL to scan your actions workflows is as easy as enabling CodeQL code scanning with the default setup, which automatically includes analyzing actions workflows and will run on any protected branch. You can then check for the code scanning results to identify potential risks and start fixing them.  If you’re already using the advanced setup for CodeQL, you can add support for scanning your actions workflows by adding the actions language to the target languages. These scans will be performed going forward and help to identify these vulnerabilities. While we won’t get into it in this blog, it’s important to know that CodeQL code scanning runs several queries—it’s not just good at finding actions workflow injections. We encourage you to give it a try and see what it can find.  While CodeQL is a very effective tool—and it is really good at finding this specific vulnerability—it’s still not going to be 100% effective. Remember that no tool is perfect, and you should focus on keeping a security mindset and taking a critical idea to your own code. By keeping this in the forefront of your thoughts, you will be able to develop more secure code and help prevent these vulnerabilities from ever appearing in the first place.  Future steps Actions workflow injections are known to be one of the most prevalent vulnerabilities in repositories available on GitHub. However, they are relatively easy to address. The biggest issues with eliminating this vulnerability are simply being aware that they’re a problem and discovering the possible weak spots in your code. Now that you’re aware of the issue, and have CodeQL on your side as a useful tool, you should be able to start looking for and fixing these vulnerabilities in your own code. And if you keep the proactive measures in mind, you’ll be in a better position to prevent them from occurring in future code you write. If you’d like to learn more about actions workflow injections, we previously published a four-part series about keeping your actions workflows secure. The second part is specifically about actions workflow injections, but we encourage you to give the entire series a read. Need some help searching through your code to look for potential vulnerabilities? Set up code scanning in your project today. Written by Dylan Birtolo is a senior content writer at GitHub, where he works on sharing all the good things that GitHub has to offer. He's been a technical writer for almost 20 years, a large portion of which was working on various teams across Microsoft. In his off time, he works with animals, plays a lot of games, and professionally jousts. Explore more from GitHub Docs Everything you need to master GitHub, all in one place. Go to Docs GitHub Build what’s next on GitHub, the place for anyone from anywhere to build anything. Start building Customer stories Meet the companies and engineering teams that build with GitHub. Learn more GitHub Universe 2025 Last chance: Save $700 on your IRL pass to Universe and join us on Oct. 28-29 in San Francisco. Register now",
  "image": "https://github.blog/wp-content/uploads/2025/04/wallpaper_github_generic_2.png?fit=1920%2C1080",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eYou already know that security is important to keep in mind when creating code and maintaining projects. Odds are, you also know that it’s much easier to think about security from the ground up rather than trying to squeeze it in at the end of a project.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut did you know that GitHub Actions injections are one of the most common vulnerabilities in projects stored in GitHub repositories? Thankfully, this is a relatively easy vulnerability to address, and GitHub has some tools to make it even easier.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"768\" height=\"768\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/07/vulnerabilities.png?resize=768%2C768\" alt=\"A bar chart detailing the most common vulnerabilities found by CodeQL in 2024. In order from most to least, they are: injection, broken access control, insecure design, cryptographic failures, identification and authentication failures, security misconfigurations, software and data integrity failures, security logging and monitoring failures, server side request forgery, and vulnerable and outdated components.\" srcset=\"https://github.blog/wp-content/uploads/2025/07/vulnerabilities.png?w=768 768w, https://github.blog/wp-content/uploads/2025/07/vulnerabilities.png?w=150 150w, https://github.blog/wp-content/uploads/2025/07/vulnerabilities.png?w=300 300w, https://github.blog/wp-content/uploads/2025/07/vulnerabilities.png?w=600 600w, https://github.blog/wp-content/uploads/2025/07/vulnerabilities.png?w=400 400w, https://github.blog/wp-content/uploads/2025/07/vulnerabilities.png?w=200 200w, https://github.blog/wp-content/uploads/2025/07/vulnerabilities.png?w=90 90w, https://github.blog/wp-content/uploads/2025/07/vulnerabilities.png?w=116 116w\" sizes=\"auto, (max-width: 768px) 100vw, 768px\"/\u003e\u003cfigcaption\u003e\u003cem\u003eFrom the 2024 Octoverse report detailing the most common types of OWASP-classified vulnerabilities identified by CodeQL in 2024. Our latest data shows a similar trend, highlighting the continued risks of injection attacks despite continued warnings for several decades.\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003ch2 id=\"h-embracing-a-security-mindset\"\u003eEmbracing a security mindset\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe truth is that security is not something that is ever “done.” It’s a continuous process, one that you need to keep focusing on to help keep your code safe and secure. While automated tools are a huge help, they’re not an all-in-one, fire-and-forget solution.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is why it’s important to understand the causes behind security vulnerabilities as well as how to address them. No tool will be 100% effective, but by increasing your understanding and deepening your knowledge, you will be better able to respond to threats. \u003c/p\u003e\n\n\n\n\u003cp\u003eWith that in mind, let’s talk about one of the most common vulnerabilities found in GitHub repositories.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-explaining-actions-workflow-injections\"\u003eExplaining actions workflow injections\u003c/h2\u003e\n\n\n\n\u003cp\u003eSo what exactly is a GitHub Actions workflow injection? This is when a malicious attacker is able to submit a command that is run by a \u003ca href=\"https://docs.github.com/actions/writing-workflows/about-workflows\"\u003eworkflow\u003c/a\u003e in your repository. This can happen when an attacker controls the data, such as when they create an issue title or a branch name, and you execute that untrusted input. For example, you might execute it in the run portion of your workflow.\u003c/p\u003e\n\n\n\n\u003cp\u003eOne of the most common causes of this is with the \u003ccode\u003e${{}}\u003c/code\u003e syntax in your code. In the preprocessing step, this syntax will automatically expand. That expansion may alter your code by inserting new commands. Then, when the system executes the code, these malicious commands are executed too.\u003c/p\u003e\n\n\n\n\u003cp\u003eConsider the following workflow as an example:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e- name: print title\n  run: echo \u0026#34;${{ github.event.issue.title }}\u0026#34;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s assume that this workflow is triggered whenever a user creates an issue. Then an attacker can create an issue with malicious code in the title, and the code will be executed when this workflow runs. The attacker only needs to do a small amount of trickery such as adding backtick characters to the title: \u003ccode\u003etouch pwned.txt\u003c/code\u003e. Furthermore, this code will run using the permissions granted to the workflow, permissions the attacker is otherwise unlikely to have.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is the root of the actions workflow injection. The biggest issues with actions workflow injections are awareness that this is a problem and finding all the instances that could lead to this vulnerability.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"how-to-proactively-protect-your-code\"\u003eHow to proactively protect your code\u003c/h2\u003e\n\n\n\n\u003cp\u003eAs stated earlier, it’s easier to prevent a vulnerability from appearing than it is to catch it after the fact. To that end, there are a few things that you should keep in mind while writing your code to help protect yourself from actions workflow injections.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhile these are valuable tips, remember that even if you follow all of these guidelines, it doesn’t guarantee that you’re completely protected.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"use-environment-variables\"\u003eUse environment variables\u003c/h3\u003e\n\n\n\n\u003cp\u003eRemember that the actions workflow injections happen as a result of expanding what should be treated as untrusted input. When it is inserted into your workflow, if it contains malicious code, it changes the intended behavior. Then when the workflow triggers and executes, the attacker’s code runs.\u003cbr/\u003eOne solution is to avoid using the \u003ccode\u003e${{}}\u003c/code\u003e syntax in workflow sections like \u003ccode\u003erun\u003c/code\u003e. Instead, expand the untrusted data into an environment variable and then use the environment variable when you are running the workflow. If you consider our example above, this would change to the following.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e- name: print title\n  env:\n    TITLE: ${{ github.event.issue.title }}\n  run: echo \u0026#34;$TITLE\u0026#34;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis won’t make the input trusted, but it will help to protect you from some of the ways attackers could take advantage of this vulnerability. We encourage you to do this, but still remember that this data is untrusted and could be a potential risk.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"the-principle-of-least-privilege-is-your-best-friend\"\u003eThe principle of least privilege is your best friend\u003c/h3\u003e\n\n\n\n\u003cp\u003eWhen an actions workflow injection triggers, it runs with the permissions granted to the workflow. You can specify what permissions workflows have by \u003ca href=\"https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token#defining-access-for-the-github_token-permissions\"\u003esetting the permissions for the workflow’s GITHUB_TOKEN\u003c/a\u003e. For this reason, it’s important to make sure that your workflows are only running with the lowest privilege levels they need in order to perform duties. Otherwise, you might be giving an attacker permissions you didn’t intend if they manage to inject their code into your workflow.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"be-cautious-with-pull_request_target\"\u003eBe cautious with \u003ccode\u003epull_request_target\u003c/code\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe impact is usually much more devastating when injection happens in a workflow that is triggered on \u003ccode\u003epull_request_target\u003c/code\u003e than on \u003ccode\u003epull_request\u003c/code\u003e. There is a significant difference between the \u003ccode\u003epull_request\u003c/code\u003e and \u003ccode\u003epull_request_target\u003c/code\u003e workflow triggers.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003epull_request\u003c/code\u003e workflow trigger prevents write permissions and secrets access on the target repository by default when it’s triggered from a fork. Note that when the workflow is triggered from a branch in the same repository, it has access to secrets and potentially has write permissions. It does this in order to help prevent unauthorized access and protect your repository.\u003c/p\u003e\n\n\n\n\u003cp\u003eBy contrast, the \u003ccode\u003epull_request_target\u003c/code\u003e workflow trigger gives the workflow writer the ability to release some of the restrictions. While this is important for some scenarios, it does mean that by using \u003ccode\u003epull_request_target\u003c/code\u003e instead of \u003ccode\u003epull_request\u003c/code\u003e, you are potentially putting your repository at a greater risk.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis means you should be using the \u003ccode\u003epull_request\u003c/code\u003e trigger unless you have a very specific need to use \u003ccode\u003epull_request_target\u003c/code\u003e. And if you are using the latter, you want to take extra care with the workflow given the additional permissions.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"the-problems-not-just-on-main\"\u003eThe problem’s not just on main\u003c/h2\u003e\n\n\n\n\u003cp\u003eIt’s not uncommon to create several branches while developing your code, often for various features or bug fixes. This is a normal part of the software development cycle. And sometimes we’re not the best at remembering to close and delete those branches after merging or after we’ve finished working with them. Unfortunately, these branches are still a potential vulnerability if you’re using the \u003ccode\u003epull_request_target\u003c/code\u003e trigger.\u003c/p\u003e\n\n\n\n\u003cp\u003eAn attacker can target a workflow that runs on a pull request in a branch, and still take advantage of this exploit. This means that you can’t just assume your repository is safe because the workflows against your \u003ccode\u003emain\u003c/code\u003e branch are secure. You need to review all of the branches that are publicly visible in your repository.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"what-codeql-brings-to-the-table\"\u003eWhat CodeQL brings to the table\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://codeql.github.com/\"\u003eCodeQL\u003c/a\u003e is GitHub’s code analysis tool that provides automated security checks against your code. The specific feature of CodeQL that is most relevant here is \u003ca href=\"https://docs.github.com/code-security/code-scanning/introduction-to-code-scanning/about-code-scanning-with-codeql\"\u003ethe code scanning feature\u003c/a\u003e, which can provide feedback on your code and help identify potential security vulnerabilities. We recently \u003ca href=\"https://github.blog/changelog/2025-04-22-github-actions-workflow-security-analysis-with-codeql-is-now-generally-available/\"\u003emade the ability to scan GitHub Actions workflow files generally available\u003c/a\u003e, and you can use this feature to look for several types of vulnerabilities, such as potential actions workflow injection risks. \u003c/p\u003e\n\n\n\n\u003cp\u003eOne of the reasons CodeQL is so good at finding where untrusted data might be used is because of taint tracking. We \u003ca href=\"https://github.blog/security/application-security/how-to-secure-your-github-actions-workflows-with-codeql/#taint-tracking-is-key\"\u003eadded taint tracking to CodeQL\u003c/a\u003e for actions late last year. With taint tracking, CodeQL tracks where untrusted data flows through your code and identifies potential risks that might not be as obvious as the previous examples.\u003c/p\u003e\n\n\n\n\u003cp\u003eEnabling CodeQL to scan your actions workflows is as easy as \u003ca href=\"https://docs.github.com/code-security/code-scanning/enabling-code-scanning/configuring-default-setup-for-code-scanning\"\u003eenabling CodeQL code scanning with the default setup\u003c/a\u003e, which automatically includes analyzing actions workflows and will run on any \u003ca href=\"https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches\"\u003eprotected branch\u003c/a\u003e. You can then check for the code scanning results to identify potential risks and start fixing them. \u003c/p\u003e\n\n\n\n\u003cp\u003eIf you’re already using \u003ca href=\"https://docs.github.com/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/configuring-advanced-setup-for-code-scanning\"\u003ethe advanced setup for CodeQL\u003c/a\u003e, you can add support for scanning your actions workflows by adding the \u003ccode\u003eactions\u003c/code\u003e language to the target languages. These scans will be performed going forward and help to identify these vulnerabilities.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhile we won’t get into it in this blog, it’s important to know that CodeQL code scanning runs several queries—it’s not just good at finding actions workflow injections. We encourage you to give it a try and see what it can find. \u003c/p\u003e\n\n\n\n\u003cp\u003eWhile CodeQL is a very effective tool—and it is really good at finding this specific vulnerability—it’s still not going to be 100% effective. Remember that no tool is perfect, and you should focus on keeping a security mindset and taking a critical idea to your own code. By keeping this in the forefront of your thoughts, you will be able to develop more secure code and help prevent these vulnerabilities from ever appearing in the first place. \u003c/p\u003e\n\n\n\n\u003ch2 id=\"future-steps\"\u003eFuture steps\u003c/h2\u003e\n\n\n\n\u003cp\u003eActions workflow injections are known to be one of the most prevalent vulnerabilities in repositories available on GitHub. However, they are relatively easy to address. The biggest issues with eliminating this vulnerability are simply being aware that they’re a problem and discovering the possible weak spots in your code.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow that you’re aware of the issue, and have CodeQL on your side as a useful tool, you should be able to start looking for and fixing these vulnerabilities in your own code. And if you keep the proactive measures in mind, you’ll be in a better position to prevent them from occurring in future code you write.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you’d like to learn more about actions workflow injections, we previously published \u003ca href=\"https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/\"\u003ea four-part series about keeping your actions workflows secure\u003c/a\u003e. The \u003ca href=\"https://securitylab.github.com/resources/github-actions-untrusted-input/\"\u003esecond part\u003c/a\u003e is specifically about actions workflow injections, but we encourage you to give the entire series a read.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNeed some help searching through your code to look for potential vulnerabilities?\u003c/strong\u003e \u003ca href=\"https://docs.github.com/code-security/code-scanning/enabling-code-scanning/configuring-default-setup-for-code-scanning\"\u003eSet up code scanning\u003c/a\u003e in your project today.\u003c/p\u003e\n\n\n\n\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/39363041?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/39363041?v=4\u0026amp;s=200\" alt=\"Dylan Birtolo\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eDylan Birtolo is a senior content writer at GitHub, where he works on sharing all the good things that GitHub has to offer. He\u0026#39;s been a technical writer for almost 20 years, a large portion of which was working on various teams across Microsoft. In his off time, he works with animals, plays a lot of games, and professionally jousts.\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tExplore more from GitHub\t\u003c/h2\u003e\n\t\u003cdiv\u003e\n\t\t\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg\" width=\"44\" height=\"44\" alt=\"Docs\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tDocs\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eEverything you need to master GitHub, all in one place.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Go to Docs; ref_location:bottom recirculation;\" href=\"https://docs.github.com/\" target=\"_blank\" aria-label=\"Go to Docs\"\u003e\n\t\t\t\t\tGo to Docs\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg\" width=\"44\" height=\"44\" alt=\"GitHub\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tGitHub\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eBuild what’s next on GitHub, the place for anyone from anywhere to build anything.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Start building; ref_location:bottom recirculation;\" href=\"https://github.com/\" target=\"_blank\" aria-label=\"Start building\"\u003e\n\t\t\t\t\tStart building\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg\" width=\"44\" height=\"44\" alt=\"Customer stories\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tCustomer stories\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eMeet the companies and engineering teams that build with GitHub.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Learn more; ref_location:bottom recirculation;\" href=\"https://github.com/customer-stories\" target=\"_blank\" aria-label=\"Learn more\"\u003e\n\t\t\t\t\tLearn more\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg\" width=\"44\" height=\"44\" alt=\"GitHub Universe 2025\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tGitHub Universe 2025\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eLast chance: Save $700 on your IRL pass to Universe and join us on Oct. 28-29 in San Francisco.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Register now; ref_location:bottom recirculation;\" href=\"https://githubuniverse.com/?utm_source=Blog\u0026amp;utm_medium=GitHub\u0026amp;utm_campaign=module\" target=\"_blank\" aria-label=\"Register now\"\u003e\n\t\t\t\t\tRegister now\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2025-07-16T16:00:00Z",
  "modifiedTime": null
}
