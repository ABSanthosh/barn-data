{
  "id": "ea26e16c-7353-411f-84c6-fa26edcf536a",
  "title": "Why Does RSC Integrate with a Bundler?",
  "link": "https://overreacted.io/why-does-rsc-integrate-with-a-bundler/",
  "description": "One does not simply serialize a module.",
  "author": "",
  "published": "Fri, 30 May 2025 00:00:00 GMT",
  "source": "https://overreacted.io/rss.xml",
  "categories": null,
  "byline": "",
  "length": 5659,
  "excerpt": "One does not simply serialize a module.",
  "siteName": "",
  "favicon": "https://overreacted.io/icon.png?e0852c1e2c7f0e65",
  "text": "Fair warning—this one’s for the nerds. React Server Components is a programming paradigm that extends the module system to express a server/client application as a single program spanning two runtimes. Under the hood, the RSC implementation consists of two main pieces: A serializer for React trees (packages/react-server in the React repo). A deserializer for React trees (packages/react-client in the React repo). The react-server and react-client packages are internal to the React repo. They are fully open source, of course, but they don’t get published in their raw form to npm. This is because they’re missing a key ingredient—the module system integration. Unlike many (de)serializers, RSC concerns itself not only with sending data, but also with sending code. For example, consider this tree: \u003cp\u003eHello, world\u003c/p\u003e If you want to turn this \u003cp\u003e tag into JSON, you could do it like this: { type: 'p', props: { children: 'Hello world' } } But now consider this \u003cCounter\u003e tag. How do you serialize it? import { Counter } from './client'; \u003cCounter initialCount={10} /\u003e 'use client'; import { useState, useEffect } from 'react'; export function Counter({ initialCount }) { const [count, setCount] = useState(initialCount); // ... } How does one serialize a module? Serializing Modules Recall that we want to revive an actual \u003cCounter\u003e on the other side of the wire—so we don’t just want a snapshot of it. We want its entire logic for interactivity! One way to serialize it is to literally embed the Counter code into our JSON: { type: ` import { useState, useEffect } from 'react'; export function Counter({ initialCount }) { const [count, setCount] = useState(initialCount); // ... } `, props: { initialCount: 10 } } But that’s kind of bad, right? You don’t really want to send code as strings to eval on the client, and you don’t want to send the same component’s code many times. So instead it’s reasonable to assume its code is being served by our app as a static JS asset—which we can refer to in the JSON. It’s almost like a \u003cscript\u003e tag: { type: '/src/client.js#Counter', // \"Load src/client.js and grab Counter\" props: { initialCount: 10 } } In fact, on the client, you could load it by generating a \u003cscript\u003e tag. However, loading imports one by one from their source files over the network is inefficient. Recall that one file can import other files, and the client doesn’t know the import tree in advance. You don’t want to create a waterfall. We already know how to fix this from two decades of working on client-side applications: bundling. RSC Bundler Bindings For this reason, RSC integrates with bundlers. RSC doesn’t require a bundler per se: here’s a bundler-less RSC ESM proof of concept. But it exists mostly for posterity because of how inefficient it actually is to do naïvely without more optimizations. Realistic RSC integrations are bundler-specific. Bindings for Parcel, Webpack, and (eventually) Vite live in the React repo and specify how to send and load modules: First, during the build, their job is to find the files with 'use client' and to actually create the bundle chunks for those entry points—a bit like Astro Islands. Then, on the server, these bindings teach React how to send modules to the client. For example, a bundler might refer to a module like 'chunk123.js#Counter'. On the client, they teach React how to ask the bundler runtime to load those modules. For example, the Parcel bindings call a Parcel-specific function for that. Thanks to these three things, React Server will know how to serialize a module when it encounters one—and the React Client will know how to deserialize it. The API to serialize a tree with the React Server is exposed via bundler bindings: import { serialize } from 'react-server-dom-yourbundler'; // Bundler-specific package const reactTree = \u003cCounter initialCount={10} /\u003e; const outputString = serialize(reactTree); // Something like the JSON above Then one can store the outputString on the disk, or send it over the network, or cache it, whatever—and eventually feed it to the React Client. The React Client will deserialize the entire tree, loading code from the referenced modules as needed: import { deserialize } from 'react-server-dom-yourbundler/client'; // Bundler-specific package const outputString = // ... received over network, read from disk, etc... const reactTree = deserialize(outputString); // \u003cCounter initialCount={10} /\u003e And that, assuming everything worked correctly, will give you a normal piece of JSX, as if you wrote \u003cCounter initialCount={10} /\u003e on the client yourself. You can do anything with that tree—render it, keep it in state, turn into HTML, etc. const outputString = // ... received over network, read from disk, etc... const reactTree = deserialize(outputString); // \u003cCounter initialCount={10} /\u003e // You can do anything you'd do with a regular JSX tree, for example: const root = createRoot(domNode); root.render(reactTree); That’s the APIs that RSC frameworks like Next.js use under the hood. If you want to play with RSC using these lower-level APIs and see your React trees getting (de)serialized, the Parcel RSC implementation is a good starting point. (The serialize and deserialize names above are illustrative. The exact names are up to the bindings (and may have multiple overloads). For example, @parcel/rsc package, which is a thin wrapper over the underlying react-server-dom-parcel bindings, exposes serialization as renderRSC and deserialization as fetchRSC. Also, their actual implementations are non-blocking and support streaming on both sides.)",
  "image": "https://overreacted.io/why-does-rsc-integrate-with-a-bundler/opengraph-image?5b0b970dfd19bb8c",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eFair warning—this one’s for the nerds.\u003c/p\u003e\n\u003cp\u003eReact Server Components is a programming paradigm that \u003ca href=\"https://overreacted.io/what-does-use-client-do/\"\u003eextends the module system\u003c/a\u003e to express a server/client application as a single program spanning two runtimes. Under the hood, the RSC implementation consists of two main pieces:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA serializer for React trees (\u003ca target=\"_blank\" href=\"https://github.com/facebook/react/tree/main/packages/react-server\"\u003e\u003ccode\u003epackages/react-server\u003c/code\u003e\u003c/a\u003e in the React repo).\u003c/li\u003e\n\u003cli\u003eA deserializer for React trees (\u003ca target=\"_blank\" href=\"https://github.com/facebook/react/tree/main/packages/react-client\"\u003e\u003ccode\u003epackages/react-client\u003c/code\u003e\u003c/a\u003e in the React repo).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe \u003ccode\u003ereact-server\u003c/code\u003e and \u003ccode\u003ereact-client\u003c/code\u003e packages are internal to the React repo.\u003c/p\u003e\n\u003cp\u003eThey are fully open source, of course, but they don’t get published in their raw form to npm. This is because they’re missing a key ingredient—the module system integration. Unlike many (de)serializers, RSC concerns itself not only with sending \u003cem\u003edata\u003c/em\u003e, but also with sending \u003cem\u003ecode\u003c/em\u003e. For example, consider this tree:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003eHello, world\u003c/span\u003e\u003cspan\u003e\u0026lt;/\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eIf you want to turn this \u003ccode\u003e\u0026lt;p\u0026gt;\u003c/code\u003e tag into JSON, you could do it like this:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  type: \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  props: \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    children: \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003eHello world\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eBut now consider this \u003ccode\u003e\u0026lt;Counter\u0026gt;\u003c/code\u003e tag. How do you serialize it?\u003c/p\u003e\n\u003cdiv\u003e\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e Counter \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e./client\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eCounter\u003c/span\u003e\u003cspan\u003e initialCount={\u003c/span\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003euse client\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e useState\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e useEffect \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003ereact\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e Counter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ initialCount }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const [\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e setCount\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e useState\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003einitialCount\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  // ...\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\u003c/div\u003e\n\u003cp\u003eHow does one serialize a \u003cem\u003emodule?\u003c/em\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"serializing-modules\"\u003e\u003ca target=\"_self\" href=\"#serializing-modules\"\u003eSerializing Modules\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eRecall that we want to revive an actual \u003ccode\u003e\u0026lt;Counter\u0026gt;\u003c/code\u003e on the other side of the wire—so we don’t just want a snapshot of it. We want its entire logic for interactivity!\u003c/p\u003e\n\u003cp\u003eOne way to serialize it is to literally embed the \u003ccode\u003eCounter\u003c/code\u003e code into our JSON:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  type: \u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    import { useState, useEffect } from \u0026#39;react\u0026#39;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    export function Counter({ initialCount }) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      const [count, setCount] = useState(initialCount);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      // ...\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  `\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  props: \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    initialCount: \u003c/span\u003e\u003cspan\u003e10\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eBut that’s kind of bad, right? You don’t \u003cem\u003ereally\u003c/em\u003e want to send code as strings to \u003ccode\u003eeval\u003c/code\u003e on the client, and you don’t want to send the same component’s code many times. So instead it’s reasonable to assume its code is being served by our app as a static JS asset—which we can refer to in the JSON. It’s almost like a \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e tag:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e  type: \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e/src/client.js#Counter\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e // \u0026#34;Load src/client.js and grab Counter\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  props: \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    initialCount: \u003c/span\u003e\u003cspan\u003e10\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eIn fact, on the client, you could load it \u003cem\u003eby\u003c/em\u003e generating a \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e tag.\u003c/p\u003e\n\u003cp\u003eHowever, loading imports one by one from their source files over the network is inefficient. Recall that one file can import other files, and the client doesn’t know the import tree in advance. You don’t want to create a waterfall. We already know how to fix this from two decades of working on client-side applications: bundling.\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"rsc-bundler-bindings\"\u003e\u003ca target=\"_self\" href=\"#rsc-bundler-bindings\"\u003eRSC Bundler Bindings\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eFor this reason, RSC integrates with bundlers. RSC doesn’t require a bundler \u003cem\u003eper se\u003c/em\u003e: here’s a \u003ca target=\"_blank\" href=\"https://github.com/facebook/react/tree/main/fixtures/flight-esm\"\u003ebundler-less RSC ESM proof of concept\u003c/a\u003e. But it exists mostly for posterity because of how inefficient it actually is to do naïvely without more optimizations.\u003c/p\u003e\n\u003cp\u003eRealistic RSC integrations are bundler-specific. Bindings for \u003ca target=\"_blank\" href=\"https://github.com/facebook/react/tree/main/packages/react-server-dom-parcel\"\u003eParcel\u003c/a\u003e, \u003ca target=\"_blank\" href=\"https://github.com/facebook/react/tree/main/packages/react-server-dom-webpack\"\u003eWebpack\u003c/a\u003e, and (eventually) \u003ca target=\"_blank\" href=\"https://github.com/facebook/react/pull/33152\"\u003eVite\u003c/a\u003e live in the React repo and specify how to send and load modules:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirst, \u003cstrong\u003eduring the build,\u003c/strong\u003e their job is to find the files with \u003ccode\u003e\u0026#39;use client\u0026#39;\u003c/code\u003e and to actually create the bundle chunks for those entry points—a bit like \u003ca target=\"_blank\" href=\"https://docs.astro.build/en/concepts/islands/\"\u003eAstro Islands\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eThen, \u003cstrong\u003eon the server,\u003c/strong\u003e these bindings teach React how to send modules to the client. For example, a bundler might refer to a module like \u003ccode\u003e\u0026#39;chunk123.js#Counter\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOn the client,\u003c/strong\u003e they teach React how to ask the bundler runtime to load those modules. For example, the Parcel bindings \u003ca target=\"_blank\" href=\"https://github.com/facebook/react/blob/ee76351917106c6146745432a52e9a54a41ee181/packages/react-server-dom-parcel/src/client/ReactFlightClientConfigBundlerParcel.js#L80-L81\"\u003ecall a Parcel-specific function\u003c/a\u003e for that.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThanks to these three things, React Server will know how to serialize a module when it encounters one—and the React Client will know how to deserialize it.\u003c/p\u003e\n\u003cp\u003eThe API to serialize a tree with the React Server is exposed \u003cem\u003evia\u003c/em\u003e bundler bindings:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e serialize \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003ereact-server-dom-yourbundler\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003cspan\u003e // Bundler-specific package\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003ereactTree\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026lt;\u003c/span\u003e\u003cspan\u003eCounter\u003c/span\u003e\u003cspan\u003e initialCount={\u003c/span\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e} /\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003eoutputString\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e serialize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ereactTree\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003cspan\u003e // Something like the JSON above\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eThen one can store the \u003ccode\u003eoutputString\u003c/code\u003e on the disk, or send it over the network, or cache it, whatever—and eventually feed it to the React Client. The React Client will deserialize the entire tree, loading code from the referenced modules as needed:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e deserialize \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003ereact-server-dom-yourbundler/client\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003cspan\u003e  // Bundler-specific package\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003eoutputString\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e // ... received over network, read from disk, etc...\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003ereactTree\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e deserialize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eoutputString\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003cspan\u003e // \u0026lt;Counter initialCount={10} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eAnd that, assuming everything worked correctly, will give you a normal piece of JSX, as if you wrote \u003ccode\u003e\u0026lt;Counter initialCount={10} /\u0026gt;\u003c/code\u003e  on the client yourself. You can do anything with that tree—render it, keep it in state, turn into HTML, etc.\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003eoutputString\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e // ... received over network, read from disk, etc...\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003ereactTree\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e deserialize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eoutputString\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003cspan\u003e // \u0026lt;Counter initialCount={10} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e// You can do anything you\u0026#39;d do with a regular JSX tree, for example:\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003eroot\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e createRoot\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edomNode\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003eroot\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erender\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ereactTree\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eThat’s the APIs that RSC frameworks like Next.js use under the hood.\u003c/p\u003e\n\u003cp\u003eIf you want to play with RSC using these lower-level APIs and see your React trees getting (de)serialized, the \u003ca target=\"_blank\" href=\"https://parceljs.org/recipes/rsc/\"\u003eParcel RSC implementation\u003c/a\u003e is a good starting point.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e(The \u003ccode\u003eserialize\u003c/code\u003e and \u003ccode\u003edeserialize\u003c/code\u003e names above are illustrative. The exact names are up to the bindings (and may have multiple overloads). For example, \u003ccode\u003e@parcel/rsc\u003c/code\u003e package, which is a thin wrapper over the underlying \u003ccode\u003ereact-server-dom-parcel\u003c/code\u003e bindings, exposes serialization as \u003ccode\u003erenderRSC\u003c/code\u003e and deserialization as \u003ccode\u003efetchRSC\u003c/code\u003e. Also, their actual implementations are non-blocking and support streaming on both sides.)\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
