{
  "id": "f20fc871-b1a7-4fb3-9ca9-1ee988960ff7",
  "title": "Kotlin and Azul: Collaboration for Enhanced Runtime Performance",
  "link": "https://blog.jetbrains.com/kotlin/2025/05/kotlin-and-azul-collaboration-for-enhanced-runtime-performance/",
  "description": "Striving for high application performance For many years, JetBrains has aimed to help developers write high-performance applications by providing tools for development and diagnostics. On the Kotlin team, we pay close attention to performance, offering language features such as inline functions and classes, optimizations in the standard library, thoughtful bytecode generation, and the Kotlin coroutines […]",
  "author": "Anton Yalyshev",
  "published": "Tue, 20 May 2025 13:00:09 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": null,
  "byline": "Anton Yalyshev",
  "length": 5936,
  "excerpt": "Kotlin and Azul team up to boost JVM performance, with early benchmarks showing major wins in latency and throughput for Kotlin applications.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "A concise multiplatform language developed by JetBrains Kotlin and Azul: Collaboration for Enhanced Runtime Performance Striving for high application performance For many years, JetBrains has aimed to help developers write high-performance applications by providing tools for development and diagnostics. On the Kotlin team, we pay close attention to performance, offering language features such as inline functions and classes, optimizations in the standard library, thoughtful bytecode generation, and the Kotlin coroutines library, among other initiatives. A significant contribution to runtime performance comes from the JDK. We believe that viewing these components as an integrated system can bring even greater performance benefits. We are excited to announce a strategic technical collaboration with Azul, a renowned high-performance JVM provider. Azul has a longstanding reputation in the Java community for delivering JVM innovations that address some of the toughest performance challenges facing JVM-based applications. Joining forces for JVM performance This collaboration is driven by a shared vision: by closely examining how Kotlin-generated bytecode interacts with advanced JVM optimizations, we can uncover new ways to enhance runtime performance. Azul’s deep JVM expertise, combined with Kotlin’s ability to control bytecode generation, offers a unique opportunity to optimize the entire execution stack. Ultimately, our collaboration aims to benefit both specialized high-performance JVM implementations (like Zing) and standard JVMs such as OpenJDK, thus helping all Kotlin users achieve better performance out of the box. Our first Step: Establishing clear benchmarks First, we needed to verify that existing features of the Zing JDK (also known as Azul’s Platform Prime product) positively impact Kotlin applications. We selected a Kotlin project from the widely respected TechEmpower Framework Benchmarks, which reflect typical backend workloads. The test exercised the ORM, database connectivity, dynamically sized collections, sorting, server-side templates, and other standard operations. Additionally, we implemented an application that performs CPU-intensive and memory-intensive operations. We ran these applications using different JDKs – standard OpenJDK and the high-performance Zing JDK – and tested them under high load. Early results from this effort have already shown significant promise. The chart below illustrates the improvement in performance metrics when using the Zing JDK compared to OpenJDK. TechEmpower testCPU-intensive testMemory-intensive testLatency Avg23.9%28.0%27.8%Throughput30.5%39.0%38.1%Test environmentZing JDK version: zing25.02.0.0-2-jdk11.0.26OpenJDK version: 21.0.7JVM run config: -Xms2g -Xmx2gHardware config: AWS EC2, 8 vCPUs, 16GB OS: Amazon Linux 2023 Standard deviation for throughput remained within 15%.  Apart from using different JDKs, the test machines were identical. The performance enhancements observed can be attributed to key Platform Prime technologies: Falcon JIT compiler: Utilizes LLVM-based optimization techniques, enabling deeper optimizations and improved throughput. This directly enhances the execution efficiency of bytecode generated by the Kotlin compiler. C4 Pauseless Garbage Collector: Continuously manages memory concurrently without “stop-the-world” pauses, significantly reducing latency spikes and maintaining consistent response times, particularly beneficial for coroutine-intensive Kotlin applications. Next steps: Deeper exploration and optimization Encouraged by these findings, our next objectives are: To expand benchmark coverage by adding various real-world use cases. The Azul team will also add Kotlin projects for regular testing of their JDK distributions. To delve deeper into potential bytecode-level optimizations within the Kotlin compiler itself. The Azul engineering team will advise us on JVM requirements for bytecode optimizations. With this data, Kotlin’s compiler team will explore targeted changes in bytecode generation that could further boost runtime performance. Join our journey We invite the Kotlin community to participate in this exploration of runtime performance. What kinds of optimizations have worked for you? How does your application behave under load? Share your stories about achieving high runtime performance. If you’re curious, try running your server-side Kotlin applications on Platform Prime and observe how it performs in your environment. Upcoming webinar: Dive deeper into JVM performance Stay tuned for our upcoming joint Kotlin-Azul webinar, where our engineers will present practical optimization strategies covering the entire technology stack – from the JVM platform to web application frameworks. We’ll be announcing registration details soon. Subscribe to Kotlin Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/05/KT-social-BlogSocialShare-2560x1440-1-2.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/kotlin/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/Kotlin-5.svg\" alt=\"Kotlin logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eA concise multiplatform language developed by JetBrains\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                                        \u003ch2 id=\"major-updates\"\u003eKotlin and Azul: Collaboration for Enhanced Runtime Performance\u003c/h2\u003e                    \n                    \n\u003ch2\u003e\u003cstrong\u003eStriving for high application performance\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eFor many years, JetBrains has aimed to help developers write high-performance applications by providing tools for development and diagnostics. On the Kotlin team, we pay close attention to performance, offering language features such as inline functions and classes, optimizations in the standard library, thoughtful bytecode generation, and the Kotlin coroutines library, among other initiatives.\u003c/p\u003e\n\n\n\n\u003cp\u003eA significant contribution to runtime performance comes from the JDK. We believe that viewing these components as an integrated system can bring even greater performance benefits.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe are excited to announce a strategic technical collaboration with Azul, a renowned high-performance JVM provider. Azul has a longstanding reputation in the Java community for delivering JVM innovations that address some of the toughest performance challenges facing JVM-based applications.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eJoining forces for JVM performance\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eThis collaboration is driven by a shared vision: by closely examining how Kotlin-generated bytecode interacts with advanced JVM optimizations, we can uncover new ways to enhance runtime performance. Azul’s deep JVM expertise, combined with Kotlin’s ability to control bytecode generation, offers a unique opportunity to optimize the entire execution stack.\u003c/p\u003e\n\n\n\n\u003cp\u003eUltimately, our collaboration aims to benefit both specialized high-performance JVM implementations (like Zing) and standard JVMs such as OpenJDK, thus helping all Kotlin users achieve better performance out of the box.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eOur first Step: Establishing clear benchmarks\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eFirst, we needed to verify that existing features of the Zing JDK (also known as Azul’s Platform Prime product) positively impact Kotlin applications. We selected a \u003ca href=\"https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/Kotlin/ktor/ktor\" target=\"_blank\" rel=\"noopener\"\u003eKotlin project\u003c/a\u003e from the widely respected TechEmpower Framework Benchmarks, which reflect typical backend workloads. The test exercised the ORM, database connectivity, dynamically sized collections, sorting, server-side templates, and other standard operations. Additionally, we implemented an \u003ca href=\"https://github.com/yalishevant/ktor-perf-test-app\" target=\"_blank\" rel=\"noopener\"\u003eapplication\u003c/a\u003e that performs CPU-intensive and memory-intensive operations. We ran these applications using different JDKs – standard OpenJDK and the high-performance Zing JDK – and tested them under high load.\u003c/p\u003e\n\n\n\n\u003cp\u003eEarly results from this effort have already shown significant promise. The chart below illustrates the improvement in performance metrics when using the Zing JDK compared to OpenJDK.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003eTechEmpower test\u003c/td\u003e\u003ctd\u003eCPU-intensive test\u003c/td\u003e\u003ctd\u003eMemory-intensive test\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eLatency Avg\u003c/td\u003e\u003ctd\u003e23.9%\u003c/td\u003e\u003ctd\u003e28.0%\u003c/td\u003e\u003ctd\u003e27.8%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eThroughput\u003c/td\u003e\u003ctd\u003e30.5%\u003c/td\u003e\u003ctd\u003e39.0%\u003c/td\u003e\u003ctd\u003e38.1%\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cfigcaption\u003e\u003cem\u003eTest environment\u003cbr/\u003eZing JDK version: zing25.02.0.0-2-jdk11.0.26\u003c/em\u003e\u003cbr/\u003e\u003cem\u003eOpenJDK version: 21.0.7\u003cbr/\u003eJVM run config: -Xms2g -Xmx2g\u003cbr/\u003eHardware config: AWS EC2, 8 vCPUs, 16GB \u003cbr/\u003eOS: Amazon Linux 2023\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\n\n\n\n\u003cp\u003eStandard deviation for throughput remained within 15%. \u003c/p\u003e\n\n\n\n\u003cp\u003eApart from using different JDKs, the test machines were identical. The performance enhancements observed can be attributed to key Platform Prime technologies:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eFalcon JIT compiler: Utilizes LLVM-based optimization techniques, enabling deeper optimizations and improved throughput. This directly enhances the execution efficiency of bytecode generated by the Kotlin compiler.\u003c/li\u003e\n\n\n\n\u003cli\u003eC4 Pauseless Garbage Collector: Continuously manages memory concurrently without “stop-the-world” pauses, significantly reducing latency spikes and maintaining consistent response times, particularly beneficial for coroutine-intensive Kotlin applications.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eNext steps: Deeper exploration and optimization\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eEncouraged by these findings, our next objectives are:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eTo expand benchmark coverage by adding various real-world use cases. The Azul team will also add Kotlin projects for regular testing of their JDK distributions.\u003c/li\u003e\n\n\n\n\u003cli\u003eTo delve deeper into potential bytecode-level optimizations within the Kotlin compiler itself. The Azul engineering team will advise us on JVM requirements for bytecode optimizations. With this data, Kotlin’s compiler team will explore targeted changes in bytecode generation that could further boost runtime performance.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eJoin our journey\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe invite the Kotlin community to participate in this exploration of runtime performance. What kinds of optimizations have worked for you? How does your application behave under load? Share your stories about achieving high runtime performance. If you’re curious, try running your server-side Kotlin applications on \u003ca href=\"https://www.azul.com/blog/azul-platform-prime-stream-builds-are-now-free-for-evaluation-development-and-testing/\" target=\"_blank\" rel=\"noopener\"\u003ePlatform Prime\u003c/a\u003e and observe how it performs in your environment.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eUpcoming webinar: Dive deeper into JVM performance\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://info.jetbrains.com/kotlin-communication-center.html\" target=\"_blank\" rel=\"noopener\"\u003eStay tuned\u003c/a\u003e for our upcoming joint Kotlin-Azul webinar, where our engineers will present practical optimization strategies covering the entire technology stack – from the JVM platform to web application frameworks. We’ll be announcing registration details soon.\u003c/p\u003e\n\n\n\n\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to Kotlin Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
