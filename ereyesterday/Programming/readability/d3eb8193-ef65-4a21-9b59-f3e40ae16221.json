{
  "id": "d3eb8193-ef65-4a21-9b59-f3e40ae16221",
  "title": "C++26 Draft Finalized with Static Reflection, Contracts, and Sender/Receiver Types",
  "link": "https://www.infoq.com/news/2025/06/cpp-26-feature-complete/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "The next major release of C++ reached an important milestone earlier this month, when the ISO C++ committee froze the feature set that will go into C++26. Notable additions include compile-time reflection, contracts, asynchronous execution, and many others. By Sergio De Simone",
  "author": "Sergio De Simone",
  "published": "Fri, 27 Jun 2025 18:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "C++26",
    "Embedded Software Dev",
    "Concurrency",
    "Programming Languages",
    "System Programming",
    "C++",
    "Development",
    "news"
  ],
  "byline": "Sergio De Simone",
  "length": 3613,
  "excerpt": "The next major release of C++ reached an important milestone earlier this month, when the ISO C++ committee froze the feature set that will go into C++26. Notable additions include compile-time reflec",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s1_20250605075448/apple-touch-icon.png",
  "text": "The next major release of C++ reached an important milestone earlier this month, when the ISO C++ committee froze the feature set that will go into C++26. Notable additions include compile-time reflection, contracts, asynchronous execution, and many others. Static reflection enables compile-time introspection on types and behavior, aiming to extend C++ metaprogramming capabilities. At a basic level, reflection allows to write code similar to the following to convert an enum to a string: enum Color { red, green, blue }; static_assert(enum_to_string(Color::red) == \"red\"); While the user-facing syntax for using reflection is simple, in keeping with modern C++ philosophy, the implementation of the feature shown above is significantly more complex. Still it offers a glimpse of the capabilities reflection will unlock: template \u003ctypename E\u003e requires std::is_enum_v\u003cE\u003e constexpr std::string enum_to_string(E value) { template for (constexpr auto e : std::meta::members_of(^E)) { if (value == [:e:]) { return std::string(std::meta::name_of(e)); } } return \"\u003cunnamed\u003e\"; } Reflection will debut in C++ in an early form and is expected to evolve in future versions. Even so, it will already be powerful enough to enable advanced use cases, such as generating bindings for other languages like JavaScript and Python. This is how Herb Sutter describes the feature in its latest Trip Report: Even with the first partial reflection capability we have today, we will already be able to reflect on C++ types and use that information plus plain old std::cout to generate arbitrary additional C++ source code that is based on that information and that we can compile and link into the same program as it’s being built. In the future, using reflection it will be possible to generate C++ code within the same source file using token injection. Other features accepted into the standard at the latest ISO C++ committee meeting include parallel algorithms for the Ranges library, async scopes, aimed at enabling RAII (resource allocation is initialization) style programming for resource management in asynchronous contexts, and a parallel scheduler providing an advanced execution context for thread pools. Several major features accepted in previous committee meetings include contracts, asynchronous execution, and numerous others not covered here, such as enhancements to template metaprogramming with pack indexing, the #embed directive for including binary resources, bounds-checked iterators and null pointer validation, SIMD parallelism, and more. Contracts aim to support design by contract through [[pre:]], [[post:]], and contract_assert. Originally planned for C++20, they were ultimately removed from the final draft, but are now making their way into the standard. std::execution provides mechanisms to manage asynchronous execution on generic execution resources. Its core concepts are sender and receiver: a sender represents a unit of asynchronous work that sends its result to a receiver. The framework is completed by the concepts of state associated with an asynchronous operation and a light-weight scheduler. Work on C++26 continues, but as Sutter highlights, it is closer to completion than many might expect, with GCC and Clang already supporting about two-thirds of the adopted language features. InfoQ will keep reporting on the evolution of the next C++ standard as it progresses. About the Author Sergio De Simone",
  "image": "https://res.infoq.com/news/2025/06/cpp-26-feature-complete/en/headerimage/cpp-26-feature-complete-1751043754882.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eThe next major release of C++ reached an important milestone earlier this month, when \u003ca href=\"https://herbsutter.com/2025/06/21/trip-report-june-2025-iso-c-standards-meeting-sofia-bulgaria/\"\u003ethe ISO C++ committee froze the feature set that will go into C++26\u003c/a\u003e. Notable additions include compile-time reflection, contracts, asynchronous execution, and many others.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://wg21.link/p2996\"\u003eStatic reflection\u003c/a\u003e enables compile-time introspection on types and behavior, aiming to extend C++ metaprogramming capabilities. At a basic level, reflection allows to write code similar to the following to convert an \u003ca href=\"https://herbsutter.com/2023/11/11/trip-report-autumn-iso-c-standards-meeting-kona-hi-usa/\"\u003e\u003ccode\u003eenum\u003c/code\u003e to a \u003ccode\u003estring\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eenum Color { red, green, blue };\nstatic_assert(enum_to_string(Color::red) == \u0026#34;red\u0026#34;);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhile the user-facing syntax for using reflection is simple, in keeping with \u003ca href=\"https://www.infoq.com/news/2014/10/modern-cpp-essentials/\"\u003emodern C++ philosophy\u003c/a\u003e, the implementation of the feature shown above is significantly more complex. Still it offers a glimpse of the capabilities reflection will unlock:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etemplate \u0026lt;typename E\u0026gt;\n    requires std::is_enum_v\u0026lt;E\u0026gt;\nconstexpr std::string enum_to_string(E value) {\n    template for (constexpr auto e : std::meta::members_of(^E)) {\n        if (value == [:e:]) {\n            return std::string(std::meta::name_of(e));\n        }\n    }\n    return \u0026#34;\u0026lt;unnamed\u0026gt;\u0026#34;;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReflection will debut in C++ in an early form and is expected to evolve in future versions. Even so, it will already be powerful enough to enable advanced use cases, such as generating bindings for other languages like JavaScript and Python. This is how Herb Sutter describes the feature in its latest Trip Report:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eEven with the first partial reflection capability we have today, we will already be able to reflect on C++ types and use that information plus plain old \u003ccode\u003estd::cout\u003c/code\u003e to generate arbitrary additional C++ source code that is based on that information and that we can compile and link into the same program as it’s being built.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eIn the future, using reflection it will be possible to generate C++ code within the same source file using token injection.\u003c/p\u003e\n\n\u003cp\u003eOther features accepted into the standard at the latest ISO C++ committee meeting include \u003ca href=\"https://wg21.link/p3179\"\u003eparallel algorithms for the Ranges library\u003c/a\u003e, \u003ca href=\"https://wg21.link/p3149\"\u003easync scopes\u003c/a\u003e, aimed at enabling RAII (resource allocation is initialization) style programming for resource management in asynchronous contexts, and a \u003ca href=\"https://wg21.link/p2079\"\u003eparallel scheduler\u003c/a\u003e providing an advanced execution context for thread pools.\u003c/p\u003e\n\n\u003cp\u003eSeveral major features accepted in previous committee meetings include contracts, asynchronous execution, and numerous others not covered here, such as enhancements to template metaprogramming with pack indexing, the \u003ccode\u003e#embed\u003c/code\u003e directive for including binary resources, bounds-checked iterators and null pointer validation, SIMD parallelism, and more.\u003c/p\u003e\n\n\u003cp\u003eContracts aim to support design by contract through \u003ccode\u003e[[pre:]]\u003c/code\u003e, \u003ccode\u003e[[post:]]\u003c/code\u003e, and \u003ccode\u003econtract_assert\u003c/code\u003e. \u003ca href=\"https://www.infoq.com/news/2019/07/cpp20-draft-finalized/\"\u003eOriginally planned for C++20, they were ultimately removed\u003c/a\u003e from the final draft, but are now making their way into the standard.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003estd::execution\u003c/code\u003e provides mechanisms to manage asynchronous execution on generic execution resources. Its core concepts are \u003cstrong\u003esender\u003c/strong\u003e and \u003cstrong\u003ereceiver\u003c/strong\u003e: a sender represents a unit of asynchronous work that sends its result to a receiver. The framework is completed by the concepts of \u003cstrong\u003estate\u003c/strong\u003e associated with an asynchronous operation and a light-weight \u003cstrong\u003escheduler\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eWork on C++26 continues, but as Sutter highlights, it is closer to completion than many might expect, with GCC and Clang already supporting about two-thirds of the adopted language features. InfoQ will keep reporting on the evolution of the next C++ standard as it progresses.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Sergio-De-Simone\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eSergio De Simone\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-06-27T00:00:00Z",
  "modifiedTime": null
}
