{
  "id": "4ec11813-fb1c-40a4-a72f-780323a7e546",
  "title": "LittleHorse, a Java Workflow Engine for Distributed Systems Orchestration",
  "link": "https://www.infoq.com/news/2025/04/littlehorse/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "LittleHorse is a Java open-source platform designed to orchestrate distributed systems, addressing the challenges related to state management and the coordination of microservices, external APIs, and human tasks. It allows developers to define workflows programmatically using languages such as Java, Go, Python, C#/.NET, eliminating the need for specialized DSLs. By Diogo Carleto",
  "author": "Diogo Carleto",
  "published": "Wed, 23 Apr 2025 15:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Java",
    "Web Development",
    "Software Development",
    "Development",
    "news"
  ],
  "byline": "Diogo Carleto",
  "length": 4601,
  "excerpt": "LittleHorse is a Java open-source platform designed to orchestrate distributed systems, addressing the challenges related to state management and the coordination of microservices, external APIs, and",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s1_20250422123038_u1/apple-touch-icon.png",
  "text": "LittleHorse is a Java open-source platform designed to orchestrate distributed systems, addressing the challenges related to state management and the coordination of microservices, external APIs, and human tasks. It allows developers to define workflows programmatically using languages such as Java, Go, Python, C#, .NET; eliminating the need for specialized DSLs. The key capabilities include real-time observability, automated error recovery with retries, event-driven coordination, User Task integration, and developer SDKs. Modern distributed systems often introduce complexities in inter-service coordination, state management, and ensuring reliability. LittleHorse aims to provide intelligent workflow orchestration to manage these underlying issues, such as state consistency and automated retries, allowing developers to concentrate on core business logic rather than infrastructure. LittleHorse platform's architecture is centered around the LittleHorse Kernel (formerly the LittleHorse Server), the core engine responsible for executing defined processes (WfSpecs as WfRuns), managing state durably, and ensuring reliable execution. The Kernel is predominantly written in Java, making use of Apache Kafka as a durable write-ahead log, for state persistence and enabling robust recovery from failures. It is designed for diverse use cases including microservice orchestration, business process management, and agentic workflows. (Image taken from https://littlehorse.io) Workflow-as-Code is the primary approach to iterate with LittleHorse Kernel. By use of the LittleHorse SDKs, developers define the Workflow Specification (WfSpec), a reusable template outlining the sequence of operations, variable management, conditional branching, parallelism, and error handling strategies for a given process. Following a WfSpec example: import io.littlehorse.sdk.wfsdk.*; // Required imports public class KycWorkflow implements Workflow { @Override public String getName() { return \"kyc-workflow\"; } // Name of the WfSpec @Override public void workflow(WorkflowThread wf) { // Define workflow variables WfRunVariable customerInfoVar = wf.addVariable(\"customer-info\", VariableType.JSON); WfRunVariable verificationResultVar = wf.addVariable(\"verification-result\", VariableType.JSON); // Instruct the Kernel to execute a task named \"verify-identity-task\" // Input: customerInfoVar, Output captured in: verificationResultVar wf.execute(\"verify-identity-task\", customerInfoVar).output(verificationResultVar); // Define further steps, conditions, etc., based on verificationResultVar... // wf.execute(\"notify-customer-task\",...); } } Within a WfSpec, there are the Tasks, the individual units of work. A Task is declared via Task Definition (TaskDef), so the developer is able to implement the TaskDef business logic via a Task Method. Let's see a Java Task Method for \"verify-identity-task\": import io.littlehorse.sdk.worker.LHTaskMethod; public class VerificationTasks { @LHTaskMethod(\"verify-identity-task\") // Links method to the Task Definition public VerificationResult verifyIdentity(CustomerInfo customer) { System.out.println(\"Verifying identity for: \" + customer.getName()); //... verification logic... return new VerificationResult(true); // Return result object } } Task Workers, that are separate client applications using the LittleHorse SDK, are responsible for handling Task Methods pooling the LittleHorse kernel. When a WfSpec is being executed it is known as a Workflow Run (WfRun). Deployment options include an Open Source (OSS) Kernel (SSPLv1 license), the managed LittleHorse Cloud service, and LittleHorse For Kubernetes (LHK). Essential tools include the web-based Dashboard for monitoring , the lhctl Command-Line Interface, and language-specific SDKs. Founded in December 2021 by Colt McNealy, son of Sun Microsystems co-founder Scott McNealy, LittleHorse was open-sourced in 2023 to reflect the team's belief that software built by engineers, for engineers, should be accessible to all. Both Colt and Scott McNealy participated in the opening keynote at JavaOne 2025, titled \"Our World, Moved by Java\". More details about LittleHorse can be found in the LittleHorse QuickStart or GitHub repo. Developers willing to contribute with LittleHorse can find more details in the GitHub repository. About the Author Diogo Carleto",
  "image": "https://res.infoq.com/news/2025/04/littlehorse/en/headerimage/generatedHeaderImage-1745412529651.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003e\u003ca href=\"https://littlehorse.io/\"\u003eLittleHorse\u003c/a\u003e is a Java open-source platform designed to orchestrate distributed systems, addressing the challenges related to state management and the coordination of microservices, external APIs, and human tasks. It allows developers to define workflows programmatically using languages such as Java, Go, Python, C#, .NET; eliminating the need for specialized DSLs. The key capabilities include real-time observability, automated error recovery with retries, event-driven coordination, User Task integration, and developer SDKs.\u003c/p\u003e\n\n\u003cp\u003eModern distributed systems often introduce complexities in inter-service coordination, state management, and ensuring reliability. LittleHorse aims to provide intelligent workflow orchestration to manage these underlying issues, such as state consistency and automated retries, allowing developers to concentrate on core business logic rather than infrastructure.\u003c/p\u003e\n\n\u003cp\u003eLittleHorse platform\u0026#39;s architecture is centered around the LittleHorse Kernel (formerly the LittleHorse Server), the core engine responsible for executing defined processes (WfSpecs as WfRuns), managing state durably, and ensuring reliable execution. The Kernel is predominantly written in Java, making use of Apache Kafka as a durable write-ahead log, for state persistence and enabling robust recovery from failures. It is designed for diverse use cases including microservice orchestration, business process management, and agentic workflows.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" data-src=\"news/2025/04/littlehorse/en/resources/image1-1745410247025.png\" rel=\"\" share\"\"=\"\" share=\"\" src=\"https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/news/2025/04/littlehorse/en/resources/image1-1745410247025.png\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e(Image taken from \u003ca href=\"https://littlehorse.io/docs/server/concepts\"\u003ehttps://littlehorse.io\u003c/a\u003e)\u003c/p\u003e\n\n\u003cp\u003eWorkflow-as-Code is the primary approach to iterate with LittleHorse Kernel. By use of the LittleHorse SDKs, developers define the Workflow Specification (WfSpec), a reusable template outlining the sequence of operations, variable management, conditional branching, parallelism, and error handling strategies for a given process. Following a WfSpec example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eimport io.littlehorse.sdk.wfsdk.*; // Required imports\n\npublic class KycWorkflow implements Workflow {\n    @Override public String getName() { return \u0026#34;kyc-workflow\u0026#34;; } // Name of the WfSpec\n\n    @Override public void workflow(WorkflowThread wf) {\n        // Define workflow variables\n        WfRunVariable customerInfoVar = wf.addVariable(\u0026#34;customer-info\u0026#34;, VariableType.JSON);\n        WfRunVariable verificationResultVar = wf.addVariable(\u0026#34;verification-result\u0026#34;, VariableType.JSON);\n\n        // Instruct the Kernel to execute a task named \u0026#34;verify-identity-task\u0026#34;\n        // Input: customerInfoVar, Output captured in: verificationResultVar\n        wf.execute(\u0026#34;verify-identity-task\u0026#34;, customerInfoVar).output(verificationResultVar);\n\n        // Define further steps, conditions, etc., based on verificationResultVar...\n        // wf.execute(\u0026#34;notify-customer-task\u0026#34;,...);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWithin a WfSpec, there are the Tasks, the individual units of work. A Task is declared via Task Definition (TaskDef), so the developer is able to implement the TaskDef business logic via a Task Method. Let\u0026#39;s see a Java Task Method for \u0026#34;verify-identity-task\u0026#34;:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eimport io.littlehorse.sdk.worker.LHTaskMethod;\n\npublic class VerificationTasks {\n    @LHTaskMethod(\u0026#34;verify-identity-task\u0026#34;) // Links method to the Task Definition\n    public VerificationResult verifyIdentity(CustomerInfo customer) {\n        System.out.println(\u0026#34;Verifying identity for: \u0026#34; + customer.getName());\n        //... verification logic...\n        return new VerificationResult(true); // Return result object\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTask Workers, that are separate client applications using the LittleHorse SDK, are responsible for handling Task Methods pooling the LittleHorse kernel. When a WfSpec is being executed it is known as a Workflow Run (WfRun).\u003c/p\u003e\n\n\u003cp\u003eDeployment options include an Open Source (OSS) Kernel (SSPLv1 license), the managed LittleHorse Cloud service, and LittleHorse For Kubernetes (LHK). Essential tools include the web-based Dashboard for monitoring , the \u003ccode\u003elhctl\u003c/code\u003e Command-Line Interface, and language-specific SDKs.\u003c/p\u003e\n\n\u003cp\u003eFounded in December 2021 by Colt McNealy, son of Sun Microsystems co-founder Scott McNealy, LittleHorse was open-sourced in 2023 to reflect the team\u0026#39;s belief that software built by engineers, for engineers, should be accessible to all. Both Colt and Scott McNealy participated in the opening keynote at \u003ca href=\"https://www.infoq.com/news/2025/03/day-one-java-one-2025/\"\u003eJavaOne 2025\u003c/a\u003e, titled \u0026#34;Our World, Moved by Java\u0026#34;.\u003c/p\u003e\n\n\u003cp\u003eMore details about LittleHorse can be found in the \u003ca href=\"https://littlehorse.io/docs/getting-started/quickstart\"\u003eLittleHorse QuickStart\u003c/a\u003e or \u003ca href=\"https://github.com/littlehorse-enterprises/littlehorse\"\u003eGitHub repo\u003c/a\u003e. Developers willing to contribute with LittleHorse can find more details in the \u003ca href=\"https://github.com/littlehorse-enterprises/littlehorse/blob/master/local-dev/README.md\"\u003eGitHub repository\u003c/a\u003e.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Diogo-Carleto\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eDiogo Carleto\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-04-23T00:00:00Z",
  "modifiedTime": null
}
