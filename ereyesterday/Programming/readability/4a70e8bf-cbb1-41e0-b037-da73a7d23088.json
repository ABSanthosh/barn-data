{
  "id": "4a70e8bf-cbb1-41e0-b037-da73a7d23088",
  "title": "Rider 2025.2 EAP 7: Low-Level Exception Suppression and Other Updates for Debugging Games",
  "link": "https://blog.jetbrains.com/dotnet/2025/06/26/rider-2025-2-eap-7-low-level-exception-suppression/",
  "description": "Rider 2025.2 is shaping up to be an exciting release for game developers, no matter which engine you work with. Over the last few EAP builds, we’ve been rolling out targeted improvements to make debugging smoother, faster, and more reliable, whether you’re building with Unreal Engine, Unity, Godot, or custom C++ frameworks. In the latest […]",
  "author": "Sasha Korepanov",
  "published": "Thu, 26 Jun 2025 09:52:35 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "net-tools",
    "eap",
    "news",
    "releases",
    "rider",
    "game-developement",
    "gdscript",
    "godot",
    "unity",
    "unreal-engine"
  ],
  "byline": "",
  "length": 7883,
  "excerpt": "Rider 2025.2 is shaping up to be an exciting release for game developers, no matter which engine you work with. Over the last few EAP builds, we’ve been rolling out targeted improvements to make debug",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "Essential productivity kit for .NET and game developers .NET Tools Early Access Program News Releases RiderRider 2025.2 EAP 7: Low-Level Exception Suppression and Other Updates for Debugging Games Rider 2025.2 is shaping up to be an exciting release for game developers, no matter which engine you work with. Over the last few EAP builds, we’ve been rolling out targeted improvements to make debugging smoother, faster, and more reliable, whether you’re building with Unreal Engine, Unity, Godot, or custom C++ frameworks. In the latest EAP 7 build, we’ve added low-level exception suppression to give you more control when dealing with manual breakpoints and assertions commonly found in game projects. But that’s just one piece of the puzzle. Let’s take a look at how Rider 2025.2 is evolving into a more powerful, engine-agnostic debugger for your games. Low-level exception suppression in the native debugger In many C++ game engines, it’s common to use custom assertions that trigger manual breakpoints, for example, the assertions in Unreal Engine. Usually, it’s done via __debugbreak() or inline assembly with int3. It’s a handy trick: when such an assertion fires, your debugger stops right there, letting you inspect the issue on the spot. Sometimes, especially when debugging complex projects, you’d rather skip over the assertion and keep going without constantly pressing the resume. That’s where our new low-level exception suppression feature comes in. Depending on the platform, the int3 instruction triggers different types of exceptions or signals: On Windows, it raises a 0x80000003 exception. On macOS, it triggers EXC_BREAKPOINT. On Linux, it sends a SIGTRAP signal. We’ve made it possible to suppress these exceptions and signals across all platforms, so you can control when you want the debugger to stop and when you want it to move on. Global suppression Want to suppress a specific low-level exception entirely?Open Run | View Breakpoints and Exceptions…, hit the + button, select Low-Level Exceptions Suppressions, and checkmark the exceptions or signals you’d like to suppress. Line and address suppressions Want to suppress a specific low-level exception at a particular line or address? Think of this like a “reverse breakpoint”. To set it up, let the exception trigger once, then hover over the red lightning bolt icon. Right-click to open the context menu and then add suppression for that line or address. Left-click quickly adds suppression for the current line. A yellow lightning bolt indicates that suppression is active.  You can manage suppressions anytime in the Breakpoints settings (via Run | View Breakpoints and Exceptions…). Suppression by address can be handy if a low-level exception happens inside a library where source code isn’t available.An important detail: Rider doesn’t just ignore and skip the exception or signal triggered by int3; it replaces int3 with a nop in the debugging process. This means that such suppression works very fast and doesn’t affect performance.Related issues: RIDER-122587, RIDER-74532 Manual breakpoint adjustment A small but important detail: on x86, when int3 fires, the program counter moves to the next instruction, which might be the following line, several lines away, or even in a different file. That could be confusing during debugging. Good news: we’ve fixed that behavior! Rider now adjusts the program counter so it remains on the int3 instruction. That way, when an assertion triggers, the debugger shows the exact line where it happened, not somewhere random. Related issues: RIDER-123665, CPP-22000, RIDER-126143  The ability to pause all processes on a breakpoint Rider now includes an option to pause all attached native processes when a breakpoint is hit during multi-process debugging. This improves debugging consistency in complex scenarios, such as game development or distributed systems. The feature has been available since 2025.2 EAP 5, but it’s disabled by default. You can enable it by going to Settings/Preferences | Build, Execution, Deployment | Debugger and checking the Pause all native processes on breakpoint hit option. Additionally, Rider’s new Resume/Pause/Stop All Processes actions (found in the main menu under Run | Debugging Actions) make it easier to manage the state of multiple processes during debugging. You can search for these actions in Search Everywhere, assign hotkeys to them, or add them to the toolbar for quick access. Unity shader debugging with the new Frame Viewer plugin If you’re working with Unity, the new Frame Viewer plugin introduced in EAP 6 takes shader debugging to a new level by introducing source-level debugging for Unity shaders.  You can now inspect .rdc snapshots from RenderDoc, step through original ShaderLab code, set breakpoints, and analyze draw calls with vertex and pixel selection, texture previews, and shader-based filters.  The Frame Viewer plugin is currently only available for Unity projects on Windows. Major update to GDScript support Meanwhile, Rider 2025.2 brings a major upgrade to GDScript support for Godot developers, making the entire workflow more stable and integrated. GDScript support has been significantly upgraded by integrating the former third-party plugin directly into Rider. This update resolves SDK initialization issues, fixes missing references like Globals, improves icon rendering, and eliminates reliance on insecure SDK downloads. And that’s not all! These are just a few of the most recent enhancements to the game project debugging experience. If you haven’t been keeping up with the Early Access Program releases for Rider 2025.2, we encourage you to read through the changes we’ve introduced so far on this page.  Share your thoughts Whether you’re debugging low-level C++ code, stepping through Unity shaders, or building your next game in Godot, Rider 2025.2 aims to make the process faster and less frustrating. With improvements across debugging tools, process control, and engine-specific support, this release brings us one step closer to making Rider the go-to IDE for game development. If you download the latest EAP build and try these updates out for yourself, please share your experience with us. You can send us your opinions and suggestions through our usual feedback channels: here in the comments section, over on our issue tracker, or on our social media – X and Bluesky.  Subscribe to a monthly digest curated from the .NET Tools blog: Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/06/Social_Share_Blog_1280x720-2x-11-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/dotnet/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/Frame-1321314548.svg\" alt=\"Dotnet logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eEssential productivity kit for .NET and game developers\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/dotnet/category/net-tools/\"\u003e.NET Tools\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/dotnet/category/eap/\"\u003eEarly Access Program\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/dotnet/category/news/\"\u003eNews\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/dotnet/category/releases/\"\u003eReleases\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/dotnet/category/rider/\"\u003eRider\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eRider 2025.2 EAP 7: Low-Level Exception Suppression and Other Updates for Debugging Games\u003c/h2\u003e                    \u003cdiv\u003e\n                            \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/01/T0288D531-U02MS2N48LF-d752c9f04d23-512.png\" width=\"200\" height=\"200\" alt=\"Sasha Korepanov\" loading=\"lazy\"/\u003e\n                                                                                                                    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2022/07/F34E0F9B-D3F0-4DD4-B7C7-B11AF3FC6D25-200x200.jpeg\" width=\"200\" height=\"200\" alt=\"Sasha Ivanova\" loading=\"lazy\"/\u003e\n                                                                                                \u003c/p\u003e\n                            \n                        \u003c/div\u003e\n                    \n\u003cp\u003eRider 2025.2 is shaping up to be an exciting release for game developers, no matter which engine you work with. Over the last few EAP builds, we’ve been rolling out targeted improvements to make debugging smoother, faster, and more reliable, whether you’re building with Unreal Engine, Unity, Godot, or custom C++ frameworks.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn the latest EAP 7 build, we’ve added low-level exception suppression to give you more control when dealing with manual breakpoints and assertions commonly found in game projects. But that’s just one piece of the puzzle. Let’s take a look at how Rider 2025.2 is evolving into a more powerful, engine-agnostic debugger for your games.\u003c/p\u003e\n\n\n    \n\n\n\n\n\n\n\n\u003ch2\u003eLow-level exception suppression in the native debugger\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn many C++ game engines, it’s common to use custom assertions that trigger manual breakpoints, for example, \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/asserts-in-unreal-engine\" target=\"_blank\" rel=\"noopener\"\u003ethe assertions in Unreal Engine\u003c/a\u003e. Usually, it’s done via \u003ca href=\"https://learn.microsoft.com/en-us/cpp/intrinsics/debugbreak\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003e__debugbreak()\u003c/code\u003e\u003c/a\u003e or inline assembly with \u003ccode\u003eint3\u003c/code\u003e. It’s a handy trick: when such an assertion fires, your debugger stops right there, letting you inspect the issue on the spot. Sometimes, especially when debugging complex projects, you’d rather skip over the assertion and keep going without constantly pressing the resume. That’s where our new low-level exception suppression feature comes in.\u003c/p\u003e\n\n\n\n\u003cp\u003eDepending on the platform, the \u003ccode\u003eint3\u003c/code\u003e instruction triggers different types of exceptions or signals:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eOn Windows, it raises a \u003cstrong\u003e\u003ccode\u003e0x80000003\u003c/code\u003e \u003c/strong\u003eexception.\u003c/li\u003e\n\n\n\n\u003cli\u003eOn macOS, it triggers \u003cstrong\u003e\u003ccode\u003eEXC_BREAKPOINT\u003c/code\u003e\u003c/strong\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eOn Linux, it sends a \u003cstrong\u003e\u003ccode\u003eSIGTRAP\u003c/code\u003e \u003c/strong\u003esignal.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWe’ve made it possible to suppress these exceptions and signals across all platforms, so you can control when you want the debugger to stop and when you want it to move on.\u003c/p\u003e\n\n\n\n\u003ch3\u003eGlobal suppression\u003c/h3\u003e\n\n\n\n\u003cdiv\u003e\u003cp\u003eWant to suppress a specific low-level exception entirely?\u003c/p\u003e\u003cp\u003eOpen \u003cem\u003eRun | View Breakpoints and Exceptions…\u003c/em\u003e, hit the \u003cem\u003e+\u003c/em\u003e button, select \u003cem\u003eLow-Level Exceptions Suppressions\u003c/em\u003e, and checkmark the exceptions or signals you’d like to suppress.\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1490\" height=\"657\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/image5.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1487\" height=\"658\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/image6-3.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eLine and address suppressions\u003c/h3\u003e\n\n\n\n\u003cp\u003eWant to suppress a specific low-level exception at a particular line or address? Think of this like a “reverse breakpoint”. To set it up, let the exception trigger once, then hover over the red lightning bolt\u003cstrong\u003e \u003c/strong\u003eicon. Right-click to open the context menu and then add suppression for that line or address.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1802\" height=\"1514\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/image1-2.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eLeft-click quickly adds suppression for the current line.\u003c/p\u003e\n\n\n\n\u003cp\u003eA yellow lightning bolt indicates that suppression is active. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1839\" height=\"1184\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/image3-1.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou can manage suppressions anytime in the \u003cem\u003eBreakpoints\u003c/em\u003e settings (via \u003cem\u003eRun | View Breakpoints and Exceptions…\u003c/em\u003e).\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1999\" height=\"834\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/image4-1.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cdiv\u003e\u003cp\u003eSuppression by address can be handy if a low-level exception happens inside a library where source code isn’t available.\u003c/p\u003e\u003cp\u003eAn important detail: Rider doesn’t just ignore and skip the exception or signal triggered by \u003ccode\u003eint3\u003c/code\u003e; it replaces \u003ccode\u003eint3\u003c/code\u003e with a nop in the debugging process. This means that such suppression works very fast and doesn’t affect performance.\u003c/p\u003e\u003cp\u003eRelated issues: \u003ca href=\"https://youtrack.jetbrains.com/issue/RIDER-122587\" target=\"_blank\" rel=\"noopener\"\u003eRIDER-122587\u003c/a\u003e, \u003ca href=\"https://youtrack.jetbrains.com/issue/RIDER-74532\" target=\"_blank\" rel=\"noopener\"\u003eRIDER-74532\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003ch2\u003eManual breakpoint adjustment\u003c/h2\u003e\n\n\n\n\u003cp\u003eA small but important detail: on \u003ccode\u003ex86\u003c/code\u003e, when \u003ccode\u003eint3\u003c/code\u003e fires, the program counter moves to the next instruction, which might be the following line, several lines away, or even in a different file. That could be confusing during debugging.\u003c/p\u003e\n\n\n\n\u003cp\u003eGood news: we’ve fixed that behavior! Rider now adjusts the program counter so it remains on the \u003ccode\u003eint3\u003c/code\u003e instruction. That way, when an assertion triggers, the debugger shows the exact line where it happened, not somewhere random.\u003c/p\u003e\n\n\n\n\u003cp\u003eRelated issues: \u003ca href=\"https://youtrack.jetbrains.com/issue/RIDER-123665\" target=\"_blank\" rel=\"noopener\"\u003eRIDER-123665\u003c/a\u003e, \u003ca href=\"https://youtrack.jetbrains.com/issue/CPP-22000\" target=\"_blank\" rel=\"noopener\"\u003eCPP-22000\u003c/a\u003e, \u003ca href=\"https://youtrack.jetbrains.com/issue/RIDER-126143\" target=\"_blank\" rel=\"noopener\"\u003eRIDER-126143\u003c/a\u003e \u003c/p\u003e\n\n\n\n\u003ch2\u003eThe ability to pause all processes on a breakpoint\u003c/h2\u003e\n\n\n\n\u003cp\u003eRider now includes an option to pause all attached native processes when a breakpoint is hit during multi-process debugging. This improves debugging consistency in complex scenarios, such as game development or distributed systems. The feature has been available since 2025.2 EAP 5, but it’s disabled by default. You can enable it by going to \u003cem\u003eSettings/Preferences | Build, Execution, Deployment | Debugger \u003c/em\u003eand checking the \u003cem\u003ePause all native processes on breakpoint hit\u003c/em\u003e option.\u003c/p\u003e\n\n\n\n\u003cp\u003eAdditionally, Rider’s new \u003cem\u003eResume/Pause/Stop All Processes\u003c/em\u003e actions (found in the main menu under \u003cem\u003eRun | Debugging Actions\u003c/em\u003e) make it easier to manage the state of multiple processes during debugging. You can search for these actions in \u003cem\u003eSearch Everywhere\u003c/em\u003e, assign hotkeys to them, or add them to the toolbar for quick access.\u003c/p\u003e\n\n\n\n\u003ch2\u003eUnity shader debugging with the new Frame Viewer plugin\u003c/h2\u003e\n\n\n\n\u003cp\u003eIf you’re working with Unity, the new Frame Viewer plugin introduced in EAP 6 takes shader debugging to a new level by introducing source-level debugging for Unity shaders. \u003c/p\u003e\n\n\n\n\u003cp\u003eYou can now inspect .rdc snapshots from RenderDoc, step through original ShaderLab code, set breakpoints, and analyze draw calls with vertex and pixel selection, texture previews, and shader-based filters. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1200\" height=\"1002\" data-id=\"577947\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/252-frameviewer-b.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1200\" height=\"1002\" data-id=\"577949\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/252-frameviewer-debugger.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe Frame Viewer plugin is currently only available for Unity projects on Windows.\u003c/p\u003e\n\n\n\n\u003ch2\u003eMajor update to GDScript support\u003c/h2\u003e\n\n\n\n\u003cp\u003eMeanwhile, Rider 2025.2 brings a major upgrade to GDScript support for Godot developers, making the entire workflow more stable and integrated. GDScript support has been significantly upgraded by integrating the former third-party plugin directly into Rider. This update resolves SDK initialization issues, fixes missing references like Globals, improves icon rendering, and eliminates reliance on insecure SDK downloads.\u003c/p\u003e\n\n\n\n\u003ch2\u003eAnd that’s not all!\u003c/h2\u003e\n\n\n\n\u003cp\u003eThese are just a few of the most recent enhancements to the game project debugging experience. If you haven’t been keeping up with the Early Access Program releases for Rider 2025.2, we encourage you to read through the changes we’ve introduced so far \u003ca href=\"https://www.jetbrains.com/rider/nextversion/\" target=\"_blank\" rel=\"noopener\"\u003eon this page\u003c/a\u003e. \u003c/p\u003e\n\n\n\n\u003ch2\u003eShare your thoughts\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhether you’re debugging low-level C++ code, stepping through Unity shaders, or building your next game in Godot, Rider 2025.2 aims to make the process faster and less frustrating. With improvements across debugging tools, process control, and engine-specific support, this release brings us one step closer to making Rider \u003cem\u003ethe\u003c/em\u003e go-to IDE for game development.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you download the latest EAP build and try these updates out for yourself, please share your experience with us. You can send us your opinions and suggestions through our usual feedback channels: here in the comments section, over on our \u003ca href=\"https://youtrack.jetbrains.com/issues/RIDER\" target=\"_blank\" rel=\"noopener\"\u003eissue tracker\u003c/a\u003e, or on our social media – \u003ca href=\"https://x.com/JetBrainsRider\" target=\"_blank\"\u003eX\u003c/a\u003e and \u003ca href=\"https://bsky.app/profile/jetbrains-rider.bsky.social\" target=\"_blank\" rel=\"noopener\"\u003eBluesky\u003c/a\u003e. \u003c/p\u003e\n\n\n    \n\n\n\n\n                    \n                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to a monthly digest curated from the .NET Tools blog:\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": null,
  "modifiedTime": null
}
