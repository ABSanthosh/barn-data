{
  "id": "7313051a-d68a-4e42-acc7-00094c132d07",
  "title": "When to choose GitHub-Hosted runners or self-hosted runners with GitHub Actions",
  "link": "https://github.blog/enterprise-software/ci-cd/when-to-choose-github-hosted-runners-or-self-hosted-runners-with-github-actions/",
  "description": "Comparing GitHub-hosted vs self-hosted runners for your CI/CD workflows? This deep dive explores important factors to consider when making this critical infrastructure decision for your development team. The post When to choose GitHub-Hosted runners or self-hosted runners with GitHub Actions appeared first on The GitHub Blog.",
  "author": "kenmuse",
  "published": "Tue, 15 Apr 2025 16:00:22 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "CI/CD",
    "Enterprise software",
    "actions",
    "best practices",
    "GitHub Actions",
    "GitHub-hosted runners"
  ],
  "byline": "kenmuse",
  "length": 12833,
  "excerpt": "This deep dive explores important factors to consider when making this critical infrastructure decision for your development team.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "Whether it’s building, testing, or deploying code, automating manual processes is key to improving developer experience and achieving a successful DevOps strategy. On GitHub, you can use GitHub Actions to not only implement your CI/CD pipeline, but also automate other processes both on and off GitHub. When you are adopting GitHub Actions on GitHub Enterprise Cloud, you can choose between GitHub-hosted runners and self-hosted runners to run your workloads, and each has its pros and cons. In this post, we’ll compare GitHub-hosted runners with self-hosted runners across five areas to help you determine which type best fits your GitHub Actions adoption strategy. What are GitHub-hosted runners and self-hosted runners? GitHub-hosted runners and self-hosted runners are based on the same open-source software and both support macOS, Windows, and Linux. But they have many differences. GitHub-hosted runners are fully managed on GitHub’s infrastructure using pre-configured Windows, Linux, and macOS virtual machines. In addition to offering standard runners for typical workloads, hosted runners offer larger runners with more resources (memory, CPU, and storage), custom images, static IP ranges, and Azure Virtual Network integration for enhanced security control. Self-hosted runners operate on your own infrastructure, whether on-premises or in the cloud. You manage all aspects—configuration, security, and scaling. They also allow you to operate runners in places you couldn’t otherwise—for example, on GitHub Enterprise Server or on custom hardware. They can also be the only way to implement certain compliance requirements, especially when working with highly secured systems. Both options offer distinct advantages depending on your specific needs and resources. Let’s explore when GitHub-hosted runners may be the right choice for your projects, and when it may be better to use self-hosted runners. Fully managed or self-managed? A key distinction between these two options is where they’re hosted, as we’ve pointed out. But that choice comes with several implications. GitHub-hosted runners provide managed infrastructure with pools of on-demand virtual machines (VMs) that are automatically secured and updated. The environments are ephemeral, with the disks reimaged after each job, preventing files from previous jobs from affecting subsequent runs. The VMs are optimized for GitHub Actions, with pre-installed software and tools, including the latest versions of GitHub CLI, Docker, and common development platforms to ensure fast start times and avoid rate limits. With GitHub-hosted runners, you can jump right in and start building workflows. There’s nothing to configure or secure before you start, making them ideal when you want to get started quickly. And we all prefer to spend more time on code than infrastructure, right? Self-hosted runners offer you complete flexibility in defining your solution, but also means you are responsible for managing the infrastructure, images, caches, and security, and monitoring availability and usage against GitHub’s rate limits. This requires expertise in GitHub Actions architecture, VM and container image building, and network and infrastructure management. If your core business offering is scalable infrastructure solutions or Kubernetes, self-hosted runners may make sense. Let’s take a closer look. Scalability To remain productive, it’s important to have highly-available resources available on demand, especially for CI/CD workloads, where waiting for a job to run may mean you’re blocked from working on other tasks. In fact, a single wasted hour each week can cost a company over $4,000 a year per developer! But scaling highly available, on-demand resources is hard. Even with a well-designed cloud infrastructure, it takes time to provision new virtual machines. You need systems in multiple regions to maintain up time, with 20-25% spare capacity to scale quickly and handle unexpected system failures. GitHub-hosted runners take advantage of Microsoft’s deep data center and cloud expertise and have dedicated teams to meet our service level agreement (SLA) of 99.9% availability. And that’s without any expertise on your part. In fact, many teams consider self-hosted runners in hopes of beating this availability, but it turns out that’s not even technically possible, as all runnings depend on the same services and control plane. That said, there are conditions where self-hosted runners may work for you. Self-hosted runners may meet your needs if you need a fixed number of servers, are primarily focused on deployment to non-cloud resources, and don’t need to scale on demand. Just remember that the instances are not natively ephemeral, so you’ll need to have a strategy to keep the instances free from artifacts created by earlier runs. Self-hosted runners also lack automatic scaling capabilities; they require a scaling solution to be able to support large teams or create new instances dynamically. GitHub’s Actions Runner Controller (ARC) offers a solution, but it has limitations as it requires Kubernetes expertise and only supports Linux runners. Kubernetes relies on containers instead of VMs, which can require you to troubleshoot resource contention and scaling issues. ARC can also offer high availability by having multiple clusters. As we noted before, if your primary business is hosting and managing Kubernetes clusters, then ARC may be the right approach. ARC does not support macOS or Windows workloads, and both environments present a number of limitations. For example, on macOS, you are required to use Apple hardware, you are limited to two VMs per machine, and containerizing the Apple runtime is not supported. For Windows, virtual machines are supported, but you need a custom orchestrator for scaling the instances. While you can create Windows containers and manage them with Kubernetes, the containers have slow startup times and may not support some of the necessary development and testing tools. In short, we recommend GitHub-hosted runners for both macOS and Windows workloads. Security Security is critical for CI/CD processes, since they may require access to internal or production resources, and builds often use third-party libraries, runtimes, and tools, which can create a large attack surface if not properly secured. GitHub-hosted runners provide built-in security through a defense-in-depth, zero-trust approach. VMs provide network isolation, preventing exposure to other runners and corporate resources. In fact, access to corporate or cloud resources requires elevating privileges (we recommend OIDC). Their ephemeral nature eliminates code persistence and prevents application execution after job completion, reducing unauthorized access risks. Storage disks for hosted runners are encrypted at rest, ensuring the code is protected on the disk. All communications are encrypted to GitHub, and deployments to Microsoft Azure are routed through the Azure backbone, minimizing transits through the public internet. We provide regular security updates to both operating systems and runner software. The minimized attack surface and reduced risk of security breaches are key factors in the Department of Defense DevSecOps Reference Design’s recommendation to prefer GitHub-hosted runners for workloads up to Impact Level 5. Self-hosted runners shift security responsibility entirely to you, requiring management of network, infrastructure, images, containers, and caches—that’s a lot of work. You also need to keep everything up to date, as runners connected to GitHub Enterprise Cloud will not be able to connect if they are more than 30 days behind the current release. Not to mention, if you operate runners within your network environment with access to corporate resources and production environments, you’ll want to implement a zero-trust, defense-in-depth strategy with time-limited resource access, which demands a high level of network security expertise. Finally, you’ll need to implement and keep updated both a tool cache and an Actions archive cache. Otherwise, you’re likely to encounter our rate limits as you scale up. Troubleshooting Keeping you productive means that problems with workflows or jobs—lack of resources, network issues, outages—need to be solved quickly. As a result, it’s important to have a support strategy. GitHub-hosted runners come with 24/7 support across all time zones, with premium plans offering dedicated reliability engineers and rapid 30-minute response times for critical issues. This eliminates the need for infrastructure troubleshooting on your part. GitHub handles all runner environment issues, from performance problems to queue times, letting you focus on development while we roll up our sleeves, figure out the problems, and get them fixed. Self-hosted runners, however, shift first-level support responsibility to you, which means someone will have to troubleshoot performance, network, or queueing issues when they happen, leaving less time for the fun coding stuff. 🙁 Not only that, but GitHub can only assist with the Actions service itself; we cannot assist with your infrastructure, Kubernetes clusters, or custom orchestration solutions. So if they figure out the issue is with your system, you’ll be on your own to solve it. Without sufficient planning, you can spend a lot of time waiting for a solution that lets you get back to writing and deploying code. That can be a big price to pay for self-hosted runners. Cost management Finally, there’s the issue of cost. If you are offering Kubernetes or infrastructure management solutions, self-hosted runners may have some advantages. If not, then GitHub-hosted runners are likely the answer here too. GitHub-hosted runners operate on a pay-as-you-go model with no upfront costs or commitments. Teams optimize expenses through workflow improvements and appropriate runner selection. In addition, there are built-in cost savings. For example, GitHub doesn’t charge network egress fees—a significant advantage when working with large container images on cloud platforms. GitHub also has a partnership with Docker that allows unlimited image pulls from Docker Hub by GitHub-hosted runners, which often eliminates the need to create a pass-through registry or purchase business licenses for your CI/CD processes. Maintaining, supporting, and securing the environment is handled by GitHub, avoiding additional staff and service expenses. Finally, Enterprise accounts benefit from 50,000 free monthly minutes for standard runners. Self-hosted runners, as in other areas, means organizations assume responsibility for all infrastructure, network, storage, security, and support costs. This gives you a lot of flexibility in defining the environment, right-sizing your resources, and customizing the networking. While per-minute virtual machine expenses might initially seem lower, the total ownership cost can (and often does) exceed GitHub-hosted solutions when accounting for these additional support costs. Which runner is best for you? Choosing the right runner depends on your specific needs. Self-hosted runners are most suitable when using GitHub Enterprise Server (which lacks hosted runners), if your core business involves managing infrastructure or Kubernetes, or when you have compliance requirements not met by GitHub Enterprise Cloud with data residency. Scaling and ephemerality challenges make self-hosting less ideal for Windows and macOS workloads. If self-hosting is necessary, consider a hybrid approach and use self-hosted runners just for the specific workloads where they are needed. For most developers and the vast majority of scenarios, unless you have very unique requirements or are willing to deeply invest in infrastructure to keep your CI/CD system humming, GitHub-hosted runners are likely your best option. They’re especially beneficial for those new to GitHub Actions and they let you spend your time focused on business value, new ideas, and writing code—instead of managing runners. Tags: actions best practices CI/CD GitHub Actions GitHub-hosted runners Written by Ken is a Staff DevOps Architect on the FastTrack team at GitHub. He is a 4-time Microsoft Azure MVP and a Microsoft Certified Trainer, and he was both an ALM | DevOps Ranger and a member of the Microsoft Azure Advisors. Ken is a frequent community speaker and has appeared at GitHub Universe, VSLive!, DevOps World, SQLSaturday, All Day DevOps, Global Azure, and TAG DevOps panels. When not speaking or coding, Ken enjoys playing multiple instruments and composing.",
  "image": "https://github.blog/wp-content/uploads/2025/04/wallpaper_github_generic_3.png?fit=1920%2C1080",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eWhether it’s building, testing, or deploying code, automating manual processes is key to improving developer experience and achieving a successful DevOps strategy.\u003c/p\u003e\n\u003cp\u003eOn GitHub, you can use \u003ca href=\"https://github.com/features/actions\"\u003eGitHub Actions\u003c/a\u003e to not only implement your CI/CD pipeline, but also \u003ca href=\"https://github.blog/engineering/issueops-automate-ci-cd-and-more-with-github-issues-and-actions/\"\u003eautomate other processes\u003c/a\u003e both on and off GitHub. When you are adopting GitHub Actions on GitHub Enterprise Cloud, you can choose between GitHub-hosted runners and self-hosted runners to run your workloads, and each has its pros and cons.\u003c/p\u003e\n\u003cp\u003eIn this post, we’ll compare GitHub-hosted runners with self-hosted runners across five areas to help you determine which type best fits your GitHub Actions adoption strategy.\u003c/p\u003e\n\u003ch2 id=\"what-are-github-hosted-runners-and-self-hosted-runners\" id=\"what-are-github-hosted-runners-and-self-hosted-runners\"\u003eWhat are GitHub-hosted runners and self-hosted runners?\u003ca href=\"#what-are-github-hosted-runners-and-self-hosted-runners\" aria-label=\"What are GitHub-hosted runners and self-hosted runners?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGitHub-hosted runners and self-hosted runners are based on the same open-source software and both support macOS, Windows, and Linux. But they have many differences.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGitHub-hosted runners\u003c/strong\u003e are fully managed on GitHub’s infrastructure using pre-configured Windows, Linux, and macOS virtual machines. In addition to offering standard runners for typical workloads, hosted runners offer larger runners with more resources (memory, CPU, and storage), custom images, static IP ranges, and Azure Virtual Network integration for enhanced security control.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSelf-hosted runners\u003c/strong\u003e operate on your own infrastructure, whether on-premises or in the cloud. You manage all aspects—configuration, security, and scaling. They also allow you to operate runners in places you couldn’t otherwise—for example, on GitHub Enterprise Server or on custom hardware. They can also be the only way to implement certain compliance requirements, especially when working with highly secured systems.\u003c/p\u003e\n\u003cp\u003eBoth options offer distinct advantages depending on your specific needs and resources. Let’s explore when GitHub-hosted runners may be the right choice for your projects, and when it may be better to use self-hosted runners.\u003c/p\u003e\n\u003ch2 id=\"fully-managed-or-self-managed\" id=\"fully-managed-or-self-managed\"\u003eFully managed or self-managed?\u003ca href=\"#fully-managed-or-self-managed\" aria-label=\"Fully managed or self-managed?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eA key distinction between these two options is where they’re hosted, as we’ve pointed out. But that choice comes with several implications.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGitHub-hosted runners\u003c/strong\u003e provide managed infrastructure with pools of on-demand virtual machines (VMs) that are automatically secured and updated. The environments are ephemeral, with the disks reimaged after each job, preventing files from previous jobs from affecting subsequent runs. The VMs are optimized for GitHub Actions, with pre-installed software and tools, including the latest versions of GitHub CLI, Docker, and common development platforms to ensure fast start times and avoid rate limits.\u003c/p\u003e\n\u003cp\u003eWith GitHub-hosted runners, you can jump right in and start building workflows. There’s nothing to configure or secure before you start, making them ideal when you want to get started quickly. And we all prefer to spend more time on code than infrastructure, right?\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSelf-hosted runners\u003c/strong\u003e offer you complete flexibility in defining your solution, but also means you are responsible for managing the infrastructure, images, caches, and security, and monitoring availability and usage against GitHub’s rate limits. This requires expertise in GitHub Actions architecture, VM and container image building, and network and infrastructure management. If your core business offering is scalable infrastructure solutions or Kubernetes, self-hosted runners may make sense.\u003c/p\u003e\n\u003cp\u003eLet’s take a closer look.\u003c/p\u003e\n\u003ch2 id=\"scalability\" id=\"scalability\"\u003eScalability\u003ca href=\"#scalability\" aria-label=\"Scalability\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eTo remain productive, it’s important to have highly-available resources available on demand, especially for CI/CD workloads, where waiting for a job to run may mean you’re blocked from working on other tasks. In fact, a single wasted hour each week can cost a company over $4,000 a year per developer!\u003c/p\u003e\n\u003cp\u003eBut scaling highly available, on-demand resources is hard. Even with a well-designed cloud infrastructure, it takes time to provision new virtual machines. You need systems in multiple regions to maintain up time, with 20-25% spare capacity to scale quickly and handle unexpected system failures.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGitHub-hosted runners\u003c/strong\u003e take advantage of Microsoft’s deep data center and cloud expertise and have dedicated teams to meet our \u003ca href=\"https://github.com/customer-terms/github-online-services-sla\"\u003eservice level agreement (SLA)\u003c/a\u003e of 99.9% availability. And that’s without any expertise on your part. In fact, many teams consider self-hosted runners in hopes of beating this availability, but it turns out that’s \u003ca href=\"https://www.kenmuse.com/blog/understanding-the-sla-of-arc/\"\u003enot even technically possible\u003c/a\u003e, as all runnings depend on the same services and control plane. That said, there are conditions where self-hosted runners may work for you.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSelf-hosted runners\u003c/strong\u003e may meet your needs if you need a fixed number of servers, are primarily focused on deployment to non-cloud resources, and don’t need to scale on demand. Just remember that the instances are not natively ephemeral, so you’ll need to have a strategy to keep the instances free from artifacts created by earlier runs. Self-hosted runners also lack automatic scaling capabilities; they require a scaling solution to be able to support large teams or create new instances dynamically.\u003c/p\u003e\n\u003cp\u003eGitHub’s \u003ca href=\"https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-actions-runner-controller\"\u003eActions Runner Controller (ARC)\u003c/a\u003e offers a solution, but it has limitations as it requires Kubernetes expertise and only supports Linux runners. Kubernetes relies on containers instead of VMs, which can require you to troubleshoot resource contention and scaling issues. ARC can also offer high availability by having multiple clusters. As we noted before, if your primary business is hosting and managing Kubernetes clusters, then ARC may be the right approach.\u003c/p\u003e\n\u003cp\u003eARC does not support macOS or Windows workloads, and both environments present a number of limitations. For example, on macOS, you are required to use Apple hardware, you are limited to two VMs per machine, and containerizing the Apple runtime is not supported. For Windows, virtual machines are supported, but you need a custom orchestrator for scaling the instances. While you can create Windows containers and manage them with Kubernetes, the containers have slow startup times and may not support some of the necessary development and testing tools.\u003c/p\u003e\n\u003cp\u003eIn short, we recommend GitHub-hosted runners for both macOS and Windows workloads.\u003c/p\u003e\n\u003ch2 id=\"security\" id=\"security\"\u003eSecurity\u003ca href=\"#security\" aria-label=\"Security\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSecurity is critical for CI/CD processes, since they may require access to internal or production resources, and builds often use third-party libraries, runtimes, and tools, which can create a large attack surface if not properly secured.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGitHub-hosted runners\u003c/strong\u003e provide built-in security through a defense-in-depth, zero-trust approach. VMs provide network isolation, preventing exposure to other runners and corporate resources. In fact, access to corporate or cloud resources requires elevating privileges (we recommend \u003ca href=\"https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect\"\u003eOIDC\u003c/a\u003e). Their ephemeral nature eliminates code persistence and prevents application execution after job completion, reducing unauthorized access risks.\u003c/p\u003e\n\u003cp\u003eStorage disks for hosted runners are encrypted at rest, ensuring the code is protected on the disk. All communications are encrypted to GitHub, and deployments to Microsoft Azure are routed through the Azure backbone, minimizing transits through the public internet. We provide regular security updates to both operating systems and runner software. The minimized attack surface and reduced risk of security breaches are key factors in the Department of Defense \u003ca href=\"https://dodcio.defense.gov/Portals/0/Documents/Library/DoDRefDesignCloudGithub.pdf\"\u003eDevSecOps Reference Design’s\u003c/a\u003e recommendation to prefer GitHub-hosted runners for workloads up to Impact Level 5.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSelf-hosted runners\u003c/strong\u003e shift security responsibility entirely to you, requiring management of network, infrastructure, images, containers, and caches—that’s a lot of work. You also need to keep everything up to date, as runners connected to GitHub Enterprise Cloud will not be able to connect if they are \u003ca href=\"https://docs.github.com/en/enterprise-cloud@latest/actions/hosting-your-own-runners/managing-self-hosted-runners/autoscaling-with-self-hosted-runners#controlling-runner-software-updates-on-self-hosted-runners\"\u003emore than 30 days behind\u003c/a\u003e the current release.\u003c/p\u003e\n\u003cp\u003eNot to mention, if you operate runners within your network environment with access to corporate resources and production environments, you’ll want to implement a zero-trust, defense-in-depth strategy with time-limited resource access, which demands a high level of network security expertise.\u003c/p\u003e\n\u003cp\u003eFinally, you’ll need to implement and keep updated both a \u003ca href=\"https://docs.github.com/en/enterprise-server@3.16/admin/managing-github-actions-for-your-enterprise/managing-access-to-actions-from-githubcom/setting-up-the-tool-cache-on-self-hosted-runners-without-internet-access\"\u003etool cache\u003c/a\u003e and an \u003ca href=\"https://www.kenmuse.com/blog/building-github-actions-runner-images-with-an-action-archive-cache/\"\u003eActions archive cache\u003c/a\u003e. Otherwise, you’re likely to encounter our rate limits as you scale up.\u003c/p\u003e\n\u003ch2 id=\"troubleshooting\" id=\"troubleshooting\"\u003eTroubleshooting\u003ca href=\"#troubleshooting\" aria-label=\"Troubleshooting\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eKeeping you productive means that problems with workflows or jobs—lack of resources, network issues, outages—need to be solved quickly. As a result, it’s important to have a support strategy.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGitHub-hosted runners\u003c/strong\u003e come with 24/7 \u003ca href=\"https://docs.github.com/en/support/learning-about-github-support/about-github-support\"\u003esupport\u003c/a\u003e across all time zones, with premium plans offering dedicated reliability engineers and rapid 30-minute response times for critical issues. This eliminates the need for infrastructure troubleshooting on your part. GitHub handles all runner environment issues, from performance problems to queue times, letting you focus on development while we roll up our sleeves, figure out the problems, and get them fixed.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSelf-hosted runners\u003c/strong\u003e, however, shift first-level support responsibility to you, which means someone will have to troubleshoot performance, network, or queueing issues when they happen, leaving less time for the fun coding stuff. 🙁\u003c/p\u003e\n\u003cp\u003eNot only that, but GitHub can only assist with the Actions service itself; we cannot assist with your infrastructure, Kubernetes clusters, or custom orchestration solutions. So if they figure out the issue is with your system, you’ll be on your own to solve it. Without sufficient planning, you can spend a lot of time waiting for a solution that lets you get back to writing and deploying code. That can be a big price to pay for self-hosted runners.\u003c/p\u003e\n\u003ch2 id=\"cost-management\" id=\"cost-management\"\u003eCost management\u003ca href=\"#cost-management\" aria-label=\"Cost management\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFinally, there’s the issue of cost. If you are offering Kubernetes or infrastructure management solutions, self-hosted runners may have some advantages. If not, then GitHub-hosted runners are likely the answer here too.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGitHub-hosted runners\u003c/strong\u003e operate on a pay-as-you-go model with no upfront costs or commitments. Teams optimize expenses through workflow improvements and appropriate runner selection. In addition, there are built-in cost savings. For example, GitHub doesn’t charge network egress fees—a significant advantage when working with large container images on cloud platforms. GitHub also has a partnership with Docker that allows unlimited image pulls from Docker Hub by GitHub-hosted runners, which often eliminates the need to create a pass-through registry or purchase business licenses for your CI/CD processes. Maintaining, supporting, and securing the environment is handled by GitHub, avoiding additional staff and service expenses. Finally, Enterprise accounts benefit from 50,000 free monthly minutes for standard runners.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSelf-hosted runners\u003c/strong\u003e, as in other areas, means organizations assume responsibility for all infrastructure, network, storage, security, and support costs. This gives you a lot of flexibility in defining the environment, right-sizing your resources, and customizing the networking. While per-minute virtual machine expenses might initially seem lower, the total ownership cost can (and often does) exceed GitHub-hosted solutions when accounting for these additional support costs.\u003c/p\u003e\n\u003ch2 id=\"which-runner-is-best-for-you\" id=\"which-runner-is-best-for-you\"\u003eWhich runner is best for you?\u003ca href=\"#which-runner-is-best-for-you\" aria-label=\"Which runner is best for you?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eChoosing the right runner depends on your specific needs. Self-hosted runners are most suitable when using GitHub Enterprise Server (which lacks hosted runners), if your core business involves managing infrastructure or Kubernetes, or when you have compliance requirements not met by GitHub Enterprise Cloud with data residency. Scaling and ephemerality challenges make self-hosting less ideal for Windows and macOS workloads. If self-hosting is necessary, consider a hybrid approach and use self-hosted runners just for the specific workloads where they are needed.\u003c/p\u003e\n\u003cp\u003eFor most developers and the vast majority of scenarios, unless you have very unique requirements or are willing to deeply invest in infrastructure to keep your CI/CD system humming, GitHub-hosted runners are likely your best option. They’re especially beneficial for those new to GitHub Actions and they let you spend your time focused on business value, new ideas, and writing code—instead of managing runners.\u003c/p\u003e\n\n\t\n\u003csection\u003e\n\t\u003chr/\u003e\n\t\u003cdiv\u003e\n\t\t\u003ch2\u003eTags:\u003c/h2\u003e\n\t\t\u003cul\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/actions/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tactions\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/best-practices/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tbest practices\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/ci-cd/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tCI/CD\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/github-actions/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tGitHub Actions\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/github-hosted-runners/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tGitHub-hosted runners\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\u003c/ul\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/5390980?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/5390980?v=4\u0026amp;s=200\" alt=\"kenmuse\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eKen is a Staff DevOps Architect on the FastTrack team at GitHub. He is a 4-time Microsoft Azure MVP and a Microsoft Certified Trainer, and he was both an ALM | DevOps Ranger and a member of the Microsoft Azure Advisors. Ken is a frequent community speaker and has appeared at GitHub Universe, VSLive!, DevOps World, SQLSaturday, All Day DevOps, Global Azure, and TAG DevOps panels. When not speaking or coding, Ken enjoys playing multiple instruments and composing.\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2025-04-15T16:00:22Z",
  "modifiedTime": null
}
