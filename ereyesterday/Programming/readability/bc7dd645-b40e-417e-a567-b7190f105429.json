{
  "id": "bc7dd645-b40e-417e-a567-b7190f105429",
  "title": "How to use OCI images as the source of truth for continuous delivery",
  "link": "https://about.gitlab.com/blog/2025/02/19/how-to-use-oci-images-as-the-source-of-truth-for-continuous-delivery",
  "description": "",
  "author": "Daniel Helfand",
  "published": "2025-02-19T00:00:00.000Z",
  "source": "https://about.gitlab.com/atom.xml",
  "categories": null,
  "byline": "Daniel Helfand",
  "length": 13797,
  "excerpt": "Discover the benefits of using Open Container Initiative images as part of GitOps workflows and the many features GitLab offers to simplify deployments to Kubernetes.",
  "siteName": "GitLab",
  "favicon": "https://about.gitlab.com/blog/nuxt-images/ico/favicon-192x192.png?cache=2022041",
  "text": "Is GitOps still GitOps if you are not using a git repository as your deployment artifact? While git remains central to GitOps workflows, storing infrastructure definitions as Open Container Initiative (OCI) artifacts in container registries has seen a rise in adoption as the source for GitOps deployments. In this article, we will dive deeper into the ideas behind this trend and how GitLab features support this enhancement to GitOps workflows. What is GitOps? The OpenGitOps project has defined four principles for the practice of GitOps: A system managed by GitOps must have its desired state expressed declaratively. Desired state is stored in a way that enforces immutability and versioning, and retains a complete version history. Software agents automatically pull the desired state declarations from the source. Software agents continuously observe actual system state and attempt to apply the desired state. An example of GitOps is storing the Kubernetes manifests for a microservice in a GitLab project. Those Kubernetes resources are then continuously reconciled by a controller running on the Kubernetes cluster where the microservice is deployed to. This allows engineers to manage infrastructure using the same workflows as working with regular code, such as opening merge requests to make and review changes and versioning changes. GitOps also has operational benefits such as preventing configuration drift and helps engineers audit what changes led to certain outcomes with deployments. Benefits and limitations of git in GitOps workflows While git is an essential piece of GitOps workflows, git repositories were not designed to be deployed by GitOps controllers. Git does provide the ability for engineers to collaborate on infrastructure changes and audit these changes later on, but controllers do not need to download an entire git repository for a successful deployment. GitOps controllers simply need the infrastructure defined for a particular environment. Additionally, an important piece of the deployment process is to sign and verify deployments to assure deployment changes to an environment are coming from a trusted source. While git commits can be signed and verified by GitOps controllers, commits may also capture other details not related to the deployment itself (e.g., documentation changes, updates to other environments, and git repository restructuring) or not enough of the deployment picture as a deployment may consist of multiple commits. This again feels like a case this git feature wasn’t designed for. Another challenging aspect of git in GitOps workflows is that it can sometimes lead to more automation than expected. Soon after merging a change to the watched branch, it will be deployed. There are no controls in the process outside of git. How can you make sure that nothing gets deployed on a Friday late afternoon? What if teams responsible for deployment do not have permissions to merge changes in certain GitLab projects? Using OCI images adds a pipeline into the process, including all the delivery control features, like approvals or deploy freezes. OCI images The Open Container Initiative has helped to define standards around container formats. While most engineers are familiar with building Dockerfiles into container images, many may not be as familiar with storing Kubernetes manifests in a container registry. Because GitLab’s Container Registry is OCI compliant, it allows for users to push Kubernetes manifests for a particular environment to a container registry. GitOps controllers, such as Flux CD, can use the manifests stored in this OCI artifact instead of needing to clone an entire git repository. Often in GitOps workflows, a git repository can include the infrastructure definitions for all environments that a microservice will be deployed to. By packaging the Kubernetes manifests for only a specific environment, Flux CD can download the minimum files needed to carry out a deployment to a specific environment. Security benefits of using OCI artifacts As mentioned previously, signing and verifying the artifacts to be deployed to an environment adds an additional layer of security for software projects. After Kubernetes manifests are pushed to a container registry, a tool like Sigstore Cosign can be used to sign the OCI image with a private key that can be securely stored in a GitLab project as a CI/CD variable. Flux CD can then use a public key stored on a Kubernetes cluster to verify that a deployment is coming from a trusted source. Using GitLab to push and sign OCI images GitLab offers many features that help simplify the process of packaging, signing, and deploying OCI images. A common way to structure GitLab projects with GitOps workflows is to have separate GitLab projects for microservices’ code and a single infrastructure repository for all microservices. If an application is composed of n microservices, this would require having n +1 GitLab projects for an application. The artifact produced by a code project is usually a container image that will be used to package the application. The infrastructure or delivery project will contain the Kubernetes manifests defining all the resources required to scale and serve traffic to each microservice. The artifact produced by this project is usually an OCI image used to deploy the application and other manifests to Kubernetes. In this setup, separation of environments is handled by defining Kubernetes manifests in separate folders. These folders represent environments (e.g., development, staging, and production) that will host the application. When changes are made to the code project and a new container image is pushed, all that needs to be done to deploy these changes via GitLab’s integration with Flux CD is to edit the manifests under the environment folder to include the new image reference and open a merge request. Once that merge request is reviewed, approved, and merged, the delivery project’s CI/CD job will push a new OCI image that Flux CD will pick up and deploy to the new environment. Signing an OCI image is as simple as including Cosign in your project’s CI/CD job. You can simply generate a new public and private key with Cosign by running the commands below locally. Just make sure to log in to your GitLab instance with the glab CLI and replace the [PROJECT_ID] for the Cosign command with your delivery project’s ID. glab auth login cosign generate-key-pair gitlab://[PROJECT_ID] Once the cosign command runs successfully, you can see the Cosign keys added to your project under the CI/CD variables section under the key names COSIGN_PUBLIC_KEY and COSIGN_PRIVATE_KEY. Example CI/CD job A GitLab CI/CD job for pushing an OCI image will look something like the following: frontend-deploy: rules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH changes: paths: - manifests/dev/frontend-dev.yaml trigger: include: - component: gitlab.com/components/fluxcd/[email protected] inputs: version: 0.3.1 kubernetes_agent_reference: gitlab-da/projects/tanuki-bank/flux-config:dev registry_image_url: \"oci://$CI_REGISTRY_IMAGE/frontend\" image_tag: dev manifest_path: ./manifests/dev/frontend-dev.yaml flux_oci_repo_name: frontend flux_oci_namespace_name: frontend-dev signing_private_key: \"$COSIGN_PRIVATE_KEY\" The GitLab CI/CD Catalog offers a GitLab-maintained CI/CD component for working with OCI artifacts and Flux CD. This component allows development teams to push Kubernetes manifests as OCI images to GitLab’s Container Registry or an external container registry, sign the OCI image using Cosign, and immediately reconcile the newly pushed image via Flux CD. In the example above, the Flux CD component is included in a .gitlab-ci.yml file of a GitLab project. Using the component’s inputs, users can define what registry to push the image to (i.e., registry_image_url and image tag), the file path to Kubernetes manifests that will be pushed (i.e., manifest_path), the cosign private key used to sign images (i.e., signing_private_key), and the Kubernetes namespace and Flux CD OCIRepository name needed to sync updates to an environment (i.e., flux_oci_namespace_name and flux_oci_repo_name). The kubernetes_agent_reference allows GitLab CI/CD jobs to inherit the kubeconfig needed to access a Kubernetes cluster without needing to store a kubeconfig CI/CD variable in each GitLab project. By setting up the GitLab agent for Kubernetes, you can configure all GitLab projects’ CI/CD jobs in a GitLab group to inherit permissions to deploy to the Kubernetes cluster. The agent for Kubernetes context is typically configured wherever you configure the GitLab Agent for Kubernetes in your GitLab group. It is typically recommended that this be done in the project where Flux CD is managed. More information on configuring the agent for CI/CD access can be found in our CI/CD workflow documentation. The variables $COSIGN_PRIVATE_KEY, $FLUX_OCI_REPO_NAME, and $FRONTEND_DEV_NAMESPACE are values stored as CI/CD variables to easily access and mask these sensitive pieces of data in CI/CD logs. The $CI_REGISTRY_IMAGE is a variable that GitLab jobs have available by default that specifies the GitLab project’s container registry. Deploy OCI images Using Flux CD with your GitLab projects, you can automate deployments and signing verification for your microservice’s environments. Once Flux CD is configured to sync from a GitLab project, you could add the following Kubernetes custom resource definitions to your project to sync your pushed OCI image. apiVersion: v1 kind: Namespace metadata: name: frontend-dev labels: name: frontend-dev --- apiVersion: bitnami.com/v1alpha1 kind: SealedSecret metadata: name: cosign-public-key namespace: frontend-dev spec: encryptedData: cosign.pub: AgAKgLf4VbVzJOmr6++k81LlFayx88AELaUQFNOaXmBF4G+fBfBYeABl0skNvMAa1UrPVNSfMIHgFoYHoO96g576a+epk6V6glOI+++XvYbfsygof3GGxe0nL5Qh2b3ge0fNpyd0kTPSjTj0YUhRhKtMGMRSRw1jrwhNcGxCHK+Byibs52v8Np49KsIkeZKbzLdgYABkrv+k0j7hQM+jR180NpG+2UiRvaXpPuogxkbj61FEqWGrJHk8IVyfl3eh+YhoXxOHGDqko6SUC+bUZPDBlU6yKegO0/8Zq3hwulrSEsEjzRZNK+RFVMOLWWuC6h+WGpYhAMcsZPwjjJ/y29KLNa/YeqkN/cdk488QyEFc6ehCxzhH67HxIn2PDa+KkEOTv2TuycGF+Q00jKIizXF+IwLx/oRb3pTCF0AoAY8D8N3Ey+KfkOjsBON7gGID8GbQiJqX2IgIZxFMk0JRzxbRKOEqn+guLd5Shj7CD1a1Mkk0DxBdbqrGv2XNYUaFPI7xd3rZXUJZlnv+fsmwswsiGWRuXwim45HScWzQnfgLAe7tv3spVEGeaO5apl6d89uN21PBQnfE/zyugB//7ZW9tSp6+CSMyc5HynxI8diafqiwKPgvzLmVWRnkvxJijoXicRr3sCo5RudZPSlnjfd7CKdhwEVvLl7dRR4e/XBMdxCzk1p52Pl+3/kJR+LJii5+iwOpYrpVltSZdzc/3qRd19yMpc9PWpXYi7HxTb24EOQ25i21eDJY1ceplDN6bRtop2quzkjlwVeE2i4cEsX/YG8QBtQbop/3fjiAjKaED3QH3Ul0PECS9ARTScSkcOL3I00Xpp8DyD+xH0/i9wCBRDmH3yKX18C8VrMq02ALSnlP7WCVVjCPzubqKx2LPZRxK9EG0fylwv/vWQzTUUwfbPQZsd4c75bSTsTvxqp/UcFaXA== template: metadata: name: cosign-public-key namespace: frontend-dev --- apiVersion: source.toolkit.fluxcd.io/v1beta2 kind: OCIRepository metadata: name: frontend namespace: frontend-dev spec: interval: 1m url: oci://registry.gitlab.com/gitlab-da/projects/tanuki-bank/tanuki-bank-delivery/frontend ref: tag: dev verify: provider: cosign secretRef: name: cosign-public-key --- apiVersion: kustomize.toolkit.fluxcd.io/v1 kind: Kustomization metadata: name: frontend namespace: frontend-dev spec: interval: 1m targetNamespace: frontend-dev path: \".\" sourceRef: kind: OCIRepository name: frontend prune: true The Kustomization resource allows for further customization of Kubernetes manifests and also specifies which namespace to deploy resources to. The OCIRepository resource for Flux CD allows users to specify the OCI image repository reference and tag to regularly sync from. Additionally, you will notice the verify.provider and verify.secretRef properties. These fields allow you to verify that the OCI image deployed to the cluster was signed by the corresponding Cosign private key used in the earlier CI/CD job. The public key needs to be stored in a Kubernetes secret that will need to be present in the same namespace as the OCIRepository resource. To have this secret managed by Flux CD and not store the secret in plain text, you can consider using SealedSecrets to encrypt the value and have it be decrypted cluster side by a controller. For a simpler approach not requiring SealedSecrets, you can deploy the secret via a GitLab CI/CD job using the kubectl CLI. In the non-sealed secret approach, you would simply remove the SealedSecret included above and run the job to deploy the public key secret before running the job to push the new OCI image. This will make sure the secret is stored securely in GitLab and make sure the secret can be accessed on the cluster by the OCIRepository. While this approach is a bit simpler, just note this is not a suitable approach for managing secrets in production. The benefits of OCI, GitLab, and GitOps OCI artifacts allow for GitOps teams to take deployments even further with added security benefits and allowing for deployments to be minimal. Users still gain all the benefits offered by git as far as having a source of truth for infrastructure and collaborating on projects. OCI images add a packaging approach that improves the deployment aspect of GitOps. GitLab continues to learn from our customers and the cloud native community on building experiences that help simplify GitOps workflows. To get started using some of the features mentioned in this blog, you can sign up for a 60-day free trial of GitLab Ultimate. We would also love to hear from users about their experiences with these tools, and you can provide feedback in the community forum.",
  "image": "https://images.ctfassets.net/r9o86ar0p03f/76Tn5jFmEHY5LFj8RdDjNY/49f23277263a127bab8482ea2841cfa7/REFERENCE_-_Use_this_page_as_a_reference_for_thumbnail_sizes.png?fm=webp\u0026w=820\u0026h=500",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-v-37f1022b=\"\" data-v-53094866=\"\" data-v-74bd29c6=\"\"\u003e\u003cp\u003eIs \u003ca href=\"https://about.gitlab.com/topics/gitops/\"\u003eGitOps\u003c/a\u003e still GitOps if you are not using a git repository as your deployment artifact? While git remains central to GitOps workflows, storing infrastructure definitions as Open Container Initiative (OCI) artifacts in container registries has seen a rise in adoption as the source for GitOps deployments. In this article, we will dive deeper into the ideas behind this trend and how GitLab features support this enhancement to GitOps workflows.\u003c/p\u003e\n\u003ch2 id=\"what-is-gitops%3F\" tabindex=\"-1\"\u003eWhat is GitOps? \u003ca href=\"#what-is-gitops%3F\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"https://opengitops.dev/\"\u003eOpenGitOps\u003c/a\u003e project has defined \u003ca href=\"https://opengitops.dev/#principles\"\u003efour principles\u003c/a\u003e for the practice of GitOps:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ca href=\"https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#software-system\"\u003esystem managed by GitOps\u003c/a\u003e must have its \u003ca href=\"https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#declarative-description\"\u003edesired state expressed declaratively\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eDesired state is stored in a way that enforces immutability and versioning, and retains a complete version history.\u003c/li\u003e\n\u003cli\u003eSoftware agents automatically pull the desired state declarations from the source.\u003c/li\u003e\n\u003cli\u003eSoftware agents \u003ca href=\"https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#continuous\"\u003econtinuously\u003c/a\u003e observe actual system state and \u003ca href=\"https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#reconciliation\"\u003eattempt to apply the desired state\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAn example of GitOps is storing the Kubernetes manifests for a microservice in a GitLab project. Those Kubernetes resources are then continuously reconciled by a \u003ca href=\"https://kubernetes.io/docs/concepts/architecture/controller/\"\u003econtroller\u003c/a\u003e running on the Kubernetes cluster where the microservice is deployed to. This allows engineers to manage infrastructure using the same workflows as working with regular code, such as opening merge requests to make and review changes and versioning changes. GitOps also has operational benefits such as \u003ca href=\"https://about.gitlab.com/topics/gitops/#cicd\"\u003epreventing configuration drift\u003c/a\u003e and helps engineers audit what changes led to certain outcomes with deployments.\u003c/p\u003e\n\u003ch2 id=\"benefits-and-limitations-of-git-in-gitops-workflows\" tabindex=\"-1\"\u003eBenefits and limitations of git in GitOps workflows \u003ca href=\"#benefits-and-limitations-of-git-in-gitops-workflows\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWhile git is an essential piece of GitOps workflows, git repositories were not designed to be deployed by GitOps controllers. Git does provide the ability for engineers to collaborate on infrastructure changes and audit these changes later on, but controllers do not need to download an entire git repository for a successful deployment. GitOps controllers simply need the infrastructure defined for a particular environment.\u003c/p\u003e\n\u003cp\u003eAdditionally, an important piece of the deployment process is to \u003ca href=\"https://docs.sigstore.dev/about/overview/#why-cryptographic-signing\"\u003esign and verify deployments\u003c/a\u003e to assure deployment changes to an environment are coming from a trusted source. While git commits can be signed and verified by GitOps controllers, commits may also capture other details not related to the deployment itself (e.g., documentation changes, updates to other environments, and git repository restructuring) or not enough of the deployment picture as a deployment may consist of multiple commits. This again feels like a case this git feature wasn’t designed for.\u003c/p\u003e\n\u003cp\u003eAnother challenging aspect of git in GitOps workflows is that it can sometimes lead to more automation than expected. Soon after merging a change to the watched branch, it will be deployed. There are no controls in the process outside of git. How can you make sure that nothing gets deployed on a Friday late afternoon? What if teams responsible for deployment do not have permissions to merge changes in certain GitLab projects? Using OCI images adds a pipeline into the process, including all the delivery control features, like \u003ca href=\"https://docs.gitlab.com/ee/ci/environments/protected_environments.html\"\u003eapprovals or deploy freezes\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"oci-images\" tabindex=\"-1\"\u003eOCI images \u003ca href=\"#oci-images\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"https://opencontainers.org/\"\u003eOpen Container Initiative\u003c/a\u003e has helped to define standards around container formats. While most engineers are familiar with building Dockerfiles into container images, many may not be as familiar with storing Kubernetes manifests in a container registry. Because \u003ca href=\"https://docs.gitlab.com/ee/user/packages/container_registry/\"\u003eGitLab’s Container Registry\u003c/a\u003e is OCI compliant, it allows for users to push Kubernetes manifests for a particular environment to a container registry. GitOps controllers, such as \u003ca href=\"https://about.gitlab.com/blog/2023/02/08/why-did-we-choose-to-integrate-fluxcd-with-gitlab/\"\u003eFlux CD\u003c/a\u003e, can use the manifests stored in this OCI artifact instead of needing to clone an entire git repository.\u003c/p\u003e\n\u003cp\u003eOften in GitOps workflows, a git repository can include the infrastructure definitions for all environments that a microservice will be deployed to. By packaging the Kubernetes manifests for only a specific environment, Flux CD can download the minimum files needed to carry out a deployment to a specific environment.\u003c/p\u003e\n\u003ch3 id=\"security-benefits-of-using-oci-artifacts\" tabindex=\"-1\"\u003eSecurity benefits of using OCI artifacts \u003ca href=\"#security-benefits-of-using-oci-artifacts\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAs mentioned previously, signing and verifying the artifacts to be deployed to an environment adds an additional layer of security for software projects. After Kubernetes manifests are pushed to a container registry, a tool like \u003ca href=\"https://docs.sigstore.dev/quickstart/quickstart-cosign/\"\u003eSigstore Cosign\u003c/a\u003e can be used to sign the OCI image with a private key that can be securely stored in a GitLab project as a \u003ca href=\"https://docs.gitlab.com/ee/ci/variables/\"\u003eCI/CD variable\u003c/a\u003e. Flux CD can then use a public key stored on a Kubernetes cluster to verify that a deployment is coming from a trusted source.\u003c/p\u003e\n\u003ch2 id=\"using-gitlab-to-push-and-sign-oci-images\" tabindex=\"-1\"\u003eUsing GitLab to push and sign OCI images \u003ca href=\"#using-gitlab-to-push-and-sign-oci-images\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGitLab offers many features that help simplify the process of packaging, signing, and deploying OCI images. A common way to structure GitLab projects with GitOps workflows is to have separate GitLab projects for microservices’ code and a single infrastructure repository for all microservices. If an application is composed of \u003ccode\u003en\u003c/code\u003e microservices, this would require having \u003ccode\u003en +1\u003c/code\u003e GitLab projects for an application.\u003c/p\u003e\n\u003cp\u003eThe artifact produced by a code project is usually a container image that will be used to package the application. The infrastructure or delivery project will contain the Kubernetes manifests defining all the resources required to scale and serve traffic to each microservice. The artifact produced by this project is usually an OCI image used to deploy the application and other manifests to Kubernetes.\u003c/p\u003e\n\u003cp\u003eIn this setup, separation of environments is handled by defining Kubernetes manifests in separate folders. These folders represent environments (e.g., development, staging, and production) that will host the application. When changes are made to the code project and a new container image is pushed, all that needs to be done to deploy these changes via GitLab’s integration with Flux CD is to edit the manifests under the environment folder to include the new image reference and open a merge request. Once that merge request is reviewed, approved, and merged, the delivery project’s CI/CD job will push a new OCI image that Flux CD will pick up and deploy to the new environment.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://images.ctfassets.net/r9o86ar0p03f/6haKvLzVKDvEol941Vielp/ad24424d776a2d9c277a33468a176b92/image1.png\" alt=\"OCI images - flow chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eSigning an OCI image is as simple as including Cosign in your project’s CI/CD job. You can simply generate a new public and private key with Cosign by running the commands below locally. Just make sure to log in to your GitLab instance with the \u003ca href=\"https://gitlab.com/gitlab-org/cli/#installation\"\u003eglab CLI\u003c/a\u003e and replace the [\u003ccode\u003ePROJECT_ID\u003c/code\u003e] for the Cosign command with your \u003ca href=\"https://docs.gitlab.com/ee/user/project/working_with_projects.html#access-a-project-by-using-the-project-id\"\u003edelivery project’s ID\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eglab auth login\ncosign generate-key-pair gitlab://[PROJECT_ID]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnce the cosign command runs successfully, you can see the Cosign keys added to your project under the CI/CD variables section under the key names \u003ccode\u003eCOSIGN_PUBLIC_KEY\u003c/code\u003e and \u003ccode\u003eCOSIGN_PRIVATE_KEY\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"example-cicd-job\" tabindex=\"-1\"\u003eExample CI/CD job \u003ca href=\"#example-cicd-job\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eA GitLab CI/CD job for pushing an OCI image will look something like the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrontend-deploy:\n  rules:\n  - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n    changes:\n      paths: \n      - manifests/dev/frontend-dev.yaml\n  trigger:\n    include:\n      - component: gitlab.com/components/fluxcd/\u003ca href=\"https://about.gitlab.com/cdn-cgi/l/email-protection\" data-cfemail=\"0c636f65216d7e78656a6d6f784c3c223f223d\"\u003e[email protected]\u003c/a\u003e\n        inputs:\n          version: 0.3.1\n          kubernetes_agent_reference: gitlab-da/projects/tanuki-bank/flux-config:dev\n          registry_image_url: \u0026#34;oci://$CI_REGISTRY_IMAGE/frontend\u0026#34;\n          image_tag: dev\n          manifest_path: ./manifests/dev/frontend-dev.yaml\n          flux_oci_repo_name: frontend\n          flux_oci_namespace_name: frontend-dev\n          signing_private_key: \u0026#34;$COSIGN_PRIVATE_KEY\u0026#34; \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ca href=\"https://about.gitlab.com/blog/2024/05/08/ci-cd-catalog-goes-ga-no-more-building-pipelines-from-scratch/\"\u003eGitLab CI/CD Catalog\u003c/a\u003e offers a GitLab-maintained \u003ca href=\"https://gitlab.com/explore/catalog/components/fluxcd\"\u003eCI/CD component for working with OCI artifacts and Flux CD\u003c/a\u003e. This component allows development teams to push Kubernetes manifests as OCI images to GitLab’s Container Registry or an external container registry, sign the OCI image using Cosign, and immediately reconcile the newly pushed image via Flux CD.\u003c/p\u003e\n\u003cp\u003eIn the example above, the Flux CD \u003ccode\u003ecomponent\u003c/code\u003e is included in a \u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e file of a GitLab project. Using the component’s \u003ccode\u003einputs\u003c/code\u003e, users can define what registry to push the image to (i.e., \u003ccode\u003eregistry_image_url\u003c/code\u003e and \u003ccode\u003eimage tag\u003c/code\u003e), the file path to Kubernetes manifests that will be pushed (i.e., \u003ccode\u003emanifest_path\u003c/code\u003e), the cosign private key used to sign images (i.e., \u003ccode\u003esigning_private_key\u003c/code\u003e), and the Kubernetes namespace and Flux CD \u003ca href=\"https://fluxcd.io/flux/components/source/ocirepositories/\"\u003eOCIRepository\u003c/a\u003e name needed to sync updates to an environment (i.e., \u003ccode\u003eflux_oci_namespace_name\u003c/code\u003e and \u003ccode\u003eflux_oci_repo_name\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ekubernetes_agent_reference\u003c/code\u003e allows GitLab CI/CD jobs to inherit the \u003ccode\u003ekubeconfig\u003c/code\u003e needed to access a Kubernetes cluster without needing to store a \u003ccode\u003ekubeconfig\u003c/code\u003e CI/CD variable in each GitLab project. By setting up the \u003ca href=\"https://docs.gitlab.com/ee/user/clusters/agent/\"\u003eGitLab agent for Kubernetes\u003c/a\u003e, you can configure all GitLab projects’ CI/CD jobs in a \u003ca href=\"https://docs.gitlab.com/ee/user/group/\"\u003eGitLab group\u003c/a\u003e to inherit permissions to deploy to the Kubernetes cluster.\u003c/p\u003e\n\u003cp\u003eThe agent for Kubernetes context is typically configured wherever you configure the GitLab Agent for Kubernetes in your GitLab group. It is typically recommended that this be done in the project where Flux CD is managed. More information on configuring the agent for CI/CD access can be found in our \u003ca href=\"https://docs.gitlab.com/ee/user/clusters/agent/ci_cd_workflow.html\"\u003eCI/CD workflow documentation\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe variables \u003ccode\u003e$COSIGN_PRIVATE_KEY\u003c/code\u003e, \u003ccode\u003e$FLUX_OCI_REPO_NAME\u003c/code\u003e, and \u003ccode\u003e$FRONTEND_DEV_NAMESPACE\u003c/code\u003e are values stored as CI/CD variables to easily access and mask these sensitive pieces of data in CI/CD logs. The \u003ccode\u003e$CI_REGISTRY_IMAGE\u003c/code\u003e is a variable that GitLab jobs have available by default that specifies the GitLab project’s container registry.\u003c/p\u003e\n\u003ch3 id=\"deploy-oci-images\" tabindex=\"-1\"\u003eDeploy OCI images \u003ca href=\"#deploy-oci-images\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eUsing \u003ca href=\"https://docs.gitlab.com/ee/user/clusters/agent/gitops/flux_tutorial.html\"\u003eFlux CD with your GitLab projects\u003c/a\u003e, you can automate deployments and signing verification for your microservice’s environments. Once Flux CD is configured to sync from a GitLab project, you could add the following Kubernetes \u003ca href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/\"\u003ecustom resource definitions\u003c/a\u003e to your project to sync your pushed OCI image.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eapiVersion: v1\nkind: Namespace\nmetadata:\n  name: frontend-dev\n  labels:\n    name: frontend-dev\n---\napiVersion: bitnami.com/v1alpha1\nkind: SealedSecret\nmetadata:\n  name: cosign-public-key\n  namespace: frontend-dev\nspec:\n  encryptedData:\n    cosign.pub: AgAKgLf4VbVzJOmr6++k81LlFayx88AELaUQFNOaXmBF4G+fBfBYeABl0skNvMAa1UrPVNSfMIHgFoYHoO96g576a+epk6V6glOI+++XvYbfsygof3GGxe0nL5Qh2b3ge0fNpyd0kTPSjTj0YUhRhKtMGMRSRw1jrwhNcGxCHK+Byibs52v8Np49KsIkeZKbzLdgYABkrv+k0j7hQM+jR180NpG+2UiRvaXpPuogxkbj61FEqWGrJHk8IVyfl3eh+YhoXxOHGDqko6SUC+bUZPDBlU6yKegO0/8Zq3hwulrSEsEjzRZNK+RFVMOLWWuC6h+WGpYhAMcsZPwjjJ/y29KLNa/YeqkN/cdk488QyEFc6ehCxzhH67HxIn2PDa+KkEOTv2TuycGF+Q00jKIizXF+IwLx/oRb3pTCF0AoAY8D8N3Ey+KfkOjsBON7gGID8GbQiJqX2IgIZxFMk0JRzxbRKOEqn+guLd5Shj7CD1a1Mkk0DxBdbqrGv2XNYUaFPI7xd3rZXUJZlnv+fsmwswsiGWRuXwim45HScWzQnfgLAe7tv3spVEGeaO5apl6d89uN21PBQnfE/zyugB//7ZW9tSp6+CSMyc5HynxI8diafqiwKPgvzLmVWRnkvxJijoXicRr3sCo5RudZPSlnjfd7CKdhwEVvLl7dRR4e/XBMdxCzk1p52Pl+3/kJR+LJii5+iwOpYrpVltSZdzc/3qRd19yMpc9PWpXYi7HxTb24EOQ25i21eDJY1ceplDN6bRtop2quzkjlwVeE2i4cEsX/YG8QBtQbop/3fjiAjKaED3QH3Ul0PECS9ARTScSkcOL3I00Xpp8DyD+xH0/i9wCBRDmH3yKX18C8VrMq02ALSnlP7WCVVjCPzubqKx2LPZRxK9EG0fylwv/vWQzTUUwfbPQZsd4c75bSTsTvxqp/UcFaXA==\n  template:\n    metadata:\n      name: cosign-public-key\n      namespace: frontend-dev\n---\napiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: OCIRepository\nmetadata:\n    name: frontend\n    namespace: frontend-dev\nspec:\n    interval: 1m\n    url: oci://registry.gitlab.com/gitlab-da/projects/tanuki-bank/tanuki-bank-delivery/frontend\n    ref:\n        tag: dev\n    verify:\n      provider: cosign\n      secretRef:\n        name: cosign-public-key\n---\napiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\n    name: frontend\n    namespace: frontend-dev\nspec:\n    interval: 1m\n    targetNamespace: frontend-dev\n    path: \u0026#34;.\u0026#34;\n    sourceRef:\n        kind: OCIRepository\n        name: frontend\n    prune: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ca href=\"https://fluxcd.io/flux/components/kustomize/kustomizations/\"\u003e\u003ccode\u003eKustomization\u003c/code\u003e\u003c/a\u003e resource allows for further customization of Kubernetes manifests and also specifies which namespace to deploy resources to. The \u003ccode\u003eOCIRepository\u003c/code\u003e resource for Flux CD allows users to specify the OCI image repository reference and tag to regularly sync from. Additionally, you will notice the \u003ccode\u003everify.provider\u003c/code\u003e and \u003ccode\u003everify.secretRef\u003c/code\u003e properties. These fields allow you to verify that the OCI image deployed to the cluster was signed by the corresponding Cosign private key used in the earlier CI/CD job.\u003c/p\u003e\n\u003cp\u003eThe public key needs to be stored in a \u003ca href=\"https://kubernetes.io/docs/concepts/configuration/secret/\"\u003eKubernetes secret\u003c/a\u003e that will need to be present in the same namespace as the \u003ccode\u003eOCIRepository\u003c/code\u003e resource. To have this secret managed by Flux CD and not store the secret in plain text, you can consider using \u003ca href=\"https://fluxcd.io/flux/guides/sealed-secrets/\"\u003eSealedSecrets\u003c/a\u003e to encrypt the value and have it be decrypted cluster side by a controller.\u003c/p\u003e\n\u003cp\u003eFor a simpler approach not requiring SealedSecrets, you can \u003ca href=\"https://docs.gitlab.com/ee/user/clusters/agent/getting_started_deployments.html\"\u003edeploy the secret via a GitLab CI/CD\u003c/a\u003e job using the \u003ca href=\"https://kubernetes.io/docs/reference/kubectl/\"\u003e\u003ccode\u003ekubectl CLI\u003c/code\u003e\u003c/a\u003e. In the non-sealed secret approach, you would simply remove the SealedSecret included above and run the job to deploy the public key secret before running the job to push the new OCI image. This will make sure the secret is stored securely in GitLab and make sure the secret can be accessed on the cluster by the OCIRepository. While this approach is a bit simpler, just note this is not a suitable approach for managing secrets in production.\u003c/p\u003e\n\u003ch2 id=\"the-benefits-of-oci-gitlab%2C-and-gitops\" tabindex=\"-1\"\u003eThe benefits of OCI, GitLab, and GitOps \u003ca href=\"#the-benefits-of-oci-gitlab%2C-and-gitops\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eOCI artifacts allow for GitOps teams to take deployments even further with added security benefits and allowing for deployments to be minimal. Users still gain all the benefits offered by git as far as having a source of truth for infrastructure and collaborating on projects. OCI images add a packaging approach that improves the deployment aspect of GitOps.\u003c/p\u003e\n\u003cp\u003eGitLab continues to learn from our customers and the cloud native community on building experiences that help simplify GitOps workflows. To get started using some of the features mentioned in this blog, you can sign up for a \u003ca href=\"https://about.gitlab.com/free-trial/\"\u003e60-day free trial of GitLab Ultimate\u003c/a\u003e. We would also love to hear from users about their experiences with these tools, and you can provide feedback in the \u003ca href=\"https://forum.gitlab.com/t/oci-images-as-source-of-truth-for-gitops-with-gitlab/120965\"\u003ecommunity forum\u003c/a\u003e.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-02-19T00:00:00Z",
  "modifiedTime": null
}
