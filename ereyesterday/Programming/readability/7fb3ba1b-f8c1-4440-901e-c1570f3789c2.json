{
  "id": "7fb3ba1b-f8c1-4440-901e-c1570f3789c2",
  "title": "QCon SF 2024: Refactoring Large, Stubborn Codebases",
  "link": "https://www.infoq.com/news/2024/12/refactoring-zimmerman-ritter/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "Jake Zimmerman, Technical Lead of Sorbet at Stripe, and Getty Ritter, Ruby Infrastructure Engineer at Stripe, presented Refactoring Stubborn, Legacy Codebases at the 2024 QCon San Francisco conference. Zimmerman and Ritter demonstrated how to fix complaints on maintaining a large codebase with leverage and by ratcheting incremental progress. By Michael Redlich",
  "author": "Michael Redlich",
  "published": "Mon, 09 Dec 2024 13:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Java",
    "Refactoring",
    "Ruby",
    "QCon San Francisco 2024",
    "Architecture \u0026 Design",
    "Development",
    "news"
  ],
  "byline": "Michael Redlich",
  "length": 4720,
  "excerpt": "Jake Zimmerman, Technical Lead of Sorbet at Stripe, and Getty Ritter, Ruby Infrastructure Engineer at Stripe, presented Refactoring Stubborn, Legacy Codebases at the 2024 QCon San Francisco conference",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s2_20241209233417/apple-touch-icon.png",
  "text": "Jake Zimmerman, Technical Lead of Sorbet at Stripe, and Getty Ritter, Ruby Infrastructure Engineer at Stripe, presented Refactoring Stubborn, Legacy Codebases at the 2024 QCon San Francisco conference. Zimmerman kicked off the presentation enumerating some common complaints about stubborn codebases according to a 2017 company survey. In order to refactor to a happy state, Zimmerman maintained that the best way to centralize a refactoring involved having one team drive it in such a way to concentrate on expertise, incentivize automation and a higher probability of finishing. A centralized migration needs two things: leverage over the codebase such that a small problem-solving force can have a large effect on system behavior; and a method to \"ratchet\" incremental progress. Use of the term \"ratchet\" implies a mechanical gear that can only turn in only one direction. With this in mind, Zimmerman introduced Sorbet, a type checker for Ruby. He maintained: To refactor a large, stubborn codebase, you need to have a point of leverage and to pick good ratchets. Building Sorbet was key to address all of these complaints and introduced points of leverage to address them. Use of ratcheting is achieved with the # typed comments located at the top of each Ruby file. It acts like a ratchet because it's easy to \"go up a little.\" Valid use of this construct is: # typed: false is used for syntax and constants # typed: true is used for inference in methods # typed: strict is used for every method that needs a signature While this may seem easy enough, Zimmerman cautioned that the order in which true and false are used may have unintended consequences. He used the following example: # typed: true # ^ start with false class KnownParent def method_on_parent(x); end end class MyClass \u003c UnknownParent def example self.method_on_parent() end end Initially using # typed: true, the UnknownParent constant and the call to method_on_parent() method in MyClass were highlighted. This can be confusing since the method_on_parent() method is defined in the KnownParent class. Upon switching over to # typed: false, only the UnknownParent constant is highlighted because it doesn't exist. The issue can now be easily resolved by changing the constant to KnownParent. Now, a return to # typed: true, only the call to the method_on_parent() method in MyClass is highlighted to alert the developer that the method call requires a parameter. As a result, there was an improvement in developer satisfaction because: a significant amount of the large, stubborn codebase was refactored; they had a point of leverage using Sorbet; and they selected good ratchets. Ritter then discussed how to make a Ruby monolith more modular and why modularity is important. He used a simple logger application containing personally identifiable information as an example. # a toy logger class Logger def log(message, **storytime) payload = storytime.map do |k, v| \"#{k}=#{v.inspect}\" end.join(\" \") @output.puts(\"#{Time.now.to_i}: #{message} #{payload}\") end end # elsewhere logger.log(\"Attempting operation\", op: my_op, merchant: m) # 1730756308: Attempting operation op=:update merchant=#\u003cMerchant id=22 secret=\"hunter2\"\u003e The solution, however, can create tangled code despite writing well-intentioned code. # ... payload = storytime.map do |k, v| if v.is_a?(Merchant) # if we're logging a merchant... \"#{k}=Merchant(id=#{v.id}, ...)\" # redact most fields else \"#{k}=#{v.inspect}\" # other objects can be logged as-is end end.join(\" \") # ... Ritter discussed two points of leverage: Packaging, which is inherent in Sorbet, but isn't enough to address modularity: and Layering, the \"essential principle is that any element of a layer depends only on other elements in the same layer or on elements of the layer 'beneath' it. Communication upward must pass through some indirect mechanism\" as defined by Eric Evans. Ritter provided many code examples of layering, using ratchets that Zimmerman had earlier described, and the attributes of what makes a good ratchet. How can this all fall apart? Walter J. Savitch, relaying a quote overheard at a computer science conference, stated: In theory, there is no difference between theory and practice. In practice, there is. Tools aren't always perfect at first, said Ritter, and recommended to not rush the launch of a project. One team can refactor a larger, stubborn codebase. About the Author Michael Redlich",
  "image": "https://res.infoq.com/news/2024/12/refactoring-zimmerman-ritter/en/headerimage/java-istock-image-01-1733748581399.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003e\u003ca href=\"https://qconsf.com/speakers/jakezimmerman\"\u003eJake Zimmerman\u003c/a\u003e, Technical Lead of Sorbet at Stripe, and \u003ca href=\"https://qconsf.com/speakers/gettyritter\"\u003eGetty Ritter\u003c/a\u003e, Ruby Infrastructure Engineer at Stripe, presented \u003ca href=\"https://qconsf.com/presentation/nov2024/refactoring-stubborn-legacy-codebases\"\u003eRefactoring Stubborn, Legacy Codebases\u003c/a\u003e at the 2024 \u003ca href=\"https://qconsf.com/\"\u003eQCon San Francisco\u003c/a\u003e conference.\u003c/p\u003e\n\n\u003cp\u003eZimmerman kicked off the presentation enumerating some common complaints about stubborn codebases according to a 2017 company survey. In order to refactor to a happy state, Zimmerman maintained that the best way to centralize a refactoring involved having one team drive it in such a way to concentrate on expertise, incentivize automation and a higher probability of finishing.\u003c/p\u003e\n\n\u003cp\u003eA centralized migration needs two things: leverage over the codebase such that a small problem-solving force can have a large effect on system behavior; and a method to \u0026#34;ratchet\u0026#34; incremental progress. Use of the term \u0026#34;ratchet\u0026#34; implies a mechanical gear that can only turn in only one direction. With this in mind, Zimmerman introduced \u003ca href=\"https://sorbet.org/\"\u003eSorbet\u003c/a\u003e, a type checker for Ruby. He maintained:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eTo refactor a large, stubborn codebase, you need to have a point of leverage and to pick good ratchets.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eBuilding Sorbet was key to address all of these complaints and introduced points of leverage to address them.\u003c/p\u003e\n\n\u003cp\u003eUse of ratcheting is achieved with the \u003cstrong\u003e\u003ccode\u003e# typed\u003c/code\u003e\u003c/strong\u003e comments located at the top of each Ruby file. It acts like a ratchet because it\u0026#39;s easy to \u0026#34;\u003cem\u003ego up a little.\u003c/em\u003e\u0026#34; Valid use of this construct is:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e# typed: false\u003c/code\u003e\u003c/strong\u003e is used for syntax and constants\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e# typed: true\u003c/code\u003e\u003c/strong\u003e is used for inference in methods\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e# typed: strict\u003c/code\u003e\u003c/strong\u003e is used for every method that needs a signature\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eWhile this may seem easy enough, Zimmerman cautioned that the order in which \u003cstrong\u003e\u003ccode\u003etrue\u003c/code\u003e\u003c/strong\u003e and \u003cstrong\u003e\u003ccode\u003efalse\u003c/code\u003e\u003c/strong\u003e are used may have unintended consequences. He used the following example:\u003c/p\u003e\n\n\u003cpre\u003e    \u003ccode\u003e\n# typed: true\n#         ^ start with false\n\nclass KnownParent\n    def method_on_parent(x); end\nend\n\nclass MyClass \u0026lt; UnknownParent\n    def example\n        self.method_on_parent()\n    end\nend\n    \u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eInitially using \u003cstrong\u003e\u003ccode\u003e# typed: true\u003c/code\u003e\u003c/strong\u003e, the \u003cstrong\u003e\u003ccode\u003eUnknownParent\u003c/code\u003e\u003c/strong\u003e constant and the call to \u003cstrong\u003e\u003ccode\u003emethod_on_parent()\u003c/code\u003e\u003c/strong\u003e method in \u003cstrong\u003e\u003ccode\u003eMyClass\u003c/code\u003e\u003c/strong\u003e were highlighted. This can be confusing since the \u003cstrong\u003e\u003ccode\u003emethod_on_parent()\u003c/code\u003e\u003c/strong\u003e method is defined in the \u003cstrong\u003e\u003ccode\u003eKnownParent\u003c/code\u003e\u003c/strong\u003e class.\u003c/p\u003e\n\n\u003cp\u003eUpon switching over to \u003cstrong\u003e\u003ccode\u003e# typed: false\u003c/code\u003e\u003c/strong\u003e, only the \u003cstrong\u003e\u003ccode\u003eUnknownParent\u003c/code\u003e\u003c/strong\u003e constant is highlighted because it doesn\u0026#39;t exist. The issue can now be easily resolved by changing the constant to \u003cstrong\u003e\u003ccode\u003eKnownParent\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eNow, a return to \u003cstrong\u003e\u003ccode\u003e# typed: true\u003c/code\u003e\u003c/strong\u003e, only the call to the \u003cstrong\u003e\u003ccode\u003emethod_on_parent()\u003c/code\u003e\u003c/strong\u003e method in \u003cstrong\u003e\u003ccode\u003eMyClass\u003c/code\u003e\u003c/strong\u003e is highlighted to alert the developer that the method call requires a parameter.\u003c/p\u003e\n\n\u003cp\u003eAs a result, there was an improvement in developer satisfaction because: a significant amount of the large, stubborn codebase was refactored; they had a point of leverage using Sorbet; and they selected good ratchets.\u003c/p\u003e\n\n\u003cp\u003eRitter then discussed how to make a Ruby monolith more modular and why modularity is important. He used a simple logger application containing personally identifiable information as an example.\u003c/p\u003e\n\n\u003cpre\u003e    \u003ccode\u003e\n# a toy logger\nclass Logger\n    def log(message, **storytime)\n        payload = storytime.map do |k, v|\n            \u0026#34;#{k}=#{v.inspect}\u0026#34;\n        end.join(\u0026#34; \u0026#34;)\n\n        @output.puts(\u0026#34;#{Time.now.to_i}: #{message} #{payload}\u0026#34;)\n    end\nend\n\n# elsewhere\nlogger.log(\u0026#34;Attempting operation\u0026#34;, op: my_op, merchant: m)\n# 1730756308: Attempting operation op=:update merchant=#\u0026lt;Merchant id=22 secret=\u0026#34;hunter2\u0026#34;\u0026gt;\n    \u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eThe solution, however, can create tangled code despite writing well-intentioned code.\u003c/p\u003e\n\n\u003cpre\u003e    \u003ccode\u003e\n# ...\npayload = storytime.map do |k, v|\n    if v.is_a?(Merchant) # if we\u0026#39;re logging a merchant...\n        \u0026#34;#{k}=Merchant(id=#{v.id}, ...)\u0026#34; # redact most fields\n    else\n        \u0026#34;#{k}=#{v.inspect}\u0026#34; # other objects can be logged as-is\n    end\nend.join(\u0026#34; \u0026#34;)\n# ...\n    \u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eRitter discussed two points of leverage: \u003cstrong\u003ePackaging\u003c/strong\u003e, which is inherent in Sorbet, but isn\u0026#39;t enough to address modularity: and \u003cstrong\u003eLayering\u003c/strong\u003e, the \u0026#34;\u003cem\u003eessential principle is that any element of a layer depends only on other elements in the same layer or on elements of the layer \u0026#39;beneath\u0026#39; it. Communication upward must pass through some indirect mechanism\u003c/em\u003e\u0026#34; as defined by \u003ca href=\"https://www.linkedin.com/in/ericevansddd/\"\u003eEric Evans\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eRitter provided many code examples of layering, using ratchets that Zimmerman had earlier described, and the attributes of what makes a good ratchet.\u003c/p\u003e\n\n\u003cp\u003eHow can this all fall apart? \u003ca href=\"https://jacobsschool.ucsd.edu/people/profile/walter-savitch\"\u003eWalter J. Savitch\u003c/a\u003e, relaying a quote overheard at a computer science conference, stated:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eIn theory, there is no difference between theory and practice. In practice, there is.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eTools aren\u0026#39;t always perfect at first, said Ritter, and recommended to not rush the launch of a project. One team can refactor a larger, stubborn codebase.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Michael-Redlich\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eMichael Redlich\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-12-09T00:00:00Z",
  "modifiedTime": null
}
