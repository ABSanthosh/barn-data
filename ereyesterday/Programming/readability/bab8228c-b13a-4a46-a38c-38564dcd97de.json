{
  "id": "bab8228c-b13a-4a46-a38c-38564dcd97de",
  "title": "Integration Tests for Plugin Developers: API Interaction",
  "link": "https://blog.jetbrains.com/platform/2025/03/integration-tests-for-plugin-developers-api-interaction/",
  "description": "In our previous blog posts (1,2), we created integration tests that interact with UI components and assert different properties of UI components. However, sometimes we need to check the internal state of our plugin or invoke some method to simplify or speed up the test and avoid too many UI interactions. Let’s explore exactly how […]",
  "author": "Maxim Kolmakov",
  "published": "Mon, 24 Mar 2025 16:42:40 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "plugin-development",
    "marketplace",
    "plugins",
    "testing"
  ],
  "byline": "Maxim Kolmakov",
  "length": 10030,
  "excerpt": "In the third post of the series, learn how to interact with your plugin’s API in integration tests to speed up execution and reduce UI dependency.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "Plugin and extension development for JetBrains products. Development Marketplace PluginsIntegration Tests for Plugin Developers: API Interaction In our previous blog posts (1,2), we created integration tests that interact with UI components and assert different properties of UI components. However, sometimes we need to check the internal state of our plugin or invoke some method to simplify or speed up the test and avoid too many UI interactions. Let’s explore exactly how we can do this. Java Management Extension Going back to our last post, the IDE and tests were running in different processes, which means we need some way to communicate between them. There are a lot of different ways we can do this. For example, the first version of the framework we used exclusively for performance testing worked via files (this mode is still supported in the Starter framework). With this approach, the Starter framework prepares a simple text file with a list of commands and passes this file to the IDE. The IDE reads the file, parses the commands and arguments, and executes them one by one. Though functional, this approach has significant downsides. There is no real communication between the IDE and the test. All the test can do is prepare commands and wait until the IDE is finished running them. There is also no way for the IDE to communicate the results back to the test other than by storing some information in the files, which will only be read once the testing is complete. It’s clear that we need a more flexible approach. We could opt for gRPC or create our own custom protocol, but fortunately there is already a standard Java technology – Java Management Extensions (or JMX for short) – that is a perfect choice for what we’re trying to achieve. JMX supports different connectors to manage the state of the JVM. In our case, we’re using a standard Java Remote Method Invocation (RMI) protocol. This protocol allows us to access objects and invoke methods from tests in the JVM of the IDE. The architecture of our RMI protocol is as follows: When a test wants to invoke a method on a remote object: The test looks up the remote object in the RMI registry (the IDE in our case). The IDE returns a reference to the stub, which implements the same interface as the remote object. When the client calls a method on the stub: The stub serializes the method call, including any parameters. It sends the serialized data over the network to the remote server. The RMI runtime inside the IDE unmarshals the request and invokes the corresponding method on the actual remote object. The method executes, and the result is serialized and sent back to the client via the stub. The stub unmarshals the response and returns the result to the caller. Thus, the stub makes remote calls feel like local method calls, without the caller worrying about low-level networking, data conversion, or request handling. Creating stubs To demonstrate how this works in practice, let’s add the following code to our plugin: package org.jetbrains.testPlugin import com.intellij.openapi.components.Service import com.jetbrains.rd.generator.nova.array class PluginStorage { companion object { @JvmStatic fun getPluginStorage() = Storage(\"static method\", listOf(\"static1\", \"static2\")) } } @Service class PluginService { fun someMethod(): Unit = Unit fun getAnswer(): Int = 42 } @Service(Service.Level.PROJECT) class PluginProjectService { fun getStrings(): Array\u003cString\u003e = arrayOf(\"foo\",\"bar\") } data class Storage(val key: String, val attributes: List\u003cString\u003e) This file contains one class with the static method getPluginStorage, and two light services – one application-level PluginService and one project-level PluginProjectService.  We want to be able to call the methods of these classes from our test and verify their return values. Before we can do this, we need to create stubs for all of the classes we wish to use. So, let’s create a Stubs.kt file in our test code: import com.intellij.driver.client.Remote @Remote(\"org.jetbrains.testPlugin.PluginStorage\", plugin = \"org.example.demo\") interface PluginStorage{ fun getPluginStorage(): Storage } @Remote(\"org.jetbrains.testPlugin.PluginService\", plugin = \"org.example.demo\") interface PluginService { fun getAnswer(): Int } @Remote(\"org.jetbrains.testPlugin.PluginProjectService\", plugin = \"org.example.demo\") interface PluginProjectService { fun getStrings(): Array\u003cString\u003e } @Remote(\"org.jetbrains.testPlugin.Storage\", plugin = \"org.example.demo\") interface Storage{ fun getAttributes(): List\u003cString\u003e fun getKey(): String } All we’ve done is take our classes and declare corresponding interfaces with methods that we will need in our tests. We don’t need to create stubs for methods that won’t be used. We also need to provide a fully qualified name of the class that will correspond to our stubs using the @Remote annotation. Here, we use strings to avoid introducing dependency between production and test code. The second parameter that we need to specify is pluginId, where our classes are located. This parameter is required since IntelliJ-based IDEs use separate classloaders for each plugin, and the code that will call methods on the IDE side (Invoker) needs to know where to search for them. There is built-in support for such annotations inside IntelliJ IDEA: When you rename or move the target class using refactorings, the annotation will be updated accordingly. You can also use gutters to navigate to the target class from a stub. Calling IDE methods from tests Now that we have our stubs set up, we’re ready to use them in our test: import com.intellij.driver.client.* import com.intellij.driver.sdk.* import com.intellij.ide.starter.ci.* import com.intellij.ide.starter.di.di import com.intellij.ide.starter.driver.engine.runIdeWithDriver import com.intellij.ide.starter.ide.IdeProductProvider import com.intellij.ide.starter.models.TestCase import com.intellij.ide.starter.plugins.PluginConfigurator import com.intellij.ide.starter.project.GitHubProject import com.intellij.ide.starter.runner.Starter import org.junit.jupiter.api.* import org.kodein.di.* import kotlin.io.path.Path class PluginTest { @Test fun testStubs() { Starter.newContext( testName = \"testExample\", TestCase( IdeProductProvider.IC, projectInfo = GitHubProject.fromGithub( branchName = \"master\", repoRelativeUrl = \"JetBrains/ij-perf-report-aggregator\" ) ).withVersion(\"2024.2\") ).apply { val pathToPlugin = System.getProperty(\"path.to.build.plugin\") PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin)) }.runIdeWithDriver().useDriverAndCloseIde { val storage = utility\u003cPluginStorage\u003e().getPluginStorage() val key = storage.getKey() val attributes = storage.getAttributes() Assertions.assertEquals(\"static method\", key) Assertions.assertEquals(listOf(\"static1\", \"static2\"), attributes) val answer = service\u003cPluginService\u003e().getAnswer() Assertions.assertEquals(42, answer) waitForProjectOpen() val project = singleProject() val strings = service\u003cPluginProjectService\u003e(project).getStrings() Assertions.assertArrayEquals(arrayOf(\"foo\", \"bar\"), strings) } } } There are two methods that will help us to invoke our methods: service and utility. The first one will return us an instance of service, and the second will return an instance of any class. You might notice that the project-level service requires the Project stub. To get it, we use the singleProject method, which is implemented in the same way as demonstrated above: service\u003cProjectManager\u003e().getOpenProjects().singleOrNull() Note: Service and utility proxies can be acquired on each call, there is no need to cache them in clients. JMX/RMI limitations The main inconvenience of using JMX/RMI is that you have to create stub interfaces and methods for all objects which you wish to use in your tests. But on the other hand, you don’t have to modify your production code in any way. As with any protocol, JMX/RMI has its limitations: Parameters and return values can only be: Primitives and their wrappers: Integer, Short, Long, Double, Float, and Byte. String. @Remote references. An array of primitive values or String or @Remote references. Lists of primitive values or String or @Remote references. Only public methods can be called. JMX/RMI can’t interact with suspend methods. What’s next? Stay tuned for upcoming blog posts in this series, where we’ll cover: GitHub Actions: setting up continuous integration. Common pitfalls: tips and tricks for stable UI tests. Subscribe to JetBrains Platform updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/03/Plugin-Testing-3_blog_social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/platform/\"\u003e\n                                                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/JetBrains-icon-1.svg\" alt=\"Platform logo\"/\u003e\n                                                                                                                            \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003ePlugin and extension development for JetBrains products. \u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/platform/category/plugin-development/\"\u003eDevelopment\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/platform/category/marketplace/\"\u003eMarketplace\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/platform/category/plugins/\"\u003ePlugins\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eIntegration Tests for Plugin Developers: API Interaction\u003c/h2\u003e                    \n                    \n\u003cp\u003eIn our previous blog posts (\u003ca href=\"https://blog.jetbrains.com/platform/2025/02/integration-tests-for-plugin-developers-intro-dependencies-and-first-integration-test/\" data-type=\"link\" data-id=\"https://blog.jetbrains.com/platform/2025/02/integration-tests-for-plugin-developers-intro-dependencies-and-first-integration-test/\"\u003e1\u003c/a\u003e,\u003ca href=\"https://blog.jetbrains.com/platform/2025/02/integration-tests-for-plugin-developers-ui-testing/\" data-type=\"link\" data-id=\"https://blog.jetbrains.com/platform/2025/02/integration-tests-for-plugin-developers-ui-testing/\"\u003e2\u003c/a\u003e), we created integration tests that interact with UI components and assert different properties of UI components. However, sometimes we need to check the internal state of our plugin or invoke some method to simplify or speed up the test and avoid too many UI interactions. Let’s explore exactly how we can do this.\u003c/p\u003e\n\n\n\n\u003ch2\u003eJava Management Extension\u003c/h2\u003e\n\n\n\n\u003cp\u003eGoing back to our last post, the IDE and tests were running in different processes, which means we need some way to communicate between them. There are a lot of different ways we can do this. For example, the first version of the framework we used exclusively for performance testing worked via files (this mode is still supported in the Starter framework). With this approach, the Starter framework prepares a simple text file with a list of commands and passes this file to the IDE. The IDE reads the file, parses the commands and arguments, and executes them one by one.\u003c/p\u003e\n\n\n\n\u003cp\u003eThough functional, this approach has significant downsides. There is no real communication between the IDE and the test. All the test can do is prepare commands and wait until the IDE is finished running them. There is also no way for the IDE to communicate the results back to the test other than by storing some information in the files, which will only be read once the testing is complete.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt’s clear that we need a more flexible approach. We could opt for gRPC or create our own custom protocol, but fortunately there is already a standard Java technology – \u003ca href=\"https://www.oracle.com/java/technologies/javase/javamanagement.html\" target=\"_blank\" rel=\"noopener\"\u003eJava Management Extensions\u003c/a\u003e (or JMX for short) – that is a perfect choice for what we’re trying to achieve.\u003c/p\u003e\n\n\n\n\u003cp\u003eJMX supports different connectors to manage the state of the JVM. In our case, we’re using a standard \u003ca href=\"https://www.oracle.com/java/technologies/javase/remote-method-invocation-home.html\" target=\"_blank\" rel=\"noopener\"\u003eJava Remote Method Invocation\u003c/a\u003e (RMI) protocol. This protocol allows us to access objects and invoke methods from tests in the JVM of the IDE.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe architecture of our RMI protocol is as follows:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1600\" height=\"1402\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/03/unnamed.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWhen a test wants to invoke a method on a remote object:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eThe test looks up the remote object in the RMI registry (the IDE in our case).\u003c/li\u003e\n\n\n\n\u003cli\u003eThe IDE returns a reference to the stub, which implements the same interface as the remote object.\u003c/li\u003e\n\n\n\n\u003cli\u003eWhen the client calls a method on the stub:\n\u003cul\u003e\n\u003cli\u003eThe stub serializes the method call, including any parameters.\u003c/li\u003e\n\n\n\n\u003cli\u003eIt sends the serialized data over the network to the remote server.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe RMI runtime inside the IDE unmarshals the request and invokes the corresponding method on the actual remote object.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe method executes, and the result is serialized and sent back to the client via the stub.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe stub unmarshals the response and returns the result to the caller.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eThus, the stub makes remote calls feel like local method calls, without the caller worrying about low-level networking, data conversion, or request handling.\u003c/p\u003e\n\n\n\n\u003ch2\u003eCreating stubs\u003c/h2\u003e\n\n\n\n\u003cp\u003eTo demonstrate how this works in practice, let’s add the following code to our plugin:\u003c/p\u003e\n\n\n\n\u003cpre\u003epackage org.jetbrains.testPlugin\n\nimport com.intellij.openapi.components.Service\nimport com.jetbrains.rd.generator.nova.array\n\nclass PluginStorage {\n   companion object {\n       @JvmStatic\n       fun getPluginStorage() = Storage(\u0026#34;static method\u0026#34;, listOf(\u0026#34;static1\u0026#34;, \u0026#34;static2\u0026#34;))\n   }\n}\n@Service\nclass PluginService {\n   fun someMethod(): Unit = Unit\n   fun getAnswer(): Int = 42\n}\n@Service(Service.Level.PROJECT)\nclass PluginProjectService {\n   fun getStrings(): Array\u0026lt;String\u0026gt; = arrayOf(\u0026#34;foo\u0026#34;,\u0026#34;bar\u0026#34;)\n}\ndata class Storage(val key: String, val attributes: List\u0026lt;String\u0026gt;)\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis file contains one class with the static method \u003ccode\u003egetPluginStorage\u003c/code\u003e, and two \u003ca href=\"https://plugins.jetbrains.com/docs/intellij/plugin-services.html#light-services\" target=\"_blank\" rel=\"noopener\"\u003elight services\u003c/a\u003e – one application-level \u003ccode\u003ePluginService\u003c/code\u003e and one project-level \u003ccode\u003ePluginProjectService\u003c/code\u003e. \u003c/p\u003e\n\n\n\n\u003cp\u003eWe want to be able to call the methods of these classes from our test and verify their return values.\u003c/p\u003e\n\n\n\n\u003cp\u003eBefore we can do this, we need to create stubs for all of the classes we wish to use. So, let’s create a \u003cem\u003eStubs.kt\u003c/em\u003e file in our test code:\u003c/p\u003e\n\n\n\n\u003cpre\u003eimport com.intellij.driver.client.Remote\n\n@Remote(\u0026#34;org.jetbrains.testPlugin.PluginStorage\u0026#34;, plugin = \u0026#34;org.example.demo\u0026#34;)\ninterface PluginStorage{\n   fun getPluginStorage(): Storage\n}\n\n\n@Remote(\u0026#34;org.jetbrains.testPlugin.PluginService\u0026#34;, plugin = \u0026#34;org.example.demo\u0026#34;)\ninterface PluginService {\n   fun getAnswer(): Int\n}\n\n\n@Remote(\u0026#34;org.jetbrains.testPlugin.PluginProjectService\u0026#34;, plugin = \u0026#34;org.example.demo\u0026#34;)\ninterface PluginProjectService {\n   fun getStrings(): Array\u0026lt;String\u0026gt;\n}\n\n\n@Remote(\u0026#34;org.jetbrains.testPlugin.Storage\u0026#34;, plugin = \u0026#34;org.example.demo\u0026#34;)\ninterface Storage{\n   fun getAttributes(): List\u0026lt;String\u0026gt;\n   fun getKey(): String\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eAll we’ve done is take our classes and declare corresponding interfaces with methods that we will need in our tests. We don’t need to create stubs for methods that won’t be used.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe also need to provide a fully qualified name of the class that will correspond to our stubs using the \u003ccode\u003e@Remote\u003c/code\u003e annotation. Here, we use strings to avoid introducing dependency between production and test code.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe second parameter that we need to specify is \u003ccode\u003epluginId\u003c/code\u003e, where our classes are located. This parameter is required since IntelliJ-based IDEs use separate classloaders for each plugin, and the code that will call methods on the IDE side (\u003ccode\u003eInvoker\u003c/code\u003e) needs to know where to search for them.\u003c/p\u003e\n\n\n\n\u003cp\u003eThere is built-in support for such annotations inside IntelliJ IDEA:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1600\" height=\"207\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/03/unnamed-1.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWhen you rename or move the target class using refactorings, the annotation will be updated accordingly. You can also use gutters to navigate to the target class from a stub.\u003c/p\u003e\n\n\n\n\u003ch2\u003eCalling IDE methods from tests\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow that we have our stubs set up, we’re ready to use them in our test:\u003c/p\u003e\n\n\n\n\u003cpre\u003eimport com.intellij.driver.client.*\nimport com.intellij.driver.sdk.*\nimport com.intellij.ide.starter.ci.*\nimport com.intellij.ide.starter.di.di\nimport com.intellij.ide.starter.driver.engine.runIdeWithDriver\nimport com.intellij.ide.starter.ide.IdeProductProvider\nimport com.intellij.ide.starter.models.TestCase\nimport com.intellij.ide.starter.plugins.PluginConfigurator\nimport com.intellij.ide.starter.project.GitHubProject\nimport com.intellij.ide.starter.runner.Starter\nimport org.junit.jupiter.api.*\nimport org.kodein.di.*\nimport kotlin.io.path.Path\n\nclass PluginTest {\n   @Test\n   fun testStubs() {\n       Starter.newContext(\n           testName = \u0026#34;testExample\u0026#34;, TestCase(\n               IdeProductProvider.IC, projectInfo = GitHubProject.fromGithub(\n                   branchName = \u0026#34;master\u0026#34;,\n                   repoRelativeUrl = \u0026#34;JetBrains/ij-perf-report-aggregator\u0026#34;\n               )\n           ).withVersion(\u0026#34;2024.2\u0026#34;)\n       ).apply {\n           val pathToPlugin = System.getProperty(\u0026#34;path.to.build.plugin\u0026#34;)\n           PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin))\n       }.runIdeWithDriver().useDriverAndCloseIde {\n           val storage = utility\u0026lt;PluginStorage\u0026gt;().getPluginStorage()\n           val key = storage.getKey()\n           val attributes = storage.getAttributes()\n           Assertions.assertEquals(\u0026#34;static method\u0026#34;, key)\n           Assertions.assertEquals(listOf(\u0026#34;static1\u0026#34;, \u0026#34;static2\u0026#34;), attributes)\n\n\n           val answer = service\u0026lt;PluginService\u0026gt;().getAnswer()\n           Assertions.assertEquals(42, answer)\n\n\n           waitForProjectOpen()\n           val project = singleProject()\n           val strings = service\u0026lt;PluginProjectService\u0026gt;(project).getStrings()\n           Assertions.assertArrayEquals(arrayOf(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), strings)\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThere are two methods that will help us to invoke our methods: \u003ccode\u003eservice\u003c/code\u003e and \u003ccode\u003eutility\u003c/code\u003e. The first one will return us an instance of service, and the second will return an instance of any class.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou might notice that the project-level service requires the \u003ccode\u003eProject\u003c/code\u003e stub. To get it, we use the \u003ccode\u003esingleProject\u003c/code\u003e method, which is implemented in the same way as demonstrated above:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003e\u003cem\u003eservice\u003c/em\u003e\u0026lt;ProjectManager\u0026gt;().getOpenProjects().singleOrNull()\u003c/code\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eNote: Service and utility proxies can be acquired on each call, there is no need to cache them in clients.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eJMX/RMI limitations\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe main inconvenience of using JMX/RMI is that you have to create stub interfaces and methods for all objects which you wish to use in your tests. But on the other hand, you don’t have to modify your production code in any way.\u003c/p\u003e\n\n\n\n\u003cp\u003eAs with any protocol, JMX/RMI has its limitations:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eParameters and return values can only be:\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003ePrimitives and their wrappers: \u003ccode\u003eInteger\u003c/code\u003e, \u003ccode\u003eShort\u003c/code\u003e, \u003ccode\u003eLong\u003c/code\u003e, \u003ccode\u003eDouble\u003c/code\u003e, \u003ccode\u003eFloat\u003c/code\u003e, and \u003ccode\u003eByte\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eString\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e@Remote\u003c/code\u003e references.\u003c/li\u003e\n\n\n\n\u003cli\u003eAn array of primitive values or \u003ccode\u003eString\u003c/code\u003e or \u003ccode\u003e@Remote\u003c/code\u003e references.\u003c/li\u003e\n\n\n\n\u003cli\u003eLists of primitive values or \u003ccode\u003eString\u003c/code\u003e or \u003ccode\u003e@Remote\u003c/code\u003e references.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eOnly \u003ccode\u003epublic\u003c/code\u003e methods can be called.\u003c/li\u003e\n\n\n\n\u003cli\u003eJMX/RMI can’t interact with suspend methods.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eWhat’s next?\u003c/h2\u003e\n\n\n\n\u003cp\u003eStay tuned for upcoming blog posts in this series, where we’ll cover:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eGitHub Actions: setting up continuous integration.\u003c/li\u003e\n\n\n\n\u003cli\u003eCommon pitfalls: tips and tricks for stable UI tests.\u003c/li\u003e\n\u003c/ul\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to JetBrains Platform updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": null,
  "modifiedTime": null
}
