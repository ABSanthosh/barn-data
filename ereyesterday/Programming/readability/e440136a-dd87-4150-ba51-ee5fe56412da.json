{
  "id": "e440136a-dd87-4150-ba51-ee5fe56412da",
  "title": "How to Use Kotlin Notebooks for Productive Development",
  "link": "https://blog.jetbrains.com/idea/2025/04/how-to-use-kotlin-notebooks-for-productive-development/",
  "description": "Kotlin Notebook is a new interactive environment for JVM developers. This article will cover the main Notebook features and how you can utilize them to improve your productivity.¬† How to use Kotlin Notebook Kotlin Notebook is bundled with IntelliJ IDEA starting from the 2025.1 release, and it is easier than ever to start working with [‚Ä¶]",
  "author": "Ilya Muradyan",
  "published": "Mon, 28 Apr 2025 15:02:45 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "kotlin",
    "tutorials",
    "intellij-idea",
    "kotlin-notebook"
  ],
  "byline": "",
  "length": 19549,
  "excerpt": "Kotlin Notebook is a new interactive environment for JVM developers. This article will cover the main Notebook features and how you can utilize them to improve your productivity. How to use K",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA ‚Äì the IDE for Professional Development in Java and Kotlin Kotlin TutorialsHow to Use Kotlin Notebooks for Productive Development¬† Kotlin Notebook is a new interactive environment for JVM developers. This article will cover the main Notebook features and how you can utilize them to improve your productivity.¬† How to use Kotlin Notebook Kotlin Notebook is bundled with IntelliJ IDEA starting from the 2025.1 release, and it is easier than ever to start working with notebooks across various contexts. You can create notebooks in three main ways: Creating a notebook in a project From within a project, right-click the source root or a folder in the Project view, then choose New | Kotlin Notebook. This will create an .ipynb file inside your project. Notebooks are generally placed in notebooks or samples subdirectories, but you can place them anywhere within your project. Creating a scratch notebook Imagine you want to experiment with code without having to add new files to your project. The Scratch notebook should come in handy for this. To create a notebook that isn‚Äôt part of a specific project, follow these steps: Use the New Scratch File action (Cmd+Shift+N on macOS or Ctrl+Alt+Shift+Insert on Windows/Linux). Select Kotlin Notebook from the list. This creates a file in the Scratches and Consoles | Kotlin Notebooks directory, and the notebook can be accessed across all projects, making it easy to store random pieces of code and refer to them whenever you need to. Creating a notebook from the Welcome screen You can open or create a Kotlin notebook directly from the Welcome screen without even opening a project. Navigate to the Kotlin Notebooks tab and click New Notebook. You‚Äôll be prompted to name the notebook and choose whether it should be saved as a scratch file or within a specified folder. Basics: Interactive cell execution and kernel control Kotlin Notebook provides a familiar notebook interface within IntelliJ IDEA, making it easy to run code and manage the execution state. Each notebook consists of cells that can be executed independently or in sequence. The toolbar at the top of the notebook includes controls for running cells and managing the Kotlin kernel: Run a single cell: Click the Run button on the left of a code cell or press Ctrl+Enter/ Cmd+Enter. The cell‚Äôs code will run, and the output will appear directly beneath the cell.¬† Run multiple cells: Click Run All to execute every cell in the notebook from top to bottom. If you want to run all cells below a certain point (for example, to resume from the middle of a notebook), you can right-click that cell and choose Run All Below. This flexibility lets you rerun the entire notebook or just a section without having to run each cell manually. Interrupt execution: If a cell is taking too long or has entered an infinite loop, click the Interrupt button (‚èπ). This stops the currently running cell without affecting the state of the already executed ones. It‚Äôs useful for pausing long-running computations or canceling mistaken operations. Restart or stop the session: Use the Restart Kernel button (üîÑ) to reset the Kotlin kernel. Restarting will terminate the current session and clear the runtime state, so all variables and imports become unresolved. This is helpful to ensure a clean slate (for example, if you want to run the notebook from scratch or recover from a bad state). You can also stop the session entirely by closing the notebook or using the standard Stop action in the Kotlin Notebook tool window, which shuts down the kernel process. Configure Kotlin notebook: The gear icon on the toolbar opens the Kotlin Notebook settings, where you can adjust the notebook‚Äôs configuration. This settings panel lets you control the Kotlin kernel environment, such as the JDK or kernel version used. Using these controls, you can execute code interactively and manage the notebook‚Äôs state, with each executed cell getting a number.¬† This is important because the notebook‚Äôs state depends on execution order, not just the linear order of cells. For example, if one cell defines a variable and a later cell uses it, you must run them in the correct sequence. Kotlin Notebook will help by marking cells with an asterisk if they haven‚Äôt been run yet, and by updating the execution count on each cell as you run it. Sharing notebooks via Gist and Datalore One of the advantages of using the standard .ipynb notebook format is the ease with which you can share your work. Kotlin Notebook provides convenient ways to share notebooks with others or publish your results online: GitHub Gist: You can quickly share your current notebook as a GitHub Gist. Simply click the Create Gist button (the icon with the GitHub logo) on the toolbar. The IDE will export your notebook to a Gist on your GitHub account and provide you with the URL, which you send to colleagues, knowing they can view the notebook on GitHub or download it. This is perfect for sharing a quick example or including notebook content in issues and forums. The Gist will contain the notebook in JSON format, which GitHub can render for preview. All code, output, and markdown from your Kotlin notebook are preserved. JetBrains Datalore: Because Kotlin Notebook uses the same file format and Kotlin Jupyter kernel as Datalore, JetBrains‚Äô online data science notebook platform, your notebooks are fully compatible with it. You can simply upload the .ipynb file to Datalore to share it or continue working in the cloud. This means you can collaborate with others by simply moving the notebook to Datalore ‚Äì no conversion needed.¬† By leveraging Gists for quick snippets and Datalore for cloud collaboration, Kotlin Notebook makes sharing results and prototypes effortless. Whether you‚Äôre posting a code snippet publicly or working on data analysis with a teammate, you can move from IntelliJ IDEA to the web and back without missing a beat. Testing REST APIs Kotlin Notebook provides a powerful tool for backend and API developers: the ability to call and test RESTful APIs directly from your notebook, with full support for HTTP methods, JSON serialization, and IDE-based code completion. This is enabled through integration with Kotlin‚Äôs HTTP client, powered by Ktor. To get started, simply add %use ktor-client to a code cell. This command pulls in a Ktor-based HTTP client and the kotlinx.serialization library, both of which are ready to use. After that, you have access to a pre-configured HTTP client instance in your notebook, available through the http variable. Strongly-typed HTTP calls: With the HTTP client integration, you can perform HTTP requests with Kotlin code and get typed results. For example, to fetch JSON data from an API, you might write: val response = http.get(\"https://jsonplaceholder.typicode.com/todos/1\") response.bodyAsText() This will perform a GET request and return the response as pretty-printed and highlighted JSON output. Automatic JSON serialization: The notebook‚Äôs HTTP client is integrated with Kotlin Serialization, and your responses can be automatically deserialized: The Ktor client integration will automatically handle class generation and JSON deserialization itself. This means you get a typed Kotlin object with proper fields, instead of manually dealing with JSON parsing. If you have a pre-defined data class, you can also call the body() method of a response with the appropriate type argument. Under the hood, this feature relies on the open-source kotlin-jupyter-http-util library, which brings together the Ktor client and serialization for use in notebooks. In practice, it means your Kotlin notebook can act like a full-fledged HTTP client tool (akin to Postman or a REST client), but with the added benefit of being able to script and assert on the responses in Kotlin. This is extremely handy for trying out endpoints, testing microservices, or scraping web APIs ‚Äì all within the comfort of IntelliJ IDEA. Working with data: Tables and visualizations Data explorers will feel at home in Kotlin Notebook. The 2025.1 release enhances how data is displayed and plotted, through tight integration with the Kotlin DataFrame library for tabular data and Kandy for charts. These integrations turn your notebook into an interactive data exploration tool. DataFrame integration ‚Äì interactive tables When you add the DataFrame library, simply by putting %use dataframe in a cell, you gain access to a powerful DSL for data manipulation. It builds type information from the runtime the same way HTTP integration logic does, for example: Any time you display a DataFrame (for example, by evaluating a variable holding a table or by calling df.head()), Kotlin Notebook will render it using a special UI component rather than plain text. It offers: Scrollable pagination: Large datasets are handled gracefully. Instead of trying to dump thousands of rows, the table output shows a limited number of rows per page and offers navigation controls. Sortable columns: You can sort the table by a column with a single click on its header. Hierarchical data drilling: If your DataFrame has nested data (for example, a column that contains another table or complex objects), you can expand that data inline. Click on cells that contain nested structures to drill down into sub-tables. This approach to exploration is great for hierarchical JSON datasets loaded into DataFrames. Open in separate tabs: Sometimes you want to compare two tables side by side. You can now move a DataFrame output into its own tab within the notebook interface. Each table you open in a new tab stays accessible, so you can switch between multiple data views. Export to file: The output panel now has an Export button (üíæ). With a couple of clicks, you can export the displayed DataFrame to a file in common formats like CSV, JSON, or XML. This is useful if you‚Äôve transformed some data and want to save the results. By default, the DataFrame will be saved to your project directory, but you can choose any location. The exported data respects the currently displayed state (for instance, if you‚Äôve sorted the view by a column, the export will follow that sorted order, so you get exactly what you see). It‚Äôs also possible to just drop a CSV onto your notebook: necessary code will be automatically generated and executed. You‚Äôll be able to work with the loaded dataframe right away. With Kotlin DataFrame, you can load CSV and JSON files, as well as SQL query results, into tables and then filter, aggregate, and transform them with Kotlin code. Kotlin Notebook will back you up by displaying each step‚Äôs result in a user-friendly way. It‚Äôs like having a mini data grid inside your IDE for instant feedback on your data manipulations. Check out the official documentation to learn more about Kotlin DataFrame‚Äôs full capabilities. Visualizing data with Kandy No data science notebook is complete without visualization. Kotlin Notebook integrates with Kandy, a plotting library built on LetsPlot by JetBrains and created by the Kotlin team to deliver the best experience when working with Kotlin DataFrame and Kotlin Notebook. Run %use kandy in a cell to load the Kandy library and enable its rendering support in the notebook. This allows you to create charts using Kandy‚Äôs simple, type-safe DSL and have them appear right below your code. For example, you can quickly produce a line chart for a DataFrame, df, with the columns Year and Population: %use kandy df.plot { ¬†¬†¬†¬†line { ¬†¬†¬†¬†¬†¬†¬†¬†x(Year) ¬†¬†¬†¬†¬†¬†¬†¬†y(Population) ¬† width = 3.5 ¬† color = Color.LIGHT_BLUE ¬†¬†¬†¬†}¬† layout.title = \"Population Growth\" } When you execute this cell, a chart will be displayed in the notebook output area. You can see many examples of charts in the Kandy documentation and gallery. Exporting and copying plots: You can easily save your charts or copy them. Every plot output has an output menu (accessible via a small icon that appears at the top-right of the output when you hover over it). From this menu, select Export Plot As‚Ä¶ to save the chart as an image file.¬† If you need to use the plot in another application immediately, you can choose Copy Plot, which will copy the chart image to your clipboard so you can paste it into a document or chat. This workflow makes sharing visual insights from your data trivial: run a cell to create a chart, then export or copy that visualization in just a couple of clicks. Kandy‚Äôs plotting capabilities, combined with DataFrame, enable a smooth data exploration experience. You can load and prepare data in a table and then visualize patterns with a chart ‚Äì all in Kotlin. You can even iterate, adjusting your data transformation and re-running the plot cell to see updates instantly. Kotlin Notebook ensures the charts render efficiently inside the IDE, so you don‚Äôt have to switch to an external browser for interactive visuals. For more advanced usage (like interactive plots or complex layouts), refer to the Kandy documentation, but for most needs, a few lines of Kotlin code will produce the desired chart. Using JVM libraries and project code Kotlin has a rich ecosystem of libraries and integrates seamlessly with Java. Kotlin Notebook embraces these strengths by allowing you to bring in external libraries or your project‚Äôs own code into a notebook session easily. Adding external libraries with %use and USE {} You have two primary options when it comes to using a third-party JVM library (for example, an HTTP client, a CSV parser, or a machine learning toolkit) in your notebook: Integrated libraries via %use: Kotlin Notebook comes with a collection of pre-defined library descriptors for many popular libraries (Kotlin DataFrame, Kandy, Ktor, KotlinDL, etc.). You can import these libraries with the magical %use libraryName, without the need to think about dependencies! For example, as we saw, %use dataframe brings in the Kotlin DataFrame library and sets up its renderer, and %use ktor-client brings in Ktor and related utilities. We maintain a list of supported libraries and their descriptors on GitHub, and many community libraries are already integrated. Unintegrated libraries via Gradle syntax: If %use doesn‚Äôt support a given library, or you need to specify the version, you can still add it manually using a Gradle-style dependency block. Kotlin Notebook supports a special USE { ... } code block where you can declare repositories and dependencies, for example: USE { ¬†¬†¬†¬†repositories { ¬†¬†¬†¬†¬†¬†¬†¬†maven(\"https://my.repo/url\") ¬†¬†¬†¬†} ¬†¬†¬†¬†dependencies { ¬†¬†¬†¬†¬†¬†¬†¬†implementation(\"com.example:my-library:1.2.3\") ¬†¬†¬†¬†¬†¬†¬†¬†implementation(\"org.apache.commons:commons-text:1.10.0\") ¬†¬†¬†¬†} } This will fetch the specified Maven artifacts and add them to the notebook‚Äôs classpath. To fine-tune how libraries are resolved, use Kotlin Notebook options. When you use either of these methods to load a library, the Kotlin Notebook kernel may perform additional integration steps if a descriptor or integration class is present. Read more about defining your own library integration. If you add a library in one cell, code in subsequent cells can use it, but code in the same cell may not see it until after that cell is executed. A best practice is to put your %use commands or USE {} blocks at the top of the notebook or at least in their own cells. Also, if you ever restart the kernel, you‚Äôll need to re-run those dependency cells to re-establish the classpath. Prototyping with project code and module dependencies Kotlin Notebook can also interact with the code in your project, making it incredibly useful for prototyping and debugging. For example, if you have a large codebase, you can create a scratch notebook to experiment with your own APIs or data models interactively, without having to write a temporary main function or unit test. In the 2025.1 release, using project code in notebooks has become easier, and there are more configuration options: Module classpath selection: By default, when you open a notebook file in an IntelliJ IDEA project, the notebook‚Äôs classpath will not include any project dependencies. However, you can also set the notebook up to depend on all project libraries or on a particular project module with all the dependencies inside it. Switch between these options using the combobox in the notebook‚Äôs toolbar. Up-to-date code: Notebooks use the compiled classes from your project. To ensure that the latest compiled .class files are available, you should build your project before running a notebook. If you edit a source file in your project while the notebook is open, a notification will remind you to rebuild the module and restart the notebook to see the changes take effect in the notebook‚Äôs output. Integrations: If your project defines any integration classes for a Kotlin notebook in the module your notebook depends on, those integrations will also be loaded. Kotlin Notebook‚Äôs approach to libraries and dependencies allows you to incorporate whatever you need ‚Äì be it a well-known library or your own code ‚Äì and use it interactively. Because Kotlin notebooks have access to your project code, you can do things like instantiate your application‚Äôs classes, call functions from your business logic, or run quick experiments on your data models. You can even use notebooks to write exploratory tests against your APIs, since notebooks allow you to run code in any order and inspect the results, which can be more flexible than a fixed unit test. What‚Äôs next? The next article will tell you about Kotlin Notebook‚Äôs advanced features. Stay tuned! If you have any questions or suggestions, you can: Ask them right under this post. YouTrack: Create a #ktnb ticket to report bugs or suggest features. Slack: Check out #notebooks for discussions and questions. Email: Email teodor.irkhin@jetbrains.com with any suggestions or requests for functionality that would allow you to incorporate Kotlin Notebook into your workflow. Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/04/ij-social_share_blog_1280x720_en-9.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA ‚Äì the IDE for Professional Development in Java and Kotlin\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/category/kotlin/\"\u003eKotlin\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/idea/category/tutorials/\"\u003eTutorials\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eHow to Use Kotlin Notebooks for Productive Development¬†\u003c/h2\u003e                    \u003cdiv\u003e\n                            \u003cp\u003e\u003cimg src=\"https://secure.gravatar.com/avatar/a47bc1a78e6833a5abfe2c4fe1a89bff?s=200\u0026amp;r=g\" width=\"200\" height=\"200\" alt=\"Ilya Muradyan\" loading=\"lazy\"/\u003e\n                                                                                                                    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2024/08/photo_2024-08-02-14.40.26.jpeg\" width=\"200\" height=\"200\" alt=\"Teodor Irkhin\" loading=\"lazy\"/\u003e\n                                                                                                \u003c/p\u003e\n                            \n                        \u003c/div\u003e\n                    \n\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/2025/04/kotlin-notebook-arrives-in-intellij-idea/\"\u003eKotlin Notebook\u003c/a\u003e is a new interactive environment for JVM developers. This article will cover the main Notebook features and how you can utilize them to improve your productivity.¬†\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eHow to use Kotlin Notebook\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eKotlin Notebook is bundled with IntelliJ IDEA starting from the 2025.1 release, and it is easier than ever to start working with notebooks across various contexts. You can create notebooks in three main ways:\u003c/p\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eCreating a notebook in a project\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eFrom within a project, right-click the source root or a folder in the \u003cem\u003eProject\u003c/em\u003e view, then choose \u003cem\u003eNew | Kotlin Notebook\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis will create an .ipynb file inside your project. Notebooks are generally placed in notebooks or samples subdirectories, but you can place them anywhere within your project.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcLHe0-4yKbAtT8ZHRjfS23On1Wh3yJqGQlxdlaCqXV-m3wrlg7tse7dvLft9Vw5XrRff7MSzlbsodkrJ9eQWmhvNuhyjrREMmMgzJAsbfJo5zOpiJuV6cFVYQatTwv6fmDlxMyOw?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eCreating a scratch notebook\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eImagine you want to experiment with code without having to add new files to your project. The Scratch notebook should come in handy for this. To create a notebook that isn‚Äôt part of a specific project, follow these steps:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eUse the \u003cem\u003eNew Scratch File\u003c/em\u003e action (\u003cem\u003eCmd+Shift+N\u003c/em\u003e on macOS or \u003cem\u003eCtrl+Alt+Shift+Insert\u003c/em\u003e on Windows/Linux).\u003c/li\u003e\n\n\n\n\u003cli\u003eSelect \u003cem\u003eKotlin Notebook\u003c/em\u003e from the list.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeZle_yv5UtOTkHds-YgNZ0KSvx-CCw5yYx9MMQd4nShhDf2oVMDIrA6M6qHddcJkjU2SenWcSfo7H7Bqj6GmOnKMqI8t4EqHuITbkA6l5AK7CRGHWlWIwlmkiB0YuXzRg8OBKDnw?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThis creates a file in the \u003cem\u003eScratches and Consoles | Kotlin Notebooks\u003c/em\u003e directory, and the notebook can be accessed across all projects, making it easy to store random pieces of code and refer to them whenever you need to.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeaDG4zlZPqktX9jVx1UtjAJHEfbXeNxio6i4VkX1tlMLcOGk3h04v6x_8FDKm19zFQRzY-d-Y53LpfwCKTUHnXRuIKEyasLpDJsO4gBSoVFtGDbVzL8aFMjo2e8e6PpylBQGZb5Q?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eCreating a notebook from the \u003c/strong\u003e\u003cstrong\u003e\u003cem\u003eWelcome \u003c/em\u003e\u003c/strong\u003e\u003cstrong\u003escreen\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eYou can open or create a Kotlin notebook directly from the \u003cem\u003eWelcome \u003c/em\u003escreen without even opening a project. Navigate to the \u003cem\u003eKotlin Notebooks\u003c/em\u003e tab and click \u003cem\u003eNew Notebook\u003c/em\u003e. You‚Äôll be prompted to name the notebook and choose whether it should be saved as a scratch file or within a specified folder.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdwIP5eQHrkxLzAYuJzD-593_N_QBjL7nFrUJGSkojoflKezmlvCQURqYqnovSgGoeeNr4DvoqtvOvu4o61-JlfKYnSLwlitPYufPcO-kfZWjcQCfowDLAGO8jN2rXbhPkXMOMx?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eBasics: Interactive cell execution and kernel control\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eKotlin Notebook provides a familiar notebook interface within IntelliJ IDEA, making it easy to run code and manage the execution state. Each notebook consists of cells that can be executed independently or in sequence. The toolbar at the top of the notebook includes controls for running cells and managing the Kotlin kernel:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeQ-tHIROlhlNIpfZ5u04BP2CnM4hsYMll3fuh4NSSqM2GU7mcwa02ej2M2Ct7H9P2tWY79LBPgNzliIAvYrcM6TZcKG0qinmm--Sd-h4cHrvHN-oOJfB116mHOKGD7ghOIa7LUTg?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRun a single cell:\u003c/strong\u003e Click the \u003cem\u003eRun\u003c/em\u003e button on the left of a code cell or press \u003cem\u003eCtrl+Enter/ Cmd+Enter\u003c/em\u003e. The cell‚Äôs code will run, and the output will appear directly beneath the cell.¬†\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eRun multiple cells:\u003c/strong\u003e Click \u003cem\u003eRun All \u003c/em\u003eto \u003ca href=\"https://www.jetbrains.com/help/idea/kotlin-notebook.html#:~:text=If%20you%20restart%20the%20kernel,cells%27%20position%20in%20the%20notebook\" target=\"_blank\" rel=\"noopener\"\u003eexecute every cell\u003c/a\u003e in the notebook from top to bottom. If you want to run all cells below a certain point (for example, to resume from the middle of a notebook), you can right-click that cell and choose \u003cem\u003eRun All Below\u003c/em\u003e. This flexibility lets you rerun the entire notebook or just a section without having to run each cell manually.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eInterrupt execution:\u003c/strong\u003e If a cell is taking too long or has entered an infinite loop, click the \u003cem\u003eInterrupt \u003c/em\u003ebutton (‚èπ). This \u003ca href=\"https://www.jetbrains.com/help/idea/kotlin-notebook.html#best-practices\" target=\"_blank\" rel=\"noopener\"\u003estops the currently running\u003c/a\u003e cell without affecting the state of the already executed ones. It‚Äôs useful for pausing long-running computations or canceling mistaken operations.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eRestart or stop the session:\u003c/strong\u003e Use the \u003cem\u003eRestart Kernel\u003c/em\u003e button (üîÑ) to reset the Kotlin kernel. Restarting will \u003cstrong\u003eterminate the current session and clear the runtime state\u003c/strong\u003e, so all variables and imports become unresolved. This is helpful to ensure a clean slate (for example, if you want to run the notebook from scratch or recover from a bad state). You can also stop the session entirely by closing the notebook or using the standard \u003cem\u003eStop \u003c/em\u003eaction in the\u003cem\u003e Kotlin Notebook\u003c/em\u003e tool window, which shuts down the kernel process.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eConfigure Kotlin notebook:\u003c/strong\u003e The gear icon on the toolbar opens the Kotlin Notebook settings, where you can adjust the notebook‚Äôs configuration. This settings panel lets you control the Kotlin kernel environment, such as the JDK or kernel version used.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eUsing these controls, you can execute code interactively and manage the notebook‚Äôs state, with each executed cell getting a number.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is important because the notebook‚Äôs state depends on execution order, not just the linear order of cells. For example, if one cell defines a variable and a later cell uses it, you must run them in the correct sequence\u003cem\u003e. \u003c/em\u003eKotlin Notebook will help by marking cells with an asterisk if they haven‚Äôt been run yet, and by updating the execution count on each cell as you run it.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eSharing notebooks via Gist and Datalore\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eOne of the advantages of using the standard .ipynb notebook format is the ease with which you can share your work. Kotlin Notebook provides convenient ways to share notebooks with others or publish your results online:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGitHub Gist:\u003c/strong\u003e You can quickly share your current notebook as a GitHub Gist. Simply click the \u003cem\u003eCreate Gist\u003c/em\u003e button (the icon with the GitHub logo) on the toolbar. The IDE will export your notebook to a Gist on your GitHub account and provide you with the URL, which you send to colleagues, knowing they can view the notebook on GitHub or download it. This is perfect for sharing a quick example or including notebook content in issues and forums. The Gist will contain the notebook in JSON format, which GitHub can render for preview. All code, output, and markdown from your Kotlin notebook are preserved.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1080\" height=\"600\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/gist_final.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eJetBrains Datalore:\u003c/strong\u003e Because Kotlin Notebook uses the same file format and Kotlin Jupyter kernel as \u003ca href=\"https://datalore.jetbrains.com/\" target=\"_blank\" rel=\"noopener\"\u003eDatalore\u003c/a\u003e, JetBrains‚Äô online data science notebook platform, your notebooks are fully compatible with it. You can simply upload the .ipynb file to Datalore to share it or continue working in the cloud. This means you can collaborate with others by simply moving the notebook to Datalore ‚Äì no conversion needed.¬†\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eBy leveraging Gists for quick snippets and Datalore for cloud collaboration, Kotlin Notebook makes sharing results and prototypes effortless. Whether you‚Äôre posting a code snippet publicly or working on data analysis with a teammate, you can move from IntelliJ IDEA to the web and back without missing a beat.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eTesting REST APIs\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eKotlin Notebook provides a powerful tool for backend and API developers: the ability to call and test RESTful APIs directly from your notebook, with full support for HTTP methods, JSON serialization, and IDE-based code completion. This is enabled through integration with Kotlin‚Äôs HTTP client, powered by Ktor.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo get started, simply add \u003ccode\u003e%use ktor-client\u003c/code\u003e to a code cell. This command pulls in a Ktor-based HTTP client and the \u003cem\u003e\u003ccode\u003ekotlinx.serialization\u003c/code\u003e\u003c/em\u003e library, both of which are ready to use. After that, you have access to a pre-configured HTTP client instance in your notebook, available through the http variable.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eStrongly-typed HTTP calls:\u003c/strong\u003e With the HTTP client integration, you can perform HTTP requests with Kotlin code and get typed results. For example, to fetch JSON data from an API, you might write:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eval response = http.get(\u0026#34;https://jsonplaceholder.typicode.com/todos/1\u0026#34;)\n\nresponse.bodyAsText()\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis will perform a \u003ccode\u003eGET\u003c/code\u003e request and return the response as pretty-printed and highlighted JSON output.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXewaAaf_YGVrUllpNZExl7JDGkYFJl0tR8oBfBxycqPeV66R-XOj1rCWaaTmbc84k8tNM5mgsnh6r85ssnPob-22r6f03hj3K-WbL3Kp546EYtuRrkv2Ud40ShhuVmWL-l6ke-UyA?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eAutomatic JSON serialization:\u003c/strong\u003e The notebook‚Äôs HTTP client is integrated with Kotlin Serialization, and your responses can be automatically deserialized:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeOMtOhTgL_-Mp1wWykGGCKfQPH0d7gGQX6MU067o1sBNj8PLYcBIsttYYNA8cFDSS9IDtyBKbi1UjilK6UwihBFN8yVCNLdOz9zxrh7C-TZv8E8mpltJj0CCAHhqYGjW34JUN6?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe Ktor client integration will automatically handle class generation and JSON deserialization itself. This means you get a typed Kotlin object with proper fields, instead of manually dealing with JSON parsing. If you have a pre-defined data class, you can also call the body() method of a response with the appropriate type argument.\u003c/p\u003e\n\n\n\n\u003cp\u003eUnder the hood, this feature relies on the open-source\u003ca href=\"https://github.com/Kotlin/kotlin-jupyter-http-util\" target=\"_blank\" rel=\"noopener\"\u003e kotlin-jupyter-http-util\u003c/a\u003e library, which brings together the Ktor client and serialization for use in notebooks. In practice, it means your Kotlin notebook can act like a full-fledged HTTP client tool (akin to Postman or a REST client), but with the added benefit of being able to script and assert on the responses in Kotlin. This is extremely handy for trying out endpoints, testing microservices, or scraping web APIs ‚Äì all within the comfort of IntelliJ IDEA.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eWorking with data: Tables and visualizations\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eData explorers will feel at home in Kotlin Notebook. The 2025.1 release enhances how data is displayed and plotted, through tight integration with the \u003cstrong\u003eKotlin DataFrame\u003c/strong\u003e library for tabular data and \u003cstrong\u003eKandy\u003c/strong\u003e for charts. These integrations turn your notebook into an interactive data exploration tool.\u003c/p\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eDataFrame integration ‚Äì interactive tables\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eWhen you add the DataFrame library, simply by putting \u003ccode\u003e%use dataframe\u003c/code\u003e in a cell, you gain access to a powerful DSL for data manipulation. It builds type information from the runtime the same way HTTP integration logic does, for example:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdOdIa-3ht_o8IrYXRc8t7E0ZfGVjqt9HQpajnrECoOSq_EVDLz08jl9ydiyUNT1kduorFlsfa-dEZT45N4lO-XcdG-DCzXsthmRNtt0jyL68a8pnN5hBF9jPFNrV7yB2_1YUgT?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAny time you display a DataFrame (for example, by evaluating a variable holding a table or by calling \u003ccode\u003edf.head())\u003c/code\u003e, Kotlin Notebook will render it using a special UI component rather than plain text. It offers:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eScrollable pagination:\u003c/strong\u003e Large datasets are handled gracefully. Instead of trying to dump thousands of rows, the table output shows a limited number of rows per page and offers navigation controls.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eSortable columns:\u003c/strong\u003e You can sort the table by a column with a single click on its header.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eHierarchical data drilling:\u003c/strong\u003e If your DataFrame has nested data (for example, a column that contains another table or complex objects), you can expand that data inline. Click on cells that contain nested structures to drill down into sub-tables. This approach to exploration is great for hierarchical JSON datasets loaded into DataFrames.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eOpen in separate tabs:\u003c/strong\u003e Sometimes you want to compare two tables side by side. You can now move a DataFrame output into its own tab within the notebook interface. Each table you open in a new tab stays accessible, so you can switch between multiple data views.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eExport to file:\u003c/strong\u003e The output panel now has an \u003cem\u003eExport\u003c/em\u003e button (üíæ). With a couple of clicks, you can export the displayed DataFrame to a file in common formats like CSV, JSON, or XML. This is useful if you‚Äôve transformed some data and want to save the results. By default, the DataFrame will be saved to your project directory, but you can choose any location. The exported data respects the currently displayed state (for instance, if you‚Äôve sorted the view by a column, the export will follow that sorted order, so you get exactly what you see).\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcVzcfGUPWuuKul1WEq6bd5e_MJqyI6_fvbNfPjPqUc7Wt3Ban2yszxSqp6i1NFpeLokpVvLGyUD7fTbb3frFF6WTYEX2FnHDlvT1CHSkgcZ7v8Gi1lgxsUJJ9DZwplmLfq-XdbvQ?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIt‚Äôs also possible to just drop a CSV onto your notebook: necessary code will be automatically generated and executed. You‚Äôll be able to work with the loaded dataframe right away.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith Kotlin DataFrame, you can load CSV and JSON files, as well as SQL query results, into tables and then filter, aggregate, and transform them with Kotlin code. Kotlin Notebook will back you up by displaying each step‚Äôs result in a user-friendly way. It‚Äôs like having a mini data grid inside your IDE for instant feedback on your data manipulations.\u003c/p\u003e\n\n\n\n\u003cp\u003eCheck out the \u003ca href=\"https://kotlin.github.io/dataframe/overview.html\" target=\"_blank\" rel=\"noopener\"\u003eofficial documentation\u003c/a\u003e to learn more about Kotlin DataFrame‚Äôs full capabilities.\u003c/p\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eVisualizing data with Kandy\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eNo data science notebook is complete without visualization. Kotlin Notebook integrates with \u003cstrong\u003eKandy\u003c/strong\u003e, a plotting library built on LetsPlot by JetBrains and created by the Kotlin team to deliver the best experience when working with Kotlin DataFrame and Kotlin Notebook. Run \u003ccode\u003e%use kandy\u003c/code\u003e in a cell to load the Kandy library and enable its rendering support in the notebook. This allows you to create charts using Kandy‚Äôs simple, type-safe DSL and have them appear right below your code.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor example, you can quickly produce a line chart for a DataFrame, df, with the columns Year and Population:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e%use kandy\n\ndf.plot {\n\n¬†¬†¬†¬†line {\n\n¬†¬†¬†¬†¬†¬†¬†¬†x(Year)\n\n¬†¬†¬†¬†¬†¬†¬†¬†y(Population)\n\n¬† width = 3.5\n\n¬† color = Color.LIGHT_BLUE\n\n¬†¬†¬†¬†}¬†\n\nlayout.title = \u0026#34;Population Growth\u0026#34;\n\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen you execute this cell, a chart will be displayed in the notebook output area.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1270\" height=\"822\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/image-22.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou can see many examples of charts in the\u003ca href=\"https://kotlin.github.io/kandy/examples.html\" target=\"_blank\" rel=\"noopener\"\u003e Kandy documentation and gallery\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eExporting and copying plots:\u003c/strong\u003e You can easily save your charts or copy them. Every plot output has an output menu (accessible via a small icon that appears at the top-right of the output when you hover over it). From this menu, select \u003cem\u003eExport Plot As‚Ä¶\u003c/em\u003e to save the chart as an image file.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you need to use the plot in another application immediately, you can choose \u003cem\u003eCopy Plot\u003c/em\u003e, which will copy the chart image to your clipboard so you can paste it into a document or chat. This workflow makes sharing visual insights from your data trivial: run a cell to create a chart, then export or copy that visualization in just a couple of clicks.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdcPe4vbLatLQkpTyImh9gBkQfCxSe6mmkIGfSL_HWgQ4b_GjtcN7J6ju6MrhWfuaAjp85KbN8-8OsjzgVg0h6nAvfzo67u8VzvLwq26yhoyZ28sfsIQHCXnntABOUrqNaZt_XjzA?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eKandy‚Äôs plotting capabilities, combined with DataFrame, enable a smooth data exploration experience. You can load and prepare data in a table and then visualize patterns with a chart ‚Äì all in Kotlin. You can even iterate, adjusting your data transformation and re-running the plot cell to see updates instantly. Kotlin Notebook ensures the charts render efficiently inside the IDE, so you don‚Äôt have to switch to an external browser for interactive visuals. For more advanced usage (like interactive plots or complex layouts), refer to the Kandy documentation, but for most needs, a few lines of Kotlin code will produce the desired chart.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eUsing JVM libraries and project code\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eKotlin has a rich ecosystem of libraries and integrates seamlessly with Java. Kotlin Notebook embraces these strengths by allowing you to bring in external libraries or your project‚Äôs own code into a notebook session easily.\u003c/p\u003e\n\n\n\n\u003ch3\u003eAdding external libraries with %use and USE {}\u003c/h3\u003e\n\n\n\n\u003cp\u003eYou have two primary options when it comes to using a third-party JVM library (for example, an HTTP client, a CSV parser, or a machine learning toolkit) in your notebook:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eIntegrated libraries via %use:\u003c/strong\u003e Kotlin Notebook comes with a collection of pre-defined library descriptors for many popular libraries (Kotlin DataFrame, Kandy, Ktor, KotlinDL, etc.). You can import these libraries with the magical  \u003ccode\u003e%use libraryName\u003c/code\u003e, without the need to think about dependencies! For example, as we saw, \u003ccode\u003e%use dataframe\u003c/code\u003e brings in the Kotlin DataFrame library and sets up its renderer, and \u003ccode\u003e%use ktor-client\u003c/code\u003e brings in Ktor and related utilities. We maintain a list of supported libraries and their descriptors \u003ca href=\"https://github.com/Kotlin/kotlin-jupyter-libraries\" target=\"_blank\" rel=\"noopener\"\u003eon GitHub\u003c/a\u003e, and many community libraries are already integrated.\u003cbr/\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eUnintegrated libraries via Gradle syntax:\u003c/strong\u003e If \u003ccode\u003e%use\u003c/code\u003e doesn‚Äôt support a given library, or you need to specify the version, you can still add it manually using a Gradle-style dependency block. Kotlin Notebook supports a special \u003ccode\u003eUSE { ... }\u003c/code\u003e code block where you can declare repositories and dependencies, for example:\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eUSE {\n\n¬†¬†¬†¬†repositories {\n\n¬†¬†¬†¬†¬†¬†¬†¬†maven(\u0026#34;https://my.repo/url\u0026#34;)\n\n¬†¬†¬†¬†}\n\n¬†¬†¬†¬†dependencies {\n\n¬†¬†¬†¬†¬†¬†¬†¬†implementation(\u0026#34;com.example:my-library:1.2.3\u0026#34;)\n\n¬†¬†¬†¬†¬†¬†¬†¬†implementation(\u0026#34;org.apache.commons:commons-text:1.10.0\u0026#34;)\n\n¬†¬†¬†¬†}\n\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cbr/\u003eThis will fetch the specified Maven artifacts and add them to the notebook‚Äôs classpath. To fine-tune how libraries are resolved, use Kotlin Notebook options.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcS5UGr1N-MWwEq1eblbXoT7EsCgWHUd8q76Yzh86ahXCGykLtMrRO-2WP5jWd69d-HwgJc1Wf4PyrzFy1J4LM3NGzxEs0WFj20YMq7f1JI-a031RyYSm1sg3HeVkDfyiqi_lC_EQ?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWhen you use either of these methods to load a library, the Kotlin Notebook kernel may perform additional integration steps if a descriptor or integration class is present. \u003ca href=\"https://github.com/Kotlin/kotlin-jupyter/blob/master/docs/libraries.md\" target=\"_blank\" rel=\"noopener\"\u003eRead more\u003c/a\u003e about defining your own library integration.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you add a library in one cell, code in subsequent cells can use it, but code in the same cell may not see it until after that cell is executed. A best practice is to put your\u003ccode\u003e %use \u003c/code\u003ecommands or \u003ccode\u003eUSE {}\u003c/code\u003e blocks at the top of the notebook or at least in their own cells. Also, if you ever restart the kernel, you‚Äôll need to re-run those dependency cells to re-establish the classpath.\u003c/p\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003ePrototyping with project code and module dependencies\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eKotlin Notebook can also interact with the code in your project, making it incredibly useful for prototyping and debugging. For example, if you have a large codebase, you can create a scratch notebook to experiment with your own APIs or data models interactively, without having to write a temporary main function or unit test.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn the 2025.1 release, using project code in notebooks has become easier, and there are more configuration options:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eModule classpath selection:\u003c/strong\u003e By default, when you open a notebook file in an IntelliJ IDEA project, the notebook‚Äôs classpath will \u003cstrong\u003enot\u003c/strong\u003e include any project dependencies. However, you can also set the notebook up to depend on all project libraries or on a particular project module with all the dependencies inside it. Switch between these options using the combobox in the notebook‚Äôs toolbar.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdiqTAjJQ41rOg-lZYMuPe_EhOyGs7ybJHQTOMCH2l_x4vHlOdXGb2XBdikoTaEqVbBkneyTRO-47oy-wvAI54sm9k30aCwfnIi3WpV2C5XqkoW55eJ2N-3aanqJW7Di2YELVZ3_w?key=oG58zccSKh1bQS-agZac1X9E\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eUp-to-date code:\u003c/strong\u003e Notebooks use the compiled classes from your project. To ensure that the latest compiled .class files are available, you should \u003cstrong\u003ebuild your project\u003c/strong\u003e before running a notebook. If you edit a source file in your project while the notebook is open, a notification will remind you to rebuild the module and restart the notebook to see the changes take effect in the notebook‚Äôs output.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eIntegrations:\u003c/strong\u003e If your project defines any integration classes for a Kotlin notebook in the module your notebook depends on, those integrations will also be loaded.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eKotlin Notebook‚Äôs approach to libraries and dependencies allows you to incorporate whatever you need ‚Äì be it a well-known library or your own code ‚Äì and use it interactively. Because Kotlin notebooks have access to your project code, you can do things like instantiate your application‚Äôs classes, call functions from your business logic, or run quick experiments on your data models. You can even use notebooks to write exploratory tests against your APIs, since notebooks allow you to run code in any order and inspect the results, which can be more flexible than a fixed unit test.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhat‚Äôs next?\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe next article will tell you about Kotlin Notebook‚Äôs advanced features. Stay tuned!\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you have any questions or suggestions, you can:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eAsk them right under this post.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eYouTrack\u003c/strong\u003e: Create a \u003ca href=\"https://youtrack.jetbrains.com/newIssue?draftId=25-6422446\" target=\"_blank\" rel=\"noopener\"\u003e#ktnb\u003c/a\u003e\u003cstrong\u003e \u003c/strong\u003eticket\u003cstrong\u003e \u003c/strong\u003eto report bugs or suggest features.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eSlack\u003c/strong\u003e: Check out \u003ca href=\"https://kotlinlang.slack.com/archives/C05333T208Y\" target=\"_blank\" rel=\"noopener\"\u003e#notebooks\u003c/a\u003e for discussions and questions.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eEmail\u003c/strong\u003e: Email \u003ca href=\"mailto:teodor.irkhin@jetbrains.com\"\u003eteodor.irkhin@jetbrains.com\u003c/a\u003e with any suggestions or requests for functionality that would allow you to incorporate Kotlin Notebook into your workflow.\u003c/li\u003e\n\u003c/ul\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "21 min read",
  "publishedTime": null,
  "modifiedTime": null
}
