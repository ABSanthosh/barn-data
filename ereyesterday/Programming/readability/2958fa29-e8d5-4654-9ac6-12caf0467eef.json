{
  "id": "2958fa29-e8d5-4654-9ac6-12caf0467eef",
  "title": "Attacks on Maven proxy repositories",
  "link": "https://github.blog/security/vulnerability-research/attacks-on-maven-proxy-repositories/",
  "description": "Learn how specially crafted artifacts can be used to attack Maven repository managers. This post describes PoC exploits that can lead to pre-auth remote code execution and poisoning of the local artifacts in Sonatype Nexus and JFrog Artifactory. The post Attacks on Maven proxy repositories appeared first on The GitHub Blog.",
  "author": "Michael Stepankin",
  "published": "Wed, 22 Jan 2025 18:00:51 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Security",
    "Vulnerability research",
    "exploit development",
    "GitHub Security Lab",
    "java",
    "maven",
    "supply chain security"
  ],
  "byline": "Michael Stepankin",
  "length": 25518,
  "excerpt": "Learn how specially crafted artifacts can be used to attack Maven repository managers. This post describes PoC exploits that can lead to pre-auth remote code execution and poisoning of the local artifacts in Sonatype Nexus and JFrog Artifactory.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "As someone who’s been breaking the security of Java applications for many years, I was always curious about the supply chain attacks on Java libraries. In 2019, I accidentally discovered an arbitrary file read vulnerability on search.maven.org, a website that is closely tied to the Maven Central Repository. Maven Central is a place where most of the Java libraries are downloaded from and its security is paramount for all companies who develop in Java. If someone is able to infiltrate Maven Central and replace a popular library, they can get the key to the whole kingdom, as almost every large tech company uses Java. Last year, I committed myself to have a look at how Maven works under the hood. I decided to challenge myself: Perhaps I could find a way to get inside? In this blog post, I’ll reveal some intriguing vulnerabilities and CVEs that I’ve recently found in popular Maven repository managers. I’ll illustrate how specially crafted artifacts can be used to attack the repository managers that distribute them. Finally, I’ll demonstrate some exploits that can lead to pre-auth remote code execution and poisoning of the local artifacts. What is Maven and how does it work? Apache Maven is a popular tool to build Java projects. One of its widely adopted features allows you to resolve dependencies for the project. In a very simplistic scenario, a developer needs to create an pom.xml file that will list all the dependencies for their project, like this: \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003cversion\u003e3.3.0\u003c/version\u003e \u003c/dependency\u003e During the build process, the developer executes the maven console tool to download these dependencies for local use. For example, the widely used mvn package command invokes Maven Artifact Resolver to make the following HTTP request to download this dependency: GET /org/springframework/boot/spring-boot-starter-web/3.3.0/spring-boot-starter-web-3.3.0.jar Host: repo.maven.apache.org Since the artifact can have its own dependencies, maven also fetches the /org/springframework/boot/spring-boot-starter-web/3.3.0/pom.xml file to identify and download all transitive dependencies. Downloaded dependencies are stored in the local file system (on MacOS it’s ~/.m2/repository) following the Maven Repository Layout. Attack surface It’s important to note that Maven, as a console tool, is built with some security assumptions in mind: The purpose of Maven is to perform the actions defined in the supplied pom.xml, which commonly includes compiling and running the associated code and using plugins and dependencies downloaded from the configured repositories. As such, the Maven security model assumes you trust the pom.xml and the code, dependencies, and repositories used in your build. If you want to use Maven to build untrusted code, it’s up to you to provide the required isolation. Maven repositories (places from where artifacts are downloaded), on the other hand, are essentially web applications that allow uploading, storing, and downloading compiled artifacts. Their security is crucial, because if a hacker is able to publish or replace a commonly used artifact in them, all repository clients will execute the malicious code from this artifact. Maven Central and other public repositories By default, Maven downloads all dependencies from https://repo.maven.apache.org, the address of the Maven Central repository. It is hardcoded in the default installation of Maven, but can be changed in settings. This website is hosted by Sonatype on AWS S3 buckets and served with Fastly CDN. Image source: Sonatype, The Secret Life of Maven Central Maven Central repository is public. Anybody can publish an artifact to it, but users’ publishing rights are restricted by the groupId ownership. So, only the company or user who owns the org.springframework.boot groupId is allowed to publish artifacts with this groupId. To upload artifacts, publishers can use either a new Sonatype Central Portal or a legacy OSSRH (OSS Repository Hosting). Maven Central has a complex infrastructure hosted by Sonatype. At GitHub Security Lab, we only audit open source code, which means that Sonatype’s website is out of scope for us. Still, I realized that a lot of companies publish through the legacy OSSRH portal (https://oss.sonatype.org/), which is backed by the product Sonatype Nexus 2. Apart from Maven Central, there are also some other public Maven repositories: Address Product Maven Central (default) repo1.maven.org, repo.maven.apache.org Amazon S3 + Fastly Infrastructure is managed by Sonatype Maven Central OSSRH (synced with default) oss.sonatype.org, s01.oss.sonatype.org Sonatype Nexus 2 Apache repository.apache.org Sonatype Nexus 2 (behind a proxy) Spring repo.spring.io JFrog Artifactory Atlassian packages.atlassian.com JFrog Artifactory JBoss repository.jboss.org Sonatype Nexus 2 As you can see from the table, the biggest repositories are powered by two major products: Sonatype Nexus and JFrog Artifactory. These products are (partially) open source and have free versions that you can test locally. So in my research, I decided to challenge myself with breaking the security of these repository managers. Additionally, I thought it would be good to also include a completely free open source alternative: Reposilite. In-house Maven repository managers While downloading artifacts from Maven Central and other public repositories is free, many companies choose to use their own in-house Maven repository managers for additional benefits, such as: Ability to publish and use company’s private artifacts Ability to restrict and get clarity on which libraries are used within the organization Reduced bandwidth consumption by minimizing external network calls These in-house repository managers are powered by the same open source products as the public repositories: Nexus, JFrog, and Reposilite. All of these products support multiple access roles. Typically an anonymous role allows you to download any artifact, a developer’s role can publish new artifacts, and an admin role can manage repositories, users, and enforce policies. Looking at Proxy mode from a security perspective Apart from handling artifacts developed within a company, Maven repository managers are also often used as dedicated proxy servers for public Maven repositories. In this mode, when a repository manager handles a request to download an artifact, it first checks if the artifact is available locally. If not, it forwards this request to the upstream repository. The proxy mode is particularly interesting from the security perspective. First, because it allows even anonymous users to fetch their own artifact from the public repository and plant it in the local repository manager. Second, because in-house repository managers not only store and serve these artifacts, but also try to have a “sneak peek” into their content by expanding archives, analyzing “pom.xml” files, building dependency graphs, checking them for malware, and displaying their content in the Admin UI. This may introduce a second-order vulnerability when an attacker uploads a specially crafted artifact to the public repository first, and then uses it to attack the in-house manager. As someone who built DAST and SAST products in the past, I know firsthand that these types of issues are very hard to detect with automation, so I decided to have a look at the source code to manually identify some. Attacks on proxy Mode: Stored XSS Artifacts published to Maven repositories are normally the JAR archives that contain compiled java classes (with .class file extension), but technically they can contain arbitrary data and extensions. All the repository managers I tested have their web admin interfaces listening on the same port as the application that serves the artifact’s content. So, what if an artifact’s pom.xml file contains some JavaScript inside? \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003ca:script xmlns:a=\"http://www.w3.org/1999/xhtml\"\u003e alert(`Secret key: ${localStorage.getItem('token-secret')}`) \u003c/a:script\u003e It turned out that at least two of the tested Repository managers (Reposilite and Sonatype Nexus 2) fall into this basic Stored XSS vulnerability. The problem lies in the fact that the artifact’s content is served via the same origin (protocol/host/port) as the Admin UI. If the artifact contains HTML content with javascript inside, the javascript is executed within the same origin. Therefore, if an authenticated user views the artifact’s content, the javascript inside can make authenticated requests to the Admin area, which can lead to the modification of other artifacts, and subsequently to remote code execution on users who download them. In case of the Reposilite vulnerability, an XSS payload can be used to access the browser’s local storage where the user’s password (aka “token-secret”) is located. That’s game over, as the same token can be used on another device to access the admin area. How to protect from that? Obviously, we cannot “escape” the special characters, as it would break the legitimate functionality. Instead, a combination of the following approaches can be used: “Content-Security-Policy: sandbox;” header when serving the artifact’s content. This means the resource will be treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs). It’s an elegant solution to protect the Admin area, but it still allows HTML content rendering, leaving some opportunities for phishing. “Content-Disposition: attachment” header. This will prevent the browser from displaying the content entirely, so it just saves it to the “Download” folder. This may affect the UX though. Example: Look at the advisories for CVE-2024-36115 in Reposilite and CVE-2024-5083 in Sonatype Nexus 2 on the GitHub Security Lab website. Archive expansion and path traversal All the tested Repository managers support unpacking the artifact’s files on the server to serve individual files from the archive. Most of them use Java’s ZipInputStream interface, which allows you to do it in-memory only, without storing anything on disk, which makes it safe from path traversal vulnerabilities. Still, I was able to find one instance of this vulnerability in Reposilite’s support for JavaDoc files. CVE-2024-36116: Arbitrary file overwrite in Reposilite JavadocContainerService.kt#L127-L136 jarFile.entries().asSequence().forEach { file -\u003e if (file.isDirectory) { return@forEach } val path = Paths.get(javadocUnpackPath.toString() + \"/\" + file.name) path.parent?.also { parent -\u003e Files.createDirectories(parent) } jarFile.getInputStream(file).copyToAndClose(path.outputStream()) }.asSuccess\u003cUnit, ErrorResponse\u003e() The file.name taken from the archive can contain path traversal characters, such as ‘/../../../anything.txt’, so the resulting extraction path can be outside the target directory. If the archive is taken from an untrusted source, such as Maven Central, an attacker can craft a special archive to overwrite any local file on the repository manager. In the case of Reposilite, this could lead to remote code execution, for example by placing a new plugin into the $workspace$/plugins directory. Alternatively, an attacker can overwrite the content of any other package. CVE-2024-36117: Arbitrary file read in Reposilite Another CVE I discovered in Reposilite was in the way the expanded javadoc files are served. Reposilite has the GET /javadoc/{repository}/\u003cgav\u003e/raw/\u003cresource\u003e route to find the file in the exploded archive and return its content to the user. In that case, the path parameter can contain URL-encoded path traversal characters such as /../. Since the path is concatenated with the main directory, it opens the possibility to read files outside the target directory. I reported both of these vulnerabilities using GitHub’s Private Vulnerability Reporting feature. If you want to read more details about them, look at the advisories for CVE-2024-36116: Arbitrary file overwrite in Reposilite and CVE-2024-36117: Leaking internal database in Reposilite. Name confusion attacks When a repository manager processes requests to download artifacts, it needs to map the incoming URL path value to the artifact’s coordinates: GroupId, ArtifactId, and Version (commonly known as GAV). The Maven documentation suggests using the following convention for mapping from URL path to GAV: /${groupId}/${artifactId}/${baseVersion}/${artifactId}-${version}-${classifier}.${extension} GroupId can contain multiple forward slashes, which are translated to dots while parsing. For instance, the following URL path: GET /org/apache/maven/apache-maven/3.8.4/apache-maven-3.8.4-bin.tar.gz HTTP/1.1 will be translated to these coordinates: groupId: org.apache.maven artifactId:apache-maven version: 3.8.4:bin:tar.gz classifier: bin Extension: tar.gz While this operation looks like a simple regexp matching, there is some room for misinterpretation, especially in how the URL decoding, path normalization, and control characters of the URL are handled. For instance, if the path contains any special url encoded characters, such as “?” (%3b) or “#” (%23), they will be decoded and considered as part of the artifact name: GET /com/company/artifact/1.0/artifact-1.0.jar%23/xyz/anything.any?isRemote=true Interpreted by proxy and transferred to upstream as: /com/company/artifact/1.0/artifact-1.0.jar\\#/xyz/anything.any On the upstream server however, everything after the hash sign will be parsed as hash properties. The path to artifact will be truncated to: /com/company/artifact/1.0/artifact-1.0.jar#/xyz/anything.any Essentially, this would allow attackers to create files on the target proxy repository with arbitrary names and extensions, as long as their path starts with a predefined value, for example: This behavior affects almost every product I tested, but it’s hardly exploitable on its own, as no client would use an artifact with such a weird name. While testing this, I noticed that JFrog Artifactory also has a special handling for the semicolon character “;”. Artifactory considers everything in the path after semicolon as “path parameters”, but not a part of the artifact name. GET /com/company1/artifact1/1.0/artifact1-1.0.jar;/../../../../company2/artifact2/2.0/artifact2-2.0.jar When processing a request like that, JFrog considers artifact1-1.0.jar as the artifact name, but still forwards the full url to the upstream repository. Contrary to that, Nexus 3 and some public servers perform path normalization and reduce this path to /company2/artifact2/2.0/artifact2-2.0.jar, which is expected according to RFC 3986. In cases where Artifactory is configured to proxy an external repository, this behavior can lead to a severe vulnerability: artifact poisoning (CVE-2024-6915). Technically, it allows saving any HTTP response from the remote endpoint to an arbitrary artifact on the Artifactory instance. The straightforward way to exploit that would be to publish a malicious artifact into the upstream repository with any name, and then save it under a commonly used name on Artifactory, (for example, “spring-boot-starter-web”). Then, the next time a client fetches this commonly used artifact, Artifactory will serve malicious content of another package. In cases when an attacker is unable to publish anything into the upstream repository, it can still be potentially exploitable with an open redirect or a reflected/stored XSS on the upstream server. Artifactory does not check what is passed after “;/../”, so it can be not only an “artifact2-2.0.jar” but any relative URL path. The ultimate requirement for this exploitation is that the upstream server should perform a path normalization process to consume “/../” characters. Maven Central repository does not perform it, but several other public repositories such as Apache or JitPack do. Moreover, this vulnerability in JFrog Artifactory affects not only Maven repositories, but any other proxy types, such as npm or Docker repositories. artifact/../ artifact/%2e%2e/ Maven Central repo1.maven.org ✗ ✗ Apache repository.apache.org ✓* ✓ JitPack jitpack.io ✓ ✗ npm ✓ ✗ Docker Registry ✓ ✓ Rubygems.io ✗ ✗ Python Package Index (PyPI) ✗ ✗ GO package registry (gocenter.io) ✓ ✗ “✓” means path traversal is accepted by repository, “✗” – not Example CVE-2024-6915: Is it even or is it odd? To demonstrate its impact in my bug bounty report, I chose to use an Artifactory instance that proxies to npm. Npm has a different layout than Maven, but the core idea is the same: we just need to overwrite a package.json file with the content of another package. In the following request, we simply replace the package.json file of the is-even package with the content of the is-odd package. When I install this poisoned package from Artifactory, the npm client shows a warning that the name in the package.json file (is-odd) is different from the requested one (is-even), but as the downloaded file is properly formatted and contains the links to archive with the source code, the npm client still downloads and executes it. The npm client is designed with the assumption that it trusts the source. If the integrity of the source registry is compromised (which was the case for JFrog Artifactory), npm clients cannot really do anything to protect from such malicious artifacts. Even hash checksums can be bypassed if they are tampered with in Artifactory. When I reported this issue to the JFrog bug bounty program, it was assigned a critical severity and later awarded with a $5000 bounty. Since I’m doing this research as a part of my work at GitHub, we donated the full bounty amount to charity, specifically Cancer Research UK. Magic parameters for exploiting name confusion attacks Both Nexus and JFrog support some URL query parameters for proxy repositories. In JFrog Artifactory, the following parameters are accepted: When attacking proxy repositories, these parameters may be applied on the proxy side, or “smuggled” into the upstream repository by using URL encoding. In both cases, they may alter how one or another repository processes the request, leaving options for potential exploitation. For example, by applying a :properties suffix to the path, we can trigger a local redirect to the same URL. By default, Artifactory does not perform path normalization for incoming requests, but with a redirect we can force the path normalization to be performed on the HTTP client side, instead of the server. It may help to perform a path traversal for name confusion attacks. Nexus 2 also supports a few parameters, but perhaps only these two are interesting for attackers: Along with the artifacts uploaded by the users, repository managers also store additional metadata, such as checksums, creation date, the user who uploaded it, number of downloads, etc. Most of this data is stored in the database, but some repository managers also store files in the same directory as artifacts. For instance, Nexus 2 stores the following files: /.meta/repository-metadata.xml – contains repository properties in XML format /.meta/prefixes.txt /.index/nexus-maven-repository-index.properties /.index/nexus-maven-repository-index.gz /.nexus/tmp/\u003cartifact\u003enx-tmp\u003crandom\u003e.nx-upload – temporary file name during artifact’s upload /.nexus/attributes/\u003cartifact-name\u003e – for every artifact, Nexus creates this json file with artifact’s metadata The last file is the only one that Nexus prohibits access to. Indeed if you try to download or upload a file that starts with /.nexus/attributes/, Nexus rejects this request: At the same time, I figured out that we can circumvent this protection by using a different prefix (/nexus/service/local/repositories/test/content/ instead of /nexus/content/repositories/test/) and by using a double slash before the .nexus/attributes: Reading local attributes is probably not that interesting for attackers, but the same bug can be abused to overwrite them using PUT HTTP requests instead of GET. By default, Nexus does not allow you to update artifact’s content in its release repositories, but we can update the attributes of any maven-metadata.xml file: For exploitation purposes, I discovered a supported attribute that is particularly interesting: “contentGenerator”:”velocity”. If present, this attribute changes the way how the artifact’s content is rendered, enabling resolution of Velocity templates in the artifact’s content. So if we upload the ‘maven-metadata.xml’ file with the following content: And then reissue the previous PUT request to update the attributes, the content of the ‘maven-metadata.xml’ file will be rendered as a Velocity template. Sweet, as the velocity template I used in the example above triggers the execution of the java.lang.Runtime.getRuntime().exec(\"id\") command. It’s not a real RCE unless it’s pre-auth To overwrite the metadata in the previous requests, I used a ‘PUT’ request method that requires the cookie of a user who has sufficient privileges to upload artifacts. This severely reduces the potential impact, as obtaining even a low-privileged account on the target repository might be a difficult task. Still, it wouldn’t be like myself if I didn’t try to find a way to exploit it without any authentication. One of the ways to achieve that would be combining this vulnerability with the stored XSS (CVE-2024-5083) in proxy repositories that I discovered earlier. Planting an XSS payload would not require any permissions on Nexus. Still, that XSS requires an administrator user to view an artifact, with a valid session, so the exploitation is still not that clean. Another way to trigger this vulnerability would be through a ‘proxy’ repository. If an attacker is able to publish an artifact into the upstream repository, it’s possible to exploit this vulnerability without any authentication on Nexus. You may reasonably assume that publishing an artifact with a Maven Group ID that starts with ‘.nexus/attributes’ may be unrealistic in popular upstream repositories like Maven Central, Apache Snapshots or JitPack. While I could not test this myself in their production systems, I noticed that one may publish an artifact with the group ID of ‘org.example’ and then force Nexus to save it as /.nexus/attributes/… with the same path traversal trick as in the name confusion attacks: GET /nexus/service/local/repositories/apache-snapshots/content//.nexus/attributes/%252e./%252e./com/sbt/ignite/ignite-bom/maven-metadata.xml When processing this request, Nexus will decode the URL path to /.nexus/attributes/%2e./%2e./com/sbt/ignite/ignite-bom/maven-metadata.xml and forward it to the Apache Snapshots upstream repository. Then, Apache’s repository will (quite reasonably) perform URI normalization and return the content of the file. This would allow you to store an artifact with an arbitrary name from Apache Snapshots in the /.nexus/attributes/ directory. Apache Snapshots is enabled by default in the Nexus installation. Also, as I mentioned earlier, pulling artifacts from it does not require any permissions on Nexus—it can be done with a simple GET request without any cookies. A real attacker would probably try to publish their own artifact to the Apache Snapshots repository and therefore use it to attack all Nexus instances worldwide. Additionally, it’s possible to enumerate all the Apache user names and their emails. Perhaps some of their credentials can be found on websites that accumulate leaked passwords, but testing these kinds of attacks lies beyond the legal and moral scope of my research. Summary As we can see, using repository managers such as Nexus, JFrog, and Reposilite in proxy mode can introduce an attack surface that is otherwise only available to authenticated users. All tested solutions not only store and serve artifacts, but also perform complex parsing and indexing operations on them. Therefore, a specially crafted artifact can be used to attack the repository manager that processes it. This opens a possibility for XSS, XXE, archive expansion, and path traversal attacks. The innate URL decoding mechanism along with special characters sparks parsing discrepancies. All repository managers parse URLs differently and cache proxied artifacts locally, which can lead to cache poisoning vulnerabilities, such as CVE-2024-6915 in JFrog, for example. The major public and private Maven repositories are powered by just a few partially open source solutions. Although these solutions are already backed by reputable companies with strong security teams and bug bounty programs, it’s still possible to find critical vulnerabilities in them. Lastly, these kinds of attacks are not even specific to Maven, but for all other dependency ecosystems, whether its NPM, Docker, RubyGems or anything else. I encourage every hacker to test this ‘proxy repository’ functionality in other products as well, as this may bring about many fruitful findings. Note: I presented this research at the Ekoparty Security Conference in November 2024. Tags: exploit development GitHub Security Lab java maven supply chain security Written by",
  "image": "https://github.blog/wp-content/uploads/2023/12/Security-DarkMode-1-2.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eAs someone who’s been breaking the security of Java applications for many years, I was always curious about the supply chain attacks on Java libraries. In 2019, I accidentally discovered an arbitrary file read vulnerability on \u003ca href=\"http://search.maven.org\"\u003esearch.maven.org\u003c/a\u003e, a website that is closely tied to the Maven Central Repository. Maven Central is a place where most of the Java libraries are downloaded from and its security is paramount for all companies who develop in Java. If someone is able to infiltrate Maven Central and replace a popular library, they can get the key to the whole kingdom, as almost every large tech company uses Java.\u003c/p\u003e\n\u003cp\u003eLast year, I committed myself to have a look at how Maven works under the hood. I decided to challenge myself: Perhaps I could find a way to get inside?\u003c/p\u003e\n\u003cp\u003eIn this blog post, I’ll reveal some intriguing vulnerabilities and CVEs that I’ve recently found in popular Maven repository managers. I’ll illustrate how specially crafted artifacts can be used to attack the repository managers that distribute them. Finally, I’ll demonstrate some exploits that can lead to pre-auth remote code execution and poisoning of the local artifacts.\u003c/p\u003e\n\u003ch2 id=\"what-is-maven-and-how-does-it-work\" id=\"what-is-maven-and-how-does-it-work\"\u003eWhat is Maven and how does it work?\u003ca href=\"#what-is-maven-and-how-does-it-work\" aria-label=\"What is Maven and how does it work?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eApache Maven is a popular tool to build Java projects. One of its widely adopted features allows you to resolve dependencies for the project. In a very simplistic scenario, a developer needs to create an pom.xml file that will list all the dependencies for their project, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;dependency\u0026gt;\n\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n\u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt;\n\u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDuring the build process, the developer executes the maven console tool to download these dependencies for local use. For example, the widely used \u003ccode\u003emvn package\u003c/code\u003e command invokes \u003ca href=\"https://maven.apache.org/resolver/\"\u003eMaven Artifact Resolver\u003c/a\u003e to make the following HTTP request to download this dependency:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGET /org/springframework/boot/spring-boot-starter-web/3.3.0/spring-boot-starter-web-3.3.0.jar\nHost: repo.maven.apache.org\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince the artifact can have its own dependencies, maven also fetches the \u003ccode\u003e/org/springframework/boot/spring-boot-starter-web/3.3.0/pom.xml\u003c/code\u003e file to identify and download all transitive dependencies.\u003c/p\u003e\n\u003cp\u003eDownloaded dependencies are stored in the local file system (on MacOS it’s \u003ccode\u003e~/.m2/repository\u003c/code\u003e) following the \u003ca href=\"https://maven.apache.org/repositories/layout.html\"\u003eMaven Repository Layout\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"attack-surface\" id=\"attack-surface\"\u003eAttack surface\u003ca href=\"#attack-surface\" aria-label=\"Attack surface\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIt’s important to note that Maven, as a console tool, is built with some \u003ca href=\"https://maven.apache.org/security.html\"\u003esecurity assumptions\u003c/a\u003e in mind:\u003c/p\u003e\n\u003cblockquote\u003e\u003cp\u003e\n  The purpose of Maven is to perform the actions defined in the supplied pom.xml, which commonly includes compiling and running the associated code and using plugins and dependencies downloaded from the configured repositories.\u003c/p\u003e\n\u003cp\u003e  As such, the Maven security model assumes you trust the pom.xml and the code, dependencies, and repositories used in your build. If you want to use Maven to build untrusted code, it’s up to you to provide the required isolation.\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eMaven repositories (places from where artifacts are downloaded), on the other hand, are essentially web applications that allow uploading, storing, and downloading compiled artifacts. Their security is crucial, because if a hacker is able to publish or replace a commonly used artifact in them, all repository clients will execute the malicious code from this artifact.\u003c/p\u003e\n\u003ch2 id=\"maven-central-and-other-public-repositories\" id=\"maven-central-and-other-public-repositories\"\u003eMaven Central and other public repositories\u003ca href=\"#maven-central-and-other-public-repositories\" aria-label=\"Maven Central and other public repositories\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eBy default, Maven downloads all dependencies from \u003ccode\u003ehttps://repo.maven.apache.org\u003c/code\u003e, the address of the Maven Central repository. It is hardcoded in the default installation of Maven, but can be changed in settings. This website is hosted by Sonatype on AWS S3 buckets and served with Fastly CDN.\u003c/p\u003e\n\u003cfigure id=\"attachment_82168\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1600\" height=\"900\" src=\"https://github.blog/wp-content/uploads/2025/01/maven-infra.png?w=1024\u0026amp;resize=1600%2C900\" alt=\"Maven Infrastructure\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/maven-infra.png?w=1600 1600w, https://github.blog/wp-content/uploads/2025/01/maven-infra.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/maven-infra.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/maven-infra.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/maven-infra.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003cfigcaption\u003eImage source: Sonatype, The Secret Life of Maven Central\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eMaven Central repository is public. Anybody can publish an artifact to it, but users’ publishing rights are restricted by the \u003ccode\u003egroupId\u003c/code\u003e ownership. So, only the company or user who owns the \u003ccode\u003eorg.springframework.boot\u003c/code\u003e groupId is allowed to publish artifacts with this groupId. To upload artifacts, publishers can use either a new \u003ca href=\"https://central.sonatype.org/publish-ea/publish-ea-guide/\"\u003eSonatype Central Portal\u003c/a\u003e or a legacy \u003ca href=\"https://central.sonatype.org/publish/publish-guide/\"\u003eOSSRH (OSS Repository Hosting)\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eMaven Central has a complex infrastructure hosted by Sonatype. At GitHub Security Lab, we only audit open source code, which means that Sonatype’s website is out of scope for us. Still, I realized that a lot of companies publish through the legacy OSSRH portal (https://oss.sonatype.org/), which is backed by the product Sonatype Nexus 2.\u003c/p\u003e\n\u003cp\u003eApart from Maven Central, there are also some other public Maven repositories:\u003c/p\u003e\n\u003cdiv\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003eAddress\u003c/th\u003e\n\u003cth\u003eProduct\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eMaven Central (default)\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003erepo1.maven.org\u003c/code\u003e, \u003ccode\u003erepo.maven.apache.org\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eAmazon S3 + Fastly Infrastructure is managed by Sonatype\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMaven Central OSSRH (synced with default)\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eoss.sonatype.org\u003c/code\u003e, \u003ccode\u003es01.oss.sonatype.org\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eSonatype Nexus 2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eApache\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003erepository.apache.org\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eSonatype Nexus 2 (behind a proxy)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSpring\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003erepo.spring.io\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eJFrog Artifactory\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eAtlassian\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003epackages.atlassian.com\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eJFrog Artifactory\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eJBoss\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003erepository.jboss.org\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eSonatype Nexus 2\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\u003c/div\u003e\n\u003cp\u003eAs you can see from the table, the biggest repositories are powered by two major products: \u003cstrong\u003eSonatype Nexus\u003c/strong\u003e and \u003cstrong\u003eJFrog Artifactory\u003c/strong\u003e. These products are (partially) open source and have free versions that you can test locally.\u003c/p\u003e\n\u003cp\u003eSo in my research, I decided to challenge myself with breaking the security of these repository managers. Additionally, I thought it would be good to also include a completely free open source alternative: \u003ca href=\"https://github.com/dzikoysk/reposilite\"\u003e\u003cstrong\u003eReposilite\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"in-house-maven-repository-managers\" id=\"in-house-maven-repository-managers\"\u003eIn-house Maven repository managers\u003ca href=\"#in-house-maven-repository-managers\" aria-label=\"In-house Maven repository managers\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWhile downloading artifacts from Maven Central and other public repositories is free, many companies choose to use their own in-house Maven repository managers for additional benefits, such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAbility to publish and use company’s private artifacts  \u003c/li\u003e\n\u003cli\u003eAbility to restrict and get clarity on which libraries are used within the organization  \u003c/li\u003e\n\u003cli\u003eReduced bandwidth consumption by minimizing external network calls\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese in-house repository managers are powered by the same open source products as the public repositories: Nexus, JFrog, and Reposilite.\u003c/p\u003e\n\u003cp\u003eAll of these products support multiple access roles. Typically an anonymous role allows you to download any artifact, a developer’s role can publish new artifacts, and an admin role can manage repositories, users, and enforce policies.\u003c/p\u003e\n\u003ch2 id=\"looking-at-proxy-mode-from-a-security-perspective\" id=\"looking-at-proxy-mode-from-a-security-perspective\"\u003eLooking at Proxy mode from a security perspective\u003ca href=\"#looking-at-proxy-mode-from-a-security-perspective\" aria-label=\"Looking at Proxy mode from a security perspective\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eApart from handling artifacts developed within a company, Maven repository managers are also often used as dedicated proxy servers for public Maven repositories. In this mode, when a repository manager handles a request to download an artifact, it first checks if the artifact is available locally. If not, it forwards this request to the upstream repository.\u003c/p\u003e\n\u003cp\u003eThe proxy mode is particularly interesting from the security perspective. First, because it allows even anonymous users to fetch their own artifact from the public repository and plant it in the local repository manager. Second, because in-house repository managers not only store and serve these artifacts, but also try to have a “sneak peek” into their content by expanding archives, analyzing “pom.xml” files, building dependency graphs, checking them for malware, and displaying their content in the Admin UI.\u003c/p\u003e\n\u003cp\u003eThis may introduce a second-order vulnerability when an attacker uploads a specially crafted artifact to the public repository first, and then uses it to attack the in-house manager. As someone who built DAST and SAST products in the past, I know firsthand that these types of issues are very hard to detect with automation, so I decided to have a look at the source code to manually identify some.\u003c/p\u003e\n\u003ch2 id=\"attacks-on-proxy-mode-stored-xss\" id=\"attacks-on-proxy-mode-stored-xss\"\u003eAttacks on proxy Mode: Stored XSS\u003ca href=\"#attacks-on-proxy-mode-stored-xss\" aria-label=\"Attacks on proxy Mode: Stored XSS\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eArtifacts published to Maven repositories are normally the JAR archives that contain compiled java classes (with \u003ccode\u003e.class\u003c/code\u003e file extension), but technically they can contain arbitrary data and extensions. All the repository managers I tested have their web admin interfaces listening on the same port as the application that serves the artifact’s content. So, what if an artifact’s pom.xml file contains some JavaScript inside?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\n\u0026lt;a:script xmlns:a=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt;\n    alert(`Secret key: ${localStorage.getItem(\u0026#39;token-secret\u0026#39;)}`)\n\u0026lt;/a:script\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/reposilite-xss.png?w=1024\u0026amp;resize=1024%2C392\" alt=\"Reposilite XSS\" width=\"1024\" height=\"392\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/reposilite-xss.png?w=1498 1498w, https://github.blog/wp-content/uploads/2025/01/reposilite-xss.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/reposilite-xss.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/reposilite-xss.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eIt turned out that at least two of the tested Repository managers (Reposilite and Sonatype Nexus 2) fall into this basic Stored XSS vulnerability. The problem lies in the fact that the artifact’s content is served via the same origin (protocol/host/port) as the Admin UI. If the artifact contains HTML content with javascript inside, the javascript is executed within the same origin. Therefore, if an authenticated user views the artifact’s content, the javascript inside can make authenticated requests to the Admin area, which can lead to the modification of other artifacts, and subsequently to remote code execution on users who download them.\u003c/p\u003e\n\u003cp\u003eIn case of the Reposilite vulnerability, an XSS payload can be used to access the browser’s local storage where the user’s password (aka “token-secret”) is located. That’s game over, as the same token can be used on another device to access the admin area.\u003c/p\u003e\n\u003cp\u003eHow to protect from that? Obviously, we cannot “escape” the special characters, as it would break the legitimate functionality. Instead, a combination of the following approaches can be used:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e“Content-Security-Policy: sandbox;” header when serving the artifact’s content. This means the resource will be treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs). It’s an elegant solution to protect the Admin area, but it still allows HTML content rendering, leaving some opportunities for phishing.  \u003c/li\u003e\n\u003cli\u003e“Content-Disposition: attachment” header. This will prevent the browser from displaying the content entirely, so it just saves it to the “Download” folder. This may affect the UX though.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eExample: Look at the advisories for \u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-072_GHSL-2024-074_Reposilite/\"\u003eCVE-2024-36115 in Reposilite\u003c/a\u003e and \u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-075_GHSL-2024-076_Sonatype_Nexus_2/\"\u003eCVE-2024-5083 in Sonatype Nexus 2\u003c/a\u003e on the GitHub Security Lab website.\u003c/p\u003e\n\u003ch2 id=\"archive-expansion-and-path-traversal\" id=\"archive-expansion-and-path-traversal\"\u003eArchive expansion and path traversal\u003ca href=\"#archive-expansion-and-path-traversal\" aria-label=\"Archive expansion and path traversal\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAll the tested Repository managers support unpacking the artifact’s files on the server to serve individual files from the archive. Most of them use Java’s ZipInputStream interface, which allows you to do it in-memory only, without storing anything on disk, which makes it safe from path traversal vulnerabilities.\u003c/p\u003e\n\u003cp\u003eStill, I was able to find one instance of this vulnerability in Reposilite’s support for JavaDoc files.\u003c/p\u003e\n\u003ch3 id=\"cve-2024-36116-arbitrary-file-overwrite-in-reposilite\" id=\"cve-2024-36116-arbitrary-file-overwrite-in-reposilite\"\u003eCVE-2024-36116: Arbitrary file overwrite in Reposilite\u003ca href=\"#cve-2024-36116-arbitrary-file-overwrite-in-reposilite\" aria-label=\"CVE-2024-36116: Arbitrary file overwrite in Reposilite\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/dzikoysk/reposilite/blob/68b73f19dc9811ccf10936430cf17f7b0e622bd6/reposilite-backend/src/main/kotlin/com/reposilite/javadocs/JavadocContainerService.kt#L127-L136\"\u003eJavadocContainerService.kt#L127-L136\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ejarFile.entries().asSequence().forEach { file -\u0026gt;\n    if (file.isDirectory) {\n        return@forEach\n    }\n\n    val path = Paths.get(javadocUnpackPath.toString() + \u0026#34;/\u0026#34; + file.name)\n\n    path.parent?.also { parent -\u0026gt; Files.createDirectories(parent) }\n    jarFile.getInputStream(file).copyToAndClose(path.outputStream())\n}.asSuccess\u0026lt;Unit, ErrorResponse\u0026gt;()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003efile.name\u003c/code\u003e taken from the archive can contain path traversal characters, such as ‘/../../../anything.txt’, so the resulting extraction path can be outside the target directory.\u003c/p\u003e\n\u003cp\u003eIf the archive is taken from an untrusted source, such as Maven Central, an attacker can craft a special archive to overwrite any local file on the repository manager. In the case of Reposilite, this could lead to remote code execution, for example by placing a new plugin into the \u003ccode\u003e$workspace$/plugins\u003c/code\u003e directory. Alternatively, an attacker can overwrite the content of any other package.\u003c/p\u003e\n\u003ch3 id=\"cve-2024-36117-arbitrary-file-read-in-reposilite\" id=\"cve-2024-36117-arbitrary-file-read-in-reposilite\"\u003eCVE-2024-36117: Arbitrary file read in Reposilite\u003ca href=\"#cve-2024-36117-arbitrary-file-read-in-reposilite\" aria-label=\"CVE-2024-36117: Arbitrary file read in Reposilite\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAnother CVE I discovered in Reposilite was in the way the expanded javadoc files are served. Reposilite has the \u003ccode\u003eGET /javadoc/{repository}/\u0026lt;gav\u0026gt;/raw/\u0026lt;resource\u0026gt;\u003c/code\u003e route to find the file in the exploded archive and return its content to the user.\u003c/p\u003e\n\u003cp\u003eIn that case, the \u003cresource\u003e path parameter can contain URL-encoded path traversal characters such as \u003ccode\u003e/../.\u003c/code\u003e Since the path is concatenated with the main directory, it opens the possibility to read files outside the target directory.\u003c/resource\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/reposilite-file-read.png?w=1024\u0026amp;resize=1024%2C381\" alt=\"Reposilite file read\" width=\"1024\" height=\"381\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/reposilite-file-read.png?w=1600 1600w, https://github.blog/wp-content/uploads/2025/01/reposilite-file-read.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/reposilite-file-read.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/reposilite-file-read.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/reposilite-file-read.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eI reported both of these vulnerabilities using GitHub’s \u003ca href=\"https://docs.github.com/en/code-security/security-advisories/guidance-on-reporting-and-writing-information-about-vulnerabilities/privately-reporting-a-security-vulnerability\"\u003ePrivate Vulnerability Reporting\u003c/a\u003e feature. If you want to read more details about them, look at the advisories for \u003ca href=\"https://github.com/dzikoysk/reposilite/security/advisories/GHSA-frvj-cfq4-3228\"\u003eCVE-2024-36116: Arbitrary file overwrite in Reposilite\u003c/a\u003e and \u003ca href=\"https://github.com/dzikoysk/reposilite/security/advisories/GHSA-82j3-hf72-7x93\"\u003eCVE-2024-36117: Leaking internal database in Reposilite\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"name-confusion-attacks\" id=\"name-confusion-attacks\"\u003eName confusion attacks\u003ca href=\"#name-confusion-attacks\" aria-label=\"Name confusion attacks\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWhen a repository manager processes requests to download artifacts, it needs to map the incoming URL path value to the artifact’s coordinates: GroupId, ArtifactId, and Version (commonly known as GAV).\u003c/p\u003e\n\u003cp\u003eThe Maven \u003ca href=\"https://maven.apache.org/repositories/layout.html\"\u003edocumentation\u003c/a\u003e suggests using the following convention for mapping from URL path to GAV:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e/${groupId}/${artifactId}/${baseVersion}/${artifactId}-${version}-${classifier}.${extension}\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eGroupId can contain multiple forward slashes, which are translated to dots while parsing. For instance, the following URL path:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eGET /org/apache/maven/apache-maven/3.8.4/apache-maven-3.8.4-bin.tar.gz HTTP/1.1\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003ewill be translated to these coordinates:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egroupId: org.apache.maven\nartifactId:apache-maven\nversion: 3.8.4:bin:tar.gz\nclassifier: bin\nExtension: tar.gz\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhile this operation looks like a simple regexp matching, there is some room for misinterpretation, especially in how the URL decoding, path normalization, and control characters of the URL are handled.\u003c/p\u003e\n\u003cp\u003eFor instance, if the path contains any special url encoded characters, such as “?” (%3b) or “#” (%23), they will be decoded and considered as part of the artifact name:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eGET /com/company/artifact/1.0/artifact-1.0.jar%23/xyz/anything.any?isRemote=true\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eInterpreted by proxy and transferred to upstream as:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e/com/company/artifact/1.0/artifact-1.0.jar\\#/xyz/anything.any\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eOn the upstream server however, everything after the hash sign will be parsed as hash properties. The path to artifact will be truncated to:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e/com/company/artifact/1.0/artifact-1.0.jar#/xyz/anything.any\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eEssentially, this would allow attackers to create files on the target proxy repository with arbitrary names and extensions, as long as their path starts with a predefined value, for example:\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/name-confusion-arbitrary-extension.png?w=300\u0026amp;resize=300%2C279\" alt=\"Name confusion arbitrary extension\" width=\"300\" height=\"279\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/name-confusion-arbitrary-extension.png?w=896 896w, https://github.blog/wp-content/uploads/2025/01/name-confusion-arbitrary-extension.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/name-confusion-arbitrary-extension.png?w=768 768w\" sizes=\"auto, (max-width: 300px) 100vw, 300px\"/\u003e\u003c/p\u003e\n\u003cp\u003eThis behavior affects almost every product I tested, but it’s hardly exploitable on its own, as no client would use an artifact with such a weird name.\u003c/p\u003e\n\u003cp\u003eWhile testing this, I noticed that JFrog Artifactory also has a special handling for the semicolon character “;”. Artifactory considers everything in the path after semicolon as “path parameters”, but not a part of the artifact name.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eGET /com/company1/artifact1/1.0/artifact1-1.0.jar;/../../../../company2/artifact2/2.0/artifact2-2.0.jar\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWhen processing a request like that, JFrog considers artifact1-1.0.jar as the artifact name, but still forwards the full url to the upstream repository. Contrary to that, Nexus 3 and some public servers perform path normalization and reduce this path to \u003ccode\u003e/company2/artifact2/2.0/artifact2-2.0.jar\u003c/code\u003e, which is expected according to RFC 3986.\u003c/p\u003e\n\u003cp\u003eIn cases where Artifactory is configured to proxy an external repository, this behavior can lead to a severe vulnerability: artifact poisoning (CVE-2024-6915). Technically, it allows saving any HTTP response from the remote endpoint to an arbitrary artifact on the Artifactory instance.\u003c/p\u003e\n\u003cp\u003eThe straightforward way to exploit that would be to publish a malicious artifact into the upstream repository with any name, and then save it under a commonly used name on Artifactory, (for example, “spring-boot-starter-web”). Then, the next time a client fetches this commonly used artifact, Artifactory will serve malicious content of another package.\u003c/p\u003e\n\u003cp\u003eIn cases when an attacker is unable to publish anything into the upstream repository, it can still be potentially exploitable with an open redirect or a reflected/stored XSS on the upstream server. Artifactory does not check what is passed after “;/../”, so it can be not only an “artifact2-2.0.jar” but any relative URL path.\u003c/p\u003e\n\u003cp\u003eThe ultimate requirement for this exploitation is that the upstream server should perform a path normalization process to consume “/../” characters. Maven Central repository does not perform it, but several other public repositories such as Apache or JitPack do. Moreover, this vulnerability in JFrog Artifactory affects not only Maven repositories, but any other proxy types, such as npm or Docker repositories.\u003c/p\u003e\n\u003cdiv\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003eartifact/../\u003c/th\u003e\n\u003cth\u003eartifact/%2e%2e/\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eMaven Central repo1.maven.org\u003c/td\u003e\n\u003ctd\u003e✗\u003c/td\u003e\n\u003ctd\u003e✗\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eApache repository.apache.org\u003c/td\u003e\n\u003ctd\u003e✓*\u003c/td\u003e\n\u003ctd\u003e✓\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eJitPack jitpack.io\u003c/td\u003e\n\u003ctd\u003e✓\u003c/td\u003e\n\u003ctd\u003e✗\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003enpm\u003c/td\u003e\n\u003ctd\u003e✓\u003c/td\u003e\n\u003ctd\u003e✗\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDocker Registry\u003c/td\u003e\n\u003ctd\u003e✓\u003c/td\u003e\n\u003ctd\u003e✓\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eRubygems.io\u003c/td\u003e\n\u003ctd\u003e✗\u003c/td\u003e\n\u003ctd\u003e✗\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ePython Package Index (PyPI)\u003c/td\u003e\n\u003ctd\u003e✗\u003c/td\u003e\n\u003ctd\u003e✗\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGO package registry (gocenter.io)\u003c/td\u003e\n\u003ctd\u003e✓\u003c/td\u003e\n\u003ctd\u003e✗\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e“✓” means path traversal is accepted by repository, “✗” – not\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"example-cve-2024-6915-is-it-even-or-is-it-odd\" id=\"example-cve-2024-6915-is-it-even-or-is-it-odd\"\u003eExample CVE-2024-6915: Is it even or is it odd?\u003ca href=\"#example-cve-2024-6915-is-it-even-or-is-it-odd\" aria-label=\"Example CVE-2024-6915: Is it even or is it odd?\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTo demonstrate its impact in my bug bounty report, I chose to use an Artifactory instance that proxies to npm. Npm has a different layout than Maven, but the core idea is the same: we just need to overwrite a package.json file with the content of another package. In the following request, we simply replace the package.json file of the \u003ca href=\"https://www.npmjs.com/package/is-even\"\u003eis-even\u003c/a\u003e package with the content of the \u003ca href=\"https://www.npmjs.com/package/is-odd\"\u003eis-odd\u003c/a\u003e package.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/is-even-attack.png?w=1024\u0026amp;resize=1024%2C464\" alt=\"Is even attack\" width=\"1024\" height=\"464\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/is-even-attack.png?w=1880 1880w, https://github.blog/wp-content/uploads/2025/01/is-even-attack.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/is-even-attack.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/is-even-attack.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/is-even-attack.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/is-even-poisoned.png?w=1024\u0026amp;resize=1024%2C484\" alt=\"Is even poisoned\" width=\"1024\" height=\"484\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/is-even-poisoned.png?w=1880 1880w, https://github.blog/wp-content/uploads/2025/01/is-even-poisoned.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/is-even-poisoned.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/is-even-poisoned.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/is-even-poisoned.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eWhen I install this poisoned package from Artifactory, the npm client shows a warning that the name in the package.json file (is-odd) is different from the requested one (is-even), but as the downloaded file is properly formatted and contains the links to archive with the source code, the npm client still downloads and executes it.\u003c/p\u003e\n\u003cp\u003eThe npm client is designed with the assumption that it trusts the source. If the integrity of the source registry is compromised (which was the case for JFrog Artifactory), npm clients cannot really do anything to protect from such malicious artifacts. Even hash checksums can be bypassed if they are tampered with in Artifactory.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/npm-confused-bounty-usd-5000.png?w=1024\u0026amp;resize=1024%2C314\" alt=\"npm confused\" width=\"1024\" height=\"314\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/npm-confused-bounty-usd-5000.png?w=2470 2470w, https://github.blog/wp-content/uploads/2025/01/npm-confused-bounty-usd-5000.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/npm-confused-bounty-usd-5000.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/npm-confused-bounty-usd-5000.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/npm-confused-bounty-usd-5000.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/01/npm-confused-bounty-usd-5000.png?w=2048 2048w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eWhen I reported this issue to the JFrog bug bounty program, it was assigned a critical severity and later awarded with a $5000 bounty. Since I’m doing this research as a part of my work at GitHub, we donated the full bounty amount to charity, specifically Cancer Research UK.\u003c/p\u003e\n\u003ch3 id=\"magic-parameters-for-exploiting-name-confusion-attacks\" id=\"magic-parameters-for-exploiting-name-confusion-attacks\"\u003eMagic parameters for exploiting name confusion attacks\u003ca href=\"#magic-parameters-for-exploiting-name-confusion-attacks\" aria-label=\"Magic parameters for exploiting name confusion attacks\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBoth Nexus and JFrog support some URL query parameters for proxy repositories. In JFrog Artifactory, the following parameters are accepted:\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/magic-parameters-jfrog.png?w=1024\u0026amp;resize=1024%2C433\" alt=\"magic parameters jfrog\" width=\"1024\" height=\"433\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/magic-parameters-jfrog.png?w=2798 2798w, https://github.blog/wp-content/uploads/2025/01/magic-parameters-jfrog.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/magic-parameters-jfrog.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/magic-parameters-jfrog.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/magic-parameters-jfrog.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/01/magic-parameters-jfrog.png?w=2048 2048w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eWhen attacking proxy repositories, these parameters may be applied on the proxy side, or “smuggled” into the upstream repository by using URL encoding. In both cases, they may alter how one or another repository processes the request, leaving options for potential exploitation.\u003c/p\u003e\n\u003cp\u003eFor example, by applying a \u003ccode\u003e:properties\u003c/code\u003e suffix to the path, we can trigger a local redirect to the same URL. By default, Artifactory does not perform path normalization for incoming requests, but with a redirect we can force the path normalization to be performed on the HTTP client side, instead of the server. It may help to perform a path traversal for name confusion attacks.\u003c/p\u003e\n\u003cp\u003eNexus 2 also supports a few parameters, but perhaps only these two are interesting for attackers:\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/magic-parameters-nexus.png?w=1024\u0026amp;resize=1024%2C492\" alt=\"magic parameters nexus\" width=\"1024\" height=\"492\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/magic-parameters-nexus.png?w=2008 2008w, https://github.blog/wp-content/uploads/2025/01/magic-parameters-nexus.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/magic-parameters-nexus.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/magic-parameters-nexus.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/magic-parameters-nexus.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eAlong with the artifacts uploaded by the users, repository managers also store additional metadata, such as checksums, creation date, the user who uploaded it, number of downloads, etc. Most of this data is stored in the database, but some repository managers also store files in the same directory as artifacts. For instance, Nexus 2 stores the following files:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/.meta/repository-metadata.xml\u003c/code\u003e – contains repository properties in XML format\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/.meta/prefixes.txt\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/.index/nexus-maven-repository-index.properties\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/.index/nexus-maven-repository-index.gz\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/.nexus/tmp/\u0026lt;artifact\u0026gt;nx-tmp\u0026lt;random\u0026gt;.nx-upload\u003c/code\u003e –  temporary file name during artifact’s upload\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e/.nexus/attributes/\u0026lt;artifact-name\u0026gt;\u003c/code\u003e – for every artifact, Nexus creates this json file with artifact’s metadata\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe last file is the only one that Nexus prohibits access to. Indeed if you try to download or upload a file that starts with \u003ccode\u003e/.nexus/attributes/\u003c/code\u003e, Nexus rejects this request:\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/nexus-attributes-forbidden.png?w=1024\u0026amp;resize=1024%2C530\" alt=\"nexus attributes forbidden\" width=\"1024\" height=\"530\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/nexus-attributes-forbidden.png?w=1976 1976w, https://github.blog/wp-content/uploads/2025/01/nexus-attributes-forbidden.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/nexus-attributes-forbidden.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/nexus-attributes-forbidden.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/nexus-attributes-forbidden.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/01/nexus-attributes-forbidden.png?w=804 804w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eAt the same time, I figured out that we can circumvent this protection by using a different prefix (\u003ccode\u003e/nexus/service/local/repositories/test/content/\u003c/code\u003e instead of \u003ccode\u003e/nexus/content/repositories/test/\u003c/code\u003e) and by using a double slash before the \u003ccode\u003e.nexus/attributes\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/nexus-attribues-bypass.png?w=1024\u0026amp;resize=1024%2C536\" alt=\"nexus attributes bypass\" width=\"1024\" height=\"536\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/nexus-attribues-bypass.png?w=2068 2068w, https://github.blog/wp-content/uploads/2025/01/nexus-attribues-bypass.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/nexus-attribues-bypass.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/nexus-attribues-bypass.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/nexus-attribues-bypass.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/01/nexus-attribues-bypass.png?w=2048 2048w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eReading local attributes is probably not that interesting for attackers, but the same bug can be abused to overwrite them using PUT HTTP requests instead of GET. By default, Nexus does not allow you to update artifact’s content in its release repositories, but we can update the attributes of any \u003ccode\u003emaven-metadata.xml\u003c/code\u003e file:\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/nexus-content-generator.png?w=1024\u0026amp;resize=1024%2C689\" alt=\"nexus velocity content generator\" width=\"1024\" height=\"689\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/nexus-content-generator.png?w=1468 1468w, https://github.blog/wp-content/uploads/2025/01/nexus-content-generator.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/nexus-content-generator.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/nexus-content-generator.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eFor exploitation purposes, I discovered a supported attribute that is particularly interesting: “contentGenerator”:”velocity”. If present, this attribute changes the way how the artifact’s content is rendered, enabling resolution of Velocity templates in the artifact’s content. So if we upload the ‘maven-metadata.xml’ file with the following content:\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/nexus-put-shell.png?w=1024\u0026amp;resize=1024%2C405\" alt=\"nexus put shell\" width=\"1024\" height=\"405\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/nexus-put-shell.png?w=2164 2164w, https://github.blog/wp-content/uploads/2025/01/nexus-put-shell.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/nexus-put-shell.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/nexus-put-shell.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/nexus-put-shell.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/01/nexus-put-shell.png?w=2048 2048w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eAnd then reissue the previous PUT request to update the attributes, the content of the ‘maven-metadata.xml’ file will be rendered as a Velocity template.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/nexus-exec-shell-id.png?w=1024\u0026amp;resize=1024%2C332\" alt=\"nexus exec shell id\" width=\"1024\" height=\"332\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/nexus-exec-shell-id.png?w=1924 1924w, https://github.blog/wp-content/uploads/2025/01/nexus-exec-shell-id.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/nexus-exec-shell-id.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/nexus-exec-shell-id.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/nexus-exec-shell-id.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eSweet, as the velocity template I used in the example above triggers the execution of the \u003ccode\u003ejava.lang.Runtime.getRuntime().exec(\u0026#34;id\u0026#34;)\u003c/code\u003e command.\u003c/p\u003e\n\u003ch3 id=\"its-not-a-real-rce-unless-its-pre-auth\" id=\"its-not-a-real-rce-unless-its-pre-auth\"\u003eIt’s not a real RCE unless it’s pre-auth\u003ca href=\"#its-not-a-real-rce-unless-its-pre-auth\" aria-label=\"It’s not a real RCE unless it’s pre-auth\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTo overwrite the metadata in the previous requests, I used a ‘PUT’ request method that requires the cookie of a user who has sufficient privileges to upload artifacts. This severely reduces the potential impact, as obtaining even a low-privileged account on the target repository might be a difficult task. Still, it wouldn’t be like myself if I didn’t try to find a way to exploit it without any authentication.\u003c/p\u003e\n\u003cp\u003eOne of the ways to achieve that would be combining this vulnerability with the stored XSS (CVE-2024-5083) in proxy repositories that I discovered earlier. Planting an XSS payload would not require any permissions on Nexus. Still, that XSS requires an administrator user to view an artifact, with a valid session, so the exploitation is still not that clean.\u003c/p\u003e\n\u003cp\u003eAnother way to trigger this vulnerability would be through a ‘proxy’ repository. If an attacker is able to publish an artifact into the upstream repository, it’s possible to exploit this vulnerability without any authentication on Nexus.\u003c/p\u003e\n\u003cp\u003eYou may reasonably assume that publishing an artifact with a Maven Group ID that starts with ‘.nexus/attributes’ may be unrealistic in popular upstream repositories like Maven Central, Apache Snapshots or JitPack. While I could not test this myself in their production systems, I noticed that one may publish an artifact with the group ID of ‘org.example’ and then force Nexus to save it as \u003ccode\u003e/.nexus/attributes/…\u003c/code\u003e with the same path traversal trick as in the name confusion attacks:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGET /nexus/service/local/repositories/apache-snapshots/content//.nexus/attributes/%252e./%252e./com/sbt/ignite/ignite-bom/maven-metadata.xml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/nexus-apache-snapshots-trick.png?w=1024\u0026amp;resize=1024%2C670\" alt=\"nexus apache snapshots trick\" width=\"1024\" height=\"670\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/nexus-apache-snapshots-trick.png?w=1764 1764w, https://github.blog/wp-content/uploads/2025/01/nexus-apache-snapshots-trick.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/nexus-apache-snapshots-trick.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/nexus-apache-snapshots-trick.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/nexus-apache-snapshots-trick.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eWhen processing this request, Nexus will decode the URL path to \u003ccode\u003e/.nexus/attributes/%2e./%2e./com/sbt/ignite/ignite-bom/maven-metadata.xml\u003c/code\u003e and forward it to the Apache Snapshots upstream repository. Then, Apache’s repository will (quite reasonably) perform URI normalization and return the content of the file. This would allow you to store an artifact with an arbitrary name from Apache Snapshots in the \u003ccode\u003e/.nexus/attributes/\u003c/code\u003e directory.\u003c/p\u003e\n\u003cp\u003eApache Snapshots is enabled by default in the Nexus installation. Also, as I mentioned earlier, pulling artifacts from it does not require any permissions on Nexus—it can be done with a simple GET request without any cookies.\u003c/p\u003e\n\u003cp\u003eA real attacker would probably try to publish their own artifact to the Apache Snapshots repository and therefore use it to attack all Nexus instances worldwide. Additionally, \u003ca href=\"https://people.apache.org/committer-index.html\"\u003eit’s possible to enumerate all the Apache user names\u003c/a\u003e and their emails. Perhaps some of their credentials can be found on websites that accumulate leaked passwords, but testing these kinds of attacks lies beyond the legal and moral scope of my research.\u003c/p\u003e\n\u003ch2 id=\"summary\" id=\"summary\"\u003eSummary\u003ca href=\"#summary\" aria-label=\"Summary\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAs we can see, using repository managers such as Nexus, JFrog, and Reposilite in proxy mode can introduce an attack surface that is otherwise only available to authenticated users.\u003c/p\u003e\n\u003cp\u003eAll tested solutions not only store and serve artifacts, but also perform complex parsing and indexing operations on them. Therefore, a specially crafted artifact can be used to attack the repository manager that processes it. This opens a possibility for XSS, XXE, archive expansion, and path traversal attacks.\u003c/p\u003e\n\u003cp\u003eThe innate URL decoding mechanism along with special characters sparks parsing discrepancies. All repository managers parse URLs differently and cache proxied artifacts locally, which can lead to cache poisoning vulnerabilities, such as CVE-2024-6915 in JFrog, for example.\u003c/p\u003e\n\u003cp\u003eThe major public and private Maven repositories are powered by just a few partially open source solutions. Although these solutions are already backed by reputable companies with strong security teams and bug bounty programs, it’s still possible to find critical vulnerabilities in them.\u003c/p\u003e\n\u003cp\u003eLastly, these kinds of attacks are not even specific to Maven, but for all other dependency ecosystems, whether its NPM, Docker, RubyGems or anything else. I encourage every hacker to test this ‘proxy repository’ functionality in other products as well, as this may bring about many fruitful findings.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNote: I presented this research at the \u003ca href=\"https://www.youtube.com/watch?v=0Z_QXtk0Z54\"\u003eEkoparty Security Conference\u003c/a\u003e in November 2024.\u003c/em\u003e\u003c/p\u003e\n\n\t\n\u003csection\u003e\n\t\u003chr/\u003e\n\t\u003cdiv\u003e\n\t\t\u003ch2\u003eTags:\u003c/h2\u003e\n\t\t\u003cul\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/exploit-development/\" rel=\"tag\"\u003e\n\t\t\t\t\t\texploit development\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/github-security-lab/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tGitHub Security Lab\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/java/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tjava\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/maven/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tmaven\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/supply-chain-security/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tsupply chain security\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\u003c/ul\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/44605151?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/44605151?v=4\u0026amp;s=200\" alt=\"Michael Stepankin\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "27 min read",
  "publishedTime": "2025-01-22T18:00:51Z",
  "modifiedTime": "2025-01-22T19:58:36Z"
}
