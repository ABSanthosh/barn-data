{
  "id": "12562695-c01c-4448-91f8-9c178a239fcd",
  "title": "Article: Binary Size Matters: The Challenges of Fitting Complex Applications in Storage-Constrained Devices",
  "link": "https://www.infoq.com/articles/complex-applications-storage-constraints/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "This article explores developing software for microcontrollers in C or C++, where constraints are the limited amount of volatile memory and the embedded hardware platform on which the software runs. It shows how to adopt languages like C++ while optimizing for binary size due to stringent hardware constraints, and trade off between runtime efficiency and binary size in architecture decisions. By Paulo Martinez",
  "author": "Paulo Martinez",
  "published": "Fri, 16 May 2025 09:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Artifacts \u0026 Tools",
    "Storage",
    "C",
    "C++",
    "Embedded Devices",
    "Embedded Software Dev",
    "Hardware",
    "Software Development",
    "Culture \u0026 Methods",
    "Development",
    "article"
  ],
  "byline": "Paulo Martinez",
  "length": 28016,
  "excerpt": "This article explores developing software for microcontrollers in C or C++, where constraints are the limited amount of volatile memory and the embedded hardware platform on which the software runs.",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s2_20250513062629/apple-touch-icon.png",
  "text": "Key Takeaways Modern embedded systems must reconcile increasing software complexity with stagnating memory limits, pushing developers to adopt languages like C++ while optimizing for binary size due to stringent hardware constraints. C++ offers zero-cost abstractions that allow high-level programming without runtime performance penalties, but developers must remain aware of how language features like templates, smart pointers, and STL usage affect binary size. Tools such as Bloaty and Puncover are essential for understanding and managing binary bloat, providing insight into which components and design patterns contribute most to firmware size. Trade-offs between runtime efficiency and binary size should influence architecture decisions, such as preferring concepts over polymorphism or using simpler standard library alternatives like \u003ccstdio\u003e instead of \u003ciostream\u003e. Binary size optimization is a full lifecycle concern, best addressed by integrating size tracking into CI pipelines and making conscious decisions around language features, toolchain flags, and design scalability. When thinking about the kinds of products software developers work on, we mostly think about web services, desktop applications, or high performance computing, such as training an AI model, in a cluster of servers. When I think about software development, I generally look at my circuit boards, sensors, and LEDs over my desk. These \"tiny\" gadgets are usually called embedded devices. Although single-board computers, such as the Raspberry Pi, are also referred to as embedded Linux systems, we are going to focus on microcontrollers. This article investigates constraints faced when writing software for microcontrollers, the current landscape of C++ development, and how to tackle one of the big challenges when building scalability and complexity: binary size. What are microcontrollers? This class of chips does not run fully-fledged operating systems such as Windows or Linux. Usually, they run more lightweight real-time operating systems (RTOS). Sometimes the requirements are so harsh (or the computing power so limited) that applications are written in bare metal, with direct access to the interrupts and registers of the processor. Related Sponsored Content In many product segments, microcontrollers are employed as the fundamental processing unit in the system, where efficient and low-power computing is required, i.e., environmental monitoring, industry sensors, and home automation. The term Internet of Things (IoT) is commonly used to define these use cases that rely on a network of tiny sensors and edge computing nodes. In comparison with conventional processors, microcontrollers have a greater diversity of hardware architectures. This fragmentation is also reflected on the software side, where we see a greater reliance on proprietary tooling and software development kits (SDKs) to accommodate the low-level hardware access for each chip and its architecture. Because of this close relationship with the hardware, microcontroller SDKs have almost exclusively been written in lower level languages, especially C. Frameworks and Languages Building upon SDKs, we are already able to develop full applications, and even directly access hardware intrinsics such as interrupts and registers. However, being so close to the hardware makes the effort to develop complex programs and reuse them in multiple platforms significantly higher. Because of this increased effort, we usually build applications for microcontrollers on top of an RTOS. These frameworks provide an abstraction layer to manage multiple threads, configure their priorities, and appropriately schedule their execution. Notable examples in this space are FreeRTOS and Zephyr. To keep up with the evolutions in both software and product requirements, embedded development needs to leverage the expressiveness and ease of use of higher level languages. Programming languages such as C++ and Rust are also being used in the embedded space now, which brings a whole new set of challenges to tackle, because these languages were primarily developed without such harsh restrictions in terms of memory and computing power. C++ in microcontrollers C++ is a general-purpose programming language that has been developed for the last 40 years. Updates to the language are introduced by the standardization committee in the form of versions. More recently, the committee has followed a three year cadence, with C++23 being the latest revision. C++ features are generally divided in two major categories: language features and library features. Language features define the core functionality and syntax of your written code, such as the meaning of keywords, mathematical operators and what their operations mean. Library features introduce additional utilities, generally in the form of objects or functions, which are written with core language. Commonly used libraries are strings, data containers and algorithms. While language features are intrinsically implemented by the compiler, library features are available in the form of a library that you can link to your program, called the standard library. Developers of microcontroller projects usually avoid using the standard library, because several standard library features, such as data containers, use dynamic memory allocations. As previously discussed, microcontroller chips have very limited volatile memory (RAM) and usually run applications on bare metal or a simple RTOS, without the presence of a memory management unit (MMU). Because of this memory limitation, during the application's lifetime, the constant memory allocation and deallocation can generate fragmentation. Memory fragmentation is a process of scattering available memory in a program through allocations and partial deallocations. After a certain time, the program is unable to allocate new contiguous memory blocks, although the total available memory could indicate so. The process is visualized in the picture below: In failing to allocate memory, the program will either throw an std::bad_alloc exception or terminate. In the context of a microcontroller firmware that doesn’t support exceptions, this means your firmware run will always consume usable memory until it inevitably crashes and reboots again. To avoid dealing with dynamic allocations, a popular alternative is to use the embedded template library (ETL), where all objects have static memory. In this way, the developer has a very deterministic view of how much memory will be used during runtime. Having said that, using the standard template library (STL) also has its benefits. With the STL you get access to the latest library features developed for C++ and their synergies with new language features. The entry barrier for developers is lower, because they have more resources to learn and rely on. As we make more and more objects and contexts available for evaluation in compile time, with the constexpr and consteval qualifiers, we can also perform more logic in compile-time, thus reducing the need for allocations in run time. More importantly, the dynamic allocation disadvantage that I previously mentioned by using the standard library might actually not matter, depending on the domain you are working with and how you design your application. So let’s say we have an application that can be fully characterized on boot time, such as a single-function device like an appliance. Another example of such a system is if it has separate execution and configuration modes, and a complete reset or restart of the application is required between them. This means you can fully define and allocate your objects during initialization and then have a stable memory footprint during your application's run time. I would even go further and relax this constraint if you have a stable allocation and deallocation cycle, or cycles from different tasks don’t execute at the same timespan so we don't have irregular allocation cycles that generate fragmentation. Therefore, we should not rule out the standard library from the get go. Analyze your application domain and execution lifecycle, and then assess if it is suitable in terms of memory footprint. It is also notable that the standard library is bringing more embedded-friendly features. For instance, C++26 will introduce a fixed capacity container in std::inplace_vector, where the user can try to push back an element and the container will check if there is still space left to perform the operation. Hopefully, we will see more of such relevant features in upcoming standards. C++ evolution C++ has seen an impressive amount of language and library features added to the standard in the last 20 years. There are many aspects to talk about as to how this has affected the software architecture and development, for microcontrollers. The two main effects I want to highlight are that we can write C++ code with a higher abstraction level than before, because we have smart pointers and auto type deduction. We also have more powerful libraries, such as format and print, that save a lot of development effort with memory management, type system, and so on. Additionally, the language and its libraries have introduced more powerful syntax for performing complex operations, such as variadic templates, fold expressions, and ranges. Let’s combine some of these aspects in a small example and see them in practice. We have a system that accumulates data points of different types. We can generalize the data point implementation in a templated structure, where further metadata can also be stored: template \u003ctypename T\u003e struct data_point { T value; }; The specification is to have a common interface, through which a series of values from the same type are processed and then sent to a certain peripheral. In the end, our client code will look like this: int main() { // 1. process value based on integer or floating point // 2a. send integers through peripheral a // 2b. send floating points through peripheral b // 3. return std::vector\u003cdata_point\u003cT\u003e\u003e auto ints = process_and_send(16, 32, 48, 64); auto floats = process_and_send(1.f, 2.f, 3.f, 4.f); auto doubles = process_and_send(5.0, 6.0, 7.0, 8.0); } As we can see, the client code is fairly high-level. The user doesn’t need to worry about explicitly indicating the type to be processed, although C++ is a statically typed language. The code underneath should take care of resolving the correct use case. First, let’s think about the peripherals. We need to define an interface for the serial driver, through which we want to send a sequence of characters and return a boolean to indicate if the operation was successful. Instead of virtual classes and polymorphism, we use concepts to define the constraints a type needs to satisfy to be a serial driver: template \u003ctypename T\u003e concept peripheral_like = requires(T drv, std::string const\u0026 str) { { drv.send(str) } -\u003e std::convertible_to\u003cbool\u003e; }; From this concept, we can write classes for each peripheral that satisfy these constraints. In order to get the desired peripheral in each instance, we have a function that resolves in compile time the wanted peripheral with respect to a certain id number that enumerates all peripherals in the system, and then returns a smart shared pointer. We omit the implementation details to keep focus on the overall architecture of the code: class peripheral_a { ... }; static_assert(peripheral_like\u003cperipheral_a\u003e); class peripheral_b { ... }; static_assert(peripheral_like\u003cperipheral_b\u003e); template \u003cunsigned int id\u003e auto get_peripheral() { ... } // std::shared_ptr of peripheral_like type or nullptr Now we turn our attention to processing the values we want to send. For that we use a feature introduced in C++20 called concepts. Concepts provide a simpler syntax for defining requirements for types in template metaprogramming. In this example, we overload the function process_and_send_dp by having implementations attached to different concepts that constrain the type of incoming data. In each implementation, the data point is post processed, then we acquire the corresponding peripheral and send the data under a specific formatting scheme. template \u003ctypename T\u003e concept is_integer = std::numeric_limits\u003cT\u003e::is_integer; template \u003cis_integer T\u003e constexpr data_point\u003cT\u003e process_and_send_dp(T \u0026v) { v += 1; auto drv = get_peripheral\u003cperiph_a_id\u003e(); drv-\u003esend(std::format(\"0x{:04x}\", v)); return {v}; } template \u003cstd::floating_point T\u003e constexpr data_point\u003cT\u003e process_and_send_dp(T \u0026v) { v *= 2; auto drv = get_peripheral\u003cperiph_a_id\u003e(); drv-\u003esend(std::format(\"{:.2f}\", v)); return {v}; } At last, we need a function that continuously calls process_and_send_dp through the whole data series and constructs the resulting vector. Again, we can use the auto type deduction, now in combination with variadic templates and fold expressions to process the entire list of input parameters. auto process_and_send(auto... values) { using value_type = typename std::common_type\u003cdecltype(values)...\u003e::type; std::vector\u003cdata_point\u003cvalue_type\u003e\u003e v; (v.push_back(process_and_send_dp(values)), ...); return v; } The resulting implementation is able to identify the common type among the values being sent and use the according processing, formatting and peripheral: int main() { auto ints = process_and_send(16, 32, 48, 64); // 0x0011 0x0021 0x0031 0x0041 over peripheral a auto floats = process_and_send(1.f, 2.f, 3.f, 4.f); // 2.00 4.00 6.00 8.00 over peripheral b auto doubles = process_and_send(5.0, 6.0, 7.0, 8.0); // 10.00 12.00 14.00 16.00 over peripheral b } By seeing the example above, we can see that we have an interface that is quite flexible and powerful. For instance, we don’t need extra configuration parameters or different function names for each input type. Intuitively, bringing such flexibility would also mean performance overhead, because the underlying implementation has to resolve the different use cases under the hood. This overhead in object-oriented programming with C++ usually comes in the form of vtables and its indirections need to resolve which derived class is going to be used. However, this is not necessarily the case and C++ has many techniques to mitigate this overhead. The constexpr / consteval contexts and template meta programming can shift a lot of logic and type resolution to compile time, when combined with move semantics to avoid copies,inline code for speeding up code execution, and even precalculated values with tables. By choosing the right function to be called at compile time, we don’t get any performance penalty by writing the code in this manner. A common term for these techniques, where we can write more complex functionality with minimal or no performance overhead, is zero-cost abstraction. We can write client code in a less specialized way with no downside. Even though that sounds like the perfect world, there might be trade-offs in other regions besides code complexity and run time that we are not accounting for. In C++ development, some features and designs can have a great impact on binary size. That binary size can be a particularly important criterion for embedded applications due to their hardware and cost constraints. Before continuing to look at such features, let’s try to understand why binary size is such a critical constraint in certain types of hardware. Hardware Perspective Although we are here focusing on software, it is important to say that software does not run in a vacuum. Having an understanding of the hardware our programs run on and even how hardware is developed can offer important insights into how to tackle programming challenges. In the software world, we have a more iterative process, new features and fixes can usually be incorporated later in the form of over-the-air updates, for example. That is not the case with hardware. Design errors and faults in hardware can at the very best be mitigated with considerable performance penalties. These errors can introduce the meltdown and spectre vulnerabilities, or render the whole device unusable. Therefore the hardware design phase has a much longer and rigorous process before release than the software design phase. This rigorous process also impacts design decisions in terms of optimizations and computational power. Once you define a layout and bill of materials for your device, the expectation is to keep this constant for production as long as possible in order to reduce costs. Embedded hardware platforms are designed to be very cost-effective. Designing a product whose specifications such as memory or I/O count are wasted also means a cost increase in an industry where every cent in the bill of materials matters. One important specification is non-volatile (NV) memory, such as flash memory, which is used to store the firmware and data needed by the application. NV memory has a great impact on the die size of microcontrollers, so chip designers will include the minimum amount needed to run an application. Looking at major vendors, we still see most microcontrollers offering less than 1 megabyte of internal flash memory. Even the more modern and capable chips do not exceed 2-4 megabytes. At the same time, the architectures and node technology evolutions made the compute capability of these tiny chips much higher and thus capable of running more complex applications. Looking at these contrasting points, we can see that one of the greatest challenges in embedded development is being able to fit larger applications in a still limited memory footprint, which makes analyzing the binary size of the developed firmware crucial. Binary Size Analysis Once you have the resulting binary file of your firmware compiled, we can start analyzing how many bytes each source code component, function, and so on contributes to the overall size. Some freely available, open-source tools to do this analysis are Bloaty and Puncover. Bloaty is a command line tool that profiles and sorts the size of components in your binary at different levels, such as sections, segments and compile units. The results are displayed on the terminal in the form of lists: Bloaty dynamic_storage.elf -- fixed_storage.elf -d symbols --domain=vm -n 15      VM SIZE      --------------   [NEW]     +84    dynamic_storage::store()   [NEW]     +46    std::__shared_count\u003c\u003e::~__shared_count()   [NEW]     +44    dynamic_storage::~dynamic_storage()   [NEW]     +36    fixed_storage::store()   [NEW]     +36    store_and_print()   [NEW]     +24    vtable for dynamic_storage   [NEW]     +24    vtable for fixed_storage   [NEW]     +18    fixed_storage::~fixed_storage()   +100%      +8    std::_Sp_counted_ptr_inplace\u003c\u003e::_M_dispose()   [NEW]      +4    dynamic_storage::cstr()   [NEW]      +4    fixed_storage::cstr()   +9.1%      +2    std::__cxx11::basic_string\u003c\u003e::_M_dispose()   -5.6%      -2    std::_Sp_counted_ptr_inplace\u003c\u003e::~_Sp_counted_ptr_inplace()  -16.1%     -36    experiment()   [DEL]     -40    std::_Sp_counted_base\u003c\u003e::_M_release()   +2.5%    +252    TOTAL Puncover, on the other hand, spawns a web server so the results can be seen graphically. It creates a File Explorer-like application, where the binary contribution of each source file is shown. Each source file then has its own page, where the user can see the disassembly and a list of symbols ordered by stack, code, or static sizes. In a way, these tools complement each other. Bloaty gives a higher-level, quick overview for the entire binary, making it faster to identify the parts of your binary that are contributing the most to the size. Puncover can then be used to have a deeper look at the identified components and better understand the changes by comparing the symbols list or direct disassembly differences. I have made a public repository with different case studies of binary size impact in C++ development, see cpp_binary_size. The aforementioned tools can be used to compare the resulting binaries within each case and identify the causes for binary size variations. Going through the examples, we can see the impact of binary size in different aspects of C++ programming. This also means there are different approaches for optimizing binary size during development. Here are some relevant remarks to keep in mind: Assess the impact at the interface, like constructors and function calls. Look for places where unnecessary copies or casts are being made. Moreover, also analyze how this impact evolves at scale, e.g., when the amount of objects and/or call sites increases. For instance, passing char* into a function that has std::string or even std::string\u0026 as its signature will allocate a temporary string. In another instance, using push_back or emplace_back to add an element to a vector can either result in a copy or move of that element. Copies usually introduce more code (and thus bigger binary) than moves. Tune the usage of libraries with compilation flags. When introducing any third-party library, get familiar with its build system and configuration headers and explore how the available options may affect binary size. Most commonly, disabling unused features can yield big savings in binary size. For example, instead of using \u003cformat\u003e from the standard library, fmtlib, the formatting library \u003cformat\u003e was based on, has many different flags that can reduce binary size. These are flags that not only disable features, but also use simpler algorithms or trade off smaller binary size for slower performance. Especially in the standard library, testing out different objects and libraries that accomplish similar functionality can have a big impact. In my experiments, I noticed that using functions from \u003ccstdio\u003e instead of \u003ciostream\u003e for printing to the stdout saves over 100 kilobytes of binary size, due to iostream bringing with it many static strings and the locale library. A similar memory-saving effect happens also when using the newer \u003cprint\u003e library from C++23. Optimizing for binary size should not be an afterthought but also influence the design as a whole. When designing the architecture of your application, there are design decisions that can make a great impact in binary size, but we must be mindful of potential downsides in other aspects. For example, using concepts, a C++20 feature, instead of polymorphism, can save a lot of binary size by getting rid of virtual functions, indirections, and bigger destructors. However, it also forces the code base into mostly header files, leading to longer compilation times and also recompilation of all compilation units it affects. Even within a specific design, it is important to test out variations of how it can be implemented. For example, type erasure is a commonly used pattern in software programming, which can use concrete types through a generic interface in runtime and thus reduce binary bloat. It can be implemented either through inheritance, static functions, or a vtable. We can implement and analyze the binary size impact in an experiment with an increasing number of base objects, and then instances of each object type, and then to look for which variant is the best fit for the size of our application. Despite all the analysis you do in the source code you write, the target architecture you are planning to deploy can also have a significant impact. For instance, sometimes design variations can yield the same binary size in 64-bit architectures due to its instructions being able to support larger addresses and therefore being less sensitive to changes in function signatures, like the amount of input variables. Meanwhile in ARM, thumb instructions can be either standard or wide, with wide instructions taking up more binary size. Therefore, the compiler might need to employ a different mixture of standard and wide instructions already with smaller function signatures and then yield different binary size footprints for each design variation. Binary Size Optimization In the end, C++ is able to generate very efficient code for size-constrained devices. However, tooling and application context are critical, and there are caveats and design decisions to be aware of: Find the optimal setup for your build environment: The flags of your toolchain and linker have a great overall effect on the size of the whole application. Sometimes, even rebuilding the toolchain and/or standard library from a source with specialized flags can have a great impact. For example, you can build the standard library with non-default hidden visibility, which can allow the linker to throw away code that is not used in a statically linked firmware. Look for the binary size cost of language features and libraries. With Bloaty and Puncover, we can identify symbols and/or files that have binary bloat and can then look for alternatives and optimizations. As we have seen in the last section, using cstdio over iostream calls for printing can have a big impact. This is not an isolated incident with the standard library and software design in general, because there are many different ways to implement similar functionality. Algorithms and data structures are other notable features that can have great variance in terms of binary size. Test out different variations of the same design and analyze their scalability when increasing the number of objects/instances. For instance, avoid excessive use of virtual functions or function calls that require unnecessary copies or casts from its parameters. Beware of interactions around types (e.g., polymorphism), constructors (e.g., cost of copy and move constructors and when they are used), and function calls (e.g., when copies and/or allocation of temporaries are needed). Prefer simpler algorithms (e.g., for loop over \u003calgorithm\u003e suite such as std::find_if) and objects/data structures (e.g., std::map over std::unordered_map), because they usually generate less code. With template meta programming, a lot of type checking can be deferred to compile type, enabling the user to use simpler, raw types in runtime. This is a common strategy employed by dependency injection frameworks, which can check if the injected types are valid during compilation. Constexpr/consteval contexts can also defer many calculations to compile time and reduce the amount of code to be executed at run time, although it can also add a lot of pre-calculated data to the binary. Integrate firmware size as an automated metric in your code analysis/CI pipeline to report the delta with incoming code changes. This reporting allows the development team to keep track of eventual binary size creep with incoming features and act in time. In Summary Modern software in microcontrollers represents a challenge not only from the feature development standpoint, but also about being mindful of the impact in terms of binary size and memory footprint. Unlike computing done on desktop and servers, embedded platforms had a very modest evolution in terms of available memory in comparison with their evolution in terms of computing power. Because of this modest memory increase, binary size optimization is a crucial criterion in the whole development lifecycle, from architecture to library selection to implementation. Using firmware analysis tools and knowledge of the binary size impact of C++ language features are essential to better understand how the impact will scale in your application. In the end, making your application smaller will allow the product to host more features and more powerful use cases in the same firmware envelope. About the Author Paulo Martinez",
  "image": "https://res.infoq.com/articles/complex-applications-storage-constraints/en/headerimage/compex-applications-storage-constraints-header-1747126977374.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\t\u003ch3\u003eKey Takeaways\u003c/h3\u003e\n\t\t\t\t\t\t\t\t\t\u003cul\u003e\n\t\u003cli\u003eModern embedded systems must reconcile increasing software complexity with stagnating memory limits, pushing developers to adopt languages like C++ while optimizing for binary size due to stringent hardware constraints.\u003c/li\u003e\n\t\u003cli\u003eC++ offers zero-cost abstractions that allow high-level programming without runtime performance penalties, but developers must remain aware of how language features like templates, smart pointers, and STL usage affect binary size.\u003c/li\u003e\n\t\u003cli\u003eTools such as Bloaty and Puncover are essential for understanding and managing binary bloat, providing insight into which components and design patterns contribute most to firmware size.\u003c/li\u003e\n\t\u003cli\u003eTrade-offs between runtime efficiency and binary size should influence architecture decisions, such as preferring concepts over polymorphism or using simpler standard library alternatives like \u0026lt;cstdio\u0026gt; instead of \u0026lt;iostream\u0026gt;.\u003c/li\u003e\n\t\u003cli\u003eBinary size optimization is a full lifecycle concern, best addressed by integrating size tracking into CI pipelines and making conscious decisions around language features, toolchain flags, and design scalability.\u003c/li\u003e\n\u003c/ul\u003e\n\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\u003cp\u003eWhen thinking about the kinds of products software developers work on, we mostly think about web services, desktop applications, or high performance computing, such as training an AI model, in a cluster of servers.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cp\u003eWhen I think about software development, I generally look at my circuit boards, sensors, and LEDs over my desk. These \u0026#34;tiny\u0026#34; gadgets are usually called embedded devices. Although single-board computers, such as the Raspberry Pi, are also referred to as embedded Linux systems, we are going to focus on microcontrollers.\u003c/p\u003e\u003cp\u003e\n\nThis article investigates constraints faced when writing software for microcontrollers, the current landscape of C++ development, and how to tackle one of the big challenges when building scalability and complexity: binary size.\u003c/p\u003e\u003c/div\u003e\n\n\u003ch2\u003eWhat are microcontrollers?\u003c/h2\u003e\n\n\u003cp\u003eThis class of chips does not run fully-fledged operating systems such as Windows or Linux. Usually, they run more lightweight real-time operating systems (RTOS). Sometimes the requirements are so harsh (or the computing power so limited) that applications are written in bare metal, with direct access to the interrupts and registers of the processor.\u003c/p\u003e\n\n\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\u003cdiv data-trk-view=\"true\" data-trk-impr=\"true\" data-place=\"EMBEDDED\"\u003e\n\t\n\t\u003cul\u003e\n\t\t\u003ch4\u003eRelated Sponsored Content\u003c/h4\u003e\n\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\n\t\u003c/ul\u003e\n\t\n\t\t\n\t\n\t\n\u003c/div\u003e\n\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\u003cp\u003eIn many product segments, microcontrollers are employed as the fundamental processing unit in the system, where efficient and low-power computing is required, i.e., environmental monitoring, industry sensors, and home automation. The term Internet of Things (IoT) is commonly used to define these use cases that rely on a network of tiny sensors and edge computing nodes.\u003c/p\u003e\n\n\u003cp\u003eIn comparison with conventional processors, microcontrollers have a greater diversity of hardware architectures.\u003c/p\u003e\n\n\u003cp\u003eThis fragmentation is also reflected on the software side, where we see a greater reliance on proprietary tooling and software development kits (SDKs) to accommodate the low-level hardware access for each chip and its architecture. Because of this close relationship with the hardware, microcontroller SDKs have almost exclusively been written in lower level languages, especially C.\u003c/p\u003e\n\n\u003ch2\u003eFrameworks and Languages\u003c/h2\u003e\n\n\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\u003cp\u003eBuilding upon SDKs, we are already able to develop full applications, and even directly access hardware intrinsics such as interrupts and registers. However, being so close to the hardware makes the effort to develop complex programs and reuse them in multiple platforms significantly higher. Because of this increased effort, we usually build applications for microcontrollers on top of an RTOS. These frameworks provide an abstraction layer to manage multiple threads, configure their priorities, and appropriately schedule their execution. Notable examples in this space are \u003ca href=\"https://www.freertos.org/\"\u003eFreeRTOS\u003c/a\u003e and \u003ca href=\"https://zephyrproject.org/\"\u003eZephyr\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eTo keep up with the evolutions in both software and product requirements, embedded development needs to leverage the expressiveness and ease of use of higher level languages. Programming languages such as C++ and Rust are also being used in the embedded space now, which brings a whole new set of challenges to tackle, because these languages were primarily developed without such harsh restrictions in terms of memory and computing power.\u003c/p\u003e\n\n\u003ch2\u003eC++ in microcontrollers\u003c/h2\u003e\n\n\u003cp\u003eC++ is a general-purpose programming language that has been developed for the last 40 years. Updates to the language are introduced by the standardization committee in the form of versions. More recently, the committee has followed a three year cadence, with \u003ca href=\"https://en.cppreference.com/w/cpp/23\"\u003eC++23 being the latest revision\u003c/a\u003e. C++ features are generally divided in two major categories: language features and library features. Language features define the core functionality and syntax of your written code, such as the meaning of keywords, mathematical operators and what their operations mean.\u003c/p\u003e\n\n\u003cp\u003eLibrary features introduce additional utilities, generally in the form of objects or functions, which are written with core language. Commonly used libraries are strings, data containers and algorithms. While language features are intrinsically implemented by the compiler, library features are available in the form of a library that you can link to your program, called the standard library.\u003c/p\u003e\n\n\u003cp\u003eDevelopers of microcontroller projects usually avoid using the standard library, because several standard library features, such as data containers, use dynamic memory allocations. As previously discussed, microcontroller chips have very limited volatile memory (RAM) and usually run applications on bare metal or a simple RTOS, without the presence of a memory management unit (MMU). Because of this memory limitation, during the application\u0026#39;s lifetime, the constant memory allocation and deallocation can generate fragmentation. Memory fragmentation is a process of scattering available memory in a program through allocations and partial deallocations. After a certain time, the program is unable to allocate new contiguous memory blocks, although the total available memory could indicate so. The process is visualized in the picture below:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" data-src=\"articles/complex-applications-storage-constraints/en/resources/105figure-1-1747128301201.jpg\" src=\"https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/articles/complex-applications-storage-constraints/en/resources/105figure-1-1747128301201.jpg\" rel=\"share\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eIn failing to allocate memory, the program will either throw an \u003ccode\u003estd::bad_alloc\u003c/code\u003e exception or terminate. In the context of a microcontroller firmware that doesn’t support exceptions, this means your firmware run will always consume usable memory until it inevitably crashes and reboots again.\u003c/p\u003e\n\n\u003cp\u003eTo avoid dealing with dynamic allocations, a popular alternative is to use the \u003ca href=\"https://www.etlcpp.com/\"\u003eembedded template library (ETL)\u003c/a\u003e, where all objects have static memory. In this way, the developer has a very deterministic view of how much memory will be used during runtime.\u003c/p\u003e\n\n\u003cp\u003eHaving said that, using the standard template library (STL) also has its benefits. With the STL you get access to the latest library features developed for C++ and their synergies with new language features. The entry barrier for developers is lower, because they have more resources to learn and rely on. As we make more and more objects and contexts available for evaluation in compile time, with the \u003ca href=\"https://en.cppreference.com/w/cpp/language/constexpr\"\u003e\u003cem\u003econstexpr\u003c/em\u003e\u003c/a\u003e and \u003cem\u003e\u003ca href=\"https://en.cppreference.com/w/cpp/language/consteval\"\u003econsteval\u003c/a\u003e\u003c/em\u003e qualifiers, we can also perform more logic in compile-time, thus reducing the need for allocations in run time.\u003c/p\u003e\n\n\u003cp\u003eMore importantly, the dynamic allocation disadvantage that I previously mentioned by using the standard library might actually not matter, depending on the domain you are working with and how you design your application. So let’s say we have an application that can be fully characterized on boot time, such as a single-function device like an appliance. Another example of such a system is if it has separate execution and configuration modes, and a complete reset or restart of the application is required between them. This means you can fully define and allocate your objects during initialization and then have a stable memory footprint during your application\u0026#39;s run time. I would even go further and relax this constraint if you have a stable allocation and deallocation cycle, or cycles from different tasks don’t execute at the same timespan so we don\u0026#39;t have irregular allocation cycles that generate fragmentation.\u003c/p\u003e\n\n\u003cp\u003eTherefore, we should not rule out the standard library from the get go. Analyze your application domain and execution lifecycle, and then assess if it is suitable in terms of memory footprint. It is also notable that the standard library is bringing more embedded-friendly features. For instance, C++26 will introduce a fixed capacity container in \u003ccode\u003e\u003ca href=\"https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0843r8.html\"\u003estd::inplace_vector\u003c/a\u003e\u003c/code\u003e, where the user can try to push back an element and the container will check if there is still space left to perform the operation. Hopefully, we will see more of such relevant features in upcoming standards.\u003c/p\u003e\n\n\u003ch2\u003eC++ evolution\u003c/h2\u003e\n\n\u003cp\u003eC++ has seen an impressive amount of language and library features added to the standard in the last 20 years. There are many aspects to talk about as to how this has affected the software architecture and development, for microcontrollers.\u003c/p\u003e\n\n\u003cp\u003eThe two main effects I want to highlight are that we can write C++ code with a higher abstraction level than before, because we have smart pointers and auto type deduction. We also have more powerful libraries, such as format and print, that save a lot of development effort with memory management, type system, and so on. Additionally, the language and its libraries have introduced more powerful syntax for performing complex operations, such as variadic templates, fold expressions, and ranges.\u003c/p\u003e\n\n\u003cp\u003eLet’s combine some of these aspects in a small example and see them in practice. We have a system that accumulates data points of different types. We can generalize the data point implementation in a templated structure, where further metadata can also be stored:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etemplate \u0026lt;typename T\u0026gt;\nstruct data_point {\nT value;\n};\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe specification is to have a common interface, through which a series of values from the same type are processed and then sent to a certain peripheral. In the end, our client code will look like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eint main() {\n// 1. process value based on integer or floating point\n// 2a. send integers through peripheral a\n// 2b. send floating points through peripheral b\n// 3. return std::vector\u0026lt;data_point\u0026lt;T\u0026gt;\u0026gt;\nauto ints = process_and_send(16, 32, 48, 64);\nauto floats = process_and_send(1.f, 2.f, 3.f, 4.f);\nauto doubles = process_and_send(5.0, 6.0, 7.0, 8.0);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAs we can see, the client code is fairly high-level. The user doesn’t need to worry about explicitly indicating the type to be processed, although C++ is a statically typed language. The code underneath should take care of resolving the correct use case.\u003c/p\u003e\n\n\u003cp\u003eFirst, let’s think about the peripherals. We need to define an interface for the serial driver, through which we want to send a sequence of characters and return a boolean to indicate if the operation was successful. Instead of virtual classes and polymorphism, we use concepts to define the constraints a type needs to satisfy to be a serial driver:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etemplate \u0026lt;typename T\u0026gt;\nconcept peripheral_like = requires(T drv, std::string const\u0026amp; str) {\n{ drv.send(str) } -\u0026gt; std::convertible_to\u0026lt;bool\u0026gt;;\n};\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFrom this concept, we can write classes for each peripheral that satisfy these constraints. In order to get the desired peripheral in each instance, we have a function that resolves in compile time the wanted peripheral with respect to a certain id number that enumerates all peripherals in the system, and then returns a smart shared pointer. We omit the implementation details to keep focus on the overall architecture of the code:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eclass peripheral_a { ... };\nstatic_assert(peripheral_like\u0026lt;peripheral_a\u0026gt;);\nclass peripheral_b { ... };\nstatic_assert(peripheral_like\u0026lt;peripheral_b\u0026gt;);\n\ntemplate \u0026lt;unsigned int id\u0026gt;\nauto get_peripheral() { ... } // std::shared_ptr of peripheral_like type or nullptr\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow we turn our attention to processing the values we want to send. For that we use a feature introduced in C++20 called concepts. Concepts provide a simpler syntax for defining requirements for types in template metaprogramming. In this example, we overload the function \u003ccode\u003eprocess_and_send_dp\u003c/code\u003e by having implementations attached to different concepts that constrain the type of incoming data. In each implementation, the data point is post processed, then we acquire the corresponding peripheral and send the data under a specific formatting scheme.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etemplate \u0026lt;typename T\u0026gt; concept is_integer = std::numeric_limits\u0026lt;T\u0026gt;::is_integer;\n\ntemplate \u0026lt;is_integer T\u0026gt;\nconstexpr data_point\u0026lt;T\u0026gt; process_and_send_dp(T \u0026amp;v) {\nv += 1;\nauto drv = get_peripheral\u0026lt;periph_a_id\u0026gt;();\ndrv-\u0026gt;send(std::format(\u0026#34;0x{:04x}\u0026#34;, v));\nreturn {v};\n}\n\ntemplate \u0026lt;std::floating_point T\u0026gt;\nconstexpr data_point\u0026lt;T\u0026gt; process_and_send_dp(T \u0026amp;v) {\nv *= 2;\nauto drv = get_peripheral\u0026lt;periph_a_id\u0026gt;();\ndrv-\u0026gt;send(std::format(\u0026#34;{:.2f}\u0026#34;, v));\nreturn {v};\n}\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAt last, we need a function that continuously calls \u003ccode\u003eprocess_and_send_dp\u003c/code\u003e through the whole data series and constructs the resulting vector. Again, we can use the auto type deduction, now in combination with variadic templates and fold expressions to process the entire list of input parameters.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eauto process_and_send(auto... values) {\nusing value_type = typename std::common_type\u0026lt;decltype(values)...\u0026gt;::type;\nstd::vector\u0026lt;data_point\u0026lt;value_type\u0026gt;\u0026gt; v;\n(v.push_back(process_and_send_dp(values)), ...);\nreturn v;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe resulting implementation is able to identify the common type among the values being sent and use the according processing, formatting and peripheral:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eint main() {\nauto ints = process_and_send(16, 32, 48, 64);\n// 0x0011 0x0021 0x0031 0x0041 over peripheral a\nauto floats = process_and_send(1.f, 2.f, 3.f, 4.f);\n// 2.00 4.00 6.00 8.00 over peripheral b\nauto doubles = process_and_send(5.0, 6.0, 7.0, 8.0);\n// 10.00 12.00 14.00 16.00 over peripheral b\n}\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eBy seeing the example above, we can see that we have an interface that is quite flexible and powerful. For instance, we don’t need extra configuration parameters or different function names for each input type. Intuitively, bringing such flexibility would also mean performance overhead, because the underlying implementation has to resolve the different use cases under the hood. This overhead in object-oriented programming with C++ usually comes in the form of vtables and its indirections need to resolve which derived class is going to be used. However, this is not necessarily the case and C++ has many techniques to mitigate this overhead.\u003c/p\u003e\n\n\u003cp\u003eThe constexpr / consteval contexts and template meta programming can shift a lot of logic and type resolution to compile time, when combined with move semantics to avoid copies,inline code for speeding up code execution, and even precalculated values with tables.\u003c/p\u003e\n\n\u003cp\u003eBy choosing the right function to be called at compile time, we don’t get any performance penalty by writing the code in this manner. A common term for these techniques, where we can write more complex functionality with minimal or no performance overhead, is zero-cost abstraction. We can write client code in a less specialized way with no downside. Even though that sounds like the perfect world, there might be trade-offs in other regions besides code complexity and run time that we are not accounting for. In C++ development, some features and designs can have a great impact on binary size. That binary size can be a particularly important criterion for embedded applications due to their hardware and cost constraints. Before continuing to look at such features, let’s try to understand why binary size is such a critical constraint in certain types of hardware.\u003c/p\u003e\n\n\u003ch2\u003eHardware Perspective\u003c/h2\u003e\n\n\u003cp\u003eAlthough we are here focusing on software, it is important to say that software does not run in a vacuum. Having an understanding of the hardware our programs run on and even how hardware is developed can offer important insights into how to tackle programming challenges.\u003c/p\u003e\n\n\u003cp\u003eIn the software world, we have a more iterative process, new features and fixes can usually be incorporated later in the form of over-the-air updates, for example. That is not the case with hardware. Design errors and faults in hardware can at the very best be mitigated with considerable performance penalties. These errors can introduce the meltdown and spectre \u003ca href=\"https://meltdownattack.com/\"\u003evulnerabilities\u003c/a\u003e, or render the whole device unusable. Therefore the hardware design phase has a much longer and rigorous process before release than the software design phase. This rigorous process also impacts design decisions in terms of optimizations and computational power. Once you define a layout and bill of materials for your device, the expectation is to keep this constant for production as long as possible in order to reduce costs.\u003c/p\u003e\n\n\u003cp\u003eEmbedded hardware platforms are designed to be very cost-effective. Designing a product whose specifications such as memory or I/O count are wasted also means a cost increase in an industry where every cent in the bill of materials matters.\u003c/p\u003e\n\n\u003cp\u003eOne important specification is non-volatile (NV) memory, such as flash memory, which is used to store the firmware and data needed by the application. NV memory has a great impact on the die size of microcontrollers, so chip designers will include the minimum amount needed to run an application. Looking at major vendors, we still see most microcontrollers offering less than 1 megabyte of internal flash memory. Even the more modern and capable chips do not exceed 2-4 megabytes. At the same time, the architectures and node technology evolutions made the compute capability of these tiny chips much higher and thus capable of running more complex applications. Looking at these contrasting points, we can see that one of the greatest challenges in embedded development is being able to fit larger applications in a still limited memory footprint, which makes analyzing the binary size of the developed firmware crucial.\u003c/p\u003e\n\n\u003ch2\u003eBinary Size Analysis\u003c/h2\u003e\n\n\u003cp\u003eOnce you have the resulting binary file of your firmware compiled, we can start analyzing how many bytes each source code component, function, and so on contributes to the overall size. Some freely available, open-source tools to do this analysis are \u003ca href=\"https://github.com/google/bloaty\"\u003eBloaty\u003c/a\u003e and \u003ca href=\"https://github.com/HBehrens/puncover\"\u003ePuncover\u003c/a\u003e. Bloaty is a command line tool that profiles and sorts the size of components in your binary at different levels, such as sections, segments and compile units. The results are displayed on the terminal in the form of lists:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBloaty dynamic_storage.elf -- fixed_storage.elf -d symbols --domain=vm -n 15\n     VM SIZE    \n --------------\n  [NEW]     +84    dynamic_storage::store()\n  [NEW]     +46    std::__shared_count\u0026lt;\u0026gt;::~__shared_count()\n  [NEW]     +44    dynamic_storage::~dynamic_storage()\n  [NEW]     +36    fixed_storage::store()\n  [NEW]     +36    store_and_print()\n  [NEW]     +24    vtable for dynamic_storage\n  [NEW]     +24    vtable for fixed_storage\n  [NEW]     +18    fixed_storage::~fixed_storage()\n  +100%      +8    std::_Sp_counted_ptr_inplace\u0026lt;\u0026gt;::_M_dispose()\n  [NEW]      +4    dynamic_storage::cstr()\n  [NEW]      +4    fixed_storage::cstr()\n  +9.1%      +2    std::__cxx11::basic_string\u0026lt;\u0026gt;::_M_dispose()\n  -5.6%      -2    std::_Sp_counted_ptr_inplace\u0026lt;\u0026gt;::~_Sp_counted_ptr_inplace()\n -16.1%     -36    experiment()\n  [DEL]     -40    std::_Sp_counted_base\u0026lt;\u0026gt;::_M_release()\n  +2.5%    +252    TOTAL\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ePuncover, on the other hand, spawns a web server so the results can be seen graphically. It creates a File Explorer-like application, where the binary contribution of each source file is shown. Each source file then has its own page, where the user can see the disassembly and a list of symbols ordered by stack, code, or static sizes.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" data-src=\"articles/complex-applications-storage-constraints/en/resources/83figure-2-1747128301201.jpg\" src=\"https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/articles/complex-applications-storage-constraints/en/resources/83figure-2-1747128301201.jpg\" rel=\"share\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" data-src=\"articles/complex-applications-storage-constraints/en/resources/70figure-3-1747128301201.jpg\" src=\"https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/articles/complex-applications-storage-constraints/en/resources/70figure-3-1747128301201.jpg\" rel=\"share\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eIn a way, these tools complement each other. Bloaty gives a higher-level, quick overview for the entire binary, making it faster to identify the parts of your binary that are contributing the most to the size. Puncover can then be used to have a deeper look at the identified components and better understand the changes by comparing the symbols list or direct disassembly differences.\u003c/p\u003e\n\n\u003cp\u003eI have made a public repository with different case studies of binary size impact in C++ development, see \u003ccode\u003e\u003ca href=\"https://github.com/pauloacmartinez/cpp_binary_size\"\u003ecpp_binary_size\u003c/a\u003e\u003c/code\u003e. The aforementioned tools can be used to compare the resulting binaries within each case and identify the causes for binary size variations.\u003c/p\u003e\n\n\u003cp\u003eGoing through the examples, we can see the impact of binary size in different aspects of C++ programming. This also means there are different approaches for optimizing binary size during development. Here are some relevant remarks to keep in mind:\u003c/p\u003e\n\n\u003cp\u003eAssess the impact at the interface, like constructors and function calls. Look for places where unnecessary copies or casts are being made. Moreover, also analyze how this impact evolves at scale, e.g., when the amount of objects and/or call sites increases. For instance, passing \u003ccode\u003echar*\u003c/code\u003e into a function that has \u003ccode\u003estd::string\u003c/code\u003e or even \u003ccode\u003estd::string\u0026amp;\u003c/code\u003e as its signature will allocate a temporary string. In another instance, using \u003ccode\u003epush_back\u003c/code\u003e or \u003ccode\u003eemplace_back\u003c/code\u003e to add an element to a vector can either result in a copy or move of that element. Copies usually introduce more code (and thus bigger binary) than moves.\u003c/p\u003e\n\n\u003cp\u003eTune the usage of libraries with compilation flags. When introducing any third-party library, get familiar with its build system and configuration headers and explore how the available options may affect binary size. Most commonly, disabling unused features can yield big savings in binary size. For example, instead of using \u003ccode\u003e\u0026lt;format\u0026gt;\u003c/code\u003e from the standard library, \u003ccode\u003efmtlib\u003c/code\u003e, the formatting library \u003ccode\u003e\u0026lt;format\u0026gt;\u003c/code\u003e was based on, has many different flags that can reduce binary size.\u003c/p\u003e\n\n\u003cp\u003eThese are flags that not only disable features, but also use simpler algorithms or trade off smaller binary size for slower performance. Especially in the standard library, testing out different objects and libraries that accomplish similar functionality can have a big impact. In my experiments, I noticed that using functions from \u003ccode\u003e\u0026lt;cstdio\u0026gt;\u003c/code\u003e instead of \u003ccode\u003e\u0026lt;iostream\u0026gt;\u003c/code\u003e for printing to the stdout saves over 100 kilobytes of binary size, due to iostream bringing with it many static strings and the locale library. A similar memory-saving effect happens also when using the newer \u003ccode\u003e\u0026lt;print\u0026gt;\u003c/code\u003e library from C++23.\u003c/p\u003e\n\n\u003cp\u003eOptimizing for binary size should not be an afterthought but also influence the design as a whole. When designing the architecture of your application, there are design decisions that can make a great impact in binary size, but we must be mindful of potential downsides in other aspects. For example, using concepts, a C++20 feature, instead of polymorphism, can save a lot of binary size by getting rid of virtual functions, indirections, and bigger destructors. However, it also forces the code base into mostly header files, leading to longer compilation times and also recompilation of all compilation units it affects.\u003c/p\u003e\n\n\u003cp\u003eEven within a specific design, it is important to test out variations of how it can be implemented. For example, type erasure is a commonly used pattern in software programming, which can use concrete types through a generic interface in runtime and thus reduce binary bloat. It can be implemented either through inheritance, static functions, or a \u003ca href=\"https://youtu.be/p-qaf6OS_f4?si=Dv5yjFxFP0p3r97b\"\u003evtable\u003c/a\u003e. We can implement and analyze the binary size impact in an experiment with an increasing number of base objects, and then instances of each object type, and then to look for which variant is the best fit for the size of our application.\u003c/p\u003e\n\n\u003cp\u003eDespite all the analysis you do in the source code you write, the target architecture you are planning to deploy can also have a significant impact. For instance, sometimes design variations can yield the same binary size in 64-bit architectures due to its instructions being able to support larger addresses and therefore being less sensitive to changes in function signatures, like the amount of input variables. Meanwhile in ARM, thumb instructions can be either standard or wide, with wide instructions taking up more binary size. Therefore, the compiler might need to employ a different mixture of standard and wide instructions already with smaller function signatures and then yield different binary size footprints for each design variation.\u003c/p\u003e\n\n\u003ch2\u003eBinary Size Optimization\u003c/h2\u003e\n\n\u003cp\u003eIn the end, C++ is able to generate very efficient code for size-constrained devices. However, tooling and application context are critical, and there are caveats and design decisions to be aware of:\u003c/p\u003e\n\n\u003cul\u003e\n\t\u003cli\u003eFind the optimal setup for your build environment: The flags of your toolchain and linker have a great overall effect on the size of the whole application. Sometimes, even rebuilding the toolchain and/or standard library from a source with specialized flags can have a great impact. For example, you can build the standard library with non-default hidden visibility, which can allow the linker to throw away code that is not used in a statically linked firmware.\u003c/li\u003e\n\t\u003cli\u003eLook for the binary size cost of language features and libraries. With Bloaty and Puncover, we can identify symbols and/or files that have binary bloat and can then look for alternatives and optimizations. As we have seen in the last section, using \u003ccode\u003ecstdio\u003c/code\u003e over iostream calls for printing can have a big impact. This is not an isolated incident with the standard library and software design in general, because there are many different ways to implement similar functionality. Algorithms and data structures are other notable features that can have great variance in terms of binary size.\u003c/li\u003e\n\t\u003cli\u003eTest out different variations of the same design and analyze their scalability when increasing the number of objects/instances. For instance, avoid excessive use of virtual functions or function calls that require unnecessary copies or casts from its parameters.\u003c/li\u003e\n\t\u003cli\u003eBeware of interactions around types (e.g., polymorphism), constructors (e.g., cost of copy and move constructors and when they are used), and function calls (e.g., when copies and/or allocation of temporaries are needed).\u003c/li\u003e\n\t\u003cli\u003ePrefer simpler algorithms (e.g., for loop over \u003ccode\u003e\u0026lt;algorithm\u0026gt;\u003c/code\u003e suite such as \u003ccode\u003estd::find_if\u003c/code\u003e) and objects/data structures (e.g., \u003ccode\u003estd::map\u003c/code\u003e over \u003ccode\u003estd::unordered_map\u003c/code\u003e), because they usually generate less code.\u003c/li\u003e\n\t\u003cli\u003eWith template meta programming, a lot of type checking can be deferred to compile type, enabling the user to use simpler, raw types in runtime. This is a common strategy employed by dependency injection frameworks, which can check if the injected types are valid during compilation. Constexpr/consteval contexts can also defer many calculations to compile time and reduce the amount of code to be executed at run time, although it can also add a lot of pre-calculated data to the binary.\u003c/li\u003e\n\t\u003cli\u003eIntegrate firmware size as an automated metric in your code analysis/CI pipeline to report the delta with incoming code changes. This reporting allows the development team to keep track of eventual binary size creep with incoming features and act in time.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eIn Summary\u003c/h2\u003e\n\n\u003cp\u003eModern software in microcontrollers represents a challenge not only from the feature development standpoint, but also about being mindful of the impact in terms of binary size and memory footprint. Unlike computing done on desktop and servers, embedded platforms had a very modest evolution in terms of available memory in comparison with their evolution in terms of computing power. Because of this modest memory increase, binary size optimization is a crucial criterion in the whole development lifecycle, from architecture to library selection to implementation.\u003c/p\u003e\n\n\u003cp\u003eUsing firmware analysis tools and knowledge of the binary size impact of C++ language features are essential to better understand how the impact will scale in your application. In the end, making your application smaller will allow the product to host more features and more powerful use cases in the same firmware envelope.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Paulo-Martinez\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003ePaulo Martinez\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\n                            \n                            \n\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "30 min read",
  "publishedTime": "2025-05-16T00:00:00Z",
  "modifiedTime": null
}
