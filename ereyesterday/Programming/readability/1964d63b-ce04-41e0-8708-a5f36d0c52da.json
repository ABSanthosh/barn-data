{
  "id": "1964d63b-ce04-41e0-8708-a5f36d0c52da",
  "title": "IssueOps: Automate CI/CD (and more!) with GitHub Issues and Actions",
  "link": "https://github.blog/engineering/issueops-automate-ci-cd-and-more-with-github-issues-and-actions/",
  "description": "A look into building IssueOps workflows on GitHub to do everything from CI/CD to handling approvals and more. The post IssueOps: Automate CI/CD (and more!) with GitHub Issues and Actions appeared first on The GitHub Blog.",
  "author": "Nick Alteen",
  "published": "Wed, 19 Mar 2025 16:00:24 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Engineering",
    "GitHub Issues",
    "IssueOps",
    "pull requests"
  ],
  "byline": "Nick Alteen",
  "length": 30720,
  "excerpt": "A look into building IssueOps workflows on GitHub to do everything from CI/CD to handling approvals and more.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "Software development is filled with repetitive tasks—managing issues, handling approvals, triggering CI/CD workflows, and more. But what if you could automate these types of tasks directly within GitHub Issues? That’s the promise of IssueOps, a methodology that turns GitHub Issues into a command center for automation. Whether you’re a solo developer or part of an engineering team, IssueOps helps you streamline operations without ever leaving your repository. In this article, I’ll explore the concept of IssueOps using state-machine terminology and strategies to help you work more efficiently on GitHub. After all, who doesn’t love automation? What is IssueOps? IssueOps is the practice of using GitHub Issues, GitHub Actions, and pull requests (PR) as an interface for automating workflows. Instead of switching between tools or manually triggering actions, you can use issue comments, labels, and state changes to kick off CI/CD pipelines, assign tasks, and even deploy applications. Much like the various other *Ops paradigms (ChatOps, ClickOps, and so on), IssueOps is a collection of tools, workflows, and concepts that, when applied to GitHub Issues, can automate mundane, repetitive tasks. The flexibility and power of issues, along with their relationship to pull requests, create a near limitless number of possibilities, such as managing approvals and deployments. All of this can really help to simplify your workflows on GitHub. I’m speaking from personal experience here. It’s important to note that IssueOps isn’t just a DevOps thing! Where DevOps offers a methodology to bring developers and operations into closer alignment, IssueOps is a workflow automation practice centered around GitHub Issues. IssueOps lets you run anything from complex CI/CD pipelines to a bed and breakfast reservation system. If you can interact with it via an API, there’s a good chance you can build it with IssueOps! So, why use IssueOps? There are lots of benefits to utilizing IssueOps. Here’s how it’s useful in practice: It’s event-driven, so you can automate the boring stuff: IssueOps lets you automate workflows directly from GitHub Issues and pull requests, turning everyday interactions—from kicking off a CI/CD pipeline and managing approvals to updating project boards—into powerful triggers for GitHub Actions. It’s customizable, so you can tailor workflows to your needs: No two teams work the same way, and IssueOps is flexible enough to adapt. Whether you’re automating bug triage or triggering deployments, you can customize workflows based on event type and data provided. It’s transparent, so you can keep a record: All actions taken on an issue are logged in its timeline, creating an easy-to-follow record of what happened and when. It’s immutable, so you do an audit whenever you need: Because IssueOps uses GitHub Issues and pull requests as a source of truth, every action leaves a record. No more chasing approvals in Slack or manually triggering workflows: IssueOps keeps everything structured, automated, and auditable right inside GitHub. Defining IssueOps workflows and how they’re like finite-state machines Most IssueOps workflows follow the same basic pattern: A user opens an issue and provides information about a request The issue is validated to ensure it contains the required information The issue is submitted for processing Approval is requested from an authorized user or team The request is processed and the issue is closed Suppose you’re an administrator of an organization and want to reduce the overhead of managing team members. In this instance, you could use IssueOps to build an automated membership request and approval process. Within a workflow like this, you’d have several core steps: A user creates a request to be added to a team The request is validated The request is submitted for approval An administrator approves or denies this request The request is processed If approved, the user is added to the team If denied, the user is not added to the team The user is notified of the outcome When designing your own IssueOps workflows, it can be very helpful to think of them as a finite-state machine: a model for how objects move through a series of states in response to external events. Depending on certain rules defined within the state machine, a number of different actions can take place in response to state changes. If this is a little too complex, you can also think of it like a flow chart. To apply this comparison to IssueOps, an issue is the object that is processed by a state machine. It changes state in response to events. As the object changes state, certain actions may be performed as part of a transition, provided any required conditions (guards) are met. Once an end state is reached, the issue can be closed. This breaks down into a few key concepts: State: A point in an object’s lifecycle that satisfies certain condition(s). Event: An external occurrence that triggers a state change. Transition: A link between two states that, when traversed by an object, will cause certain action(s) to be performed. Action: An atomic task that is performed when a transition is taken. Guard: A condition that is evaluated when a trigger event occurs. A transition is taken only if all associated guard condition(s) are met. Here’s a simple state diagram for the example I discussed above. Now, let’s dive into the state machine in more detail! Key concepts behind state machines The benefit of breaking your workflow down into these components is that you can look for edge cases, enforce conditions, and create a robust, reliable result. States Within a state machine, a state defines the current status of an object. As the object transitions through the state machine, it will change states in response to external events. When building IssueOps workflows, common states for issues include opened, submitted, approved, denied, and closed. These should suffice as the core states to consider when building our workflows in our team membership example above. Events In a state machine, an event can be any form of interaction with the object and its current state. When building your own IssueOps, you should consider events from both the user and GitHub points of view. In our team membership request example, there are several events that can trigger a change in state. The request can be created, submitted, approved, denied, or processed. In this example, a user interacting with an issue—such as adding labels, commenting, or updating milestones—can also change its state. In GitHub Actions, there are many events that can trigger your workflows (see events that trigger workflows). Here are a few interactions, or events, that would affect our example IssueOps workflow when it comes to managing team members: Request Event State Request is created issues opened Request is approved issue_comment created Request is denied issue_comment created As you can see, the same GitHub workflow trigger can apply to multiple events in our state machine. Because of this, validation is key. Within your workflows, you should check both the type of event and the information provided by the user. In this case, we can conditionally trigger different workflow steps based on the content of the issue_comment event. jobs: approve: name: Process Approval runs-on: ubuntu-latest if: ${{ startsWith(github.event.comment.body, '.approve') }} # ... deny: name: Process Denial runs-on: ubuntu-latest if: ${{ startsWith(github.event.comment.body, '.deny') }} # ... Transitions A transition is simply the change from one state to another. In our example, for instance, a transition occurs when someone opens an issue. When a request meets certain conditions, or guards, the change in state can take place. When the transition occurs, some actions or processing may take place, as well. With our example workflow, you can think of the transitions themselves as the lines connecting different nodes in the state diagram. Or the lines connecting boxes in a flow chart. Guards Guards are conditions that must be verified before an event can trigger a transition to a different state. In our case, we know the following guards must be in place: A request should not transition to an Approved state unless an administrator comments .approve on the issue. A request should not transition to a Denied state unless an administrator comments .deny on the issue. What about after the request is approved and the user is added to the team? This is referred to as an unguarded transition. There are no conditions that must be met, so the transition happens immediately! Actions Lastly, actions are specific tasks that are performed during a transition. They may affect the object itself, but this is not a requirement in our state machine. In our example, the following actions may take place at different times: Administrators are notified that a request has been submitted The user is added to the requested team The user is notified of the outcome A real-world example: Building a team membership workflow with IssueOps Now that all of the explanation is out of the way, let’s dive into building our example! For reference, we’ll focus on the GitHub Actions workflows involved in building this automation. There are some additional repository and permissions settings involved that are discussed in more detail in these IssueOps docs. Step 1: Issue form template GitHub issue forms let you create standardized, formatted issues based on a set of form fields. Combined with the issue-ops/parser action, you can get reliable, machine-readable JSON from issue body Markdown. For our example, we are going to create a simple form that accepts a single input: the team where we want to add the user. name: Team Membership Request description: Submit a new membership request title: New Team Membership Request labels: - team-membership body: - type: input id: team attributes: label: Team Name description: The team name you would like to join placeholder: my-team validations: required: true When issues are created using this form, they will be parsed into JSON, which can then be passed to the rest of the IssueOps workflow. { \"team\": \"my-team\" } Step 2: Issue validation With a machine-readable issue body, we can run additional validation checks to ensure the information provided follows any rules we might have in place. For example, we can’t automatically add a user to a team if the team doesn’t exist yet! That is where the issue-ops/validator action comes into play. Using an issue form template and a custom validation script, we can confirm the existence of the team ahead of time. module.exports = async (field) =\u003e { const { Octokit } = require('@octokit/rest') const core = require('@actions/core') const github = new Octokit({ auth: core.getInput('github-token', { required: true }) }) try { // Check if the team exists core.info(`Checking if team '${field}' exists`) await github.rest.teams.getByName({ org: process.env.GITHUB_REPOSITORY_OWNER ?? '', team_slug: field }) core.info(`Team '${field}' exists`) return 'success' } catch (error) { if (error.status === 404) { // If the team does not exist, return an error message core.error(`Team '${field}' does not exist`) return `Team '${field}' does not exist` } else { // Otherwise, something else went wrong... throw error } } } When included in our IssueOps workflow, this adds any validation error(s) to the comment on the issue. Step 3: Issue workflows The main “entrypoint” of this workflow occurs when a user creates or edits their team membership request issue. This workflow should focus heavily on validating any user inputs! For example, what should happen if the user inputs a team that does not exist? In our state machine, this workflow is responsible for handling everything up to the opened state. Any time an issue is created, edited, or updated, it will re-run validation to ensure the request is ready to be processed. In this case, an additional guard condition is introduced. Before the request can be submitted, the user must comment with .submit after validation has passed. name: Process Issue Open/Edit on: issues: types: - opened - edited - reopened permissions: contents: read id-token: write issues: write jobs: validate: name: Validate Request runs-on: ubuntu-latest # This job should only be run on issues with the `team-membership` label. if: ${{ contains(github.event.issue.labels.*.name, 'team-membership') }} steps: # This is required to ensure the issue form template and any validation # scripts are included in the workspace. - name: Checkout id: checkout uses: actions/checkout@v4 # Since this workflow includes custom validation scripts, we need to # install Node.js and any dependencies. - name: Setup Node.js id: setup-node uses: actions/setup-node@v4 # Install dependencies from `package.json`. - name: Install Dependencies id: install run: npm install # GitHub App authentication is required if you want to interact with any # resources outside the scope of the repository this workflow runs in. - name: Get GitHub App Token id: token uses: actions/create-github-app-token@v1 with: app-id: ${{ vars.ISSUEOPS_APP_ID }} private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }} owner: ${{ github.repository_owner }} # Remove any labels and start fresh. This is important because the # issue may have been closed and reopened. - name: Remove Labels id: remove-label uses: issue-ops/labeler@v2 with: action: remove github_token: ${{ steps.token.outputs.token }} labels: | validated approved denied issue_number: ${{ github.event.issue.number }} repository: ${{ github.repository }} # Parse the issue body into machine-readable JSON, so that it can be # processed by the rest of the workflow. - name: Parse Issue Body id: parse uses: issue-ops/parser@v4 with: body: ${{ github.event.issue.body }} issue-form-template: team-membership.yml workspace: ${{ github.workspace }} # Validate early and often! Validation should be run any time an issue is # interacted with, to ensure that any changes to the issue body are valid. - name: Validate Request id: validate uses: issue-ops/validator@v3 with: add-comment: true github-token: ${{ steps.token.outputs.token }} issue-form-template: team-membership.yml issue-number: ${{ github.event.issue.number }} parsed-issue-body: ${{ steps.parse.outputs.json }} workspace: ${{ github.workspace }} # If validation passes, add the validated label to the issue. - if: ${{ steps.validate.outputs.result == 'success' }} name: Add Validated Label id: add-label uses: issue-ops/labeler@v2 with: action: add github_token: ${{ steps.token.outputs.token }} labels: | validated issue_number: ${{ github.event.issue.number }} repository: ${{ github.repository }} # The `issue-ops/validator` action will automatically notify the user that # the request was validated. However, you can optionally add instruction # on what to do next. - if: ${{ steps.validate.outputs.result == 'success' }} name: Notify User (Success) id: notify-success uses: peter-evans/create-or-update-comment@v4 with: issue-number: ${{ github.event.issue.number }} body: | Hello! Your request has been validated successfully! Please comment with `.submit` to submit this request. Once the issue is created, any further processing is triggered using issue comments—and this can be done with one workflow. However, to make things a bit easier to follow, we’ll break this into a few separate workflows. Submit workflow The first workflow handles the user submitting the request. The main task it performs is validating the issue body against the form template to ensure it hasn’t been modified. name: Process Submit Comment on: issue_comment: types: - created permissions: contents: read id-token: write issues: write jobs: submit: name: Submit Request runs-on: ubuntu-latest # This job should only be run when the following conditions are true: # # - A user comments `.submit` on the issue. # - The issue has the `team-membership` label. # - The issue has the `validated` label. # - The issue does not have the `approved` or `denied` labels. # - The issue is open. if: | startsWith(github.event.comment.body, '.submit') \u0026\u0026 contains(github.event.issue.labels.*.name, 'team-membership') == true \u0026\u0026 contains(github.event.issue.labels.*.name, 'approved') == false \u0026\u0026 contains(github.event.issue.labels.*.name, 'denied') == false \u0026\u0026 github.event.issue.state == 'open' steps: # First, we are going to re-run validation. This is important because # the issue body may have changed since the last time it was validated. # This is required to ensure the issue form template and any validation # scripts are included in the workspace. - name: Checkout id: checkout uses: actions/checkout@v4 # Since this workflow includes custom validation scripts, we need to # install Node.js and any dependencies. - name: Setup Node.js id: setup-node uses: actions/setup-node@v4 # Install dependencies from `package.json`. - name: Install Dependencies id: install run: npm install # GitHub App authentication is required if you want to interact with any # resources outside the scope of the repository this workflow runs in. - name: Get GitHub App Token id: token uses: actions/create-github-app-token@v1 with: app-id: ${{ vars.ISSUEOPS_APP_ID }} private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }} owner: ${{ github.repository_owner }} # Remove the validated label. This will be re-added if validation passes. - name: Remove Validated Label id: remove-label uses: issue-ops/labeler@v2 with: action: remove github_token: ${{ steps.token.outputs.token }} labels: | validated issue_number: ${{ github.event.issue.number }} repository: ${{ github.repository }} # Parse the issue body into machine-readable JSON, so that it can be # processed by the rest of the workflow. - name: Parse Issue Body id: parse uses: issue-ops/parser@v4 with: body: ${{ github.event.issue.body }} issue-form-template: team-membership.yml workspace: ${{ github.workspace }} # Validate early and often! Validation should be run any time an issue is # interacted with, to ensure that any changes to the issue body are valid. - name: Validate Request id: validate uses: issue-ops/validator@v3 with: add-comment: false # Don't add another validation comment. github-token: ${{ steps.token.outputs.token }} issue-form-template: team-membership.yml issue-number: ${{ github.event.issue.number }} parsed-issue-body: ${{ steps.parse.outputs.json }} workspace: ${{ github.workspace }} # If validation passed, add the validated and submitted labels to the issue. - if: ${{ steps.validate.outputs.result == 'success' }} name: Add Validated Label id: add-label uses: issue-ops/labeler@v2 with: action: add github_token: ${{ steps.token.outputs.token }} labels: | validated submitted issue_number: ${{ github.event.issue.number }} repository: ${{ github.repository }} # If validation succeeded, alert the administrator team so they can # approve or deny the request. - if: ${{ steps.validate.outputs.result == 'success' }} name: Notify Admin (Success) id: notify-success uses: peter-evans/create-or-update-comment@v4 with: issue-number: ${{ github.event.issue.number }} body: | 👋 @issue-ops/admins! The request has been validated and is ready for your review. Please comment with `.approve` or `.deny` to approve or deny this request. Deny workflow If the request is denied, the user should be notified and the issue should close. name: Process Denial Comment on: issue_comment: types: - created permissions: contents: read id-token: write issues: write jobs: submit: name: Deny Request runs-on: ubuntu-latest # This job should only be run when the following conditions are true: # # - A user comments `.deny` on the issue. # - The issue has the `team-membership` label. # - The issue has the `validated` label. # - The issue has the `submitted` label. # - The issue does not have the `approved` or `denied` labels. # - The issue is open. if: | startsWith(github.event.comment.body, '.deny') \u0026\u0026 contains(github.event.issue.labels.*.name, 'team-membership') == true \u0026\u0026 contains(github.event.issue.labels.*.name, 'submitted') == true \u0026\u0026 contains(github.event.issue.labels.*.name, 'validated') == true \u0026\u0026 contains(github.event.issue.labels.*.name, 'approved') == false \u0026\u0026 contains(github.event.issue.labels.*.name, 'denied') == false \u0026\u0026 github.event.issue.state == 'open' steps: # This time, we do not need to re-run validation because the request is # being denied. It can just be closed. # However, we do need to confirm that the user who commented `.deny` is # a member of the administrator team. # GitHub App authentication is required if you want to interact with any # resources outside the scope of the repository this workflow runs in. - name: Get GitHub App Token id: token uses: actions/create-github-app-token@v1 with: app-id: ${{ vars.ISSUEOPS_APP_ID }} private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }} owner: ${{ github.repository_owner }} # Check if the user who commented `.deny` is a member of the # administrator team. - name: Check Admin Membership id: check-admin uses: actions/github-script@v7 with: github-token: ${{ steps.token.outputs.token }} script: | try { await github.rest.teams.getMembershipForUserInOrg({ org: context.repo.owner, team_slug: 'admins', username: context.actor, }) core.setOutput('member', 'true') } catch (error) { if (error.status === 404) { core.setOutput('member', 'false') } throw error } # If the user is not a member of the administrator team, exit the # workflow. - if: ${{ steps.check-admin.outputs.member == 'false' }} name: Exit run: exit 0 # If the user is a member of the administrator team, add the denied label. - name: Add Denied Label id: add-label uses: issue-ops/labeler@v2 with: action: add github_token: ${{ steps.token.outputs.token }} labels: | denied issue_number: ${{ github.event.issue.number }} repository: ${{ github.repository }} # Notify the user that the request was denied. - name: Notify User id: notify uses: peter-evans/create-or-update-comment@v4 with: issue-number: ${{ github.event.issue.number }} body: | This request has been denied and will be closed. # Close the issue as not planned. - name: Close Issue id: close uses: actions/github-script@v7 with: script: | await github.rest.issues.update({ issue_number: ${{ github.event.issue.number }}, owner: context.repo.owner, repo: context.repo.repo, state: 'closed', state_reason: 'not_planned' }) Approve workflow Finally, we need to handle request approval. In this case, we need to add the user to the team, notify them, and close the issue. name: Process Approval Comment on: issue_comment: types: - created permissions: contents: read id-token: write issues: write jobs: submit: name: Approve Request runs-on: ubuntu-latest # This job should only be run when the following conditions are true: # # - A user comments `.approve` on the issue. # - The issue has the `team-membership` label. # - The issue has the `validated` label. # - The issue has the `submitted` label. # - The issue does not have the `approved` or `denied` labels. # - The issue is open. if: | startsWith(github.event.comment.body, '.approve') \u0026\u0026 contains(github.event.issue.labels.*.name, 'team-membership') == true \u0026\u0026 contains(github.event.issue.labels.*.name, 'submitted') == true \u0026\u0026 contains(github.event.issue.labels.*.name, 'validated') == true \u0026\u0026 contains(github.event.issue.labels.*.name, 'approved') == false \u0026\u0026 contains(github.event.issue.labels.*.name, 'denied') == false \u0026\u0026 github.event.issue.state == 'open' steps: # This time, we do not need to re-run validation because the request is # being approved. It can just be processed. # This is required to ensure the issue form template is included in the # workspace. - name: Checkout id: checkout uses: actions/checkout@v4 # We do need to confirm that the user who commented `.approve` is a member # of the administrator team. GitHub App authentication is required if you # want to interact with any resources outside the scope of the repository # this workflow runs in. - name: Get GitHub App Token id: token uses: actions/create-github-app-token@v1 with: app-id: ${{ vars.ISSUEOPS_APP_ID }} private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }} owner: ${{ github.repository_owner }} # Check if the user who commented `.approve` is a member of the # administrator team. - name: Check Admin Membership id: check-admin uses: actions/github-script@v7 with: github-token: ${{ steps.token.outputs.token }} script: | try { await github.rest.teams.getMembershipForUserInOrg({ org: context.repo.owner, team_slug: 'admins', username: context.actor, }) core.setOutput('member', 'true') } catch (error) { if (error.status === 404) { core.setOutput('member', 'false') } throw error } # If the user is not a member of the administrator team, exit the # workflow. - if: ${{ steps.check-admin.outputs.member == 'false' }} name: Exit run: exit 0 # Parse the issue body into machine-readable JSON, so that it can be # processed by the rest of the workflow. - name: Parse Issue body id: parse uses: issue-ops/parser@v4 with: body: ${{ github.event.issue.body }} issue-form-template: team-membership.yml workspace: ${{ github.workspace }} - name: Add to Team id: add uses: actions/github-script@v7 with: github-token: ${{ steps.token.outputs.token }} script: | const parsedIssue = JSON.parse('${{ steps.parse.outputs.json }}') await github.rest.teams.addOrUpdateMembershipForUserInOrg({ org: context.repo.owner, team_slug: parsedIssue.team, username: '${{ github.event.issue.user.login }}', role: 'member' }) - name: Notify User id: notify uses: peter-evans/create-or-update-comment@v4 with: issue-number: ${{ github.event.issue.number }} body: | This request has been processed successfully! - name: Close Issue id: close uses: actions/github-script@v7 with: script: | await github.rest.issues.update({ issue_number: ${{ github.event.issue.number }}, owner: context.repo.owner, repo: context.repo.repo, state: 'closed', state_reason: 'completed' }) Take this with you And there you have it! With a handful of standardized workflows, you have an end-to-end, issue-driven process in place to manage team membership. This can be extended as far as you want, including support for removing users, auditing access, and more. With IssueOps, the sky is the limit! Here’s the best thing about IssueOps: It brings another level of automation to a surface I’m constantly using—and that’s GitHub. By using issues and pull requests as control centers for workflows, teams can reduce friction, improve efficiency, and keep everything transparent. Whether you want to automate deployments, approvals, or bug triage, IssueOps makes it all possible, without ever leaving your repo. For more information and examples, check out the open source IssueOps documentation repository, and if you want a deeper dive, you can head over to the open source IssueOps documentation. In my experience, it’s always best to start small and experiment with what works best for you. With just a bit of time, you’ll see your workflows get smoother with every commit (I know I have). Happy coding! ✨ Written by Sr. Service Delivery Engineer",
  "image": "https://github.blog/wp-content/uploads/2024/01/Productivity-DarkMode-3.png?fit=1200%2C630",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eSoftware development is filled with repetitive tasks—managing issues, handling approvals, triggering CI/CD workflows, and more. But what if you could automate these types of tasks directly within GitHub Issues? That’s the promise of \u003cstrong\u003eIssueOps\u003c/strong\u003e, a methodology that turns GitHub Issues into a command center for automation.\u003c/p\u003e\n\u003cp\u003eWhether you’re a solo developer or part of an engineering team, IssueOps helps you streamline operations without ever leaving your repository.\u003c/p\u003e\n\u003cp\u003eIn this article, I’ll explore the concept of IssueOps using state-machine terminology and strategies to help you work more efficiently on GitHub. After all, who doesn’t love automation?\u003c/p\u003e\n\u003ch2 id=\"what-is-issueops\" id=\"what-is-issueops\"\u003eWhat is IssueOps?\u003ca href=\"#what-is-issueops\" aria-label=\"What is IssueOps?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIssueOps is the practice of using GitHub Issues, GitHub Actions, and pull requests (PR) as an interface for automating workflows. Instead of switching between tools or manually triggering actions, you can use issue comments, labels, and state changes to kick off CI/CD pipelines, assign tasks, and even deploy applications.\u003c/p\u003e\n\u003cp\u003eMuch like the various other \u003cem\u003e*Ops\u003c/em\u003e paradigms (\u003ca href=\"https://github.blog/engineering/infrastructure/using-chatops-to-help-actions-on-call-engineers/\"\u003eChatOps\u003c/a\u003e, ClickOps, and so on), IssueOps is a collection of tools, workflows, and concepts that, when applied to \u003ca href=\"https://github.com/features/issues\"\u003eGitHub Issues\u003c/a\u003e, can automate mundane, repetitive tasks. The flexibility and power of issues, along with their relationship to pull requests, create a near limitless number of possibilities, such as managing approvals and deployments. All of this can really help to simplify your workflows on GitHub. I’m speaking from personal experience here.\u003c/p\u003e\n\u003cp\u003eIt’s important to note that IssueOps isn’t just a DevOps thing! Where DevOps offers a methodology to bring developers and operations into closer alignment, IssueOps is a workflow automation practice centered around GitHub Issues. IssueOps lets you run anything from \u003ca href=\"https://github.blog/engineering/engineering-principles/enabling-branch-deployments-through-issueops-with-github-actions/\"\u003ecomplex CI/CD pipelines\u003c/a\u003e to a \u003ca href=\"https://github.com/issue-ops/bear-creek-honey-farm\"\u003ebed and breakfast reservation system\u003c/a\u003e. If you can interact with it via an API, there’s a good chance you can build it with IssueOps!\u003c/p\u003e\n\u003ch2 id=\"so-why-use-issueops\" id=\"so-why-use-issueops\"\u003eSo, why use IssueOps?\u003ca href=\"#so-why-use-issueops\" aria-label=\"So, why use IssueOps?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThere are lots of benefits to utilizing IssueOps. Here’s how it’s useful in practice:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eIt’s event-driven, so you can automate the boring stuff:\u003c/strong\u003e IssueOps lets you automate workflows directly from GitHub Issues and pull requests, turning everyday interactions—from kicking off a CI/CD pipeline and managing approvals to updating project boards—into powerful triggers for GitHub Actions.\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIt’s customizable, so you can tailor workflows to your needs:\u003c/strong\u003e No two teams work the same way, and IssueOps is flexible enough to adapt. Whether you’re automating bug triage or triggering deployments, you can customize workflows based on event type and data provided.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIt’s transparent, so you can keep a record:\u003c/strong\u003e All actions taken on an issue are logged in its timeline, creating an easy-to-follow record of what happened and when.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIt’s immutable, so you do an audit whenever you need:\u003c/strong\u003e Because IssueOps uses GitHub Issues and pull requests as a source of truth, every action leaves a record. No more chasing approvals in Slack or manually triggering workflows: IssueOps keeps everything structured, automated, and auditable right inside GitHub.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"defining-issueops-workflows-and-how-theyre-like-finite-state-machines\" id=\"defining-issueops-workflows-and-how-theyre-like-finite-state-machines\"\u003eDefining IssueOps workflows and how they’re like finite-state machines\u003ca href=\"#defining-issueops-workflows-and-how-theyre-like-finite-state-machines\" aria-label=\"Defining IssueOps workflows and how they’re like finite-state machines\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eMost IssueOps workflows follow the same basic pattern:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA user opens an issue and provides information about a request  \u003c/li\u003e\n\u003cli\u003eThe issue is validated to ensure it contains the required information  \u003c/li\u003e\n\u003cli\u003eThe issue is submitted for processing  \u003c/li\u003e\n\u003cli\u003eApproval is requested from an authorized user or team  \u003c/li\u003e\n\u003cli\u003eThe request is processed and the issue is closed\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eSuppose you’re an administrator of an organization and want to reduce the overhead of managing team members. In this instance, you could use IssueOps to build an automated membership request and approval process. Within a workflow like this, you’d have several core steps:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA user creates a request to be added to a team  \u003c/li\u003e\n\u003cli\u003eThe request is validated   \u003c/li\u003e\n\u003cli\u003eThe request is submitted for approval  \u003c/li\u003e\n\u003cli\u003eAn administrator approves or denies this request  \u003c/li\u003e\n\u003cli\u003eThe request is processed\n\u003col\u003e\n\u003cli\u003eIf \u003cem\u003eapproved\u003c/em\u003e, the user is added to the team  \u003c/li\u003e\n\u003cli\u003eIf \u003cem\u003edenied\u003c/em\u003e, the user is not added to the team  \u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eThe user is notified of the outcome\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWhen designing your own IssueOps workflows, it can be very helpful to think of them as a \u003ca href=\"https://web.stanford.edu/class/cs123/lectures/CS123_lec07_Finite_State_Machine.pdf\"\u003efinite-state machine\u003c/a\u003e: a model for how objects move through a series of states in response to external events. Depending on certain rules defined within the state machine, a number of different actions can take place in response to state changes. If this is a little too complex, you can also think of it like a flow chart.\u003c/p\u003e\n\u003cp\u003eTo apply this comparison to IssueOps, an issue is the \u003cem\u003eobject\u003c/em\u003e that is processed by a state machine. It changes \u003cem\u003estate\u003c/em\u003e in response to \u003cem\u003eevents\u003c/em\u003e. As the object changes state, certain \u003cem\u003eactions\u003c/em\u003e may be performed as part of a \u003cem\u003etransition\u003c/em\u003e, provided any required conditions (\u003cem\u003eguards\u003c/em\u003e) are met. Once an \u003cem\u003eend state\u003c/em\u003e is reached, the issue can be closed.\u003c/p\u003e\n\u003cp\u003eThis breaks down into a few key concepts:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eState\u003c/strong\u003e: A point in an object’s lifecycle that satisfies certain condition(s).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEvent\u003c/strong\u003e: An external occurrence that triggers a state change.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTransition\u003c/strong\u003e: A link between two states that, when traversed by an object, will cause certain action(s) to be performed.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAction\u003c/strong\u003e: An atomic task that is performed when a transition is taken.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGuard\u003c/strong\u003e: A condition that is evaluated when a trigger event occurs. A transition is taken only if all associated guard condition(s) are met.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHere’s a simple state diagram for the example I discussed above.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/03/state-machine.png?resize=916%2C1588\" alt=\"A state diagram featuring a request approval process driven by an IssueOps workflow on GitHub. This workflow uses a combination of GitHub Issues and GitHub Actions to automate how team members are added to a given project. \" width=\"916\" height=\"1588\" srcset=\"https://github.blog/wp-content/uploads/2025/03/state-machine.png?w=916 916w, https://github.blog/wp-content/uploads/2025/03/state-machine.png?w=173 173w, https://github.blog/wp-content/uploads/2025/03/state-machine.png?w=768 768w, https://github.blog/wp-content/uploads/2025/03/state-machine.png?w=591 591w, https://github.blog/wp-content/uploads/2025/03/state-machine.png?w=886 886w\" sizes=\"auto, (max-width: 916px) 100vw, 916px\"/\u003e\u003c/p\u003e\n\u003cp\u003eNow, let’s dive into the state machine in more detail!\u003c/p\u003e\n\u003ch2 id=\"key-concepts-behind-state-machines\" id=\"key-concepts-behind-state-machines\"\u003eKey concepts behind state machines\u003ca href=\"#key-concepts-behind-state-machines\" aria-label=\"Key concepts behind state machines\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe benefit of breaking your workflow down into these components is that you can look for edge cases, enforce conditions, and create a robust, reliable result.\u003c/p\u003e\n\u003ch3 id=\"states\" id=\"states\"\u003e\u003cstrong\u003eStates\u003c/strong\u003e\u003ca href=\"#states\" aria-label=\"\u0026lt;strong\u0026gt;States\u0026lt;/strong\u0026gt;\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWithin a state machine, a \u003cem\u003estate\u003c/em\u003e defines the current status of an object. As the object transitions through the state machine, it will change states in response to external events. When building IssueOps workflows, common states for issues include opened, submitted, approved, denied, and closed.\u003c/p\u003e\n\u003cp\u003eThese should suffice as the core states to consider when building our workflows in our team membership example above.\u003c/p\u003e\n\u003ch3 id=\"events\" id=\"events\"\u003e\u003cstrong\u003eEvents\u003c/strong\u003e\u003ca href=\"#events\" aria-label=\"\u0026lt;strong\u0026gt;Events\u0026lt;/strong\u0026gt;\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIn a state machine, an \u003cem\u003eevent\u003c/em\u003e can be any form of interaction with the object and its current state. When building your own IssueOps, you should consider events from both the user and GitHub points of view.\u003c/p\u003e\n\u003cp\u003eIn our team membership request example, there are several events that can trigger a change in state. The request can be created, submitted, approved, denied, or processed.\u003c/p\u003e\n\u003cp\u003eIn this example, a user interacting with an issue—such as adding labels, commenting, or updating milestones—can also change its state. In GitHub Actions, there are many events that can trigger your workflows (see \u003ca href=\"https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows\"\u003eevents that trigger workflows\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003eHere are a few interactions, or events, that would affect our example IssueOps workflow when it comes to managing team members: \u003c/p\u003e\n\u003cdiv\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003cstrong\u003eRequest\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEvent\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eState\u003c/strong\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eRequest is created\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eissues\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eopened\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eRequest is approved\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eissue_comment\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ecreated\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eRequest is denied\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eissue_comment\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ecreated\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\u003c/div\u003e\n\u003cp\u003eAs you can see, the same GitHub workflow trigger can apply to multiple events in our state machine. Because of this, validation is key. Within your workflows, you should check both the type of event and the information provided by the user. In this case, we can conditionally trigger different workflow steps based on the content of the \u003ccode\u003eissue_comment\u003c/code\u003e event.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ejobs:\n  approve:\n    name: Process Approval\n    runs-on: ubuntu-latest\n\n    if: ${{ startsWith(github.event.comment.body, \u0026#39;.approve\u0026#39;) }}\n\n    # ...\n\n  deny:\n    name: Process Denial\n    runs-on: ubuntu-latest\n\n    if: ${{ startsWith(github.event.comment.body, \u0026#39;.deny\u0026#39;) }}\n\n    # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"transitions\" id=\"transitions\"\u003eTransitions\u003ca href=\"#transitions\" aria-label=\"Transitions\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eA \u003cem\u003etransition\u003c/em\u003e is simply the change from one state to another. In our example, for instance, a transition occurs when someone opens an issue. When a request meets certain conditions, or guards, the change in state can take place. When the transition occurs, some actions or processing may take place, as well.\u003c/p\u003e\n\u003cp\u003eWith our example workflow, you can think of the transitions themselves as the lines connecting different nodes in the state diagram. Or the lines connecting boxes in a flow chart.\u003c/p\u003e\n\u003ch3 id=\"guards\" id=\"guards\"\u003eGuards\u003ca href=\"#guards\" aria-label=\"Guards\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eGuards\u003c/em\u003e are conditions that must be verified before an event can trigger a transition to a different state. In our case, we know the following guards must be in place:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA request should not transition to an Approved state unless an administrator comments \u003ccode\u003e.approve\u003c/code\u003e on the issue.  \u003c/li\u003e\n\u003cli\u003eA request should not transition to a Denied state unless an administrator comments \u003ccode\u003e.deny\u003c/code\u003e on the issue.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhat about after the request is approved and the user is added to the team? This is referred to as an \u003cem\u003eunguarded transition\u003c/em\u003e. There are no conditions that must be met, so the transition happens immediately!\u003c/p\u003e\n\u003ch3 id=\"actions\" id=\"actions\"\u003e\u003cstrong\u003eActions\u003c/strong\u003e\u003ca href=\"#actions\" aria-label=\"\u0026lt;strong\u0026gt;Actions\u0026lt;/strong\u0026gt;\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLastly, \u003cem\u003eactions\u003c/em\u003e are specific tasks that are performed during a transition. They may affect the object itself, but this is not a requirement in our state machine. In our example, the following actions may take place at different times:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdministrators are notified that a request has been submitted  \u003c/li\u003e\n\u003cli\u003eThe user is added to the requested team  \u003c/li\u003e\n\u003cli\u003eThe user is notified of the outcome\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-real-world-example-building-a-team-membership-workflow-with-issueops\" id=\"a-real-world-example-building-a-team-membership-workflow-with-issueops\"\u003eA real-world example: Building a team membership workflow with IssueOps\u003ca href=\"#a-real-world-example-building-a-team-membership-workflow-with-issueops\" aria-label=\"A real-world example: Building a team membership workflow with IssueOps\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eNow that all of the explanation is out of the way, let’s dive into building our example! For reference, we’ll focus on the GitHub Actions workflows involved in building this automation. There are some additional repository and permissions settings involved that are discussed in more detail \u003ca href=\"https://issue-ops.github.io/docs/setup\"\u003ein these IssueOps docs\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"step-1-issue-form-template\" id=\"step-1-issue-form-template\"\u003eStep 1: Issue form template\u003ca href=\"#step-1-issue-form-template\" aria-label=\"Step 1: Issue form template\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://docs.github.com/en/communities/using-templates-to-encourage-useful-issues-and-pull-requests/syntax-for-issue-forms\"\u003eGitHub issue forms\u003c/a\u003e let you create standardized, formatted issues based on a set of form fields. Combined with the \u003ca href=\"https://github.com/issue-ops/parser\"\u003eissue-ops/parser\u003c/a\u003e action, you can get reliable, machine-readable JSON from issue body Markdown. For our example, we are going to create a simple form that accepts a single input: the team where we want to add the user.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ename: Team Membership Request\ndescription: Submit a new membership request\ntitle: New Team Membership Request\nlabels:\n  - team-membership\nbody:\n  - type: input\n    id: team\n    attributes:\n      label: Team Name\n      description: The team name you would like to join\n      placeholder: my-team\n    validations:\n      required: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen issues are created using this form, they will be parsed into JSON, which can then be passed to the rest of the IssueOps workflow.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;team\u0026#34;: \u0026#34;my-team\u0026#34;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"step-2-issue-validation\" id=\"step-2-issue-validation\"\u003eStep 2: Issue validation\u003ca href=\"#step-2-issue-validation\" aria-label=\"Step 2: Issue validation\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWith a machine-readable issue body, we can run additional validation checks to ensure the information provided follows any rules we might have in place. For example, we can’t automatically add a user to a team if the team doesn’t exist yet! That is where the \u003ca href=\"https://github.com/issue-ops/validator\"\u003eissue-ops/validator\u003c/a\u003e action comes into play. Using an issue form template and a custom validation script, we can confirm the existence of the team ahead of time.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emodule.exports = async (field) =\u0026gt; {\n  const { Octokit } = require(\u0026#39;@octokit/rest\u0026#39;)\n  const core = require(\u0026#39;@actions/core\u0026#39;)\n\n  const github = new Octokit({\n    auth: core.getInput(\u0026#39;github-token\u0026#39;, { required: true })\n  })\n\n  try {\n    // Check if the team exists\n    core.info(`Checking if team \u0026#39;${field}\u0026#39; exists`)\n\n    await github.rest.teams.getByName({\n      org: process.env.GITHUB_REPOSITORY_OWNER ?? \u0026#39;\u0026#39;,\n      team_slug: field\n    })\n\n    core.info(`Team \u0026#39;${field}\u0026#39; exists`)\n    return \u0026#39;success\u0026#39;\n  } catch (error) {\n    if (error.status === 404) {\n      // If the team does not exist, return an error message\n      core.error(`Team \u0026#39;${field}\u0026#39; does not exist`)\n      return `Team \u0026#39;${field}\u0026#39; does not exist`\n    } else {\n      // Otherwise, something else went wrong...\n      throw error\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen included in our IssueOps workflow, this adds any validation error(s) to the comment on the issue.\u003c/p\u003e\n\u003ch3 id=\"step-3-issue-workflows\" id=\"step-3-issue-workflows\"\u003eStep 3: Issue workflows\u003ca href=\"#step-3-issue-workflows\" aria-label=\"Step 3: Issue workflows\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe main “entrypoint” of this workflow occurs when a user creates or edits their team membership request issue. This workflow should focus heavily on validating any user inputs! For example, what should happen if the user inputs a team that does not exist?\u003c/p\u003e\n\u003cp\u003eIn our state machine, this workflow is responsible for handling everything up to the \u003cem\u003eopened\u003c/em\u003e state. Any time an issue is created, edited, or updated, it will re-run validation to ensure the request is ready to be processed. In this case, an additional guard condition is introduced. Before the request can be submitted, the user must comment with \u003ccode\u003e.submit\u003c/code\u003e after validation has passed.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ename: Process Issue Open/Edit\n\non:\n  issues:\n    types:\n      - opened\n      - edited\n      - reopened\n\npermissions:\n  contents: read\n  id-token: write\n  issues: write\n\njobs:\n  validate:\n    name: Validate Request\n    runs-on: ubuntu-latest\n\n    # This job should only be run on issues with the `team-membership` label.\n    if: ${{ contains(github.event.issue.labels.*.name, \u0026#39;team-membership\u0026#39;) }}\n\n    steps:\n      # This is required to ensure the issue form template and any validation\n      # scripts are included in the workspace.\n      - name: Checkout\n        id: checkout\n        uses: actions/checkout@v4\n\n      # Since this workflow includes custom validation scripts, we need to\n      # install Node.js and any dependencies.\n      - name: Setup Node.js\n        id: setup-node\n        uses: actions/setup-node@v4\n\n      # Install dependencies from `package.json`.\n      - name: Install Dependencies\n        id: install\n        run: npm install\n\n      # GitHub App authentication is required if you want to interact with any\n      # resources outside the scope of the repository this workflow runs in.\n      - name: Get GitHub App Token\n        id: token\n        uses: actions/create-github-app-token@v1\n        with:\n          app-id: ${{ vars.ISSUEOPS_APP_ID }}\n          private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }}\n          owner: ${{ github.repository_owner }}\n\n      # Remove any labels and start fresh. This is important because the\n      # issue may have been closed and reopened.\n      - name: Remove Labels\n        id: remove-label\n        uses: issue-ops/labeler@v2\n        with:\n          action: remove\n          github_token: ${{ steps.token.outputs.token }}\n          labels: |\n            validated\n            approved\n            denied\n          issue_number: ${{ github.event.issue.number }}\n          repository: ${{ github.repository }}\n\n      # Parse the issue body into machine-readable JSON, so that it can be\n      # processed by the rest of the workflow.\n      - name: Parse Issue Body\n        id: parse\n        uses: issue-ops/parser@v4\n        with:\n          body: ${{ github.event.issue.body }}\n          issue-form-template: team-membership.yml\n          workspace: ${{ github.workspace }}\n\n      # Validate early and often! Validation should be run any time an issue is\n      # interacted with, to ensure that any changes to the issue body are valid.\n      - name: Validate Request\n        id: validate\n        uses: issue-ops/validator@v3\n        with:\n          add-comment: true\n          github-token: ${{ steps.token.outputs.token }}\n          issue-form-template: team-membership.yml\n          issue-number: ${{ github.event.issue.number }}\n          parsed-issue-body: ${{ steps.parse.outputs.json }}\n          workspace: ${{ github.workspace }}\n\n      # If validation passes, add the validated label to the issue.\n      - if: ${{ steps.validate.outputs.result == \u0026#39;success\u0026#39; }}\n        name: Add Validated Label\n        id: add-label\n        uses: issue-ops/labeler@v2\n        with:\n          action: add\n          github_token: ${{ steps.token.outputs.token }}\n          labels: |\n            validated\n          issue_number: ${{ github.event.issue.number }}\n          repository: ${{ github.repository }}\n\n      # The `issue-ops/validator` action will automatically notify the user that\n      # the request was validated. However, you can optionally add instruction\n      # on what to do next.\n      - if: ${{ steps.validate.outputs.result == \u0026#39;success\u0026#39; }}\n        name: Notify User (Success)\n        id: notify-success\n        uses: peter-evans/create-or-update-comment@v4\n        with:\n          issue-number: ${{ github.event.issue.number }}\n          body: |\n            Hello! Your request has been validated successfully!\n\n            Please comment with `.submit` to submit this request.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOnce the issue is created, any further processing is triggered using issue comments—and this can be done with one workflow. However, to make things a bit easier to follow, we’ll break this into a few separate workflows.\u003c/p\u003e\n\u003ch4 id=\"submit-workflow\" id=\"submit-workflow\"\u003eSubmit workflow\u003ca href=\"#submit-workflow\" aria-label=\"Submit workflow\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eThe first workflow handles the user submitting the request. The main task it performs is validating the issue body against the form template to ensure it hasn’t been modified.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ename: Process Submit Comment\n\non:\n  issue_comment:\n    types:\n      - created\n\npermissions:\n  contents: read\n  id-token: write\n  issues: write\n\njobs:\n  submit:\n    name: Submit Request\n    runs-on: ubuntu-latest\n\n    # This job should only be run when the following conditions are true:\n    #\n    # - A user comments `.submit` on the issue.\n    # - The issue has the `team-membership` label.\n    # - The issue has the `validated` label.\n    # - The issue does not have the `approved` or `denied` labels.\n    # - The issue is open.\n    if: |\n      startsWith(github.event.comment.body, \u0026#39;.submit\u0026#39;) \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;team-membership\u0026#39;) == true \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;approved\u0026#39;) == false \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;denied\u0026#39;) == false \u0026amp;\u0026amp;\n      github.event.issue.state == \u0026#39;open\u0026#39;\n\n    steps:\n      # First, we are going to re-run validation. This is important because\n      # the issue body may have changed since the last time it was validated.\n\n      # This is required to ensure the issue form template and any validation\n      # scripts are included in the workspace.\n      - name: Checkout\n        id: checkout\n        uses: actions/checkout@v4\n\n      # Since this workflow includes custom validation scripts, we need to\n      # install Node.js and any dependencies.\n      - name: Setup Node.js\n        id: setup-node\n        uses: actions/setup-node@v4\n\n      # Install dependencies from `package.json`.\n      - name: Install Dependencies\n        id: install\n        run: npm install\n\n      # GitHub App authentication is required if you want to interact with any\n      # resources outside the scope of the repository this workflow runs in.\n      - name: Get GitHub App Token\n        id: token\n        uses: actions/create-github-app-token@v1\n        with:\n          app-id: ${{ vars.ISSUEOPS_APP_ID }}\n          private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }}\n          owner: ${{ github.repository_owner }}\n\n      # Remove the validated label. This will be re-added if validation passes.\n      - name: Remove Validated Label\n        id: remove-label\n        uses: issue-ops/labeler@v2\n        with:\n          action: remove\n          github_token: ${{ steps.token.outputs.token }}\n          labels: |\n            validated\n          issue_number: ${{ github.event.issue.number }}\n          repository: ${{ github.repository }}\n\n      # Parse the issue body into machine-readable JSON, so that it can be\n      # processed by the rest of the workflow.\n      - name: Parse Issue Body\n        id: parse\n        uses: issue-ops/parser@v4\n        with:\n          body: ${{ github.event.issue.body }}\n          issue-form-template: team-membership.yml\n          workspace: ${{ github.workspace }}\n\n      # Validate early and often! Validation should be run any time an issue is\n      # interacted with, to ensure that any changes to the issue body are valid.\n      - name: Validate Request\n        id: validate\n        uses: issue-ops/validator@v3\n        with:\n          add-comment: false # Don\u0026#39;t add another validation comment.\n          github-token: ${{ steps.token.outputs.token }}\n          issue-form-template: team-membership.yml\n          issue-number: ${{ github.event.issue.number }}\n          parsed-issue-body: ${{ steps.parse.outputs.json }}\n          workspace: ${{ github.workspace }}\n\n      # If validation passed, add the validated and submitted labels to the issue.\n      - if: ${{ steps.validate.outputs.result == \u0026#39;success\u0026#39; }}\n        name: Add Validated Label\n        id: add-label\n        uses: issue-ops/labeler@v2\n        with:\n          action: add\n          github_token: ${{ steps.token.outputs.token }}\n          labels: |\n            validated\n            submitted\n          issue_number: ${{ github.event.issue.number }}\n          repository: ${{ github.repository }}\n\n      # If validation succeeded, alert the administrator team so they can\n      # approve or deny the request.\n      - if: ${{ steps.validate.outputs.result == \u0026#39;success\u0026#39; }}\n        name: Notify Admin (Success)\n        id: notify-success\n        uses: peter-evans/create-or-update-comment@v4\n        with:\n          issue-number: ${{ github.event.issue.number }}\n          body: |\n            \u003cg-emoji fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44b.png?v8\" alias=\"wave\"\u003e👋\u003c/g-emoji\u003e @issue-ops/admins! The request has been validated and is\n            ready for your review. Please comment with `.approve` or `.deny`\n            to approve or deny this request.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"deny-workflow\" id=\"deny-workflow\"\u003eDeny workflow\u003ca href=\"#deny-workflow\" aria-label=\"Deny workflow\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eIf the request is denied, the user should be notified and the issue should close.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ename: Process Denial Comment\n\non:\n  issue_comment:\n    types:\n      - created\n\npermissions:\n  contents: read\n  id-token: write\n  issues: write\n\njobs:\n  submit:\n    name: Deny Request\n    runs-on: ubuntu-latest\n\n    # This job should only be run when the following conditions are true:\n    #\n    # - A user comments `.deny` on the issue.\n    # - The issue has the `team-membership` label.\n    # - The issue has the `validated` label.\n    # - The issue has the `submitted` label.\n    # - The issue does not have the `approved` or `denied` labels.\n    # - The issue is open.\n    if: |\n      startsWith(github.event.comment.body, \u0026#39;.deny\u0026#39;) \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;team-membership\u0026#39;) == true \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;submitted\u0026#39;) == true \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;validated\u0026#39;) == true \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;approved\u0026#39;) == false \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;denied\u0026#39;) == false \u0026amp;\u0026amp;\n      github.event.issue.state == \u0026#39;open\u0026#39;\n\n    steps:\n      # This time, we do not need to re-run validation because the request is\n      # being denied. It can just be closed.\n\n      # However, we do need to confirm that the user who commented `.deny` is\n      # a member of the administrator team.\n      # GitHub App authentication is required if you want to interact with any\n      # resources outside the scope of the repository this workflow runs in.\n      - name: Get GitHub App Token\n        id: token\n        uses: actions/create-github-app-token@v1\n        with:\n          app-id: ${{ vars.ISSUEOPS_APP_ID }}\n          private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }}\n          owner: ${{ github.repository_owner }}\n\n      # Check if the user who commented `.deny` is a member of the\n      # administrator team.\n      - name: Check Admin Membership\n        id: check-admin\n        uses: actions/github-script@v7\n        with:\n          github-token: ${{ steps.token.outputs.token }}\n          script: |\n            try {\n              await github.rest.teams.getMembershipForUserInOrg({\n                org: context.repo.owner,\n                team_slug: \u0026#39;admins\u0026#39;,\n                username: context.actor,\n              })\n              core.setOutput(\u0026#39;member\u0026#39;, \u0026#39;true\u0026#39;)\n            } catch (error) {\n              if (error.status === 404) {\n                core.setOutput(\u0026#39;member\u0026#39;, \u0026#39;false\u0026#39;)\n              }\n              throw error\n            }\n\n      # If the user is not a member of the administrator team, exit the\n      # workflow.\n      - if: ${{ steps.check-admin.outputs.member == \u0026#39;false\u0026#39; }}\n        name: Exit\n        run: exit 0\n\n      # If the user is a member of the administrator team, add the denied label.\n      - name: Add Denied Label\n        id: add-label\n        uses: issue-ops/labeler@v2\n        with:\n          action: add\n          github_token: ${{ steps.token.outputs.token }}\n          labels: |\n            denied\n          issue_number: ${{ github.event.issue.number }}\n          repository: ${{ github.repository }}\n\n      # Notify the user that the request was denied.\n      - name: Notify User\n        id: notify\n        uses: peter-evans/create-or-update-comment@v4\n        with:\n          issue-number: ${{ github.event.issue.number }}\n          body: |\n            This request has been denied and will be closed.\n\n      # Close the issue as not planned.\n      - name: Close Issue\n        id: close\n        uses: actions/github-script@v7\n        with:\n          script: |\n            await github.rest.issues.update({\n              issue_number: ${{ github.event.issue.number }},\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              state: \u0026#39;closed\u0026#39;,\n              state_reason: \u0026#39;not_planned\u0026#39;\n            })\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"approve-workflow\" id=\"approve-workflow\"\u003eApprove workflow\u003ca href=\"#approve-workflow\" aria-label=\"Approve workflow\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eFinally, we need to handle request approval. In this case, we need to add the user to the team, notify them, and close the issue.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ename: Process Approval Comment\n\non:\n  issue_comment:\n    types:\n      - created\n\npermissions:\n  contents: read\n  id-token: write\n  issues: write\n\njobs:\n  submit:\n    name: Approve Request\n    runs-on: ubuntu-latest\n\n    # This job should only be run when the following conditions are true:\n    #\n    # - A user comments `.approve` on the issue.\n    # - The issue has the `team-membership` label.\n    # - The issue has the `validated` label.\n    # - The issue has the `submitted` label.\n    # - The issue does not have the `approved` or `denied` labels.\n    # - The issue is open.\n    if: |\n      startsWith(github.event.comment.body, \u0026#39;.approve\u0026#39;) \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;team-membership\u0026#39;) == true \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;submitted\u0026#39;) == true \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;validated\u0026#39;) == true \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;approved\u0026#39;) == false \u0026amp;\u0026amp;\n      contains(github.event.issue.labels.*.name, \u0026#39;denied\u0026#39;) == false \u0026amp;\u0026amp;\n      github.event.issue.state == \u0026#39;open\u0026#39;\n\n    steps:\n      # This time, we do not need to re-run validation because the request is\n      # being approved. It can just be processed.\n\n      # This is required to ensure the issue form template is included in the\n      # workspace.\n      - name: Checkout\n        id: checkout\n        uses: actions/checkout@v4\n\n      # We do need to confirm that the user who commented `.approve` is a member\n      # of the administrator team. GitHub App authentication is required if you\n      # want to interact with any resources outside the scope of the repository\n      # this workflow runs in.\n      - name: Get GitHub App Token\n        id: token\n        uses: actions/create-github-app-token@v1\n        with:\n          app-id: ${{ vars.ISSUEOPS_APP_ID }}\n          private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }}\n          owner: ${{ github.repository_owner }}\n\n      # Check if the user who commented `.approve` is a member of the\n      # administrator team.\n      - name: Check Admin Membership\n        id: check-admin\n        uses: actions/github-script@v7\n        with:\n          github-token: ${{ steps.token.outputs.token }}\n          script: |\n            try {\n              await github.rest.teams.getMembershipForUserInOrg({\n                org: context.repo.owner,\n                team_slug: \u0026#39;admins\u0026#39;,\n                username: context.actor,\n              })\n              core.setOutput(\u0026#39;member\u0026#39;, \u0026#39;true\u0026#39;)\n            } catch (error) {\n              if (error.status === 404) {\n                core.setOutput(\u0026#39;member\u0026#39;, \u0026#39;false\u0026#39;)\n              }\n              throw error\n            }\n\n      # If the user is not a member of the administrator team, exit the\n      # workflow.\n      - if: ${{ steps.check-admin.outputs.member == \u0026#39;false\u0026#39; }}\n        name: Exit\n        run: exit 0\n\n      # Parse the issue body into machine-readable JSON, so that it can be\n      # processed by the rest of the workflow.\n      - name: Parse Issue body\n        id: parse\n        uses: issue-ops/parser@v4\n        with:\n          body: ${{ github.event.issue.body }}\n          issue-form-template: team-membership.yml\n          workspace: ${{ github.workspace }}\n\n      - name: Add to Team\n        id: add\n        uses: actions/github-script@v7\n        with:\n          github-token: ${{ steps.token.outputs.token }}\n          script: |\n            const parsedIssue = JSON.parse(\u0026#39;${{ steps.parse.outputs.json }}\u0026#39;)\n\n            await github.rest.teams.addOrUpdateMembershipForUserInOrg({\n              org: context.repo.owner,\n              team_slug: parsedIssue.team,\n              username: \u0026#39;${{ github.event.issue.user.login }}\u0026#39;,\n              role: \u0026#39;member\u0026#39;\n            })\n\n      - name: Notify User\n        id: notify\n        uses: peter-evans/create-or-update-comment@v4\n        with:\n          issue-number: ${{ github.event.issue.number }}\n          body: |\n            This request has been processed successfully!\n\n      - name: Close Issue\n        id: close\n        uses: actions/github-script@v7\n        with:\n          script: |\n            await github.rest.issues.update({\n              issue_number: ${{ github.event.issue.number }},\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              state: \u0026#39;closed\u0026#39;,\n              state_reason: \u0026#39;completed\u0026#39;\n            })\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"take-this-with-you\" id=\"take-this-with-you\"\u003eTake this with you\u003ca href=\"#take-this-with-you\" aria-label=\"Take this with you\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAnd there you have it! With a handful of standardized workflows, you have an end-to-end, issue-driven process in place to manage team membership. This can be extended as far as you want, including support for removing users, auditing access, and more. With IssueOps, the sky is the limit!\u003c/p\u003e\n\u003cp\u003eHere’s the best thing about IssueOps: It brings another level of automation to a surface I’m constantly using—and that’s GitHub. By using issues and pull requests as control centers for workflows, teams can reduce friction, improve efficiency, and keep everything transparent. Whether you want to automate deployments, approvals, or bug triage, IssueOps makes it all possible, without ever leaving your repo.\u003c/p\u003e\n\u003cp\u003eFor more information and examples, check out the open source \u003ca href=\"https://github.com/issue-ops/docs\"\u003eIssueOps documentation repository\u003c/a\u003e, and if you want a deeper dive, you can head over to the open source \u003ca href=\"https://issue-ops.github.io/docs/\"\u003eIssueOps documentation\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIn my experience, it’s always best to start small and experiment with what works best for you. With just a bit of time, you’ll see your workflows get smoother with every commit (I know I have). Happy coding! ✨\u003c/p\u003e\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/5089146?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/5089146?v=4\u0026amp;s=200\" alt=\"Nick Alteen\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eSr. Service Delivery Engineer\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "32 min read",
  "publishedTime": "2025-03-19T16:00:24Z",
  "modifiedTime": null
}
