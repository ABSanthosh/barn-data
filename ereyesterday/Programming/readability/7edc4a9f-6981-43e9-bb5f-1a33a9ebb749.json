{
  "id": "7edc4a9f-6981-43e9-bb5f-1a33a9ebb749",
  "title": "Using the Strangler Fig with Mobile Apps",
  "link": "https://martinfowler.com/articles/strangler-fig-mobile-apps.html",
  "description": "",
  "author": "",
  "published": "2024-10-29T10:34:00-04:00",
  "source": "https://martinfowler.com/feed.atom",
  "categories": null,
  "byline": "Matthew Foster",
  "length": 17021,
  "excerpt": "How to incrementally replace a legacy mobile application",
  "siteName": "martinfowler.com",
  "favicon": "",
  "text": "In this article we aim to show why taking an incremental approach to legacy mobile application modernization can be preferable to the classical 'rewrite from scratch' methodology. Thoughtworks has the benefit of working with large enterprise clients that are dependent on their in-house mobile applications for their core business. We see many of them asking their applications to do more and evolve faster, while at the same time, we see an increasing rejection of reputationally damaging high risk releases. As a solution, this article proposes alternative methods of legacy modernization that are based in Domain Driven Design and hinge on the application of the Strangler Fig pattern. While these concepts are far from new, we believe that their usage in mobile applications are novel. We feel that despite incurring a larger temporary overhead from their usage, this is an acceptable tradeoff. We assert how the methodology is used to combat the aforementioned attitudinal shifts in legacy mobile application development while gaining a platform to lower risk and drive incremental value delivery. We discuss how this works in theory, diving into both the architecture and code. We also recount how this worked in practice when it was trialled on a large, legacy mobile application at one of Thoughtworks’ enterprise clients. We highlight how the pattern enabled our client to rapidly build, test and productionize a modernized subset of domain functionalities inside an existing legacy application. We move on to evaluate the effectiveness of the trial by highlighting the business facing benefits such as a signficantly faster time to value and a 50% reduced median cycle time. We also touch on other expected benefits that should be used to measure the success of this methodology. The Problem with Mobile Legacy Modernization As applications age and grow, they tend to deteriorate both in quality and performance. Features take longer to get to market while outages and rolled back releases become more severe and frequent. There is a nuanced complexity to be understood about the reasons why this occurs both at the code and organizational level. To summarize though, at some point, an organization will grow tired of the poor outcomes from their software and start the process of legacy replacement. The decision to replace may be made based on multiple factors, including (but not limited to) cost/benefit analysis, risk analysis, or opportunity cost. Eventually a legacy modernization strategy will be chosen. This will be dependent on the organization’s attitude to risk. For example, a complex, high availability system may demand a more incremental or interstitial approach to legacy replacement/displacement than a simpler, less business critical one. In the case of mobile application modernization, those decisions have in recent memory been reasonably clear cut. A mobile application was often designed to do an individual thing- Apple’s “There’s an app for that” still rings out loud and clear in people’s minds 15 years after the initial batch of advertisements. That message was one that was taken to heart by organizations and startups alike: If you need to do something, write an app to do it. If you need to do something else, write another app to do that. This example struck me when I was pruning the apps on my phone a couple of years ago. At the time I noticed I had several apps from the manufacturer of my car; an older one and a newer one. I also had two apps from my bank; one showed my checking account, another that analyzed and illustrated my spending habits. I had three apps from Samsung for various IoT devices, and at least two from Philips that controlled my toothbrush and light bulbs. The point I’m laboring here is that a mobile application was never allowed to get so complicated, that it couldn’t be torn down, split out or started from scratch again. But what happens when this isn’t the case? Surely not all apps are created equal? Many believe that the mobile experience of the future will be centered around so-called “super-apps”; apps where you can pay, socialize, shop, call, message, and game, all under one application. To some degree this has already happened in China with “do-everything” applications like ‘WeChat’ and ‘AliPay’- we see the mobile device and its operating system as more of a vehicle to allow the running of these gigantic pieces of software. Comments from industry indicate a realization that the West is not quite as far along as China in this regard. But while not at the super-app, there is no doubt that complexity of the mobile app experience as a whole has increased significantly in recent years. Take the example of YouTube, when first installed, back in the early 2010’s, the application could play videos and not much else. Opening the application today one is presented with “Videos” and “Shorts”, a news feed, controllable categories, subscriptions, not to mention a content editing and publishing studio. Similarly with the Uber app, the user is asked if they want to order food. Google Maps can show a 3D view of a street and Amazon now recommends scrollable product-recommendation mood boards. These extra features have certainly enriched a user’s experience but they also make the traditional build, use, rebuild technique much more difficult. This difficulty can be explained by considering some of the existing common problems of mobile application development: Massive View Controllers/Activities/Fragments Direct manipulation of UI elements Platform specific code Poor Separation of Concerns Limited Testability With discipline, these problems can be managed early on. However, with a large application that has grown chaotically inline with the business it supports, incremental change will be difficult regardless. The solution then, as before, is to build new and release all at once. But what if you only want to add a new feature, or modernize an existing domain? What if you want to test your new feature with a small group of users ahead of time while serving everyone else the old experience? What if you’re happy with your app store reviews and don’t want to risk impacting them? Taking an incremental approach to app replacement then is the key to avoiding the pitfalls associated with ‘big bang releases’. The Strangler Fig pattern is often used to rebuild a legacy application in place: a new system is gradually created around the edges of an old one through frequent releases. This pattern is well known, but not widely used in a mobile context. We believe the reason for this is that there are several prerequisites that need to be in place before diving headfirst into the pattern. In their article on Patterns of Legacy Displacement, the authors describe four broad categories (prerequisites) used to help break a legacy problem into smaller, deliverable parts: Understand the outcomes you want to achieve Decide how to break the problem up into smaller parts Successfully deliver the parts Change the organization to allow this to happen on an ongoing basis Only in the third point, can we envisage the invocation of the Strangler Fig pattern. Doing so without an understanding of why, what or how it might continue in the future is a recipe for failure. Going forward, the article charts how Thoughtworks was able to help one of its enterprise clients expand its existing mobile legacy modernization efforts into a successful experiment that demonstrated the value behind the use of the Strangler Fig pattern in a mobile context. Satisfying the Prerequisites At this point, it seems appropriate to introduce the client that inspired the writing of this article – a globally distributed business with an established retail organization that had embraced mobile applications for many years. Our client had realized the benefits an app brought to provide a self-service experience for their products. They had quickly expanded and developed their app domains to allow millions of customers to take full advantage of all the products they sold. The organization had already spent a significant amount of time and effort modernizing its mobile applications in its smaller sub-brands. Responding to a lack of reuse/significant duplication of efforts, high cognitive load in app teams and slow feature delivery, the organization chose a mobile technology stack that leveraged a Modular Micro-app architecture. This strategy had been largely successful for them, enabling proliferation of features common to the organization (e.g. ‘login/registration/auth’ or ‘grocery shopping’) across different brands and territories, in a fraction of the time it would have taken to write them all individually. The diagram above is a simplified representation of the modular architecture the organization had successfully implemented. React Native was used due to its ability to entirely encapsulate a domain’s bounded context within an importable component. Each component was underpinned by its own backend for frontend (BFF) that came with the infrastructure as code to instantiate and run it. The host apps, shown above as UK and US, were simply containers that provided the app specific configuration and theming to the individual micro-apps. This ‘full slice’ of functionality has the advantages of both allowing re-use and reducing complexity by abstracting application domains to micro-apps managed by individual teams. We speak in depth about the results of this architecture in the already referenced article on ‘Linking Modular Architecture’. As touched upon earlier, the organization’s mobile estate was made up of a number of smaller sub-brands that served similar products in other territories. With the modular architecture pattern tried and tested, the organization wanted to focus efforts on its 'home-territory' mobile application (serving its main brand). Their main mobile app was much larger in terms of feature richness, revenue and user volumes to that of the sub brands. The app had been gaining features and users over many years of product development. This steady but significant growth had brought success in terms of how well-regarded their software was on both Google and Apple stores. However, it also started to show the characteristic signs of deterioration. Change frequency in the application had moved from days to months, resulting in a large product backlog and frustrated stakeholders who wanted an application that could evolve as fast as their products did. Their long release cycle was related to risk aversion: Any outage in the application was a serious loss of revenue to the organization and also caused their customers distress due to the essential nature of the products they sold. Changes were always tested exhaustively before being put live. The organization first considered a rewrite of the entire application and were shocked by the cost and duration of such a project. The potential negative reception of a ‘big bang’ new release to their app store customers also caused concerns in the levels of risk they could accept. Suggestions of alpha and beta user groups were considered unacceptable given the huge volumes of users the organization was serving. In this instance, a modernization effort similar to that seen in their sub-brands was believed to be of considerably higher cost and risk. Thoughtworks suggested an initial proof of concept that built on the successes of the reusability already seen with a modular architecture. We addressed the organization’s big bang risk aversion by suggesting the Strangler Fig pattern to incrementally replace individual domains. By leveraging both techniques together we were able to give the organization the ability to reuse production-ready domains from their modernized mobile apps inside their legacy app experience. The idea was to deliver value into the hands of customers much sooner with less duplication than in a full rewrite. Our focus was not on delivering the most beautiful or cohesive full app experience (-not quite yet anyway). It was about obtaining confidence both in the stability of the iterative replacement pattern and also in how well the new product was being received. These pieces of information allowed the organization to make more informed product decisions early on in the modernization process. This ensured the finished product had been extensively used and molded by the actual end users. Strangler Fig and Micro-apps So how far did we get with the proof of concept and more importantly how did we actually do this? Taking the learnings from Modular Micro-app architecture (described above), we theorized the design to be as follows: The initial state of the application involved the identification of domains and their navigation routes (Decide how to break the problem into smaller parts). We focused our efforts on finding navigation entry points to domains, we called them our ‘points of interception’. Those familiar with mobile application development will know that navigation is generally a well encapsulated concern, meaning that we could be confident that we could always direct our users to the experience of our choosing. Once we identified our ‘points of interception’, we selected a domain for incremental replacement/retirement. In the example above we focus on the Grocery domain within the existing application. The ‘new‘ Grocery domain, was a micro-app that was already being used within the sub-brand apps. The key to implementation of the Strangler Fig pattern involved embedding an entire React Native application inside the existing legacy application. The team took the opportunity to follow the good modularity practices that the framework encourages and built Grocery as an encapsulated component. This meant that as we added more domains to our Strangler Fig Embedded Application, we could control their enablement on an individual level. As per the diagram, in the legacy app, Grocery functionality was underpinned by a monolithic backend. When we imported the New Grocery Micro-app, it was configured to use that same monolithic backend. As mentioned previously, each micro-app came with its own Backend for Frontend (BFF). In this instance, the BFF was used as an anti-corruption layer; creating an isolating layer to maintain the same domain model as the frontend. The BFF talked to the existing monolith through the same interfaces the legacy mobile application did. Translation between both monolith and micro-app happened in both directions as necessary. This allowed the new module’s frontend not to be constrained by the legacy API as it developed. We continued the inside out replacement of the old application by repeating the process again on the next prioritized domain. Although out of scope for this proof of concept, the intention was that the process shown be repeated until the native application is eventually just a shell containing the new React Native application. This then would allow the removal of the old native application entirely, leaving the new one in its place. The new application is already tested with the existing customer base, the business has confidence in its resilience under load, developers find it easier to develop features and most importantly, unacceptable risks associated with a typical big bang release were negated. We're releasing this article in installments. Future installments will go into more detail on how we implanted the strangler fig, handled communication with the native application, and assessed the effectiveness of the new architecture.. To find out when we publish the next installment subscribe to this site's RSS feed, or Martin's feeds on Mastodon, LinkedIn, or X (Twitter).",
  "image": "https://martinfowler.com/articles/strangler-fig-mobile-apps/card.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\n\u003cp\u003eIn this article we aim to show why taking an incremental approach to\n    legacy mobile application modernization can be preferable to the classical\n    \u0026#39;rewrite from scratch\u0026#39; methodology. Thoughtworks has the benefit of working with\n    large enterprise clients that are dependent on their in-house mobile\n    applications for their core business. We see many of them asking their\n    applications to do more and evolve faster, while at the same time, we see an\n    increasing rejection of reputationally damaging high risk releases.\u003c/p\u003e\n\n\u003cp\u003eAs a solution, this article proposes alternative methods of legacy\n    modernization that are based in Domain Driven Design and hinge on the\n    application of the Strangler Fig pattern. While these concepts are far from\n    new, we believe that their usage in mobile applications are novel. We feel\n    that despite incurring a larger temporary overhead from their usage, this is\n    an acceptable tradeoff. We assert how the methodology is used to combat the\n    aforementioned attitudinal shifts in legacy mobile application development\n    while gaining a platform to lower risk and drive incremental value\n    delivery.\u003c/p\u003e\n\n\u003cp\u003eWe discuss how this works in theory, diving into both the architecture\n    and code. We also recount how this worked in practice when it was trialled on\n    a large, legacy mobile application at one of Thoughtworks’ enterprise\n    clients. We highlight how the pattern enabled our client to rapidly build,\n    test and productionize a modernized subset of domain functionalities inside\n    an existing legacy application. \u003c/p\u003e\n\n\u003cp\u003eWe move on to evaluate the effectiveness of the trial by highlighting the business\n    facing benefits such as a signficantly faster time to value and a 50% reduced median cycle\n    time. We also touch on other expected benefits that should be used to\n    measure the success of this methodology.\u003c/p\u003e\n\n\u003csection id=\"TheProblemWithMobileLegacyModernization\"\u003e\n\u003ch2\u003eThe Problem with Mobile Legacy Modernization\u003c/h2\u003e\n\n\u003cp\u003eAs applications age and grow, they tend to deteriorate both in quality\n      and performance. Features take longer to get to market while outages\n      and rolled back releases become more severe and frequent. There is a\n      nuanced complexity to be understood about the reasons why this\n      occurs both at the code and organizational level.\n      To summarize though, at some point, an\n      organization will grow tired of the poor outcomes from their\n      software and start the process of legacy replacement. The decision\n      to replace may be made based on multiple factors, including (but not limited to)\n      cost/benefit analysis, risk analysis, or opportunity cost. Eventually a legacy modernization strategy will be chosen.\n      This will be dependent on the organization’s attitude to risk. For\n      example, a complex, high availability system may demand a more\n      incremental or interstitial approach to legacy\n      replacement/displacement than a simpler, less business critical one.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn the case of mobile application modernization, those decisions have\n      in recent memory been reasonably clear cut. A mobile application was\n      often designed to do an individual thing- Apple’s “There’s an app for\n      that” still rings out loud and clear in people’s minds 15 years after\n      the initial batch of advertisements. That message was one that was taken\n      to heart by organizations and startups alike: \u003ci\u003eIf you need to do\n      something, write an app to do it. If you need to do something else, write\n      another app to do that.\u003c/i\u003e This example struck me when I was\n      pruning the apps on my phone a couple of years ago. At the time I noticed I\n      had several apps from the manufacturer of my car; an older one and a newer\n      one. I also had two apps from my bank; one showed my checking account,\n      another that analyzed and illustrated my spending habits. I had three apps\n      from Samsung for various IoT devices, and at least two from Philips that\n      controlled my toothbrush and light bulbs. The point I’m laboring here is\n      that a mobile application was never allowed to get so complicated,\n      that it couldn’t be torn down, split out or started from scratch again.\n      \u003c/p\u003e\n\n\u003cp\u003e But what happens when this isn’t the case? Surely not all apps are\n      created equal? Many believe that the mobile experience of the future\n      will be centered around so-called \u003ca href=\"https://www.theverge.com/23940924/elon-musk-x-twitter-all-hands-linda-yaccarino-super-app\"\u003e\n      “super-apps”\u003c/a\u003e; apps where you can pay, socialize, shop, call,\n      message, and game, all under one application. To some degree this has\n      already happened in China with “do-everything” applications like\n      ‘WeChat’ and ‘AliPay’- we see the mobile device and its operating\n      system as more of a vehicle to allow the running of these gigantic\n      pieces of software. Comments from industry indicate a realization\n      that the \u003ca href=\"https://hbr.org/2023/04/are-super-apps-coming-to-the-u-s-market\"\u003eWest\n      is not quite as far along as China in this regard\u003c/a\u003e. But while not\n      at the super-app, there is no doubt that complexity of the mobile\n      app experience as a whole has increased significantly in recent\n      years. Take the example of YouTube, when first installed, back in\n      the early 2010’s, the application could play videos and not much\n      else. Opening the application today one is presented with “Videos”\n      and “Shorts”, a news feed, controllable categories, subscriptions,\n      not to mention a content editing and publishing studio. Similarly\n      with the Uber app, the user is asked if they want to order food.\n      Google Maps can show a 3D view of a street and Amazon now recommends\n      scrollable product-recommendation mood boards. These extra features\n      have certainly enriched a user’s experience but they also make the\n      traditional build, use, rebuild technique much more difficult. \u003c/p\u003e\n\n\u003cp\u003eThis difficulty can be explained by considering some of the existing\n      common problems of mobile application development:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e Massive View Controllers/Activities/Fragments\u003c/li\u003e\n\n\u003cli\u003eDirect manipulation of UI elements \u003c/li\u003e\n\n\u003cli\u003e Platform specific code \u003c/li\u003e\n\n\u003cli\u003e Poor Separation of Concerns \u003c/li\u003e\n\n\u003cli\u003eLimited Testability\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eWith discipline, these problems can be managed early on. However, with\n      a large application that has grown chaotically inline with the business it\n      supports, incremental change will be difficult regardless. The solution then, as\n      before, is to build new and release all at once. But what if you only want\n      to add a new feature, or modernize an existing domain? What if you want to\n      test your new feature with a small group of users ahead of time while\n      serving everyone else the old experience? What if you’re happy with your\n      app store reviews and don’t want to risk impacting them? \u003c/p\u003e\n\n\u003cp\u003eTaking an incremental approach to app replacement then is the key to\n      avoiding the pitfalls associated with ‘big bang releases’. The \u003ca href=\"https://martinfowler.com/bliki/StranglerFigApplication.html\"\u003eStrangler\n      Fig pattern\u003c/a\u003e is often used to rebuild a legacy application in\n      place: a new system is gradually created around the edges of an old\n      one through frequent releases. This pattern is well known, but\n      not widely used in a mobile context. We believe the reason for this is that there are several prerequisites that need to be in\n      place before diving headfirst into the pattern. \u003c/p\u003e\n\n\u003cp\u003e In their article on \u003ca href=\"https://martinfowler.com/articles/patterns-legacy-displacement/\"\u003ePatterns\n      of Legacy Displacement\u003c/a\u003e, the authors describe four broad\n      categories (prerequisites) used to help break a legacy problem into\n      smaller, deliverable parts: \u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eUnderstand the outcomes you want to achieve\u003c/li\u003e\n\n\u003cli\u003eDecide how to break the problem up into smaller parts\u003c/li\u003e\n\n\u003cli\u003eSuccessfully deliver the parts\u003c/li\u003e\n\n\u003cli\u003eChange the organization to allow this to happen on an ongoing\n        basis\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eOnly in the third point, can we envisage the invocation of the Strangler Fig\n      pattern. Doing so without an understanding of why, what or how it might\n      continue in the future is a recipe for failure.\u003c/p\u003e\n\n\u003cp\u003eGoing forward, the article charts how Thoughtworks was able to help one\n      of its enterprise clients expand its existing mobile legacy modernization\n      efforts into a successful experiment that demonstrated the value behind\n      the use of the Strangler Fig pattern in a mobile context.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"SatisfyingThePrerequisites\"\u003e\n\u003ch2\u003eSatisfying the Prerequisites \u003c/h2\u003e\n\n\n\n\u003cp\u003eAt this point, it seems appropriate to introduce the client that\n      inspired the writing of this article – a globally distributed business\n      with an established retail organization that had embraced mobile\n      applications for many years. Our client had realized the benefits an\n      app brought to provide a self-service experience for their\n      products. They had quickly expanded and developed their app domains to allow millions\n      of customers to take full advantage of all the products they sold.\u003c/p\u003e\n\n\u003cp\u003eThe organization had already spent a significant amount of time and\n      effort modernizing its mobile applications in its smaller\n      sub-brands. Responding to a lack of reuse/significant duplication of\n      efforts, \u003ca href=\"https://itrevolution.com/articles/cognitive-load/\"\u003ehigh\n      cognitive load\u003c/a\u003e in app teams and slow feature delivery, the\n      organization chose a mobile technology stack that leveraged a\n      Modular Micro-app architecture. This strategy had been largely\n      successful for them, enabling proliferation of features common to\n      the organization (e.g. ‘login/registration/auth’ or ‘grocery shopping’)\n      across different brands and territories, in a fraction of the time it\n      would have taken to write them all individually. \u003c/p\u003e\n\n\u003cdiv id=\"d1.svg\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/strangler-fig-mobile-apps/d1.svg\" width=\"900\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003e The diagram above is a simplified representation of the modular\n      architecture the organization had successfully implemented. React\n      Native was used due to its ability to entirely encapsulate a\n      domain’s bounded context within an importable component. Each\n      component was underpinned by its own \u003ca href=\"https://samnewman.io/patterns/architectural/bff/\"\u003ebackend\n      for frontend (BFF) \u003c/a\u003e that came with the infrastructure as code to\n      instantiate and run it. The host apps, shown above as UK and US,\n      were simply containers that provided the app specific configuration\n      and theming to the individual micro-apps. This ‘full slice’ of\n      functionality has the advantages of both allowing re-use and\n      reducing complexity by abstracting application domains to micro-apps\n      managed by individual teams. We speak in depth about the results of\n      this architecture in the already referenced article on \u003ca href=\"https://martinfowler.com/articles/linking-modular-arch.html\"\u003e‘Linking\n      Modular Architecture’\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eAs touched upon earlier, the organization’s mobile estate was made up of\n      a number of smaller sub-brands that served similar products in other\n      territories. With the modular architecture pattern tried and tested, the\n      organization wanted to focus efforts on its \u0026#39;home-territory\u0026#39; mobile\n      application (serving its main brand). Their main mobile app was much\n      larger in terms of feature richness, revenue and user volumes to that of\n      the sub brands. The app had been gaining features and users over many\n      years of product development. This steady but significant growth had\n      brought success in terms of how well-regarded their software was on both\n      Google and Apple stores. However, it also started to show the\n      characteristic signs of deterioration. Change frequency in the application\n      had moved from days to months, resulting in a large product backlog and\n      frustrated stakeholders who wanted an application that could evolve as\n      fast as their products did. Their long release cycle was related to risk\n      aversion: Any outage in the application was a serious loss of revenue to\n      the organization and also caused their customers distress due to the\n      essential nature of the products they sold. Changes were always tested\n      exhaustively before being put live.\u003c/p\u003e\n\n\u003cp\u003eThe organization first considered a rewrite of the entire application\n      and were shocked by the cost and duration of such a project. The potential\n      negative reception of a ‘big bang’ new release to their app store\n      customers also caused concerns in the levels of risk they could accept.\n      Suggestions of alpha and beta user groups were considered unacceptable\n      given the huge volumes of users the organization was serving. In this\n      instance, a modernization effort similar to that seen in their sub-brands\n      was believed to be of considerably higher cost and risk.\u003c/p\u003e\n\n\u003cp\u003e Thoughtworks suggested an initial proof of concept that built on the\n      successes of the reusability already seen with a modular\n      architecture. We addressed the organization’s big bang risk aversion\n      by suggesting the \u003ca href=\"https://martinfowler.com/bliki/StranglerFigApplication.html\"\u003eStrangler\n      Fig pattern\u003c/a\u003e to incrementally replace individual domains. By\n      leveraging both techniques together we were able to give the\n      organization the ability to reuse production-ready domains from\n      their modernized mobile apps inside their legacy app experience. The\n      idea was to deliver value into the hands of customers much sooner\n      with less duplication than in a full rewrite. Our focus was not on\n      delivering the most beautiful or cohesive full app experience (-not\n      quite yet anyway). It was about obtaining confidence both in the\n      stability of the iterative replacement pattern and also in how well\n      the new product was being received. These pieces of information\n      allowed the organization to make more informed product decisions\n      early on in the modernization process. This ensured the finished product\n      had been extensively used and molded by the actual end users. \u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"StranglerFigAndMicro-apps\"\u003e\n\u003ch2\u003eStrangler Fig and Micro-apps\u003c/h2\u003e\n\n\u003cp\u003eSo how far did we get with the proof of concept and more importantly\n      how did we actually do this? Taking the learnings from Modular Micro-app\n      architecture (described above), we theorized the design to be as follows:\u003c/p\u003e\n\n\u003cdiv id=\"d2.svg\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/strangler-fig-mobile-apps/d2.svg\" width=\"900\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\n\n\u003cp\u003eThe initial state of the application involved the identification of\n      domains and their navigation routes \u003ci\u003e(Decide how to break the problem into\n      smaller parts)\u003c/i\u003e. We focused our efforts on finding navigation entry points\n      to domains, we called them our ‘points of interception’. Those familiar\n      with mobile application development will know that navigation is generally\n      a well encapsulated concern, meaning that we could be confident that we\n      could always direct our users to the experience of our choosing.\u003c/p\u003e\n\n\u003cdiv id=\"d3.svg\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/strangler-fig-mobile-apps/d3.svg\" width=\"900\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eOnce we identified our ‘points of interception’, we selected a domain\n      for incremental replacement/retirement. In the example above we focus on\n      the Grocery domain within the existing application. The ‘new‘ Grocery domain,\n      was a micro-app that was already being used within the sub-brand apps. The\n      key to implementation of the Strangler Fig pattern involved embedding an\n      entire React Native application inside the existing legacy application.\n      The team took the opportunity to follow the good modularity practices that\n      the framework encourages and built Grocery as an encapsulated component. This\n      meant that as we added more domains to our Strangler Fig Embedded\n      Application, we could control their enablement on an individual level.\u003c/p\u003e\n\n\u003cp\u003eAs per the diagram, in the legacy app, Grocery functionality was\n      underpinned by a monolithic backend. When we imported the New Grocery\n      Micro-app, it was configured to use that same monolithic backend. As\n      mentioned previously, each micro-app came with its own Backend for\n      Frontend (BFF). In this instance, the BFF was used as an anti-corruption\n      layer; creating an isolating layer to maintain the same domain model as\n      the frontend. The BFF talked to the existing monolith through the same\n      interfaces the legacy mobile application did. Translation between both\n      monolith and micro-app happened in both directions as necessary. This\n      allowed the new module’s frontend not to be constrained by the legacy API\n      as it developed.\u003c/p\u003e\n\n\u003cp\u003eWe continued the inside out replacement of the old application by\n      repeating the process again on the next prioritized domain. Although out\n      of scope for this proof of concept, the intention was that the process\n      shown be repeated until the native application is eventually just a shell\n      containing the new React Native application. This then would allow the removal of the\n      old native application entirely, leaving the new one in its place. The new\n      application is already tested with the existing customer base, the\n      business has confidence in its resilience under load, developers find it\n      easier to develop features and most importantly, unacceptable risks\n      associated with a typical big bang release were negated.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003cdiv\u003e\n\u003cp\u003eWe\u0026#39;re releasing this article in installments. Future installments will\n        go into more detail on how we implanted the strangler fig, handled\n        communication with the native application, and assessed the\n        effectiveness of the new architecture..\u003c/p\u003e\n\n\u003cp\u003e To find out when we publish the next installment subscribe to this\n        site\u0026#39;s\n        \u003ca href=\"https://martinfowler.com/feed.atom\"\u003eRSS feed\u003c/a\u003e, or Martin\u0026#39;s feeds on \n        \u003ca href=\"https://toot.thoughtworks.com/@mfowler\"\u003eMastodon\u003c/a\u003e,\n        \u003ca href=\"https://www.linkedin.com/in/martin-fowler-com/\"\u003eLinkedIn\u003c/a\u003e, or\n        \u003ca href=\"https://twitter.com/martinfowler\"\u003eX (Twitter)\u003c/a\u003e.\n        \u003c/p\u003e\n\n\u003c/div\u003e\n\n\u003chr/\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": null,
  "modifiedTime": "2024-10-29T00:00:00Z"
}
