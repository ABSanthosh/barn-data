{
  "id": "1dbde00e-df77-4dbd-a6d9-77a7b4c316c7",
  "title": "You‚Äôll Rebuild Everything Every Four Years Anyway",
  "link": "https://engineering.prezi.com/youll-rebuild-everything-every-four-years-anyway-b31ab0dcc17e?source=rss----911e72786e31---4",
  "description": "",
  "author": "Attila V√°g√≥",
  "published": "Fri, 04 Apr 2025 03:12:34 GMT",
  "source": "https://engineering.prezi.com/feed",
  "categories": [
    "software-engineering",
    "software-development",
    "prezi",
    "software-architecture",
    "web-development"
  ],
  "byline": "Attila V√°g√≥",
  "length": 9664,
  "excerpt": "The headline is a direct quote from a colleague of mine many years ago. We were on a Tiger Team rebuilding the frontend architecture of the company‚Äôs main product. Being a contractor, he had very‚Ä¶",
  "siteName": "Prezi Engineering",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*U0lNGgJfm0Qo1ZfYDS36KA.png",
  "text": "You‚Äôll Rebuild Everything Every Four Years AnywayTo refactor, or to rebuild? That is the question‚Ä¶The headline is a direct quote from a colleague of mine many years ago. We were on a Tiger Team rebuilding the frontend architecture of the company‚Äôs main product. Being a contractor, he had very little skin in the game. He came in, helped us six months ‚Äî one of the best engineers I have ever worked with ‚Äî then moved on. But his casual remark stayed with me. Do we really rebuild that often? If so, why? And when we don‚Äôt, why don‚Äôt we? Finding myself looking at the prospect of doing yet another major architectural migration, the questions are especially poignant.It‚Äôs probably no surprise to anyone, at this point, that software typically tends to evolve over time. This evolution is more often than not driven by product teams who ‚Äî naturally ‚Äî want the software to cater to the users‚Äô needs, to entice more users and keep them for a long time. That comes at a cost. Some of it avoidable, some of it, not so much. Some of it dependent on engineers, while other aspects a lot less. Long story short, it gets complicated, and it does so quickly.Clean code and successful products don‚Äôt always go hand in hand. This is a software engineering inevitability.When jQuery became the hottest new kid on the block, we all jumped at the opportunities it presented us with. Even though technically, it was still JavaScript, just enough of the complexities and tediousness of the language was abstracted away that everyone started building JS-heavy apps. That quickly ballooned into jQuery plugins ‚Äî really just more JavaScript files added to the head of your pages ‚Äî and you found yourself having a frontend monolith, unless you called it what it really was ‚Äî a gigantic pile of spaghetti code.Angular with its MVC architecture was supposed to solve that ‚Äî and other things ‚Äî but then it didn‚Äôt. Nor did React. Nor did Vue. Or Svelte. Or whatever you can think of. Given enough time, you‚Äôd keep finding yourself dealing with the same unintelligible mess, grinding yourself to a halt, wishing for yet another ‚Äúrebuild‚Äù.The problem with rebuildsIt‚Äôs a surprisingly common engineering request. If the app was built in Angular, you‚Äôll surely find a group of passionate engineers who will want to rebuild it all in React. If it‚Äôs a React app, you‚Äôll surely find some hard-core Svelte fans who‚Äôll jump at the opportunity to migrate everything to Svelte. No matter what library or framework an ‚Äúold‚Äù codebase is built with, there will be a group of engineers ready to kill it, and start from scratch.There is a false sense of security in rebuilding an existing product in a new architecture, language or framework. It‚Äôs meant to solve everything, while often it fails to solve much, if anything.Of course, before you even get the opportunity to rebuild, you already have a massive blocker to overcome ‚Äî selling it to the product teams and the business. I have yet to meet a product owner or manager who gets excited about not delivering features or experiments for 6‚Äì12 months, or a business that proactively wants to invest in getting the exact same thing a year later, for the cost of an entire year‚Äôs development time. Selling a major refactor or rebuild is perhaps one of the most difficult challenges an engineering team will face, as for it to make any sense it has to be tied to performance, security and/or scalability, and that isn‚Äôt always easy case to make, especially if we‚Äôre talking about an application built 3‚Äì4 years ago.Another trap that I often see engineering organisations fall for is what I call ‚Äúinherited fallacies‚Äù. During its lifetime, all software tends to attract dead weight in the form of abandoned features, unresolved A/B tests, business complexities due to decisions being made at a certain point for potentially even legitimate reasons. Add to that spaghetti code that possibly ties all of it together, and when rebuilding, you‚Äôll soon find yourself recreating the same monster you were hoping to get rid of in the first place. I strongly believe that rebuilds more often than not require product input, very pragmatic conversations as to what is kept and what isn‚Äôt. That said, watch out not to shed too much of those ‚Äúinherited fallacies‚Äù as you‚Äôll end up in Sonos‚Äô shoes, and heads will roll.The final aspect worth keeping in mind when rebuilding is new technical debt. The ‚Äî and I might add, wrong ‚Äî assumption is that a rebuild is a clean slate, and thus technical debt gets reset to zero. In my experience, that‚Äôs far from reality and an overly naive and quite dangerous assumption. All rebuilds come with their own set of technical challenges, some of which will end up in the backlog.Documentation is also something I often see being left for last, alongside less important feature enablements. You might also find that certain nice-to-haves developers were used to in their day-to-day are also missing. I remember the first time we handed over microfrontends to the teams in a previous company I worked at, half the DX (developer experience) features were missing. It took another year for a colleague of mine and me to develop a robust CLI tool, which to this day is being praised for being a tremendous help for developers every day.The problem with cleanupsIt‚Äôs difficult to bring up the conversation of rebuilds without cleanups and refactors being brought up as well. And for a good reason. Few businesses have an infinite number of resources for constant rebuilds, especially when in the same breath engineering teams keep harping on about clean code, software engineering best-practices, and various programming paradigms being enforced. It‚Äôs a conversation that gets contentious very quickly. How does code even get to such a state if engineers care so much about code quality, right? Regardless of what the answer might be, cleanup and refactors come with their own risks.As messy and tangled legacy code may often be, it‚Äôs working code, and that needs to be remembered. With that, anytime you refactor, you put that working state at risk, and when tests are inadequate or nonexistent, any sort of cleanup could end up in disaster. Sure, there‚Äôs always the revert button to save the day, but what‚Äôs most important to take away from this is that effective refactors and cleanups require robust testing to be in place.Effective refactors require robust testing, and that, unfortunately, isn‚Äôt commonplace.Another unfortunate reality is just how low developer interest is for refactors and cleanups. The vast majority of engineers are far more interested in building new things, greenfield stuff, rebuilds. Refactoring existing code is also not for the faint-of-heart and teams tend not to want to use their senior engineering resources for cleanups. And if that wasn‚Äôt enough, you also need to contend with the fact that engineers don‚Äôt always see eye-to-eye on what an effective refactor looks like, and you‚Äôve got yourself endless conversations in code reviews.Finally, it has to be said out loud that a lot of code complexity is also due to certain product and business decisions that have been made over the years. Some were likely made for business survival, or a reaction to the market. Years later those may make very little sense, but for a meaningful cleanup, product teams need to be involved in the decision-making, which makes many refractors more than just an engineering exercise. And we all know how this works ‚Äî the more stakeholders, the more difficult agreeing on something gets.A more pragmatic approachSo what do you do when neither of the above avenues seem particularly ideal? You pivot! Nah, I‚Äôm only joking. üòÑ I think anyone who has worked in a tech company for more than a year has PTSD from all the pivots they‚Äôve experienced. You need something that you can sell to product as an enabler, excites engineers and has business potential. In our case, that‚Äôs a new architecture that allows for a staggered departure from a highly interconnected setup to a much more modular one, where microservices are loosely coupled with microfrontends.Take for instance a Django-based site where over time you may have combined your templates and views with some modular React applications. If you examine closely the historical context in which these decisions were made, they‚Äôll all make sense. Unfortunately, that also means you‚Äôre dealing with an overly complex setup where even developing locally becomes a pain and slows delivery down to a grinding halt over time. Your option could be to throw all the Django out, and start fresh ‚Äî aka a complete rebuild. Or, instead, you can return JSON instead of views, remove the need for routing on the backend and apply something like Single-SPA on the frontend. On the server side the refactoring is far less risky, while on the frontend the rebuild is straightforward, yet staggered, as you‚Äôll only rebuild what you need, when you need it.More importantly, this answers the question I started with. Do we rebuild every four years? There is certainly an industry tendency to do so, and the reasons vary from technical to business and anything in-between. But if you ask me whether we need to, I think not. Not if the architecture we set up for ourselves allows for staggered migrations and an organic evolution, where you even have the option to build throwaway applications that satisfy a business goal for a limited amount of time without having long-term detrimental effects on the overall state of the code and your architecture.The best software architecture is the one that allows for change, where rebuilds are rare, and cleaning up just means throwing stuff out.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*4gf5UDs9E97yw0c2E44Cag.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"d380\" data-testid=\"storyTitle\"\u003eYou‚Äôll Rebuild Everything Every Four Years Anyway\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"f8dc\"\u003eTo refactor, or to rebuild? That is the question‚Ä¶\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://attilavago.medium.com/?source=post_page---byline--b31ab0dcc17e---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Attila V√°g√≥\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*Ilzy6aGvG__n7QzdkiL41A.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"4204\"\u003e\u003cspan\u003eT\u003c/span\u003ehe headline is a direct quote from a colleague of mine many years ago. We were on a Tiger Team rebuilding the frontend architecture of the company‚Äôs main product. Being a contractor, he had very little skin in the game. He came in, helped us six months ‚Äî one of the best engineers I have ever worked with ‚Äî then moved on. But his casual remark stayed with me. Do we really rebuild that often? If so, why? And when we don‚Äôt, why don‚Äôt we? Finding myself looking at the prospect of doing yet another major architectural migration, the questions are especially poignant.\u003c/p\u003e\u003cp id=\"048d\"\u003eIt‚Äôs probably no surprise to anyone, at this point, that software typically tends to evolve over time. This evolution is more often than not driven by product teams who ‚Äî naturally ‚Äî want the software to cater to the users‚Äô needs, to entice more users and keep them for a long time. That comes at a cost. Some of it avoidable, some of it, not so much. Some of it dependent on engineers, while other aspects a lot less. Long story short, it gets complicated, and it does so quickly.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"ad87\"\u003eClean code and successful products don‚Äôt always go hand in hand. This is a software engineering inevitability.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"e740\"\u003eWhen jQuery became the hottest new kid on the block, we all jumped at the opportunities it presented us with. Even though technically, it was still JavaScript, just enough of the complexities and tediousness of the language was abstracted away that everyone started building JS-heavy apps. That quickly ballooned into jQuery plugins ‚Äî really just more JavaScript files added to the head of your pages ‚Äî and you found yourself having a frontend monolith, unless you called it what it really was ‚Äî a gigantic pile of spaghetti code.\u003c/p\u003e\u003cp id=\"2ba8\"\u003eAngular with its MVC architecture was supposed to solve that ‚Äî and other things ‚Äî but then it didn‚Äôt. Nor did React. Nor did Vue. Or Svelte. Or whatever you can think of. Given enough time, you‚Äôd keep finding yourself dealing with the same unintelligible mess, grinding yourself to a halt, wishing for yet another ‚Äúrebuild‚Äù.\u003c/p\u003e\u003ch2 id=\"3d3e\"\u003eThe problem with rebuilds\u003c/h2\u003e\u003cp id=\"0e36\"\u003eIt‚Äôs a surprisingly common engineering request. If the app was built in Angular, you‚Äôll surely find a group of passionate engineers who will want to rebuild it all in React. If it‚Äôs a React app, you‚Äôll surely find some hard-core Svelte fans who‚Äôll jump at the opportunity to migrate everything to Svelte. No matter what library or framework an ‚Äúold‚Äù codebase is built with, there will be a group of engineers ready to kill it, and start from scratch.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"039e\"\u003eThere is a false sense of security in rebuilding an existing product in a new architecture, language or framework. It‚Äôs meant to solve everything, while often it fails to solve much, if anything.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"efb8\"\u003eOf course, before you even get the opportunity to rebuild, you already have a massive blocker to overcome ‚Äî \u003ca href=\"https://levelup.gitconnected.com/how-to-sell-engineering-needs-to-product-managers-2a4f379103b6?sk=60f7bf95b768bc5dbdcd463bddf56e84\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eselling it\u003c/strong\u003e to the product teams and the business\u003c/a\u003e. I have yet to meet a product owner or manager who gets excited about \u003cstrong\u003e\u003cem\u003enot\u003c/em\u003e\u003c/strong\u003e \u003ca rel=\"noopener ugc nofollow\" href=\"https://engineering.prezi.com/a-rare-insight-into-the-daily-challenges-of-an-experiments-team-349a94960b4f\" target=\"_blank\" data-discover=\"true\"\u003edelivering features or experiments\u003c/a\u003e for 6‚Äì12 months, or a business that proactively wants to invest in getting the exact same thing a year later, for the cost of an entire year‚Äôs development time. Selling a major refactor or rebuild is perhaps one of the most difficult challenges an engineering team will face, as for it to make any sense it has to be tied to performance, security and/or scalability, and that isn‚Äôt always easy case to make, especially if we‚Äôre talking about an application built 3‚Äì4 years ago.\u003c/p\u003e\u003cp id=\"0585\"\u003eAnother trap that I often see engineering organisations fall for is what I call ‚Äú\u003cstrong\u003einherited fallacies\u003c/strong\u003e‚Äù. During its lifetime, all software tends to attract dead weight in the form of abandoned features, unresolved A/B tests, business complexities due to decisions being made at a certain point for potentially even legitimate reasons. Add to that spaghetti code that possibly ties all of it together, and when rebuilding, you‚Äôll soon find yourself recreating the same monster you were hoping to get rid of in the first place. I strongly believe that rebuilds more often than not require product input, very pragmatic conversations as to what is kept and what isn‚Äôt. That said, watch out not to shed too much of those ‚Äúinherited fallacies‚Äù as \u003ca href=\"https://forums.macrumors.com/threads/sonos-ceo-steps-down-following-disastrous-app-redesign.2447308/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eyou‚Äôll end up in Sonos‚Äô shoes, and heads will roll\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"2d83\"\u003eThe final aspect worth keeping in mind when rebuilding is \u003cstrong\u003enew technical debt\u003c/strong\u003e. The ‚Äî and I might add, wrong ‚Äî assumption is that a rebuild is a clean slate, and thus technical debt gets reset to zero. In my experience, that‚Äôs far from reality and an overly naive and quite dangerous assumption. All rebuilds come with their own set of technical challenges, some of which will end up in the backlog.\u003c/p\u003e\u003cp id=\"26e6\"\u003eDocumentation is also something I often see being left for last, alongside less important feature enablements. You might also find that certain nice-to-haves developers were used to in their day-to-day are also missing. I remember the first time we handed over microfrontends to the teams in a previous company I worked at, half the DX (developer experience) features were missing. It took another year for a colleague of mine and me to develop a robust CLI tool, which to this day is being praised for being a tremendous help for developers every day.\u003c/p\u003e\u003ch2 id=\"5fc9\"\u003eThe problem with cleanups\u003c/h2\u003e\u003cp id=\"8807\"\u003eIt‚Äôs difficult to bring up the conversation of rebuilds without cleanups and refactors being brought up as well. And for a good reason. Few businesses have an infinite number of resources for constant rebuilds, especially when in the same breath engineering teams keep harping on about clean code, software engineering best-practices, and various programming paradigms being enforced. It‚Äôs a conversation that gets contentious very quickly. How does code even get to such a state if engineers care so much about code quality, right? Regardless of what the answer might be, cleanup and refactors come with their own risks.\u003c/p\u003e\u003cp id=\"0c50\"\u003eAs messy and tangled legacy code may often be, it‚Äôs working code, and that needs to be remembered. With that, anytime you refactor, you put that working state at risk, and when tests are inadequate or nonexistent, any sort of cleanup could end up in disaster. Sure, there‚Äôs always the revert button to save the day, but what‚Äôs most important to take away from this is that effective refactors and cleanups require robust testing to be in place.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"b4f1\"\u003eEffective refactors require robust testing, and that, unfortunately, isn‚Äôt commonplace.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"9490\"\u003eAnother unfortunate reality is just how low developer interest is for refactors and cleanups. The vast majority of engineers are far more interested in building new things, greenfield stuff, rebuilds. Refactoring existing code is also not for the faint-of-heart and teams tend not to want to use their senior engineering resources for cleanups. And if that wasn‚Äôt enough, you also need to contend with the fact that engineers don‚Äôt always see eye-to-eye on what an effective refactor looks like, and you‚Äôve got yourself \u003ca href=\"https://medium.com/gitconnected/code-review-etiquette-for-the-modern-developer-3fb5e1ad62d0?sk=ccda3532a86e90d3576ef3ce7a705f32\" rel=\"noopener\"\u003eendless conversations in code reviews\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"bf36\"\u003eFinally, it has to be said out loud that a lot of code complexity is also due to certain product and business decisions that have been made over the years. Some were likely made for business survival, or a reaction to the market. Years later those may make very little sense, but for a meaningful cleanup, product teams need to be involved in the decision-making, which makes many refractors more than just an engineering exercise. And we all know how this works ‚Äî the more stakeholders, the \u003ca href=\"https://medium.com/@jchyip/guiding-principle-consent-over-consensus-8aee08540d62\" rel=\"noopener\"\u003emore difficult agreeing on something gets\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"6233\"\u003eA more pragmatic approach\u003c/h2\u003e\u003cp id=\"51df\"\u003eSo what do you do when neither of the above avenues seem particularly ideal? You pivot! Nah, I‚Äôm only joking. üòÑ I think anyone who has worked in a tech company for more than a year has PTSD from all the pivots they‚Äôve experienced. You need something that you can sell to product as an enabler, excites engineers and has business potential. In our case, that‚Äôs a new architecture that allows for a staggered departure from a highly interconnected setup to a much more modular one, where microservices are loosely coupled with microfrontends.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"96cc\"\u003eTake for instance a Django-based site where over time you may have combined your templates and views with some modular React applications. If you examine closely the historical context in which these decisions were made, they‚Äôll all make sense. Unfortunately, that also means you‚Äôre dealing with an overly complex setup where even developing locally becomes a pain and slows delivery down to a grinding halt over time. Your option could be to throw all the Django out, and start fresh ‚Äî aka a complete rebuild. Or, instead, you can return JSON instead of views, remove the need for routing on the backend and apply something like Single-SPA on the frontend. On the server side the refactoring is far less risky, while on the frontend the rebuild is straightforward, yet staggered, as you‚Äôll only rebuild what you need, when you need it.\u003c/p\u003e\u003cp id=\"bcbe\"\u003eMore importantly, this answers the question I started with. Do we rebuild every four years? There is certainly an industry tendency to do so, and the reasons vary from technical to business and anything in-between. But if you ask me whether we need to, I think not. Not if the architecture we set up for ourselves allows for staggered migrations and an organic evolution, where you even have the option to build throwaway applications that satisfy a business goal for a limited amount of time without having long-term detrimental effects on the overall state of the code and your architecture.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"e57b\"\u003eThe best software architecture is the one that allows for change, where rebuilds are rare, and cleaning up just means throwing stuff out.\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-04-04T03:12:34.299Z",
  "modifiedTime": null
}
