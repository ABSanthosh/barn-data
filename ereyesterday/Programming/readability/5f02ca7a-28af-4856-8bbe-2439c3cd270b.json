{
  "id": "5f02ca7a-28af-4856-8bbe-2439c3cd270b",
  "title": "CodeQL zero to hero part 4: Gradio framework case study",
  "link": "https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-4-gradio-framework-case-study/",
  "description": "Learn how I discovered 11 new vulnerabilities by writing CodeQL models for Gradio framework and how you can do it, too. The post CodeQL zero to hero part 4: Gradio framework case study appeared first on The GitHub Blog.",
  "author": "Sylwia Budzynska",
  "published": "Wed, 11 Dec 2024 15:00:15 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Security",
    "Vulnerability research",
    "code scanning",
    "CodeQL",
    "GitHub Security Lab"
  ],
  "byline": "Sylwia Budzynska",
  "length": 35681,
  "excerpt": "Learn how I discovered 11 new vulnerabilities by writing CodeQL models for Gradio framework and how you can do it, too.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "Gradio is a Python web framework for demoing machine learning applications, which in the past few years has exploded in popularity. In this blog, you’ll will follow along with the process, in which I modeled (that is, added support for) Gradio framework, finding 11 vulnerabilities to date in a number of open source projects, including AUTOMATIC1111/stable-diffusion-webui—one of the most popular projects on GitHub, that was included in the 2023 Octoverse report and 2024 Octoverse report. Check out the vulnerabilities I’ve found on the GitHub Security Lab’s website. Following the process outlined in this blog, you will learn how to model new frameworks and libraries in CodeQL and scale your research to find more vulnerabilities. This blog is written to be read standalone; however, if you are new to CodeQL or would like to dig deeper into static analysis and CodeQL, you may want to check out the previous parts of my CodeQL zero to hero blog series. Each deals with a different topic: status analysis fundamentals, writing CodeQL, and using CodeQL for security research. CodeQL zero to hero part 1: The fundamentals of static analysis for vulnerability research CodeQL zero to hero part 2: Getting started with CodeQL CodeQL zero to hero part 3: Security research with CodeQL Each also has accompanying exercises, which are in the above blogs, and in the CodeQL zero to hero repository. Quick recap CodeQL uses data flow analysis to find vulnerabilities. It uses models of sources (for example, an HTTP GET request parameter) and sinks in libraries and frameworks that could cause a vulnerability (for example, cursor.execute from MySQLdb, which executes SQL queries), and checks if there is a data flow path between the two. If there is, and there is no sanitizer on the way, CodeQL will report a vulnerability in the form of an alert. Check out the first blog of the CodeQL zero to hero series to learn more about sources, sinks and data flow analysis,. See the second blog to learn about the basics of writing CodeQL. Head on to the third blog of the CodeQL zero to hero series to implement your own data flow analysis on certain code elements in CodeQL. Motivation CodeQL has models for the majority of most popular libraries and frameworks, and new ones are continuously being added to improve the detection of vulnerabilities. One such example is Gradio. We will go through the process of analyzing it and modeling it today. Looking into a new framework or a library and modeling it with CodeQL is a perfect chance to do research on the projects using that framework, and potentially find multiple vulnerabilities at once. Hat tip to my coworker, Alvaro Munoz, for giving me a tip about Gradio, and for his guide on researching Apache Dubbo and writing models for it, which served as inspiration for my research (if you are learning CodeQL and haven’t checked it out yet, you should!). Research and CodeQL modeling process Frameworks have sources and sinks, and that’s what we are interested in identifying, and later modeling in CodeQL. A framework may also provide user input sanitizers, which we are also interested in. The process consisted, among others, of: Reviewing the documentation and code for sources—any entry points to the application, which take user input. Reviewing the documentation and code for sinks—any functionality that is potentially dangerous, for example, a function that executes raw SQL queries and that may take user input. Dynamically testing interesting elements. Checking for previous security issues related to Gradio, and vulnerabilities in the applications that use Gradio. Let me preface here that it’s natural that a framework like Gradio has sources and sinks, and there’s nothing inherently wrong about it. All frameworks have sources and sinks—Django, Flask, Tornado, and so on. The point is that if the classes and functions provided by the frameworks are not used in a secure way, they may lead to vulnerabilities. And that’s what we are interested in catching here, for applications that use the Gradio framework. Gradio Gradio is a Python web framework for demoing machine learning applications, which in the past few years has become increasingly popular. Gradio’s documentation is thorough and gives a lot of good examples to get started with using Gradio. We will use some of them, modifying them a little bit, where needed. Gradio Interface We can create a simple interface in Gradio by using the Interface class. import gradio as gr def greet(name, intensity): return \"Hello, \" + name + \"!\" * int(intensity) demo = gr.Interface( fn=greet, inputs=[gr.Textbox(), gr.Slider()], outputs=[gr.Textbox()]) demo.launch() In this example, the Interface class takes three arguments: The fn argument takes a reference to a function that contains the logic of the program. In this case, it’s the reference to the greet function. The inputs argument takes a list of input components that will be used by the function passed to fn. Here, inputs takes the values from a text (which is equivalent to a gr.Textbox component) and a slider (equivalent to a gr.Slider component). The outputs argument specifies what will be returned by the function passed to fn in the return statement. Here, the output will be returned as text (so, gr.Textbox). Running the code will start an application with the following interface. We provide example inputs, “Sylwia” in the textbox and “3” in the slider, and submit them, which results in an output, “Hello, Sylwia!!!”. Example app written using Gradio Interface class Gradio Blocks Another popular way of creating applications is by using the gr.Blocks class with a number of components; for example, a dropdown list, a set of radio buttons, checkboxes, and so on. Gradio documentation describes the Blocks class in the following way: Blocks offers more flexibility and control over: (1) the layout of components (2) the events that trigger the execution of functions (3) data flows (for example, inputs can trigger outputs, which can trigger the next level of outputs). With gr.Blocks, we can use certain components as event listeners, for example, a click of a given button, which will trigger execution of functions using the input components we provided to them. In the following code we create a number of input components: a slider, a dropdown, a checkbox group, a radio buttons group, and a checkbox. Then, we define a button, which will execute the logic of the sentence_builder function on a click of the button and output the results of it as a textbox. import gradio as gr def sentence_builder(quantity, animal, countries, place, morning): return f\"\"\"The {quantity} {animal}s from {\" and \".join(countries)} went to the {place} in the {\"morning\" if morning else \"night\"}\"\"\" with gr.Blocks() as demo: gr.Markdown(\"Choose the options and then click **Run** to see the output.\") with gr.Row(): quantity = gr.Slider(2, 20, value=4, label=\"Count\", info=\"Choose between 2 and 20\") animal = gr.Dropdown([\"cat\", \"dog\", \"bird\"], label=\"Animal\", info=\"Will add more animals later!\") countries = gr.CheckboxGroup([\"USA\", \"Japan\", \"Pakistan\"], label=\"Countries\", info=\"Where are they from?\") place = gr.Radio([\"park\", \"zoo\", \"road\"], label=\"Location\", info=\"Where did they go?\") morning = gr.Checkbox(label=\"Morning\", info=\"Did they do it in the morning?\") btn = gr.Button(\"Run\") btn.click( fn=sentence_builder, inputs=[quantity, animal, countries, place, morning], outputs=gr.Textbox(label=\"Output\") ) if __name__ == \"__main__\": demo.launch(debug=True) Running the code and providing example inputs will give us the following results: Example app written using Gradio Blocks Identifying attack surface in Gradio Given the code examples, the next step is to identify how a Gradio application might be written in a vulnerable way, and what we could consider a source or a sink. A good point to start is to run a few code examples, use the application the way it is meant to be used, observe the traffic, and then poke at the application for any interesting areas. The first interesting point that stood out for me for investigation are the variables passed to the inputs keyword argument in the Interface example app above, and the on click button event handler in the Blocks example. Let’s start by running the above Gradio Interface example app in your favorite proxy (or observing the traffic in your browser’s DevTools), and filling out the form with example values (string \"Sylwia\" and integer 3) shows the data being sent: Traffic in the Gradio Interface example app, observed in Firefox DevTools The values we set are sent as a string “Sylwia” and an integer 3 in a JSON, in the value of the “data” key. Here are the values as seen in Burp Suite: JSON in the request to the example Interface application The text box naturally allows for setting any string value we would like, and that data will later be processed by the application as a string. What if I try to set it to something else than a string, for example, an integer 1000? Testing setting the textbox value to an integer Turns out that’s allowed. What about a slider? You might expect that we can only set the values that are restricted in the code (so, here these should be integer values from 2 to 20). Could we send something else, for example, a string \"high”? Testing setting the slider value to a string We see an error: File \"/**/**/**/example.py\", line 4, in greet return \"Hello, \" + name + \"!\" * int(intensity) ^^^^^^^^^^^^^^ ValueError: invalid literal for int() with base 10: 'high' That’s very interesting. 🤔 The error didn’t come up from us setting a string value on a slider (which should only allow integer values from 2 to 20), but from the int function, which converts a value to an integer in Python. Meaning, until that point, the value from the slider can be set to anything, and can be used in any dangerous functions (sinks) or otherwise sensitive functionality. All in all, perfect candidate for sources. We can do a similar check with a more complex example with gr.Blocks. We run the example code from the previous section and observe our data being sent: Observed values in the request The values sent correspond to values given in the inputs list, which comes from the components: A Slider with values from 2 to 20. A Dropdown with values: “cat”, “dog”, “bird”. ACheckboxGroup with values: “USA”, “Japan”, “Pakistan”. A Radio with values: “park”, “zoo”, “road”. A Checkbox. Then, we test what we can send to the application. We pass values that are not expected for the given components: A Slider—a string \"a thousand\". A Dropdown – a string \"turtle\", which is not one of the dropdown options. A CheckboxGroup—a list with [\"USA\",\"Japan\", \"Poland\"], of which \"Poland\" is not one of the options. A Radio—a list [\"a\", \"b\"]. Radio is supposed to allow only one value, and not a list. A Checkbox—an integer 123. Checkbox is supposed to take only true or false. Observed values in the request No issues reported—we can set the source values to anything no matter which component they come from. That makes them perfect candidates for modeling as sources and later doing research at scale. Except. Echo of sources past: gr.Dropdown example Not long after I had a look at Gradio version 4.x.x and wrote models for its sources, the Gradio team asked Trail of Bits (ToB) to conduct a security audit of the framework, which resulted in Maciej Domański and Vasco Franco‬ creating a report on Gradio’s security with a lot of cool findings. The fixes for the issues reported were incorporated into Gradio 5.0, which was released on October 9, 2024. One of the issues that ToB’s team reported was TOB-GRADIO-15: Dropdown component pre-process step does not limit the values to those‬‭ in the dropdown list‬. TOB-GRADIO-15 from Trail of Bits’ Gradio review. The issue was subsequently fixed in Gradio 5.0 and so, submitting values that are not valid choices in gr.Dropdown, gr.Radio, and gr.CheckboxGroup results in an error, namely: gradio.exceptions.Error: \"Value: turtle is not in the list of choices: ['cat', 'dog', 'bird']\" In this case, the vulnerabilities which may result from these sources, may not be exploitable in Gradio version 5.0 and later. There were also a number of other changes regarding security to the Gradio framework in version 5.0, which can be explored in the ToB report on Gradio security. The change made me ponder whether to update the CodeQL models I have written and added to CodeQL. However, since the sources can still be misused in applications running Gradio versions below 5.0, I decided to leave them as they are. Modeling Gradio with CodeQL We have now identified a number of potential sources. We can then write CodeQL models for them, and later use these sources with existing sinks to find vulnerabilities in Gradio applications at scale. But let’s go back to the beginning: how do we model these Gradio sources with CodeQL? Preparing example CodeQL database for testing Recall that to run CodeQL queries, we first need to create a CodeQL database from the source code that we are interested in. Then, we can run our CodeQL queries on that database to find vulnerabilities in the code. How CodeQL works – create a CodeQL database, and run queries on that database We start with intentionally vulnerable source code using gr.Interface that we want to use as our test case for finding Gradio sources. The code is vulnerable to command injection via both folder and logs arguments, which end in the first argument to an os.system call. import gradio as gr import os def execute_cmd(folder, logs): cmd = f\"python caption.py --dir={folder} --logs={logs}\" os.system(cmd) folder = gr.Textbox(placeholder=\"Directory to caption\") logs = gr.Checkbox(label=\"Add verbose logs\") demo = gr.Interface(fn=execute_cmd, inputs=[folder, logs]) if __name__ == \"__main__\": demo.launch(debug=True) Let’s create another example using gr.Blocks and gr.Button.click to mimic our earlier examples. Similarly, the code is vulnerable to command injection via both folder and logs arguments. The code is a simplified version of a vulnerability I found in an open source project. import gradio as gr import os def execute_cmd(folder, logs): cmd = f\"python caption.py --dir={folder} --logs={logs}\" os.system(cmd) with gr.Blocks() as demo: gr.Markdown(\"Create caption files for images in a directory\") with gr.Row(): folder = gr.Textbox(placeholder=\"Directory to caption\") logs = gr.Checkbox(label=\"Add verbose logs\") btn = gr.Button(\"Run\") btn.click(fn=execute_cmd, inputs=[folder, logs]) if __name__ == \"__main__\": demo.launch(debug=True) I also added two more code snippets which use positional arguments instead of keyword arguments. The database and the code snippets are available in the CodeQL zero to hero repository. Now that we have the code, we can create a CodeQL database for it by using the CodeQL CLI. It can be installed either as an extension to the gh tool (recommended) or as a binary. Using the gh tool with the CodeQL CLI makes it much easier to update CodeQL. CodeQL CLI installation instructions Install GitHub’s command line tool, gh, using the installation instructions for your system. Install CodeQL CLI: gh extensions install github/gh-codeql (optional, but recommended) To use the CodeQL CLI directly in the terminal (without having to type gh), run: gh codeql install-stub Make sure to regularly update the CodeQL CLI with: codeql set-version latest After installing CodeQL CLI, we can create a CodeQL database. First, we move to the folder, where all our source code is located. Then, to create a CodeQL database called gradio-cmdi-db for the Python code in the folder gradio-tests, run: codeql database create gradio-cmdi-db --language=python --source-root='./gradio-tests' This command creates a new folder gradio-cmdi-db with the extracted source code elements. We will use this database to test and run CodeQL queries on. I assume here you already have the VS Code CodeQL starter workspace set up. If not, follow the instructions to create a starter workspace and come back when you are finished. To run queries on the database we created, we need to add it to the VS Code CodeQL extension. We can do it with the “Choose Database from Folder” button and pointing it to the gradio-cmdi-db folder. Now that we are all set up, we can move on to actual CodeQL modeling. Identifying code elements to query for Let’s have another look at our intentionally vulnerable code. import gradio as gr import os def execute_cmd(folder, logs): cmd = f\"python caption.py --dir={folder} --logs={logs}\" os.system(cmd) return f\"Command: {cmd}\" folder = gr.Textbox(placeholder=\"Directory to caption\") logs = gr.Checkbox(label=\"Save verbose logs\") output = gr.Textbox() demo = gr.Interface( fn=execute_cmd, inputs=[folder, logs], outputs=output) if __name__ == \"__main__\": demo.launch(debug=True) In the first example with the Interface class, we had several components on the website. In fact, on the left side we have one source component which takes user input – a textbox. On the right side, we have an output text component. So, it’s not enough that a component is, for example, of a gr.Textbox() type to be considered a source. To be considered a source of an untrusted input, a component has to be passed to the inputs keyword argument, which takes an input component or a list of input components that will be used by the function passed to fn and processed by the logic of the application in a potentially vulnerable way. So, not all components are sources. In our case, any values passed to inputs in the gr.Interface class are sources. We could go a step further, and say that if gr.Interface is used, then anything passed to the execute_cmd function is a source – so here the folder and logs. The same situation happens in the second example with the gr.Blocks class and the gr.Button.click event listener. Any arguments passed to inputs in the Button.onlick method, so, to the execute_cmd function, are sources. Modeling gr.Interface Let’s start by looking at the gr.Interface class. Since we are interested in identifying any values passed to inputs in the gr.Interface class, we first need to identify any calls to gr.Interface. CodeQL for Python has a library for finding reference classes and functions defined in library code called ApiGraphs, which we can use to identify any calls to gr.Interface. See CodeQL zero to hero part 2 for a refresher on writing CodeQL and CodeQL zero to hero part 3 for a refresher on using ApiGraphs. We can get all references to gr.Interface calls with the following query. Note that: We set the query to be @kind problem, which will format the results of the select as an alert. In from, we define a node variable of the API::CallNode type, which gives us the set of all API::CallNodes in the program. In where, we filter the node to be a gr.Interface call. In select, we choose our output to be node and string “Call to gr.Interface”, which will be formatted as an alert due to setting @kind problem. /** * @id codeql-zero-to-hero/4-1 * @severity error * @kind problem */ import python import semmle.python.ApiGraphs from API::CallNode node where node = API::moduleImport(\"gradio\").getMember(\"Interface\").getACall() select node, \"Call to gr.Interface\" Run the query by right-clicking and selecting “CodeQL: Run Query on Selected Database”. If you are using the same CodeQL database, you should see two results, which proves that the query is working as expected (recall that I added more code snippets to the test database. The database and the code snippets are available in the CodeQL zero to hero repository). Query results in two alerts Next, we want to identify values passed to inputs in the gr.Interface class, which are passed to the execute_cmd function. We could do it in two ways—by identifying the values passed to inputs and then linking them to the function referenced in fn, or by looking at the parameters to the function referenced in fn directly. The latter is a bit easier, so let’s focus on that solution. If you’d be interested in the second solution, check out the Taint step section. To sum up, we are interested in getting the folder and logs parameters. import gradio as gr import os def execute_cmd(folder, logs): cmd = f\"python caption.py --dir={folder} --logs={logs}\" os.system(cmd) return f\"Command: {cmd}\" folder = gr.Textbox(placeholder=\"Directory to caption\") logs = gr.Checkbox(label=\"Save verbose logs\") output = gr.Textbox() demo = gr.Interface( fn=execute_cmd, inputs=[folder, logs], outputs=output) if __name__ == \"__main__\": demo.launch(debug=True) We can get folder and logs with the query below: /** * @id codeql-zero-to-hero/4-2 * @severity error * @kind problem */ import python import semmle.python.ApiGraphs from API::CallNode node where node = API::moduleImport(\"gradio\").getMember(\"Interface\").getACall() select node.getParameter(0, \"fn\").getParameter(_), \"Gradio sources\" To get the first the function reference in fn (or in the 1st positional argument) we use the getParameter(0, \"fn\") predicate – 0 refers to the 1st positional argument and \"fn\" refers to the fn keyword argument. Then, to get the parameters themselves, we use the getParameter(_) predicate. Note that an underscore here is a wildcard, meaning it will output all of the parameters to the function referenced in fn. Running the query results in 3 alerts. Query results in three alerts We can also encapsulate the logic of the query into a class to make it more portable. This query will give us the same results. If you need a refresher on classes and using the exists mechanism, see CodeQL zero to hero part 2. /** * @id codeql-zero-to-hero/4-3 * @severity error * @kind problem */ import python import semmle.python.ApiGraphs import semmle.python.dataflow.new.RemoteFlowSources class GradioInterface extends RemoteFlowSource::Range { GradioInterface() { exists(API::CallNode n | n = API::moduleImport(\"gradio\").getMember(\"Interface\").getACall() | this = n.getParameter(0, \"fn\").getParameter(_).asSource()) } override string getSourceType() { result = \"Gradio untrusted input\" } } from GradioInterface inp select inp, \"Gradio sources\" Note that for GradioInterface class we start with the RemoteFlowSource::Range supertype. This allows us to add the sources contained in the query to the RemoteFlowSource abstract class. An abstract class is a union of all its subclasses, for example, the GradioInterface class we just modeled as well as the sources already added to CodeQL, for example, from Flask, Django or Tornado web frameworks. An abstract class is useful if you want to group multiple existing classes together under a common name. Meaning, if we now query for all sources using the RemoteFlowSource class, the results will include the results produced from our class above. Try it! /** * @id codeql-zero-to-hero/4-4 * @severity error * @kind problem */ import python import semmle.python.ApiGraphs import semmle.python.dataflow.new.RemoteFlowSources class GradioInterface extends RemoteFlowSource::Range { GradioInterface() { exists(API::CallNode n | n = API::moduleImport(\"gradio\").getMember(\"Interface\").getACall() | this = n.getParameter(0, \"fn\").getParameter(_).asSource()) } override string getSourceType() { result = \"Gradio untrusted input\" } } from RemoteFlowSource rfs select rfs, \"All python sources\" For a refresher on RemoteFlowSource, and how to use it in a query, head to CodeQL zero to hero part 3. Note that since we modeled the new sources using the RemoteFlowSource abstract class, all Python queries that already use RemoteFlowSource will automatically use our new sources if we add them to library files, like I did in this pull request to add Gradio models. Almost all CodeQL queries use RemoteFlowSource. For example, if you run the SQL injection query, it will also include vulnerabilities that use the sources we’ve modeled. See how to run prewritten queries in CodeQL zero to hero part 3. Modeling gr.Button.click We model gr.Button.click in a very similar way. /** * @id codeql-zero-to-hero/4-5 * @severity error * @kind problem */ import python import semmle.python.ApiGraphs from API::CallNode node where node = API::moduleImport(\"gradio\").getMember(\"Button\").getReturn() .getMember(\"click\").getACall() select node.getParameter(0, \"fn\").getParameter(_), \"Gradio sources\" Note that in the code we first create a Button object with gr.Button() and then call the click() event listener on it. Due to that, we need to use API::moduleImport(\"gradio\").getMember(\"Button\").getReturn() to first get the nodes representing the result of calling gr.Button() and then we continue with .getMember(\"click\").getACall() to get all calls to gr.Button.click. Running the query results in 3 alerts. Query results in three alerts We can also encapsulate the logic of this query into a class too. /** * @id codeql-zero-to-hero/4-6 * @severity error * @kind problem */ import python import semmle.python.ApiGraphs import semmle.python.dataflow.new.RemoteFlowSources class GradioButton extends RemoteFlowSource::Range { GradioButton() { exists(API::CallNode n | n = API::moduleImport(\"gradio\").getMember(\"Button\").getReturn() .getMember(\"click\").getACall() | this = n.getParameter(0, \"fn\").getParameter(_).asSource()) } override string getSourceType() { result = \"Gradio untrusted input\" } } from GradioButton inp select inp, \"Gradio sources\" Vulnerabilities using Gradio sources We can now use our two classes as sources in a taint tracking query, to detect vulnerabilities that have a Gradio source, and, continuing with our command injection example, an os.system sink (the first argument to the os.system call is the sink). See CodeQL zero to hero part 3 to learn more about taint tracking queries. The os.system call is defined in the OsSystemSink class and the sink, that is the first argument to the os.system sink call, is defined in the isSink predicate. /** * @id codeql-zero-to-hero/4-7 * @severity error * @kind path-problem */ import python import semmle.python.dataflow.new.DataFlow import semmle.python.dataflow.new.TaintTracking import semmle.python.ApiGraphs import semmle.python.dataflow.new.RemoteFlowSources import MyFlow::PathGraph class GradioButton extends RemoteFlowSource::Range { GradioButton() { exists(API::CallNode n | n = API::moduleImport(\"gradio\").getMember(\"Button\").getReturn() .getMember(\"click\").getACall() | this = n.getParameter(0, \"fn\").getParameter(_).asSource()) } override string getSourceType() { result = \"Gradio untrusted input\" } } class GradioInterface extends RemoteFlowSource::Range { GradioInterface() { exists(API::CallNode n | n = API::moduleImport(\"gradio\").getMember(\"Interface\").getACall() | this = n.getParameter(0, \"fn\").getParameter(_).asSource()) } override string getSourceType() { result = \"Gradio untrusted input\" } } class OsSystemSink extends API::CallNode { OsSystemSink() { this = API::moduleImport(\"os\").getMember(\"system\").getACall() } } private module MyConfig implements DataFlow::ConfigSig { predicate isSource(DataFlow::Node source) { source instanceof GradioButton or source instanceof GradioInterface } predicate isSink(DataFlow::Node sink) { exists(OsSystemSink call | sink = call.getArg(0) ) } } module MyFlow = TaintTracking::Global\u003cMyConfig\u003e; from MyFlow::PathNode source, MyFlow::PathNode sink where MyFlow::flowPath(source, sink) select sink.getNode(), source, sink, \"Data Flow from a Gradio source to `os.system`\" Running the query results in 6 alerts, which show us the path from source to sink. Note that the os.system sink we used is already modeled in CodeQL, but we are using it here to illustrate the example. Query results in six alerts Similarly to the GradioInterface class, since we have already written the sources, we can actually use them (as well as the query we’ve written above) on any Python project. We just have to add them to library files, like I did in this pull request to add Gradio models. We can actually run any query on up to 1000 projects at once using a tool called Multi repository Variant Analysis (MRVA). But before that. Other sources in Gradio Based on the tests we did in the Identifying attack surface in Gradio section, we can identify other sources that behave in a similar way. For example, there’s gr.LoginButton.click, an event listener that also takes inputs and could be considered a source. I’ve modeled these cases and added them to CodeQL, which you can see in the pull request to add Gradio models. The modeling of these event listeners is very similar to what we’ve done in the previous section. Taint step We’ve mentioned that there are two ways to model gr.Interface and other Gradio sources—by identifying the values passed to inputs and then linking them to the function referenced in fn, or by looking at the parameters to the function referenced in fn directly. import gradio as gr import os def execute_cmd(folder, logs): cmd = f\"python caption.py --dir={folder} --logs={logs}\" os.system(cmd) return f\"Command: {cmd}\" folder = gr.Textbox(placeholder=\"Directory to caption\") logs = gr.Checkbox(label=\"Save verbose logs\") output = gr.Textbox() demo = gr.Interface( fn=execute_cmd, inputs=[folder, logs], outputs=output) if __name__ == \"__main__\": demo.launch(debug=True) As it turns out, machine learning applications written using Gradio often use a lot of input variables, which are later processed by the application. In this case, inputs argument gets a list of variables, which at times can be very long. I’ve found several cases which used a list with 10+ elements. In these cases, it would be nice to be able to track the source all the way to the component that introduces it— in our case, gr.Textbox and gr.Checkbox. To do that, we need to use a taint step. Taint steps are usually used in case taint analysis stops at a specific code element, and we want to make it propagate forward. In our case, however, we are going to write a taint step to track a variable in inputs, that is an element of a list, and track it back to the component. The Gradio.qll file in CodeQL upstream contains all the Gradio source models and the taint step if you’d like to see the whole modeling. We start by identifying the variables passed to inputs in, for example, gr.Interface: class GradioInputList extends RemoteFlowSource::Range { GradioInputList() { exists(GradioInput call | // limit only to lists of parameters given to `inputs`. ( ( call.getKeywordParameter(\"inputs\").asSink().asCfgNode() instanceof ListNode or call.getParameter(1).asSink().asCfgNode() instanceof ListNode ) and ( this = call.getKeywordParameter(\"inputs\").getASubscript().getAValueReachingSink() or this = call.getParameter(1).getASubscript().getAValueReachingSink() ) ) ) } override string getSourceType() { result = \"Gradio untrusted input\" } } Next, we identify the function in fn and link the elements of the list of variables in inputs to the parameters of the function referenced in fn. class ListTaintStep extends TaintTracking::AdditionalTaintStep { override predicate step(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { exists(GradioInput node, ListNode inputList | inputList = node.getParameter(1, \"inputs\").asSink().asCfgNode() | exists(int i | nodeTo = node.getParameter(0, \"fn\").getParameter(i).asSource() | nodeFrom.asCfgNode() = inputList.getElement(i)) ) } } Let’s explain the taint step, step by step. exists(GradioInput node, Listnode inputList | In the taint step, we define two temporary variables in the exists mechanism—node of type GradioInput and inputList of type ListNode. inputList = node.getParameter(1, \"inputs\").asSink().asCfgNode() | Then, we set our inputList to the value of inputs. Note that because inputList has type ListNode, we are looking only for lists. exists(int i | nodeTo = node.getParameter(0, \"fn\").getParameter(i).asSource() | nodeFrom.asCfgNode() = inputList.getElement(i)) Next, we identify the function in fn and link the parameters of the function referenced in fn to the elements of the list of variables in inputs, by using a temporary variable i. All in all, the taint step provides us with a nicer display of the paths, from the component used as a source to a potential sink. Scaling the research to thousands of repositories with MRVA CodeQL zero to hero part 3 introduced Multi-Repository Variant Analysis (MRVA) and variant analysis. Head over there if you need a refresher on the topics. In short,MRVA allows you to run a query on up to 1000 projects hosted on GitHub at once. It comes preconfigured with dynamic lists for most popular repositories 10, 100, and 1000 for each language. You can configure your own lists of repositories to run CodeQL queries on and potentially find more variants of vulnerabilities that use our new models. @maikypedia wrote a neat case study about using MRVA to find SSTI vulnerabilities in Ruby and Unsafe Deserialization vulnerabilities in Python. MRVA is used together with the VS Code CodeQL extension and can be configured in the extension, in the “Variant Analysis” section. It uses GitHub Actions to run, so you need a repository, which will be used as a controller to run these actions. You can create a public repository, in which case running the queries will be free, but in this case, you can run MRVA only on public repositories. The docs contain more information about MRVA and its setup. Using MRVA, I’ve found 11 vulnerabilities to date in several Gradio projects. Check out the vulnerability reports on GitHub Security Lab’s website. Reach out! Today, we learned how to model a new framework in CodeQL, using Gradio as an example, and how to use those models for finding vulnerabilities at scale. I hope that this post helps you with finding new cool vulnerabilities! 🔥 If CodeQL and this post helped you to find a vulnerability, we would love to hear about it! Reach out to us on GitHub Security Lab on Slack or tag us @ghsecuritylab on X. If you have any questions, issues with challenges or with writing a CodeQL query, feel free to join and ask on the GitHub Security Lab server on Slack. The Slack server is open to anyone and gives you access to ask questions about issues with CodeQL, CodeQL modeling or anything else CodeQL related, and receive answers from a number of CodeQL engineers. If you prefer to stay off Slack, feel free to ask any questions in CodeQL repository discussions or in GitHub Security Lab repository discussions. Written by Sylwia is a security researcher at GitHub Security Lab, where she works with finding vulnerabilities in open source software, helping secure the foundations on which all modern software is built upon.",
  "image": "https://github.blog/wp-content/uploads/2024/12/creative-image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eGradio is a Python web framework for demoing machine learning applications, which in the past few years has exploded in popularity. In this blog, you’ll will follow along with the process, in which I modeled (that is, added support for) Gradio framework, finding 11 vulnerabilities to date in a number of open source projects, including \u003ca href=\"https://github.com/AUTOMATIC1111/stable-diffusion-webui\"\u003eAUTOMATIC1111/stable-diffusion-webui\u003c/a\u003e—one of the most popular projects on GitHub, that was included in the \u003ca href=\"https://github.blog/2023-11-08-the-state-of-open-source-and-ai/#:~:text=Generative%20AI%20grows,to%20user%20needs.\"\u003e2023 Octoverse report\u003c/a\u003e and \u003ca href=\"https://github.blog/news-insights/octoverse/octoverse-2024/#the-state-of-generative-ai-in-2024\"\u003e2024 Octoverse report\u003c/a\u003e. Check out the vulnerabilities I’ve found on the \u003ca href=\"https://securitylab.github.com/advisories/\"\u003eGitHub Security Lab’s website\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFollowing the process outlined in this blog, you will learn how to model new frameworks and libraries in CodeQL and scale your research to find more vulnerabilities.\u003c/p\u003e\n\u003cp\u003eThis blog is written to be read standalone; however, if you are new to CodeQL or would like to dig deeper into static analysis and CodeQL, you may want to check out the previous parts of my CodeQL zero to hero blog series. Each deals with a different topic: status analysis fundamentals, writing CodeQL, and using CodeQL for security research.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://github.blog/developer-skills/github/codeql-zero-to-hero-part-1-the-fundamentals-of-static-analysis-for-vulnerability-research/\"\u003eCodeQL zero to hero part 1: The fundamentals of static analysis for vulnerability research\u003c/a\u003e \u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.blog/developer-skills/github/codeql-zero-to-hero-part-2-getting-started-with-codeql/\"\u003eCodeQL zero to hero part 2: Getting started with CodeQL\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-3-security-research-with-codeql/\"\u003eCodeQL zero to hero part 3: Security research with CodeQL\u003c/a\u003e \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eEach also has accompanying exercises, which are in the above blogs, and in the \u003ca href=\"https://github.com/GitHubSecurityLab/codeql-zero-to-hero\"\u003eCodeQL zero to hero repository\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"quick-recap\" id=\"quick-recap\"\u003eQuick recap\u003ca href=\"#quick-recap\" aria-label=\"Quick recap\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCodeQL uses data flow analysis to find vulnerabilities. It uses models of sources (for example, an HTTP GET request parameter) and sinks in libraries and frameworks that could cause a vulnerability (for example, \u003ccode\u003ecursor.execute\u003c/code\u003e from MySQLdb, which executes SQL queries), and checks if there is a data flow path between the two. If there is, and there is no sanitizer on the way, CodeQL will report a vulnerability in the form of an alert.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2024/12/data-flow-path.png?w=880\u0026amp;resize=880%2C280\" alt=\"Diagram showing a node titled ‘Sources’ and another node titled ‘Sinks’. An arrow titled ‘Data flow path’ points from ‘Sources’ to ‘Sinks’. ‘Sources’ node gives examples of sources, that is ‘untrusted input, for example HTTP GET request parameters and ‘Sinks’ node gives examples of sinks, that is ‘dangerous functions, for example cursor.execute() from MySQLdb library’.\" width=\"880\" height=\"280\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/data-flow-path.png?w=880 880w, https://github.blog/wp-content/uploads/2024/12/data-flow-path.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/data-flow-path.png?w=768 768w\" sizes=\"auto, (max-width: 880px) 100vw, 880px\"/\u003e\u003c/p\u003e\n\u003cp\u003eCheck out the first blog of the CodeQL zero to hero series to \u003ca href=\"https://github.blog/developer-skills/github/codeql-zero-to-hero-part-1-the-fundamentals-of-static-analysis-for-vulnerability-research/#vulnerability-detection-sources-and-sinks\"\u003elearn more about sources, sinks and data flow analysis\u003c/a\u003e,. See the second blog to \u003ca href=\"https://github.blog/developer-skills/github/codeql-zero-to-hero-part-2-getting-started-with-codeql/\"\u003elearn about the basics of writing CodeQL\u003c/a\u003e. Head on to the third blog of the CodeQL zero to hero series to \u003ca href=\"https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-3-security-research-with-codeql/\"\u003eimplement your own data flow analysis on certain code elements in CodeQL\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"motivation\" id=\"motivation\"\u003eMotivation\u003ca href=\"#motivation\" aria-label=\"Motivation\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCodeQL has models for the majority of most popular libraries and frameworks, and new ones are continuously being added to improve the detection of vulnerabilities.\u003c/p\u003e\n\u003cp\u003eOne such example is Gradio. We will go through the process of analyzing it and modeling it today. Looking into a new framework or a library and modeling it with CodeQL is a perfect chance to do research on the projects using that framework, and potentially find multiple vulnerabilities at once.\u003c/p\u003e\n\u003cp\u003eHat tip to my coworker, \u003ca href=\"https://github.com/pwntester\"\u003eAlvaro Munoz\u003c/a\u003e, for giving me a tip about Gradio, and for his \u003ca href=\"https://securitylab.github.com/research/apache-dubbo/\"\u003eguide on researching Apache Dubbo and writing models for it\u003c/a\u003e, which served as inspiration for my research (if you are learning CodeQL and haven’t checked it out yet, you should!).\u003c/p\u003e\n\u003ch2 id=\"research-and-codeql-modeling-process\" id=\"research-and-codeql-modeling-process\"\u003eResearch and CodeQL modeling process\u003ca href=\"#research-and-codeql-modeling-process\" aria-label=\"Research and CodeQL modeling process\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFrameworks have sources and sinks, and that’s what we are interested in identifying, and later modeling in CodeQL. A framework may also provide user input sanitizers, which we are also interested in.\u003c/p\u003e\n\u003cp\u003eThe process consisted, among others, of:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReviewing the documentation and code for sources—any entry points to the application, which take user input.\u003c/li\u003e\n\u003cli\u003eReviewing the documentation and code for sinks—any functionality that is potentially dangerous, for example, a function that executes raw SQL queries and that may take user input.\u003c/li\u003e\n\u003cli\u003eDynamically testing interesting elements.\u003c/li\u003e\n\u003cli\u003eChecking for previous security issues related to Gradio, and vulnerabilities in the applications that use Gradio.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet me preface here that it’s natural that a framework like Gradio has sources and sinks, and there’s nothing inherently wrong about it. All frameworks have sources and sinks—Django, Flask, Tornado, and so on. The point is that if the classes and functions provided by the frameworks are not used in a secure way, they may lead to vulnerabilities. And that’s what we are interested in catching here, for applications that use the Gradio framework.\u003c/p\u003e\n\u003ch2 id=\"gradio\" id=\"gradio\"\u003eGradio\u003ca href=\"#gradio\" aria-label=\"Gradio\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGradio is a Python web framework for demoing machine learning applications, which in the past few years has become increasingly popular.\u003c/p\u003e\n\u003cp\u003eGradio’s documentation is thorough and gives a lot of good examples to get started with using Gradio. We will use some of them, modifying them a little bit, where needed.\u003c/p\u003e\n\u003ch3 id=\"gradio-interface\" id=\"gradio-interface\"\u003eGradio Interface\u003ca href=\"#gradio-interface\" aria-label=\"Gradio Interface\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWe can create a simple interface in Gradio by using the \u003ccode\u003eInterface\u003c/code\u003e class.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport gradio as gr\n\ndef greet(name, intensity):\n    return \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34; * int(intensity)\n\ndemo = gr.Interface(\n    fn=greet,\n    inputs=[gr.Textbox(), gr.Slider()],\n    outputs=[gr.Textbox()])\n\ndemo.launch()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the \u003ccode\u003eInterface\u003c/code\u003e class takes three arguments:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003ccode\u003efn\u003c/code\u003e argument takes a reference to a function that contains the logic of the program. In this case, it’s the reference to the \u003ccode\u003egreet\u003c/code\u003e function.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003einputs\u003c/code\u003e argument takes a list of input components that will be used by the function passed to \u003ccode\u003efn\u003c/code\u003e. Here, \u003ccode\u003einputs\u003c/code\u003e takes the values from a \u003ccode\u003etext\u003c/code\u003e (which is equivalent to a \u003ccode\u003egr.Textbox\u003c/code\u003e component) and a \u003ccode\u003eslider\u003c/code\u003e (equivalent to a \u003ccode\u003egr.Slider\u003c/code\u003e component).\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003eoutputs\u003c/code\u003e argument specifies what will be returned by the function passed to \u003ccode\u003efn\u003c/code\u003e in the \u003ccode\u003ereturn\u003c/code\u003e statement. Here, the output will be returned as \u003ccode\u003etext\u003c/code\u003e (so, \u003ccode\u003egr.Textbox\u003c/code\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRunning the code will start an application with the following interface. We provide example inputs, “Sylwia” in the textbox and “3” in the slider, and submit them, which results in an output, “Hello, Sylwia!!!”.\u003c/p\u003e\n\u003cfigure id=\"attachment_81608\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1770\" height=\"450\" src=\"https://github.blog/wp-content/uploads/2024/12/gr-interface.png?w=1024\u0026amp;resize=1770%2C450\" alt=\"Website with an input box with the value “Sylwia”, an “intensity” slider set to “3” and an output box with the value “Hello, Sylwia!!!”\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/gr-interface.png?w=1770 1770w, https://github.blog/wp-content/uploads/2024/12/gr-interface.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/gr-interface.png?w=768 768w, https://github.blog/wp-content/uploads/2024/12/gr-interface.png?w=1024 1024w, https://github.blog/wp-content/uploads/2024/12/gr-interface.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003cfigcaption\u003eExample app written using Gradio Interface class\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch3 id=\"gradio-blocks\" id=\"gradio-blocks\"\u003eGradio Blocks\u003ca href=\"#gradio-blocks\" aria-label=\"Gradio Blocks\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAnother popular way of creating applications is by using the \u003ccode\u003egr.Blocks\u003c/code\u003e class with a number of components; for example, a dropdown list, a set of radio buttons, checkboxes, and so on. Gradio documentation describes the \u003ccode\u003eBlocks\u003c/code\u003e class in the following way:\u003c/p\u003e\n\u003cblockquote\u003e\u003cp\u003e\n  Blocks offers more flexibility and control over: (1) the layout of components (2) the events that trigger the execution of functions (3) data flows (for example, inputs can trigger outputs, which can trigger the next level of outputs).\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eWith \u003ccode\u003egr.Blocks\u003c/code\u003e, we can use certain components as event listeners, for example, a click of a given button, which will trigger execution of functions using the input components we provided to them.\u003c/p\u003e\n\u003cp\u003eIn the following code we create a number of input components: a slider, a dropdown, a checkbox group, a radio buttons group, and a checkbox. Then, we define a button, which will execute the logic of the \u003ccode\u003esentence_builder\u003c/code\u003e function on a click of the button and output the results of it as a textbox.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport gradio as gr\n\ndef sentence_builder(quantity, animal, countries, place, morning):\n    return f\u0026#34;\u0026#34;\u0026#34;The {quantity} {animal}s from {\u0026#34; and \u0026#34;.join(countries)} went to the {place} in the {\u0026#34;morning\u0026#34; if morning else \u0026#34;night\u0026#34;}\u0026#34;\u0026#34;\u0026#34;\n\nwith gr.Blocks() as demo:\n\n    gr.Markdown(\u0026#34;Choose the options and then click **Run** to see the output.\u0026#34;)\n    with gr.Row():\n        quantity = gr.Slider(2, 20, value=4, label=\u0026#34;Count\u0026#34;, info=\u0026#34;Choose between 2 and 20\u0026#34;)\n        animal = gr.Dropdown([\u0026#34;cat\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;bird\u0026#34;], label=\u0026#34;Animal\u0026#34;, info=\u0026#34;Will add more animals later!\u0026#34;)\n        countries = gr.CheckboxGroup([\u0026#34;USA\u0026#34;, \u0026#34;Japan\u0026#34;, \u0026#34;Pakistan\u0026#34;], label=\u0026#34;Countries\u0026#34;, info=\u0026#34;Where are they from?\u0026#34;)\n        place = gr.Radio([\u0026#34;park\u0026#34;, \u0026#34;zoo\u0026#34;, \u0026#34;road\u0026#34;], label=\u0026#34;Location\u0026#34;, info=\u0026#34;Where did they go?\u0026#34;)\n        morning = gr.Checkbox(label=\u0026#34;Morning\u0026#34;, info=\u0026#34;Did they do it in the morning?\u0026#34;)\n\n    btn = gr.Button(\u0026#34;Run\u0026#34;)\n    btn.click(\n        fn=sentence_builder,\n        inputs=[quantity, animal, countries, place, morning],\n        outputs=gr.Textbox(label=\u0026#34;Output\u0026#34;)\n    )\n\nif __name__ == \u0026#34;__main__\u0026#34;:\n    demo.launch(debug=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRunning the code and providing example inputs will give us the following results:\u003c/p\u003e\n\u003cfigure id=\"attachment_81609\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1752\" height=\"652\" src=\"https://github.blog/wp-content/uploads/2024/12/gr-dropdown.png?w=1024\u0026amp;resize=1752%2C652\" alt=\"Website with a slider titled “Count” set to 4, a dropdown list titled “Animal” set to “cat”, a checkbox group titled “Countries” with checked “USA” and “Japan” and unchecked “Pakistan”, a radio button titled “Locations” set to “park” and a checked checkbox with question with explanation “Did they do it in the morning?”. Below the form is a button titled “Run” and an output box with the value “The 4 cats from USA and Japan went to the park in the morning.\u0026#34;\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/gr-dropdown.png?w=1752 1752w, https://github.blog/wp-content/uploads/2024/12/gr-dropdown.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/gr-dropdown.png?w=768 768w, https://github.blog/wp-content/uploads/2024/12/gr-dropdown.png?w=1024 1024w, https://github.blog/wp-content/uploads/2024/12/gr-dropdown.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003cfigcaption\u003eExample app written using Gradio Blocks\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch2 id=\"identifying-attack-surface-in-gradio\" id=\"identifying-attack-surface-in-gradio\"\u003eIdentifying attack surface in Gradio\u003ca href=\"#identifying-attack-surface-in-gradio\" aria-label=\"Identifying attack surface in Gradio\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGiven the code examples, the next step is to identify how a Gradio application might be written in a vulnerable way, and what we could consider a source or a sink. A good point to start is to run a few code examples, use the application the way it is meant to be used, observe the traffic, and then poke at the application for any interesting areas.\u003c/p\u003e\n\u003cp\u003eThe first interesting point that stood out for me for investigation are the variables passed to the \u003ccode\u003einputs\u003c/code\u003e keyword argument in the Interface example app above, and the on \u003ccode\u003eclick\u003c/code\u003e button event handler in the Blocks example.\u003c/p\u003e\n\u003cp\u003eLet’s start by running the above Gradio Interface example app in your favorite proxy (or observing the traffic in your browser’s DevTools), and filling out the form with example values (string \u003ccode\u003e\u0026#34;Sylwia\u0026#34;\u003c/code\u003e and integer \u003ccode\u003e3\u003c/code\u003e) shows the data being sent:\u003c/p\u003e\n\u003cfigure id=\"attachment_81610\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1384\" height=\"582\" src=\"https://github.blog/wp-content/uploads/2024/12/firefox-interface.png?w=1024\u0026amp;resize=1384%2C582\" alt=\"Screenshot from Firefox DevTools showing the traffic in the Gradio Interface app. Two requests are visible, and one of them is selected, showing data being sent in a form of JSON.\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/firefox-interface.png?w=1384 1384w, https://github.blog/wp-content/uploads/2024/12/firefox-interface.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/firefox-interface.png?w=768 768w, https://github.blog/wp-content/uploads/2024/12/firefox-interface.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003cfigcaption\u003eTraffic in the Gradio Interface example app, observed in Firefox DevTools\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eThe values we set are sent as a string \u003ccode\u003e“Sylwia”\u003c/code\u003e and an integer \u003ccode\u003e3\u003c/code\u003e in a JSON, in the value of the “data” key. Here are the values as seen in Burp Suite:\u003c/p\u003e\n\u003cfigure id=\"attachment_81611\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"560\" height=\"346\" src=\"https://github.blog/wp-content/uploads/2024/12/interface-test-1.png?w=300\u0026amp;resize=560%2C346\" alt=\"Screenshot showing request with data in a form of a JSON. The “data” key takes a list with two values: “Sylwia”, 3. ’\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/interface-test-1.png?w=560 560w, https://github.blog/wp-content/uploads/2024/12/interface-test-1.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/interface-test-1.png?w=288 288w\" sizes=\"auto, (max-width: 560px) 100vw, 560px\"/\u003e\u003cfigcaption\u003eJSON in the request to the example Interface application\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eThe text box naturally allows for setting any string value we would like, and that data will later be processed by the application as a string. What if I try to set it to something else than a string, for example, an integer \u003ccode\u003e1000\u003c/code\u003e?\u003c/p\u003e\n\u003cfigure id=\"attachment_81612\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"568\" height=\"348\" src=\"https://github.blog/wp-content/uploads/2024/12/interface-test-2.png?w=300\u0026amp;resize=568%2C348\" alt=\"Screenshot showing request with data in a form of a JSON. The “data” key takes a list with two values: 1000, 3. \" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/interface-test-2.png?w=568 568w, https://github.blog/wp-content/uploads/2024/12/interface-test-2.png?w=300 300w\" sizes=\"auto, (max-width: 568px) 100vw, 568px\"/\u003e\u003cfigcaption\u003eTesting setting the textbox value to an integer\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eTurns out that’s allowed. What about a slider? You might expect that we can only set the values that are restricted in the code (so, here these should be integer values from 2 to 20). Could we send something else, for example, a string \u003ccode\u003e\u0026#34;high”\u003c/code\u003e?\u003c/p\u003e\n\u003cfigure id=\"attachment_81613\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"572\" height=\"358\" src=\"https://github.blog/wp-content/uploads/2024/12/interface-test-3.png?w=300\u0026amp;resize=572%2C358\" alt=\"Screenshot showing request with data in a form of a JSON. The “data” key takes a list with two values: 1000, “high”. \" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/interface-test-3.png?w=572 572w, https://github.blog/wp-content/uploads/2024/12/interface-test-3.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/interface-test-3.png?w=288 288w\" sizes=\"auto, (max-width: 572px) 100vw, 572px\"/\u003e\u003cfigcaption\u003eTesting setting the slider value to a string\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eWe see an error:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFile \u0026#34;/**/**/**/example.py\u0026#34;, line 4, in greet\n    return \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34; * int(intensity)\n                                    ^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: \u0026#39;high\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat’s very interesting. 🤔\u003c/p\u003e\n\u003cp\u003eThe error didn’t come up from us setting a string value on a slider (which should only allow integer values from 2 to 20), but from the \u003ccode\u003eint\u003c/code\u003e function, which converts a value to an integer in Python. Meaning, until that point, the value from the slider can be set to anything, and can be used in any dangerous functions (sinks) or otherwise sensitive functionality. All in all, perfect candidate for sources.\u003c/p\u003e\n\u003cp\u003eWe can do a similar check with a more complex example with \u003ccode\u003egr.Blocks\u003c/code\u003e. We run the example code from the previous section and observe our data being sent:\u003c/p\u003e\n\u003cfigure id=\"attachment_81614\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"560\" height=\"550\" src=\"https://github.blog/wp-content/uploads/2024/12/blocks-test-1.png?w=300\u0026amp;resize=560%2C550\" alt=\"Screenshot showing request with data in a form of a JSON. The “data” key takes a list with two values: 4,\u0026#34;cat\u0026#34;,[\u0026#34;USA\u0026#34;,\u0026#34;Japan\u0026#34;],\u0026#34;park\u0026#34;,true’\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/blocks-test-1.png?w=560 560w, https://github.blog/wp-content/uploads/2024/12/blocks-test-1.png?w=300 300w\" sizes=\"auto, (max-width: 560px) 100vw, 560px\"/\u003e\u003cfigcaption\u003eObserved values in the request\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eThe values sent correspond to values given in the \u003ccode\u003einputs\u003c/code\u003e list, which comes from the components:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003eSlider\u003c/code\u003e with values from 2 to 20. \u003c/li\u003e\n\u003cli\u003eA \u003ccode\u003eDropdown\u003c/code\u003e with values: “cat”, “dog”, “bird”. \u003c/li\u003e\n\u003cli\u003eA\u003ccode\u003eCheckboxGroup\u003c/code\u003e with values: “USA”, “Japan”, “Pakistan”. \u003c/li\u003e\n\u003cli\u003eA \u003ccode\u003eRadio\u003c/code\u003e with values: “park”, “zoo”, “road”.\u003c/li\u003e\n\u003cli\u003eA \u003ccode\u003eCheckbox\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThen, we test what we can send to the application. We pass values that are not expected for the given components:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003eSlider\u003c/code\u003e—a string \u003ccode\u003e\u0026#34;a thousand\u0026#34;\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003ccode\u003eDropdown\u003c/code\u003e – a string \u003ccode\u003e\u0026#34;turtle\u0026#34;\u003c/code\u003e, which is not one of the dropdown options.\u003c/li\u003e\n\u003cli\u003eA \u003ccode\u003eCheckboxGroup\u003c/code\u003e—a list with \u003ccode\u003e[\u0026#34;USA\u0026#34;,\u0026#34;Japan\u0026#34;, \u0026#34;Poland\u0026#34;]\u003c/code\u003e, of which \u003ccode\u003e\u0026#34;Poland\u0026#34;\u003c/code\u003e is not one of the options.\u003c/li\u003e\n\u003cli\u003eA \u003ccode\u003eRadio\u003c/code\u003e—a list \u003ccode\u003e[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;]\u003c/code\u003e. \u003ccode\u003eRadio\u003c/code\u003e is supposed to allow only one value, and not a list.\u003c/li\u003e\n\u003cli\u003eA \u003ccode\u003eCheckbox\u003c/code\u003e—an integer \u003ccode\u003e123\u003c/code\u003e. Checkbox is supposed to take only \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure id=\"attachment_81615\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"382\" height=\"490\" src=\"https://github.blog/wp-content/uploads/2024/12/blocks-test-2.png?w=234\u0026amp;resize=382%2C490\" alt=\"Screenshot showing request with data in the form of a JSON. The “data” key takes a list with two values: \u0026#34;a thousand\u0026#34;,\u0026#34;turtle\u0026#34;,[\u0026#34;USA\u0026#34;,\u0026#34;Japan\u0026#34;, \u0026#34;Poland\u0026#34;],[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;],123’\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/blocks-test-2.png?w=382 382w, https://github.blog/wp-content/uploads/2024/12/blocks-test-2.png?w=234 234w\" sizes=\"auto, (max-width: 382px) 100vw, 382px\"/\u003e\u003cfigcaption\u003eObserved values in the request\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eNo issues reported—we can set the source values to anything no matter which component they come from. That makes them perfect candidates for modeling as sources and later doing research at scale.\u003c/p\u003e\n\u003cp\u003eExcept.\u003c/p\u003e\n\u003ch3 id=\"echo-of-sources-past-gr-dropdown-example\" id=\"echo-of-sources-past-gr-dropdown-example\"\u003eEcho of sources past: \u003ccode\u003egr.Dropdown\u003c/code\u003e example\u003ca href=\"#echo-of-sources-past-gr-dropdown-example\" aria-label=\"Echo of sources past: \u0026lt;code\u0026gt;gr.Dropdown\u0026lt;/code\u0026gt; example\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eNot long after I had a look at Gradio version 4.x.x and wrote models for its sources, the Gradio team asked Trail of Bits (ToB) to conduct a security audit of the framework, which resulted in \u003ca href=\"https://github.com/ahpaleus\"\u003eMaciej Domański\u003c/a\u003e and \u003ca href=\"https://github.com/Vasco-jofra\"\u003eVasco Franco\u003c/a\u003e‬ creating a \u003ca href=\"https://github.com/trailofbits/publications/blob/master/reviews/2024-10-huggingface-gradio-securityreview.pdf\"\u003ereport on Gradio’s security\u003c/a\u003e with a lot of cool findings. The fixes for the issues reported were incorporated into \u003ca href=\"https://huggingface.co/blog/gradio-5\"\u003eGradio 5.0\u003c/a\u003e, which was released on October 9, 2024. One of the issues that ToB’s team reported was TOB-GRADIO-15: \u003cem\u003eDropdown component pre-process step does not limit the values to those‬‭ in the dropdown list‬.\u003c/em\u003e\u003c/p\u003e\n\u003cfigure id=\"attachment_81616\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"864\" height=\"400\" src=\"https://github.blog/wp-content/uploads/2024/12/tob-15.png?w=864\u0026amp;resize=864%2C400\" alt=\"Screenshot from Trail of Bits’ Gradio audit showing finding number 15: Dropdown component pre-process step does not limit the values to those‬‭ in the dropdown list’ with severity set to low and difficulty set to low. The descriptions says, ‬\n‭ The‬‭ Dropdown‬‭ component allows a user to set arbitrary values, even when the‬‭ allow_custom_value‬‭ parameter is set to‬‭ False‬‭.\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/tob-15.png?w=864 864w, https://github.blog/wp-content/uploads/2024/12/tob-15.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/tob-15.png?w=768 768w\" sizes=\"auto, (max-width: 864px) 100vw, 864px\"/\u003e\u003cfigcaption\u003eTOB-GRADIO-15 from Trail of Bits’ Gradio review.\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eThe issue was subsequently fixed in Gradio 5.0 and so, submitting values that are not valid choices in \u003ccode\u003egr.Dropdown\u003c/code\u003e, \u003ccode\u003egr.Radio\u003c/code\u003e, and \u003ccode\u003egr.CheckboxGroup\u003c/code\u003e results in an error, namely:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egradio.exceptions.Error: \u0026#34;Value: turtle is not in the list of choices: [\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;bird\u0026#39;]\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this case, the vulnerabilities which may result from these sources, may not be exploitable in Gradio version 5.0 and later. There were also a number of other changes regarding security to the Gradio framework in version 5.0, which can be explored in \u003ca href=\"https://github.com/trailofbits/publications/blob/master/reviews/2024-10-huggingface-gradio-securityreview.pdf\"\u003ethe ToB report on Gradio security\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe change made me ponder whether to update the CodeQL models I have written and added to CodeQL. However, since the sources can still be misused in applications running Gradio versions below 5.0, I decided to leave them as they are.\u003c/p\u003e\n\u003ch2 id=\"modeling-gradio-with-codeql\" id=\"modeling-gradio-with-codeql\"\u003eModeling Gradio with CodeQL\u003ca href=\"#modeling-gradio-with-codeql\" aria-label=\"Modeling Gradio with CodeQL\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe have now identified a number of potential sources. We can then write CodeQL models for them, and later use these sources with existing sinks to find vulnerabilities in Gradio applications at scale. But let’s go back to the beginning: how do we model these Gradio sources with CodeQL?\u003c/p\u003e\n\u003ch3 id=\"preparing-example-codeql-database-for-testing\" id=\"preparing-example-codeql-database-for-testing\"\u003ePreparing example CodeQL database for testing\u003ca href=\"#preparing-example-codeql-database-for-testing\" aria-label=\"Preparing example CodeQL database for testing\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eRecall that to run CodeQL queries, we first need to create a CodeQL database from the source code that we are interested in. Then, we can run our CodeQL queries on that database to find vulnerabilities in the code.\u003c/p\u003e\n\u003cfigure id=\"attachment_81617\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"991\" height=\"509\" src=\"https://github.blog/wp-content/uploads/2024/12/how-codeql-works.png?w=991\u0026amp;resize=991%2C509\" alt=\"A diagram titled “How CodeQL works”. The diagram starts from the left with a picture of example source code and an arrow going to the right and pointing to an icon of a database, titled “CodeQL database”. Another arrow goes through the “CodeQL database”. On its beginning it says “CodeQL queries”’ and on its end - “Vulnzzz”’\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/how-codeql-works.png?w=991 991w, https://github.blog/wp-content/uploads/2024/12/how-codeql-works.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/how-codeql-works.png?w=768 768w\" sizes=\"auto, (max-width: 991px) 100vw, 991px\"/\u003e\u003cfigcaption\u003eHow CodeQL works – create a CodeQL database, and run queries on that database\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eWe start with intentionally vulnerable source code using \u003ccode\u003egr.Interface\u003c/code\u003e that we want to use as our test case for finding Gradio sources. The code is vulnerable to command injection via both \u003ccode\u003efolder\u003c/code\u003e and \u003ccode\u003elogs\u003c/code\u003e arguments, which end in the first argument to an \u003ccode\u003eos.system\u003c/code\u003e call.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport gradio as gr\nimport os\n\ndef execute_cmd(folder, logs):\n    cmd = f\u0026#34;python caption.py --dir={folder} --logs={logs}\u0026#34;\n    os.system(cmd)\n\n\nfolder = gr.Textbox(placeholder=\u0026#34;Directory to caption\u0026#34;)\nlogs = gr.Checkbox(label=\u0026#34;Add verbose logs\u0026#34;)\n\ndemo = gr.Interface(fn=execute_cmd, inputs=[folder, logs])\n\nif __name__ == \u0026#34;__main__\u0026#34;:\n    demo.launch(debug=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s create another example using \u003ccode\u003egr.Blocks\u003c/code\u003e and \u003ccode\u003egr.Button.click\u003c/code\u003e to mimic our earlier examples. Similarly, the code is vulnerable to command injection via both \u003ccode\u003efolder\u003c/code\u003e and \u003ccode\u003elogs\u003c/code\u003e arguments. The code is a  \u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-019_GHSL-2024-024_kohya_ss/\"\u003esimplified version of a vulnerability I found\u003c/a\u003e in an open source project.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport gradio as gr\nimport os\n\ndef execute_cmd(folder, logs):\n    cmd = f\u0026#34;python caption.py --dir={folder} --logs={logs}\u0026#34;\n    os.system(cmd)\n\n\nwith gr.Blocks() as demo:\n    gr.Markdown(\u0026#34;Create caption files for images in a directory\u0026#34;)\n    with gr.Row():\n        folder = gr.Textbox(placeholder=\u0026#34;Directory to caption\u0026#34;)\n        logs = gr.Checkbox(label=\u0026#34;Add verbose logs\u0026#34;)\n\n    btn = gr.Button(\u0026#34;Run\u0026#34;)\n    btn.click(fn=execute_cmd, inputs=[folder, logs])\n\n\nif __name__ == \u0026#34;__main__\u0026#34;:\n    demo.launch(debug=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI also added two more code snippets which use positional arguments instead of keyword arguments. The database and the code snippets are available in the \u003ca href=\"https://github.com/GitHubSecurityLab/codeql-zero-to-hero\"\u003eCodeQL zero to hero repository\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eNow that we have the code, we can create a CodeQL database for it by using the \u003ca href=\"https://github.com/github/gh-codeql\"\u003eCodeQL CLI\u003c/a\u003e. It can be installed either as an extension to the \u003ccode\u003egh\u003c/code\u003e tool (recommended) or as a \u003ca href=\"https://docs.github.com/code-security/codeql-cli/getting-started-with-the-codeql-cli/setting-up-the-codeql-cli\"\u003ebinary\u003c/a\u003e. Using the \u003ccode\u003egh\u003c/code\u003e tool with the CodeQL CLI makes it much easier to update CodeQL.\u003c/p\u003e\n\u003cdetails\u003e\n\u003csummary\u003e\u003cstrong\u003eCodeQL CLI installation instructions\u003c/strong\u003e\u003c/summary\u003e\n\u003col\u003e\n\u003cli\u003eInstall GitHub’s command line tool, \u003ccode\u003egh\u003c/code\u003e, using the \u003ca href=\"https://cli.github.com/\"\u003einstallation instructions\u003c/a\u003e for your system.\u003c/li\u003e\n\u003cli\u003eInstall CodeQL CLI:\n\u003cpre\u003e\u003ccode\u003egh extensions install github/gh-codeql\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e(optional, but recommended) To use the CodeQL CLI directly in the terminal (without having to type \u003ccode\u003egh\u003c/code\u003e), run:\n\u003cpre\u003e\u003ccode\u003egh codeql install-stub\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003eMake sure to regularly update the CodeQL CLI with:\n\u003cpre\u003e\u003ccode\u003ecodeql set-version latest\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/details\u003e\n\u003cp\u003eAfter installing CodeQL CLI, we can create a CodeQL database. First, we move to the folder, where all our source code is located. Then, to create a CodeQL database called \u003ccode\u003egradio-cmdi-db\u003c/code\u003e for the Python code in the folder \u003ccode\u003egradio-tests\u003c/code\u003e, run:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecodeql database create gradio-cmdi-db --language=python --source-root=\u0026#39;./gradio-tests\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis command creates a new folder \u003ccode\u003egradio-cmdi-db\u003c/code\u003e with the extracted source code elements. We will use this database to test and run CodeQL queries on.\u003c/p\u003e\n\u003cp\u003eI assume here you already have the VS Code CodeQL starter workspace set up. If not, follow the \u003ca href=\"https://github.com/github/vscode-codeql-starter\"\u003einstructions to create a starter workspace\u003c/a\u003e and come back when you are finished.\u003c/p\u003e\n\u003cp\u003eTo run queries on the database we created, we need to add it to the VS Code CodeQL extension. We can do it with the “Choose Database from Folder” button and pointing it to the \u003ccode\u003egradio-cmdi-db\u003c/code\u003e folder.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2024/12/select-database.png?w=426\u0026amp;resize=426%2C142\" alt=\"A screenshot from the VS Code CodeQL extension showing the “Databases” section and highlighted “Choose Database from Folder” button\" width=\"426\" height=\"142\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/select-database.png?w=426 426w, https://github.blog/wp-content/uploads/2024/12/select-database.png?w=300 300w\" sizes=\"auto, (max-width: 426px) 100vw, 426px\"/\u003e\u003c/p\u003e\n\u003cp\u003eNow that we are all set up, we can move on to actual CodeQL modeling.\u003c/p\u003e\n\u003ch3 id=\"identifying-code-elements-to-query-for\" id=\"identifying-code-elements-to-query-for\"\u003eIdentifying code elements to query for\u003ca href=\"#identifying-code-elements-to-query-for\" aria-label=\"Identifying code elements to query for\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLet’s have another look at our intentionally vulnerable code.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport gradio as gr\nimport os\n\ndef execute_cmd(folder, logs):\n    cmd = f\u0026#34;python caption.py --dir={folder} --logs={logs}\u0026#34;\n    os.system(cmd)\n    return f\u0026#34;Command: {cmd}\u0026#34;\n\n\nfolder = gr.Textbox(placeholder=\u0026#34;Directory to caption\u0026#34;)\nlogs = gr.Checkbox(label=\u0026#34;Save verbose logs\u0026#34;)\noutput = gr.Textbox()\n\ndemo = gr.Interface(\n    fn=execute_cmd,\n    inputs=[folder, logs],\n    outputs=output)\n\nif __name__ == \u0026#34;__main__\u0026#34;:\n    demo.launch(debug=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the first example with the \u003ccode\u003eInterface\u003c/code\u003e class, we had several components on the website. In fact, on the left side we have one source component which takes user input – a textbox. On the right side, we have an output text component. So, it’s not enough that a component is, for example, of a \u003ccode\u003egr.Textbox()\u003c/code\u003e type to be considered a source.\u003c/p\u003e\n\u003cp\u003eTo be considered a source of an untrusted input, a component has to be passed to the \u003ccode\u003einputs\u003c/code\u003e keyword argument, which takes an input component or a list of input components that will be used by the function passed to \u003ccode\u003efn\u003c/code\u003e and processed by the logic of the application in a potentially vulnerable way. So, not all components are sources. In our case, any values passed to \u003ccode\u003einputs\u003c/code\u003e in the \u003ccode\u003egr.Interface\u003c/code\u003e class are sources. We could go a step further, and say that if \u003ccode\u003egr.Interface\u003c/code\u003e is used, then anything passed to the \u003ccode\u003eexecute_cmd\u003c/code\u003e function is a source – so here the \u003ccode\u003efolder\u003c/code\u003e and \u003ccode\u003elogs\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe same situation happens in the second example with the \u003ccode\u003egr.Blocks\u003c/code\u003e class and the \u003ccode\u003egr.Button.click\u003c/code\u003e event listener. Any arguments passed to \u003ccode\u003einputs\u003c/code\u003e in the \u003ccode\u003eButton.onlick\u003c/code\u003e method, so, to the \u003ccode\u003eexecute_cmd\u003c/code\u003e function, are sources.\u003c/p\u003e\n\u003ch3 id=\"modeling-gr-interface\" id=\"modeling-gr-interface\"\u003eModeling \u003ccode\u003egr.Interface\u003c/code\u003e\u003ca href=\"#modeling-gr-interface\" aria-label=\"Modeling \u0026lt;code\u0026gt;gr.Interface\u0026lt;/code\u0026gt;\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLet’s start by looking at the \u003ccode\u003egr.Interface\u003c/code\u003e class.\u003c/p\u003e\n\u003cp\u003eSince we are interested in identifying any values passed to \u003ccode\u003einputs\u003c/code\u003e in the \u003ccode\u003egr.Interface\u003c/code\u003e class, we first need to identify any \u003cem\u003ecalls\u003c/em\u003e to \u003ccode\u003egr.Interface\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eCodeQL for Python has a library for finding reference classes and functions defined in library code called ApiGraphs, which we can use to identify any \u003cem\u003ecalls\u003c/em\u003e to \u003ccode\u003egr.Interface\u003c/code\u003e. See \u003ca href=\"https://github.blog/developer-skills/github/codeql-zero-to-hero-part-2-getting-started-with-codeql/#ql-query-language-writing-your-own-codeql-query\"\u003eCodeQL zero to hero part 2\u003c/a\u003e for a refresher on writing CodeQL and \u003ca href=\"https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-3-security-research-with-codeql/#querying-for-specific-library-methods\"\u003eCodeQL zero to hero part 3\u003c/a\u003e for a refresher on using ApiGraphs.\u003c/p\u003e\n\u003cp\u003eWe can get all references to \u003ccode\u003egr.Interface\u003c/code\u003e calls with the following query. Note that:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe set the query to be \u003ccode\u003e@kind problem\u003c/code\u003e, which will format the results of the \u003ccode\u003eselect\u003c/code\u003e as an alert.\u003c/li\u003e\n\u003cli\u003eIn \u003ccode\u003efrom\u003c/code\u003e, we define a \u003ccode\u003enode\u003c/code\u003e variable of the \u003ccode\u003eAPI::CallNode\u003c/code\u003e type, which gives us the set of all \u003ccode\u003eAPI::CallNode\u003c/code\u003es in the program. \u003c/li\u003e\n\u003cli\u003eIn \u003ccode\u003ewhere\u003c/code\u003e, we filter the \u003ccode\u003enode\u003c/code\u003e to be a \u003ccode\u003egr.Interface\u003c/code\u003e call.\u003c/li\u003e\n\u003cli\u003eIn \u003ccode\u003eselect\u003c/code\u003e, we choose our output to be \u003ccode\u003enode\u003c/code\u003e and string “Call to gr.Interface”, which will be formatted as an alert due to setting \u003ccode\u003e@kind problem\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003e/**\n * @id codeql-zero-to-hero/4-1\n * @severity error\n * @kind problem\n */\n\nimport python\nimport semmle.python.ApiGraphs\n\nfrom API::CallNode node\nwhere node =\n    API::moduleImport(\u0026#34;gradio\u0026#34;).getMember(\u0026#34;Interface\u0026#34;).getACall()\nselect node, \u0026#34;Call to gr.Interface\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRun the query by right-clicking and selecting “CodeQL: Run Query on Selected Database”. If you are using the same CodeQL database, you should see two results, which proves that the query is working as expected (recall that I added more code snippets to the test database. The database and the code snippets are available in the \u003ca href=\"https://github.com/GitHubSecurityLab/codeql-zero-to-hero\"\u003eCodeQL zero to hero repository\u003c/a\u003e).\u003c/p\u003e\n\u003cfigure id=\"attachment_81624\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1966\" height=\"644\" src=\"https://github.blog/wp-content/uploads/2024/12/interface-vuln-alert-1.png?w=1024\u0026amp;resize=1966%2C644\" alt=\"creenshot from the VS Code CodeQL extension showing two alerts in files “cmdi-interface-list.py” and in “cmdi-interface.py”. The first one is highlighted and shows a the “cmdi-interface-list.py” file open on the right side. In the file, the code line “demo = gr.Interface(fn=execute_cmd, inputs=[folder, logs], outputs=output)” is highlighted.\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/interface-vuln-alert-1.png?w=1966 1966w, https://github.blog/wp-content/uploads/2024/12/interface-vuln-alert-1.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/interface-vuln-alert-1.png?w=768 768w, https://github.blog/wp-content/uploads/2024/12/interface-vuln-alert-1.png?w=1024 1024w, https://github.blog/wp-content/uploads/2024/12/interface-vuln-alert-1.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003cfigcaption\u003eQuery results in two alerts\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eNext, we want to identify values passed to \u003ccode\u003einputs\u003c/code\u003e in the \u003ccode\u003egr.Interface\u003c/code\u003e class, which are passed to the \u003ccode\u003eexecute_cmd\u003c/code\u003e function. We could do it in two ways—by identifying the values passed to \u003ccode\u003einputs\u003c/code\u003e and then linking them to the function referenced in \u003ccode\u003efn\u003c/code\u003e, or by looking at the parameters to the function referenced in \u003ccode\u003efn\u003c/code\u003e directly. The latter is a bit easier, so let’s focus on that solution. If you’d be interested in the second solution, check out the \u003ca href=\"#taint-step\"\u003eTaint step section\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eTo sum up, we are interested in getting the \u003ccode\u003efolder\u003c/code\u003e and \u003ccode\u003elogs\u003c/code\u003e parameters.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport gradio as gr\nimport os\n\ndef execute_cmd(folder, logs):\n    cmd = f\u0026#34;python caption.py --dir={folder} --logs={logs}\u0026#34;\n    os.system(cmd)\n    return f\u0026#34;Command: {cmd}\u0026#34;\n\n\nfolder = gr.Textbox(placeholder=\u0026#34;Directory to caption\u0026#34;)\nlogs = gr.Checkbox(label=\u0026#34;Save verbose logs\u0026#34;)\noutput = gr.Textbox()\n\ndemo = gr.Interface(\n    fn=execute_cmd,\n    inputs=[folder, logs],\n    outputs=output)\n\nif __name__ == \u0026#34;__main__\u0026#34;:\n    demo.launch(debug=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can get \u003ccode\u003efolder\u003c/code\u003e and \u003ccode\u003elogs\u003c/code\u003e with the query below:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/**\n * @id codeql-zero-to-hero/4-2\n * @severity error\n * @kind problem\n */\n\n import python\n import semmle.python.ApiGraphs\n\n from API::CallNode node\n where node =\n     API::moduleImport(\u0026#34;gradio\u0026#34;).getMember(\u0026#34;Interface\u0026#34;).getACall()\n\n select node.getParameter(0, \u0026#34;fn\u0026#34;).getParameter(_), \u0026#34;Gradio sources\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo get the first the function reference in \u003ccode\u003efn\u003c/code\u003e (or in the 1st positional argument) we use the \u003ccode\u003egetParameter(0, \u0026#34;fn\u0026#34;)\u003c/code\u003e predicate – \u003ccode\u003e0\u003c/code\u003e refers to the 1st positional argument and \u003ccode\u003e\u0026#34;fn\u0026#34;\u003c/code\u003e refers to the \u003ccode\u003efn\u003c/code\u003e keyword argument. Then, to get the parameters themselves, we use the \u003ccode\u003egetParameter(_)\u003c/code\u003e predicate. Note that an underscore here is a wildcard, meaning it will output all of the parameters to the function referenced in \u003ccode\u003efn\u003c/code\u003e. Running the query results in 3 alerts.\u003c/p\u003e\n\u003cfigure id=\"attachment_81625\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1960\" height=\"636\" src=\"https://github.blog/wp-content/uploads/2024/12/interface-alert-vuln-2.png?w=1024\u0026amp;resize=1960%2C636\" alt=\"Screenshot from the VS Code CodeQL extension showing three alerts, two in file “cmdi-interface-list.py” and one in “cmdi-interface.py”. The first one is highlighted and shows the “cmdi-interface-list.py” file open on the right side. In the file, the “folder” parameter to “execute_cmd” function is highlighted.\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/interface-alert-vuln-2.png?w=1960 1960w, https://github.blog/wp-content/uploads/2024/12/interface-alert-vuln-2.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/interface-alert-vuln-2.png?w=768 768w, https://github.blog/wp-content/uploads/2024/12/interface-alert-vuln-2.png?w=1024 1024w, https://github.blog/wp-content/uploads/2024/12/interface-alert-vuln-2.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003cfigcaption\u003eQuery results in three alerts\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eWe can also encapsulate the logic of the query into a class to make it more portable. This query will give us the same results. If you need a refresher on classes and using the \u003ccode\u003eexists\u003c/code\u003e mechanism, see \u003ca href=\"https://github.blog/developer-skills/github/codeql-zero-to-hero-part-2-getting-started-with-codeql/#classes\"\u003eCodeQL zero to hero part 2\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/**\n * @id codeql-zero-to-hero/4-3\n * @severity error\n * @kind problem\n */\n\n import python\n import semmle.python.ApiGraphs\n import semmle.python.dataflow.new.RemoteFlowSources\n\n class GradioInterface extends RemoteFlowSource::Range {\n    GradioInterface() {\n        exists(API::CallNode n |\n        n = API::moduleImport(\u0026#34;gradio\u0026#34;).getMember(\u0026#34;Interface\u0026#34;).getACall() |\n        this = n.getParameter(0, \u0026#34;fn\u0026#34;).getParameter(_).asSource())\n    }\n    override string getSourceType() { result = \u0026#34;Gradio untrusted input\u0026#34; }\n\n }\n\nfrom GradioInterface inp\nselect inp, \u0026#34;Gradio sources\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that for \u003ccode\u003eGradioInterface\u003c/code\u003e class we start with the \u003ccode\u003eRemoteFlowSource::Range\u003c/code\u003e supertype. This allows us to add the sources contained in the query to the \u003ccode\u003eRemoteFlowSource\u003c/code\u003e abstract class.\u003c/p\u003e\n\u003cp\u003eAn \u003ca href=\"https://codeql.github.com/docs/ql-language-reference/types/\"\u003eabstract class\u003c/a\u003e is a union of all its subclasses, for example, the \u003ccode\u003eGradioInterface\u003c/code\u003e class we just modeled as well as the sources already added to CodeQL, for example, from Flask, Django or Tornado web frameworks. An abstract class is useful if you want to group multiple existing classes together under a common name.\u003c/p\u003e\n\u003cp\u003eMeaning, if we now query for all sources using the \u003ccode\u003eRemoteFlowSource\u003c/code\u003e class, the results will include the results produced from our class above. Try it!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/**\n * @id codeql-zero-to-hero/4-4\n * @severity error\n * @kind problem\n */\n\n import python\n import semmle.python.ApiGraphs\n import semmle.python.dataflow.new.RemoteFlowSources\n\nclass GradioInterface extends RemoteFlowSource::Range {\n    GradioInterface() {\n        exists(API::CallNode n |\n        n = API::moduleImport(\u0026#34;gradio\u0026#34;).getMember(\u0026#34;Interface\u0026#34;).getACall() |\n        this = n.getParameter(0, \u0026#34;fn\u0026#34;).getParameter(_).asSource())\n    }\n    override string getSourceType() { result = \u0026#34;Gradio untrusted input\u0026#34; }\n\n }\n\n\nfrom RemoteFlowSource rfs\nselect rfs, \u0026#34;All python sources\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor a refresher on \u003ccode\u003eRemoteFlowSource\u003c/code\u003e, and how to use it in a query, head to \u003ca href=\"https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-3-security-research-with-codeql/#find-all-sources-with-the-remoteflowsource-type\"\u003eCodeQL zero to hero part 3\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eNote that since we modeled the new sources using the \u003ccode\u003eRemoteFlowSource\u003c/code\u003e abstract class, all Python queries that already use \u003ccode\u003eRemoteFlowSource\u003c/code\u003e will automatically use our new sources if we add them to library files, like I did in this \u003ca href=\"https://github.com/github/codeql/pull/16135/files\"\u003epull request to add Gradio models\u003c/a\u003e. Almost all CodeQL queries use \u003ccode\u003eRemoteFlowSource\u003c/code\u003e. For example, if you run the \u003ca href=\"https://github.com/github/codeql/blob/main/python/ql/src/Security/CWE-089/SqlInjection.ql\"\u003eSQL injection query\u003c/a\u003e, it will also include vulnerabilities that use the sources we’ve modeled. See how to run prewritten queries in \u003ca href=\"https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-3-security-research-with-codeql/#run-specific-queries-or-parts-of-queries\"\u003eCodeQL zero to hero part 3\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"modeling-gr-button-click\" id=\"modeling-gr-button-click\"\u003eModeling \u003ccode\u003egr.Button.click\u003c/code\u003e\u003ca href=\"#modeling-gr-button-click\" aria-label=\"Modeling \u0026lt;code\u0026gt;gr.Button.click\u0026lt;/code\u0026gt;\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWe model \u003ccode\u003egr.Button.click\u003c/code\u003e in a very similar way.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/**\n * @id codeql-zero-to-hero/4-5\n * @severity error\n * @kind problem\n */\n\n import python\n import semmle.python.ApiGraphs\n\n from API::CallNode node\n where node =\n     API::moduleImport(\u0026#34;gradio\u0026#34;).getMember(\u0026#34;Button\u0026#34;).getReturn()\n     .getMember(\u0026#34;click\u0026#34;).getACall()\n\nselect node.getParameter(0, \u0026#34;fn\u0026#34;).getParameter(_), \u0026#34;Gradio sources\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that in the code we first create a Button object with \u003ccode\u003egr.Button()\u003c/code\u003e and then call the \u003ccode\u003eclick()\u003c/code\u003e event listener on it. Due to that, we need to use \u003ccode\u003eAPI::moduleImport(\u0026#34;gradio\u0026#34;).getMember(\u0026#34;Button\u0026#34;).getReturn()\u003c/code\u003e to first get the nodes representing the result of calling \u003ccode\u003egr.Button()\u003c/code\u003e and then we continue with \u003ccode\u003e.getMember(\u0026#34;click\u0026#34;).getACall()\u003c/code\u003e to get all calls to \u003ccode\u003egr.Button.click\u003c/code\u003e. Running the query results in 3 alerts.\u003c/p\u003e\n\u003cfigure id=\"attachment_81626\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1966\" height=\"786\" src=\"https://github.blog/wp-content/uploads/2024/12/button-alert-1.png?w=1024\u0026amp;resize=1966%2C786\" alt=\"Screenshot from the VS Code CodeQL extension showing three alerts, two in file “cmdi-list.py” and one in “cmdi.py”. The first one is highlighted and shows the “cmdi-list.py” file open on the right side. In the file, the “folder” parameter to “execute_cmd” function is highlighted.\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/button-alert-1.png?w=1966 1966w, https://github.blog/wp-content/uploads/2024/12/button-alert-1.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/button-alert-1.png?w=768 768w, https://github.blog/wp-content/uploads/2024/12/button-alert-1.png?w=1024 1024w, https://github.blog/wp-content/uploads/2024/12/button-alert-1.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003cfigcaption\u003eQuery results in three alerts\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eWe can also encapsulate the logic of this query into a class too.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/**\n * @id codeql-zero-to-hero/4-6\n * @severity error\n * @kind problem\n */\n\n\n import python\n import semmle.python.ApiGraphs\n import semmle.python.dataflow.new.RemoteFlowSources\n\nclass GradioButton extends RemoteFlowSource::Range {\n    GradioButton() {\n        exists(API::CallNode n |\n        n = API::moduleImport(\u0026#34;gradio\u0026#34;).getMember(\u0026#34;Button\u0026#34;).getReturn()\n        .getMember(\u0026#34;click\u0026#34;).getACall() |\n        this = n.getParameter(0, \u0026#34;fn\u0026#34;).getParameter(_).asSource())\n    }\n\n    override string getSourceType() { result = \u0026#34;Gradio untrusted input\u0026#34; }\n\n }\n\nfrom GradioButton inp\nselect inp, \u0026#34;Gradio sources\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"vulnerabilities-using-gradio-sources\" id=\"vulnerabilities-using-gradio-sources\"\u003eVulnerabilities using Gradio sources\u003ca href=\"#vulnerabilities-using-gradio-sources\" aria-label=\"Vulnerabilities using Gradio sources\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe can now use our two classes as sources in a taint tracking query, to detect vulnerabilities that have a Gradio source, and, continuing with our command injection example, an \u003ccode\u003eos.system\u003c/code\u003e sink (the first argument to the \u003ccode\u003eos.system\u003c/code\u003e call is the sink). See \u003ca href=\"https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-3-security-research-with-codeql/#taint-analysis-in-codeql-taint-tracking\"\u003eCodeQL zero to hero part 3\u003c/a\u003e to learn more about taint tracking queries.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eos.system\u003c/code\u003e call is defined in the \u003ccode\u003eOsSystemSink\u003c/code\u003e class and the sink, that is the first argument to the os.system sink call, is defined in the \u003ccode\u003eisSink\u003c/code\u003e predicate.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/**\n * @id codeql-zero-to-hero/4-7\n * @severity error\n * @kind path-problem\n */\n\n\n import python\n import semmle.python.dataflow.new.DataFlow\n import semmle.python.dataflow.new.TaintTracking\n import semmle.python.ApiGraphs\n import semmle.python.dataflow.new.RemoteFlowSources\n import MyFlow::PathGraph\n\nclass GradioButton extends RemoteFlowSource::Range {\n    GradioButton() {\n        exists(API::CallNode n |\n        n = API::moduleImport(\u0026#34;gradio\u0026#34;).getMember(\u0026#34;Button\u0026#34;).getReturn()\n        .getMember(\u0026#34;click\u0026#34;).getACall() |\n        this = n.getParameter(0, \u0026#34;fn\u0026#34;).getParameter(_).asSource())\n    }\n\n    override string getSourceType() { result = \u0026#34;Gradio untrusted input\u0026#34; }\n\n }\n\n class GradioInterface extends RemoteFlowSource::Range {\n    GradioInterface() {\n        exists(API::CallNode n |\n        n = API::moduleImport(\u0026#34;gradio\u0026#34;).getMember(\u0026#34;Interface\u0026#34;).getACall() |\n        this = n.getParameter(0, \u0026#34;fn\u0026#34;).getParameter(_).asSource())\n    }\n    override string getSourceType() { result = \u0026#34;Gradio untrusted input\u0026#34; }\n\n }\n\n\nclass OsSystemSink extends API::CallNode {\n    OsSystemSink() {\n        this = API::moduleImport(\u0026#34;os\u0026#34;).getMember(\u0026#34;system\u0026#34;).getACall()\n    }\n}\n\n\n private module MyConfig implements DataFlow::ConfigSig {\n   predicate isSource(DataFlow::Node source) {\n     source instanceof GradioButton\n     or\n     source instanceof GradioInterface\n   }\n\n   predicate isSink(DataFlow::Node sink) {\n    exists(OsSystemSink call |\n        sink = call.getArg(0)\n        )\n   }\n }\n\n module MyFlow = TaintTracking::Global\u0026lt;MyConfig\u0026gt;;\n\n from MyFlow::PathNode source, MyFlow::PathNode sink\n where MyFlow::flowPath(source, sink)\n select sink.getNode(), source, sink, \u0026#34;Data Flow from a Gradio source to `os.system`\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRunning the query results in 6 alerts, which show us the path from source to sink. Note that the \u003ccode\u003eos.system\u003c/code\u003e sink we used is already modeled in CodeQL, but we are using it here to illustrate the example.\u003c/p\u003e\n\u003cfigure id=\"attachment_81627\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1968\" height=\"642\" src=\"https://github.blog/wp-content/uploads/2024/12/path-alert-1.png?w=1024\u0026amp;resize=1968%2C642\" alt=\"creenshot from the VS Code CodeQL extension showing six alerts, two in file “cmdi-interface-list.py”, one in “cmdi-interface.py”, two in file “cmdi-list.py” and one in “cmdi.py”. The first alert in the  “cmdi-interface-list.py” file is open and shows a three steps, with the last step highlighted. The file open on the right side. In the file, the “cmd” argument to “os.system” is highlighted.\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/path-alert-1.png?w=1968 1968w, https://github.blog/wp-content/uploads/2024/12/path-alert-1.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/path-alert-1.png?w=768 768w, https://github.blog/wp-content/uploads/2024/12/path-alert-1.png?w=1024 1024w, https://github.blog/wp-content/uploads/2024/12/path-alert-1.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003cfigcaption\u003eQuery results in six alerts\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eSimilarly to the \u003ccode\u003eGradioInterface\u003c/code\u003e class, since we have already written the sources, we can actually use them (as well as the query we’ve written above) on any Python project. We just have to add them to library files, like I did in this \u003ca href=\"https://github.com/github/codeql/pull/16135/files\"\u003epull request to add Gradio models\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWe can actually run any query on up to \u003cstrong\u003e1000 projects\u003c/strong\u003e at once using a tool called Multi repository Variant Analysis (MRVA).\u003c/p\u003e\n\u003cp\u003eBut before that.\u003c/p\u003e\n\u003ch3 id=\"other-sources-in-gradio\" id=\"other-sources-in-gradio\"\u003eOther sources in Gradio\u003ca href=\"#other-sources-in-gradio\" aria-label=\"Other sources in Gradio\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBased on the tests we did in the \u003ca href=\"#identifying-attack-surface-in-gradio\"\u003eIdentifying attack surface in Gradio section\u003c/a\u003e, we can identify other sources that behave in a similar way. For example, there’s \u003ca href=\"https://www.gradio.app/docs/gradio/loginbutton#event-listeners\"\u003e\u003ccode\u003egr.LoginButton.click\u003c/code\u003e\u003c/a\u003e, an event listener that also takes \u003ccode\u003einputs\u003c/code\u003e and could be considered a source. I’ve modeled these cases and added them to CodeQL, which you can see \u003ca href=\"https://github.com/github/codeql/pull/16135/files\"\u003ein the pull request to add Gradio models\u003c/a\u003e. The modeling of these event listeners is very similar to what we’ve done in the previous section.\u003c/p\u003e\n\u003ch2 id=\"taint-step\" id=\"taint-step\"\u003eTaint step\u003ca href=\"#taint-step\" aria-label=\"Taint step\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe’ve mentioned that there are two ways to model \u003ccode\u003egr.Interface\u003c/code\u003e and other Gradio sources—by identifying the values passed to \u003ccode\u003einputs\u003c/code\u003e and then linking them to the function referenced in \u003ccode\u003efn\u003c/code\u003e, or by looking at the parameters to the function referenced in \u003ccode\u003efn\u003c/code\u003e directly.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport gradio as gr\nimport os\n\ndef execute_cmd(folder, logs):\n    cmd = f\u0026#34;python caption.py --dir={folder} --logs={logs}\u0026#34;\n    os.system(cmd)\n    return f\u0026#34;Command: {cmd}\u0026#34;\n\n\nfolder = gr.Textbox(placeholder=\u0026#34;Directory to caption\u0026#34;)\nlogs = gr.Checkbox(label=\u0026#34;Save verbose logs\u0026#34;)\noutput = gr.Textbox()\n\ndemo = gr.Interface(\n    fn=execute_cmd,\n    inputs=[folder, logs],\n    outputs=output)\n\nif __name__ == \u0026#34;__main__\u0026#34;:\n    demo.launch(debug=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs it turns out, machine learning applications written using Gradio often use a lot of input variables, which are later processed by the application. In this case, \u003ccode\u003einputs\u003c/code\u003e argument gets a list of variables, which at times can be very long. I’ve found several cases which used a list with 10+ elements.\u003c/p\u003e\n\u003cp\u003eIn these cases, it would be nice to be able to track the source all the way to the component that introduces it— in our case, \u003ccode\u003egr.Textbox\u003c/code\u003e and \u003ccode\u003egr.Checkbox\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTo do that, we need to use a \u003cstrong\u003etaint step.\u003c/strong\u003e Taint steps are usually used in case taint analysis stops at a specific code element, and we want to make it propagate forward. In our case, however, we are going to write a taint step to track a variable in \u003ccode\u003einputs\u003c/code\u003e, that is an element of a list, and track it back to the component.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eGradio.qll\u003c/code\u003e file in CodeQL upstream contains all the \u003ca href=\"https://github.com/sylwia-budzynska/codeql/blob/main/python/ql/lib/semmle/python/frameworks/Gradio.qll\"\u003eGradio source models and the taint step\u003c/a\u003e if you’d like to see the whole modeling.\u003c/p\u003e\n\u003cp\u003eWe start by identifying the variables passed to \u003ccode\u003einputs\u003c/code\u003e in, for example, \u003ccode\u003egr.Interface\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass GradioInputList extends RemoteFlowSource::Range {\n    GradioInputList() {\n      exists(GradioInput call |\n        // limit only to lists of parameters given to `inputs`.\n        (\n          (\n            call.getKeywordParameter(\u0026#34;inputs\u0026#34;).asSink().asCfgNode() instanceof ListNode\n            or\n            call.getParameter(1).asSink().asCfgNode() instanceof ListNode\n          ) and\n          (\n            this = call.getKeywordParameter(\u0026#34;inputs\u0026#34;).getASubscript().getAValueReachingSink()\n            or\n            this = call.getParameter(1).getASubscript().getAValueReachingSink()\n          )\n        )\n      )\n    }\n\n    override string getSourceType() { result = \u0026#34;Gradio untrusted input\u0026#34; }\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we identify the function in \u003ccode\u003efn\u003c/code\u003e and link the elements of the list of variables in \u003ccode\u003einputs\u003c/code\u003e to the parameters of the function referenced in \u003ccode\u003efn\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass ListTaintStep extends TaintTracking::AdditionalTaintStep {\n  override predicate step(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) {\n    exists(GradioInput node, ListNode inputList |\n       inputList = node.getParameter(1, \u0026#34;inputs\u0026#34;).asSink().asCfgNode() |\n       exists(int i | \n         nodeTo = node.getParameter(0, \u0026#34;fn\u0026#34;).getParameter(i).asSource() |\n         nodeFrom.asCfgNode() =\n         inputList.getElement(i))\n       )\n    }\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s explain the taint step, step by step.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexists(GradioInput node, Listnode inputList |\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the taint step, we define two temporary variables in the \u003ccode\u003eexists\u003c/code\u003e mechanism—\u003ccode\u003enode\u003c/code\u003e of type \u003ccode\u003eGradioInput\u003c/code\u003e and \u003ccode\u003einputList\u003c/code\u003e of type \u003ccode\u003eListNode\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einputList = node.getParameter(1, \u0026#34;inputs\u0026#34;).asSink().asCfgNode() |\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen, we set our \u003ccode\u003einputList\u003c/code\u003e to the value of \u003ccode\u003einputs\u003c/code\u003e. Note that because \u003ccode\u003einputList\u003c/code\u003e has type \u003ccode\u003eListNode\u003c/code\u003e, we are looking only for lists.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexists(int i | \nnodeTo = node.getParameter(0, \u0026#34;fn\u0026#34;).getParameter(i).asSource() |\nnodeFrom.asCfgNode() = inputList.getElement(i))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we identify the function in \u003ccode\u003efn\u003c/code\u003e and link the parameters of the function referenced in \u003ccode\u003efn\u003c/code\u003e to the elements of the list of variables in \u003ccode\u003einputs\u003c/code\u003e, by using a temporary variable \u003ccode\u003ei\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAll in all, the taint step provides us with a nicer display of the paths, from the component used as a source to a potential sink.\u003c/p\u003e\n\u003ch2 id=\"scaling-the-research-to-thousands-of-repositories-with-mrva\" id=\"scaling-the-research-to-thousands-of-repositories-with-mrva\"\u003eScaling the research to thousands of repositories with MRVA\u003ca href=\"#scaling-the-research-to-thousands-of-repositories-with-mrva\" aria-label=\"Scaling the research to thousands of repositories with MRVA\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCodeQL zero to hero part 3 introduced \u003ca href=\"https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-3-security-research-with-codeql/#multi-repository-variant-analysis-mrva\"\u003eMulti-Repository Variant Analysis\u003c/a\u003e (MRVA) and \u003ca href=\"https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-3-security-research-with-codeql/#variant-analysis\"\u003evariant analysis\u003c/a\u003e. Head over there if you need a refresher on the topics.\u003c/p\u003e\n\u003cp\u003eIn short,MRVA allows you to run a query on up to 1000 projects hosted on GitHub at once. It comes preconfigured with dynamic lists for most popular repositories 10, 100, and 1000 for each language. You can configure your own lists of repositories to run CodeQL queries on and potentially find more variants of vulnerabilities that use our new models. \u003ca href=\"https://github.com/maikypedia\"\u003e@maikypedia\u003c/a\u003e wrote a neat \u003ca href=\"https://maikypedia.gitlab.io/posts/finding-vulns-with-mrva-codeql/\"\u003ecase study about using MRVA to find SSTI vulnerabilities in Ruby and Unsafe Deserialization vulnerabilities in Python\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eMRVA is used together with the VS Code CodeQL extension and can be configured in the extension, in the “Variant Analysis” section. It uses GitHub Actions to run, so you need a repository, which will be used as a controller to run these actions. You can create a public repository, in which case running the queries will be free, but in this case, you can run MRVA only on \u003cstrong\u003epublic\u003c/strong\u003e repositories. The docs contain more \u003ca href=\"https://docs.github.com/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/running-codeql-queries-at-scale-with-multi-repository-variant-analysis\"\u003einformation about MRVA and its setup\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eUsing MRVA, I’ve found 11 vulnerabilities to date in several Gradio projects. Check out the vulnerability reports on \u003ca href=\"https://securitylab.github.com/advisories/\"\u003eGitHub Security Lab’s website\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"reach-out\" id=\"reach-out\"\u003eReach out!\u003ca href=\"#reach-out\" aria-label=\"Reach out!\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eToday, we learned how to model a new framework in CodeQL, using Gradio as an example, and how to use those models for finding vulnerabilities at scale. I hope that this post helps you with finding new cool vulnerabilities! 🔥\u003c/p\u003e\n\u003cp\u003eIf CodeQL and this post helped you to find a vulnerability, we would love to hear about it! Reach out to us on \u003ca href=\"https://gh.io/securitylabslack\"\u003eGitHub Security Lab on Slack\u003c/a\u003e or tag us \u003ca href=\"https://twitter.com/GHSecurityLab\"\u003e@ghsecuritylab\u003c/a\u003e on X.\u003c/p\u003e\n\u003cp\u003eIf you have any questions, issues with challenges or with writing a CodeQL query, feel free to join and ask on the \u003ca href=\"https://gh.io/securitylabslack\"\u003eGitHub Security Lab server on Slack\u003c/a\u003e. The Slack server is open to anyone and gives you access to ask questions about issues with CodeQL, CodeQL modeling or anything else CodeQL related, and receive answers from a number of CodeQL engineers. If you prefer to stay off Slack, feel free to ask any questions in \u003ca href=\"https://github.com/github/codeql/discussions\"\u003eCodeQL repository discussions\u003c/a\u003e or in \u003ca href=\"https://github.com/github/securitylab/discussions\"\u003eGitHub Security Lab repository discussions\u003c/a\u003e.\u003c/p\u003e\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/102833689?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/102833689?v=4\u0026amp;s=200\" alt=\"Sylwia Budzynska\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eSylwia is a security researcher at GitHub Security Lab, where she works with finding vulnerabilities in open source software, helping secure the foundations on which all modern software is built upon.\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "38 min read",
  "publishedTime": "2024-12-11T15:00:15Z",
  "modifiedTime": "2024-12-11T15:34:21Z"
}
