{
  "id": "d312d958-ac1d-4f1f-b1ce-85260643daca",
  "title": "Modular Ktor: Building Backends for Scale",
  "link": "https://blog.jetbrains.com/kotlin/2025/07/modular-ktor-building-backends-for-scale/",
  "description": "Ktor offers a lightweight, flexible approach to building web applications that differs from more opinionated all-in-one frameworks. While Ktor’s minimalist design might seem challenging at first, a little experience using our modules can go a long way towards building for scale. In this article, I’ll show you some techniques for introducing modularity to your Ktor […]",
  "author": "Bruce Hamilton",
  "published": "Thu, 10 Jul 2025 15:28:30 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "best-practices",
    "ktor",
    "kotlin"
  ],
  "byline": "Bruce Hamilton",
  "length": 16614,
  "excerpt": "In this article, the author walks you through a few ways to bring modularity into your Ktor projects.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "A concise multiplatform language developed by JetBrains Best Practices KtorModular Ktor: Building Backends for Scale Ktor offers a lightweight, flexible approach to building web applications that differs from more opinionated all-in-one frameworks. While Ktor’s minimalist design might seem challenging at first, a little experience using our modules can go a long way towards building for scale. In this article, I’ll show you some techniques for introducing modularity to your Ktor projects. Why modularity matters One of the reasons Ktor remains a popular choice for server-side development is the directness and transparency of its implementations. Without the need for meta-programming or a host of configuration files, you can write simple services constrained to just a few Kotlin source files and it’s always clear that you’re working with an HTTP server. This approach is great for simple applications, but when growing projects, it is important to anticipate future needs and mitigate their impact. The best way to accomplish this is break up your application into small, isolated parts, so that you can replace relevant pieces of functionality without modifying the whole thing. In other words, in order to gracefully scale the complexity of our project, we introduce modularity. Most application frameworks include some first-class support for baking in modularity — usually by having some central registry for including bits of functionality. The Ktor server framework is no exception to this, and in the next section I’ll introduce the concept of application modules in Ktor. Modules in Ktor To start, let’s cover the basics. 1. What is a Ktor module? To put it simply, it’s one of these: fun Application.moduleName() { // Add a little functionality } And with Ktor 3.2, you’ll also be able to use suspend functions as modules: suspend fun Application.moduleName() { // Add some functionality with coroutines! } Either way, a module is just an extension function for an Application that runs as the server starts. Now, you might be wondering… 2. What is an Application? This is the container that holds all the hooks for business logic that execute when a request is handled. For example, we can inject some logging at the start of our pipeline, or we can insert some logic for serializing objects in the response. When the server is restarted, the Application is created anew and all the Ktor modules are reapplied. This also happens after changes are made while running in development mode, with the environment and engine configuration remaining untouched. 3. What can I do with Ktor modules? You can reference modules directly from the context of the Application from an EmbeddedServer instance: fun main() { embeddedServer(CIO, port = 8080, host = \"0.0.0.0\", module = Application::module) .start(wait = true) } fun Application.module() { routing { get(\"/\") { call.respond(\"Hello, World!\") } } } Or you can reference modules from your configuration file: # application.yaml ktor: application: modules: - com.example.ApplicationKt.module Referencing modules from our configuration allows us to change the behavior of our server during runtime. For example, we can include some stronger security features only in production, or include some debugging hooks for our test environments. To properly leverage this functionality, it’s best to split your modules up into smaller units. Granular modules provide greater flexibility, but can present a challenge when many of them rely on some specific piece of code. These common requirements can be duplicated across modules, or we can introduce dependencies between our modules by sharing this data through the Application instance. Modules will often be related via dependencies, but there’s no obvious way to apply these connections.  In the next section, I’ll describe how to hook modules together. Connecting modules Reviewing the signature of the module function, it is difficult to see how modules can relate to one another: fun Application.module(): Unit There aren’t any arguments or return types, so how can the platform possibly piece them together? 1. Use the stack The simplest and most natural way to relate modules is by treating them exactly as you would any other function call: fun main() { embeddedServer(CIO, port = 8080, host = \"0.0.0.0\") { // Instantiate your dependency val myService = MyService(property\u003cMyServiceConfig\u003e()) // Inject it into your modules as a parameter routingModule(myService) schedulingModule(myService) }.start(wait = true) } This approach can work well for applications of any size, with the sole caveat that our modules are now strongly coupled at compile time, so they’re no longer interchangeable at runtime. When working in a single repository, you’re unlikely to need interchangeable modules, but when scaling out to multiple repositories and teams, using them can be an asset for reducing coordination overhead. To get around this rigidity, we can consider removing inter-module references by passing dependencies through a common container. 2. Application Attributes Ktor includes a built-in container for passing references between modules and plugins. You can find it in the Application.attributes property, which is really just a Map\u003cString, Any\u003e that retains some extra type information. Here is an example to show how the attributes map can be used: val connectionFactoryKey = AttributeKey\u003cConnectionFactory\u003e(\"ConnectionFactory\") // Declaring fun Application.database() {     attributes[connectionFactoryKey] = PostgresConnectionFactory() } // Resolving fun Application.service() {     val connectionFactory = attributes[connectionFactoryKey]     // Use the connection factory in our service } With this method of connecting different modules, we create loose coupling by avoiding direct references between our modules. We can achieve this using parameterized attribute keys for sharing implementations through a common map. This qualifies our attributes property as a basic inversion of control (IoC) container. This technique can be fairly versatile, but it has a few disadvantages: It requires a shared “key” variable that lives outside the scope of our server. Modules are now temporally coupled, i.e., they must be referenced in a specific order. There is no tracking of what goes into or comes out of the map. Everything is manual, i.e., there is no support for reflection. There is no way to manage the lifecycle of these services. In summary, you can do quite a bit with a simple map of instances, but it falls short when working with larger projects. 3. External libraries To address some of these pain points, we can look at some popular Kotlin IoC libraries. In this article, I won’t go into the details of which library solves which problems, but there are plenty of options when working in Kotlin. Here are some examples of IoC libraries that allow sharing between modules in Ktor using a declarative approach: Kodein An open-source library developed by KodeinKoders to provide a simple declarative means for sharing instances. // Declaring fun Application.database() { di { bind\u003cConnectionFactory\u003e { singleton { PostgresConnectionFactory() } } } } // Resolving fun Application.service() { val connectionFactory by closestDI().instance\u003cConnectionFactory\u003e() // Use the connection factory in our service } Koin A popular and pragmatic open-source framework by Kotzilla that uses a fairly similar approach. // Declaring fun Application.database() { koinModule { singleOf\u003cConnectionFactory\u003e { PostgresConnectionFactory() } } } // Resolving fun Application.service() { val connectionFactory by inject\u003cConnectionFactory\u003e() // Use the connection factory in our service } Apart from these declarative, multi-platform libraries, there are also several libraries made for injecting classes using annotations and compiler plugins: Kotlin-inject Dagger Anvil Metro At this point, you might feel a little overwhelmed with options. After all, when using all-in-one frameworks, everything you need is built in, and you don’t have to worry about choosing some external means for sharing code. This is why in our latest release, we’ve worked to resolve this mental overhead by introducing a new DI plugin for Ktor server applications. Obligatory XKCD reference. Ktor’s dependency injection The goal of the new plugin is to simplify the management of inter-module dependencies. To facilitate this, we focused on improving the developer experience and introducing deep platform integration. With the new plugin, there are a few options for sharing instances between your modules: The plugin DSL File configuration Module parameters Here are some examples of how each of these techniques work. Plugin DSL If you’re accustomed to the libraries described above, the DSL will probably be most familiar to you. Here’s the same example from above using the Ktor DI plugin: // Declaring fun Application.database() { dependencies { provide\u003cConnectionFactory\u003e { PostgresConnectionFactory() } } } // Resolving suspend fun Application.service() { val connectionFactory: ConnectionFactory = dependencies.resolve() } We also allow for declaring types from class references. This way, types are created automatically, and their constructor arguments will be populated from other declared types. Any of the class’s covariant types can also be resolved from the registry this way, so you don’t have to worry about the abstraction on the declaration side. Here’s how to declare your instances from class references: fun Application.database() { dependencies { provide(PostgresConnectionFactory::class) } } Now, we’ll show how to use these references for changing functionality at runtime! File configuration As shown earlier in the article, you can modify the behavior of your server by swapping modules in your file configuration. The DI plugin accommodates a similar approach, but for targeting specific types. Considering our last connection factory example using class references, we can now do the same from our configuration file: # application.yaml ktor: application: dependencies: - com.example.PostgresConnectionFactory You can also reference functions that return the types you’re interested in: ktor: application: dependencies: - com.example.Postgres#createConnectionFactory db: url: postgres://localhost:3456 Where the actual function looks something like: fun createConnectionFactory(@Property(\"db.url\") url: String): ConnectionFactory { return PostgresConnectionFactory(url) } As you can see in the example function, properties from your configuration can now be imported directly as parameters. You can import basic types like String and Int, or you can import more complex data types marked with the @Serializable annotation. Module parameters Not only can you inject the parameters of instance-providing functions, but you can also inject the module functions themselves. For any module, you can import parameters from: Your file configuration, using the @Property annotation. Special types, like Application, ApplicationEnvironment, or ApplicationConfig Any declared dependency. Here’s how our connection factory example looks: fun Application.service(connectionFactory: ConnectionFactory) {     // Use the connection factory in our service } The platform will handle the injection of connectionFactory automatically, and it doesn’t matter what order you reference your modules in. The same injection works with dependencies referenced from your file configuration, so you can chain them together to construct more complex dependency trees. It’s important to note that, since this injection relies on type reflection, it will only be available for the JVM. Testing with DI One major advantage of decoupling your modules is that it simplifies testing. Using the DI plugin in Ktor 3.2, you can mock out components with ease: fun `can fetch messages`() = testApplication { // replace the production implementation with a mock dependencies { provide { MockConnectionFactory() } } // load modules from your default application.conf configure() val messageList: List\u003cMessage\u003e = client.get(\"/messages\").body() assertEquals(listOf(expectedMessage), messageList) } This works by providing an alternative conflict policy in the test application context, so initial dependencies are retained. All you need to remember is that your mocks should go in before your production modules. Scaling with DI Now that we have a reliable way to share code between modules, we can easily start splitting our projects into small Gradle modules. Instead of keeping all of our server logic in a single project, we can isolate different integration points, providing the opportunity to use domain-centric architectures, like the hexagonal or clean. If we continue with our previous example, we can consider excluding the postgres connection factory from our compilation classpath entirely. Let’s say we have a project structure like this: db ├─ core ├─ postgres └─ mongo server ├─ core ├─ admin └─ banking Now, we can share some common server modules under server/core and focus more strictly on domain logic in our smaller services. Under server/banking, for example, our build.gradle.kts file would look like this: plugins { id(\"io.ktor.plugin\") version \"3.2.0\" } dependencies { implementation(\":server:core\") implementation(\":db:core\") runtimeOnly(\":db:postgres\") runtimeOnly(\":db:mongo\") } Then we can defer choosing our storage implementation right up until our application is deployed and reads the configuration file. For this, we simply edit application.yaml like so: ktor: application: dependencies: # Taken from modules db/* - com.example.MockConnectionFactory # - com.example.MongoConnectionFactory # - com.example.PostgresConnectionFactory modules: # Taken from server/core - com.example.Authentication.configureAuth # My domain service - com.example.Banking.configureBankRoutes Since the implementations are hidden from our compile classpath, we can avoid polluting our services with implementation details while introducing several options for how our application operates. Wrapping up In this article, we’ve covered the basics of working with modules in Ktor and how to leverage dependency injection tools for sharing code between them. To summarize: Ktor modules are replaceable extension functions for the Application class. Modules can be used to manage complexity in a growing application. Code can be shared between modules indirectly via attributes or a DI library. Ktor now includes a robust DI plugin out of the box. Here is an example of a project that uses the new tooling: https://github.com/ktorio/ktor-chat/ If you have any thoughts on any of the topics in this article, you can leave a comment here or find us in the official Kotlin Slack channel. Subscribe to Kotlin Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/07/KT-social-BlogSocialShare-1280x720-2x-3.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/kotlin/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/Kotlin-5.svg\" alt=\"Kotlin logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eA concise multiplatform language developed by JetBrains\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/kotlin/category/best-practices/\"\u003eBest Practices\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/kotlin/category/ktor/\"\u003eKtor\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eModular Ktor: Building Backends for Scale\u003c/h2\u003e                    \n                    \n\u003cp\u003eKtor offers a lightweight, flexible approach to building web applications that differs from more opinionated all-in-one frameworks. While Ktor’s minimalist design might seem challenging at first, a little experience using our modules can go a long way towards building for scale.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this article, I’ll show you some techniques for introducing modularity to your Ktor projects.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhy modularity matters\u003c/h2\u003e\n\n\n\n\u003cp\u003eOne of the reasons Ktor remains a popular choice for server-side development is the directness and transparency of its implementations. Without the need for meta-programming or a host of configuration files, you can write simple services constrained to just a few Kotlin source files and it’s always clear that you’re working with an HTTP server.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis approach is great for simple applications, but when growing projects, it is important to anticipate future needs and mitigate their impact. The best way to accomplish this is break up your application into small, isolated parts, so that you can replace relevant pieces of functionality without modifying the whole thing. In other words, in order to gracefully scale the complexity of our project, we introduce \u003ca href=\"https://en.wikipedia.org/wiki/Modularity\" target=\"_blank\" rel=\"noopener\"\u003e\u003cem\u003emodularity\u003c/em\u003e\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eMost application frameworks include some first-class support for baking in modularity — usually by having some central registry for including bits of functionality. The Ktor server framework is no exception to this, and in the next section I’ll introduce the concept of application modules in Ktor.\u003c/p\u003e\n\n\n\n\u003ch2\u003eModules in Ktor\u003c/h2\u003e\n\n\n\n\u003cp\u003eTo start, let’s cover the basics.\u003c/p\u003e\n\n\n\n\u003ch3\u003e1. What is a Ktor module?\u003c/h3\u003e\n\n\n\n\u003cp\u003eTo put it simply, it’s one of these:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun Application.moduleName() {\n    // Add a little functionality\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd with Ktor 3.2, you’ll also be able to use \u003cstrong\u003esuspend\u003c/strong\u003e functions as modules:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003esuspend fun Application.moduleName() {\n    // Add some functionality with coroutines!\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eEither way, a module is just an extension function for an \u003ccode\u003eApplication\u003c/code\u003e that runs as the server starts.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow, you might be wondering…\u003c/p\u003e\n\n\n\n\u003ch3\u003e2. What is an \u003cstrong\u003eApplication\u003c/strong\u003e?\u003c/h3\u003e\n\n\n\n\u003cp\u003eThis is the container that holds all the hooks for business logic that execute when a request is handled. For example, we can inject some logging at the start of our pipeline, or we can insert some logic for serializing objects in the response.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen the server is restarted, the \u003ccode\u003eApplication\u003c/code\u003e is created anew and all the Ktor modules are reapplied. This also happens after changes are made while running in development mode, with the environment and engine configuration remaining untouched.\u003c/p\u003e\n\n\n\n\u003ch3\u003e3. What can I do with Ktor modules?\u003c/h3\u003e\n\n\n\n\u003cp\u003eYou can reference modules directly from the context of the \u003ccode\u003eApplication\u003c/code\u003e from an \u003ccode\u003eEmbeddedServer\u003c/code\u003e instance:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun main() {\n    embeddedServer(CIO, port = 8080, host = \u0026#34;0.0.0.0\u0026#34;, module = Application::module)\n        .start(wait = true)\n}\n\nfun Application.module() {\n    routing {\n        get(\u0026#34;/\u0026#34;) {\n            call.respond(\u0026#34;Hello, World!\u0026#34;)\n        }\n    }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eOr you can reference modules from your configuration file:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"yaml\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e# application.yaml\nktor:\n  application:\n    modules:\n      - com.example.ApplicationKt.module\u003c/pre\u003e\n\n\n\n\u003cp\u003eReferencing modules from our configuration allows us to change the behavior of our server during runtime. For example, we can include some stronger security features only in production, or include some debugging hooks for our test environments. To properly leverage this functionality, it’s best to split your modules up into smaller units.\u003c/p\u003e\n\n\n\n\u003cp\u003eGranular modules provide greater flexibility, but can present a challenge when many of them rely on some specific piece of code. These common requirements can be duplicated across modules, or we can introduce dependencies between our modules by sharing this data through the \u003ccode\u003eApplication\u003c/code\u003e instance.\u003c/p\u003e\n\n\n\n\u003cp\u003eModules will often be related via dependencies, but there’s no obvious way to apply these connections.  In the next section, I’ll describe how to hook modules together.\u003c/p\u003e\n\n\n\n\u003ch2\u003eConnecting modules\u003c/h2\u003e\n\n\n\n\u003cp\u003eReviewing the signature of the module function, it is difficult to see how modules can relate to one another:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun Application.module(): Unit\u003c/pre\u003e\n\n\n\n\u003cp\u003eThere aren’t any arguments or return types, so how can the platform possibly piece them together?\u003c/p\u003e\n\n\n\n\u003ch3\u003e1. Use the stack\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe simplest and most natural way to relate modules is by treating them exactly as you would any other function call:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun main() {\n    embeddedServer(CIO, port = 8080, host = \u0026#34;0.0.0.0\u0026#34;) {\n        // Instantiate your dependency\n        val myService = MyService(property\u0026lt;MyServiceConfig\u0026gt;())\n        // Inject it into your modules as a parameter\n        routingModule(myService)\n        schedulingModule(myService)\n    }.start(wait = true)\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis approach can work well for applications of any size, with the sole caveat that our modules are now strongly coupled at compile time, so they’re no longer interchangeable at runtime.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen working in a single repository, you’re unlikely to need interchangeable modules, but when scaling out to multiple repositories and teams, using them can be an asset for reducing coordination overhead. To get around this rigidity, we can consider removing inter-module references by passing dependencies through a common container.\u003c/p\u003e\n\n\n\n\u003ch3\u003e2. Application Attributes\u003c/h3\u003e\n\n\n\n\u003cp\u003eKtor includes a built-in container for passing references between modules and plugins. You can find it in the \u003ccode\u003eApplication.attributes\u003c/code\u003e property, which is really just a \u003ccode\u003eMap\u0026lt;String, Any\u0026gt;\u003c/code\u003e that retains some extra type information.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is an example to show how the attributes map can be used:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eval connectionFactoryKey = AttributeKey\u0026lt;ConnectionFactory\u0026gt;(\u0026#34;ConnectionFactory\u0026#34;)\n\n// Declaring\nfun Application.database() {\n    attributes[connectionFactoryKey] = PostgresConnectionFactory()\n}\n\n// Resolving\nfun Application.service() {\n    val connectionFactory = attributes[connectionFactoryKey]\n\n    // Use the connection factory in our service\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith this method of connecting different modules, we create loose coupling by avoiding direct references between our modules. We can achieve this using parameterized attribute keys for sharing implementations through a common map. This qualifies our attributes property as a basic \u003ca href=\"https://en.wikipedia.org/wiki/Inversion_of_control\" target=\"_blank\" rel=\"noopener\"\u003e\u003cem\u003einversion of control\u003c/em\u003e\u003c/a\u003e (IoC) container.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis technique can be fairly versatile, but it has a few disadvantages:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eIt requires a shared “key” variable that lives outside the scope of our server.\u003c/li\u003e\n\n\n\n\u003cli\u003eModules are now temporally coupled, i.e., they must be referenced in a specific order.\u003c/li\u003e\n\n\n\n\u003cli\u003eThere is no tracking of what goes into or comes out of the map.\u003c/li\u003e\n\n\n\n\u003cli\u003eEverything is manual, i.e., there is no support for reflection.\u003c/li\u003e\n\n\n\n\u003cli\u003eThere is no way to manage the lifecycle of these services.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eIn summary, you can do quite a bit with a simple map of instances, but it falls short when working with larger projects.\u003c/p\u003e\n\n\n\n\u003ch3\u003e3. External libraries\u003c/h3\u003e\n\n\n\n\u003cp\u003eTo address some of these pain points, we can look at some popular Kotlin IoC libraries. In this article, I won’t go into the details of which library solves which problems, but there are plenty of options when working in Kotlin.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere are some examples of IoC libraries that allow sharing between modules in Ktor using a declarative approach:\u003c/p\u003e\n\n\n\n\u003ch4\u003e\u003ca href=\"https://github.com/kosi-libs/Kodein\" target=\"_blank\" rel=\"noopener\"\u003eKodein\u003c/a\u003e\u003c/h4\u003e\n\n\n\n\u003cp\u003eAn open-source library developed by \u003ca href=\"https://kodein.net/\" target=\"_blank\" rel=\"noopener\"\u003eKodeinKoders\u003c/a\u003e to provide a simple declarative means for sharing instances.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e// Declaring\nfun Application.database() {\n    di {\n        bind\u0026lt;ConnectionFactory\u0026gt; {\n            singleton {\n                PostgresConnectionFactory()\n            }\n        }\n    }\n}\n\n// Resolving\nfun Application.service() {\n    val connectionFactory by closestDI().instance\u0026lt;ConnectionFactory\u0026gt;()\n    // Use the connection factory in our service\n}\n\u003c/pre\u003e\n\n\n\n\u003ch4\u003e\u003ca href=\"https://insert-koin.io/\" target=\"_blank\" rel=\"noopener\"\u003eKoin\u003c/a\u003e\u003c/h4\u003e\n\n\n\n\u003cp\u003eA popular and pragmatic open-source framework by \u003ca href=\"https://kotzilla.io/\" target=\"_blank\" rel=\"noopener\"\u003eKotzilla\u003c/a\u003e that uses a fairly similar approach. \u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e// Declaring\nfun Application.database() {\n    koinModule {\n        singleOf\u0026lt;ConnectionFactory\u0026gt; {\n            PostgresConnectionFactory()\n        }\n    }\n}\n\n// Resolving\nfun Application.service() {\n    val connectionFactory by inject\u0026lt;ConnectionFactory\u0026gt;()\n    // Use the connection factory in our service\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eApart from these declarative, multi-platform libraries, there are also several libraries made for injecting classes using annotations and compiler plugins:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/evant/kotlin-inject\" target=\"_blank\" rel=\"noopener\"\u003eKotlin-inject\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://github.com/google/dagger\" target=\"_blank\" rel=\"noopener\"\u003eDagger\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://github.com/square/anvil\" target=\"_blank\" rel=\"noopener\"\u003eAnvil\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://github.com/ZacSweers/metro\" target=\"_blank\" rel=\"noopener\"\u003eMetro\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAt this point, you might feel a little overwhelmed with options. After all, when using all-in-one frameworks, everything you need is built in, and you don’t have to worry about choosing some external means for sharing code. This is why in our latest release, we’ve worked to resolve this mental overhead by introducing a \u003cstrong\u003enew DI plugin\u003c/strong\u003e for Ktor server applications.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://imgs.xkcd.com/comics/standards_2x.png\" target=\"_blank\" rel=\"noopener\"\u003eObligatory XKCD reference.\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eKtor’s dependency injection\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe goal of the new plugin is to simplify the management of inter-module dependencies. To facilitate this, we focused on improving the developer experience and introducing deep platform integration.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith the new plugin, there are a few options for sharing instances between your modules:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eThe plugin DSL\u003c/li\u003e\n\n\n\n\u003cli\u003eFile configuration\u003c/li\u003e\n\n\n\n\u003cli\u003eModule parameters\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eHere are some examples of how each of these techniques work.\u003c/p\u003e\n\n\n\n\u003ch3\u003ePlugin DSL\u003c/h3\u003e\n\n\n\n\u003cp\u003eIf you’re accustomed to the libraries described above, the DSL will probably be most familiar to you.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere’s the same example from above using the Ktor DI plugin:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e// Declaring\nfun Application.database() {\n    dependencies {\n        provide\u0026lt;ConnectionFactory\u0026gt; { PostgresConnectionFactory() }\n    }\n}\n// Resolving\nsuspend fun Application.service() {\n    val connectionFactory: ConnectionFactory = dependencies.resolve()\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe also allow for declaring types from class references. This way, types are created automatically, and their constructor arguments will be populated from other declared types. Any of the class’s covariant types can also be resolved from the registry this way, so you don’t have to worry about the abstraction on the declaration side.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere’s how to declare your instances from class references:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun Application.database() {\n    dependencies {\n        provide(PostgresConnectionFactory::class)\n    }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow, we’ll show how to use these references for changing functionality at runtime!\u003c/p\u003e\n\n\n\n\u003ch3\u003eFile configuration\u003c/h3\u003e\n\n\n\n\u003cp\u003eAs shown earlier in the article, you can modify the behavior of your server by swapping modules in your file configuration. The DI plugin accommodates a similar approach, but for targeting specific types.\u003c/p\u003e\n\n\n\n\u003cp\u003eConsidering our last connection factory example using class references, we can now do the same from our configuration file:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"yaml\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e# application.yaml\nktor:\n  application:\n    dependencies:\n      - com.example.PostgresConnectionFactory\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou can also reference functions that return the types you’re interested in:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"yaml\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003ektor:\n  application:\n    dependencies:\n      - com.example.Postgres#createConnectionFactory\ndb:\n  url: postgres://localhost:3456\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhere the actual function looks something like:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun createConnectionFactory(@Property(\u0026#34;db.url\u0026#34;) url: String): ConnectionFactory {\n    return PostgresConnectionFactory(url)\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eAs you can see in the example function, properties from your configuration can now be imported directly as parameters. You can import basic types like String and Int, or you can import more complex data types marked with the \u003ccode\u003e@Serializable\u003c/code\u003e annotation.\u003c/p\u003e\n\n\n\n\u003ch3\u003eModule parameters\u003c/h3\u003e\n\n\n\n\u003cp\u003eNot only can you inject the parameters of instance-providing functions, but you can also inject the module functions themselves.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor any module, you can import parameters from:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eYour file configuration, using the \u003ccode\u003e@Property\u003c/code\u003e annotation.\u003c/li\u003e\n\n\n\n\u003cli\u003eSpecial types, like \u003ccode\u003eApplication\u003c/code\u003e, \u003ccode\u003eApplicationEnvironment\u003c/code\u003e, or \u003ccode\u003eApplicationConfig\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eAny declared dependency.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eHere’s how our connection factory example looks:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun Application.service(connectionFactory: ConnectionFactory) {\n    // Use the connection factory in our service\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe platform will handle the injection of \u003ccode\u003econnectionFactory\u003c/code\u003e automatically, and it doesn’t matter what order you reference your modules in. The same injection works with dependencies referenced from your file configuration, so you can chain them together to construct more complex dependency trees.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt’s important to note that, since this injection relies on type reflection, it will only be available for the JVM.\u003c/p\u003e\n\n\n\n\u003ch3\u003eTesting with DI\u003c/h3\u003e\n\n\n\n\u003cp\u003eOne major advantage of decoupling your modules is that it simplifies testing.\u003c/p\u003e\n\n\n\n\u003cp\u003eUsing the DI plugin in Ktor 3.2, you can mock out components with ease:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun `can fetch messages`() = testApplication {\n    // replace the production implementation with a mock\n    dependencies { \n        provide { MockConnectionFactory() }\n    }\n    // load modules from your default application.conf\n    configure()\n    \n    val messageList: List\u0026lt;Message\u0026gt; = client.get(\u0026#34;/messages\u0026#34;).body()\n    assertEquals(listOf(expectedMessage), messageList)\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis works by providing an alternative conflict policy in the test application context, so initial dependencies are retained. All you need to remember is that your mocks should go in \u003cstrong\u003ebefore\u003c/strong\u003e your production modules.\u003c/p\u003e\n\n\n\n\u003ch2\u003eScaling with DI\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow that we have a reliable way to share code between modules, we can easily start splitting our projects into small Gradle modules. Instead of keeping all of our server logic in a single project, we can isolate different integration points, providing the opportunity to use domain-centric architectures, like the \u003ca href=\"https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)\" target=\"_blank\" rel=\"noopener\"\u003ehexagonal\u003c/a\u003e or \u003ca href=\"https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html\" target=\"_blank\" rel=\"noopener\"\u003eclean\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf we continue with our previous example, we can consider excluding the \u003ccode\u003epostgres\u003c/code\u003e connection factory from our compilation classpath entirely.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s say we have a project structure like this:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"raw\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003edb\n├─ core\n├─ postgres\n└─ mongo\n\nserver\n├─ core\n├─ admin\n└─ banking\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow, we can share some common server modules under \u003ccode\u003eserver/core\u003c/code\u003e and focus more strictly on domain logic in our smaller services.\u003c/p\u003e\n\n\n\n\u003cp\u003eUnder \u003ccode\u003eserver/banking\u003c/code\u003e, for example, our \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e file would look like this:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eplugins {\n    id(\u0026#34;io.ktor.plugin\u0026#34;) version \u0026#34;3.2.0\u0026#34;\n}\ndependencies {\n    implementation(\u0026#34;:server:core\u0026#34;)\n    implementation(\u0026#34;:db:core\u0026#34;)\n    runtimeOnly(\u0026#34;:db:postgres\u0026#34;)\n    runtimeOnly(\u0026#34;:db:mongo\u0026#34;)\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eThen we can defer choosing our storage implementation right up until our application is deployed and reads the configuration file.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor this, we simply edit \u003ccode\u003eapplication.yaml\u003c/code\u003e like so:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"yaml\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003ektor:\n  application:\n    dependencies:\n      # Taken from modules db/*\n      - com.example.MockConnectionFactory\n      # - com.example.MongoConnectionFactory\n      # - com.example.PostgresConnectionFactory\n    modules:\n      # Taken from server/core\n      - com.example.Authentication.configureAuth\n      # My domain service\n      - com.example.Banking.configureBankRoutes\u003c/pre\u003e\n\n\n\n\u003cp\u003eSince the implementations are hidden from our compile classpath, we can avoid polluting our services with implementation details while introducing several options for how our application operates.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWrapping up\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn this article, we’ve covered the basics of working with modules in Ktor and how to leverage dependency injection tools for sharing code between them.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo summarize:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eKtor modules are replaceable extension functions for the \u003ccode\u003eApplication\u003c/code\u003e class.\u003c/li\u003e\n\n\n\n\u003cli\u003eModules can be used to manage complexity in a growing application.\u003c/li\u003e\n\n\n\n\u003cli\u003eCode can be shared between modules indirectly via attributes or a DI library.\u003c/li\u003e\n\n\n\n\u003cli\u003eKtor now includes a robust DI plugin out of the box.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eHere is an example of a project that uses the new tooling:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://github.com/ktorio/ktor-chat/tree/dependency-injection-preview\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/ktorio/ktor-chat/\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you have any thoughts on any of the topics in this article, you can leave a comment here or find us in the \u003ca href=\"https://app.slack.com/client/T09229ZC6/C0A974TJ9\" target=\"_blank\" rel=\"noopener\"\u003eofficial Kotlin Slack channel\u003c/a\u003e.\u003c/p\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to Kotlin Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": null,
  "modifiedTime": null
}
