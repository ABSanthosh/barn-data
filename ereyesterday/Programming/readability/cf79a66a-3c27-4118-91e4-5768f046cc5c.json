{
  "id": "cf79a66a-3c27-4118-91e4-5768f046cc5c",
  "title": "Tutorial: Advanced use case for GitLab Pipeline Execution Policies",
  "link": "https://about.gitlab.com/blog/2025/01/22/tutorial-advanced-use-case-for-gitlab-pipeline-execution-policies",
  "description": "",
  "author": "Dan Rabinovitz",
  "published": "2025-01-22T00:00:00.000Z",
  "source": "https://about.gitlab.com/atom.xml",
  "categories": null,
  "byline": "Dan Rabinovitz",
  "length": 9013,
  "excerpt": "Learn how new GitLab Ultimate functionality can enforce a standardized pipeline across an organization for improved compliance.",
  "siteName": "GitLab",
  "favicon": "https://about.gitlab.com/blog/nuxt-images/ico/favicon-192x192.png?cache=2022041",
  "text": "Pipeline execution policies are a newer addition to the GitLab DevSecOps platform and a powerful mechanism to enforce CI/CD jobs across applicable projects. They enable platform engineering or security teams to inject jobs into developers’ YAML pipeline definition files, guaranteeing that certain CI/CD jobs will execute no matter what a developer defines in their `.gitlab-ci.yml` file. This article will explain how to utilize pipeline execution policies to create guardrails around the stages or jobs that a developer can use in their pipeline definition. In regulated environments, this may be necessary to ensure developers adhere to a standard set of jobs or stages in their GitLab pipeline. Any job or stage that a developer adds to their pipeline that does not adhere to a corporate standard will cause the pipeline to fail. One example use case for pipeline execution policies is ensuring a security scanner job runs. Let’s say an organization has made an investment in a third-party security scanner and they have a requirement that the external scan runs before any merge is made into the main branch. Without a pipeline execution policy, a developer could easily skip this step by not including the required code in their .gitlab-ci.yml file. With a pipeline execution policy in place, a security team can guarantee the external security scanning job executes regardless of how a developer defines their pipeline. To use pipeline execution policies to enforce these restrictions requires two parts: a shell script to make calls to the GitLab API and the policy itself. This tutorial uses a bash script; if your runner uses a different scripting language, it is easy to adapt to other languages. Here is the example shell script I will use for this exercise: #!/bin/bash echo \"Checking pipeline stages and jobs...\" # Pull the group access token from the environment variable GROUP_ACCESS_TOKEN=\"$PIPELINE_TOKEN\" echo \"PROJECT_ID: $PROJECT_ID\" echo \"PIPELINE_ID: $PIPELINE_ID\" if [ -z \"$GROUP_ACCESS_TOKEN\" ]; then echo \"GROUP_ACCESS_TOKEN (MR_GENERATOR) is not set\" exit 1 fi if [ -z \"$PROJECT_ID\" ]; then echo \"PROJECT_ID is not set\" exit 1 fi if [ -z \"$PIPELINE_ID\" ]; then echo \"PIPELINE_ID is not set\" exit 1 fi # Use the group access token for the API request api_url=\"$GITLAB_API_URL/projects/$PROJECT_ID/pipelines/$PIPELINE_ID/jobs\" echo \"API URL: $api_url\" # Fetch pipeline jobs using the group access token jobs=$(curl --silent --header \"PRIVATE-TOKEN: $GROUP_ACCESS_TOKEN\" \"$api_url\") echo \"Fetched Jobs: $jobs\" if [[ \"$jobs\" == *\"404 Project Not Found\"* ]]; then echo \"Failed to authenticate with GitLab API: Project not found\" exit 1 fi # Extract stages and jobs pipeline_stages=$(echo \"$jobs\" | grep -o '\"stage\":\"[^\"]*\"' | cut -d '\"' -f 4 | sort | uniq | tr '\\n' ',') pipeline_jobs=$(echo \"$jobs\" | grep -o '\"name\":\"[^\"]*\"' | cut -d '\"' -f 4 | sort | uniq | tr '\\n' ',') echo \"Pipeline Stages: $pipeline_stages\" echo \"Pipeline Jobs: $pipeline_jobs\" # Check if pipeline stages are approved for stage in $(echo $pipeline_stages | tr ',' ' '); do echo \"Checking stage: $stage\" if ! [[ \",$APPROVED_STAGES,\" =~ \",$stage,\" ]]; then echo \"Stage $stage is not approved.\" exit 1 fi done # Check if pipeline jobs are approved for job in $(echo $pipeline_jobs | tr ',' ' '); do echo \"Checking job: $job\" if ! [[ \",$APPROVED_JOBS,\" =~ \",$job,\" ]]; then echo \"Job $job is not approve Let’s break this down a bit. The first few lines of this code perform some sanity checks, ensuring that a pipeline ID, project ID, and group access token exist. A GitLab pipeline ID is a unique numerical identifier that GitLab automatically assigns to each pipeline run. A GitLab project ID is a unique numerical identifier assigned to each project in GitLab. A GitLab group access token is a token that authenticates and authorizes access to resources at the group level in GitLab. This is in contrast to a GitLab personal access token (PAT), which is unique to each user. The bulk of the work comes from the GitLab Projects API call where the script requests the jobs for the specified pipeline. Once you have job information for the currently running pipeline, you can use a simple grep command to parse out stage and job names, and store them in variables for comparison. The last portion of the script checks to see if pipeline stages and jobs are on the approved list. Where do these parameters come from? This is where GitLab Pipeline Execution Policies come into play. They enable injection of YAML code into a pipeline. How can we leverage injected YAML to execute this shell script? Here’s a code snippet showing how to do this. ## With this config, the goal is to create a pre-check job that evaluates the pipeline and fails the job/pipeline if any checks do not pass variables: GITLAB_API_URL: \"https://gitlab.com/api/v4\" PROJECT_ID: $CI_PROJECT_ID PIPELINE_ID: $CI_PIPELINE_ID APPROVED_STAGES: \".pipeline-policy-pre,pre_check,build,test,deploy\" APPROVED_JOBS: \"pre_check,build_job,test_job,deploy_job\" pre_check: stage: .pipeline-policy-pre script: - curl -H \"PRIVATE-TOKEN:${REPO_ACCESS_TOKEN}\" --url \"https://\u003cgitlab_URL\u003e/api/v4/projects/\u003cproject_id\u003e/repository/files/check_settings.sh/raw\" -o pre-check.sh - ls -l - chmod +x pre-check.sh - DEBUG_MODE=false ./pre-check.sh # Set DEBUG_MODE to true or false allow_failure: true In this YAML snippet, we set a few variables used in the shell script. Most importantly, this is where approved stages and approved jobs are defined. After the variables section, we then add a new job to the .pipeline-policy-pre stage. This is a reserved stage for pipeline execution policies and is guaranteed to execute before any stages defined in a .gitlab-ci.yml file. There is a corresponding .pipeline-policy-post stage as well, though we will not be using it in this scenario. The script portion of the job does the actual work. Here, we leverage a curl command to execute the shell script defined above. This example includes authentication if it’s located in a private repository. However, if it’s publicly accessible, you can forgo this authentication. The last line controls whether or not the pipeline will fail. In this example, the pipeline will continue. This is useful for testing – in practice, you would likely set allow_failure: false to cause the pipeline to fail. This is desired as the goal of this exercise is to not allow pipelines to continue execution if a developer adds a rogue job or stage. To utilize this YAML, save it to a .yml file in a repository of your choice. We’ll see how to connect it to a policy shortly. Now, we have our script and our YAML to inject into a developer’s pipeline. Next, let’s see how to put this together using a pipeline execution policy. Like creating other policies in GitLab, start by creating a new Pipeline Execution Policy by navigating to Secure \u003e Policies in the left hand navigation menu. Then, choose New Policy at the top right, and select Pipeline Execution Policy from the policy creation options. For this exercise, you can leave the Policy Scope set to the default options. In the Actions section, be sure to choose Inject and select the project and file where you’ve saved your YAML code snippet. Click on Update via Merge Request at the very bottom to create an MR that you can then merge into your project. If this is your first security policy, clicking on Merge in the MR will create a Security Policy Project, which is a project to store all security policies. When implementing any type of security policy in a production environment, access to this project should be restricted so developers cannot make changes to security policies. In fact, you may also want to consider storing YAML code that’s used by pipeline execution policies in this project to restrict access as well, though this is not a requirement. Executing a pipeline where this pipeline execution policy is enabled should result in the following output when you attempt to add an invalid stage to the project .gitlab-ci.yml file. While this use case is very focused on one aspect of security and compliance in your organization, this opens the door to other use cases. For example, you may want to make group-level variables accessible to every project within a group; this is possible with pipeline execution policies. Or, you may want to create a golden pipeline and have developers add to it. The possibilities are endless. GitLab customers are finding new and exciting ways to use this new functionality every day. If you’re a GitLab Ultimate customer, try this out today and let us know how you’re using pipeline execution policies. Not a GitLab Ultimate customer? Sign up for a free 60-day trial to get started. Read more How to integrate custom security scanners into GitLab Integrate external security scanners into your DevSecOps workflow Why GitLab is deprecating compliance pipelines in favor of security policies",
  "image": "https://images.ctfassets.net/r9o86ar0p03f/3Ldy1urjMStQCl4qnOBvE0/1cdde9c89eef7a81d19057ad22ab371e/AdobeStock_397632156.jpeg?fm=webp\u0026w=820\u0026h=500",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-v-37f1022b=\"\" data-v-53094866=\"\" data-v-74bd29c6=\"\"\u003e\u003cp\u003e\u003ca href=\"https://docs.gitlab.com/ee/user/application_security/policies/pipeline_execution_policies.html\"\u003ePipeline execution policies\u003c/a\u003e are a newer addition to the GitLab DevSecOps platform and a powerful mechanism to enforce CI/CD jobs across applicable projects. They enable platform engineering or security teams to inject jobs into developers’ YAML pipeline definition files, guaranteeing that certain CI/CD jobs will execute no matter what a developer defines in their `.gitlab-ci.yml` file.\u003c/p\u003e\n\u003cp\u003eThis article will explain how to utilize pipeline execution policies to create guardrails around the stages or jobs that a developer can use in their pipeline definition. In regulated environments, this may be necessary to ensure developers adhere to a standard set of jobs or stages in their GitLab pipeline. Any job or stage that a developer adds to their pipeline that does not adhere to a corporate standard will cause the pipeline to fail.\u003c/p\u003e\n\u003cp\u003eOne example use case for pipeline execution policies is ensuring a security scanner job runs. Let’s say an organization has made an investment in a third-party security scanner and they have a requirement that the external scan runs before any merge is made into the main branch. Without a pipeline execution policy, a developer could easily skip this step by not including the required code in their \u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e file.  With a pipeline execution policy in place, a security team can guarantee the external security scanning job executes regardless of how a developer defines their pipeline.\u003c/p\u003e\n\u003cp\u003eTo use pipeline execution policies to enforce these restrictions requires two parts: a shell script to make calls to the GitLab API and the policy itself. This tutorial uses a bash script; if your runner uses a different scripting language, it is easy to adapt to other languages.\u003c/p\u003e\n\u003cp\u003eHere is the example shell script I will use for this exercise:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#!/bin/bash\n\necho \u0026#34;Checking pipeline stages and jobs...\u0026#34;\n\n# Pull the group access token from the environment variable\nGROUP_ACCESS_TOKEN=\u0026#34;$PIPELINE_TOKEN\u0026#34;\n\necho \u0026#34;PROJECT_ID: $PROJECT_ID\u0026#34;\necho \u0026#34;PIPELINE_ID: $PIPELINE_ID\u0026#34;\n\nif [ -z \u0026#34;$GROUP_ACCESS_TOKEN\u0026#34; ]; then  \n  echo \u0026#34;GROUP_ACCESS_TOKEN (MR_GENERATOR) is not set\u0026#34;\n  exit 1\nfi\n\nif [ -z \u0026#34;$PROJECT_ID\u0026#34; ]; then\n  echo \u0026#34;PROJECT_ID is not set\u0026#34;\n  exit 1\nfi\n\nif [ -z \u0026#34;$PIPELINE_ID\u0026#34; ]; then\n  echo \u0026#34;PIPELINE_ID is not set\u0026#34;\n  exit 1\nfi\n\n# Use the group access token for the API request\napi_url=\u0026#34;$GITLAB_API_URL/projects/$PROJECT_ID/pipelines/$PIPELINE_ID/jobs\u0026#34;\necho \u0026#34;API URL: $api_url\u0026#34;\n\n# Fetch pipeline jobs using the group access token\njobs=$(curl --silent --header \u0026#34;PRIVATE-TOKEN: $GROUP_ACCESS_TOKEN\u0026#34; \u0026#34;$api_url\u0026#34;)\necho \u0026#34;Fetched Jobs: $jobs\u0026#34;\n\nif [[ \u0026#34;$jobs\u0026#34; == *\u0026#34;404 Project Not Found\u0026#34;* ]]; then\n  echo \u0026#34;Failed to authenticate with GitLab API: Project not found\u0026#34;\n  exit 1\nfi\n\n# Extract stages and jobs\npipeline_stages=$(echo \u0026#34;$jobs\u0026#34; | grep -o \u0026#39;\u0026#34;stage\u0026#34;:\u0026#34;[^\u0026#34;]*\u0026#34;\u0026#39; | cut -d \u0026#39;\u0026#34;\u0026#39; -f 4 | sort | uniq | tr \u0026#39;\\n\u0026#39; \u0026#39;,\u0026#39;)\npipeline_jobs=$(echo \u0026#34;$jobs\u0026#34; | grep -o \u0026#39;\u0026#34;name\u0026#34;:\u0026#34;[^\u0026#34;]*\u0026#34;\u0026#39; | cut -d \u0026#39;\u0026#34;\u0026#39; -f 4 | sort | uniq | tr \u0026#39;\\n\u0026#39; \u0026#39;,\u0026#39;)\n\necho \u0026#34;Pipeline Stages: $pipeline_stages\u0026#34;  \necho \u0026#34;Pipeline Jobs: $pipeline_jobs\u0026#34;\n\n# Check if pipeline stages are approved\nfor stage in $(echo $pipeline_stages | tr \u0026#39;,\u0026#39; \u0026#39; \u0026#39;); do \n  echo \u0026#34;Checking stage: $stage\u0026#34;\n  if ! [[ \u0026#34;,$APPROVED_STAGES,\u0026#34; =~ \u0026#34;,$stage,\u0026#34; ]]; then\n    echo \u0026#34;Stage $stage is not approved.\u0026#34;\n    exit 1\n  fi\ndone\n\n# Check if pipeline jobs are approved \nfor job in $(echo $pipeline_jobs | tr \u0026#39;,\u0026#39; \u0026#39; \u0026#39;); do\n  echo \u0026#34;Checking job: $job\u0026#34;\n  if ! [[ \u0026#34;,$APPROVED_JOBS,\u0026#34; =~ \u0026#34;,$job,\u0026#34; ]]; then\n    echo \u0026#34;Job $job is not approve\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s break this down a bit.\u003c/p\u003e\n\u003cp\u003eThe first few lines of this code perform some sanity checks, ensuring that a pipeline ID, project ID, and group access token exist.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA GitLab pipeline ID is a unique numerical identifier that GitLab automatically assigns to each pipeline run.\u003c/li\u003e\n\u003cli\u003eA GitLab project ID is a unique numerical identifier assigned to each project in GitLab.\u003c/li\u003e\n\u003cli\u003eA GitLab group access token is a token that authenticates and authorizes access to resources at the group level in GitLab. This is in contrast to a GitLab personal access token (PAT), which is unique to each user.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe bulk of the work comes from the \u003ca href=\"https://docs.gitlab.com/ee/api/projects.html\"\u003eGitLab Projects API\u003c/a\u003e call where the script requests the jobs for the specified pipeline. Once you have job information for the currently running pipeline, you can use a simple grep command to parse out stage and job names, and store them in variables for comparison. The last portion of the script checks to see if pipeline stages and jobs are on the approved list. Where do these parameters come from?\u003c/p\u003e\n\u003cp\u003eThis is where \u003ca href=\"https://docs.gitlab.com/ee/user/application_security/policies/pipeline_execution_policies.html\"\u003eGitLab Pipeline Execution Policies\u003c/a\u003e come into play. They enable injection of YAML code into a pipeline. How can we leverage injected YAML to execute this shell script?  Here’s a code snippet showing how to do this.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e## With this config, the goal is to create a pre-check job that evaluates the pipeline and fails the job/pipeline if any checks do not pass\n\nvariables:\n  GITLAB_API_URL: \u0026#34;https://gitlab.com/api/v4\u0026#34;\n  PROJECT_ID: $CI_PROJECT_ID\n  PIPELINE_ID: $CI_PIPELINE_ID\n  APPROVED_STAGES: \u0026#34;.pipeline-policy-pre,pre_check,build,test,deploy\u0026#34;\n  APPROVED_JOBS: \u0026#34;pre_check,build_job,test_job,deploy_job\u0026#34;\n\npre_check:\n  stage: .pipeline-policy-pre\n  script:\n    - curl -H \u0026#34;PRIVATE-TOKEN:${REPO_ACCESS_TOKEN}\u0026#34; --url \u0026#34;https://\u0026lt;gitlab_URL\u0026gt;/api/v4/projects/\u0026lt;project_id\u0026gt;/repository/files/check_settings.sh/raw\u0026#34; -o pre-check.sh\n    - ls -l\n    - chmod +x pre-check.sh\n    - DEBUG_MODE=false ./pre-check.sh  # Set DEBUG_MODE to true or false\n  allow_failure: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this YAML snippet, we set a few variables used in the shell script. Most importantly, this is where approved stages and approved jobs are defined. After the \u003ccode\u003evariables\u003c/code\u003e section, we then add a new job to the \u003ccode\u003e.pipeline-policy-pre\u003c/code\u003e stage. This is a reserved stage for pipeline execution policies and is guaranteed to execute before any stages defined in a \u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e file.  There is a corresponding \u003ccode\u003e.pipeline-policy-post\u003c/code\u003e stage as well, though we will not be using it in this scenario.\u003c/p\u003e\n\u003cp\u003eThe script portion of the job does the actual work. Here, we leverage a curl command to execute the shell script defined above. This example includes authentication if it’s located in a private repository. However, if it’s publicly accessible, you can forgo this authentication. The last line controls whether or not the pipeline will fail. In this example, the pipeline will continue. This is useful for testing – in practice, you would likely set \u003ccode\u003eallow_failure: false\u003c/code\u003e to cause the pipeline to fail. This is desired as the goal of this exercise is to not allow pipelines to continue execution if a developer adds a rogue job or stage.\u003c/p\u003e\n\u003cp\u003eTo utilize this YAML, save it to a \u003ccode\u003e.yml\u003c/code\u003e file in a repository of your choice. We’ll see how to connect it to a policy shortly.\u003c/p\u003e\n\u003cp\u003eNow, we have our script and our YAML to inject into a developer’s pipeline. Next, let’s see how to put this together using a pipeline execution policy.\u003c/p\u003e\n\u003cp\u003eLike creating other policies in GitLab, start by creating a new Pipeline Execution Policy by navigating to \u003cstrong\u003eSecure \u0026gt; Policies\u003c/strong\u003e in the left hand navigation menu. Then, choose \u003cstrong\u003eNew Policy\u003c/strong\u003e at the top right, and select \u003cstrong\u003ePipeline Execution Policy\u003c/strong\u003e from the policy creation options.\u003c/p\u003e\n\u003cp\u003eFor this exercise, you can leave the \u003cstrong\u003ePolicy Scope\u003c/strong\u003e set to the default options. In the \u003cstrong\u003eActions\u003c/strong\u003e section, be sure to choose \u003cstrong\u003eInject\u003c/strong\u003e and select the project and file where you’ve saved your YAML code snippet. Click on \u003cstrong\u003eUpdate via Merge Request\u003c/strong\u003e at the very bottom to create an MR that you can then merge into your project.\u003c/p\u003e\n\u003cp\u003eIf this is your first security policy, clicking on \u003cstrong\u003eMerge\u003c/strong\u003e in the MR will create a \u003ca href=\"https://docs.gitlab.com/ee/user/application_security/policies/vulnerability_management_policy.html\"\u003eSecurity Policy Project\u003c/a\u003e, which is a project to store all security policies. When implementing any type of security policy in a production environment, \u003ca href=\"https://docs.gitlab.com/ee/user/project/members/\"\u003eaccess to this project should be restricted\u003c/a\u003e so developers cannot make changes to security policies. In fact, you may also want to consider storing YAML code that’s used by pipeline execution policies in this project to restrict access as well, though this is not a requirement.\u003cbr/\u003e\nExecuting a pipeline where this pipeline execution policy is enabled should result in the following output when you attempt to add an invalid stage to the project \u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e file.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://images.ctfassets.net/r9o86ar0p03f/5ahf1xaxSEDbT5rKGc2T0C/19340d225c9581569a6804a771f236da/image1.png\" alt=\"Output of attempting an invalid stage to project gitlab-ci.yml file\"/\u003e\u003c/p\u003e\n\u003cp\u003eWhile this use case is very focused on one aspect of security and compliance in your organization, this opens the door to other use cases. For example, you may want to make group-level variables accessible to every project within a group; this is possible with pipeline execution policies. Or, you may want to create a golden pipeline and have developers add to it. The possibilities are endless. GitLab customers are finding new and exciting ways to use this new functionality every day.\u003c/p\u003e\n\u003cp\u003eIf you’re a GitLab Ultimate customer, try this out today and let us know how you’re using pipeline execution policies. Not a GitLab Ultimate customer? \u003ca href=\"https://about.gitlab.com/free-trial/devsecops/\"\u003eSign up for a free 60-day trial\u003c/a\u003e to get started.\u003c/p\u003e\n\u003ch2 id=\"read-more\" tabindex=\"-1\"\u003eRead more \u003ca href=\"#read-more\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://about.gitlab.com/blog/2024/02/27/how-to-integrate-custom-security-scanners-into-gitlab/\"\u003eHow to integrate custom security scanners into GitLab\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://about.gitlab.com/blog/2024/04/08/integrate-external-security-scanners-into-your-devsecops-workflow/\"\u003eIntegrate external security scanners into your DevSecOps workflow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://about.gitlab.com/blog/2024/10/01/why-gitlab-is-deprecating-compliance-pipelines-in-favor-of-security-policies/\"\u003eWhy GitLab is deprecating compliance pipelines in favor of security policies\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2025-01-22T00:00:00Z",
  "modifiedTime": null
}
