{
  "id": "3760583f-90fb-4fb3-acb3-5350de6dc0ec",
  "title": "Migration Automation: Easing the Jenkins → GHA shift with help from AI",
  "link": "https://slack.engineering/migration-automation-easing-the-jenkins-%e2%86%92-gha-shift-with-help-from-ai/",
  "description": "Overview The past few months have been exciting times for Slack’s CI infrastructure. After years of developer frustration with Jenkins (everything from security issues to downtime to generally poor UX) internal pressure led us to move a majority of Slack’s CI jobs from Jenkins to GitHub Actions.  My intern project at Slack this summer involved… The post Migration Automation: Easing the Jenkins → GHA shift with help from AI appeared first on Engineering at Slack.",
  "author": "Zhengyu Shen",
  "published": "Mon, 16 Dec 2024 09:00:03 +0000",
  "source": "https://slack.engineering/feed",
  "categories": [
    "Uncategorized",
    "ci-cd",
    "devops",
    "devtools",
    "machine-learning"
  ],
  "byline": "",
  "length": 16887,
  "excerpt": "Overview The past few months have been exciting times for Slack’s CI infrastructure. After years of developer frustration with Jenkins (everything from security issues to downtime to generally poor UX) internal pressure led us to move a majority of Slack’s CI jobs from Jenkins to GitHub Actions. My intern project at Slack this summer involved…",
  "siteName": "Engineering at Slack",
  "favicon": "https://slack.engineering/wp-content/uploads/sites/7/2020/05/cropped-octothrope-1.png?w=192",
  "text": "Overview The past few months have been exciting times for Slack’s CI infrastructure. After years of developer frustration with Jenkins (everything from security issues to downtime to generally poor UX) internal pressure led us to move a majority of Slack’s CI jobs from Jenkins to GitHub Actions.  My intern project at Slack this summer involved creating a conversion tool that could automatically migrate Jenkins pipelines to GitHub Actions, saving developers time and accelerating the migration. The project was successful, and is expected to cut the migration time by half and save over 1,300 hours. This blog is focused on that conversion tool, and the 7 week journey to design, implement, and improve it.  Before we start though, you should know some terminology: Pipeline: A set of Jenkins plugins used for organizing Jenkins jobs. “Jenkins pipeline” refers to a set of one or more ordered Jenkins jobs. At the beginning of this project we had242 Jenkins pipelines to migrate. Instance: A Jenkins instance is where Jenkins pipelines are hosted. We were migrating off of 3 Jenkins instances. Workflow: a GitHub Actions CI job. GHA: GitHub Actions. Planning for the Project Pondering the Problem The success criteria for the project are as follows: Create tooling that automates the difficulties of manually migrating a Jenkins pipeline to GHA Run this tooling on a large subset of existing Jenkins jobs Create documentation around the conversion process  Tools of the Trade After doing some research, we identified a few useful tools to use to convert from Jenkins to GHA: The GitHub Actions Importer. GitHub publishes a tool that can audit a Jenkins instance and either fully convert, partially convert, or fail to convert all pipelines on it to GitHub Actions. Although generally most pipelines fully convert, not all do. So a few more tools will be needed after using the Importer. Python scripting: It seemed likely that some amount of the Importer’s errors would be easy to fix with just regex scripts. We expected to use Large Language Models (LLMs) for any errors that were too intricate to fix with regular expressions. The Solution Part 1 – The Importer Over the span of a week, we ran the Importer on several of our Jenkins instances. The tool was simple. You install it from the GitHub CLI, configure it, and run a command like this: gh actions-importer audit jenkins --output-dir \u003coutput-dir\u003e The Importer would then output GitHub Actions workflow files for each Jenkins pipeline on the Jenkins instance being audited. Upon running the Importer, we were curious as to how well it performed. Fortunately, the Importer creates an audit summary upon completing its audit of a Jenkins instance. The audit file contains information about how many Jenkins jobs were fully converted, partially converted, and failed to convert from Jenkins to GHA. About 50% of the time the Importer moved the pipeline from Jenkins to GHA without error. 5% of the time the importer failed completely, and the rest of the jobs were partially-imported — it created a workflow YAML file, but wasn’t able to populate it fully. In addition to the success and failure rates, we were curious as to exactly what Jenkins build steps and environments were unsupported by the Importer. Fortunately the audit summaries contain information about this as well. Glancing at the audit summary, it was initially concerning to see that there were hundreds of Jenkins pipelines that weren’t able to fully convert to GitHub Actions. A deeper inspection revealed a pleasant surprise – only eight unsupported Jenkins build steps and environments were responsible for over 90% of those failures. This was good news. Instead of needing to spread ourselves thin looking at dozens of unsupported Jenkins steps, we instead only had to look at eight. For those key few unsupported items, we’d need to look at the following: Is this actually unsupported by GHA, or do equivalents exist? If equivalents do exist, is it easy to write scripts to edit the Importer’s outputs accordingly? Part 2 – Research At this point in the project, it was known that the Importer’s workflows had a lot of room for improvement. Around half of the pipelines didn’t fully convert, so a big objective was to look into the unsupported Jenkins steps that caused them to not fully convert. Another task though was to investigate the pipelines that fully converted. Can we really trust the Importer when it claims that it could fully convert something? So really every pipeline that got (or didn’t get) converted to a workflow had to be looked at.  After looking through several dozen of the YAML files the Importer made, it was clear that there were 4 main types of corrections we’d need to make to the workflow YAML files: Replacing rate-limited actions with internal mirrors  Replacing actions with other actions Adding useful comments for end users  Removing unnecessary comments Over the course of 2 weeks, we studied each of these: 1 – Replacing rate limited actions with internal mirrors RoI: Very High Overview By default, if you use an arbitrary action from the GitHub Actions marketplace, like say actions/github-script, any requests made by the action will hit the github.com API. There are rate limits for this. Actions that hit our self-hosted GitHub Enterprise instance have far higher rate limits however. So a task we had to do was replace rate-limited actions with internal mirrors of those actions that we have on our GitHub Enterprise instance. End-User Value Correcting rate-limited actions is simple to do on our end, and prevents end users from dealing with the headache that is having jobs fail from rate limits. So high RoI here. 2 – Replacing actions with other actions RoI: High Overview There were a few instances where, to perform a certain task, the Importer would use one action whereas we’d prefer if it had used another. For instance, for sending Slack messages the Importer often elected to use the rtCamp/action-slack-notify action. Naturally, Slack has internal actions for sending Slack messages, and we’d rather use internal libraries for this purpose. So something to look into was replacing rtCamp/action-slack-notify with Slack’s internal messaging action. This type of task seemed suitable for an LLM to do, since two actions often have disparate syntax which is hard to convert between by just using Python’s string methods. Preliminary testing also showed perfect LLM performance for this task which was reassuring. End-User Value Replacing one action with a different action would require end users to know both actions well. So automating this saves quite a bit of time and effort on their end, and it’s not that hard to write LLM prompts for these tasks. The RoI is thus high. 3 – Adding Useful Comments for End Users RoI: Medium Overview Some action items in the workflow files could only be done manually. For example, the syntax used in the workflow files to access secrets assumed that the secrets would be stored on GitHub. However, we don’t store our secrets on GitHub, and it would be time prohibitive and against our security policies to move them to GitHub. It would instead be better for end users to edit the workflow files such that secrets get read from where we store them instead of from GitHub. This couldn’t really be automated on the conversion tool side, since only the end users know where their secrets are and how to access them. All the conversion tool could do in such situations was leave a comment like: “Change these lines so that secrets are being read from where we store them instead of from GitHub. Go to a certain slack channel to find relevant docs about this.” End-User Value It’s definitely useful for end users to know where they should look to fix problems, but they still have to do the actual work of fixing the problem. So overall, medium RoI.  4 – Removing Unnecessary Comments RoI: Low-medium Overview Recall that around 45% of pipelines only partially converted. What this means is that the Importer couldn’t find a GHA equivalent for a Jenkins environment or build step. When this happened, the Importer left a comment in the workflow that looked something like “X Jenkins item was unsupported.”  As it turns out, the reason why a lot of Jenkins pipelines were unsupported is because that piece of functionality in Jenkins was either already included or not necessary in GHA. So most of those “X was unsupported” comments weren’t too important and would probably be better off removed. End-User Value The benefits here to end users was small, as all it really does is declutter the workflows. So overall this had a low return. However, a script to delete strings is also very easy to write. So overall low-medium RoI. Part 3 – Corrections Tool Overview The last part of the implementation is the corrections tool, which would correct the Importer’s workflows. We knew from the start that the tool would have a balance of using Python’s string methods and using LLMs. From the last section, note that out of the 4 categories of action items for the correction tool, the only one that needed AI was “replacing actions with other actions”. So the corrections tool was largely non-AI. It took around 3 weeks to make the corrections tool. Implementation Architecture Here’s the bird’s-eye view. The input to the corrections tool was the path to a directory containing workflow yaml files. The following chain of events then happened: The path to each yaml file in that directory was written to an array. Then, for each element in that array: The contents of the yaml file at that path were read. Then: Every relevant non-AI correction was made to those file contents, and written back to the original file Every relevant AI correction was made to those file contents, and written back to the original file The end result is that every yaml file in the directory inputted to the corrections tool was edited in place. Implementing the Non-AI Corrections As mentioned previously, a large part of what needed to happen to the Importer’s yaml files boiled down to “add a comment after a line containing a certain string” or “replace a string with another string”. Python’s String.replace() method was used extensively here.  Implementing the AI Corrections Prompt engineering is both science and art. It’s science, because there’s a formula that’s useful for doing prompt engineering: Use the following structure: Context Setting (let the LLM know what the task is and why it’s doing it) Specific Steps (Several instructions, each about very specific individual tasks the LLM must do. Too long of a prompt is much less dangerous than too vague of a prompt) Output Instructions (Instructions about how the LLM should present its output) In the context setting part of the prompt, include any relevant syntax and documentation Prompt engineering is also art, because experimenting with the prompt and seeing how you feel about the AI’s output is a key part too. There were a few rounds of this process: Start with a very basic prompt See the LLM’s response to it Add detail and context to the prompt to prevent any errors the LLM made An example of a prompt we’d end up at: I’m going to provide you with a GitHub Actions workflow yaml file. In the file an action called rtCamp/action-slack-notify@v2.2.1 is being used. Your job is to replace every rtCamp/action-slack-notify@v2.2.1 action with the slack/message-action@v1.0 action, and output the resulting workflow yaml file. For reference, I will provide you with the syntax for the slack/message-action@v1.0 action. I’ll put it between \u003csyntax\u003e\u003c/syntax\u003e XML tags: \u003csyntax\u003e - uses: slack/message-action@v1.0   with:    channel: channel-name    text: text-message \u003c/syntax\u003e Now, perform the following steps: Find every instance of the rtCamp/action-slack-notify@v2.2.1 action being used. Replace each instance with the slack/message-action@v1.0 action with the aforementioned syntax. Replace channel-name with the value of the SLACK_CHANNEL field in the rtCamp/action-slack-notify@v2.2.1 action. Replace text-message with the value of the SLACK_MESSAGE field in the rtCamp/action-slack-notify@v2.2.1 action. Also, there are a few things you should absolutely never do: Do not remove any comments from the file Do not alter any other action in the file besides rtCamp/action-slack-notify@v2.2.1 I will now provide you with the workflow file you will be making edits to between \u003cworkflow\u003e\u003c/workflow\u003e XML tags. When providing your output, only provide the contents of a YAML file. Do not describe what you did. Do not provide any justifications for your decisions. Only provide the corrected GitHub Actions yaml file, with nothing else before or after the yaml file in your output. Now, please perform the instructions I gave you: We examined about 2 dozen of the LLM’s outputs and noticed something stunning — 100% accuracy in performing the requested tasks. A big concern with asking LLMs to do these corrections were hallucinations and other unexpected side effects, so seeing the LLM’s performance was reassuring. Overall, the LLM ended up being really useful for the migration. Even though prompt engineering isn’t trivial, it doesn’t take that long either, and after doing it the LLM could perform as well as any human for these “replace A with B” tasks. LLMs filled a crucial gap for fixing those errors that were too hard to fix with Python’s string methods. Impact and End User Feedback Impact First, consider the process of converting a pipeline from Jenkins to GHA manually: Looking at your Jenkins pipeline as a reference, write a GHA workflow yaml file. Test that workflow yaml and do debugging as needed. Write the documentation for the workflow. Delete the pipeline from its Jenkins instance. Note how the steps are in descending order of difficulty and time cost.  The conversion tool lets end users skip step 1 entirely and have a much easier time with step 2. End users are given workflow files that have few, if any, flaws. They can skip straight to debugging, which will be accelerated since the workflows they get are highly accurate. There are about 242 pipelines that this tool attempted to convert from Jenkins to GitHub Actions. The amount of time it would take a developer to manually convert one Jenkins pipeline to GHA varies. Here are some estimates for averages based on the type of developer: Highly experienced with Jenkins and GHA: 2 hours So basically, a good chunk of a day Highly experienced with Jenkins but not GHA: 5 hours These folks would need to learn GHA syntax. So most of a day Not experienced with either: 10 hours This could take over a day for someone who’s brand new to Jenkins and GHA. This number includes the time it may take others to help them. Assuming 10% of end users are type 1, 40% are type 2 and 50% are type 3, it gives a total amount of time of about 1700 hours to convert all pipelines to GHA Suppose that with this tool, half of pipelines run with no edits necessary (this is realistic, since half of pipelines are fully converted), and that the other half may take an average of 3 hours to debug. It would then take about 360 hours to convert all pipelines to GHA. This tool is thus projected to save over 1,300 hours, 80% of the time it would take to move every Jenkins pipeline to GHA.  Final Comments At time of writing, two weeks have passed since the outputs from the conversion tool have been published, and end-user feedback is now starting to arrive. It’s clear that developers at Slack have found the tool useful, but I’ve also heard that there are a few errors in the generated workflows. Even from the very start of my internship, I expected this to happen, but was worried that it might be hard to triage those incidents. As it turns out, there wasn’t a problem. I made a Canvas doc for this conversion, and whenever end-users of the tool encountered an issue I updated the canvas with details about the problem and its solution. As more users used the tool, I got more feedback, and the canvas became more comprehensive. If I were to pick the best thing about Slack, both the app and the company, it would be the ease of communication and collaboration. It’s easy to let people know things, to find out who to go to for help, to meet people, to take notes and keep track of info. All these things have made my internship experience more fun, pleasant, and educational than it would’ve been otherwise. And, if you join us, it’d make your time here great too 🙂. Acknowledgments Thank you everyone who contributed your knowledge and helped this project get to where it is: Jerry Shen Buddhadev Veeramallu Ellen Wong Shane Gearon Sergii Gorbachov Catherine Li Nick Matute Now more than ever, Slack needs GHA specialists. Does that sound like you? If so, we’re hiring 👀💼! Apply now",
  "image": "https://slack.engineering/wp-content/uploads/sites/7/2024/12/Jenkins-GHA.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\u003ch2\u003e\u003cspan\u003eOverview\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eThe past few months have been exciting times for Slack’s CI infrastructure. After years of developer frustration with Jenkins (everything from security issues to downtime to generally poor UX) internal pressure led us to move a majority of Slack’s CI jobs from Jenkins to GitHub Actions. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eMy intern project at Slack this summer involved creating a conversion tool that could automatically migrate Jenkins pipelines to GitHub Actions, saving developers time and accelerating the migration. The project was successful, and is expected to cut the migration time by half and save over 1,300 hours. This blog is focused on that conversion tool, and the 7 week journey to design, implement, and improve it. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eBefore we start though, you should know some terminology:\u003c/span\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cspan\u003ePipeline: A set of Jenkins plugins used for organizing Jenkins jobs. “Jenkins pipeline” refers to a set of one or more ordered Jenkins jobs. At the beginning of this project we had242 Jenkins pipelines to migrate.\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eInstance: A Jenkins instance is where Jenkins pipelines are hosted. We were migrating off of 3 Jenkins instances.\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eWorkflow: a GitHub Actions CI job.\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eGHA: GitHub Actions.\u003c/span\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e\u003cspan\u003ePlanning for the Project\u003c/span\u003e\u003c/h2\u003e\n\u003ch3\u003e\u003cspan\u003ePondering the Problem\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eThe success criteria for the project are as follows:\u003c/span\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eCreate tooling that automates the difficulties of manually migrating a Jenkins pipeline to GHA\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eRun this tooling on a large subset of existing Jenkins jobs\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eCreate documentation around the conversion process \u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003cspan\u003eTools of the Trade\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eAfter doing some research, we identified a few useful tools to use to convert from Jenkins to GHA:\u003c/span\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/github/gh-actions-importer\"\u003e\u003cb\u003eThe GitHub Actions Importer\u003c/b\u003e\u003c/a\u003e\u003cb\u003e. \u003c/b\u003e\u003cspan\u003eGitHub publishes a tool that can audit a Jenkins instance and either fully convert, partially convert, or fail to convert all pipelines on it to GitHub Actions. Although generally most pipelines fully convert, not all do. So a few more tools will be needed after using the Importer.\u003c/span\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003e\u003cb\u003ePython scripting: \u003c/b\u003e\u003cspan\u003eIt seemed likely that some amount of the Importer’s errors would be easy to fix with just regex scripts.\u003c/span\u003e \u003cspan\u003eWe expected to use Large Language Models (LLMs) for any errors that were too intricate to fix with regular expressions.\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e\u003cspan\u003eThe Solution\u003c/span\u003e\u003c/h2\u003e\n\u003ch3\u003e\u003cspan\u003ePart 1 – The Importer\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eOver the span of a week, we ran the Importer on several of our Jenkins instances. The tool was simple. You install it from the GitHub CLI, configure it, and run a command like this:\u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egh actions-importer audit jenkins --output-dir \u0026lt;output-dir\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cspan\u003eThe Importer would then output GitHub Actions workflow files for each Jenkins pipeline on the Jenkins instance being audited. Upon running the Importer, we were curious as to how well it performed. Fortunately, the Importer creates an audit summary upon completing its audit of a Jenkins instance. The audit file contains information about how many Jenkins jobs were fully converted, partially converted, and failed to convert from Jenkins to GHA.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eAbout 50% of the time the Importer moved the pipeline from Jenkins to GHA without error. 5% of the time the importer failed completely, and the rest of the jobs were partially-imported — it created a workflow YAML file, but wasn’t able to populate it fully.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eIn addition to the success and failure rates, we were curious as to exactly what Jenkins build steps and environments were unsupported by the Importer. Fortunately the audit summaries contain information about this as well. Glancing at the audit summary, it was initially concerning to see that there were hundreds of Jenkins pipelines that weren’t able to fully convert to GitHub Actions. A deeper inspection revealed a pleasant surprise – only eight unsupported Jenkins build steps and environments were responsible for over 90% of those failures.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThis was good news. Instead of needing to spread ourselves thin looking at dozens of unsupported Jenkins steps, we instead only had to look at eight. For those key few unsupported items, we’d need to look at the following:\u003c/span\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eIs this actually unsupported by GHA, or do equivalents exist?\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eIf equivalents do exist, is it easy to write scripts to edit the Importer’s outputs accordingly?\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003cspan\u003ePart 2 – Research\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eAt this point in the project, it was known that the Importer’s workflows had a lot of room for improvement. Around half of the pipelines didn’t fully convert, so a big objective was to look into the unsupported Jenkins steps that caused them to not fully convert. Another task though was to investigate the pipelines that fully converted. Can we really trust the Importer when it claims that it could fully convert something? So really every pipeline that got (or didn’t get) converted to a workflow had to be looked at. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eAfter looking through several dozen of the YAML files the Importer made, it was clear that there were 4 main types of corrections we’d need to make to the workflow YAML files:\u003c/span\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eReplacing rate-limited actions with internal mirrors \u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eReplacing actions with other actions\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eAdding useful comments for end users \u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eRemoving unnecessary comments\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cspan\u003eOver the course of 2 weeks, we studied each of these:\u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan\u003e1 – Replacing rate limited actions with internal mirrors\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eRoI: Very High\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003ch5\u003e\u003cspan\u003eOverview\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e\u003cspan\u003eBy default, if you use an arbitrary action from the GitHub Actions marketplace, like say actions/github-script, any requests made by the action will hit the github.com API. There are rate limits for this. Actions that hit our self-hosted GitHub Enterprise instance have far higher rate limits however. So a task we had to do was replace rate-limited actions with internal mirrors of those actions that we have on our GitHub Enterprise instance.\u003c/span\u003e\u003c/p\u003e\n\u003ch5\u003e\u003cspan\u003eEnd-User Value\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e\u003cspan\u003eCorrecting rate-limited actions is simple to do on our end, and prevents end users from dealing with the headache that is having jobs fail from rate limits. So high RoI here.\u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan\u003e2 – Replacing actions with other actions\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eRoI: High\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003ch5\u003e\u003cspan\u003eOverview\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e\u003cspan\u003eThere were a few instances where, to perform a certain task, the Importer would use one action whereas we’d prefer if it had used another. For instance, for sending Slack messages the Importer often elected to use the \u003c/span\u003e\u003ca href=\"https://github.com/rtCamp/action-slack-notify\"\u003e\u003cspan\u003ertCamp/action-slack-notify\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e action. Naturally, Slack has internal actions for sending Slack messages, and we’d rather use internal libraries for this purpose. So something to look into was replacing rtCamp/action-slack-notify with Slack’s internal messaging action.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThis type of task seemed suitable for an LLM to do, since two actions often have disparate syntax which is hard to convert between by just using Python’s string methods. Preliminary testing also showed perfect LLM performance for this task which was reassuring.\u003c/span\u003e\u003c/p\u003e\n\u003ch5\u003e\u003cspan\u003eEnd-User Value\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e\u003cspan\u003eReplacing one action with a different action would require end users to know both actions well. So automating this saves quite a bit of time and effort on their end, and it’s not that hard to write LLM prompts for these tasks. The RoI is thus high.\u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan\u003e3 – Adding Useful Comments for End Users\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eRoI: Medium\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003ch5\u003e\u003cspan\u003eOverview\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e\u003cspan\u003eSome action items in the workflow files could only be done manually. For example, the syntax used in the workflow files to access secrets assumed that the secrets would be stored on GitHub. However, we don’t store our secrets on GitHub, and it would be time prohibitive and against our security policies to move them to GitHub. It would instead be better for end users to edit the workflow files such that secrets get read from where we store them instead of from GitHub. This couldn’t really be automated on the conversion tool side, since only the end users know where their secrets are and how to access them. All the conversion tool could do in such situations was leave a comment like: “Change these lines so that secrets are being read from where we store them instead of from GitHub. Go to a certain slack channel to find relevant docs about this.”\u003c/span\u003e\u003c/p\u003e\n\u003ch5\u003e\u003cspan\u003eEnd-User Value\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e\u003cspan\u003eIt’s definitely useful for end users to know where they should look to fix problems, but they still have to do the actual work of fixing the problem. So overall, medium RoI. \u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan\u003e4 – Removing Unnecessary Comments\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eRoI: Low-medium\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003ch5\u003e\u003cspan\u003eOverview\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e\u003cspan\u003eRecall that around 45% of pipelines only partially converted. What this means is that the Importer couldn’t find a GHA equivalent for a Jenkins environment or build step. When this happened, the Importer left a comment in the workflow that looked something like “X Jenkins item was unsupported.” \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eAs it turns out, the reason why a lot of Jenkins pipelines were unsupported is because that piece of functionality in Jenkins was either already included or not necessary in GHA. So most of those “X was unsupported” comments weren’t too important and would probably be better off removed.\u003c/span\u003e\u003c/p\u003e\n\u003ch5\u003e\u003cspan\u003eEnd-User Value\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e\u003cspan\u003eThe benefits here to end users was small, as all it really does is declutter the workflows. So overall this had a low return. However, a script to delete strings is also very easy to write. So overall low-medium RoI.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003ePart 3 – Corrections Tool\u003c/span\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cspan\u003eOverview\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cspan\u003eThe last part of the implementation is the corrections tool, which would correct the Importer’s workflows. We knew from the start that the tool would have a balance of using Python’s string methods and using LLMs. From the last section, note that out of the 4 categories of action items for the correction tool, the only one that needed AI was “replacing actions with other actions”. So the corrections tool was largely non-AI. It took around 3 weeks to make the corrections tool.\u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan\u003eImplementation Architecture\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cspan\u003eHere’s the bird’s-eye view. The input to the corrections tool was the path to a directory containing workflow yaml files. The following chain of events then happened:\u003c/span\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eThe path to each yaml file in that directory was written to an array. Then, for each element in that array:\u003c/span\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eThe contents of the yaml file at that path were read. Then:\u003c/span\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eEvery relevant non-AI correction was made to those file contents, and written back to the original file\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eEvery relevant AI correction was made to those file contents, and written back to the original file\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cspan\u003eThe end result is that every yaml file in the directory inputted to the corrections tool was edited in place.\u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan\u003eImplementing the Non-AI Corrections\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cspan\u003eAs mentioned previously, a large part of what needed to happen to the Importer’s yaml files boiled down to “add a comment after a line containing a certain string” or “replace a string with another string”. Python’s String.replace() method was used extensively here. \u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan\u003eImplementing the AI Corrections\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cspan\u003ePrompt engineering is both science and art. It’s science, because there’s a formula that’s useful for doing prompt engineering:\u003c/span\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eUse the following structure:\u003c/span\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eContext Setting (let the LLM know what the task is and why it’s doing it)\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eSpecific Steps (Several instructions, each about very specific individual tasks the LLM must do. Too long of a prompt is much less dangerous than too vague of a prompt)\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eOutput Instructions (Instructions about how the LLM should present its output)\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eIn the context setting part of the prompt, include any relevant syntax and documentation\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cspan\u003ePrompt engineering is also art, because experimenting with the prompt and seeing how you feel about the AI’s output is a key part too. There were a few rounds of this process:\u003c/span\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eStart with a very basic prompt\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eSee the LLM’s response to it\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eAdd detail and context to the prompt to prevent any errors the LLM made\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cspan\u003eAn example of a prompt we’d end up at:\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI’m going to provide you with a GitHub Actions workflow yaml file. In the file an action called rtCamp/action-slack-notify@v2.2.1 is being used. Your job is to replace every rtCamp/action-slack-notify@v2.2.1 action with the slack/message-action@v1.0 action, and output the resulting workflow yaml file. For reference, I will provide you with the syntax for the slack/message-action@v1.0 action. I’ll put it between \u0026lt;syntax\u0026gt;\u0026lt;/syntax\u0026gt; XML tags:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;syntax\u0026gt;\n\n- uses: slack/message-action@v1.0\n\n  with:\n\n   channel: channel-name\n\n   text: text-message\n\n\u0026lt;/syntax\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNow, perform the following steps:\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e Find every instance of the rtCamp/action-slack-notify@v2.2.1 action being used.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e Replace each instance with the slack/message-action@v1.0 action with the aforementioned syntax.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e Replace channel-name with the value of the SLACK_CHANNEL field in the rtCamp/action-slack-notify@v2.2.1 action.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e Replace text-message with the value of the SLACK_MESSAGE field in the rtCamp/action-slack-notify@v2.2.1 action.\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eAlso, there are a few things you should absolutely never do:\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e Do not remove any comments from the file\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e Do not alter any other action in the file besides rtCamp/action-slack-notify@v2.2.1\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eI will now provide you with the workflow file you will be making edits to between \u0026lt;workflow\u0026gt;\u0026lt;/workflow\u0026gt; XML tags. When providing your output, only provide the contents of a YAML file. Do not describe what you did. Do not provide any justifications for your decisions. Only provide the corrected GitHub Actions yaml file, with nothing else before or after the yaml file in your output. Now, please perform the instructions I gave you:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe examined about 2 dozen of the LLM’s outputs and noticed something stunning — 100% accuracy in performing the requested tasks. A big concern with asking LLMs to do these corrections were hallucinations and other unexpected side effects, so seeing the LLM’s performance was reassuring. Overall, the LLM ended up being really useful for the migration. Even though prompt engineering isn’t trivial, it doesn’t take that long either, and after doing it the LLM could perform as well as any human for these “replace A with B” tasks. LLMs filled a crucial gap for fixing those errors that were too hard to fix with Python’s string methods.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eImpact and End User Feedback\u003c/span\u003e\u003c/h2\u003e\n\u003ch3\u003e\u003cspan\u003eImpact\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eFirst, consider the process of converting a pipeline from Jenkins to GHA manually:\u003c/span\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eLooking at your Jenkins pipeline as a reference, write a GHA workflow yaml file.\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eTest that workflow yaml and do debugging as needed.\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eWrite the documentation for the workflow.\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eDelete the pipeline from its Jenkins instance.\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cspan\u003eNote how the steps are in descending order of difficulty and time cost. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThe conversion tool lets end users skip step 1 entirely and have a much easier time with step 2. End users are given workflow files that have few, if any, flaws. They can skip straight to debugging, which will be accelerated since the workflows they get are highly accurate.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThere are about 242 pipelines that this tool attempted to convert from Jenkins to GitHub Actions. The amount of time it would take a developer to manually convert one Jenkins pipeline to GHA varies. Here are some estimates for averages based on the type of developer:\u003c/span\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eHighly experienced with Jenkins and GHA: 2 hours\u003c/span\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eSo basically, a good chunk of a day\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eHighly experienced with Jenkins but not GHA: 5 hours\u003c/span\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eThese folks would need to learn GHA syntax. So most of a day\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eNot experienced with either: 10 hours\u003c/span\u003e\n\u003col\u003e\n\u003cli\u003e\u003cspan\u003eThis could take over a day for someone who’s brand new to Jenkins and GHA. This number includes the time it may take others to help them.\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cspan\u003eAssuming 10% of end users are type 1, 40% are type 2 and 50% are type 3, it gives a total amount of time of about 1700 hours to convert all pipelines to GHA\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eSuppose that with this tool, half of pipelines run with no edits necessary (this is realistic, since half of pipelines are fully converted), and that the other half may take an average of 3 hours to debug. It would then take about 360 hours to convert all pipelines to GHA.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThis tool is thus projected to save over 1,300 hours, 80% of the time it would take to move every Jenkins pipeline to GHA. \u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eFinal Comments\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eAt time of writing, two weeks have passed since the outputs from the conversion tool have been published, and end-user feedback is now starting to arrive. It’s clear that developers at Slack have found the tool useful, but I’ve also heard that there are a few errors in the generated workflows. Even from the very start of my internship, I expected this to happen, but was worried that it might be hard to triage those incidents.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eAs it turns out, there wasn’t a problem. I made a Canvas doc for this conversion, and whenever end-users of the tool encountered an issue I updated the canvas with details about the problem and its solution. As more users used the tool, I got more feedback, and the canvas became more comprehensive.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eIf I were to pick the best thing about Slack, both the app and the company, it would be the ease of communication and collaboration. It’s easy to let people know things, to find out who to go to for help, to meet people, to take notes and keep track of info. All these things have made my internship experience more fun, pleasant, and educational than it would’ve been otherwise. And, if you join us, it’d make your time here great too 🙂.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eAcknowledgments\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eThank you everyone who contributed your knowledge and helped this project get to where it is:\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eJerry Shen\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eBuddhadev Veeramallu\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eEllen Wong\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eShane Gearon\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eSergii Gorbachov\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eCatherine Li\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eNick Matute\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\t\t\u003cdiv\u003e\n\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"26\" height=\"37\" fill=\"none\" viewBox=\"0 0 26 37\"\u003e\u003cpath stroke=\"#032d60\" stroke-linejoin=\"round\" stroke-width=\"5\" d=\"m4.112 1c-2.5 6.167-2.4 21.1 18 31.5\"\u003e\u003c/path\u003e\u003cpath stroke=\"#032d60\" stroke-width=\"5\" d=\"m20.112 18 2.5 14.5-13.5 1.5\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\u003cp\u003eNow more than ever, Slack needs GHA specialists. Does that sound like you? If so, we’re hiring 👀💼!\u003c/p\u003e\n\t\t\t\u003cp\u003e\u003ca href=\"https://slack.com/careers/dept/engineering\" target=\"_blank\" data-clog-click=\"\" data-clog-trigger=\"trigger=\" data-clog-ui-element=\"\" data-clog-ui-component=\"\"\u003eApply now\u003c/a\u003e\n\t\t\u003c/p\u003e\u003c/div\u003e\n\t\n\n\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": "2024-12-16T09:00:03Z",
  "modifiedTime": "2024-12-13T23:55:08Z"
}
