{
  "id": "443fdc21-3d1d-453f-916d-6bab52988643",
  "title": "Load Testing with Impulse at Airbnb",
  "link": "https://medium.com/airbnb-engineering/load-testing-with-impulse-at-airbnb-f466874d03d2?source=rss----53c7c27702d5---4",
  "description": "",
  "author": "Chenhao Yang",
  "published": "Mon, 09 Jun 2025 17:45:39 GMT",
  "source": "https://medium.com/feed/airbnb-engineering",
  "categories": [
    "tech",
    "infrastructure",
    "engineering",
    "technology",
    "load-testing"
  ],
  "byline": "Chenhao Yang",
  "length": 11361,
  "excerpt": "System-level load testing is crucial for reliability and efficiency. It identifies bottlenecks, evaluates capacity for peak traffic, establishes performance baselines, and detects errors. At a…",
  "siteName": "The Airbnb Tech Blog",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Load Testing with Impulse at AirbnbComprehensive Load Testing with Load Generator, Dependency Mocker, Traffic Collector, and MoreAuthors: Chenhao Yang, Haoyue Wang, Xiaoya Wei, Zay Guan, Yaolin Chen and Fei YuanSystem-level load testing is crucial for reliability and efficiency. It identifies bottlenecks, evaluates capacity for peak traffic, establishes performance baselines, and detects errors. At a company of Airbnb’s size and complexity, we’ve learned that load testing needs to be robust, flexible, and decentralized. This requires the right set of tools to enable engineering teams to do self-service load tests that integrate seamlessly with CI.Impulse is one of our internal load-testing-as-a-service frameworks. It provides tools that can generate synthetic loads, mock dependencies, and collect traffic data from production environments. In this blog post, we’ll share how Impulse is architected to minimize manual effort, seamlessly integrate with our observability stack, and empower teams to proactively address potential issues.ArchitectureImpulse is a comprehensive load testing framework that allows service owners to conduct context-aware load tests, mock dependencies, and collect traffic data to ensure the system’s performance under various conditions. It includes the following components:Load generator to generate context-aware requests on the fly, for testing different scenarios with synthetic or collected traffic.Dependency mocker to mock the downstream responses with latency, so that the load testing on the service under test (SUT) doesn’t need to involve certain dependent services. This is especially crucial when the dependencies are vendor services that don’t support load testing, or if the team wants to regression load test their service during day-to-day deployment without affecting downstreams.Traffic collector to collect both the upstream and downstream traffic from the production environment, and then apply the resulting data to the test environment.Testing API generator to wrap asynchronous workflows into synchronous API calls for load testing.Figure 1: The Impulse framework and its four main componentsEach of these four tools are independent, allowing service owners the flexibility to select one or more components for their load testing needs.Load generatorFigure 2: Containerized load generatorContext awareWhen load testing, requests made to the SUT often require some information from the previous response or need to be sent in a specific order. For example, if an update API needs to provide an entity_id to update, we must ensure the entity already exists in the testing environment context.Our load generator tool allows users to write arbitrary testing logic in Java or Kotlin and launch containers to run these tests at scale against the SUT. Why write code instead of DSL/configuration logic?Flexibility: Programming languages are more expressive than DSL and can better support complex contextual scenarios.Reusability: The same testing code can be used in other tests, e.g., integration tests.Developer proficiency: Low/no learning curve to onboard, don’t need to learn how to write testing logic.Developer experience: IDE support, testing, debugging, etc.Here is an example of synthetic context-aware test case:class HelloWorldLoadGenerator : LoadGenerator { override suspend fun run() { val createdEntity = sutApiClient.create(CreateRequest(name=\"foo\", ...)).data // request with id from previous response (context) val updateResponse = sutApiClient.update(UpdateRequest(id=createdEntity.id, name=\"bar\")) // ... other operations // clean up sutApiClient.delete(DeleteRequest(id=createdEntity.id)) }}DecentralizedThe load generator is decentralized and containerized, which means each time a load test is triggered, a set of new containers will be created to run the test. This design has several benefits:Isolation: Load testing runs between different services are isolated from each other, eliminating any interference.Scalability: The number of containers can be scaled up or down according to the traffic requirements.Cost efficiency: The containers are short-lived, as they only exist during the load testing run.What’s more, as our services are cloud based, a subtle point is that the Impulse framework will evenly distribute the workers among all our data centers, and the load will be emitted evenly from all the workers. Impulse’s load generator ensures the overall trigger per second (TPS) is as configured. Based on this, we can better leverage the locality settings in load balancers, which can better mimic the real traffic distribution in production.ExecutionThe load generator is designed to be executed in the CI/CD pipeline, which means we can trigger load testing automatically. Developers can configure the testing spec in multiple phases, e.g., a warm up phase, a steady state phase, a peak phase, etc. Each phase can be configured with:Test cases to runTPS (trigger per second) of each test caseTest durationDependency mockerFigure 3: Dependency mockerImpulse is a decentralized framework where each service has its own dependency mocker. This can eliminate interference between services and reduce communication costs. Each dependency mocker is an out-of-process service, which means the SUT behaves just as it does in production. We run the mockers in separate instances to avoid any impact on the performance of the SUT. The mock servers are all short lived — they only start before tests run and shut down afterwards to save costs and maintenance effort. The response latency and exceptions are configurable and the number of mocker instances can be adjusted on demand to support large amounts of traffic.Other noteworthy features:You can selectively stub some of the dependencies. Currently, stubbing is supported for HTTP JSON, Airbnb Thrift, and Airbnb GraphQL dependencies.The dependency mockers support use cases beyond load testing. For instance, integration tests often rely on other services or third-party API calls, which may not guarantee a stable testing environment or might only support ideal scenarios. Dependency mockers can address this by offering predefined responses or exceptions to fully test those flows.Impulse supports two options for generating mock responses:Synthetic response: The response is generated by user logic, as in integration testing; the difference is that the response comes from a remote (out-of-process) server with simulated latency.- Similar to the load generator, the logic is written in Java/Kotlin code and contains request matching and response generation.- Latency can be simulated using p95/p99 metrics.Replay response: The response is replayed from the production downstream recording, supported by the traffic collector component.Here is an example of a synthetic response with latency in Kotlin:downstreamsMocking.every( thriftRequest\u003cFooRequest\u003e().having { it.message == \"hello\" } ).returns { request -\u003e ThriftDownstream.Response.thriftEncoded( HttpStatus.OK, FooResponse.builder.reply(\"${request.message} world\").build() ) }.with { delay = latencyFromP95(p95=500.miliseconds, min=200.miliseconds, max=2000.miliseconds) }Traffic collectorFigure 4: Traffic collectorThe traffic collector component is designed to capture both upstream and downstream traffic, along with the relationships between them. This approach allows Impulse to accurately replay production traffic during load testing, avoiding inconsistencies in downstream data or behavior. By replicating downstream responses — including production-like latency and errors — via the dependency mocker, the system ensures high-fidelity load testing. As a result, services in the testing environment behave identically to those in production, enabling more realistic and reliable performance evaluations.Testing API generatorWe rely heavily on event-driven, asynchronous workflows that are critical to our business operations. These include processing events from a message queue (MQ) and executing delayed jobs. Most of the MQ events/jobs are emitted from synchronous flows (e.g., API calls), so theoretically they can be covered by API load testing. However, the real world is more complex. These asynchronous flows often involve long chains of event and job emissions originating from various sources, making it difficult to replicate and test them accurately using only API-based methods.To address this, the testing API generator component creates HTTP APIs during the CI stage according to the event or job schema. These APIs act as wrappers around the underlying asynchronous flows and are registered exclusively in the testing environment. This setup enables load testing tools — such as load generators — to send traffic to these synthetic APIs, allowing asynchronous flows to be exercised as if they were synchronous. As a result, it’s possible to perform targeted, realistic load testing on asynchronous logic that would otherwise be hard to simulate.Figure 5: Testing API generator for async flowsThe goal of the testing API generator is to help developers identify performance bottlenecks and potential issues in their async flow implementations and under high traffic conditions. It does this by enabling direct load testing of async flows without involving middleware components like MQs. The rationale is that developers typically aim to evaluate the behavior of their own logic, not the middleware, which is usually already well-tested. By bypassing these components, this approach simplifies the load testing process and empowers developers to independently manage and execute their own tests.Integration with other testing frameworksAirbnb emphasizes product quality, utilizing versatile testing frameworks that cover integration and API tests across development, staging, and production environments, and integrate smoothly into CI/CD pipelines. The modular design of Impulse facilitates its integration with these frameworks, offering systematic service testing.Figure 6: How Impulse interfaces with other internal testing frameworksConclusionIn this blog post, we shared how Impulse and its four core components help developers perform self-service load testing at Airbnb. As of this writing, Impulse has been implemented in several customer support backend services and is currently under review with different teams across the company who are planning to leverage Impulse to conduct load testing.We’ve received a lot of good feedback in the process. For example: “Impulse helps us to identify and address potential issues in our service. During testing, it detected an ApiClientThreadToolExhaustionException caused by thread pool pressure. Additionally, it alerted us about occasional timeout errors in client API calls during service deployments. Impulse helped us identify high memory usage in the main service container, enabling us to fine-tune the memory allocation and optimize our service’s resource usage. Highly recommend utilizing Impulse as an integral part of the development and testing processes.”AcknowledgmentsThanks to Jeremy Werner, Yashar Mehdad, Raj Rajagopal, Claire Cheng, Tim L., Wei Ji, Jay Wu, Brian Wallace for support on the Impulse project.Does this type of work interest you? Check out our open roles here.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*3LijjQrJDLVA_ptfeRe83g.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"f03d\" data-testid=\"storyTitle\"\u003eLoad Testing with Impulse at Airbnb\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@chenhao.yang?source=post_page---byline--f466874d03d2---------------------------------------\" data-discover=\"true\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Chenhao Yang\" src=\"https://miro.medium.com/v2/resize:fill:64:64/0*gj-Rpi1dOmxDue6y.jpg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"867b\"\u003eComprehensive Load Testing with Load Generator, Dependency Mocker, Traffic Collector, and More\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d5e7\"\u003eAuthors: \u003ca href=\"https://www.linkedin.com/in/chenhao-yang-9799b022/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eChenhao Yang\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/haoyue-wang-a722509a/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHaoyue Wang\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/xiaoyawei/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eXiaoya Wei\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/zhijie-guan/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZay Guan\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/yaolin-chen-591a31339/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eYaolin Chen\u003c/a\u003e and \u003ca href=\"https://www.linkedin.com/in/fei-yuan/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFei Yuan\u003c/a\u003e\u003c/p\u003e\u003cp id=\"bc87\"\u003eSystem-level load testing is crucial for reliability and efficiency. It identifies bottlenecks, evaluates capacity for peak traffic, establishes performance baselines, and detects errors. At a company of Airbnb’s size and complexity, we’ve learned that load testing needs to be robust, flexible, and decentralized. This requires the right set of tools to enable engineering teams to do self-service load tests that integrate seamlessly with CI.\u003c/p\u003e\u003cp id=\"d857\"\u003eImpulse is one of our internal load-testing-as-a-service frameworks. It provides tools that can generate synthetic loads, mock dependencies, and collect traffic data from production environments. In this blog post, we’ll share how Impulse is architected to minimize manual effort, seamlessly integrate with our observability stack, and empower teams to proactively address potential issues.\u003c/p\u003e\u003ch2 id=\"2c65\"\u003eArchitecture\u003c/h2\u003e\u003cp id=\"806d\"\u003eImpulse is a comprehensive load testing framework that allows service owners to conduct context-aware load tests, mock dependencies, and collect traffic data to ensure the system’s performance under various conditions. It includes the following components:\u003c/p\u003e\u003col\u003e\u003cli id=\"95b3\"\u003e\u003cstrong\u003eLoad generator\u003c/strong\u003e to generate context-aware requests on the fly, for testing different scenarios with synthetic or collected traffic.\u003c/li\u003e\u003cli id=\"11bc\"\u003e\u003cstrong\u003eDependency mocker\u003c/strong\u003e to mock the downstream responses with latency, so that the load testing on the service under test (SUT) doesn’t need to involve certain dependent services. This is especially crucial when the dependencies are vendor services that don’t support load testing, or if the team wants to regression load test their service during day-to-day deployment without affecting downstreams.\u003c/li\u003e\u003cli id=\"a388\"\u003e\u003cstrong\u003eTraffic collector\u003c/strong\u003e to collect both the upstream and downstream traffic from the production environment, and then apply the resulting data to the test environment.\u003c/li\u003e\u003cli id=\"3944\"\u003e\u003cstrong\u003eTesting API generator\u003c/strong\u003e to wrap asynchronous workflows into synchronous API calls for load testing.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003cfigcaption\u003eFigure 1: The Impulse framework and its four main components\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"f043\"\u003eEach of these four tools are independent, allowing service owners the flexibility to select one or more components for their load testing needs.\u003c/p\u003e\u003ch2 id=\"3397\"\u003eLoad generator\u003c/h2\u003e\u003cfigure\u003e\u003cfigcaption\u003eFigure 2: Containerized load generator\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"b182\"\u003e\u003cem\u003eContext aware\u003c/em\u003e\u003c/p\u003e\u003cp id=\"b9cc\"\u003eWhen load testing, requests made to the SUT often require some information from the previous response or need to be sent in a specific order. For example, if an update API needs to provide an \u003cem\u003eentity_id\u003c/em\u003e to update, we must ensure the entity already exists in the testing environment context.\u003c/p\u003e\u003cp id=\"0224\"\u003eOur load generator tool allows users to write arbitrary testing logic in Java or Kotlin and launch containers to run these tests at scale against the SUT. Why write code instead of DSL/configuration logic?\u003c/p\u003e\u003cul\u003e\u003cli id=\"9218\"\u003eFlexibility: Programming languages are more expressive than DSL and can better support complex contextual scenarios.\u003c/li\u003e\u003cli id=\"28ad\"\u003eReusability: The same testing code can be used in other tests, e.g., integration tests.\u003c/li\u003e\u003cli id=\"d916\"\u003eDeveloper proficiency: Low/no learning curve to onboard, don’t need to learn how to write testing logic.\u003c/li\u003e\u003cli id=\"91f5\"\u003eDeveloper experience: IDE support, testing, debugging, etc.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"700e\"\u003eHere is an example of synthetic context-aware test case:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"81cf\"\u003eclass HelloWorldLoadGenerator : LoadGenerator {\u003cbr/\u003e   override suspend fun run() {\u003cbr/\u003e       val createdEntity = sutApiClient.create(CreateRequest(name=\u0026#34;foo\u0026#34;, ...)).data\u003cp\u003e       // request with id from previous response (context)\u003cbr/\u003e       val updateResponse = sutApiClient.update(UpdateRequest(id=createdEntity.id, name=\u0026#34;bar\u0026#34;))\u003c/p\u003e\u003cp\u003e              // ... other operations\u003c/p\u003e\u003cp\u003e              // clean up\u003cbr/\u003e       sutApiClient.delete(DeleteRequest(id=createdEntity.id))\u003cbr/\u003e   }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"eabe\"\u003e\u003cem\u003eDecentralized\u003c/em\u003e\u003c/p\u003e\u003cp id=\"f86c\"\u003eThe load generator is decentralized and containerized, which means each time a load test is triggered, a set of new containers will be created to run the test. This design has several benefits:\u003c/p\u003e\u003cul\u003e\u003cli id=\"c1b5\"\u003eIsolation: Load testing runs between different services are isolated from each other, eliminating any interference.\u003c/li\u003e\u003cli id=\"a85d\"\u003eScalability: The number of containers can be scaled up or down according to the traffic requirements.\u003c/li\u003e\u003cli id=\"6e5e\"\u003eCost efficiency: The containers are short-lived, as they only exist during the load testing run.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"86d0\"\u003eWhat’s more, as our services are cloud based, a subtle point is that the Impulse framework will evenly distribute the workers among all our data centers, and the load will be emitted evenly from all the workers. Impulse’s load generator ensures the overall trigger per second (TPS) is as configured. Based on this, we can better leverage the locality settings in load balancers, which can better mimic the real traffic distribution in production.\u003c/p\u003e\u003cp id=\"2d65\"\u003e\u003cem\u003eExecution\u003c/em\u003e\u003c/p\u003e\u003cp id=\"f88d\"\u003eThe load generator is designed to be executed in the CI/CD pipeline, which means we can trigger load testing automatically. Developers can configure the testing spec in multiple phases, e.g., a warm up phase, a steady state phase, a peak phase, etc. Each phase can be configured with:\u003c/p\u003e\u003cul\u003e\u003cli id=\"4f2e\"\u003eTest cases to run\u003c/li\u003e\u003cli id=\"a93b\"\u003eTPS (trigger per second) of each test case\u003c/li\u003e\u003cli id=\"5318\"\u003eTest duration\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"bf73\"\u003eDependency mocker\u003c/h2\u003e\u003cfigure\u003e\u003cfigcaption\u003eFigure 3: Dependency mocker\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"9b6a\"\u003eImpulse is a decentralized framework where each service has its own dependency mocker. This can eliminate interference between services and reduce communication costs. Each dependency mocker is an out-of-process service, which means the SUT behaves just as it does in production. We run the mockers in separate instances to avoid any impact on the performance of the SUT. The mock servers are all short lived — they only start before tests run and shut down afterwards to save costs and maintenance effort. The response latency and exceptions are configurable and the number of mocker instances can be adjusted on demand to support large amounts of traffic.\u003c/p\u003e\u003cp id=\"bcce\"\u003eOther noteworthy features:\u003c/p\u003e\u003cul\u003e\u003cli id=\"f1c1\"\u003eYou can selectively stub some of the dependencies. Currently, stubbing is supported for HTTP JSON, Airbnb Thrift, and Airbnb GraphQL dependencies.\u003c/li\u003e\u003cli id=\"42e8\"\u003eThe dependency mockers support use cases beyond load testing. For instance, integration tests often rely on other services or third-party API calls, which may not guarantee a stable testing environment or might only support ideal scenarios. Dependency mockers can address this by offering predefined responses or exceptions to fully test those flows.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5c25\"\u003eImpulse supports two options for generating mock responses:\u003c/p\u003e\u003col\u003e\u003cli id=\"29f3\"\u003eSynthetic response: The response is generated by user logic, as in integration testing; the difference is that the response comes from a remote (out-of-process) server with simulated latency.\u003cbr/\u003e- Similar to the load generator, the logic is written in Java/Kotlin code and contains request matching and response generation.\u003cbr/\u003e- Latency can be simulated using p95/p99 metrics.\u003c/li\u003e\u003cli id=\"8fc6\"\u003eReplay response: The response is replayed from the production downstream recording, supported by the traffic collector component.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"adb4\"\u003eHere is an example of a synthetic response with latency in Kotlin:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"75db\"\u003edownstreamsMocking.every(\u003cbr/\u003e      thriftRequest\u0026lt;FooRequest\u0026gt;().having { it.message == \u0026#34;hello\u0026#34; }\u003cbr/\u003e    ).returns { request -\u0026gt;\u003cbr/\u003e      ThriftDownstream.Response.thriftEncoded(\u003cbr/\u003e        HttpStatus.OK,\u003cbr/\u003e        FooResponse.builder.reply(\u0026#34;${request.message} world\u0026#34;).build()\u003cbr/\u003e      )\u003cbr/\u003e    }.with {\u003cbr/\u003e      delay = latencyFromP95(p95=500.miliseconds, min=200.miliseconds, max=2000.miliseconds)\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"d412\"\u003eTraffic collector\u003c/h2\u003e\u003cfigure\u003e\u003cfigcaption\u003eFigure 4: Traffic collector\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"5c47\"\u003eThe traffic collector component is designed to capture both upstream and downstream traffic, along with the relationships between them. This approach allows Impulse to accurately replay production traffic during load testing, avoiding inconsistencies in downstream data or behavior. By replicating downstream responses — including production-like latency and errors — via the dependency mocker, the system ensures high-fidelity load testing. As a result, services in the testing environment behave identically to those in production, enabling more realistic and reliable performance evaluations.\u003c/p\u003e\u003ch2 id=\"9575\"\u003eTesting API generator\u003c/h2\u003e\u003cp id=\"bb25\"\u003eWe rely heavily on event-driven, asynchronous workflows that are critical to our business operations. These include processing events from a message queue (MQ) and executing delayed jobs. Most of the MQ events/jobs are emitted from synchronous flows (e.g., API calls), so theoretically they can be covered by API load testing. However, the real world is more complex. These asynchronous flows often involve long chains of event and job emissions originating from various sources, making it difficult to replicate and test them accurately using only API-based methods.\u003c/p\u003e\u003cp id=\"4e30\"\u003eTo address this, the testing API generator component creates HTTP APIs during the CI stage according to the event or job schema. These APIs act as wrappers around the underlying asynchronous flows and are registered exclusively in the testing environment. This setup enables load testing tools — such as load generators — to send traffic to these synthetic APIs, allowing asynchronous flows to be exercised as if they were synchronous. As a result, it’s possible to perform targeted, realistic load testing on asynchronous logic that would otherwise be hard to simulate.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eFigure 5: Testing API generator for async flows\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"e448\"\u003eThe goal of the testing API generator is to help developers identify performance bottlenecks and potential issues in their async flow implementations and under high traffic conditions. It does this by enabling direct load testing of async flows without involving middleware components like MQs. The rationale is that developers typically aim to evaluate the behavior of their own logic, not the middleware, which is usually already well-tested. By bypassing these components, this approach simplifies the load testing process and empowers developers to independently manage and execute their own tests.\u003c/p\u003e\u003ch2 id=\"6ee9\"\u003eIntegration with other testing frameworks\u003c/h2\u003e\u003cp id=\"29bc\"\u003eAirbnb emphasizes product quality, utilizing versatile testing frameworks that cover integration and API tests across development, staging, and production environments, and integrate smoothly into CI/CD pipelines. The modular design of Impulse facilitates its integration with these frameworks, offering systematic service testing.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eFigure 6: How Impulse interfaces with other internal testing frameworks\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"649a\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"9a29\"\u003eIn this blog post, we shared how Impulse and its four core components help developers perform self-service load testing at Airbnb. As of this writing, Impulse has been implemented in several customer support backend services and is currently under review with different teams across the company who are planning to leverage Impulse to conduct load testing.\u003c/p\u003e\u003cp id=\"9b09\"\u003eWe’ve received a lot of good feedback in the process. For example: “\u003cem\u003eImpulse helps us to identify and address potential issues in our service. During testing, it detected an ApiClientThreadToolExhaustionException caused by thread pool pressure. Additionally, it alerted us about occasional timeout errors in client API calls during service deployments. Impulse helped us identify high memory usage in the main service container, enabling us to fine-tune the memory allocation and optimize our service’s resource usage. Highly recommend utilizing Impulse as an integral part of the development and testing processes.\u003c/em\u003e”\u003c/p\u003e\u003ch2 id=\"7f23\"\u003eAcknowledgments\u003c/h2\u003e\u003cp id=\"e6c7\"\u003eThanks to Jeremy Werner, Yashar Mehdad, Raj Rajagopal, Claire Cheng, Tim L., Wei Ji, Jay Wu, Brian Wallace for support on the Impulse project.\u003c/p\u003e\u003cp id=\"41d1\"\u003eDoes this type of work interest you? Check out our open roles \u003ca href=\"https://careers.airbnb.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-06-09T17:45:39.642Z",
  "modifiedTime": null
}
