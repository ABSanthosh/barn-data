{
  "id": "d1ce80cf-731a-4bf6-8a8d-f5f5708d7df5",
  "title": "Guiding an LLM for Robust Java ByteBuffer Code",
  "link": "https://martinfowler.com/articles/exploring-gen-ai/14-guiding-llm-java-bytebuffer.html",
  "description": "",
  "author": "",
  "published": "2025-04-17T09:39:00-04:00",
  "source": "https://martinfowler.com/feed.atom",
  "categories": null,
  "byline": "Unmesh Joshi",
  "length": 11725,
  "excerpt": "Notes from my Thoughtworks colleagues on AI-assisted software delivery",
  "siteName": "martinfowler.com",
  "favicon": "",
  "text": "AI editors like Cursor can generate code with remarkable speed using LLMs, handling boilerplate and providing functional snippets for various tasks. However, when building robust systems, functional correctness is only the starting point. Code must also be safe, predictable, maintainable, and free from subtle side effects. This article demonstrates, through a dialogue between a developer and an LLM, how expert guidance is crucial to transform an initial, potentially unsafe code snippet into a robust, system-ready component. This development session was done as part of a larger development effort to write a BoltDB like storage engine for an internal workshop. This also demonstrates how breaking the larger development efforts into smaller programming sessions can be more effective with LLM based development. We'll use the common task of reading and writing a fixed-structure header within a Java ByteBuffer. The Conversation Begins Initial Prompt to Start the Conversation Can you show me how to write and read a simple page header structure to a Java ByteBuffer? The header should contain: Page Type (byte), Page Level (byte), Number of Keys (short), Free Space Offset (int), Right Sibling Page ID (int). LLM-Generated Code (Using position()) Certainly. Here's a basic example using ByteBuffer's position() method to manage reads and writes:” import java.nio.ByteBuffer; public class PageHeaderV1 { // Offsets (implicitly managed by position) private static final int PAGE_TYPE_OFFSET = 0; private static final int LEVEL_OFFSET = 1; // pageType is 1 byte private static final int NUM_KEYS_OFFSET = 2; // level is 1 byte private static final int FREE_SPACE_OFFSET_OFFSET = 4; // numKeys is 2 bytes private static final int RIGHT_SIBLING_OFFSET = 8; // freeSpaceOffset is 4 bytes public static final int HEADER_SIZE = 12; // rightSibling is 4 bytes public static void write(ByteBuffer buffer, byte pageType, byte level, short numKeys, int freeSpaceOffset, int rightSiblingPageId) { buffer.clear(); // Reset position to 0, limit to capacity buffer.position(PAGE_TYPE_OFFSET); buffer.put(pageType); buffer.position(LEVEL_OFFSET); buffer.put(level); buffer.position(NUM_KEYS_OFFSET); buffer.putShort(numKeys); buffer.position(FREE_SPACE_OFFSET_OFFSET); buffer.putInt(freeSpaceOffset); buffer.position(RIGHT_SIBLING_OFFSET); buffer.putInt(rightSiblingPageId); } public static byte getPageType(ByteBuffer buffer) { buffer.position(PAGE_TYPE_OFFSET); return buffer.get(); } public static byte getLevel(ByteBuffer buffer) { buffer.position(LEVEL_OFFSET); return buffer.get(); } public static short getNumKeys(ByteBuffer buffer) { buffer.position(NUM_KEYS_OFFSET); return buffer.getShort(); } public static int getFreeSpaceOffset(ByteBuffer buffer) { buffer.position(FREE_SPACE_OFFSET_OFFSET); return buffer.getInt(); } public static int getRightSiblingPageId(ByteBuffer buffer) { buffer.position(RIGHT_SIBLING_OFFSET); return buffer.getInt(); } } This code uses position() to move to the correct offset before each read or write. Developer Insight: The LLM produced functionally correct code for a simple case. However, the expert developer immediately recognizes a potential problem: the use of buffer.position(). This method modifies the state of the ByteBuffer object itself. Developer Suggests Absolute Offsets Thanks. However, constantly changing the buffer's position can cause issues, especially with shared buffers like MappedByteBuffer or in concurrent code. It introduces side effects. Can we rewrite this using the absolute get(index) and put(index, value) methods instead to make it stateless regarding the buffer's position? Developer Insight: The developer identifies the specific issue (side effects via state mutation) and understands the context where it becomes dangerous (shared buffers, concurrency). They guide the LLM towards a safer, stateless pattern. You are absolutely right. Using absolute offset methods avoids modifying the buffer's position state, which is much safer for shared or concurrent use cases. Here's how you can read the numKeys and freeSpaceOffset using the absolute methods: import java.nio.ByteBuffer; // Example correction for a couple of methods: public class PageHeaderCorrection { private static final int NUM_KEYS_OFFSET = 2; private static final int FREE_SPACE_OFFSET_OFFSET = 4; // Corrected getter using absolute offset public static short getNumKeys(ByteBuffer buffer) { return buffer.getShort(NUM_KEYS_OFFSET); // Reads at index 2, doesn't change position } // Corrected getter using absolute offset public static int getFreeSpaceOffset(ByteBuffer buffer) { return buffer.getInt(FREE_SPACE_OFFSET_OFFSET); // Reads at index 4, doesn't change position } // Similarly, writing would use put(index, value): public static void writeNumKeys(ByteBuffer buffer, short numKeys) { buffer.putShort(NUM_KEYS_OFFSET, numKeys); // Writes at index 2, doesn't change position } } Using get(index) and put(index, value) ensures the operations are side-effect-free concerning the buffer's position. Developer Insight: The LLM correctly implements the suggested pattern. The developer now pushes for better software design, moving from static utility methods to an object-oriented approach. Developer Requests Refactoring to Instance-Based Class Developer: “Excellent, that's exactly the pattern needed. Please provide the complete PageHeader class using only the absolute offset methods (get(index), put(index, value), getShort(index), putShort(index, value), etc.) for all fields. Also, let's refactor this. Instead of static methods, make PageHeader a class that takes the ByteBuffer in its constructor. It should act as a view or wrapper around that buffer section. Remove the static write method that takes all attributes. Instead, provide instance methods for getting and setting each field directly on the buffer provided in the constructor, still using the safe absolute offset methods.” Developer Insight: The developer applies software design principles: Encapsulation (wrapping the buffer) and Object-Oriented Design (instance methods acting on object state – the buffer reference). This improves usability and maintainability. LLM: “Understood. Refactoring the PageHeader into a class that wraps a ByteBuffer provided at construction is a good way to encapsulate header access for a specific page buffer. Here's the refactored class with instance methods for getting and setting fields using absolute offsets:” import java.nio.ByteBuffer; public class PageHeader { // Define constants for offsets and size private static final int OFFSET_PAGE_TYPE = 0; private static final int OFFSET_LEVEL = 1; private static final int OFFSET_NUM_KEYS = 2; private static final int OFFSET_FREE_SPACE = 4; private static final int OFFSET_RIGHT_SIBLING = 8; public static final int HEADER_SIZE = 12; // Total size of the header private final ByteBuffer buffer; // Store the buffer instance /** * Creates a PageHeader view wrapping the given ByteBuffer. * Assumes the buffer's relevant section starts at position 0 * or that the buffer slice/view is correctly positioned. * @param buffer The ByteBuffer containing the page data. */ public PageHeader(ByteBuffer buffer) { // Consider adding checks: buffer != null, buffer.capacity() \u003e= HEADER_SIZE this.buffer = buffer; } // --- Getters using absolute offsets --- public byte getPageType() { return buffer.get(OFFSET_PAGE_TYPE); } public byte getLevel() { return buffer.get(OFFSET_LEVEL); } public short getNumKeys() { return buffer.getShort(OFFSET_NUM_KEYS); } public int getFreeSpaceOffset() { return buffer.getInt(OFFSET_FREE_SPACE); } public int getRightSiblingPageId() { return buffer.getInt(OFFSET_RIGHT_SIBLING); } // --- Setters using absolute offsets --- public void setPageType(byte pageType) { buffer.put(OFFSET_PAGE_TYPE, pageType); } public void setLevel(byte level) { buffer.put(OFFSET_LEVEL, level); } public void setNumKeys(short numKeys) { buffer.putShort(OFFSET_NUM_KEYS, numKeys); } public void setFreeSpaceOffset(int freeSpaceOffset) { buffer.putInt(OFFSET_FREE_SPACE, freeSpaceOffset); } public void setRightSiblingPageId(int rightSiblingPageId) { buffer.putInt(OFFSET_RIGHT_SIBLING, rightSiblingPageId); } /** * Initializes a new header structure with default/zero values * in the underlying buffer. */ public void initializeNewHeader() { setPageType((byte) 0); setLevel((byte) 0); setNumKeys((short) 0); setFreeSpaceOffset(HEADER_SIZE); // Default free space starts after header setRightSiblingPageId(0); // Assuming 0 represents no sibling initially // Or use specific constants for null/invalid IDs if available } } This version encapsulates access to the header fields within an instance tied to a specific ByteBuffer. All read and write operations use absolute offsets, ensuring safety and avoiding side effects on the buffer's position. I've also added an example initializeNewHeader method for convenience. Takeaways: The importance of the developer role There are more improvements possible. But this dialogue highlights critical areas where developer expertise is indispensable when working with LLMs: Identifying Hidden Risks: The initial code worked, but the developer recognized the latent danger of side effects from position() in broader system contexts. Contextual Awareness: Understanding implications for MappedByteBuffer, concurrency, and library design was key to steering away from the stateful approach. Guiding Towards Robust Patterns: The developer explicitly prompted for stateless, absolute offset methods, leveraging deep knowledge of safe low-level programming practices. Applying Software Design Principles: The final refactoring wasn't just about correctness but about better design – encapsulation, instance-based logic, maintainability (constants), and usability. Critical Evaluation: Throughout the process, the developer critically evaluated the LLM's output against not just functional requirements but also non-functional requirements like safety, stability, and maintainability. Conclusion LLMs are incredibly powerful coding assistants, accelerating development and handling complex tasks. However, as this case study shows, they are tools that respond to guidance. Building robust, reliable, and performant systems, requires the critical thinking, contextual understanding, and deep systems knowledge of an experienced developer. The expert doesn't just prompt for code; they evaluate, guide, refine, and integrate, ensuring the final product meets the rigorous demands of real-world software engineering.",
  "image": "https://martinfowler.com/articles/exploring-gen-ai/donkey-card.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eAI editors like Cursor can generate code with remarkable speed using LLMs,\n    handling boilerplate and providing functional snippets for various tasks.\n    However, when building robust systems, functional correctness is only the\n    starting point. Code must also be safe, predictable, maintainable, and free\n    from subtle side effects.\u003c/p\u003e\n\n\u003cp\u003eThis article demonstrates, through a dialogue between a developer and an\n    LLM, how expert guidance is crucial to transform an initial, potentially\n    unsafe code snippet into a robust, system-ready component. This development\n    session was done as part of a larger development effort to write a BoltDB\n    like storage engine for an internal workshop. This also demonstrates how\n    breaking the larger development efforts into smaller programming sessions\n    can be more effective with LLM based development. We\u0026#39;ll use the common task\n    of reading and writing a fixed-structure header within a Java ByteBuffer.\n    \u003c/p\u003e\n\n\n\n\u003csection id=\"TheConversationBegins\"\u003e\n\u003ch2\u003eThe Conversation Begins\u003c/h2\u003e\n\n\u003cp\u003eInitial Prompt to Start the Conversation\u003c/p\u003e\n\n\u003cp\u003eCan you show me how to write and read a simple page header\n        structure to a Java ByteBuffer? The header should contain: Page Type (byte),\n        Page Level (byte), Number of Keys (short), Free Space Offset (int), Right\n        Sibling Page ID (int).\u003c/p\u003e\n\n\u003cp\u003eLLM-Generated Code (Using position())\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cp\u003eCertainly. Here\u0026#39;s a basic example using ByteBuffer\u0026#39;s position()\n        method to manage reads and writes:”\u003c/p\u003e\n\n\u003cpre\u003eimport java.nio.ByteBuffer;\n\npublic class PageHeaderV1 {\n    // Offsets (implicitly managed by position)\n    private static final int PAGE_TYPE_OFFSET = 0;\n    private static final int LEVEL_OFFSET = 1; // pageType is 1 byte\n    private static final int NUM_KEYS_OFFSET = 2; // level is 1 byte\n    private static final int FREE_SPACE_OFFSET_OFFSET = 4; // numKeys is 2 bytes\n    private static final int RIGHT_SIBLING_OFFSET = 8; // freeSpaceOffset is 4 bytes\n    public static final int HEADER_SIZE = 12; // rightSibling is 4 bytes\n\n    public static void write(ByteBuffer buffer, byte pageType, byte level, short numKeys, int freeSpaceOffset, int rightSiblingPageId) {\n        buffer.clear(); // Reset position to 0, limit to capacity\n\n        buffer.position(PAGE_TYPE_OFFSET);\n        buffer.put(pageType);\n\n        buffer.position(LEVEL_OFFSET);\n        buffer.put(level);\n\n        buffer.position(NUM_KEYS_OFFSET);\n        buffer.putShort(numKeys);\n\n        buffer.position(FREE_SPACE_OFFSET_OFFSET);\n        buffer.putInt(freeSpaceOffset);\n\n        buffer.position(RIGHT_SIBLING_OFFSET);\n        buffer.putInt(rightSiblingPageId);\n    }\n\n    public static byte getPageType(ByteBuffer buffer) {\n        buffer.position(PAGE_TYPE_OFFSET);\n        return buffer.get();\n    }\n\n    public static byte getLevel(ByteBuffer buffer) {\n        buffer.position(LEVEL_OFFSET);\n        return buffer.get();\n    }\n\n    public static short getNumKeys(ByteBuffer buffer) {\n        buffer.position(NUM_KEYS_OFFSET);\n        return buffer.getShort();\n    }\n\n    public static int getFreeSpaceOffset(ByteBuffer buffer) {\n        buffer.position(FREE_SPACE_OFFSET_OFFSET);\n        return buffer.getInt();\n    }\n\n    public static int getRightSiblingPageId(ByteBuffer buffer) {\n        buffer.position(RIGHT_SIBLING_OFFSET);\n        return buffer.getInt();\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eThis code uses position() to move to the correct offset before each read\n        or write.\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cb\u003eDeveloper Insight\u003c/b\u003e: The LLM produced functionally correct code for a\n      simple case. However, the expert developer immediately recognizes a potential\n      problem: the use of \u003ccode\u003ebuffer.position()\u003c/code\u003e. This method modifies the state of the\n      ByteBuffer object itself.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"DeveloperSuggestsAbsoluteOffsets\"\u003e\n\u003ch2\u003eDeveloper Suggests Absolute Offsets\u003c/h2\u003e\n\n\u003cp\u003eThanks. However, constantly changing the buffer\u0026#39;s position can\n        cause issues, especially with shared buffers like MappedByteBuffer or in\n        concurrent code. It introduces side effects. Can we rewrite this using the\n        absolute get(index) and put(index, value) methods instead to make it stateless\n        regarding the buffer\u0026#39;s position?\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003eDeveloper Insight\u003c/b\u003e: The developer identifies the specific issue (side\n      effects via state mutation) and understands the context where it becomes\n      dangerous (shared buffers, concurrency). They guide the LLM towards a safer,\n      stateless pattern.\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cp\u003eYou are absolutely right. Using absolute offset methods avoids\n        modifying the buffer\u0026#39;s position state, which is much safer for shared or\n        concurrent use cases. Here\u0026#39;s how you can read the numKeys and freeSpaceOffset\n        using the absolute methods:\u003c/p\u003e\n\n\u003cpre\u003eimport java.nio.ByteBuffer;\n\n// Example correction for a couple of methods:\npublic class PageHeaderCorrection {\n    private static final int NUM_KEYS_OFFSET = 2;\n    private static final int FREE_SPACE_OFFSET_OFFSET = 4;\n\n    // Corrected getter using absolute offset\n    public static short getNumKeys(ByteBuffer buffer) {\n        return buffer.getShort(NUM_KEYS_OFFSET); // Reads at index 2, doesn\u0026#39;t change position\n    }\n\n    // Corrected getter using absolute offset\n    public static int getFreeSpaceOffset(ByteBuffer buffer) {\n        return buffer.getInt(FREE_SPACE_OFFSET_OFFSET); // Reads at index 4, doesn\u0026#39;t change position\n    }\n\n    // Similarly, writing would use put(index, value):\n    public static void writeNumKeys(ByteBuffer buffer, short numKeys) {\n         buffer.putShort(NUM_KEYS_OFFSET, numKeys); // Writes at index 2, doesn\u0026#39;t change position\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eUsing get(index) and put(index, value) ensures the operations are\n        side-effect-free concerning the buffer\u0026#39;s position.\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cb\u003eDeveloper Insight\u003c/b\u003e: The LLM correctly implements the suggested pattern.\n      The developer now pushes for better software design, moving from static\n      utility methods to an object-oriented approach.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"DeveloperRequestsRefactoringToInstance-basedClass\"\u003e\n\u003ch2\u003eDeveloper Requests Refactoring to Instance-Based Class\u003c/h2\u003e\n\n\u003cp\u003eDeveloper: “Excellent, that\u0026#39;s exactly the pattern needed. Please provide\n        the complete PageHeader class using only the absolute offset methods\n        (get(index), put(index, value), getShort(index), putShort(index, value), etc.)\n        for all fields. Also, let\u0026#39;s refactor this. Instead of static methods, make\n        PageHeader a class that takes the ByteBuffer in its constructor. It should act\n        as a view or wrapper around that buffer section. Remove the static write\n        method that takes all attributes. Instead, provide instance methods for\n        getting and setting each field directly on the buffer provided in the\n        constructor, still using the safe absolute offset methods.”\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003eDeveloper Insight\u003c/b\u003e: The developer applies software design principles:\n      Encapsulation (wrapping the buffer) and Object-Oriented Design (instance\n      methods acting on object state – the buffer reference). This improves\n      usability and maintainability.\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cp\u003eLLM: “Understood. Refactoring the PageHeader into a class that wraps a\n        ByteBuffer provided at construction is a good way to encapsulate header access\n        for a specific page buffer. Here\u0026#39;s the refactored class with instance methods\n        for getting and setting fields using absolute offsets:”\u003c/p\u003e\n\n\u003cpre\u003eimport java.nio.ByteBuffer;\n\npublic class PageHeader {\n    // Define constants for offsets and size\n    private static final int OFFSET_PAGE_TYPE = 0;\n    private static final int OFFSET_LEVEL = 1;\n    private static final int OFFSET_NUM_KEYS = 2;\n    private static final int OFFSET_FREE_SPACE = 4;\n    private static final int OFFSET_RIGHT_SIBLING = 8;\n    public static final int HEADER_SIZE = 12; // Total size of the header\n\n    private final ByteBuffer buffer; // Store the buffer instance\n\n    /**\n     * Creates a PageHeader view wrapping the given ByteBuffer.\n     * Assumes the buffer\u0026#39;s relevant section starts at position 0\n     * or that the buffer slice/view is correctly positioned.\n     * @param buffer The ByteBuffer containing the page data.\n     */\n    public PageHeader(ByteBuffer buffer) {\n        // Consider adding checks: buffer != null, buffer.capacity() \u0026gt;= HEADER_SIZE\n        this.buffer = buffer;\n    }\n\n    // --- Getters using absolute offsets ---\n\n    public byte getPageType() {\n        return buffer.get(OFFSET_PAGE_TYPE);\n    }\n\n    public byte getLevel() {\n        return buffer.get(OFFSET_LEVEL);\n    }\n\n    public short getNumKeys() {\n        return buffer.getShort(OFFSET_NUM_KEYS);\n    }\n\n    public int getFreeSpaceOffset() {\n        return buffer.getInt(OFFSET_FREE_SPACE);\n    }\n\n    public int getRightSiblingPageId() {\n        return buffer.getInt(OFFSET_RIGHT_SIBLING);\n    }\n\n    // --- Setters using absolute offsets ---\n\n    public void setPageType(byte pageType) {\n        buffer.put(OFFSET_PAGE_TYPE, pageType);\n    }\n\n    public void setLevel(byte level) {\n        buffer.put(OFFSET_LEVEL, level);\n    }\n\n    public void setNumKeys(short numKeys) {\n        buffer.putShort(OFFSET_NUM_KEYS, numKeys);\n    }\n\n    public void setFreeSpaceOffset(int freeSpaceOffset) {\n        buffer.putInt(OFFSET_FREE_SPACE, freeSpaceOffset);\n    }\n\n    public void setRightSiblingPageId(int rightSiblingPageId) {\n        buffer.putInt(OFFSET_RIGHT_SIBLING, rightSiblingPageId);\n    }\n\n    /**\n     * Initializes a new header structure with default/zero values\n     * in the underlying buffer.\n     */\n    public void initializeNewHeader() {\n        setPageType((byte) 0);\n        setLevel((byte) 0);\n        setNumKeys((short) 0);\n        setFreeSpaceOffset(HEADER_SIZE); // Default free space starts after header\n        setRightSiblingPageId(0); // Assuming 0 represents no sibling initially\n        // Or use specific constants for null/invalid IDs if available\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eThis version encapsulates access to the header fields within an instance\n        tied to a specific ByteBuffer. All read and write operations use absolute\n        offsets, ensuring safety and avoiding side effects on the buffer\u0026#39;s position.\n        I\u0026#39;ve also added an example initializeNewHeader method for convenience.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/section\u003e\n\n\u003csection id=\"TakeawaysTheImportanceOfTheDeveloperRole\"\u003e\n\u003ch2\u003eTakeaways: The importance of the developer role\u003c/h2\u003e\n\n\u003cp\u003eThere are more improvements possible. But this dialogue highlights critical areas where developer expertise is\n      indispensable when working with LLMs:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cb\u003eIdentifying Hidden Risks\u003c/b\u003e: The initial code worked, but the developer\n        recognized the latent danger of side effects from \u003ccode\u003eposition()\u003c/code\u003e in broader system\n        contexts.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eContextual Awareness\u003c/b\u003e: Understanding implications for\n        MappedByteBuffer, concurrency, and library design was key to steering away from\n        the stateful approach.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eGuiding Towards Robust Patterns\u003c/b\u003e: The developer explicitly prompted\n        for stateless, absolute offset methods, leveraging deep knowledge of safe\n        low-level programming practices.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eApplying Software Design Principles\u003c/b\u003e: The final refactoring wasn\u0026#39;t\n        just about correctness but about better design – encapsulation, instance-based\n        logic, maintainability (constants), and usability.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eCritical Evaluation\u003c/b\u003e: Throughout the process, the developer critically\n        evaluated the LLM\u0026#39;s output against not just functional requirements but also\n        non-functional requirements like safety, stability, and maintainability.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Conclusion\"\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eLLMs are incredibly powerful coding assistants, accelerating development\n      and handling complex tasks. However, as this case study shows, they are tools\n      that respond to guidance. Building robust, reliable, and performant systems,\n      requires the critical thinking, contextual understanding, and deep systems\n      knowledge of an experienced developer. The expert doesn\u0026#39;t just prompt for\n      code; they evaluate, guide, refine, and integrate, ensuring the final product\n      meets the rigorous demands of real-world software engineering.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003chr/\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": null,
  "modifiedTime": "2025-04-17T00:00:00Z"
}
