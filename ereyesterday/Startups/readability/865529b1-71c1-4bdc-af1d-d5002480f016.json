{
  "id": "865529b1-71c1-4bdc-af1d-d5002480f016",
  "title": "A better approach to gravity: how we made EGM2008 faster",
  "link": "https://www.elodin.systems/post/a-better-approach-to-gravity-how-we-made-egm2008-faster",
  "description": "Article URL: https://www.elodin.systems/post/a-better-approach-to-gravity-how-we-made-egm2008-faster Comments URL: https://news.ycombinator.com/item?id=42300841 Points: 21 # Comments: 6",
  "author": "sphw",
  "published": "Mon, 02 Dec 2024 21:55:13 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 7335,
  "excerpt": "‍",
  "siteName": "",
  "favicon": "https://cdn.prod.website-files.com/65b83ac4cf86c236d2b91487/65c6b203a575b67a4d99023b_32x32.png",
  "text": "‍For the last month we've been hard at work adding a new feature to Elodin, an ultra-high-speed implementation of EGM2008. EGM2008 – or Earth Gravitational Model 2008 for those acronym phobic readers – a high precision model of Earth's gravitational field.. What once required significant computational resources can now run in milliseconds, unlocking new possibilities for satellite missions, constellation management, and more.‍You’d think we could stick to Newton’s classic gravity model (aka the Coulomb model) to explain everything about Earth’s gravitational field. It’d be great if it were that simple, but planetary gravity is far messier. Earth isn’t a perfectly smooth, uniformly dense sphere; it’s more like a slightly squished ball (an oblate spheroid) with bumps and dips from mountains, ocean trenches, and uneven internal mass distribution. So early on (before the space age), scientists began measuring Earth’s gravitational field - using ground-based techniques like pendulum experiments. Though pendulums provided more accuracy than the coulomb model, in order to get accurate enough data for something as simple as an orbit simulation, the pendulums would be unfathomably massive.‍That all started to change in 1957 with the launch of Sputnik I, the first satellite to reveal how gravity could be studied through its effects on orbits. Early missions like Vanguard and Transit laid the groundwork, giving scientists basic estimates of Earth’s gravity. But the technology of the time had its limits—data was sparse, and computers were primitive. Over the years, advanced satellites like Topex/Poseidon and Lageos brought more detailed and accurate measurements, transforming our understanding of Earth’s gravitational quirks.‍Fast forward to today, and EGM2008 is the cornerstone of high-precision gravity models. It accounts for every bump and dip, every subtle anomaly in Earth’s gravity field, capturing details earlier methods could never achieve. A big part of this leap forward came from GRACE (Gravity Recovery and Climate Experiment) satellites. Launched in 2002, GRACE used twin satellites to measure tiny variations in Earth’s gravity by tracking the distance between them as they orbited the planet. These variations revealed shifts in mass—whether from melting ice caps, ocean currents, or changes in groundwater. GRACE provided an unprecedented view of how gravity changes over time and space, feeding crucial data into the EGM2008 model. Combined with data from earlier missions like Topex/Poseidon and Lageos, GRACE helped create a model that doesn’t just map Earth’s gravity—it tells the story of its dynamic changes.‍But how does EGM2008 actually work? ‍EGM2008 uses math inspired by quantum physics, known as spherical harmonics (think solutions to the Schrödinger equation for atoms) to break Earth’s gravity field into components of different “degrees” and “orders.” Each degree and order represents a different level of detail or “frequency” in the gravity field, much like how quantum physics uses harmonics to describe energy levels and probabilities. If you look at the visualization of these mathematical models, it makes perfect sense—they map peaks and valleys across a semi-spherical surface with uncanny precision.To avoid reinventing the wheel, I looked for a library that already implemented EGM2008, but unfortunately, none could support real-time simulation effectively.  So I set off on a journey to implement the EGM2008 gravity model into our simulation platform. Like any good expedition team preparing for uncharted waters, I stocked up on critical supplies: energy drinks (far too many), research papers, and modern sea shanties (nothing helps me focus like the Interstellar soundtrack). After poring over four different academic papers, I decided to try implementing the approach outlined in one.‍My first attempt? Pretty straightforward: take the math from the paper and translate it directly into code. Most of my time was spent decoding the intricate mathematical gymnastics Dr. Schaub and Dr. Martin performed in their equations. After a week of abusing energy drinks and wrecking my sleep schedule, I finally had a working gravity model. But when I tested it, disaster struck—the calculations were taking ~1.2 seconds for fidelity levels appropriate for a LEO satellite orbit. All that effort for an implementation slower than MATLAB? Unacceptable.Determined to boost performance, I turned to some dark magic: JAX. I took another shot at implementing the paper’s math, this time “JAXified”. By replacing all the for loops with JAXs “fori” function, I hacked together a new implementation. The results? Marginal improvements—still far from acceptable. At this point, it seemed pointless to switch libraries or try another paper’s approach.While marinating in defeat, I realized that the mathematical steps in the paper weren’t compatible with JAX’s optimizations, due to heavy use of conditionals and recursion (both big no-nos in JAX). The strength of JAX lies in its ability to perform vector computation, utilizing specialized instructions for simultaneous array operations. Recursion and conditional expressions, however, prevent the use of vectorization, resulting in slower execution. With this insight, I set out to reformulate the math to better align with JAX’s computation schemes. As I worked, I found even more areas to optimize. With a new mission plan, I dove in.First, I reformulated all the math to use array operations (snippet of the reformulation is shown below). This way, I was able to swap out for-loops for combinations of JAX’s scan and vmap functions and compute the addend of these summation blocks by using traditional array operations rather than traversing through them and doing element by element scalar operationsFinally, I replaced all conditional execution with precomputed steps or JAX-friendly conditional blocks. Sounds simple enough, right? (Hint: it wasn’t.) It took an entire weekend to reformulate the math and another week of 10- to 12-hour days to implement it. But in the end, I had a working model. Not just any model—my implementation wasn’t just a few milliseconds faster than others. It was orders of magnitude faster.Benchmarking revealed that we are the only available platform capable of simulating gravity using the EGM2008 model at full resolution in real time. That means our platform doesn’t just simulate satellite orbits in real time—it can simulate entire constellations on a laptop. Who’s the fastest kid on the block now, MATLAB? ‍If being blazing fast wasn’t enough, our library is easy to use as well. Typically EGM models are very hard to use – they are embedded in proprietary software and hard to integrate with your existing software stack. Elodin has solved this by exposing our EGM model through a simple Python interface:‍gravity_model = egm08.EGM08(defree = 2159, use_j2= False) gravity_force_vector = gravity_model.compute_field(pos_x, pos_y, pos_z, mass)‍This breakthrough opens up a whole new world for space simulations, enabling applications like constellation planning, space debris management, fuel budgeting, and control system design. The possibilities are endless, and we’re just getting started. We’re excited to see how people can use our platform's newest addition to tackle new challenges.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-w-id=\"9ab7e733-2bd2-7d8c-9ee9-9e1cd6085149\"\u003e\u003cp\u003e‍\u003c/p\u003e\u003cp\u003eFor the last month we\u0026#39;ve been hard at work adding a new feature to Elodin, an ultra-high-speed implementation of EGM2008. EGM2008 – or Earth Gravitational Model 2008 for those acronym phobic readers – a high precision model of Earth\u0026#39;s gravitational field.. What once required significant computational resources can now run in milliseconds, unlocking new possibilities for satellite missions, constellation management, and more.\u003c/p\u003e\u003cp\u003e‍\u003c/p\u003e\u003cp\u003eYou’d think we could stick to Newton’s classic gravity model (aka the Coulomb model) to explain everything about Earth’s gravitational field. It’d be great if it were that simple, but planetary gravity is far messier. Earth isn’t a perfectly smooth, uniformly dense sphere; it’s more like a slightly squished ball (an oblate spheroid) with bumps and dips from mountains, ocean trenches, and uneven internal mass distribution. So early on (before the space age), scientists began measuring Earth’s gravitational field - using ground-based techniques like pendulum experiments. Though pendulums provided more accuracy than the coulomb model, in order to get accurate enough data for something as simple as an orbit simulation, the pendulums would be unfathomably massive.\u003c/p\u003e\u003cp\u003e‍\u003c/p\u003e\u003cp\u003eThat all started to change in 1957 with the launch of Sputnik I, the first satellite to reveal how gravity could be studied through its effects on orbits. Early missions like Vanguard and Transit laid the groundwork, giving scientists basic estimates of Earth’s gravity. But the technology of the time had its limits—data was sparse, and computers were primitive. Over the years, advanced satellites like Topex/Poseidon and Lageos brought more detailed and accurate measurements, transforming our understanding of Earth’s gravitational quirks.\u003c/p\u003e\u003cp\u003e‍\u003c/p\u003e\u003cp\u003eFast forward to today, and EGM2008 is the cornerstone of high-precision gravity models. It accounts for every bump and dip, every subtle anomaly in Earth’s gravity field, capturing details earlier methods could never achieve. A big part of this leap forward came from GRACE (Gravity Recovery and Climate Experiment) satellites. Launched in 2002, GRACE used twin satellites to measure tiny variations in Earth’s gravity by tracking the distance between them as they orbited the planet. These variations revealed shifts in mass—whether from melting ice caps, ocean currents, or changes in groundwater. GRACE provided an unprecedented view of how gravity changes over time and space, feeding crucial data into the EGM2008 model. Combined with data from earlier missions like Topex/Poseidon and Lageos, GRACE helped create a model that doesn’t just map Earth’s gravity—it tells the story of its dynamic changes.\u003c/p\u003e\u003cp\u003e‍\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eBut how does EGM2008 actually work? \u003c/strong\u003e‍\u003cbr/\u003eEGM2008 uses math inspired by quantum physics, known as spherical harmonics (think solutions to the Schrödinger equation for atoms) to break Earth’s gravity field into components of different “degrees” and “orders.” Each degree and order represents a different level of detail or “frequency” in the gravity field, much like how quantum physics uses harmonics to describe energy levels and probabilities. If you look at the visualization of these mathematical models, it makes perfect sense—they map peaks and valleys across a semi-spherical surface with uncanny precision.\u003c/p\u003e\u003cfigure\u003e\u003cp\u003e\u003cimg src=\"https://cdn.prod.website-files.com/65badeacc94ad9eb3ec9c27e/674e1781ee139d4424b58c24_674e177485b624c4997784d5_spherical%2520harmonics.jpeg\" loading=\"lazy\" alt=\"\"/\u003e\u003c/p\u003e\u003c/figure\u003e\u003cp\u003eTo avoid reinventing the wheel, I looked for a library that already implemented EGM2008, but unfortunately, none could support real-time simulation effectively.  So I set off on a journey to implement the EGM2008 gravity model into our simulation platform. Like any good expedition team preparing for uncharted waters, I stocked up on critical supplies: energy drinks (far too many), research papers, and modern sea shanties (nothing helps me focus like the Interstellar soundtrack). After poring over four different academic papers, I decided to try implementing the approach outlined in \u003ca href=\"https://hanspeterschaub.info/conferences.html#:~:text=GPGPU%20Implementation%20Of%20Pines%E2%80%99%20Spherical%20Harmonic%20Gravity%20Model\" target=\"_blank\"\u003eone\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e‍\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMy first attempt?\u003c/strong\u003e \u003cbr/\u003ePretty straightforward: take the math from the paper and translate it directly into code. Most of my time was spent decoding the intricate mathematical gymnastics Dr. Schaub and Dr. Martin performed in their equations. After a week of abusing energy drinks and wrecking my sleep schedule, I finally had a working gravity model. But when I tested it, disaster struck—the calculations were taking ~1.2 seconds for fidelity levels appropriate for a LEO satellite orbit. All that effort for an implementation slower than MATLAB? Unacceptable.\u003c/p\u003e\u003cp\u003eDetermined to boost performance, I turned to some dark magic: \u003ca href=\"https://github.com/jax-ml/jax\" target=\"_blank\"\u003eJAX\u003c/a\u003e. I took another shot at implementing the paper’s math, this time “JAXified”. By replacing all the for loops with JAXs “fori” function, I hacked together a new implementation. The results? Marginal improvements—still far from acceptable. At this point, it seemed pointless to switch libraries or try another paper’s approach.\u003c/p\u003e\u003cp\u003eWhile marinating in defeat, I realized that the mathematical steps in the paper weren’t compatible with JAX’s optimizations, due to heavy use of conditionals and recursion (both big no-nos in JAX). The strength of JAX lies in its ability to perform vector computation, utilizing specialized instructions for simultaneous array operations. Recursion and conditional expressions, however, prevent the use of vectorization, resulting in slower execution. With this insight, I set out to reformulate the math to better align with JAX’s computation schemes. As I worked, I found even more areas to optimize. With a new mission plan, I dove in.\u003c/p\u003e\u003cp\u003eFirst, I reformulated all the math to use array operations (snippet of the reformulation is shown below). This way, I was able to swap out for-loops for combinations of JAX’s scan and vmap functions and compute the addend of these summation blocks by using traditional array operations rather than traversing through them and doing element by element scalar operations\u003c/p\u003e\u003cfigure\u003e\u003cp\u003e\u003cimg src=\"https://cdn.prod.website-files.com/65badeacc94ad9eb3ec9c27e/674e1c257c3ebf9d7f53e546_AD_4nXcinqZAgKhs49nM9DxRepLjnUHvGI-TEh8VWjf_3gO8Xa3M5PQXJPEhGg_AHMonF_0bHkiUEE6B0lt19Ud_KetDYbVwH8XFCqMNcMc4I70eZ03hzSVzFl0cH5A-gors9AqEhimPWw.png\" loading=\"lazy\" alt=\"\"/\u003e\u003c/p\u003e\u003c/figure\u003e\u003cp\u003eFinally, I replaced all conditional execution with precomputed steps or JAX-friendly conditional blocks. Sounds simple enough, right? (Hint: it wasn’t.) It took an entire weekend to reformulate the math and another week of 10- to 12-hour days to implement it. But in the end, I had a working model. Not just any model—my implementation wasn’t just a few milliseconds faster than others. \u003cstrong\u003eIt was orders of magnitude faster.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eBenchmarking revealed that we are the only available platform capable of simulating gravity using the EGM2008 model at full resolution in real time. That means our platform doesn’t just simulate satellite orbits in real time—it can simulate entire constellations on a laptop. Who’s the fastest kid on the block now, MATLAB? \u003c/p\u003e\u003cfigure\u003e\u003cp\u003e\u003cimg src=\"https://cdn.prod.website-files.com/65badeacc94ad9eb3ec9c27e/674e1e85bfbe09ad5883c4c2_674e1e7cfe5b82a2b5a2b6dc_benchmark.png\" loading=\"lazy\" alt=\"\"/\u003e\u003c/p\u003e\u003c/figure\u003e\u003cp\u003e‍\u003c/p\u003e\u003cp\u003eIf being blazing fast wasn’t enough, our library is easy to use as well. Typically EGM models are very hard to use – they are embedded in proprietary software and hard to integrate with your existing software stack. Elodin has solved this by exposing our EGM model through a simple Python interface:\u003c/p\u003e\u003cp\u003e‍\u003c/p\u003e\u003cpre contenteditable=\"false\"\u003e\u003ccode\u003e\u003cspan\u003egravity_model = egm08.EGM08(defree = \u003c/span\u003e\u003cspan\u003e2159\u003c/span\u003e\u003cspan\u003e, use_j2= False)\n\u003c/span\u003egravity_force_vector = gravity_model.compute_field(pos_x, pos_y, pos_z, mass)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e‍\u003c/p\u003e\u003cp\u003eThis breakthrough opens up a whole new world for space simulations, enabling applications like constellation planning, space debris management, fuel budgeting, and control system design. The possibilities are endless, and we’re just getting started. We’re excited to see how people can use our platform\u0026#39;s newest addition to tackle new challenges.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
