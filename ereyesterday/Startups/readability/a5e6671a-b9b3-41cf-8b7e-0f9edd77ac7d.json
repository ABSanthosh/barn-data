{
  "id": "a5e6671a-b9b3-41cf-8b7e-0f9edd77ac7d",
  "title": "Shift-to-Middle Array: A Faster Alternative to Std:Deque?",
  "link": "https://github.com/attilatorda/Shift-To-Middle_Array",
  "description": "Article URL: https://github.com/attilatorda/Shift-To-Middle_Array Comments URL: https://news.ycombinator.com/item?id=43456669 Points: 42 # Comments: 26",
  "author": "AttilaT",
  "published": "Sun, 23 Mar 2025 23:20:27 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "attilatorda",
  "length": 3509,
  "excerpt": "An innovative data struicture for implementing lists and deques - attilatorda/Shift-To-Middle_Array",
  "siteName": "GitHub",
  "favicon": "https://github.com/fluidicon.png",
  "text": "Shift-To-Middle Array The Shift-To-Middle Array is a dynamic array designed to optimize insertions and deletions at both ends, offering a high-performance alternative to std::deque, std::vector, and linked lists. It achieves this while maintaining contiguous memory storage, improving cache locality and enabling efficient parallel processing. üåü Features ‚úÖ Amortized O(1) insertions \u0026 deletions at both ends ‚úÖ Fast random access (O(1)) ‚úÖ Better cache locality than linked lists ‚úÖ Supports SIMD \u0026 parallel optimizations ‚úÖ Efficient memory usage compared to std::deque üìå How It Works Unlike std::deque, which uses a fragmented block structure, the Shift-To-Middle Array dynamically redistributes space to avoid costly shifts. When resizing, elements are moved toward the middle, ensuring efficient insertions at both ends without excessive copying. üöÄ Time Complexity Comparison The following table compares the time complexity of Shift-To-Middle Array operations with other common data structures: Operation ArrayList (std::vector) Linked List Shift-To-Middle Array Access (by index) O(1) O(n) O(1) Insertion at head O(n) O(1) O(1) amortized Insertion at tail O(1) amortized O(1) O(1) amortized Insertion in middle O(n) O(n) O(n) Deletion at head O(n) O(1) O(1) amortized Deletion at tail O(1) O(1) O(1) amortized Deletion in middle O(n) O(n) O(n) Cache Locality Excellent Poor Excellent üèÜ Performance Benchmarks Benchmarks comparing Shift-To-Middle Array vs. std::deque vs. ExpandingRingBuffer vs. std::queue demonstrate that performance improvements depend on CPU and GPU capabilities, such as multi-core parallelism, SIMD optimizations, and cache efficiency. The benchmarks were compiled using GCC with the -O3 optimization flag, ensuring high-performance execution. Results vary based on hardware specifications and workload characteristics. üìÇ Installation \u0026 Usage To use Shift-To-Middle Array in your project: #include \"ShiftToMiddleArray.h\" ShiftToMiddleArray\u003cint\u003e stmArray; stmArray.insert_head(42); stmArray.insert_tail(99); int value = stmArray.get_head(); stmArray.remove_head(); üî¨ When To Use High-performance queue structures Game engines \u0026 real-time applications Networking (packet buffering, event queues) Dynamic sequences in computational geometry \u0026 physics üìñ Documentation Running Java Benchmarks To run the Java benchmarks, ensure you have the Trove library installed. Compile and execute using: javac -cp trove-3.0.3.jar; ShiftToMiddleArrayBenchmarkTrove.java java -cp trove-3.0.3.jar; ShiftToMiddleArrayBenchmarkTrove Full API reference and benchmarks are available in the Wiki! üìä Benchmarks \u0026 Results For full benchmark details, check out the benchmarks report. The provided Python scripts can be used to visualize performance metrics from CSV benchmark results. üèõ History The Shift-To-Middle Array was developed as part of an effort to create a more efficient implementation strategy for lists and deques. Traditional data structures, such as std::deque and linked lists, suffer from poor cache locality or fragmented memory allocations, leading to inefficiencies. By leveraging contiguous memory, dynamic mid-shifting, and modern CPU optimizations, Shift-To-Middle Array provides a balanced solution for insertion, deletion, and access performance. üìú License This project is licensed under the MIT License. ü§ù Contributing Contributions are welcome! Feel free to open an issue or pull request. üöÄ Try Shift-To-Middle Array today and optimize your data structures!",
  "image": "https://opengraph.githubassets.com/7930173fed8e68589638e5dd93504bd1e8f83cb6af6492c6bf89f0345af83607/attilatorda/Shift-To-Middle_Array",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-hpc=\"true\"\u003e\u003carticle itemprop=\"text\"\u003e\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eShift-To-Middle Array\u003c/h2\u003e\u003ca id=\"user-content-shift-to-middle-array\" aria-label=\"Permalink: Shift-To-Middle Array\" href=\"#shift-to-middle-array\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe \u003cstrong\u003eShift-To-Middle Array\u003c/strong\u003e is a dynamic array designed to optimize \u003cstrong\u003einsertions and deletions at both ends\u003c/strong\u003e, offering a high-performance alternative to \u003ccode\u003estd::deque\u003c/code\u003e, \u003ccode\u003estd::vector\u003c/code\u003e, and linked lists. It achieves this while maintaining \u003cstrong\u003econtiguous memory storage\u003c/strong\u003e, improving \u003cstrong\u003ecache locality\u003c/strong\u003e and enabling \u003cstrong\u003eefficient parallel processing\u003c/strong\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/attilatorda/Shift-To-Middle_Array/blob/main/stm.png\"\u003e\u003cimg src=\"https://github.com/attilatorda/Shift-To-Middle_Array/raw/main/stm.png\" alt=\"Shift-To-Middle Array\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eüåü Features\u003c/h2\u003e\u003ca id=\"user-content--features\" aria-label=\"Permalink: üåü Features\" href=\"#-features\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e‚úÖ \u003cstrong\u003eAmortized O(1) insertions \u0026amp; deletions at both ends\u003c/strong\u003e\u003cbr/\u003e\n‚úÖ \u003cstrong\u003eFast random access (O(1))\u003c/strong\u003e\u003cbr/\u003e\n‚úÖ \u003cstrong\u003eBetter cache locality than linked lists\u003c/strong\u003e\u003cbr/\u003e\n‚úÖ \u003cstrong\u003eSupports SIMD \u0026amp; parallel optimizations\u003c/strong\u003e\u003cbr/\u003e\n‚úÖ \u003cstrong\u003eEfficient memory usage compared to \u003ccode\u003estd::deque\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eüìå How It Works\u003c/h2\u003e\u003ca id=\"user-content--how-it-works\" aria-label=\"Permalink: üìå How It Works\" href=\"#-how-it-works\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eUnlike \u003ccode\u003estd::deque\u003c/code\u003e, which uses a fragmented block structure, the \u003cstrong\u003eShift-To-Middle Array\u003c/strong\u003e dynamically \u003cstrong\u003eredistributes space\u003c/strong\u003e to avoid costly shifts. When resizing, elements are moved toward the middle, ensuring \u003cstrong\u003eefficient insertions at both ends\u003c/strong\u003e without excessive copying.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eüöÄ Time Complexity Comparison\u003c/h2\u003e\u003ca id=\"user-content--time-complexity-comparison\" aria-label=\"Permalink: üöÄ Time Complexity Comparison\" href=\"#-time-complexity-comparison\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe following table compares the time complexity of Shift-To-Middle Array operations with other common data structures:\u003c/p\u003e\n\u003cmarkdown-accessiblity-table\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eOperation\u003c/th\u003e\n\u003cth\u003eArrayList (\u003ccode\u003estd::vector\u003c/code\u003e)\u003c/th\u003e\n\u003cth\u003eLinked List\u003c/th\u003e\n\u003cth\u003eShift-To-Middle Array\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eAccess (by index)\u003c/td\u003e\n\u003ctd\u003eO(1)\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003ctd\u003eO(1)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eInsertion at head\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003ctd\u003eO(1)\u003c/td\u003e\n\u003ctd\u003eO(1) amortized\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eInsertion at tail\u003c/td\u003e\n\u003ctd\u003eO(1) amortized\u003c/td\u003e\n\u003ctd\u003eO(1)\u003c/td\u003e\n\u003ctd\u003eO(1) amortized\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eInsertion in middle\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDeletion at head\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003ctd\u003eO(1)\u003c/td\u003e\n\u003ctd\u003eO(1) amortized\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDeletion at tail\u003c/td\u003e\n\u003ctd\u003eO(1)\u003c/td\u003e\n\u003ctd\u003eO(1)\u003c/td\u003e\n\u003ctd\u003eO(1) amortized\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDeletion in middle\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCache Locality\u003c/td\u003e\n\u003ctd\u003eExcellent\u003c/td\u003e\n\u003ctd\u003ePoor\u003c/td\u003e\n\u003ctd\u003eExcellent\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\u003c/markdown-accessiblity-table\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eüèÜ Performance Benchmarks\u003c/h2\u003e\u003ca id=\"user-content--performance-benchmarks\" aria-label=\"Permalink: üèÜ Performance Benchmarks\" href=\"#-performance-benchmarks\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eBenchmarks comparing \u003cstrong\u003eShift-To-Middle Array vs. \u003ccode\u003estd::deque\u003c/code\u003e vs. ExpandingRingBuffer vs. \u003ccode\u003estd::queue\u003c/code\u003e\u003c/strong\u003e demonstrate that performance improvements depend on \u003cstrong\u003eCPU and GPU capabilities\u003c/strong\u003e, such as \u003cstrong\u003emulti-core parallelism, SIMD optimizations, and cache efficiency\u003c/strong\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe benchmarks were compiled using \u003cstrong\u003eGCC with the \u003ccode\u003e-O3\u003c/code\u003e optimization flag\u003c/strong\u003e, ensuring high-performance execution. Results vary based on \u003cstrong\u003ehardware specifications\u003c/strong\u003e and \u003cstrong\u003eworkload characteristics\u003c/strong\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eüìÇ Installation \u0026amp; Usage\u003c/h2\u003e\u003ca id=\"user-content--installation--usage\" aria-label=\"Permalink: üìÇ Installation \u0026amp; Usage\" href=\"#-installation--usage\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eTo use Shift-To-Middle Array in your project:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"#include \u0026#34;ShiftToMiddleArray.h\u0026#34;\nShiftToMiddleArray\u0026lt;int\u0026gt; stmArray;\nstmArray.insert_head(42);\nstmArray.insert_tail(99);\nint value = stmArray.get_head();\nstmArray.remove_head();\"\u003e\u003cpre\u003e#\u003cspan\u003einclude\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eShiftToMiddleArray.h\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e\nShiftToMiddleArray\u0026lt;\u003cspan\u003eint\u003c/span\u003e\u0026gt; stmArray;\nstmArray.insert_head(\u003cspan\u003e42\u003c/span\u003e);\nstmArray.insert_tail(\u003cspan\u003e99\u003c/span\u003e);\n\u003cspan\u003eint\u003c/span\u003e value = stmArray.get_head();\nstmArray.remove_head();\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eüî¨ When To Use\u003c/h2\u003e\u003ca id=\"user-content--when-to-use\" aria-label=\"Permalink: üî¨ When To Use\" href=\"#-when-to-use\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e\u003cstrong\u003eHigh-performance queue structures\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGame engines \u0026amp; real-time applications\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNetworking (packet buffering, event queues)\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDynamic sequences in computational geometry \u0026amp; physics\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eüìñ Documentation\u003c/h2\u003e\u003ca id=\"user-content--documentation\" aria-label=\"Permalink: üìñ Documentation\" href=\"#-documentation\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eRunning Java Benchmarks\u003c/h3\u003e\u003ca id=\"user-content-running-java-benchmarks\" aria-label=\"Permalink: Running Java Benchmarks\" href=\"#running-java-benchmarks\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eTo run the \u003cstrong\u003eJava benchmarks\u003c/strong\u003e, ensure you have the \u003cstrong\u003eTrove library\u003c/strong\u003e installed. Compile and execute using:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"javac -cp trove-3.0.3.jar; ShiftToMiddleArrayBenchmarkTrove.java\njava -cp trove-3.0.3.jar; ShiftToMiddleArrayBenchmarkTrove\"\u003e\u003cpre\u003ejavac -cp trove-3.0.3.jar\u003cspan\u003e;\u003c/span\u003e ShiftToMiddleArrayBenchmarkTrove.java\njava -cp trove-3.0.3.jar\u003cspan\u003e;\u003c/span\u003e ShiftToMiddleArrayBenchmarkTrove\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eFull API reference and benchmarks are available in the \u003ca href=\"#\"\u003eWiki\u003c/a\u003e!\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eüìä Benchmarks \u0026amp; Results\u003c/h2\u003e\u003ca id=\"user-content--benchmarks--results\" aria-label=\"Permalink: üìä Benchmarks \u0026amp; Results\" href=\"#-benchmarks--results\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eFor full benchmark details, check out the \u003ca href=\"#\"\u003ebenchmarks report\u003c/a\u003e. The provided \u003cstrong\u003ePython scripts\u003c/strong\u003e can be used to visualize performance metrics from CSV benchmark results.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eüèõ History\u003c/h2\u003e\u003ca id=\"user-content--history\" aria-label=\"Permalink: üèõ History\" href=\"#-history\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe \u003cstrong\u003eShift-To-Middle Array\u003c/strong\u003e was developed as part of an effort to create a more efficient \u003cstrong\u003eimplementation strategy for lists and deques\u003c/strong\u003e. Traditional data structures, such as \u003ccode\u003estd::deque\u003c/code\u003e and linked lists, suffer from \u003cstrong\u003epoor cache locality\u003c/strong\u003e or \u003cstrong\u003efragmented memory allocations\u003c/strong\u003e, leading to inefficiencies. By leveraging \u003cstrong\u003econtiguous memory\u003c/strong\u003e, dynamic mid-shifting, and modern CPU optimizations, Shift-To-Middle Array provides a \u003cstrong\u003ebalanced solution\u003c/strong\u003e for insertion, deletion, and access performance.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eüìú License\u003c/h2\u003e\u003ca id=\"user-content--license\" aria-label=\"Permalink: üìú License\" href=\"#-license\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThis project is licensed under the MIT License.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eü§ù Contributing\u003c/h2\u003e\u003ca id=\"user-content--contributing\" aria-label=\"Permalink: ü§ù Contributing\" href=\"#-contributing\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eContributions are welcome! Feel free to open an issue or pull request.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eüöÄ \u003cstrong\u003eTry Shift-To-Middle Array today and optimize your data structures!\u003c/strong\u003e\u003c/p\u003e\n\u003c/article\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
