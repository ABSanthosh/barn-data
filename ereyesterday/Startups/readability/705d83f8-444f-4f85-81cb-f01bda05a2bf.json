{
  "id": "705d83f8-444f-4f85-81cb-f01bda05a2bf",
  "title": "Teaching Program Verification in Dafny at Amazon (2023)",
  "link": "https://dafny.org/blog/2023/12/15/teaching-program-verification-in-dafny-at-amazon/",
  "description": "Article URL: https://dafny.org/blog/2023/12/15/teaching-program-verification-in-dafny-at-amazon/ Comments URL: https://news.ycombinator.com/item?id=44163618 Points: 12 # Comments: 3",
  "author": "Jtsummers",
  "published": "Mon, 02 Jun 2025 22:03:50 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "Jean-Baptiste Tristan",
  "length": 9773,
  "excerpt": "Introduction We recently made available some teaching material that we have used to teach program verification to scientists and engineers at Amazon. It composed of lecture slides and exercises with solution. If you want to learn about Dafny and program verification, you can jump right in. You will learn how to program in Dafny, how to do use Dafny as a proof assistant, and finally how to verify programs. If instead you are more interested in teaching program verification, you may find the organization of the lectures and the focus on Dafny as a proof assistant surprising, and the following note should provide some context and explanations. Dafny: Program Verifier and Proof Assistant A proof plays two roles. (i) A proof convinces the reader that the statement is correct. (ii) A proof explains why the statement is correct. The first point consists of the administrative (‘bookkeeper’) activities of verifying the correctness of the small reasoning steps and see if they constitute a correct proof. One doesn’t have to look at the broad picture, but one just has to verify step by step whether every step is correct. The second point deals with giving the intuition of the theorem: Why is it so natural that this property holds? How did we come to the idea of proving it in this way? — Herman Geuvers, in Proof assistants: History, ideas and future One way to introduce program verification, including writing specifications and proofs, is exemplified by the book Program Proofs authored by K. Rustan M. Leino and published by MIT press. A defining characteristic of the methodology in that book is that verification is not only always motivated by programs, but specifications and proofs are attributes of programs. The book starts by considering simple imperative programs whose specification is written as pre and post conditions, and proving is done by writing annotations for loops and, on occasion, additional assertions. The curriculum continues with programs of increasing complexity, and specification and proofs continue to “decorate” programs. The concept of a proof is introduced somewhat implicitly through a program logic that details the effect of different programming constructs on the validity of a specification. This is an effective way to teach program verification: combined with Dafny's automation, one can verify programs by decorating them with a few assertions that explain at a high-level why the specification should hold. It promotes a style of program verification where “proving” amounts to explaining. Unfortunately, when automation comes short, it may not always be clear what explanations will help with the verification. It may seem as if one needs to provide the right assertion at the right place, without a clear methodology to figure it out. This can be frustrating to a developer for whom program verification, after appearing so simple for a while, may now seem ad hoc. We attempt to address this problem by providing a complementary perspective on program verification in Dafny. The key idea is to introduce Dafny as a proof assistant and to study proofs explicitly and independently of programs. With this perspective, we not only learn how to write intuitive proofs that take advantage of automation, but we also learn to write detailed formal proofs in natural deduction. This methodology opens the possibility of proving by convincing: a handful of rules can be used to refine a proof that will eventually pass the verification if it is indeed valid. The course is organized in 3 distinct parts. In the first two, Dafny is in turn introduced as a programming language (with no verification) and as a proof assistant (with no programming). Program verification is introduced last and emphasizes extrinsic verification. Part 1: Dafny as a Programming Language The first set of lectures introduces Dafny as a programming language, without any consideration for verification. The primary motivation is to allow Dafny newcomers to familiarize themselves with the syntax and semantics of the language, and its tools (CLI, IDE). It also makes it easy for more seasoned Dafny developers to skip directly to verification. Finally, it emphasizes that Dafny is at its core a full-fledged and classic programming language with strong static typing, object-orientation, and functional features. It may be an opportunity to introduce Dafny's foreign function interface and the idea that Dafny can be used as part of a large software project. We introduce in turn functional programming, imperative programming, and object-oriented programming. We usually keep the presentation of the module system to a minimum. Part 2: Dafny as a Proof Assistant After introducing Dafny as a programming language while ignoring verification, we learn about Dafny as a proof assistant while ignoring programming. We start by introducing the language of specification of Dafny. At its core, a Dafny specification is composed of uninterpreted symbols of type, constant, predicate, and function symbols and the language of formulas is a variant of Church's simple type theory or higher-order logic. The lecture also introduces lemma as a way to declare a family of formulas and axiomatize the meaning of symbols. In particular, the primitive types and operations such as reals or sets are presented as specific theories. We then explain how to define types, constants, predicates, and functions instead of axiomatizing them and assuming their existence. This is an opportunity to talk about partiality, termination of functions, fixed-points, and algebraic datatypes. Finally, we start studying proofs in Dafny in the more intuitive way that aims to prove by explaining. In this style, which is the more idiomatic Dafny style of proofs, one can prove in a way that is similar to the kind of proofs that we write in a high-school geometry class by making intermediate assertions, appealing to know results, fixing values and assumptions (e,g, let x be a fixed but arbitrary odd number), and high-level proof methods such as proof by contradiction, proof by case analysis, or proof by induction. Lastly, and most importantly, we study proofs in a much more formal way by explaining how to develop completely detailed and rigorous proofs using the rules of natural deduction (and sequent calculus). This systematic approach to formal proofs in Dafny allows one to prove by convincing, with the fundamental idea that you can always provide enough details so that the verifier will eventually accept your proof if it is indeed valid. Part 3: Program Verification in Dafny As we mentioned in the introduction, a typical path to learning about program verification in a language like Dafny would be to start with simple imperative programs, specifications as program annotations, and proofs as program annotations in a program logic. However, since we introduced proofs independently of programs by taking the unusual point of view that Dafny is a proof assistant and that proofs are expressed in natural deduction, our journey into program verification is somewhat different. We start with verification of functional programs, as it is largely similar to verifying mathematics. More specially, we first review extrinsic verification of functional programs, meaning that we keep function and type definitions separate (as much as possible) from specifying and proving their properties. In practice, it means that we do not annotate functions with properties but instead state and prove them as separate lemmas. Only then do we go over intrinsic verification of functional programs with pre and post conditions, and subset types. The motivation for keeping extrinsic and intrinsic verification separate is to emphasize the importance of being mindful about proof brittleness and that it may be a better strategy in general to introduce intrinsic verification where it simplifies verification the most, rather than making it the default verified programming strategy. We then discuss verification of imperative programs. First, we introduce local state and finally mention briefly program logic, loop invariants, and ghost state. We also emphasize an important methodology where instead of proving properties of an imperative program directly, one first proves that it behaves as a functional model and then prove interesting properties on that functional model. Finally, we talk about verification of object-oriented programs. The material is standard, but we emphasize the importance of defining an object's API by writing clients first to avoid coming up with an API that is inconsistent or cannot actually be used. We also emphasize that ghost representations need not be limited to sets and that it is tremendously useful to capture as much as possible the intended structure of a class in the type of its representation. Lastly, we emphasize the importance of master nodes in data structures that can make verification significantly easier. Conclusion The first version of this course was designed as a complement to Program Proofs. Its goal was to introduce seasoned Dafny software engineers to a different way of thinking about proofs by introducing them to some of the material from a course on the foundations of proof systems ; natural deduction and sequent calculus in particular. There is anecdotal evidence that it was effective and we have continued to develop this curriculum to use it both as an introduction to program verification, and as a way to help experts take their proving skills to the next level. Automation can be a significant challenge to teaching formal proofs in Dafny because it makes it difficult to work on simple examples and exercises, but the lecture on proving by convincing shows one attempt to do so.",
  "siteName": "Dafny Blog",
  "favicon": "",
  "text": "Introduction We recently made available some teaching material that we have used to teach program verification to scientists and engineers at Amazon. It composed of lecture slides and exercises with solution. If you want to learn about Dafny and program verification, you can jump right in. You will learn how to program in Dafny, how to do use Dafny as a proof assistant, and finally how to verify programs. If instead you are more interested in teaching program verification, you may find the organization of the lectures and the focus on Dafny as a proof assistant surprising, and the following note should provide some context and explanations. Dafny: Program Verifier and Proof Assistant A proof plays two roles. (i) A proof convinces the reader that the statement is correct. (ii) A proof explains why the statement is correct. The first point consists of the administrative (‘bookkeeper’) activities of verifying the correctness of the small reasoning steps and see if they constitute a correct proof. One doesn’t have to look at the broad picture, but one just has to verify step by step whether every step is correct. The second point deals with giving the intuition of the theorem: Why is it so natural that this property holds? How did we come to the idea of proving it in this way?    — Herman Geuvers, in Proof assistants: History, ideas and future One way to introduce program verification, including writing specifications and proofs, is exemplified by the book Program Proofs authored by K. Rustan M. Leino and published by MIT press. A defining characteristic of the methodology in that book is that verification is not only always motivated by programs, but specifications and proofs are attributes of programs. The book starts by considering simple imperative programs whose specification is written as pre and post conditions, and proving is done by writing annotations for loops and, on occasion, additional assertions. The curriculum continues with programs of increasing complexity, and specification and proofs continue to “decorate” programs. The concept of a proof is introduced somewhat implicitly through a program logic that details the effect of different programming constructs on the validity of a specification. This is an effective way to teach program verification: combined with Dafny's automation, one can verify programs by decorating them with a few assertions that explain at a high-level why the specification should hold. It promotes a style of program verification where “proving” amounts to explaining. Unfortunately, when automation comes short, it may not always be clear what explanations will help with the verification. It may seem as if one needs to provide the right assertion at the right place, without a clear methodology to figure it out. This can be frustrating to a developer for whom program verification, after appearing so simple for a while, may now seem ad hoc. We attempt to address this problem by providing a complementary perspective on program verification in Dafny. The key idea is to introduce Dafny as a proof assistant and to study proofs explicitly and independently of programs. With this perspective, we not only learn how to write intuitive proofs that take advantage of automation, but we also learn to write detailed formal proofs in natural deduction. This methodology opens the possibility of proving by convincing: a handful of rules can be used to refine a proof that will eventually pass the verification if it is indeed valid. The course is organized in 3 distinct parts. In the first two, Dafny is in turn introduced as a programming language (with no verification) and as a proof assistant (with no programming). Program verification is introduced last and emphasizes extrinsic verification. Part 1: Dafny as a Programming Language The first set of lectures introduces Dafny as a programming language, without any consideration for verification. The primary motivation is to allow Dafny newcomers to familiarize themselves with the syntax and semantics of the language, and its tools (CLI, IDE). It also makes it easy for more seasoned Dafny developers to skip directly to verification. Finally, it emphasizes that Dafny is at its core a full-fledged and classic programming language with strong static typing, object-orientation, and functional features. It may be an opportunity to introduce Dafny's foreign function interface and the idea that Dafny can be used as part of a large software project. We introduce in turn functional programming, imperative programming, and object-oriented programming. We usually keep the presentation of the module system to a minimum. Part 2: Dafny as a Proof Assistant After introducing Dafny as a programming language while ignoring verification, we learn about Dafny as a proof assistant while ignoring programming. We start by introducing the language of specification of Dafny. At its core, a Dafny specification is composed of uninterpreted symbols of type, constant, predicate, and function symbols and the language of formulas is a variant of Church's simple type theory or higher-order logic. The lecture also introduces lemma as a way to declare a family of formulas and axiomatize the meaning of symbols. In particular, the primitive types and operations such as reals or sets are presented as specific theories. We then explain how to define types, constants, predicates, and functions instead of axiomatizing them and assuming their existence. This is an opportunity to talk about partiality, termination of functions, fixed-points, and algebraic datatypes. Finally, we start studying proofs in Dafny in the more intuitive way that aims to prove by explaining. In this style, which is the more idiomatic Dafny style of proofs, one can prove in a way that is similar to the kind of proofs that we write in a high-school geometry class by making intermediate assertions, appealing to know results, fixing values and assumptions (e,g, let x be a fixed but arbitrary odd number), and high-level proof methods such as proof by contradiction, proof by case analysis, or proof by induction. Lastly, and most importantly, we study proofs in a much more formal way by explaining how to develop completely detailed and rigorous proofs using the rules of natural deduction (and sequent calculus). This systematic approach to formal proofs in Dafny allows one to prove by convincing, with the fundamental idea that you can always provide enough details so that the verifier will eventually accept your proof if it is indeed valid. As we mentioned in the introduction, a typical path to learning about program verification in a language like Dafny would be to start with simple imperative programs, specifications as program annotations, and proofs as program annotations in a program logic. However, since we introduced proofs independently of programs by taking the unusual point of view that Dafny is a proof assistant and that proofs are expressed in natural deduction, our journey into program verification is somewhat different. We start with verification of functional programs, as it is largely similar to verifying mathematics. More specially, we first review extrinsic verification of functional programs, meaning that we keep function and type definitions separate (as much as possible) from specifying and proving their properties. In practice, it means that we do not annotate functions with properties but instead state and prove them as separate lemmas. Only then do we go over intrinsic verification of functional programs with pre and post conditions, and subset types. The motivation for keeping extrinsic and intrinsic verification separate is to emphasize the importance of being mindful about proof brittleness and that it may be a better strategy in general to introduce intrinsic verification where it simplifies verification the most, rather than making it the default verified programming strategy. We then discuss verification of imperative programs. First, we introduce local state and finally mention briefly program logic, loop invariants, and ghost state. We also emphasize an important methodology where instead of proving properties of an imperative program directly, one first proves that it behaves as a functional model and then prove interesting properties on that functional model. Finally, we talk about verification of object-oriented programs. The material is standard, but we emphasize the importance of defining an object's API by writing clients first to avoid coming up with an API that is inconsistent or cannot actually be used. We also emphasize that ghost representations need not be limited to sets and that it is tremendously useful to capture as much as possible the intended structure of a class in the type of its representation. Lastly, we emphasize the importance of master nodes in data structures that can make verification significantly easier. Conclusion The first version of this course was designed as a complement to Program Proofs. Its goal was to introduce seasoned Dafny software engineers to a different way of thinking about proofs by introducing them to some of the material from a course on the foundations of proof systems ; natural deduction and sequent calculus in particular. There is anecdotal evidence that it was effective and we have continued to develop this curriculum to use it both as an introduction to program verification, and as a way to help experts take their proving skills to the next level. Automation can be a significant challenge to teaching formal proofs in Dafny because it makes it difficult to work on simple examples and exercises, but the lecture on proving by convincing shows one attempt to do so.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003ch2 id=\"sec-introduction\" data-line=\"18\" data-heading-depth=\"1\"\u003e\u003cspan data-line=\"18\"\u003e\u003c/span\u003eIntroduction\u003c/h2\u003e\n\u003cp data-line=\"20\"\u003e\u003cspan data-line=\"20\"\u003e\u003c/span\u003eWe recently made available some teaching material that we have used to teach program verification to scientists and engineers at Amazon. \nIt composed of \u003cspan data-line=\"21\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/\"\u003e\u003cspan data-line=\"21\"\u003e\u003c/span\u003electure slides\u003cspan data-line=\"21\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"21\"\u003e\u003c/span\u003e \nand \u003cspan data-line=\"22\"\u003e\u003c/span\u003e\u003ca href=\"https://github.com/dafny-lang/teaching-material/tree/main/Exercises\"\u003e\u003cspan data-line=\"22\"\u003e\u003c/span\u003eexercises with solution\u003cspan data-line=\"22\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"22\"\u003e\u003c/span\u003e. \nIf you want to learn about Dafny and program verification, you can jump right in. You will learn how to program in Dafny, how to do\nuse Dafny as a proof assistant, and finally how to verify programs. If instead you are more interested in teaching program\nverification, you may find the organization of the lectures and the focus on Dafny\nas a proof assistant surprising, and the following note should provide some context and explanations. \n\u003c/p\u003e\u003ch2 id=\"sec-dafny--program-verifier-and-proof-assistant\" data-line=\"28\" data-heading-depth=\"1\"\u003e\u003cspan data-line=\"28\"\u003e\u003c/span\u003eDafny: Program Verifier and Proof Assistant\u003c/h2\u003e\n\u003cblockquote data-line=\"30\"\u003e\n\n\u003cp data-line=\"30\"\u003e\u003cspan data-line=\"30\"\u003e\u003c/span\u003eA proof plays two roles. \u003cspan data-line=\"30\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan data-line=\"30\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan data-line=\"30\"\u003e\u003c/span\u003e\n(i) A proof convinces the reader that the statement is correct. \u003cspan data-line=\"31\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan data-line=\"31\"\u003e\u003c/span\u003e\n(ii) A proof explains why the statement is correct.\u003cspan data-line=\"32\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan data-line=\"32\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan data-line=\"32\"\u003e\u003c/span\u003e\nThe first point consists of the administrative (‘bookkeeper’) activities of verifying the\ncorrectness of the small reasoning steps and see if they constitute a correct proof. One doesn’t\nhave to look at the broad picture, but one just has to verify step by step whether every step is\ncorrect. The second point deals with giving the intuition of the theorem: Why is it so natural\nthat this property holds? How did we come to the idea of proving it in this way?\u003cspan data-line=\"37\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan data-line=\"37\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan data-line=\"37\"\u003e\u003c/span\u003e\n\u003cspan data-line=\"38\"\u003e\u003c/span\u003e \u003cspan data-line=\"38\"\u003e\u003c/span\u003e \u003cspan data-line=\"38\"\u003e\u003c/span\u003e \u003cspan data-line=\"38\"\u003e\u003c/span\u003e—\u003cspan data-line=\"38\"\u003e\u003c/span\u003e Herman Geuvers, in \u003cspan data-line=\"38\"\u003e\u003c/span\u003e\u003ca href=\"https://www.ias.ac.in/article/fulltext/sadh/034/01/0003-0025\"\u003e\u003cspan data-line=\"38\"\u003e\u003c/span\u003e Proof assistants: History, ideas and future\u003cspan data-line=\"38\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"38\"\u003e\u003c/span\u003e\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp data-line=\"40\"\u003e\u003cspan data-line=\"40\"\u003e\u003c/span\u003eOne way to introduce program verification, including writing specifications and proofs,\nis exemplified by the book \u003cspan data-line=\"41\"\u003e\u003c/span\u003e\u003ca href=\"https://mitpress.mit.edu/9780262546232/program-proofs/\"\u003e\u003cspan data-line=\"41\"\u003e\u003c/span\u003eProgram Proofs\u003cspan data-line=\"41\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"41\"\u003e\u003c/span\u003e authored by \nK. Rustan M. Leino and published by MIT press. A defining characteristic of the methodology in that book is that verification is\nnot only always motivated by programs, but specifications and proofs are attributes of programs. \nThe book starts by considering simple imperative programs whose specification is written as pre and post conditions, and proving is done\nby writing annotations for loops and, on occasion, additional assertions. The curriculum continues with programs of increasing complexity, and specification\nand proofs continue to \u003cspan data-line=\"46\"\u003e\u003c/span\u003e“decorate”\u003cspan data-line=\"46\"\u003e\u003c/span\u003e programs.\nThe concept of a proof is introduced somewhat implicitly through a program logic that details the effect of different programming constructs on the validity of a specification. \nThis is an effective way to teach program verification: combined with Dafny\u003cspan data-line=\"48\"\u003e\u003c/span\u003e\u0026#39;\u003cspan data-line=\"48\"\u003e\u003c/span\u003es automation, one can verify programs by \ndecorating them with a few assertions that explain at a high-level why the specification should hold. It promotes a style of\nprogram verification where \u003cspan data-line=\"50\"\u003e\u003c/span\u003e“proving”\u003cspan data-line=\"50\"\u003e\u003c/span\u003e amounts to explaining. \n\u003c/p\u003e\n\u003cp data-line=\"52\"\u003e\u003cspan data-line=\"52\"\u003e\u003c/span\u003eUnfortunately, when automation comes short, it may not always be clear what explanations will help with the verification.\nIt may seem as if one needs to provide the\nright assertion at the right place, without a clear methodology to figure it out. This can be frustrating to a developer for whom program verification,\nafter appearing so simple for a while, may now seem ad hoc. We attempt to address this problem by providing a complementary perspective on\nprogram verification in Dafny. The key idea is to introduce Dafny as a proof assistant and to study proofs explicitly and independently of programs.\nWith this perspective, we not only learn how to write intuitive proofs that take advantage of automation, but we also learn to write detailed formal proofs\nin natural deduction. This methodology opens the possibility of proving by convincing: a handful of rules can be used to refine a proof that will eventually\npass the verification if it is indeed valid. \n\u003c/p\u003e\n\u003cp data-line=\"61\"\u003e\u003cspan data-line=\"61\"\u003e\u003c/span\u003eThe course is organized in 3 distinct parts. In the first two, Dafny is in turn introduced as a programming language (with no verification) and as a proof\nassistant (with no programming). Program verification is introduced last and emphasizes extrinsic verification. \n\u003c/p\u003e\u003ch2 id=\"sec-part-1--dafny-as-a-programming-language\" data-line=\"64\" data-heading-depth=\"1\"\u003e\u003cspan data-line=\"64\"\u003e\u003c/span\u003ePart 1: Dafny as a Programming Language\u003c/h2\u003e\n\u003cp data-line=\"66\"\u003e\u003cspan data-line=\"66\"\u003e\u003c/span\u003eThe first set of lectures introduces Dafny as a programming language, without any consideration for verification. \nThe primary motivation is to allow Dafny newcomers to familiarize themselves with\nthe syntax and semantics of the language, and its tools (CLI, IDE). It also makes it easy for more seasoned Dafny developers to skip directly to\nverification. Finally, it emphasizes that Dafny is at its core a full-fledged and classic programming language \nwith strong static typing,  object-orientation, and functional features. It may be an opportunity to introduce\nDafny\u003cspan data-line=\"71\"\u003e\u003c/span\u003e\u0026#39;\u003cspan data-line=\"71\"\u003e\u003c/span\u003es foreign function interface and the idea that Dafny can be used as part of a large software project. \n\u003c/p\u003e\n\u003cp data-line=\"73\"\u003e\u003cspan data-line=\"73\"\u003e\u003c/span\u003eWe introduce in turn \u003cspan data-line=\"73\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/Lectures/1-1-Programming-Functional.html\"\u003e\u003cspan data-line=\"73\"\u003e\u003c/span\u003efunctional programming\u003cspan data-line=\"73\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"73\"\u003e\u003c/span\u003e, \n\u003cspan data-line=\"74\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/Lectures/1-2-Programming-Imperative.html\"\u003e\u003cspan data-line=\"74\"\u003e\u003c/span\u003eimperative programming\u003cspan data-line=\"74\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"74\"\u003e\u003c/span\u003e, and \n\u003cspan data-line=\"75\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/Lectures/1-3-Programming-ObjectOriented.html\"\u003e\u003cspan data-line=\"75\"\u003e\u003c/span\u003eobject-oriented programming\u003cspan data-line=\"75\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"75\"\u003e\u003c/span\u003e. We usually keep\nthe presentation of the module system to a minimum.\n\u003c/p\u003e\u003ch2 id=\"sec-part-2--dafny-as-a-proof-assistant\" data-line=\"78\" data-heading-depth=\"1\"\u003e\u003cspan data-line=\"78\"\u003e\u003c/span\u003ePart 2: Dafny as a Proof Assistant\u003c/h2\u003e\n\u003cp data-line=\"80\"\u003e\u003cspan data-line=\"80\"\u003e\u003c/span\u003eAfter introducing Dafny as a programming language while ignoring verification, we learn about Dafny as a proof assistant while ignoring programming. \n \nWe start by introducing the \u003cspan data-line=\"82\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/Lectures/2-1-Logic-Propositions.html\"\u003e\u003cspan data-line=\"82\"\u003e\u003c/span\u003elanguage of specification\u003cspan data-line=\"82\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"82\"\u003e\u003c/span\u003e\nof Dafny. At its core, a Dafny specification is composed of uninterpreted symbols of type, constant, predicate, and function symbols and the language of formulas is\na variant of Church\u003cspan data-line=\"84\"\u003e\u003c/span\u003e\u0026#39;\u003cspan data-line=\"84\"\u003e\u003c/span\u003es simple type theory or higher-order logic. The lecture also introduces lemma as a way to declare a family of formulas and axiomatize the meaning of\nsymbols. In particular, the primitive types and operations such as reals or sets are presented as specific theories. \n\u003c/p\u003e\n\u003cp data-line=\"87\"\u003e\u003cspan data-line=\"87\"\u003e\u003c/span\u003eWe then explain how to \u003cspan data-line=\"87\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/Lectures/2-2-Logic-Definitions.html\"\u003e\u003cspan data-line=\"87\"\u003e\u003c/span\u003edefine\u003cspan data-line=\"87\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"87\"\u003e\u003c/span\u003e types, constants, predicates, and functions instead\nof axiomatizing them and assuming their existence. This is an opportunity to talk about partiality, termination of functions, fixed-points, and algebraic datatypes.\n\u003c/p\u003e\n\u003cp data-line=\"90\"\u003e\u003cspan data-line=\"90\"\u003e\u003c/span\u003eFinally, we start studying proofs in Dafny in the more intuitive way that aims to\n\u003cspan data-line=\"91\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/Lectures/2-3-Logic-ProvingByExplaining.html\"\u003e\u003cspan data-line=\"91\"\u003e\u003c/span\u003eprove by explaining\u003cspan data-line=\"91\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"91\"\u003e\u003c/span\u003e. In this style, which is the more\nidiomatic Dafny style of proofs, one can prove in a way that is similar to the kind of proofs that we write in a high-school geometry class by\nmaking intermediate assertions, appealing to know results, fixing values and assumptions (e,g, \u003cspan data-line=\"93\"\u003e\u003c/span\u003e\u003cem\u003elet x be a fixed but arbitrary odd number\u003c/em\u003e\u003cspan data-line=\"93\"\u003e\u003c/span\u003e), \nand high-level proof methods such as proof by contradiction, proof by case analysis, or proof by induction.\n\u003c/p\u003e\n\u003cp data-line=\"96\"\u003e\u003cspan data-line=\"96\"\u003e\u003c/span\u003eLastly, and most importantly, we study proofs in a much more formal way by explaining how to develop completely detailed and rigorous proofs using the \nrules of natural deduction (and sequent calculus). This systematic approach to formal proofs in Dafny allows one to \n\u003cspan data-line=\"98\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/Lectures/2-4-Logic-ProvingByConvincing.html\"\u003e\u003cspan data-line=\"98\"\u003e\u003c/span\u003eprove by convincing\u003cspan data-line=\"98\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"98\"\u003e\u003c/span\u003e, with the fundamental idea that you can \nalways provide enough details so that the verifier will eventually accept your proof if it is indeed valid. \n\u003c/p\u003e\n\u003cp data-line=\"103\"\u003e\u003cspan data-line=\"103\"\u003e\u003c/span\u003eAs we mentioned in the introduction, a typical path to learning about program verification in a language like Dafny would be to start with\nsimple imperative programs, specifications as program annotations, and proofs as program annotations in a program logic. However, since we introduced\nproofs independently of programs by taking the unusual point of view that Dafny is a proof assistant and that proofs are expressed in natural deduction, our\njourney into program verification is somewhat different. \u003cspan data-line=\"106\"\u003e\u003c/span\u003e \u003cspan data-line=\"106\"\u003e\u003c/span\u003e \n\u003c/p\u003e\n\u003cp data-line=\"108\"\u003e\u003cspan data-line=\"108\"\u003e\u003c/span\u003eWe start with verification of functional programs, as it is largely similar to verifying mathematics. More specially, we first review\n\u003cspan data-line=\"109\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/Lectures/3-1-Verification-Functional-Independent.html\"\u003e\u003cspan data-line=\"109\"\u003e\u003c/span\u003eextrinsic verification of functional programs\u003cspan data-line=\"109\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"109\"\u003e\u003c/span\u003e, meaning that \nwe keep function and type definitions separate (as much as possible) from specifying and proving their properties. In practice, it means that we do not\nannotate functions with properties but instead state and prove them as separate lemmas. Only then do we go over \n\u003cspan data-line=\"112\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/Lectures/3-2-Verification-Functional-Dependent.html\"\u003e\u003cspan data-line=\"112\"\u003e\u003c/span\u003eintrinsic verification of functional programs\u003cspan data-line=\"112\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"112\"\u003e\u003c/span\u003e with pre and post conditions,\nand subset types. The motivation for keeping extrinsic and intrinsic verification separate is to emphasize the importance of being mindful about proof brittleness\nand that it may be a better strategy in general to introduce intrinsic verification where it simplifies verification the most, rather than making it the default\nverified programming strategy.\n\u003c/p\u003e\n\u003cp data-line=\"117\"\u003e\u003cspan data-line=\"117\"\u003e\u003c/span\u003eWe then discuss \u003cspan data-line=\"117\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/Lectures/3-3-Verification-Imperative.html\"\u003e\u003cspan data-line=\"117\"\u003e\u003c/span\u003everification of imperative programs\u003cspan data-line=\"117\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"117\"\u003e\u003c/span\u003e. First, we\nintroduce local state and finally mention briefly program logic, loop invariants, and ghost state. We also emphasize an \n\u003cspan data-line=\"119\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/blog/2023/08/14/clear-specification-and-implementation/\"\u003e\u003cspan data-line=\"119\"\u003e\u003c/span\u003eimportant methodology\u003cspan data-line=\"119\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"119\"\u003e\u003c/span\u003e where\ninstead of proving properties of an imperative program directly, one first proves that it behaves as a functional model and then prove interesting properties \non that functional model. \n\u003c/p\u003e\n\u003cp data-line=\"123\"\u003e\u003cspan data-line=\"123\"\u003e\u003c/span\u003eFinally, we talk about verification of \u003cspan data-line=\"123\"\u003e\u003c/span\u003e\u003ca href=\"https://dafny.org/teaching-material/Lectures/3-4-Verification-ObjectOriented.html\"\u003e\u003cspan data-line=\"123\"\u003e\u003c/span\u003eobject-oriented programs\u003cspan data-line=\"123\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"123\"\u003e\u003c/span\u003e. The material is standard, but we emphasize the importance of defining an object\u003cspan data-line=\"123\"\u003e\u003c/span\u003e\u0026#39;\u003cspan data-line=\"123\"\u003e\u003c/span\u003es API by \nwriting clients first to avoid coming up with an API that is inconsistent or cannot actually be used. We also emphasize that ghost representations need not\nbe limited to sets and that it is tremendously useful to capture as much as possible the intended structure of a class in the type of its representation. Lastly, \nwe emphasize the importance of \u003cspan data-line=\"126\"\u003e\u003c/span\u003e\u003cem\u003emaster\u003c/em\u003e\u003cspan data-line=\"126\"\u003e\u003c/span\u003e nodes in data structures that can make verification significantly easier.\n\u003c/p\u003e\u003ch2 id=\"sec-conclusion\" data-line=\"129\" data-heading-depth=\"1\"\u003e\u003cspan data-line=\"129\"\u003e\u003c/span\u003eConclusion\u003c/h2\u003e\n\u003cp data-line=\"131\"\u003e\u003cspan data-line=\"131\"\u003e\u003c/span\u003eThe first version of this course was designed as a complement to \u003cspan data-line=\"131\"\u003e\u003c/span\u003e\u003ca href=\"https://mitpress.mit.edu/9780262546232/program-proofs/\"\u003e\u003cspan data-line=\"131\"\u003e\u003c/span\u003eProgram Proofs\u003cspan data-line=\"131\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"131\"\u003e\u003c/span\u003e.\nIts goal was to introduce seasoned Dafny software engineers to a different way of thinking about proofs by introducing them to some of the material\nfrom a \u003cspan data-line=\"133\"\u003e\u003c/span\u003e\u003ca href=\"https://wikimpri.dptinfo.ens-cachan.fr/doku.php?id=cours:c-2-7-1\"\u003e\u003cspan data-line=\"133\"\u003e\u003c/span\u003ecourse on the foundations of proof systems\u003cspan data-line=\"133\"\u003e\u003c/span\u003e\u003c/a\u003e\u003cspan data-line=\"133\"\u003e\u003c/span\u003e ; natural deduction and sequent calculus\nin particular.\nThere is anecdotal evidence that it was effective and we have continued to develop this curriculum to use it both as an introduction to program verification, \nand as a way to help experts take their proving skills to the next level. Automation can be a significant challenge to teaching formal proofs in Dafny because\nit makes it difficult to work on simple examples and exercises, but the lecture on proving by convincing shows one attempt to do so.\n\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2023-12-15T16:00:00Z",
  "modifiedTime": null
}
