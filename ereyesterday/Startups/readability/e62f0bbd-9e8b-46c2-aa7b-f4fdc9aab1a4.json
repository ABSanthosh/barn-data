{
  "id": "e62f0bbd-9e8b-46c2-aa7b-f4fdc9aab1a4",
  "title": "Tales from Mainframe Modernization",
  "link": "https://oppi.li/posts/tales_from_mainframe_modernization/",
  "description": "Article URL: https://oppi.li/posts/tales_from_mainframe_modernization/ Comments URL: https://news.ycombinator.com/item?id=44057467 Points: 9 # Comments: 1",
  "author": "todsacerdoti",
  "published": "Thu, 22 May 2025 00:01:46 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 3853,
  "excerpt": "a static site {for, by, about} me",
  "siteName": "",
  "favicon": "https://oppi.li/favicon.png",
  "text": "At my last workplace, I wrote transpilers (or just compilers if you prefer) from mainframe languages (COBOL, JCL, BASIC etc.) to Java (in Rust!). Legacy code is full of surprises. In the roughly 200k lines of COBOL that I had the (dis)pleasure of working with, I saw some wonderful hacks to get around the limitations of the system. Mainframes are also chock full of history. Base-10 numerics This is the first thing that stood out to me when I looked at COBOL code, a data-definition (the phrase for “variable”) in COBOL is declared like so: ,-- name | ,- type __|___ __|_ 01 HEIGHT PIC 9(3). -- --- | | | `- picture clause (keyword) `- level number That statement declares a variable called HEIGHT with type 9(3), which is shorthand for 999, which indicates “3-digit number”. The possible values for this variable are 0 to 999! Internationalisation Below is another data-definition in COBOL, declaring 3 variables: 01 FOO-PERSON. 05 FOO-NAME PIC X(5). 05 FOO-HEIGHT PIC 9(3). What that means is: FOO-PERSON: a “group” variable consisting of two other variables FOO-NAME: an alphanumeric type with 5 characters FOO-HEIGHT: a numeric type with 3 digits (remember, base 10 and not base 2) COBOL has an interesting construct called “REDEFINES”: 01 FOO-PERSON. 05 FOO-NAME PIC X(5). 05 FOO-HEIGHT PIC 9(3). 01 FOO-PERSONNE REDEFINES FOO-PERSON. 05 FOO-NOM PIC X(5). 05 FOO-TAILLE PIC 9(3). FOO-PERSON and FOO-PERSONNE refer to the same region of memory. I helped modernise a codebase that had clearly been worked on by a Spanish consultancy at some point, and they had decided to redefine all data definitions in Spanish. String parsing Here’s another fun one: 01 FOO-PERSON. 05 FOO-NAME PIC X(5). 05 FOO-HEIGHT PIC 9(3). . . . MOVE \"PETER\" TO FOO-NAME. MOVE 175 TO FOO-HEIGHT. *\u003e display the entire memory region DISPLAY FOO-PERSON. *\u003e PETER175 *\u003e subscripting the first 7 bytes... DISPLAY FOO-PERSON (1:7) *\u003e PETER17 So data-definitions simply describe names for regions. Which enables a clever way to parse strings: 01 DATE. 05 DD PIC 9(2). 05 FILLER PIC X. 05 MMM PIC A(3). 05 FILLER PIC X. 05 YYYY PIC 9(4). . . . MOVE \"03 MAR 2025\" TO DATE. DISPLAY \"DAY: \" DD. *\u003e DAY: 03 DISPLAY \"MONTH: \" MMM. *\u003e MONTH: MAR DISPLAY \"YEAR: \" YYYY. *\u003e YEAR: 2025 *\u003e also works: MOVE \"03-MAR-2025\" TO DATE. Early exit I’d see this peppered around in a few places; which I later realized was a way to trigger an abnormal end to a batch job (possibly triggering an error handling routine in the outer job control system): 01 CONSTANT-ZERO S9(9)V9 VALUE 0. 01 ABEND S9(9)V9. . . . COMPUTE ABEND = CONSTANT-ZERO / CONSTANT-ZERO. All the numbers I have yet to find an explanation for this one, but I once found a file with just the first 800 natural numbers defined as string constants: 01 TC0001 X(5) \"00001\". 01 TC0002 X(5) \"00002\". 01 TC0003 X(5) \"00003\". . . *\u003e .... 800 lines later .... . . 01 TC0800 X(5) \"00800\". The file was definitely not generated, and I can’t imagine text editors on the mainframe were all that advanced either. dd - disk destroyer The DD statement in the JCL subsystem stands for “data definition”, which is largely used to describe files and IO streams used by a batch job. The dd command 1 on UNIX is named after this statement! Wikipedia - dd (Unix)↩︎",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n            \u003cp\u003eAt my last workplace, I wrote transpilers (or just \u003ca href=\"https://people.csail.mit.edu/rachit/post/transpiler/\"\u003ecompilers\u003c/a\u003e\nif you prefer) from mainframe languages (COBOL, JCL, BASIC etc.) to Java\n(in Rust!).\u003c/p\u003e\n\u003cp\u003eLegacy code is full of surprises. In the roughly 200k lines of COBOL\nthat I had the (dis)pleasure of working with, I saw some wonderful hacks\nto get around the limitations of the system. Mainframes are also chock\nfull of history.\u003c/p\u003e\n\u003ch3 id=\"base-10-numerics\"\u003eBase-10 numerics\u003c/h3\u003e\n\u003cp\u003eThis is the first thing that stood out to me when I looked at COBOL\ncode, a data-definition (the phrase for “variable”) in COBOL is declared\nlike so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e                 ,-- name                \n                 |          ,- type      \n               __|___     __|_      \n            01 HEIGHT PIC 9(3).\n            --        ---       \n            |          |\n            |           `- picture clause (keyword)\n            `- level number              \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat statement declares a variable called \u003ccode\u003eHEIGHT\u003c/code\u003e with\ntype \u003ccode\u003e9(3)\u003c/code\u003e, which is shorthand for \u003ccode\u003e999\u003c/code\u003e, which\nindicates “3-digit number”. The possible values for this variable are\n\u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e999\u003c/code\u003e!\u003c/p\u003e\n\u003ch3 id=\"internationalisation\"\u003eInternationalisation\u003c/h3\u003e\n\u003cp\u003eBelow is another data-definition in COBOL, declaring 3 variables:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e01 FOO-PERSON.\n  05 FOO-NAME PIC X(5).\n  05 FOO-HEIGHT PIC 9(3).\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat that means is:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eFOO-PERSON\u003c/code\u003e: a “group” variable consisting of two other\nvariables\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFOO-NAME\u003c/code\u003e: an alphanumeric type with 5 characters\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFOO-HEIGHT\u003c/code\u003e: a numeric type with 3 digits (remember,\nbase 10 and not base 2)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCOBOL has an interesting construct called “REDEFINES”:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e01 FOO-PERSON.\n  05 FOO-NAME PIC X(5).\n  05 FOO-HEIGHT PIC 9(3).\n\n01 FOO-PERSONNE REDEFINES FOO-PERSON.\n  05 FOO-NOM PIC X(5).\n  05 FOO-TAILLE PIC 9(3).\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eFOO-PERSON\u003c/code\u003e and \u003ccode\u003eFOO-PERSONNE\u003c/code\u003e refer to the\nsame region of memory.\u003c/p\u003e\n\u003cp\u003eI helped modernise a codebase that had clearly been worked on by a\nSpanish consultancy at some point, and they had decided to redefine all\ndata definitions in Spanish.\u003c/p\u003e\n\u003ch3 id=\"string-parsing\"\u003eString parsing\u003c/h3\u003e\n\u003cp\u003eHere’s another fun one:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e       01 FOO-PERSON.\n         05 FOO-NAME PIC X(5).\n         05 FOO-HEIGHT PIC 9(3).\n       .\n       .\n       .\n\n       MOVE \u0026#34;PETER\u0026#34; TO FOO-NAME.\n       MOVE 175 TO FOO-HEIGHT.\n\n    *\u0026gt; display the entire memory region\n       DISPLAY FOO-PERSON.\n    *\u0026gt; PETER175\n\n    *\u0026gt; subscripting the first 7 bytes...\n       DISPLAY FOO-PERSON (1:7)\n    *\u0026gt; PETER17\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo data-definitions simply describe names for regions. Which enables\na clever way to parse strings:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e       01 DATE.\n         05 DD     PIC 9(2).\n         05 FILLER PIC X.\n         05 MMM    PIC A(3).\n         05 FILLER PIC X.\n         05 YYYY   PIC 9(4).\n\n       .\n       .\n       .\n\n       MOVE \u0026#34;03 MAR 2025\u0026#34; TO DATE.\n       DISPLAY \u0026#34;DAY: \u0026#34;   DD.      *\u0026gt; DAY: 03\n       DISPLAY \u0026#34;MONTH: \u0026#34; MMM.     *\u0026gt; MONTH: MAR\n       DISPLAY \u0026#34;YEAR: \u0026#34;  YYYY.    *\u0026gt; YEAR: 2025\n\n    *\u0026gt; also works:\n       MOVE \u0026#34;03-MAR-2025\u0026#34; TO DATE.\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"early-exit\"\u003eEarly exit\u003c/h3\u003e\n\u003cp\u003eI’d see this peppered around in a few places; which I later realized\nwas a way to trigger an abnormal end to a batch job (possibly triggering\nan error handling routine in the outer job control system):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e       01 CONSTANT-ZERO S9(9)V9 VALUE 0.\n       01 ABEND         S9(9)V9.\n\n           .\n           .\n           .\n\n       COMPUTE ABEND = CONSTANT-ZERO / CONSTANT-ZERO.\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"all-the-numbers\"\u003eAll the numbers\u003c/h3\u003e\n\u003cp\u003eI have yet to find an explanation for this one, but I once found a\nfile with just the first 800 natural numbers defined as string\nconstants:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e         01 TC0001 X(5) \u0026#34;00001\u0026#34;.\n         01 TC0002 X(5) \u0026#34;00002\u0026#34;.\n         01 TC0003 X(5) \u0026#34;00003\u0026#34;.\n         .\n         .\n       *\u0026gt; .... 800 lines later ....\n         .\n         .\n         01 TC0800 X(5) \u0026#34;00800\u0026#34;.\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe file was definitely not generated, and I can’t imagine text\neditors on the mainframe were all that advanced either.\u003c/p\u003e\n\u003ch3 id=\"dd---disk-destroyer\"\u003e\u003ccode\u003edd\u003c/code\u003e - disk destroyer\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eDD\u003c/code\u003e statement in the JCL subsystem stands for “data\ndefinition”, which is largely used to describe files and IO streams used\nby a batch job. The \u003ccode\u003edd\u003c/code\u003e command \u003ca href=\"#fn1\" id=\"fnref1\" role=\"doc-noteref\"\u003e\u003csup\u003e1\u003c/sup\u003e\u003c/a\u003e on\nUNIX is named after this statement!\u003c/p\u003e\n\u003csection id=\"footnotes\" role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn1\"\u003e\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Dd_%28Unix%29#History\"\u003eWikipedia -\ndd (Unix)\u003c/a\u003e\u003ca href=\"#fnref1\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\n          \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
