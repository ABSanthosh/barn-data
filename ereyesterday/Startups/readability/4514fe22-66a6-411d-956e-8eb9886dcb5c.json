{
  "id": "4514fe22-66a6-411d-956e-8eb9886dcb5c",
  "title": "The Alder Lake SHLX Anomaly",
  "link": "https://tavianator.com/2025/shlx.html",
  "description": "Article URL: https://tavianator.com/2025/shlx.html Comments URL: https://news.ycombinator.com/item?id=42579969 Points: 47 # Comments: 12",
  "author": "panic",
  "published": "Thu, 02 Jan 2025 23:00:48 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 4657,
  "excerpt": "At the end of 2024, Harold Aptroot posted this:",
  "siteName": "",
  "favicon": "https://tavianator.com/favicon.png",
  "text": "tavianator.com The Alder Lake SHLX anomaly At the end of 2024, Harold Aptroot posted this: Apparently shlx is a \"medium latency\" (3 cycles) instruction on Alder Lake. My disappointment is immeasurable, and my day is ruined. — Twitter / Bluesky / Mastodon I was immediately nerd sniped because I am into low-level performance analysis, and I happen to own an Alder Lake laptop. A bit of background: Alder Lake is the 12th generation of Intel Core processors. It's the first generation with a \"hybrid architecture,\" containing both performance (P) and efficiency (E) cores. SHLX is a left-shift instruction introduced in the BMI2 instruction set. The main difference with SHL is that SHLX doesn't affect the FLAGS register. It's also a 3-operand instruction: SHL RAX, CL ; RAX = RAX \u003c\u003c CL ; (only CL allowed as shift count) SHLX RAX, RBX, RDX ; RAX = RBX \u003c\u003c RDX ; (any register allowed as shift count) Left-shift is one of the simplest things to implement in hardware, so it's quite surprising that it should take 3 whole CPU cycles. It's been 1 cycle on every other CPU I'm aware of. It's even 1 cycle on Alder Lake's efficiency cores! Only the performance cores have this particular performance problem. The 3-cycle figure Harold cited comes from uops.info. They even document the exact instruction sequence used in their benchmark that measured the 3-cycle latency, with a sample nanoBench command to reproduce it. Running that command on my laptop indeed measures 3 cycles of latency. On the other hand, other sources (like Intel and InstLatX64) claim the latency is 1 cycle. What gives? I decided to write my own benchmark to try to understand the discrepancy. .intel_syntax noprefix .globl main main: MOV RDX, 10000 ; RDX = 10000 XOR RAX, RAX ; RAX = 0 .LOOP: MOV RCX, 1 ; RCX = 1 .rept 10000 SHLX RAX, RAX, RCX ; RAX = RAX \u003c\u003c RCX ; (repeated 10,000 times) .endr DEC RDX JNZ .LOOP ; (loop 10,000 times) XOR EAX, EAX RET ; return 0 This code contains an outer loop with 10,000 iterations. Inside the loop, we initialize RCX to 1, then run SHLX RAX, RAX, RCX 10,000 times. In total, we run SHLX 10,000,000 times, so all the other instructions (including the ones before main() runs) are negligible. I used taskset -c 0 to pin it to a P core, and perf for measurement: $ gcc shlx.s -o shlx $ taskset -c 0 perf stat --cputype=core -e 'cycles,instructions' ./shlx Performance counter stats for './shlx': 301,614,809 cpu_core/cycles:u/ 100,155,910 cpu_core/instructions:u/ # 0.33 insn per cycle Here we see 0.33 instructions per cycle, a.k.a. 3-cycle latency. Let's try initializing RCX differently: .LOOP: - MOV RCX, 1 + MOV ECX, 1 ECX is the 32-bit low half of the 64-bit RCX register. On x86-64, writing a 32-bit register implicitly sets the upper half of the corresponding 64-bit register to zero. So these two instructions should behave identically. And yet: Performance counter stats for './shlx': 100,321,870 cpu_core/cycles:u/ 100,155,867 cpu_core/instructions:u/ # 1.00 insn per cycle It seems like SHLX performs differently depending on how the shift count register is initialized. If you use a 64-bit instruction with an immediate, performance is slow. This is also true for instructions like INC (which is similar to ADD with a 1 immediate). .LOOP: - MOV RCX, 1 + XOR RCX, RCX + INC RCX Performance counter stats for './shlx': 300,138,108 cpu_core/cycles:u/ 100,165,881 cpu_core/instructions:u/ # 0.33 insn per cycle On the other hand, 32-bit instructions, and 64-bit instructions without immediates (even no-op ones), make it fast. All of these ways to initialize RCX lead to 1-cycle latency: .LOOP: MOV ECX, 1 .LOOP: XOR RCX, RCX .LOOP: MOV RCX, 1 MOV RCX, RCX MOV RCX, 1 .LOOP: PUSH RCX POP RCX It is very strange to me that the instruction used to set the shift count register can make the SHLX instruction 3× slower. The 32-bit vs. 64-bit operand size distinction is especially surprising to me as SHLX only looks at the bottom 6 bits of the shift count. I do not have a good explanation for this yet, but I will update this page if I ever figure it out.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\n    \u003cdiv id=\"body-container\"\u003e\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \u003cnav id=\"sidebar\" aria-label=\"Table of contents\"\u003e\n            \n            \u003cmdbook-sidebar-scrollbox\u003e\u003c/mdbook-sidebar-scrollbox\u003e\n            \n            \n        \u003c/nav\u003e\n\n        \u003cdiv id=\"page-wrapper\"\u003e\n                \n                \u003cdiv id=\"menu-bar\"\u003e\n                    \n\n                    \u003ch2\u003etavianator.com\u003c/h2\u003e\n\n                    \n                \u003c/div\u003e\n\n                \n\n                \n                \n\n                \u003cdiv id=\"content\"\u003e\n                    \u003cmain\u003e\n                        \u003ch2 id=\"the-alder-lake-shlx-anomaly\"\u003e\u003ca href=\"#the-alder-lake-shlx-anomaly\"\u003eThe Alder Lake \u003ccode\u003eSHLX\u003c/code\u003e anomaly\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eAt the end of 2024, Harold Aptroot posted this:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eApparently shlx is a \u0026#34;medium latency\u0026#34; (3 cycles) instruction on Alder Lake. My disappointment is immeasurable, and my day is ruined.\u003c/p\u003e\n\u003cp\u003e— \u003ca href=\"https://x.com/HaroldAptroot/status/1873461353203302819\"\u003eTwitter\u003c/a\u003e / \u003ca href=\"https://bsky.app/profile/haroldaptroot.bsky.social/post/3leht4lp2dk2u\"\u003eBluesky\u003c/a\u003e / \u003ca href=\"https://mastodon.gamedev.place/@harold/113737900853968212\"\u003eMastodon\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eI was immediately \u003ca href=\"https://xkcd.com/356/\"\u003enerd sniped\u003c/a\u003e because I am into low-level performance analysis, and I happen to own an Alder Lake laptop.\u003c/p\u003e\n\u003cp\u003eA bit of background: \u003ca href=\"https://en.wikipedia.org/wiki/Alder_Lake\"\u003e\u003cem\u003eAlder Lake\u003c/em\u003e\u003c/a\u003e is the 12th generation of Intel Core processors.\nIt\u0026#39;s the first generation with a \u0026#34;hybrid architecture,\u0026#34; containing both performance (P) and efficiency (E) cores.\n\u003ca href=\"https://www.felixcloutier.com/x86/sarx:shlx:shrx\"\u003e\u003ccode\u003eSHLX\u003c/code\u003e\u003c/a\u003e is a left-shift instruction introduced in the \u003ca href=\"https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set#BMI2_(Bit_Manipulation_Instruction_Set_2)\"\u003eBMI2\u003c/a\u003e instruction set.\nThe main difference with \u003ca href=\"https://www.felixcloutier.com/x86/sal:sar:shl:shr\"\u003e\u003ccode\u003eSHL\u003c/code\u003e\u003c/a\u003e is that \u003ccode\u003eSHLX\u003c/code\u003e doesn\u0026#39;t affect the \u003ca href=\"https://en.wikipedia.org/wiki/FLAGS_register\"\u003eFLAGS\u003c/a\u003e register.\nIt\u0026#39;s also a 3-operand instruction:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e        SHL  RAX, CL       ; RAX = RAX \u0026lt;\u0026lt; CL\n                           ; (only CL allowed as shift count)\n\n        SHLX RAX, RBX, RDX ; RAX = RBX \u0026lt;\u0026lt; RDX\n                           ; (any register allowed as shift count)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLeft-shift is one of the simplest things to implement in hardware, so it\u0026#39;s quite surprising that it should take 3 whole CPU cycles.\nIt\u0026#39;s been 1 cycle on every other CPU I\u0026#39;m aware of.\nIt\u0026#39;s even 1 cycle on Alder Lake\u0026#39;s \u003cem\u003eefficiency cores\u003c/em\u003e!\nOnly the performance cores have this particular performance problem.\u003c/p\u003e\n\u003cp\u003eThe 3-cycle figure Harold cited comes from \u003ca href=\"https://uops.info/html-instr/SHLX_R64_R64_R64.html#ADL-P\"\u003euops.info\u003c/a\u003e.\nThey even document the exact \u003ca href=\"https://uops.info/html-lat/ADL-P/SHLX_R64_R64_R64-Measurements.html#lat2-%3E1\"\u003einstruction sequence\u003c/a\u003e used in their benchmark that measured the 3-cycle latency, with a sample \u003ca href=\"https://github.com/andreas-abel/nanoBench\"\u003enanoBench\u003c/a\u003e command to reproduce it.\nRunning that command on my laptop indeed measures 3 cycles of latency.\u003c/p\u003e\n\u003cp\u003eOn the other hand, other sources (like \u003ca href=\"https://www.intel.com/content/www/us/en/content-details/671488/intel-64-and-ia-32-architectures-optimization-reference-manual-volume-1.html\"\u003eIntel\u003c/a\u003e and \u003ca href=\"http://users.atw.hu/instlatx64/GenuineIntel/GenuineIntel00906A4_AlderLakeP_00_BC_InstLatX64.txt\"\u003eInstLatX64\u003c/a\u003e) claim the latency is 1 cycle.\nWhat gives?\nI decided to write my own benchmark to try to understand the discrepancy.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.intel_syntax noprefix\n.globl main\nmain:\n        MOV RDX, 10000     ; RDX = 10000\n        XOR RAX, RAX       ; RAX = 0\n.LOOP:\n        MOV RCX, 1         ; RCX = 1\n.rept 10000\n        SHLX RAX, RAX, RCX ; RAX = RAX \u0026lt;\u0026lt; RCX\n                           ; (repeated 10,000 times)\n.endr\n        DEC RDX\n        JNZ .LOOP          ; (loop 10,000 times)\n        XOR EAX, EAX\n        RET                ; return 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code contains an outer loop with 10,000 iterations.\nInside the loop, we initialize \u003ccode\u003eRCX\u003c/code\u003e to 1, then run \u003ccode\u003eSHLX RAX, RAX, RCX\u003c/code\u003e 10,000 times.\nIn total, we run \u003ccode\u003eSHLX\u003c/code\u003e 10,000,000 times, so all the other instructions (including the ones before \u003ccode\u003emain()\u003c/code\u003e runs) are negligible.\nI used \u003ccode\u003etaskset -c 0\u003c/code\u003e to pin it to a P core, and \u003ccode\u003eperf\u003c/code\u003e for measurement:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ gcc shlx.s -o shlx\n$ taskset -c 0 perf stat --cputype=core -e \u0026#39;cycles,instructions\u0026#39; ./shlx\n\n Performance counter stats for \u0026#39;./shlx\u0026#39;:\n\n       301,614,809      cpu_core/cycles:u/\n       100,155,910      cpu_core/instructions:u/         #    0.33  insn per cycle\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere we see 0.33 instructions per cycle, a.k.a. 3-cycle latency.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s try initializing \u003ccode\u003eRCX\u003c/code\u003e differently:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e .LOOP:\n-        MOV RCX, 1\n+        MOV ECX, 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eECX\u003c/code\u003e is the 32-bit low half of the 64-bit \u003ccode\u003eRCX\u003c/code\u003e register.\nOn x86-64, writing a 32-bit register implicitly sets the upper half of the corresponding 64-bit register to zero.\nSo these two instructions should behave identically.\nAnd yet:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e Performance counter stats for \u0026#39;./shlx\u0026#39;:\n\n       100,321,870      cpu_core/cycles:u/\n       100,155,867      cpu_core/instructions:u/         #    1.00  insn per cycle\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt seems like \u003ccode\u003eSHLX\u003c/code\u003e performs differently depending on how the shift count register is initialized.\nIf you use a 64-bit instruction with an immediate, performance is slow.\nThis is also true for instructions like \u003ccode\u003eINC\u003c/code\u003e (which is similar to \u003ccode\u003eADD\u003c/code\u003e with a 1 immediate).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e .LOOP:\n-        MOV RCX, 1\n+        XOR RCX, RCX\n+        INC RCX\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e Performance counter stats for \u0026#39;./shlx\u0026#39;:\n\n       300,138,108      cpu_core/cycles:u/\n       100,165,881      cpu_core/instructions:u/         #    0.33  insn per cycle\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn the other hand, 32-bit instructions, and 64-bit instructions without immediates (even no-op ones), make it fast.\nAll of these ways to initialize RCX lead to 1-cycle latency:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.LOOP:\n        MOV ECX, 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e.LOOP:\n        XOR RCX, RCX\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e.LOOP:\n        MOV RCX, 1\n        MOV RCX, RCX\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e        MOV RCX, 1\n.LOOP:\n        PUSH RCX\n        POP RCX\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is very strange to me that the \u003cem\u003einstruction used to set the shift count register\u003c/em\u003e can make the \u003ccode\u003eSHLX\u003c/code\u003e instruction 3× slower.\nThe 32-bit vs. 64-bit operand size distinction is especially surprising to me as \u003ccode\u003eSHLX\u003c/code\u003e only looks at the bottom 6 bits of the shift count.\u003c/p\u003e\n\u003cp\u003eI do not have a good explanation for this yet, but I will update this page if I ever figure it out.\u003c/p\u003e\n\n                    \u003c/main\u003e\n\n                    \n                \u003c/div\u003e\n            \u003c/div\u003e\n\n\n\n\n\n\n        \n        \n        \n\n        \n        \n        \n\n        \n\n\n    \u003c/div\u003e\n    \n\n\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": null,
  "modifiedTime": null
}
