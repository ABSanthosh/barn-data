{
  "id": "2669120d-011d-4f42-9020-051b524bffaa",
  "title": "Portals and Quake",
  "link": "https://30fps.net/pages/pvs-portals-and-quake/",
  "description": "Article URL: https://30fps.net/pages/pvs-portals-and-quake/ Comments URL: https://news.ycombinator.com/item?id=42661185 Points: 39 # Comments: 1",
  "author": "ibobev",
  "published": "Fri, 10 Jan 2025 22:48:13 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 9422,
  "excerpt": "This is the first installment in the “Demystifying the PVS” series.",
  "siteName": "",
  "favicon": "",
  "text": "This is the first installment in the “Demystifying the PVS” series. Portals and Quake Coarse base visibility Fine visibility via clipping Portal flow brings it all together (to be published) Ever wanted to know how exactly did Quake’s precomputed visibility work? I did, so I wrote vis.py, a reimplementation of their algorithm in Python. This guide has all the information you need to understand vis, the tool used by Quake, Half-Life and Source Engine games. During the development of Quake, overdraw became a concern. It means the same pixel getting written many times during the rendering of a frame. Only the last color stays visible and the earlier writes go to waste. This is bad if your game is software rendered and already pushing the mid 90’s PCs to their limits. How to reduce overdraw? Let’s begin with a very high-level overview of the solution landscape. Portal culling helps with overdraw In 3D games, it’s a good idea to reduce the number of drawn objects. Frustum culling is one fundamental method for this, in which objects confirmed to be outside the virtual camera’s view are skipped during rendering. This can be done for example with object bounding boxes or bounding spheres. Frustum culling still leaves some performance on the table. Many objects may still be within the field of view of the camera even if they don’t contribute any pixels to the final image. This is not a performance catastrophe if everything is rendered from front to back. GPU’s early-z testing will help here. Still, in large worlds it would be faster to never submit these objects for rendering in the first place. Occlusion culling is a process where you discard objects that you deem to lie behind other objects in the scene. Its purpose is to discard as many occluded objects as possible. It’s not strictly needed, since you’ll get the correct image thanks to the z-buffer anyway. There are a few ways to do this such as the hierarchical z-buffer, occlusion queries, portal culling, and potentially visible sets (PVS). In this article I talk about the last two: portals and the PVS. In portal culling, the world is divided into spaces where the virtual camera can move around and the openings between them. The spaces are called cells, viewcells, zones, clusters or sectors, and the openings portals. This is a useful split especially in architectural models with cleanly separated rooms connected by doorways or windows. It also works for mostly-indoor video game levels :) Portal rendering starts from the camera’s cell. The game renders everything inside that cell, and then recursively looks into portals leading away from that first cell to find out what else to draw. It renders all objects in every cell and then examines the cell’s portals. If a portal doesn’t line up with another one on screen, it won’t be visited. Each successive portal shrinks the visible screen area smaller and smaller until the whole portal is clipped away. A straightforward way to test portals for visibility is to intersect their screenspace bounding boxes. Those are shown in white in the picture below. If two bounding boxes overlap, we can see through the respective portals. More accurate tests can be performed with 3D clipping or per-pixel operations. The Quake engine uses portals but only during map preparation time. At runtime, the portals are nowhere to be seen. This technique is a variant of Seth Teller’s PVS method presented in his 1992 dissertation that only worked with axis-aligned walls. Portals of a Quake map disappear Often portals are placed by hand by a level designer. Quake’s bsp map compilation tool places portals automatically, which is nice, but unfortunately it creates a lot of them! You see, in Quake the cells are very small. But no portals are tested at runtime. Instead, each cell gets a precomputed list of other cells that can been seen from it. This is the Potentially Visible Set (PVS) for that cell. In Quake, a cell is a small convex volume of space, so a single room will usually get split into multiple cells. These cells correspond to leaves of a binary space partitioning (BSP) tree. The BSP tree was used to divide the map into cells and portals. For us, the exact method is irrelevant though. But BSP does make it easy to find the cell the camera is in at runtime. Since we have now entered the Quake territory in our discussion, I’ll start calling a cell a leaf. Leaf is the term used in all source code, level editors, error messages, and other resources on Quake. The meaning stays exactly the same though, it’s just a convex cell connected to other cells via portals. This is how leaves look in our example level: The portals appear in between leaves, as expected: Nothing would’ve stopped them from grouping multiple leaves to form larger cells with fewer portals in between. In fact, this is exactly what they did for Quake 2 with its “clusters” of leaves. With larger clusters of leaves, you do get more overdraw. Also, a cluster made of convex leaves may not be convex itself any more. But even in that case you can still act as if it still is, and assume the portals inside can be seen from anywhere in the cluster. It’s less accurate but works. High-level overview of vis The Quake map tool vis takes in portals generated by another tool, bsp, precomputes a leaf-to-leaf visibility matrix, and writes the matrix back to the compiled map file. This article series describes how vis functions. We know that leaves can see each other only through portals. So we don’t even need to know how exactly the leaves look like, only how they are connected together. At its most basic level, vis does two recursive depth-first traversals, followed by a quick resolve pass before writing the visibility results back to a compiled map file. Three steps: Base visibility. Estimate a coarse leaf-to-portal visibility. Full visibility. Refine the coarse results via portal clipping. Resolve. Combine the refined portal-to-leaf results to the final leaf-to-leaf visibility. For a quick visual overview, I can recommend Matthew Earl’s great video on Quake’s PVS. Portals have a direction In a portal system, the cells and portals are structured as a cell-and-portal graph. Quake’s map tooling follows this pattern and connects leaves with portals, even though this structure isn’t present at runtime. Leafs are connected by portals: Each portal is a 3D polygon. They are written by bsp to a plain text file with a version code, the number of leaves and portals, followed by one portal per line. Like this: PRT1 11 12 4 0 1 (880 -224 -8 ) (880 -272 -8 ) (880 -272 72 ) (880 -224 72 ) 4 1 2 (832 -224 -8 ) (832 -272 -8 ) (832 -272 72 ) (832 -224 72 ) 4 2 4 (768 -272 -8 ) (768 -320 -8 ) (768 -320 72 ) (768 -272 72 ) 4 2 3 (768 -112 72 ) (768 -112 -8 ) (768 -160 -8 ) (768 -160 72 ) 4 3 5 (720 -112 72 ) (720 -112 -8 ) (720 -160 -8 ) (720 -160 72 ) 4 4 5 (720 -272 -8 ) (720 -320 -8 ) (720 -320 72 ) (720 -272 72 ) 4 5 6 (640 -224 -8 ) (640 -288 -8 ) (640 -288 72 ) (640 -224 72 ) 4 6 7 (592 -224 -8 ) (592 -288 -8 ) (592 -288 72 ) (592 -224 72 ) 4 7 10 (384 -304 -8 ) (384 -368 -8 ) (384 -368 72 ) (384 -304 72 ) 4 7 8 (384 -112 -8 ) (384 -176 -8 ) (384 -176 72 ) (384 -112 72 ) 4 8 9 (240 -176 -8 ) (336 -176 -8 ) (336 -176 72 ) (240 -176 72 ) 4 9 10 (240 -304 -8 ) (336 -304 -8 ) (336 -304 72 ) (240 -304 72 ) Each portal is a loop of 3D points: ┌ the number of points │ ▽ x y z x y z x y z x y z 4 0 1 (880 -224 -8 ) (880 -272 -8 ) (880 -272 72 ) (880 -224 72 ) △ △ └─┴─ the two leaves the portal is in between Since portals are interfaces between convex leaves, the polygons are also convex. In 3D, a portal looks like this: Conceptually, each portal is a two way opening. You can see through it in both directions. However, it’s convenient to make the portals directed. This way we can keep track on what’s visible in different directions. We give each portal a normal vector, the direction the portal can be seen through. Now a single input portal becomes two directed portals: Therefore the graph will now have directed edges instead: The graph in code Now is the time to present the main data structures of vis.py, the Portal and Leaf classes: class Portal: winding: list[np.ndarray] # polygon's 3D points leaf: int # the leaf this portal leads to plane: Plane # plane normal points to destination leaf ... # (other class attributes omitted) class Leaf: portals: list[int] # indices of portals leading away from this leaf Note that a leaf stores only indices of portals leading away from that leaf. The graph is stored in two global arrays called portals and leaves with objects of the respective types. Since the graph is accessed both via indices and direct object references, I came up with the following naming convention: pi is the index of a portal, Pi is the actual object Pi = portals[pi], and li is the index of a leaf, Li is the actual object Li = leaves[li]. Our goal is to compute which nodes can reach each other in this graph while honoring the 3D visibility relations between portals associated with each edge. But what on earth are those “visibility relations”? In the next part we’ll use the graph for some quick checks. I’m also thinking of writing a book. Sign up here if you’re interested.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"text\"\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eThis is the first installment in the “Demystifying the PVS” series.\u003c/p\u003e\n\u003col type=\"1\"\u003e\n\u003cli\u003e\u003cstrong\u003ePortals and Quake\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://30fps.net/pages/pvs-coarse-visibility/\"\u003eCoarse base visibility\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://30fps.net/pages/pvs-fine-visibility/\"\u003eFine visibility via clipping\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePortal flow brings it all together (to be published)\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003cfigure\u003e\n\u003cimg src=\"https://30fps.net/pages/pvs-portals-and-quake/e1m1_pvs.jpg\" alt=\"Precomputed visibility in Quake’s first level. The camera location is shown in red.\"/\u003e\n\n\u003c/figure\u003e\n\u003cp\u003e\u003cem\u003eEver wanted to know how exactly did Quake’s precomputed visibility work?\nI did, so I wrote \u003ca href=\"https://github.com/pekkavaa/vis.py\"\u003evis.py\u003c/a\u003e, a reimplementation of their algorithm in Python.\nThis guide has all the information you need to understand \u003cstrong\u003evis\u003c/strong\u003e, the tool used by Quake, Half-Life and Source Engine games.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eDuring the development of Quake, \u003cem\u003eoverdraw\u003c/em\u003e became a concern.\nIt means the same pixel getting written many times during the rendering of a frame.\nOnly the last color stays visible and the earlier writes go to waste.\nThis is bad if your game is software rendered and already pushing the mid 90’s PCs to their limits.\u003c/p\u003e\n\u003cp\u003eHow to reduce overdraw?\nLet’s begin with a very high-level overview of the solution landscape.\u003c/p\u003e\n\u003ch2 id=\"portal-culling-helps-with-overdraw\"\u003ePortal culling helps with overdraw\u003c/h2\u003e\n\u003cp\u003eIn 3D games, it’s a good idea to reduce the number of drawn objects.\n\n\u003cem\u003eFrustum culling\u003c/em\u003e is one fundamental method for this, in which objects confirmed to be outside the virtual camera’s view are skipped during rendering.\nThis can be done for example with object bounding boxes or bounding spheres.\u003c/p\u003e\n\u003cp\u003eFrustum culling still leaves some performance on the table.\nMany objects may still be within the field of view of the camera even if they don’t contribute any pixels to the final image. This is not a performance catastrophe if everything is rendered from front to back.\nGPU’s early-z testing will help here.\nStill, in large worlds it would be faster to never submit these objects for rendering in the first place.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eOcclusion culling\u003c/em\u003e is a process where you discard objects that you deem to lie behind other objects in the scene. Its purpose is to discard as many \u003cem\u003eoccluded\u003c/em\u003e objects as possible. It’s not strictly needed, since you’ll get the correct image thanks to the z-buffer anyway. There are a few ways to do this such as the hierarchical z-buffer, occlusion queries, portal culling, and potentially visible sets (PVS). In this article I talk about the last two: portals and the PVS.\u003c/p\u003e\n\u003cp\u003eIn portal culling, the world is divided into spaces where the virtual camera can move around and the openings between them. The spaces are called \u003cem\u003ecells\u003c/em\u003e, \u003cem\u003eviewcells\u003c/em\u003e, \u003cem\u003ezones\u003c/em\u003e, \u003cem\u003eclusters\u003c/em\u003e or \u003cem\u003esectors\u003c/em\u003e, and the openings \u003cem\u003eportals\u003c/em\u003e. This is a useful split especially in architectural models with cleanly separated rooms connected by doorways or windows.\nIt also works for mostly-indoor video game levels :)\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"https://30fps.net/pages/pvs-portals-and-quake/portals_topdown_crop.png\" alt=\"The floorplan of our example level with three hand-placed portals shown. Cells have the color of their entry portal. In this case also the cell where the camera lies is visible.\"/\u003e\n\n\u003c/figure\u003e\n\u003cp\u003ePortal rendering starts from the camera’s cell.\nThe game renders everything inside that cell, and then recursively looks into portals leading away from that first cell to find out what else to draw.\nIt renders all objects in every cell and then examines the cell’s portals.\nIf a portal doesn’t line up with another one on screen, it won’t be visited.\nEach successive portal shrinks the visible screen area smaller and smaller until the whole portal is clipped away.\u003c/p\u003e\n\u003cp\u003eA straightforward way to test portals for visibility is to intersect their screenspace bounding boxes.\nThose are shown in white in the picture below.\nIf two bounding boxes overlap, we can see through the respective portals.\nMore accurate tests can be performed with 3D clipping or per-pixel operations.\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"https://30fps.net/pages/pvs-portals-and-quake/portals_sprite.jpg\" alt=\"This is how three portals could look in game. Portal openings are shown as colored polygons and their screenspace bounding boxes are in white. Objects have dashed bounding boxes. The star object is culled because it doesn’t overlap with the red portal.\"/\u003e\n\n\u003c/figure\u003e\n\u003cp\u003eThe Quake engine uses portals but only during map preparation time.\nAt runtime, the portals are nowhere to be seen.\nThis technique is a variant of Seth Teller’s PVS method presented \u003ca href=\"https://www2.eecs.berkeley.edu/Pubs/TechRpts/1992/CSD-92-708.pdf\"\u003ein his 1992 dissertation\u003c/a\u003e that only worked with axis-aligned walls.\u003c/p\u003e\n\u003ch2 id=\"portals-of-a-quake-map-disappear\"\u003ePortals of a Quake map disappear\u003c/h2\u003e\n\u003cp\u003eOften portals are placed by hand by a level designer. Quake’s \u003cstrong\u003ebsp\u003c/strong\u003e map compilation tool places portals automatically, which is nice, but unfortunately it creates a lot of them!\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"https://30fps.net/pages/pvs-portals-and-quake/e1m1_start_withportals.jpg\" alt=\"Quake’s first map viewed in the TrenchBroom map editor with portals shown in red. As you can see, not just doorways act as portals.\"/\u003e\n\n\u003c/figure\u003e\n\u003cp\u003eYou see, in Quake the cells are very small.\nBut no portals are tested at runtime.\nInstead, each cell gets a precomputed list of other cells that can been seen from it.\nThis is the \u003cem\u003ePotentially Visible Set\u003c/em\u003e (PVS) for that cell.\u003c/p\u003e\n\u003cp\u003eIn Quake, a cell is a small convex volume of space, so a single room will usually get split into multiple cells.\nThese cells correspond to leaves of a binary space partitioning (BSP) tree.\nThe BSP tree was used to divide the map into cells and portals.\nFor us, the exact method is irrelevant though.\nBut BSP does make it easy to find the cell the camera is in at runtime.\u003c/p\u003e\n\u003cp\u003eSince we have now entered the Quake territory in our discussion, I’ll start calling a cell a \u003cem\u003eleaf\u003c/em\u003e.\nLeaf is the term used in all source code, level editors, error messages, and other resources on Quake.\nThe meaning stays exactly the same though, it’s just a convex cell connected to other cells via portals.\nThis is how leaves look in our example level:\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"https://30fps.net/pages/pvs-portals-and-quake/colored_leaves.png\" alt=\"The example map divided to convex leaves. Leaf colors are random.\"/\u003e\n\n\u003c/figure\u003e\n\u003cp\u003eThe portals appear in between leaves, as expected:\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"https://30fps.net/pages/pvs-portals-and-quake/example_top_notextures_small.png\" alt=\"Portals placed automatically by the bsp tool. This map is pretty much 2D but everything discussed works just fine in 3D too. Leaf indices are shown in white.\"/\u003e\n\n\u003c/figure\u003e\n\u003cp\u003eNothing would’ve stopped them from grouping multiple leaves to form larger cells with fewer portals in between.\nIn fact, this is exactly what they did for Quake 2 with its “clusters” of leaves.\u003c/p\u003e\n\u003cp\u003eWith larger clusters of leaves, you do get more overdraw.\nAlso, a cluster made of convex leaves may not be convex itself any more.\nBut even in that case you can still act as if it still is, and assume the portals inside can be seen from anywhere in the cluster.\nIt’s less accurate but works.\u003c/p\u003e\n\n\u003ch2 id=\"high-level-overview-of-vis\"\u003eHigh-level overview of vis\u003c/h2\u003e\n\u003cp\u003eThe Quake map tool \u003cstrong\u003evis\u003c/strong\u003e takes in portals generated by another tool, \u003cstrong\u003ebsp\u003c/strong\u003e, precomputes a leaf-to-leaf visibility matrix, and writes the matrix back to the compiled map file.\nThis article series describes how \u003cstrong\u003evis\u003c/strong\u003e functions.\u003c/p\u003e\n\u003cp\u003eWe know that leaves can see each other only through portals.\nSo we don’t even need to know how exactly the leaves look like, only how they are connected together.\u003c/p\u003e\n\u003cp\u003eAt its most basic level, \u003cstrong\u003evis\u003c/strong\u003e does two recursive depth-first traversals, followed by a quick resolve pass before writing the visibility results back to a compiled map file. Three steps:\u003c/p\u003e\n\u003col type=\"1\"\u003e\n\u003cli\u003e\u003cstrong\u003eBase visibility.\u003c/strong\u003e Estimate a coarse leaf-to-portal visibility.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFull visibility.\u003c/strong\u003e Refine the coarse results via portal clipping.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eResolve.\u003c/strong\u003e Combine the refined portal-to-leaf results to the final leaf-to-leaf visibility.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor a quick visual overview, I can recommend Matthew Earl’s \u003ca href=\"https://www.youtube.com/watch?v=IfCRHSIg6zo\"\u003egreat video on Quake’s PVS\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"portals-have-a-direction\"\u003ePortals have a direction\u003c/h3\u003e\n\u003cp\u003eIn a portal system, the cells and portals are structured as a cell-and-portal graph.\nQuake’s map tooling follows this pattern and connects leaves with portals, even though this structure isn’t present at runtime.\nLeafs are connected by portals:\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"https://30fps.net/pages/pvs-portals-and-quake/undirected_graph.png\" alt=\"Leaves (nodes) connected by portals (edges) in a cell-and-portal graph.\"/\u003e\n\n\u003c/figure\u003e\n\u003cp\u003eEach portal is a 3D polygon.\nThey are written by \u003cstrong\u003ebsp\u003c/strong\u003e to a plain text file with a version code, the number of leaves and portals, followed by one portal per line. Like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePRT1\n11\n12\n4 0 1 (880 -224 -8 ) (880 -272 -8 ) (880 -272 72 ) (880 -224 72 ) \n4 1 2 (832 -224 -8 ) (832 -272 -8 ) (832 -272 72 ) (832 -224 72 ) \n4 2 4 (768 -272 -8 ) (768 -320 -8 ) (768 -320 72 ) (768 -272 72 ) \n4 2 3 (768 -112 72 ) (768 -112 -8 ) (768 -160 -8 ) (768 -160 72 ) \n4 3 5 (720 -112 72 ) (720 -112 -8 ) (720 -160 -8 ) (720 -160 72 ) \n4 4 5 (720 -272 -8 ) (720 -320 -8 ) (720 -320 72 ) (720 -272 72 ) \n4 5 6 (640 -224 -8 ) (640 -288 -8 ) (640 -288 72 ) (640 -224 72 ) \n4 6 7 (592 -224 -8 ) (592 -288 -8 ) (592 -288 72 ) (592 -224 72 ) \n4 7 10 (384 -304 -8 ) (384 -368 -8 ) (384 -368 72 ) (384 -304 72 ) \n4 7 8 (384 -112 -8 ) (384 -176 -8 ) (384 -176 72 ) (384 -112 72 ) \n4 8 9 (240 -176 -8 ) (336 -176 -8 ) (336 -176 72 ) (240 -176 72 ) \n4 9 10 (240 -304 -8 ) (336 -304 -8 ) (336 -304 72 ) (240 -304 72 ) \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEach portal is a loop of 3D points:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌ the number of points\n│ \n▽      x    y    z   x     y    z    x    y   z     x    y   z\n4 0 1 (880 -224 -8 ) (880 -272 -8 ) (880 -272 72 ) (880 -224 72 ) \n  △ △ \n  └─┴─ the two leaves the portal is in between\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince portals are interfaces between convex leaves, the polygons are also convex.\nIn 3D, a portal looks like this:\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"https://30fps.net/pages/pvs-portals-and-quake/portal_onedirection.jpg\" alt=\"Each portal is stored as a convex polygon.\"/\u003e\n\n\u003c/figure\u003e\n\u003cp\u003eConceptually, each portal is a two way opening. You can see through it in both directions.\nHowever, it’s convenient to make the portals directed.\nThis way we can keep track on what’s visible in different directions.\nWe give each portal a normal vector, the direction the portal can be seen through.\u003c/p\u003e\n\u003cp\u003eNow a single input portal becomes two directed portals:\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"https://30fps.net/pages/pvs-portals-and-quake/portal_two_directions.jpg\" alt=\"Each input portal is split into a so called forward (red) and backward (yellow) portal before processing. There’s a small gap here for demonstration purposes but actually they overlap. The arrows show the directions the portals can be seen through.\"/\u003e\n\n\u003c/figure\u003e\n\u003cp\u003eTherefore the graph will now have directed edges instead:\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg src=\"https://30fps.net/pages/pvs-portals-and-quake/directed_graph_with_colors.png\" alt=\"Each portal is represented by two edges in the graph. The earlier forward and backwards portal edges are highlighted with red and gold, respectively.\"/\u003e\n\n\u003c/figure\u003e\n\u003ch3 id=\"the-graph-in-code\"\u003eThe graph in code\u003c/h3\u003e\n\u003cp\u003eNow is the time to present the main data structures of \u003cstrong\u003evis.py\u003c/strong\u003e, the \u003ca href=\"https://github.com/pekkavaa/vis.py/blob/main/portaltypes.py\"\u003e\u003cstrong\u003ePortal\u003c/strong\u003e and \u003cstrong\u003eLeaf\u003c/strong\u003e classes\u003c/a\u003e:\u003c/p\u003e\n\u003cdiv id=\"cb3\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb3-1\"\u003e\u003cspan\u003eclass\u003c/span\u003e Portal:\u003c/span\u003e\n\u003cspan id=\"cb3-2\"\u003e  winding: \u003cspan\u003elist\u003c/span\u003e[np.ndarray]   \u003cspan\u003e# polygon\u0026#39;s 3D points\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-3\"\u003e  leaf: \u003cspan\u003eint\u003c/span\u003e                   \u003cspan\u003e# the leaf this portal leads to\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-4\"\u003e  plane: Plane                \u003cspan\u003e# plane normal points to destination leaf\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-5\"\u003e  ...                         \u003cspan\u003e# (other class attributes omitted)\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-6\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-7\"\u003e\u003cspan\u003eclass\u003c/span\u003e Leaf:\u003c/span\u003e\n\u003cspan id=\"cb3-8\"\u003e  portals: \u003cspan\u003elist\u003c/span\u003e[\u003cspan\u003eint\u003c/span\u003e]    \u003cspan\u003e# indices of portals leading away from this leaf\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNote that a leaf stores only indices of portals \u003cem\u003eleading away\u003c/em\u003e from that leaf.\nThe graph is stored in two global arrays called \u003cstrong\u003eportals\u003c/strong\u003e and \u003cstrong\u003eleaves\u003c/strong\u003e with objects of the respective types.\nSince the graph is accessed both via indices and direct object references, I came up with the following naming convention:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epi\u003c/code\u003e is the index of a portal, \u003ccode\u003ePi\u003c/code\u003e is the actual object \u003ccode\u003ePi = portals[pi]\u003c/code\u003e, and\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eli\u003c/code\u003e is the index of a leaf, \u003ccode\u003eLi\u003c/code\u003e is the actual object \u003ccode\u003eLi = leaves[li]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOur goal is to compute which nodes can reach each other in this graph while honoring the 3D visibility relations between portals associated with each edge.\nBut what on earth are those “visibility relations”?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eIn \u003ca href=\"https://30fps.net/pages/pvs-coarse-visibility/\"\u003ethe next part\u003c/a\u003e we’ll use the graph for some quick checks.\u003c/em\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003e\u003cem\u003eI’m also thinking of writing a book. \u003ca href=\"https://30fps.net/book\"\u003eSign up here\u003c/a\u003e if you’re interested.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": null,
  "modifiedTime": null
}
