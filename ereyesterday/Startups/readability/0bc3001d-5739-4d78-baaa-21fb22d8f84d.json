{
  "id": "0bc3001d-5739-4d78-baaa-21fb22d8f84d",
  "title": "Multi-Stage Programming with Splice Variables",
  "link": "https://tsung-ju.org/icfp25/",
  "description": "Article URL: https://tsung-ju.org/icfp25/ Comments URL: https://news.ycombinator.com/item?id=44401303 Points: 6 # Comments: 0",
  "author": "matt_d",
  "published": "Fri, 27 Jun 2025 23:45:03 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 17321,
  "excerpt": "This is an interactive demonstration of the ICFP 2025 paper Multi-Stage Programming with Splice Variables by Tsung-Ju Chiang and Ningning Xie.",
  "siteName": "",
  "favicon": "",
  "text": "This is an interactive demonstration of the ICFP 2025 paper Multi-Stage Programming with Splice Variables by Tsung-Ju Chiang and Ningning Xie. What is multi-stage programming? It's a technique where programs generate other programs. Instead of writing generic code that handles all cases at runtime, you generate specialized, optimized code tailored to specific situations. For example, instead of a power function that uses a loop, you could generate specialized code like x * x * x * x * x directly. This eliminates runtime overhead and creates highly optimized code. Our approach introduces splice variables — a new way to make code generation predictable and safe. This technique provides precise control over the generation process and seamlessly scales to advanced features like code pattern matching and rewriting. The type system automatically tracks variable dependencies, ensuring that generated code is always well-formed, properly scoped, and type-checks correctly. Playground The code editor below lets you experiment with the language described in the paper. Try the examples as you read through the tutorial, or experiment with your own code! For more details on the type system's inner workings and implementation, please refer to the paper. Examples: Staged Power Function   Anaphoric If   Symbolic Differentiation Tutorial The Basics The language syntax resembles OCaml or (to a lesser extent) Haskell. It includes basic types like int and bool, arithmetic operators (+, -, *, /), comparison (==), conditionals (if then else), functions, and let bindings. Type annotations are written as e : type for expression e. Quotations: Capturing Code as Data The first key idea is quotations. When you write \u003c1 + 2\u003e, instead of computing 3, this creates a piece of code that represents the expression 1 + 2. Try it: The angle brackets \u003c \u003e tell the system \"don't evaluate this yet, just treat it as data.\" Think of it like putting code in quotes to talk about the code itself rather than running it. Quotations can even be nested inside other quotations to create code that generates code: \u003cif true then \u003c1\u003e else \u003c2\u003e\u003e Splice Variables: Injecting Code into Code Now comes the interesting part: how can quoted code be used inside other quoted code? Consider having some code stored in a quotation, and wanting to use it as part of a larger piece of code. The let$ construct \"unwraps\" a piece of quoted code and allows its use inside other quotations: What happened here? The quoted code \u003c1\u003e was unwrapped into a variable called x, then x was used twice inside a new quotation. The result is code that adds 1 + 1. The variable x is called a splice variable because it \"splices\" the unwrapped code into the new quotation. More interestingly, code that contains variables can also be unwrapped by declaring variable dependencies: let$ s [x : int] = \u003cx + 1\u003e in \u003cfun x : int -\u003e s\u003e Here, s is a splice variable that depends on an integer variable x. The square brackets [x : int] say \"this code uses a variable called x of type int.\" When we use s, it automatically captures the variable x from the surrounding context. Instead of capturing the same variable, you can also explicitly provide a value for the variable: let$ s [x : int] = \u003cx + 1\u003e in \u003cs [x=42]\u003e Here, we tell the system to substitute x with 42 when generating the code. The result is code that adds 42 + 1. Why Splice Variables Are Necessary Why do we need this special let$ syntax instead of just using regular variables? There are two fundamental reasons why splice variables are necessary for safe code generation. Stage Tracking The first reason is stage tracking: In our system, each variable has a stage level that determines how deeply nested in quotations it can be used. Regular variables exist at stage 0 (the current evaluation context), but let$ creates splice variables at stage 1, which means they can be used inside one level of quotations to represent code fragments. For example, with nested quotations like \u003c\u003cx\u003e\u003e (code that generates code that uses x), you need variables at different stages: stage 0 for the outermost context, stage 1 for inside the first quotation, and stage 2 for inside the nested quotation. This stage tracking ensures that variables are only used in appropriate contexts. Let's see this in action: let$ s [x@1 : bool; y@2 : int] = \u003cif x then \u003cy + 1\u003e else \u003cy + 2\u003e\u003e in \u003cfun x : int -\u003e s[y=42]\u003e In this example, a splice variable s is created that depends on a boolean variable x at stage 1 and an integer variable y at stage 2. The code inside s uses these variables to generate code that conditionally generates either y + 1 or y + 2. When s[y=42] is used inside a function, it substitutes y with 42, generating code that evaluates to either 42 + 1 or 42 + 2 based on the value of x. This demonstrates how stage tracking works in practice: x is used inside the first quotation, y is used inside the nested quotation, and s brings code into quotations. The type system ensures each variable is only used at the quotation level it belongs to. Dependency Tracking The second reason is dependency tracking: When you create a piece of code like \u003cx + 1\u003e, it contains a reference to variable x. This code only makes sense if there's actually a variable x available when the code runs. The challenge is keeping track of these dependencies as code gets moved around, put inside functions, or extracted from functions. Consider what happens when code with variables is used in different contexts: let$ s [x : int] = \u003cx + 1\u003e in \u003cfun x : int -\u003e s\u003e Here, s depends on x, and we use it inside a function that has a parameter named x. The system automatically captures the function's x parameter to satisfy the dependency, so we get a function that adds 1 to its input. let$ s [x : int] = \u003cx + 1\u003e in \u003cfun y : int -\u003e s\u003e But here, the function parameter is named y, not x. Since s needs a variable x that doesn't exist in this context, the system reports an error. This prevents you from accidentally generating code with undefined variables. To fix this, you explicitly provide the missing dependency: let$ s [x : int] = \u003cx + 1\u003e in \u003cfun y : int -\u003e s[x=y]\u003e You can provide any valid expression for the dependency: let$ s [x : int] = \u003cx + 1\u003e in \u003cfun y : int -\u003e s[x=y * y]\u003e This dependency tracking is also relevant when pattern matching on code. (We'll see how code pattern matching works later in the tutorial.) If you extract the body from \u003cfun x -\u003e x + 1\u003e, that extracted code now depends on the variable x from the function. Our type system automatically tracks these dependencies, ensuring all generated code has correct scoping. Our type system automatically tracks both stage levels and variable dependencies, ensuring that all generated code is well-formed, properly scoped, and type-checks correctly. This makes code generation predictable and safe. A Practical Example: The Power Function Let's see how these ideas work together in a practical example. We'll build a function that creates optimized power functions — instead of using loops, we'll generate code that does direct multiplication. let rec power : int code -\u003e int -\u003e int code = fun x -\u003e fun n -\u003e if n == 0 then \u003c1\u003e else let$ s1 = x in let$ s2 = power x (n - 1) in \u003cs1 * s2\u003e in power \u003c2\u003e 3 This function takes some quoted code x and a number n, then builds code that multiplies x by itself n times. Try it with power \u003c2\u003e 3 to see how it generates 2 * 2 * 2 * 1. Making Code Reusable What if we want to create a power function that can work with different inputs? This is where dependency variables come in. They let us create code templates with placeholders. let rec power : int code -\u003e int -\u003e int code = fun x -\u003e fun n -\u003e if n == 0 then \u003c1\u003e else let$ s1 = x in let$ s2 = power x (n - 1) in \u003cs1 * s2\u003e in let$ power5 [x : int] = power \u003cx\u003e 5 in \u003cfun x : int -\u003e power5\u003e Here, power5 is a splice variable that depends on x. The square brackets [x : int] say \"this code fragment uses a variable called x that will be provided later.\" When we use power5 inside the function, it automatically gets the x from the function parameter. The result is a function that directly multiplies its input five times — no loops, no recursion at runtime! Code Pattern Matching Our language also supports pattern matching on code, which allows you to inspect and transform code structures. This is useful for optimizations and code analysis. let swap_add : int code -\u003e int code = fun e -\u003e match$ e with | (x + y) -\u003e \u003cy + x\u003e | _ -\u003e e in swap_add \u003c1 + 2\u003e This function takes a piece of code and, if it's an addition, swaps the operands. The pattern (x + y) matches any addition where x and y become pattern variables that can be used in the result. Working with Functions Pattern matching becomes more tricky when dealing with code that contains variables. This is where the variable dependency tracking we discussed earlier becomes crucial. Our system automatically handles the binding structure: match$ \u003cfun x : int -\u003e x + 1\u003e with | (fun x -\u003e body) -\u003e \u003cbody [x=42]\u003e Here, body captures the function body x + 1 and remembers that it uses a variable x. We can then substitute x with 42 to get 42 + 1. The system knows that body depends on x and handles the substitution correctly. Code generation often produces unoptimized expressions with redundant operations. For example, when generating mathematical code, you might end up with expressions like x * 0 or 1 * y that could be simplified. Code rewriting lets you automatically clean up these patterns. The rewrite operator applies transformation rules to simplify generated code: \u003c42 + (0 * 5)\u003e rewrite (0 * z) -\u003e \u003c0\u003e rewrite (z + 0) -\u003e \u003cz\u003e This applies two simplification rules to the expression 42 + (0 * 5): first it replaces 0 * 5 with 0, then it replaces 42 + 0 with 42. Each rewrite rule says \"whenever you see this pattern anywhere in the code, replace it with that expression.\" The key difference from match$ is that rewrite searches through the entire code structure and applies transformations wherever patterns match, not just at the top level. This makes it perfect for cleanup operations that need to work throughout a complex expression. Again, we use splice variables to handle code patterns that contain variable bindings. The system automatically tracks variable dependencies, so you can write transformations that manipulate binding structures safely: \u003c(fun y : int -\u003e y * 2) ((fun x : int -\u003e x + 1) 5)\u003e rewrite ((fun arg : int -\u003e body : int) expr) -\u003e \u003cbody [arg=expr]\u003e This rewrite rule performs beta reduction — it finds function applications and substitutes the argument into the function body. The pattern (fun arg -\u003e body) expr matches any function being applied to an argument. The system knows that body depends on the variable arg, so when we write body [arg=expr], it correctly substitutes all occurrences of arg in the body with the provided expression. This kind of transformation would be error-prone to write manually, but our dependency tracking system handles all the variable scoping automatically, ensuring the result is always well-formed. Advanced Features Unhygienic Functions: Intentional Variable Capture Most programming languages try to prevent accidental variable capture — when a macro or function accidentally uses a variable from the surrounding context, or defines a variable that conflicts with the context where the macro is expanded. This can lead to bugs that are hard to track down. This property is called hygiene, and it's generally a good thing. But sometimes you actually want to define a variable that can be used within the arguments given to a function. Our language supports unhygienic functions — functions whose arguments can use variables that are not defined in the current scope but are provided by the function itself. This allows you to write code generation patterns that intentionally introduce or capture variables. The simplest example is a function that expects its argument to use a specific variable: let with_x_42 : int code [x : int] -\u003e int code = fun c -\u003e c[x=42] in with_x_42 \u003cx + 1\u003e Here, with_x_42 is a function that takes a piece of code that depends on a variable x and substitutes x with 42. The type signature int code [x : int] -\u003e int code tells us that the function accepts code that may refer to a variable x and produces regular code. When we call with_x_42 \u003cx + 1\u003e, the system allows the argument to reference x even though x isn't defined in the current scope — because the function promises to provide it. This becomes especially useful when creating functions that act like new binding constructs. A classic example is an anaphoric conditional — a conditional that binds the test expression to a variable it that can be used in both branches: let aif : bool code -\u003e int code [it : bool] -\u003e int code [it : bool] -\u003e int code = fun cond -\u003e fun then_branch -\u003e fun else_branch -\u003e let$ s1 = cond in let$ s2 [it : bool] = then_branch in let$ s3 [it : bool] = else_branch in \u003clet it = s1 in if it then s2 else s3\u003e in aif \u003ctrue\u003e \u003c42\u003e \u003c43\u003e This aif function takes three arguments: a condition, a then-branch, and an else-branch. The key insight is that both branches can refer to a variable it that will be bound to the result of evaluating the condition. The type signatures int code [it : bool] tell the type system that these arguments are allowed to use this variable. The implementation uses splice variables to construct the final code: it evaluates the condition once, binds it to it, and then uses it in the appropriate branch. This avoids re-evaluating the condition and gives both branches access to its value. You can also declare normal variables (not splice variables) with dependencies: let x : int code [y : int] = \u003cy + 1\u003e in x[y=2] Here, x is a normal variable that depends on y. Unlike splice variables created with let$, normal variables stay at the same stage level — they don't get \"unwrapped\" for use in quotations. The variable x holds the code value \u003cy + 1\u003e, and when we write x[y=2], it substitutes y with 2 to produce \u003c2 + 1\u003e. Wrap Types Most of the time, let$ and let provide convenient ways to create variables with dependencies. But sometimes you need more control over when and how dependencies are introduced. The wrap construct lets you create values with dependencies without immediately binding them to variables. Most importantly, let$ and let only allow declaring dependencies for variables, while wrap allows you to declare dependencies for values. This enables you to declare dependencies for the output of a function, or store a value with dependencies in a data structure. Think of wrap as creating a value that uses some symbolic variables. It creates a value of type type \u003c| [dependencies] without binding it to a variable, where type is the type of the value and [dependencies] are the declared dependencies. This wraps a int code value that depends on the variable x. The result has type int code \u003c| [x : int] — this is called a wrap type. The \u003c| notation (\u003c followed by |) indicates that this is a wrapped value that, when unwrapped, will require the dependencies to be provided. Wrap types are useful when you want to store a value with dependencies in data structures or pass it around without immediately providing the dependencies. To use a wrapped value, you can unwrap it into a variable using let wrap: let wrap_s : int code \u003c| [x : int] = wrap [x : int] \u003cx + 1\u003e in let wrap s : int code [x : int] = wrap_s in s[x=42] Here, the first line creates a wrapped value without binding it to any variable. The second line uses let wrap to turn the wrapped value into a regular variable s that depends on x. Finally, we provide the dependency x=42 to get the concrete code \u003c42 + 1\u003e.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\n  \n\n  \u003cp\u003e\n    This is an interactive demonstration of the ICFP 2025 paper\n    \u003cem\u003e\u003ca href=\"https://tsung-ju.org/icfp25/Multi-Stage%20Programming%20with%20Splice%20Variables.pdf\"\u003eMulti-Stage Programming with Splice Variables\u003c/a\u003e\u003c/em\u003e\n    by \u003ca href=\"https://tsung-ju.org/\"\u003eTsung-Ju Chiang\u003c/a\u003e and \u003ca href=\"https://xnning.github.io/\"\u003eNingning Xie\u003c/a\u003e.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    \u003cstrong\u003eWhat is multi-stage programming?\u003c/strong\u003e It\u0026#39;s a technique where programs generate other programs. \n    Instead of writing generic code that handles all cases at runtime, you generate specialized, optimized code \n    tailored to specific situations.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    For example, instead of a power function that uses a loop, you could generate specialized code like \n    \u003ccode\u003ex * x * x * x * x\u003c/code\u003e directly. This eliminates runtime overhead and creates highly optimized code.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Our approach introduces \u003cem\u003esplice variables\u003c/em\u003e — a new way to make code generation predictable and safe.\n    This technique provides precise control over the generation process and seamlessly scales to advanced features like code pattern matching and rewriting.\n    The type system automatically tracks variable dependencies, ensuring that generated code is always well-formed, properly scoped, and type-checks correctly.\n  \u003c/p\u003e\n\n  \u003ch2\u003ePlayground\u003c/h2\u003e\n  \u003cp\u003e\n    The code editor below lets you experiment with the language described in the paper.\n    Try the examples as you read through the tutorial, or experiment with your own code!\n    For more details on the type system\u0026#39;s inner workings and implementation, please refer to \u003ca href=\"https://tsung-ju.org/icfp25/Multi-Stage%20Programming%20with%20Splice%20Variables.pdf\"\u003ethe paper\u003c/a\u003e.\n  \u003c/p\u003e  \n\n  \u003cnav id=\"playground-examples\"\u003e\n    \u003cstrong\u003eExamples:\u003c/strong\u003e\n    Staged Power Function  \n    Anaphoric If  \n    Symbolic Differentiation\n  \u003c/nav\u003e\n  \n  \n\n  \n\n  \n\n  \u003ch2\u003eTutorial\u003c/h2\u003e\n\n  \u003ch3\u003eThe Basics\u003c/h3\u003e\n  \u003cp\u003e\n    The language syntax resembles OCaml or (to a lesser extent) Haskell.\n    It includes basic types like \u003ccode\u003eint\u003c/code\u003e and \u003ccode\u003ebool\u003c/code\u003e,\n    arithmetic operators (\u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e*\u003c/code\u003e, \u003ccode\u003e/\u003c/code\u003e), \n    comparison (\u003ccode\u003e==\u003c/code\u003e), conditionals (\u003ccode\u003eif then else\u003c/code\u003e), \n    functions, and let bindings.\n    Type annotations are written as \u003ccode\u003ee : type\u003c/code\u003e for expression \u003ccode\u003ee\u003c/code\u003e.\n  \u003c/p\u003e\n\n  \u003ch4\u003eQuotations: Capturing Code as Data\u003c/h4\u003e\n  \u003cp\u003e\n    The first key idea is \u003cem\u003equotations\u003c/em\u003e. When you write \u003ccode\u003e\u0026lt;1 + 2\u0026gt;\u003c/code\u003e, \n    instead of computing \u003ccode\u003e3\u003c/code\u003e, this creates a piece of \u003cem\u003ecode\u003c/em\u003e that represents the expression \u003ccode\u003e1 + 2\u003c/code\u003e.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Try it:\n  \u003c/p\u003e\n  \n\n  \u003cp\u003e\n    The angle brackets \u003ccode\u003e\u0026lt; \u0026gt;\u003c/code\u003e tell the system \u0026#34;don\u0026#39;t evaluate this yet, just treat it as data.\u0026#34;\n    Think of it like putting code in quotes to talk about the code itself rather than running it.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Quotations can even be nested inside other quotations to create code that generates code:\n  \u003c/p\u003e\n  \u003cdiv\u003e\n    \u003cp\u003e\u0026lt;if true then \u0026lt;1\u0026gt; else \u0026lt;2\u0026gt;\u0026gt;\u003c/p\u003e\n    \n  \u003c/div\u003e\n\n  \u003ch3\u003eSplice Variables: Injecting Code into Code\u003c/h3\u003e\n  \u003cp\u003e\n    Now comes the interesting part: how can quoted code be used inside other quoted code? \n    Consider having some code stored in a quotation, and wanting to use it as part of a larger piece of code.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    The \u003ccode\u003elet$\u003c/code\u003e construct \u0026#34;unwraps\u0026#34; a piece of quoted code and allows its use inside other quotations:\n  \u003c/p\u003e\n  \n\n  \u003cp\u003e\n    What happened here? The quoted code \u003ccode\u003e\u0026lt;1\u0026gt;\u003c/code\u003e was unwrapped into a variable called \u003ccode\u003ex\u003c/code\u003e, \n    then \u003ccode\u003ex\u003c/code\u003e was used twice inside a new quotation. The result is code that adds \u003ccode\u003e1 + 1\u003c/code\u003e.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    The variable \u003ccode\u003ex\u003c/code\u003e is called a \u003cem\u003esplice variable\u003c/em\u003e because it \u0026#34;splices\u0026#34; the unwrapped code into the new quotation.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    More interestingly, code that contains variables can also be unwrapped by declaring \u003cem\u003evariable dependencies\u003c/em\u003e:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cp\u003elet$ s [x : int] = \u0026lt;x + 1\u0026gt; in \u0026lt;fun x : int -\u0026gt; s\u0026gt;\u003c/p\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    Here, \u003ccode\u003es\u003c/code\u003e is a splice variable that depends on an integer variable \u003ccode\u003ex\u003c/code\u003e. \n    The square brackets \u003ccode\u003e[x : int]\u003c/code\u003e say \u0026#34;this code uses a variable called \u003ccode\u003ex\u003c/code\u003e of type \u003ccode\u003eint\u003c/code\u003e.\u0026#34;\n    When we use \u003ccode\u003es\u003c/code\u003e, it automatically captures the variable \u003ccode\u003ex\u003c/code\u003e from the surrounding context.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Instead of capturing the same variable, you can also explicitly provide a value for the variable:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cp\u003elet$ s [x : int] = \u0026lt;x + 1\u0026gt; in \u0026lt;s [x=42]\u0026gt;\u003c/p\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    Here, we tell the system to substitute \u003ccode\u003ex\u003c/code\u003e with \u003ccode\u003e42\u003c/code\u003e when generating the code.\n    The result is code that adds \u003ccode\u003e42 + 1\u003c/code\u003e.\n  \u003c/p\u003e\n\n  \u003ch4\u003eWhy Splice Variables Are Necessary\u003c/h4\u003e\n  \u003cp\u003e\n    Why do we need this special \u003ccode\u003elet$\u003c/code\u003e syntax instead of just using regular variables?\n    There are two fundamental reasons why splice variables are necessary for safe code generation.\n  \u003c/p\u003e\n\n  \u003ch5\u003eStage Tracking\u003c/h5\u003e\n  \u003cp\u003e\n    The first reason is \u003cem\u003estage tracking\u003c/em\u003e: In our system, each variable has a \u003cem\u003estage level\u003c/em\u003e that determines \n    how deeply nested in quotations it can be used. Regular variables exist at stage 0 (the current evaluation context), \n    but \u003ccode\u003elet$\u003c/code\u003e creates splice variables at stage 1, which means they can be used inside one level of quotations \n    to represent code fragments.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    For example, with nested quotations like \u003ccode\u003e\u0026lt;\u0026lt;x\u0026gt;\u0026gt;\u003c/code\u003e (code that generates code that uses \u003ccode\u003ex\u003c/code\u003e), \n    you need variables at different stages: stage 0 for the outermost context, stage 1 for inside the first quotation, \n    and stage 2 for inside the nested quotation. This stage tracking ensures that variables are only used in appropriate contexts.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Let\u0026#39;s see this in action:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cpre\u003elet$ s [x@1 : bool; y@2 : int] = \u0026lt;if x then \u0026lt;y + 1\u0026gt; else \u0026lt;y + 2\u0026gt;\u0026gt; in\n\u0026lt;fun x : int -\u0026gt; s[y=42]\u0026gt;\u003c/pre\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    In this example, a splice variable \u003ccode\u003es\u003c/code\u003e is created that depends on a boolean variable \u003ccode\u003ex\u003c/code\u003e at stage 1 \n    and an integer variable \u003ccode\u003ey\u003c/code\u003e at stage 2. The code inside \u003ccode\u003es\u003c/code\u003e uses these variables to generate \n    code that conditionally generates either \u003ccode\u003ey + 1\u003c/code\u003e or \u003ccode\u003ey + 2\u003c/code\u003e.\n    When \u003ccode\u003es[y=42]\u003c/code\u003e is used inside a function, it substitutes \u003ccode\u003ey\u003c/code\u003e with \u003ccode\u003e42\u003c/code\u003e,\n    generating code that evaluates to either \u003ccode\u003e42 + 1\u003c/code\u003e or \u003ccode\u003e42 + 2\u003c/code\u003e based on the value of \u003ccode\u003ex\u003c/code\u003e. \n  \u003c/p\u003e\n\n  \u003cp\u003e\n    This demonstrates how stage tracking works in practice: \u003ccode\u003ex\u003c/code\u003e is used inside the first quotation, \n    \u003ccode\u003ey\u003c/code\u003e is used inside the nested quotation, and \u003ccode\u003es\u003c/code\u003e brings code into quotations. \n    The type system ensures each variable is only used at the quotation level it belongs to.\n  \u003c/p\u003e\n\n  \u003ch5\u003eDependency Tracking\u003c/h5\u003e\n  \u003cp\u003e\n    The second reason is \u003cem\u003edependency tracking\u003c/em\u003e: When you create a piece of code like \u003ccode\u003e\u0026lt;x + 1\u0026gt;\u003c/code\u003e, it contains a reference to variable \u003ccode\u003ex\u003c/code\u003e.\n    This code only makes sense if there\u0026#39;s actually a variable \u003ccode\u003ex\u003c/code\u003e available when the code runs.\n    The challenge is keeping track of these dependencies as code gets moved around, put inside functions, or extracted from functions.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Consider what happens when code with variables is used in different contexts:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cp\u003elet$ s [x : int] = \u0026lt;x + 1\u0026gt; in \u0026lt;fun x : int -\u0026gt; s\u0026gt;\u003c/p\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    Here, \u003ccode\u003es\u003c/code\u003e depends on \u003ccode\u003ex\u003c/code\u003e, and we use it inside a function that has a parameter named \u003ccode\u003ex\u003c/code\u003e. \n    The system automatically captures the function\u0026#39;s \u003ccode\u003ex\u003c/code\u003e parameter to satisfy the dependency, \n    so we get a function that adds 1 to its input.\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cp\u003elet$ s [x : int] = \u0026lt;x + 1\u0026gt; in \u0026lt;fun y : int -\u0026gt; s\u0026gt;\u003c/p\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    But here, the function parameter is named \u003ccode\u003ey\u003c/code\u003e, not \u003ccode\u003ex\u003c/code\u003e. Since \u003ccode\u003es\u003c/code\u003e needs a variable \u003ccode\u003ex\u003c/code\u003e \n    that doesn\u0026#39;t exist in this context, the system reports an error. This prevents you from accidentally \n    generating code with undefined variables.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    To fix this, you explicitly provide the missing dependency:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cp\u003elet$ s [x : int] = \u0026lt;x + 1\u0026gt; in \u0026lt;fun y : int -\u0026gt; s[x=y]\u0026gt;\u003c/p\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    You can provide any valid expression for the dependency:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cp\u003elet$ s [x : int] = \u0026lt;x + 1\u0026gt; in \u0026lt;fun y : int -\u0026gt; s[x=y * y]\u0026gt;\u003c/p\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    This dependency tracking is also relevant when pattern matching on code.\n    (We\u0026#39;ll see how code pattern matching works later in the tutorial.)\n    If you extract the body from \u003ccode\u003e\u0026lt;fun x -\u0026gt; x + 1\u0026gt;\u003c/code\u003e, that extracted code \n    now depends on the variable \u003ccode\u003ex\u003c/code\u003e from the function. Our type system \n    automatically tracks these dependencies, ensuring all generated code has correct scoping.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Our type system automatically tracks both stage levels and variable dependencies, \n    ensuring that all generated code is well-formed, properly scoped, and type-checks correctly.\n    This makes code generation predictable and safe.\n  \u003c/p\u003e\n\n  \u003ch3\u003eA Practical Example: The Power Function\u003c/h3\u003e\n  \u003cp\u003e\n    Let\u0026#39;s see how these ideas work together in a practical example. We\u0026#39;ll build a function that creates \n    optimized power functions — instead of using loops, we\u0026#39;ll generate code that does direct multiplication.\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cpre\u003elet rec power : int code -\u0026gt; int -\u0026gt; int code = fun x -\u0026gt; fun n -\u0026gt;\n  if n == 0 then \u0026lt;1\u0026gt;\n  else\n    let$ s1 = x in\n    let$ s2 = power x (n - 1) in\n    \u0026lt;s1 * s2\u0026gt;\nin power \u0026lt;2\u0026gt; 3\u003c/pre\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    This function takes some quoted code \u003ccode\u003ex\u003c/code\u003e and a number \u003ccode\u003en\u003c/code\u003e, then builds code that \n    multiplies \u003ccode\u003ex\u003c/code\u003e by itself \u003ccode\u003en\u003c/code\u003e times. Try it with \u003ccode\u003epower \u0026lt;2\u0026gt; 3\u003c/code\u003e to see how it generates \u003ccode\u003e2 * 2 * 2 * 1\u003c/code\u003e.\n  \u003c/p\u003e\n\n  \u003ch3\u003eMaking Code Reusable\u003c/h3\u003e\n  \u003cp\u003e\n    What if we want to create a power function that can work with different inputs? \n    This is where \u003cem\u003edependency variables\u003c/em\u003e come in. They let us create code templates with placeholders.\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cpre\u003elet rec power : int code -\u0026gt; int -\u0026gt; int code = fun x -\u0026gt; fun n -\u0026gt;\n  if n == 0 then \u0026lt;1\u0026gt;\n  else\n    let$ s1 = x in\n    let$ s2 = power x (n - 1) in\n    \u0026lt;s1 * s2\u0026gt; in\nlet$ power5 [x : int] = power \u0026lt;x\u0026gt; 5 in\n  \u0026lt;fun x : int -\u0026gt; power5\u0026gt;\u003c/pre\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    Here, \u003ccode\u003epower5\u003c/code\u003e is a splice variable that depends on \u003ccode\u003ex\u003c/code\u003e. The square brackets \u003ccode\u003e[x : int]\u003c/code\u003e \n    say \u0026#34;this code fragment uses a variable called \u003ccode\u003ex\u003c/code\u003e that will be provided later.\u0026#34; When we use \u003ccode\u003epower5\u003c/code\u003e \n    inside the function, it automatically gets the \u003ccode\u003ex\u003c/code\u003e from the function parameter.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    The result is a function that directly multiplies its input five times — no loops, no recursion at runtime!\n  \u003c/p\u003e\n\n  \u003ch3\u003eCode Pattern Matching\u003c/h3\u003e\n  \u003cp\u003e\n    Our language also supports pattern matching on code, which allows you to inspect and transform \n    code structures. This is useful for optimizations and code analysis.\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cpre\u003elet swap_add : int code -\u0026gt; int code = fun e -\u0026gt;\n  match$ e with\n    | (x + y) -\u0026gt; \u0026lt;y + x\u0026gt;\n    | _ -\u0026gt; e\nin\n  swap_add \u0026lt;1 + 2\u0026gt;\u003c/pre\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    This function takes a piece of code and, if it\u0026#39;s an addition, swaps the operands. The pattern \u003ccode\u003e(x + y)\u003c/code\u003e \n    matches any addition where \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e become pattern variables that can be used in the result.\n  \u003c/p\u003e\n\n  \u003ch4\u003eWorking with Functions\u003c/h4\u003e\n  \u003cp\u003e\n    Pattern matching becomes more tricky when dealing with code that contains variables. \n    This is where the variable dependency tracking we discussed earlier becomes crucial.\n    Our system automatically handles the binding structure:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cp\u003ematch$ \u0026lt;fun x : int -\u0026gt; x + 1\u0026gt; with \n| (fun x -\u0026gt; body) -\u0026gt; \u0026lt;body [x=42]\u0026gt;\u003c/p\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    Here, \u003ccode\u003ebody\u003c/code\u003e captures the function body \u003ccode\u003ex + 1\u003c/code\u003e and remembers that it uses a variable \u003ccode\u003ex\u003c/code\u003e. \n    We can then substitute \u003ccode\u003ex\u003c/code\u003e with \u003ccode\u003e42\u003c/code\u003e to get \u003ccode\u003e42 + 1\u003c/code\u003e.\n    The system knows that \u003ccode\u003ebody\u003c/code\u003e depends on \u003ccode\u003ex\u003c/code\u003e and handles the substitution correctly.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Code generation often produces unoptimized expressions with redundant operations. \n    For example, when generating mathematical code, you might end up with expressions like \n    \u003ccode\u003ex * 0\u003c/code\u003e or \u003ccode\u003e1 * y\u003c/code\u003e that could be simplified. \n    Code rewriting lets you automatically clean up these patterns.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    The \u003ccode\u003erewrite\u003c/code\u003e operator applies transformation rules to simplify generated code:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cpre\u003e\u0026lt;42 + (0 * 5)\u0026gt;\n  rewrite (0 * z) -\u0026gt; \u0026lt;0\u0026gt;\n  rewrite (z + 0) -\u0026gt; \u0026lt;z\u0026gt;\u003c/pre\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    This applies two simplification rules to the expression \u003ccode\u003e42 + (0 * 5)\u003c/code\u003e:\n    first it replaces \u003ccode\u003e0 * 5\u003c/code\u003e with \u003ccode\u003e0\u003c/code\u003e, then it replaces \u003ccode\u003e42 + 0\u003c/code\u003e with \u003ccode\u003e42\u003c/code\u003e.\n    Each rewrite rule says \u0026#34;whenever you see this pattern anywhere in the code, replace it with that expression.\u0026#34;\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    The key difference from \u003ccode\u003ematch$\u003c/code\u003e is that \u003ccode\u003erewrite\u003c/code\u003e searches through the entire \n    code structure and applies transformations wherever patterns match, not just at the top level. \n    This makes it perfect for cleanup operations that need to work throughout a complex expression.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Again, we use splice variables to handle code patterns that contain variable bindings.\n    The system automatically tracks variable dependencies, so you can write transformations that \n    manipulate binding structures safely:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cpre\u003e\u0026lt;(fun y : int -\u0026gt; y * 2) ((fun x : int -\u0026gt; x + 1) 5)\u0026gt;\n  rewrite ((fun arg : int -\u0026gt; body : int) expr) -\u0026gt; \u0026lt;body [arg=expr]\u0026gt;\u003c/pre\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    This rewrite rule performs beta reduction — it finds function applications and substitutes \n    the argument into the function body. The pattern \u003ccode\u003e(fun arg -\u0026gt; body) expr\u003c/code\u003e matches \n    any function being applied to an argument. The system knows that \u003ccode\u003ebody\u003c/code\u003e depends on \n    the variable \u003ccode\u003earg\u003c/code\u003e, so when we write \u003ccode\u003ebody [arg=expr]\u003c/code\u003e, it correctly \n    substitutes all occurrences of \u003ccode\u003earg\u003c/code\u003e in the body with the provided expression.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    This kind of transformation would be error-prone to write manually, but our dependency tracking \n    system handles all the variable scoping automatically, ensuring the result is always well-formed.\n  \u003c/p\u003e\n\n  \u003ch3\u003eAdvanced Features\u003c/h3\u003e\n\n  \u003ch4\u003eUnhygienic Functions: Intentional Variable Capture\u003c/h4\u003e\n  \n  \u003cp\u003e\n    Most programming languages try to prevent accidental variable capture — when a macro or function \n    accidentally uses a variable from the surrounding context, or defines a variable that conflicts with \n    the context where the macro is expanded. This can lead to bugs that are hard to track down.\n    This property is called \u003cem\u003ehygiene\u003c/em\u003e, and it\u0026#39;s generally a good thing. But sometimes you actually\n    \u003cem\u003ewant\u003c/em\u003e to define a variable that can be used within the arguments given to a function.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Our language supports \u003cem\u003eunhygienic functions\u003c/em\u003e — functions whose arguments can use variables\n    that are not defined in the current scope but are provided by the function itself. This allows you\n    to write code generation patterns that intentionally introduce or capture variables.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    The simplest example is a function that expects its argument to use a specific variable:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cpre\u003elet with_x_42 : int code [x : int] -\u0026gt; int code = fun c -\u0026gt; c[x=42] in\n  with_x_42 \u0026lt;x + 1\u0026gt;\u003c/pre\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    Here, \u003ccode\u003ewith_x_42\u003c/code\u003e is a function that takes a piece of code that depends on a variable \u003ccode\u003ex\u003c/code\u003e\n    and substitutes \u003ccode\u003ex\u003c/code\u003e with \u003ccode\u003e42\u003c/code\u003e. The type signature \u003ccode\u003eint code [x : int] -\u0026gt; int code\u003c/code\u003e\n    tells us that the function accepts code that may refer to a variable \u003ccode\u003ex\u003c/code\u003e and produces regular code.\n    When we call \u003ccode\u003ewith_x_42 \u0026lt;x + 1\u0026gt;\u003c/code\u003e, the system allows the argument to reference \u003ccode\u003ex\u003c/code\u003e \n    even though \u003ccode\u003ex\u003c/code\u003e isn\u0026#39;t defined in the current scope — because the function promises to provide it.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    This becomes especially useful when creating functions that act like new binding constructs. \n    A classic example is an \u003cem\u003eanaphoric conditional\u003c/em\u003e — a conditional that binds the test expression \n    to a variable \u003ccode\u003eit\u003c/code\u003e that can be used in both branches:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cpre\u003elet aif : bool code -\u0026gt; int code [it : bool] -\u0026gt; int code [it : bool] -\u0026gt; int code = \n  fun cond -\u0026gt; fun then_branch -\u0026gt; fun else_branch -\u0026gt;\n    let$ s1 = cond in\n    let$ s2 [it : bool] = then_branch in\n    let$ s3 [it : bool] = else_branch in\n    \u0026lt;let it = s1 in if it then s2 else s3\u0026gt;\nin\n  aif \u0026lt;true\u0026gt; \u0026lt;42\u0026gt; \u0026lt;43\u0026gt;\u003c/pre\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    This \u003ccode\u003eaif\u003c/code\u003e function takes three arguments: a condition, a then-branch, and an else-branch. \n    The key insight is that both branches can refer to a variable \u003ccode\u003eit\u003c/code\u003e that will be bound to \n    the result of evaluating the condition. The type signatures \u003ccode\u003eint code [it : bool]\u003c/code\u003e tell \n    the type system that these arguments are allowed to use this variable.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    The implementation uses splice variables to construct the final code: it evaluates the condition once, \n    binds it to \u003ccode\u003eit\u003c/code\u003e, and then uses \u003ccode\u003eit\u003c/code\u003e in the appropriate branch. This avoids \n    re-evaluating the condition and gives both branches access to its value.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    You can also declare normal variables (not splice variables) with dependencies:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cpre\u003elet x : int code [y : int] = \u0026lt;y + 1\u0026gt; in\n  x[y=2]\u003c/pre\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    Here, \u003ccode\u003ex\u003c/code\u003e is a normal variable that depends on \u003ccode\u003ey\u003c/code\u003e. Unlike splice variables created \n    with \u003ccode\u003elet$\u003c/code\u003e, normal variables stay at the same stage level — they don\u0026#39;t get \u0026#34;unwrapped\u0026#34; for \n    use in quotations. The variable \u003ccode\u003ex\u003c/code\u003e holds the code value \u003ccode\u003e\u0026lt;y + 1\u0026gt;\u003c/code\u003e, and when \n    we write \u003ccode\u003ex[y=2]\u003c/code\u003e, it substitutes \u003ccode\u003ey\u003c/code\u003e with \u003ccode\u003e2\u003c/code\u003e to produce \u003ccode\u003e\u0026lt;2 + 1\u0026gt;\u003c/code\u003e.\n  \u003c/p\u003e\n\n  \u003ch4\u003eWrap Types\u003c/h4\u003e\n\n  \u003cp\u003e\n    Most of the time, \u003ccode\u003elet$\u003c/code\u003e and \u003ccode\u003elet\u003c/code\u003e provide convenient ways to create variables \n    with dependencies. But sometimes you need more control over when and how dependencies are introduced. \n    The \u003ccode\u003ewrap\u003c/code\u003e construct lets you create values with dependencies without immediately binding \n    them to variables.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Most importantly, \u003ccode\u003elet$\u003c/code\u003e and \u003ccode\u003elet\u003c/code\u003e only allow declaring dependencies for \u003cem\u003evariables\u003c/em\u003e,\n    while \u003ccode\u003ewrap\u003c/code\u003e allows you to declare dependencies for \u003cem\u003evalues\u003c/em\u003e.\n    This enables you to declare dependencies for the output of a function,\n    or store a value with dependencies in a data structure.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    Think of \u003ccode\u003ewrap\u003c/code\u003e as creating a value that uses some symbolic variables.\n    It creates a value of type \u003ccode\u003etype \u0026lt;| [dependencies]\u003c/code\u003e without binding it to a variable,\n    where \u003ccode\u003etype\u003c/code\u003e is the type of the value and \u003ccode\u003e[dependencies]\u003c/code\u003e are the declared dependencies.\n  \u003c/p\u003e\n\n  \n\n  \u003cp\u003e\n    This wraps a \u003ccode\u003eint code\u003c/code\u003e value that depends on the variable \u003ccode\u003ex\u003c/code\u003e. The result has type \n    \u003ccode\u003eint code \u0026lt;| [x : int]\u003c/code\u003e — this is called a \u003cem\u003ewrap type\u003c/em\u003e. The \u003ccode\u003e\u0026lt;|\u003c/code\u003e\n    notation (\u003ccode\u003e\u0026lt;\u003c/code\u003e followed by \u003ccode\u003e|\u003c/code\u003e)\n    indicates that this is a wrapped value that, when unwrapped, will require the dependencies\n    to be provided.\n    Wrap types are useful when you want to store a value with dependencies in data structures\n    or pass it around without immediately providing the dependencies.\n  \u003c/p\u003e\n\n  \u003cp\u003e\n    To use a wrapped value, you can unwrap it into a variable using \u003ccode\u003elet wrap\u003c/code\u003e:\n  \u003c/p\u003e\n\n  \u003cdiv\u003e\n    \u003cpre\u003elet wrap_s : int code \u0026lt;| [x : int] = wrap [x : int] \u0026lt;x + 1\u0026gt; in\nlet wrap s : int code [x : int] = wrap_s in\n  s[x=42]\u003c/pre\u003e\n    \n  \u003c/div\u003e\n\n  \u003cp\u003e\n    Here, the first line creates a wrapped value without binding it to any variable. The second line \n    uses \u003ccode\u003elet wrap\u003c/code\u003e to turn the wrapped value into a regular variable \u003ccode\u003es\u003c/code\u003e that \n    depends on \u003ccode\u003ex\u003c/code\u003e. Finally, we provide the dependency \u003ccode\u003ex=42\u003c/code\u003e to get the concrete \n    code \u003ccode\u003e\u0026lt;42 + 1\u0026gt;\u003c/code\u003e.\n  \u003c/p\u003e\n\n  \n\n\n\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": null,
  "modifiedTime": null
}
