{
  "id": "251d4c4c-993e-47bb-9ecb-f184746dfa86",
  "title": "Breaking CityHash64, MurmurHash2/3, wyhash, and more",
  "link": "https://orlp.net/blog/breaking-hash-functions/",
  "description": "Article URL: https://orlp.net/blog/breaking-hash-functions/ Comments URL: https://news.ycombinator.com/item?id=42029542 Points: 25 # Comments: 8",
  "author": "fanf2",
  "published": "Sat, 02 Nov 2024 22:07:09 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 29168,
  "excerpt": "Hash functions are incredibly neat mathematical objects. They can map arbitrary data to a small fixed-size output domain such that the mapping is deterministic, yet appears to be random. This “deterministic randomness” is incredibly useful for a variety of purposes, such as hash tables, checksums, monte carlo algorithms, communication-less distributed algorithms, etc, the list goes on.",
  "siteName": "",
  "favicon": "https://orlp.net/assets/images/favicon.png",
  "text": "2024-11-02 Hash functions are incredibly neat mathematical objects. They can map arbitrary data to a small fixed-size output domain such that the mapping is deterministic, yet appears to be random. This “deterministic randomness” is incredibly useful for a variety of purposes, such as hash tables, checksums, monte carlo algorithms, communication-less distributed algorithms, etc, the list goes on. In this article we will take a look at the dark side of hash functions: when things go wrong. Luckily this essentially never happens due to unlucky inputs in the wild (for good hash functions, at least). However, people exist, and some of them may be malicious. Thus we must look towards computer security for answers. I will quickly explain some of the basics of hash function security and then show how easy it is to break this security for some commonly used non-cryptographic hash functions. As a teaser, this article explains how you can generate strings such as these, thousands per second: cityhash64(\"orlp-cityhash64-D-:K5yx*zkgaaaaa\") == 1337 murmurhash2(\"orlp-murmurhash64-bkiaaa\u0026JInaNcZ\") == 1337 murmurhash3(\"orlp-murmurhash3_x86_32-haaaPa*+\") == 1337 farmhash64(\"orlp-farmhash64-/v^CqdPvziuheaaa\") == 1337 I also show how you can create some really funky pairs of strings that can be concatenated arbitrarily such that when concatenating $k$ strings together any of the $2^k$ combinations all have the same hash output, regardless of the seed used for the hash function: a = \"xx0rlpx!xxsXъВ\" b = \"xxsXъВxx0rlpx!\" murmurhash2(a + a, seed) == murmurhash2(a + b, seed) murmurhash2(a + a, seed) == murmurhash2(b + a, seed) murmurhash2(a + a, seed) == murmurhash2(b + b, seed) a = \"!\u0026orlpՓ\" b = \"yǏglp$X\" murmurhash3(a + a, seed) == murmurhash3(a + b, seed) murmurhash3(a + a, seed) == murmurhash3(b + a, seed) murmurhash3(a + a, seed) == murmurhash3(b + b, seed) Hash function security basics Hash functions play a critical role in computer security. Hash functions are used not only to verify messages over secure channels, they are also used to identify trusted updates as well as known viruses. Virtually every signature scheme ever used starts with a hash function. If a hash function does not behave randomly, we can break the above security constructs. Cryptographic hash functions thus take the randomness aspect very seriously. The ideal hash function would choose an output completely at random for each input, remembering that choice for future calls. This is called a random oracle. The problem is that a random oracle requires a true random number generator, and more problematically, a globally accessible infinite memory bank. So we approximate it using deterministic hash functions instead. These compute their output by essentially shuffling their input really, really well, in such a way that it is not feasible to reverse. To help quantify whether a specific function does a good job of approximating a random oracle, cryptographers came up with a variety of properties that a random oracle would have. The three most important and well-known properties a secure cryptographic hash function should satisfy are: Pre-image resistance. For some constant $c$ it should be hard to find some input $m$ such that $h(m) = c$. Second pre-image resistance. For some input $m_1$ it should be hard to find another input $m_2$ such that $h(m_1) = h(m_2)$. Collision resistance. It should be hard to find inputs $m_1, m_2$ such that $h(m_1) = h(m_2)$. We generally consider one of these properties broken if there exists a method that produces a collision or pre-image faster than simply trying random inputs (also known as a brute force attack). However, there are definitely gradations in breakage, as some methods are only several orders of magnitude faster than brute force. That may sound like a lot, but a method taking $2^{110}$ steps instead of $2^{128}$ are still both equally out of reach for today’s computers. MD5 used to be a common hash function, and SHA-1 is still in common use today. While both were considered cryptographically secure at one point, generating MD5 collisions now takes less than a second on a modern PC. In 2017 a collaboration of researchers from CWI and Google and announced the first SHA-1 collision. However, as far as I’m aware, neither MD5 nor SHA-1 have practical (second) pre-image attacks, only theoretical ones. Non-cryptographic hash functions Cryptographically secure hash functions tend to have a small problem: they’re slow. Modern hash functions such as BLAKE3 resolve this somewhat by heavily vectorizing the hash using SIMD instructions, as well as parallelizing over multiple threads, but even then they require large input sizes before reaching those speeds. A lot of problems don’t necessarily require secure hash functions, and people would much prefer a faster hash speed. Especially when we are computing many small hashes, such as in a hash table. Let’s take a look what common hash table implementations actually use as their hash for strings: C++: there are multiple standard library implementations, but 64-bit clang 13.0.0 on Apple M1 ships CityHash64. Currently libstdc++ ships MurmurHash64A, a variant of Murmur2 for 64-bit platforms. Java: OpenJDK uses an incredibly simple hash algorithm, which essentially just computes h = 31 * h + c for each character c. PHP: the Zend engine uses essentially the same algorithm as Java, just using unsigned integers and 33 as its multiplier. Nim: it used to use MurmurHash3_x86_32. While writing this article they appeared to have switched to use farmhash by default. Zig: it uses wyhash by default, with 0 as seed. Javascript: in V8 they use a custom weak string hash, with a randomly initialized seed. There were some that used stronger hashes by default as well: Go uses an AES-based hash if hardware acceleration is available on x86-64. Even though its construction is custom and likely not full-strength cryptographically secure, breaking it is too much effort and quite possibly beyond my capabilities. If not available, it uses an algorithm inspired by wyhash. Python and Rust use SipHash by default, which is a cryptographically secure pseudorandom function. This is effectively a hash function where you’re allowed to use a secret key during hashing, unlike a hash like SHA-2 where everyone knows all information involved. This latter concept is actually really important, at least for protecting against HashDoS in hash tables. Even if a hash function is perfectly secure over its complete output, hash tables further reduce the output to only a couple bits to find the data it is looking for. For a static hash function without any randomness it’s possible to produce large lists of hashes that collide post-reduction, just by brute force. But for non-cryptographic hashes as we’ll see here we often don’t need brute force and can generate collisions at high speed for the full output, if not randomized by a random seed. Interlude: inverse operations Before we get to breaking some of the above hash functions, I must explain a basic technique I will use a lot: the inverting of operations. We are first exposed to this in primary school, where we might get faced by a question such as “$2 + x = 10$”. There we learn subtraction is the inverse of addition, such that we may find $x$ by computing $10 - 2 = 8$. Most operations on the integer registers in computers are also invertible, despite the integers being reduced modulo $2^{w}$ in the case of overflow. Let us study some: Addition can be inverted using subtraction. That is, x += y can be inverted using x -= y. Seems obvious enough. Multiplication by a constant $c$ is not inverted by division. This would not work in the case of overflow. Instead, we calculate the modular multiplicative inverse of $c$. This is an integer $c^{-1}$ such that $c \\cdot c^{-1} \\equiv 1 \\pmod {m}$. Then we invert multiplication by $c$ simply by multiplying by $c^{-1}$. This constant exists if and only if $c$ is coprime with our modulus $m$, which for us means that $c$ must be odd as $m = 2^n$. For example, multiplication by $2$ is not invertible, which is easy to see as such, as it is equivalent to a bit shift to the left by one position, losing the most significant bit forever. Without delving into the details, here is a snippet of Python code that computes the modular multiplicative inverse of an integer using the extended Euclidean algorithm by calculating $x, y$ such that $$cx + my = \\gcd(c, m).$$ Then, because $c$ is coprime we find $\\gcd(c, m) = 1$, which means that $$cx + 0 \\equiv 1 \\pmod m,$$ and thus $x = c^{-1}$. def egcd(a, b): if a == 0: return (b, 0, 1) g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(c, m): g, x, y = egcd(c, m) assert g == 1, \"c, m must be coprime\" return x % m Using this we can invert modular multiplication: \u003e\u003e\u003e modinv(17, 2**32) 4042322161 \u003e\u003e\u003e 42 * 17 * 4042322161 % 2**32 42 Magic! XOR can be inverted using… XOR. It is its own inverse. So x ^= y can be inverted using x ^= y. Bit shifts can not be inverted, but two common operations in hash functions that use bit shifts can be. The first is bit rotation by a constant. This is best explained visually, for example a bit rotation to the left by 3 places on a 8-bit word, where each bit is shown as a letter: abcdefghi defghiabc The formula for a right-rotation of k places is (x \u003e\u003e k) | (x \u003c\u003c (w - k)), where w is the width of the integer type. Its inverse is a left-rotation, which simply swaps the direction of both shifts. Alternatively, the inverse of a right-rotation of k places is another right-rotation of w-k places. Another common operation in hash functions is the “xorshift”. It is an operation of one of the following forms, with $k \u003e 0$: x ^= x \u003c\u003c k // Left xorshift. x ^= x \u003e\u003e k // Right xorshift. How to invert it is entirely analogous between the two, so I will focus on the left xorshift. An important observation is that the least significant $k$ bits are left entirely untouched by the xorshift. Thus by repeating the operation, we recover the least significant $2k$ bits, as the XOR will invert itself for the next $k$ bits. Let’s take a look at the resulting value to see how we should proceed: v0 = (x \u003c\u003c k) ^ x // Apply first step of inverse v1 = v0 ^ (v0 \u003c\u003c k). v1 = (x \u003c\u003c 2*k) ^ (x \u003c\u003c k) ^ (x \u003c\u003c k) ^ x // Simplify using self-inverse (x \u003c\u003c k) ^ (x \u003c\u003c k) = 0. v1 = (x \u003c\u003c 2*k) ^ x From this we can conclude the following identity: $$\\operatorname{xorshift}(\\operatorname{xorshift}(x, k), k) = \\operatorname{xorshift}(x, 2k)$$ Now we only need one more observation to complete our algorithm: a xorshift of $k \\geq w$ where $w$ is the width of our integer is a no-op. Thus we repeatedly apply our doubling identity until we reach large enough $q$ such that $\\operatorname{xorshift}(x, 2^q \\cdot k) = x$. For example, to invert a left xorshift by 13 for 64-bit integers we apply the following sequence: x ^= x \u003c\u003c 13 // Left xorshift by 13. x ^= x \u003c\u003c 13 // Inverse step 1. x ^= x \u003c\u003c 26 // Inverse step 2. x ^= x \u003c\u003c 52 // Inverse step 3. // x ^= x \u003c\u003c 104 // Next step would be a no-op. Armed with this knowledge, we can now attack. Breaking CityHash64 Let us take a look at (part of) the source code of CityHash64 from libcxx that’s used for hashing strings on 64-bit platforms: static const uint64_t mul = 0x9ddfea08eb382d69ULL; static const uint64_t k0 = 0xc3a5c85c97cb3127ULL; static const uint64_t k1 = 0xb492b66fbe98f273ULL; static const uint64_t k2 = 0x9ae16a3b2f90404fULL; static const uint64_t k3 = 0xc949d7c7509e6557ULL; template\u003cclass T\u003e T loadword(const void* p) { T r; std::memcpy(\u0026r, p, sizeof(r)); return r; } uint64_t rotate(uint64_t val, int shift) { if (shift == 0) return val; return (val \u003e\u003e shift) | (val \u003c\u003c (64 - shift)); } uint64_t hash_len_16(uint64_t u, uint64_t v) { uint64_t x = u ^ v; x *= mul; x ^= x \u003e\u003e 47; uint64_t y = v ^ x; y *= mul; y ^= y \u003e\u003e 47; y *= mul; return y; } uint64_t hash_len_17_to_32(const char *s, uint64_t len) { const uint64_t a = loadword\u003cuint64_t\u003e(s) * k1; const uint64_t b = loadword\u003cuint64_t\u003e(s + 8); const uint64_t c = loadword\u003cuint64_t\u003e(s + len - 8) * k2; const uint64_t d = loadword\u003cuint64_t\u003e(s + len - 16) * k0; return hash_len_16( rotate(a - b, 43) + rotate(c, 30) + d, a + rotate(b ^ k3, 20) - c + len ); } To break this, let’s assume we’ll always give length 32 inputs. Then the implementation will always call hash_len_17_to_32, and we have full control over variables a, b, c and d by changing our input. Note that d is only used once, in the final expression. This makes it a prime target for attacking the hash. We will choose a, b and c arbitrarily, and then solve for d to compute a desired hash outcome. Using the above modinv function we first compute the necessary modular multiplicative inverses of mul and k0: \u003e\u003e\u003e 0x9ddfea08eb382d69 * 0xdc56e6f5090b32d9 % 2**64 1 \u003e\u003e\u003e 0xc3a5c85c97cb3127 * 0x81bc9c5aa9c72e97 % 2**64 1 We also note that in this case the xorshift is easy to invert, as x ^= x \u003e\u003e 47 is simply its own inverse. Having all the components ready, we can invert the function step by step. We first load a, b and c like in the hash function, and compute uint64_t v = a + rotate(b ^ k3, 20) - c + len; which is the second parameter to hash_len_16. Then, starting from our desired return value of hash_len_16(u, v) we work backwards step by step, inverting each operation to find the function argument u that would result in our target hash. Then once we have found such the unique u we compute our required input d. Putting it all together: static const uint64_t mul_inv = 0xdc56e6f5090b32d9ULL; static const uint64_t k0_inv = 0x81bc9c5aa9c72e97ULL; void cityhash64_preimage32(uint64_t hash, char *s) { const uint64_t len = 32; const uint64_t a = loadword\u003cuint64_t\u003e(s) * k1; const uint64_t b = loadword\u003cuint64_t\u003e(s + 8); const uint64_t c = loadword\u003cuint64_t\u003e(s + len - 8) * k2; uint64_t v = a + rotate(b ^ k3, 20) - c + len; // Invert hash_len_16(u, v). Original operation inverted // at each step is shown on the right, note that it is in // the inverse order of hash_len_16. uint64_t y = hash; // return y; y *= mul_inv; // y *= mul; y ^= y \u003e\u003e 47; // y ^= y \u003e\u003e 47; y *= mul_inv; // y *= mul; uint64_t x = y ^ v; // uint64_t y = v ^ x; x ^= x \u003e\u003e 47; // x ^= x \u003e\u003e 47; x *= mul_inv; // x *= mul; uint64_t u = x ^ v; // uint64_t x = u ^ v; // Find loadword\u003cuint64_t\u003e(s + len - 16). uint64_t d = u - rotate(a - b, 43) - rotate(c, 30); d *= k0_inv; std::memcpy(s + len - 16, \u0026d, sizeof(d)); } The chance that a random uint64_t forms 8 printable ASCII bytes is $\\left(94/256\\right)^8 \\approx 0.033%$. Not great, but cityhash64_preimage32 is so fast that having to repeat it on average ~3000 times to get a purely ASCII result isn’t so bad. For example, the following 10 strings all hash to 1337 using CityHash64, generated using this code: orlp-cityhash64-D-:K5yx*zkgaaaaa orlp-cityhash64-TXb7;1j\u0026btkaaaaa orlp-cityhash64-+/LM$0 ;msnaaaaa orlp-cityhash64-u'f\u0026\u003eI'~mtnaaaaa orlp-cityhash64-pEEv.LyGcnpaaaaa orlp-cityhash64-v~~bm@,Vahtaaaaa orlp-cityhash64-RxHr_\u0026~{miuaaaaa orlp-cityhash64-is_$34#\u003euavaaaaa orlp-cityhash64-$*~l\\{S!zoyaaaaa orlp-cityhash64-W@^5|3^:gtcbaaaa Breaking MurmurHash2 We can’t let libstdc++ get away after targetting libc++, can we? The default string hash calls an implementation of MurmurHash2 with seed 0xc70f6907. The hash—simplified to only handle strings whose lengths are multiples of 8—is as follows: uint64_t murmurhash64a(const char* s, size_t len, uint64_t seed) { const uint64_t mul = 0xc6a4a7935bd1e995ULL; uint64_t hash = seed ^ (len * mul); for (const char* p = s; p != s + len; p += 8) { uint64_t data = loadword\u003cuint64_t\u003e(p); data *= mul; data ^= data \u003e\u003e 47; data *= mul; hash ^= data; hash *= mul; } hash ^= hash \u003e\u003e 47; hash *= mul; hash ^= hash \u003e\u003e 47; return hash; } We can take a similar approach here as before. We note that the modular multiplicative inverse of 0xc6a4a7935bd1e995 mod $2^{64}$ is 0x5f7a0ea7e59b19bd. As an example, we can choose the first 24 bytes arbitrarily, and solve for the last 8 bytes: void murmurhash64a_preimage32(uint64_t hash, char* s, uint64_t seed) { const uint64_t mul = 0xc6a4a7935bd1e995ULL; const uint64_t mulinv = 0x5f7a0ea7e59b19bdULL; // Compute the hash state for the first 24 bytes as normal. uint64_t state = seed ^ (32 * mul); for (const char* p = s; p != s + 24; p += 8) { uint64_t data = loadword\u003cuint64_t\u003e(p); data *= mul; data ^= data \u003e\u003e 47; data *= mul; state ^= data; state *= mul; } // Invert target hash transformation. // return hash; hash ^= hash \u003e\u003e 47; // hash ^= hash \u003e\u003e 47; hash *= mulinv; // hash *= mul; hash ^= hash \u003e\u003e 47; // hash ^= hash \u003e\u003e 47; // Invert last iteration for last 8 bytes. hash *= mulinv; // hash *= mul; uint64_t data = state ^ hash; // hash = hash ^ data; data *= mulinv; // data *= mul; data ^= data \u003e\u003e 47; // data ^= data \u003e\u003e 47; data *= mulinv; // data *= mul; std::memcpy(s + 24, \u0026data, 8); // data = loadword\u003cuint64_t\u003e(s); } The following 10 strings all hash to 1337 using MurmurHash64A with the default seed 0xc70f6907, generated using this code: orlp-murmurhash64-bhbaaat;SXtgVa orlp-murmurhash64-bkiaaa\u0026JInaNcZ orlp-murmurhash64-ewmaaa(%J+jw\u003ej orlp-murmurhash64-vxpaaag\"93\\Yj5 orlp-murmurhash64-ehuaaafa`Wp`/| orlp-murmurhash64-yizaaa1x.zQF6r orlp-murmurhash64-lpzaaaZphp\u0026c F orlp-murmurhash64-wsjbaa771rz{z\u003c orlp-murmurhash64-rnkbaazy4X]p\u003eB orlp-murmurhash64-aqnbaaZ~OzP_Tp Universal collision attack on MurmurHash64A In fact, MurmurHash64A is so weak that Jean-Philippe Aumasson, Daniel J. Bernstein and Martin Boßlet published an attack that creates sets of strings which collide regardless of the random seed used. To see how it works, let’s take a look at the core loop of MurmurHash64A: uint64_t data = loadword\u003cuint64_t\u003e(p); data *= mul; // Trivially invertible. data ^= data \u003e\u003e 47; // Trivially invertible. data *= mul; // Trivially invertible. state ^= data; state *= mul; We know we can trivially invert the operations done on data regardless of what the current state is, so we might as well have had the following body: state ^= data; state *= mul; Now the hash starts looking rather weak indeed. The clever trick they employ is by creating two strings simultaneously, such that they differ precisely in the top bit in each 8-byte word. Why the top bit? \u003e\u003e\u003e 1 \u003c\u003c 63 9223372036854775808 \u003e\u003e\u003e (1 \u003c\u003c 63) * mul % 2**64 9223372036854775808 Since mul is odd, its least significant bit is set. Multiplying 1 \u003c\u003c 63 by it is equivalent to shifting that bit 63 places to the left, which is once again 1 \u003c\u003c 63. That is, 1 \u003c\u003c 63 is a fixed point for the state *= mul operation. We also note that for the top bit XOR is equivalent to addition, as the overflow from addition is removed mod $2^{64}$. So if we have two input strings, one starting with the 8 bytes data, and the other starting with data ^ (1 \u003c\u003c 63) == data + (1 \u003c\u003c 63) (after doing the trivial inversions). We then find that the two states, regardless of seed, differ exactly in the top bit after state ^= data. After multiplication we find we have two states x * mul and (x + (1 \u003c\u003c 63)) * mul == x * mul + (1 \u003c\u003c 63)… which again differ exactly in the top bit! We are now back to state ^= data in our iteration, for the next 8 bytes. We can now use this moment to cancel our top bit difference, by again feeding two 8-byte strings that differ in the top bit (after inverting). In fact, we only have to find one pair of such strings that differ in the top bit, which we can then repeat twice (in either order) to cancel our difference again. When represented as a uint64_t if we choose the first string as x we can derive the second string as x *= mul; // Forward transformation... x ^= x \u003e\u003e 47; // ... x *= mul; // ... x ^= 1 \u003c\u003c 63; // Difference in top bit. x *= mulinv; // Backwards transformation... x ^= x \u003e\u003e 47; // ... x *= mulinv; // ... I was unable to find a printable ASCII string that has another printable ASCII string as its partner. But I was able to find the following pair of 8-byte UTF-8 strings that differ in exactly the top bit after the Murmurhash64A input transformation: xx0rlpx! xxsXъВ Combining them as such gives two 16-byte strings that when fed through the hash algorithm manipulate the state in the same way: a collision. xx0rlpx!xxsXъВ xxsXъВxx0rlpx! But it doesn’t stop there. By concatenating these two strings we can create $2^n$ different colliding strings each $16n$ bytes long. With the current libstdc++ implementation the following prints the same number eight times: std::hash\u003cstd::u8string\u003e h; std::u8string a = u8\"xx0rlpx!xxsXъВ\"; std::u8string b = u8\"xxsXъВxx0rlpx!\"; std::cout \u003c\u003c h(a + a + a) \u003c\u003c \"\\n\"; std::cout \u003c\u003c h(a + a + b) \u003c\u003c \"\\n\"; std::cout \u003c\u003c h(a + b + a) \u003c\u003c \"\\n\"; std::cout \u003c\u003c h(a + b + b) \u003c\u003c \"\\n\"; std::cout \u003c\u003c h(b + a + a) \u003c\u003c \"\\n\"; std::cout \u003c\u003c h(b + a + b) \u003c\u003c \"\\n\"; std::cout \u003c\u003c h(b + b + a) \u003c\u003c \"\\n\"; std::cout \u003c\u003c h(b + b + b) \u003c\u003c \"\\n\"; Even if the libstdc++ would randomize the seed used by MurmurHash64a, the strings would still collide. Breaking MurmurHash3 Nim uses used to use MurmurHash3_x86_32, so let’s try to break that. If we once again simplify to strings whose lengths are a multiple of 4 we get the following code: uint32_t rotl32(uint32_t x, int r) { return (x \u003c\u003c r) | (x \u003e\u003e (32 - r)); } uint32_t murmurhash3_x86_32(const char* s, int len, uint32_t seed) { const uint32_t c1 = 0xcc9e2d51; const uint32_t c2 = 0x1b873593; const uint32_t c3 = 0x85ebca6b; const uint32_t c4 = 0xc2b2ae35; uint32_t h = seed; for (const char* p = s; p != s + len; p += 4) { uint32_t k = loadword\u003cuint32_t\u003e(p); k *= c1; k = rotl32(k, 15); k *= c2; h ^= k; h = rotl32(h, 13); h = h * 5 + 0xe6546b64; } h ^= len; h ^= h \u003e\u003e 16; h *= c3; h ^= h \u003e\u003e 13; h *= c4; h ^= h \u003e\u003e 16; return h; } I think by now you should be able to get this function to spit out any value you want if you know the seed. The inverse of rotl32(x, r) is rotl32(x, 32-r) and the inverse of h ^= h \u003e\u003e 16 is once again just h ^= h \u003e\u003e 16. Only h ^= h \u003e\u003e 13 is a bit different, it’s the first time we’ve seen that a xorshift’s inverse has more than one step: h ^= h \u003e\u003e 13 h ^= h \u003e\u003e 26 Compute the modular inverses of c1 through c4 as well as 5 mod $2^{32}$, and go to town. If you want to cheat or check your answer, you can check out the code I’ve used to generate the following ten strings that all hash to 1337 when fed to MurmurHash3_x86_32 with seed 0: orlp-murmurhash3_x86_32-haaaPa*+ orlp-murmurhash3_x86_32-saaaUW\u0026\u003c orlp-murmurhash3_x86_32-ubaa/!/\" orlp-murmurhash3_x86_32-weaare]] orlp-murmurhash3_x86_32-chaa5@/} orlp-murmurhash3_x86_32-claaM[,5 orlp-murmurhash3_x86_32-fraaIx`N orlp-murmurhash3_x86_32-iwaara\u0026\u003c orlp-murmurhash3_x86_32-zwaa]\u003ezd orlp-murmurhash3_x86_32-zbbaW-5G Nim uses 0 as a fixed seed. Universal collision attack on MurmurHash3 Suppose that Nim didn’t use 0 as a fixed seed, but chose a randomly generated one. Can we do a similar attack as the one done to MurmurHash2 to still generate universal multicollisions? Yes we can. Let’s take another look at that core loop body: uint32_t k = loadword\u003cuint32_t\u003e(p); k *= c1; // Trivially invertable. k = rotl32(k, 15); // Trivially invertable. k *= c2; // Trivially invertable. h ^= k; h = rotl32(h, 13); h = h * 5 + 0xe6546b64; Once again we can ignore the first three trivially invertable instructions as we can simply choose our input so that we get exactly the k we want. Remember from last time that we want to introduce a difference in exactly the top bit of h, as the multiplication will leave this difference in place. But here there is a bit rotation between the XOR and the multiplication. The solution? Simply place our bit difference such that rotl32(h, 13) shifts it into the top position. Does the addition of 0xe6546b64 mess things up? No. Since only the top bit between the two states will be different, there is a difference of exactly $2^{31}$ between the two states. This difference is maintained by the addition. Since two 32-bit numbers with the same top bit can be at most $2^{31} - 1$ apart, we can conclude that the two states still differ in the top bit after the addition. So we want to find two pairs of 32-bit ints, such that after applying the first three instructions the first pair differs in bit 1 \u003c\u003c (31 - 13) == 0x00040000 and the second pair in bit 1 \u003c\u003c 31 == 0x80000000. After some brute-force searching I found some cool pairs (again forced to use UTF-8), which when combined give the following collision: a = \"!\u0026orlpՓ\" b = \"yǏglp$X\" As before, any concatenation of as and bs of length n collides with all other combinations of length n. Breaking FarmHash64 Nim switched to farmhash since I started writing this post. To break it we can notice that its structure is very similar to CityHash64, so we can use those same techniques again. In fact, the only changes between the two for lengths 17-32 bytes is that a few operators were changed from subtraction/XOR to addition, a rotation operator had its constant tweaked, and some k constants are slightly tweaked in usage. The process of breaking it is so similar that it’s entirely analogous, so we can skip straight to the result. These 10 strings all hash to 1337 with FarmHash64: orlp-farmhash64-?VrJ@L7ytzwheaaa orlp-farmhash64-p3`!SQb}fmxheaaa orlp-farmhash64-pdt'cuI\\gvxheaaa orlp-farmhash64-IbY`xAG\u0026ibkieaaa orlp-farmhash64-[_LU!d1hwmkieaaa orlp-farmhash64-QiY!clz]bttieaaa orlp-farmhash64-\u0026?J3rZ_8gsuieaaa orlp-farmhash64-LOBWtm5Szyuieaaa orlp-farmhash64-Mptaa^g^ytvieaaa orlp-farmhash64-B?\u0026l::hxqmfjeaaa Trivial fixed-seed wyhash multicollisions Zig uses wyhash with a fixed seed of zero. While I was unable to do seed-independent attacks against wyhash, using it with a fixed seed makes generating collisions trivial. Wyhash is built upon the folded multiply, which takes two 64-bit inputs, multiplies them to a 128-bit product before XORing together the two halves: uint64_t folded_multiply(uint64_t a, uint64_t b) { __uint128_t full = __uint128_t(a) * __uint128_t(b); return uint64_t(full) ^ uint64_t(full \u003e\u003e 64); } It’s easy to immediately see a critical flaw with this: if one of the two sides is zero, the output will also always be zero. To protect against this, wyhash always uses a folded multiply in the following form: out = folded_multiply(input_a ^ secret_a, input_b ^ secret_b); where secret_a and secret_b are determined by the seed, or outputs of previous iterations which are influenced by the seed. However, when your seed is constant… With a bit of creativity we can use the start of our string to prepare a ‘secret’ value which we can perfectly cancel with another ASCII string later in the input. So, without further ado, every 32-byte string of the form orlp-wyhash-oGf_________tWJbzMJR hashes to the same value with Zig’s default hasher. Zig uses a different set of parameters than the defaults found in the wyhash repository, so for good measure, this pattern provides arbitrary multicollisions for the default parameters found in wyhash when using seed == 0: orlp-wyhash-EUv_________NLXyytkp Conclusion We’ve seen that a lot of the hash functions in common use in hash tables today are very weak, allowing fairly trivial attacks to produce arbitrary amounts of collisions if not randomly initialized. Using a randomly seeded hash table is paramount if you don’t wish to become a victim of a hash flooding attack. We’ve also seen that some hash functions are vulnerable to attack even if randomly seeded. These are completely broken and should not be used if attacks are a concern at all. Luckily I was unable to find such attacks against most hashes, but the possibility of such an attack existing is quite unnerving. With universal hashing it’s possible to construct hash functions for which such an attack is provably impossible, last year I published a hash function called polymur-hash that has this property. Your HTTPS connection to this website also likely uses a universal hash function for authenticity of the transferred data, both Poly1305 and GCM are based on universal hashing for their security proofs. Of course, if your data is not user-controlled, or there is no reasonable security model where your application would face attacks, you can get away with faster and insecure hashes. More to come on the subject of hashing and hash tables and how it can go right or wrong, but for now this article is long enough as-is…",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\n\n\u003ctime datetime=\"2024-11-02\"\u003e2024-11-02\u003c/time\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Hash_function\"\u003eHash functions\u003c/a\u003e are incredibly\nneat mathematical objects. They can map arbitrary data to a small fixed-size\noutput domain such that the mapping is deterministic, yet appears to be random.\nThis “deterministic randomness” is incredibly useful for a variety of purposes,\nsuch as \u003ca href=\"https://en.wikipedia.org/wiki/Hash_function\"\u003ehash tables\u003c/a\u003e,\n\u003ca href=\"https://en.wikipedia.org/wiki/Checksum\"\u003echecksums\u003c/a\u003e, \u003ca href=\"https://en.wikipedia.org/wiki/Monte_Carlo_algorithm\"\u003emonte carlo\nalgorithms\u003c/a\u003e,\ncommunication-less \u003ca href=\"https://en.wikipedia.org/wiki/Distributed_algorithm\"\u003edistributed\nalgorithms\u003c/a\u003e, etc, the list\ngoes on.\u003c/p\u003e\n\u003cp\u003eIn this article we will take a look at the dark side of hash functions: when\nthings go wrong. Luckily this essentially never happens due to unlucky inputs in\nthe wild (for good hash functions, at least). However, people exist, and some of\nthem may be malicious. Thus we must look towards computer security for answers.\nI will quickly explain some of the basics of hash function security and then\nshow how easy it is to break this security for some commonly used\nnon-cryptographic hash functions.\u003c/p\u003e\n\u003cp\u003eAs a teaser, this article explains how you can generate strings\nsuch as these, thousands per second:\u003c/p\u003e\n\u003cpre data-lang=\"python\"\u003e\u003ccode data-lang=\"python\"\u003e\u003cspan\u003e cityhash64(\u003c/span\u003e\u003cspan\u003e\u0026#34;orlp-cityhash64-D-:K5yx*zkgaaaaa\u0026#34;\u003c/span\u003e\u003cspan\u003e) == \u003c/span\u003e\u003cspan\u003e1337\n\u003c/span\u003e\u003cspan\u003emurmurhash2(\u003c/span\u003e\u003cspan\u003e\u0026#34;orlp-murmurhash64-bkiaaa\u0026amp;JInaNcZ\u0026#34;\u003c/span\u003e\u003cspan\u003e) == \u003c/span\u003e\u003cspan\u003e1337\n\u003c/span\u003e\u003cspan\u003emurmurhash3(\u003c/span\u003e\u003cspan\u003e\u0026#34;orlp-murmurhash3_x86_32-haaaPa*+\u0026#34;\u003c/span\u003e\u003cspan\u003e) == \u003c/span\u003e\u003cspan\u003e1337\n\u003c/span\u003e\u003cspan\u003e farmhash64(\u003c/span\u003e\u003cspan\u003e\u0026#34;orlp-farmhash64-/v^CqdPvziuheaaa\u0026#34;\u003c/span\u003e\u003cspan\u003e) == \u003c/span\u003e\u003cspan\u003e1337\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI also show how you can create some really funky pairs of strings that can be\nconcatenated arbitrarily such that when concatenating $k$ strings together\nany of the $2^k$ combinations all have the same hash output, regardless of the\nseed used for the hash function:\u003c/p\u003e\n\u003cpre data-lang=\"python\"\u003e\u003ccode data-lang=\"python\"\u003e\u003cspan\u003ea = \u003c/span\u003e\u003cspan\u003e\u0026#34;xx0rlpx!xxsXъВ\u0026#34;\n\u003c/span\u003e\u003cspan\u003eb = \u003c/span\u003e\u003cspan\u003e\u0026#34;xxsXъВxx0rlpx!\u0026#34;\n\u003c/span\u003e\u003cspan\u003emurmurhash2(a + a, seed) == murmurhash2(a + b, seed)\n\u003c/span\u003e\u003cspan\u003emurmurhash2(a + a, seed) == murmurhash2(b + a, seed)\n\u003c/span\u003e\u003cspan\u003emurmurhash2(a + a, seed) == murmurhash2(b + b, seed)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003ea = \u003c/span\u003e\u003cspan\u003e\u0026#34;!\u0026amp;orlpՓ\u0026#34;\n\u003c/span\u003e\u003cspan\u003eb = \u003c/span\u003e\u003cspan\u003e\u0026#34;yǏglp$X\u0026#34;\n\u003c/span\u003e\u003cspan\u003emurmurhash3(a + a, seed) == murmurhash3(a + b, seed)\n\u003c/span\u003e\u003cspan\u003emurmurhash3(a + a, seed) == murmurhash3(b + a, seed)\n\u003c/span\u003e\u003cspan\u003emurmurhash3(a + a, seed) == murmurhash3(b + b, seed)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"hash-function-security-basics\"\u003e\u003ca href=\"#hash-function-security-basics\" aria-label=\"Anchor link for: hash-function-security-basics\"\u003eHash function security basics\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eHash functions play a critical role in computer security. Hash\nfunctions are used not only to verify messages over secure channels, they are\nalso used to identify trusted updates as well as known viruses. Virtually every\nsignature scheme ever used starts with a hash function.\u003c/p\u003e\n\u003cp\u003eIf a hash function does not behave randomly, we can break the above security\nconstructs. \u003ca href=\"https://en.wikipedia.org/wiki/Cryptographic_hash_function\"\u003eCryptographic hash\nfunctions\u003c/a\u003e thus take\nthe randomness aspect very seriously. The ideal hash function would choose an\noutput completely at random for each input, remembering that choice for future\ncalls. This is called a \u003ca href=\"https://en.wikipedia.org/wiki/Random_oracle\"\u003erandom\noracle\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe problem is that a random oracle requires a true random number generator, and\nmore problematically, a globally accessible infinite memory bank. So we\napproximate it using deterministic hash functions instead. These compute their\noutput by essentially shuffling their input really, really well, in such a way\nthat it is not feasible to reverse.\u003c/p\u003e\n\u003cp\u003eTo help quantify whether a specific function does a good job of approximating a\nrandom oracle, cryptographers came up with a variety of properties that a random\noracle would have. The three most important and well-known properties a secure\ncryptographic hash function should satisfy are:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePre-image resistance.\u003c/strong\u003e For some constant $c$ it should be hard to find\nsome input $m$ such that $h(m) = c$.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eSecond pre-image resistance.\u003c/strong\u003e For some input $m_1$ it should be hard to\nfind another input $m_2$ such that $h(m_1) = h(m_2)$.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCollision resistance.\u003c/strong\u003e It should be hard to find inputs $m_1, m_2$ such\nthat $h(m_1) = h(m_2)$.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eWe generally consider one of these properties \u003cem\u003ebroken\u003c/em\u003e if there exists a method\nthat produces a collision or pre-image faster than simply trying random\ninputs (also known as a \u003cem\u003ebrute force attack\u003c/em\u003e). However, there are definitely\ngradations in breakage, as some methods are only several orders of magnitude\nfaster than brute force. That may sound like a lot, but a method taking\n$2^{110}$ steps instead of $2^{128}$ are still both equally out of reach for\ntoday’s computers.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/MD5\"\u003eMD5\u003c/a\u003e used to be a common hash function, and\n\u003ca href=\"https://en.wikipedia.org/wiki/SHA-1\"\u003eSHA-1\u003c/a\u003e is still in common use today. While\nboth were considered cryptographically secure at one point, generating MD5\ncollisions now takes less than a second on a modern PC. In 2017 a collaboration\nof researchers from CWI and Google and announced \u003ca href=\"https://shattered.io/\"\u003ethe first SHA-1\ncollision\u003c/a\u003e. However, as far as I’m aware, neither MD5 nor\nSHA-1 have practical (second) pre-image attacks, only theoretical ones.\u003c/p\u003e\n\u003ch2 id=\"non-cryptographic-hash-functions\"\u003e\u003ca href=\"#non-cryptographic-hash-functions\" aria-label=\"Anchor link for: non-cryptographic-hash-functions\"\u003eNon-cryptographic hash functions\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCryptographically secure hash functions tend to have a small problem: they’re\nslow. Modern hash functions such as \u003ca href=\"https://github.com/BLAKE3-team/BLAKE3\"\u003eBLAKE3\u003c/a\u003e\nresolve this somewhat by heavily vectorizing the hash using\nSIMD instructions, as well as parallelizing over multiple threads, but even then\nthey require large input sizes before reaching those speeds.\u003c/p\u003e\n\n\u003cp\u003eA lot of problems don’t necessarily require secure hash functions, and people\nwould much prefer a faster hash speed. Especially when we are computing many\nsmall hashes, such as in a \u003ca href=\"https://en.wikipedia.org/wiki/Hash_table\"\u003ehash table\u003c/a\u003e.\nLet’s take a look what common hash table implementations actually use as their\nhash for strings:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eC++: there are multiple standard library implementations, but 64-bit\n\u003ccode\u003eclang\u003c/code\u003e 13.0.0 on Apple M1 \u003ca href=\"https://github.com/llvm-mirror/libcxx/blob/78d6a7767ed57b50122a161b91f59f19c9bd0d19/include/utility#L977\"\u003eships\u003c/a\u003e \u003ca href=\"https://github.com/google/cityhash\"\u003e\u003ccode\u003eCityHash64\u003c/code\u003e\u003c/a\u003e.\nCurrently \u003ccode\u003elibstdc++\u003c/code\u003e \u003ca href=\"https://github.com/gcc-mirror/gcc/blob/20d790aa3ea5b0d240032cab997b8e0938cac62c/libstdc%2B%2B-v3/libsupc%2B%2B/hash_bytes.cc#L136\"\u003eships\u003c/a\u003e\n\u003ca href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash2.cpp\"\u003e\u003ccode\u003eMurmurHash64A\u003c/code\u003e\u003c/a\u003e,\na variant of Murmur2 for 64-bit platforms.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eJava: OpenJDK uses an \u003ca href=\"https://github.com/openjdk/zgc/blob/ccf2f5837b31cddd24ec81f7f67107d9fc03c294/src/java.base/share/classes/jdk/internal/util/ArraysSupport.java#L212\"\u003eincredibly simple hash algorithm\u003c/a\u003e, which essentially just computes\n\u003ccode\u003eh = 31 * h + c\u003c/code\u003e for each character \u003ccode\u003ec\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePHP: the Zend engine uses \u003ca href=\"https://github.com/php/php-src/blob/master/Zend/zend_string.h#L431\"\u003eessentially the same algorithm\u003c/a\u003e\nas Java, just using unsigned integers and \u003ccode\u003e33\u003c/code\u003e as its multiplier.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNim: it \u003ca href=\"https://github.com/nim-lang/Nim/blob/46d2161c23c2aa1905571512b9a1ef7d61ae670e/lib/pure/hashes.nim#L386\"\u003eused to use\u003c/a\u003e \u003ca href=\"https://github.com/PeterScott/murmur3/blob/master/murmur3.c\"\u003e\u003ccode\u003eMurmurHash3_x86_32\u003c/code\u003e\u003c/a\u003e. While writing this article they appeared to \u003ca href=\"https://github.com/nim-lang/Nim/blob/46bb47a444bd377860d832fc1c62b262343f36a2/lib/pure/hashes.nim#L537\"\u003ehave switched\u003c/a\u003e to use\n\u003ca href=\"https://github.com/google/farmhash\"\u003efarmhash\u003c/a\u003e by default.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eZig: it \u003ca href=\"https://github.com/ziglang/zig/blob/904f414e7eab7bc0f7ea00f616831bfc3c1f18a4/lib/std/hash_map.zig#L31\"\u003euses\u003c/a\u003e\n\u003ca href=\"https://github.com/wangyi-fudan/wyhash/blob/master/wyhash.h\"\u003e\u003ccode\u003ewyhash\u003c/code\u003e\u003c/a\u003e by default, with \u003ccode\u003e0\u003c/code\u003e as seed.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eJavascript: in V8 they use \u003ca href=\"https://github.com/v8/v8/blob/b3776d5dea2f7858e9903a014b63ea86ef30c04f/src/strings/string-hasher-inl.h#L114\"\u003ea custom\u003c/a\u003e\nweak string hash, with a randomly initialized seed.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere were some that used stronger hashes by default as well:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGo \u003ca href=\"https://github.com/golang/go/blob/d12fe60004ae5e4024c8a93f4f7de7183bb61576/src/runtime/asm_amd64.s#L1117\"\u003euses\u003c/a\u003e an\n\u003ca href=\"https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\"\u003eAES\u003c/a\u003e-based hash\nif hardware acceleration is available on x86-64. Even though its construction is custom\nand likely not full-strength cryptographically secure, breaking it is too\nmuch effort and quite possibly beyond my capabilities.\u003c/p\u003e\n\u003cp\u003eIf not available, it uses an algorithm \u003ca href=\"https://github.com/golang/go/blob/d12fe60004ae5e4024c8a93f4f7de7183bb61576/src/runtime/hash64.go#L25\"\u003einspired by wyhash\u003c/a\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePython and Rust use \u003ca href=\"https://en.wikipedia.org/wiki/SipHash\"\u003eSipHash\u003c/a\u003e by\ndefault, which is a cryptographically secure \u003ca href=\"https://en.wikipedia.org/wiki/Pseudorandom_function_family\"\u003epseudorandom function\u003c/a\u003e.\nThis is effectively a hash function where you’re allowed to use a secret key \nduring hashing, unlike a hash like SHA-2 where everyone knows all information\ninvolved.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis latter concept is actually really important, at least for protecting\nagainst \u003ca href=\"https://en.wikipedia.org/wiki/Collision_attack\"\u003eHashDoS\u003c/a\u003e in hash\ntables. Even if a hash function is perfectly secure over its complete output,\nhash tables further reduce the output to only a couple bits to find the data it\nis looking for. For a static hash function without any randomness it’s possible\nto produce large lists of hashes that collide post-reduction, just by brute\nforce. But for non-cryptographic hashes as we’ll see here we often don’t need\nbrute force and can generate collisions at high speed for the full output, if\nnot randomized by a random seed.\u003c/p\u003e\n\u003ch2 id=\"interlude-inverse-operations\"\u003e\u003ca href=\"#interlude-inverse-operations\" aria-label=\"Anchor link for: interlude-inverse-operations\"\u003eInterlude: inverse operations\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eBefore we get to breaking some of the above hash functions, I must explain a basic\ntechnique I will use a lot: the inverting of operations. We are first exposed to\nthis in primary school, where we might get faced by a question such as “$2 + x = 10$”.\nThere we learn \u003cem\u003esubtraction\u003c/em\u003e is the \u003cem\u003einverse\u003c/em\u003e of addition, such that we may find\n$x$ by computing $10 - 2 = 8$.\u003c/p\u003e\n\u003cp\u003eMost operations on the integer registers in computers are also invertible, despite\nthe integers being reduced modulo $2^{w}$ in the case of overflow. Let\nus study some:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAddition can be inverted using subtraction. That is, \u003ccode\u003ex += y\u003c/code\u003e can be inverted\nusing \u003ccode\u003ex -= y\u003c/code\u003e. Seems obvious enough.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMultiplication by a constant $c$ is \u003cem\u003enot\u003c/em\u003e inverted by division. This would\nnot work in the case of overflow. Instead, we calculate the \u003ca href=\"https://en.wikipedia.org/wiki/Modular_multiplicative_inverse\"\u003emodular\nmultiplicative\ninverse\u003c/a\u003e of\n$c$. This is an integer $c^{-1}$ such that $c \\cdot c^{-1} \\equiv 1 \\pmod\n{m}$. Then we invert multiplication by $c$ simply by multiplying by $c^{-1}$.\u003c/p\u003e\n\u003cp\u003eThis constant exists if and only if $c$ is \u003ca href=\"https://en.wikipedia.org/wiki/Coprime_integers\"\u003ecoprime\u003c/a\u003e with our modulus $m$, which for\nus means that $c$ must be odd as $m = 2^n$. For example, multiplication by $2$ is not\ninvertible, which is easy to see as such, as it is equivalent to a bit shift\nto the left by one position, losing the most significant bit forever.\u003c/p\u003e\n\u003cp\u003eWithout delving into the details, here is a snippet of Python code that computes\nthe modular multiplicative inverse of an integer using the\n\u003ca href=\"https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\"\u003eextended Euclidean algorithm\u003c/a\u003e\nby calculating $x, y$ such that\n$$cx + my = \\gcd(c, m).$$\nThen, because $c$ is coprime we find $\\gcd(c, m) = 1$, which means that\n$$cx + 0 \\equiv 1 \\pmod m,$$\nand thus $x = c^{-1}$.\u003c/p\u003e\n\u003cpre data-lang=\"python\"\u003e\u003ccode data-lang=\"python\"\u003e\u003cspan\u003edef \u003c/span\u003e\u003cspan\u003eegcd(a, b):\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eif \u003c/span\u003e\u003cspan\u003ea == \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003ereturn \u003c/span\u003e\u003cspan\u003e(b, \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e    g, y, x = egcd(b % a, a)\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn \u003c/span\u003e\u003cspan\u003e(g, x - (b // a) * y, y)\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003edef \u003c/span\u003e\u003cspan\u003emodinv(c, m):\n\u003c/span\u003e\u003cspan\u003e    g, x, y = egcd(c, m)\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eassert \u003c/span\u003e\u003cspan\u003eg == \u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e\u0026#34;c, m must be coprime\u0026#34;\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn \u003c/span\u003e\u003cspan\u003ex % m\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing this we can invert modular multiplication:\u003c/p\u003e\n\u003cpre data-lang=\"python\"\u003e\u003ccode data-lang=\"python\"\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt; modinv(\u003c/span\u003e\u003cspan\u003e17\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e4042322161\n\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e42 \u003c/span\u003e\u003cspan\u003e* \u003c/span\u003e\u003cspan\u003e17 \u003c/span\u003e\u003cspan\u003e* \u003c/span\u003e\u003cspan\u003e4042322161 \u003c/span\u003e\u003cspan\u003e% \u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003e32\n\u003c/span\u003e\u003cspan\u003e42\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMagic!\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eXOR can be inverted using… XOR. It is its own inverse. So \u003ccode\u003ex ^= y\u003c/code\u003e can be\ninverted using \u003ccode\u003ex ^= y\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBit shifts can not be inverted, but two common operations in hash functions\nthat use bit shifts can be. The first is bit \u003cem\u003erotation\u003c/em\u003e by a constant. This\nis best explained visually, for example a bit rotation to the left by 3\nplaces on a 8-bit word, where each bit is shown as a letter:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eabcdefghi\n\u003c/span\u003e\u003cspan\u003edefghiabc\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe formula for a right-rotation of \u003ccode\u003ek\u003c/code\u003e places is \u003ccode\u003e(x \u0026gt;\u0026gt; k) | (x \u0026lt;\u0026lt; (w - k))\u003c/code\u003e, where \u003ccode\u003ew\u003c/code\u003e is the width of the integer type. Its inverse is a\nleft-rotation, which simply swaps the direction of both shifts.\nAlternatively, the inverse of a right-rotation of \u003ccode\u003ek\u003c/code\u003e places is another\nright-rotation of \u003ccode\u003ew-k\u003c/code\u003e places.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAnother common operation in hash functions is the “xorshift”. It is an operation\nof one of the following forms, with $k \u0026gt; 0$:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003ex ^= x \u0026lt;\u0026lt; k  \u003c/span\u003e\u003cspan\u003e// Left xorshift.\n\u003c/span\u003e\u003cspan\u003ex ^= x \u0026gt;\u0026gt; k  \u003c/span\u003e\u003cspan\u003e// Right xorshift.\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHow to invert it is entirely analogous between the two, so I will focus on the\nleft xorshift.\u003c/p\u003e\n\u003cp\u003eAn important observation is that the least\nsignificant $k$ bits are left entirely untouched by the xorshift.\nThus by repeating the operation, we recover the least significant $2k$ bits,\nas the XOR will invert itself for the next $k$ bits.\nLet’s take a look at the resulting value to see how we should proceed:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003ev0 = (x \u0026lt;\u0026lt; k) ^ x\n\u003c/span\u003e\u003cspan\u003e// Apply first step of inverse v1 = v0 ^ (v0 \u0026lt;\u0026lt; k).\n\u003c/span\u003e\u003cspan\u003ev1 = (x \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e*k) ^ (x \u0026lt;\u0026lt; k) ^ (x \u0026lt;\u0026lt; k) ^ x\n\u003c/span\u003e\u003cspan\u003e// Simplify using self-inverse (x \u0026lt;\u0026lt; k) ^ (x \u0026lt;\u0026lt; k) = 0.\n\u003c/span\u003e\u003cspan\u003ev1 = (x \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e*k) ^ x\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFrom this we can conclude the following identity:\n$$\\operatorname{xorshift}(\\operatorname{xorshift}(x, k), k) = \\operatorname{xorshift}(x, 2k)$$\nNow we only need one more observation to complete our algorithm: a xorshift of $k \\geq w$ where $w$ is the width of our integer is\na no-op. Thus we repeatedly apply our doubling identity until we reach\nlarge enough $q$ such that $\\operatorname{xorshift}(x, 2^q \\cdot k) = x$.\u003c/p\u003e\n\u003cp\u003eFor example, to invert a left xorshift by 13 for 64-bit integers we apply the following sequence:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003ex ^= x \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e13  \u003c/span\u003e\u003cspan\u003e// Left xorshift by 13.\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003ex ^= x \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e13  \u003c/span\u003e\u003cspan\u003e// Inverse step 1.\n\u003c/span\u003e\u003cspan\u003ex ^= x \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e26  \u003c/span\u003e\u003cspan\u003e// Inverse step 2.\n\u003c/span\u003e\u003cspan\u003ex ^= x \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e52  \u003c/span\u003e\u003cspan\u003e// Inverse step 3.\n\u003c/span\u003e\u003cspan\u003e// x ^= x \u0026lt;\u0026lt; 104  // Next step would be a no-op.\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eArmed with this knowledge, we can now attack.\u003c/p\u003e\n\u003ch2 id=\"breaking-cityhash64\"\u003e\u003ca href=\"#breaking-cityhash64\" aria-label=\"Anchor link for: breaking-cityhash64\"\u003eBreaking \u003ccode\u003eCityHash64\u003c/code\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLet us take a look at (part of) \u003ca href=\"https://github.com/llvm-mirror/libcxx/blob/78d6a7767ed57b50122a161b91f59f19c9bd0d19/include/utility#L977\"\u003ethe source code\u003c/a\u003e of\n\u003ccode\u003eCityHash64\u003c/code\u003e from \u003ccode\u003elibcxx\u003c/code\u003e that’s used for hashing strings on 64-bit platforms:\u003c/p\u003e\n\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003estatic const uint64_t mul = \u003c/span\u003e\u003cspan\u003e0x9ddfea08eb382d69\u003c/span\u003e\u003cspan\u003eULL\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estatic const uint64_t k0 = \u003c/span\u003e\u003cspan\u003e0xc3a5c85c97cb3127\u003c/span\u003e\u003cspan\u003eULL\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estatic const uint64_t k1 = \u003c/span\u003e\u003cspan\u003e0xb492b66fbe98f273\u003c/span\u003e\u003cspan\u003eULL\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estatic const uint64_t k2 = \u003c/span\u003e\u003cspan\u003e0x9ae16a3b2f90404f\u003c/span\u003e\u003cspan\u003eULL\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estatic const uint64_t k3 = \u003c/span\u003e\u003cspan\u003e0xc949d7c7509e6557\u003c/span\u003e\u003cspan\u003eULL\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e T\u0026gt;\n\u003c/span\u003e\u003cspan\u003eT loadword(const \u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e* p) {\n\u003c/span\u003e\u003cspan\u003e    T r;\n\u003c/span\u003e\u003cspan\u003e    std::memcpy(\u0026amp;r, p, sizeof(r));\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e r;\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003euint64_t rotate(uint64_t val, \u003c/span\u003e\u003cspan\u003eint \u003c/span\u003e\u003cspan\u003eshift) {\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eif \u003c/span\u003e\u003cspan\u003e(shift == \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e val;\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn \u003c/span\u003e\u003cspan\u003e(val \u0026gt;\u0026gt; shift) | (val \u0026lt;\u0026lt; (\u003c/span\u003e\u003cspan\u003e64 \u003c/span\u003e\u003cspan\u003e- shift));\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003euint64_t hash_len_16(uint64_t u, uint64_t v) {\n\u003c/span\u003e\u003cspan\u003e    uint64_t x = u ^ v;\n\u003c/span\u003e\u003cspan\u003e    x *= mul;\n\u003c/span\u003e\u003cspan\u003e    x ^= x \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    uint64_t y = v ^ x;\n\u003c/span\u003e\u003cspan\u003e    y *= mul;\n\u003c/span\u003e\u003cspan\u003e    y ^= y \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    y *= mul;\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e y;\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003euint64_t hash_len_17_to_32(const \u003c/span\u003e\u003cspan\u003echar \u003c/span\u003e\u003cspan\u003e*s, uint64_t len) {\n\u003c/span\u003e\u003cspan\u003e    const uint64_t a = loadword\u0026lt;uint64_t\u0026gt;(s) * k1;\n\u003c/span\u003e\u003cspan\u003e    const uint64_t b = loadword\u0026lt;uint64_t\u0026gt;(s + \u003c/span\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003cspan\u003e    const uint64_t c = loadword\u0026lt;uint64_t\u0026gt;(s + len - \u003c/span\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e) * k2;\n\u003c/span\u003e\u003cspan\u003e    const uint64_t d = loadword\u0026lt;uint64_t\u0026gt;(s + len - \u003c/span\u003e\u003cspan\u003e16\u003c/span\u003e\u003cspan\u003e) * k0;\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn \u003c/span\u003e\u003cspan\u003ehash_len_16(\n\u003c/span\u003e\u003cspan\u003e        rotate(a - b, \u003c/span\u003e\u003cspan\u003e43\u003c/span\u003e\u003cspan\u003e) + rotate(c, \u003c/span\u003e\u003cspan\u003e30\u003c/span\u003e\u003cspan\u003e) + d,\n\u003c/span\u003e\u003cspan\u003e        a + rotate(b ^ k3, \u003c/span\u003e\u003cspan\u003e20\u003c/span\u003e\u003cspan\u003e) - c + len\n\u003c/span\u003e\u003cspan\u003e    );\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo break this, let’s assume we’ll always give length 32 inputs. Then the\nimplementation will always call \u003ccode\u003ehash_len_17_to_32\u003c/code\u003e, and we have full control\nover variables \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e, \u003ccode\u003ec\u003c/code\u003e and \u003ccode\u003ed\u003c/code\u003e by changing our input.\u003c/p\u003e\n\u003cp\u003eNote that \u003ccode\u003ed\u003c/code\u003e is only used once, in the final expression. This makes it a\nprime target for attacking the hash. We will choose \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e and \u003ccode\u003ec\u003c/code\u003e arbitrarily,\nand then solve for \u003ccode\u003ed\u003c/code\u003e to compute a desired hash outcome.\u003c/p\u003e\n\u003cp\u003eUsing the above \u003ccode\u003emodinv\u003c/code\u003e function we first compute the necessary modular multiplicative\ninverses of \u003ccode\u003emul\u003c/code\u003e and \u003ccode\u003ek0\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-lang=\"python\"\u003e\u003ccode data-lang=\"python\"\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e0x9ddfea08eb382d69 \u003c/span\u003e\u003cspan\u003e* \u003c/span\u003e\u003cspan\u003e0xdc56e6f5090b32d9 \u003c/span\u003e\u003cspan\u003e% \u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003e64\n\u003c/span\u003e\u003cspan\u003e1\n\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e0xc3a5c85c97cb3127 \u003c/span\u003e\u003cspan\u003e* \u003c/span\u003e\u003cspan\u003e0x81bc9c5aa9c72e97 \u003c/span\u003e\u003cspan\u003e% \u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003e64\n\u003c/span\u003e\u003cspan\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe also note that in this case the xorshift is easy to invert, as \u003ccode\u003ex ^= x \u0026gt;\u0026gt; 47\u003c/code\u003e\nis simply its own inverse. Having all the components ready, we can invert\nthe function step by step.\u003c/p\u003e\n\u003cp\u003eWe first load \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e and \u003ccode\u003ec\u003c/code\u003e like in the hash function, and compute\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003euint64_t v = a + rotate(b ^ k3, \u003c/span\u003e\u003cspan\u003e20\u003c/span\u003e\u003cspan\u003e) - c + len;\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich is the second parameter to \u003ccode\u003ehash_len_16\u003c/code\u003e. Then, starting from our\ndesired return value of \u003ccode\u003ehash_len_16(u, v)\u003c/code\u003e we work backwards step by step, inverting\neach operation to find the function argument \u003ccode\u003eu\u003c/code\u003e that would result in our target \u003ccode\u003ehash\u003c/code\u003e.\nThen once we have found such the unique \u003ccode\u003eu\u003c/code\u003e we compute our required input \u003ccode\u003ed\u003c/code\u003e.\nPutting it all together:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003estatic const uint64_t mul_inv = \u003c/span\u003e\u003cspan\u003e0xdc56e6f5090b32d9\u003c/span\u003e\u003cspan\u003eULL\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estatic const uint64_t k0_inv  = \u003c/span\u003e\u003cspan\u003e0x81bc9c5aa9c72e97\u003c/span\u003e\u003cspan\u003eULL\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003evoid \u003c/span\u003e\u003cspan\u003ecityhash64_preimage32(uint64_t hash, \u003c/span\u003e\u003cspan\u003echar \u003c/span\u003e\u003cspan\u003e*s) {\n\u003c/span\u003e\u003cspan\u003e    const uint64_t len = \u003c/span\u003e\u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    const uint64_t a = loadword\u0026lt;uint64_t\u0026gt;(s) * k1;\n\u003c/span\u003e\u003cspan\u003e    const uint64_t b = loadword\u0026lt;uint64_t\u0026gt;(s + \u003c/span\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003cspan\u003e    const uint64_t c = loadword\u0026lt;uint64_t\u0026gt;(s + len - \u003c/span\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e) * k2;\n\u003c/span\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003cspan\u003e    uint64_t v = a + rotate(b ^ k3, \u003c/span\u003e\u003cspan\u003e20\u003c/span\u003e\u003cspan\u003e) - c + len;\n\u003c/span\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Invert hash_len_16(u, v). Original operation inverted\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// at each step is shown on the right, note that it is in\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// the inverse order of hash_len_16.\n\u003c/span\u003e\u003cspan\u003e    uint64_t y = hash;    \u003c/span\u003e\u003cspan\u003e// return y;\n\u003c/span\u003e\u003cspan\u003e    y *= mul_inv;         \u003c/span\u003e\u003cspan\u003e// y *= mul;\n\u003c/span\u003e\u003cspan\u003e    y ^= y \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;         \u003c/span\u003e\u003cspan\u003e// y ^= y \u0026gt;\u0026gt; 47;\n\u003c/span\u003e\u003cspan\u003e    y *= mul_inv;         \u003c/span\u003e\u003cspan\u003e// y *= mul;\n\u003c/span\u003e\u003cspan\u003e    uint64_t x = y ^ v;   \u003c/span\u003e\u003cspan\u003e// uint64_t y = v ^ x;\n\u003c/span\u003e\u003cspan\u003e    x ^= x \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;         \u003c/span\u003e\u003cspan\u003e// x ^= x \u0026gt;\u0026gt; 47;\n\u003c/span\u003e\u003cspan\u003e    x *= mul_inv;         \u003c/span\u003e\u003cspan\u003e// x *= mul;\n\u003c/span\u003e\u003cspan\u003e    uint64_t u = x ^ v;   \u003c/span\u003e\u003cspan\u003e// uint64_t x = u ^ v;\n\u003c/span\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Find loadword\u0026lt;uint64_t\u0026gt;(s + len - 16).\n\u003c/span\u003e\u003cspan\u003e    uint64_t d = u - rotate(a - b, \u003c/span\u003e\u003cspan\u003e43\u003c/span\u003e\u003cspan\u003e) - rotate(c, \u003c/span\u003e\u003cspan\u003e30\u003c/span\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003cspan\u003e    d *= k0_inv;\n\u003c/span\u003e\u003cspan\u003e    std::memcpy(s + len - \u003c/span\u003e\u003cspan\u003e16\u003c/span\u003e\u003cspan\u003e, \u0026amp;d, sizeof(d));\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe chance that a random \u003ccode\u003euint64_t\u003c/code\u003e forms 8 printable ASCII bytes is\n$\\left(94/256\\right)^8 \\approx 0.033%$. Not great, but \u003ccode\u003ecityhash64_preimage32\u003c/code\u003e\nis so fast that having to repeat it on average ~3000 times to get a purely\nASCII result isn’t so bad.\u003c/p\u003e\n\u003cp\u003eFor example, the following 10 strings all hash to \u003ccode\u003e1337\u003c/code\u003e using CityHash64, generated\nusing \u003ca href=\"https://gist.github.com/orlp/8debf0047e7735b43887aafb041c9a01\"\u003ethis code\u003c/a\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eorlp-cityhash64-D-:K5yx*zkgaaaaa\n\u003c/span\u003e\u003cspan\u003eorlp-cityhash64-TXb7;1j\u0026amp;btkaaaaa\n\u003c/span\u003e\u003cspan\u003eorlp-cityhash64-+/LM$0 ;msnaaaaa\n\u003c/span\u003e\u003cspan\u003eorlp-cityhash64-u\u0026#39;f\u0026amp;\u0026gt;I\u0026#39;~mtnaaaaa\n\u003c/span\u003e\u003cspan\u003eorlp-cityhash64-pEEv.LyGcnpaaaaa\n\u003c/span\u003e\u003cspan\u003eorlp-cityhash64-v~~bm@,Vahtaaaaa\n\u003c/span\u003e\u003cspan\u003eorlp-cityhash64-RxHr_\u0026amp;~{miuaaaaa\n\u003c/span\u003e\u003cspan\u003eorlp-cityhash64-is_$34#\u0026gt;uavaaaaa\n\u003c/span\u003e\u003cspan\u003eorlp-cityhash64-$*~l\\{S!zoyaaaaa\n\u003c/span\u003e\u003cspan\u003eorlp-cityhash64-W@^5|3^:gtcbaaaa\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"breaking-murmurhash2\"\u003e\u003ca href=\"#breaking-murmurhash2\" aria-label=\"Anchor link for: breaking-murmurhash2\"\u003eBreaking MurmurHash2\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe can’t let \u003ccode\u003elibstdc++\u003c/code\u003e get away after targetting \u003ccode\u003elibc++\u003c/code\u003e, can we? \nThe \u003ca href=\"https://github.com/gcc-mirror/gcc/blob/97a36b466ba1420210294f0a1dd7002054ba3b7e/libstdc%2B%2B-v3/include/bits/basic_string.h#L4402\"\u003edefault string hash\u003c/a\u003e\n\u003ca href=\"https://github.com/gcc-mirror/gcc/blob/97a36b466ba1420210294f0a1dd7002054ba3b7e/libstdc%2B%2B-v3/include/bits/functional_hash.h#L206\"\u003ecalls\u003c/a\u003e\nan \u003ca href=\"https://github.com/gcc-mirror/gcc/blob/97a36b466ba1420210294f0a1dd7002054ba3b7e/libstdc%2B%2B-v3/libsupc%2B%2B/hash_bytes.cc#L138\"\u003eimplementation of MurmurHash2\u003c/a\u003e\nwith seed \u003ccode\u003e0xc70f6907\u003c/code\u003e. The hash—simplified to only handle strings whose\nlengths are multiples of 8—is as follows:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003euint64_t murmurhash64a(const \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e* s, size_t len, uint64_t seed) {\n\u003c/span\u003e\u003cspan\u003e    const uint64_t mul = \u003c/span\u003e\u003cspan\u003e0xc6a4a7935bd1e995\u003c/span\u003e\u003cspan\u003eULL\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    uint64_t hash = seed ^ (len * mul);\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003e(const \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e* p = s; p != s + len; p += \u003c/span\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e) {\n\u003c/span\u003e\u003cspan\u003e        uint64_t data = loadword\u0026lt;uint64_t\u0026gt;(p);\n\u003c/span\u003e\u003cspan\u003e        data *= mul;\n\u003c/span\u003e\u003cspan\u003e        data ^= data \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e        data *= mul;\n\u003c/span\u003e\u003cspan\u003e        hash ^= data;\n\u003c/span\u003e\u003cspan\u003e        hash *= mul;\n\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    hash ^= hash \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    hash *= mul;\n\u003c/span\u003e\u003cspan\u003e    hash ^= hash \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e hash;\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can take a similar approach here as before. We note that the modular\nmultiplicative inverse of \u003ccode\u003e0xc6a4a7935bd1e995\u003c/code\u003e mod $2^{64}$ is \n\u003ccode\u003e0x5f7a0ea7e59b19bd\u003c/code\u003e. As an example, we can choose the first 24 bytes\narbitrarily, and solve for the last 8 bytes:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003evoid \u003c/span\u003e\u003cspan\u003emurmurhash64a_preimage32(uint64_t hash, \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e* s, uint64_t seed) {\n\u003c/span\u003e\u003cspan\u003e    const uint64_t mul = \u003c/span\u003e\u003cspan\u003e0xc6a4a7935bd1e995\u003c/span\u003e\u003cspan\u003eULL\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    const uint64_t mulinv = \u003c/span\u003e\u003cspan\u003e0x5f7a0ea7e59b19bd\u003c/span\u003e\u003cspan\u003eULL\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Compute the hash state for the first 24 bytes as normal.\n\u003c/span\u003e\u003cspan\u003e    uint64_t state = seed ^ (\u003c/span\u003e\u003cspan\u003e32 \u003c/span\u003e\u003cspan\u003e* mul);\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003e(const \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e* p = s; p != s + \u003c/span\u003e\u003cspan\u003e24\u003c/span\u003e\u003cspan\u003e; p += \u003c/span\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e) {\n\u003c/span\u003e\u003cspan\u003e        uint64_t data = loadword\u0026lt;uint64_t\u0026gt;(p);\n\u003c/span\u003e\u003cspan\u003e        data *= mul;\n\u003c/span\u003e\u003cspan\u003e        data ^= data \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e        data *= mul;\n\u003c/span\u003e\u003cspan\u003e        state ^= data;\n\u003c/span\u003e\u003cspan\u003e        state *= mul;\n\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Invert target hash transformation.\n\u003c/span\u003e\u003cspan\u003e                        \u003c/span\u003e\u003cspan\u003e// return hash;\n\u003c/span\u003e\u003cspan\u003e    hash ^= hash \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e; \u003c/span\u003e\u003cspan\u003e// hash ^= hash \u0026gt;\u0026gt; 47;\n\u003c/span\u003e\u003cspan\u003e    hash *= mulinv;     \u003c/span\u003e\u003cspan\u003e// hash *= mul;\n\u003c/span\u003e\u003cspan\u003e    hash ^= hash \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e; \u003c/span\u003e\u003cspan\u003e// hash ^= hash \u0026gt;\u0026gt; 47;\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Invert last iteration for last 8 bytes.\n\u003c/span\u003e\u003cspan\u003e    hash *= mulinv;                \u003c/span\u003e\u003cspan\u003e// hash *= mul;\n\u003c/span\u003e\u003cspan\u003e    uint64_t data = state ^ hash;  \u003c/span\u003e\u003cspan\u003e// hash = hash ^ data;\n\u003c/span\u003e\u003cspan\u003e    data *= mulinv;                \u003c/span\u003e\u003cspan\u003e// data *= mul;\n\u003c/span\u003e\u003cspan\u003e    data ^= data \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;            \u003c/span\u003e\u003cspan\u003e// data ^= data \u0026gt;\u0026gt; 47;\n\u003c/span\u003e\u003cspan\u003e    data *= mulinv;                \u003c/span\u003e\u003cspan\u003e// data *= mul;\n\u003c/span\u003e\u003cspan\u003e    std::memcpy(s + \u003c/span\u003e\u003cspan\u003e24\u003c/span\u003e\u003cspan\u003e, \u0026amp;data, \u003c/span\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e); \u003c/span\u003e\u003cspan\u003e// data = loadword\u0026lt;uint64_t\u0026gt;(s);\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe following 10 strings all hash to \u003ccode\u003e1337\u003c/code\u003e using MurmurHash64A with the\ndefault seed \u003ccode\u003e0xc70f6907\u003c/code\u003e, generated using \u003ca href=\"https://gist.github.com/orlp/59470263c1e2b05b035719f3121bcc45\"\u003ethis code\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eorlp-murmurhash64-bhbaaat;SXtgVa\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash64-bkiaaa\u0026amp;JInaNcZ\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash64-ewmaaa(%J+jw\u0026gt;j\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash64-vxpaaag\u0026#34;93\\Yj5\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash64-ehuaaafa`Wp`/|\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash64-yizaaa1x.zQF6r\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash64-lpzaaaZphp\u0026amp;c F\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash64-wsjbaa771rz{z\u0026lt;\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash64-rnkbaazy4X]p\u0026gt;B\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash64-aqnbaaZ~OzP_Tp\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"universal-collision-attack-on-murmurhash64a\"\u003e\u003ca href=\"#universal-collision-attack-on-murmurhash64a\" aria-label=\"Anchor link for: universal-collision-attack-on-murmurhash64a\"\u003eUniversal collision attack on MurmurHash64A\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIn fact, MurmurHash64A is so weak that Jean-Philippe Aumasson, Daniel J.\nBernstein and Martin Boßlet published \u003ca href=\"https://cr.yp.to/talks/2012.12.29/slides.pdf\"\u003ean\nattack\u003c/a\u003e that creates sets of\nstrings which collide \u003cstrong\u003eregardless of the random seed used\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eTo see how it works, let’s take a look at the core loop of MurmurHash64A:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003euint64_t data = loadword\u0026lt;uint64_t\u0026gt;(p);\n\u003c/span\u003e\u003cspan\u003edata *= mul;          \u003c/span\u003e\u003cspan\u003e// Trivially invertible.\n\u003c/span\u003e\u003cspan\u003edata ^= data \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;   \u003c/span\u003e\u003cspan\u003e// Trivially invertible.\n\u003c/span\u003e\u003cspan\u003edata *= mul;          \u003c/span\u003e\u003cspan\u003e// Trivially invertible.\n\u003c/span\u003e\u003cspan\u003estate ^= data;\n\u003c/span\u003e\u003cspan\u003estate *= mul;\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe know we can trivially invert the operations done on \u003ccode\u003edata\u003c/code\u003e regardless of what the\ncurrent state is, so we might as well have had the following body:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003estate ^= data;\n\u003c/span\u003e\u003cspan\u003estate *= mul;\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow the hash starts looking rather weak indeed. The clever trick they\nemploy is by creating two strings simultaneously, such that they\ndiffer precisely in the top bit in each 8-byte word. Why the top bit?\u003c/p\u003e\n\u003cpre data-lang=\"python\"\u003e\u003ccode data-lang=\"python\"\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e1 \u003c/span\u003e\u003cspan\u003e\u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e63\n\u003c/span\u003e\u003cspan\u003e9223372036854775808\n\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt; (\u003c/span\u003e\u003cspan\u003e1 \u003c/span\u003e\u003cspan\u003e\u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e63\u003c/span\u003e\u003cspan\u003e) * mul % \u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003e64\n\u003c/span\u003e\u003cspan\u003e9223372036854775808\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince \u003ccode\u003emul\u003c/code\u003e is odd, its least significant bit is set. Multiplying \u003ccode\u003e1 \u0026lt;\u0026lt; 63\u003c/code\u003e by\nit is equivalent to shifting that bit 63 places to the left, which is once again\n\u003ccode\u003e1 \u0026lt;\u0026lt; 63\u003c/code\u003e. That is, \u003ccode\u003e1 \u0026lt;\u0026lt; 63\u003c/code\u003e is a fixed point for the \u003ccode\u003estate *= mul\u003c/code\u003e operation.\nWe also note that for the top bit XOR is equivalent to addition, as the overflow\nfrom addition is removed mod $2^{64}$.\u003c/p\u003e\n\u003cp\u003eSo if we have two input strings, one starting with the 8 bytes \u003ccode\u003edata\u003c/code\u003e, and the\nother starting with \u003ccode\u003edata ^ (1 \u0026lt;\u0026lt; 63) == data + (1 \u0026lt;\u0026lt; 63)\u003c/code\u003e (after doing the\ntrivial inversions). We then find that the two states, regardless of seed,\ndiffer exactly in the top bit after \u003ccode\u003estate ^= data\u003c/code\u003e. After multiplication we\nfind we have two states \u003ccode\u003ex * mul\u003c/code\u003e and \u003ccode\u003e(x + (1 \u0026lt;\u0026lt; 63)) * mul == x * mul + (1 \u0026lt;\u0026lt; 63)\u003c/code\u003e… which again differ exactly in the top bit! We are now back to \u003ccode\u003estate ^= data\u003c/code\u003e in our iteration, for the next 8 bytes. We can now use this moment to\ncancel our top bit difference, by again feeding two 8-byte strings that\ndiffer in the top bit (after inverting).\u003c/p\u003e\n\u003cp\u003eIn fact, we only have to find one pair of such strings that differ in the top\nbit, which we can then repeat twice (in either order) to cancel our difference\nagain. When represented as a \u003ccode\u003euint64_t\u003c/code\u003e if we choose the first string as \u003ccode\u003ex\u003c/code\u003e we\ncan derive the second string as\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003ex *= mul;        \u003c/span\u003e\u003cspan\u003e// Forward transformation...\n\u003c/span\u003e\u003cspan\u003ex ^= x \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;    \u003c/span\u003e\u003cspan\u003e// ...\n\u003c/span\u003e\u003cspan\u003ex *= mul;        \u003c/span\u003e\u003cspan\u003e// ...\n\u003c/span\u003e\u003cspan\u003ex ^= \u003c/span\u003e\u003cspan\u003e1 \u003c/span\u003e\u003cspan\u003e\u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e63\u003c/span\u003e\u003cspan\u003e;    \u003c/span\u003e\u003cspan\u003e// Difference in top bit.\n\u003c/span\u003e\u003cspan\u003ex *= mulinv;     \u003c/span\u003e\u003cspan\u003e// Backwards transformation...\n\u003c/span\u003e\u003cspan\u003ex ^= x \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e;    \u003c/span\u003e\u003cspan\u003e// ...\n\u003c/span\u003e\u003cspan\u003ex *= mulinv;     \u003c/span\u003e\u003cspan\u003e// ...\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI was unable to find a printable ASCII string that has another printable\nASCII string as its partner. But I was able to find the following pair of 8-byte\nUTF-8 strings that differ in exactly the top bit after the Murmurhash64A input\ntransformation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003exx0rlpx!\n\u003c/span\u003e\u003cspan\u003exxsXъВ\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCombining them as such gives two 16-byte strings that when fed through the hash\nalgorithm manipulate the state in the same way: a collision.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003exx0rlpx!xxsXъВ\n\u003c/span\u003e\u003cspan\u003exxsXъВxx0rlpx!\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut it doesn’t stop there. By concatenating these two strings we can create\n$2^n$ different colliding strings each $16n$ bytes long. With the current\n\u003ccode\u003elibstdc++\u003c/code\u003e implementation the following prints the same number eight times:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003estd::hash\u0026lt;std::u8string\u0026gt; h;\n\u003c/span\u003e\u003cspan\u003estd::u8string a = \u003c/span\u003e\u003cspan\u003eu8\u003c/span\u003e\u003cspan\u003e\u0026#34;xx0rlpx!xxsXъВ\u0026#34;\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estd::u8string b = \u003c/span\u003e\u003cspan\u003eu8\u003c/span\u003e\u003cspan\u003e\u0026#34;xxsXъВxx0rlpx!\u0026#34;\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estd::cout \u0026lt;\u0026lt; h(a + a + a) \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estd::cout \u0026lt;\u0026lt; h(a + a + b) \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estd::cout \u0026lt;\u0026lt; h(a + b + a) \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estd::cout \u0026lt;\u0026lt; h(a + b + b) \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estd::cout \u0026lt;\u0026lt; h(b + a + a) \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estd::cout \u0026lt;\u0026lt; h(b + a + b) \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estd::cout \u0026lt;\u0026lt; h(b + b + a) \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003estd::cout \u0026lt;\u0026lt; h(b + b + b) \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEven if the \u003ccode\u003elibstdc++\u003c/code\u003e would randomize the seed used by MurmurHash64a, the\nstrings would \u003cem\u003estill\u003c/em\u003e collide.\u003c/p\u003e\n\u003ch2 id=\"breaking-murmurhash3\"\u003e\u003ca href=\"#breaking-murmurhash3\" aria-label=\"Anchor link for: breaking-murmurhash3\"\u003eBreaking MurmurHash3\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eNim \u003cdel\u003euses\u003c/del\u003e\n\u003ca href=\"https://github.com/nim-lang/Nim/blob/46d2161c23c2aa1905571512b9a1ef7d61ae670e/lib/pure/hashes.nim#L386\"\u003eused to use\u003c/a\u003e\n\u003ca href=\"https://github.com/PeterScott/murmur3/blob/master/murmur3.c\"\u003e\u003ccode\u003eMurmurHash3_x86_32\u003c/code\u003e\u003c/a\u003e,\nso let’s try to break that.\u003c/p\u003e\n\n\u003cp\u003eIf we once again simplify to strings whose lengths are a multiple of 4 we get the following code:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003euint32_t rotl32(uint32_t x, \u003c/span\u003e\u003cspan\u003eint \u003c/span\u003e\u003cspan\u003er) {\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn \u003c/span\u003e\u003cspan\u003e(x \u0026lt;\u0026lt; r) | (x \u0026gt;\u0026gt; (\u003c/span\u003e\u003cspan\u003e32 \u003c/span\u003e\u003cspan\u003e- r));\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003euint32_t murmurhash3_x86_32(const \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e* s, \u003c/span\u003e\u003cspan\u003eint \u003c/span\u003e\u003cspan\u003elen, uint32_t seed) {\n\u003c/span\u003e\u003cspan\u003e    const uint32_t c1 = \u003c/span\u003e\u003cspan\u003e0xcc9e2d51\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    const uint32_t c2 = \u003c/span\u003e\u003cspan\u003e0x1b873593\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    const uint32_t c3 = \u003c/span\u003e\u003cspan\u003e0x85ebca6b\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    const uint32_t c4 = \u003c/span\u003e\u003cspan\u003e0xc2b2ae35\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    uint32_t h = seed;\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003e(const \u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e* p = s; p != s + len; p += \u003c/span\u003e\u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e) {\n\u003c/span\u003e\u003cspan\u003e        uint32_t k = loadword\u0026lt;uint32_t\u0026gt;(p);\n\u003c/span\u003e\u003cspan\u003e        k *= c1;\n\u003c/span\u003e\u003cspan\u003e        k = rotl32(k, \u003c/span\u003e\u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003cspan\u003e        k *= c2;\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        h ^= k;\n\u003c/span\u003e\u003cspan\u003e        h = rotl32(h, \u003c/span\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003cspan\u003e        h = h * \u003c/span\u003e\u003cspan\u003e5 \u003c/span\u003e\u003cspan\u003e+ \u003c/span\u003e\u003cspan\u003e0xe6546b64\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    h ^= len;\n\u003c/span\u003e\u003cspan\u003e    h ^= h \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e16\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    h *= c3;\n\u003c/span\u003e\u003cspan\u003e    h ^= h \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    h *= c4;\n\u003c/span\u003e\u003cspan\u003e    h ^= h \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e16\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e h;\n\u003c/span\u003e\u003cspan\u003e} \n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI think by now you should be able to get this function to spit out any\nvalue you want if you know the seed. \nThe inverse of\n\u003ccode\u003erotl32(x, r)\u003c/code\u003e is \u003ccode\u003erotl32(x, 32-r)\u003c/code\u003e and the inverse of \u003ccode\u003eh ^= h \u0026gt;\u0026gt; 16\u003c/code\u003e is\nonce again just \u003ccode\u003eh ^= h \u0026gt;\u0026gt; 16\u003c/code\u003e. Only \u003ccode\u003eh ^= h \u0026gt;\u0026gt; 13\u003c/code\u003e is a bit different, it’s the first time\nwe’ve seen that a xorshift’s inverse has more than one step:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eh ^= h \u0026gt;\u0026gt; 13\n\u003c/span\u003e\u003cspan\u003eh ^= h \u0026gt;\u0026gt; 26\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCompute the modular inverses\nof \u003ccode\u003ec1\u003c/code\u003e through \u003ccode\u003ec4\u003c/code\u003e as well as \u003ccode\u003e5\u003c/code\u003e mod $2^{32}$, and go to town. \nIf you want to cheat or check your answer, you can check out \u003ca href=\"https://gist.github.com/orlp/0c33157a0971053b60ac1da84b021bea\"\u003ethe code\u003c/a\u003e\nI’ve used to generate the following ten strings that all hash to 1337 when\nfed to \u003ccode\u003eMurmurHash3_x86_32\u003c/code\u003e with seed \u003ccode\u003e0\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eorlp-murmurhash3_x86_32-haaaPa*+\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash3_x86_32-saaaUW\u0026amp;\u0026lt;\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash3_x86_32-ubaa/!/\u0026#34;\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash3_x86_32-weaare]]\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash3_x86_32-chaa5@/}\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash3_x86_32-claaM[,5\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash3_x86_32-fraaIx`N\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash3_x86_32-iwaara\u0026amp;\u0026lt;\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash3_x86_32-zwaa]\u0026gt;zd\n\u003c/span\u003e\u003cspan\u003eorlp-murmurhash3_x86_32-zbbaW-5G\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNim uses \u003ccode\u003e0\u003c/code\u003e as a fixed seed.\u003c/p\u003e\n\n\u003ch3 id=\"universal-collision-attack-on-murmurhash3\"\u003e\u003ca href=\"#universal-collision-attack-on-murmurhash3\" aria-label=\"Anchor link for: universal-collision-attack-on-murmurhash3\"\u003eUniversal collision attack on MurmurHash3\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSuppose that Nim didn’t use \u003ccode\u003e0\u003c/code\u003e as a fixed seed, but chose a randomly generated\none. Can we do a similar attack as the one done to MurmurHash2 to still generate\nuniversal multicollisions?\u003c/p\u003e\n\u003cp\u003eYes we can. Let’s take another look at that core loop body:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003euint32_t k = loadword\u0026lt;uint32_t\u0026gt;(p);\n\u003c/span\u003e\u003cspan\u003ek *= c1;            \u003c/span\u003e\u003cspan\u003e// Trivially invertable.\n\u003c/span\u003e\u003cspan\u003ek = rotl32(k, \u003c/span\u003e\u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e);  \u003c/span\u003e\u003cspan\u003e// Trivially invertable.\n\u003c/span\u003e\u003cspan\u003ek *= c2;            \u003c/span\u003e\u003cspan\u003e// Trivially invertable.\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003eh ^= k;\n\u003c/span\u003e\u003cspan\u003eh = rotl32(h, \u003c/span\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003cspan\u003eh = h * \u003c/span\u003e\u003cspan\u003e5 \u003c/span\u003e\u003cspan\u003e+ \u003c/span\u003e\u003cspan\u003e0xe6546b64\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnce again we can ignore the first three trivially invertable instructions as we\ncan simply choose our input so that we get exactly the \u003ccode\u003ek\u003c/code\u003e we want.\nRemember from last time that we want to introduce a difference in exactly the\ntop bit of \u003ccode\u003eh\u003c/code\u003e, as the multiplication will leave this difference in place.\nBut here there is a bit rotation between the XOR  and the multiplication.\nThe solution? Simply place our bit difference such that \u003ccode\u003erotl32(h, 13)\u003c/code\u003e shifts\nit into the top position.\u003c/p\u003e\n\u003cp\u003eDoes the addition of \u003ccode\u003e0xe6546b64\u003c/code\u003e mess things up? No. Since only the top bit\nbetween the two states will be different, there is a difference of exactly\n$2^{31}$ between the two states. This difference is maintained by the addition.\nSince two 32-bit numbers with the same top bit can be at most $2^{31} - 1$ \napart, we can conclude that the two states still differ in the top bit after\nthe addition.\u003c/p\u003e\n\u003cp\u003eSo we want to find two pairs of 32-bit ints, such that after applying the first\nthree instructions the first pair differs in bit \u003ccode\u003e1 \u0026lt;\u0026lt; (31 - 13) == 0x00040000\u003c/code\u003e\nand the second pair in bit \u003ccode\u003e1 \u0026lt;\u0026lt; 31 == 0x80000000\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAfter some brute-force searching I found some cool pairs (again forced to use\nUTF-8), which when combined give the following collision:\u003c/p\u003e\n\u003cpre data-lang=\"nim\"\u003e\u003ccode data-lang=\"nim\"\u003e\u003cspan\u003ea = \u003c/span\u003e\u003cspan\u003e\u0026#34;!\u0026amp;orlpՓ\u0026#34;\n\u003c/span\u003e\u003cspan\u003eb = \u003c/span\u003e\u003cspan\u003e\u0026#34;yǏglp$X\u0026#34;\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs before, any concatenation of \u003ccode\u003ea\u003c/code\u003es and \u003ccode\u003eb\u003c/code\u003es of length \u003ccode\u003en\u003c/code\u003e collides with all\nother combinations of length \u003ccode\u003en\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"breaking-farmhash64\"\u003e\u003ca href=\"#breaking-farmhash64\" aria-label=\"Anchor link for: breaking-farmhash64\"\u003eBreaking FarmHash64\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eNim switched to\n\u003ca href=\"https://github.com/nim-lang/Nim/blob/46bb47a444bd377860d832fc1c62b262343f36a2/lib/pure/hashes.nim#L537\"\u003efarmhash\u003c/a\u003e\nsince I started writing this post. To break it we can notice that its structure\nis very similar to CityHash64, so we can use those same techniques again. In\nfact, the only changes between the two for lengths 17-32 bytes is that a few\noperators were changed from subtraction/XOR to addition, a rotation operator had\nits constant tweaked, and some \u003ccode\u003ek\u003c/code\u003e constants are slightly tweaked in usage. The\nprocess of breaking it is so similar that it’s entirely analogous, so we can\nskip straight to \u003ca href=\"https://gist.github.com/orlp/f0f3307530841183ddb72a0528ce0742\"\u003ethe result\u003c/a\u003e.\nThese 10 strings all hash to 1337 with FarmHash64:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eorlp-farmhash64-?VrJ@L7ytzwheaaa\n\u003c/span\u003e\u003cspan\u003eorlp-farmhash64-p3`!SQb}fmxheaaa\n\u003c/span\u003e\u003cspan\u003eorlp-farmhash64-pdt\u0026#39;cuI\\gvxheaaa\n\u003c/span\u003e\u003cspan\u003eorlp-farmhash64-IbY`xAG\u0026amp;ibkieaaa\n\u003c/span\u003e\u003cspan\u003eorlp-farmhash64-[_LU!d1hwmkieaaa\n\u003c/span\u003e\u003cspan\u003eorlp-farmhash64-QiY!clz]bttieaaa\n\u003c/span\u003e\u003cspan\u003eorlp-farmhash64-\u0026amp;?J3rZ_8gsuieaaa\n\u003c/span\u003e\u003cspan\u003eorlp-farmhash64-LOBWtm5Szyuieaaa\n\u003c/span\u003e\u003cspan\u003eorlp-farmhash64-Mptaa^g^ytvieaaa\n\u003c/span\u003e\u003cspan\u003eorlp-farmhash64-B?\u0026amp;l::hxqmfjeaaa\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"trivial-fixed-seed-wyhash-multicollisions\"\u003e\u003ca href=\"#trivial-fixed-seed-wyhash-multicollisions\" aria-label=\"Anchor link for: trivial-fixed-seed-wyhash-multicollisions\"\u003eTrivial fixed-seed wyhash multicollisions\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eZig uses \u003ca href=\"https://github.com/wangyi-fudan/wyhash/blob/master/wyhash.h\"\u003ewyhash\u003c/a\u003e\nwith a fixed seed of zero. While I was unable to do\nseed-independent attacks against wyhash, using it with a fixed seed makes\ngenerating collisions trivial. Wyhash is \u003ca href=\"https://github.com/wangyi-fudan/wyhash/blob/46cebe9dc4e51f94d0dca287733bc5a94f76a10d/wyhash.h#L46\"\u003ebuilt upon\u003c/a\u003e\nthe folded multiply, which takes two 64-bit inputs, multiplies them to a 128-bit product before XORing\ntogether the two halves:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003euint64_t folded_multiply(uint64_t a, uint64_t b) {\n\u003c/span\u003e\u003cspan\u003e    __uint128_t full = __uint128_t(a) * __uint128_t(b);\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn \u003c/span\u003e\u003cspan\u003euint64_t(full) ^ uint64_t(full \u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e64\u003c/span\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIt’s easy to immediately see a critical flaw with this: if one of the two sides\nis zero, the output will also always be zero. To protect against this, wyhash\nalways uses a folded multiply in the following form:\u003c/p\u003e\n\u003cpre data-lang=\"cpp\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003eout = folded_multiply(input_a ^ secret_a, input_b ^ secret_b);\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere \u003ccode\u003esecret_a\u003c/code\u003e and \u003ccode\u003esecret_b\u003c/code\u003e are determined by the seed, or outputs of\nprevious iterations which are influenced by the seed. However, when your seed is\nconstant… With \u003ca href=\"https://gist.github.com/orlp/a9cc8dae3a74b1faaa0a642135ee81df\"\u003ea bit of creativity\u003c/a\u003e\nwe can use the start of our string to prepare a ‘secret’ value which we can\nperfectly cancel with another ASCII string later in the input.\u003c/p\u003e\n\u003cp\u003eSo, without further ado, every 32-byte string of the form\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eorlp-wyhash-oGf_________tWJbzMJR\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ehashes to the same value with Zig’s default hasher.\u003c/p\u003e\n\u003cp\u003eZig uses a different set of parameters than the defaults found in the wyhash\nrepository, so for good measure, this pattern provides arbitrary multicollisions\nfor the default parameters found in wyhash when using \u003ccode\u003eseed == 0\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eorlp-wyhash-EUv_________NLXyytkp\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003e\u003ca href=\"#conclusion\" aria-label=\"Anchor link for: conclusion\"\u003eConclusion\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe’ve seen that a lot of the hash functions in common use in hash tables today\nare very weak, allowing fairly trivial attacks to produce arbitrary amounts of\ncollisions if not randomly initialized. Using a randomly seeded hash table is\nparamount if you don’t wish to become a victim of a hash flooding attack.\u003c/p\u003e\n\u003cp\u003eWe’ve also seen that some hash functions are vulnerable to attack \u003cem\u003eeven if\nrandomly seeded\u003c/em\u003e. These are completely broken and should not be used if attacks\nare a concern at all. Luckily I was unable to find such attacks against most\nhashes, but the possibility of such an attack existing is quite unnerving.\u003c/p\u003e\n\u003cp\u003eWith \u003ca href=\"https://en.wikipedia.org/wiki/Universal_hashing\"\u003euniversal hashing\u003c/a\u003e it’s\npossible to construct hash functions for which such an attack is provably\nimpossible, last year I published a hash function called\n\u003ca href=\"https://github.com/orlp/polymur-hash\"\u003epolymur-hash\u003c/a\u003e that has this property. Your\nHTTPS connection to this website also likely uses a universal hash function\nfor authenticity of the transferred data, both \u003ca href=\"https://en.wikipedia.org/wiki/Poly1305\"\u003ePoly1305\u003c/a\u003e\nand \u003ca href=\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eGCM\u003c/a\u003e are based on\nuniversal hashing for their security proofs.\u003c/p\u003e\n\n\u003cp\u003eOf course, if your data is not user-controlled, or there is no reasonable\nsecurity model where your application would face attacks, you can get away with\nfaster and insecure hashes.\u003c/p\u003e\n\u003cp\u003eMore to come on the subject of hashing and hash\ntables and how it can go right or wrong, but for now this article is long enough as-is…\u003c/p\u003e\n\n\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "31 min read",
  "publishedTime": null,
  "modifiedTime": null
}
