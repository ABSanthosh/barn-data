{
  "id": "1381a9d7-6eda-45d7-8523-6b7dfd41aa06",
  "title": "Reverse Engineering Call of Duty Anti-Cheat",
  "link": "https://ssno.cc/posts/reversing-tac-1-4-2025/",
  "description": "Article URL: https://ssno.cc/posts/reversing-tac-1-4-2025/ Comments URL: https://news.ycombinator.com/item?id=42774221 Points: 52 # Comments: 4",
  "author": "deverton",
  "published": "Mon, 20 Jan 2025 23:07:10 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "ssno",
  "length": 67759,
  "excerpt": "I’ve been reversing Black Ops Cold War for a while now, and I’ve finally decided to share my research regarding the user-mode anti-cheat inside the game. It’s not my intention to shame or promote cheating/bypassing of the anti-cheat, so I’ve redacted a few things. To clear up any confusion, Black Ops Cold War does not have the kernel-mode component of Ricochet that Modern Warfare (2019) and later titles have. I’ll be referring to the anti-cheat as TAC (Treyarch Anti-Cheat) as the game I reversed is a Treyarch game. Also, whenever I provide function pseudocode, it will be the best I can do since the actual decompilation is super cluttered with a lot of junk/resolving code. The biggest difference between the newer games is the kernel-mode driver, while the majority of anti-cheat code is user-mode and very similar to TAC.",
  "siteName": "ssno",
  "favicon": "https://github.com/ssnob.png",
  "text": "I’ve been reversing Black Ops Cold War for a while now, and I’ve finally decided to share my research regarding the user-mode anti-cheat inside the game. It’s not my intention to shame or promote cheating/bypassing of the anti-cheat, so I’ve redacted a few things. To clear up any confusion, Black Ops Cold War does not have the kernel-mode component of Ricochet that Modern Warfare (2019) and later titles have. I’ll be referring to the anti-cheat as TAC (Treyarch Anti-Cheat) as the game I reversed is a Treyarch game. Also, whenever I provide function pseudocode, it will be the best I can do since the actual decompilation is super cluttered with a lot of junk/resolving code. The biggest difference between the newer games is the kernel-mode driver, while the majority of anti-cheat code is user-mode and very similar to TAC. Let’s look at how the anti-cheat and the game is protected before we dig too deep. Arxan Arxan is an obfuscation/protection tool that’s used on many Call of Duty games, most of which are anything past Black Ops 3. Which includes many features, that make cheaters/reverse engineers’ life a lot harder. Runtime Executable Decryption The game executable is packed and encrypted; Arxan inserts code during the startup process to unpack and decrypt the game executable. Executable Checksums Arxan is constantly monitoring the game executable for any patches. If you want to learn more about these, momo5502 has a great blog post which can be found here Whenever Arxan detects a debugger or a checksum mismatch, it will terminate the process. Jmp Obfuscation Arxan can take a function and all of its instructions and separate them with a jmp. This is also useful to hide where a function is called from, it breaks IDA and requires an external tool to sift through the instructions. push rbp mov rbp, offset unk_7FF60ECD1310 xchg rbp, [rsp] push rbx jmp loc_7FF62B2050A6 loc_7FF62B2050A6: push rax mov rbx, [rsp+10h] mov rax, offset loc_7FF60ECD1622 cmovbe rbx, rax jmp loc_7FF62BD590D3 loc_7FF62BD590D3: mov [rsp+10h], rbx pop rax pop rbx retn loc_7FF60ECD1622: jmp loc_7FF629D04404 ; etc This is difficult to analyze statically, especially whenever it’s a giant function that’s been planted with hundreds of jumps. Entrypoint Obfuscation It’s really difficult to follow the entry point on Arxan-protected games; first, you have the protected Arxan code that unpacks and executes the game’s real entry point, which jmp obfuscation can also be planted in here, making it extremely difficult to understand what’s going on. Pointer Encryption This was actually thought to be Arxan for the longest time, but with recent information, it’s pretty certain this is just something Treyarch has developed and shared with IW for their games, or maybe it’s the other way around. Important pointers such as the current game glob, entity array, object pointers, etc., are encrypted and decrypted every time before use. There are 16 variations of the same encryption method; the current PEB address is actually what decides which encryption method to use. This is pretty effective and does make your life harder for a little bit. Forces you to get the decrypted pointer. Prevents cheat engine pointer scanning (when scanning for the memory address of something that is encrypted, the actual global value will be holding the encrypted value, and this value is never set with the decrypted value; the decrypted value is always on the stack.) There are a couple of ways to retrieve these decrypted pointers (these are not all of them): Using a tool to trace the decryption instructions. Creating a hook on spots where the memory has already been decrypted by the game for use. __forceinline int get_encryption_method() { // this is actually how it is in the exe // the result of this ROL is 0x60 which is gs[PEB] // these values are generated and will not always be the same const auto value = (unsigned __int8)__ROL1__(-127, 230); auto peb = __readgsqword(value); return _byteswap_uint64(peb \u003c\u003c 33) \u0026 0xF; } Here’s just a small portion of the operations done in the game exe for the encryption. Now we that understand how the game and anti-cheat are protected we can dig deeper. TAC is planted directly into the game executable, uses no kernel components, and will also terminate the process if debug artifacts are found. How does TAC detect monitoring? API Hook Detection TAC is designed for Windows; this means it’s going to be using Windows-specific APIs for the anti-cheat. The hook detection used here is pretty basic, and it’s currently only checking for 7 patterns. It looks like they have just taken previous cheats’ hook stubs and put them in. NOTE: Each time I provide example code, every API called in that example code is what TAC is using, is being checked for hooks, and is being resolved by their runtime hash lookup. Also, most of TAC is heavily inlined. ; First stub push rax movabs rax,0x0 xchg QWORD PTR [rsp],rax ret ; Second Stub push rbx movabs rbx,0x0 xchg QWORD PTR [rsp],rbx ret ; Third Stub push rcx movabs rcx,0x0 xchg QWORD PTR [rsp],rcx ret ; Fourth Stub push rdx movabs rdx,0x0 xchg QWORD PTR [rsp],rdx ret ; Fifth Stub push 0x0 ret ; Sixth Stub (this is any call, 0xE8, 0x0, 0x0, 0x0, 0x0) call 0x00000 ; Seventh Stub (this is any jmp [rip+x], 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00) jmp QWORD PTR [rip+0] Here’s how these checks are implemented. Those 0x0 spots in the assembly are 8 bytes because this is x64. __forceinline void ac_check_hook(unsigned __int64 address, callback cb) { unsigned __int8* current_pos = nullptr; bool hook_detected = false; for (current_pos = (unsigned __int8 *)address; *current_pos == 144; ++current_pos) ; switch (*current_pos) { case 0x50u: if (current_pos[1] == 72 \u0026\u0026 current_pos[2] == 184 \u0026\u0026 current_pos[11] == 72 \u0026\u0026 current_pos[12] == 135 \u0026\u0026 current_pos[13] == 4 \u0026\u0026 current_pos[14] == 36 \u0026\u0026 current_pos[15] == 195) { hook_detected = true; } break; case 0x53u: if (current_pos[1] == 72 \u0026\u0026 current_pos[2] == 187 \u0026\u0026 current_pos[11] == 72 \u0026\u0026 current_pos[12] == 135 \u0026\u0026 current_pos[13] == 28 \u0026\u0026 current_pos[14] == 36 \u0026\u0026 current_pos[15] == 195) { hook_detected = true; } break; case 0x51u: if (current_pos[1] == 72 \u0026\u0026 current_pos[2] == 185 \u0026\u0026 current_pos[11] == 72 \u0026\u0026 current_pos[12] == 135 \u0026\u0026 current_pos[13] == 12 \u0026\u0026 current_pos[14] == 36 \u0026\u0026 current_pos[15] == 195) { hook_detected = true; } break; case 0x52u: if (current_pos[1] == 72 \u0026\u0026 current_pos[2] == 186 \u0026\u0026 current_pos[11] == 72 \u0026\u0026 current_pos[12] == 135 \u0026\u0026 current_pos[13] == 20 \u0026\u0026 current_pos[14] == 36 \u0026\u0026 current_pos[15] == 195) { hook_detected = true; } break; case 0x68u: if (current_pos[5] == 195) hook_detected = true; break; case 0xE9u: hook_detected = true; break; default: if (*current_pos == 255 \u0026\u0026 current_pos[1] == 37) hook_detected = true; break; } if (hook_detected) { cb(); } } // example usage ac_check_hook((unsigned __int64)\u0026Thread32First, callback); Runtime API Export Lookup TAC has an inlined API lookup function; it takes the module hash and the API name hash, iterates the current list of loaded modules, hashes the name, then goes through each exported function from that module and compares it to the compile-time hash of the API they want. This is what the decomp looks like. Here’s a recreation of their runtime lookup. void* get_module_base(size_t base, size_t hash) { ac_setbase(base); auto peb = static_cast\u003cPPEB\u003e(NtCurrentPeb()); auto head = \u0026peb-\u003eLdr-\u003eInMemoryOrderModuleList; int mc = 0; auto entry = head-\u003eFlink; while (entry != head) { auto table_entry = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); auto n = static_cast\u003cint\u003e(offsetof(LDR_DATA_TABLE_ENTRY, DllBase)); char buf[255]; size_t count = 0; wcstombs_s(\u0026count, buf, table_entry-\u003eFullDllName.Buffer, table_entry-\u003eFullDllName.Length); // this is just from my hash tool; +20 skips past C:\\Windows\\System32 auto h = ac_mod64(buf + 20); if (h == hash) { return table_entry-\u003eDllBase; break; } entry = entry-\u003eFlink; } return nullptr; } How can we figure out what these hashes are? The answer is super simple; I grabbed a list of all the loaded modules in my game process and copied over the game’s hashing function (note: dll names are hashed a little bit differently), which can be seen here. // this is used for dll names size_t ac_mod64(const char* str) { auto base = ac_getbase(); while (*str) { auto v203 = *str++; auto v39 = v203; if (v203 \u003e= 0x41u \u0026\u0026 v39 \u003c= 0x5Au) v39 += 32; base = 0x100000001B3i64 * (((v39 \u0026 0xFF00) \u003e\u003e 8) ^ (0x100000001B3i64 * (static_cast\u003cunsigned __int8\u003e(v39) ^ base))); } return base; } // this is used for exported function names size_t ac_fnv64(const char* str) { auto base = ac_getbase(); while (*str) { auto s = *str++; auto v12 = s; if (s \u003e= 65 \u0026\u0026 v12 \u003c= 90) v12 += 32; base = ac_prime * (v12 ^ base); } return base; } I took that function and calculated the hash of all the module names and exports from the module list that I grabbed, then created a function to look up these API names by using the FNV hash base and the inlined hash of the API name. Here’s how I managed to cache and resolve all of the exports. void cache_exports() { for (auto dll : loadedDlls) { HMODULE mod = GetModuleHandleA(dll.c_str()); if (!mod) { continue; } IMAGE_DOS_HEADER* mz = (PIMAGE_DOS_HEADER)mod; IMAGE_NT_HEADERS* nt = RVA2PTR(PIMAGE_NT_HEADERS, mz, mz-\u003ee_lfanew); IMAGE_DATA_DIRECTORY* edirp = \u0026nt-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; IMAGE_DATA_DIRECTORY edir = *edirp; IMAGE_EXPORT_DIRECTORY* exports = RVA2PTR(PIMAGE_EXPORT_DIRECTORY, mz, edir.VirtualAddress); DWORD* addrs = RVA2PTR(DWORD*, mz, exports-\u003eAddressOfFunctions); DWORD* names = RVA2PTR(DWORD*, mz, exports-\u003eAddressOfNames); for (unsigned i = 0; i \u003c exports-\u003eNumberOfFunctions; i++) { char* name = RVA2PTR(char*, mz, names[i]); void* addr = RVA2PTR(void*, mz, addrs[i]); MEMORY_BASIC_INFORMATION mbi; if (ssno::bypass::VirtualQuery((void*)name, \u0026mbi, sizeof(mbi))) { if (mbi.AllocationBase == mod) { hashes[ac_fnv64(name)] = std::string(name); } } } } } void lookup_hash(size_t base, size_t hash) { ac_setbase(base); hashes.clear(); cache_exports(); if (hashes.find(hash) == hashes.end()) { printf(\"Failed to find hash: 0x%p\\n\", hash); return; } printf(\"0x%p, 0x%p = %s\\n\", base, hash, hashes[hash].c_str()); } After all of this, it was time to do some manual work. I went in by hand and grabbed the base hashes and function hashes from the decompilation then put those into my program. Now I was able to tell exactly which APIs the anti-cheat was calling. Here’s how my tool ended up working. // (lookup_pebhash is the get_module_base function I wrote about further up) lookup_pebhash(0xB8BC6A966753F382u, 0x7380E62B9E1CA6D6); // ntdll lookup_hash(0x6B9D7FEE4A7D71CEui64, 0xE5FAB4B4E649C7A4ui64); // VirtualProtect lookup_hash(0x1592DD0A71569429i64, 0xB5902EE75629AA6Cui64); //NtAllocateVirtualMemory lookup_hash(0x3E4D681B236AE0A0i64, 0x3AB0D0D1450DE52Di64); //GetWindowLongA lookup_hash(0x77EF6ADABFA1098Fi64, 0x94CA321842195A88ui64); //OpenProcess lookup_hash(0xA3439F4AFAAB52AEui64, 0xE48550DEAB23A8C9ui64); //K32EnumProcessModules lookup_hash(0x2004CA9BE823B79Ai64, 0x828CC84F9E74E1A0ui64); //CloseHandle lookup_hash(0x423E363D6FEF8CEAi64, 0x5B3E9BDB215405F3i64); //K32GetModuleFileNameExW lookup_hash(0x52D5BB326B1FC6B2i64, 0x1C2D0172D09B7286i64); //GetWindowThreadProcessId lookup_hash(0x13FA4A203570A0A2i64, 0xB8DA7EDECE20A5DCui64); //GetWindowDisplayAffinity I do want to mention that these hashes aren’t going to be the same in different versions of the game. Also, this isn’t the only way of beating this hashing technique; these function pointers are stored in global variables; you can simply inspect them and match the virtual address of the function to one of the exported functions from all of the DLLs loaded. Ok, now we have established that TAC detects API hooking (It only checks functions that it uses, not actually checking all important APIs for hooks, just the ones it’s using). These are only here to monitor API hooking attempts that would hurt or prevent the anti-cheat from doing its job. What if there was a hooking method that bypassed their hooking detections? Debug Registers For actual cheaters trying to hook into the game, Arxan has got the code patching covered; cheaters must use non-code patching hooking methods while Arxan is present. There are a couple of these hooking methods, and I’ll list a few here: Exception hooking - Forcefully triggering an exception and handling it. Exceptions can be triggered in multiple ways. Modify a global pointer to be a nullptr or invalid memory address. Modify page access protections to trigger an access exception (Example: PAGE_NOACCESS or PAGE_GUARD). Debug registers - telling the CPU to break (throw a STATUS_SINGLE_STEP exception) on a specific instruction. These are very powerful; the CPU can break on any or all of these conditions for a given instruction address. Read Write Execute Debug registers are the easiest to use, the most popular, and the easiest to detect! Since debug registers are so popular and powerful, and completely bypass Arxan’s .text patch monitoring, this makes them the perfect hooking technique for Call of Duty games. Here’s how TAC checks for debug registers. __forceinline void ac_check_debug_registers(HANDLE thread_handle, fn callback) { CONTEXT context; context.ContextFlags = CONTEXT_FULL; if (!GetThreadContext(thread_handle, \u0026context)) { return; } if (context.Dr0 || context.Dr1 || context.Dr2 || context.Dr3) { if (GetProcessIdOfThread(thread_handle) != GetCurrentProcessId()) { callback(\"debug registers found, but not in our process\"); } else { callback(\"debug registers found inside current process\"); } // the anti-cheat would then jump to the quit functions that I wrote about a little bit further down // default will call ac_terminate_process_clear_registers // if ZwTerminateProcess was hooked it will jump to ac_close_game2_crash_zeroxzero } } // access rights that are requested __forceinline HANDLE ac_open_thread(int pid) { return OpenThread(THREAD_QUERY_INFORMATION | THREAD_GET_CONTEXT, 0, pid); } Since debug registers are in the DR0-DR3 registers, you can’t just write some custom assembly to directly read them because these registers are privileged and must be fetched by the Windows kernel or sent to the process by Windows whenever an exception occurs. ; This will throw a STATUS_PRIVILEGED_INSTRUCTION exception mov rax, dr0 ret Driver Signing Enforcement Windows has a test mode, which is designed for driver development. This will allow you to bypass the normal Windows restriction on kernel-mode drivers not having valid digital signatures. This is a protection mechanism in place to prevent bad actors from running kernel mode drivers on your system without the proper authorization. TAC will know if you have test mode enabled on Windows, via ntdll!NtQuerySystemInformation. This isn’t going to ban you directly, but this will have your account flagged. __forceinline bool is_test_signing_on() { SYSTEM_CODEINTEGRITY_INFORMATION sys_cii; sys_cii.Length = sizeof(sys_cii); NTSTATUS status = NtQuerySystemInformation(103, \u0026sys_cii, static_cast\u003cULONG\u003e(sizeof(sys_cii)), static_cast\u003cPULONG\u003e(NULL)); if (NT_SUCCESS(status)) { return !!(sys_cii.CodeIntegrityOptions \u0026 /*CODEINTEGRITY_OPTION_TESTSIGN*/ 0x2); } return false; } __forceinline void ac_check_test_signing(callback cb) { if (is_test_signing_on()) { cb(); } } Now we understand some of TAC’s anti-static analysis and debug register detection tactics. We’re going to move on to the more advanced detections implemented into TAC. How does TAC exit the process? TAC uses two ways of exiting the process; both of them clear the registers, and these are written in inline shellcode. The first method sets RCX to -1 as it calls NtTerminateProcess. TAC will not use this method if NtTerminateProcess is detected to be hooked. If NtTerminateProcess is hooked, it’ll go to the second one, which jumps to 0x0. xor rax, rax xor rbx, rbx xor rcx, rcx dec rcx xor rdx, rdx xor rsi, rsi xor rdi, rdi xor r8, r8 xor r9, r9 xor r10, r10 xor r11, r11 xor r12, r12 xor r13, r13 xor r14, r14 xor r15, r15 mov rsp, 0x0F8 jmp qword ptr [0x1B607DC7FF0] ; This is not a custom syscall setup; this is a jump to ntdll!NtTerminateProcess. spot_1B607DC7FF0: mov r10, rcx mov eax, 0x2C test byte ptr [0x7FFE0308], 1 jne NtTerminateProcess + 0x15 (0x07FFA7A3CDA75) syscall ret Here’s the second method; we can see the same register clearing, and we see a jmp. This jump goes to 0x0, which will crash the process. xor rax, rax xor rbx, rbx xor rcx, rcx xor rdx, rdx xor rsi, rsi xor rdi, rdi xor r8, r8 xor r9, r9 xor r10, r10 xor r11, r11 xor r12, r12 xor r13, r13 xor r14, r14 xor r15, r15 xor rsp, rsp xor rbp, rbp jmp qword ptr [0x27E45550036] ; value of 0x27E45550036 = 0x000000000000 These are hard to recover from since all of the important registers are cleared. The code for generating and running these shellcodes is provided here. // these are reconstructed to make it readable void ac_terminate_process_clear_registers() { const auto memory = reinterpret_cast\u003cunsigned __int64\u003e(VirtualAlloc( nullptr, 0x8000uLL, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE )); const auto proc_addr = reinterpret_cast\u003cunsigned __int64\u003e(GetProcAddress( LoadLibraryA(\"ntdll.dll\"), \"ZwTerminateProcess\" )); unsigned char terminate_process_shellcode[] = { 0x48, 0x31, 0xC0, // xor rax, rax 0x48, 0x31, 0xDB, // xor rbx, rbx 0x48, 0x31, 0xC9, // xor rcx, rcx 0x48, 0xFF, 0xC9, // dec rcx 0x48, 0x31, 0xD2, // xor rdx, rdx 0x48, 0x31, 0xF6, // xor rsi, rsi 0x48, 0x31, 0xFF, // xor rdi, rdi 0x4D, 0x31, 0xC0, // xor r8, r8 0x4D, 0x31, 0xC9, // xor r9, r9 0x4D, 0x31, 0xD2, // xor r10, r10 0x4D, 0x31, 0xDB, // xor r11, r11 0x4D, 0x31, 0xE4, // xor r12, r12 0x4D, 0x31, 0xED, // xor r13, r13 0x4D, 0x31, 0xF6, // xor r14, r14 0x4D, 0x31, 0xFF, // xor r15, r15 0x48, 0xC7, 0xC4, 0xF8, 0x00, 0x00, 0x00, // mov rsp, 0x0F8 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00 // jmp QWORD PTR [rip + 0x0] }; const auto zw_terminate_process_spot = 0x320; // write the address of ZwTerminateProcess somewhere *reinterpret_cast\u003c__int64*\u003e(memory + zw_terminate_process_spot) = proc_addr; // calculate the memory offset of where ZwTerminateProcess was written (needs to be RVA from RIP) const auto rva_addy = zw_terminate_process_spot - sizeof(terminate_process_shellcode); *reinterpret_cast\u003cDWORD*\u003e(\u0026terminate_process_shellcode[sizeof (terminate_process_shellcode) - 4]) = rva_addy; memcpy(reinterpret_cast\u003cvoid*\u003e(memory), terminate_process_shellcode, sizeof (terminate_process_shellcode)); reinterpret_cast\u003cvoid(*)()\u003e(memory)(); } void ac_close_game2_crash_zeroxzero() { const auto memory = reinterpret_cast\u003c__int64\u003e(VirtualAlloc( nullptr, 0x40uLL, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE )); memset(reinterpret_cast\u003cvoid*\u003e(memory), 0, 0x40); unsigned char zero_zero_shellcode[] = { 0x48, 0x31, 0xC0, // xor rax, rax 0x48, 0x31, 0xDB, // xor rbx, rbx 0x48, 0x31, 0xC9, // xor rcx, rcx 0x48, 0x31, 0xD2, // xor rdx, rdx 0x48, 0x31, 0xF6, // xor rsi, rsi 0x48, 0x31, 0xFF, // xor rdi, rdi 0x4D, 0x31, 0xC0, // xor r8, r8 0x4D, 0x31, 0xC9, // xor r9, r9 0x4D, 0x31, 0xD2, // xor r10, r10 0x4D, 0x31, 0xDB, // xor r11, r11 0x4D, 0x31, 0xE4, // xor r12, r12 0x4D, 0x31, 0xED, // xor r13, r13 0x4D, 0x31, 0xF6, // xor r14, r14 0x4D, 0x31, 0xFF, // xor r15, r15 0x48, 0x31, 0xE4, // xor rsp, rsp 0x48, 0x31, 0xED, // xor rbp, rbp 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00 // jmp qword ptr[rip + 0] }; // this offset will just be to memory thats already 0x00000000 *reinterpret_cast\u003cDWORD*\u003e(\u0026zero_zero_shellcode[sizeof(zero_zero_shellcode) - 4]) = 4; memcpy(reinterpret_cast\u003cvoid*\u003e(memory), zero_zero_shellcode, sizeof (zero_zero_shellcode)); reinterpret_cast\u003cvoid(*)()\u003e(memory)(); } Detecting Cheat Logging Oftentimes, internal cheaters will allocate a console using AllocConsole to print their debug logs to, or even make their menu in it using print statements. The PEB (Process Environment Block) contains information regarding the allocation of a console. The PEB contains a ton of useful information regarding the process. If you want to read more about this click here; most of this structure is undocumented, but that’ll take you to the MSDN page. The game knows that there shouldn’t ever be a console window allocated; checking for one is super simple and will catch some people who use this method of logging. Here’s the implementation. __forceinline void ac_detect_allocated_console(fn callback) { if (GetConsoleWindow() != 0 || NtCurrentPeb() -\u003eProcessParameters-\u003eConsoleHandle != 0) { callback(); } } Detecting Visuals Cheaters need to draw on the screen if they want a working ESP or even a Menu/User Interface. How do they do this? There are a few ways of drawing on the screen; the most common method for internal cheats is to hook whichever graphics API the game is using and draw their information in there. Modern Call of Duty games are made with DirectX 12. A common function to hook when wanting to draw things on DirectX is IDXGISwapChain::Present. The present function is what presents the rendered game image to the user. The idea is you add your custom data to the image before it’s presented to the user, update the image then present it to the user. How is this detected? First, we need to understand how these functions are hooked. The DirectX functions are inside of the dxgi DLL on your computer. DirectX interfaces hold vtables which will point to the functions inside of dxgi, these vtable indexes will be the same across the versions of windows. IDXGISwapChain vtable holds the present function. This can either be directly hooked, or pointer swapped. Detecting these hooks. Something that can be done is to scan the DXGI present function, but TAC doesn’t currently do this. TAC checks the present pointer in the vtable. DirectX 12 introduced command queues; whenever the game is drawing something, it’s from the command queue, a list of draw commands. This is something cheaters will also need if they want to draw. How do cheaters get this command queue? The most common method of grabbing the game’s command queue is to hook another function from the command queue interface, ID3D12CommandQueue::ExecuteCommandLists. Since this is an interface, the methods will have a this pointer passed as the first parameter; in this case, that pointer is the command queue. Cool information: Many things such as OBS Studio/Streamlabs OBS/Discords game overlay/Steams game overlay actually all do this, while Steam and Discord draw here, things like OBS studio are just here to capture the rendered image (capture the frames) and save them into your recording. This only happens if you use game capture on recording software. Cheaters can ignore the game, and simply hook into Discord/steam and draw things there if they want to. What about External Cheats? External cheats are most likely going to create an overlapped window that covers the width and height of the game window. There are a few ways to detect this; the detection methods heavily rely on Windows APIs and require more effort to implement. TAC loops through all of the windows, checking their window style for WS_EX_LAYERED using GetWindowLongA; once it finds that, it then compares that window’s rect with the game rect using GetWindowRect. After all of that, if the window is over the game’s rect and it is a layered window, the hwnd to that window will be cached, which will later be used for many string checks. This stores a bunch of information and uploads it to their servers. Here we can see how that works. GetWindowRect(hwnd, \u0026output_rect); if (output_rect.right \u003e= game_rect_7FF61BBA2F50.left \u0026\u0026 output_rect.left \u003c= game_rect_7FF61BBA2F50.right \u0026\u0026 output_rect.bottom \u003e= game_rect_7FF61BBA2F50.top \u0026\u0026 output_rect.top \u003c= game_rect_7FF61BBA2F50.bottom) { min_value = get_min_value(output_rect.left, game_rect_7FF61BBA2F50.left); greater_value = get_greater_value(output_rect.right, game_rect_7FF61BBA2F50.right); v193 = get_min_value(output_rect.top, game_rect_7FF61BBA2F50.top); v195 = get_greater_value(output_rect.bottom, game_rect_7FF61BBA2F50.bottom); v76 = (float)((v193 - v195) * (greater_value - min_value)) / (float)((game_rect_7FF61BBA2F50.top - game_rect_7FF61BBA2F50.bottom) * (game_rect_7FF61BBA2F50.right - game_rect_7FF61BBA2F50.left)); if (v76 \u003e= 0.5 \u0026\u0026 cached_window_count \u003c 8) cached_windows[cached_window_count++] = hwnd; } RECT game_rect_7FF61BBA2F50; game_rect_7FF61BBA2F50 RECT \u003c0, 0, 780h, 438h\u003e; We can see 0x780 and 0x438, which represent 1920 by 1080, which was my screen size. Okay, so we know the windows are cached. Now what? The cached list is handled in another function that checks the window text and its class names. TAC queries the window text using GetWindowTextW. TAC queries the window class name using GetClassNameA. Cheat developers can hide their overlapping windows from recording software, and screenshot tools using SetWindowDisplayAffinity with WDA_EXCLUDEFROMCAPTURE. This is checked by TAC, and it’s saved into the buffer that will be uploaded to their servers later. ac_fmt_sprint(v1035, 32LL, \"%lu\", display_affinity); There are a couple more things related to the window that are uploaded as well. The normal window style is also checked; you can find more here. TAC checks that the window is visible first before any more processing happens on it. TAC also stores the list of modules, including the exe name of the overlapping window. When you do anything in Windows to another process, you need to have permission; Windows has an API that will let you request permission from the system. OpenProcess HANDLE process_handle = OpenProcess(0x410, 0LL, pid); The first parameter in OpenProcess is the access desired, since this is a bitmask our reversing software will just show us 0x410 by default, but that doesn’t do us any good! This can be figured out with some IDA magic. Creating a bitmask structure in IDA Pro and setting that as the function declaration’s first parameter helps us out. // these are taken from https://learn.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights enum __bitmask process_access_flags { PROCESS_TERMINATE = 0x1, PROCESS_CREATE_THREAD = 0x2, PROCESS_SET_SESSIONID = 0x4, PROCESS_VM_OPERATION = 0x8, PROCESS_VM_READ = 0x10, PROCESS_VM_WRITE = 0x20, PROCESS_DUP_HANDLE = 0x40, PROCESS_CREATE_PROCESS = 0x80, PROCESS_SET_QUOTA = 0x100, PROCESS_SET_INFORMATION = 0x200, PROCESS_QUERY_INFORMATION = 0x400, PROCESS_SUSPEND_RESUME = 0x800, PROCESS_QUERY_LIMITED_INFORMATION = 0x1000, PROCESS_SET_LIMITED_INFORMATION = 0x2000, }; Here’s the resulting code we get from IDA. HANDLE handle = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, 0LL, pid); As you can see, TAC wants to read the overlapping process’ virtual memory, and it wants to query information about the process. This is the access level you would expect for enumerating process modules. example. The first thing TAC does with this handle is call K32EnumProcessModules. After that, TAC loops through the process modules and gathers the name of each using K32GetModuleFileNameExW. Then the strings are encrypted and stored into the encryption buffer. Here’s what the majority of the code looks like. void ac_cached_window(HWND hwnd) { if (hwnd == game_hwnd) { return; } const auto is_visible = (GetWindowLongA(hwnd, GWL_STYLE) \u0026 WS_VISIBLE) != 0; if (!is_visible) { return; } const auto window_style = GetWindowLongA(hwnd, GWL_EXSTYLE); const auto is_top_most = (window_style \u0026 WS_EX_TOPMOST) != 0; const auto is_layered_window = (window_style \u0026 WS_EX_LAYERED) != 0; if (!is_top_most \u0026\u0026 !is_layered_window) { return; } RECT output_rect; GetWindowRect(hwnd, \u0026output_rect); if (output_rect.right \u003e= game_rect.left \u0026\u0026 output_rect.left \u003c= game_rect.right \u0026\u0026 output_rect.bottom \u003e= game_rect.top \u0026\u0026 output_rect.top \u003c= game_rect.bottom) { const auto min_value_x1 = min(output_rect.left, game_rect.left); const auto max_value_x2 = max(output_rect.right, game_rect.right); const auto min_value_y1 = min(output_rect.top, game_rect.top); const auto max_value_y2 = max(output_rect.bottom, game_rect.bottom); const auto difference_center = static_cast\u003cfloat\u003e((min_value_y1 - max_value_y2) * (max_value_x2 - min_value_x1)) / static_cast\u003cfloat\u003e((game_rect.top - game_rect.bottom) * (game_rect.right - game_rect.left)); if (difference_center \u003e= 0.5 \u0026\u0026 cached_window_count \u003c 8) { cached_windows[cached_window_count++] = hwnd; } } } void ac_log_cached_window_process(unsigned int pid, char* encrypted_string_buffer) { const HANDLE process_handle = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, 0LL, pid); if (process_handle == INVALID_HANDLE_VALUE) { return; } DWORD lpcbNeeded = 0; HMODULE modules[1024]; if (K32EnumProcessModules(process_handle, modules, 0x2000LL, \u0026lpcbNeeded)) { for (auto current_module_index = 0; ; ++current_module_index) { if (current_module_index \u003e= lpcbNeeded / 8uLL) break; const auto current_module = modules[current_module_index]; WCHAR wide_module_name[260]; if (K32GetModuleFileNameExW(process_handle, current_module, wide_module_name, 260LL)) { char ascii_module_name[1568]; WideCharToMultiByte(65001LL, 0LL, wide_module_name, 0xFFFFFFFFLL, ascii_module_name, 1560, 0LL, 0LL); ac_string_encrypt(encrypted_string_buffer, ascii_module_name); } } } CloseHandle(process_handle); } void ac_handle_window(HWND hwnd, char* encrypted_string_thing) { // tons of string encryption stuff all over here wchar_t window_text_WIDE[512]{0}; GetWindowTextW(hwnd, window_text_WIDE, 512LL); char window_text_asci[3072]{0}; WideCharToMultiByte(65001LL, 0LL, window_text_WIDE, 0xFFFFFFFFLL, window_text_asci, 3072, 0LL); char window_class_name[256]{0}; GetClassNameA(hwnd, window_class_name, 256LL); RECT window_rect; GetWindowRect(hwnd, \u0026window_rect); const auto window_gwl_style = GetWindowLongA(hwnd, GWL_STYLE); const auto window_gwl_ex_style = GetWindowLongA(hwnd, GWL_EXSTYLE); DWORD display_affinity = 0; GetWindowDisplayAffinity(hwnd, \u0026display_affinity); // adds these strings to the buffer directly ac_string_encrypt(encrypted_string_thing, window_text_asci); ac_string_encrypt(encrypted_string_thing, window_class_name); // store info ac_fmt_sprint_encrypt(encrypted_string_thing, 32, \"%li\", window_rect.left); ac_fmt_sprint_encrypt(encrypted_string_thing, 32, \"%li\", window_rect.top); ac_fmt_sprint_encrypt(encrypted_string_thing, 32, \"%li\", window_rect.right); ac_fmt_sprint_encrypt(encrypted_string_thing, 32, \"%li\", window_rect.bottom); ac_fmt_sprint_encrypt(encrypted_string_thing, 32, \"%li\", window_gwl_style); ac_fmt_sprint_encrypt(encrypted_string_thing, 32, \"%li\", window_gwl_ex_style); ac_fmt_sprint_encrypt(encrypted_string_thing, 32, \"%lu\", display_affinity); DWORD pid = 0; if (GetWindowThreadProcessId(hwnd, \u0026pid)) { ac_log_cached_window_process(pid, encrypted_string_thing); } else { // assuming encrypted failure message, logs the current process id instead. } } void ac_process_cached_windows() { // lots of encryption stuff here char* encrypted_string_thing = (char*)malloc(0x40000); for (unsigned int i = 0; i \u003c cached_window_count; ++i) { // lots of encryption stuff here, and ptr modifications ac_handle_window(cached_windows[i], encrypted_string_thing); } // lots of encryption stuff here, and ptr modifications ac_send_data_to_server(encrypted_string_thing); free(encrypted_string_thing); // lots of encryption stuff here } Example data. TAC will format in json with modules hashed. NVIDIA GeForce Overlay - Window Text CEF-OSC-WIDGET - Window Class 0 - Left 0 - Top 2560 - Right 1440 - Bottom -1811939328 - window_gwl_style 134742184 - window_gwl_ex_style 0 - display_affinity Loaded Modules: C:\\Program Files\\NVIDIA Corporation\\NVIDIA GeForce Experience\\NVIDIA Share.exe C:\\Windows\\SYSTEM32\\ntdll.dll C:\\Windows\\System32\\KERNEL32.DLL C:\\Windows\\System32\\KERNELBASE.dll C:\\Windows\\System32\\SHLWAPI.dll C:\\Windows\\System32\\msvcrt.dll C:\\Windows\\System32\\WS2_32.dll C:\\Windows\\SYSTEM32\\urlmon.dll C:\\Windows\\System32\\RPCRT4.dll C:\\Windows\\System32\\CRYPT32.dll C:\\Windows\\System32\\ucrtbase.dll C:\\Windows\\System32\\USER32.dll C:\\Windows\\System32\\win32u.dll C:\\Windows\\SYSTEM32\\iertutil.dll C:\\Windows\\System32\\GDI32.dll C:\\Windows\\SYSTEM32\\srvcli.dll C:\\Windows\\System32\\combase.dll C:\\Windows\\System32\\gdi32full.dll C:\\Windows\\System32\\msvcp_win.dll C:\\Windows\\System32\\sechost.dll C:\\Windows\\SYSTEM32\\netutils.dll C:\\Windows\\System32\\advapi32.dll C:\\Windows\\System32\\SHELL32.dll C:\\Windows\\System32\\shcore.dll C:\\Windows\\System32\\ole32.dll C:\\Windows\\System32\\OLEAUT32.dll C:\\Program Files\\NVIDIA Corporation\\NVIDIA GeForce Experience\\libcef.dll C:\\Windows\\System32\\WINTRUST.dll C:\\Windows\\SYSTEM32\\wlanapi.dll C:\\Windows\\System32\\COMDLG32.dll C:\\Windows\\SYSTEM32\\dxgi.dll C:\\Windows\\SYSTEM32\\IPHLPAPI.DLL C:\\Windows\\System32\\IMM32.dll C:\\Windows\\SYSTEM32\\UxTheme.dll C:\\Windows\\SYSTEM32\\CRYPTUI.dll C:\\Windows\\SYSTEM32\\MSIMG32.dll C:\\Windows\\SYSTEM32\\WINMM.dll C:\\Windows\\SYSTEM32\\d3d11.dll C:\\Windows\\SYSTEM32\\Secur32.dll C:\\Windows\\SYSTEM32\\NETAPI32.dll C:\\Windows\\SYSTEM32\\d3d9.dll C:\\Windows\\System32\\bcrypt.dll C:\\Windows\\SYSTEM32\\OLEACC.dll C:\\Windows\\SYSTEM32\\dwmapi.dll C:\\Windows\\SYSTEM32\\WTSAPI32.dll C:\\Program Files\\NVIDIA Corporation\\ShadowPlay\\nvspapi64.dll C:\\Windows\\SYSTEM32\\ntmarta.dll C:\\Program Files\\NVIDIA Corporation\\NvContainer\\libprotobuf.dll C:\\Windows\\SYSTEM32\\MSVCP140.dll C:\\Windows\\SYSTEM32\\VCRUNTIME140.dll C:\\Windows\\SYSTEM32\\VCRUNTIME140_1.dll C:\\Program Files\\NVIDIA Corporation\\ShadowPlay\\IpcCommon64.dll C:\\Program Files\\NVIDIA Corporation\\NvContainer\\MessageBus.dll C:\\Windows\\System32\\NSI.dll C:\\Windows\\System32\\MSCTF.dll C:\\Windows\\system32\\NLAapi.dll C:\\Windows\\SYSTEM32\\dhcpcsvc6.DLL C:\\Windows\\SYSTEM32\\DNSAPI.dll C:\\Windows\\SYSTEM32\\WINSTA.dll C:\\Windows\\System32\\clbcatq.dll C:\\Windows\\System32\\MMDevApi.dll C:\\Windows\\SYSTEM32\\mscms.dll C:\\Windows\\SYSTEM32\\ColorAdapterClient.dll C:\\Windows\\System32\\Windows.UI.dll C:\\Windows\\System32\\WindowManagementAPI.dll C:\\Windows\\System32\\TextInputFramework.dll C:\\Windows\\System32\\InputHost.dll C:\\Windows\\SYSTEM32\\wintypes.dll C:\\Windows\\SYSTEM32\\twinapi.appcore.dll C:\\Windows\\System32\\CoreMessaging.dll C:\\Windows\\System32\\CoreUIComponents.dll C:\\Windows\\system32\\twinapi.dll C:\\Windows\\system32\\apphelp.dll C:\\Program Files\\NVIDIA Corporation\\NVIDIA GeForce Experience\\cef\\common\\OverClocking.dll C:\\Program Files\\NVIDIA Corporation\\NVIDIA GeForce Experience\\dependencies\\CrimsonUtil.dll C:\\Windows\\SYSTEM32\\POWRPROF.dll C:\\Windows\\SYSTEM32\\UMPDC.dll C:\\Program Files\\NVIDIA Corporation\\NVIDIA GeForce Experience\\cef\\share\\MessageBusRouter.dll C:\\Windows\\SYSTEM32\\nvapi64.dll C:\\Windows\\System32\\SETUPAPI.dll C:\\Windows\\SYSTEM32\\FvSDK_x64.dll C:\\Windows\\system32\\mswsock.dll C:\\Windows\\System32\\rasadhlp.dll C:\\Windows\\System32\\fwpuclnt.dll C:\\Windows\\SYSTEM32\\xinput1_4.dll C:\\Windows\\SYSTEM32\\dxcore.dll Cheat Engine is one of the easiest programs to detect, and it’s really because of how virtual memory works in Windows. Whenever a program wants to allocate virtual memory, they’re going to call the Windows API VirtualAlloc. This memory is allocated, but it’s not backed by any physical memory yet because it hasn’t been accessed, this is a feature in the Windows kernel. This allows the game to allocate virtual memory with that function and never use it. After Cheat Engine scans the process, it will hit this virtual memory, which will then make that memory valid, because now it has been accessed by Cheat Engine. Here’s how that detection would look, and this is for any memory scanner, not just Cheat Engine. This will also include the Process Hacker memory tab. void run_honey_pot_violation(fn callback) { // the protection won't matter const auto allocated_virtual_memory = VirtualAlloc(nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); PSAPI_WORKING_SET_EX_INFORMATION working_set_information; memset(\u0026working_set_information, 0, sizeof(working_set_information)); working_set_information.VirtualAddress = allocated_virtual_memory; while (true) { // query about the current process const auto did_it_work = K32QueryWorkingSetEx((HANDLE)-1, \u0026working_set_information, sizeof(working_set_information)); if (did_it_work \u0026\u0026 (working_set_information.VirtualAttributes.Flags \u0026 1) != 0 ) { printf(\"XD CHEAT ENGINE DETECTED HAHAHAH\\n\"); callback(); } // just an example timer, not what the game does Sleep(1000); } } Anti-Sig Scanning Game hackers love signatures; whenever the game updates, no problem the cheat will automatically update. Treyarch had a pretty interesting idea. Their idea is to create a function that’ll never be called again; this function will call another function that protects the return address with PAGE_NOACCESS. Since this will never be reached again by the program, this isn’t an issue. The way sig scanners work is they attempt to match a signature by reading bytes in the executable. It’s extremely slow to query each byte you are going to be reading, which is why this is such a good method. You can read more about VirtualProtect here. It’s not undefeatable, but it’s something that’s there and will probably give most a hard time. void enable_anti_sig_scanning(fn callback) { DWORD old = 0; const auto cpu_stamp = __rdtsc(); unsigned __int64 protect_location = reinterpret_cast\u003cunsigned __int64\u003e(_ReturnAddress()); if ( (protect_location \u0026 cpu_stamp) + (protect_location | cpu_stamp) - (protect_location + cpu_stamp) ) { if ( (cpu_stamp \u0026 1) == 0 ) { protect_location = (protect_location + 5120) \u0026 0xFFFFFFFFFFFFF000uLL; } if (!VirtualProtect(reinterpret_cast\u003cvoid*\u003e(protect_location), 1, PAGE_NOACCESS, \u0026old) ) { // this is here just to detect someone hooking VirtualProtect and returning false on PAGE_NOACCESS callback(); } } } Here’s a good example of code that’ll never be reached again. (The program will never reach the top of the main function again.) int main(int argc, const char** argv) { enable_anti_sig_scanning(); scan_pattern(GetModuleHandleA(nullptr), \"xxsaj3\"); // pretend this is a signature that's far into the executable } The scan pattern function will start at the base of the executable and continue to the end until it finds the pattern it wants, ultimately hitting the PAGE_NOACCESS memory, and crashing the process. Anti-Debugging TAC has a simple anti-debug check; but remember, Arxan is still running, so they still have all of those anti-debugging tricks. How does TAC prevent debugging? TAC loops through all threads in the current process by using CreateToolHelpSnapshot32 with SnapThread passed and checks the thread for a DebugObject, which is going to be present if a debugger is running. void ac_loop_threads_debug(fn callback) { HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, GetCurrentProcessId()); THREADENTRY32 te32{}; te32.dwSize = sizeof(te32); do { if (te32.th32OwnerProcessID != GetCurrentProcessId()) { continue; } const HANDLE thread_handle = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); if (thread_handle) { HANDLE debug_object_handle = INVALID_HANDLE_VALUE; ULONG ret_length = 0; THREAD_BASIC_INFORMATION thread_basic_information; if (!NtQueryInformationThread(thread_handle, 0, \u0026thread_basic_information, sizeof(thread_basic_information), \u0026ret_length)) { if (thread_basic_information.TebBaseAddress) { if (thread_basic_information.TebBaseAddress-\u003eDbgSsReserved[1]) { debug_object_handle = HANDLE(thread_basic_information.TebBaseAddress-\u003eDbgSsReserved[1]); } } } if (debug_object_handle != INVALID_HANDLE_VALUE) { callback(); } CloseHandle(thread_handle); } } while (Thread32Next(snapshot, \u0026te32)); CloseHandle(snapshot); } A weird anti-debug trick. It throws an access violation by writing to invalid memory; if the code ever gets past the exception, a debugger got past it or handled the exception properly. void ac_exception_anti_debug(fn callback) { // this is writing to invalid memory and will throw an access violation __sidt((void *)0xFFFFFF8000000900LL); callback(); // this should never be reached } Standard API check __forceinline void ac_check_remote_debugger(callback cb) { BOOL dbg = false; if (CheckRemoteDebuggerPresent((HANDLE)-1, \u0026dbg)) { if (dbg) { cb(); // the process will close } } } ThreadHideFromDebugger sends exceptions to the process instead of the debugger which means whenever the debugger attempts to pause the process, a STATUS_BREAKPOINT exception will go off which will close the process. The best part about this is you can not unset the ThreadHideFromDebugger flag once its been set from user mode, this tactic runs in their tls callback which is before the entry point of the exe. ```c++ __forceinline void ac_hide_current_thread() { char use_ThreadHideFromDebugger = 1; nt_set_information_thread((HANDLE)-2, ThreadHideFromDebugger, (void**)\u0026use_ThreadHideFromDebugger, 0); } Monitoring Network Traffic This is a super cool detection method used for some cheats, and don’t be alarmed by this; they do not store any of your active connections; they are only looking for a very specific check. A cheater can write shellcode into the game process that starts a network server inside of the game process on the local network, then the cheater can have their external application send and receive information to this local server, kind of like a local command and control center. Here’s how it’s implemented. // custom tac struct struct tcp_entry { DWORD OwningPid; DWORD LocalAddr; DWORD RemoteAddr; DWORD LocalPort; DWORD RemotePort; }; void ac_detect_local_command_center(fn callback) { // WSA must be the first call before any other Windows socket functions can be called successfully WSAData data; WSAStartup(MAKEWORD(2, 2), \u0026data); bool successfully_looped_tcp_table = false; __int64 tcp_table_container[3]{}; // allocate the table auto table = static_cast\u003cPMIB_TCPTABLE2\u003e(malloc(sizeof(MIB_TCPTABLE2))); // get the tcp table size, the first call is expected to fail ULONG size; auto result = GetTcpTable2(table, \u0026size, 1); if (result == ERROR_INSUFFICIENT_BUFFER) { free(table); table = static_cast\u003cPMIB_TCPTABLE2\u003e(malloc(size)); } // store the tcp table into our newly allocated buffer result = GetTcpTable2(table, \u0026size, 1); if (!result) // it returns NO_ERROR which is 0x0 on success { for (auto i64 = 0; i64 \u003c static_cast\u003csigned int\u003e(table-\u003edwNumEntries); ++i64) { // store each entry PMIB_TCPROW2 tableptr = \u0026table-\u003etable[i64]; if (!static_cast\u003cunsigned __int8\u003e(add_tcp_entry(tableptr, tcp_table_container))) break; } successfully_looped_tcp_table = true; } // memory is no longer needed free(table); if (successfully_looped_tcp_table) { // get the current process id const auto current_process_id = GetCurrentProcessId(); tcp_entry* tcp_table; init_tcp_table_entry(\u0026tcp_table); tcp_entry* dummy; // loop the tcp table for (tcp_table = *get_tcp_table_entry(tcp_table_container, \u0026dummy);; increment_tcp_table_entry(\u0026tcp_table)) { auto next_tcp_entry = get_next_tcp_entry(tcp_table_container, \u0026dummy); // break if we are just comparing the same entry if (!tcp_entires_different(\u0026tcp_table, next_tcp_entry)) break; auto tcp_ptr = get_tcp_ptr(\u0026tcp_table); // verify the entry was created by the current process if (tcp_ptr-\u003eOwningPid == current_process_id) { // get the other entries tcp_entry* entry2; init_tcp_table_entry(\u0026entry2); for (entry2 = *get_tcp_table_entry(tcp_table_container, \u0026dummy); ; increment_tcp_table_entry(\u0026entry2)) { auto next_entry2 = get_next_tcp_entry(tcp_table_container, \u0026dummy); // we have relooped back to the start, break if (!tcp_entires_different(\u0026entry2, next_entry2)) break; auto entry2_tcp_ptr = get_tcp_ptr(\u0026entry2); /* if the entrys port and the one found inside the current process match and they aren't owned by the same process */ if (entry2_tcp_ptr-\u003eLocalPort == tcp_ptr-\u003eRemotePort \u0026\u0026 entry2_tcp_ptr-\u003eOwningPid != tcp_ptr-\u003eOwningPid) { // flagged callback(); } } } } } } Encrypted Custom Syscalls Whenever you look at exported APIs in ntdll, you’ll notice most of them do a syscall. A syscall is what moves over into the kernel, where the actual implementation of the function is. This is what a syscall stub looks like. IMO this is the coolest feature TAC has! ; rcx is used by the kernel as a jump back location for the syscall instruction. ; rcx needs to be stored so the kernel can use it. mov r10, rcx mov eax, 0x11B ; eax holds the syscall index which the kernel looks up in the table of system calls syscall ret Writing your own syscall stub has a purpose. Whenever a user-mode cheat hooks those ntdll functions that syscall, it’ll work, but their hooks can be bypassed very easily if the anti-cheat just calls the syscall instruction with eax set to the same syscall index as the normal function. Syscalls are vulnerable to instrumentation callbacks; these are callbacks coded into Windows, and they will work on every single user-mode process. These callbacks will catch every syscall instruction and every exception. Just an FYI, instrumentation callbacks are called AFTER the syscall; their return address will be right after the syscall instruction. This would normally allow cheaters to easily see where every syscall is coming from since all of the functions using it are just exported in ntdll. It fails because the cheater will see a syscall from a random ntdll function, rather than the anti-cheat code. If you want to see instrumentations in action, you can do so here. Let’s take a look at TAC’s custom syscall stub. At a quick glance, this is very confusing and hard to figure out statically. They even make it confusing to see what memory is being written to. some_random_text_encrypted_func[0] = ((unsigned __int64)\u0026loc_7FF60E12D0B0 + 4095) \u0026 0xFFFFFFFFFFFFF000uLL; It turned out to be pretty simple to figure this out and understand exactly how it works. That memory being written to is actually a large chunk allocated in the .text section that they just virtual protect for write/execute rights. Now we could spend all day in our XOR calculator and try to build the byte array of these XOR encrypted instructions ourselves. Or we could just let the computer do it…. This was pretty much just copy and paste from IDA Pro, all I did was allocate my own memory here. auto v3867 = 12288LL; LABEL_1798: auto v2168 = __rdtsc() % (v3867 - 3); auto v1328 = v2168; auto ac_NtReadFile_1 = (char*)GetProcAddress(GetModuleHandleA(\"ntdll\"), \"NtReadFile\"); __int64 i67 = 0; for (i67 = 0LL; ; ++i67) { if (v1328 + i67 \u003e= v3867) goto LABEL_1798; if (ac_NtReadFile_1[i67 + 1 + v1328] == 5 \u0026\u0026 (unsigned __int8)ac_NtReadFile_1[i67 + 2 + v1328] == 195 \u0026\u0026 ac_NtReadFile_1[i67 + v1328] == 15) { break; } } auto nt_read_file_syscall_instruction = \u0026ac_NtReadFile_1[i67 + v1328]; volatile __int64 syscall_stub_memory = (__int64)VirtualAlloc(nullptr, 0x4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); __int64 syscall_index = 0; // this is going to be the syscall index; it's 0 here just while I'm explaining auto offset_that_doesnt_matter = 0x50; // it's just here to add to the confusion; this can be any number above 4 *(_QWORD*)(syscall_stub_memory + offset_that_doesnt_matter + 28LL) = (__int64)nt_read_file_syscall_instruction; *(_QWORD*)(syscall_stub_memory + offset_that_doesnt_matter + 20LL) = 0x63B4B73DD1E509A9LL; *(_QWORD*)(syscall_stub_memory + offset_that_doesnt_matter + 20LL) ^= 0x7FA6B73DD1E72C56uLL; *(_DWORD*)(syscall_stub_memory + offset_that_doesnt_matter + 12LL) = syscall_index; *(_DWORD*)(syscall_stub_memory + offset_that_doesnt_matter + 8LL) = -997864955; *(_DWORD*)(syscall_stub_memory + offset_that_doesnt_matter + 8LL) ^= 0x7CEB6A07u; *(_DWORD*)(syscall_stub_memory + offset_that_doesnt_matter) = -1006268688; *(_DWORD*)(syscall_stub_memory + offset_that_doesnt_matter) ^= 0x62ADC0BFu; *(_DWORD*)(syscall_stub_memory + offset_that_doesnt_matter + 4LL) = -1637542171; *(_DWORD*)(syscall_stub_memory + offset_that_doesnt_matter + 4LL) ^= 0x75B49DA9u; *(_DWORD*)(syscall_stub_memory + offset_that_doesnt_matter + 16LL) = 109211239; *(_DWORD*)(syscall_stub_memory + offset_that_doesnt_matter + 16LL) ^= 0xBBCA6C8C; auto syscall_stub_ptr = (__int64(__fastcall*)(_QWORD, _QWORD, _QWORD, _QWORD))(syscall_stub_memory + offset_that_doesnt_matter + 4LL); printf(\"memory allocated: %p\\n\", syscall_stub_ptr); getchar(); Inspecting this memory address reveals the unencrypted shellcode and we can see the standard syscall stub here. Starting with the “mov r10, rcx” instruction. Following that jmp after the mov, 0x2C is the NtTerminateProcess syscall index for my Windows version, and we can see that being moved into eax. Following the jump after mov eax, this is where the address of the syscall instruction comes in; it’s just a jump to it. Syscall instruction. We can take a look at where this syscall instruction is located, just to verify that it’s a bit random. And just to double-check, if we run the code again, our syscall instruction location will change! This is a lot, so let’s recap quickly. Why would you use a custom syscall stub? This will completely bypass cheaters hooking ntdll functions. What’s going on with the NtReadFile stuff? TAC is actually searching for the syscall instruction; their encrypted syscall stub is designed to actually fake where syscalls are coming from, the CPU time is the RNG factor. Example: Someone monitoring the process will see that a syscall happened from NtReadFile, so they’ll do some inspecting and try to cover up anything NtReadFile would expose of theirs, but the syscall wasn’t even NtReadFile. The actual syscall could have been anything; the cheater will never know unless they’re able to inspect the eax register after the syscall (which should be cleared out and replaced with the NTSTATUS code). This is really cool; an attacker won’t have any way of knowing what syscall instruction to monitor. A good way to monitor these would be preventing page execute protections, and looking at the exception, this is what the stub looks like in Ida Pro. Just for bonus points, I’ve recreated their syscalling method. __forceinline int get_syscall_index(unsigned __int64 address) { return *(int*)\u0026reinterpret_cast\u003cchar*\u003e(address)[4]; } __forceinline __int64 get_syscall_instruction_address(unsigned __int64 func) { const auto distance = 12288LL; LABEL_1798: const auto starting_distance = __rdtsc() % (distance - 3); auto ntdll_exported_func = reinterpret_cast\u003cchar*\u003e(func); __int64 syscall_instruction_spot = 0; for (syscall_instruction_spot = 0LL; ; ++syscall_instruction_spot) { if (starting_distance + syscall_instruction_spot \u003e= distance) goto LABEL_1798; if (ntdll_exported_func[syscall_instruction_spot + 1 + starting_distance] == 5 \u0026\u0026 (unsigned __int8)ntdll_exported_func[syscall_instruction_spot + 2 + starting_distance] == 195 \u0026\u0026 ntdll_exported_func[syscall_instruction_spot + starting_distance] == 15) { break; } } return reinterpret_cast\u003cunsigned __int64\u003e(\u0026ntdll_exported_func[syscall_instruction_spot + starting_distance]); } __forceinline void* generate_syscall_stub(unsigned __int64 syscall_instruction, const int syscall_index, void** base, int* size) { if (base == nullptr || size == nullptr) { return nullptr; } *size = 0x4096; auto offset = rand() % (*size - 0x40); // using virtual allocated memory just for the example, game has a .text blob allocated for this volatile __int64 syscall_stub_memory = reinterpret_cast\u003c__int64\u003e(VirtualAlloc(nullptr, *size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)); *(_QWORD*)(syscall_stub_memory + offset + 28LL) = (__int64)syscall_instruction; *(_QWORD*)(syscall_stub_memory + offset + 20LL) = 0x63B4B73DD1E509A9LL; *(_QWORD*)(syscall_stub_memory + offset + 20LL) ^= 0x7FA6B73DD1E72C56uLL; *(_DWORD*)(syscall_stub_memory + offset + 12LL) = syscall_index; *(_DWORD*)(syscall_stub_memory + offset + 8LL) = -997864955; *(_DWORD*)(syscall_stub_memory + offset + 8LL) ^= 0x7CEB6A07u; *(_DWORD*)(syscall_stub_memory + offset) = -1006268688; *(_DWORD*)(syscall_stub_memory + offset) ^= 0x62ADC0BFu; *(_DWORD*)(syscall_stub_memory + offset + 4LL) = -1637542171; *(_DWORD*)(syscall_stub_memory + offset + 4LL) ^= 0x75B49DA9u; *(_DWORD*)(syscall_stub_memory + offset + 16LL) = 109211239; *(_DWORD*)(syscall_stub_memory + offset + 16LL) ^= 0xBBCA6C8C; *base = reinterpret_cast\u003cvoid*\u003e(syscall_stub_memory); return reinterpret_cast\u003cvoid*\u003e(syscall_stub_memory + offset + 4LL); } __forceinline void free_syscall_stub(void* base, int size) { memset(base, 0, size); VirtualFree(base, 0, MEM_RELEASE); } template\u003ctypename... Params\u003e __forceinline NTSTATUS spoof_syscall(unsigned __int64 exported_ntdll_function, unsigned __int64 function_to_call, Params... params) { void* base_address_of_stub = nullptr; int stub_size = 0; const auto nt_syscall_instruction = get_syscall_instruction_address(exported_ntdll_function); const auto syscall_index = get_syscall_index(function_to_call); void* stub = generate_syscall_stub(nt_syscall_instruction, syscall_index, \u0026base_address_of_stub, \u0026stub_size); NTSTATUS result = reinterpret_cast\u003cNTSTATUS(__fastcall*)(Params...)\u003e(stub)(params...); free_syscall_stub(base_address_of_stub, stub_size); return result; } __forceinline void terminate_process() { const auto syassasd = reinterpret_cast\u003cunsigned __int64\u003e(GetProcAddress(LoadLibraryA(\"ntdll\"), \"NtTerminateProcess\")); const auto spoof_start = reinterpret_cast\u003cunsigned __int64\u003e(GetProcAddress(LoadLibraryA(\"ntdll\"), \"NtOpenFile\")); spoof_syscall(spoof_start, syassasd, static_cast\u003cHANDLE\u003e(-1), 1337); } int main(int argc, const char** argv) { terminate_process(); } Let’s test this just to make sure. We can see this is working exactly how it should! Again, this is clever and even more effective; cheaters will have no clue which syscall instruction to watch out for. Detecting Anti-Debugger-Hiding Attempts It’s common for anti-debugging or anti-cheat threads to set ThreadHideFromDebugger to true. Whenever a thread has ThreadHideFromDebugger set, any exceptions thrown from that thread will skip past a debugger and crash the process or be handled in the process’s structured exception handling. Which means this flag is pretty important, and you want to make sure someone isn’t spying on your activity. TAC has a pretty interesting approach to detecting hooks for this. To set ThreadHideFromDebugger, the API NtSetInformationThread must be called. Cheaters can hook this and just return TRUE whenever ThreadHideFromDebugger is being requested. This will make the anti-cheat think it has been successfully hidden even though nothing happened. This method detects poorly made hooks. #define ThreadHideFromDebugger 17 #define NT_SUCCESS(Status) (((NTSTATUS)(Status)) \u003e= 0) __forceinline void ac_detect_hidden_thread(callback cb) { HANDLE current_thread_handle = (HANDLE)-2; char use_ThreadHideFromDebugger = 0; // this call will fail because NtSetInformationThread returns // STATUS_INFO_LENGTH_MISMATCH if the length parameter is set // if it doesn't fail, then this function has been poorly hooked NTSTATUS query_result_1 = nt_set_information_thread( current_thread_handle, ThreadHideFromDebugger, (void**)\u0026use_ThreadHideFromDebugger, 1); if (NT_SUCCESS(query_result_1)) { printf(\"fake call passed\\n\"); cb(); } // this should return 0 always // when running under a debugger with ScyllaHide, this returns 0xC000005. NTSTATUS query_result_2 = nt_set_information_thread(current_thread_handle, ThreadHideFromDebugger, 0LL, 0LL); if (query_result_2 \u003c 0) { printf(\"second call failed\\n\"); cb(); } // this will catch hooks that do not check the size properly // NtQueryInformationThread expects the size to be 1, not 4. // 4 is sizeof(BOOL) vs sizeof(bool), which is 1. NTSTATUS query_result_3 = nt_query_information_thread( current_thread_handle, ThreadHideFromDebugger, (void**)\u0026use_ThreadHideFromDebugger, 4LL, NULL); if (NT_SUCCESS(query_result_3)) { printf(\"third call succeeded\\n\"); cb(); } // this call just passes a fake handle to check // for a hook returning success whenever ThreadHideFromDebugger is passed HANDLE fake_handle = (HANDLE)__rdtsc(); NTSTATUS query_result_4 = nt_set_information_thread(fake_handle, ThreadHideFromDebugger, 0LL, 0LL); if (NT_SUCCESS(query_result_3)) { printf(\"fourth call succeeded\\n\"); cb(); } } This is the result when running under x64dbg with ScyllaHide. And this is the result without a debugger and without ScyllaHide. Create Remote Thread Blocking TAC installs an exception handler that just calls TerminateThread on the STATUS_PRIVILEGED_INSTRUCTION exception code. There’s a good reason for this; when cheaters manually map their DLL, they need a way to get the remote process to actually run the shellcode they wrote. One of the most common ways of doing this is CreateRemoteThread, which just allows the cheater to have a newly created thread that immediately executes their shellcode. How is it detected?: TLS callbacks are callbacks that can be planted inside of a Windows PE file; these callbacks are called before the thread’s entry point whenever a thread is created. Here’s how that works; keep in mind that we are running in the current thread context of the newly created thread. ; this isn't exactly how the game does this ; anyways, this will still raise the STATUS_PRIVILEGED_INSTRUCTION exception. PUBLIC _priv_ins_exx .code _priv_ins_exx PROC mov rax, dr0 ; dr0 is privileged and we do not have access _priv_ins_exx ENDP END LONG WINAPI ac_vectored_handler(EXCEPTION_POINTERS* exptrs) { // this code is running in the same thread as the TLS callback if (exptrs-\u003eExceptionRecord-\u003eExceptionCode == STATUS_PRIVILEGED_INSTRUCTION) { // terminate the current thread TerminateThread(NtCurrentThread(), 1); return 0; } } VOID WINAPI tls_callback(PVOID DllHandle, DWORD Reason, PVOID Reserved) { if (Reason == DLL_THREAD_ATTACH) { // collect the threads start address __int64 start_address = 0; NtQueryInformationThread(NtCurrentThread(), ThreadQuerySetWin32StartAddress, \u0026start_address, sizeof(start_address), nullptr); // assume the address is invalid until proven otherwise bool outside_of_valid_module = true; // loop the current loaded modules list const auto memory_module_list = \u0026reinterpret_cast\u003cnt::PTEB\u003e(NtCurrentTeb())-\u003eProcessEnvironmentBlock-\u003eLdr-\u003eInMemoryOrderModuleList; for (PLIST_ENTRY p_list_entry = memory_module_list-\u003eFlink; p_list_entry != memory_module_list; p_list_entry = p_list_entry-\u003eFlink) { auto p_entry = CONTAINING_RECORD(p_list_entry, nt::LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); // this condition will be true as long as the start address is within a loaded dlls range. // example: memory such as 0x1E000000000 will not exist in any module (any memory from the result of a virtual alloc call will not be valid.) // while something like 0x7FFF12397591 could be inside of ntdll.dll if (start_address \u003e reinterpret_cast\u003c__int64\u003e(p_entry-\u003eDllBase) \u0026\u0026 start_address \u003c reinterpret_cast\u003c__int64\u003e(p_entry-\u003eDllBase) + p_entry-\u003eSizeOfImage) { outside_of_valid_module = false; break; } } // if we failed to prove the address is valid if (outside_of_valid_module) { callback(); // detection is stored and uploaded later _priv_ins_exx(); } } } Dumping Exception Handlers For those interested in how I dumped the exception handlers, I’ve provided the code. You’ll need to update these offsets if you want to use this. void dump_exception_handlers() { // 75 ? 4C 8D 9C 24 ? ? ? ? 48 8B C3 : mov xxx, rsi __int64 exception_filter = (__int64)GetModuleHandleA(\"kernelbase.dll\") + 0x28CC60; auto rtl_decode_pointer = reinterpret_cast\u003c__int64(__fastcall*)(__int64)\u003e(get_address(\"ntdll.dll\", \"RtlDecodePointer\")); // F0 0F AB 48 : lea rcx PLDRP_VECTOR_HANDLER_LIST vector_list = (PLDRP_VECTOR_HANDLER_LIST)((__int64)GetModuleHandleA(\"ntdll.dll\") + 0x17F3E8); LIST_ENTRY* list_head = \u0026vector_list-\u003eLdrpVehList; // this will be the function passed into SetUnhandledExceptionFilter log(\"UnhandledExceptionFilter: 0x%p\\n\", rtl_decode_pointer(*(__int64*)exception_filter)); // dump out the vectored handler list for (LIST_ENTRY* list_entry = list_head-\u003eFlink; list_entry != list_head; list_entry = list_entry-\u003eFlink) { PVECTOR_HANDLER_ENTRY pEntry = CONTAINING_RECORD(list_entry, VECTOR_HANDLER_ENTRY, ListEntry); __int64 pExceptionHandler = rtl_decode_pointer((__int64)pEntry-\u003eEncodedHandler); TCHAR modname[MAX_PATH]; GetModuleBaseNameW(GetCurrentProcess(), GetModuleHandle(NULL), modname, MAX_PATH); log(\"VEH: 0x%p (%ws) [0x%p]\\n\", pExceptionHandler, modname, pExceptionHandler - (__int64)GetModuleHandleW(modname)); } // dump out the continued handler list list_head = \u0026vector_list-\u003eLdrpVchList; for (LIST_ENTRY* list_entry = list_head-\u003eFlink; list_entry != list_head; list_entry = list_entry-\u003eFlink) { PVECTOR_HANDLER_ENTRY pEntry = CONTAINING_RECORD(list_entry, VECTOR_HANDLER_ENTRY, ListEntry); __int64 pExceptionHandler = rtl_decode_pointer((__int64)pEntry-\u003eEncodedHandler); TCHAR modname[MAX_PATH]; GetModuleBaseNameW(GetCurrentProcess(), GetModuleHandle(NULL), modname, MAX_PATH); log(\"VCH: 0x%p (%ws) [0x%p]\\n\", pExceptionHandler, modname, pExceptionHandler - (__int64)GetModuleHandleW(modname)); } } Mystery Tech? I’m not sure what this is, but it looks like something that would flag virtual machines or custom versions of Windows. void ac_check_allocation_grad(fn callback) { SYSTEM_BASIC_INFORMATION sbi; NtQuerySystemInformation(0, \u0026sbi, sizeof(sbi), nullptr); if (sbi.AllocationGranularity != 0x10000) { callback(); } } Since TAC is so reliant on the linked module list, they have a check that prevents someone from setting it to an empty list. Setting this to an empty list will probably break the process anyway. void ac_detect_invalidated_module_list(fn callback) { const auto memory_module_list = \u0026NtCurrentPeb()-\u003eLdr-\u003eInMemoryOrderModuleList; if (memory_module_list-\u003eFlink == memory_module_list) { callback(); } } The End TAC is a pretty cool user-mode anti-cheat, with features such as runtime API lookups, detecting poorly made hooks by passing clever invalid parameters, external overlay detection, internal DirectX hook detection, checking APIs that it uses for hooks, checking for debuggers and debugging artifacts, AllocConsole detection, CreateRemoteThread detection, and the coolest of all, spoofed and encrypted syscall stubs. Arxan really helps out TAC; it has powerful obfuscation, anti-static analysis methods, and a couple of features that break IDA Pro, all while monitoring the executable for .text modifications. It even has its own anti-debug techniques built-in. Similar code from TAC is being used in modern Call of Duty games. Overall, this was a huge learning experience, and a great challenge, and pretty unreal to see all the things that caught me! I hope you found my research interesting. I’m still not 100% done reversing the anti-cheat, so you can expect to see new information posted here sometime in the future! :) References https://www.lodsb.com/ntsetinformationthread-disabling-threadhidefromdebugger [#1] https://github.com/ayoubfaouzi/al-khaser/blob/master/al-khaser/AntiDebug/NtSetInformationThread_ThreadHideFromDebugger.cpp [#2] https://www.unknowncheats.me/forum/c-and-c-/567151-vectored-exception-handlers-x64-windows.html [#3] https://momo5502.com/posts/2022-11-17-reverse-engineering-integrity-checks-in-black-ops-3/ [#4]",
  "image": "https://ssno.cc/coldwar.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \n  \u003carticle\u003e\n    \n    \u003cdiv\u003e\n      \u003cp\u003e\u003cstrong\u003eI’ve been reversing Black Ops Cold War for a while now, and I’ve finally decided to share my research regarding the user-mode anti-cheat inside the game. It’s not my intention to shame or promote cheating/bypassing of the anti-cheat, so I’ve redacted a few things.\u003c/strong\u003e\u003c/p\u003e\n\u003cmeta property=\"og:image\" content=\"https://ssno.cc/coldwar.png\"/\u003e\n\u003cp\u003e\u003cimg src=\"https://ssno.cc/coldwar.png\" alt=\"image info\"/\u003e\u003c/p\u003e\n\u003cp\u003eTo clear up any confusion, Black Ops Cold War does not have the kernel-mode component of Ricochet that Modern Warfare (2019) and later titles have. I’ll be referring to the anti-cheat as TAC (Treyarch Anti-Cheat) as the game I reversed is a Treyarch game. Also, whenever I provide function pseudocode, it will be the best I can do since the actual decompilation is super cluttered with a lot of junk/resolving code. The biggest difference between the newer games is the kernel-mode driver, while the majority of anti-cheat code is user-mode and very similar to TAC.\u003c/p\u003e\n\u003cp\u003eLet’s look at how the anti-cheat and the game is protected before we dig too deep.\u003c/p\u003e\n\u003ch2 id=\"arxan\"\u003eArxan\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eArxan is an obfuscation/protection tool that’s used on many Call of Duty games, most of which are anything past Black Ops 3. Which includes many features, that make cheaters/reverse engineers’ life a lot harder.\u003c/p\u003e\n\u003ch2 id=\"runtime-executable-decryption\"\u003eRuntime Executable Decryption\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eThe game executable is packed and encrypted; Arxan inserts code during the startup process to unpack and decrypt the game executable.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"executable-checksums\"\u003eExecutable Checksums\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eArxan is constantly monitoring the game executable for any patches.\u003c/li\u003e\n\u003cli\u003eIf you want to learn more about these, momo5502 has a great blog post which can be found \u003ca href=\"https://momo5502.com/posts/2022-11-17-reverse-engineering-integrity-checks-in-black-ops-3/\"\u003ehere\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eWhenever Arxan detects a debugger or a checksum mismatch, it will terminate the process.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"jmp-obfuscation\"\u003eJmp Obfuscation\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eArxan can take a function and all of its instructions and separate them with a jmp.\u003c/li\u003e\n\u003cli\u003eThis is also useful to hide where a function is called from, it breaks IDA and requires an external tool to sift through the instructions.\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"asm\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epush\u003c/span\u003e    \u003cspan\u003erbp\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emov\u003c/span\u003e     \u003cspan\u003erbp\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eoffset\u003c/span\u003e \u003cspan\u003eunk_7FF60ECD1310\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exchg\u003c/span\u003e    \u003cspan\u003erbp\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ersp\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epush\u003c/span\u003e    \u003cspan\u003erbx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejmp\u003c/span\u003e     \u003cspan\u003eloc_7FF62B2050A6\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eloc_7FF62B2050A6:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epush\u003c/span\u003e    \u003cspan\u003erax\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emov\u003c/span\u003e     \u003cspan\u003erbx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ersp\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003eh\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emov\u003c/span\u003e     \u003cspan\u003erax\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eoffset\u003c/span\u003e \u003cspan\u003eloc_7FF60ECD1622\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ecmovbe\u003c/span\u003e  \u003cspan\u003erbx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erax\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejmp\u003c/span\u003e     \u003cspan\u003eloc_7FF62BD590D3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eloc_7FF62BD590D3:\u003c/span\u003e   \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emov\u003c/span\u003e     \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ersp\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003eh\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \u003cspan\u003erbx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epop\u003c/span\u003e     \u003cspan\u003erax\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003epop\u003c/span\u003e     \u003cspan\u003erbx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eretn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eloc_7FF60ECD1622:\u003c/span\u003e   \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejmp\u003c/span\u003e     \u003cspan\u003eloc_7FF629D04404\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; etc\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003eThis is difficult to analyze statically, especially whenever it’s a giant function that’s been planted with hundreds of jumps.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"entrypoint-obfuscation\"\u003eEntrypoint Obfuscation\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eIt’s really difficult to follow the entry point on Arxan-protected games; first, you have the protected Arxan code that unpacks and executes the game’s real entry point, which jmp obfuscation can also be planted in here, making it extremely difficult to understand what’s going on.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"pointer-encryption\"\u003ePointer Encryption\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eThis was actually thought to be Arxan for the longest time, but with recent information, it’s pretty certain this is just something Treyarch has developed and shared with IW for their games, or maybe it’s the other way around.\u003c/li\u003e\n\u003cli\u003eImportant pointers such as the current game glob, entity array, object pointers, etc., are encrypted and decrypted every time before use.\u003c/li\u003e\n\u003cli\u003eThere are 16 variations of the same encryption method; the current PEB address is actually what decides which encryption method to use.\n\u003cul\u003e\n\u003cli\u003eThis is pretty effective and does make your life harder for a little bit.\n\u003cul\u003e\n\u003cli\u003eForces you to get the decrypted pointer.\u003c/li\u003e\n\u003cli\u003ePrevents cheat engine pointer scanning (when scanning for the memory address of something that is encrypted, the actual global value will be holding the encrypted value, and this value is never set with the decrypted value; the decrypted value is always on  the stack.)\u003c/li\u003e\n\u003cli\u003eThere are a couple of ways to retrieve these decrypted pointers (these are not all of them):\n\u003cul\u003e\n\u003cli\u003eUsing a tool to trace the decryption instructions.\u003c/li\u003e\n\u003cli\u003eCreating a hook on spots where the memory has already been decrypted by the game for use.\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003eget_encryption_method\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// this is actually how it is in the exe\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e// the result of this ROL is 0x60 which is gs[PEB]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e// these values are generated and will not always be the same\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e value \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int8\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e__ROL1__\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e127\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e230\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eauto\u003c/span\u003e peb \u003cspan\u003e=\u003c/span\u003e __readgsqword\u003cspan\u003e(\u003c/span\u003evalue\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e _byteswap_uint64\u003cspan\u003e(\u003c/span\u003epeb \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e33\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003e0xF\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003eHere’s just a small portion of the operations done in the game exe for the encryption.\n\u003cimg src=\"https://ssno.cc/ptr_enc.png\" alt=\"image info\"/\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNow we that understand how the game and anti-cheat are protected we can dig deeper.\nTAC is planted directly into the game executable, uses no kernel components, and will also terminate the process if debug artifacts are found.\u003c/p\u003e\n\u003ch3 id=\"how-does-tac-detect-monitoring\"\u003eHow does TAC detect monitoring?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAPI Hook Detection\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eTAC is designed for Windows; this means it’s going to be using Windows-specific APIs for the anti-cheat.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe hook detection used here is pretty basic, and it’s currently only checking for 7 patterns. It looks like they have just taken previous cheats’ hook stubs and put them in.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNOTE: Each time I provide example code, every API called in that example code is what TAC is using, is being checked for hooks, and is being resolved by their runtime hash lookup. Also, most of TAC is heavily inlined.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"asm\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; First stub\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003epush\u003c/span\u003e   \u003cspan\u003erax\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emovabs\u003c/span\u003e \u003cspan\u003erax\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e0x0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exchg\u003c/span\u003e   \u003cspan\u003eQWORD\u003c/span\u003e \u003cspan\u003ePTR\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ersp\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e\u003cspan\u003erax\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eret\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; Second Stub\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003epush\u003c/span\u003e   \u003cspan\u003erbx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emovabs\u003c/span\u003e \u003cspan\u003erbx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e0x0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exchg\u003c/span\u003e   \u003cspan\u003eQWORD\u003c/span\u003e \u003cspan\u003ePTR\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ersp\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e\u003cspan\u003erbx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eret\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; Third Stub\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003epush\u003c/span\u003e   \u003cspan\u003ercx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emovabs\u003c/span\u003e \u003cspan\u003ercx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e0x0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exchg\u003c/span\u003e   \u003cspan\u003eQWORD\u003c/span\u003e \u003cspan\u003ePTR\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ersp\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e\u003cspan\u003ercx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eret\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; Fourth Stub\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003epush\u003c/span\u003e   \u003cspan\u003erdx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emovabs\u003c/span\u003e \u003cspan\u003erdx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e0x0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exchg\u003c/span\u003e   \u003cspan\u003eQWORD\u003c/span\u003e \u003cspan\u003ePTR\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ersp\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e\u003cspan\u003erdx\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eret\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; Fifth Stub\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003epush\u003c/span\u003e   \u003cspan\u003e0x0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eret\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; Sixth Stub (this is any call, 0xE8, 0x0, 0x0, 0x0, 0x0)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ecall\u003c/span\u003e \u003cspan\u003e0x00000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; Seventh Stub (this is any jmp [rip+x], 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ejmp\u003c/span\u003e \u003cspan\u003eQWORD\u003c/span\u003e \u003cspan\u003ePTR\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003erip\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003eHere’s how these checks are implemented. Those 0x0 spots in the assembly are 8 bytes because this is x64.\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_check_hook\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e address\u003cspan\u003e,\u003c/span\u003e callback cb\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int8\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e current_pos \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ebool\u003c/span\u003e hook_detected \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ecurrent_pos \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int8\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003eaddress\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003ecurrent_pos \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e144\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e++\u003c/span\u003ecurrent_pos\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eswitch\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003ecurrent_pos\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e0x50u\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ecurrent_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e72\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e184\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e11\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e72\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e135\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e14\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e36\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e195\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          hook_detected \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e0x53u\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ecurrent_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e72\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e187\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e11\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e72\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e135\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e28\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e14\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e36\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e195\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          hook_detected \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e0x51u\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ecurrent_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e72\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e185\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e11\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e72\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e135\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e12\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e14\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e36\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e195\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          hook_detected \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e0x52u\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ecurrent_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e72\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e186\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e11\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e72\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e135\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e20\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e14\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e36\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e195\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          hook_detected \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e0x68u\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ecurrent_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e195\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          hook_detected \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e0xE9u\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      hook_detected \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003ecurrent_pos \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e255\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e current_pos\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e37\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          hook_detected \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ehook_detected\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      cb\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// example usage\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003eac_check_hook\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003eThread32First\u003cspan\u003e,\u003c/span\u003e callback\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003c/div\u003e\n\n\u003ch2 id=\"runtime-api-export-lookup\"\u003eRuntime API Export Lookup\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTAC has an inlined API lookup function; it takes the module hash and the API name hash, iterates the current list of loaded modules, hashes the name, then goes through each exported function from that module and compares it to the compile-time hash of the API they want.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis is what the decomp looks like.\n\u003cimg src=\"https://ssno.cc/runtime_lookup.PNG\" alt=\"image info\"/\u003e\u003c/p\u003e\n\u003cp\u003eHere’s a recreation of their runtime lookup.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e \u003cspan\u003eget_module_base\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003esize_t base\u003cspan\u003e,\u003c/span\u003e size_t hash\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \tac_setbase\u003cspan\u003e(\u003c/span\u003ebase\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\u003cspan\u003eauto\u003c/span\u003e peb \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003ePPEB\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eNtCurrentPeb\u003cspan\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\u003cspan\u003eauto\u003c/span\u003e head \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003epeb\u003cspan\u003e-\u0026gt;\u003c/span\u003eLdr\u003cspan\u003e-\u0026gt;\u003c/span\u003eInMemoryOrderModuleList\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\u003cspan\u003eint\u003c/span\u003e mc \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\u003cspan\u003eauto\u003c/span\u003e entry \u003cspan\u003e=\u003c/span\u003e head\u003cspan\u003e-\u0026gt;\u003c/span\u003eFlink\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\u003cspan\u003ewhile\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eentry \u003cspan\u003e!=\u003c/span\u003e head\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\t\u003cspan\u003eauto\u003c/span\u003e table_entry \u003cspan\u003e=\u003c/span\u003e CONTAINING_RECORD\u003cspan\u003e(\u003c/span\u003eentry\u003cspan\u003e,\u003c/span\u003e LDR_DATA_TABLE_ENTRY\u003cspan\u003e,\u003c/span\u003e InMemoryOrderLinks\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\t\u003cspan\u003eauto\u003c/span\u003e n \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eoffsetof\u003cspan\u003e(\u003c/span\u003eLDR_DATA_TABLE_ENTRY\u003cspan\u003e,\u003c/span\u003e DllBase\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\t\u003cspan\u003echar\u003c/span\u003e buf\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e255\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\tsize_t count \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\twcstombs_s\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003ecount\u003cspan\u003e,\u003c/span\u003e buf\u003cspan\u003e,\u003c/span\u003e table_entry\u003cspan\u003e-\u0026gt;\u003c/span\u003eFullDllName\u003cspan\u003e.\u003c/span\u003eBuffer\u003cspan\u003e,\u003c/span\u003e table_entry\u003cspan\u003e-\u0026gt;\u003c/span\u003eFullDllName\u003cspan\u003e.\u003c/span\u003eLength\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// this is just from my hash tool; +20 skips past C:\\Windows\\System32\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e  \t\t\u003cspan\u003eauto\u003c/span\u003e h \u003cspan\u003e=\u003c/span\u003e ac_mod64\u003cspan\u003e(\u003c/span\u003ebuf \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e20\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eh \u003cspan\u003e==\u003c/span\u003e hash\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ereturn\u003c/span\u003e table_entry\u003cspan\u003e-\u0026gt;\u003c/span\u003eDllBase\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\t\t\u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\tentry \u003cspan\u003e=\u003c/span\u003e entry\u003cspan\u003e-\u0026gt;\u003c/span\u003eFlink\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"how-can-we-figure-out-what-these-hashes-are\"\u003eHow can we figure out what these hashes are?\u003c/h2\u003e\n\u003cp\u003eThe answer is super simple; I grabbed a list of all the loaded modules in my game process and copied over the game’s hashing function (note: dll names are hashed a little bit differently), which can be seen here.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// this is used for dll names\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003esize_t \u003cspan\u003eac_mod64\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e str\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eauto\u003c/span\u003e base \u003cspan\u003e=\u003c/span\u003e ac_getbase\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003ewhile\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003estr\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eauto\u003c/span\u003e v203 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003estr\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eauto\u003c/span\u003e v39 \u003cspan\u003e=\u003c/span\u003e v203\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ev203 \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e0x41u\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e v39 \u003cspan\u003e\u0026lt;=\u003c/span\u003e \u003cspan\u003e0x5Au\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\tv39 \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\tbase \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x100000001B3\u003c/span\u003ei64 \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003e(((\u003c/span\u003ev39 \u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003e0xFF00\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x100000001B3\u003c/span\u003ei64 \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int8\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ev39\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\tbase\u003cspan\u003e)));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003ereturn\u003c/span\u003e base\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// this is used for exported function names\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003esize_t \u003cspan\u003eac_fnv64\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e str\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eauto\u003c/span\u003e base \u003cspan\u003e=\u003c/span\u003e ac_getbase\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ewhile\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003estr\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eauto\u003c/span\u003e s \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003estr\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eauto\u003c/span\u003e v12 \u003cspan\u003e=\u003c/span\u003e s\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003es \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e65\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e v12 \u003cspan\u003e\u0026lt;=\u003c/span\u003e \u003cspan\u003e90\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            v12 \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        base \u003cspan\u003e=\u003c/span\u003e ac_prime \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ev12 \u003cspan\u003e^\u003c/span\u003e base\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e base\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI took that function and calculated the hash of all the module names and exports from the module list that I grabbed, then created a function to look up these API names by using the FNV hash base and the inlined hash of the API name.\u003c/p\u003e\n\u003cp\u003eHere’s how I managed to cache and resolve all of the exports.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003ecache_exports\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003edll\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e loadedDlls\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        HMODULE mod \u003cspan\u003e=\u003c/span\u003e GetModuleHandleA\u003cspan\u003e(\u003c/span\u003edll\u003cspan\u003e.\u003c/span\u003ec_str\u003cspan\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003emod\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003econtinue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        IMAGE_DOS_HEADER\u003cspan\u003e*\u003c/span\u003e mz \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ePIMAGE_DOS_HEADER\u003cspan\u003e)\u003c/span\u003emod\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        IMAGE_NT_HEADERS\u003cspan\u003e*\u003c/span\u003e nt \u003cspan\u003e=\u003c/span\u003e RVA2PTR\u003cspan\u003e(\u003c/span\u003ePIMAGE_NT_HEADERS\u003cspan\u003e,\u003c/span\u003e mz\u003cspan\u003e,\u003c/span\u003e mz\u003cspan\u003e-\u0026gt;\u003c/span\u003ee_lfanew\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        IMAGE_DATA_DIRECTORY\u003cspan\u003e*\u003c/span\u003e edirp \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003ent\u003cspan\u003e-\u0026gt;\u003c/span\u003eOptionalHeader\u003cspan\u003e.\u003c/span\u003eDataDirectory\u003cspan\u003e[\u003c/span\u003eIMAGE_DIRECTORY_ENTRY_EXPORT\u003cspan\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        IMAGE_DATA_DIRECTORY edir \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003eedirp\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        IMAGE_EXPORT_DIRECTORY\u003cspan\u003e*\u003c/span\u003e exports \u003cspan\u003e=\u003c/span\u003e RVA2PTR\u003cspan\u003e(\u003c/span\u003ePIMAGE_EXPORT_DIRECTORY\u003cspan\u003e,\u003c/span\u003e mz\u003cspan\u003e,\u003c/span\u003e edir\u003cspan\u003e.\u003c/span\u003eVirtualAddress\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        DWORD\u003cspan\u003e*\u003c/span\u003e addrs \u003cspan\u003e=\u003c/span\u003e RVA2PTR\u003cspan\u003e(\u003c/span\u003eDWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e mz\u003cspan\u003e,\u003c/span\u003e exports\u003cspan\u003e-\u0026gt;\u003c/span\u003eAddressOfFunctions\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        DWORD\u003cspan\u003e*\u003c/span\u003e names \u003cspan\u003e=\u003c/span\u003e RVA2PTR\u003cspan\u003e(\u003c/span\u003eDWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e mz\u003cspan\u003e,\u003c/span\u003e exports\u003cspan\u003e-\u0026gt;\u003c/span\u003eAddressOfNames\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e i \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e i \u003cspan\u003e\u0026lt;\u003c/span\u003e exports\u003cspan\u003e-\u0026gt;\u003c/span\u003eNumberOfFunctions\u003cspan\u003e;\u003c/span\u003e i\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e name \u003cspan\u003e=\u003c/span\u003e RVA2PTR\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e mz\u003cspan\u003e,\u003c/span\u003e names\u003cspan\u003e[\u003c/span\u003ei\u003cspan\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e addr \u003cspan\u003e=\u003c/span\u003e RVA2PTR\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e mz\u003cspan\u003e,\u003c/span\u003e addrs\u003cspan\u003e[\u003c/span\u003ei\u003cspan\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            MEMORY_BASIC_INFORMATION mbi\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003essno\u003cspan\u003e::\u003c/span\u003ebypass\u003cspan\u003e::\u003c/span\u003eVirtualQuery\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003ename\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003embi\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003embi\u003cspan\u003e)))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003embi\u003cspan\u003e.\u003c/span\u003eAllocationBase \u003cspan\u003e==\u003c/span\u003e mod\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    hashes\u003cspan\u003e[\u003c/span\u003eac_fnv64\u003cspan\u003e(\u003c/span\u003ename\u003cspan\u003e)]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e std\u003cspan\u003e::\u003c/span\u003estring\u003cspan\u003e(\u003c/span\u003ename\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003elookup_hash\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003esize_t base\u003cspan\u003e,\u003c/span\u003e size_t hash\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tac_setbase\u003cspan\u003e(\u003c/span\u003ebase\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\thashes\u003cspan\u003e.\u003c/span\u003eclear\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tcache_exports\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ehashes\u003cspan\u003e.\u003c/span\u003efind\u003cspan\u003e(\u003c/span\u003ehash\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e hashes\u003cspan\u003e.\u003c/span\u003eend\u003cspan\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\tprintf\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Failed to find hash: 0x%p\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e hash\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tprintf\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;0x%p, 0x%p = %s\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e base\u003cspan\u003e,\u003c/span\u003e hash\u003cspan\u003e,\u003c/span\u003e hashes\u003cspan\u003e[\u003c/span\u003ehash\u003cspan\u003e].\u003c/span\u003ec_str\u003cspan\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eAfter all of this, it was time to do some manual work.\n\u003cul\u003e\n\u003cli\u003eI went in by hand and grabbed the base hashes and function hashes from the decompilation then put those into my program.\u003c/li\u003e\n\u003cli\u003eNow I was able to tell exactly which APIs the anti-cheat was calling.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHere’s how my tool ended up working.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// (lookup_pebhash is the get_module_base function I wrote about further up)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003elookup_pebhash\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0xB8BC6A966753F382u\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x7380E62B9E1CA6D6\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e// ntdll\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003elookup_hash\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x6B9D7FEE4A7D71CEu\u003c/span\u003ei64\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xE5FAB4B4E649C7A4u\u003c/span\u003ei64\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e// VirtualProtect\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003elookup_hash\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x1592DD0A71569429\u003c/span\u003ei64\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xB5902EE75629AA6Cu\u003c/span\u003ei64\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e//NtAllocateVirtualMemory\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003elookup_hash\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x3E4D681B236AE0A0\u003c/span\u003ei64\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x3AB0D0D1450DE52D\u003c/span\u003ei64\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e//GetWindowLongA\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003elookup_hash\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x77EF6ADABFA1098F\u003c/span\u003ei64\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x94CA321842195A88u\u003c/span\u003ei64\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e//OpenProcess\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003elookup_hash\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0xA3439F4AFAAB52AEu\u003c/span\u003ei64\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xE48550DEAB23A8C9u\u003c/span\u003ei64\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e//K32EnumProcessModules\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003elookup_hash\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x2004CA9BE823B79A\u003c/span\u003ei64\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x828CC84F9E74E1A0u\u003c/span\u003ei64\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e//CloseHandle\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003elookup_hash\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x423E363D6FEF8CEA\u003c/span\u003ei64\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x5B3E9BDB215405F3\u003c/span\u003ei64\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e//K32GetModuleFileNameExW\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003elookup_hash\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x52D5BB326B1FC6B2\u003c/span\u003ei64\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x1C2D0172D09B7286\u003c/span\u003ei64\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e//GetWindowThreadProcessId\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003elookup_hash\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x13FA4A203570A0A2\u003c/span\u003ei64\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xB8DA7EDECE20A5DCu\u003c/span\u003ei64\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e//GetWindowDisplayAffinity\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://ssno.cc/example_lookup.png\" alt=\"image info\"/\u003e\u003c/p\u003e\n\u003cp\u003eI do want to mention that these hashes aren’t going to be the same in different versions of the game.\nAlso, this isn’t the only way of beating this hashing technique; these function pointers are stored in global variables; you can simply inspect them and match the virtual address of the function to one of the exported functions from all of the DLLs loaded.\u003c/p\u003e\n\u003cp\u003eOk, now we have established that TAC detects API hooking \u003cem\u003e(It only checks functions that it uses, not actually checking all important APIs for hooks, just the ones it’s using)\u003c/em\u003e. These are only here to monitor API hooking attempts that would hurt or prevent the anti-cheat from doing its job.\u003c/p\u003e\n\u003cp\u003eWhat if there was a hooking method that bypassed their hooking detections?\u003c/p\u003e\n\u003ch2 id=\"debug-registers\"\u003eDebug Registers\u003c/h2\u003e\n\u003cp\u003eFor actual cheaters trying to hook into the game, Arxan has got the code patching covered; cheaters must use non-code patching hooking methods while Arxan is present.\nThere are a couple of these hooking methods, and I’ll list a few here:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eException hooking - Forcefully triggering an exception and handling it.\n\u003cul\u003e\n\u003cli\u003eExceptions can be triggered in multiple ways.\u003c/li\u003e\n\u003cli\u003eModify a global pointer to be a nullptr or invalid memory address.\u003c/li\u003e\n\u003cli\u003eModify page access protections to trigger an access exception (Example: PAGE_NOACCESS or PAGE_GUARD).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDebug registers - telling the CPU to break (throw a STATUS_SINGLE_STEP exception) on a specific instruction.\n\u003cul\u003e\n\u003cli\u003eThese are very powerful; the CPU can break on any or all of these conditions for a given instruction address.\n\u003cul\u003e\n\u003cli\u003eRead\u003c/li\u003e\n\u003cli\u003eWrite\u003c/li\u003e\n\u003cli\u003eExecute\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDebug registers are the easiest to use, the most popular, and the easiest to detect!\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSince debug registers are so popular and powerful, and completely bypass Arxan’s .text patch monitoring, this makes them the perfect hooking technique for Call of Duty games.\u003c/p\u003e\n\u003ch2 id=\"heres-how-tac-checks-for-debug-registers\"\u003eHere’s how TAC checks for debug registers.\u003c/h2\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_check_debug_registers\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eHANDLE thread_handle\u003cspan\u003e,\u003c/span\u003e fn callback\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        CONTEXT context\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        context\u003cspan\u003e.\u003c/span\u003eContextFlags \u003cspan\u003e=\u003c/span\u003e CONTEXT_FULL\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003eGetThreadContext\u003cspan\u003e(\u003c/span\u003ethread_handle\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003econtext\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003econtext\u003cspan\u003e.\u003c/span\u003eDr0 \u003cspan\u003e||\u003c/span\u003e context\u003cspan\u003e.\u003c/span\u003eDr1 \u003cspan\u003e||\u003c/span\u003e context\u003cspan\u003e.\u003c/span\u003eDr2 \u003cspan\u003e||\u003c/span\u003e context\u003cspan\u003e.\u003c/span\u003eDr3\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eGetProcessIdOfThread\u003cspan\u003e(\u003c/span\u003ethread_handle\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e GetCurrentProcessId\u003cspan\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            callback\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;debug registers found, but not in our process\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            callback\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;debug registers found inside current process\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e// the anti-cheat would then jump to the quit functions that I wrote about a little bit further down\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e          \u003cspan\u003e// default will call ac_terminate_process_clear_registers\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e          \u003cspan\u003e// if ZwTerminateProcess was hooked it will jump to ac_close_game2_crash_zeroxzero\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e        \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// access rights that are requested\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e__forceinline\u003c/span\u003e HANDLE \u003cspan\u003eac_open_thread\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e pid\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ereturn\u003c/span\u003e OpenThread\u003cspan\u003e(\u003c/span\u003eTHREAD_QUERY_INFORMATION \u003cspan\u003e|\u003c/span\u003e THREAD_GET_CONTEXT\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e pid\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eSince debug registers are in the DR0-DR3 registers, you can’t just write some custom assembly to directly read them because these registers are privileged and must be fetched by the Windows kernel or sent to the process by Windows whenever an exception occurs.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"asm\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; This will throw a STATUS_PRIVILEGED_INSTRUCTION exception\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003emov\u003c/span\u003e \u003cspan\u003erax\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003edr0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eret\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"driver-signing-enforcement\"\u003eDriver Signing Enforcement\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eWindows has a test mode, which is designed for driver development.\u003c/li\u003e\n\u003cli\u003eThis will allow you to bypass the normal Windows restriction on kernel-mode drivers not having valid digital signatures.\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eThis is a protection mechanism in place to prevent bad actors from running kernel mode drivers on your system without the proper authorization.\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eTAC will know if you have test mode enabled on Windows, via \u003cstrong\u003e\u003cem\u003entdll!NtQuerySystemInformation\u003c/em\u003e\u003c/strong\u003e. This isn’t going to ban you directly, but this will have your account flagged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e \u003cspan\u003eis_test_signing_on\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tSYSTEM_CODEINTEGRITY_INFORMATION sys_cii\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tsys_cii\u003cspan\u003e.\u003c/span\u003eLength \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003esys_cii\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tNTSTATUS status \u003cspan\u003e=\u003c/span\u003e NtQuerySystemInformation\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e103\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003esys_cii\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eULONG\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003esys_cii\u003cspan\u003e)),\u003c/span\u003e \u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003ePULONG\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNULL\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eNT_SUCCESS\u003cspan\u003e(\u003c/span\u003estatus\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e!!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003esys_cii\u003cspan\u003e.\u003c/span\u003eCodeIntegrityOptions \u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003e/*CODEINTEGRITY_OPTION_TESTSIGN*/\u003c/span\u003e \u003cspan\u003e0x2\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_check_test_signing\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ecallback cb\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eis_test_signing_on\u003cspan\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    cb\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow we understand some of TAC’s anti-static analysis and debug register detection tactics. We’re going to move on to the more advanced detections implemented into TAC.\u003c/p\u003e\n\u003ch2 id=\"how-does-tac-exit-the-process\"\u003eHow does TAC exit the process?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTAC uses two ways of exiting the process; both of them clear the registers, and these are written in inline shellcode.\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe first method sets RCX to -1 as it calls NtTerminateProcess.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTAC will not use this method if NtTerminateProcess is detected to be hooked.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf NtTerminateProcess is hooked, it’ll go to the second one, which jumps to 0x0.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"asm\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003erax\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erax\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003erbx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erbx\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003ercx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ercx\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003edec\u003c/span\u003e         \u003cspan\u003ercx\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003erdx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erdx\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003ersi\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ersi\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003erdi\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erdi\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er8\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er8\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er9\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er9\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er10\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er10\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er11\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er11\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er12\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er12\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er13\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er13\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er14\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er14\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er15\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er15\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emov\u003c/span\u003e         \u003cspan\u003ersp\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x0F8\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejmp\u003c/span\u003e         \u003cspan\u003eqword\u003c/span\u003e \u003cspan\u003eptr\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0x1B607DC7FF0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; This is not a custom syscall setup; this is a jump to ntdll!NtTerminateProcess.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003espot_1B607DC7FF0:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emov\u003c/span\u003e         \u003cspan\u003er10\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ercx\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emov\u003c/span\u003e         \u003cspan\u003eeax\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x2C\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003etest\u003c/span\u003e        \u003cspan\u003ebyte\u003c/span\u003e \u003cspan\u003eptr\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0x7FFE0308\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejne\u003c/span\u003e         \u003cspan\u003eNtTerminateProcess\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e0x15\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x07FFA7A3CDA75\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003esyscall\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eret\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere’s the second method; we can see the same register clearing, and we see a jmp. This jump goes to 0x0, which will crash the process.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"asm\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003erax\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erax\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003erbx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erbx\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003ercx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ercx\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003erdx\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erdx\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003ersi\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ersi\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003erdi\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erdi\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er8\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er8\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er9\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er9\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er10\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er10\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er11\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er11\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er12\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er12\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er13\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er13\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er14\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er14\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003er15\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003er15\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003ersp\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ersp\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003exor\u003c/span\u003e         \u003cspan\u003erbp\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erbp\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejmp\u003c/span\u003e         \u003cspan\u003eqword\u003c/span\u003e \u003cspan\u003eptr\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0x27E45550036\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; value of 0x27E45550036 = 0x000000000000\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThese are hard to recover from since all of the important registers are cleared.\u003cbr/\u003e\nThe code for generating and running these shellcodes is provided here.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// these are reconstructed to make it readable\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_terminate_process_clear_registers\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e memory \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eVirtualAlloc\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e0x8000uLL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      MEM_COMMIT \u003cspan\u003e|\u003c/span\u003e MEM_RESERVE\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      PAGE_EXECUTE_READWRITE\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e proc_addr \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eGetProcAddress\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      LoadLibraryA\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;ntdll.dll\u0026#34;\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e\u0026#34;ZwTerminateProcess\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e terminate_process_shellcode\u003cspan\u003e[]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xC0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rax, rax\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xDB\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rbx, rbx\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xC9\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rcx, rcx\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xFF\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xC9\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// dec rcx\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xD2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rdx, rdx\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xF6\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rsi, rsi\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xFF\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rdi, rdi\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xC0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r8, r8\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xC9\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r9, r9\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xD2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r10, r10\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xDB\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r11, r11\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xE4\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r12, r12\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xED\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r13, r13\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xF6\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r14, r14\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xFF\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r15, r15\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xC7\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xC4\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xF8\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x00\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x00\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x00\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// mov rsp, 0x0F8\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003e0xFF\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x25\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x00\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x00\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x00\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x00\u003c/span\u003e  \u003cspan\u003e// jmp QWORD PTR [rip + 0x0]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e zw_terminate_process_spot \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x320\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e// write the address of ZwTerminateProcess somewhere\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e*\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ememory \u003cspan\u003e+\u003c/span\u003e zw_terminate_process_spot\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e proc_addr\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e// calculate the memory offset of where ZwTerminateProcess was written (needs to be   RVA from RIP)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e rva_addy \u003cspan\u003e=\u003c/span\u003e zw_terminate_process_spot \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eterminate_process_shellcode\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eDWORD\u003cspan\u003e*\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003eterminate_process_shellcode\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003esizeof\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eterminate_process_shellcode\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e rva_addy\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tmemcpy\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ememory\u003cspan\u003e),\u003c/span\u003e terminate_process_shellcode\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eterminate_process_shellcode\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)()\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ememory\u003cspan\u003e)();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_close_game2_crash_zeroxzero\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e memory \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eVirtualAlloc\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e0x40uLL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      MEM_COMMIT \u003cspan\u003e|\u003c/span\u003e MEM_RESERVE\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      PAGE_EXECUTE_READWRITE\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    memset\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ememory\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x40\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e zero_zero_shellcode\u003cspan\u003e[]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xC0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rax, rax\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xDB\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rbx, rbx\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xC9\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rcx, rcx\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xD2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rdx, rdx\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xF6\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rsi, rsi\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xFF\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rdi, rdi\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xC0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r8, r8\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xC9\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r9, r9\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xD2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r10, r10\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xDB\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r11, r11\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xE4\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r12, r12\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xED\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r13, r13\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xF6\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r14, r14\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x4D\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xFF\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor r15, r15\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xE4\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rsp, rsp\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0x48\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x31\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xED\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e// xor rbp, rbp\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \t\u003cspan\u003e0xFF\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x25\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x00\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x00\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x00\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x00\u003c/span\u003e \u003cspan\u003e// jmp  qword ptr[rip + 0]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// this offset will just be to memory thats already 0x00000000\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eDWORD\u003cspan\u003e*\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003ezero_zero_shellcode\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ezero_zero_shellcode\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    memcpy\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ememory\u003cspan\u003e),\u003c/span\u003e zero_zero_shellcode\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ezero_zero_shellcode\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)()\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ememory\u003cspan\u003e)();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"detecting-cheat-logging\"\u003eDetecting Cheat Logging\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eOftentimes, internal cheaters will allocate a console using \u003ca href=\"https://learn.microsoft.com/en-us/windows/console/allocconsole\"\u003eAllocConsole\u003c/a\u003e to print their debug logs to, or even make their menu in it using print statements.\n\u003cul\u003e\n\u003cli\u003eThe PEB (Process Environment Block) contains information regarding the allocation of a console.\n\u003cul\u003e\n\u003cli\u003eThe PEB contains a ton of useful information regarding the process. If you want to read more about this \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb\"\u003eclick here\u003c/a\u003e; most of this structure is undocumented, but that’ll take you to the MSDN page.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eThe game knows that there shouldn’t ever be a console window allocated; checking for one is super simple and will catch some people who use this method of logging. Here’s the implementation.\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_detect_allocated_console\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003efn callback\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eGetConsoleWindow\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e NtCurrentPeb\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003eProcessParameters\u003cspan\u003e-\u0026gt;\u003c/span\u003eConsoleHandle \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    callback\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"detecting-visuals\"\u003eDetecting Visuals\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eCheaters need to draw on the screen if they want a working \u003cstrong\u003eESP\u003c/strong\u003e or even a \u003cstrong\u003eMenu/User Interface\u003c/strong\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHow do they do this?\n\u003cul\u003e\n\u003cli\u003eThere are a few ways of drawing on the screen; the most common method for internal cheats is to hook whichever graphics API the game is using and draw their information in there.\u003c/li\u003e\n\u003cli\u003eModern Call of Duty games are made with \u003cstrong\u003eDirectX 12\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eA common function to hook when wanting to draw things on \u003cstrong\u003eDirectX\u003c/strong\u003e is \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present\"\u003eIDXGISwapChain::Present\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eThe present function is what presents the rendered game image to the user. The idea is you add your custom data to the image before it’s presented to the user, update the image then present it to the user.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHow is this detected?\n\u003cul\u003e\n\u003cli\u003eFirst, we need to understand how these functions are hooked.\n\u003cul\u003e\n\u003cli\u003eThe \u003cstrong\u003eDirectX\u003c/strong\u003e functions are inside of the \u003cstrong\u003edxgi\u003c/strong\u003e DLL on your computer.\u003c/li\u003e\n\u003cli\u003eDirectX interfaces hold vtables which will point to the functions inside of dxgi, these vtable indexes will be the same across the versions of windows.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/dxgi/nn-dxgi-idxgiswapchain\"\u003eIDXGISwapChain\u003c/a\u003e vtable holds the present function.\u003c/li\u003e\n\u003cli\u003eThis can either be directly hooked, or pointer swapped.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDetecting these hooks.\n\u003cul\u003e\n\u003cli\u003eSomething that can be done is to scan the DXGI present function, but TAC doesn’t currently do this.\u003c/li\u003e\n\u003cli\u003eTAC checks the present pointer in the vtable.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDirectX 12\u003c/strong\u003e introduced command queues; whenever the game is drawing something, it’s from the command queue, a list of draw commands. This is something cheaters will also need if they want to draw.\n\u003cul\u003e\n\u003cli\u003eHow do cheaters get this command queue?\n\u003cul\u003e\n\u003cli\u003eThe most common method of grabbing the game’s command queue is to hook another function from the command queue interface, \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12commandqueue-executecommandlists\"\u003eID3D12CommandQueue::ExecuteCommandLists\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eSince this is an interface, the methods will have a \u003cstrong\u003e\u003cem\u003ethis\u003c/em\u003e\u003c/strong\u003e pointer passed as the first parameter; in this case, that pointer is the command queue.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCool information:\n\u003cul\u003e\n\u003cli\u003eMany things such as OBS Studio/Streamlabs OBS/Discords game overlay/Steams game overlay actually all do this, while Steam and Discord draw here, things like OBS studio are just here to capture the rendered image (capture the frames) and save them into your recording. This only happens if you use game capture on recording software.\u003c/li\u003e\n\u003cli\u003eCheaters can ignore the game, and simply hook into Discord/steam and draw things there if they want to.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-about-external-cheats\"\u003eWhat about External Cheats?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eExternal cheats are most likely going to create an overlapped window that covers the width and height of the game window. There are a few ways to detect this; the detection methods heavily rely on Windows APIs and require more effort to implement.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTAC loops through all of the windows, checking their \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/winmsg/extended-window-styles\"\u003ewindow style\u003c/a\u003e for \u003cstrong\u003eWS_EX_LAYERED\u003c/strong\u003e  using \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlonga\"\u003eGetWindowLongA\u003c/a\u003e; once it finds that, it then compares that window’s rect with the game rect using \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowrect\"\u003eGetWindowRect\u003c/a\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAfter all of that, if the window is over the game’s rect and it is a layered window, the hwnd to that window will be cached, which will later be used for many string checks. This stores a bunch of information and uploads it to their servers.\u003c/p\u003e\n\u003cp\u003eHere we can see how that works.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003eGetWindowRect\u003cspan\u003e(\u003c/span\u003ehwnd\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003eoutput_rect\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eoutput_rect\u003cspan\u003e.\u003c/span\u003eright \u003cspan\u003e\u0026gt;=\u003c/span\u003e game_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003eleft \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    output_rect\u003cspan\u003e.\u003c/span\u003eleft \u003cspan\u003e\u0026lt;=\u003c/span\u003e game_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003eright \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    output_rect\u003cspan\u003e.\u003c/span\u003ebottom \u003cspan\u003e\u0026gt;=\u003c/span\u003e game_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003etop \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    output_rect\u003cspan\u003e.\u003c/span\u003etop \u003cspan\u003e\u0026lt;=\u003c/span\u003e game_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003ebottom\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  min_value \u003cspan\u003e=\u003c/span\u003e get_min_value\u003cspan\u003e(\u003c/span\u003eoutput_rect\u003cspan\u003e.\u003c/span\u003eleft\u003cspan\u003e,\u003c/span\u003e game_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003eleft\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  greater_value \u003cspan\u003e=\u003c/span\u003e get_greater_value\u003cspan\u003e(\u003c/span\u003eoutput_rect\u003cspan\u003e.\u003c/span\u003eright\u003cspan\u003e,\u003c/span\u003e game_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003eright\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  v193 \u003cspan\u003e=\u003c/span\u003e get_min_value\u003cspan\u003e(\u003c/span\u003eoutput_rect\u003cspan\u003e.\u003c/span\u003etop\u003cspan\u003e,\u003c/span\u003e game_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003etop\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  v195 \u003cspan\u003e=\u003c/span\u003e get_greater_value\u003cspan\u003e(\u003c/span\u003eoutput_rect\u003cspan\u003e.\u003c/span\u003ebottom\u003cspan\u003e,\u003c/span\u003e game_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003ebottom\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  v76 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efloat\u003c/span\u003e\u003cspan\u003e)((\u003c/span\u003ev193 \u003cspan\u003e-\u003c/span\u003e v195\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003egreater_value \u003cspan\u003e-\u003c/span\u003e min_value\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efloat\u003c/span\u003e\u003cspan\u003e)((\u003c/span\u003egame_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003etop \u003cspan\u003e-\u003c/span\u003e game_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003ebottom\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e              \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003egame_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003eright \u003cspan\u003e-\u003c/span\u003e game_rect_7FF61BBA2F50\u003cspan\u003e.\u003c/span\u003eleft\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ev76 \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e0.5\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e cached_window_count \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    cached_windows\u003cspan\u003e[\u003c/span\u003ecached_window_count\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e hwnd\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003eRECT game_rect_7FF61BBA2F50\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003egame_rect_7FF61BBA2F50 RECT \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e780\u003c/span\u003eh\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e438\u003c/span\u003eh\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cdiv\u003e\u003cp\u003eWe can see 0x780 and 0x438, which represent 1920 by 1080, which was my screen size.\n\u003c/p\u003e\u003cp\u003e\n\nOkay, so we know the windows are cached. Now what?\u003c/p\u003e\u003c/div\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe cached list is handled in another function that checks the window text and its class names.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTAC queries the window text using \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowtextw\"\u003eGetWindowTextW\u003c/a\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTAC queries the window class name using \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclassnamea\"\u003eGetClassNameA\u003c/a\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCheat developers can hide their overlapping windows from recording software, and screenshot tools using \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowdisplayaffinity\"\u003eSetWindowDisplayAffinity\u003c/a\u003e with \u003cstrong\u003eWDA_EXCLUDEFROMCAPTURE\u003c/strong\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThis is checked by TAC, and it’s saved into the buffer that will be uploaded to their servers later.\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003eac_fmt_sprint\u003cspan\u003e(\u003c/span\u003ev1035\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e32LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;%lu\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e display_affinity\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003eThere are a couple more things related to the window that are uploaded as well.\n\u003cul\u003e\n\u003cli\u003eThe normal window style is also checked; you can find more \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/winmsg/window-styles\"\u003ehere\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eTAC checks that the window is visible first before any more processing happens on it.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTAC also stores the list of modules, including the exe name of the overlapping window.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhen you do anything in Windows to another process, you need to have permission; Windows has an API that will let you request permission from the system. \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess\"\u003eOpenProcess\u003c/a\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003eHANDLE process_handle \u003cspan\u003e=\u003c/span\u003e OpenProcess\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x410\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e pid\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe first parameter in OpenProcess is the access desired, since this is a bitmask our reversing software will just show us 0x410 by default, but that doesn’t do us any good!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThis can be figured out with some IDA magic.\u003c/li\u003e\n\u003cli\u003eCreating a \u003ca href=\"https://docs.hex-rays.com/user-guide/disassembler/bitfields/bitfields-tutorial\"\u003ebitmask structure\u003c/a\u003e in IDA Pro and setting that as the function declaration’s first parameter helps us out.\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// these are taken from https://learn.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eenum\u003c/span\u003e \u003cspan\u003e__bitmask\u003c/span\u003e process_access_flags\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_TERMINATE \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_CREATE_THREAD \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_SET_SESSIONID \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x4\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_VM_OPERATION \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x8\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_VM_READ \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x10\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_VM_WRITE \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x20\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_DUP_HANDLE \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x40\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_CREATE_PROCESS \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x80\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_SET_QUOTA \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x100\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_SET_INFORMATION \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x200\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_QUERY_INFORMATION \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x400\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_SUSPEND_RESUME \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x800\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_QUERY_LIMITED_INFORMATION \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x1000\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PROCESS_SET_LIMITED_INFORMATION \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x2000\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003eHere’s the resulting code we get from IDA.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003eHANDLE handle \u003cspan\u003e=\u003c/span\u003e OpenProcess\u003cspan\u003e(\u003c/span\u003ePROCESS_VM_READ \u003cspan\u003e|\u003c/span\u003e PROCESS_QUERY_INFORMATION\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e pid\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eAs you can see, TAC wants to read the overlapping process’ virtual memory, and it wants to query information about the process.\u003c/li\u003e\n\u003cli\u003eThis is the access level you would expect for enumerating process modules. \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/psapi/enumerating-all-processes\"\u003eexample\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003eThe first thing TAC does with this handle is call \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessmodules\"\u003eK32EnumProcessModules\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eAfter that, TAC loops through the process modules and gathers the name of each using \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getmodulefilenameexa\"\u003eK32GetModuleFileNameExW\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eThen the strings are encrypted and stored into the encryption buffer.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHere’s what the majority of the code looks like.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_cached_window\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eHWND hwnd\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ehwnd \u003cspan\u003e==\u003c/span\u003e game_hwnd\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e is_visible \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eGetWindowLongA\u003cspan\u003e(\u003c/span\u003ehwnd\u003cspan\u003e,\u003c/span\u003e GWL_STYLE\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e WS_VISIBLE\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003eis_visible\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e window_style \u003cspan\u003e=\u003c/span\u003e GetWindowLongA\u003cspan\u003e(\u003c/span\u003ehwnd\u003cspan\u003e,\u003c/span\u003e GWL_EXSTYLE\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e is_top_most \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ewindow_style \u003cspan\u003e\u0026amp;\u003c/span\u003e WS_EX_TOPMOST\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e is_layered_window \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ewindow_style \u003cspan\u003e\u0026amp;\u003c/span\u003e WS_EX_LAYERED\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003eis_top_most \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003eis_layered_window\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tRECT output_rect\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tGetWindowRect\u003cspan\u003e(\u003c/span\u003ehwnd\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003eoutput_rect\u003cspan\u003e);\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eoutput_rect\u003cspan\u003e.\u003c/span\u003eright \u003cspan\u003e\u0026gt;=\u003c/span\u003e game_rect\u003cspan\u003e.\u003c/span\u003eleft\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t  \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e output_rect\u003cspan\u003e.\u003c/span\u003eleft \u003cspan\u003e\u0026lt;=\u003c/span\u003e game_rect\u003cspan\u003e.\u003c/span\u003eright\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t  \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e output_rect\u003cspan\u003e.\u003c/span\u003ebottom \u003cspan\u003e\u0026gt;=\u003c/span\u003e game_rect\u003cspan\u003e.\u003c/span\u003etop\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t  \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e output_rect\u003cspan\u003e.\u003c/span\u003etop \u003cspan\u003e\u0026lt;=\u003c/span\u003e game_rect\u003cspan\u003e.\u003c/span\u003ebottom\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t    \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e min_value_x1 \u003cspan\u003e=\u003c/span\u003e min\u003cspan\u003e(\u003c/span\u003eoutput_rect\u003cspan\u003e.\u003c/span\u003eleft\u003cspan\u003e,\u003c/span\u003e game_rect\u003cspan\u003e.\u003c/span\u003eleft\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t    \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e max_value_x2 \u003cspan\u003e=\u003c/span\u003e max\u003cspan\u003e(\u003c/span\u003eoutput_rect\u003cspan\u003e.\u003c/span\u003eright\u003cspan\u003e,\u003c/span\u003e game_rect\u003cspan\u003e.\u003c/span\u003eright\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t    \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e min_value_y1 \u003cspan\u003e=\u003c/span\u003e min\u003cspan\u003e(\u003c/span\u003eoutput_rect\u003cspan\u003e.\u003c/span\u003etop\u003cspan\u003e,\u003c/span\u003e game_rect\u003cspan\u003e.\u003c/span\u003etop\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t    \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e max_value_y2 \u003cspan\u003e=\u003c/span\u003e max\u003cspan\u003e(\u003c/span\u003eoutput_rect\u003cspan\u003e.\u003c/span\u003ebottom\u003cspan\u003e,\u003c/span\u003e game_rect\u003cspan\u003e.\u003c/span\u003ebottom\u003cspan\u003e);\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t    \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e difference_center \u003cspan\u003e=\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t      \u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003efloat\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003emin_value_y1 \u003cspan\u003e-\u003c/span\u003e max_value_y2\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003emax_value_x2 \u003cspan\u003e-\u003c/span\u003e min_value_x1\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t      \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003efloat\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003egame_rect\u003cspan\u003e.\u003c/span\u003etop \u003cspan\u003e-\u003c/span\u003e game_rect\u003cspan\u003e.\u003c/span\u003ebottom\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t            \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003egame_rect\u003cspan\u003e.\u003c/span\u003eright \u003cspan\u003e-\u003c/span\u003e game_rect\u003cspan\u003e.\u003c/span\u003eleft\u003cspan\u003e));\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003edifference_center \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e0.5\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e cached_window_count \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e{\u003c/span\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\tcached_windows\u003cspan\u003e[\u003c/span\u003ecached_window_count\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e hwnd\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_log_cached_window_process\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e pid\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e encrypted_string_buffer\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e HANDLE process_handle \u003cspan\u003e=\u003c/span\u003e OpenProcess\u003cspan\u003e(\u003c/span\u003ePROCESS_VM_READ \u003cspan\u003e|\u003c/span\u003e PROCESS_QUERY_INFORMATION\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e pid\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eprocess_handle \u003cspan\u003e==\u003c/span\u003e INVALID_HANDLE_VALUE\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tDWORD lpcbNeeded \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tHMODULE modules\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1024\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eK32EnumProcessModules\u003cspan\u003e(\u003c/span\u003eprocess_handle\u003cspan\u003e,\u003c/span\u003e modules\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x2000LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003elpcbNeeded\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e current_module_index \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e++\u003c/span\u003ecurrent_module_index\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ecurrent_module_index \u003cspan\u003e\u0026gt;=\u003c/span\u003e lpcbNeeded \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003e8uLL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e current_module \u003cspan\u003e=\u003c/span\u003e modules\u003cspan\u003e[\u003c/span\u003ecurrent_module_index\u003cspan\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\tWCHAR wide_module_name\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e260\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eK32GetModuleFileNameExW\u003cspan\u003e(\u003c/span\u003eprocess_handle\u003cspan\u003e,\u003c/span\u003e current_module\u003cspan\u003e,\u003c/span\u003e wide_module_name\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e260LL\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\u003cspan\u003echar\u003c/span\u003e ascii_module_name\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1568\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\tWideCharToMultiByte\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e65001LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e wide_module_name\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xFFFFFFFFLL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e ascii_module_name\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e1560\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\tac_string_encrypt\u003cspan\u003e(\u003c/span\u003eencrypted_string_buffer\u003cspan\u003e,\u003c/span\u003e ascii_module_name\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tCloseHandle\u003cspan\u003e(\u003c/span\u003eprocess_handle\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_handle_window\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eHWND hwnd\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e encrypted_string_thing\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e// tons of string encryption stuff all over here  \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003ewchar_t\u003c/span\u003e window_text_WIDE\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e512\u003c/span\u003e\u003cspan\u003e]{\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tGetWindowTextW\u003cspan\u003e(\u003c/span\u003ehwnd\u003cspan\u003e,\u003c/span\u003e window_text_WIDE\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e512LL\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003echar\u003c/span\u003e window_text_asci\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e3072\u003c/span\u003e\u003cspan\u003e]{\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tWideCharToMultiByte\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e65001LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e window_text_WIDE\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0xFFFFFFFFLL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e window_text_asci\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e3072\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003echar\u003c/span\u003e window_class_name\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e256\u003c/span\u003e\u003cspan\u003e]{\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tGetClassNameA\u003cspan\u003e(\u003c/span\u003ehwnd\u003cspan\u003e,\u003c/span\u003e window_class_name\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e256LL\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tRECT window_rect\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tGetWindowRect\u003cspan\u003e(\u003c/span\u003ehwnd\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003ewindow_rect\u003cspan\u003e);\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e window_gwl_style \u003cspan\u003e=\u003c/span\u003e GetWindowLongA\u003cspan\u003e(\u003c/span\u003ehwnd\u003cspan\u003e,\u003c/span\u003e GWL_STYLE\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e window_gwl_ex_style \u003cspan\u003e=\u003c/span\u003e GetWindowLongA\u003cspan\u003e(\u003c/span\u003ehwnd\u003cspan\u003e,\u003c/span\u003e GWL_EXSTYLE\u003cspan\u003e);\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tDWORD display_affinity \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tGetWindowDisplayAffinity\u003cspan\u003e(\u003c/span\u003ehwnd\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003edisplay_affinity\u003cspan\u003e);\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e// adds these strings to the buffer directly\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\tac_string_encrypt\u003cspan\u003e(\u003c/span\u003eencrypted_string_thing\u003cspan\u003e,\u003c/span\u003e window_text_asci\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tac_string_encrypt\u003cspan\u003e(\u003c/span\u003eencrypted_string_thing\u003cspan\u003e,\u003c/span\u003e window_class_name\u003cspan\u003e);\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e// store info\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\tac_fmt_sprint_encrypt\u003cspan\u003e(\u003c/span\u003eencrypted_string_thing\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;%li\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e window_rect\u003cspan\u003e.\u003c/span\u003eleft\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tac_fmt_sprint_encrypt\u003cspan\u003e(\u003c/span\u003eencrypted_string_thing\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;%li\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e window_rect\u003cspan\u003e.\u003c/span\u003etop\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tac_fmt_sprint_encrypt\u003cspan\u003e(\u003c/span\u003eencrypted_string_thing\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;%li\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e window_rect\u003cspan\u003e.\u003c/span\u003eright\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tac_fmt_sprint_encrypt\u003cspan\u003e(\u003c/span\u003eencrypted_string_thing\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;%li\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e window_rect\u003cspan\u003e.\u003c/span\u003ebottom\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tac_fmt_sprint_encrypt\u003cspan\u003e(\u003c/span\u003eencrypted_string_thing\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;%li\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e window_gwl_style\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tac_fmt_sprint_encrypt\u003cspan\u003e(\u003c/span\u003eencrypted_string_thing\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;%li\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e window_gwl_ex_style\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tac_fmt_sprint_encrypt\u003cspan\u003e(\u003c/span\u003eencrypted_string_thing\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;%lu\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e display_affinity\u003cspan\u003e);\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tDWORD pid \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eGetWindowThreadProcessId\u003cspan\u003e(\u003c/span\u003ehwnd\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003epid\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\tac_log_cached_window_process\u003cspan\u003e(\u003c/span\u003epid\u003cspan\u003e,\u003c/span\u003e encrypted_string_thing\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e// assuming encrypted failure message, logs the current process id instead.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_process_cached_windows\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e// lots of encryption stuff here\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e encrypted_string_thing \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003emalloc\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x40000\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e i \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e i \u003cspan\u003e\u0026lt;\u003c/span\u003e cached_window_count\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e++\u003c/span\u003ei\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e// lots of encryption stuff here, and ptr modifications\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\tac_handle_window\u003cspan\u003e(\u003c/span\u003ecached_windows\u003cspan\u003e[\u003c/span\u003ei\u003cspan\u003e],\u003c/span\u003e encrypted_string_thing\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e// lots of encryption stuff here, and ptr modifications\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\tac_send_data_to_server\u003cspan\u003e(\u003c/span\u003eencrypted_string_thing\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tfree\u003cspan\u003e(\u003c/span\u003eencrypted_string_thing\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e// lots of encryption stuff here\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003eExample data. TAC will format in json with modules hashed.\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003e\u003cspan\u003eNVIDIA GeForce Overlay \u003cspan\u003e-\u003c/span\u003e Window Text \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eCEF\u003cspan\u003e-\u003c/span\u003eOSC\u003cspan\u003e-\u003c/span\u003eWIDGET \u003cspan\u003e-\u003c/span\u003e Window Class\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e Left\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e Top\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e2560\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e Right\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e1440\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e Bottom\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1811939328\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e window_gwl_style\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e134742184\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e window_gwl_ex_style\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e display_affinity  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eLoaded \u003cspan\u003eModules\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eProgram Files\u003cspan\u003e\\\u003c/span\u003eNVIDIA Corporation\u003cspan\u003e\\\u003c/span\u003eNVIDIA GeForce Experience\u003cspan\u003e\\\u003c/span\u003eNVIDIA Share\u003cspan\u003e.\u003c/span\u003eexe\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003entdll\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eKERNEL32\u003cspan\u003e.\u003c/span\u003eDLL\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eKERNELBASE\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eSHLWAPI\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003emsvcrt\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eWS2_32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eurlmon\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eRPCRT4\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eCRYPT32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eucrtbase\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eUSER32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003ewin32u\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eiertutil\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eGDI32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003esrvcli\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003ecombase\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003egdi32full\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003emsvcp_win\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003esechost\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003enetutils\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eadvapi32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eSHELL32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eshcore\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eole32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eOLEAUT32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eProgram Files\u003cspan\u003e\\\u003c/span\u003eNVIDIA Corporation\u003cspan\u003e\\\u003c/span\u003eNVIDIA GeForce Experience\u003cspan\u003e\\\u003c/span\u003elibcef\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eWINTRUST\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003ewlanapi\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eCOMDLG32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003edxgi\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eIPHLPAPI\u003cspan\u003e.\u003c/span\u003eDLL\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eIMM32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eUxTheme\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eCRYPTUI\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eMSIMG32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eWINMM\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003ed3d11\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eSecur32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eNETAPI32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003ed3d9\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003ebcrypt\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eOLEACC\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003edwmapi\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eWTSAPI32\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eProgram Files\u003cspan\u003e\\\u003c/span\u003eNVIDIA Corporation\u003cspan\u003e\\\u003c/span\u003eShadowPlay\u003cspan\u003e\\\u003c/span\u003envspapi64\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003entmarta\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eProgram Files\u003cspan\u003e\\\u003c/span\u003eNVIDIA Corporation\u003cspan\u003e\\\u003c/span\u003eNvContainer\u003cspan\u003e\\\u003c/span\u003elibprotobuf\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eMSVCP140\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eVCRUNTIME140\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eVCRUNTIME140_1\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eProgram Files\u003cspan\u003e\\\u003c/span\u003eNVIDIA Corporation\u003cspan\u003e\\\u003c/span\u003eShadowPlay\u003cspan\u003e\\\u003c/span\u003eIpcCommon64\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eProgram Files\u003cspan\u003e\\\u003c/span\u003eNVIDIA Corporation\u003cspan\u003e\\\u003c/span\u003eNvContainer\u003cspan\u003e\\\u003c/span\u003eMessageBus\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eNSI\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eMSCTF\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003esystem32\u003cspan\u003e\\\u003c/span\u003eNLAapi\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003edhcpcsvc6\u003cspan\u003e.\u003c/span\u003eDLL\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eDNSAPI\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eWINSTA\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eclbcatq\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eMMDevApi\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003emscms\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eColorAdapterClient\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e.\u003c/span\u003eUI\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eWindowManagementAPI\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eTextInputFramework\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eInputHost\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003ewintypes\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003etwinapi\u003cspan\u003e.\u003c/span\u003eappcore\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eCoreMessaging\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eCoreUIComponents\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003esystem32\u003cspan\u003e\\\u003c/span\u003etwinapi\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003esystem32\u003cspan\u003e\\\u003c/span\u003eapphelp\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eProgram Files\u003cspan\u003e\\\u003c/span\u003eNVIDIA Corporation\u003cspan\u003e\\\u003c/span\u003eNVIDIA GeForce Experience\u003cspan\u003e\\\u003c/span\u003ecef\u003cspan\u003e\\\u003c/span\u003ecommon\u003cspan\u003e\\\u003c/span\u003eOverClocking\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eProgram Files\u003cspan\u003e\\\u003c/span\u003eNVIDIA Corporation\u003cspan\u003e\\\u003c/span\u003eNVIDIA GeForce Experience\u003cspan\u003e\\\u003c/span\u003edependencies\u003cspan\u003e\\\u003c/span\u003eCrimsonUtil\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003ePOWRPROF\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eUMPDC\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eProgram Files\u003cspan\u003e\\\u003c/span\u003eNVIDIA Corporation\u003cspan\u003e\\\u003c/span\u003eNVIDIA GeForce Experience\u003cspan\u003e\\\u003c/span\u003ecef\u003cspan\u003e\\\u003c/span\u003eshare\u003cspan\u003e\\\u003c/span\u003eMessageBusRouter\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003envapi64\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003eSETUPAPI\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003eFvSDK_x64\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003esystem32\u003cspan\u003e\\\u003c/span\u003emswsock\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003erasadhlp\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSystem32\u003cspan\u003e\\\u003c/span\u003efwpuclnt\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003exinput1_4\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eC\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\\u003c/span\u003eWindows\u003cspan\u003e\\\u003c/span\u003eSYSTEM32\u003cspan\u003e\\\u003c/span\u003edxcore\u003cspan\u003e.\u003c/span\u003edll\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cul\u003e\n\u003cli\u003eCheat Engine is one of the easiest programs to detect, and it’s really because of how virtual memory works in Windows.\u003c/li\u003e\n\u003cli\u003eWhenever a program wants to allocate virtual memory, they’re going to call the Windows API \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc\"\u003eVirtualAlloc\u003c/a\u003e.\n\u003cul\u003e\n\u003cli\u003eThis memory is allocated, but it’s not backed by any physical memory yet because it hasn’t been accessed, this is a feature in the Windows kernel.\u003c/li\u003e\n\u003cli\u003eThis allows the game to allocate virtual memory with that function and never use it.\u003c/li\u003e\n\u003cli\u003eAfter Cheat Engine scans the process, it will hit this virtual memory, which will then make that memory valid, because now it has been accessed by Cheat Engine.\n\u003cul\u003e\n\u003cli\u003eHere’s how that detection would look, and this is for any memory scanner, not just Cheat Engine. This will also include the Process Hacker memory tab.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003erun_honey_pot_violation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003efn callback\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// the protection won\u0026#39;t matter\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e  \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e allocated_virtual_memory \u003cspan\u003e=\u003c/span\u003e VirtualAlloc\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x1000\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e MEM_COMMIT \u003cspan\u003e|\u003c/span\u003e MEM_RESERVE\u003cspan\u003e,\u003c/span\u003e PAGE_READWRITE\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  PSAPI_WORKING_SET_EX_INFORMATION working_set_information\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  memset\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003eworking_set_information\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eworking_set_information\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  working_set_information\u003cspan\u003e.\u003c/span\u003eVirtualAddress \u003cspan\u003e=\u003c/span\u003e allocated_virtual_memory\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ewhile\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// query about the current process\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e did_it_work \u003cspan\u003e=\u003c/span\u003e K32QueryWorkingSetEx\u003cspan\u003e((\u003c/span\u003eHANDLE\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003eworking_set_information\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eworking_set_information\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003edid_it_work \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eworking_set_information\u003cspan\u003e.\u003c/span\u003eVirtualAttributes\u003cspan\u003e.\u003c/span\u003eFlags \u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      printf\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;XD CHEAT ENGINE DETECTED HAHAHAH\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      callback\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// just an example timer, not what the game does\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    Sleep\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1000\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"anti-sig-scanning\"\u003eAnti-Sig Scanning\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eGame hackers love signatures; whenever the game updates, no problem the cheat will automatically update.\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTreyarch had a pretty interesting idea.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTheir idea is to create a function that’ll never be called again; this function will call another function that protects the return address with PAGE_NOACCESS. Since this will never be reached again by the program, this isn’t an issue.\u003c/li\u003e\n\u003cli\u003eThe way sig scanners work is they attempt to match a signature by reading bytes in the executable. It’s extremely slow to query each byte you are going to be reading, which is why this is such a good method. You can read more about VirtualProtect \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect\"\u003ehere\u003c/a\u003e.\n\u003cul\u003e\n\u003cli\u003eIt’s not undefeatable, but it’s something that’s there and will probably give most a hard time.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eenable_anti_sig_scanning\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003efn callback\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  DWORD old \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e cpu_stamp \u003cspan\u003e=\u003c/span\u003e __rdtsc\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e protect_location \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_ReturnAddress\u003cspan\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eprotect_location \u003cspan\u003e\u0026amp;\u003c/span\u003e cpu_stamp\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eprotect_location \u003cspan\u003e|\u003c/span\u003e cpu_stamp\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eprotect_location \u003cspan\u003e+\u003c/span\u003e cpu_stamp\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ecpu_stamp \u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t  protect_location \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eprotect_location \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e5120\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003e0xFFFFFFFFFFFFF000uLL\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003eVirtualProtect\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eprotect_location\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e PAGE_NOACCESS\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003eold\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e// this is here just to detect someone hooking VirtualProtect and returning false on PAGE_NOACCESS\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e      callback\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eHere’s a good example of code that’ll never be reached again. (The program will never reach the top of the main function again.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e argc\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e argv\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  enable_anti_sig_scanning\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  scan_pattern\u003cspan\u003e(\u003c/span\u003eGetModuleHandleA\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e\u0026#34;xxsaj3\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e// pretend this is a signature that\u0026#39;s far into the executable\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eThe scan pattern function will start at the base of the executable and continue to the end until it finds the pattern it wants, ultimately hitting the PAGE_NOACCESS memory, and crashing the process.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://ssno.cc/anti_sig_scan.png\" alt=\"image info\"/\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"anti-debugging\"\u003eAnti-Debugging\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTAC has a simple anti-debug check; but remember, Arxan is still running, so they still have all of those anti-debugging tricks.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHow does TAC prevent debugging?\n\u003cul\u003e\n\u003cli\u003eTAC loops through all threads in the current process by using \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot\"\u003eCreateToolHelpSnapshot32\u003c/a\u003e with SnapThread passed and checks the thread for a DebugObject, which is going to be present if a debugger is running.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_loop_threads_debug\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003efn callback\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tHANDLE snapshot \u003cspan\u003e=\u003c/span\u003e CreateToolhelp32Snapshot\u003cspan\u003e(\u003c/span\u003eTH32CS_SNAPTHREAD\u003cspan\u003e,\u003c/span\u003e GetCurrentProcessId\u003cspan\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tTHREADENTRY32 te32\u003cspan\u003e{};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tte32\u003cspan\u003e.\u003c/span\u003edwSize \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ete32\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003edo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ete32\u003cspan\u003e.\u003c/span\u003eth32OwnerProcessID \u003cspan\u003e!=\u003c/span\u003e GetCurrentProcessId\u003cspan\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003econtinue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003econst\u003c/span\u003e HANDLE thread_handle \u003cspan\u003e=\u003c/span\u003e OpenThread\u003cspan\u003e(\u003c/span\u003eTHREAD_ALL_ACCESS\u003cspan\u003e,\u003c/span\u003e FALSE\u003cspan\u003e,\u003c/span\u003e te32\u003cspan\u003e.\u003c/span\u003eth32ThreadID\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ethread_handle\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\tHANDLE debug_object_handle \u003cspan\u003e=\u003c/span\u003e INVALID_HANDLE_VALUE\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\tULONG ret_length \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\tTHREAD_BASIC_INFORMATION thread_basic_information\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003eNtQueryInformationThread\u003cspan\u003e(\u003c/span\u003ethread_handle\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003ethread_basic_information\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ethread_basic_information\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003eret_length\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e              \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ethread_basic_information\u003cspan\u003e.\u003c/span\u003eTebBaseAddress\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e              \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ethread_basic_information\u003cspan\u003e.\u003c/span\u003eTebBaseAddress\u003cspan\u003e-\u0026gt;\u003c/span\u003eDbgSsReserved\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                  debug_object_handle \u003cspan\u003e=\u003c/span\u003e HANDLE\u003cspan\u003e(\u003c/span\u003ethread_basic_information\u003cspan\u003e.\u003c/span\u003eTebBaseAddress\u003cspan\u003e-\u0026gt;\u003c/span\u003eDbgSsReserved\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e              \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003edebug_object_handle \u003cspan\u003e!=\u003c/span\u003e INVALID_HANDLE_VALUE\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\tcallback\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\tCloseHandle\u003cspan\u003e(\u003c/span\u003ethread_handle\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003ewhile\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eThread32Next\u003cspan\u003e(\u003c/span\u003esnapshot\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003ete32\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tCloseHandle\u003cspan\u003e(\u003c/span\u003esnapshot\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003eA weird anti-debug trick.\n\u003cul\u003e\n\u003cli\u003eIt throws an access violation by writing to invalid memory; if the code ever gets past the exception, a debugger got past it or handled the exception properly.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_exception_anti_debug\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003efn callback\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// this is writing to invalid memory and will throw an access violation\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e  __sidt\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e0xFFFFFF8000000900LL\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  callback\u003cspan\u003e();\u003c/span\u003e \u003cspan\u003e// this should never be reached\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003eStandard API check\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_check_remote_debugger\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ecallback cb\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  BOOL dbg \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eCheckRemoteDebuggerPresent\u003cspan\u003e((\u003c/span\u003eHANDLE\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003edbg\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003edbg\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      cb\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e// the process will close\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eThreadHideFromDebugger sends exceptions to the process instead of the debugger which means\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003ewhenever the debugger attempts to pause the process\u003cspan\u003e,\u003c/span\u003e a STATUS_BREAKPOINT exception will go off which will close the process\u003cspan\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eThe best part about \u003cspan\u003ethis\u003c/span\u003e is you can not unset the ThreadHideFromDebugger flag once its been set from user mode\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e tactic runs in their tls callback which is before the entry point of the exe\u003cspan\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e```\u003c/span\u003ec\u003cspan\u003e++\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e ac_hide_current_thread\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003echar\u003c/span\u003e use_ThreadHideFromDebugger \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    nt_set_information_thread\u003cspan\u003e((\u003c/span\u003eHANDLE\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e ThreadHideFromDebugger\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003euse_ThreadHideFromDebugger\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"monitoring-network-traffic\"\u003eMonitoring Network Traffic\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eThis is a super cool detection method used for some cheats, and don’t be alarmed by this; they do not store any of your active connections; they are only looking for a very specific check.\n\u003cul\u003e\n\u003cli\u003eA cheater can write shellcode into the game process that starts a network server inside of the game process on the local network, then the cheater can have their external application send and receive information to this local server, kind of like a local command and control center.\n\u003cul\u003e\n\u003cli\u003eHere’s how it’s implemented.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// custom tac struct\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003etcp_entry\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  DWORD OwningPid\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  DWORD LocalAddr\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  DWORD RemoteAddr\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  DWORD LocalPort\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  DWORD RemotePort\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_detect_local_command_center\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003efn callback\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// WSA must be the first call before any other Windows socket functions can be called successfully \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\tWSAData data\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tWSAStartup\u003cspan\u003e(\u003c/span\u003eMAKEWORD\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003edata\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003ebool\u003c/span\u003e successfully_looped_tcp_table \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e__int64\u003c/span\u003e tcp_table_container\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e]{};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// allocate the table\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003eauto\u003c/span\u003e table \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003ePMIB_TCPTABLE2\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003emalloc\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eMIB_TCPTABLE2\u003cspan\u003e)));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// get the tcp table size, the first call is expected to fail\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\tULONG size\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eauto\u003c/span\u003e result \u003cspan\u003e=\u003c/span\u003e GetTcpTable2\u003cspan\u003e(\u003c/span\u003etable\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003esize\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eresult \u003cspan\u003e==\u003c/span\u003e ERROR_INSUFFICIENT_BUFFER\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\tfree\u003cspan\u003e(\u003c/span\u003etable\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\ttable \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003ePMIB_TCPTABLE2\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003emalloc\u003cspan\u003e(\u003c/span\u003esize\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// store the tcp table into our newly allocated buffer \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\tresult \u003cspan\u003e=\u003c/span\u003e GetTcpTable2\u003cspan\u003e(\u003c/span\u003etable\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003esize\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003eresult\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e// it returns NO_ERROR which is 0x0 on success\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e i64 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e i64 \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003esigned\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003etable\u003cspan\u003e-\u0026gt;\u003c/span\u003edwNumEntries\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e++\u003c/span\u003ei64\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003e// store each entry\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\tPMIB_TCPROW2 tableptr \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003etable\u003cspan\u003e-\u0026gt;\u003c/span\u003etable\u003cspan\u003e[\u003c/span\u003ei64\u003cspan\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int8\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eadd_tcp_entry\u003cspan\u003e(\u003c/span\u003etableptr\u003cspan\u003e,\u003c/span\u003e tcp_table_container\u003cspan\u003e)))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\tsuccessfully_looped_tcp_table \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// memory is no longer needed\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\tfree\u003cspan\u003e(\u003c/span\u003etable\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003esuccessfully_looped_tcp_table\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// get the current process id\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e current_process_id \u003cspan\u003e=\u003c/span\u003e GetCurrentProcessId\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\ttcp_entry\u003cspan\u003e*\u003c/span\u003e tcp_table\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\tinit_tcp_table_entry\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003etcp_table\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\ttcp_entry\u003cspan\u003e*\u003c/span\u003e dummy\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// loop the tcp table\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003etcp_table \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003eget_tcp_table_entry\u003cspan\u003e(\u003c/span\u003etcp_table_container\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003edummy\u003cspan\u003e);;\u003c/span\u003e increment_tcp_table_entry\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003etcp_table\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003eauto\u003c/span\u003e next_tcp_entry \u003cspan\u003e=\u003c/span\u003e get_next_tcp_entry\u003cspan\u003e(\u003c/span\u003etcp_table_container\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003edummy\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003e// break if we are just comparing the same entry\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003etcp_entires_different\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003etcp_table\u003cspan\u003e,\u003c/span\u003e next_tcp_entry\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003eauto\u003c/span\u003e tcp_ptr \u003cspan\u003e=\u003c/span\u003e get_tcp_ptr\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003etcp_table\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e            \u003cspan\u003e// verify the entry was created by the current process\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003etcp_ptr\u003cspan\u003e-\u0026gt;\u003c/span\u003eOwningPid \u003cspan\u003e==\u003c/span\u003e current_process_id\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                \u003cspan\u003e// get the other entries\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\t\ttcp_entry\u003cspan\u003e*\u003c/span\u003e entry2\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\tinit_tcp_table_entry\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003eentry2\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eentry2 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003eget_tcp_table_entry\u003cspan\u003e(\u003c/span\u003etcp_table_container\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003edummy\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e;\u003c/span\u003e increment_tcp_table_entry\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003eentry2\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\t\u003cspan\u003eauto\u003c/span\u003e next_entry2 \u003cspan\u003e=\u003c/span\u003e get_next_tcp_entry\u003cspan\u003e(\u003c/span\u003etcp_table_container\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003edummy\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    \u003cspan\u003e// we have relooped back to the start, break\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\t\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003etcp_entires_different\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003eentry2\u003cspan\u003e,\u003c/span\u003e next_entry2\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\t\t\u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\t\u003cspan\u003eauto\u003c/span\u003e entry2_tcp_ptr \u003cspan\u003e=\u003c/span\u003e get_tcp_ptr\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003eentry2\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                    \u003cspan\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e                    if the entrys port and the one found inside the current process match\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e                    and they aren\u0026#39;t owned by the same process \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e                    */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eentry2_tcp_ptr\u003cspan\u003e-\u0026gt;\u003c/span\u003eLocalPort \u003cspan\u003e==\u003c/span\u003e tcp_ptr\u003cspan\u003e-\u0026gt;\u003c/span\u003eRemotePort \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                        entry2_tcp_ptr\u003cspan\u003e-\u0026gt;\u003c/span\u003eOwningPid \u003cspan\u003e!=\u003c/span\u003e tcp_ptr\u003cspan\u003e-\u0026gt;\u003c/span\u003eOwningPid\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                        \u003cspan\u003e// flagged\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\t\t\t\t\tcallback\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"encrypted-custom-syscalls\"\u003eEncrypted Custom Syscalls\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eWhenever you look at exported APIs in ntdll, you’ll notice most of them do a syscall.\u003c/li\u003e\n\u003cli\u003eA syscall is what moves over into the kernel, where the actual implementation of the function is.\u003c/li\u003e\n\u003cli\u003eThis is what a syscall stub looks like.\u003c/li\u003e\n\u003cli\u003eIMO this is the coolest feature TAC has!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"asm\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; rcx is used by the kernel as a jump back location for the syscall instruction.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; rcx needs to be stored so the kernel can use it.    \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003emov\u003c/span\u003e \u003cspan\u003er10\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ercx\u003c/span\u003e                                                             \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003emov\u003c/span\u003e \u003cspan\u003eeax\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x11B\u003c/span\u003e  \u003cspan\u003e; eax holds the syscall index which the kernel looks up in the table of system calls                                                                                                               \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003esyscall\u003c/span\u003e                                                                    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eret\u003c/span\u003e                                                                                                                                               \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eWriting your own syscall stub has a purpose. Whenever a user-mode cheat hooks those ntdll functions that syscall, it’ll work, but their hooks can be bypassed very easily if the anti-cheat just calls the syscall instruction with eax set to the same syscall index as the normal function.\u003c/li\u003e\n\u003cli\u003eSyscalls are vulnerable to instrumentation callbacks; these are callbacks coded into Windows, and they will work on every single user-mode process.\u003c/li\u003e\n\u003cli\u003eThese callbacks will catch every syscall instruction and every exception.\n\u003cul\u003e\n\u003cli\u003eJust an FYI, instrumentation callbacks are called AFTER the syscall; their return address will be right after the syscall instruction.\u003c/li\u003e\n\u003cli\u003eThis would normally allow cheaters to easily see where every syscall is coming from since all of the functions using it are just exported in ntdll.\u003c/li\u003e\n\u003cli\u003eIt fails because the cheater will see a syscall from a random ntdll function, rather than the anti-cheat code.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to see instrumentations in action, you can do so \u003ca href=\"https://github.com/Deputation/instrumentation_callbacks\"\u003ehere\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eLet’s take a look at TAC’s custom syscall stub.\u003c/strong\u003e\n\u003cimg src=\"https://ssno.cc/syscall_stub.png\" alt=\"image info\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAt a quick glance, this is very confusing and hard to figure out statically.\u003c/li\u003e\n\u003cli\u003eThey even make it confusing to see what memory is being written to.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c\"\u003e\u003cspan\u003e\u003cspan\u003esome_random_text_encrypted_func\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e((\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003eloc_7FF60E12D0B0 \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e4095\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003e0xFFFFFFFFFFFFF000uLL\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eIt turned out to be pretty simple to figure this out and understand exactly how it works.\u003c/li\u003e\n\u003cli\u003eThat memory being written to is actually a large chunk allocated in the .text section that they just virtual protect for write/execute rights.\u003c/li\u003e\n\u003cli\u003eNow we could spend all day in our XOR calculator and try to build the byte array of these XOR encrypted instructions ourselves.\u003c/li\u003e\n\u003cli\u003eOr we could just let the computer do it….\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis was pretty much just copy and paste from IDA Pro, all I did was allocate my own memory here.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eauto\u003c/span\u003e v3867 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e12288LL\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eLABEL_1798\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eauto\u003c/span\u003e v2168 \u003cspan\u003e=\u003c/span\u003e __rdtsc\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e%\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ev3867 \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eauto\u003c/span\u003e v1328 \u003cspan\u003e=\u003c/span\u003e v2168\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eauto\u003c/span\u003e ac_NtReadFile_1 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003eGetProcAddress\u003cspan\u003e(\u003c/span\u003eGetModuleHandleA\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;ntdll\u0026#34;\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e\u0026#34;NtReadFile\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e__int64\u003c/span\u003e i67 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ei67 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e++\u003c/span\u003ei67\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ev1328 \u003cspan\u003e+\u003c/span\u003e i67 \u003cspan\u003e\u0026gt;=\u003c/span\u003e v3867\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003egoto\u003c/span\u003e LABEL_1798\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eac_NtReadFile_1\u003cspan\u003e[\u003c/span\u003ei67 \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e v1328\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int8\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003eac_NtReadFile_1\u003cspan\u003e[\u003c/span\u003ei67 \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e v1328\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e195\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e ac_NtReadFile_1\u003cspan\u003e[\u003c/span\u003ei67 \u003cspan\u003e+\u003c/span\u003e v1328\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eauto\u003c/span\u003e nt_read_file_syscall_instruction \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003eac_NtReadFile_1\u003cspan\u003e[\u003c/span\u003ei67 \u003cspan\u003e+\u003c/span\u003e v1328\u003cspan\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003evolatile\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e syscall_stub_memory \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003eVirtualAlloc\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0x4096\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e MEM_COMMIT \u003cspan\u003e|\u003c/span\u003e MEM_RESERVE\u003cspan\u003e,\u003c/span\u003e PAGE_EXECUTE_READWRITE\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e__int64\u003c/span\u003e syscall_index \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// this is going to be the syscall index; it\u0026#39;s 0 here just while I\u0026#39;m explaining\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003eauto\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x50\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// it\u0026#39;s just here to add to the confusion; this can be any number above 4\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_QWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e28LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003ent_read_file_syscall_instruction\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_QWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e20LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x63B4B73DD1E509A9LL\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_QWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e20LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^=\u003c/span\u003e \u003cspan\u003e0x7FA6B73DD1E72C56uLL\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e12LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e syscall_index\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e8LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e997864955\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e8LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^=\u003c/span\u003e \u003cspan\u003e0x7CEB6A07u\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1006268688\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^=\u003c/span\u003e \u003cspan\u003e0x62ADC0BFu\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e4LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1637542171\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e4LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^=\u003c/span\u003e \u003cspan\u003e0x75B49DA9u\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e16LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e109211239\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e16LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^=\u003c/span\u003e \u003cspan\u003e0xBBCA6C8C\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eauto\u003c/span\u003e syscall_stub_ptr \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__fastcall\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003e_QWORD\u003cspan\u003e,\u003c/span\u003e _QWORD\u003cspan\u003e,\u003c/span\u003e _QWORD\u003cspan\u003e,\u003c/span\u003e _QWORD\u003cspan\u003e))(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset_that_doesnt_matter \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e4LL\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    printf\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;memory allocated: %p\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e syscall_stub_ptr\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    getchar\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eInspecting this memory address reveals the unencrypted shellcode and we can see the standard syscall stub here.\n\u003cbr/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003eStarting with the “mov r10, rcx” instruction.\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"https://ssno.cc/spoof_stub1.png\" alt=\"image info\"/\u003e\n\u003cbr/\u003e\u003c/p\u003e\n\u003cp\u003eFollowing that jmp after the mov, 0x2C is the NtTerminateProcess syscall index for my Windows version, and we can see that being moved into eax.\n\u003cbr/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ssno.cc/spoof_stub2.png\" alt=\"image info\"/\u003e\n\u003cbr/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003eFollowing the jump after mov eax, this is where the address of the syscall instruction comes in; it’s just a jump to it.\n\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003e\u003cstrong\u003eSyscall instruction.\u003c/strong\u003e\n\u003cimg src=\"https://ssno.cc/spoof_stub3.png\" alt=\"image info\"/\u003e\n\u003cbr/\u003e\n\u003cimg src=\"https://ssno.cc/spoof_stub4.png\" alt=\"image info\"/\u003e\n\u003cbr/\u003e\u003c/p\u003e\n\u003cp\u003eWe can take a look at where this syscall instruction is located, just to verify that it’s a bit random.\n\u003cimg src=\"https://ssno.cc/spoof_stub5.png\" alt=\"image info\"/\u003e\n\u003cbr/\u003e\u003c/p\u003e\n\u003cp\u003eAnd just to double-check, if we run the code again, our syscall instruction location will change!\n\u003cimg src=\"https://ssno.cc/spoof_stub6.png\" alt=\"image info\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThis is a lot, so let’s recap quickly.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhy would you use a custom syscall stub?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThis will completely bypass cheaters hooking ntdll functions.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhat’s going on with the NtReadFile stuff?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTAC is actually searching for the syscall instruction; their encrypted syscall stub is designed to actually fake where syscalls are coming from, the CPU time is the RNG factor.\u003c/li\u003e\n\u003cli\u003eExample: Someone monitoring the process will see that a syscall happened from NtReadFile, so they’ll do some inspecting and try to cover up anything NtReadFile would expose of theirs, but the syscall wasn’t even NtReadFile. The actual syscall could have been anything; the cheater will never know unless they’re able to inspect the eax register after the syscall (which should be cleared out and replaced with the NTSTATUS code). This is really cool; an attacker won’t have any way of knowing what syscall instruction to monitor.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eA good way to monitor these would be preventing page execute protections, and looking at the exception, this is what the stub looks like in Ida Pro.\n\u003cimg src=\"https://ssno.cc/syscall_ida.png\" alt=\"image info\"/\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eJust for bonus points, I’ve recreated their syscalling method.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"cpp\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003eget_syscall_index\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e address\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eaddress\u003cspan\u003e)[\u003c/span\u003e\u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e \u003cspan\u003eget_syscall_instruction_address\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e func\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e distance \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e12288LL\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eLABEL_1798\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e starting_distance \u003cspan\u003e=\u003c/span\u003e __rdtsc\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e%\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003edistance \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eauto\u003c/span\u003e ntdll_exported_func \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003efunc\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e__int64\u003c/span\u003e syscall_instruction_spot \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003esyscall_instruction_spot \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e++\u003c/span\u003esyscall_instruction_spot\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003estarting_distance \u003cspan\u003e+\u003c/span\u003e syscall_instruction_spot \u003cspan\u003e\u0026gt;=\u003c/span\u003e distance\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003egoto\u003c/span\u003e LABEL_1798\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003entdll_exported_func\u003cspan\u003e[\u003c/span\u003esyscall_instruction_spot \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e starting_distance\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int8\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003entdll_exported_func\u003cspan\u003e[\u003c/span\u003esyscall_instruction_spot \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e starting_distance\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e195\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e ntdll_exported_func\u003cspan\u003e[\u003c/span\u003esyscall_instruction_spot \u003cspan\u003e+\u003c/span\u003e starting_distance\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\t\u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003entdll_exported_func\u003cspan\u003e[\u003c/span\u003esyscall_instruction_spot \u003cspan\u003e+\u003c/span\u003e starting_distance\u003cspan\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e \u003cspan\u003egenerate_syscall_stub\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e syscall_instruction\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e syscall_index\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e base\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e size\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ebase \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003enullptr\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e size \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003esize \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x4096\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eauto\u003c/span\u003e offset \u003cspan\u003e=\u003c/span\u003e rand\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e%\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003esize \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e0x40\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// using virtual allocated memory just for the example, game has a .text blob allocated for this\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003evolatile\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e syscall_stub_memory \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eVirtualAlloc\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003esize\u003cspan\u003e,\u003c/span\u003e MEM_COMMIT \u003cspan\u003e|\u003c/span\u003e MEM_RESERVE\u003cspan\u003e,\u003c/span\u003e PAGE_EXECUTE_READWRITE\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_QWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e28LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003esyscall_instruction\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_QWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e20LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0x63B4B73DD1E509A9LL\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_QWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e20LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^=\u003c/span\u003e \u003cspan\u003e0x7FA6B73DD1E72C56uLL\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e12LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e syscall_index\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e8LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e997864955\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e8LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^=\u003c/span\u003e \u003cspan\u003e0x7CEB6A07u\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1006268688\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^=\u003c/span\u003e \u003cspan\u003e0x62ADC0BFu\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e4LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1637542171\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e4LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^=\u003c/span\u003e \u003cspan\u003e0x75B49DA9u\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e16LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e109211239\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e_DWORD\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e16LL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e^=\u003c/span\u003e \u003cspan\u003e0xBBCA6C8C\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e*\u003c/span\u003ebase \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003esyscall_stub_memory\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003esyscall_stub_memory \u003cspan\u003e+\u003c/span\u003e offset \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e4LL\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003efree_syscall_stub\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e base\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e size\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tmemset\u003cspan\u003e(\u003c/span\u003ebase\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e size\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tVirtualFree\u003cspan\u003e(\u003c/span\u003ebase\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e MEM_RELEASE\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e Params\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e NTSTATUS spoof_syscall\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e exported_ntdll_function\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e function_to_call\u003cspan\u003e,\u003c/span\u003e Params\u003cspan\u003e...\u003c/span\u003e params\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e base_address_of_stub \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eint\u003c/span\u003e stub_size \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e nt_syscall_instruction \u003cspan\u003e=\u003c/span\u003e get_syscall_instruction_address\u003cspan\u003e(\u003c/span\u003eexported_ntdll_function\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e syscall_index \u003cspan\u003e=\u003c/span\u003e get_syscall_index\u003cspan\u003e(\u003c/span\u003efunction_to_call\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e stub \u003cspan\u003e=\u003c/span\u003e generate_syscall_stub\u003cspan\u003e(\u003c/span\u003ent_syscall_instruction\u003cspan\u003e,\u003c/span\u003e syscall_index\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003ebase_address_of_stub\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003estub_size\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tNTSTATUS result \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eNTSTATUS\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__fastcall\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003eParams\u003cspan\u003e...)\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003estub\u003cspan\u003e)(\u003c/span\u003eparams\u003cspan\u003e...);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tfree_syscall_stub\u003cspan\u003e(\u003c/span\u003ebase_address_of_stub\u003cspan\u003e,\u003c/span\u003e stub_size\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003ereturn\u003c/span\u003e result\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eterminate_process\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e syassasd \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eGetProcAddress\u003cspan\u003e(\u003c/span\u003eLoadLibraryA\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;ntdll\u0026#34;\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e\u0026#34;NtTerminateProcess\u0026#34;\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e spoof_start \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eGetProcAddress\u003cspan\u003e(\u003c/span\u003eLoadLibraryA\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;ntdll\u0026#34;\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e\u0026#34;NtOpenFile\u0026#34;\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tspoof_syscall\u003cspan\u003e(\u003c/span\u003espoof_start\u003cspan\u003e,\u003c/span\u003e syassasd\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003estatic_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eHANDLE\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e1337\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e argc\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e argv\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tterminate_process\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet’s test this just to make sure.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ssno.cc/poc_syscall.png\" alt=\"image info\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe can see this is working exactly how it should! Again, this is clever and even more effective; cheaters will have no clue which syscall instruction to watch out for.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"detecting-anti-debugger-hiding-attempts\"\u003eDetecting Anti-Debugger-Hiding Attempts\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eIt’s common for anti-debugging or anti-cheat threads to set \u003ccode\u003eThreadHideFromDebugger\u003c/code\u003e to true.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhenever a thread has \u003ccode\u003eThreadHideFromDebugger\u003c/code\u003e set, any exceptions thrown from that thread will skip past a debugger and crash the process or be handled in the process’s structured exception handling.\u003c/li\u003e\n\u003cli\u003eWhich means this flag is pretty important, and you want to make sure someone isn’t spying on your activity.\u003c/li\u003e\n\u003cli\u003eTAC has a pretty interesting approach to detecting hooks for this.\n\u003cul\u003e\n\u003cli\u003eTo set \u003ccode\u003eThreadHideFromDebugger\u003c/code\u003e, the API \u003ccode\u003eNtSetInformationThread\u003c/code\u003e must be called.\u003c/li\u003e\n\u003cli\u003eCheaters can hook this and just return TRUE whenever \u003ccode\u003eThreadHideFromDebugger\u003c/code\u003e is being requested. This will make the anti-cheat think it has been successfully hidden even though nothing happened.\u003c/li\u003e\n\u003cli\u003eThis method detects poorly made hooks.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e#define ThreadHideFromDebugger 17\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) \u0026gt;= 0)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e__forceinline\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_detect_hidden_thread\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ecallback cb\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\tHANDLE current_thread_handle \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eHANDLE\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003echar\u003c/span\u003e use_ThreadHideFromDebugger \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e// this call will fail because NtSetInformationThread returns  \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e// STATUS_INFO_LENGTH_MISMATCH if the length parameter is set\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003e// if it doesn\u0026#39;t fail, then this function has been poorly hooked\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\tNTSTATUS query_result_1 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ent_set_information_thread\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                              current_thread_handle\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                              ThreadHideFromDebugger\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                              \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003euse_ThreadHideFromDebugger\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                              \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNT_SUCCESS\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003equery_result_1\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eprintf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;fake call passed\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003ecb\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e// this should return 0 always \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e// when running under a debugger with ScyllaHide, this returns 0xC000005.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\tNTSTATUS query_result_2 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ent_set_information_thread\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ecurrent_thread_handle\u003cspan\u003e,\u003c/span\u003e ThreadHideFromDebugger\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003equery_result_2 \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003eprintf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;second call failed\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\t\u003cspan\u003ecb\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003e// this will catch hooks that do not check the size properly\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003e// NtQueryInformationThread expects the size to be 1, not 4.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\t\u003cspan\u003e// 4 is sizeof(BOOL) vs sizeof(bool), which is 1.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    NTSTATUS query_result_3 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ent_query_information_thread\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                              current_thread_handle\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                              ThreadHideFromDebugger\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                              \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003euse_ThreadHideFromDebugger\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                              \u003cspan\u003e4LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e                              \u003cspan\u003eNULL\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNT_SUCCESS\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003equery_result_3\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \t\u003cspan\u003eprintf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;third call succeeded\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \t\u003cspan\u003ecb\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// this call just passes a fake handle to check\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e// for a hook returning success whenever ThreadHideFromDebugger is passed\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    HANDLE fake_handle \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eHANDLE\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e__rdtsc\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    NTSTATUS query_result_4 \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ent_set_information_thread\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003efake_handle\u003cspan\u003e,\u003c/span\u003e ThreadHideFromDebugger\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0LL\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNT_SUCCESS\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003equery_result_3\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \t\u003cspan\u003eprintf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;fourth call succeeded\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \t\u003cspan\u003ecb\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis is the result when running under x64dbg with ScyllaHide.\n\u003cbr/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ssno.cc/scyllahide.png\" alt=\"image info\"/\u003e\u003c/p\u003e\n\u003cp\u003eAnd this is the result without a debugger and without ScyllaHide.\n\u003cbr/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ssno.cc/no_scyllahide.png\" alt=\"image info\"/\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"create-remote-thread-blocking\"\u003eCreate Remote Thread Blocking\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTAC installs an exception handler that just calls \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread\"\u003eTerminateThread\u003c/a\u003e on the \u003ccode\u003eSTATUS_PRIVILEGED_INSTRUCTION\u003c/code\u003e exception code.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThere’s a good reason for this; when cheaters manually map their DLL, they need a way to get the remote process to actually run the shellcode they wrote. One of the most common ways of doing this is \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread\"\u003eCreateRemoteThread\u003c/a\u003e, which just allows the cheater to have a newly created thread that immediately executes their shellcode.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHow is it detected?:\n\u003cul\u003e\n\u003cli\u003eTLS callbacks are callbacks that can be planted inside of a Windows PE file; these callbacks are called before the thread’s entry point whenever a thread is created.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHere’s how that works; keep in mind that we are running in the current thread context of the newly created thread.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"asm\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; this isn\u0026#39;t exactly how the game does this \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e; anyways, this will still raise the STATUS_PRIVILEGED_INSTRUCTION exception.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ePUBLIC\u003c/span\u003e \u003cspan\u003e_priv_ins_exx\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e.code\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e_priv_ins_exx\u003c/span\u003e \u003cspan\u003ePROC\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\t\u003cspan\u003emov\u003c/span\u003e \u003cspan\u003erax\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003edr0\u003c/span\u003e \u003cspan\u003e; dr0 is privileged and we do not have access\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e_priv_ins_exx\u003c/span\u003e \u003cspan\u003eENDP\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eEND\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003eLONG WINAPI \u003cspan\u003eac_vectored_handler\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eEXCEPTION_POINTERS\u003cspan\u003e*\u003c/span\u003e exptrs\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// this code is running in the same thread as the TLS callback\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eexptrs\u003cspan\u003e-\u0026gt;\u003c/span\u003eExceptionRecord\u003cspan\u003e-\u0026gt;\u003c/span\u003eExceptionCode \u003cspan\u003e==\u003c/span\u003e STATUS_PRIVILEGED_INSTRUCTION\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e// terminate the current thread\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e        TerminateThread\u003cspan\u003e(\u003c/span\u003eNtCurrentThread\u003cspan\u003e(),\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eVOID WINAPI \u003cspan\u003etls_callback\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ePVOID DllHandle\u003cspan\u003e,\u003c/span\u003e DWORD Reason\u003cspan\u003e,\u003c/span\u003e PVOID Reserved\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eReason \u003cspan\u003e==\u003c/span\u003e DLL_THREAD_ATTACH\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e// collect the threads start address\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e      \u003cspan\u003e__int64\u003c/span\u003e start_address \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      NtQueryInformationThread\u003cspan\u003e(\u003c/span\u003eNtCurrentThread\u003cspan\u003e(),\u003c/span\u003e ThreadQuerySetWin32StartAddress\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003estart_address\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003estart_address\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e// assume the address is invalid until proven otherwise\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e      \u003cspan\u003ebool\u003c/span\u003e outside_of_valid_module \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e// loop the current loaded modules list\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e      \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e memory_module_list \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003ent\u003cspan\u003e::\u003c/span\u003ePTEB\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eNtCurrentTeb\u003cspan\u003e())\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003eProcessEnvironmentBlock\u003cspan\u003e-\u0026gt;\u003c/span\u003eLdr\u003cspan\u003e-\u0026gt;\u003c/span\u003eInMemoryOrderModuleList\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ePLIST_ENTRY p_list_entry \u003cspan\u003e=\u003c/span\u003e memory_module_list\u003cspan\u003e-\u0026gt;\u003c/span\u003eFlink\u003cspan\u003e;\u003c/span\u003e p_list_entry \u003cspan\u003e!=\u003c/span\u003e memory_module_list\u003cspan\u003e;\u003c/span\u003e p_list_entry \u003cspan\u003e=\u003c/span\u003e p_list_entry\u003cspan\u003e-\u0026gt;\u003c/span\u003eFlink\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003eauto\u003c/span\u003e p_entry \u003cspan\u003e=\u003c/span\u003e CONTAINING_RECORD\u003cspan\u003e(\u003c/span\u003ep_list_entry\u003cspan\u003e,\u003c/span\u003e nt\u003cspan\u003e::\u003c/span\u003eLDR_DATA_TABLE_ENTRY\u003cspan\u003e,\u003c/span\u003e InMemoryOrderLinks\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e// this condition will be true as long as the start address is within a loaded dlls range.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e          \u003cspan\u003e// example: memory such as 0x1E000000000 will not exist in any module (any memory from the result of a virtual alloc call will not be valid.)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e          \u003cspan\u003e// while something like 0x7FFF12397591 could be inside of ntdll.dll\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e          \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003estart_address \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ep_entry\u003cspan\u003e-\u0026gt;\u003c/span\u003eDllBase\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e start_address \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ep_entry\u003cspan\u003e-\u0026gt;\u003c/span\u003eDllBase\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e p_entry\u003cspan\u003e-\u0026gt;\u003c/span\u003eSizeOfImage\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e              outside_of_valid_module \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e              \u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e// if we failed to prove the address is valid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eoutside_of_valid_module\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          callback\u003cspan\u003e();\u003c/span\u003e \u003cspan\u003e// detection is stored and uploaded later\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e          _priv_ins_exx\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"dumping-exception-handlers\"\u003eDumping Exception Handlers\u003c/h2\u003e\n\u003cp\u003eFor those interested in how I dumped the exception handlers, I’ve provided the code.\nYou’ll need to update these offsets if you want to use this.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003edump_exception_handlers\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// 75 ? 4C 8D 9C 24 ? ? ? ? 48 8B C3 : mov xxx, rsi\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e  \u003cspan\u003e__int64\u003c/span\u003e exception_filter \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003eGetModuleHandleA\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;kernelbase.dll\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e0x28CC60\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eauto\u003c/span\u003e rtl_decode_pointer \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereinterpret_cast\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__fastcall\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eget_address\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;ntdll.dll\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;RtlDecodePointer\u0026#34;\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// F0 0F AB 48 : lea rcx \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e  PLDRP_VECTOR_HANDLER_LIST vector_list \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ePLDRP_VECTOR_HANDLER_LIST\u003cspan\u003e)((\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003eGetModuleHandleA\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;ntdll.dll\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e0x17F3E8\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  LIST_ENTRY\u003cspan\u003e*\u003c/span\u003e list_head \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003evector_list\u003cspan\u003e-\u0026gt;\u003c/span\u003eLdrpVehList\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// this will be the function passed into SetUnhandledExceptionFilter \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e  log\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;UnhandledExceptionFilter: 0x%p\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e rtl_decode_pointer\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003eexception_filter\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// dump out the vectored handler list\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e  \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eLIST_ENTRY\u003cspan\u003e*\u003c/span\u003e list_entry \u003cspan\u003e=\u003c/span\u003e list_head\u003cspan\u003e-\u0026gt;\u003c/span\u003eFlink\u003cspan\u003e;\u003c/span\u003e list_entry \u003cspan\u003e!=\u003c/span\u003e list_head\u003cspan\u003e;\u003c/span\u003e list_entry \u003cspan\u003e=\u003c/span\u003e list_entry\u003cspan\u003e-\u0026gt;\u003c/span\u003eFlink\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \tPVECTOR_HANDLER_ENTRY pEntry \u003cspan\u003e=\u003c/span\u003e CONTAINING_RECORD\u003cspan\u003e(\u003c/span\u003elist_entry\u003cspan\u003e,\u003c/span\u003e VECTOR_HANDLER_ENTRY\u003cspan\u003e,\u003c/span\u003e ListEntry\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\u003cspan\u003e__int64\u003c/span\u003e pExceptionHandler \u003cspan\u003e=\u003c/span\u003e rtl_decode_pointer\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003epEntry\u003cspan\u003e-\u0026gt;\u003c/span\u003eEncodedHandler\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \tTCHAR modname\u003cspan\u003e[\u003c/span\u003eMAX_PATH\u003cspan\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \tGetModuleBaseNameW\u003cspan\u003e(\u003c/span\u003eGetCurrentProcess\u003cspan\u003e(),\u003c/span\u003e GetModuleHandle\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNULL\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e modname\u003cspan\u003e,\u003c/span\u003e MAX_PATH\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \tlog\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;VEH: 0x%p (%ws) [0x%p]\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e pExceptionHandler\u003cspan\u003e,\u003c/span\u003e modname\u003cspan\u003e,\u003c/span\u003e pExceptionHandler \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003eGetModuleHandleW\u003cspan\u003e(\u003c/span\u003emodname\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// dump out the continued handler list\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e  list_head \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003evector_list\u003cspan\u003e-\u0026gt;\u003c/span\u003eLdrpVchList\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eLIST_ENTRY\u003cspan\u003e*\u003c/span\u003e list_entry \u003cspan\u003e=\u003c/span\u003e list_head\u003cspan\u003e-\u0026gt;\u003c/span\u003eFlink\u003cspan\u003e;\u003c/span\u003e list_entry \u003cspan\u003e!=\u003c/span\u003e list_head\u003cspan\u003e;\u003c/span\u003e list_entry \u003cspan\u003e=\u003c/span\u003e list_entry\u003cspan\u003e-\u0026gt;\u003c/span\u003eFlink\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \tPVECTOR_HANDLER_ENTRY pEntry \u003cspan\u003e=\u003c/span\u003e CONTAINING_RECORD\u003cspan\u003e(\u003c/span\u003elist_entry\u003cspan\u003e,\u003c/span\u003e VECTOR_HANDLER_ENTRY\u003cspan\u003e,\u003c/span\u003e ListEntry\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \t\u003cspan\u003e__int64\u003c/span\u003e pExceptionHandler \u003cspan\u003e=\u003c/span\u003e rtl_decode_pointer\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003epEntry\u003cspan\u003e-\u0026gt;\u003c/span\u003eEncodedHandler\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \tTCHAR modname\u003cspan\u003e[\u003c/span\u003eMAX_PATH\u003cspan\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \tGetModuleBaseNameW\u003cspan\u003e(\u003c/span\u003eGetCurrentProcess\u003cspan\u003e(),\u003c/span\u003e GetModuleHandle\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNULL\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e modname\u003cspan\u003e,\u003c/span\u003e MAX_PATH\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \tlog\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;VCH: 0x%p (%ws) [0x%p]\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e pExceptionHandler\u003cspan\u003e,\u003c/span\u003e modname\u003cspan\u003e,\u003c/span\u003e pExceptionHandler \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__int64\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003eGetModuleHandleW\u003cspan\u003e(\u003c/span\u003emodname\u003cspan\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"mystery-tech\"\u003eMystery Tech?\u003c/h2\u003e\n\u003cp\u003eI’m not sure what this is, but it looks like something that would flag virtual machines or custom versions of Windows.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_check_allocation_grad\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003efn callback\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  SYSTEM_BASIC_INFORMATION sbi\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  NtQuerySystemInformation\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003esbi\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003esbi\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003enullptr\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003esbi\u003cspan\u003e.\u003c/span\u003eAllocationGranularity \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e0x10000\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    callback\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSince TAC is so reliant on the linked module list, they have a check that prevents someone from setting it to an empty list. Setting this to an empty list will probably break the process anyway.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"c++\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eac_detect_invalidated_module_list\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003efn callback\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e memory_module_list \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003eNtCurrentPeb\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003eLdr\u003cspan\u003e-\u0026gt;\u003c/span\u003eInMemoryOrderModuleList\u003cspan\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ememory_module_list\u003cspan\u003e-\u0026gt;\u003c/span\u003eFlink \u003cspan\u003e==\u003c/span\u003e memory_module_list\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    callback\u003cspan\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"the-end\"\u003eThe End\u003c/h2\u003e\n\u003cp\u003eTAC is a pretty cool user-mode anti-cheat, with features such as runtime API lookups, detecting poorly made hooks by passing clever invalid parameters, external overlay detection, internal DirectX hook detection, checking APIs that it uses for hooks, checking for debuggers and debugging artifacts, AllocConsole detection, CreateRemoteThread detection, and the coolest of all, spoofed and encrypted syscall stubs. Arxan really helps out TAC; it has powerful obfuscation, anti-static analysis methods, and a couple of features that break IDA Pro, all while monitoring the executable for .text modifications. It even has its own anti-debug techniques built-in. Similar code from TAC is being used in modern Call of Duty games. Overall, this was a huge learning experience, and a great challenge, and pretty unreal to see all the things that caught me! I hope you found my research interesting. I’m still not 100% done reversing the anti-cheat, so you can expect to see new information posted here sometime in the future! :)\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003e\u003cstrong\u003eReferences\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.lodsb.com/ntsetinformationthread-disabling-threadhidefromdebugger\"\u003ehttps://www.lodsb.com/ntsetinformationthread-disabling-threadhidefromdebugger\u003c/a\u003e [#1]\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ayoubfaouzi/al-khaser/blob/master/al-khaser/AntiDebug/NtSetInformationThread_ThreadHideFromDebugger.cpp\"\u003ehttps://github.com/ayoubfaouzi/al-khaser/blob/master/al-khaser/AntiDebug/NtSetInformationThread_ThreadHideFromDebugger.cpp\u003c/a\u003e  [#2]\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.unknowncheats.me/forum/c-and-c-/567151-vectored-exception-handlers-x64-windows.html\"\u003ehttps://www.unknowncheats.me/forum/c-and-c-/567151-vectored-exception-handlers-x64-windows.html\u003c/a\u003e [#3]\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://momo5502.com/posts/2022-11-17-reverse-engineering-integrity-checks-in-black-ops-3/\"\u003ehttps://momo5502.com/posts/2022-11-17-reverse-engineering-integrity-checks-in-black-ops-3/\u003c/a\u003e [#4]\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr/\u003e\n\n    \n    \n  \u003c/article\u003e\n\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "70 min read",
  "publishedTime": "2025-01-04T23:57:56-06:00",
  "modifiedTime": "2025-01-04T23:57:56-06:00"
}
