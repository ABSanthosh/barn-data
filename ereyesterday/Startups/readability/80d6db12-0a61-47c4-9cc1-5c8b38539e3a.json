{
  "id": "80d6db12-0a61-47c4-9cc1-5c8b38539e3a",
  "title": "Why Bloat Is Still Software's Biggest Vulnerability (2024)",
  "link": "https://spectrum.ieee.org/lean-software-development",
  "description": "Article URL: https://spectrum.ieee.org/lean-software-development Comments URL: https://news.ycombinator.com/item?id=43910745 Points: 16 # Comments: 1",
  "author": "kristianp",
  "published": "Tue, 06 May 2025 23:33:54 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "Bert Hubert",
  "length": 16648,
  "excerpt": "\u003cp\u003eA 2024 plea for lean software \u003c/p\u003e",
  "siteName": "IEEE Spectrum",
  "favicon": "https://assets.rebelmouse.io/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpbWFnZSI6Imh0dHBzOi8vYXNzZXRzLnJibC5tcy8yNjU5NjY0OS9vcmlnaW4ucG5nIiwiZXhwaXJlc19hdCI6MTc4NTc0NjUwNn0.pFbPADvK9fyfasig9FMci3xf6UeB_WJaER5Yea_eRpI/img.png?width=192\u0026height=192",
  "text": "This post is dedicated to the memory of Niklaus Wirth, a computing pioneer who passed away 1 January 2024. In 1995 he wrote an influential article called “A Plea for Lean Software,” published in Computer, the magazine for members of the IEEE Computer Society, which I read early in my career as an entrepreneur and software developer. In what follows, I try to make the same case nearly 30 years later, updated for today’s computing horrors. A version of this post was originally published on my personal blog, Berthub.eu.Some years ago I did a talk at a local university on cybersecurity, titled “Cyber and Information Security: Have We All Gone Mad?” It is still worth reading today since we have gone quite mad collectively.The way we build and ship software these days is mostly ridiculous, leading to apps using millions of lines of code to open a garage door, and other simple programs importing 1,600 external code libraries—dependencies—of unknown provenance. Software security is dire, which is a function both of the quality of the code and the sheer amount of it. Many of us programmers know the current situation is untenable. Many programmers (and their management) sadly haven’t ever experienced anything else. And for the rest of us, we rarely get the time to do a better job.It is not just you; we are not merely suffering from nostalgia: Software really is very weird today. Let me briefly go over the terrible state of software security, and then spend some time on why it is so bad. I also mention some regulatory and legislative things going on that we might use to make software quality a priority again. Finally, I talk about an actual useful piece of software I wrote as a proof of concept that one can still make minimal and simple yet modern software.I hope that this post provides some mental and moral support for suffering programmers and technologists who want to improve things. It is not just you; We are not merely suffering from nostalgia: Software really is very weird today.The terrible state of software securityWithout going all “Old man (48) yells at cloud,” let me restate some obvious things. The state of software security is dire. If we only look at the past year, if you ran industry-standard software like Ivanti, MOVEit, Outlook, Confluence, Barracuda Email Security Gateway, Citrix NetScaler ADC, and NetScaler Gateway, chances are you got hacked. Even companies with near-infinite resources (like Apple and Google) made trivial “worst practice” security mistakes that put their customers in danger. Yet we continue to rely on all these products.Software is now (rightfully) considered so dangerous that we tell everyone not to run it themselves.Software is now (rightfully) considered so dangerous that we tell everyone not to run it themselves. Instead, you are supposed to leave that to an “X as a service” provider, or perhaps just to “the cloud.” Compare this to a hypothetical situation where cars are so likely to catch fire that the advice is not to drive a car yourself, but to leave that to professionals who are always accompanied by professional firefighters.The assumption is then that the cloud is somehow able to make insecure software trustworthy. Yet in the past year, we’ve learned that Microsoft’s email platform was thoroughly hacked, including classified government email. (Twice!) There are also well-founded worries about the security of the Azure cloud. Meanwhile, industry darling Okta, which provides cloud-based software that enables user log-in to various applications, got comprehensively owned. This was their second breach within two years. Also, there was a suspicious spate of Okta users subsequently getting hacked.Clearly, we need better software.The European Union has launched three pieces of legislation to this effect: NIS2 for important services; the Cyber Resilience Act for almost all commercial software and electronic devices; and a revamped Product Liability Directive that also extends to software. Legislation is always hard, and it remains to be seen if they got it right. But that software security is terrible enough these days to warrant legislation seems obvious.Why software security is so badI want to touch on incentives. The situation today is clearly working well for commercial operators. Making more secure software takes time and is a lot of work, and the current security incidents don’t appear to be impacting the bottom line or stock prices. You can speed up time to market by cutting corners. So from an economic standpoint, what we see is entirely predictable. Legislation could be very important in changing this equation.The security of software depends on two factors—the density of security issues in the source code and the sheer amount of code accessible by hackers. As the U.S. defense community loved to point out in the 1980s, quantity has a quality all of its own. The reverse applies to software—the more you have of it, the more risks you run.As a case in point, Apple iPhone users got repeatedly hacked over many years because of the huge attack surface exposed by iMessage. It is possible to send an unsolicited iMessage to an Apple user. The phone will then immediately process that message so it can preview it. The problem is that Apple in its wisdom decided that such unsolicited messages needed to support a vast array of image formats, accidentally including PDFs with weird embedded compressed fonts using an ancient format that effectively included a programming language. So someone could send an unsolicited message to your iPhone that could probe for weaknesses in the rest of the phone.In this way, attackers were able to benefit from security bugs in the phone’s millions of lines of code. You don’t need a high bug density to find an exploitable hole in millions of lines of code.Wiping out all the bugs in your code won’t save you from the decision to implement a feature to automatically execute code embedded in documents.Apple could have prevented this situation by restricting previews to a far smaller range of image formats, or even a single “known good” image format. Apple could have saved themselves an enormous amount of pain simply by exposing fewer lines of their code to attackers. Incidentally, the E.U.’s Cyber Resilience Act explicitly tells vendors to minimize the attack surface.Apple is (by far) not the worst offender in this field. But it is a widely respected and well-resourced company that usually thinks through what they do. And even they got it wrong by needlessly shipping and exposing too much code.Could we not write better code?There are those who think the biggest problem is the quality of the code, expressed in terms of the density of bugs in it. There are many interesting things happening on this front, like the use of memory safe languages like Rust. Other languages are also upping their security game. Fuzzers—test tools that automatically modify inputs to computer programs to find weaknesses and bugs—are also getting ever more advanced.But many security problems are in the logic underlying the code. For example, the Barracuda email exploit originated in a third-party library that would actually execute code in Excel spreadsheets when they were scanned for viruses. Wiping out all the bugs in your code won’t save you from the decision to implement a feature to automatically execute code embedded in documents.The state of shipping softwareAnother problem is that we often don’t know what code we are actually shipping. Software has gotten huge. In 1995 Niklaus Wirth lamented that software had grown to megabytes in size. In his article “A Plea for Lean Software,” he went on to describe his Oberon operating system, which was only 200 kilobytes, including an editor and a compiler. There are now projects that have more than 200 KB for their configuration files alone.A typical app today is built on Electron JS, a framework that incorporates both Chromium (“Chrome”) and Node.JS, which provides access to tens of thousands of software packages for JavaScript. I estimate just using Electron JS entails at least 50 million lines of code if you include dependencies. Perhaps more. The app meanwhile likely pulls in hundreds or thousands of helper packages. Many packages used will also, by default, snitch on your users to advertisers and other data brokers. Dependencies pull in further dependencies, and exactly what gets included in the build can change on a daily basis, and no one really knows.If this app controls anything in your house, it will also connect to a software stack over at Amazon, probably also powered by Node.js, also pulling in many dependencies. We are likely looking at over 50 million active lines of code to open a garage door….But wait, there’s more. We used to ship software as the output of a compiler, or perhaps as a bunch of files to be interpreted. Such software then had to be installed and configured to work right. Getting your code packaged to ship like this is a lot of work. But it was good work since it forced people to think about what was in their “package.” This software package would then integrate with an operating system and with local services, based on the configuration.Since the software ran on a different computer than the one it was developed on, people really had to know what they shipped and think it through. And sometimes it didn’t work, leading to the joke where a developer tells the operations people, “Well, it works on my system,” and the retort “Then back up your email, we’re taking your laptop into production!”This used to be a joke, but these days we often ship software as containers, shipping not only the software itself but also including operating system files to make sure the software runs in a well-known environment. This frequently entails effectively shipping a complete computer disk image. This again vastly expands the amount of code being deployed. Note that you can do good things with containers like Docker (see below), but there are a lot of images over 350 MB on the Docker Hub.Add it all up and we are likely looking at over 50 million active lines of code to open a garage door, running several operating-system images on multiple servers.Now, even if all the included dependencies are golden, are we sure that their security updates are making it to your garage door opener app? I wonder how many Electron apps are still shipping with the image processing bug that had Google and Apple scramble to put out updates last year. We don’t even know.But even worse, it is a known fact that all these dependencies are not golden. The Node.js ecosystem has a comical history of package repositories being taken over, hijacked, or resurrected under the same name by someone else, someone with nefarious plans for your security. PyPI (a Python counterpart of Node.js) has suffered from similar problems. Dependencies always need scrutiny, but no one can reasonably be expected to check thousands of them frequently. But we prefer not to think about this. (Note that you should also not overshoot and needlessly reimplement everything yourself to prevent dependencies. There are very good modules that likely are more secure than what you could type in on your own.)The world is shipping far too much code where we don’t even know what we ship and we aren’t looking hard enough (or at all) at what we do know we ship.You can write lean code todayWriting has been called the process by which you find out you don’t know what you are talking about. Actually doing stuff, meanwhile, is the process by which you find out you also did not know what you were writing about.In a small reenactment of Wirth’s Oberon Project, I too wrote some code to prove a point, and to reassure myself I still know what I am talking and writing about. Can you still make useful and modern software the old way? I decided to try to create a minimalistic but full-featured image-sharing solution that I could trust.Trifecta is the result. It is actual stand-alone software that lets you use a browser to drag and drop images for easy sharing. It has pained me for years that I had to use imgur for this purpose. Not only does imgur install lots of cookies and trackers in my browser, I also force these trackers onto the people who view the images that I share. If you want to self-host a Web service like this, you also don’t want to get hacked. Most image-sharing solutions I found that you could run yourself are based on huge frameworks that I don’t trust too much for the reasons outlined above.So, also to make a point, I decided to create a minimalistic but also useful image-sharing solution that I could trust. And more important, that other people could trust as well, because you can check out all Trifecta’s code within a few hours. It consists of 1,600 lines of new source code, plus around five important dependencies. You end up with a grand total of 3 megabytes of code.To contrast, one other image-sharing solution ships as a 288-MB Docker image, although admittedly it looks better and has some more features. But not 285 MB worth of them. Another comparison is this Node-based picture-sharing solution, which clocks in at 1,600 dependencies, apparently totaling over 4 million lines of JavaScript.The world ships too much code, most of it by third parties, sometimes unintended, most of it uninspected. Note that Trifecta is not intended as a public site where random people can share images, as that does not tend to end well. It is however very suitable for company or personal use. You can read more about the project here, and there is also a page about the technology used to deliver such a tiny self-contained solution.Response to TrifectaThis has been rather interesting. The most common response to Trifecta so far has been that I should use a whole bag of Amazon Web Services to deploy it. This is an exceedingly odd response to a project with the clearly stated goal of providing stand-alone software that does not rely on external services. I’m not sure what is going on here.Another reaction has been that I treat Docker unfairly, and that you could definitely use containers for good. And I agree wholeheartedly. But I also look at what people are actually doing (also with other forms of containers or virtual machines), and it’s not so great.I want to end this post with some observations from Niklaus Wirth’s 1995 paper:“To some, complexity equals power. (…) Increasingly, people seem to misinterpret complexity as sophistication, which is baffling—the incomprehensible should cause suspicion rather than admiration.”I’ve similarly observed that some people prefer complicated systems. As Tony Hoare noted long ago, “[T]here are two methods in software design. One is to make the program so simple, there are obviously no errors. The other is to make it so complicated, there are no obvious errors.” If you can’t do the first variant, the second way starts looking awfully attractive perhaps.Back to Wirth: “Time pressure is probably the foremost reason behind the emergence of bulky software. The time pressure that designers endure discourages careful planning. It also discourages improving acceptable solutions; instead, it encourages quickly conceived software additions and corrections. Time pressure gradually corrupts an engineer’s standard of quality and perfection. It has a detrimental effect on people as well as products.”Why spend weeks paring down your software when you can also ship a whole pre-installed operating-system image that just works?“The plague of software explosion is not a ‘law of nature.’ It is avoidable, and it is the software engineer’s task to curtail it.”If this is indeed on the shoulders of software people, we should perhaps demand more time for it.The world ships too much code, most of it by third parties, sometimes unintended, most of it uninspected. Because of this, there is a huge attack surface full of mediocre code. Efforts are ongoing to improve the quality of code itself, but many exploits are due to logic fails, and less progress has been made scanning for those. Meanwhile, great strides could be made by paring down just how much code we expose to the world. This will increase time to market for products, but legislation is around the corner that should force vendors to take security more seriously.Trifecta is, like Wirth’s Oberon Project mentioned above, meant as a proof that you can deliver a lot of functionality even with a limited amount of code and dependencies. With effort and legislation, maybe the future could again bring sub-50-million-line garage-door openers. Let’s try to make it happen.",
  "image": "https://spectrum.ieee.org/media-library/image.jpg?id=51411262\u0026width=1200\u0026height=600\u0026coordinates=0%2C100%2C0%2C100",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-headline=\"Why Bloat Is Still Software’s Biggest Vulnerability\"\u003e\u003cp\u003e\u003cem\u003eThis post is dedicated to the memory of \u003c/em\u003e\u003ca href=\"https://ethz.ch/en/news-and-events/eth-news/news/2024/01/computer-pioneer-niklaus-wirth-has-died.html\" rel=\"noopener noreferrer\" target=\"_blank\"\u003e\u003cem\u003eNiklaus Wirth\u003c/em\u003e\u003c/a\u003e\u003cem\u003e, a computing pioneer who passed away 1 January 2024. In 1995 he wrote an influential article called “\u003c/em\u003e\u003ca href=\"https://cr.yp.to/bib/1995/wirth.pdf\" rel=\"noopener noreferrer\" target=\"_blank\"\u003e\u003cem\u003eA Plea for Lean Software\u003c/em\u003e\u003c/a\u003e\u003cem\u003e,”\u003c/em\u003e\u003cem\u003e published in \u003c/em\u003e\u003ca href=\"https://ieeexplore.ieee.org/document/348001\" target=\"_blank\"\u003eComputer\u003c/a\u003e\u003cem\u003e, the magazine for members of the \u003ca href=\"https://spectrum.ieee.org/tag/ieee-computer-society\"\u003eIEEE Computer Society\u003c/a\u003e, which I read early in my career as an entrepreneur and software developer. In what follows, I try to make the same case nearly 30 years later, updated for today’s computing horrors. A version of this post was \u003c/em\u003e\u003ca href=\"https://berthub.eu/articles/posts/a-2024-plea-for-lean-software/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003e\u003cem\u003eoriginally published\u003c/em\u003e\u003c/a\u003e\u003cem\u003e on my personal blog, \u003ca href=\"http://berthub.eu\" target=\"_blank\"\u003eBerthub.eu\u003c/a\u003e.\u003c/em\u003e\u003cbr/\u003e\u003c/p\u003e\u003cp\u003eSome years ago I did a talk at a local university on \u003ca href=\"https://spectrum.ieee.org/tag/cybersecurity\"\u003ecybersecurity\u003c/a\u003e, titled “\u003ca href=\"https://berthub.eu/cyber-mad/Cyber%20and%20information%20security.pdf\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eCyber and Information Security: Have We All Gone Mad?\u003c/a\u003e” It is still worth reading today since we \u003cem\u003ehave\u003c/em\u003e gone quite mad collectively.\u003c/p\u003e\u003cp\u003eThe way we build and ship software these days is mostly ridiculous, leading to apps using millions of lines of code to open a garage door, and other simple programs importing \u003ca href=\"https://github.com/SashenJayathilaka/Photo-Sharing-Application\" target=\"_blank\"\u003e1,600 external code libraries\u003c/a\u003e—dependencies—of unknown provenance. \u003ca href=\"https://spectrum.ieee.org/tag/software-security\"\u003eSoftware security\u003c/a\u003e is dire, which is a function both of the quality of the code and the sheer amount of it. Many of us \u003ca href=\"https://spectrum.ieee.org/tag/programmers\"\u003eprogrammers\u003c/a\u003e know the current situation is untenable. Many programmers (and their management) sadly haven’t ever experienced anything else. And for the rest of us, we rarely get the time to do a better job.\u003c/p\u003e\u003cp\u003eIt is not just you; we are not merely suffering from nostalgia: Software really is very weird today.\u003c/p\u003e\u003cp\u003e Let me briefly go over the terrible state of software security, and then spend some time on why it is so bad. I also mention some regulatory and legislative things going on that we might use to make software quality a priority again. Finally, I talk about \u003ca href=\"https://berthub.eu/articles/trifecta\" rel=\"noopener noreferrer\" target=\"_blank\"\u003ean actual useful piece of software I wrote\u003c/a\u003e as a proof of concept that one can still make \u003ca href=\"https://berthub.eu/articles/posts/trifecta-technology\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eminimal and simple yet modern software\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eI hope that this post provides some mental and moral support for suffering programmers and technologists who want to improve things. It is not just you; We are not merely suffering from nostalgia: Software really is very weird today.\u003c/p\u003e\u003ch2\u003eThe terrible state of software security\u003c/h2\u003e\u003cp\u003eWithout going all \u003ca href=\"https://knowyourmeme.com/memes/old-man-yells-at-cloud\" rel=\"noopener noreferrer\" target=\"_blank\"\u003e“Old man (48) yells at cloud\u003c/a\u003e,” let me restate some obvious things. The state of software security is \u003cem\u003edire\u003c/em\u003e. If we only look at the past year, if you ran industry-standard software like \u003ca href=\"https://www.ncsc.gov.uk/news/exploitation-ivanti-vulnerabilities\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eIvanti\u003c/a\u003e, \u003ca href=\"https://en.wikipedia.org/wiki/2023_MOVEit_data_breach\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eMOVEit\u003c/a\u003e, \u003ca href=\"https://www.bleepingcomputer.com/news/microsoft/russian-hackers-exploiting-outlook-bug-to-hijack-exchange-accounts/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eOutlook\u003c/a\u003e, \u003ca href=\"https://confluence.atlassian.com/security/cve-2023-22518-improper-authorization-vulnerability-in-confluence-data-center-and-server-1311473907.html\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eConfluence\u003c/a\u003e, \u003ca href=\"https://www.mandiant.com/resources/blog/barracuda-esg-exploited-globally\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eBarracuda Email Security Gateway\u003c/a\u003e, \u003ca href=\"https://www.mandiant.com/resources/blog/remediation-netscaler-adc-gateway-cve-2023-4966\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eCitrix NetScaler ADC, and NetScaler Gateway\u003c/a\u003e, chances are you got hacked. Even companies with near-infinite resources (like Apple and \u003ca href=\"https://spectrum.ieee.org/tag/google\"\u003eGoogle\u003c/a\u003e) made \u003ca href=\"https://www.schneier.com/blog/archives/2023/09/critical-vulnerability-in-libwebp-library.html\" rel=\"noopener noreferrer\" target=\"_blank\"\u003etrivial “worst practice” security mistakes\u003c/a\u003e that put \u003ca href=\"https://www.bleepingcomputer.com/news/security/apple-zero-click-imessage-exploit-used-to-infect-iphones-with-spyware/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003etheir customers in danger\u003c/a\u003e. Yet we continue to rely on all these products.\u003c/p\u003e\u003cp\u003eSoftware is now (rightfully) considered so dangerous that we tell everyone not to run it themselves.\u003cem\u003e\u003c/em\u003e\u003c/p\u003e\u003cp\u003eSoftware is now (rightfully) considered so dangerous that we tell everyone not to run it themselves. Instead, you are supposed to leave that to an “\u003cem\u003eX\u003c/em\u003e as a service” provider, or perhaps just to “the cloud.” Compare this to a hypothetical situation where cars are so likely to catch fire that the advice is not to drive a car yourself, but to leave that to professionals who are always accompanied by professional firefighters.\u003c/p\u003e\u003cp\u003eThe assumption is then that the cloud is somehow able to make insecure software trustworthy. Yet in the past year, we’ve learned that Microsoft’s \u003ca href=\"https://thehackernews.com/2023/09/outlook-breach-microsoft-reveals-how.html\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eemail platform was thoroughly hacked\u003c/a\u003e, including classified government email. (\u003ca href=\"https://metacurity.substack.com/p/russian-hacking-group-midnight-blizzard\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eTwice!\u003c/a\u003e) There are also \u003ca href=\"https://www.lastweekinaws.com/blog/azures-terrible-security-posture-comes-home-to-roost/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003ewell-founded worries about the security of the Azure cloud\u003c/a\u003e. Meanwhile, industry darling Okta, which provides cloud-based software that enables user log-in to various applications, \u003ca href=\"https://www.reuters.com/technology/cybersecurity/okta-says-hackers-stole-data-all-customer-support-users-cyber-breach-2023-11-29/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003egot comprehensively owned\u003c/a\u003e. This was their second breach within two years. Also, there was a suspicious spate of Okta users subsequently getting hacked.\u003c/p\u003e\u003cp\u003eClearly, we need better software.\u003c/p\u003e\u003cp\u003eThe \u003ca href=\"https://spectrum.ieee.org/tag/european-union\"\u003eEuropean Union\u003c/a\u003e has launched three pieces of \u003ca href=\"https://spectrum.ieee.org/tag/legislation\"\u003elegislation\u003c/a\u003e to this effect: \u003ca href=\"https://digital-strategy.ec.europa.eu/en/policies/nis2-directive\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eNIS2 for important services\u003c/a\u003e; the \u003ca href=\"https://digital-strategy.ec.europa.eu/en/policies/cyber-resilience-act\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eCyber Resilience Act \u003c/a\u003efor almost all commercial software and electronic devices; and a revamped \u003ca href=\"https://www.euractiv.com/section/digital/news/eu-updates-product-liability-regime-to-include-software-artificial-intelligence/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eProduct Liability Directive\u003c/a\u003e that also extends to software. Legislation is always hard, and it remains to be seen \u003ca href=\"https://berthub.eu/articles/posts/eu-cra-what-does-it-mean-for-open-source/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eif they got it right\u003c/a\u003e. But that software security is terrible enough these days to warrant legislation seems obvious.\u003c/p\u003e\u003ch2\u003eWhy software security is so bad\u003c/h2\u003e\u003cp\u003eI want to touch on incentives. The situation today is clearly working well for commercial operators. Making more secure software takes time and is a lot of work, and the current security incidents don’t appear to be impacting the bottom line or stock prices. You can \u003ca href=\"https://www.microsoft.com/en-us/research/publication/software-components-only-the-giants-survive/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003espeed up time to market by cutting corners\u003c/a\u003e. So from an economic standpoint, what we see is entirely predictable. Legislation could be very important in changing this equation.\u003c/p\u003e\u003cp\u003eThe security of software depends on two factors—the \u003cem\u003edensity\u003c/em\u003e of security issues in the \u003ca href=\"https://spectrum.ieee.org/tag/source-code\"\u003esource code\u003c/a\u003e and the sheer \u003cem\u003eamount of code\u003c/em\u003e accessible by \u003ca href=\"https://spectrum.ieee.org/tag/hackers\"\u003ehackers\u003c/a\u003e. As the U.S. defense community loved to point out in the 1980s, \u003ca href=\"https://www.quora.com/Who-said-Quantity-has-a-quality-all-its-own\" rel=\"noopener noreferrer\" target=\"_blank\"\u003equantity has a quality all of its own\u003c/a\u003e. The reverse applies to software—the more you have of it, the more risks you run.\u003c/p\u003e\u003cp\u003eAs a case in point, Apple iPhone users got repeatedly hacked over many years because of the huge attack surface exposed by iMessage. It is possible to send an unsolicited iMessage to an Apple user. The phone will then immediately process that message so it can preview it. The problem is that Apple in its wisdom decided that such unsolicited messages needed to support a vast array of image formats, accidentally \u003ca href=\"https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eincluding PDFs with weird embedded compressed fonts\u003c/a\u003e using an ancient format that effectively included a \u003ca href=\"https://spectrum.ieee.org/tag/programming\"\u003eprogramming\u003c/a\u003e language. So someone could send an unsolicited message to your iPhone that could probe for weaknesses in the rest of the phone.\u003c/p\u003e\u003cp\u003eIn this way, attackers were able to benefit from security bugs in the phone’s millions of lines of code. You don’t need a high bug density to find \u003ca href=\"https://www.europarl.europa.eu/meetdocs/2014_2019/plmrep/COMMITTEES/PEGA/DV/2023/05-08/REPORTcompromises_EN.pdf\" rel=\"noopener noreferrer\" target=\"_blank\"\u003ean exploitable hole\u003c/a\u003e in millions of lines of code.\u003c/p\u003e\u003cp\u003eWiping out all the bugs in your code won’t save you from the decision to implement a feature to automatically execute code embedded in documents.\u003c/p\u003e\u003cp\u003eApple could have prevented this situation by restricting previews to a far smaller range of image formats, or even a single “known good” image format. Apple could have saved themselves an enormous amount of pain simply by \u003ca href=\"https://github.com/berthubert/sbox#sbox\" target=\"_blank\"\u003eexposing fewer lines of their code\u003c/a\u003e to attackers. Incidentally, the E.U.’s Cyber Resilience Act \u003ca href=\"https://berthub.eu/articles/posts/eu-cra-secure-coding-solution/\" target=\"_blank\"\u003eexplicitly tells vendors to minimize the attack surface\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cspan\u003e\u003c/span\u003eApple is (by far) not the worst offender in this field. But it is a widely respected and well-resourced company that usually thinks through what they do. And even they got it wrong by needlessly shipping and exposing too much code.\u003c/p\u003e\u003ch2\u003eCould we not write better code?\u003c/h2\u003e\u003cp\u003eThere are those who think the biggest problem is the quality of the code, expressed in terms of the density of bugs in it. There are many interesting things happening on this front, like the use of \u003ca href=\"https://www.nsa.gov/Press-Room/Press-Releases-Statements/Press-Release-View/Article/3608324/us-and-international-partners-issue-recommendations-to-secure-software-products/\" target=\"_blank\"\u003ememory safe languages\u003c/a\u003e like \u003ca href=\"https://www.rust-lang.org/\" target=\"_blank\"\u003eRust\u003c/a\u003e. Other languages are \u003ca href=\"https://github.com/google/sanitizers/wiki/AddressSanitizer\" target=\"_blank\"\u003ealso upping their security game\u003c/a\u003e. \u003ca href=\"https://en.wikipedia.org/wiki/Fuzzing\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eFuzzers\u003c/a\u003e—test tools that automatically modify inputs to computer programs to find weaknesses and bugs—are also getting ever more advanced.\u003c/p\u003e\u003cp\u003eBut many security problems are in the logic underlying the code. For example, the Barracuda email exploit originated in a third-party library that would actually \u003ca href=\"https://www.cvedetails.com/cve/CVE-2023-7101/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eexecute code\u003c/a\u003e in Excel spreadsheets when they were scanned for \u003ca href=\"https://spectrum.ieee.org/tag/viruses\"\u003eviruses\u003c/a\u003e. Wiping out all the bugs in your code won’t save you from the decision to implement a feature to automatically execute code embedded in documents.\u003c/p\u003e\u003ch2\u003eThe state of shipping software\u003c/h2\u003e\u003cp\u003eAnother problem is that we often don’t know what code we are actually shipping. Software has gotten \u003cem\u003ehuge\u003c/em\u003e. In 1995 \u003ca href=\"https://en.wikipedia.org/wiki/Niklaus_Wirth\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eNiklaus Wirth\u003c/a\u003e lamented that software had grown to megabytes in size. In his article “A Plea for Lean Software,” he went on to describe his \u003ca href=\"https://en.wikipedia.org/wiki/Oberon_(operating_system)\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eOberon operating system\u003c/a\u003e, which was only 200 kilobytes, including an editor and a compiler. There are now projects that have more than 200 KB for their configuration files alone.\u003c/p\u003e\u003cp\u003eA typical app today is built on \u003ca href=\"https://www.electronjs.org/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eElectron JS\u003c/a\u003e, a framework that incorporates both Chromium (“Chrome”) and Node.JS, which provides access to tens of thousands of software packages for \u003ca href=\"https://spectrum.ieee.org/tag/javascript\"\u003eJavaScript\u003c/a\u003e. I estimate just using Electron JS entails at least 50 million lines of code if you include dependencies. Perhaps more. The app meanwhile likely pulls in hundreds or thousands of helper packages. Many packages used will also, by default, snitch on your users to advertisers and other data brokers. Dependencies pull in further dependencies, and exactly what gets included in the build can change on a daily basis, and no one really knows.\u003c/p\u003e\u003cp\u003eIf this app controls anything in your house, it will also connect to a software stack over at \u003ca href=\"https://spectrum.ieee.org/tag/amazon\"\u003eAmazon\u003c/a\u003e, probably also powered by Node.js, also pulling in many dependencies. \u003c/p\u003e\u003cp\u003eWe are likely looking at over 50 million active lines of code to open a garage door….\u003c/p\u003e\u003cp\u003eBut wait, there’s more. We used to ship software as the output of a compiler, or perhaps as a bunch of files to be interpreted. Such software then had to be \u003cem\u003einstalled\u003c/em\u003e and \u003cem\u003econfigured\u003c/em\u003e to work right. Getting your code packaged to ship like this is a lot of work. But it was good work since it forced people to think about what was in their “package.” This software package would then integrate with an \u003ca href=\"https://spectrum.ieee.org/tag/operating-system\"\u003eoperating system\u003c/a\u003e and with local services, based on the configuration.\u003c/p\u003e\u003cp\u003eSince the software ran on a different computer than the one it was developed on, people really had to know what they shipped and think it through. And sometimes it didn’t work, leading to the joke where a developer tells the operations people, “Well, it works on my system,” and the retort “Then back up your email, we’re taking your laptop into production!”\u003c/p\u003e\u003cp\u003eThis used to be a joke, but these days we often ship software as containers, shipping not only the software itself but also including operating system files to make sure the software runs in a well-known environment. This frequently entails effectively shipping a complete computer disk image. This again vastly expands the amount of code being deployed. Note that you can do good things with containers like \u003ca href=\"https://spectrum.ieee.org/tag/docker\"\u003eDocker\u003c/a\u003e (see below), but there are a lot of images over 350 MB on the \u003ca href=\"https://hub.docker.com/explore\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eDocker Hub\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eAdd it all up and we are likely looking at over 50 million active lines of code to open a garage door, running several operating-system images on multiple servers.\u003c/p\u003e\u003cp\u003eNow, even if all the included dependencies are golden, are we sure that their security updates are making it to your garage door opener app? I wonder how many Electron apps are still shipping with the \u003ca href=\"https://www.schneier.com/blog/archives/2023/09/critical-vulnerability-in-libwebp-library.html\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eimage processing bug\u003c/a\u003e that had Google and Apple scramble to put out updates last year. We don’t even know.\u003c/p\u003e\u003cp\u003eBut even worse, it is a known fact that all these dependencies are \u003cem\u003enot\u003c/em\u003e golden. The Node.js ecosystem has a \u003ca href=\"https://thehackernews.com/2023/02/researchers-hijack-popular-npm-package.html\" rel=\"noopener noreferrer\" target=\"_blank\"\u003ecomical history\u003c/a\u003e of package repositories \u003ca href=\"https://snyk.io/blog/npm-security-preventing-supply-chain-attacks/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003ebeing taken over\u003c/a\u003e, hijacked, or resurrected under the same name by someone else, someone with nefarious\u003ca href=\"https://www.theregister.com/2023/06/19/npm_s3_buckets_malware/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003e plans for your security\u003c/a\u003e. \u003ca href=\"https://www.theregister.com/2023/06/02/novel_pypi_attack_reversinglabs/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003ePyPI\u003c/a\u003e (a \u003ca href=\"https://spectrum.ieee.org/tag/python\"\u003ePython\u003c/a\u003e counterpart of Node.js) has suffered from \u003ca href=\"https://www.theregister.com/2023/01/04/pypi_pytorch_dependency_attack/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003esimilar problems\u003c/a\u003e. Dependencies always need scrutiny, but no one can reasonably be expected to \u003ca href=\"https://medium.com/graph-commons/analyzing-the-npm-dependency-network-e2cf318c1d0d\" rel=\"noopener noreferrer\" target=\"_blank\"\u003echeck thousands of them frequently\u003c/a\u003e. But we prefer not to think about this. (Note that you should also not overshoot and needlessly reimplement everything yourself to prevent dependencies. There are very good modules that \u003ca href=\"https://sqlite.org/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003elikely are more secure\u003c/a\u003e than what you could type in on your own.)\u003c/p\u003e\u003cp\u003eThe world is shipping far too much code where we don’t even know what we ship and we aren’t looking hard enough (or at all) at what we \u003cem\u003edo\u003c/em\u003e know we ship.\u003c/p\u003e\u003ch2\u003eYou \u003cem\u003ecan\u003c/em\u003e write lean code today\u003c/h2\u003e\u003cp\u003eWriting has been called the process by which you find out you don’t \u003ca href=\"https://fs.blog/writing-to-think/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eknow what you are talking about\u003c/a\u003e. Actually doing stuff, meanwhile, is the process by which you find out you also did not know what you were writing about.\u003c/p\u003e\u003cp\u003eIn a small reenactment of Wirth’s Oberon Project, I too wrote some code to prove a point, and to reassure myself I still know what I am talking and writing about. Can you still make useful and modern software the old way? I decided to try to create a minimalistic but full-featured image-sharing solution that I could trust.\u003c/p\u003e\u003cp\u003eTrifecta is the result. It is \u003ca href=\"https://berthub.eu/articles/trifecta/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eactual stand-alone software\u003c/a\u003e that lets you use a browser to drag and drop images for easy sharing. It has pained me for years that I had to use \u003ca href=\"https://imgur.com/\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eimgur\u003c/a\u003e for this purpose. Not only does imgur install lots of cookies and trackers in my browser, I also force these trackers onto the people who view the images that I share. If you want to self-host a Web service like this, you also don’t want to get hacked. Most image-sharing solutions I found that you could run yourself are based on huge frameworks that I don’t trust too much for the reasons outlined above.\u003c/p\u003e\u003cp\u003eSo, also to make a point, I decided to create a minimalistic but also useful image-sharing solution that I could trust. And more important, that other people could trust as well, because you can check out all Trifecta’s code within a few hours. It consists of \u003ca href=\"https://berthub.eu/articles/posts/trifecta-technology\" target=\"_blank\"\u003e1,600 lines of new source code\u003c/a\u003e, plus around five important dependencies. \u003c/p\u003e\u003cp\u003eYou end up with a grand total of 3 megabytes of code.\u003c/p\u003e\u003cp\u003eTo contrast, \u003ca href=\"https://github.com/CaramelFur/Picsur/pkgs/container/picsur\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eone other image-sharing solution\u003c/a\u003e ships as a 288-MB Docker image, although admittedly it looks better and has some more features. But not 285 MB worth of them. Another comparison is \u003ca href=\"https://github.com/SashenJayathilaka/Photo-Sharing-Application\" rel=\"noopener noreferrer\" target=\"_blank\"\u003ethis Node-based picture-sharing solution\u003c/a\u003e, which \u003ca href=\"https://spectrum.ieee.org/tag/clocks\"\u003eclocks\u003c/a\u003e in at 1,600 dependencies, apparently totaling over 4 million lines of JavaScript.\u003c/p\u003e\u003cp\u003eThe world ships too much code, most of it by third parties, sometimes unintended, most of it uninspected. \u003cem\u003e\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cspan\u003e\u003c/span\u003eNote that Trifecta is not intended as a public site where random people can share images, as that does not tend to end well. It is however very suitable for company or personal use. You can read more about the project \u003ca href=\"https://berthub.eu/articles/trifecta\" target=\"_blank\"\u003ehere\u003c/a\u003e, and there is also \u003ca href=\"https://berthub.eu/articles/posts/trifecta-technology\" target=\"_blank\"\u003ea page\u003c/a\u003e about the technology used to deliver such a tiny self-contained solution.\u003c/p\u003e\u003ch2\u003eResponse to Trifecta\u003c/h2\u003e\u003cp\u003eThis has been rather interesting. The most common response to Trifecta so far has been that I should use a whole bag of Amazon Web Services to deploy it. This is an exceedingly odd response to a project with the clearly stated goal of providing stand-alone software that does not rely on external services. I’m not sure what is going on here.\u003c/p\u003e\u003cp\u003eAnother reaction has been that I treat Docker unfairly, and that you could definitely use containers for good. And I agree wholeheartedly. But I also look at what people are actually doing (also with other forms of containers or virtual machines), and it’s not so great.\u003c/p\u003e\u003cp\u003eI want to end this post with some observations from \u003ca href=\"https://cr.yp.to/bib/1995/wirth.pdf\" target=\"_blank\"\u003eNiklaus Wirth’s 1995 paper\u003c/a\u003e:\u003c/p\u003e\u003cblockquote\u003e“To some, complexity equals power. (…) Increasingly, \u003cem\u003epeople seem to misinterpret complexity as sophistication\u003c/em\u003e, which is baffling—the incomprehensible should cause suspicion rather than admiration.”\u003c/blockquote\u003e\u003cp\u003eI’ve similarly observed that some people prefer complicated systems. As \u003ca href=\"https://en.wikipedia.org/wiki/Tony_Hoare\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eTony Hoare\u003c/a\u003e noted long ago, “[T]here are two methods in software design. \u003ca href=\"https://dl.acm.org/doi/pdf/10.1145/1283920.1283936\" rel=\"noopener noreferrer\" target=\"_blank\"\u003eOne is to make the program so simple, there are obviously no errors\u003c/a\u003e. The other is to make it so complicated, there are no obvious errors.” If you can’t do the first variant, the second way starts looking awfully attractive perhaps.\u003c/p\u003e\u003cp\u003eBack to Wirth: \u003c/p\u003e\u003cblockquote\u003e“Time pressure is probably the foremost reason behind the emergence of bulky software. The time pressure that designers endure discourages careful planning. It also discourages improving acceptable solutions; instead, it encourages quickly conceived software additions and corrections. Time pressure gradually corrupts an engineer’s standard of quality and perfection. It has a detrimental effect on people as well as products.”\u003c/blockquote\u003e\u003cp\u003eWhy spend weeks paring down your software when you can also ship a whole pre-installed operating-system image that just works?\u003c/p\u003e\u003cblockquote\u003e“The plague of software explosion is not a ‘law of nature.’ It is avoidable, and it is the software engineer’s task to curtail it.”\u003c/blockquote\u003e\u003cp\u003eIf this is indeed on the shoulders of software people, we should perhaps demand more time for it.\u003c/p\u003e\u003cp\u003eThe world ships too much code, most of it by third parties, sometimes unintended, most of it uninspected. Because of this, there is a huge \u003cem\u003eattack surface\u003c/em\u003e full of mediocre code. Efforts are ongoing to improve the quality of code itself, but many exploits are due to logic fails, and less progress has been made scanning for those. Meanwhile, great strides could be made by paring down just how much code we expose to the world. This will increase time to market for products, but legislation is around the corner that should force vendors to take security more seriously.\u003c/p\u003e\u003cp\u003eTrifecta is, like Wirth’s Oberon Project mentioned above, meant as a proof that you can deliver a lot of functionality even with a limited amount of code and dependencies. With effort and legislation, maybe the future could again bring sub-50-million-line garage-door openers. Let’s try to make it happen.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": "2024-02-08T15:44:20Z",
  "modifiedTime": "2024-03-25T17:23:47Z"
}
