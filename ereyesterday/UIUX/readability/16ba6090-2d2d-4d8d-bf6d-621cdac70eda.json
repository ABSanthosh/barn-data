{
  "id": "16ba6090-2d2d-4d8d-bf6d-621cdac70eda",
  "title": "CSS Cascade Layers Vs. BEM Vs. Utility Classes: Specificity Control",
  "link": "https://smashingmagazine.com/2025/06/css-cascade-layers-bem-utility-classes-specificity-control/",
  "description": "CSS can be unpredictable — and specificity is often the culprit. Victor Ayomipo breaks down how and why your styles might not behave as expected, and why understanding specificity is better than relying on `!important`.",
  "author": "Victor Ayomipo",
  "published": "Thu, 19 Jun 2025 15:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 16006,
  "excerpt": "CSS can be unpredictable — and specificity is often the culprit. Victor Ayomipo breaks down how and why your styles might not behave as expected, and why understanding specificity is better than relying on `!important`.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "13 min readCSS, Coding, TechniquesCSS can be unpredictable — and specificity is often the culprit. Victor Ayomipo breaks down how and why your styles might not behave as expected, and why understanding specificity is better than relying on !important flags.CSS is wild, really wild. And tricky. But let’s talk specifically about specificity.When writing CSS, it’s close to impossible that you haven’t faced the frustration of styles not applying as expected — that’s specificity. You applied a style, it worked, and later, you try to override it with a different style and… nothing, it just ignores you. Again, specificity.Sure, there’s the option of resorting to !important flags, but like all developers before us, it’s always risky and discouraged. It’s way better to fully understand specificity than go down that route because otherwise you wind up fighting your own important styles.Lots of developers understand the concept of specificity in different ways.The core idea of specificity is that the CSS Cascade algorithm used by browsers determines which style declaration is applied when two or more rules match the same element.Think about it. As a project expands, so do the specificity challenges. Let’s say Developer A adds .cart-button, then maybe the button style looks good to be used on the sidebar, but with a little tweak. Then, later, Developer B adds .cart-button .sidebar, and from there, any future changes applied to .cart-button might get overridden by .cart-button .sidebar, and just like that, the specificity war begins.(Large preview)I’ve written CSS long enough to witness different strategies that developers have used to manage the specificity battles that come with CSS./* Traditional approach */ #header .nav li a.active { color: blue; } /* BEM approach */ .header__nav-item--active { color: blue; } /* Utility classes approach */ .text-blue { color: blue; } /* Cascade Layers approach */ @layer components { .nav-link.active { color: blue; } } All these methods reflect different strategies on how to control or at least maintain CSS specificity:BEM: tries to simplify specificity by being explicit.Utility-first CSS: tries to bypass specificity by keeping it all atomic.CSS Cascade Layers: manage specificity by organizing styles in layered groups.We’re going to put all three side by side and look at how they handle specificity.(Large preview)My Relationship With SpecificityI actually used to think that I got the whole picture of CSS specificity. Like the usual inline greater than ID greater than class greater than tag. But, reading the MDN docs on how the CSS Cascade truly works was an eye-opener.There’s a code I worked on in an old codebase provided by a client, which looked something like this:/* Legacy code */ #main-content .product-grid button.add-to-cart { background-color: #3a86ff; color: white; padding: 10px 15px; border-radius: 4px; } /* 100 lines of other code here */ /* My new CSS */ .btn-primary { background-color: #4361ee; /* New brand color */ color: white; padding: 12px 20px; border-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); } Looking at this code, no way that the .btn-primary class stands a chance against whatever specificity chain of selectors was previously written. As far as specification goes, CSS gives the first selector a specificity score of 1, 2, 1: one point for the ID, two points for the two classes, and one point for the element selector. Meanwhile, the second selector is scored as 0, 1, 0 since it only consists of a single class selector.Sure, I had some options:I could use !important on the properties in .btn-primary to override the ones declared in the stronger selector, but the moment that happens, be prepared to use it everywhere. So, I’d rather avoid it.I could try going more specific, but personally, that’s just being cruel to the next developer (who might even be me).I could change the styles of the existing code, but that’s adding to the specificity problem:#main-content .product-grid .btn-primary { /* edit styles directly */ } Eventually, I ended up writing the whole CSS from scratch.(Large preview)When nesting was introduced, I tried it to control specificity that way:.profile-widget { // ... other styles .header { // ... header styles .user-avatar { border: 2px solid blue; \u0026.is-admin { border-color: gold; // This becomes .profile-widget .header .user-avatar.is-admin } } } } And just like that, I have unintentionally created high-specificity rules. That’s how easily and naturally we can drift toward specificity complexities.So, to save myself a lot of these issues, I have one principle I always abide by: keep specificity as low as possible. And if the selector complexity is becoming a complex chain, I rethink the whole thing.BEM: The OG SystemThe Block-Element-Modifier (BEM, for short) has been around the block (pun intended) for a long time. It is a methodological system for writing CSS that forces you to make every style hierarchy explicit./* Block */ .panel {} /* Element that depends on the Block */ .panel__header {} .panel__content {} .panel__footer {} /* Modifier that changes the style of the Block */ .panel--highlighted {} .panel__button--secondary {} When I first experienced BEM, I thought it was amazing, despite contrary opinions that it looked ugly. I had no problems with the double hyphens or underscores because they made my CSS predictable and simplified.(Large preview)How BEM Handles SpecificityTake a look at these examples. Without BEM:/* Specificity: 0, 3, 0 */ .site-header .main-nav .nav-link { color: #472EFE; text-decoration: none; } /* Specificity: 0, 2, 0 */ .nav-link.special { color: #FF5733; } With BEM:/* Specificity: 0, 1, 0 */ .main-nav__link { color: #472EFE; text-decoration: none; } /* Specificity: 0, 1, 0 */ .main-nav__link--special { color: #FF5733; } You see how BEM makes the code look predictable as all selectors are created equal, thus making the code easier to maintain and extend. And if I want to add a button to .main-nav, I just add .main-nav__btn, and if I need a disabled button (modifier), .main-nav__btn--disabled. Specificity is low, as I don’t have to increase it or fight the cascade; I just write a new class.BEM’s naming principle made sure components lived in isolation, which, for a part of CSS, the specificity part, it worked, i.e, .card__title class will never accidentally clash with a .menu__title class.Where BEM Falls ShortI like the idea of BEM, but it is not perfect, and a lot of people noticed it:The class names can get really long.\u003cdiv class=\"product-carousel__slide--featured product-carousel__slide--on-sale\"\u003e \u003c!-- yikes --\u003e \u003c/div\u003e Reusability might not be prioritized, which somewhat contradicts the native CSS ideology. Should a button inside a card be .card__button or reuse a global .button class? With the former, styles are being duplicated, and with the latter, the BEM strict model is being broken.One of the core pains in software development starts becoming a reality — naming things. I’m sure you know the frustration of that already.BEM is good, but sometimes you may need to be flexible with it. A hybrid system (maybe using BEM for core components but simpler classes elsewhere) can still keep specificity as low as needed./* Base button without BEM */ .button { /* Button styles */ } /* Component-specific button with BEM */ .card__footer .button { /* Minor overrides */ } Utility Classes: Specificity By AvoidanceThis is also called Atomic CSS. And in its entirety, it avoids specificity.\u003cbutton class=\"bg-red-300 hover:bg-red-500 text-white py-2 px-4 rounded\"\u003e A button \u003c/button\u003e The idea behind utility-first classes is that every utility class has the same specificity, which is one class selector. Each class is a tiny CSS property with a single purpose.p-2? Padding, nothing more. text-red? Color red for text. text-center? Text alignment. It’s like how LEGOs work, but for styling. You stack classes on top of each other until you get your desired appearance.(Large preview)How Utility Classes Handle SpecificityUtility classes do not solve specificity, but rather, they take the BEM ideology of low specificity to the extreme. Almost all utility classes have the same lowest possible specificity level of (0, 1, 0). And because of this, overrides become easy; if more padding is needed, bump .p-2 to .p-4.Another example:\u003cbutton class=\"bg-orange-300 hover:bg-orange-700\"\u003e This can be hovered \u003c/button\u003e If another class, hover:bg-red-500, is added, the order matters for CSS to determine which to use. So, even though the utility classes avoid specificity, the other parts of the CSS Cascade come in, which is the order of appearance, with the last matching selector declared being the winner.Utility Class Trade-OffsThe most common issue with utility classes is that they make the code look ugly. And frankly, I agree. But being able to picture what a component looks like without seeing it rendered is just priceless.There’s also the argument of reusability, that you repeat yourself every single time. But once one finds a repetition happening, just turn that part into a reusable component. It also has its genuine limitations when it comes to specificity:If your brand color changes, which is a global change, and you’re deep in the codebase, you can’t just change one and have others follow like native CSS.The parent-child relationship that happens naturally in native CSS is out the window due to how atomic utility classes behave.Some argue the HTML part should be left as markup and the CSS part for styling. Because now, there’s more markup to scan, and if you decide to clean up:\u003c!-- Too long --\u003e \u003cdiv class=\"p-4 bg-yellow-100 border border-yellow-300 text-yellow-800 rounded\"\u003e \u003c!-- Better? --\u003e \u003cdiv class=\"alert-warning\"\u003e Just like that, we’ve ended up writing CSS. Circle of life.In my experience with utility classes, they work best for:SpeedWriting the markup, styling it, and seeing the result swiftly.PredictabilityA utility class does exactly what it says it does.Cascade Layers: Specificity By DesignNow, this is where it gets interesting. BEM offers structure, utility classes gain speed, and CSS Cascade Layers give us something paramount: control.Anyways, Cascade Layers (@layers) groups styles and declares what order the groups should be, regardless of the specificity scores of those rules.Looking at a set of independent rulesets:button { background-color: orange; /* Specificity: 0, 0, 1 */ } .button { background-color: blue; //* Specificity: 0, 1, 0*/ } #button { background-color: red; /* Specificity: 1, 0, 0 */ } /* No matter what, the button is red */ But with @layer, let’s say, I want to prioritize the .button class selector. I can shape how the specificity order should go:@layer utilities, defaults, components; @layer defaults { button { background-color: orange; /* Specificity: 0, 0, 1 */ } } @layer components { .button { background-color: blue; //* Specificity: 0, 1, 0*/ } } @layer utilities { #button { background-color: red; /* Specificity: 1, 0, 0 */ } } Due to how @layer works, .button would win because the components layer is the highest priority, even though #button has higher specificity. Thus, before CSS could even check the usual specificity rules, the layer order would first be respected.You just have to respect the folks over at W3C, because now one can purposely override an ID selector with a simple class, without even using !important. Fascinating.Cascade Layers NuancesHere are some things that are worth calling out when we’re talking about CSS Cascade Layers:Specificity is still part of the game.!important acts differently than expected in @layer (they work in reverse!).@layers aren’t selector-specific but rather style-property-specific.@layer base { .button { background-color: blue; color: white; } } @layer theme { .button { background-color: red; /* No color property here, so white from base layer still applies */ } } @layer can easily be abused. I’m sure there’s a developer out there with over 20+ layer declarations that’s grown into a monstrosity.Comparing All ThreeNow, for the TL;DR folks out there, here’s a side-by-side comparison of the three: BEM, utility classes, and CSS Cascade Layers.FeatureBEMUtility ClassesCascade LayersCore IdeaNamespace componentsSingle purpose classesControl cascade orderSpecificity ControlLow and flatAvoids entirelyAbsolute control due to Layer supremacyCode ReadabilityClear structure due to namingUnclear if unfamiliar with the class namesClear if layer structure is followedHTML VerbosityModerate class names (can get long)Many small classes that adds up quicklyNo direct impact, stays only in CSSCSS OrganizationBy componentBy propertyBy priority orderLearning CurveRequires understanding conventionsRequires knowing the utility namesEasy to pick up, but requires a deep understanding of CSSTools DependencyPure CSSOften depends of third-party e.g TailwindNative CSSRefactoring EaseHighMediumLowBest Use CaseDesign SystemsFast buildsLegacy code or third-party codes that need overridesBrowser SupportAllAllAll (except IE)Among the three, each has its sweet spot:BEM is best when:There’s a clear design system that needs to be consistent,There’s a team with different philosophies about CSS (BEM can be the middle ground), andStyles are less likely to leak between components.Utility classes work best when:You need to build fast, like prototypes or MVPs, andUsing a component-based JavaScript framework like React.Cascade Layers are most effective when:Working on legacy codebases where you need full specificity control,You need to integrate third-party libraries or styles from different sources, andWorking on a large, complex application or projects with long-term maintenance.If I had to choose or rank them, I’d go for utility classes with Cascade Layers over using BEM. But that’s just me!Where They Intersect (How They Can Work Together)Among the three, Cascade Layers should be seen as an orchestrator, as it can work with the other two strategies. @layer is a fundamental tenet of the CSS Cascade’s architecture, unlike BEM and utility classes, which are methodologies for controlling the Cascade’s behavior./* Cascade Layers + BEM */ @layer components { .card__title { font-size: 1.5rem; font-weight: bold; } } /* Cascade Layers + Utility Classes */ @layer utilities { .text-xl { font-size: 1.25rem; } .font-bold { font-weight: 700; } } On the other hand, using BEM with utility classes would just end up clashing:\u003c!-- This feels wrong --\u003e \u003cdiv class=\"card__container p-4 flex items-center\"\u003e \u003cp class=\"card__title text-xl font-bold\"\u003eSomething seems wrong\u003c/p\u003e \u003c/div\u003e I’m putting all my cards on the table: I’m a utility-first developer. And most utility class frameworks use @layer behind the scenes (e.g., Tailwind). So, those two are already together in the bag.But, do I dislike BEM? Not at all! I’ve used it a lot and still would, if necessary. I just find naming things to be an exhausting exercise.That said, we’re all different, and you might have opposing thoughts about what you think feels best. It truly doesn’t matter, and that’s the beauty of this web development space. Multiple routes can lead to the same destination.ConclusionSo, when it comes to comparing BEM, utility classes, and CSS Cascade Layers, is there a true “winning” approach for controlling specificity in the Cascade?First of all, CSS Cascade Layers are arguably the most powerful CSS feature that we’ve gotten in years. They shouldn’t be confused with BEM or utility classes, which are strategies rather than part of the CSS feature set.That’s why I like the idea of combining either BEM with Cascade Layers or utility classes with Cascade Layers. Either way, the idea is to keep specificity low and leverage Cascade Layers to set priorities on those styles. (gg, yk)",
  "image": "https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/css-cascade-layers-bem-utility-classes-specificity-control.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e13 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/css\"\u003eCSS\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/coding\"\u003eCoding\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/techniques\"\u003eTechniques\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eCSS can be unpredictable — and specificity is often the culprit. Victor Ayomipo breaks down how and why your styles might not behave as expected, and why understanding specificity is better than relying on \u003ccode\u003e!important\u003c/code\u003e flags.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eCSS is wild, really wild. And tricky. But let’s talk specifically about \u003cstrong\u003especificity\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eWhen writing CSS, it’s close to impossible that you haven’t faced the frustration of styles not applying as expected — that’s specificity. You applied a style, it worked, and later, you try to override it with a different style and… nothing, it just ignores you. Again, specificity.\u003c/p\u003e\u003cp\u003eSure, there’s the option of resorting to \u003ccode\u003e!important\u003c/code\u003e flags, but like all developers before us, it’s always \u003ca href=\"https://cssguidelin.es/#important\"\u003erisky and discouraged\u003c/a\u003e. It’s way better to fully understand specificity than go down that route because otherwise you wind up fighting your own important styles.\u003c/p\u003e\u003cp\u003eLots of developers understand the concept of specificity in different ways.\u003c/p\u003e\u003cblockquote\u003eThe core idea of specificity is that the CSS Cascade algorithm used by browsers determines which style declaration is applied when two or more rules match the same element.\u003c/blockquote\u003e\u003cp\u003eThink about it. As a project expands, so do the specificity challenges. Let’s say Developer A adds \u003ccode\u003e.cart-button\u003c/code\u003e, then maybe the button style looks good to be used on the sidebar, but with a little tweak. Then, later, Developer B adds \u003ccode\u003e.cart-button .sidebar\u003c/code\u003e, and from there, any future changes applied to \u003ccode\u003e.cart-button\u003c/code\u003e might get overridden by \u003ccode\u003e.cart-button .sidebar\u003c/code\u003e, and just like that, the specificity war begins.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/1-specificity-tension.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"500\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/1-specificity-tension.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/1-specificity-tension.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/1-specificity-tension.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/1-specificity-tension.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/1-specificity-tension.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/1-specificity-tension.png\" sizes=\"100vw\" alt=\"Specifity tension represented by a pile of different elements\"/\u003e\u003c/a\u003e\u003cfigcaption\u003e(\u003ca href=\"https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/1-specificity-tension.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eI’ve written CSS long enough to witness different strategies that developers have used to manage the specificity battles that come with CSS.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/* Traditional approach */\n#header .nav li a.active { color: blue; }\n\n/* BEM approach */\n.header__nav-item--active { color: blue; }\n\n/* Utility classes approach */\n.text-blue { color: blue; }\n\n/* Cascade Layers approach */\n@layer components {\n  .nav-link.active { color: blue; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAll these methods reflect different strategies on how to control or at least maintain CSS specificity:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eBEM\u003c/strong\u003e: tries to simplify specificity by being explicit.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eUtility-first CSS\u003c/strong\u003e: tries to bypass specificity by keeping it all atomic.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eCSS Cascade Layers\u003c/strong\u003e: manage specificity by organizing styles in layered groups.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWe’re going to put all three side by side and look at how they handle specificity.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/2-different-strategies-control-css-specificity.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"500\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/2-different-strategies-control-css-specificity.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/2-different-strategies-control-css-specificity.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/2-different-strategies-control-css-specificity.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/2-different-strategies-control-css-specificity.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/2-different-strategies-control-css-specificity.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/2-different-strategies-control-css-specificity.png\" sizes=\"100vw\" alt=\"A chart which ilustrates different strategies on how to control or at least maintain CSS specificity\"/\u003e\u003c/a\u003e\u003cfigcaption\u003e(\u003ca href=\"https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/2-different-strategies-control-css-specificity.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"my-relationship-with-specificity\"\u003eMy Relationship With Specificity\u003c/h2\u003e\u003cp\u003eI actually used to think that I got the whole picture of CSS specificity. Like the usual inline greater than ID greater than class greater than tag. But, reading \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Cascade\"\u003ethe MDN docs on how the CSS Cascade truly works\u003c/a\u003e was an eye-opener.\u003c/p\u003e\u003cp\u003eThere’s a code I worked on in an old codebase provided by a client, which looked something like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/* Legacy code */\n#main-content .product-grid button.add-to-cart {\n  background-color: #3a86ff;\n  color: white;\n  padding: 10px 15px;\n  border-radius: 4px;\n}\n\n/* 100 lines of other code here */\n\n/* My new CSS */\n.btn-primary {\n  background-color: #4361ee; /* New brand color */\n  color: white;\n  padding: 12px 20px;\n  border-radius: 4px;\n  box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLooking at this code, no way that the \u003ccode\u003e.btn-primary\u003c/code\u003e class stands a chance against whatever specificity chain of selectors was previously written. As far as specification goes, CSS gives the first selector a specificity score of \u003ccode\u003e1, 2, 1\u003c/code\u003e: one point for the ID, two points for the two classes, and one point for the element selector. Meanwhile, the second selector is scored as \u003ccode\u003e0, 1, 0\u003c/code\u003e since it only consists of a single class selector.\u003c/p\u003e\u003cp\u003eSure, I had some options:\u003c/p\u003e\u003cul\u003e\u003cli\u003eI could \u003cstrong\u003euse \u003ccode\u003e!important\u003c/code\u003e on the properties\u003c/strong\u003e in \u003ccode\u003e.btn-primary\u003c/code\u003e to override the ones declared in the stronger selector, but the moment that happens, be prepared to use it everywhere. So, I’d rather avoid it.\u003c/li\u003e\u003cli\u003eI could try \u003cstrong\u003egoing more specific\u003c/strong\u003e, but personally, that’s just being cruel to the next developer (who might even be me).\u003c/li\u003e\u003cli\u003eI could \u003cstrong\u003echange the styles of the existing code\u003c/strong\u003e, but that’s adding to the specificity problem:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003e#main-content .product-grid .btn-primary {\n  /* edit styles directly */\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEventually, I ended up writing the whole CSS from scratch.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/3-legacy-modern-button.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"500\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/3-legacy-modern-button.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/3-legacy-modern-button.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/3-legacy-modern-button.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/3-legacy-modern-button.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/3-legacy-modern-button.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/3-legacy-modern-button.png\" sizes=\"100vw\" alt=\"Legacy button vs modern button\"/\u003e\u003c/a\u003e\u003cfigcaption\u003e(\u003ca href=\"https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/3-legacy-modern-button.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eWhen \u003cem\u003enesting\u003c/em\u003e was introduced, I tried it to control specificity that way:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e.profile-widget {\n  // ... other styles\n  .header {\n    // ... header styles\n    .user-avatar {\n      border: 2px solid blue;\n      \u0026amp;.is-admin {\n        border-color: gold; // This becomes .profile-widget .header .user-avatar.is-admin\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAnd just like that, I have unintentionally created high-specificity rules. That’s how easily and naturally we can drift toward specificity complexities.\u003c/p\u003e\u003cp\u003eSo, to save myself a lot of these issues, I have one principle I always abide by: \u003ca href=\"https://css-tricks.com/strategies-keeping-css-specificity-low/\"\u003e\u003cstrong\u003ekeep specificity as low as possible\u003c/strong\u003e\u003c/a\u003e. And if the selector complexity is becoming a complex chain, I rethink the whole thing.\u003c/p\u003e\u003ch2 id=\"bem-the-og-system\"\u003eBEM: The OG System\u003c/h2\u003e\u003cp\u003eThe Block-Element-Modifier (BEM, for short) has been around the block (pun intended) for a long time. It is a methodological system for writing CSS that forces you to make every style hierarchy explicit.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/* Block */\n.panel {}\n\n/* Element that depends on the Block */\n.panel__header {}\n.panel__content {}\n.panel__footer {}\n\n/* Modifier that changes the style of the Block */\n.panel--highlighted {}\n.panel__button--secondary {}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen I first experienced BEM, I thought it was amazing, despite contrary opinions that it looked ugly. I had no problems with the double hyphens or underscores because they made my CSS predictable and simplified.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/4-bem.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"500\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/4-bem.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/4-bem.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/4-bem.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/4-bem.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/4-bem.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/4-bem.png\" sizes=\"100vw\" alt=\"Illustration for BEM methodological system\"/\u003e\u003c/a\u003e\u003cfigcaption\u003e(\u003ca href=\"https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/4-bem.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003ch3 id=\"how-bem-handles-specificity\"\u003eHow BEM Handles Specificity\u003c/h3\u003e\u003cp\u003eTake a look at these examples. Without BEM:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/* Specificity: 0, 3, 0 */\n.site-header .main-nav .nav-link {\n  color: #472EFE;\n  text-decoration: none;\n}\n\n/* Specificity: 0, 2, 0 */\n.nav-link.special {\n  color: #FF5733;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith BEM:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/* Specificity: 0, 1, 0 */\n.main-nav__link {\n  color: #472EFE;\n  text-decoration: none;\n}\n\n/* Specificity: 0, 1, 0 */\n.main-nav__link--special {\n  color: #FF5733;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou see how BEM makes the code look predictable as all selectors are created equal, thus making the code easier to maintain and extend. And if I want to add a button to \u003ccode\u003e.main-nav\u003c/code\u003e, I just add \u003ccode\u003e.main-nav__btn\u003c/code\u003e, and if I need a disabled button (modifier), \u003ccode\u003e.main-nav__btn--disabled\u003c/code\u003e. Specificity is low, as I don’t have to increase it or fight the cascade; I just write a new class.\u003c/p\u003e\u003cp\u003eBEM’s naming principle made sure components lived in isolation, which, for a part of CSS, the specificity part, it worked, i.e, \u003ccode\u003e.card__title\u003c/code\u003e class will never accidentally clash with a \u003ccode\u003e.menu__title\u003c/code\u003e class.\u003c/p\u003e\u003ch3 id=\"where-bem-falls-short\"\u003eWhere BEM Falls Short\u003c/h3\u003e\u003cp\u003eI like the idea of BEM, but it is not perfect, and a lot of people noticed it:\u003c/p\u003e\u003cul\u003e\u003cli\u003eThe class names can get \u003cem\u003ereally\u003c/em\u003e long.\u003c/li\u003e\u003c/ul\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;div class=\u0026#34;product-carousel__slide--featured product-carousel__slide--on-sale\u0026#34;\u0026gt;\n  \u0026lt;!-- yikes --\u0026gt;\n\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eReusability might not be prioritized\u003c/strong\u003e, which somewhat contradicts the native CSS ideology. Should a button inside a card be \u003ccode\u003e.card__button\u003c/code\u003e or reuse a global \u003ccode\u003e.button\u003c/code\u003e class? With the former, styles are being duplicated, and with the latter, the BEM strict model is being broken.\u003c/li\u003e\u003cli\u003eOne of the core pains in software development starts becoming a reality — \u003cstrong\u003enaming things\u003c/strong\u003e. \u003ca href=\"https://css-tricks.com/naming-things-is-only-getting-harder/\"\u003eI’m sure you know the frustration of that already.\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eBEM is good, but sometimes you may need to be flexible with it. A \u003cstrong\u003ehybrid system\u003c/strong\u003e (maybe using BEM for core components but simpler classes elsewhere) can still keep specificity as low as needed.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/* Base button without BEM */\n.button {\n  /* Button styles */\n}\n\n/* Component-specific button with BEM */\n.card__footer .button {\n  /* Minor overrides */\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"utility-classes-specificity-by-avoidance\"\u003eUtility Classes: Specificity By Avoidance\u003c/h2\u003e\u003cp\u003eThis is also called \u003ca href=\"https://css-tricks.com/lets-define-exactly-atomic-css/\"\u003eAtomic CSS\u003c/a\u003e. And in its entirety, it \u003cem\u003eavoids specificity.\u003c/em\u003e\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;button class=\u0026#34;bg-red-300 hover:bg-red-500 text-white py-2 px-4 rounded\u0026#34;\u0026gt;\n  A button\n\u0026lt;/button\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003eThe idea behind utility-first classes is that every utility class has the same specificity, which is one class selector. Each class is a tiny CSS property with a single purpose.\u003c/blockquote\u003e\u003cp\u003e\u003ccode\u003ep-2\u003c/code\u003e? Padding, nothing more. \u003ccode\u003etext-red\u003c/code\u003e? Color red for text. \u003ccode\u003etext-center\u003c/code\u003e? Text alignment. It’s like how LEGOs work, but for styling. You stack classes on top of each other until you get your desired appearance.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/5-specificity-by-avoidance.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"500\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/5-specificity-by-avoidance.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/5-specificity-by-avoidance.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/5-specificity-by-avoidance.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/5-specificity-by-avoidance.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/5-specificity-by-avoidance.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/5-specificity-by-avoidance.png\" sizes=\"100vw\" alt=\"An illustration with a title: Avoiding specifity - one utility at a time\"/\u003e\u003c/a\u003e\u003cfigcaption\u003e(\u003ca href=\"https://files.smashing.media/articles/css-cascade-layers-bem-utility-classes-specificity-control/5-specificity-by-avoidance.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003ch3 id=\"how-utility-classes-handle-specificity\"\u003eHow Utility Classes Handle Specificity\u003c/h3\u003e\u003cp\u003eUtility classes do not solve specificity, but rather, they take the BEM ideology of low specificity to the extreme. Almost all utility classes have the same lowest possible specificity level of (\u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003e1\u003c/code\u003e, \u003ccode\u003e0\u003c/code\u003e). And because of this, overrides become easy; if more padding is needed, bump \u003ccode\u003e.p-2\u003c/code\u003e to \u003ccode\u003e.p-4\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eAnother example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;button class=\u0026#34;bg-orange-300 hover:bg-orange-700\u0026#34;\u0026gt;\n  This can be hovered\n\u0026lt;/button\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf another class, \u003ccode\u003ehover:bg-red-500\u003c/code\u003e, is added, the order matters for CSS to determine which to use. So, even though the utility classes avoid specificity, the other parts of the CSS Cascade come in, which is the order of appearance, with the last matching selector declared being the winner.\u003c/p\u003e\u003ch3 id=\"utility-class-trade-offs\"\u003eUtility Class Trade-Offs\u003c/h3\u003e\u003cp\u003eThe most common issue with utility classes is that \u003cstrong\u003ethey make the code look ugly\u003c/strong\u003e. And frankly, I agree. But being able to picture what a component looks like without seeing it rendered is just priceless.\u003c/p\u003e\u003cp\u003eThere’s also the argument of reusability, that you repeat yourself every single time. But once one finds a repetition happening, just turn that part into a reusable component. It also has its genuine \u003cstrong\u003elimitations\u003c/strong\u003e when it comes to specificity:\u003c/p\u003e\u003cul\u003e\u003cli\u003eIf your brand color changes, which is a global change, and you’re deep in the codebase, you can’t just change one and have others follow like native CSS.\u003c/li\u003e\u003cli\u003eThe parent-child relationship that happens naturally in native CSS is out the window due to how atomic utility classes behave.\u003c/li\u003e\u003cli\u003eSome argue the HTML part should be left as markup and the CSS part for styling. Because now, there’s more markup to scan, and if you decide to clean up:\u003c/li\u003e\u003c/ul\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;!-- Too long --\u0026gt;\n\u0026lt;div class=\u0026#34;p-4 bg-yellow-100 border border-yellow-300 text-yellow-800 rounded\u0026#34;\u0026gt;\n\n\u0026lt;!-- Better? --\u0026gt;\n\u0026lt;div class=\u0026#34;alert-warning\u0026#34;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eJust like that, we’ve ended up writing CSS. Circle of life.\u003c/p\u003e\u003cp\u003eIn my experience with utility classes, they work best for:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eSpeed\u003c/strong\u003e\u003cbr/\u003eWriting the markup, styling it, and seeing the result swiftly.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003ePredictability\u003c/strong\u003e\u003cbr/\u003eA utility class does exactly what it says it does.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"cascade-layers-specificity-by-design\"\u003eCascade Layers: Specificity By Design\u003c/h2\u003e\u003cp\u003eNow, this is where it gets interesting. BEM offers structure, utility classes gain speed, and CSS Cascade Layers give us something paramount: \u003cstrong\u003econtrol\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eAnyways, Cascade Layers (\u003ccode\u003e@layers\u003c/code\u003e) groups styles and declares what order the groups should be, regardless of the specificity scores of those rules.\u003c/p\u003e\u003cp\u003eLooking at a set of independent rulesets:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ebutton {\n  background-color: orange; /* Specificity: 0, 0, 1 */\n}\n\n.button {\n  background-color: blue; //* Specificity: 0, 1, 0*/\n}\n\n#button {\n  background-color: red; /* Specificity: 1, 0, 0 */\n}\n\n/* No matter what, the button is red */\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut with \u003ccode\u003e@layer\u003c/code\u003e, let’s say, I want to prioritize the \u003ccode\u003e.button\u003c/code\u003e class selector. I can shape how the specificity order should go:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@layer utilities, defaults, components;\n\n@layer defaults {\n  button {\n    background-color: orange; /* Specificity: 0, 0, 1 */\n  }\n}\n\n@layer components {\n  .button {\n    background-color: blue; //* Specificity: 0, 1, 0*/\n  }\n}\n\n@layer utilities {\n  #button {\n    background-color: red; /* Specificity: 1, 0, 0 */\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDue to how \u003ccode\u003e@layer\u003c/code\u003e works, \u003ccode\u003e.button\u003c/code\u003e would win because the \u003ccode\u003ecomponents\u003c/code\u003e layer is the highest priority, even though \u003ccode\u003e#button\u003c/code\u003e has higher specificity. Thus, before CSS could even check the usual specificity rules, the layer order would first be respected.\u003c/p\u003e\u003cp\u003eYou just have to respect the folks over at W3C, because now one can purposely override an ID selector with a simple class, without even using \u003ccode\u003e!important\u003c/code\u003e. Fascinating.\u003c/p\u003e\u003ch3 id=\"cascade-layers-nuances\"\u003eCascade Layers Nuances\u003c/h3\u003e\u003cp\u003eHere are some things that are worth calling out when we’re talking about CSS Cascade Layers:\u003c/p\u003e\u003cul\u003e\u003cli\u003eSpecificity is still part of the game.\u003c/li\u003e\u003cli\u003e\u003ccode\u003e!important\u003c/code\u003e acts differently than expected in \u003ccode\u003e@layer\u003c/code\u003e (they work in reverse!).\u003c/li\u003e\u003cli\u003e\u003ccode\u003e@layers\u003c/code\u003e aren’t selector-specific but rather style-property-specific.\u003c/li\u003e\u003c/ul\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e@layer base {\n  .button {\n    background-color: blue;\n    color: white;\n  }\n}\n\n@layer theme {\n  .button {\n    background-color: red;\n    /* No color property here, so white from base layer still applies */\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003e@layer\u003c/code\u003e can easily be abused. I’m sure there’s a developer out there with over 20+ layer declarations that’s grown into a monstrosity.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"comparing-all-three\"\u003eComparing All Three\u003c/h3\u003e\u003cp\u003eNow, for the TL;DR folks out there, here’s a side-by-side comparison of the three: BEM, utility classes, and CSS Cascade Layers.\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eFeature\u003c/th\u003e\u003cth\u003eBEM\u003c/th\u003e\u003cth\u003eUtility Classes\u003c/th\u003e\u003cth\u003eCascade Layers\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eCore Idea\u003c/td\u003e\u003ctd\u003eNamespace components\u003c/td\u003e\u003ctd\u003eSingle purpose classes\u003c/td\u003e\u003ctd\u003eControl cascade order\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSpecificity Control\u003c/td\u003e\u003ctd\u003eLow and flat\u003c/td\u003e\u003ctd\u003eAvoids entirely\u003c/td\u003e\u003ctd\u003eAbsolute control due to Layer supremacy\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCode Readability\u003c/td\u003e\u003ctd\u003eClear structure due to naming\u003c/td\u003e\u003ctd\u003eUnclear if unfamiliar with the class names\u003c/td\u003e\u003ctd\u003eClear if layer structure is followed\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eHTML Verbosity\u003c/td\u003e\u003ctd\u003eModerate class names (can get long)\u003c/td\u003e\u003ctd\u003eMany small classes that adds up quickly\u003c/td\u003e\u003ctd\u003eNo direct impact, stays only in CSS\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCSS Organization\u003c/td\u003e\u003ctd\u003eBy component\u003c/td\u003e\u003ctd\u003eBy property\u003c/td\u003e\u003ctd\u003eBy priority order\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eLearning Curve\u003c/td\u003e\u003ctd\u003eRequires understanding conventions\u003c/td\u003e\u003ctd\u003eRequires knowing the utility names\u003c/td\u003e\u003ctd\u003eEasy to pick up, but requires a deep understanding of CSS\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTools Dependency\u003c/td\u003e\u003ctd\u003ePure CSS\u003c/td\u003e\u003ctd\u003eOften depends of third-party e.g Tailwind\u003c/td\u003e\u003ctd\u003eNative CSS\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eRefactoring Ease\u003c/td\u003e\u003ctd\u003eHigh\u003c/td\u003e\u003ctd\u003eMedium\u003c/td\u003e\u003ctd\u003eLow\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eBest Use Case\u003c/td\u003e\u003ctd\u003eDesign Systems\u003c/td\u003e\u003ctd\u003eFast builds\u003c/td\u003e\u003ctd\u003eLegacy code or third-party codes that need overrides\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eBrowser Support\u003c/td\u003e\u003ctd\u003eAll\u003c/td\u003e\u003ctd\u003eAll\u003c/td\u003e\u003ctd\u003eAll (except IE)\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eAmong the three, each has its sweet spot:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eBEM\u003c/strong\u003e is best when:\u003cul\u003e\u003cli\u003eThere’s a clear design system that needs to be consistent,\u003c/li\u003e\u003cli\u003eThere’s a team with different philosophies about CSS (BEM can be the middle ground), and\u003c/li\u003e\u003cli\u003eStyles are less likely to leak between components.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eUtility classes\u003c/strong\u003e work best when:\u003cul\u003e\u003cli\u003eYou need to build fast, like prototypes or MVPs, and\u003c/li\u003e\u003cli\u003eUsing a component-based JavaScript framework like React.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eCascade Layers\u003c/strong\u003e are most effective when:\u003cul\u003e\u003cli\u003eWorking on legacy codebases where you need full specificity control,\u003c/li\u003e\u003cli\u003eYou need to integrate third-party libraries or styles from different sources, and\u003c/li\u003e\u003cli\u003eWorking on a large, complex application or projects with long-term maintenance.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIf I had to choose or rank them, I’d go for utility classes with Cascade Layers over using BEM. But that’s just me!\u003c/p\u003e\u003ch2 id=\"where-they-intersect-how-they-can-work-together\"\u003eWhere They Intersect (How They Can Work Together)\u003c/h2\u003e\u003cp\u003eAmong the three, Cascade Layers should be seen as an orchestrator, as it can work with the other two strategies. \u003ccode\u003e@layer\u003c/code\u003e is a fundamental tenet of the CSS Cascade’s architecture, unlike BEM and utility classes, which are methodologies for controlling the Cascade’s behavior.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/* Cascade Layers + BEM */\n@layer components {\n  .card__title {\n    font-size: 1.5rem;\n    font-weight: bold;\n  }\n}\n\n/* Cascade Layers + Utility Classes */\n@layer utilities {\n  .text-xl {\n    font-size: 1.25rem;\n  }\n  .font-bold {\n    font-weight: 700;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOn the other hand, using BEM with utility classes would just end up clashing:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;!-- This feels wrong --\u0026gt;\n\u0026lt;div class=\u0026#34;card__container p-4 flex items-center\u0026#34;\u0026gt;\n  \u0026lt;p class=\u0026#34;card__title text-xl font-bold\u0026#34;\u0026gt;Something seems wrong\u0026lt;/p\u0026gt;\n\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI’m putting all my cards on the table: I’m a utility-first developer. And most utility class frameworks use \u003ccode\u003e@layer\u003c/code\u003e behind the scenes (e.g., \u003ca href=\"https://tailwindcss.com/blog/tailwindcss-v4#designed-for-the-modern-web\"\u003eTailwind\u003c/a\u003e). So, those two are already together in the bag.\u003c/p\u003e\u003cp\u003eBut, do I dislike BEM? Not at all! I’ve used it a lot and still would, if necessary. I just find naming things to be an exhausting exercise.\u003c/p\u003e\u003cp\u003eThat said, we’re all different, and you might have opposing thoughts about what you think feels best. It truly doesn’t matter, and that’s the beauty of this web development space. \u003cem\u003eMultiple routes can lead to the same destination\u003c/em\u003e.\u003c/p\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eSo, when it comes to comparing BEM, utility classes, and CSS Cascade Layers, is there a true “winning” approach for controlling specificity in the Cascade?\u003c/p\u003e\u003cp\u003eFirst of all, CSS Cascade Layers are arguably the most powerful CSS feature that we’ve gotten in years. They shouldn’t be confused with BEM or utility classes, which are strategies rather than part of the CSS feature set.\u003c/p\u003e\u003cp\u003eThat’s why I like the idea of combining either BEM with Cascade Layers or utility classes with Cascade Layers. Either way, the idea is to \u003cstrong\u003ekeep specificity low and leverage Cascade Layers to set priorities on those styles\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(gg, yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2025-06-19T15:00:00Z",
  "modifiedTime": "2025-06-19T15:00:00Z"
}
