{
  "id": "e78ce28d-7213-4e5f-a233-6f259be03684",
  "title": "The Hype Around Signals",
  "link": "https://smashingmagazine.com/2024/11/the-hype-around-signals/",
  "description": "From KnockoutJS to modern UI libraries like SolidJS, Vue.js, and Svelte, signals revolutionized how we think about reactivity in UIs. Here’s a deep dive into their history and impact by Atila Fassina.",
  "author": "Atila Fassina",
  "published": "Wed, 27 Nov 2024 10:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 9360,
  "excerpt": "From KnockoutJS to modern UI libraries like SolidJS, Vue.js, and Svelte, signals revolutionized how we think about reactivity in UIs. Here’s a deep dive into their history and impact by Atila Fassina.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "8 min readCoding, Techniques, UIFrom KnockoutJS to modern UI libraries like SolidJS, Vue.js, and Svelte, signals revolutionized how we think about reactivity in UIs. Here’s a deep dive into their history and impact by Atila Fassina.The groundwork for what we call today “signals” dates as early as the 1970s. Based on this work, they became popular with different fields of computer science, defining them more specifically around the 90s and the early 2000s.In Web Development, they first made a run for it with KnockoutJS, and shortly after, signals took a backseat in (most of) our brains. Some years ago, multiple similar implementations came to be.MobX observable statesVue.js refs and shallow refsSolidJS signalsWith different names and implementation details, those approaches are similar enough to be wrapped in a category we know today as Fine-Grained Reactivity, even if they have different levels of “fine” x “coarse” updates — we’ll get more into what this means soon enough.To summarize the history: Even being an older technology, signals started a revolution in how we thought about interactivity and data in our UIs at the time. And since then, every UI library (SolidJS, Marko, Vue.js, Qwik, Angular, Svelte, Wiz, Preact, etc) has adopted some kind of implementation of them (except for React).Typically, a signal is composed of an accessor (getter) and a setter. The setter establishes an update to the value held by the signal and triggers all dependent effects. While an accessor pulls the value from the source and is run by effects every time a change happens upstream.const [signal, setSignal] = createSignal(\"initial value\"); setSignal(\"new value\"); console.log(signal()); // \"new value\" In order to understand the reason for that, we need to dig a little deeper into what API Architectures and Fine-Grained Reactivity actually mean.API ArchitecturesThere are two basic ways of defining systems based on how they handle their data. Each of these approaches has its pros and cons.Pull: The consumer pings the source for updates.Push: The source sends the updates as soon as they are available.Pull systems need to handle polling or some other way of maintaining their data up-to-date. They also need to guarantee that all consumers of the data get torn down and recreated once new data arrives to avoid state tearing.State Tearing occurs when different parts of the same UI are at different stages of the state. For example, when your header shows 8 posts available, but the list has 10.Push systems don’t need to worry about maintaining their data up-to-date. Nevertheless, the source is unaware of whether the consumer is ready to receive the updates. This can cause backpressure. A data source may send too many updates in a shorter amount of time than the consumer is capable of handling. If the update flux is too intense for the receiver, it can cause loss of data packages (leading to state tearing once again) and, in more serious cases, even crash the client.In pull systems, the accepted tradeoff is that data is unaware of where it’s being used; this causes the receiving end to create precautions around maintaining all their components up-to-date. That’s how systems like React work with their teardown/re-render mechanism around updates and reconciliation.In push systems, the accepted tradeoff is that the receiving end needs to be able to deal with the update stream in a way that won’t cause it to crash while maintaining all consuming nodes in a synchronized state. In web development, RxJS is the most popular example of a push system.The attentive reader may have noticed the tradeoffs on each system are at the opposite ends of the spectrum: while pull systems are good at scheduling the updates efficiently, in push architectures, the data knows where it’s being used — allows for more granular control. That’s what makes a great opportunity for a hybrid model.Push-Pull ArchitecturesIn Push-Pull systems, the state has a list of subscribers, which can then trigger for re-fetching data once there is an update. The way it differs from traditional push is that the update itself isn’t sent to the subscribers — just a notification that they’re now stale.Once the subscriber is aware its current state has become stale, it will then fetch the new data at a proper time, avoiding any kind of backpressure and behaving similarly to the pull mechanism. The difference is that this only happens when the subscriber is certain there is new data to be fetched.We call these data signals, and the way those subscribers are triggered to update are called effects. Not to confuse with useEffect, which is a similar name for a completely different thing.Fine-Grained ReactivityOnce we establish the two-way interaction between the data source and data consumer, we will have a reactive system.A reactive system only exists when data can notify the consumer it has changed, and the consumer can apply those changes.Now, to make it fine-grained there are two fundamental requirements that need to be met:Efficiency: The system only executes the minimum amount of computations necessary.Glitch-Free: No intermediary states are shown in the process of updating a state.Efficiency In UIsTo really understand how signals can achieve high levels of efficiency, one needs to understand what it means to have an accessor. In broad strokes, they behave as getter functions. Having an accessor means the value does not exist within the boundaries of our component — what our templates receive is a getter for that value, and every time their effects run, they will bring an up-to-date new value. This is why signals are functions and not simple variables. For example, in Solid:import { createSignal } from 'solid-js' function ReactiveComponent() { const [signal, setSignal] = createSignal() return ( \u003ch1\u003eHello, {signal()}\u003c/h1\u003e ) } The part that is relevant to performance (and efficiency) in the snippet above is that considering signal() is a getter, it does not need to re-run the whole ReactiveComponent() function to update the rendered artifact; only the signal is re-run, guaranteeing no extra computation will run.Glitch-Free UIsNon-reactive systems avoid intermediary states by having a teardown/re-render mechanism. They toss away the artifacts with possibly stale data and recreate everything from scratch. That works well and consistently but at the expense of efficiency.In order to understand how reactive systems handle this problem, we need to talk about the Diamond Challenge. This is a quick problem to describe but a tough one to solve. Take a look at the diagram below:(Large preview)Pay attention to the E node. It depends on D and B, but only D depends on C.If your reactive system is too eager to update, it can receive the update from B while D is still stale. That will cause E to show an intermediary state that should not exist.It’s easy and intuitive to have A trigger its children for updates as soon as new data arrives and let it cascade down. But if this happens, E receives the data from B while D is stale. If B is able to trigger an update from E, E will show an intermediate state.Each implementation adopts different update strategies to solve this challenge. They can be grouped into two categories:Lazy SignalsWhere a scheduler defines the order within which the updates will occur. (A, then B and C, then D, and finally E).Eager SignalsWhen signals are aware if their parents are stale, checking, or clean. In this approach, when E receives the update from B, it will trigger a check/update on D, which will climb up until it can ensure to be back in a clean state, allowing E to finally update.Back To Our UIsAfter this dive into what fine-grained reactivity means, it’s time to take a step back and look at our websites and apps. Let’s analyze what it means to our daily work.DX And UXWhen the code we wrote is easier to reason about, we can then focus on the things that really matter: the features we deliver to our users. Naturally, tools that require less work to operate will deliver less maintenance and overhead for the craftsperson.A system that is glitch-free and efficient by default will get out of the developer’s way when it’s time to build with it. It will also enforce a higher connection to the platform via a thinner abstraction layer.When it comes to Developer Experience, there is also something to be said about known territory. People are more productive within the mental models and paradigms they are used to. Naturally, solutions that have been around for longer and have solved a larger quantity of challenges are easier to work with, but that is at odds with innovation. It was a cognitive exercise when JSX came around and replaced imperative DOM updates with jQuery. In the same way, a new paradigm to handle rendering will cause a similar discomfort until it becomes common.Going DeeperWe will talk further about this in the next article, where we’re looking more closely into different implementations of signals (lazy, eager, hybrid), scheduled updates, interacting with the DOM, and debugging your own code!Meanwhile, you can find me in the comments section below, on 𝕏 (Twitter), LinkedIn, BlueSky, or even youtube. I’m always happy to chat, and if you tell me what you want to know, I’ll make sure to include it in the next article! See ya! (yk)",
  "image": "https://files.smashing.media/articles/the-hype-around-signals/the-hype-around-signals.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e8 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/coding\"\u003eCoding\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/techniques\"\u003eTechniques\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/ui\"\u003eUI\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eFrom KnockoutJS to modern UI libraries like SolidJS, Vue.js, and Svelte, signals revolutionized how we think about reactivity in UIs. Here’s a deep dive into their history and impact by Atila Fassina.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eThe groundwork for what we call today “signals” dates as early as the 1970s. Based on this work, they became popular with different fields of computer science, defining them more specifically around the 90s and the early 2000s.\u003c/p\u003e\u003cp\u003eIn Web Development, they first made a run for it with \u003ca href=\"https://knockoutjs.com\"\u003eKnockoutJS\u003c/a\u003e, and shortly after, signals took a backseat in (most of) our brains. Some years ago, multiple similar implementations came to be.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://mobx.js.org/observable-state.html\"\u003eMobX observable states\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://vuejs.org/api/reactivity-advanced.html\"\u003eVue.js refs and shallow refs\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://docs.solidjs.com/concepts/intro-to-reactivity\"\u003eSolidJS signals\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWith different names and implementation details, those approaches are similar enough to be wrapped in a category we know today as \u003cstrong\u003eFine-Grained Reactivity\u003c/strong\u003e, even if they have different levels of “fine” x “coarse” updates — we’ll get more into what this means soon enough.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTo summarize the history\u003c/strong\u003e: Even being an older technology, signals started a revolution in how we thought about interactivity and data in our UIs at the time. And since then, every UI library (SolidJS, Marko, Vue.js, Qwik, Angular, Svelte, Wiz, Preact, etc) has adopted some kind of implementation of them (except for React).\u003c/p\u003e\u003cp\u003eTypically, a \u003cstrong\u003esignal\u003c/strong\u003e is composed of an accessor (getter) and a setter. The setter establishes an update to the value held by the signal and triggers all dependent effects. While an accessor pulls the value from the source and is run by effects every time a change happens upstream.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst [signal, setSignal] = createSignal(\u0026#34;initial value\u0026#34;);\n\nsetSignal(\u0026#34;new value\u0026#34;);\n\nconsole.log(signal()); // \u0026#34;new value\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn order to understand the reason for that, we need to dig a little deeper into what \u003cstrong\u003eAPI Architectures\u003c/strong\u003e and \u003cstrong\u003eFine-Grained Reactivity\u003c/strong\u003e actually mean.\u003c/p\u003e\u003ch2 id=\"api-architectures\"\u003eAPI Architectures\u003c/h2\u003e\u003cp\u003eThere are two basic ways of defining systems based on how they handle their data. Each of these approaches has its pros and cons.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003ePull\u003c/strong\u003e: The consumer pings the source for updates.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003ePush\u003c/strong\u003e: The source sends the updates as soon as they are available.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003ePull\u003c/strong\u003e systems need to handle polling or some other way of maintaining their data up-to-date. They also need to guarantee that all consumers of the data get torn down and recreated once new data arrives to avoid \u003cstrong\u003estate tearing\u003c/strong\u003e.\u003c/p\u003e\u003cblockquote\u003e\u003cstrong\u003eState Tearing\u003c/strong\u003e occurs when different parts of the same UI are at different stages of the state. For example, when your header shows 8 posts available, but the list has 10.\u003c/blockquote\u003e\u003cp\u003e\u003cstrong\u003ePush\u003c/strong\u003e systems don’t need to worry about maintaining their data up-to-date. Nevertheless, the source is unaware of whether the consumer is ready to receive the updates. This can cause \u003cstrong\u003ebackpressure\u003c/strong\u003e. A data source may send too many updates in a shorter amount of time than the consumer is capable of handling. If the update flux is too intense for the receiver, it can cause loss of data packages (leading to \u003cstrong\u003estate tearing\u003c/strong\u003e once again) and, in more serious cases, even crash the client.\u003c/p\u003e\u003cp\u003eIn \u003cstrong\u003epull\u003c/strong\u003e systems, the accepted tradeoff is that data is unaware of where it’s being used; this causes the receiving end to create precautions around maintaining all their components up-to-date. That’s how systems like \u003ca href=\"https://react.dev\"\u003eReact\u003c/a\u003e work with their teardown/re-render mechanism around updates and reconciliation.\u003c/p\u003e\u003cp\u003eIn \u003cstrong\u003epush\u003c/strong\u003e systems, the accepted tradeoff is that the receiving end needs to be able to deal with the update stream in a way that won’t cause it to crash while maintaining all consuming nodes in a synchronized state. In web development, \u003ca href=\"https://rxjs.dev\"\u003eRxJS\u003c/a\u003e is the most popular example of a push system.\u003c/p\u003e\u003cp\u003eThe attentive reader may have noticed the tradeoffs on each system are at the opposite ends of the spectrum: while pull systems are good at scheduling the updates efficiently, in push architectures, the data knows where it’s being used — allows for more granular control. That’s what makes a great opportunity for a \u003cstrong\u003ehybrid\u003c/strong\u003e model.\u003c/p\u003e\u003ch2 id=\"push-pull-architectures\"\u003ePush-Pull Architectures\u003c/h2\u003e\u003cp\u003eIn Push-Pull systems, the state has a list of subscribers, which can then trigger for re-fetching data once there is an update. The way it differs from traditional push is that the update itself isn’t sent to the subscribers — just a notification that they’re now stale.\u003c/p\u003e\u003cp\u003eOnce the subscriber is aware its current state has become stale, it will then fetch the new data at a proper time, avoiding any kind of backpressure and behaving similarly to the pull mechanism. The difference is that this only happens when the subscriber is certain there is new data to be fetched.\u003c/p\u003e\u003cp\u003eWe call these data \u003cstrong\u003esignals\u003c/strong\u003e, and the way those subscribers are triggered to update are called \u003cstrong\u003eeffects\u003c/strong\u003e. Not to confuse with \u003ccode\u003euseEffect\u003c/code\u003e, which is a similar name for a completely different thing.\u003c/p\u003e\u003ch2 id=\"fine-grained-reactivity\"\u003eFine-Grained Reactivity\u003c/h2\u003e\u003cp\u003eOnce we establish the two-way interaction between the data source and data consumer, we will have a reactive system.\u003c/p\u003e\u003cblockquote\u003eA \u003cstrong\u003ereactive system\u003c/strong\u003e only exists when data can notify the consumer it has changed, and the consumer can apply those changes.\u003c/blockquote\u003e\u003cp\u003eNow, to make it \u003cstrong\u003efine-grained\u003c/strong\u003e there are two fundamental requirements that need to be met:\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eEfficiency\u003c/strong\u003e: The system only executes the minimum amount of computations necessary.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eGlitch-Free\u003c/strong\u003e: No intermediary states are shown in the process of updating a state.\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"efficiency-in-uis\"\u003eEfficiency In UIs\u003c/h3\u003e\u003cp\u003eTo really understand how signals can achieve high levels of efficiency, one needs to understand what it means to have an \u003cstrong\u003eaccessor\u003c/strong\u003e. In broad strokes, they behave as getter functions. Having an accessor means the value does not exist within the boundaries of our component — what our templates receive is a getter for that value, and every time their effects run, they will bring an up-to-date new value. This is why signals are functions and not simple variables. For example, in Solid:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimport { createSignal } from \u0026#39;solid-js\u0026#39;\n\nfunction ReactiveComponent() {\n  const [signal, setSignal] = createSignal()\n  \n  return (\n    \u0026lt;h1\u0026gt;Hello, {signal()}\u0026lt;/h1\u0026gt;\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe part that is relevant to performance (and efficiency) in the snippet above is that considering \u003ccode\u003esignal()\u003c/code\u003e is a getter, it does not need to re-run the whole \u003ccode\u003eReactiveComponent()\u003c/code\u003e function to update the rendered artifact; only the signal is re-run, guaranteeing no extra computation will run.\u003c/p\u003e\u003ch2 id=\"glitch-free-uis\"\u003eGlitch-Free UIs\u003c/h2\u003e\u003cp\u003eNon-reactive systems avoid intermediary states by having a teardown/re-render mechanism. They toss away the artifacts with possibly stale data and recreate everything from scratch. That works well and consistently but at the expense of efficiency.\u003c/p\u003e\u003cp\u003eIn order to understand how reactive systems handle this problem, we need to talk about the \u003cstrong\u003eDiamond Challenge\u003c/strong\u003e. This is a quick problem to describe but a tough one to solve. Take a look at the diagram below:\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/the-hype-around-signals/1-diamond-diagram.jpg\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"679\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/the-hype-around-signals/1-diamond-diagram.jpg 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/the-hype-around-signals/1-diamond-diagram.jpg 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/the-hype-around-signals/1-diamond-diagram.jpg 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/the-hype-around-signals/1-diamond-diagram.jpg 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/the-hype-around-signals/1-diamond-diagram.jpg 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/the-hype-around-signals/1-diamond-diagram.jpg\" sizes=\"100vw\" alt=\"Diamond diagram\"/\u003e\u003c/a\u003e\u003cfigcaption\u003e(\u003ca href=\"https://files.smashing.media/articles/the-hype-around-signals/1-diamond-diagram.jpg\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003ePay attention to the \u003ccode\u003eE\u003c/code\u003e node. It depends on \u003ccode\u003eD\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e, but only \u003ccode\u003eD\u003c/code\u003e depends on \u003ccode\u003eC\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eIf your reactive system is too eager to update, it can receive the update from \u003ccode\u003eB\u003c/code\u003e while \u003ccode\u003eD\u003c/code\u003e is still stale. That will cause \u003ccode\u003eE\u003c/code\u003e to show an intermediary state that should not exist.\u003c/p\u003e\u003cp\u003eIt’s easy and intuitive to have \u003ccode\u003eA\u003c/code\u003e trigger its children for updates as soon as new data arrives and let it cascade down. But if this happens, \u003ccode\u003eE\u003c/code\u003e receives the data from \u003ccode\u003eB\u003c/code\u003e while \u003ccode\u003eD\u003c/code\u003e is stale. If \u003ccode\u003eB\u003c/code\u003e is able to trigger an update from \u003ccode\u003eE\u003c/code\u003e, \u003ccode\u003eE\u003c/code\u003e will show an intermediate state.\u003c/p\u003e\u003cp\u003eEach implementation adopts different update strategies to solve this challenge. They can be grouped into two categories:\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eLazy Signals\u003c/strong\u003e\u003cbr/\u003eWhere a scheduler defines the order within which the updates will occur. (\u003ccode\u003eA\u003c/code\u003e, then \u003ccode\u003eB\u003c/code\u003e and \u003ccode\u003eC\u003c/code\u003e, then \u003ccode\u003eD\u003c/code\u003e, and finally \u003ccode\u003eE\u003c/code\u003e).\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eEager Signals\u003c/strong\u003e\u003cbr/\u003eWhen signals are aware if their parents are \u003cstrong\u003estale\u003c/strong\u003e, \u003cstrong\u003echecking\u003c/strong\u003e, or \u003cstrong\u003eclean\u003c/strong\u003e. In this approach, when \u003ccode\u003eE\u003c/code\u003e receives the update from \u003ccode\u003eB\u003c/code\u003e, it will trigger a check/update on \u003ccode\u003eD\u003c/code\u003e, which will climb up until it can ensure to be back in a \u003cstrong\u003eclean\u003c/strong\u003e state, allowing \u003ccode\u003eE\u003c/code\u003e to finally update.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"back-to-our-uis\"\u003eBack To Our UIs\u003c/h2\u003e\u003cp\u003eAfter this dive into what \u003cstrong\u003efine-grained reactivity\u003c/strong\u003e means, it’s time to take a step back and look at our websites and apps. Let’s analyze what it means to our daily work.\u003c/p\u003e\u003ch2 id=\"dx-and-ux\"\u003eDX And UX\u003c/h2\u003e\u003cp\u003eWhen the code we wrote is easier to reason about, we can then focus on the things that really matter: the features we deliver to our users. Naturally, tools that require less work to operate will deliver less maintenance and overhead for the craftsperson.\u003c/p\u003e\u003cp\u003eA system that is glitch-free and efficient by default will get out of the developer’s way when it’s time to build with it. It will also enforce a higher connection to the platform via a thinner abstraction layer.\u003c/p\u003e\u003cp\u003eWhen it comes to Developer Experience, there is also something to be said about known territory. People are more productive within the mental models and paradigms they are used to. Naturally, solutions that have been around for longer and have solved a larger quantity of challenges are easier to work with, but that is \u003cstrong\u003eat odds with innovation\u003c/strong\u003e. It was a cognitive exercise when JSX came around and replaced imperative DOM updates with jQuery. In the same way, a new paradigm to handle rendering will cause a similar discomfort until it becomes common.\u003c/p\u003e\u003ch2 id=\"going-deeper\"\u003eGoing Deeper\u003c/h2\u003e\u003cp\u003eWe will talk further about this in the next article, where we’re looking more closely into different implementations of signals (lazy, eager, hybrid), scheduled updates, interacting with the DOM, and debugging your own code!\u003c/p\u003e\u003cp\u003eMeanwhile, you can find me in the comments section below, on \u003ca href=\"https://atila.io/x\"\u003e𝕏 (Twitter)\u003c/a\u003e, \u003ca href=\"https://atila.io/linkedin\"\u003eLinkedIn\u003c/a\u003e, \u003ca href=\"https://atila.io/bsky\"\u003eBlueSky\u003c/a\u003e, or even \u003ca href=\"https://atila.io/youtube\"\u003eyoutube\u003c/a\u003e. I’m always happy to chat, and if you tell me what you want to know, I’ll make sure to include it in the next article! See ya!\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2024-11-27T10:00:00Z",
  "modifiedTime": "2024-11-27T10:00:00Z"
}
