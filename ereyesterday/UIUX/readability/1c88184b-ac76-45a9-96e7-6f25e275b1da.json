{
  "id": "1c88184b-ac76-45a9-96e7-6f25e275b1da",
  "title": "An Introduction To CSS Scroll-Driven Animations: Scroll And View Progress Timelines",
  "link": "https://smashingmagazine.com/2024/12/introduction-css-scroll-driven-animations/",
  "description": "10 years after scroll-driven animations were first proposed, they’re finally here — no JavaScript, no dependencies, no libraries, just pure CSS.",
  "author": "Mariana Beldi",
  "published": "Wed, 11 Dec 2024 15:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 27318,
  "excerpt": "10 years after scroll-driven animations were first proposed, they’re finally here — no JavaScript, no dependencies, no libraries, just pure CSS.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "20 min readCSS, Animation, DesignIt’s been 10 years since scroll-driven animations were introduced in a spec proposal, and after five years in development, we’re finally beginning to see pop up in websites. There are scrolly-telling and maze games as well as cover flow animations and 3D rotation with scroll… but what exactly is new here? It’s not like we haven’t seen scroll animations before, but what we have now requires no JavaScript, no dependencies, no libraries — just pure CSS. And if that’s not exciting enough, these animations run off the main thread, delivering smooth, high-performance, GPU-accelerated experiences.You can safely use scroll-driven animations in Chrome as of December 2024. Firefox supports them, too, though you’ll need to enable a flag. Safari? Not yet, but don’t worry — you can still offer a seamless experience across all browsers with a polyfill. Just keep in mind that adding a polyfill involves a JavaScript library, so you won’t get the same performance boost.There are plenty of valuable resources to dive into scroll-driven animations, which I’ll be linking throughout the article. My starting point was Bramus’ video tutorial, which pairs nicely with Geoff’s in-depth notes Graham that build on the tutorial.In this article, we’ll walk through the latest published version by the W3C and explore the two types of scroll-driven timelines — scroll progress timelines and view progress timelines. By the end, I hope that you are familiar with both timelines, not only being able to tell them apart but also feeling confident enough to use them in your work.Note: All demos in this article only work in Chrome 116 or later at the time of writing.The scroll progress timeline links an animation’s timeline to the scroll position of a scroll container along a specific axis. So, the animation is tied directly to scrolling. As you scroll forward, so does the animation. You’ll see me refer to them as scroll-timeline animations in addition to calling them scroll progress timelines.Just as we have two types of scroll-driven animations, we have two types of scroll-timeline animations: anonymous timelines and named timelines.Anonymous scroll-timelineLet’s start with a classic example: creating a scroll progress bar at the top of a blog post to track your reading progress.See the Pen [Scroll Progress Timeline example - before animation-timeline scroll() [forked]](https://codepen.io/smashingmag/pen/RNbRqoj) by Mariana Beldi.See the Pen Scroll Progress Timeline example - before animation-timeline scroll() [forked] by Mariana Beldi.In this example, there’s a \u003cdiv\u003e with the ID “progress.” At the end of the CSS file, you’ll see it has a background color, a defined width and height, and it’s fixed at the top of the page. There’s also an animation that scales it from 0 to 1 along the x-axis — pretty standard if you’re familiar with CSS animations!Here’s the relevant part of the styles:#progress { /* ... */ animation: progressBar 1s linear; } @keyframes progressBar { from { transform: scaleX(0); } } The progressBar animation runs once and lasts one second with a linear timing function. Linking this animation scrolling is just a single line in CSS:animation-timeline: scroll(); No need to specify seconds for the duration — the scrolling behavior itself will dictate the timing. And that’s it! You’ve just created your first scroll-driven animation! Notice how the animation’s direction is directly tied to the scrolling direction — scroll down, and the progress indicator grows wider; scroll up, and it becomes narrower.See the Pen [Scroll Progress Timeline example - animation-timeline scroll() [forked]](https://codepen.io/smashingmag/pen/ByBzGpO) by Mariana Beldi.See the Pen Scroll Progress Timeline example - animation-timeline scroll() [forked] by Mariana Beldi.scroll-timeline Property ParametersIn a scroll-timeline animation, the scroll() function is used inside the animation-timeline property. It only takes two parameters: \u003cscroller\u003e and \u003caxis\u003e.\u003cscroller\u003e refers to the scroll container, which can be set as nearest (the default), root, or self.\u003caxis\u003e refers to the scroll axis, which can be block (the default), inline, x, or y.In the reading progress example above, we didn’t declare any of these because we used the defaults. But we could achieve the same result with:animation-timeline: scroll(nearest block); Here, the nearest scroll container is the root scroll of the HTML element. So, we could also write it this way instead:animation-timeline: scroll(root block); The block axis confirms that the scroll moves top to bottom in a left-to-right writing mode. If the page has a wide horizontal scroll, and we want to animate along that axis, we could use the inline or x values (depending on whether we want the scrolling direction to always be left-to-right or adapt based on the writing mode).We’ll dive into self and inline in more examples later, but the best way to learn is to play around with all the combinations, and this tool by Bramus lets you do exactly that. Spend a few minutes before we jump into the next property associated with scroll timelines.The animation-range PropertyThe animation-range for scroll-timeline defines which part of the scrollable content controls the start and end of an animation’s progress based on the scroll position. It allows you to decide when the animation starts or ends while scrolling through the container.By default, the animation-range is set to normal, which is shorthand for the following:animation-range-start: normal; animation-range-end: normal; This translates to 0% (start) and 100% (end) in a scroll-timeline animation:animation-range: normal normal; …which is the same as:animation-range: 0% 100%; You can declare any CSS length units or even calculations. For example, let’s say I have a footer that’s 500px tall. It’s filled with banners, ads, and related posts. I don’t want the scroll progress bar to include any of that as part of the reading progress. What I want is for the animation to start at the top and end 500px before the bottom. Here we go:animation-range: 0% calc(100% - 500px); See the Pen [Scroll Progress Timeline example - animation-timeline, animation-range [forked]](https://codepen.io/smashingmag/pen/azoZQym) by Mariana Beldi.See the Pen Scroll Progress Timeline example - animation-timeline, animation-range [forked] by Mariana Beldi.Just like that, we’ve covered the key properties of scroll-timeline animations. Ready to take it a step further?Named scroll-timelineLet’s say I want to use the scroll position of a different scroll container for the same animation. The scroll-timeline-name property allows you to specify which scroll container the scroll animation should be linked to. You give it a name (a dashed-ident, e.g., --my-scroll-timeline) that maps to the scroll container you want to use. This container will then control the animation’s progress as the user scrolls through it.Next, we need to define the scroll axis for this new container by using the scroll-timeline-axis, which tells the animation which axis will trigger the motion. Here’s how it looks in the code:.my-class { /* This is my new scroll-container */ scroll-timeline-name: --my-custom-name; scroll-timeline-axis: inline; } If you omit the axis, then the default block value will be used. However, you can also use the shorthand scroll-timeline property to combine both the name and axis in a single declaration:.my-class { /* Shorthand for scroll-container with axis */ scroll-timeline: --my-custom-name inline; } I think it’s easier to understand all this with a practical example. Here’s the same progress indicator we’ve been working with, but with inline scrolling (i.e., along the x-axis):See the Pen [Named Scroll Progress Timeline [forked]](https://codepen.io/smashingmag/pen/pvzbQrM) by Mariana Beldi.See the Pen Named Scroll Progress Timeline [forked] by Mariana Beldi.We have two animations running:A progress bar grows wider when scrolling in an inline direction.The container’s background color changes the further you scroll.The HTML structure looks like the following:\u003cdiv class=\"gallery\"\u003e \u003cdiv class=\"gallery-scroll-container\"\u003e \u003cdiv class=\"gallery-progress\" role=\"progressbar\" aria-label=\"progress\"\u003e\u003c/div\u003e \u003cimg src=\"image1.svg\" alt=\"Alt text\" draggable=\"false\" width=\"500\"\u003e \u003cimg src=\"image2.svg\" alt=\"Alt text\" draggable=\"false\" width=\"500\"\u003e \u003cimg src=\"image3.svg\" alt=\"Alt text\" draggable=\"false\" width=\"500\"\u003e \u003c/div\u003e \u003c/div\u003e In this case, the gallery-scroll-container has horizontal scrolling and changes its background color as you scroll. Normally, we could just use animation-timeline: scroll(self inline) to achieve this. However, we also want the gallery-progress element to use the same scroll for its animation.The gallery-progress element is the first inside gallery-scroll-container, and we will lose it when scrolling unless it’s absolutely positioned. But when we do this, the element no longer occupies space in the normal document flow, and that affects how the element behaves with its parent and siblings. We need to specify which scroll container we want it to listen to.That’s where naming the scroll container comes in handy. By giving gallery-scroll-container a scroll-timeline-name and scroll-timeline-axis, we can ensure both animations sync to the same scroll:.gallery-scroll-container { /* ... */ animation: bg steps(1); scroll-timeline: --scroller inline; } And is using that scrolling to define its own animation-timeline:.gallery-scroll-container { /* ... */ animation: bg steps(1); scroll-timeline: --scroller inline; animation-timeline: --scroller; } Now we can scale this name to the progress bar that is using a different animation but listening to the same scroll:.gallery-progress { /* ... */ animation: progressBar linear; animation-timeline: --scroller; } This allows both animations (the growing progress bar and changing background color) to follow the same scroll behavior, even though they are separate elements and animations.The timeline-scope PropertyWhat happens if we want to animate something based on the scroll position of a sibling or even a higher ancestor? This is where the timeline-scope property comes into play. It allows us to extend the scope of a scroll-timeline beyond the current element’s subtree. The value of timeline-scope must be a custom identifier, which again is a dashed-ident.Let’s illustrate this with a new example. This time, scrolling in one container runs an animation inside another container:See the Pen [Scroll Driven Animations - timeline-scope [forked]](https://codepen.io/smashingmag/pen/jENrQGo) by Mariana Beldi.See the Pen Scroll Driven Animations - timeline-scope [forked] by Mariana Beldi.We can play the animation on the image when scrolling the text container because they are siblings in the HTML structure:\u003cdiv class=\"main-container\"\u003e \u003cdiv class=\"sardinas-container\"\u003e \u003cimg ...\u003e \u003c/div\u003e \u003cdiv class=\"scroll-container\"\u003e \u003cp\u003eLong text...\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e Here, only the .scroll-container has scrollable content, so let’s start by naming this:.scroll-container { /* ... */ overflow-y: scroll; scroll-timeline: --containerText; } Notice that I haven’t specified the scroll axis, as it defaults to block (vertical scrolling), and that’s the value I want.Let’s move on to the image inside the sardinas-container. We want this image to animate as we scroll through the scroll-container. I’ve added a scroll-timeline-name to its animation-timeline property:.sardinas-container img { /* ... */ animation: moveUp steps(6) both; animation-timeline: --containerText; } At this point, however, the animation still won’t work because the scroll-container is not directly related to the images. To make this work, we need to extend the scroll-timeline-name so it becomes reachable. This is done by adding the timeline-scope to the parent element (or a higher ancestor) shared by both elements:.main-container { /* ... */ timeline-scope: --containerText; } With this setup, the scroll of the scroll-container will now control the animation of the image inside the sardinas-container!Now that we’ve covered how to use timeline-scope, we’re ready to move on to the next type of scroll-driven animations, where the same properties will apply but with slight differences in how they behave.View Progress TimelinesWe just looked at scroll progress animations. That’s the first type of scroll-driven animation of the two. Next, we’re turning our attention to view progress animations. There’s a lot of similarities between the two! But they’re different enough to warrant their own section for us to explore how they work. You’ll see me refer to these as view-timeline animations in addition to calling them view progress animations, as they revolve around a view() function.The view progress timeline is the second type of type of scroll-driven animation that we’re looking at. It tracks an element as it enters or exits the scrollport (the visible area of the scrollable content). This behavior is quite similar to how an IntersectionObserver works in JavaScript but can be done entirely in CSS.We have anonymous and named view progress timelines, just as we have anonymous and named scroll progress animations. Let’s unpack those.Anonymous View TimelineHere’s a simple example to help us see the basic idea of anonymous view timelines. Notice how the image fades into view when you scroll down to a certain point on the page:See the Pen [View Timeline Animation - view() [forked]](https://codepen.io/smashingmag/pen/KwPMrQO) by Mariana Beldi.See the Pen View Timeline Animation - view() [forked] by Mariana Beldi.Let’s say we want to animate an image that fades in as it appears in the scrollport. The image’s opacity will go from 0 to 1. This is how you might write that same animation in classic CSS using @keyframes:img { /* ... */ animation: fadeIn 1s; } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } That’s great, but we want the image to fadeIn when it’s in view. Otherwise, the animation is sort of like a tree that falls in a forest with no one there to witness it… did the animation ever happen? We’ll never know!We have a view() function that makes this a view progress animation with a single line of CSS:img { /* ... */ animation: fadeIn; animation-timeline: view(); } And notice how we no longer need to declare an animation-duration like we did in classic CSS. The animation is no longer tied by time but by space. The animation is triggered as the image becomes visible in the scrollport.View Timeline ParametersJust like the scroll-timeline property, the view-timeline property accepts parameters that allow for more customization:animation-timeline: view( ); \u003cinset\u003eControls when the animation starts and ends relative to the element’s visibility within the scrollport. It defines the margin between the edges of the scrollport and the element being tracked. The default value is auto, but it can also take length percentages as well as start and end values.\u003caxis\u003eThis is similar to the scroll-timeline’s axis parameter. It defines which axis (horizontal or vertical) the animation is tied to. The default is block, which means it tracks the vertical movement. You can also use inline to track horizontal movement or simple x or y.Here’s an example that uses both inset and axis to customize when and how the animation starts:img { animation-timeline: view(20% block); } In this case:The animation starts when the image is 20% visible in the scrollport.The animation is triggered by vertical scrolling (block axis).Parallax EffectWith the view() function, it’s also easy to create parallax effects by simply adjusting the animation properties. For example, you can have an element move or scale as it enters the scrollport without any JavaScript:img { animation: parallaxMove 1s; animation-timeline: view(); } @keyframes parallaxMove { to { transform: translateY(-50px); } } This makes it incredibly simple to create dynamic and engaging scroll animations with just a few lines of CSS.See the Pen [Parallax effect with CSS Scroll driven animations - view() [forked]](https://codepen.io/smashingmag/pen/mybEQLK) by Mariana Beldi.See the Pen Parallax effect with CSS Scroll driven animations - view() [forked] by Mariana Beldi.The animation-range PropertyUsing the CSS animation-range property with view timelines defines how much of an element’s visibility within the scrollport controls the start and end points of the animation’s progress. This can be used to fine-tune when the animation begins and ends based on the element’s visibility in the viewport.While the default value is normal, in view timelines, it translates to tracking the full visibility of the element from the moment it starts entering the scrollport until it fully leaves. This is represented by the following:animation-range: normal normal; /* Equivalent to */ animation-range: cover 0% cover 100%; Or, more simply:animation-range: cover; There are six possible values or timeline-range-names:coverTracks the full visibility of the element, from when it starts entering the scrollport to when it completely leaves it.containTracks when the element is fully visible inside the scrollport, from the moment it’s fully contained until it no longer is.entryTracks the element from the point it starts entering the scrollport until it’s fully inside.exitTracks the element from the point it starts, leaving the scrollport until it’s fully outside.entry-crossingTracks the element as it crosses the starting edge of the scrollport, from start to full crossing.exit-crossingTracks the element as it crosses the end edge of the scrollport, from start to full crossing.You can mix different timeline-range-names to control the start and end points of the animation range. For example, you could make the animation start when the element enters the scrollport and end when it exits:animation-range: entry exit; You can also combine these values with percentages to define more custom behavior, such as starting the animation halfway through the element’s entry and ending it halfway through its exit:animation-range: entry 50% exit 50%; Exploring all these values and combinations is best done interactively. Tools like Bramus’ view-timeline range visualizer make it easier to understand.Target Range Inside @keyframesOne of the powerful features of timeline-range-names is their ability to be used inside @keyframes:See the Pen [target range inside @keyframes - view-timeline, timeline-range-name [forked]](https://codepen.io/smashingmag/pen/zxOBMaK) by Mariana Beldi.See the Pen target range inside @keyframes - view-timeline, timeline-range-name [forked] by Mariana Beldi.Two different animations are happening in that demo:slideInWhen the element enters the scrollport, it scales up and becomes visible.slideOutWhen the element leaves, it scales down and fades out.@keyframes slideIn { from { transform: scale(.8) translateY(100px); opacity: 0; } to { transform: scale(1) translateY(0); opacity: 1; } } @keyframes slideOut { from { transform: scale(1) translateY(0); opacity: 1; } to { transform: scale(.8) translateY(-100px); opacity: 0 } } The new thing is that now we can merge these two animations using the entry and exit timeline-range-names, simplifying it into one animation that handles both cases:@keyframes slideInOut { /* Animation for when the element enters the scrollport */ entry 0% { transform: scale(.8) translateY(100px); opacity: 0; } entry 100% { transform: scale(1) translateY(0); opacity: 1; } /* Animation for when the element exits the scrollport */ exit 0% { transform: scale(1) translateY(0); opacity: 1; } exit 100% { transform: scale(.8) translateY(-100px); opacity: 0; } } entry 0%Defines the state of the element at the beginning of its entry into the scrollport (scaled down and transparent).entry 100%Defines the state when the element has fully entered the scrollport (fully visible and scaled up).exit 0%Starts tracking the element as it begins to leave the scrollport (visible and scaled up).exit 100%Defines the state when the element has fully left the scrollport (scaled down and transparent).This approach allows us to animate the element’s behavior smoothly as it both enters and leaves the scrollport, all within a single @keyframes block.Named view-timeline And timeline-scopeThe concept of using view-timeline with named timelines and linking them across different elements can truly expand the possibilities for scroll-driven animations. In this case, we are linking the scroll-driven animation of images with the animations of unrelated paragraphs in the DOM structure by using a named view-timeline and timeline-scope.The view-timeline property works similarly to the scroll-timeline property. It’s the shorthand for declaring the view-timeline-name and view-timeline-axis properties in one line. However, the difference from scroll-timeline is that we can link the animation of an element when the linked elements enter the scrollport. I took the previous demo and added an animation to the paragraphs so you can see how the opacity of the text is animated when scrolling the images on the left:See the Pen [View-timeline, timeline-scope [forked]](https://codepen.io/smashingmag/pen/KwPMrBP) by Mariana Beldi.See the Pen View-timeline, timeline-scope [forked] by Mariana Beldi.This one looks a bit verbose, but I found it hard to come up with a better example to show the power of it. Each image in the vertical scroll container is assigned a named view-timeline with a unique identifier:.vertical-scroll-container img:nth-of-type(1) { view-timeline: --one; } .vertical-scroll-container img:nth-of-type(2) { view-timeline: --two; } .vertical-scroll-container img:nth-of-type(3) { view-timeline: --three; } .vertical-scroll-container img:nth-of-type(4) { view-timeline: --four; } This makes the scroll timeline of each image have its own custom name, such as --one for the first image, --two for the second, and so on.Next, we connect the animations of the paragraphs to the named timelines of the images. The corresponding paragraph should animate when the images enter the scrollport:.vertical-text p:nth-of-type(1) { animation-timeline: --one; } .vertical-text p:nth-of-type(2) { animation-timeline: --two; } .vertical-text p:nth-of-type(3) { animation-timeline: --three; } .vertical-text p:nth-of-type(4) { animation-timeline: --four; } However, since the images and paragraphs are not directly related in the DOM, we need to declare a timeline-scope on their common ancestor. This ensures that the named timelines (--one, --two, and so on) can be referenced and shared between the elements:.porto { /* ... */ timeline-scope: --one, --two, --three, --four; } By declaring the timeline-scope with all the named timelines (--one, —two, --three, --four), both the images and the paragraphs can participate in the same scroll-timeline logic, despite being in separate parts of the DOM tree.Final NotesWe’ve covered the vast majority of what’s currently defined in the CSS Scroll-Driven Animations Module Leve 1 specification today in December 2024. But I want to highlight a few key takeaways that helped me better understand these new rules that you may not get directly from the spec:Scroll container essentialsIt may seem obvious, but a scroll container is necessary for scroll-driven animations to work. Issues often arise when elements like text or containers are resized or when animations are tested on larger screens, causing the scrollable area to disappear.Impact of position: absoluteUsing absolute positioning can sometimes interfere with the intended behavior of scroll-driven animations. The relationship between elements and their parent elements gets tricky when position: absolute is applied.Tracking an element’s initial stateThe browser evaluates the element’s state before any transformations (like translate) are applied. This affects when animations, particularly view timelines, begin. Your animation might trigger earlier or later than expected due to the initial state.Avoid hiding overflowUsing overflow: hidden can disrupt the scroll-seeking mechanism in scroll-driven animations. The recommended solution is to switch to overflow: clip. Bramus has a great article about this and a video from Kevin Powell also suggests that we may no longer need overflow: hidden.PerformanceFor the best results, stick to animating GPU-friendly properties like transforms, opacity, and some filters. These skip the heavy lifting of recalculating layout and repainting. On the other hand, animating things like width, height, or box-shadow can slow things down since they require re-rendering. Bramus mentioned that soon, more properties — like background-color, clip-path, width, and height — will be animatable on the compositor, making the performance even better.Use will-change wiselyLeverage this property to promote elements to the GPU, but use it sparingly. Overusing will-change can lead to excessive memory usage since the browser reserves resources even if the animations don’t frequently change.The order mattersIf you are using the animation shorthand, always place the animation-timeline after it.Progressive enhancement and accessibilityCombine media queries for reduced motion preferences with the @supports rule to ensure animations only apply when the user has no motion restrictions, and the browser supports them.For example:@media screen and (prefers-reduce-motion: no-preference) { @supports ((animation-timeline: scroll()) and (animation-range: 0% 100%)) { .my-class { animation: moveCard linear both; animation-timeline: view(); } } } My main struggle while trying to build the demos was more about CSS itself than the scroll animations. Sometimes, building the layout and generating the scroll was more difficult than applying the scroll animation. Also, some things that confused me at the beginning as the spec keeps evolving, and some of these are not there anymore (remember, it has been under development for more than five years now!):x and y axesThese used to be called the “horizontal” and “vertical” axes, and while Firefox may still support the old terminology, it has been updated.Old @scroll-timeline syntaxIn the past, @scroll-timeline was used to declare scroll timelines, but this has changed in the most recent version of the spec.Scroll-driven vs. scroll-linked animationsScroll-driven animations were originally called scroll-linked animations. If you come across this older term in articles, double-check whether the content has been updated to reflect the latest spec, particularly with features like timeline-scope.ResourcesAll demos from this article can be found in this collection, and I might include more as I experiment further.A collection of demos from CodePen that I find interesting (send me yours, and I’ll include it!)This GitHub repo is where you can report issues or join discussions about scroll-driven animations.Demos, tools, videos, and (even) more information from BramusGoogle Chrome video tutorial (gg, yk)",
  "image": "https://files.smashing.media/articles/introduction-css-scroll-driven-animations/introduction-css-scroll-driven-animations.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e20 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/css\"\u003eCSS\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/animation\"\u003eAnimation\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/design\"\u003eDesign\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eIt’s been 10 years since scroll-driven animations were introduced in a spec proposal, and after five years in development, we’re finally beginning to see pop up in websites. There are \u003ca href=\"https://codepen.io/andrewrock/pen/NWoRavN\"\u003escrolly-telling\u003c/a\u003e and \u003ca href=\"https://codepen.io/amit_sheen/pen/ZENNgMw\"\u003emaze games\u003c/a\u003e as well as \u003ca href=\"https://codepen.io/bramus/pen/GRdGoKy\"\u003ecover flow animations\u003c/a\u003e and \u003ca href=\"https://codepen.io/leemeyer/pen/XWvrMBr\"\u003e3D rotation with scroll\u003c/a\u003e… but what exactly is new here? It’s not like we haven’t seen scroll animations before, \u003cstrong\u003ebut what we have now requires no JavaScript, no dependencies, no libraries — just pure CSS\u003c/strong\u003e. And if that’s not exciting enough, these animations run off the \u003ca href=\"https://www.smashingmagazine.com/2023/10/speedcurve-fight-main-thread/\"\u003emain thread\u003c/a\u003e, delivering smooth, high-performance, GPU-accelerated experiences.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eYou can safely use scroll-driven animations in Chrome as of December 2024. Firefox supports them, too, though you’ll need to enable a flag. Safari? Not yet, but don’t worry — you can still offer a seamless experience across all browsers with a \u003ca href=\"https://github.com/flackr/scroll-timeline\"\u003epolyfill\u003c/a\u003e. Just keep in mind that adding a polyfill involves a JavaScript library, so you won’t get the same performance boost.\u003c/p\u003e\u003cp\u003eThere are plenty of valuable resources to dive into scroll-driven animations, which I’ll be linking throughout the article. My starting point was \u003ca href=\"https://www.youtube.com/playlist?list=PLNYkxOF6rcICM3ttukz9x5LCNOHfWBVnn\"\u003eBramus’ video tutorial\u003c/a\u003e, which pairs nicely with \u003ca href=\"https://css-tricks.com/unleash-the-power-of-scroll-driven-animations/\"\u003eGeoff’s in-depth notes\u003c/a\u003e \u003ca href=\"https://css-tricks.com/unleash-the-power-of-scroll-driven-animations/\"\u003eGraham\u003c/a\u003e that build on the tutorial.\u003c/p\u003e\u003cp\u003eIn this article, we’ll walk through the \u003ca href=\"https://www.w3.org/TR/scroll-animations-1/\"\u003elatest published version by the W3C\u003c/a\u003e and explore the two types of scroll-driven timelines — \u003cstrong\u003escroll progress timelines\u003c/strong\u003e and \u003cstrong\u003eview progress timelines\u003c/strong\u003e. By the end, I hope that you are familiar with both timelines, not only being able to tell them apart but also feeling confident enough to use them in your work.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: \u003cem\u003eAll demos in this article only work in Chrome 116 or later at the time of writing.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eThe scroll progress timeline links an animation’s timeline to the scroll position of a scroll container along a specific axis. So, the animation is tied directly to scrolling. As you scroll forward, so does the animation. You’ll see me refer to them as \u003ccode\u003escroll-timeline\u003c/code\u003e animations in addition to calling them scroll progress timelines.\u003c/p\u003e\u003cp\u003eJust as we have two types of scroll-driven animations, we have two types of \u003ccode\u003escroll-timeline\u003c/code\u003e animations: \u003cstrong\u003eanonymous timelines\u003c/strong\u003e and \u003cstrong\u003enamed timelines\u003c/strong\u003e.\u003c/p\u003e\u003ch3 id=\"anonymous-scroll-timeline\"\u003eAnonymous \u003ccode\u003escroll-timeline\u003c/code\u003e\u003c/h3\u003e\u003cp\u003eLet’s start with a classic example: creating a scroll progress bar at the top of a blog post to track your reading progress.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"RNbRqoj\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Scroll Progress Timeline example - before animation-timeline scroll() [forked]](https://codepen.io/smashingmag/pen/RNbRqoj) by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/RNbRqoj\"\u003eScroll Progress Timeline example - before animation-timeline scroll() [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eIn this example, there’s a \u003ccode\u003e\u0026lt;div\u0026gt;\u003c/code\u003e with the ID “progress.” At the end of the CSS file, you’ll see it has a background color, a defined width and height, and it’s fixed at the top of the page. There’s also an animation that scales it from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e1\u003c/code\u003e along the x-axis — pretty standard if you’re familiar with CSS animations!\u003c/p\u003e\u003cp\u003eHere’s the relevant part of the styles:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e#progress {\n  /* ... */\n  animation: progressBar 1s linear;\n}\n\n\n@keyframes progressBar {\n  from { transform: scaleX(0); }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003eprogressBar\u003c/code\u003e animation runs once and lasts one second with a linear timing function. Linking this animation scrolling is just a single line in CSS:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-timeline: scroll();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNo need to specify seconds for the duration — the scrolling behavior itself will dictate the timing. And that’s it! You’ve just created your first scroll-driven animation! Notice how the animation’s direction is directly tied to the scrolling direction — scroll down, and the progress indicator grows wider; scroll up, and it becomes narrower.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"ByBzGpO\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Scroll Progress Timeline example - animation-timeline scroll() [forked]](https://codepen.io/smashingmag/pen/ByBzGpO) by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/ByBzGpO\"\u003eScroll Progress Timeline example - animation-timeline scroll() [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch3 id=\"scroll-timeline-property-parameters\"\u003e\u003ccode\u003escroll-timeline\u003c/code\u003e Property Parameters\u003c/h3\u003e\u003cp\u003eIn a \u003ccode\u003escroll-timeline\u003c/code\u003e animation, the \u003ccode\u003escroll()\u003c/code\u003e function is used inside the \u003ccode\u003eanimation-timeline\u003c/code\u003e property. It only takes two parameters: \u003ccode\u003e\u0026lt;scroller\u0026gt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;axis\u0026gt;\u003c/code\u003e.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e\u0026lt;scroller\u0026gt;\u003c/code\u003e\u003c/strong\u003e refers to the scroll container, which can be set as \u003ccode\u003enearest\u003c/code\u003e (the default), \u003ccode\u003eroot\u003c/code\u003e, or \u003ccode\u003eself\u003c/code\u003e.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e\u0026lt;axis\u0026gt;\u003c/code\u003e\u003c/strong\u003e refers to the scroll axis, which can be \u003ccode\u003eblock\u003c/code\u003e (the default), \u003ccode\u003einline\u003c/code\u003e, \u003ccode\u003ex\u003c/code\u003e, or \u003ccode\u003ey\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIn the reading progress example above, we didn’t declare any of these because we used the defaults. But we could achieve the same result with:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-timeline: scroll(nearest block);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere, the \u003ccode\u003enearest\u003c/code\u003e scroll container is the root scroll of the HTML element. So, we could also write it this way instead:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-timeline: scroll(root block);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003eblock\u003c/code\u003e axis confirms that the scroll moves top to bottom in a left-to-right writing mode. If the page has a wide horizontal scroll, and we want to animate along that axis, we could use the \u003ccode\u003einline\u003c/code\u003e or \u003ccode\u003ex\u003c/code\u003e values (depending on whether we want the scrolling direction to always be left-to-right or adapt based on the writing mode).\u003c/p\u003e\u003cp\u003eWe’ll dive into \u003ccode\u003eself\u003c/code\u003e and \u003ccode\u003einline\u003c/code\u003e in more examples later, but the best way to learn is to play around with all the combinations, and \u003ca href=\"https://scroll-driven-animations.style/tools/scroll-timeline/params/\"\u003ethis tool by Bramus\u003c/a\u003e lets you do exactly that. Spend a few minutes before we jump into the next property associated with scroll timelines.\u003c/p\u003e\u003ch3 id=\"the-animation-range-property\"\u003eThe \u003ccode\u003eanimation-range\u003c/code\u003e Property\u003c/h3\u003e\u003cp\u003eThe \u003ccode\u003eanimation-range\u003c/code\u003e for \u003ccode\u003escroll-timeline\u003c/code\u003e defines which part of the scrollable content controls the start and end of an animation’s progress based on the scroll position. It allows you to decide when the animation starts or ends while scrolling through the container.\u003c/p\u003e\u003cp\u003eBy default, the \u003ccode\u003eanimation-range\u003c/code\u003e is set to \u003ccode\u003enormal\u003c/code\u003e, which is shorthand for the following:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-range-start: normal;\nanimation-range-end: normal;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis translates to \u003ccode\u003e0%\u003c/code\u003e (\u003ccode\u003estart\u003c/code\u003e) and \u003ccode\u003e100%\u003c/code\u003e (\u003ccode\u003eend\u003c/code\u003e) in a \u003ccode\u003escroll-timeline\u003c/code\u003e animation:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-range: normal normal;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e…which is the same as:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-range: 0% 100%;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can declare any \u003ca href=\"https://css-tricks.com/css-length-units/\"\u003eCSS length units\u003c/a\u003e or even \u003ca href=\"https://www.smashingmagazine.com/2015/12/getting-started-css-calc-techniques/\"\u003ecalculations\u003c/a\u003e. For example, let’s say I have a footer that’s \u003ccode\u003e500px\u003c/code\u003e tall. It’s filled with banners, ads, and related posts. I don’t want the scroll progress bar to include any of that as part of the reading progress. What I want is for the animation to start at the top and end \u003ccode\u003e500px\u003c/code\u003e before the bottom. Here we go:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-range: 0% calc(100% - 500px);\n\u003c/code\u003e\u003c/pre\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"azoZQym\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Scroll Progress Timeline example - animation-timeline, animation-range [forked]](https://codepen.io/smashingmag/pen/azoZQym) by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/azoZQym\"\u003eScroll Progress Timeline example - animation-timeline, animation-range [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eJust like that, we’ve covered the key properties of \u003ccode\u003escroll-timeline\u003c/code\u003e animations. Ready to take it a step further?\u003c/p\u003e\u003ch3 id=\"named-scroll-timeline\"\u003eNamed \u003ccode\u003escroll-timeline\u003c/code\u003e\u003c/h3\u003e\u003cp\u003eLet’s say I want to use the scroll position of a different scroll container for the same animation. The \u003ccode\u003escroll-timeline-name\u003c/code\u003e property allows you to specify which scroll container the scroll animation should be linked to. You give it a name (a dashed-ident, e.g., \u003ccode\u003e--my-scroll-timeline\u003c/code\u003e) that maps to the scroll container you want to use. This container will then control the animation’s progress as the user scrolls through it.\u003c/p\u003e\u003cp\u003eNext, we need to define the scroll axis for this new container by using the \u003ccode\u003escroll-timeline-axis\u003c/code\u003e, which tells the animation which axis will trigger the motion. Here’s how it looks in the code:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.my-class { \n  /* This is my new scroll-container */\n  scroll-timeline-name: --my-custom-name;\n  scroll-timeline-axis: inline;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you omit the axis, then the default \u003ccode\u003eblock\u003c/code\u003e value will be used. However, you can also use the shorthand \u003ccode\u003escroll-timeline\u003c/code\u003e property to combine both the name and axis in a single declaration:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.my-class { \n  /* Shorthand for scroll-container with axis */\n  scroll-timeline: --my-custom-name inline;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI think it’s easier to understand all this with a practical example. Here’s the same progress indicator we’ve been working with, but with inline scrolling (i.e., along the x-axis):\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"pvzbQrM\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Named Scroll Progress Timeline [forked]](https://codepen.io/smashingmag/pen/pvzbQrM) by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/pvzbQrM\"\u003eNamed Scroll Progress Timeline [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eWe have two animations running:\u003c/p\u003e\u003col\u003e\u003cli\u003eA progress bar grows wider when scrolling in an inline direction.\u003c/li\u003e\u003cli\u003eThe container’s background color changes the further you scroll.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eThe HTML structure looks like the following:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;div class=\u0026#34;gallery\u0026#34;\u0026gt;\n  \u0026lt;div class=\u0026#34;gallery-scroll-container\u0026#34;\u0026gt;\n    \u0026lt;div class=\u0026#34;gallery-progress\u0026#34; role=\u0026#34;progressbar\u0026#34; aria-label=\u0026#34;progress\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n    \u0026lt;img src=\u0026#34;image1.svg\u0026#34; alt=\u0026#34;Alt text\u0026#34; draggable=\u0026#34;false\u0026#34; width=\u0026#34;500\u0026#34;\u0026gt;\n    \u0026lt;img src=\u0026#34;image2.svg\u0026#34; alt=\u0026#34;Alt text\u0026#34; draggable=\u0026#34;false\u0026#34; width=\u0026#34;500\u0026#34;\u0026gt;\n    \u0026lt;img src=\u0026#34;image3.svg\u0026#34; alt=\u0026#34;Alt text\u0026#34; draggable=\u0026#34;false\u0026#34; width=\u0026#34;500\u0026#34;\u0026gt;\n  \u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIn this case, the \u003ccode\u003egallery-scroll-container\u003c/code\u003e has horizontal scrolling and changes its background color as you scroll. Normally, we could just use \u003ccode\u003eanimation-timeline: scroll(self inline)\u003c/code\u003e to achieve this. However, we also want the \u003ccode\u003egallery-progress\u003c/code\u003e element to use the same scroll for its animation.\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003egallery-progress\u003c/code\u003e element is the first inside \u003ccode\u003egallery-scroll-container\u003c/code\u003e, and we will lose it when scrolling unless it’s absolutely positioned. But when we do this, the element no longer occupies space in the normal document flow, and that affects how the element behaves with its parent and siblings. We need to specify which scroll container we want it to listen to.\u003c/p\u003e\u003cp\u003eThat’s where naming the scroll container comes in handy. By giving \u003ccode\u003egallery-scroll-container\u003c/code\u003e a \u003ccode\u003escroll-timeline-name\u003c/code\u003e and \u003ccode\u003escroll-timeline-axis\u003c/code\u003e, we can ensure both animations sync to the same scroll:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.gallery-scroll-container {\n  /* ... */\n  animation: bg steps(1);\n  scroll-timeline: --scroller inline;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd is using that scrolling to define its own \u003ccode\u003eanimation-timeline\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.gallery-scroll-container {\n  /* ... */\n  animation: bg steps(1);\n  scroll-timeline: --scroller inline;\n  animation-timeline: --scroller;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow we can scale this name to the progress bar that is using a different animation but listening to the same scroll:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.gallery-progress {\n  /* ... */\n  animation: progressBar linear;\n  animation-timeline: --scroller;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis allows both animations (the growing progress bar and changing background color) to follow the same scroll behavior, even though they are separate elements and animations.\u003c/p\u003e\u003ch3 id=\"the-timeline-scope-property\"\u003eThe \u003ccode\u003etimeline-scope\u003c/code\u003e Property\u003c/h3\u003e\u003cp\u003eWhat happens if we want to animate something based on the scroll position of a sibling or even a higher ancestor? This is where the \u003ccode\u003etimeline-scope\u003c/code\u003e property comes into play. It allows us to extend the scope of a \u003ccode\u003escroll-timeline\u003c/code\u003e beyond the current element’s subtree. The value of \u003ccode\u003etimeline-scope\u003c/code\u003e must be a custom identifier, which again is a dashed-ident.\u003c/p\u003e\u003cp\u003eLet’s illustrate this with a new example. This time, scrolling in one container runs an animation inside another container:\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"jENrQGo\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Scroll Driven Animations - timeline-scope [forked]](https://codepen.io/smashingmag/pen/jENrQGo) by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/jENrQGo\"\u003eScroll Driven Animations - timeline-scope [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eWe can play the animation on the image when scrolling the text container because they are siblings in the HTML structure:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;div class=\u0026#34;main-container\u0026#34;\u0026gt;\n  \u0026lt;div class=\u0026#34;sardinas-container\u0026#34;\u0026gt;\n    \u0026lt;img ...\u0026gt;\n  \u0026lt;/div\u0026gt;\n\n  \u0026lt;div class=\u0026#34;scroll-container\u0026#34;\u0026gt;\n    \u0026lt;p\u0026gt;Long text...\u0026lt;/p\u0026gt;\n  \u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere, only the \u003ccode\u003e.scroll-container\u003c/code\u003e has scrollable content, so let’s start by naming this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.scroll-container {\n  /* ... */\n  overflow-y: scroll;\n  scroll-timeline: --containerText;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNotice that I haven’t specified the scroll axis, as it defaults to \u003ccode\u003eblock\u003c/code\u003e (vertical scrolling), and that’s the value I want.\u003c/p\u003e\u003cp\u003eLet’s move on to the image inside the \u003ccode\u003esardinas-container\u003c/code\u003e. We want this image to animate as we scroll through the \u003ccode\u003escroll-container\u003c/code\u003e. I’ve added a \u003ccode\u003escroll-timeline-name\u003c/code\u003e to its \u003ccode\u003eanimation-timeline\u003c/code\u003e property:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.sardinas-container img {\n  /* ... */\n  animation: moveUp steps(6) both;\n  animation-timeline: --containerText;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAt this point, however, the animation still won’t work because the \u003ccode\u003escroll-container\u003c/code\u003e is not directly related to the images. To make this work, we need to extend the \u003ccode\u003escroll-timeline-name\u003c/code\u003e so it becomes reachable. This is done by adding the \u003ccode\u003etimeline-scope\u003c/code\u003e to the parent element (or a higher ancestor) shared by both elements:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.main-container {\n  /* ... */\n  timeline-scope: --containerText;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith this setup, the scroll of the \u003ccode\u003escroll-container\u003c/code\u003e will now control the animation of the image inside the \u003ccode\u003esardinas-container\u003c/code\u003e!\u003c/p\u003e\u003cp\u003eNow that we’ve covered how to use \u003ccode\u003etimeline-scope\u003c/code\u003e, we’re ready to move on to the next type of scroll-driven animations, where the same properties will apply but with slight differences in how they behave.\u003c/p\u003e\u003ch2 id=\"view-progress-timelines\"\u003eView Progress Timelines\u003c/h2\u003e\u003cp\u003eWe just looked at \u003cstrong\u003escroll progress animations\u003c/strong\u003e. That’s the first type of scroll-driven animation of the two. Next, we’re turning our attention to \u003cstrong\u003eview progress animations\u003c/strong\u003e. There’s a lot of similarities between the two! But they’re different enough to warrant their own section for us to explore how they work. You’ll see me refer to these as \u003ccode\u003eview-timeline\u003c/code\u003e animations in addition to calling them view progress animations, as they revolve around a \u003ccode\u003eview()\u003c/code\u003e function.\u003c/p\u003e\u003cp\u003eThe \u003cstrong\u003eview progress timeline\u003c/strong\u003e is the second type of type of scroll-driven animation that we’re looking at. It tracks an element as it enters or exits the scrollport (the visible area of the scrollable content). This behavior is quite similar to \u003ca href=\"https://css-tricks.com/an-explanation-of-how-the-intersection-observer-watches/?ref=csslayout.news\"\u003ehow an \u003ccode\u003eIntersectionObserver\u003c/code\u003e works in JavaScript\u003c/a\u003e but can be done entirely in CSS.\u003c/p\u003e\u003cp\u003eWe have anonymous and named view progress timelines, just as we have anonymous and named scroll progress animations. Let’s unpack those.\u003c/p\u003e\u003ch3 id=\"anonymous-view-timeline\"\u003eAnonymous View Timeline\u003c/h3\u003e\u003cp\u003eHere’s a simple example to help us see the basic idea of anonymous view timelines. Notice how the image fades into view when you scroll down to a certain point on the page:\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"KwPMrQO\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [View Timeline Animation - view() [forked]](https://codepen.io/smashingmag/pen/KwPMrQO) by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/KwPMrQO\"\u003eView Timeline Animation - view() [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eLet’s say we want to animate an image that fades in as it appears in the scrollport. The image’s opacity will go from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e1\u003c/code\u003e. This is how you might write that same animation in classic CSS using \u003ccode\u003e@keyframes\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimg {\n  /* ... */\n  animation: fadeIn 1s;\n}\n\n@keyframes fadeIn {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat’s great, but we want the image to \u003ccode\u003efadeIn\u003c/code\u003e when it’s in view. Otherwise, the animation is sort of like a tree that falls in a forest with no one there to witness it… did the animation ever happen? We’ll never know!\u003c/p\u003e\u003cp\u003eWe have a \u003ccode\u003eview()\u003c/code\u003e function that makes this a view progress animation with a single line of CSS:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimg {\n  /* ... */\n  animation: fadeIn;\n  animation-timeline: view();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd notice how we no longer need to declare an \u003ccode\u003eanimation-duration\u003c/code\u003e like we did in classic CSS. The animation is no longer tied by time but by space. The animation is triggered as the image becomes visible in the scrollport.\u003c/p\u003e\u003ch3 id=\"view-timeline-parameters\"\u003eView Timeline Parameters\u003c/h3\u003e\u003cp\u003eJust like the \u003ccode\u003escroll-timeline\u003c/code\u003e property, the \u003cstrong\u003e\u003ccode\u003eview-timeline\u003c/code\u003e\u003c/strong\u003e property accepts parameters that allow for more customization:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-timeline: view(\u003cinset\u003e \u003caxis\u003e);\n\u003c/axis\u003e\u003c/inset\u003e\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e\u0026lt;inset\u0026gt;\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eControls when the animation starts and ends relative to the element’s visibility within the scrollport. It defines the margin between the edges of the scrollport and the element being tracked. The default value is \u003ccode\u003eauto\u003c/code\u003e, but it can also take length percentages as well as start and end values.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e\u0026lt;axis\u0026gt;\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eThis is similar to the scroll-timeline’s axis parameter. It defines which axis (horizontal or vertical) the animation is tied to. The default is \u003ccode\u003eblock\u003c/code\u003e, which means it tracks the vertical movement. You can also use \u003ccode\u003einline\u003c/code\u003e to track horizontal movement or simple \u003ccode\u003ex\u003c/code\u003e or \u003ccode\u003ey\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eHere’s an example that uses both \u003ccode\u003einset\u003c/code\u003e and \u003ccode\u003eaxis\u003c/code\u003e to customize when and how the animation starts:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimg {\n  animation-timeline: view(20% block);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this case:\u003c/p\u003e\u003col\u003e\u003cli\u003eThe animation starts when the image is 20% visible in the scrollport.\u003c/li\u003e\u003cli\u003eThe animation is triggered by vertical scrolling (\u003ccode\u003eblock\u003c/code\u003e axis).\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"parallax-effect\"\u003eParallax Effect\u003c/h3\u003e\u003cp\u003eWith the \u003ccode\u003eview()\u003c/code\u003e function, it’s also easy to create parallax effects by simply adjusting the animation properties. For example, you can have an element move or scale as it enters the scrollport without any JavaScript:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimg {\n  animation: parallaxMove 1s;\n  animation-timeline: view();\n}\n\n@keyframes parallaxMove {\n  to { transform: translateY(-50px); }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis makes it incredibly simple to create dynamic and engaging scroll animations with just a few lines of CSS.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"mybEQLK\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Parallax effect with CSS Scroll driven animations - view() [forked]](https://codepen.io/smashingmag/pen/mybEQLK) by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/mybEQLK\"\u003eParallax effect with CSS Scroll driven animations - view() [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch3 id=\"the-animation-range-property-1\"\u003eThe \u003ccode\u003eanimation-range\u003c/code\u003e Property\u003c/h3\u003e\u003cp\u003eUsing the CSS \u003cstrong\u003e\u003ccode\u003eanimation-range\u003c/code\u003e\u003c/strong\u003e property with view timelines defines how much of an element’s visibility within the scrollport controls the start and end points of the animation’s progress. This can be used to fine-tune when the animation begins and ends based on the element’s visibility in the viewport.\u003c/p\u003e\u003cp\u003eWhile the default value is \u003ccode\u003enormal\u003c/code\u003e, in view timelines, it translates to tracking the full visibility of the element from the moment it starts entering the scrollport until it fully leaves. This is represented by the following:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-range: normal normal;\n/* Equivalent to */\nanimation-range: cover 0% cover 100%;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOr, more simply:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-range: cover;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere are six possible values or \u003ccode\u003etimeline-range-names\u003c/code\u003e:\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ecover\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eTracks the full visibility of the element, from when it starts entering the scrollport to when it completely leaves it.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003econtain\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eTracks when the element is fully visible inside the scrollport, from the moment it’s fully contained until it no longer is.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eentry\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eTracks the element from the point it starts entering the scrollport until it’s fully inside.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eexit\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eTracks the element from the point it starts, leaving the scrollport until it’s fully outside.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eentry-crossing\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eTracks the element as it crosses the starting edge of the scrollport, from start to full crossing.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eexit-crossing\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eTracks the element as it crosses the end edge of the scrollport, from start to full crossing.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eYou can mix different \u003ccode\u003etimeline-range-names\u003c/code\u003e to control the start and end points of the animation range. For example, you could make the animation start when the element enters the scrollport and end when it exits:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-range: entry exit;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can also combine these values with percentages to define more custom behavior, such as starting the animation halfway through the element’s entry and ending it halfway through its exit:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanimation-range: entry 50% exit 50%;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eExploring all these values and combinations is best done interactively. Tools like Bramus’ \u003ca href=\"https://scroll-driven-animations.style/tools/view-timeline/ranges/\"\u003eview-timeline range visualizer\u003c/a\u003e make it easier to understand.\u003c/p\u003e\u003ch3 id=\"target-range-inside-keyframes\"\u003eTarget Range Inside \u003ccode\u003e@keyframes\u003c/code\u003e\u003c/h3\u003e\u003cp\u003eOne of the powerful features of \u003ccode\u003etimeline-range-names\u003c/code\u003e is their ability to be used inside \u003ccode\u003e@keyframes\u003c/code\u003e:\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"zxOBMaK\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [target range inside @keyframes - view-timeline, timeline-range-name [forked]](https://codepen.io/smashingmag/pen/zxOBMaK) by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/zxOBMaK\"\u003etarget range inside @keyframes - view-timeline, timeline-range-name [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eTwo different animations are happening in that demo:\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eslideIn\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eWhen the element enters the scrollport, it scales up and becomes visible.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eslideOut\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eWhen the element leaves, it scales down and fades out.\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode\u003e@keyframes slideIn {\n  from {\n    transform: scale(.8) translateY(100px); \n    opacity: 0;\n  }\n  to { \n    transform: scale(1) translateY(0); \n    opacity: 1;\n  }\n}\n\n@keyframes slideOut {\n  from {\n    transform: scale(1) translateY(0); \n    opacity: 1;    \n  }\n  to { \n    transform: scale(.8) translateY(-100px); \n    opacity: 0 \n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe new thing is that now we can merge these two animations using the \u003ccode\u003eentry\u003c/code\u003e and \u003ccode\u003eexit\u003c/code\u003e \u003ccode\u003etimeline-range-names\u003c/code\u003e, simplifying it into one animation that handles both cases:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@keyframes slideInOut {\n  /* Animation for when the element enters the scrollport */\n  entry 0% {\n    transform: scale(.8) translateY(100px); \n    opacity: 0;\n  }\n  entry 100% { \n    transform: scale(1) translateY(0); \n    opacity: 1;\n  }\n  /* Animation for when the element exits the scrollport */\n  exit 0% {\n    transform: scale(1) translateY(0); \n    opacity: 1;    \n  }\n  exit 100% { \n    transform: scale(.8) translateY(-100px); \n    opacity: 0;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eentry 0%\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eDefines the state of the element at the beginning of its entry into the scrollport (scaled down and transparent).\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eentry 100%\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eDefines the state when the element has fully entered the scrollport (fully visible and scaled up).\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eexit 0%\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eStarts tracking the element as it begins to leave the scrollport (visible and scaled up).\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eexit 100%\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eDefines the state when the element has fully left the scrollport (scaled down and transparent).\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis approach allows us to animate the element’s behavior smoothly as it both enters and leaves the scrollport, all within a single \u003ccode\u003e@keyframes\u003c/code\u003e block.\u003c/p\u003e\u003ch3 id=\"named-view-timeline-and-timeline-scope\"\u003eNamed \u003ccode\u003eview-timeline\u003c/code\u003e And \u003ccode\u003etimeline-scope\u003c/code\u003e\u003c/h3\u003e\u003cp\u003eThe concept of using \u003ccode\u003eview-timeline\u003c/code\u003e with named timelines and linking them across different elements can truly expand the possibilities for scroll-driven animations. In this case, we are linking the scroll-driven animation of images with the animations of unrelated paragraphs in the DOM structure by using \u003cstrong\u003ea named \u003ccode\u003eview-timeline\u003c/code\u003e and \u003ccode\u003etimeline-scope\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003eview-timeline\u003c/code\u003e property works similarly to the \u003ccode\u003escroll-timeline\u003c/code\u003e property. It’s the shorthand for declaring the \u003ccode\u003eview-timeline-name\u003c/code\u003e and \u003ccode\u003eview-timeline-axis\u003c/code\u003e properties in one line. However, the difference from \u003ccode\u003escroll-timeline\u003c/code\u003e is that we can link the animation of an element when the linked elements enter the scrollport. I took the previous demo and added an animation to the paragraphs so you can see how the opacity of the text is animated when scrolling the images on the left:\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"KwPMrBP\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [View-timeline, timeline-scope [forked]](https://codepen.io/smashingmag/pen/KwPMrBP) by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/KwPMrBP\"\u003eView-timeline, timeline-scope [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/marianab\"\u003eMariana Beldi\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eThis one looks a bit verbose, but I found it hard to come up with a better example to show the power of it. Each image in the vertical scroll container is assigned a named \u003ccode\u003eview-timeline\u003c/code\u003e with a unique identifier:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e.vertical-scroll-container img:nth-of-type(1) { view-timeline: --one; }\n.vertical-scroll-container img:nth-of-type(2) { view-timeline: --two; }\n.vertical-scroll-container img:nth-of-type(3) { view-timeline: --three; }\n.vertical-scroll-container img:nth-of-type(4) { view-timeline: --four; }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis makes the scroll timeline of each image have its own custom name, such as \u003ccode\u003e--one\u003c/code\u003e for the first image, \u003ccode\u003e--two\u003c/code\u003e for the second, and so on.\u003c/p\u003e\u003cp\u003eNext, we connect the animations of the paragraphs to the named timelines of the images. The corresponding paragraph should animate when the images enter the scrollport:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e.vertical-text p:nth-of-type(1) { animation-timeline: --one; }\n.vertical-text p:nth-of-type(2) { animation-timeline: --two; }\n.vertical-text p:nth-of-type(3) { animation-timeline: --three; }\n.vertical-text p:nth-of-type(4) { animation-timeline: --four; }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHowever, since the images and paragraphs are not directly related in the DOM, we need to declare a \u003ccode\u003etimeline-scope\u003c/code\u003e on their common ancestor. This ensures that the named timelines (\u003ccode\u003e--one\u003c/code\u003e, \u003ccode\u003e--two\u003c/code\u003e, and so on) can be referenced and shared between the elements:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.porto {\n  /* ... */\n  timeline-scope: --one, --two, --three, --four;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBy declaring the \u003ccode\u003etimeline-scope\u003c/code\u003e with all the named timelines (\u003ccode\u003e--one\u003c/code\u003e, \u003ccode\u003e—two\u003c/code\u003e, \u003ccode\u003e--three\u003c/code\u003e, \u003ccode\u003e--four\u003c/code\u003e), both the images and the paragraphs can participate in the same scroll-timeline logic, despite being in separate parts of the DOM tree.\u003c/p\u003e\u003ch2 id=\"final-notes\"\u003eFinal Notes\u003c/h2\u003e\u003cp\u003eWe’ve covered the vast majority of what’s currently defined in the \u003ca href=\"https://drafts.csswg.org/scroll-animations-1/\"\u003eCSS Scroll-Driven Animations Module Leve 1 specification\u003c/a\u003e today in December 2024. But I want to highlight a few key takeaways that helped me better understand these new rules that you may not get directly from the spec:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eScroll container essentials\u003c/strong\u003e\u003cbr/\u003eIt may seem obvious, but a scroll container is necessary for scroll-driven animations to work. Issues often arise when elements like text or containers are resized or when animations are tested on larger screens, causing the scrollable area to disappear.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eImpact of \u003ccode\u003eposition: absolute\u003c/code\u003e\u003c/strong\u003e\u003cbr/\u003eUsing absolute positioning can sometimes interfere with the intended behavior of scroll-driven animations. The relationship between elements and their parent elements gets tricky when \u003ccode\u003eposition: absolute\u003c/code\u003e is applied.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eTracking an element’s initial state\u003c/strong\u003e\u003cbr/\u003eThe browser evaluates the element’s state \u003cem\u003ebefore\u003c/em\u003e any transformations (like \u003ccode\u003etranslate\u003c/code\u003e) are applied. This affects when animations, particularly view timelines, begin. Your animation might trigger earlier or later than expected due to the initial state.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eAvoid hiding overflow\u003c/strong\u003e\u003cbr/\u003eUsing \u003ccode\u003eoverflow: hidden\u003c/code\u003e can disrupt the scroll-seeking mechanism in scroll-driven animations. The recommended solution is to switch to \u003ccode\u003eoverflow: clip\u003c/code\u003e. Bramus has \u003ca href=\"https://www.bram.us/2024/02/14/scroll-driven-animations-you-want-overflow-clip-not-overflow-hidden/\"\u003ea great article about this\u003c/a\u003e and \u003ca href=\"https://www.youtube.com/watch?v=72pUm4tQesw\"\u003ea video from Kevin Powell\u003c/a\u003e also suggests that we may no longer need \u003ccode\u003eoverflow: hidden\u003c/code\u003e.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003ePerformance\u003c/strong\u003e\u003cbr/\u003eFor the best results, stick to animating GPU-friendly properties like transforms, opacity, and some filters. These skip the heavy lifting of recalculating layout and repainting. On the other hand, animating things like \u003ccode\u003ewidth\u003c/code\u003e, \u003ccode\u003eheight\u003c/code\u003e, or \u003ccode\u003ebox-shadow\u003c/code\u003e can slow things down since they require re-rendering. Bramus \u003ca href=\"https://www.bram.us/2024/05/30/scroll-driven-animations-with-css-webexpo/\"\u003ementioned\u003c/a\u003e that soon, more properties — like \u003ccode\u003ebackground-color\u003c/code\u003e, \u003ccode\u003eclip-path\u003c/code\u003e, \u003ccode\u003ewidth\u003c/code\u003e, and \u003ccode\u003eheight\u003c/code\u003e — will be animatable on the compositor, making the performance even better.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eUse \u003ccode\u003ewill-change\u003c/code\u003e wisely\u003c/strong\u003e\u003cbr/\u003eLeverage this property to promote elements to the GPU, but use it sparingly. Overusing \u003ccode\u003ewill-change\u003c/code\u003e can lead to excessive memory usage since the browser reserves resources even if the animations don’t frequently change.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eThe order matters\u003c/strong\u003e\u003cbr/\u003eIf you are using the \u003ccode\u003eanimation\u003c/code\u003e shorthand, always place the \u003ccode\u003eanimation-timeline\u003c/code\u003e after it.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eProgressive enhancement and accessibility\u003c/strong\u003e\u003cbr/\u003eCombine media queries for reduced motion preferences with the \u003ccode\u003e@supports\u003c/code\u003e rule to ensure animations only apply when the user has no motion restrictions, and the browser supports them.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFor example:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e@media screen and (prefers-reduce-motion: no-preference) {\n  @supports ((animation-timeline: scroll()) and (animation-range: 0% 100%)) { \n    .my-class {\n      animation: moveCard linear both;    \n      animation-timeline: view(); \n    }\n  } \n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eMy main struggle while trying to build the demos was more about CSS itself than the scroll animations. Sometimes, building the layout and generating the scroll was more difficult than applying the scroll animation. Also, some things that confused me at the beginning as the spec keeps evolving, and some of these are not there anymore (remember, it has been under development for more than five years now!):\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003ex and y axes\u003c/strong\u003e\u003cbr/\u003eThese used to be called the “horizontal” and “vertical” axes, and while Firefox may still support the old terminology, it has been updated.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eOld \u003ccode\u003e@scroll-timeline\u003c/code\u003e syntax\u003c/strong\u003e\u003cbr/\u003eIn the past, \u003ccode\u003e@scroll-timeline\u003c/code\u003e was used to declare scroll timelines, but this has changed in the most recent version of the spec.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eScroll-driven vs. scroll-linked animations\u003c/strong\u003e\u003cbr/\u003eScroll-\u003cem\u003edriven\u003c/em\u003e animations were originally called scroll-\u003cem\u003elinked\u003c/em\u003e animations. If you come across this older term in articles, double-check whether the content has been updated to reflect the latest spec, particularly with features like \u003ccode\u003etimeline-scope\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"resources\"\u003eResources\u003c/h3\u003e\u003cul\u003e\u003cli\u003eAll demos from this article can be found \u003ca href=\"https://codepen.io/collection/WvVpQR\"\u003ein this collection\u003c/a\u003e, and I might include \u003ca href=\"https://codepen.io/marianab/pen/bGXdEoB\"\u003emore\u003c/a\u003e as I experiment further.\u003c/li\u003e\u003cli\u003eA collection of \u003ca href=\"https://codepen.io/collection/aMgBZp\"\u003edemos from CodePen\u003c/a\u003e that I find interesting (send me yours, and I’ll include it!)\u003c/li\u003e\u003cli\u003eThis \u003ca href=\"https://github.com/w3c/csswg-drafts/labels/scroll-animations-1\"\u003eGitHub repo\u003c/a\u003e is where you can report issues or join discussions about scroll-driven animations.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://scroll-driven-animations.style/\"\u003eDemos, tools, videos\u003c/a\u003e, and (even) more information from Bramus\u003c/li\u003e\u003cli\u003eGoogle Chrome \u003ca href=\"https://www.youtube.com/playlist?list=PLNYkxOF6rcICM3ttukz9x5LCNOHfWBVnn\"\u003evideo tutorial\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(gg, yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "29 min read",
  "publishedTime": "2024-12-11T15:00:00Z",
  "modifiedTime": "2024-12-11T15:00:00Z"
}
