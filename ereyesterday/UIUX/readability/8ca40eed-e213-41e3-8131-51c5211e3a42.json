{
  "id": "8ca40eed-e213-41e3-8131-51c5211e3a42",
  "title": "Masonry In CSS: Should Grid Evolve Or Stand Aside For A New Module?",
  "link": "https://smashingmagazine.com/2025/05/masonry-css-should-grid-evolve-stand-aside-new-module/",
  "description": "There were duelling proposals floating around for adding support for masonry-style layouts in CSS. In one corner is a proposal that extends the existing CSS Grid specification. In the other corner is a second proposal that sets up masonry as a standalone module. Well, not until recently. Now, there are three proposals with Apple WebKit’s “Item Flow” as the third option. The first two sides make strong points, and the third one merges them into one, all of which you will learn about in this article.",
  "author": "Gabriel Shoyombo",
  "published": "Tue, 06 May 2025 13:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 14783,
  "excerpt": "There were duelling proposals floating around for adding support for masonry-style layouts in CSS. In one corner is a proposal that extends the existing CSS Grid specification. In the other corner is a second proposal that sets up masonry as a standalone module. Well, not until recently. Now, there are three proposals with Apple WebKit’s “Item Flow” as the third option. The first two sides make strong points, and the third one merges them into one, all of which you will learn about in this article.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "11 min readCSS, CSS Grid, Design, TechniquesThere were duelling proposals floating around for adding support for masonry-style layouts in CSS. In one corner is a proposal that extends the existing CSS Grid specification. In the other corner is a second proposal that sets up masonry as a standalone module. Well, not until recently. Now, there are three proposals with Apple WebKit’s “Item Flow” as the third option. The first two sides make strong points, and the third one merges them into one, all of which you will learn about in this article.You’ve got a Pinterest-style layout to build, but you’re tired of JavaScript. Could CSS finally have the answer? Well, for a beginner, taking a look at the pins on your Pinterest page, you might be convinced that the CSS grid layout is enough, but not until you begin to build do you realise display: grid with additional tweaks is less than enough. In fact, Pinterest built its layout with JavaScript, but how cool would it be if it were just CSS? If there were a CSS display property that gave such a layout without any additional JavaScript, how awesome would that be?Maybe there is. The CSS grid layout has an experimental masonry value for grid-template-rows. The masonry layout is an irregular, flowing grid. Irregular in the sense that, instead of following a rigid grid pattern with spaces left after shorter pieces, the items in the next row of a masonry layout rise to fill the spaces on the masonry axis. It’s the dream for portfolios, image galleries, and social feeds — designs that thrive on organic flow. But here’s the catch: while this experimental feature exists (think Firefox Nightly with a flag enabled), it’s not the seamless solution you might expect, thanks to limited browser support and some rough edges in its current form.Maybe there isn’t. CSS lacks native masonry support, forcing developers to use hacks or JavaScript libraries like Masonry.js. Developers with a good design background have expressed their criticism about the CSS grid form of masonry, with Rachel highlighting that masonry’s organic flow contrasts with Grid’s strict two-dimensional structure, potentially confusing developers expecting Grid-like behaviour or Ahmad Shadeed fussing about how it makes the grid layout more complex than it should be, potentially overwhelming developers who value Grid’s clarity for structured layouts. Geoff also echoes Rachel Andrew’s concern that “teaching and learning grid to get to understand masonry behaviour unnecessarily lumps two different formatting contexts into one,” complicating education for designers and developers who rely on clear mental models.Perhaps there might be hope. The Apple WebKit team just sprung up a new contender, which claims not only to merge the pros of grid and masonry into a unified system shorthand but also includes flexbox concepts. Imagine the best of three CSS layout systems in one.Given these complaints and criticisms — and a new guy in the game — the question is:Should CSS Grid expand to handle Masonry, or should a new, dedicated module take over, or should item-flow just take the reins?The State Of Masonry In CSS TodaySeveral developers have attempted to create workarounds to achieve a masonry layout in their web applications using CSS Grid with manual row-span hacks, CSS Columns, and JavaScript libraries. Without native masonry, developers often turn to Grid hacks like this: a grid-auto-rows trick paired with JavaScript to fake the flow. It works — sort of — but the cracks show fast.For instance, the example below relies on JavaScript to measure each item’s height after rendering, calculate the number of 10px rows (plus gaps) the item should span while setting grid-row-end dynamically, and use event listeners to adjust the layout upon page load and window resize./* HTML */ \u003cdiv class=\"masonry-grid\"\u003e \u003cdiv class=\"masonry-item\"\u003e\u003cimg src=\"image1.jpg\" alt=\"Image 1\"\u003e\u003c/div\u003e \u003cdiv class=\"masonry-item\"\u003e\u003cp\u003eShort text content here.\u003c/p\u003e\u003c/div\u003e \u003cdiv class=\"masonry-item\"\u003e\u003cimg src=\"image2.jpg\" alt=\"Image 2\"\u003e\u003c/div\u003e \u003cdiv class=\"masonry-item\"\u003e\u003cp\u003eLonger text content that spans multiple lines to show height variation.\u003c/p\u003e\u003c/div\u003e \u003c/div\u003e /* CSS */ .masonry-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); /* Responsive columns */ grid-auto-rows: 10px; /* Small row height for precise spanning */ grid-auto-flow: column; /* Fills columns left-to-right */ gap: 10px; /* Spacing between items */ } .masonry-item { /* Ensure content doesn’t overflow */ overflow: hidden; } .masonry-item img { width: 100%; height: auto; display: block; } .masonry-item p { margin: 0; padding: 10px; } // JavaScript function applyMasonry() { const grid = document.querySelector('.masonry-grid'); const items = grid.querySelectorAll('.masonry-item'); items.forEach(item =\u003e { // Reset any previous spans item.style.gridRowEnd = 'auto'; // Calculate the number of rows to span based on item height const rowHeight = 10; const gap = 10; const itemHeight = item.getBoundingClientRect().height; const rowSpan = Math.ceil((itemHeight + gap) / (rowHeight + gap)); // Apply the span item.style.gridRowEnd = `span ${rowSpan}`; }); } // Run on load and resize window.addEventListener('load', applyMasonry); window.addEventListener('resize', applyMasonry); This Grid hack gets us close to a masonry layout — items stack, gaps fill, and it looks decent enough. But let’s be real: it’s not there yet. The code sample above, unlike native grid-template-rows: masonry (which is experimental and only exists on Firefox Nightly), relies on JavaScript to calculate spans, defeating the “no JavaScript” dream. The JavaScript logic works by recalculating spans on resize or content change. As Chris Coyier noted in his critique of similar hacks, this can lead to lag on complex pages.Also, the logical DOM order might not match the visual flow, a concern Rachel Andrew raised about masonry layouts generally. Finally, if images load slowly or content shifts (e.g., lazy-loaded media), the spans need recalculation, risking layout jumps. It’s not really the ideal hack; I’m sure you’d agree.Developers need a smooth experience, and ergonomically speaking, hacking Grid with scripts is a mental juggling act. It forces you to switch between CSS and JavaScript to tweak a layout. A native solution, whether Grid-powered or a new module, has to nail effortless responsiveness, neat rendering, and a workflow that does not make you break your tools.That’s why this debate matters — our daily grind demands it.Option 1: Extending CSS Grid For MasonryOne way forward is to strengthen the CSS Grid with masonry powers. As of this writing, CSS grids have been extended to accommodate masonry. grid-template-rows: masonry is a draft of CSS Grid Level 3 that is currently experimental in Firefox Nightly. The columns of this layout will remain as a grid axis while the row takes on masonry. The child elements are then laid out item by item along the rows, as with the grid layout’s automatic placement. With this layout, items flow vertically, respecting column tracks but not row constraints.This option leaves Grid as your go-to layout system but allows it to handle the flowing, gap-filling stacks we crave..masonry-grid { display: grid; gap: 10px; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); grid-template-rows: masonry; } First off, the grid-masonry style builds on CSS Grid’s familiarity and robust tooling (e.g., DevTools support). As a front-end developer, there’s a chance you’ve played with grid-template-columns or grid-area, so you’re halfway up the learning matrix. Masonry only extends the existing capabilities, eliminating the need to learn a whole new syntax from scratch. Also, Grid’s robust tooling comes along with Chrome DevTools’ grid overlay or Firefox’s layout inspector, removing the need for JavaScript hacks.Not so fast: there are limitations. Grid’s specifications already include properties like align-content and grid-auto-flow. Stacking masonry on the list risks turning it into a labyrinth.Then there are the edge cases. What happens when you want an item to span multiple columns and flow masonry-style? Or when gaps between items don’t align across columns? The specs are still foggy here, and early tests hint at bugs like items jumping unpredictably if content loads dynamically. This issue could break layouts, especially on responsive designs. The browser compatibility issue also exists. It’s still experimental, and even with polyfills, it does not work on other browsers except Firefox Nightly. Not something you’d want to try in your next client’s project, right?Option 2: A Standalone Masonry ModuleWhat if we had a display: masonry approach instead? Indulge me for a few minutes. This isn’t just wishful thinking. Early CSS Working Group chats have floated the idea, and it’s worth picturing how it could improve layouts. Let’s dive into the vision, how it might work, and what it gains or loses in the process.Imagine a layout system that doesn’t lean on Grid’s rigid tracks or Flexbox’s linear flow but instead thrives on vertical stacking with a horizontal twist. The goal? A clean slate for masonry’s signature look: items cascading down columns, filling gaps naturally, no hacks required. Inspired by murmurs in CSSWG discussions and the Chrome team’s alternative proposal, this module would prioritise fluidity over structure, giving designers a tool that feels as intuitive as the layouts they’re chasing. Think Pinterest but without JavaScript scaffolding.Here’s the pitch: a display value named masonry kicks off a flow-based system where items stack vertically by default, adjusting horizontally to fit the container. You’d control the direction and spacing with simple properties like the following:.masonry { display: masonry; masonry-direction: column; gap: 1rem; } Want more control? Hypothetical extras like masonry-columns: auto could mimic Grid’s repeat(auto-fill, minmax()), while masonry-align: balance might even out column lengths for a polished look. It’s less about precise placement (Grid’s strength) and more about letting content breathe and flow, adapting to whatever screen size is thrown at it. The big win here is a clean break from Grid’s rigid order. A standalone module keeps them distinct: Grid for order, Masonry for flow. No more wrestling with Grid properties that don’t quite fit; you get a system tailored to the job.Of course, it’s not all smooth sailing. A brand-new spec means starting from zero. Browser vendors would need to rally behind it, which can be slow. Also, it might lead to confusion of choice, with developers asking questions like: “Do I use Grid or Masonry for this gallery?” But hear me out: This proposed module might muddy the waters before it clears them, but after the water is clear, it’s safe for use by all and sundry.Item Flow: A Unified Layout ResolutionIn March 2025, Apple’s WebKit team proposed Item Flow, a new system that unifies concepts from Flexbox, Grid, and masonry into a single set of properties. Rather than choosing between enhancing Grid or creating a new masonry module, Item Flow merges their strengths, replacing flex-flow and grid-auto-flow with a shorthand called item-flow. This system introduces four longhand properties:item-directionControls flow direction (e.g., row, column, row-reverse).item-wrapManages wrapping behaviour (e.g., wrap, nowrap, wrap-reverse).item-packDetermines packing density (e.g., sparse, dense, balance).item-slackAdjusts tolerance for layout adjustments, allowing items to shrink or shift to fit.Item Flow aims to make masonry a natural outcome of these properties, not a separate feature. For example, a masonry layout could be achieved with:.container { display: grid; /* or flex */ item-flow: column wrap dense; /* long hand version */ item-direction: column; item-wrap: wrap; item-pack: dense; gap: 1rem; } This setup allows items to flow vertically, wrap into columns, and pack tightly, mimicking masonry’s organic arrangement. The dense packing option, inspired by Grid’s auto-flow: dense, reorders items to minimise gaps, while item-slack could fine-tune spacing for visual balance.Item Flow’s promise lies in its wide use case. It enhances Grid and Flexbox with features like nowrap for Grid or balance packing for Flexbox, addressing long-standing developer wishlists. However, the proposal is still in discussion, and properties like item-slack face naming debates due to clarity issues for non-native English speakers.The downside? Item Flow is a future-facing concept, and it has not yet been implemented in browsers as of April 2025. Developers must wait for standardisation and adoption, and the CSS Working Group is still gathering feedback.What’s The Right Path?While there is no direct answer to that question, the masonry debate hinges on balancing simplicity, performance, and flexibility. Extending the Grid with masonry is tempting but risks overcomplicating an already robust system. A standalone display: masonry module offers clarity but adds to CSS’s learning curve. Item Flow, the newest contender, proposes a unified system that could make masonry a natural extension of Grid and Flexbox, potentially putting the debate to rest at last.Each approach has trade-offs:Grid with Masonry: Familiar but potentially clunky, with accessibility and spec concerns.New Module: Clean and purpose-built, but requires learning new syntax.Item Flow: Elegant and versatile but not yet available, with ongoing debates over naming and implementation.Item Flow’s ability to enhance existing layouts while supporting masonry makes it a compelling option, but its success depends on browser adoption and community support.ConclusionSo, where do we land after all this? The masonry showdown boils down to three paths: the extension of masonry into CSS Grid, a standalone module for masonry, or Item Flow. Now, the question is, will CSS finally free us from JavaScript for masonry, or are we still dreaming?Grid’s teasing us with a taste, and a standalone module’s whispering promises — but the finish line’s unclear, and WebKit swoops in with a killer merge shorthand, Item Flow. Browser buy-in, community push, and a few more spec revisions might tell us. For now, it’s your move — test, tweak, and weigh in. The answer’s coming, one layout at a time.References“Native CSS Masonry Layout in CSS Grid” by Rachel Andrew“Should Masonry be part of CSS Grid?” by Ahmad Shadeed“CSS Masonry \u0026 CSS Grid” by Geoff Graham“Masonry? In CSS?!” by Michelle Barker“Native CSS Masonry Layout in CSS Grids” by Chris Coyier“Item Flow Part 1: A Unified Concept for Layout” by WebKit (gg, yk)",
  "image": "https://files.smashing.media/articles/masonry-css-should-grid-evolve-stand-aside-new-module/masonry-css-should-grid-evolve-stand-aside-new-module.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e11 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/css\"\u003eCSS\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/css-grid\"\u003eCSS Grid\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/design\"\u003eDesign\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/techniques\"\u003eTechniques\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eThere were duelling proposals floating around for adding support for masonry-style layouts in CSS. In one corner is a proposal that extends the existing CSS Grid specification. In the other corner is a second proposal that sets up masonry as a standalone module. Well, not until recently. Now, there are three proposals with Apple WebKit’s “Item Flow” as the third option. The first two sides make strong points, and the third one merges them into one, all of which you will learn about in this article.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eYou’ve got a Pinterest-style layout to build, but you’re tired of JavaScript. Could CSS finally have the answer? Well, for a beginner, taking a look at the pins on your Pinterest page, you might be convinced that the CSS grid layout is enough, but not until you begin to build do you realise \u003ccode\u003edisplay: grid\u003c/code\u003e with additional tweaks is less than enough. In fact, Pinterest built its layout with JavaScript, but how cool would it be if it were just CSS? If there were a CSS display property that gave such a layout without any additional JavaScript, how awesome would that be?\u003c/p\u003e\u003cp\u003eMaybe there is. The CSS grid layout has an \u003cstrong\u003eexperimental masonry value\u003c/strong\u003e for \u003ccode\u003egrid-template-rows\u003c/code\u003e. The masonry layout is an irregular, flowing grid. Irregular in the sense that, instead of following a rigid grid pattern with spaces left after shorter pieces, the items in the next row of a masonry layout rise to fill the spaces on the masonry axis. It’s the dream for portfolios, image galleries, and social feeds — designs that thrive on organic flow. But here’s the catch: while this experimental feature exists (think Firefox Nightly with a flag enabled), it’s not the seamless solution you might expect, thanks to limited browser support and some rough edges in its current form.\u003c/p\u003e\u003cp\u003eMaybe there isn’t. CSS lacks native masonry support, forcing developers to use hacks or JavaScript libraries like \u003ca href=\"https://masonry.desandro.com\"\u003eMasonry.js\u003c/a\u003e. Developers with a good design background have expressed their criticism about the CSS grid form of masonry, with \u003ca href=\"https://www.smashingmagazine.com/native-css-masonry-layout-css-grid/\"\u003eRachel\u003c/a\u003e highlighting that \u003cstrong\u003emasonry’s organic flow contrasts with Grid’s strict two-dimensional structure\u003c/strong\u003e, potentially confusing developers expecting Grid-like behaviour or \u003ca href=\"https://ishadeed.com/article/should-masonry-be-part-of-css-grid/\"\u003eAhmad Shadeed\u003c/a\u003e fussing about how it makes the grid layout more complex than it should be, potentially overwhelming developers who value Grid’s clarity for structured layouts. \u003ca href=\"https://css-tricks.com/css-masonry-css-grid/\"\u003eGeoff\u003c/a\u003e also echoes Rachel Andrew’s concern that \u003cem\u003e“teaching and learning grid to get to understand masonry behaviour unnecessarily lumps two different formatting contexts into one,”\u003c/em\u003e complicating education for designers and developers who rely on clear mental models.\u003c/p\u003e\u003cp\u003ePerhaps there might be hope. The Apple WebKit team just sprung up a new contender, which claims not only to merge the pros of grid and masonry into a unified system shorthand but also includes flexbox concepts. Imagine the best of three CSS layout systems in one.\u003c/p\u003e\u003cp\u003eGiven these complaints and criticisms — and a new guy in the game — the question is:\u003c/p\u003e\u003cblockquote\u003eShould CSS Grid expand to handle Masonry, or should a new, dedicated module take over, or should \u003ccode\u003eitem-flow\u003c/code\u003e just take the reins?\u003c/blockquote\u003e\u003ch2 id=\"the-state-of-masonry-in-css-today\"\u003eThe State Of Masonry In CSS Today\u003c/h2\u003e\u003cp\u003eSeveral developers have attempted to create workarounds to achieve a masonry layout in their web applications using CSS Grid with manual row-span hacks, CSS Columns, and JavaScript libraries. Without native masonry, developers often turn to Grid hacks like this: a \u003ccode\u003egrid-auto-rows\u003c/code\u003e trick paired with JavaScript to fake the flow. It works — sort of — but the cracks show fast.\u003c/p\u003e\u003cp\u003eFor instance, the example below relies on JavaScript to measure each item’s height after rendering, calculate the number of 10px rows (plus gaps) the item should span while setting \u003ccode\u003egrid-row-end\u003c/code\u003e dynamically, and use event listeners to adjust the layout upon page load and window resize.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e/* HTML */\n\u0026lt;div class=\u0026#34;masonry-grid\u0026#34;\u0026gt;\n  \u0026lt;div class=\u0026#34;masonry-item\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;image1.jpg\u0026#34; alt=\u0026#34;Image 1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;masonry-item\u0026#34;\u0026gt;\u0026lt;p\u0026gt;Short text content here.\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;masonry-item\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;image2.jpg\u0026#34; alt=\u0026#34;Image 2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;masonry-item\u0026#34;\u0026gt;\u0026lt;p\u0026gt;Longer text content that spans multiple lines to show height variation.\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e/* CSS */\n.masonry-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); /* Responsive columns */\n  grid-auto-rows: 10px; /* Small row height for precise spanning */\n  grid-auto-flow: column; /* Fills columns left-to-right */\n  gap: 10px; /* Spacing between items */\n}\n\n.masonry-item {\n  /* Ensure content doesn’t overflow */\n  overflow: hidden;\n}\n\n.masonry-item img {\n  width: 100%;\n  height: auto;\n  display: block;\n}\n\n.masonry-item p {\n  margin: 0;\n  padding: 10px;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e// JavaScript\n\nfunction applyMasonry() {\n  const grid = document.querySelector(\u0026#39;.masonry-grid\u0026#39;);\n  const items = grid.querySelectorAll(\u0026#39;.masonry-item\u0026#39;);\n\n  items.forEach(item =\u0026gt; {\n    // Reset any previous spans\n    item.style.gridRowEnd = \u0026#39;auto\u0026#39;;\n\n    // Calculate the number of rows to span based on item height\n    const rowHeight = 10; \n    const gap = 10; \n    const itemHeight = item.getBoundingClientRect().height;\n    const rowSpan = Math.ceil((itemHeight + gap) / (rowHeight + gap));\n\n    // Apply the span\n    item.style.gridRowEnd = `span ${rowSpan}`;\n  });\n}\n\n// Run on load and resize\nwindow.addEventListener(\u0026#39;load\u0026#39;, applyMasonry);\nwindow.addEventListener(\u0026#39;resize\u0026#39;, applyMasonry);\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis Grid hack gets us close to a masonry layout — items stack, gaps fill, and it looks decent enough. But let’s be real: it’s not there yet. The code sample above, unlike native \u003ccode\u003egrid-template-rows: masonry\u003c/code\u003e (which is experimental and only exists on Firefox Nightly), relies on JavaScript to calculate spans, defeating the “no JavaScript” dream. The JavaScript logic works by recalculating spans on resize or content change. As \u003ca href=\"https://css-tricks.com/native-css-masonry-layout-in-css-grid/\"\u003eChris Coyier\u003c/a\u003e noted in his critique of similar hacks, this can lead to lag on complex pages.\u003c/p\u003e\u003cp\u003eAlso, the logical DOM order might not match the visual flow, a concern \u003ca href=\"https://www.smashingmagazine.com/native-css-masonry-layout-css-grid/\"\u003eRachel Andrew\u003c/a\u003e raised about masonry layouts generally. Finally, if images load slowly or content shifts (e.g., lazy-loaded media), the spans need recalculation, risking layout jumps. It’s not really the ideal hack; I’m sure you’d agree.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003ca aria-label=\"Share on Twitter\" href=\"https://twitter.com/share?text=%0aDevelopers%20need%20a%20smooth%20experience,%20and%20ergonomically%20speaking,%20hacking%20Grid%20with%20scripts%20is%20a%20mental%20juggling%20act.%20It%20forces%20you%20to%20switch%20between%20CSS%20and%20JavaScript%20to%20tweak%20a%20layout.%20A%20native%20solution,%20whether%20Grid-powered%20or%20a%20new%20module,%20has%20to%20nail%20effortless%20responsiveness,%20neat%20rendering,%20and%20a%20workflow%20that%20does%20not%20make%20you%20break%20your%20tools.%0a\u0026amp;url=https://smashingmagazine.com%2f2025%2f05%2fmasonry-css-should-grid-evolve-stand-aside-new-module%2f\"\u003eDevelopers need a smooth experience, and ergonomically speaking, hacking Grid with scripts is a mental juggling act. It forces you to switch between CSS and JavaScript to tweak a layout. A native solution, whether Grid-powered or a new module, has to nail effortless responsiveness, neat rendering, and a workflow that does not make you break your tools.\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eThat’s why this debate matters — our daily grind demands it.\u003c/p\u003e\u003ch2 id=\"option-1-extending-css-grid-for-masonry\"\u003eOption 1: Extending CSS Grid For Masonry\u003c/h2\u003e\u003cp\u003eOne way forward is to strengthen the CSS Grid with masonry powers. As of this writing, CSS grids have been extended to accommodate masonry. \u003ccode\u003egrid-template-rows: masonry\u003c/code\u003e is a draft of CSS Grid Level 3 that is currently experimental in Firefox Nightly. The columns of this layout will remain as a grid axis while the row takes on masonry. The child elements are then laid out item by item along the rows, as with the grid layout’s automatic placement. With this layout, items flow vertically, respecting column tracks but not row constraints.\u003c/p\u003e\u003cp\u003eThis option leaves Grid as your go-to layout system but allows it to handle the flowing, gap-filling stacks we crave.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e.masonry-grid {\n  display: grid;\n  gap: 10px;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n  grid-template-rows: masonry;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFirst off, the grid-masonry style builds on CSS Grid’s familiarity and robust tooling (e.g., DevTools support). As a front-end developer, there’s a chance you’ve played with \u003ccode\u003egrid-template-columns\u003c/code\u003e or \u003ccode\u003egrid-area\u003c/code\u003e, so you’re halfway up the learning matrix. Masonry only extends the existing capabilities, eliminating the need to learn a whole new syntax from scratch. Also, Grid’s robust tooling comes along with Chrome DevTools’ grid overlay or Firefox’s layout inspector, removing the need for JavaScript hacks.\u003c/p\u003e\u003cp\u003eNot so fast: there are limitations. Grid’s specifications already include properties like \u003ccode\u003ealign-content\u003c/code\u003e and \u003ccode\u003egrid-auto-flow\u003c/code\u003e. Stacking masonry on the list risks turning it into a labyrinth.\u003c/p\u003e\u003cp\u003eThen there are \u003cstrong\u003ethe edge cases\u003c/strong\u003e. What happens when you want an item to span multiple columns and flow masonry-style? Or when gaps between items don’t align across columns? The specs are still foggy here, and early tests hint at bugs like items jumping unpredictably if content loads dynamically. This issue could break layouts, especially on responsive designs. \u003cstrong\u003eThe browser compatibility issue\u003c/strong\u003e also exists. It’s still experimental, and even with polyfills, it does not work on other browsers except Firefox Nightly. Not something you’d want to try in your next client’s project, right?\u003c/p\u003e\u003ch2 id=\"option-2-a-standalone-masonry-module\"\u003eOption 2: A Standalone Masonry Module\u003c/h2\u003e\u003cp\u003eWhat if we had a \u003ccode\u003edisplay: masonry\u003c/code\u003e approach instead? Indulge me for a few minutes. This isn’t just wishful thinking. Early CSS Working Group chats have floated the idea, and it’s worth picturing how it could improve layouts. Let’s dive into the vision, \u003cem\u003ehow\u003c/em\u003e it might work, and \u003cem\u003ewhat\u003c/em\u003e it gains or loses in the process.\u003c/p\u003e\u003cp\u003eImagine a layout system that doesn’t lean on Grid’s rigid tracks or Flexbox’s linear flow but instead thrives on vertical stacking with a horizontal twist. The goal? A clean slate for masonry’s signature look: items cascading down columns, filling gaps naturally, no hacks required. Inspired by murmurs in CSSWG discussions and the Chrome team’s alternative proposal, this module would \u003cstrong\u003eprioritise fluidity over structure\u003c/strong\u003e, giving designers a tool that feels as intuitive as the layouts they’re chasing. Think Pinterest but without JavaScript scaffolding.\u003c/p\u003e\u003cp\u003eHere’s the pitch: a \u003ccode\u003edisplay\u003c/code\u003e value named \u003ccode\u003emasonry\u003c/code\u003e kicks off a flow-based system where items stack vertically by default, adjusting horizontally to fit the container. You’d control the direction and spacing with simple properties like the following:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.masonry {\n  display: masonry;\n  masonry-direction: column;\n  gap: 1rem;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWant more control? Hypothetical extras like \u003ccode\u003emasonry-columns: auto\u003c/code\u003e could mimic Grid’s \u003ccode\u003erepeat(auto-fill, minmax())\u003c/code\u003e, while \u003ccode\u003emasonry-align: balance\u003c/code\u003e might even out column lengths for a polished look. It’s less about precise placement (Grid’s strength) and more about letting content breathe and flow, adapting to whatever screen size is thrown at it. The big win here is a clean break from Grid’s rigid order. A standalone module keeps them distinct: \u003cstrong\u003eGrid for order, Masonry for flow\u003c/strong\u003e. No more wrestling with Grid properties that don’t quite fit; you get a system tailored to the job.\u003c/p\u003e\u003cp\u003eOf course, it’s not all smooth sailing. A brand-new spec means starting from zero. Browser vendors would need to rally behind it, which can be slow. Also, it might lead to \u003cstrong\u003econfusion of choice\u003c/strong\u003e, with developers asking questions like: \u003cem\u003e“Do I use Grid or Masonry for this gallery?”\u003c/em\u003e But hear me out: This proposed module might muddy the waters before it clears them, but after the water is clear, it’s safe for use by all and sundry.\u003c/p\u003e\u003ch2 id=\"item-flow-a-unified-layout-resolution\"\u003eItem Flow: A Unified Layout Resolution\u003c/h2\u003e\u003cp\u003eIn March 2025, \u003ca href=\"https://webkit.org/blog/16587/item-flow-part-1-a-new-unified-concept-for-layout/\"\u003eApple’s WebKit team proposed Item Flow\u003c/a\u003e, a new system that unifies concepts from Flexbox, Grid, and masonry into a single set of properties. Rather than choosing between enhancing Grid or creating a new masonry module, Item Flow merges their strengths, replacing \u003ccode\u003eflex-flow\u003c/code\u003e and \u003ccode\u003egrid-auto-flow\u003c/code\u003e with a shorthand called \u003ccode\u003eitem-flow\u003c/code\u003e. This system introduces four longhand properties:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eitem-direction\u003c/code\u003e\u003cbr/\u003eControls flow direction (e.g., \u003ccode\u003erow\u003c/code\u003e, \u003ccode\u003ecolumn\u003c/code\u003e, \u003ccode\u003erow-reverse\u003c/code\u003e).\u003c/li\u003e\u003cli\u003e\u003ccode\u003eitem-wrap\u003c/code\u003e\u003cbr/\u003eManages wrapping behaviour (e.g., \u003ccode\u003ewrap\u003c/code\u003e, \u003ccode\u003enowrap\u003c/code\u003e, \u003ccode\u003ewrap-reverse\u003c/code\u003e).\u003c/li\u003e\u003cli\u003e\u003ccode\u003eitem-pack\u003c/code\u003e\u003cbr/\u003eDetermines packing density (e.g., \u003ccode\u003esparse\u003c/code\u003e, \u003ccode\u003edense\u003c/code\u003e, \u003ccode\u003ebalance\u003c/code\u003e).\u003c/li\u003e\u003cli\u003e\u003ccode\u003eitem-slack\u003c/code\u003e\u003cbr/\u003eAdjusts tolerance for layout adjustments, allowing items to shrink or shift to fit.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eItem Flow aims to make masonry a natural outcome of these properties, not a separate feature. For example, a masonry layout could be achieved with:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.container {\n  display: grid; /* or flex */\n  item-flow: column wrap dense;\n\n  /* long hand version */\n  item-direction: column;\n  item-wrap: wrap;\n  item-pack: dense;\n\n  gap: 1rem;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis setup allows items to flow vertically, wrap into columns, and pack tightly, mimicking masonry’s organic arrangement. The dense packing option, inspired by Grid’s \u003ccode\u003eauto-flow: dense\u003c/code\u003e, reorders items to minimise gaps, while \u003ccode\u003eitem-slack\u003c/code\u003e could fine-tune spacing for visual balance.\u003c/p\u003e\u003cp\u003eItem Flow’s promise lies in its \u003cstrong\u003ewide use case\u003c/strong\u003e. It enhances Grid and Flexbox with features like \u003ccode\u003enowrap\u003c/code\u003e for Grid or \u003ccode\u003ebalance\u003c/code\u003e packing for Flexbox, addressing long-standing developer wishlists. However, the proposal is still in discussion, and \u003ca href=\"https://grok.com/chat/caeffa67-49d2-478e-834d-611d9a7bf204\"\u003eproperties like \u003ccode\u003eitem-slack\u003c/code\u003e face naming debates due to clarity issues for non-native English speakers\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe downside? Item Flow is a \u003cstrong\u003efuture-facing concept\u003c/strong\u003e, and it has not yet been implemented in browsers as of April 2025. Developers must wait for standardisation and adoption, and the CSS Working Group is still gathering feedback.\u003c/p\u003e\u003ch2 id=\"what-s-the-right-path\"\u003eWhat’s The Right Path?\u003c/h2\u003e\u003cp\u003eWhile there is no direct answer to that question, the masonry debate hinges on balancing simplicity, performance, and flexibility. Extending the Grid with masonry is tempting but risks \u003cstrong\u003eovercomplicating\u003c/strong\u003e an already robust system. A standalone \u003ccode\u003edisplay: masonry\u003c/code\u003e module offers clarity but \u003cstrong\u003eadds to CSS’s learning curve.\u003c/strong\u003e Item Flow, the newest contender, proposes a unified system that could make masonry a natural extension of Grid and Flexbox, potentially putting the debate to rest at last.\u003c/p\u003e\u003cp\u003eEach approach has trade-offs:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eGrid with Masonry\u003c/strong\u003e: Familiar but potentially clunky, with accessibility and spec concerns.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eNew Module\u003c/strong\u003e: Clean and purpose-built, but requires learning new syntax.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eItem Flow\u003c/strong\u003e: Elegant and versatile but not yet available, with ongoing debates over naming and implementation.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eItem Flow’s ability to enhance existing layouts while supporting masonry makes it a compelling option, but its success depends on browser adoption and community support.\u003c/p\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eSo, where do we land after all this? The masonry showdown boils down to three paths: the extension of masonry into CSS Grid, a standalone module for masonry, or Item Flow. Now, the question is, \u003cstrong\u003ewill CSS finally free us from JavaScript for masonry\u003c/strong\u003e, or are we still dreaming?\u003c/p\u003e\u003cp\u003eGrid’s teasing us with a taste, and a standalone module’s whispering promises — but the finish line’s unclear, and WebKit swoops in with a killer merge shorthand, Item Flow. Browser buy-in, community push, and a few more spec revisions might tell us. For now, it’s your move — test, tweak, and weigh in. The answer’s coming, one layout at a time.\u003c/p\u003e\u003ch3 id=\"references\"\u003eReferences\u003c/h3\u003e\u003cul\u003e\u003cli\u003e“\u003ca href=\"https://www.smashingmagazine.com/native-css-masonry-layout-css-grid/\"\u003eNative CSS Masonry Layout in CSS Grid\u003c/a\u003e” by Rachel Andrew\u003c/li\u003e\u003cli\u003e“\u003ca href=\"https://ishadeed.com/article/css-grid-masonry/\"\u003eShould Masonry be part of CSS Grid?\u003c/a\u003e” by Ahmad Shadeed\u003c/li\u003e\u003cli\u003e“\u003ca href=\"https://css-tricks.com/css-masonry-css-grid/\"\u003eCSS Masonry \u0026amp; CSS Grid\u003c/a\u003e” by Geoff Graham\u003c/li\u003e\u003cli\u003e“\u003ca href=\"https://css-irl.info/masonry-in-css/\"\u003eMasonry? In CSS?!\u003c/a\u003e” by Michelle Barker\u003c/li\u003e\u003cli\u003e“\u003ca href=\"https://css-tricks.com/native-css-masonry-layout-in-css-grid/\"\u003eNative CSS Masonry Layout in CSS Grids\u003c/a\u003e” by Chris Coyier\u003c/li\u003e\u003cli\u003e“\u003ca href=\"https://webkit.org/blog/16587/item-flow-part-1-a-new-unified-concept-for-layout/\"\u003eItem Flow Part 1: A Unified Concept for Layout\u003c/a\u003e” by WebKit\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(gg, yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2025-05-06T13:00:00Z",
  "modifiedTime": "2025-05-06T13:00:00Z"
}
