{
  "id": "7fe6cc22-19ca-49e2-9ada-6c94836d450a",
  "title": "Identified the Problem",
  "link": "https://thedailywtf.com/articles/identified-the-problem",
  "description": "Denise's company formed a new team. They had a lot of low-quality legacy code, and it had gotten where it was, in terms of quality, because the company had no real policy or procedures which encouraged good code. \"If it works, it ships,\" was basically the motto. They wanted to change that, and the first step was creating a new software team to kick of green-field projects with an eye towards software craftsmanship. Enter Jack. Jack was the technical lead, and Jack had a vision of good software. This started with banning ORM-generated database models. But it also didn't involve writing raw SQL either- Jack hand-forged their tables with the Visual Table Designer feature of SQL Server Management Studio. \"The advantage,\" he happily explained to Denise, \"is that we can then just generate our ORM layer right off the database. And when the database changes, we just regenerate- it's way easier than trying to build migrations.\" \"Right, but even if we're not using ORM migrations, we still want to write migration scripts for our changes to our database. We need to version control them and test them.\" \"We test them by making the change and running the test suite,\" Jack said. And what a test suite it was. There was 100% test coverage. There was test coverage on simple getter/setter methods. There was test coverage on the data transfer objects, which had no methods but getters and setters. There were unit tests for functions that did nothing more than dispatch to built-in functions. Many of the tests just verified that a result was returned, but never checked what the result was. There were unit tests on the auto-generated ORM objects. The last one, of course, meant that any time they changed the database, there was a significant risk that the test suite would fail on code that they hadn't written. Not only did they need to update the code consuming the data, the tests on that code, they also had to update the tests on the autogenerated code. Jack's magnum opus, in the whole thing, was that he designed the software with a plugin architecture. Instead of tightly coupling different implementations of various modules together, there was a plugin loader which could fetch an assembly at runtime and use that. Unfortunately, while the whole thing could have plugins, all of the abstractions leaked across module boundaries so you couldn't reasonably swap out plugins without rewriting the entire application. Instead of making a modular architecture, Jack just made starting the application wildly inefficient. Denise and her team brought their concerns to management. Conversations were had, and it fell upon Jack to school them all. Cheerfully, he said: \"Look, not everyone gets software craftsmanship, so I'm going to implement a new feature as sort of a reference implementation. If you follow the pattern I lay out, you'll have an easy time building good code!\" The new feature was an identity verification system which called for end users to upload photographs of their IDs- drivers' licenses, passports, etc. It was not a feature which should have had one developer driving the whole thing, and Jack was not implementing the entire lifecycle of data management for this; instead he was just implementing the upload feature. Jack pushed it through, out and up into production. Somehow, he short-cut past any code reviews, feature reviews, or getting anyone else to test it. He went straight to a demo in production, where he uploaded his passport and license. \"So, there you go, a reference implementation for you all.\" Denise went ahead and ran her own test, with a synthetic ID for a test user, which didn't contain any real humans' information. The file upload crashed. In fact, in an ultimate variation of \"it works on my machine,\" the only person who ever successfully used the upload feature was Jack. Of course, since the upload never worked, none of the other features, like retention policies, ever got implemented either. Now, this didn't mean the company couldn't do identity verification- they had an existing system, so they just kept redirecting users to that, instead of the new version, which didn't work. Jack went on to other features, though, because he was a clever craftsman and needed to bring his wisdom to the rest of their project. So the file upload just languished, never getting fixed. Somehow, this wasn't Jack's fault, management didn't hold him responsible, and everyone was still expected to follow the patterns he used in designing the feature to guide their own work. Until, one day, the system was breached by hackers. This, surprisingly, had nothing to do with Jack's choices- one of the admins got phished. This meant that the company needed to send out an announcement, informing users that they were breached. \"We deeply regret the breach in our identity verification system, but can confirm that no personal data for any of our customers was affected.\" Jack, of course, was not a customer, so he got a private disclosure that his passport and ID had been compromised. [Advertisement] Keep the plebs out of prod. Restrict NuGet feed privileges with ProGet. Learn more.",
  "author": "Remy Porter",
  "published": "Mon, 27 Jan 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "Feature Articles"
  ],
  "byline": "Remy Porter",
  "length": 5136,
  "excerpt": "Denise's company formed a new team. They had a lot of low-quality legacy code, and it had gotten where it was, in terms of quality, because the company had no real policy or procedures which encouraged good code. \"If it works, it ships,\" was basically the motto. They wanted to change that, and the first step was creating a new software team to kick of green-field projects with an eye towards software craftsmanship. Enter Jack. Jack was the technical lead, and Jack had a vision of good software. This started with banning ORM-generated database models. But it also didn't involve writing raw SQL either- Jack hand-forged their tables with the Visual Table Designer feature of SQL Server Management Studio.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Denise's company formed a new team. They had a lot of low-quality legacy code, and it had gotten where it was, in terms of quality, because the company had no real policy or procedures which encouraged good code. \"If it works, it ships,\" was basically the motto. They wanted to change that, and the first step was creating a new software team to kick of green-field projects with an eye towards software craftsmanship. Enter Jack. Jack was the technical lead, and Jack had a vision of good software. This started with banning ORM-generated database models. But it also didn't involve writing raw SQL either- Jack hand-forged their tables with the Visual Table Designer feature of SQL Server Management Studio. \"The advantage,\" he happily explained to Denise, \"is that we can then just generate our ORM layer right off the database. And when the database changes, we just regenerate- it's way easier than trying to build migrations.\" \"Right, but even if we're not using ORM migrations, we still want to write migration scripts for our changes to our database. We need to version control them and test them.\" \"We test them by making the change and running the test suite,\" Jack said. And what a test suite it was. There was 100% test coverage. There was test coverage on simple getter/setter methods. There was test coverage on the data transfer objects, which had no methods but getters and setters. There were unit tests for functions that did nothing more than dispatch to built-in functions. Many of the tests just verified that a result was returned, but never checked what the result was. There were unit tests on the auto-generated ORM objects. The last one, of course, meant that any time they changed the database, there was a significant risk that the test suite would fail on code that they hadn't written. Not only did they need to update the code consuming the data, the tests on that code, they also had to update the tests on the autogenerated code. Jack's magnum opus, in the whole thing, was that he designed the software with a plugin architecture. Instead of tightly coupling different implementations of various modules together, there was a plugin loader which could fetch an assembly at runtime and use that. Unfortunately, while the whole thing could have plugins, all of the abstractions leaked across module boundaries so you couldn't reasonably swap out plugins without rewriting the entire application. Instead of making a modular architecture, Jack just made starting the application wildly inefficient. Denise and her team brought their concerns to management. Conversations were had, and it fell upon Jack to school them all. Cheerfully, he said: \"Look, not everyone gets software craftsmanship, so I'm going to implement a new feature as sort of a reference implementation. If you follow the pattern I lay out, you'll have an easy time building good code!\" The new feature was an identity verification system which called for end users to upload photographs of their IDs- drivers' licenses, passports, etc. It was not a feature which should have had one developer driving the whole thing, and Jack was not implementing the entire lifecycle of data management for this; instead he was just implementing the upload feature. Jack pushed it through, out and up into production. Somehow, he short-cut past any code reviews, feature reviews, or getting anyone else to test it. He went straight to a demo in production, where he uploaded his passport and license. \"So, there you go, a reference implementation for you all.\" Denise went ahead and ran her own test, with a synthetic ID for a test user, which didn't contain any real humans' information. The file upload crashed. In fact, in an ultimate variation of \"it works on my machine,\" the only person who ever successfully used the upload feature was Jack. Of course, since the upload never worked, none of the other features, like retention policies, ever got implemented either. Now, this didn't mean the company couldn't do identity verification- they had an existing system, so they just kept redirecting users to that, instead of the new version, which didn't work. Jack went on to other features, though, because he was a clever craftsman and needed to bring his wisdom to the rest of their project. So the file upload just languished, never getting fixed. Somehow, this wasn't Jack's fault, management didn't hold him responsible, and everyone was still expected to follow the patterns he used in designing the feature to guide their own work. Until, one day, the system was breached by hackers. This, surprisingly, had nothing to do with Jack's choices- one of the admins got phished. This meant that the company needed to send out an announcement, informing users that they were breached. \"We deeply regret the breach in our identity verification system, but can confirm that no personal data for any of our customers was affected.\" Jack, of course, was not a customer, so he got a private disclosure that his passport and ID had been compromised. [Advertisement] Keep the plebs out of prod. Restrict NuGet feed privileges with ProGet. Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eDenise\u003c/strong\u003e\u0026#39;s company formed a new team. They had a lot of low-quality legacy code, and it had gotten where it was, in terms of quality, because the company had no real policy or procedures which encouraged good code. \u0026#34;If it works, it ships,\u0026#34; was basically the motto. They wanted to change that, and the first step was creating a new software team to kick of green-field projects with an eye towards \u003ca href=\"https://manifesto.softwarecraftsmanship.org/\"\u003esoftware craftsmanship\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eEnter Jack. Jack was the technical lead, and Jack had a vision of good software. This started with banning ORM-generated database models. But it also didn\u0026#39;t involve writing raw SQL either- Jack hand-forged their tables with the Visual Table Designer feature of SQL Server Management Studio.\u003c/p\u003e\n\u003cp\u003e\u0026#34;The advantage,\u0026#34; he happily explained to Denise, \u0026#34;is that we can then just generate our ORM layer right off the database. And when the database changes, we just regenerate- it\u0026#39;s way easier than trying to build migrations.\u0026#34;\u003c/p\u003e\n\u003cp\u003e\u0026#34;Right, but even if we\u0026#39;re not using ORM migrations, we still want to write migration scripts for our changes to our database. We need to version control them and test them.\u0026#34;\u003c/p\u003e\n\u003cp\u003e\u0026#34;We test them by making the change and running the test suite,\u0026#34; Jack said.\u003c/p\u003e\n\u003cp\u003eAnd what a test suite it was. There was 100% test coverage. There was test coverage on simple getter/setter methods. There was test coverage on the data transfer objects, which had no methods \u003cem\u003ebut\u003c/em\u003e getters and setters. There were unit tests for functions that did nothing more than dispatch to built-in functions. Many of the tests just verified \u003cem\u003ethat\u003c/em\u003e a result was returned, but never checked what the result was. There were unit tests on the auto-generated ORM objects.\u003c/p\u003e\n\u003cp\u003eThe last one, of course, meant that any time they changed the database, there was a significant risk that the test suite would fail on code that they hadn\u0026#39;t written. Not only did they need to update the code consuming the data, the tests on that code, they also had to update the tests on the autogenerated code.\u003c/p\u003e\n\u003cp\u003eJack\u0026#39;s magnum opus, in the whole thing, was that he designed the software with a plugin architecture. Instead of tightly coupling different implementations of various modules together, there was a plugin loader which could fetch an assembly at runtime and use that. Unfortunately, while the whole thing could have plugins, all of the abstractions leaked across module boundaries so you couldn\u0026#39;t reasonably swap out plugins without rewriting the entire application. Instead of making a modular architecture, Jack just made starting the application wildly inefficient.\u003c/p\u003e\n\u003cp\u003eDenise and her team brought their concerns to management. Conversations were had, and it fell upon Jack to school them all. Cheerfully, he said: \u0026#34;Look, not everyone gets software craftsmanship, so I\u0026#39;m going to implement a new feature as sort of a reference implementation. If you follow the pattern I lay out, you\u0026#39;ll have an easy time building good code!\u0026#34;\u003c/p\u003e\n\u003cp\u003eThe new feature was an identity verification system which called for end users to upload photographs of their IDs- drivers\u0026#39; licenses, passports, etc. It was not a feature which should have had one developer driving the whole thing, and Jack was not implementing the entire lifecycle of data management for this; instead he was just implementing the upload feature.\u003c/p\u003e\n\u003cp\u003eJack pushed it through, out and up into production. Somehow, he short-cut past any code reviews, feature reviews, or getting anyone else to test it. He went straight to a demo in production, where he uploaded his passport and license. \u0026#34;So, there you go, a reference implementation for you all.\u0026#34;\u003c/p\u003e\n\u003cp\u003eDenise went ahead and ran her own test, with a synthetic ID for a test user, which didn\u0026#39;t contain any real humans\u0026#39; information. The file upload crashed. In fact, in an ultimate variation of \u0026#34;it works on my machine,\u0026#34; the only person who ever successfully used the upload feature was Jack. Of course, since the upload never worked, none of the other features, like retention policies, ever got implemented either.\u003c/p\u003e\n\u003cp\u003eNow, this didn\u0026#39;t mean the company couldn\u0026#39;t do identity verification- they had an existing system, so they just kept redirecting users to that, instead of the new version, which didn\u0026#39;t work.\u003c/p\u003e\n\u003cp\u003eJack went on to other features, though, because he was a clever craftsman and needed to bring his wisdom to the rest of their project. So the file upload just languished, never getting fixed. Somehow, this wasn\u0026#39;t Jack\u0026#39;s fault, management didn\u0026#39;t hold him responsible, and everyone was still expected to follow the patterns he used in designing the feature to guide their own work.\u003c/p\u003e\n\u003cp\u003eUntil, one day, the system was breached by hackers. This, surprisingly, had nothing to do with Jack\u0026#39;s choices- one of the admins got phished. This meant that the company needed to send out an announcement, informing users that they were breached. \u0026#34;We deeply regret the breach in our identity verification system, but can confirm that no personal data for any of our customers was affected.\u0026#34;\u003c/p\u003e\n\u003cp\u003eJack, of course, was not a customer, so he got a private disclosure that his passport and ID had been compromised.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tKeep the plebs out of prod. Restrict NuGet feed privileges with ProGet. \u003ca href=\"https://inedo.com/proget/private-nuget-server?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=PlebsFooter\u0026amp;utm_campaign=Cyclops2020\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-01-27T06:30:00Z",
  "modifiedTime": null
}
