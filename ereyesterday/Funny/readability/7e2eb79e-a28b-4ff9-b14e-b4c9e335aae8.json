{
  "id": "7e2eb79e-a28b-4ff9-b14e-b4c9e335aae8",
  "title": "CodeSOD: What a More And",
  "link": "https://thedailywtf.com/articles/what-a-more-and",
  "description": "Today, we're going to start with the comment before the method. /** * The topology type of primitives to render. (optional) * Default: 4 * Valid values: [0, 1, 2, 3, 4, 5, 6] * * @param mode The mode to set * @throws IllegalArgumentException If the given value does not meet * the given constraints * */ This comes from Krzysztof. As much as I dislike these JavaDoc style comments (they mostly repeat information I can get from the signature!), this one is promising. It tells me the range of values, and what happens when I exceed that range, what the default is, and it tells me that the value is optional. In short, from the comment alone I have a good picture of what the implementation looks like. With some caveats, mind you- because that's a set of magic numbers in there. No constants, no enum, just magic numbers. That's worrying. Let's look at the implementation. public void setMode(Integer mode) { if (mode == null) { this.mode = mode; return ; } if (((((((mode!= 0)\u0026\u0026(mode!= 1))\u0026\u0026(mode!= 2))\u0026\u0026(mode!= 3))\u0026\u0026(mode!= 4))\u0026\u0026(mode!= 5))\u0026\u0026(mode!= 6)) { throw new IllegalArgumentException(((\"Invalid value for mode: \"+ mode)+ \", valid: [0, 1, 2, 3, 4, 5, 6]\")); } this.mode = mode; } This code isn't terrible. But there are all sorts of small details which flummox me. Now, again, I want to stress, had they used enums this method would be much simpler. But fine, maybe they had a good reason for not doing that. Let's set that aside. The obvious ugly moment here is that if condition. Did they not understand that and is a commutative operation? Or did they come to Java from LISP and miss their parentheses? Then, of course, there's the first if statement- the null check. Honestly, we could have just put that into the chain of the if condition below, and the behavior would have been the same, or they could have just used an Optional type, which is arguably the \"right\" option here. But now we're drifting into the same space as enums- if only they'd used the core language features, this would be simpler. Let's focus, instead, on one last odd choice: how they use whitespace. mode!= 0. This, more than anything, makes me think they are coming to Java from some other language. Something that uses glyphs in unusual ways, because why else would the operator only get one space on one side of it? Which also makes me think the null check was written by someone else- because they're inconsistent with it there. So no, this code isn't terrible, but it does make me wonder a little bit about how it came to be. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "author": "Remy Porter",
  "published": "Wed, 27 Nov 2024 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 2862,
  "excerpt": "Today, we're going to start with the comment before the method. /** * The topology type of primitives to render. (optional)\u003cbr\u003e * Default: 4\u003cbr\u003e * Valid values: [0, 1, 2, 3, 4, 5, 6] * * @param mode The mode to set * @throws IllegalArgumentException If the given value does not meet * the given constraints * */",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Today, we're going to start with the comment before the method. /** * The topology type of primitives to render. (optional)\u003cbr\u003e * Default: 4\u003cbr\u003e * Valid values: [0, 1, 2, 3, 4, 5, 6] * * @param mode The mode to set * @throws IllegalArgumentException If the given value does not meet * the given constraints * */ This comes from Krzysztof. As much as I dislike these JavaDoc style comments (they mostly repeat information I can get from the signature!), this one is promising. It tells me the range of values, and what happens when I exceed that range, what the default is, and it tells me that the value is optional. In short, from the comment alone I have a good picture of what the implementation looks like. With some caveats, mind you- because that's a set of magic numbers in there. No constants, no enum, just magic numbers. That's worrying. Let's look at the implementation. public void setMode(Integer mode) { if (mode == null) { this.mode = mode; return ; } if (((((((mode!= 0)\u0026\u0026(mode!= 1))\u0026\u0026(mode!= 2))\u0026\u0026(mode!= 3))\u0026\u0026(mode!= 4))\u0026\u0026(mode!= 5))\u0026\u0026(mode!= 6)) { throw new IllegalArgumentException(((\"Invalid value for mode: \"+ mode)+ \", valid: [0, 1, 2, 3, 4, 5, 6]\")); } this.mode = mode; } This code isn't terrible. But there are all sorts of small details which flummox me. Now, again, I want to stress, had they used enums this method would be much simpler. But fine, maybe they had a good reason for not doing that. Let's set that aside. The obvious ugly moment here is that if condition. Did they not understand that and is a commutative operation? Or did they come to Java from LISP and miss their parentheses? Then, of course, there's the first if statement- the null check. Honestly, we could have just put that into the chain of the if condition below, and the behavior would have been the same, or they could have just used an Optional type, which is arguably the \"right\" option here. But now we're drifting into the same space as enums- if only they'd used the core language features, this would be simpler. Let's focus, instead, on one last odd choice: how they use whitespace. mode!= 0. This, more than anything, makes me think they are coming to Java from some other language. Something that uses glyphs in unusual ways, because why else would the operator only get one space on one side of it? Which also makes me think the null check was written by someone else- because they're inconsistent with it there. So no, this code isn't terrible, but it does make me wonder a little bit about how it came to be. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eToday, we\u0026#39;re going to start with the comment before the method.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    \u003cspan\u003e/**\n     * The topology type of primitives to render. (optional)\u0026lt;br\u0026gt;\n     * Default: 4\u0026lt;br\u0026gt;\n     * Valid values: [0, 1, 2, 3, 4, 5, 6]\n     *\n     * \u003cspan\u003e@param\u003c/span\u003e mode The mode to set\n     * \u003cspan\u003e@throws\u003c/span\u003e IllegalArgumentException If the given value does not meet\n     * the given constraints\n     *\n     */\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis comes from \u003cstrong\u003eKrzysztof\u003c/strong\u003e. As much as I dislike these JavaDoc style comments (they mostly repeat information I can get from the signature!), this one is promising. It tells me the range of values, and what happens when I exceed that range, what the default is, and it tells me that the value is optional.\u003c/p\u003e\n\u003cp\u003eIn short, from the comment alone I have a good picture of what the implementation looks like.\u003c/p\u003e\n\u003cp\u003eWith some caveats, mind you- because that\u0026#39;s a set of magic numbers in there. No constants, no enum, just magic numbers. That\u0026#39;s worrying.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s look at the implementation.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003esetMode\u003c/span\u003e\u003cspan\u003e(Integer mode)\u003c/span\u003e {\n        \u003cspan\u003eif\u003c/span\u003e (mode == \u003cspan\u003enull\u003c/span\u003e) {\n            \u003cspan\u003ethis\u003c/span\u003e.mode = mode;\n            \u003cspan\u003ereturn\u003c/span\u003e ;\n        }\n        \u003cspan\u003eif\u003c/span\u003e (((((((mode!= \u003cspan\u003e0\u003c/span\u003e)\u0026amp;\u0026amp;(mode!= \u003cspan\u003e1\u003c/span\u003e))\u0026amp;\u0026amp;(mode!= \u003cspan\u003e2\u003c/span\u003e))\u0026amp;\u0026amp;(mode!= \u003cspan\u003e3\u003c/span\u003e))\u0026amp;\u0026amp;(mode!= \u003cspan\u003e4\u003c/span\u003e))\u0026amp;\u0026amp;(mode!= \u003cspan\u003e5\u003c/span\u003e))\u0026amp;\u0026amp;(mode!= \u003cspan\u003e6\u003c/span\u003e)) {\n            \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eIllegalArgumentException\u003c/span\u003e(((\u003cspan\u003e\u0026#34;Invalid value for mode: \u0026#34;\u003c/span\u003e+ mode)+ \u003cspan\u003e\u0026#34;, valid: [0, 1, 2, 3, 4, 5, 6]\u0026#34;\u003c/span\u003e));\n        }\n        \u003cspan\u003ethis\u003c/span\u003e.mode = mode;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code isn\u0026#39;t terrible. But there are all sorts of small details which flummox me.\u003c/p\u003e\n\u003cp\u003eNow, again, I want to stress, \u003cem\u003ehad they used enums\u003c/em\u003e this method would be much simpler. But fine, maybe they had a good reason for not doing that. Let\u0026#39;s set that aside.\u003c/p\u003e\n\u003cp\u003eThe obvious ugly moment here is that \u003ccode\u003eif\u003c/code\u003e condition. Did they not understand that and is a commutative operation? Or did they come to Java from LISP and miss their parentheses?\u003c/p\u003e\n\u003cp\u003eThen, of course, there\u0026#39;s the first if statement- the \u003ccode\u003enull\u003c/code\u003e check. Honestly, we could have just put that into the chain of the \u003ccode\u003eif\u003c/code\u003e condition below, and the behavior would have been the same, \u003cem\u003eor\u003c/em\u003e they could have just used an \u003ccode\u003eOptional\u003c/code\u003e type, which is arguably the \u0026#34;right\u0026#34; option here. But now we\u0026#39;re drifting into the same space as enums- if only they\u0026#39;d used the core language features, this would be simpler.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s focus, instead, on one last odd choice: how they use whitespace. \u003ccode\u003emode!= 0\u003c/code\u003e. This, more than anything, makes me think they are coming to Java from some other language. Something that uses glyphs in unusual ways, because why else would the operator only get one space on one side of it? Which also makes me think the null check was written by someone else- because they\u0026#39;re inconsistent with it there.\u003c/p\u003e\n\u003cp\u003eSo no, this code isn\u0026#39;t terrible, but it does make me wonder a little bit about how it came to be.\u003c/p\u003e\n\u003cp\u003e\n\t[Advertisement] \u003cb\u003ePlan Your .NET 9 Migration with Confidence\u003c/b\u003e\u003cbr/\u003eYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. \u003cb\u003e\u003ca href=\"https://inedo.com/support/whitepapers/dotnet-guide?utm_campaign=dotnet\u0026amp;utm_source=tdwtf-footer\"\u003eDownload Free Guide Now!\u003c/a\u003e\u003c/b\u003e\n\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2024-11-27T06:30:00Z",
  "modifiedTime": null
}
