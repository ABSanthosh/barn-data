{
  "id": "e965c365-bd6f-45d6-82a8-213e31c50b6e",
  "title": "CodeSOD: My Identification",
  "link": "https://thedailywtf.com/articles/my-identification",
  "description": "Bejamin's team needed to generate a unique session ID value that can't easily be guessed. The traditional way of doing this would be to generate cryptographically secure random bytes. Most languages, including PHP, have a solution for doing that. But you could also do this: protected function _createId() { $id = 0; while (strlen($id) \u003c 32) { $id .= mt_rand(0, mt_getrandmax()); } $id = md5(uniqid($id, true)); return $id; } Now, mt_rand is not cryptographically secure. They generate a random number (of arbitrary size) and concatenate it to a string. When the string is 32 characters long (including a leading zero), we call that enough. This is not generating random bytes. To the contrary, the bytes it's generating are very not random, seeing as they're constrained to a character between 0 and 9. We then pass that through the uniqid function. Now, uniqid also generates a non-cryptographically secure unique identifier. Here, we're specifying our large number is the prefix to that unique ID, and asking for more randomness to be added (the true parameter). This is better than what they did with the while loop above, though still not the \"correct\" way to do it. Finally, we pass it through the md5 algorithm to reduce it to a hash, because we just love hash collisions. It's impressive that, given a chance to make a choice about security-related features, they were able to make every single wrong choice. This is also why you don't implement this stuff yourself. There are far more ways to get it wrong than there are ways to get it right. [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "author": "Remy Porter",
  "published": "Wed, 08 Jan 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 2154,
  "excerpt": "Bejamin's team needed to generate a unique session ID value that can't easily be guessed. The traditional way of doing this would be to generate cryptographically secure random bytes. Most languages, including PHP, have a solution for doing that. But you could also do this:",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2025-01-08 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. Bejamin's team needed to generate a unique session ID value that can't easily be guessed. The traditional way of doing this would be to generate cryptographically secure random bytes. Most languages, including PHP, have a solution for doing that. But you could also do this: protected function _createId() { $id = 0; while (strlen($id) \u003c 32) { $id .= mt_rand(0, mt_getrandmax()); } $id = md5(uniqid($id, true)); return $id; } Now, mt_rand is not cryptographically secure. They generate a random number (of arbitrary size) and concatenate it to a string. When the string is 32 characters long (including a leading zero), we call that enough. This is not generating random bytes. To the contrary, the bytes it's generating are very not random, seeing as they're constrained to a character between 0 and 9. We then pass that through the uniqid function. Now, uniqid also generates a non-cryptographically secure unique identifier. Here, we're specifying our large number is the prefix to that unique ID, and asking for more randomness to be added (the true parameter). This is better than what they did with the while loop above, though still not the \"correct\" way to do it. Finally, we pass it through the md5 algorithm to reduce it to a hash, because we just love hash collisions. It's impressive that, given a chance to make a choice about security-related features, they were able to make every single wrong choice. This is also why you don't implement this stuff yourself. There are far more ways to get it wrong than there are ways to get it right. [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-01-08\"\u003e2025-01-08\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10822\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eBejamin\u003c/strong\u003e\u0026#39;s team needed to generate a unique session ID value that can\u0026#39;t easily be guessed. The traditional way of doing this would be to generate cryptographically secure random bytes. Most languages, including PHP, have a solution for doing that.\u003c/p\u003e\n\u003cp\u003eBut you could also do this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprotected\u003c/span\u003e \u003cspan\u003e\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003e_createId\u003c/span\u003e(\u003cspan\u003e\u003c/span\u003e)\n\u003c/span\u003e{\n        \u003cspan\u003e$id\u003c/span\u003e = \u003cspan\u003e0\u003c/span\u003e;\n        \u003cspan\u003ewhile\u003c/span\u003e (\u003cspan\u003estrlen\u003c/span\u003e(\u003cspan\u003e$id\u003c/span\u003e) \u0026lt; \u003cspan\u003e32\u003c/span\u003e)\n        {\n                \u003cspan\u003e$id\u003c/span\u003e .= \u003cspan\u003emt_rand\u003c/span\u003e(\u003cspan\u003e0\u003c/span\u003e, \u003cspan\u003emt_getrandmax\u003c/span\u003e());\n        }\n\n        \u003cspan\u003e$id\u003c/span\u003e = \u003cspan\u003emd5\u003c/span\u003e(\u003cspan\u003euniqid\u003c/span\u003e(\u003cspan\u003e$id\u003c/span\u003e, \u003cspan\u003etrue\u003c/span\u003e));\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e$id\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, \u003ccode\u003emt_rand\u003c/code\u003e is \u003cem\u003enot\u003c/em\u003e cryptographically secure. They generate a random number (of arbitrary size) and concatenate it to a string. When the string is 32 characters long (including a leading zero), we call that enough.\u003c/p\u003e\n\u003cp\u003eThis is not generating \u003cem\u003erandom bytes\u003c/em\u003e. To the contrary, the bytes it\u0026#39;s generating are very \u003cem\u003enot\u003c/em\u003e random, seeing as they\u0026#39;re constrained to a character between 0 and 9.\u003c/p\u003e\n\u003cp\u003eWe then pass that through the \u003ccode\u003euniqid\u003c/code\u003e function. Now, \u003ccode\u003euniqid\u003c/code\u003e also generates a non-cryptographically secure unique identifier. Here, we\u0026#39;re specifying our large number is the prefix to that unique ID, and asking for more randomness to be added (the \u003ccode\u003etrue\u003c/code\u003e parameter). This is better than what they did with the while loop above, though still not the \u0026#34;correct\u0026#34; way to do it.\u003c/p\u003e\n\u003cp\u003eFinally, we pass it through the md5 algorithm to reduce it to a hash, because we just love hash collisions.\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s impressive that, given a chance to make a choice about security-related features, they were able to make \u003cem\u003eevery single wrong choice\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThis is also why you \u003cem\u003edon\u0026#39;t implement this stuff yourself\u003c/em\u003e. There are far more ways to get it wrong than there are ways to get it right.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tKeep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.\u003ca href=\"https://inedo.com/proget?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=PlebsFooter\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2025-01-08T06:30:00Z",
  "modifiedTime": null
}
