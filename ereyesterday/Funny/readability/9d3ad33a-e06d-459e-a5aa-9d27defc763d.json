{
  "id": "9d3ad33a-e06d-459e-a5aa-9d27defc763d",
  "title": "CodeSOD: Brushing Up",
  "link": "https://thedailywtf.com/articles/brushing-up",
  "description": "Keige inherited some code which seems to be part of a drawing application. It can load brush textures from image files- at least, sometimes it can. static public Brush GetImageBrush(string serviceCode, string imageName, string language) { Brush BorderChannelGroupBrush; BitmapImage image = null; int point = imageName.LastIndexOf('.'); string languageImagename = imageName.Substring(0, point) + \"-\" + language + imageName.Substring(point); try { image = FrameWork.ServicePageImageUrlOnContentServer(serviceCode, languageImagename); } catch { } if (image == null) { try { image = FrameWork.ServicePageImageUrlOnContentServer(serviceCode, imageName); } catch { } } if (image != null) { BorderChannelGroupBrush = new ImageBrush(image); } else { BorderChannelGroupBrush = Brushes.White; } return BorderChannelGroupBrush; } There are a lot of interesting \"choices\" made in this code. First, there's the old \"find the last '.'\" approach of grabbing the file extension. Which is fine, but there's a built-in which handles cases like when there isn't an extension better. I think, in this case, it probably doesn't hurt anything. But the real fun starts with our first attempt at loading our image. We jam a localized language string in the middle of the file name (foo-en.jpg), and try and fetch that from the server. If this fails, it throws an exception… which we ignore. But we don't fully ignore it! If the exception was thrown, image doesn't get set, so it's still null. So we do a null check, and repeat our empty exception handler. If the image is still null after that, we default to a \"Brushes.White\" image. It's all a very awkward and weird way to handle errors. The null checks bring with them the whiff of a C programmer checking return codes, but I don't actually think that's what happened here. I think this was just someone not fully understanding the problem they were trying to solve or the tools available to them. Or maybe they just really didn't want to deal with nesting. It's hardly the worst code, but it does just leave me feeling weird when I look at it. [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "author": "Remy Porter",
  "published": "Wed, 15 Jan 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 2650,
  "excerpt": "Keige inherited some code which seems to be part of a drawing application. It can load brush textures from image files- at least, sometimes it can. static public Brush GetImageBrush(string serviceCode, string imageName, string language) { Brush BorderChannelGroupBrush; BitmapImage image = null; int point = imageName.LastIndexOf('.'); string languageImagename = imageName.Substring(0, point) + \"-\" + language + imageName.Substring(point); try { image = FrameWork.ServicePageImageUrlOnContentServer(serviceCode, languageImagename); } catch { } if (image == null) { try { image = FrameWork.ServicePageImageUrlOnContentServer(serviceCode, imageName); } catch { } } if (image != null) { BorderChannelGroupBrush = new ImageBrush(image); } else { BorderChannelGroupBrush = Brushes.White; } return BorderChannelGroupBrush; }",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2025-01-15 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. Keige inherited some code which seems to be part of a drawing application. It can load brush textures from image files- at least, sometimes it can. static public Brush GetImageBrush(string serviceCode, string imageName, string language) { Brush BorderChannelGroupBrush; BitmapImage image = null; int point = imageName.LastIndexOf('.'); string languageImagename = imageName.Substring(0, point) + \"-\" + language + imageName.Substring(point); try { image = FrameWork.ServicePageImageUrlOnContentServer(serviceCode, languageImagename); } catch { } if (image == null) { try { image = FrameWork.ServicePageImageUrlOnContentServer(serviceCode, imageName); } catch { } } if (image != null) { BorderChannelGroupBrush = new ImageBrush(image); } else { BorderChannelGroupBrush = Brushes.White; } return BorderChannelGroupBrush; } There are a lot of interesting \"choices\" made in this code. First, there's the old \"find the last '.'\" approach of grabbing the file extension. Which is fine, but there's a built-in which handles cases like when there isn't an extension better. I think, in this case, it probably doesn't hurt anything. But the real fun starts with our first attempt at loading our image. We jam a localized language string in the middle of the file name (foo-en.jpg), and try and fetch that from the server. If this fails, it throws an exception… which we ignore. But we don't fully ignore it! If the exception was thrown, image doesn't get set, so it's still null. So we do a null check, and repeat our empty exception handler. If the image is still null after that, we default to a \"Brushes.White\" image. It's all a very awkward and weird way to handle errors. The null checks bring with them the whiff of a C programmer checking return codes, but I don't actually think that's what happened here. I think this was just someone not fully understanding the problem they were trying to solve or the tools available to them. Or maybe they just really didn't want to deal with nesting. It's hardly the worst code, but it does just leave me feeling weird when I look at it. [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-01-15\"\u003e2025-01-15\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10827\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eKeige\u003c/strong\u003e inherited some code which seems to be part of a drawing application. It can load brush textures from image files- at least, sometimes it can.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003epublic\u003c/span\u003e Brush \u003cspan\u003eGetImageBrush\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003estring\u003c/span\u003e serviceCode, \u003cspan\u003estring\u003c/span\u003e imageName, \u003cspan\u003estring\u003c/span\u003e language\u003c/span\u003e)\u003c/span\u003e\n{\n\tBrush BorderChannelGroupBrush;\n\tBitmapImage image = \u003cspan\u003enull\u003c/span\u003e;\n\n\t\u003cspan\u003eint\u003c/span\u003e point = imageName.LastIndexOf(\u003cspan\u003e\u0026#39;.\u0026#39;\u003c/span\u003e);\n\t\u003cspan\u003estring\u003c/span\u003e languageImagename = imageName.Substring(\u003cspan\u003e0\u003c/span\u003e, point) + \u003cspan\u003e\u0026#34;-\u0026#34;\u003c/span\u003e + language + imageName.Substring(point);\n\n\t\u003cspan\u003etry\u003c/span\u003e\n\t{\n\t\timage = FrameWork.ServicePageImageUrlOnContentServer(serviceCode, languageImagename);\n\t}\n\t\u003cspan\u003ecatch\u003c/span\u003e { }\n\n\t\u003cspan\u003eif\u003c/span\u003e (image == \u003cspan\u003enull\u003c/span\u003e)\n\t{\n\t\t\u003cspan\u003etry\u003c/span\u003e\n\t\t{\n\t\t\timage = FrameWork.ServicePageImageUrlOnContentServer(serviceCode, imageName);\n\t\t}\n\t\t\u003cspan\u003ecatch\u003c/span\u003e { }\n\t}\n\n\t\u003cspan\u003eif\u003c/span\u003e (image != \u003cspan\u003enull\u003c/span\u003e)\n\t{\n\t\tBorderChannelGroupBrush = \u003cspan\u003enew\u003c/span\u003e ImageBrush(image);\n\t}\n\t\u003cspan\u003eelse\u003c/span\u003e\n\t{\n\t\tBorderChannelGroupBrush = Brushes.White;\n\t}\n\t\u003cspan\u003ereturn\u003c/span\u003e BorderChannelGroupBrush;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are a lot of interesting \u0026#34;choices\u0026#34; made in this code. First, there\u0026#39;s the old \u0026#34;find the last \u0026#39;.\u0026#39;\u0026#34; approach of grabbing the file extension. Which is \u003cem\u003efine\u003c/em\u003e, but \u003ca href=\"https://learn.microsoft.com/en-us/dotnet/api/system.io.path.getextension?view=net-9.0\"\u003ethere\u0026#39;s a built-in\u003c/a\u003e which handles cases like when there \u003cem\u003eisn\u0026#39;t\u003c/em\u003e an extension better. I think, in this case, it probably doesn\u0026#39;t hurt anything.\u003c/p\u003e\n\u003cp\u003eBut the real fun starts with our first attempt at loading our image. We jam a localized language string in the middle of the file name (\u003ccode\u003efoo-en.jpg\u003c/code\u003e), and try and fetch that from the server. If this fails, it throws an exception… which we ignore.\u003c/p\u003e\n\u003cp\u003eBut we don\u0026#39;t fully ignore it! If the exception was thrown, \u003ccode\u003eimage\u003c/code\u003e doesn\u0026#39;t get set, so it\u0026#39;s still null. So we do a null check, and repeat our empty exception handler. If the image is still null after that, we default to a \u0026#34;Brushes.White\u0026#34; image.\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s all a very awkward and weird way to handle errors. The null checks bring with them the whiff of a C programmer checking return codes, but I don\u0026#39;t actually think that\u0026#39;s what happened here. I think this was just someone not fully understanding the problem they were trying to solve or the tools available to them. Or maybe they just really didn\u0026#39;t want to deal with nesting.\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s hardly the worst code, but it does just leave me feeling \u003cem\u003eweird\u003c/em\u003e when I look at it.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tKeep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.\u003ca href=\"https://inedo.com/proget?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=PlebsFooter\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-01-15T06:30:00Z",
  "modifiedTime": null
}
