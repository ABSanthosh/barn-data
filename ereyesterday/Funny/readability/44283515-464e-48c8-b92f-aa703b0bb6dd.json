{
  "id": "44283515-464e-48c8-b92f-aa703b0bb6dd",
  "title": "Representative Line: Time for Identification",
  "link": "https://thedailywtf.com/articles/time-for-identification",
  "description": "If you need a unique ID, UUIDs provide a variety of options. It's worth noting that variants 1, 2, and 7 all incorporate a timestamp into the UUID. In the case of variant 7, this has the benefit of making the UUID sortable, which can be convenient in many cases (v1/v2 incorporate a MAC address which means that they're sortable if generated with the same NIC). I bring this up because Dave inherited some code written by a \"guru\". Said guru was working before UUIDv7 was a standard, but also didn't have any problems that required sortable UUIDs, and thus had no real reason to use timestamp based UUIDs. They just needed some random identifier and, despite using C#, didn't use the UUID functions built in to the framework. No, they instead did this: string uniqueID = String.Format(\"{0:d9}\", (DateTime.UtcNow.Ticks / 10) % 1000000000); A Tick is 100 nanoseconds. We divide that by ten, mod by a billion, and then call that our unique identifier. This is, as you might guess, not unique. First there's the possibility of timestamp collisions: generating two of these too close together in time would collide. Second, the math is just complete nonsense. We divide Ticks by ten (converting hundreds of nanoseconds into thousands of nanoseconds), then we mod by a billion. So every thousand seconds we loop and have a risk of collision again? Maybe, maybe, these are short-lived IDs and a thousand seconds is plenty of time. But even if that's true, none of this is a good way to do that. I suppose the saving grace is they use UtcNow and not Now, thus avoiding situations where collisions also happen because of time zones? [Advertisement] BuildMaster allows you to create a self-service release management platform that allows different teams to manage their applications. Explore how!",
  "author": "Remy Porter",
  "published": "Wed, 26 Mar 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "Representative Line"
  ],
  "byline": "Remy Porter",
  "length": 2059,
  "excerpt": "If you need a unique ID, UUIDs provide a variety of options. It's worth noting that variants 1, 2, and 7 all incorporate a timestamp into the UUID. In the case of variant 7, this has the benefit of making the UUID sortable, which can be convenient in many cases (v1/v2 incorporate a MAC address which means that they're sortable if generated with the same NIC). I bring this up because Dave inherited some code written by a \"guru\". Said guru was working before UUIDv7 was a standard, but also didn't have any problems that required sortable UUIDs, and thus had no real reason to use timestamp based UUIDs. They just needed some random identifier and, despite using C#, didn't use the UUID functions built in to the framework. No, they instead did this:",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in Representative Line on 2025-03-26 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. If you need a unique ID, UUIDs provide a variety of options. It's worth noting that variants 1, 2, and 7 all incorporate a timestamp into the UUID. In the case of variant 7, this has the benefit of making the UUID sortable, which can be convenient in many cases (v1/v2 incorporate a MAC address which means that they're sortable if generated with the same NIC). I bring this up because Dave inherited some code written by a \"guru\". Said guru was working before UUIDv7 was a standard, but also didn't have any problems that required sortable UUIDs, and thus had no real reason to use timestamp based UUIDs. They just needed some random identifier and, despite using C#, didn't use the UUID functions built in to the framework. No, they instead did this: string uniqueID = String.Format(\"{0:d9}\", (DateTime.UtcNow.Ticks / 10) % 1000000000); A Tick is 100 nanoseconds. We divide that by ten, mod by a billion, and then call that our unique identifier. This is, as you might guess, not unique. First there's the possibility of timestamp collisions: generating two of these too close together in time would collide. Second, the math is just complete nonsense. We divide Ticks by ten (converting hundreds of nanoseconds into thousands of nanoseconds), then we mod by a billion. So every thousand seconds we loop and have a risk of collision again? Maybe, maybe, these are short-lived IDs and a thousand seconds is plenty of time. But even if that's true, none of this is a good way to do that. I suppose the saving grace is they use UtcNow and not Now, thus avoiding situations where collisions also happen because of time zones? [Advertisement] BuildMaster allows you to create a self-service release management platform that allows different teams to manage their applications. Explore how!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/representative-line\"\u003eRepresentative Line\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-03-26\"\u003e2025-03-26\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10878\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eIf you need a unique ID, \u003ca href=\"https://en.wikipedia.org/wiki/Universally_unique_identifier#Standards\"\u003eUUIDs\u003c/a\u003e provide a variety of options. It\u0026#39;s worth noting that variants 1, 2, and 7 all incorporate a timestamp into the UUID. In the case of variant 7, this has the benefit of making the UUID sortable, which can be convenient in many cases (v1/v2 incorporate a MAC address which means that they\u0026#39;re sortable if generated with the same NIC).\u003c/p\u003e\n\u003cp\u003eI bring this up because \u003cstrong\u003eDave\u003c/strong\u003e inherited some code written by a \u0026#34;guru\u0026#34;. Said guru was working before UUIDv7 was a standard, but also didn\u0026#39;t have any problems that required sortable UUIDs, and thus had no real reason to use timestamp based UUIDs. They just needed some random identifier and, despite using C#, didn\u0026#39;t use the UUID functions built in to the framework. No, they instead did this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estring\u003c/span\u003e uniqueID = String.Format(\u003cspan\u003e\u0026#34;{0:d9}\u0026#34;\u003c/span\u003e, (DateTime.UtcNow.Ticks / \u003cspan\u003e10\u003c/span\u003e) % \u003cspan\u003e1000000000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA \u003ccode\u003eTick\u003c/code\u003e is 100 nanoseconds. We divide that by ten, mod by a billion, and then call that our unique identifier.\u003c/p\u003e\n\u003cp\u003eThis is, as you might guess, \u003cem\u003enot unique\u003c/em\u003e. First there\u0026#39;s the possibility of timestamp collisions: generating two of these too close together in time would collide. Second, the math is just complete nonsense. We divide \u003ccode\u003eTicks\u003c/code\u003e by ten (converting hundreds of nanoseconds into thousands of nanoseconds), then we mod by a billion. So every thousand seconds we loop and have a risk of collision again?\u003c/p\u003e\n\u003cp\u003eMaybe, \u003cem\u003emaybe\u003c/em\u003e, these are short-lived IDs and a thousand seconds is plenty of time. But even if that\u0026#39;s true, none of this is a good way to do that.\u003c/p\u003e\n\u003cp\u003eI suppose the saving grace is they use \u003ccode\u003eUtcNow\u003c/code\u003e and not \u003ccode\u003eNow\u003c/code\u003e, thus avoiding situations where collisions also happen because of time zones?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/buildmaster-icon.png\"/\u003e [Advertisement] \n\t\u003ca href=\"https://inedo.com/BuildMaster?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Self_Service\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eBuildMaster\u003c/a\u003e allows you to create a self-service release management platform that allows different teams to manage their applications. \u003ca href=\"https://inedo.com/BuildMaster/download?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Self_Service\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eExplore how!\u003c/a\u003e \n\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2025-03-26T06:30:00Z",
  "modifiedTime": null
}
