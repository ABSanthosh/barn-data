{
  "id": "3d4f9ca4-33e7-4aa1-8fc0-58efda457116",
  "title": "More accurate DevTools performance debugging using real-world data",
  "link": "https://developer.chrome.com/blog/devtools-grounded-real-world?hl=en",
  "description": "Learn about new DevTools features like CPU throttling calibration to help you base your performance debugging decisions on data from the real world",
  "author": "",
  "published": "Fri, 04 Apr 2025 07:00:00 GMT",
  "source": "https://developer.chrome.com/static/blog/feed.xml",
  "categories": null,
  "byline": "",
  "length": 10191,
  "excerpt": "Learn about new DevTools features like CPU throttling calibration to help you base your performance debugging decisions on data from the real world",
  "siteName": "Chrome for Developers",
  "favicon": "https://www.gstatic.com/devrel-devsite/prod/v4fc9d85e6ea95f79bd6a196e3172f0f1dad2b944d8938b8bba07317f8184a4c6/chrome/images/favicon.png",
  "text": "Published: April 04, 2025 Fixing performance issues in the real world means bridging the gap between your development environment and the diverse performance experiences of your users. In this post, we'll look at new features in Chrome DevTools that help you base more of your performance debugging decisions on real data rather than guesswork. Calibrating expectations Starting in Chrome 134, DevTools includes CPU throttling calibration, a new tool to remove the uncertainty of picking the right CPU throttling level. Run the calibration once, and DevTools will generate \"low-tier mobile\" and \"mid-tier mobile\" throttling presets for you, specific to your development machine. A common mismatch in web performance work is that, as developers, we often build sites on fast desktop devices while many of our users are on more modest mobile devices. Tracking down a performance problem can be tricky when it only happens on a device with a much slower CPU. The gold standard is remote debugging on a real mobile device, but for almost a decade Chrome has also supported CPU throttling for fast and lightweight iteration cycles during development. But which CPU throttling level should you choose? 4x? 20x? How do you know which best matches the type of devices you know visit your site? And how does the speed of your own machine change that decision, whether you're on a high-end workstation or using an 8-year-old Chromebook on the go? The throttling calibration process When the Performance panel is opened, the Environment settings has a drop-down to set the CPU throttling level. If you haven't run the calibration before, you'll see two disabled options under \"Calibrated presets\" in the drop-down, and a Calibrateâ€¦ option at the very bottom. Selecting this will bring you to the CPU throttling presets in Settings (you can also go there directly). Click the Calibrate button Click Continue when it warns you that it will briefly navigate away from the current page A quick benchmark will run to measure the speed of your current machine, and calibration is complete Screen recording of running the CPU throttling process The throttling options will now be populated with the calibrated presets for low-tier and mid-tier devices. These two presets should be enough for most development use cases, and we generally recommend the \"mid-tier\" preset as matching a \"typical\" mobile device seen on the web. If you know that many of your users have even slower devices or a performance issue only typically occurs for those users, the \"low-tier\" option should be slow enough to capture even the long tail of low-end devices. Finally, if you think something went wrong with the calibration or your local machine has changed in some way, you can always recalibrate through the throttling drop-down or in settings, which will re-run the benchmark and update the presets. How CPU throttling works in DevTools If you've ever been curious about how CPU throttling works in DevTools, the idea is relatively straightforward. When you turn on throttling for a tab, Chrome launches a separate throttling thread that interrupts and suspends the tab's main thread for frequent short bursts. The goal is to suspend the main thread long enough in total that the duration of any given task goes up by the throttling factor. For example, at 4x CPU throttling, the main thread will end up suspended approximately 75% of the time, which makes any main-thread work take four times as long to complete. The benefit of this approach is that it's mostly transparent to the rest of Chrome; there's no specialized code needed to slow down JavaScript, or layout, or each of the many other types of work a browser needs to do. All work on the main thread takes longer because the thread itself is only allowed to execute for a fraction of the time. When CPU throttling acts like a real mobile device As a result, many types of mobile CPU-bound work are simulated well by CPU throttling. If an interaction triggers javascript and layout, for example, it has a good chance of resulting in executing very similarly to how it would have run on a mobile device. Consider a task triggered by the click of a button, running Javascript to add new elements to the DOM, which then requires the browser to run Style and Layout calculations to position the new content: A click interaction handler on a desktop machine, taking 67 milliseconds. With the calibrated \"mid-tier mobile\" CPU throttling preset (3.7x on this development machine), the interaction looks very similar, but the duration increases significantly, becoming a long task: The same interaction on a desktop machine with mid-tier mobile CPU throttling, taking 211 milliseconds. Testing the same interaction on a real mid-tier device using remote debugging yields a remarkably similar result, in both the shape and duration of the interaction's trace. Because this task is mostly CPU bound in the main thread (executing the page's JavaScript code and Chrome's style and layout code), the calibrated throttling accurately recreates the real mobile performance: The same interaction on a real mobile device, taking 189 milliseconds. When you might still want to test on a real mobile device While very useful, CPU throttling can't simulate all aspects of mobile hardware. On a phone, disk speed is slower, memory bandwidth is more limited, and thermal throttling can kick in at any time to cut back execution speed. A common throttling limitation involves GPU-intensive work. Mobile and desktop GPUs differ architecturally, and Chrome runs GPU operations in a separate process from the page's main thread. As a result, DevTools CPU throttling doesn't touch the GPU process (which is for the best, as that would impact the responsiveness of DevTools itself and the rest of the browser). Complicated painting, compositing, and effect-heavy styling are common performance issues that can seem fine on a development machine, but unexpectedly slow on mobile. And it can be tricky to realize there is a problem at all when trying to recreate the issue on your development machine. Consider the same interaction as before (click and add many elements to the DOM), only this time the new elements are styled with an excessive number of GPU-heavy box-shadows and blur filters. The beginning shape and duration of the interaction looks similar, but there's a lengthy new main-thread paint at the end of it for the added effects: A click interaction with heavy GPU effects on a desktop machine with mid-tier mobile CPU throttling, taking 270 milliseconds. On a real mid-tier phone, the main-thread portion of the interaction looks very similar to the simulated one, including the extra paint, but then a wild GPU process appears to do an enormous amount of work before the result of the interaction can appear on screen: The same interaction on a real mobile device, taking 620 milliseconds. The GPU work lengthens the interaction by another 300 milliseconds, and is work that barely exists at all for the laptop GPU, even with (main-thread) CPU throttling enabled. There are a few other cases that have significant emulation drawbacks, too, like deep-dependency page loads, where there's an interplay between simulated network throttling, inter-process communications, and accessing disk and memory caches. Always make sure to test on real mobile devices at some point. And if you can't recreate a problem in the lab on your desktop machine that your field data shows is affecting mobile users, definitely try out remote debugging with a real device to see if there's a difference you're missing. More data-driven debugging improvements Some other new features have recently landed to help make it easier to base debugging settings and decisions on your real users. If you have field data enabled, the Performance panel will give suggestions about throttling based on your 75th percentile users as measured by the Chrome User Experience Report (CrUX), and the real-time metric view will alert you if your locally measured metrics diverge from the field data. This was covered in detail in an earlier post about bringing real-world Core Web Vitals data into DevTools. One new addition is that the Performance panel insights in the sidebar will now also alert you if the metrics measured in a trace don't match what your users are experiencing in the real world. The insights sidebar warning that it may be helpful to adjust throttling and emulation settings to match real users. Having field data enabled will also unlock using your 75th percentile Core Web Vitals to help rank the order in which insights are shown in the sidebar. If, for example, your users typically have great Largest Contentful Paint (LCP) but poor Interaction to Next Paint (INP), insights that help with improving INP will tend to end up at the top of the list. And finally, if you've ever been flipping back and forth between multiple traces, or loading traces from disk, it can be difficult to remember exactly what mobile emulation and throttling settings you used in each trace. The trace selection drop-down at the top of the Performance panel now shows emulation information for each trace. The trace-selection drop-down, with the emulation and throttling settings for each trace. Stop, calibrate, and listen Ultimately we need to base our debugging decisions on the real world: starting with field data from analytics and user reports to find issues, then recreating those user experiences in the lab for diagnosis. These new DevTools additions should help make that process a little easier. CPU throttling calibration and alerts on diverging field and lab experiences help reduce the uncertainty of whether or not you're on the right path and enable a more consistent approximation of real-world performance. By taking guesswork out of configuration and highlighting potential discrepancies, DevTools aims to help you spend more time focused on fixing the actual performance issues affecting your users. Have ideas for more improvements or suggestions for new features? Let us know!",
  "image": "https://developer.chrome.com/static/blog/devtools-grounded-real-world/images/hero.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n  \n    \n\n\n\n\n\u003cdiv translate=\"no\"\u003e\n        \n          \u003cp\u003e\u003cimg alt=\"Brendan Kenny\" src=\"https://web.dev/images/authors/bckenny.jpg\" decoding=\"async\" height=\"64\" loading=\"lazy\" width=\"64\"/\u003e\u003c/p\u003e\n      \u003c/div\u003e\n\n\u003cp\u003e\n  Published: April 04, 2025\n\u003c/p\u003e\n\n\n\n\n\u003cp\u003eFixing performance issues in the real world means bridging the gap between your development environment and the diverse performance experiences of your users. In this post, we\u0026#39;ll look at new features in Chrome DevTools that help you base more of your performance debugging decisions on real data rather than guesswork.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"calibrating_expectations\" data-text=\"Calibrating expectations\" tabindex=\"-1\"\u003eCalibrating expectations\u003c/h2\u003e\n\n\u003cp\u003eStarting in Chrome 134, DevTools includes \u003cstrong\u003eCPU throttling calibration\u003c/strong\u003e, a new tool to remove the uncertainty of picking the right CPU throttling level. Run the calibration once, and DevTools will generate \u0026#34;low-tier mobile\u0026#34; and \u0026#34;mid-tier mobile\u0026#34; throttling presets for you, specific to your development machine.\u003c/p\u003e\n\n\u003cp\u003eA common mismatch in web performance work is that, as developers, we often build sites on fast desktop devices while many of our users are on more modest mobile devices. Tracking down a performance problem can be tricky when it only happens on a device with a much slower CPU.\u003c/p\u003e\n\n\u003cp\u003eThe gold standard is \u003ca href=\"https://developer.chrome.com/docs/devtools/remote-debugging\"\u003eremote debugging on a real mobile device\u003c/a\u003e, but for almost a decade Chrome has also supported \u003ca href=\"https://developer.chrome.com/docs/devtools/performance/reference#cpu-throttle\"\u003eCPU throttling\u003c/a\u003e for fast and lightweight iteration cycles during development.\u003c/p\u003e\n\n\u003cp\u003eBut which CPU throttling level should you choose? 4x? \u003cem\u003e20x\u003c/em\u003e? How do you know which best matches the type of devices you know visit your site? And how does the speed of your own machine change that decision, whether you\u0026#39;re on a high-end workstation or using an 8-year-old Chromebook on the go?\u003c/p\u003e\n\n\u003ch3 id=\"the_throttling_calibration_process\" data-text=\"The throttling calibration process\" tabindex=\"-1\"\u003eThe throttling calibration process\u003c/h3\u003e\n\n\u003cp\u003eWhen the Performance panel is opened, the Environment settings has a drop-down to set the CPU throttling level. If you haven\u0026#39;t run the calibration before, you\u0026#39;ll see two disabled options under \u0026#34;Calibrated presets\u0026#34; in the drop-down, and a \u003cstrong\u003eCalibrateâ€¦\u003c/strong\u003e option at the very bottom.\u003c/p\u003e\n\n\u003cp\u003eSelecting this will bring you to the CPU throttling presets in \u003cstrong\u003eSettings\u003c/strong\u003e (you can also go there directly).\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eClick the \u003cstrong\u003eCalibrate\u003c/strong\u003e button\u003c/li\u003e\n\u003cli\u003eClick \u003cstrong\u003eContinue\u003c/strong\u003e when it warns you that it will briefly navigate away from the current page\u003c/li\u003e\n\u003cli\u003eA quick benchmark will run to measure the speed of your current machine, and calibration is complete\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cfigure\u003e\n  \u003cvideo autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" controls=\"\" width=\"816\" height=\"640\"\u003e\u003csource src=\"https://developer.chrome.com/static/blog/devtools-grounded-real-world/images/calibration.mp4\" type=\"video/mp4\"/\u003e\u003c/video\u003e\n  \u003cfigcaption\u003eScreen recording of running the CPU throttling process\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eThe throttling options will now be populated with the calibrated presets for low-tier and mid-tier devices.\u003c/p\u003e\n\n\u003cp\u003eThese two presets should be enough for most development use cases, and we generally recommend the \u0026#34;mid-tier\u0026#34; preset as matching a \u0026#34;typical\u0026#34; mobile device seen on the web. If you know that many of your users have even slower devices or a performance issue only typically occurs for those users, the \u0026#34;low-tier\u0026#34; option should be slow enough to capture even the long tail of low-end devices.\u003c/p\u003e\n\n\u003cp\u003eFinally, if you think something went wrong with the calibration or your local machine has changed in some way, you can always recalibrate through the throttling drop-down or in settings, which will re-run the benchmark and update the presets.\u003c/p\u003e\n\n\u003ch3 id=\"how_cpu_throttling_works_in_devtools\" data-text=\"How CPU throttling works in DevTools\" tabindex=\"-1\"\u003eHow CPU throttling works in DevTools\u003c/h3\u003e\n\n\u003cp\u003eIf you\u0026#39;ve ever been curious about how CPU throttling works in DevTools, the idea is relatively straightforward. When you turn on throttling for a tab, Chrome launches a separate throttling thread that \u003ca href=\"https://en.wikipedia.org/wiki/Interrupt\"\u003einterrupts\u003c/a\u003e and suspends the tab\u0026#39;s main thread for frequent short bursts. The goal is to suspend the main thread long enough in total that the duration of any given task goes up by the throttling factor.\u003c/p\u003e\n\n\u003cp\u003eFor example, at 4x CPU throttling, the main thread will end up suspended approximately 75% of the time, which makes any main-thread work take four times as long to complete.\u003c/p\u003e\n\n\u003cp\u003eThe benefit of this approach is that it\u0026#39;s mostly transparent to the rest of Chrome; there\u0026#39;s no specialized code needed to slow down JavaScript, or layout, or each of the many other types of work a browser needs to do. All work on the main thread takes longer because the thread itself is only allowed to execute for a fraction of the time.\u003c/p\u003e\n\n\u003ch3 id=\"when_cpu_throttling_acts_like_a_real_mobile_device\" data-text=\"When CPU throttling acts like a real mobile device\" tabindex=\"-1\"\u003eWhen CPU throttling acts like a real mobile device\u003c/h3\u003e\n\n\u003cp\u003eAs a result, many types of mobile CPU-bound work are simulated well by CPU throttling. If an interaction triggers javascript and layout, for example, it has a good chance of resulting in executing very similarly to how it would have run on a mobile device.\u003c/p\u003e\n\n\u003cp\u003eConsider a task triggered by the click of a button, running Javascript to add new elements to the DOM, which then requires the browser to run Style and Layout calculations to position the new content:\u003c/p\u003e\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://developer.chrome.com/static/blog/devtools-grounded-real-world/images/1-click-task-unthrottled.png\" alt=\"The profile of a click interaction on a desktop machine, shown in the Performance panel, taking 67 milliseconds\" width=\"745\" height=\"131\"/\u003e\n  \u003cfigcaption\u003eA click interaction handler on a desktop machine, taking 67 milliseconds.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eWith the calibrated \u0026#34;mid-tier mobile\u0026#34; CPU throttling preset (3.7x on this development machine), the interaction looks very similar, but the duration increases significantly, becoming a long task:\u003c/p\u003e\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://developer.chrome.com/static/blog/devtools-grounded-real-world/images/1-click-task-throttled.png\" alt=\"The profile of the click interaction on a desktop machine with CPU throttling enabled, shown in the Performance panel, taking 211 milliseconds\" width=\"745\" height=\"131\"/\u003e\n  \u003cfigcaption\u003eThe same interaction on a desktop machine with mid-tier mobile CPU throttling, taking 211 milliseconds.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eTesting the same interaction on a real mid-tier device using remote debugging yields a remarkably similar result, in both the shape and duration of the interaction\u0026#39;s trace. Because this task is mostly CPU bound in the main thread (executing the page\u0026#39;s JavaScript code and Chrome\u0026#39;s style and layout code), the calibrated throttling accurately recreates the real mobile performance:\u003c/p\u003e\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://developer.chrome.com/static/blog/devtools-grounded-real-world/images/1-click-task-mobile.png\" alt=\"The profile of the click interaction on a real phone, shown in the Performance panel, taking 189 milliseconds\" width=\"745\" height=\"131\"/\u003e\n  \u003cfigcaption\u003eThe same interaction on a real mobile device, taking 189 milliseconds.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003ch3 id=\"when_you_might_still_want_to_test_on_a_real_mobile_device\" data-text=\"When you might still want to test on a real mobile device\" tabindex=\"-1\"\u003eWhen you might still want to test on a real mobile device\u003c/h3\u003e\n\n\u003cp\u003eWhile very useful, CPU throttling can\u0026#39;t simulate all aspects of mobile hardware. On a phone, disk speed is slower, memory bandwidth is more limited, and thermal throttling can kick in at any time to cut back execution speed.\u003c/p\u003e\n\n\u003cp\u003eA common throttling limitation involves GPU-intensive work. Mobile and desktop GPUs differ architecturally, and Chrome runs GPU operations in a separate process from the page\u0026#39;s main thread. As a result, DevTools CPU throttling doesn\u0026#39;t touch the GPU process (which is for the best, as that would impact the responsiveness of DevTools itself and the rest of the browser).\u003c/p\u003e\n\n\u003cp\u003eComplicated painting, compositing, and effect-heavy styling are common performance issues that can seem fine on a development machine, but unexpectedly slow on mobile. And it can be tricky to realize there is a problem at all when trying to recreate the issue on your development machine.\u003c/p\u003e\n\n\u003cp\u003eConsider the same interaction as before (click and add many elements to the DOM), only this time the new elements are styled with an excessive number of GPU-heavy box-shadows and \u003ca href=\"https://developer.mozilla.org/docs/Web/CSS/filter#blur\"\u003eblur filters\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe beginning shape and duration of the interaction looks similar, but there\u0026#39;s a lengthy new main-thread paint at the end of it for the added effects:\u003c/p\u003e\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://developer.chrome.com/static/blog/devtools-grounded-real-world/images/2-fancy-task-throttled.png\" alt=\"The profile of a click interaction on a desktop machine with CPU throttling enabled, shown in the Performance panel, taking 270 milliseconds. The last third of the task is taken up by a Paint entry\" width=\"768\" height=\"167\"/\u003e\n  \u003cfigcaption\u003eA click interaction with heavy GPU effects on a desktop machine with mid-tier mobile CPU throttling, taking 270 milliseconds.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eOn a real mid-tier phone, the main-thread portion of the interaction looks very similar to the simulated one, including the extra paint, but then a wild GPU process appears to do an enormous amount of work before the result of the interaction can appear on screen:\u003c/p\u003e\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://developer.chrome.com/static/blog/devtools-grounded-real-world/images/2-fancy-task-mobile.png\" alt=\"The profile of the click interaction on a real phone, shown in the Performance panel, taking 620 milliseconds. A very similar Paint entry is shown as the throttled trace, but this interaction is dominated by a GPU entry taking up the last half of the interaction\" width=\"768\" height=\"183\"/\u003e\n  \u003cfigcaption\u003eThe same interaction on a real mobile device, taking 620 milliseconds.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eThe GPU work lengthens the interaction by another 300 milliseconds, and is work that barely exists at all for the laptop GPU, even with (main-thread) CPU throttling enabled.\u003c/p\u003e\n\n\u003cp\u003eThere are a few other cases that have significant emulation drawbacks, too, like deep-dependency page loads, where there\u0026#39;s an interplay between simulated network throttling, inter-process communications, and accessing disk and memory caches.\u003c/p\u003e\n\n\u003cp\u003eAlways make sure to test on real mobile devices at some point. And if you can\u0026#39;t recreate a problem in the lab on your desktop machine that your field data shows is affecting mobile users, definitely try out remote debugging with a real device to see if there\u0026#39;s a difference you\u0026#39;re missing.\u003c/p\u003e\n\n\u003ch2 id=\"more_data-driven_debugging_improvements\" data-text=\"More data-driven debugging improvements\" tabindex=\"-1\"\u003eMore data-driven debugging improvements\u003c/h2\u003e\n\n\u003cp\u003eSome other new features have recently landed to help make it easier to base debugging settings and decisions on your real users.\u003c/p\u003e\n\n\u003cp\u003eIf you have \u003ca href=\"https://developer.chrome.com/docs/devtools/performance/overview#compare\"\u003efield data enabled\u003c/a\u003e, the \u003cstrong\u003ePerformance\u003c/strong\u003e panel will give suggestions about throttling based on your 75th percentile users as measured by the \u003ca href=\"https://developer.chrome.com/docs/crux\"\u003eChrome User Experience Report (CrUX)\u003c/a\u003e, and the real-time metric view will alert you if your locally measured metrics diverge from the field data. This was covered in detail in an \u003ca href=\"https://developer.chrome.com/blog/devtools-realtime-cwv#field-data\"\u003eearlier post about bringing real-world Core Web Vitals data into DevTools\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eOne new addition is that the \u003ca href=\"https://developer.chrome.com/blog/devtools-insights-sidebar\"\u003ePerformance panel insights in the sidebar\u003c/a\u003e will now also alert you if the metrics measured in a trace don\u0026#39;t match what your users are experiencing in the real world.\u003c/p\u003e\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://developer.chrome.com/static/blog/devtools-grounded-real-world/images/metrics-mismatch.png\" alt=\"An insight entry in the Performance panel sidebar. The top line shows locally measured metrics, considered good, and the next line shows the metrics from the field, with two of them considered \u0026#39;needs improvement\u0026#39;. Below this is a text that links to information about why local and field metrics may not match, and how to adjust throttling settings and device emulation\" width=\"270\" height=\"298\"/\u003e\n  \u003cfigcaption\u003eThe insights sidebar warning that it may be helpful to adjust throttling and emulation settings to match real users.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eHaving field data enabled will also unlock using your 75th percentile Core Web Vitals to help rank the order in which insights are shown in the sidebar. If, for example, your users typically have great \u003ca href=\"https://web.dev/articles/lcp\"\u003eLargest Contentful Paint (LCP)\u003c/a\u003e but poor \u003ca href=\"https://web.dev/articles/inp\"\u003eInteraction to Next Paint (INP)\u003c/a\u003e, \u003ca href=\"https://developer.chrome.com/blog/devtools-insights-sidebar#insights_for_responsiveness\"\u003einsights that help with improving INP\u003c/a\u003e will tend to end up at the top of the list.\u003c/p\u003e\n\n\u003cp\u003eAnd finally, if you\u0026#39;ve ever been flipping back and forth between multiple traces, or loading traces from disk, it can be difficult to remember exactly what mobile emulation and throttling settings you used in each trace. The trace selection  drop-down at the top of the \u003cstrong\u003ePerformance\u003c/strong\u003e panel now shows emulation information for each trace.\u003c/p\u003e\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://developer.chrome.com/static/blog/devtools-grounded-real-world/images/display-throttling-settings.png\" alt=\"\" width=\"500\" height=\"251\"/\u003e\n  \u003cfigcaption\u003eThe trace-selection drop-down, with the emulation and throttling settings for each trace.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003ch2 id=\"stop_calibrate_and_listen\" data-text=\"Stop, calibrate, and listen\" tabindex=\"-1\"\u003eStop, calibrate, and listen\u003c/h2\u003e\n\n\u003cp\u003eUltimately we need to base our debugging decisions on the real world: starting with field data from analytics and user reports to find issues, then recreating those user experiences in the lab for diagnosis. These new DevTools additions should help make that process a little easier.\u003c/p\u003e\n\n\u003cp\u003eCPU throttling calibration and alerts on diverging field and lab experiences help reduce the uncertainty of whether or not you\u0026#39;re on the right path and enable a more consistent approximation of real-world performance. By taking guesswork out of configuration and highlighting potential discrepancies, DevTools aims to help you spend more time focused on fixing the actual performance issues affecting your users.\u003c/p\u003e\n\n\u003cp\u003eHave ideas for more improvements or suggestions for new features? \u003ca href=\"http://crbug.com/408248619\"\u003eLet us know!\u003c/a\u003e\u003c/p\u003e\n\n  \n\n  \n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": null,
  "modifiedTime": null
}
