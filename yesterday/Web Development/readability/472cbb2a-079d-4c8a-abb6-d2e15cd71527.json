{
  "id": "472cbb2a-079d-4c8a-abb6-d2e15cd71527",
  "title": "How to Wait for the sibling-count() and sibling-index() Functions",
  "link": "https://css-tricks.com/how-to-wait-for-the-sibling-count-and-sibling-index-functions/",
  "description": "Today, I want to look into one of those cases of impatient and how the community has waited for that feature, to be specific, two upcoming functions: sibling-count() and sibling-index(). How to Wait for the sibling-count() and sibling-index() Functions originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Juan Diego Rodríguez",
  "published": "Mon, 13 Jan 2025 15:08:01 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "CSS functions"
  ],
  "byline": "Juan Diego Rodríguez",
  "length": 14038,
  "excerpt": "Today, I want to look into one of those cases of impatient and how the community has waited for that feature, to be specific, two upcoming functions: sibling-count() and sibling-index().",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "New features don’t just pop up in CSS (but I wish they did). Rather, they go through an extensive process of discussions and considerations, defining, writing, prototyping, testing, shipping handling support, and many more verbs that I can’t even begin to imagine. That process is long, and despite how much I want to get my hands on a new feature, as an everyday developer, I can only wait. I can, however, control how I wait: do I avoid all possible interfaces or demos that are possible with that one feature? Or do I push the boundaries of CSS and try to do them anyway? As ambitious and curious developers, many of us choose the latter option. CSS would grow stagnant without that mentality. That’s why, today, I want to look at two upcoming functions: sibling-count() and sibling-index(). We’re waiting for them — and have been for several years — so I’m letting my natural curiosity get the best of me so I can get a feel for what to be excited about. Join me! The tree-counting functions At some point, you’ve probably wanted to know the position of an element amongst its siblings or how many children an element has to calculate something in CSS, maybe for some staggering animation in which each element has a longer delay, or perhaps for changing an element’s background-color depending on its number of siblings. This has been a long-awaited deal on my CSS wishlists. Take this CSSWG GitHub Issue from 2017: Feature request. It would be nice to be able to use the counter() function inside of calc() function. That would enable new possibilities on layouts. However, counters work using strings, rendering them useless inside a calc() function that deals with numbers. We need a set of similar functions that return as integers the index of an element and the count of siblings. This doesn’t seem too much to ask. We can currently query an element by its tree position using the :nth-child() pseudo-selector (and its variants), not to mention query an element based on how many items it has using the :has() pseudo-selector. Luckily, this year the CSSWG approved implementing the sibling-count() and sibling-index() functions! And we already have something in the spec written down: The sibling-count() functional notation represents, as an \u003cinteger\u003e, the total number of child elements in the parent of the element on which the notation is used. The sibling-index() functional notation represents, as an \u003cinteger\u003e, the index of the element on which the notation is used among the children of its parent. Like :nth-child(), sibling-index() is 1-indexed. How much time do we have to wait to use them? Earlier this year Adam Argyle said that “a Chromium engineer mentioned wanting to do it, but we don’t have a flag to try it out with yet. I’ll share when we do!” So, while I am hopeful to get more news in 2025, we probably won’t see them shipped soon. In the meantime, let’s get to what we can do right now! Rubbing two sticks together The closest we can get to tree counting functions in terms of syntax and usage is with custom properties. However, the biggest problem is populating them with the correct index and count. The simplest and longest method is hardcoding each using only CSS: we can use the nth-child() selector to give each element its corresponding index: li:nth-child(1) { --sibling-index: 1; } li:nth-child(2) { --sibling-index: 2; } li:nth-child(3) { --sibling-index: 3; } /* and so on... */ Setting the sibling-count() equivalent has a bit more nuance since we will need to use quantity queries with the :has() selector. A quantity query has the following syntax: .container:has(\u003e :last-child:nth-child(m)) { } …where m is the number of elements we want to target. It works by checking if the last element of a container is also the nth element we are targeting; thus it has only that number of elements. You can create your custom quantity queries using this tool by Temani Afif. In this case, our quantity queries would look like the following: ol:has(\u003e :nth-child(1)) { --sibling-count: 1; } ol:has(\u003e :last-child:nth-child(2)) { --sibling-count: 2; } ol:has(\u003e :last-child:nth-child(3)) { --sibling-count: 3; } /* and so on... */ This example is intentionally light on the number of elements for brevity, but as the list grows it will become unmanageable. Maybe we could use a preprocessor like Sass to write them for us, but we want to focus on a vanilla CSS solution here. For example, the following demo can support up to 12 elements, and you can already see how ugly it gets in the code. That’s 24 rules to know the index and count of 12 elements for those of you keeping score. It surely feels like we could get that number down to something more manageable, but if we hardcode each index we are bound increase the amount of code we write. The best we can do is rewrite our CSS so we can nest the --sibling-index and --sibling-count properties together. Instead of writing each property by itself: li:nth-child(2) { --sibling-index: 2; } ol:has(\u003e :last-child:nth-child(2)) { --sibling-count: 2; } We could instead nest the --sibling-count rule inside the --sibling-index rule. li:nth-child(2) { --sibling-index: 2; ol:has(\u003e \u0026:last-child) { --sibling-count: 2; } } While it may seem wacky to nest a parent inside its children, the following CSS code is completely valid; we are selecting the second li element, and inside, we are selecting an ol element if its second li element is also the last, so the list only has two elements. Which syntax is easier to manage? It’s up to you. But that’s just a slight improvement. If we had, say, 100 elements we would still need to hardcode the --sibling-index and --sibling-count properties 100 times. Luckily, the following method will increase rules in a logarithmic way, specifically base-2. So instead of writing 100 rules for 100 elements, we will be writing closer to 10 rules for around 100 elements. Flint and steel This method was first described by Roman Komarov in October last year, in which he prototypes both tree counting functions and the future random() function. It’s an amazing post, so I strongly encourage you to read it. This method also uses custom properties, but instead of hardcoding each one, we will be using two custom properties that will build up the --sibling-index property for each element. Just to be consistent with Roman’s post, we will call them --si1 and --si2, both starting at 0: li { --si1: 0; --si2: 0; } The real --sibling-index will be constructed using both properties and a factor (F) that represents an integer greater or equal to 2 that tells us how many elements we can select according to the formula sqrt(F) - 1. So… For a factor of 2, we can select 3 elements. For a factor of 3, we can select 8 elements. For a factor of 5, we can select 24 elements. For a factor of 10, we can select 99 elements. For a factor of 25, we can select 624 elements. As you can see, increasing the factor by one will give us exponential gains on how many elements we can select. But how does all this translate to CSS? The first thing to know is that the formula for calculating the --sibling-index property is calc(F * var(--si2) + var(--si1)). If we take a factor of 3, it would look like the following: li { --si1: 0; --si2: 0; /* factor of 3; it's a harcoded number */ --sibling-index: calc(3 * var(--si2) + var(--si1)); } The following selectors may be random but stay with me here. For the --si1 property, we will write rules selecting elements that are multiples of the factor and offset them by one 1 until we reach F - 1, then set --si1 to the offset. This translates to the following CSS: li:nth-child(Fn + 1) { --si1: 1; } li:nth-child(Fn + 2) { --si1: 2; } /* ... */ li:nth-child(Fn+(F-1)) { --si1: (F-1) } So if our factor is 3, we will write the following rules until we reach F-1, so 2 rules: li:nth-child(3n + 1) { --si1: 1; } li:nth-child(3n + 2) { --si1: 2; } For the --si2 property, we will write rules selecting elements in batches of the factor (so if our factor is 3, we will select 3 elements per rule), going from the last possible index (in this case 8) backward until we simply are unable to select more elements in batches. This is a little more convoluted to write in CSS: li:nth-child(n + F*1):nth-child(-n + F*1-1){--si2: 1;} li:nth-child(n + F*2):nth-child(-n + F*2-1){--si2: 2;} /* ... */ li:nth-child(n+(F*(F-1))):nth-child(-n+(F*F-1)) { --si2: (F-1) } Again, if our factor is 3, we will write the following two rules: li:nth-child(n + 3):nth-child(-n + 5) { --si2: 1; } li:nth-child(n + 6):nth-child(-n + 8) { --si2: 2; } And that’s it! By only setting those two values for --si1 and --si2 we can count up to 8 total elements. The math behind how it works seems wacky at first, but once you visually get it, it all clicks. I made this interactive demo in which you can see how all elements can be reached using this formula. Hover over the code snippets to see which elements can be selected, and click on each snippet to combine them into a possible index. If you crank the elements and factor to the max, you can see that we can select 48 elements using only 14 snippets! Wait, one thing is missing: the sibling-count() function. Luckily, we will be reusing all we have learned from prototyping --sibling-index. We will start with two custom properties: --sc1 and --sc1 at the container, both starting at 0 as well. The formula for calculating --sibling-count is the same. ol { --sc1: 0; --sc2: 0; /* factor of 3; also a harcoded number */ --sibling-count: calc(3 * var(--sc2) + var(--sc1)); } Roman’s post also explains how to write selectors for the --sibling-count property by themselves, but we will use the :has() selection method from our first technique so we don’t have to write extra selectors. We can cram those --sc1 and --sc2 properties into the rules where we defined the sibling-index() properties: /* --si1 and --sc1 */ li:nth-child(3n + 1) { --si1: 1; ol:has(\u003e \u0026:last-child) { --sc1: 1; } } li:nth-child(3n + 2) { --si1: 2; ol:has(\u003e \u0026:last-child) { --sc1: 2; } } /* --si2 and --sc2 */ li:nth-child(n + 3):nth-child(-n + 5) { --si2: 1; ol:has(\u003e \u0026:last-child) { --sc2: 1; } } li:nth-child(n + 6):nth-child(-n + 8) { --si2: 2; ol:has(\u003e \u0026:last-child) { --sc2: 2; } } This is using a factor of 3, so we can count up to eight elements with only four rules. The following example has a factor of 7, so we can count up to 48 elements with only 14 rules. This method is great, but may not be the best fit for everyone due to the almost magical way of how it works, or simply because you don’t find it aesthetically pleasing. While for avid hands lighting a fire with flint and steel is a breeze, many won’t get their fire started. Using a flamethrower For this method, we will use once again custom properties to mimic the tree counting functions, and what’s best, we will write less than 20 lines of code to count up to infinity—or I guess to 1.7976931348623157e+308, which is the double precision floating point limit! We will be using the Mutation Observer API, so of course it takes JavaScript. I know that’s like admitting defeat for many, but I disagree. If the JavaScript method is simpler (which it is, by far, in this case), then it’s the most appropriate choice. Just as a side note, if performance is your main worry, stick to hard-coding each index in CSS or HTML. First, we will grab our container from the DOM: const elements = document.querySelector(\"ol\"); Then we’ll create a function that sets the --sibling-index property in each element and the --sibling-count in the container (it will be available to its children due to the cascade). For the --sibling-index, we have to loop through the elements.children, and we can get the --sibling-count from elements.children.length. const updateCustomProperties = () =\u003e { let index = 1; for (element of elements.children) { element.style.setProperty(\"--sibling-index\", index); index++; } elements.style.setProperty(\"--sibling-count\", elements.children.length); }; Once we have our function, remember to call it once so we have our initial tree counting properties: updateCustomProperties(); Lastly, the Mutation Observer. We need to initiate a new observer using the MutationObserver constructor. It takes a callback that gets invoked each time the elements change, so we write our updateCustomProperties function. With the resulting observer object, we can call its observe() method which takes two parameters: the element we want to observe, and a config object that defines what we want to observe through three boolean properties: attributes, childList, and subtree. In this case, we just want to check for changes in the child list, so we set that one to true: const observer = new MutationObserver(updateCustomProperties); const config = {attributes: false, childList: true, subtree: false}; observer.observe(elements, config); That would be all we need! Using this method we can count many elements, in the following demo I set the max to 100, but it can easily reach tenfold: So yeah, that’s our flamethrower right there. It definitely gets the fire started, but it’s plenty overkill for the vast majority of use cases. But that’s what we have while we wait for the perfect lighter. More information and tutorials Possible Future CSS: Tree-Counting Functions and Random Values (Roman Komarov) View Transitions Staggering (Chris Coyier) Element Indexes (Chris Coyier) Enable the use of counter() inside calc() #1026 Proposal: add sibling-count() and sibling-index() #4559 Extend sibling-index() and sibling-count() with a selector argument #9572 Proposal: children-count() function #11068 Proposal: descendant-count() function #11069",
  "image": "https://css-tricks.com/wp-json/social-image-generator/v1/image/383435",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eNew features don’t just pop up in CSS (but I wish they did). Rather, they go through an extensive process of discussions and considerations, defining, writing, prototyping, testing, shipping handling support, and many more verbs that I can’t even begin to imagine. That process is \u003cstrong\u003elong\u003c/strong\u003e, and despite how much I want to get my hands on a new feature, as an everyday developer, I can only wait.\u003c/p\u003e\n\n\n\n\u003cp\u003eI can, however, control how I wait: do I avoid all possible interfaces or demos that are possible with that one feature? Or do I push the boundaries of CSS and try to do them anyway?\u003c/p\u003e\n\n\n\n\u003cp\u003eAs ambitious and curious developers, many of us choose the latter option. CSS would grow stagnant without that mentality. That’s why, today, I want to look at two upcoming functions: \u003ccode\u003esibling-count()\u003c/code\u003e and \u003ccode\u003esibling-index()\u003c/code\u003e. We’re waiting for them — and have been for several years — so I’m letting my natural curiosity get the best of me so I can get a feel for what to be excited about. Join me!\u003c/p\u003e\n\n\n\n\u003ch3 id=\"the-tree-counting-functions\"\u003eThe tree-counting functions\u003c/h3\u003e\n\n\n\u003cp\u003eAt some point, you’ve probably wanted to know the position of an element amongst its siblings or how many children an element has to calculate something in CSS, maybe for some staggering animation in which each element has a longer delay, or perhaps for changing an element’s \u003ccode\u003ebackground-color\u003c/code\u003e depending on its number of siblings. This has been a long-awaited deal on my \u003ca href=\"https://css-tricks.com/a-css-wishlist-for-2025/\"\u003eCSS wishlists\u003c/a\u003e. Take this \u003ca href=\"https://github.com/w3c/csswg-drafts/issues/1026\" rel=\"noopener\"\u003eCSSWG GitHub Issue\u003c/a\u003e from 2017:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eFeature request. It would be nice to be able to use the \u003ccode\u003ecounter()\u003c/code\u003e function inside of \u003ccode\u003ecalc()\u003c/code\u003e function. That would enable new possibilities on layouts.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eHowever, counters work using strings, rendering them useless inside a \u003ccode\u003ecalc()\u003c/code\u003e function that deals with numbers. We need a set of similar functions that return \u003cstrong\u003eas integers\u003c/strong\u003e the index of an element and the count of siblings. This doesn’t seem too much to ask. We can currently query an element by its tree position using the \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/pseudo-selectors/n/nth-child/\"\u003e:nth-child()\u003c/a\u003e\u003c/code\u003e pseudo-selector (and its variants), not to mention query an element based on how many items it has using the \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/pseudo-selectors/h/has/\"\u003e:has()\u003c/a\u003e\u003c/code\u003e pseudo-selector.\u003c/p\u003e\n\n\n\n\u003cp\u003eLuckily, this year the \u003ca href=\"https://github.com/w3c/csswg-drafts/issues/4559\" rel=\"noopener\"\u003eCSSWG approved implementing the \u003ccode\u003esibling-count()\u003c/code\u003e and \u003ccode\u003esibling-index()\u003c/code\u003e functions\u003c/a\u003e! And we already have something in the spec written down:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eThe \u003ccode\u003esibling-count()\u003c/code\u003e functional notation represents, as an \u003ccode\u003e\u0026lt;integer\u0026gt;\u003c/code\u003e, the total number of child elements in the parent of the element on which the notation is used.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003esibling-index()\u003c/code\u003e functional notation represents, as an \u003ccode\u003e\u0026lt;integer\u0026gt;\u003c/code\u003e, the index of the element on which the notation is used among the children of its parent. Like \u003ccode\u003e:nth-child()\u003c/code\u003e, \u003ccode\u003esibling-index()\u003c/code\u003e is 1-indexed.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eHow much time do we have to wait to use them? Earlier this year \u003ca href=\"https://x.com/argyleink/status/1800565839214858335\"\u003eAdam Argyle said\u003c/a\u003e that “a Chromium engineer mentioned wanting to do it, but we don’t have a flag to try it out with yet. I’ll share when we do!” So, while I am hopeful to get more news in 2025, we probably won’t see them shipped soon. In the meantime, let’s get to what we can do right now!\u003c/p\u003e\n\n\n\u003ch3 id=\"rubbing-two-sticks-together\"\u003eRubbing two sticks together\u003c/h3\u003e\n\n\n\u003cp\u003eThe closest we can get to tree counting functions in terms of syntax and usage is with custom properties. However, the biggest problem is populating them with the correct index and count. The simplest and longest method is hardcoding each using only CSS: we can use the \u003ccode\u003enth-child()\u003c/code\u003e selector to give each element its corresponding index:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli:nth-child(1) {\n  --sibling-index: 1;\n}\n\nli:nth-child(2) {\n  --sibling-index: 2;\n}\n\nli:nth-child(3) {\n  --sibling-index: 3;\n}\n\n/* and so on... */\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSetting the \u003ccode\u003esibling-count()\u003c/code\u003e equivalent has a bit more nuance since we will need to use quantity queries with the \u003ccode\u003e:has()\u003c/code\u003e selector. A quantity query has the following syntax:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.container:has(\u0026gt; :last-child:nth-child(m)) { }\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e…where \u003ccode\u003em\u003c/code\u003e is the number of elements we want to target. It works by checking if the last element of a container is also the \u003ccode\u003enth\u003c/code\u003e element we are targeting; thus it has only that number of elements. You can create your custom \u003ca href=\"https://css-tip.com/quantity-queries/\" rel=\"noopener\"\u003equantity queries using this tool by Temani Afif\u003c/a\u003e. In this case, our quantity queries would look like the following:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eol:has(\u0026gt; :nth-child(1)) {\n  --sibling-count: 1;\n}\n\nol:has(\u0026gt; :last-child:nth-child(2)) {\n  --sibling-count: 2;\n}\n\nol:has(\u0026gt; :last-child:nth-child(3)) {\n  --sibling-count: 3;\n}\n\n/* and so on... */\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis example is intentionally light on the number of elements for brevity, but as the list grows it will become unmanageable. Maybe we could use a preprocessor like Sass to write them for us, but we want to focus on a vanilla CSS solution here. For example, the following demo can support up to 12 elements, and you can already see how ugly it gets in the code.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThat’s 24 rules to know the index and count of 12 elements for those of you keeping score. It surely feels like we could get that number down to something more manageable, but if we hardcode each index we are bound increase the amount of code we write. The best we can do is rewrite our CSS so we can nest the \u003ccode\u003e--sibling-index\u003c/code\u003e and \u003ccode\u003e--sibling-count\u003c/code\u003e properties together. Instead of writing each property by itself:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli:nth-child(2) {\n  --sibling-index: 2;\n}\n\nol:has(\u0026gt; :last-child:nth-child(2)) {\n  --sibling-count: 2;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe could instead nest the \u003ccode\u003e--sibling-count\u003c/code\u003e rule inside the \u003ccode\u003e--sibling-index\u003c/code\u003e rule.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli:nth-child(2) {\n  --sibling-index: 2;\n\n  ol:has(\u0026gt; \u0026amp;:last-child) {\n    --sibling-count: 2;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhile it may seem wacky to nest a parent inside its children, the following CSS code is completely valid; we are selecting the second \u003ccode\u003eli\u003c/code\u003e element, and inside, we are selecting an \u003ccode\u003eol\u003c/code\u003e element if its second \u003ccode\u003eli\u003c/code\u003e element is also the last, so the list only has two elements. Which syntax is easier to manage? It’s up to you.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eBut that’s just a slight improvement. If we had, say, 100 elements we would still need to hardcode the \u003ccode\u003e--sibling-index\u003c/code\u003e and \u003ccode\u003e--sibling-count\u003c/code\u003e properties 100 times. Luckily, the following method will increase rules in a logarithmic way, specifically base-2. So instead of writing 100 rules for 100 elements, we will be writing closer to 10 rules for around 100 elements.\u003c/p\u003e\n\n\n\u003ch3 id=\"flint-and-steel\"\u003eFlint and steel\u003c/h3\u003e\n\n\n\u003cp\u003eThis method was first described by \u003ca href=\"https://kizu.dev/tree-counting-and-random/#prototyping-with-custom-properties\" rel=\"noopener\"\u003eRoman Komarov in October last year\u003c/a\u003e, in which he prototypes both tree counting functions and the future \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/functions/r/random/\"\u003erandom()\u003c/a\u003e\u003c/code\u003e function. It’s an amazing post, so I strongly encourage you to read it.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis method also uses custom properties, but instead of hardcoding each one, we will be using two custom properties that will build up the \u003ccode\u003e--sibling-index\u003c/code\u003e property for each element. Just to be consistent with Roman’s post, we will call them \u003ccode\u003e--si1\u003c/code\u003e and \u003ccode\u003e--si2\u003c/code\u003e, both starting at \u003ccode\u003e0\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli {\n  --si1: 0;\n  --si2: 0;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe real \u003ccode\u003e--sibling-index\u003c/code\u003e will be constructed using both properties and a \u003cstrong\u003efactor\u003c/strong\u003e (\u003ccode\u003eF\u003c/code\u003e) that represents an integer greater or equal to \u003ccode\u003e2\u003c/code\u003e that tells us how many elements we can select according to the formula \u003ccode\u003esqrt(F) - 1\u003c/code\u003e. So…\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eFor a factor of \u003ccode\u003e2\u003c/code\u003e, we can select \u003ccode\u003e3\u003c/code\u003e elements.\u003c/li\u003e\n\n\n\n\u003cli\u003eFor a factor of \u003ccode\u003e3\u003c/code\u003e, we can select \u003ccode\u003e8\u003c/code\u003e elements.\u003c/li\u003e\n\n\n\n\u003cli\u003eFor a factor of \u003ccode\u003e5\u003c/code\u003e, we can select \u003ccode\u003e24\u003c/code\u003e elements.\u003c/li\u003e\n\n\n\n\u003cli\u003eFor a factor of \u003ccode\u003e10\u003c/code\u003e, we can select \u003ccode\u003e99\u003c/code\u003e elements.\u003c/li\u003e\n\n\n\n\u003cli\u003eFor a factor of \u003ccode\u003e25\u003c/code\u003e, we can select \u003ccode\u003e624\u003c/code\u003e elements.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAs you can see, increasing the factor by one will give us exponential gains on how many elements we can select. But how does all this translate to CSS?\u003c/p\u003e\n\n\n\n\u003cp\u003eThe first thing to know is that the formula for calculating the \u003ccode\u003e--sibling-index\u003c/code\u003e property is \u003ccode\u003ecalc(F * var(--si2) + var(--si1))\u003c/code\u003e. If we take a factor of \u003ccode\u003e3\u003c/code\u003e, it would look like the following:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli {\n  --si1: 0;\n  --si2: 0;\n\n  /* factor of 3; it\u0026#39;s a harcoded number */\n  --sibling-index: calc(3 * var(--si2) + var(--si1));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe following selectors may be random but stay with me here. For the \u003ccode\u003e--si1\u003c/code\u003e property, we will write rules selecting elements that are multiples of the factor and offset them by one \u003ccode\u003e1\u003c/code\u003e until we reach \u003ccode\u003eF - 1\u003c/code\u003e, then set \u003ccode\u003e--si1\u003c/code\u003e to the offset. This translates to the following CSS:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli:nth-child(Fn + 1) { --si1: 1; }\nli:nth-child(Fn + 2) { --si1: 2; }\n/* ... */\nli:nth-child(Fn+(F-1)) { --si1: (F-1) }\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSo if our factor is \u003ccode\u003e3\u003c/code\u003e, we will write the following rules until we reach \u003ccode\u003eF-1\u003c/code\u003e, so \u003ccode\u003e2\u003c/code\u003e rules:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli:nth-child(3n + 1) { --si1: 1; }\nli:nth-child(3n + 2) { --si1: 2; }\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFor the \u003ccode\u003e--si2\u003c/code\u003e property, we will write rules selecting elements in batches of the factor (so if our factor is \u003ccode\u003e3\u003c/code\u003e, we will select \u003ccode\u003e3\u003c/code\u003e elements per rule), going from the last possible index (in this case \u003ccode\u003e8\u003c/code\u003e) backward until we simply are unable to select more elements in batches. This is a little more convoluted to write in CSS:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli:nth-child(n + F*1):nth-child(-n + F*1-1){--si2: 1;}\nli:nth-child(n + F*2):nth-child(-n + F*2-1){--si2: 2;}\n/* ... */\nli:nth-child(n+(F*(F-1))):nth-child(-n+(F*F-1)) { --si2: (F-1) }\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAgain, if our factor is \u003ccode\u003e3\u003c/code\u003e, we will write the following two rules:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli:nth-child(n + 3):nth-child(-n + 5) {\n  --si2: 1;\n}\nli:nth-child(n + 6):nth-child(-n + 8) {\n  --si2: 2;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd that’s it! By only setting those two values for \u003ccode\u003e--si1\u003c/code\u003e and \u003ccode\u003e--si2\u003c/code\u003e we can count up to \u003ccode\u003e8\u003c/code\u003e total elements. The math behind how it works seems wacky at first, but once you visually get it, it all clicks. I made this interactive demo in which you can see how all elements can be reached using this formula. Hover over the code snippets to see which elements can be selected, and click on each snippet to combine them into a possible index.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eIf you crank the elements and factor to the max, you can see that we can select 48 elements using only 14 snippets!\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWait, one thing is missing: the \u003ccode\u003esibling-count()\u003c/code\u003e function.\u003c/strong\u003e Luckily, we will be reusing all we have learned from prototyping \u003ccode\u003e--sibling-index\u003c/code\u003e. We will start with two custom properties: \u003ccode\u003e--sc1\u003c/code\u003e and \u003ccode\u003e--sc1\u003c/code\u003e at the container, both starting at \u003ccode\u003e0\u003c/code\u003e as well. The formula for calculating \u003ccode\u003e--sibling-count\u003c/code\u003e is the same.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eol {\n  --sc1: 0;\n  --sc2: 0;\n\n  /* factor of 3; also a harcoded number */\n  --sibling-count: calc(3 * var(--sc2) + var(--sc1));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eRoman’s post also explains how to write selectors for the \u003ccode\u003e--sibling-count\u003c/code\u003e property by themselves, but we will use the \u003ccode\u003e:has()\u003c/code\u003e selection method from our first technique so we don’t have to write extra selectors. We can cram those \u003ccode\u003e--sc1\u003c/code\u003e and \u003ccode\u003e--sc2\u003c/code\u003e properties into the rules where we defined the \u003ccode\u003esibling-index()\u003c/code\u003e properties:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* --si1 and --sc1 */\nli:nth-child(3n + 1) {\n  --si1: 1;\n\n  ol:has(\u0026gt; \u0026amp;:last-child) {\n    --sc1: 1;\n  }\n}\n\nli:nth-child(3n + 2) {\n  --si1: 2;\n\n  ol:has(\u0026gt; \u0026amp;:last-child) {\n    --sc1: 2;\n  }\n}\n\n/* --si2 and --sc2 */\nli:nth-child(n + 3):nth-child(-n + 5) {\n  --si2: 1;\n\n  ol:has(\u0026gt; \u0026amp;:last-child) {\n    --sc2: 1;\n  }\n}\n\nli:nth-child(n + 6):nth-child(-n + 8) {\n  --si2: 2;\n\n  ol:has(\u0026gt; \u0026amp;:last-child) {\n    --sc2: 2;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is using a factor of \u003ccode\u003e3\u003c/code\u003e, so we can count up to eight elements with only four rules. The following example has a factor of \u003ccode\u003e7\u003c/code\u003e, so we can count up to 48 elements with only 14 rules.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThis method is great, but may not be the best fit for everyone due to the almost magical way of how it works, or simply because you don’t find it aesthetically pleasing. While for avid hands lighting a fire with flint and steel is a breeze, many won’t get their fire started.\u003c/p\u003e\n\n\n\u003ch3 id=\"using-a-flamethrower\"\u003eUsing a flamethrower\u003c/h3\u003e\n\n\n\u003cp\u003eFor this method, we will use once again custom properties to mimic the tree counting functions, and what’s best, we will write less than 20 lines of code to count up to infinity—or I guess to \u003ccode\u003e1.7976931348623157e+308\u003c/code\u003e, which is the double precision floating point limit!\u003c/p\u003e\n\n\n\n\u003cp\u003eWe will be using the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\" rel=\"noopener\"\u003eMutation Observer API\u003c/a\u003e, so of course it takes JavaScript. I know that’s like admitting defeat for many, but I disagree. If the JavaScript method is simpler (which it is, by far, in this case), then it’s the most appropriate choice. Just as a side note, if performance is your main worry, stick to hard-coding each index in CSS or HTML.\u003c/p\u003e\n\n\n\n\u003cp\u003eFirst, we will grab our container from the DOM:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst elements = document.querySelector(\u0026#34;ol\u0026#34;);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThen we’ll create a function that sets the \u003ccode\u003e--sibling-index\u003c/code\u003e property in each element and the \u003ccode\u003e--sibling-count\u003c/code\u003e in the container (it will be available to its children due to the cascade). For the \u003ccode\u003e--sibling-index\u003c/code\u003e, we have to loop through the \u003ccode\u003eelements.children\u003c/code\u003e, and we can get the \u003ccode\u003e--sibling-count\u003c/code\u003e from \u003ccode\u003eelements.children.length\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst updateCustomProperties = () =\u0026gt; {\n  let index = 1;\n\n  for (element of elements.children) {\n    element.style.setProperty(\u0026#34;--sibling-index\u0026#34;, index);\n    index++;\n  }\n\n  elements.style.setProperty(\u0026#34;--sibling-count\u0026#34;, elements.children.length);\n};\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOnce we have our function, remember to call it once so we have our initial tree counting properties:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eupdateCustomProperties();\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLastly, the Mutation Observer. We need to initiate a new observer using the \u003ccode\u003eMutationObserver\u003c/code\u003e constructor. It takes a callback that gets invoked each time the elements change, so we write our \u003ccode\u003eupdateCustomProperties\u003c/code\u003e function. With the resulting \u003ccode\u003eobserver\u003c/code\u003e object, we can call its \u003ccode\u003eobserve()\u003c/code\u003e method which takes two parameters:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003ethe element we want to observe, and\u003c/li\u003e\n\n\n\n\u003cli\u003ea \u003ccode\u003econfig\u003c/code\u003e object that defines what we want to observe through three boolean properties: \u003ccode\u003eattributes\u003c/code\u003e, \u003ccode\u003echildList\u003c/code\u003e, and \u003ccode\u003esubtree\u003c/code\u003e. In this case, we just want to check for changes in the child list, so we set that one to \u003ccode\u003etrue\u003c/code\u003e:\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst observer = new MutationObserver(updateCustomProperties);\nconst config = {attributes: false, childList: true, subtree: false};\nobserver.observe(elements, config);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThat would be all we need! Using this method we can count \u003cstrong\u003emany\u003c/strong\u003e elements, in the following demo I set the max to \u003ccode\u003e100\u003c/code\u003e, but it can easily reach tenfold:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eSo yeah, that’s our flamethrower right there. It definitely gets the fire started, but it’s plenty overkill for the vast majority of use cases. But that’s what we have while we wait for the perfect lighter.\u003c/p\u003e\n\n\n\u003ch3 id=\"more-information-and-tutorials\"\u003eMore information and tutorials\u003c/h3\u003e\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://kizu.dev/tree-counting-and-random/\" rel=\"noopener\"\u003ePossible Future CSS: Tree-Counting Functions and Random Values\u003c/a\u003e (Roman Komarov)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://frontendmasters.com/blog/view-transitions-staggering/\" rel=\"noopener\"\u003eView Transitions Staggering\u003c/a\u003e (Chris Coyier)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://chriscoyier.net/2023/11/29/element-indexes/\" rel=\"noopener\"\u003eElement Indexes\u003c/a\u003e (Chris Coyier)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/w3c/csswg-drafts/issues/1026\" rel=\"noopener\"\u003eEnable the use of \u003ccode\u003ecounter()\u003c/code\u003e inside \u003ccode\u003ecalc()\u003c/code\u003e #1026\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://github.com/w3c/csswg-drafts/issues/4559\" rel=\"noopener\"\u003eProposal: add \u003ccode\u003esibling-count()\u003c/code\u003e and \u003ccode\u003esibling-index()\u003c/code\u003e #4559\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://github.com/w3c/csswg-drafts/issues/9572\" rel=\"noopener\"\u003eExtend \u003ccode\u003esibling-index()\u003c/code\u003e and \u003ccode\u003esibling-count()\u003c/code\u003e with a selector argument #9572\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://github.com/w3c/csswg-drafts/issues/11068\" rel=\"noopener\"\u003eProposal: \u003ccode\u003echildren-count()\u003c/code\u003e function #11068\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://github.com/w3c/csswg-drafts/issues/11069\" rel=\"noopener\"\u003eProposal: \u003ccode\u003edescendant-count()\u003c/code\u003e function #11069\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-01-13T08:08:01-07:00",
  "modifiedTime": "2025-01-13T08:25:03-07:00"
}
