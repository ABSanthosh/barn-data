{
  "id": "dfb2dae4-54e0-4a20-b3b6-60d3520b6330",
  "title": "Unleash the Power of Scroll-Driven Animations",
  "link": "https://css-tricks.com/unleash-the-power-of-scroll-driven-animations/",
  "description": "I’m utterly behind in learning about scroll-driven animations apart from the “reading progress bar” experiments all over CodePen. Well, I’m not exactly “green” on the topic; we’ve published a handful of articles on it including this neat-o one by Lee … Unleash the Power of Scroll-Driven Animations originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Geoff Graham",
  "published": "Mon, 21 Oct 2024 13:50:53 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Notes",
    "animation",
    "Scroll Driven Animation"
  ],
  "byline": "Geoff Graham",
  "length": 29411,
  "excerpt": "I'm utterly behind in learning about scroll-driven animations apart from the \"reading progress bar\" experiments all over CodePen. Well, I'm not exactly",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "DigitalOcean provides cloud products for every stage of your journey. Get started with $200 in free credit! I’m utterly behind in learning about scroll-driven animations apart from the “reading progress bar” experiments all over CodePen. Well, I’m not exactly “green” on the topic; we’ve published a handful of articles on it including this neat-o one by Lee Meyer published the other week. Our “oldest” article about the feature is by Bramus, dated back to July 2021. We were calling it “scroll-linked” animation back then. I specifically mention Bramus because there’s no one else working as hard as he is to discover practical use cases where scroll-driven animations shine while helping everyone understand the concept. He writes about it exhaustively on his personal blog in addition to writing the Chrome for Developers documentation on it. But there’s also this free course he calls “Unleash the Power of Scroll-Driven Animations” published on YouTube as a series of 10 short videos. I decided it was high time to sit, watch, and learn from one of the best. These are my notes from it. Introduction A scroll-driven animation is an animation that responds to scrolling. There’s a direct link between scrolling progress and the animation’s progress. Scroll-driven animations are different than scroll-triggered animations, which execute on scroll and run in their entirety. Scroll-driven animations pause, play, and run with the direction of the scroll. It sounds to me like scroll-triggered animations are a lot like the CSS version of the JavaScript intersection observer that fires and plays independently of scroll. Why learn this? It’s super easy to take an existing CSS animation or a WAAPI animation and link it up to scrolling. The only “new” thing to learn is how to attach an animation to scrolling. Plus, hey, it’s the platform! There are also performance perks. JavsScript libraries that establish scroll-driven animations typically respond to scroll events on the main thread, which is render-blocking… and JANK! We’re working with hardware-accelerated animations… and NO JANK. Yuriko Hirota has a case study on the performance of scroll-driven animations published on the Chrome blog. Supported in Chrome 115+. Can use @supports (animation-timeline: scroll()). However, I recently saw Bramus publish an update saying we need to look for animation-range support as well. @supports ((animation-timeline: scroll()) and (animation-range: 0% 100%)) { /* Scroll-Driven Animations related styles go here */ /* This check excludes Firefox Nightly which only has a partial implementation at the moment of posting (mid-September 2024). */ } Remember to use prefers-reduced-motion and be mindful of those who may not want them. Core Concepts: scroll() and ScrollTimeline Let’s take an existing CSS animation. @keyframes grow-progress { from { transform: scaleX(0); } to { transform: scaleX(1); } } #progress { animation: grow-progress 2s linear forwards; } Translation: Start with no width and scale it to its full width. When applied, it takes two seconds to complete and moves with linear easing just in the forwards direction. This just runs when the #progress element is rendered. Let’s attach it to scrolling. animation-timeline: The timeline that controls the animation’s progress. scroll(): Creates a new scroll timeline set up to track the nearest ancestor scroller in the block direction. #progress { animation: grow-progress 2s linear forwards; animation-timeline: scroll(); } That’s it! We’re linked up. Now we can remove the animation-duration value from the mix (or set it to auto): #progress { animation: grow-progress linear forwards; animation-timeline: scroll(); } Note that we’re unable to plop the animation-timeline property on the animation shorthand, at least for now. Bramus calls it a “reset-only sub-property of the shorthand” which is a new term to me. Its value gets reset when you use the shorthand the same way background-color is reset by background. That means the best practice is to declare animation-timeline after animation. /* YEP! */ #progress { animation: grow-progress linear forwards; animation-timeline: scroll(); } /* NOPE! */ #progress { animation-timeline: scroll(); animation: grow-progress linear forwards; } Let’s talk about the scroll() function. It creates an anonymous scroll timeline that “walks up” the ancestor tree from the target element to the nearest ancestor scroll. In this example, the nearest ancestor scroll is the :root element, which is tracked in the block direction. We can name scroll timelines, but that’s in another video. For now, know that we can adjust which axis to track and which scroller to target in the scroll() function. animation-timeline: scroll(\u003caxis\u003e \u003cscroller\u003e); \u003caxis\u003e: The axis — be it block (default), inline, y, or x. \u003cscroller\u003e: The scroll container element that defines the scroll position that influences the timeline’s progress, which can be nearest (default), root (the document), or self. If the root element does not have an overflow, then the animation becomes inactive. WAAPI gives us a way to establish scroll timelines in JavaScript with ScrollTimeline. const $progressbar = document.querySelector(#progress); $progressbar.style.transformOrigin = '0% 50%'; $progressbar.animate( { transform: ['scaleX(0)', 'scaleY()'], }, { fill: 'forwards', timeline: new ScrollTimeline({ source: document.documentElement, // root element // can control `axis` here as well }), } ) Core Concepts: view() and ViewTimeline First, we oughta distinguish a scroll container from a scroll port. Overflow can be visible or clipped. Clipped could be scrolling. Those two bordered boxes show how easy it is to conflate scrollports and scroll containers. The scrollport is the visible part and coincides with the scroll container’s padding-box. When a scrollbar is present, that plus the scroll container is the root scroller, or the scroll container. A view timeline tracks the relative position of a subject within a scrollport. Now we’re getting into IntersectionObserver territory! So, for example, we can begin an animation on the scroll timeline when an element intersects with another, such as the target element intersecting the viewport, then it progresses with scrolling. Bramus walks through an example of animating images in long-form content when they intersect with the viewport. First, a CSS animation to reveal an image from zero opacity to full opacity (with some added clipping). @keyframes reveal { from { opacity: 0; clip-path: inset(45% 20% 45% 20%); } to { opacity: 1; clip-path: inset(0% 0% 0% 0%); } } .revealing-image { animation: reveal 1s linear both; } This currently runs on the document’s timeline. In the last video, we used scroll() to register a scroll timeline. Now, let’s use the view() function to register a view timeline instead. This way, we’re responding to when a .revealing-image element is in, well, view. .revealing-image { animation: reveal 1s linear both; /* Rember to declare the timeline after the shorthand */ animation-timeline: view(); } At this point, however, the animation is nice but only completes when the element fully exits the viewport, meaning we don’t get to see the entire thing. There’s a recommended way to fix this that Bramus will cover in another video. For now, we’re speeding up the keyframes instead by completing the animation at the 50% mark. @keyframes reveal { from { opacity: 0; clip-path: inset(45% 20% 45% 20%); } 50% { opacity: 1; clip-path: inset(0% 0% 0% 0%); } } More on the view() function: animation-timeline: view(\u003caxis\u003e \u003cview-timeline-inset\u003e); We know \u003caxis\u003e from the scroll() function — it’s the same deal. The \u003cview-timeline-inset\u003e is a way of adjusting the visibility range of the view progress (what a mouthful!) that we can set to auto (default) or a \u003clength-percentage\u003e. A positive inset moves in an outward adjustment while a negative value moves in an inward adjustment. And notice that there is no \u003cscroller\u003e argument — a view timeline always tracks its subject’s nearest ancestor scroll container. OK, moving on to adjusting things with ViewTimeline in JavaScript instead. const $images = document.querySelectorAll(.revealing-image); $images.forEach(($image) =\u003e { $image.animate( [ { opacity: 0, clipPath: 'inset(45% 20% 45% 20%)', offset: 0 } { opacity: 1; clipPath: 'inset(0% 0% 0% 0%)', offset: 0.5 } ], { fill: 'both', timeline: new ViewTimeline({ subject: $image, axis: 'block', // Do we have to do this if it's the default? }), } } ) This has the same effect as the CSS-only approach with animation-timeline. Timeline Ranges Demystified Last time, we adjusted where the image’s reveal animation ends by tweaking the keyframes to end at 50% rather than 100%. We could have played with the inset(). But there is an easier way: adjust the animation attachment range, Most scroll animations go from zero scroll to 100% scroll. The animation-range property adjusts that: animation-range: normal normal; Those two values: the start scroll and end scroll, default: animation-range: 0% 100%; Other length units, of course: animation-range: 100px 80vh; The example we’re looking at is a “full-height cover card to fixed header”. Mouthful! But it’s neat, going from an immersive full-page header to a thin, fixed header while scrolling down the page. @keyframes sticky-header { from { background-position: 50% 0; height: 100vh; font-size: calc(4vw + 1em); } to { background-position: 50% 100%; height: 10vh; font-size: calc(4vw + 1em); background-color: #0b1584; } } If we run the animation during scroll, it takes the full animation range, 0%-100%. .sticky-header { position: fixed; top: 0; animation: sticky-header linear forwards; animation-timeline: scroll(); } Like the revealing images from the last video, we want the animation range a little narrower to prevent the header from animating out of view. Last time, we adjusted the keyframes. This time, we’re going with the property approach: .sticky-header { position: fixed; top: 0; animation: sticky-header linear forwards; animation-timeline: scroll(); animation-range: 0vh 90vh; } We had to subtract the full height (100vh) from the header’s eventual height (10vh) to get that 90vh value. I can’t believe this is happening in CSS and not JavaScript! Bramus sagely notes that font-size animation happens on the main thread — it is not hardware-accelerated — and the entire scroll-driven animation runs on the main as a result. Other properties cause this as well, notably custom properties. Back to the animation range. It can be diagrammed like this: The animation “cover range”. The dashed area represents the height of the animated target element. Notice that there are four points in there. We’ve only been chatting about the “start edge” and “end edge” up to this point, but the range covers a larger area in view timelines. So, this: animation-range: 0% 100%; /* same as 'normal normal' */ …to this: animation-range: cover 0% cover 100%; /* 'cover normal cover normal' */ …which is really this: animation-range: cover; So, yeah. That revealing image animation from the last video? We could have done this, rather than fuss with the keyframes or insets: animation-range: cover 0% cover 50%; So nice. The demo visualization is hosted at scroll-driven-animations.style. Oh, and we have keyword values available: contain, entry, exit, entry-crossing, and exit-crossing. contain entry exit The examples so far are based on the scroller being the root element. What about ranges that are taller than the scrollport subject? The ranges become slightly different. Just have to be aware of the element’s size and how it impacts the scrollport. This is where the entry-crossing and entry-exit values come into play. This is a little mind-bendy at first, but I’m sure it’ll get easier with use. It’s clear things can get complex really quickly… which is especially true when we start working with multiple scroll-driven animation with their own animation ranges. Yes, that’s all possible. It’s all good as long as the ranges don’t overlap. Bramus uses a contact list demo where contact items animate when they enter and exit the scrollport. @keyframes animate-in { 0% { opacity: 0; transform: translateY: 100%; } 100% { opacity: 1; transform: translateY: 0%; } } @keyframes animate-out { 0% { opacity: 1; transform: translateY: 0%; } 100% { opacity: 0; transform: translateY: 100%; } } .list-view li { animation: animate-in linear forwards, animate-out linear forwards; animation-timeline: view(); animation-range: entry, exit; /* animation-in, animation-out */ } Another way, using entry and exit keywords directly in the keyframes: @keyframes animate-in { entry 0% { opacity: 0; transform: translateY: 100%; } entry 100% { opacity: 1; transform: translateY: 0%; } } @keyframes animate-out { exit 0% { opacity: 1; transform: translateY: 0%; } exit 100% { opacity: 0; transform: translateY: 100%; } } .list-view li { animation: animate-in linear forwards, animate-out linear forwards; animation-timeline: view(); } Notice that animation-range is no longer needed since its values are declared in the keyframes. Wow. OK, ranges in JavaScript.: const timeline = new ViewTimeline({ subjext: $li, axis: 'block', }) // Animate in $li.animate({ opacity: [ 0, 1 ], transform: [ 'translateY(100%)', 'translateY(0)' ], }, { fill: 'forwards', // One timeline instance with multiple ranges timeline, rangeStart: 'entry: 0%', rangeEnd: 'entry 100%', }) Core Concepts: Timeline Lookup and Named Timelines This time, we’re learning how to attach an animation to any scroll container on the page without needing to be an ancestor of that element. That’s all about named timelines. But first, anonymous timelines track their nearest ancestor scroll container. \u003chtml\u003e \u003c!-- scroll --\u003e \u003cbody\u003e \u003cdiv class=\"wrapper\"\u003e \u003cdiv style=\"animation-timeline: scroll();\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e Some problems might happen like when overflow is hidden from a container: \u003chtml\u003e \u003c!-- scroll --\u003e \u003cbody\u003e \u003cdiv class=\"wrapper\" style=\"overflow: hidden;\"\u003e \u003c!-- scroll --\u003e \u003cdiv style=\"animation-timeline: scroll();\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e Hiding overflow means that the element’s content block is clipped to its padding box and does not provide any scrolling interface. However, the content must still be scrollable programmatically meaning this is still a scroll container. That’s an easy gotcha if there ever was one! The better route is to use overflow: clipped rather than hidden because that prevents the element from becoming a scroll container. Hiding oveflow = scroll container. Clipping overflow = no scroll container. Bramus says he no longer sees any need to use overflow: hidden these days unless you explicitly need to set a scroll container. I might need to change my muscle memory to make that my go-to for hiding clipping overflow. Another funky thing to watch for: absolute positioning on a scroll animation target in a relatively-positioned container. It will never match an outside scroll container that is scroll(inline-nearest) since it is absolute to its container like it’s unable to see out of it. We don’t have to rely on the “nearest” scroll container or fuss with different overflow values. We can set which container to track with named timelines. .gallery { position: relative; } .gallery__scrollcontainer { overflow-x: scroll; scroll-timeline-name: --gallery__scrollcontainer; scroll-timeline-axis: inline; /* container scrolls in the inline direction */ } .gallery__progress { position: absolute; animation: progress linear forwards; animation-timeline: scroll(inline nearest); } We can shorten that up with the scroll-timeline shorthand: .gallery { position: relative; } .gallery__scrollcontainer { overflow-x: scroll; scroll-timeline: --gallery__scrollcontainer inline; } .gallery__progress { position: absolute; animation: progress linear forwards; animation-timeline: scroll(inline nearest); } Note that block is the scroll-timeline-axis initial value. Also, note that the named timeline is a dashed-ident, so it looks like a CSS variable. That’s named scroll timelines. The same is true of named view timlines. .scroll-container { view-timeline-name: --card; view-timeline-axis: inline; view-timeline-inset: auto; /* view-timeline: --card inline auto */ } Bramus showed a demo that recreates Apple’s old cover-flow pattern. It runs two animations, one for rotating images and one for setting an image’s z-index. We can attach both animations to the same view timeline. So, we go from tracking the nearest scroll container for each element in the scroll: .covers li { view-timeline-name: --li-in-and-out-of-view; view-timeline-axis: inline; animation: adjust-z-index linear both; animation-timeline: view(inline); } .cards li \u003e img { animation: rotate-cover linear both; animation-timeline: view(inline); } …and simply reference the same named timelines: .covers li { view-timeline-name: --li-in-and-out-of-view; view-timeline-axis: inline; animation: adjust-z-index linear both; animation-timeline: --li-in-and-out-of-view;; } .cards li \u003e img { animation: rotate-cover linear both; animation-timeline: --li-in-and-out-of-view;; } In this specific demo, the images rotate and scale but the updated sizing does not affect the view timeline: it stays the same size, respecting the original box size rather than flexing with the changes. Phew, we have another tool for attaching animations to timelines that are not direct ancestors: timeline-scope. timeline-scope: --example; This goes on an parent element that is shared by both the animated target and the animated timeline. This way, we can still attach them even if they are not direct ancestors. \u003cdiv style=\"timeline-scope: --gallery\"\u003e \u003cdiv style=\"scroll-timeline: --gallery-inline;\"\u003e ... \u003c/div\u003e \u003cdiv style=\"animation-timeline: --gallery;\"\u003e\u003c/div\u003e \u003c/div\u003e It accepts multiple comma-separated values: timeline-scope: --one, --two, --three; /* or */ timeline-scope: all; /* Chrome 116+ */ There’s no Safari or Firefox support for the all kewword just yet but we can watch for it at Caniuse (or the newer BCD Watch!). This video is considered the last one in the series of “core concepts.” The next five are more focused on use cases and examples. Add Scroll Shadows to a Scroll Container In this example, we’re conditionally showing scroll shadows on a scroll container. Chris calls scroll shadows one his favorite CSS-Tricks of all time and we can nail them with scroll animations. Here is the demo Chris put together a few years ago: That relies on having a background with multiple CSS gradients that are pinned to the extremes with background-attachment: fixed on a single selector. Let’s modernize this, starting with a different approach using pseudos with sticky positioning: .container::before, .container::after { content: \"\"; display: block; position: sticky; left: 0em; right 0em; height: 0.75rem; \u0026::before { top: 0; background: radial-gradient(...); } \u0026::after { bottom: 0; background: radial-gradient(...); } } The shadows fade in and out with a CSS animation: @keyframes reveal { 0% { opacity: 0; } 100% { opacity: 1; } } .container { overflow:-y auto; scroll-timeline: --scroll-timeline block; /* do we need `block`? */ \u0026::before, \u0026::after { animation: reveal linear both; animation-timeline: --scroll-timeline; } } This example rocks a named timeline, but Bramus notes that an anonymous one would work here as well. Seems like anonymous timelines are somewhat fragile and named timelines are a good defensive strategy. The next thing we need is to set the animation’s range so that each pseudo scrolls in where needed. Calculating the range from the top is fairly straightforward: .container::before { animation-range: 1em 2em; } The bottom is a little tricker. It should start when there are 2em of scrolling and then only travel for 1em. We can simply reverse the animation and add a little calculation to set the range based on it’s bottom edge. .container::after { animation-direction: reverse; animation-range: calc(100% - 2em) calc(100% - 1em); } Still one more thing. We only want the shadows to reveal when we’re in a scroll container. If, for example, the box is taller than the content, there is no scrolling, yet we get both shadows. This is where the conditional part comes in. We can detect whether an element is scrollable and react to it. Bramus is talking about an animation keyword that’s new to me: detect-scroll. @keyframes detect-scroll { from, to { --can-scroll: ; /* value is a single space and acts as boolean */ } } .container { animation: detect-scroll; animation-timeline: --scroll-timeline; animation-fill-mode: none; } Gonna have to wrap my head around this… but the general idea is that --can-scroll is a boolean value we can use to set visibility on the pseudos: .content::before, .content::after { --vis-if-can-scroll: var(--can-scroll) visible; --vis-if-cant-scroll: hidden; visibility: var(--vis-if-can-scroll, var(--vis-if-cant-scroll)); } Bramus points to this CSS-Tricks article for more on the conditional toggle stuff. Animate Elements in Different Directions This should be fun! Let’s say we have a set of columns: \u003cdiv class=\"columns\"\u003e \u003cdiv class=\"column reverse\"\u003e...\u003c/div\u003e \u003cdiv class=\"column\"\u003e...\u003c/div\u003e \u003cdiv class=\"column reverse\"\u003e...\u003c/div\u003e \u003c/div\u003e The goal is getting the two outer reverse columns to scroll in the opposite direction as the inner column scrolls in the other direction. Classic JavaScript territory! The columns are set up in a grid container. The columns flex in the column direction. /* run if the browser supports it */ @supports (animation-timeline: scroll()) { .column-reverse { transform: translateY(calc(-100% + 100vh)); flex-direction: column-reverse; /* flows in reverse order */ } .columns { overflow-y: clip; /* not a scroll container! */ } } First, the outer columns are pushed all the way up so the bottom edges are aligned with the viewport’s top edge. Then, on scroll, the outer columns slide down until their top edges re aligned with the viewport’s bottom edge. The CSS animation: @keyframes adjust-position { from /* the top */ { transform: translateY(calc(-100% + 100vh)); } to /* the bottom */ { transform: translateY(calc(100% - 100vh)); } } .column-reverse { animation: adjust-position linear forwards; animation-timeline: scroll(root block); /* viewport in block direction */ } The approach is similar in JavaScript: const timeline = new ScrollTimeline({ source: document.documentElement, }); document.querySelectorAll(\".column-reverse\").forEach($column) =\u003e { $column.animate( { transform: [ \"translateY(calc(-100% + 100vh))\", \"translateY(calc(100% - 100vh))\" ] }, { fill: \"both\", timeline, } ); } Animate 3D Models and More on Scroll This one’s working with a custom element for a 3D model: \u003cmodel-viewer alt=\"Robot\" src=\"robot.glb\"\u003e\u003c/model-viewer\u003e First, the scroll-driven animation. We’re attaching an animation to the component but not defining the keyframes just yet. @keyframes foo { } model-viewer { animation: foo linear both; animation-timeline: scroll(block root); /* root scroller in block direction */ } There’s some JavaScript for the full rotation and orientation: // Bramus made a little helper for handling the requested animation frames import { trackProgress } from \"https://esm.sh/@bramus/sda-utilities\"; // Select the component const $model = document.QuerySelector(\"model-viewer\"); // Animation begins with the first iteration const animation = $model.getAnimations()[0]; // Variable to get the animation's timing info let progress = animation.effect.getComputedTiming().progress * 1; // If when finished, $progress = 1 if (animation.playState === \"finished\") progress = 1; progress = Math.max(0.0, Math.min(1.0, progress)).toFixed(2); // Convert this to degrees $model.orientation = `0deg 0deg $(progress * -360)deg`; We’re using the effect to get the animation’s progress rather than the current timed spot. The current time value is always measured relative to the full range, so we need the effect to get the progress based on the applied animation. Scroll Velocity Detection The video description is helpful: Bramus goes full experimental and uses Scroll-Driven Animations to detect the active scroll speed and the directionality of scroll. Detecting this allows you to style an element based on whether the user is scrolling (or not scrolling), the direction they are scrolling in, and the speed they are scrolling with … and this all using only CSS. First off, this is a hack. What we’re looking at is expermental and not very performant. We want to detect the animations’s velocity and direction. We start with two custom properties. @keyframes adjust-pos { from { --scroll-position: 0; --scroll-position-delayed: 0; } to { --scroll-position: 1; --scroll-position-delayed: 1; } } :root { animation: adjust-pos linear both; animation-timeline: scroll(root); } Let’s register those custom properties so we can interpolate the values: @property --scroll-position { syntax: \"\u003cnumber\u003e\"; inherits: true; initial-value: 0; } @property --scroll-position-delayed { syntax: \"\u003cnumber\u003e\"; inherits: true; initial-value: 0; } As we scroll, those values change. If we add a little delay, then we can stagger things a bit: :root { animation: adjust-pos linear both; animation-timeline: scroll(root); } body { transition: --scroll-position-delayed 0.15s linear; } The fact that we’re applying this to the body is part of the trick because it depends on the parent-child relationship between html and body. The parent element updates the values immediately while the child lags behind just a tad. The evaluate to the same value, but one is slower to start. We can use the difference between the two values as they are staggered to get the velocity. :root { animation: adjust-pos linear both; animation-timeline: scroll(root); } body { transition: --scroll-position-delayed 0.15s linear; --scroll-velocity: calc( var(--scroll-position) - var(--scroll-position-delayed) ); } Clever! If --scroll-velocity is equal to 0, then we know that the user is not scrolling because the two values are in sync. A positive number indicates the scroll direction is down, while a negative number indicates scrolling up,. There’s a little discrepancy when scrolling abruptly changes direction. We can fix this by tighening the transition delay of --scroll-position-delayed but then we’re increasing the velocity. We might need a multiplier to further correct that… that’s why this is a hack. But now we have a way to sniff the scrolling speed and direction! Here’s the hack using math functions: body { transition: --scroll-position-delayed 0.15s linear; --scroll-velocity: calc( var(--scroll-position) - var(--scroll-position-delayed) ); --scroll-direction: sign(var(--scroll-velocity)); --scroll-speed: abs(var(--scroll-velocity)); } This is a little funny because I’m seeing that Chrome does not yet support sign() or abs(), at least at the time I’m watching this. Gotta enable chrome://flags. There’s a polyfill for the math brought to you by Ana Tudor right here on CSS-Tricks. So, now we could theoretically do something like skew an element by a certain amount or give it a certain level of background color saturation depending on the scroll speed. .box { transform: skew(calc(var(--scroll-velocity) * -25deg)); transition: background 0.15s ease; background: hsl( calc(0deg + (145deg * var(--scroll-direction))) 50 % 50% ); } We could do all this with style queries should we want to: @container style(--scroll-direction: 0) { /* idle */ .slider-item { background: crimson; } } @container style(--scroll-direction: 1) { /* scrolling down */ .slider-item { background: forestgreen; } } @container style(--scroll-direction: -1) { /* scrolling down */ .slider-item { background: lightskyblue; } } Custom properties, scroll-driven animations, and style queries — all in one demo! These are wild times for CSS, tell ya what. Outro The tenth and final video! Just a summary of the series, so no new notes here. But here’s a great demo to cap it off.",
  "image": "https://css-tricks.com/wp-json/social-image-generator/v1/image/381613",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cp\u003e\n\tDigitalOcean provides cloud products for every stage of your journey. Get started with \u003ca href=\"https://try.digitalocean.com/css-tricks/?utm_medium=content_acq\u0026amp;utm_source=css-tricks\u0026amp;utm_campaign=global_brand_ad_en\u0026amp;utm_content=conversion_prearticle_everystage\"\u003e$200 in free credit!\u003c/a\u003e\n\u003c/p\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eI’m utterly behind in learning about scroll-driven animations apart from the “reading progress bar” experiments all over CodePen. Well, I’m not exactly “green” on the topic; we’ve published a handful of articles on it including \u003ca href=\"https://css-tricks.com/slide-through-unlimited-dimensions-with-css-scroll-timelines/\"\u003ethis neat-o one by Lee Meyer\u003c/a\u003e published the other week.\u003c/p\u003e\n\n\n\n\u003cp\u003eOur \u003ca href=\"https://css-tricks.com/practical-use-cases-for-scroll-linked-animations-in-css-with-scroll-timelines/\"\u003e“oldest” article\u003c/a\u003e about the feature is by Bramus, dated back to July 2021. We were calling it “scroll-linked” animation back then. I specifically mention Bramus because there’s no one else working as hard as he is to discover practical use cases where scroll-\u003cem\u003edriven\u003c/em\u003e animations shine while helping everyone understand the concept. He writes about it exhaustively \u003ca href=\"https://www.bram.us/tag/scroll-driven-animations/\" rel=\"noopener\"\u003eon his personal blog\u003c/a\u003e in addition to writing the \u003ca href=\"https://developer.chrome.com/docs/css-ui/scroll-driven-animations\" rel=\"noopener\"\u003eChrome for Developers documentation on it\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut there’s also this free course he calls \u003ca href=\"https://www.youtube.com/playlist?list=PLNYkxOF6rcICM3ttukz9x5LCNOHfWBVnn\" rel=\"noopener\"\u003e“Unleash the Power of Scroll-Driven Animations”\u003c/a\u003e published on YouTube as a series of 10 short videos. I decided it was high time to sit, watch, and learn from one of the best. These are my notes from it.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\u003ch3 id=\"introduction\"\u003eIntroduction\u003c/h3\u003e\n\n\n\u003cul\u003e\n\u003cli\u003eA scroll-driven animation is an animation that responds to scrolling. There’s a direct link between scrolling progress and the animation’s progress.\u003c/li\u003e\n\n\n\n\u003cli\u003eScroll-\u003cem\u003edriven\u003c/em\u003e animations are different than scroll-\u003cem\u003etriggered\u003c/em\u003e animations, which execute on scroll and run in their entirety. Scroll-driven animations pause, play, and run with the direction of the scroll. It sounds to me like scroll-triggered animations are a lot like the CSS version of the JavaScript \u003ca href=\"https://css-tricks.com/an-explanation-of-how-the-intersection-observer-watches/?ref=csslayout.news\"\u003eintersection observer\u003c/a\u003e that fires and plays independently of scroll.\u003c/li\u003e\n\n\n\n\u003cli\u003eWhy learn this? It’s super easy to take an existing CSS animation or a WAAPI animation and link it up to scrolling. The only “new” thing to learn is how to attach an animation to scrolling. Plus, hey, it’s the platform!\u003c/li\u003e\n\n\n\n\u003cli\u003eThere are also performance perks. JavsScript libraries that establish scroll-driven animations typically respond to scroll events on the main thread, which is render-blocking… and JANK! We’re working with hardware-accelerated animations… and NO JANK. Yuriko Hirota has a \u003ca href=\"https://developer.chrome.com/blog/scroll-animation-performance-case-study/\" rel=\"noopener\"\u003ecase study on the performance of scroll-driven animations\u003c/a\u003e published on the Chrome blog.\u003c/li\u003e\n\n\n\n\u003cli\u003eSupported in Chrome 115+. Can use \u003ccode\u003e@supports (animation-timeline: scroll())\u003c/code\u003e. However, I recently saw \u003ca href=\"https://www.bram.us/2024/09/24/feature-detecting-scroll-driven-animations-you-want-to-check-for-animation-range-too/\" rel=\"noopener\"\u003eBramus publish an update\u003c/a\u003e saying we need to look for \u003ccode\u003eanimation-range\u003c/code\u003e support as well.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports ((animation-timeline: scroll()) and (animation-range: 0% 100%)) {\n  /* Scroll-Driven Animations related styles go here */\n  /* This check excludes Firefox Nightly which only has a partial implementation at the moment of posting (mid-September 2024). */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eRemember to use \u003ccode\u003eprefers-reduced-motion\u003c/code\u003e and be mindful of those who may not want them.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\n\n\n\u003ch3 id=\"core-concepts-scroll-and-scrolltimeline\"\u003eCore Concepts: \u003ccode\u003escroll()\u003c/code\u003e and \u003ccode\u003eScrollTimeline\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003eLet’s take an existing CSS animation.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@keyframes grow-progress {\n  from {\n    transform: scaleX(0);\n  }\n  to {\n    transform: scaleX(1);\n  }\n}\n\n#progress {\n  animation: grow-progress 2s linear forwards;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTranslation: Start with no width and scale it to its full width. When applied, it takes two seconds to complete and moves with linear easing just in the \u003ccode\u003eforwards\u003c/code\u003e direction.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis just runs when the \u003ccode\u003e#progress\u003c/code\u003e element is rendered. Let’s attach it to scrolling.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eanimation-timeline\u003c/code\u003e: The timeline that controls the animation’s progress.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003escroll()\u003c/code\u003e: Creates a new scroll timeline set up to track the nearest ancestor scroller in the block direction.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e#progress {\n  animation: grow-progress 2s linear forwards;\n  animation-timeline: scroll();\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThat’s it! We’re linked up. Now we can remove the \u003ccode\u003eanimation-duration\u003c/code\u003e value from the mix (or set it to \u003ccode\u003eauto\u003c/code\u003e):\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e#progress {\n  animation: grow-progress linear forwards;\n  animation-timeline: scroll();\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNote that we’re unable to plop the \u003ccode\u003eanimation-timeline\u003c/code\u003e property on the \u003ccode\u003eanimation\u003c/code\u003e shorthand, at least for now. Bramus calls it a “reset-only sub-property of the shorthand” which is a new term to me. Its value gets reset when you use the shorthand the same way \u003ccode\u003ebackground-color\u003c/code\u003e is reset by \u003ccode\u003ebackground\u003c/code\u003e. That means the best practice is to declare \u003ccode\u003eanimation-timeline\u003c/code\u003e \u003cem\u003eafter\u003c/em\u003e \u003ccode\u003eanimation\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* YEP! */\n#progress {\n  animation: grow-progress linear forwards;\n  animation-timeline: scroll();\n}\n\n/* NOPE! */\n#progress {\n  animation-timeline: scroll();\n  animation: grow-progress linear forwards;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s talk about the \u003ccode\u003escroll()\u003c/code\u003e function. It creates an anonymous scroll timeline that “walks up” the ancestor tree from the target element to the nearest ancestor scroll. In this example, the nearest ancestor scroll is the \u003ccode\u003e:root\u003c/code\u003e element, which is tracked in the block direction. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"1648\" height=\"1094\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.27.02%E2%80%AFAM.png?resize=1648%2C1094\u0026amp;ssl=1\" alt=\"Showing the relationship between an element and its scrolling ancestor.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.27.02%E2%80%AFAM.png?w=1648\u0026amp;ssl=1 1648w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.27.02%E2%80%AFAM.png?resize=300%2C199\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.27.02%E2%80%AFAM.png?resize=1024%2C680\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.27.02%E2%80%AFAM.png?resize=768%2C510\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.27.02%E2%80%AFAM.png?resize=1536%2C1020\u0026amp;ssl=1 1536w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWe can name scroll timelines, but that’s in another video. For now, know that we can adjust which axis to track and which scroller to target in the \u003ccode\u003escroll()\u003c/code\u003e function.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eanimation-timeline: scroll(\u0026lt;axis\u0026gt; \u0026lt;scroller\u0026gt;);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;axis\u0026gt;\u003c/code\u003e: The axis — be it \u003ccode\u003eblock\u003c/code\u003e (default), \u003ccode\u003einline\u003c/code\u003e, \u003ccode\u003ey\u003c/code\u003e, or \u003ccode\u003ex\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e\u0026lt;scroller\u0026gt;\u003c/code\u003e: The scroll container element that defines the scroll position that influences the timeline’s progress, which can be \u003ccode\u003enearest\u003c/code\u003e (default), \u003ccode\u003eroot\u003c/code\u003e (the document), or \u003ccode\u003eself\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIf the root element does not have an overflow, then the animation becomes inactive. \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API\" rel=\"noopener\"\u003eWAAPI\u003c/a\u003e gives us a way to establish scroll timelines in JavaScript with \u003ccode\u003eScrollTimeline\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"10,11,12\"\u003e\u003ccode markup=\"tt\"\u003econst $progressbar = document.querySelector(#progress);\n\n$progressbar.style.transformOrigin = \u0026#39;0% 50%\u0026#39;;\n$progressbar.animate(\n  {\n    transform: [\u0026#39;scaleX(0)\u0026#39;, \u0026#39;scaleY()\u0026#39;],\n  },\n  {\n    fill: \u0026#39;forwards\u0026#39;,\n    timeline: new ScrollTimeline({\n      source: document.documentElement, // root element\n      // can control `axis` here as well\n    }),\n  }\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\u003ch3 id=\"core-concepts-view-and-viewtimeline\"\u003eCore Concepts: \u003ccode\u003eview()\u003c/code\u003e and \u003ccode\u003eViewTimeline\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003eFirst, we oughta distinguish a \u003cstrong\u003escroll container\u003c/strong\u003e from a \u003cstrong\u003escroll port\u003c/strong\u003e. Overflow can be visible or clipped. Clipped could be scrolling.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1756\" height=\"1022\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.57.37%E2%80%AFAM.png?resize=1756%2C1022\u0026amp;ssl=1\" alt=\"Diagram showing scrollport, scroll container, and scrollable overflow.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.57.37%E2%80%AFAM.png?w=1756\u0026amp;ssl=1 1756w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.57.37%E2%80%AFAM.png?resize=300%2C175\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.57.37%E2%80%AFAM.png?resize=1024%2C596\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.57.37%E2%80%AFAM.png?resize=768%2C447\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-10.57.37%E2%80%AFAM.png?resize=1536%2C894\u0026amp;ssl=1 1536w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThose two bordered boxes show how easy it is to conflate scrollports and scroll containers. The \u003cstrong\u003escrollport\u003c/strong\u003e is the visible part and coincides with the scroll container’s \u003ccode\u003epadding-box\u003c/code\u003e. When a scrollbar is present, that plus the scroll container is the root scroller, or the \u003cstrong\u003escroll container\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"551\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-11.04.51%E2%80%AFAM.png?resize=1024%2C551\u0026amp;ssl=1\" alt=\"Diagram showing the root scroller.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-11.04.51%E2%80%AFAM.png?resize=1024%2C551\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-11.04.51%E2%80%AFAM.png?resize=300%2C162\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-11.04.51%E2%80%AFAM.png?resize=768%2C413\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-11.04.51%E2%80%AFAM.png?resize=1536%2C827\u0026amp;ssl=1 1536w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-03-at-11.04.51%E2%80%AFAM.png?w=2032\u0026amp;ssl=1 2032w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eA view timeline tracks the relative position of a subject within a scrollport. Now we’re getting into \u003ccode\u003eIntersectionObserver\u003c/code\u003e territory! So, for example, we can begin an animation on the scroll timeline when an element intersects with another, such as the target element intersecting the viewport, then it progresses with scrolling.\u003c/p\u003e\n\n\n\n\u003cp\u003eBramus walks through an example of animating images in long-form content when they intersect with the viewport. First, a CSS animation to reveal an image from zero opacity to full opacity (with some added clipping).\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@keyframes reveal {\n  from {\n    opacity: 0;\n    clip-path: inset(45% 20% 45% 20%);\n  }\n  to {\n    opacity: 1;\n    clip-path: inset(0% 0% 0% 0%);\n  }\n}\n\n.revealing-image {\n  animation: reveal 1s linear both;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis currently runs on the document’s timeline. In the last video, we used \u003ccode\u003escroll()\u003c/code\u003e to register a scroll timeline. Now, let’s use the \u003ccode\u003eview()\u003c/code\u003e function to register a view timeline instead. This way, we’re responding to when a \u003ccode\u003e.revealing-image\u003c/code\u003e element is in, well, view.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"4\"\u003e\u003ccode markup=\"tt\"\u003e.revealing-image {\n  animation: reveal 1s linear both;\n  /* Rember to declare the timeline after the shorthand */\n  animation-timeline: view();\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAt this point, however, the animation is nice but only completes when the element fully exits the viewport, meaning we don’t get to see the entire thing. There’s a recommended way to fix this that Bramus will cover in another video. For now, we’re speeding up the keyframes instead by completing the animation at the \u003ccode\u003e50%\u003c/code\u003e mark.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"6\"\u003e\u003ccode markup=\"tt\"\u003e@keyframes reveal {\n  from {\n    opacity: 0;\n    clip-path: inset(45% 20% 45% 20%);\n  }\n  50% {\n    opacity: 1;\n    clip-path: inset(0% 0% 0% 0%);\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eMore on the \u003ccode\u003eview()\u003c/code\u003e function:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eanimation-timeline: view(\u0026lt;axis\u0026gt; \u0026lt;view-timeline-inset\u0026gt;);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe know \u003ccode\u003e\u0026lt;axis\u0026gt;\u003c/code\u003e from the \u003ccode\u003escroll()\u003c/code\u003e function — it’s the same deal. The \u003ccode\u003e\u0026lt;view-timeline-inset\u0026gt;\u003c/code\u003e is a way of adjusting the visibility range of the view progress (what a mouthful!) that we can set to \u003ccode\u003eauto\u003c/code\u003e (default) or a \u003ccode\u003e\u0026lt;length-percentage\u0026gt;\u003c/code\u003e. A \u003cem\u003epositive\u003c/em\u003e inset moves in an \u003cem\u003eoutward\u003c/em\u003e adjustment while a \u003cem\u003enegative\u003c/em\u003e value moves in an \u003cem\u003einward\u003c/em\u003e adjustment. And notice that there is no \u003ccode\u003e\u0026lt;scroller\u0026gt;\u003c/code\u003e argument — \u003cstrong\u003ea view timeline always tracks its subject’s nearest ancestor scroll container.\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eOK, moving on to adjusting things with \u003ccode\u003eViewTimeline\u003c/code\u003e in JavaScript instead.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"11,12,13,14\"\u003e\u003ccode markup=\"tt\"\u003econst $images = document.querySelectorAll(.revealing-image);\n\n$images.forEach(($image) =\u0026gt; {\n  $image.animate(\n    [\n      { opacity: 0, clipPath: \u0026#39;inset(45% 20% 45% 20%)\u0026#39;, offset: 0 }\n      { opacity: 1; clipPath: \u0026#39;inset(0% 0% 0% 0%)\u0026#39;, offset: 0.5 }\n    ],\n    {\n      fill: \u0026#39;both\u0026#39;,\n      timeline: new ViewTimeline({\n        subject: $image,\n        axis: \u0026#39;block\u0026#39;, // Do we have to do this if it\u0026#39;s the default?\n      }),\n    }\n  }\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis has the same effect as the CSS-only approach with \u003ccode\u003eanimation-timeline\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"timeline-ranges-demystified\"\u003eTimeline Ranges Demystified\u003c/h3\u003e\n\n\n\u003cp\u003eLast time, we adjusted where the image’s \u003ccode\u003ereveal\u003c/code\u003e animation ends by tweaking the keyframes to end at \u003ccode\u003e50%\u003c/code\u003e rather than \u003ccode\u003e100%\u003c/code\u003e. We could have played with the \u003ccode\u003einset()\u003c/code\u003e. But there is an easier way: \u003cstrong\u003eadjust the animation attachment range,\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eMost scroll animations go from zero scroll to 100% scroll. The \u003ccode\u003eanimation-range\u003c/code\u003e property adjusts that:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eanimation-range: normal normal;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThose two values: the start scroll and end scroll, default:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eanimation-range: 0% 100%;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOther \u003ca href=\"https://css-tricks.com/css-length-units/\"\u003elength units\u003c/a\u003e, of course:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eanimation-range: 100px 80vh;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe example we’re looking at is a “full-height cover card to fixed header”. Mouthful! But it’s neat, going from an immersive full-page header to a thin, fixed header while scrolling down the page.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@keyframes sticky-header {\n  from {\n    background-position: 50% 0;\n    height: 100vh;\n    font-size: calc(4vw + 1em);\n  }\n  to {\n    background-position: 50% 100%;\n    height: 10vh;\n    font-size: calc(4vw + 1em);\n    background-color: #0b1584;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf we run the animation during scroll, it takes the full animation range, 0%-100%.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.sticky-header {\n  position: fixed;\n  top: 0;\n\n  animation: sticky-header linear forwards;\n  animation-timeline: scroll();\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLike the revealing images from the last video, we want the animation range a little narrower to prevent the header from animating out of view. Last time, we adjusted the keyframes. This time, we’re going with the property approach:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"7\"\u003e\u003ccode markup=\"tt\"\u003e.sticky-header {\n  position: fixed;\n  top: 0;\n\n  animation: sticky-header linear forwards;\n  animation-timeline: scroll();\n  animation-range: 0vh 90vh;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe had to subtract the full height (\u003ccode\u003e100vh\u003c/code\u003e) from the header’s eventual height (\u003ccode\u003e10vh\u003c/code\u003e) to get that \u003ccode\u003e90vh\u003c/code\u003e value. I can’t believe this is happening in CSS and not JavaScript! Bramus sagely notes that \u003ccode\u003efont-size\u003c/code\u003e animation happens on the main thread — it is not hardware-accelerated — and the entire scroll-driven animation runs on the main as a result. Other properties cause this as well, \u003ca href=\"https://www.bram.us/2023/02/01/the-gotcha-with-animating-custom-properties/\" rel=\"noopener\"\u003enotably custom properties\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eBack to the animation range. It can be diagrammed like this:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"872\" height=\"514\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.04.20%E2%80%AFAM.png?resize=872%2C514\u0026amp;ssl=1\" alt=\"Visual demo showing the animation\u0026#39;s full range.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.04.20%E2%80%AFAM.png?w=872\u0026amp;ssl=1 872w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.04.20%E2%80%AFAM.png?resize=300%2C177\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.04.20%E2%80%AFAM.png?resize=768%2C453\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003cfigcaption\u003eThe animation “cover range”. The dashed area represents the height of the animated target element.\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNotice that there are \u003cem\u003efour\u003c/em\u003e points in there. We’ve only been chatting about the “start edge” and “end edge” up to this point, but the range covers a larger area in view timelines. So, this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eanimation-range: 0% 100%; /* same as \u0026#39;normal normal\u0026#39; */\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e…to this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eanimation-range: cover 0% cover 100%; /* \u0026#39;cover normal cover normal\u0026#39; */\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e…which is really this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eanimation-range: cover;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSo, yeah. That revealing image animation from the last video? We could have done this, rather than fuss with the keyframes or insets:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eanimation-range: cover 0% cover 50%;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSo nice. The demo visualization is hosted at \u003ca href=\"https://scroll-driven-animations.style/tools/view-timeline/ranges/#range-start-name=cover\u0026amp;range-start-percentage=0\u0026amp;range-end-name=cover\u0026amp;range-end-percentage=100\u0026amp;view-timeline-axis=block\u0026amp;view-timeline-inset=0\u0026amp;subject-size=smaller\u0026amp;subject-animation=reveal\u0026amp;interactivity=clicktodrag\u0026amp;show-areas=yes\u0026amp;show-fromto=yes\u0026amp;show-labels=yes\" rel=\"noopener\"\u003e\u003ccode\u003escroll-driven-animations.style\u003c/code\u003e\u003c/a\u003e. Oh, and we have keyword values available: \u003ccode\u003econtain\u003c/code\u003e, \u003ccode\u003eentry\u003c/code\u003e, \u003ccode\u003eexit\u003c/code\u003e, \u003ccode\u003eentry-crossing\u003c/code\u003e, and \u003ccode\u003eexit-crossing\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1214\" height=\"696\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.17.44%E2%80%AFAM.png?resize=1214%2C696\u0026amp;ssl=1\" alt=\"Showing a contained animation range.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.17.44%E2%80%AFAM.png?w=1214\u0026amp;ssl=1 1214w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.17.44%E2%80%AFAM.png?resize=300%2C172\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.17.44%E2%80%AFAM.png?resize=1024%2C587\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.17.44%E2%80%AFAM.png?resize=768%2C440\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003cfigcaption\u003e\u003ccode\u003econtain\u003c/code\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1360\" height=\"844\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.19.13%E2%80%AFAM.png?resize=1360%2C844\u0026amp;ssl=1\" alt=\"Showing an entry animation range.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.19.13%E2%80%AFAM.png?w=1360\u0026amp;ssl=1 1360w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.19.13%E2%80%AFAM.png?resize=300%2C186\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.19.13%E2%80%AFAM.png?resize=1024%2C635\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.19.13%E2%80%AFAM.png?resize=768%2C477\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003cfigcaption\u003e\u003ccode\u003eentry\u003c/code\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"666\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.19.53%E2%80%AFAM.png?resize=1024%2C666\u0026amp;ssl=1\" alt=\"Showing an exit animation range.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.19.53%E2%80%AFAM.png?resize=1024%2C666\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.19.53%E2%80%AFAM.png?resize=300%2C195\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.19.53%E2%80%AFAM.png?resize=768%2C500\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.19.53%E2%80%AFAM.png?w=1288\u0026amp;ssl=1 1288w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003cfigcaption\u003e\u003ccode\u003eexit\u003c/code\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe examples so far are based on the scroller being the root element. What about ranges that are \u003cem\u003etaller\u003c/em\u003e than the scrollport subject? The ranges become slightly different.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1752\" height=\"1002\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.24.21%E2%80%AFAM.png?resize=1752%2C1002\u0026amp;ssl=1\" alt=\"An element larger than the scrollport where contain equals 100% when out of range but 0% before it actually reaches the end of the animation.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.24.21%E2%80%AFAM.png?w=1752\u0026amp;ssl=1 1752w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.24.21%E2%80%AFAM.png?resize=300%2C172\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.24.21%E2%80%AFAM.png?resize=1024%2C586\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.24.21%E2%80%AFAM.png?resize=768%2C439\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-04-at-8.24.21%E2%80%AFAM.png?resize=1536%2C878\u0026amp;ssl=1 1536w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003cfigcaption\u003eJust have to be aware of the element’s size and how it impacts the scrollport.\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThis is where the \u003ccode\u003eentry-crossing\u003c/code\u003e and \u003ccode\u003eentry-exit\u003c/code\u003e values come into play. This is a little mind-bendy at first, but I’m sure it’ll get easier with use. It’s clear things can get complex really quickly… which is especially true when we start working with \u003cstrong\u003emultiple scroll-driven animation with their own animation ranges\u003c/strong\u003e. Yes, that’s all possible. It’s all good as long as the ranges don’t overlap. Bramus uses a contact list demo where contact items animate when they enter and exit the scrollport.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@keyframes animate-in {\n  0% { opacity: 0; transform: translateY: 100%; }\n  100% { opacity: 1; transform: translateY: 0%; }\n}\n@keyframes animate-out {\n  0% { opacity: 1; transform: translateY: 0%; }\n  100% { opacity: 0; transform: translateY: 100%; }\n}\n\n.list-view li {\n  animation: animate-in linear forwards,\n             animate-out linear forwards;\n  animation-timeline: view();\n  animation-range: entry, exit; /* animation-in, animation-out */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnother way, using \u003ccode\u003eentry\u003c/code\u003e and \u003ccode\u003eexit\u003c/code\u003e keywords directly in the keyframes:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@keyframes animate-in {\n  entry 0% { opacity: 0; transform: translateY: 100%; }\n  entry 100% { opacity: 1; transform: translateY: 0%; }\n}\n@keyframes animate-out {\n  exit 0% { opacity: 1; transform: translateY: 0%; }\n  exit 100% { opacity: 0; transform: translateY: 100%; }\n}\n\n.list-view li {\n  animation: animate-in linear forwards,\n             animate-out linear forwards;\n  animation-timeline: view();\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNotice that \u003ccode\u003eanimation-range\u003c/code\u003e is no longer needed since its values are declared in the keyframes. Wow.\u003c/p\u003e\n\n\n\n\u003cp\u003eOK, ranges in JavaScript.:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"14,15\"\u003e\u003ccode markup=\"tt\"\u003econst timeline = new ViewTimeline({\n  subjext: $li,\n  axis: \u0026#39;block\u0026#39;,\n})\n\n// Animate in\n$li.animate({\n  opacity: [ 0, 1 ],\n  transform: [ \u0026#39;translateY(100%)\u0026#39;, \u0026#39;translateY(0)\u0026#39; ],\n}, {\n  fill: \u0026#39;forwards\u0026#39;,\n  // One timeline instance with multiple ranges\n  timeline,\n  rangeStart: \u0026#39;entry: 0%\u0026#39;,\n  rangeEnd: \u0026#39;entry 100%\u0026#39;,\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\u003ch3 id=\"core-concepts-timeline-lookup-and-named-timelines\"\u003eCore Concepts: Timeline Lookup and Named Timelines\u003c/h3\u003e\n\n\n\u003cp\u003eThis time, we’re learning how to attach an animation to any scroll container on the page without needing to be an ancestor of that element. That’s all about \u003cstrong\u003enamed timelines\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut first, anonymous timelines track their nearest ancestor scroll container.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;html\u0026gt; \u0026lt;!-- scroll --\u0026gt;\n  \u0026lt;body\u0026gt;\n    \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt;\n      \u0026lt;div style=\u0026#34;animation-timeline: scroll();\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n    \u0026lt;/div\u0026gt;\n  \u0026lt;/body\u0026gt;\n\u0026lt;/html\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSome problems might happen like when overflow is hidden from a container:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;html\u0026gt; \u0026lt;!-- scroll --\u0026gt;\n  \u0026lt;body\u0026gt;\n    \u0026lt;div class=\u0026#34;wrapper\u0026#34; style=\u0026#34;overflow: hidden;\u0026#34;\u0026gt; \u0026lt;!-- scroll --\u0026gt;\n      \u0026lt;div style=\u0026#34;animation-timeline: scroll();\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n    \u0026lt;/div\u0026gt;\n  \u0026lt;/body\u0026gt;\n\u0026lt;/html\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eHiding overflow means that the element’s content block is clipped to its padding box and does not provide any scrolling interface. However, \u003cstrong\u003ethe content must still be scrollable programmatically\u003c/strong\u003e meaning this is still a scroll container. That’s an easy gotcha if there ever was one! The better route is to use \u003ccode\u003eoverflow: clipped\u003c/code\u003e rather than \u003ccode\u003ehidden\u003c/code\u003e because that prevents the element from becoming a scroll container.\u003c/p\u003e\n\n\n\n\u003cp\u003eHiding oveflow = scroll container. Clipping overflow = no scroll container. Bramus says he no longer sees any need to use \u003ccode\u003eoverflow: hidden\u003c/code\u003e these days unless you explicitly need to set a scroll container. I might need to change my muscle memory to make that my go-to for \u003cs\u003ehiding\u003c/s\u003e clipping overflow.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnother funky thing to watch for: absolute positioning on a scroll animation target in a relatively-positioned container. It will never match an outside scroll container that is \u003ccode\u003escroll(inline-nearest)\u003c/code\u003e since it is absolute to its container like it’s unable to see out of it.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe don’t have to rely on the “nearest” scroll container or fuss with different \u003ccode\u003eoverflow\u003c/code\u003e values. We can set which container to track with \u003cstrong\u003enamed timelines\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"6-7\"\u003e\u003ccode markup=\"tt\"\u003e.gallery {\n  position: relative;\n}\n.gallery__scrollcontainer {\n  overflow-x: scroll;\n  scroll-timeline-name: --gallery__scrollcontainer;\n  scroll-timeline-axis: inline; /* container scrolls in the inline direction */\n}\n.gallery__progress {\n  position: absolute;\n  animation: progress linear forwards;\n  animation-timeline: scroll(inline nearest);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe can shorten that up with the \u003ccode\u003escroll-timeline\u003c/code\u003e shorthand:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"6\"\u003e\u003ccode markup=\"tt\"\u003e.gallery {\n  position: relative;\n}\n.gallery__scrollcontainer {\n  overflow-x: scroll;\n  scroll-timeline: --gallery__scrollcontainer inline;\n}\n.gallery__progress {\n  position: absolute;\n  animation: progress linear forwards;\n  animation-timeline: scroll(inline nearest);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNote that \u003ccode\u003eblock\u003c/code\u003e is the \u003ccode\u003escroll-timeline-axis\u003c/code\u003e initial value. Also, note that the named timeline is a dashed-ident, so it looks like a CSS variable.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat’s named scroll timelines. The same is true of \u003cstrong\u003enamed view timlines\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.scroll-container {\n  view-timeline-name: --card;\n  view-timeline-axis: inline;\n  view-timeline-inset: auto;\n  /* view-timeline: --card inline auto */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBramus showed a demo that recreates Apple’s old cover-flow pattern. It runs two animations, one for rotating images and one for setting an image’s \u003ccode\u003ez-index\u003c/code\u003e. We can attach both animations to the same view timeline. So, we go from tracking the nearest scroll container for each element in the scroll:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.covers li {\n  view-timeline-name: --li-in-and-out-of-view;\n  view-timeline-axis: inline;\n\n  animation: adjust-z-index linear both;\n  animation-timeline: view(inline);\n}\n.cards li \u0026gt; img {\n   animation: rotate-cover linear both;\n   animation-timeline: view(inline);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e…and simply reference the same named timelines:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.covers li {\n  view-timeline-name: --li-in-and-out-of-view;\n  view-timeline-axis: inline;\n\n  animation: adjust-z-index linear both;\n  animation-timeline: --li-in-and-out-of-view;;\n}\n.cards li \u0026gt; img {\n   animation: rotate-cover linear both;\n   animation-timeline: --li-in-and-out-of-view;;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn this specific demo, the images rotate and scale but the updated sizing does not affect the view timeline: it stays the same size, respecting the original box size rather than flexing with the changes.\u003c/p\u003e\n\n\n\n\u003cp\u003ePhew, we have another tool for attaching animations to timelines that are not direct ancestors: \u003cstrong\u003e\u003ccode\u003etimeline-scope\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003etimeline-scope: --example;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis goes on an parent element that is shared by \u003cem\u003eboth\u003c/em\u003e the animated target and the animated timeline. This way, we can still attach them even if they are not direct ancestors.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div style=\u0026#34;timeline-scope: --gallery\u0026#34;\u0026gt;\n  \u0026lt;div style=\u0026#34;scroll-timeline: --gallery-inline;\u0026#34;\u0026gt;\n     ...\n  \u0026lt;/div\u0026gt;\n  \u0026lt;div style=\u0026#34;animation-timeline: --gallery;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"964\" height=\"580\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-8.38.44%E2%80%AFAM.png?resize=964%2C580\u0026amp;ssl=1\" alt=\"Illustrating the relationship between a scroll target and container when they are not ancestors, but siblings.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-8.38.44%E2%80%AFAM.png?w=964\u0026amp;ssl=1 964w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-8.38.44%E2%80%AFAM.png?resize=300%2C180\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-8.38.44%E2%80%AFAM.png?resize=768%2C462\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIt accepts multiple comma-separated values:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003etimeline-scope: --one, --two, --three;\n/* or */\ntimeline-scope: all; /* Chrome 116+ */\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThere’s no Safari or Firefox support for the \u003ccode\u003eall\u003c/code\u003e kewword just yet but we can \u003ca href=\"https://caniuse.com/mdn-css_properties_timeline-scope_all\" rel=\"noopener\"\u003ewatch for it at Caniuse\u003c/a\u003e (or the newer \u003ca href=\"https://css-tricks.com/bcd-watch/\"\u003eBCD Watch\u003c/a\u003e!).\u003c/p\u003e\n\n\n\n\u003cp\u003eThis video is considered the last one in the series of “core concepts.” The next five are more focused on use cases and examples.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"add-scroll-shadows-to-a-scroll-container\"\u003eAdd Scroll Shadows to a Scroll Container\u003c/h3\u003e\n\n\n\u003cp\u003eIn this example, we’re conditionally showing scroll shadows on a scroll container. Chris \u003ca href=\"https://css-tricks.com/books/greatest-css-tricks/scroll-shadows/\"\u003ecalls\u003c/a\u003e \u003cem\u003escroll shadows\u003c/em\u003e one his favorite CSS-Tricks of all time and we can nail them with scroll animations.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is the demo Chris put together a few years ago:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThat relies on having a background with multiple CSS gradients that are pinned to the extremes with \u003ccode\u003ebackground-attachment: fixed\u003c/code\u003e on a single selector. Let’s modernize this, starting with a different approach using pseudos with sticky positioning:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.container::before,\n.container::after {\n  content: \u0026#34;\u0026#34;;\n  display: block;\n  position: sticky;\n  left: 0em; \n  right 0em;\n  height: 0.75rem;\n\n  \u0026amp;::before {\n    top: 0;\n    background: radial-gradient(...);\n  }\n  \n  \u0026amp;::after {\n    bottom: 0;\n    background: radial-gradient(...);\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe shadows fade in and out with a CSS animation:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@keyframes reveal {\n  0% { opacity: 0; }\n  100% { opacity: 1; }\n}\n\n.container {\n  overflow:-y auto;\n  scroll-timeline: --scroll-timeline block; /* do we need `block`? */\n\n  \u0026amp;::before,\n  \u0026amp;::after {\n    animation: reveal linear both;\n    animation-timeline: --scroll-timeline;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis example rocks a named timeline, but Bramus notes that an anonymous one would work here as well. Seems like anonymous timelines are somewhat fragile and named timelines are a good \u003ca href=\"https://ishadeed.com/article/defensive-css/\" rel=\"noopener\"\u003edefensive strategy\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe next thing we need is to set the animation’s range so that each pseudo scrolls in where needed. Calculating the range from the top is fairly straightforward:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.container::before {\n  animation-range: 1em 2em;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe bottom is a little tricker. It should start when there are \u003ccode\u003e2em\u003c/code\u003e of scrolling and then only travel for \u003ccode\u003e1em\u003c/code\u003e. We can simply reverse the animation and add a little calculation to set the range based on it’s bottom edge.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.container::after {\n  animation-direction: reverse;\n  animation-range: calc(100% - 2em) calc(100% - 1em);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eStill one more thing. We only want the shadows to reveal \u003cem\u003ewhen we’re in a scroll container\u003c/em\u003e. If, for example, the box is taller than the content, there is no scrolling, yet we get both shadows.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"780\" height=\"484\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-9.09.20%E2%80%AFAM.png?resize=780%2C484\u0026amp;ssl=1\" alt=\"Shadows on the top and bottom edges of the content, but the content is shorter than the box height, resulting in the shadow being in the middle of the box.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-9.09.20%E2%80%AFAM.png?w=780\u0026amp;ssl=1 780w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-9.09.20%E2%80%AFAM.png?resize=300%2C186\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-9.09.20%E2%80%AFAM.png?resize=768%2C477\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThis is where the conditional part comes in. We can detect whether an element is scrollable and react to it. Bramus is talking about an \u003ccode\u003eanimation\u003c/code\u003e keyword that’s new to me: \u003ccode\u003edetect-scroll.\u003c/code\u003e\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"9\"\u003e\u003ccode markup=\"tt\"\u003e@keyframes detect-scroll {\n  from,\n  to {\n     --can-scroll: ; /* value is a single space and acts as boolean */\n  }\n}\n\n.container {\n  animation: detect-scroll;\n  animation-timeline: --scroll-timeline;\n  animation-fill-mode: none;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eGonna have to wrap my head around this… but the general idea is that \u003ccode\u003e--can-scroll\u003c/code\u003e is a boolean value we can use to set visibility on the pseudos:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.content::before,\n.content::after {\n    --vis-if-can-scroll: var(--can-scroll) visible;\n    --vis-if-cant-scroll: hidden;\n\n  visibility: var(--vis-if-can-scroll, var(--vis-if-cant-scroll));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBramus points to \u003ca href=\"https://css-tricks.com/the-css-custom-property-toggle-trick/\"\u003ethis CSS-Tricks article\u003c/a\u003e for more on the conditional toggle stuff.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"animate-elements-in-different-directions\"\u003eAnimate Elements in Different Directions\u003c/h3\u003e\n\n\n\u003cp\u003eThis should be fun! Let’s say we have a set of columns:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div class=\u0026#34;columns\u0026#34;\u0026gt;\n  \u0026lt;div class=\u0026#34;column reverse\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;column\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt;\n  \u0026lt;div class=\u0026#34;column reverse\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe goal is getting the two outer \u003ccode\u003ereverse\u003c/code\u003e columns to scroll in the \u003cem\u003eopposite\u003c/em\u003e direction as the inner column scrolls in the other direction. Classic JavaScript territory!\u003c/p\u003e\n\n\n\n\u003cp\u003eThe columns are set up in a grid container. The columns flex in the \u003ccode\u003ecolumn\u003c/code\u003e direction.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* run if the browser supports it */\n@supports (animation-timeline: scroll()) {\n\n  .column-reverse {\n    transform: translateY(calc(-100% + 100vh));\n    flex-direction: column-reverse; /* flows in reverse order */\n  }\n\n  .columns {\n    overflow-y: clip; /* not a scroll container! */\n  }\n\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1236\" height=\"706\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-9.54.35%E2%80%AFAM.png?resize=1236%2C706\u0026amp;ssl=1\" alt=\"The bottom edge of the outer columns are aligned with the top edge of the viewport.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-9.54.35%E2%80%AFAM.png?w=1236\u0026amp;ssl=1 1236w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-9.54.35%E2%80%AFAM.png?resize=300%2C171\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-9.54.35%E2%80%AFAM.png?resize=1024%2C585\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-9.54.35%E2%80%AFAM.png?resize=768%2C439\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eFirst, the outer columns are pushed all the way up so the bottom edges are aligned with the viewport’s top edge. Then, on scroll, the outer columns slide down until their top edges re aligned with the viewport’s bottom edge.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe CSS animation:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@keyframes adjust-position {\n  from /* the top */ {\n    transform: translateY(calc(-100% + 100vh));\n  }\n  to /* the bottom */ {\n    transform: translateY(calc(100% - 100vh));\n  }\n}\n\n.column-reverse {\n  animation: adjust-position linear forwards;\n  animation-timeline: scroll(root block); /* viewport in block direction */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe approach is similar in JavaScript:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst timeline = new ScrollTimeline({\n  source: document.documentElement,\n});\n\ndocument.querySelectorAll(\u0026#34;.column-reverse\u0026#34;).forEach($column) =\u0026gt; {\n  $column.animate(\n    {\n      transform: [\n        \u0026#34;translateY(calc(-100% + 100vh))\u0026#34;,\n        \u0026#34;translateY(calc(100% - 100vh))\u0026#34;\n      ]\n    },\n    {\n      fill: \u0026#34;both\u0026#34;,\n      timeline,\n    }\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\u003ch3 id=\"animate-3d-models-and-more-on-scroll\"\u003eAnimate 3D Models and More on Scroll\u003c/h3\u003e\n\n\n\u003cp\u003eThis one’s working with a custom element for a \u003ca href=\"https://web.dev/articles/model-viewer\" rel=\"noopener\"\u003e3D model\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;model-viewer alt=\u0026#34;Robot\u0026#34; src=\u0026#34;robot.glb\u0026#34;\u0026gt;\u0026lt;/model-viewer\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFirst, the scroll-driven animation. We’re attaching an animation to the component but not defining the keyframes just yet.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@keyframes foo {\n\n}\n\nmodel-viewer {\n  animation: foo linear both;\n  animation-timeline: scroll(block root); /* root scroller in block direction */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThere’s some JavaScript for the full rotation and orientation:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// Bramus made a little helper for handling the requested animation frames\nimport { trackProgress } from \u0026#34;https://esm.sh/@bramus/sda-utilities\u0026#34;;\n\n// Select the component\nconst $model = document.QuerySelector(\u0026#34;model-viewer\u0026#34;);\n// Animation begins with the first iteration\nconst animation = $model.getAnimations()[0];\n\n// Variable to get the animation\u0026#39;s timing info\nlet progress = animation.effect.getComputedTiming().progress * 1;\n// If when finished, $progress = 1\nif (animation.playState === \u0026#34;finished\u0026#34;) progress = 1;\nprogress = Math.max(0.0, Math.min(1.0, progress)).toFixed(2);\n\n// Convert this to degrees\n$model.orientation = `0deg 0deg $(progress * -360)deg`;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe’re using the effect to get the animation’s progress rather than the current timed spot. The current time value is always measured relative to the full range, so we need the effect to get the progress based on the applied animation.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"scroll-velocity-detection\"\u003eScroll Velocity Detection\u003c/h3\u003e\n\n\n\u003cp\u003eThe video description is helpful:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eBramus goes full experimental and uses Scroll-Driven Animations to detect the active scroll speed and the directionality of scroll. Detecting this allows you to style an element based on whether the user is scrolling (or not scrolling), the direction they are scrolling in, and the speed they are scrolling with … and this all using only CSS.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eFirst off, \u003cstrong\u003ethis is a hack\u003c/strong\u003e. What we’re looking at is expermental and not very performant. We want to detect the animations’s velocity and direction. We start with two custom properties.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@keyframes adjust-pos {\n  from {\n    --scroll-position: 0;\n    --scroll-position-delayed: 0;\n  }\n  to {\n    --scroll-position: 1;\n    --scroll-position-delayed: 1;\n  }\n}\n\n:root {\n  animation: adjust-pos linear both;\n  animation-timeline: scroll(root);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s register those custom properties so we can interpolate the values:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@property --scroll-position {\n  syntax: \u0026#34;\u0026lt;number\u0026gt;\u0026#34;;\n  inherits: true;\n  initial-value: 0;\n}\n\n@property --scroll-position-delayed {\n  syntax: \u0026#34;\u0026lt;number\u0026gt;\u0026#34;;\n  inherits: true;\n  initial-value: 0;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAs we scroll, those values change. If we add a little delay, then we can stagger things a bit:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e:root {\n  animation: adjust-pos linear both;\n  animation-timeline: scroll(root);\n}\n\nbody {\n  transition: --scroll-position-delayed 0.15s linear;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe fact that we’re applying this to the \u003ccode\u003ebody\u003c/code\u003e is part of the trick because it depends on the parent-child relationship between \u003ccode\u003ehtml\u003c/code\u003e and \u003ccode\u003ebody\u003c/code\u003e. The parent element updates the values \u003cem\u003eimmediately\u003c/em\u003e while the child lags behind just a tad. The evaluate to the same value, but one is slower to start.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can use the difference between the two values as they are staggered to get the velocity.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e:root {\n  animation: adjust-pos linear both;\n  animation-timeline: scroll(root);\n}\n\nbody {\n  transition: --scroll-position-delayed 0.15s linear;\n  --scroll-velocity: calc(\n    var(--scroll-position) - var(--scroll-position-delayed)\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eClever! If \u003ccode\u003e--scroll-velocity\u003c/code\u003e is equal to \u003ccode\u003e0\u003c/code\u003e, then we know that the user is not scrolling because the two values are in sync. A positive number indicates the scroll direction is down, while a negative number indicates scrolling up,.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1170\" height=\"572\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-10.34.47%E2%80%AFAM.png?resize=1170%2C572\u0026amp;ssl=1\" alt=\"Showing values for the scroll position, the delayed position, and the velocity when scrolling occurs.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-10.34.47%E2%80%AFAM.png?w=1170\u0026amp;ssl=1 1170w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-10.34.47%E2%80%AFAM.png?resize=300%2C147\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-10.34.47%E2%80%AFAM.png?resize=1024%2C501\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-10.34.47%E2%80%AFAM.png?resize=768%2C375\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThere’s a little discrepancy when scrolling abruptly changes direction. We can fix this by tighening the transition delay of \u003ccode\u003e--scroll-position-delayed\u003c/code\u003e but then we’re increasing the velocity. We might need a multiplier to further correct that… that’s why this is a hack. But now we have a way to sniff the scrolling speed and direction!\u003c/p\u003e\n\n\n\n\u003cp\u003eHere’s the hack using math functions:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"6,7\"\u003e\u003ccode markup=\"tt\"\u003ebody {\n  transition: --scroll-position-delayed 0.15s linear;\n  --scroll-velocity: calc(\n    var(--scroll-position) - var(--scroll-position-delayed)\n  );\n  --scroll-direction: sign(var(--scroll-velocity));\n  --scroll-speed: abs(var(--scroll-velocity));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is a little funny because I’m seeing that Chrome does not yet support \u003ccode\u003esign()\u003c/code\u003e or \u003ccode\u003eabs()\u003c/code\u003e, at least at the time I’m watching this. Gotta enable \u003ccode\u003echrome://flags\u003c/code\u003e. There’s a polyfill for the math \u003ca href=\"https://css-tricks.com/using-absolute-value-sign-rounding-and-modulo-in-css-today/\"\u003ebrought to you by Ana Tudor right here on CSS-Tricks\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1096\" height=\"556\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-10.40.57%E2%80%AFAM.png?resize=1096%2C556\u0026amp;ssl=1\" alt=\"Showing values for the scroll position, the delayed position, the velocity, the scroll direction, and the scroll speed when scrolling occurs.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-10.40.57%E2%80%AFAM.png?w=1096\u0026amp;ssl=1 1096w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-10.40.57%E2%80%AFAM.png?resize=300%2C152\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-10.40.57%E2%80%AFAM.png?resize=1024%2C519\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/10/Screenshot-2024-10-18-at-10.40.57%E2%80%AFAM.png?resize=768%2C390\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eSo, now we could theoretically do something like skew an element by a certain amount or give it a certain level of background color saturation depending on the scroll speed.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.box {\n  transform: skew(calc(var(--scroll-velocity) * -25deg));\n  transition: background 0.15s ease;\n  background: hsl(\n    calc(0deg + (145deg * var(--scroll-direction))) 50 % 50%\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe could do all this with \u003ca href=\"https://css-tricks.com/digging-deeper-into-container-style-queries/\"\u003estyle queries\u003c/a\u003e should we want to:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@container style(--scroll-direction: 0) { /* idle */\n  .slider-item {\n    background: crimson;\n  }\n}\n@container style(--scroll-direction: 1) { /* scrolling down */\n  .slider-item {\n    background: forestgreen;\n  }\n}\n@container style(--scroll-direction: -1) { /* scrolling down */\n  .slider-item {\n    background: lightskyblue;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eCustom properties, scroll-driven animations, and style queries — all in one demo! These are wild times for CSS, tell ya what.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"outro\"\u003eOutro\u003c/h3\u003e\n\n\n\u003cp\u003eThe tenth and final video! Just a summary of the series, so no new notes here. But here’s a great demo to cap it off.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "31 min read",
  "publishedTime": "2024-10-21T07:50:53-06:00",
  "modifiedTime": "2024-10-21T07:51:13-06:00"
}
