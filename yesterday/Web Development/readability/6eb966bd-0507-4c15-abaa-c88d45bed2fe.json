{
  "id": "6eb966bd-0507-4c15-abaa-c88d45bed2fe",
  "title": "Better CSS Shapes Using shape() — Part 1: Lines and Arcs",
  "link": "https://css-tricks.com/better-css-shapes-using-shape-part-1-lines-and-arcs/",
  "description": "This is the first part of a series that dives deep into the shape function, starting with shapes that use lines and arcs. Better CSS Shapes Using shape() — Part 1: Lines and Arcs originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Temani Afif",
  "published": "Fri, 23 May 2025 13:02:32 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "art",
    "clip-path",
    "CSS functions",
    "css shapes"
  ],
  "byline": "Temani Afif",
  "length": 15107,
  "excerpt": "This is the first part of a series that dives deep into the shape function, starting with shapes that use lines and arcs.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "Creating CSS Shapes is a classic and one of my favorite exercise. Indeed, I have one of the biggest collections of CSS Shapes from where you can easily copy the code of any shape. I also wrote an extensive guide on how to create them: The Modern Guide For Making CSS Shapes. Even if I have detailed most of the modern techniques and tricks, CSS keeps evolving, and new stuff always emerges to simplify our developer life. Recently, clip-path was upgraded to have a new shape() value. A real game changer! Before we jump in, it’s worth calling out that the shape() function is currently only supported in Chrome 137+ and Safari 18.4+ as I’m writing this in May 2025. What is shape()? Let me quote the description from the official specification: While the path() function allows reuse of the SVG path syntax to define more arbitrary shapes than allowed by more specialized shape functions, it requires writing a path as a single string (which is not compatible with, for example, building a path piecemeal with var()), and inherits a number of limitations from SVG, such as implicitly only allowing the px unit. The shape() function uses a set of commands roughly equivalent to the ones used by path(), but does so with more standard CSS syntax, and allows the full range of CSS functionality, such as additional units and math functions. In other words, we have the SVG features in the CSS side that we can combine with existing features such as var(), calc(), different units, etc. SVG is already good at drawing complex shapes, so imagine what is possible with something more powerful. If you keep reading the spec, you will find: In that sense, shape() is a superset of path(). A path() can be easily converted to a shape(), but to convert a shape() back to a path() or to SVG requires information about the CSS environment. And guess what? I already created an online converter from SVG to CSS. Save this tool because it will be very handy. If you are already good at creating SVG shapes or you have existing codes, no need to reinvent the wheel. You paste your code in the generator, and you get the CSS code that you can easily tweak later. Let’s try with the CSS-Tricks logo. Here is the SVG I picked from the website: \u003csvg width=\"35px\" height=\"35px\" viewBox=\"0 0 362.62 388.52\" \u003e \u003cpath d=\"M156.58,239l-88.3,64.75c-10.59,7.06-18.84,11.77-29.43,11.77-21.19,0-38.85-18.84-38.85-40C0,257.83,14.13,244.88,27.08,239l103.6-44.74L27.08,148.34C13,142.46,0,129.51,0,111.85,0,90.66,18.84,73,40,73c10.6,0,17.66,3.53,28.25,11.77l88.3,64.75L144.81,44.74C141.28,20,157.76,0,181.31,0s40,18.84,36.5,43.56L206,149.52l88.3-64.75C304.93,76.53,313.17,73,323.77,73a39.2,39.2,0,0,1,38.85,38.85c0,18.84-12.95,30.61-27.08,36.5L231.93,194.26,335.54,239c14.13,5.88,27.08,18.83,27.08,37.67,0,21.19-18.84,38.85-40,38.85-9.42,0-17.66-4.71-28.26-11.77L206,239l11.77,104.78c3.53,24.72-12.95,44.74-36.5,44.74s-40-18.84-36.5-43.56Z\"\u003e\u003c/path\u003e \u003c/svg\u003e You take the value inside the d attribute, paste it in the converter, and boom! You have the following CSS: .shape { aspect-ratio: 0.933; clip-path: shape(from 43.18% 61.52%,line by -24.35% 16.67%,curve by -8.12% 3.03% with -2.92% 1.82%/-5.2% 3.03%,curve by -10.71% -10.3% with -5.84% 0%/-10.71% -4.85%,curve to 7.47% 61.52% with 0% 66.36%/3.9% 63.03%,line by 28.57% -11.52%,line to 7.47% 38.18%,curve to 0% 28.79% with 3.59% 36.67%/0% 33.33%,curve to 11.03% 18.79% with 0% 23.33%/5.2% 18.79%,curve by 7.79% 3.03% with 2.92% 0%/4.87% 0.91%,line by 24.35% 16.67%,line to 39.93% 11.52%,curve to 50% 0% with 38.96% 5.15%/43.51% 0%,smooth by 10.07% 11.21% with 11.03% 4.85%,line to 56.81% 38.48%,line by 24.35% -16.67%,curve to 89.29% 18.79% with 84.09% 19.7%/86.36% 18.79%,arc by 10.71% 10% of 10.81% 10.09% small cw,curve by -7.47% 9.39% with 0% 4.85%/-3.57% 7.88%,line to 63.96% 50%,line to 92.53% 61.52%,curve by 7.47% 9.7% with 3.9% 1.51%/7.47% 4.85%,curve by -11.03% 10% with 0% 5.45%/-5.2% 10%,curve by -7.79% -3.03% with -2.6% 0%/-4.87% -1.21%,line to 56.81% 61.52%,line by 3.25% 26.97%,curve by -10.07% 11.52% with 0.97% 6.36%/-3.57% 11.52%,smooth by -10.07% -11.21% with -11.03% -4.85%,close); } Note that you don’t need to provide any viewBox data. The converter will automatically find the smallest rectangle for the shape and will calculate the coordinates of the points accordingly. No more viewBox headaches and no need to fight with overflow or extra spacing! Here is another example where I am applying the shape to an image element. I am keeping the original SVG so you can compare both shapes. When to use shape() I would be tempted to say “all the time” but in reality, not. In my guide, I distinguish between two types of shapes: The ones with only straight lines and the ones with curves. Each type can either have repetition or not. In the end, we have four categories of shapes. If we don’t have curves and we don’t have repetition (the easiest case), then clip-path: polygon() should do the job. If we have a repetition (with or without curves), then mask is the way to go. With mask, we can rely on gradients that can have a specific size and repeat, but with clip-path we don’t have such options. If you have curves and don’t have a repetition, the new shape() is the best option. Previously, we had to rely on mask since clip-path is very limited, but that’s no longer the case. Of course, these are not universal rules, but my own way to identify which option is the most suitable. At the end of the day, it’s always a case-by-case basis as we may have other things to consider, such as the complexity of the code, the flexibility of the method, browser support, etc. Let’s draw some shapes! Enough talking, let’s move to the interesting part: drawing shapes. I will not write a tutorial to explain the “complex” syntax of shape(). It will be boring and not interesting. Instead, we will draw some common shapes and learn by practice! Rectangle Take the following polygon: clip-path: polygon( 0 0, 100% 0, 100% 100%, 0 100% ); Technically, this will do nothing since it will draw a rectangle that already follows the element shape which is a rectangle, but it’s still the perfect starting point for us. Now, let’s write it using shape(). clip-path: shape( from 0 0, line to 100% 0, line to 100% 100%, line to 0 100% ); The code should be self-explanatory and we already have two commands. The from command is always the first command and is used only once. It simply specifies the starting point. Then we have the line command that draws a line to the next point. Nothing complex so far. We can still write it differently like below: clip-path: shape( from 0 0, hline to 100%, vline to 100%, hline to 0 ); Between the points 0 0 and 100% 0, only the first value is changing which means we are drawing a horizontal line from 0 0 to 100% 0, hence the use of hline to 100% where you only need to specify the horizontal offset. It’s the same logic using vline where we draw a vertical line between 100% 0 and 100% 100%. I won’t advise you to draw your shape using hline and vline because they can be tricky and are a bit difficult to read. Always start by using line and then if you want to optimize your code you can replace them with hline or vline when applicable. We have our first shape and we know the commands to draw straight lines: Circular Cut-Out Now, let’s try to add a circular cut-out at the top of our shape: For this, we are going to rely on the arc command, so let’s understand how it works. If we have two points, A and B, there are exactly two circles with a given radius that intersect with both points like shown in the figure. The intersection gives us four possible arcs we can draw between points A and B. Each arc is defined by a size and a direction. There is also the particular case where the radius is equal to half the distance between A and B. In this case, only two arcs can be drawn and the direction will decide which one. The syntax will look like this: clip-path: shape( from Xa Ya, arc to Xb Yb of R [large or small] [cw or ccw] ); Let’s add this to our previous shape. No need to think about the values. Instead, let’s use random ones and see what happens: clip-path: shape( from 0 0, arc to 40% 0 of 50px, line to 100% 0, line to 100% 100%, line to 0 100% ); Not bad, we can already see the arc between 0 0 and 40% 0. Notice how I didn’t define the size and direction of the arc. By default, the browser will use small and ccw. Let’s explicitly define the size and direction to see the four different cases: Hmm, it’s working for the first two blocks but not the other ones. Quite strange, right? Actually, everything is working fine. The arcs are drawn outside the element area so nothing is visible. If you add some box-shadow, you can see them: Arcs can be tricky due to the size and direction thing, so get ready to be confused. If that happens, remember that you have four different cases, and trying all of them will help you find which one you need. Now let’s try to be accurate and draw half a circle with a specific radius placed at the center: We can define the radius as a variable and use what we have learned so far: .shape { --r: 50px; clip-path: shape( from 0 0, line to calc(50% - var(--r)) 0, arc to calc(50% + var(--r)) 0 of var(--r), line to 100% 0, line to 100% 100%, line to 0 100% ); } It’s working fine, but the code can still be optimized. We can replace all the line commands with hline and vline like below: .shape { --r: 50px; clip-path: shape(from 0 0, hline to calc(50% - var(--r)), arc to calc(50% + var(--r)) 0 of var(--r), hline to 100%, vline to 100%, hline to 0 ); } We can also replace the radius with 1%: .shape { --r: 50px; clip-path: shape(from 0 0, hline to calc(50% - var(--r)), arc to calc(50% + var(--r)) 0 of 1%, hline to 100%, vline to 100%, hline to 0 ); } When you define a small radius (smaller than half the distance between both points), no circle can meet the condition we explained earlier (an intersection with both points), so we cannot draw an arc. This case falls within an error handling where the browser will scale the radius until we can have a circle that meets the condition. Instead of considering this case as invalid, the browser will fix “our mistake” and draw an arc. This error handling is pretty cool as it allows us to simplify our shape() function. Instead of specifying the exact radius, I simply put a small value and the browser will do the job for me. This trick only works when the arc we want to draw is half a circle. Don’t try to apply it with any arc command because it won’t always work. Another optimization is to update the following: arc to calc(50% + var(--r)) 0 of 1%, …with this: arc by calc(2 * var(--r)) 0 of 1%, Almost all the commands can either use a to directive or a by directive. The first one defines absolute coordinates like the one we use with polygon(). It’s the exact position of the point we are moving to. The second defines relative coordinates which means we need to consider the previous point to identify the coordinates of the next point. In our case, we are telling the arc to consider the previous point (50% - R) 0 and move by 2*R 0, so the final point will be (50% - R + 2R) (0 + 0), which is the same as (50% + R) 0. .shape { --r: 50px; clip-path: shape(from 0 0, hline to calc(50% - var(--r)), arc by calc(2 * var(--r)) 0 of 1px, hline to 100%, vline to 100%, hline to 0 ); } This last optimization is great because if we want to move the cutout from the center, we only need to update one value: the 50%. .shape { --r: 50px; --p: 40%; clip-path: shape( from 0 0, hline to calc(var(--p) - var(--r)), arc by calc(2 * var(--r)) 0 of 1px, hline to 100%, vline to 100%, hline to 0 ); } How would you adjust the above to have the cut-out at the bottom, left, or right? That’s your first homework assignment! Try to do it before moving to the next part. I will give my implementation so that you can compare with yours, but don’t cheat! If you can do this without referring to my work, you will be able to do more complex shapes more easily. Rounded Tab Enough cut-out, let’s try to create a rounded tab: Can you see the puzzle of this one? Similar to the previous shape, it’s a bunch of arc and line commands. Here is the code: .shape { --r: 26px; clip-path: shape( /* left part */ from 0 100%, arc by var(--r) calc(-1 * var(--r)) of var(--r), vline to var(--r), arc by var(--r) calc(-1 * var(--r)) of var(--r) cw, /* right part */ hline to calc(100% - 2 * var(--r)), arc by var(--r) var(--r) of var(--r) cw, vline to calc(100% - var(--r)), arc by var(--r) var(--r) of var(--r) ); } It looks a bit scary, but if you follow it command by command, it becomes a lot clearer to see what’s happening. Here is a figure to help you visualize the left part of it. All the arc commands are using the by directive because, in all the cases, I always need to move by an offset equal to R, meaning I don’t have to calculate the coordinates of the points. And don’t try to replace the radius by 1% because it won’t work since we are drawing a quarter of a circle rather than half of a circle. From this, we can easily achieve the left and right variations: Notice how I am only using two arc commands instead of three. One rounded corner can be done with a classic border radius, so this can help us simplify the shape. Inverted Radius One last shape, the classic inner curve at the corner also called an inverted radius. How many arc commands do we need for this one? Check the figure below and think about it. If your answer is six, you have chosen the difficult way to do it. It’s logical to think about six arcs since we have six curves, but three of them can be done with a simple border radius, so only three arcs are needed. Always take the time to analyze the shape you are creating. Sometimes, basic CSS properties can help with creating the shape. What are you waiting for? This is your next homework and I won’t help you with a figure this time. You have all that you need to easily create it. If you are struggling, give the article another read and try to study the previous shapes more in depth. Here is my implementation of the four variations: Conclusion That’s all for this first part. You should have a good overview of the shape() function. We focused on the line and arc commands which are enough to create most of the common shapes. Don’t forget to bookmark the SVG to CSS converter and keep an eye on my CSS Shape collection where you can find the code of all the shapes I create. And here is a last shape to end this article.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2018/09/css-shapes.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eCreating CSS Shapes is a classic and one of my favorite exercise. Indeed, I have \u003ca href=\"https://css-shape.com/\" rel=\"noopener\"\u003eone of the biggest collections of CSS Shapes\u003c/a\u003e from where you can easily copy the code of any shape. I also wrote an extensive guide on how to create them: \u003cstrong\u003e\u003ca href=\"https://www.smashingmagazine.com/2024/05/modern-guide-making-css-shapes/\" rel=\"noopener\"\u003eThe Modern Guide For Making CSS Shapes\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eEven if I have detailed most of the modern techniques and tricks, CSS keeps evolving, and new stuff always emerges to simplify our developer life. Recently, \u003ccode\u003eclip-path\u003c/code\u003e was upgraded to have a new \u003ccode\u003eshape()\u003c/code\u003e value. A real game changer!\u003c/p\u003e\n\n\n\n\u003cp\u003eBefore we jump in, it’s worth calling out that the \u003ccode\u003eshape()\u003c/code\u003e function is currently only supported in Chrome 137+ and Safari 18.4+ as I’m writing this in May 2025.\u003c/p\u003e\n\n\n\u003ch3 id=\"what-is-shape-\"\u003eWhat is \u003ccode\u003eshape()\u003c/code\u003e?\u003c/h3\u003e\n\n\n\u003cp\u003eLet me quote the description from \u003ca href=\"https://drafts.csswg.org/css-shapes-2/#shape-function\" rel=\"noopener\"\u003ethe official specification\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eWhile the \u003ccode\u003epath()\u003c/code\u003e function allows reuse of the SVG path syntax to define more arbitrary shapes than allowed by more specialized shape functions, it requires writing a path as a single string (which is not compatible with, for example, building a path piecemeal with var()), and inherits a number of limitations from SVG, such as implicitly only allowing the px unit.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eshape()\u003c/code\u003e function uses a set of commands roughly equivalent to the ones used by \u003ccode\u003epath()\u003c/code\u003e, but does so with more standard CSS syntax, and allows the full range of CSS functionality, such as additional units and math functions.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eIn other words, we have the SVG features in the CSS side that we can combine with existing features such as \u003ccode\u003evar()\u003c/code\u003e, \u003ccode\u003ecalc()\u003c/code\u003e, different units, etc. SVG is already good at drawing complex shapes, so imagine what is possible with something more powerful.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you keep reading the spec, you will find:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eIn that sense, \u003ccode\u003eshape()\u003c/code\u003e is a superset of \u003ccode\u003epath()\u003c/code\u003e. A \u003ccode\u003epath()\u003c/code\u003e can be easily converted to a \u003ccode\u003eshape()\u003c/code\u003e, but to convert a \u003ccode\u003eshape()\u003c/code\u003e back to a \u003ccode\u003epath()\u003c/code\u003e or to SVG requires information about the CSS environment.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eAnd guess what? I already created \u003ca href=\"https://css-generators.com/svg-to-css/\" rel=\"noopener\"\u003ean online converter from SVG to CSS\u003c/a\u003e. Save this tool because it will be very handy. If you are already good at creating SVG shapes or you have existing codes, no need to reinvent the wheel. You paste your code in the generator, and you get the CSS code that you can easily tweak later.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s try with the CSS-Tricks logo. Here is the SVG I picked from the website:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"SVG\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;svg width=\u0026#34;35px\u0026#34; height=\u0026#34;35px\u0026#34; viewBox=\u0026#34;0 0 362.62 388.52\u0026#34; \u0026gt;\n  \u0026lt;path d=\u0026#34;M156.58,239l-88.3,64.75c-10.59,7.06-18.84,11.77-29.43,11.77-21.19,0-38.85-18.84-38.85-40C0,257.83,14.13,244.88,27.08,239l103.6-44.74L27.08,148.34C13,142.46,0,129.51,0,111.85,0,90.66,18.84,73,40,73c10.6,0,17.66,3.53,28.25,11.77l88.3,64.75L144.81,44.74C141.28,20,157.76,0,181.31,0s40,18.84,36.5,43.56L206,149.52l88.3-64.75C304.93,76.53,313.17,73,323.77,73a39.2,39.2,0,0,1,38.85,38.85c0,18.84-12.95,30.61-27.08,36.5L231.93,194.26,335.54,239c14.13,5.88,27.08,18.83,27.08,37.67,0,21.19-18.84,38.85-40,38.85-9.42,0-17.66-4.71-28.26-11.77L206,239l11.77,104.78c3.53,24.72-12.95,44.74-36.5,44.74s-40-18.84-36.5-43.56Z\u0026#34;\u0026gt;\u0026lt;/path\u0026gt;\n\u0026lt;/svg\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou take the value inside the \u003ccode\u003ed\u003c/code\u003e attribute, paste it in the converter, and \u003cem\u003eboom\u003c/em\u003e! You have the following CSS:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.shape {\n  aspect-ratio: 0.933;\n  clip-path: shape(from 43.18% 61.52%,line by -24.35% 16.67%,curve by -8.12% 3.03% with -2.92% 1.82%/-5.2% 3.03%,curve by -10.71% -10.3% with -5.84% 0%/-10.71% -4.85%,curve to 7.47% 61.52% with 0% 66.36%/3.9% 63.03%,line by 28.57% -11.52%,line to 7.47% 38.18%,curve to 0% 28.79% with 3.59% 36.67%/0% 33.33%,curve to 11.03% 18.79% with 0% 23.33%/5.2% 18.79%,curve by 7.79% 3.03% with 2.92% 0%/4.87% 0.91%,line by 24.35% 16.67%,line to 39.93% 11.52%,curve to 50% 0% with 38.96% 5.15%/43.51% 0%,smooth by 10.07% 11.21% with 11.03% 4.85%,line to 56.81% 38.48%,line by 24.35% -16.67%,curve to 89.29% 18.79% with 84.09% 19.7%/86.36% 18.79%,arc by 10.71% 10% of 10.81% 10.09% small cw,curve by -7.47% 9.39% with 0% 4.85%/-3.57% 7.88%,line to 63.96% 50%,line to 92.53% 61.52%,curve by 7.47% 9.7% with 3.9% 1.51%/7.47% 4.85%,curve by -11.03% 10% with 0% 5.45%/-5.2% 10%,curve by -7.79% -3.03% with -2.6% 0%/-4.87% -1.21%,line to 56.81% 61.52%,line by 3.25% 26.97%,curve by -10.07% 11.52% with 0.97% 6.36%/-3.57% 11.52%,smooth by -10.07% -11.21% with -11.03% -4.85%,close);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNote that you don’t need to provide any \u003ccode\u003eviewBox\u003c/code\u003e data. The converter will automatically find the smallest rectangle for the shape and will calculate the coordinates of the points accordingly. No more \u003ccode\u003eviewBox\u003c/code\u003e headaches and no need to fight with overflow or extra spacing!\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eHere is another example where I am applying the shape to an image element. I am keeping the original SVG so you can compare both shapes.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"when-to-use-shape-\"\u003eWhen to use \u003ccode\u003eshape()\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003eI would be tempted to say “all the time” but in reality, not. In \u003ca href=\"https://www.smashingmagazine.com/2024/05/modern-guide-making-css-shapes/\" rel=\"noopener\"\u003emy guide\u003c/a\u003e, I distinguish between two types of shapes: The ones with only straight lines and the ones with curves. Each type can either have repetition or not. In the end, we have four categories of shapes.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"641\" height=\"480\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747051877090_image.png.webp?resize=641%2C480\u0026amp;ssl=1\" alt=\"Two by two grid of shapes comparing those with and without curves and those with and without repetition.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747051877090_image.png.webp?w=641\u0026amp;ssl=1 641w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747051877090_image.png.webp?resize=300%2C225\u0026amp;ssl=1 300w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIf we don’t have curves and we don’t have repetition (the easiest case), then \u003ccode\u003eclip-path: polygon()\u003c/code\u003e should do the job. If we have a repetition (with or without curves), then \u003ccode\u003emask\u003c/code\u003e is the way to go. With \u003ccode\u003emask\u003c/code\u003e, we can rely on gradients that can have a specific size and repeat, but with \u003ccode\u003eclip-path\u003c/code\u003e we don’t have such options.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you have curves and don’t have a repetition, the new \u003ccode\u003eshape()\u003c/code\u003e is the best option. Previously, we had to rely on \u003ccode\u003emask\u003c/code\u003e since \u003ccode\u003eclip-path\u003c/code\u003e is very limited, but that’s no longer the case. Of course, these are not universal rules, but my own way to identify which option is the most suitable. At the end of the day, it’s always a case-by-case basis as we may have other things to consider, such as the complexity of the code, the flexibility of the method, browser support, etc.\u003c/p\u003e\n\n\n\u003ch3 id=\"let-s-draw-some-shapes-\"\u003eLet’s draw some shapes!\u003c/h3\u003e\n\n\n\u003cp\u003eEnough talking, let’s move to the interesting part: drawing shapes. I will not write a tutorial to explain the “complex” syntax of \u003ccode\u003eshape()\u003c/code\u003e. It will be boring and not interesting. Instead, we will draw some common shapes and learn by practice!\u003c/p\u003e\n\n\n\u003ch4 id=\"rectangle\"\u003eRectangle\u003c/h4\u003e\n\n\n\u003cp\u003eTake the following polygon:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclip-path: polygon(\n  0 0,\n  100% 0,\n  100% 100%,\n  0 100%\n);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTechnically, this will do nothing since it will draw a rectangle that already follows the element shape which is a rectangle, but it’s still the perfect starting point for us.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow, let’s write it using \u003ccode\u003eshape()\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclip-path: shape(\n  from 0 0,\n  line to 100% 0,\n  line to 100% 100%,\n  line to 0 100%\n);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe code should be self-explanatory and we already have two commands. The \u003ccode\u003efrom\u003c/code\u003e command is always the first command and is used only once. It simply specifies the starting point. Then we have the \u003ccode\u003eline\u003c/code\u003e command that draws a line to the next point. Nothing complex so far.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can still write it differently like below:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclip-path: shape(\n  from 0 0,\n  hline to 100%,\n  vline to 100%,\n  hline to 0\n);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBetween the points \u003ccode\u003e0 0\u003c/code\u003e and \u003ccode\u003e100% 0\u003c/code\u003e, only the first value is changing which means we are drawing a horizontal line from \u003ccode\u003e0 0\u003c/code\u003e to \u003ccode\u003e100% 0\u003c/code\u003e, hence the use of \u003ccode\u003ehline to 100%\u003c/code\u003e where you only need to specify the horizontal offset. It’s the same logic using \u003ccode\u003evline\u003c/code\u003e where we draw a vertical line between \u003ccode\u003e100% 0\u003c/code\u003e and \u003ccode\u003e100% 100%\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eI won’t advise you to draw your shape using \u003ccode\u003ehline\u003c/code\u003e and \u003ccode\u003evline\u003c/code\u003e because they can be tricky and are a bit difficult to read. Always start by using \u003ccode\u003eline\u003c/code\u003e and then if you want to optimize your code you can replace them with \u003ccode\u003ehline\u003c/code\u003e or \u003ccode\u003evline\u003c/code\u003e when applicable.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe have our first shape and we know the commands to draw straight lines:\u003c/p\u003e\n\n\n\n\n\n\n\u003ch4 id=\"circular-cut-out\"\u003eCircular Cut-Out\u003c/h4\u003e\n\n\n\u003cp\u003eNow, let’s try to add a circular cut-out at the top of our shape:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"362\" height=\"265\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747135001211_image.png.webp?resize=362%2C265\u0026amp;ssl=1\" alt=\"A square shape with a scalloped half circle cut out of the top.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747135001211_image.png.webp?w=362\u0026amp;ssl=1 362w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747135001211_image.png.webp?resize=300%2C220\u0026amp;ssl=1 300w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eFor this, we are going to rely on the \u003ccode\u003earc\u003c/code\u003e command, so let’s understand how it works.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"869\" height=\"379\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/cxmPje61.png.webp?resize=869%2C379\u0026amp;ssl=1\" alt=\"Diagram showing two intersecting circles with points indicating where they cross and arrows indicating the large and small clockwise and counterclockwise directions.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/cxmPje61.png.webp?w=869\u0026amp;ssl=1 869w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/cxmPje61.png.webp?resize=300%2C131\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/cxmPje61.png.webp?resize=768%2C335\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIf we have two points, A and B, there are exactly two circles with a given radius that intersect with both points like shown in the figure. The intersection gives us four possible arcs we can draw between points A and B. Each arc is defined by a size and a direction.\u003c/p\u003e\n\n\n\n\u003cp\u003eThere is also the particular case where the radius is equal to half the distance between A and B. In this case, only two arcs can be drawn and the direction will decide which one.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"699\" height=\"397\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/Bd23aq9Z.png.webp?resize=699%2C397\u0026amp;ssl=1\" alt=\"A circle with two points at the top and bottom highlighted to show movement in the clockwise and counterclockwise directions.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/Bd23aq9Z.png.webp?w=699\u0026amp;ssl=1 699w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/Bd23aq9Z.png.webp?resize=300%2C170\u0026amp;ssl=1 300w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe syntax will look like this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclip-path: shape(\n  from Xa Ya, \n  arc to Xb Yb of R [large or small] [cw or ccw]\n);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s add this to our previous shape. No need to think about the values. Instead, let’s use random ones and see what happens:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eclip-path: shape(\n  from 0 0,\n  arc to 40% 0 of 50px,\n  line to 100% 0,\n  line to 100% 100%,\n  line to 0 100%\n);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eNot bad, we can already see the arc between \u003ccode\u003e0 0\u003c/code\u003e and \u003ccode\u003e40% 0\u003c/code\u003e. Notice how I didn’t define the size and direction of the arc. By default, the browser will use \u003ccode\u003esmall\u003c/code\u003e and \u003ccode\u003eccw\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s explicitly define the size and direction to see the four different cases:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eHmm, it’s working for the first two blocks but not the other ones. Quite strange, right?\u003c/p\u003e\n\n\n\n\u003cp\u003eActually, everything is working fine. The arcs are drawn outside the element area so nothing is visible. If you add some \u003ccode\u003ebox-shadow\u003c/code\u003e, you can see them:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eArcs can be tricky due to the size and direction thing, so get ready to be confused. If that happens, remember that you have four different cases, and trying all of them will help you find which one you need.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow let’s try to be accurate and draw half a circle with a specific radius placed at the center:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"409\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747137898705_image.png-1024x409.webp?resize=1024%2C409\u0026amp;ssl=1\" alt=\"A rectangular shape with a scalloped half circle cut out of the top. Arrows indicate the circle\u0026#39;s radius.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747137898705_image.png.webp?resize=1024%2C409\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747137898705_image.png.webp?resize=300%2C120\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747137898705_image.png.webp?resize=768%2C306\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747137898705_image.png.webp?w=1123\u0026amp;ssl=1 1123w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWe can define the radius as a variable and use what we have learned so far:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.shape {\n  --r: 50px;\n\n  clip-path: shape(\n    from 0 0, \n    line to calc(50% - var(--r)) 0, \n    arc to calc(50% + var(--r)) 0 of var(--r), \n    line to 100% 0, \n    line to 100% 100%, \n    line to 0 100%\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eIt’s working fine, but the code can still be optimized. We can replace all the \u003ccode\u003eline\u003c/code\u003e commands with \u003ccode\u003ehline\u003c/code\u003e and \u003ccode\u003evline\u003c/code\u003e like below:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.shape {\n  --r: 50px;\n\n  clip-path: shape(from 0 0, \n    hline to calc(50% - var(--r)), \n    arc to calc(50% + var(--r)) 0 of var(--r), \n    hline to 100%, \n    vline to 100%, \n    hline to 0\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe can also replace the radius with \u003ccode\u003e1%\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.shape {\n  --r: 50px;\n\n  clip-path: shape(from 0 0, \n    hline to calc(50% - var(--r)), \n    arc to calc(50% + var(--r)) 0 of 1%,\n    hline to 100%, \n    vline to 100%, \n    hline to 0\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen you define a small radius (smaller than half the distance between both points), no circle can meet the condition we explained earlier (an intersection with both points), so we cannot draw an arc. This case falls within an error handling where the browser will scale the radius until we can have a circle that meets the condition. Instead of considering this case as invalid, the browser will fix “our mistake” and draw an arc.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis error handling is pretty cool as it allows us to simplify our \u003ccode\u003eshape()\u003c/code\u003e function. Instead of specifying the exact radius, I simply put a small value and the browser will do the job for me. This trick only works when the arc we want to draw is half a circle. Don’t try to apply it with any \u003ccode\u003earc\u003c/code\u003e command because it won’t always work.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnother optimization is to update the following:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003earc to calc(50% + var(--r)) 0 of 1%,\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e…with this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003earc by calc(2 * var(--r)) 0 of 1%,\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAlmost all the commands can either use a \u003ccode\u003eto\u003c/code\u003e directive or a \u003ccode\u003eby\u003c/code\u003e directive. The first one defines absolute coordinates like the one we use with \u003ccode\u003epolygon()\u003c/code\u003e. It’s the exact position of the point we are moving to. The second defines relative coordinates which means we need to consider the previous point to identify the coordinates of the next point.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn our case, we are telling the arc to consider the previous point \u003ccode\u003e(50% - R) 0\u003c/code\u003e and move by \u003ccode\u003e2*R 0\u003c/code\u003e, so the final point will be \u003ccode\u003e(50% - R + 2R) (0 + 0)\u003c/code\u003e, which is the same as \u003ccode\u003e(50% + R) 0\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.shape {\n  --r: 50px;\n\n  clip-path: shape(from 0 0, \n    hline to calc(50% - var(--r)), \n    arc by calc(2 * var(--r)) 0 of 1px, \n    hline to 100%, \n    vline to 100%, \n    hline to 0\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis last optimization is great because if we want to move the cutout from the center, we only need to update one value: the \u003ccode\u003e50%\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"7\"\u003e\u003ccode markup=\"tt\"\u003e.shape {\n  --r: 50px;\n  --p: 40%;\n\n  clip-path: shape(\n    from 0 0, \n    hline to calc(var(--p) - var(--r)),\n    arc by calc(2 * var(--r)) 0 of 1px, \n    hline to 100%, \n    vline to 100%, \n    hline to 0\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eHow would you adjust the above to have the cut-out at the bottom, left, or right? That’s your first homework assignment! Try to do it before moving to the next part.\u003c/p\u003e\n\n\n\n\u003cp\u003eI will give my implementation so that you can compare with yours, but don’t cheat! If you can do this without referring to my work, you will be able to do more complex shapes more easily.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch4 id=\"rounded-tab\"\u003eRounded Tab\u003c/h4\u003e\n\n\n\u003cp\u003eEnough cut-out, let’s try to create a rounded tab:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"459\" height=\"176\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747144895054_image.png.webp?resize=459%2C176\u0026amp;ssl=1\" alt=\"A rectangular tab shape with rounded corners on the top and a flat, hard edge across the bottom. The words \u0026#39;Rounded tab\u0026#39; are in white inside the rectangle.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747144895054_image.png.webp?w=459\u0026amp;ssl=1 459w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747144895054_image.png.webp?resize=300%2C115\u0026amp;ssl=1 300w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eCan you see the puzzle of this one? Similar to the previous shape, it’s a bunch of \u003ccode\u003earc\u003c/code\u003e and \u003ccode\u003eline\u003c/code\u003e commands. Here is the code:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.shape {\n  --r: 26px;\n  \n  clip-path: shape(\n    /* left part */\n    from 0 100%,\n    arc by var(--r) calc(-1 * var(--r)) of var(--r),\n    vline to var(--r),\n    arc by var(--r) calc(-1 * var(--r)) of var(--r) cw,\n    /* right part */\n    hline to calc(100% - 2 * var(--r)),\n    arc by var(--r) var(--r) of var(--r) cw,\n    vline to calc(100% - var(--r)),\n    arc by var(--r) var(--r) of var(--r)\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIt looks a bit scary, but if you follow it command by command, it becomes a lot clearer to see what’s happening. Here is a figure to help you visualize the left part of it.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"803\" height=\"455\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747147187601_image.png.webp?resize=803%2C455\u0026amp;ssl=1\" alt=\"Diagram of the left side of a rounded rectangular tab, showing the rounded edge\u0026#39;s radius and the arcs that are used to make it.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747147187601_image.png.webp?w=803\u0026amp;ssl=1 803w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747147187601_image.png.webp?resize=300%2C170\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747147187601_image.png.webp?resize=768%2C435\u0026amp;ssl=1 768w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAll the \u003ccode\u003earc\u003c/code\u003e commands are using the \u003ccode\u003eby\u003c/code\u003e directive because, in all the cases, I always need to move by an offset equal to R, meaning I don’t have to calculate the coordinates of the points. And don’t try to replace the radius by \u003ccode\u003e1%\u003c/code\u003e because it won’t work since we are drawing a quarter of a circle rather than half of a circle.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eFrom this, we can easily achieve the left and right variations:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eNotice how I am only using two \u003ccode\u003earc\u003c/code\u003e commands instead of three. One rounded corner can be done with a classic border radius, so this can help us simplify the shape.\u003c/p\u003e\n\n\n\u003ch4 id=\"inverted-radius\"\u003eInverted Radius\u003c/h4\u003e\n\n\n\u003cp\u003eOne last shape, the classic inner curve at the corner also called an inverted radius. How many \u003ccode\u003earc\u003c/code\u003e commands do we need for this one? Check the figure below and think about it.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/paper-attachments.dropboxusercontent.com/s_14F1BA2F9AB60876292CC2D9A2BDC7A08F0D5E88097DD218BC30C43D4B6F401D_1747150169480_image.png?ssl=1\" alt=\"A square with rounded edges and a a circlular arc cut out of the top-right corner of the shape.\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIf your answer is six, you have chosen the difficult way to do it. It’s logical to think about six arcs since we have six curves, but three of them can be done with a simple border radius, so only three arcs are needed. Always take the time to analyze the shape you are creating. Sometimes, basic CSS properties can help with creating the shape.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat are you waiting for? This is your next homework and I won’t help you with a figure this time. You have all that you need to easily create it. If you are struggling, give the article another read and try to study the previous shapes more in depth.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is my implementation of the four variations:\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\n\n\u003cp\u003eThat’s all for this first part. You should have a good overview of the \u003ccode\u003eshape()\u003c/code\u003e function. We focused on the \u003ccode\u003eline\u003c/code\u003e and \u003ccode\u003earc\u003c/code\u003e commands which are enough to create most of the common shapes.\u003c/p\u003e\n\n\n\n\u003cp\u003eDon’t forget to bookmark the \u003ca href=\"https://css-generators.com/svg-to-css/\" rel=\"noopener\"\u003eSVG to CSS converter\u003c/a\u003e and keep an eye on my \u003ca href=\"https://css-shape.com/\" rel=\"noopener\"\u003eCSS Shape collection\u003c/a\u003e where you can find the code of all the shapes I create. And here is a last shape to end this article.\u003c/p\u003e\n\n\n\n\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2025-05-23T07:02:32-06:00",
  "modifiedTime": "2025-05-23T11:27:28-06:00"
}
