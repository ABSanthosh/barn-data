{
  "id": "ae2138eb-73cf-401b-8c81-470f4b86852d",
  "title": "A Better API for the Intersection and Mutation Observers",
  "link": "https://css-tricks.com/a-better-api-for-the-intersection-and-mutation-observers/",
  "description": "Zell discusses refactoring the Resize, Mutation, and Intersection Observer APIs for easier usage, demonstrating how to implement callback and event listener patterns, while highlighting available options and methods. A Better API for the Intersection and Mutation Observers originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Zell Liew",
  "published": "Mon, 23 Jun 2025 13:41:34 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "JavaScript"
  ],
  "byline": "Zell Liew",
  "length": 9450,
  "excerpt": "Zell discusses refactoring the Resize, Mutation, and Intersection Observer APIs for easier usage, demonstrating how to implement callback and event listener patterns, while highlighting available options and methods.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "In a previous article, I showed you how to refactor the Resize Observer API into something way simpler to use: // From this const observer = new ResizeObserver(observerFn) function observerFn (entries) { for (let entry of entries) { // Do something with each entry } } const element = document.querySelector('#some-element') observer.observe(element); // To this const node = document.querySelector('#some-element') const obs = resizeObserver(node, { callback({ entry }) { // Do something with each entry } }) Today, weâ€™re going to do the same for MutationObserver and IntersectionObserver. Refactoring Mutation Observer MutationObserver has almost the same API as that of ResizeObserver. So we can practically copy-paste the entire chunk of code we wrote for resizeObserver to mutationObserver. export function mutationObserver(node, options = {}) { const observer = new MutationObserver(observerFn) const { callback, ...opts } = options observer.observe(node, opts) function observerFn(entries) { for (const entry of entries) { // Callback pattern if (options.callback) options.callback({ entry, entries, observer }) // Event listener pattern else { node.dispatchEvent( new CustomEvent('mutate', { detail: { entry, entries, observer }, }) ) } } } } You can now use mutationObserver with the callback pattern or event listener pattern. const node = document.querySelector('.some-element') // Callback pattern const obs = mutationObserver(node, { callback ({ entry, entries }) { // Do what you want with each entry } }) // Event listener pattern node.addEventListener('mutate', event =\u003e { const { entry } = event.detail // Do what you want with each entry }) Much easier! Disconnecting the observer Unlike ResizeObserver who has two methods to stop observing elements, MutationObserver only has one, the disconnect method. export function mutationObserver(node, options = {}) { // ... return { disconnect() { observer.disconnect() } } } But,Â MutationObserverÂ has aÂ takeRecordsÂ method that lets youÂ get unprocessed recordsÂ before you disconnect. Since we should takeRecords before we disconnect, letâ€™s use it inside disconnect. To create a complete API, we can return this method as well. export function mutationObserver(node, options = {}) { // ... return { // ... disconnect() { const records = observer.takeRecords() observer.disconnect() if (records.length \u003e 0) observerFn(records) } } } Now we can disconnect our mutation observer easily with disconnect. const node = document.querySelector('.some-element') const obs = mutationObserver(/* ... */) obs.disconnect() MutationObserverâ€™s observe options In case you were wondering, MutationObserverâ€™s observe method can take in 7 options. Each one of them determines what to observe, and they all default to false. subtree: Monitors the entire subtree of nodes childList: Monitors for addition or removal children elements. If subtree is true, this monitors all descendant elements. attributes: Monitors for a change of attributes attributeFilter: Array of specific attributes to monitor attributeOldValue: Whether to record the previous attribute value if it was changed characterData: Monitors for change in character data characterDataOldValue: Whether to record the previous character data value Refactoring Intersection Observer The API for IntersectionObserver is similar to other observers. Again, you have to: Create a new observer: with the new keyword. This observer takes in an observer function to execute. Do something with the observed changes: This is done via the observer function that is passed into the observer. Observe a specific element: By using the observe method. (Optionally) unobserve the element: By using the unobserve or disconnect method (depending on which Observer youâ€™re using). But IntersectionObserver requires you to pass the options in Step 1 (instead of Step 3). So hereâ€™s the code to use the IntersectionObserver API. // Step 1: Create a new observer and pass in relevant options const options = {/*...*/} const observer = new IntersectionObserver(observerFn, options) // Step 2: Do something with the observed changes function observerFn (entries) { for (const entry of entries) { // Do something with entry } } // Step 3: Observe the element const element = document.querySelector('#some-element') observer.observe(element) // Step 4 (optional): Disconnect the observer when we're done using it observer.disconnect(element) Since the code is similar, we can also copy-paste the code we wrote for mutationObserver into intersectionObserver. When doing so, we have to remember to pass the options into IntersectionObserver and not the observe method. export function mutationObserver(node, options = {}) { const { callback, ...opts } = options const observer = new MutationObserver(observerFn, opts) observer.observe(node) function observerFn(entries) { for (const entry of entries) { // Callback pattern if (options.callback) options.callback({ entry, entries, observer }) // Event listener pattern else { node.dispatchEvent( new CustomEvent('intersect', { detail: { entry, entries, observer }, }) ) } } } } Now we can use intersectionObserver with the same easy-to-use API: const node = document.querySelector('.some-element') // Callback pattern const obs = intersectionObserver(node, { callback ({ entry, entries }) { // Do what you want with each entry } }) // Event listener pattern node.addEventListener('intersect', event =\u003e { const { entry } = event.detail // Do what you want with each entry }) Disconnecting the Intersection Observer IntersectionObserverâ€˜s methods are a union of both resizeObserver and mutationObserver. It has four methods: observe: observe an element unobserve: stops observing one element disconnect: stops observing all elements takeRecords: gets unprocessed records So, we can combine the methods weâ€™ve written in resizeObserver and mutationObserver for this one: export function intersectionObserver(node, options = {}) { // ... return { unobserve(node) { observer.unobserve(node) }, disconnect() { // Take records before disconnecting. const records = observer.takeRecords() observer.disconnect() if (records.length \u003e 0) observerFn(records) }, takeRecords() { return observer.takeRecords() }, } } Now we can stop observing with the unobserve or disconnect method. const node = document.querySelector('.some-element') const obs = intersectionObserver(node, /*...*/) // Disconnect the observer obs.disconnect() IntersectionObserver options In case you were wondering, IntersectionObserver takes in three options: root: The element used to check if observed elements are visible rootMargin: Lets you specify an offset amount from the edges of the root threshold: Determines when to log an observer entry Hereâ€™s an article to help you understand IntersectionObserver options. Using this in practice via Splendid Labz Splendid Labz has a utils library that contains resizeObserver, mutationObserver and IntersectionObserver. You can use them if you donâ€™t want to copy-paste the above snippets into every project. import { resizeObserver, intersectionObserver, mutationObserver } from 'splendidlabz/utils/dom' const mode = document.querySelector(â€˜some-elementâ€™) const resizeObs = resizeObserver(node, /* ... */) const intersectObs = intersectionObserver(node, /* ... */) const mutateObs = mutationObserver(node, /* ... */) Aside from the code weâ€™ve written together above (and in the previous article), each observer method in Splendid Labz is capable of letting you observe and stop observing multiple elements at once (except mutationObserver because it doesnâ€™t have a unobserve method) const items = document.querySelectorAll('.elements') const obs = resizeObserver(items, { callback ({ entry, entries }) { /* Do what you want here */ } }) // Unobserves two items at once const subset = [items[0], items[1]] obs.unobserve(subset) So it might be just a tad easier to use the functions Iâ€™ve already created for you. ðŸ˜‰ Shameless Plug: Splendid Labz contains a ton of useful utilities â€” for CSS, JavaScript, Astro, and Svelte â€” that I have created over the last few years. Iâ€™ve parked them all in into Splendid Labz, so I no longer need to scour the internet for useful functions for most of my web projects. If you take a look, you might just enjoy what Iâ€™ve complied! (Iâ€™m still making the docs at the time of writing so it can seem relatively empty. Check back every now and then!) Learning to refactor stuff If you love the way I explained how to refactor the observer APIs, you may find how I teach JavaScript interesting. In my JavaScript course, youâ€™ll learn to build 20 real life components. Weâ€™ll start off simple, add features, and refactor along the way. Refactoring is such an important skill to learn â€” and in here, I make sure you got cement it into your brain. Thatâ€™s it! Hope you had fun reading this piece!",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/04/code-mutation-observer.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eIn a \u003ca href=\"\"\u003eprevious article\u003c/a\u003e, I showed you how to refactor the Resize Observer API into something way simpler to use:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// From this\nconst observer = new ResizeObserver(observerFn)\n\nfunction observerFn (entries) {\n  for (let entry of entries) {\n    // Do something with each entry\n  }\n}\n\nconst element = document.querySelector(\u0026#39;#some-element\u0026#39;)\nobserver.observe(element);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// To this \nconst node = document.querySelector(\u0026#39;#some-element\u0026#39;)\nconst obs = resizeObserver(node, {\n  callback({ entry }) {\n    // Do something with each entry\n  }\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eToday, weâ€™re going to do the same for \u003ccode\u003eMutationObserver\u003c/code\u003e and \u003ccode\u003eIntersectionObserver\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"refactoring-mutationobserver\"\u003eRefactoring Mutation Observer\u003c/h3\u003e\n\n\n\u003cp\u003e\u003ccode\u003eMutationObserver\u003c/code\u003e has almost the same API as that of \u003ccode\u003eResizeObserver\u003c/code\u003e. So we can practically copy-paste the entire chunk of code we wrote for \u003ccode\u003eresizeObserver\u003c/code\u003e to \u003ccode\u003emutationObserver\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eexport function mutationObserver(node, options = {}) {\n  const observer = new MutationObserver(observerFn)\n  const { callback, ...opts } = options\n  observer.observe(node, opts)\n\n  function observerFn(entries) {\n    for (const entry of entries) {\n      // Callback pattern\n      if (options.callback) options.callback({ entry, entries, observer })\n      // Event listener pattern\n      else {\n        node.dispatchEvent(\n          new CustomEvent(\u0026#39;mutate\u0026#39;, {\n            detail: { entry, entries, observer },\n          })\n        )\n      }\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou can now use \u003ccode\u003emutationObserver\u003c/code\u003e with the \u003ccode\u003ecallback\u003c/code\u003e pattern or event listener pattern.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst node = document.querySelector(\u0026#39;.some-element\u0026#39;)\n\n// Callback pattern \nconst obs = mutationObserver(node, {\n  callback ({ entry, entries }) {\n    // Do what you want with each entry\n  }\n})\n\n// Event listener pattern\nnode.addEventListener(\u0026#39;mutate\u0026#39;, event =\u0026gt; {\n  const { entry } = event.detail\n  // Do what you want with each entry\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eMuch easier!\u003c/p\u003e\n\n\n\u003ch4 id=\"disconnecting-the-observer\"\u003eDisconnecting the observer\u003c/h4\u003e\n\n\n\u003cp\u003eUnlike \u003ccode\u003eResizeObserver\u003c/code\u003e who has two methods to stop observing elements, \u003ccode\u003eMutationObserver\u003c/code\u003e only has one, the \u003ccode\u003edisconnect\u003c/code\u003e method.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eexport function mutationObserver(node, options = {}) {\n  // ... \n  return {\n    disconnect() {\n      observer.disconnect()\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBut,Â \u003ccode\u003eMutationObserver\u003c/code\u003eÂ has aÂ \u003ccode\u003etakeRecords\u003c/code\u003eÂ method that lets youÂ \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/takeRecords#examples\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eget unprocessed records\u003c/a\u003eÂ before you disconnect. Since we should \u003ccode\u003etakeRecords\u003c/code\u003e before we \u003ccode\u003edisconnect\u003c/code\u003e, letâ€™s use it inside \u003ccode\u003edisconnect\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo create a complete API, we can return this method as well.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eexport function mutationObserver(node, options = {}) {\n  // ... \n  return {\n    // ...\n    disconnect() {\n      const records = observer.takeRecords()\n      observer.disconnect()\n      if (records.length \u0026gt; 0) observerFn(records)\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow we can disconnect our mutation observer easily with \u003ccode\u003edisconnect\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst node = document.querySelector(\u0026#39;.some-element\u0026#39;)\nconst obs = mutationObserver(/* ... */)\n\nobs.disconnect()\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch4 id=\"mutationobserver-s-observe-options\"\u003eMutationObserverâ€™s observe options\u003c/h4\u003e\n\n\n\u003cp\u003eIn case you were wondering, \u003ccode\u003eMutationObserver\u003c/code\u003eâ€™s \u003ccode\u003eobserve\u003c/code\u003e method can take in 7 \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe#options\" rel=\"noopener\"\u003eoptions\u003c/a\u003e. Each one of them determines what to observe, and they all default to \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esubtree\u003c/code\u003e: Monitors the entire subtree of nodes\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003echildList\u003c/code\u003e: Monitors for addition or removal children elements. If \u003ccode\u003esubtree\u003c/code\u003e is \u003ccode\u003etrue\u003c/code\u003e, this monitors all descendant elements.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eattributes\u003c/code\u003e: Monitors for a change of attributes\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eattributeFilter\u003c/code\u003e: Array of specific attributes to monitor\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eattributeOldValue\u003c/code\u003e: Whether to record the previous attribute value if it was changed\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003echaracterData\u003c/code\u003e: Monitors for change in character data\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003echaracterDataOldValue\u003c/code\u003e: Whether to record the previous character data value\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003ch3 id=\"refactoring-intersection-observer\"\u003eRefactoring Intersection Observer\u003c/h3\u003e\n\n\n\u003cp\u003eThe API for \u003ccode\u003eIntersectionObserver\u003c/code\u003e is similar to other observers. Again, you have to:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eCreate a new observer:\u003c/strong\u003e with the \u003ccode\u003enew\u003c/code\u003e keyword. This observer takes in an observer function to execute.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eDo something with the observed changes:\u003c/strong\u003e This is done via the observer function that is passed into the observer.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eObserve a specific element:\u003c/strong\u003e By using the \u003ccode\u003eobserve\u003c/code\u003e method.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003e(Optionally) unobserve the element:\u003c/strong\u003e By using the \u003ccode\u003eunobserve\u003c/code\u003e or \u003ccode\u003edisconnect\u003c/code\u003e method (depending on which Observer youâ€™re using).\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eBut \u003ccode\u003eIntersectionObserver\u003c/code\u003e requires you to pass the options in Step 1 (instead of Step 3). So hereâ€™s the code to use the \u003ccode\u003eIntersectionObserver\u003c/code\u003e API.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// Step 1: Create a new observer and pass in relevant options\nconst options = {/*...*/}\nconst observer = new IntersectionObserver(observerFn, options)\n\n// Step 2: Do something with the observed changes\nfunction observerFn (entries) {\n  for (const entry of entries) {\n    // Do something with entry\n  }\n}\n\n// Step 3: Observe the element\nconst element = document.querySelector(\u0026#39;#some-element\u0026#39;)\nobserver.observe(element)\n\n// Step 4 (optional): Disconnect the observer when we\u0026#39;re done using it\nobserver.disconnect(element)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSince the code is similar, we can also copy-paste the code we wrote for \u003ccode\u003emutationObserver\u003c/code\u003e into \u003ccode\u003eintersectionObserver\u003c/code\u003e. When doing so, we have to remember to pass the options into \u003ccode\u003eIntersectionObserver\u003c/code\u003e and not the \u003ccode\u003eobserve\u003c/code\u003e method.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"2,3\"\u003e\u003ccode markup=\"tt\"\u003eexport function mutationObserver(node, options = {}) {\n  const { callback, ...opts } = options\n  const observer = new MutationObserver(observerFn, opts)\n  observer.observe(node)\n\n  function observerFn(entries) {\n    for (const entry of entries) {\n      // Callback pattern\n      if (options.callback) options.callback({ entry, entries, observer })\n      // Event listener pattern\n      else {\n        node.dispatchEvent(\n          new CustomEvent(\u0026#39;intersect\u0026#39;, {\n            detail: { entry, entries, observer },\n          })\n        )\n      }\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow we can use \u003ccode\u003eintersectionObserver\u003c/code\u003e with the same easy-to-use API:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst node = document.querySelector(\u0026#39;.some-element\u0026#39;)\n\n// Callback pattern \nconst obs = intersectionObserver(node, {\n  callback ({ entry, entries }) {\n    // Do what you want with each entry\n  }\n})\n\n// Event listener pattern\nnode.addEventListener(\u0026#39;intersect\u0026#39;, event =\u0026gt; {\n  const { entry } = event.detail\n  // Do what you want with each entry\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch4 id=\"disconnecting-the-intersection-observer\"\u003eDisconnecting the Intersection Observer\u003c/h4\u003e\n\n\n\u003cp\u003e\u003ccode\u003eIntersectionObserver\u003c/code\u003eâ€˜s methods are a union of both \u003ccode\u003eresizeObserver\u003c/code\u003e and \u003ccode\u003emutationObserver\u003c/code\u003e. It has four methods:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eobserve\u003c/code\u003e: observe an element\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eunobserve\u003c/code\u003e: stops observing one element\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003edisconnect\u003c/code\u003e: stops observing all elements\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003etakeRecords\u003c/code\u003e: gets unprocessed records\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eSo, we can combine the methods weâ€™ve written in \u003ccode\u003eresizeObserver\u003c/code\u003e and \u003ccode\u003emutationObserver\u003c/code\u003e for this one:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eexport function intersectionObserver(node, options = {}) {\n  // ...\n  return {\n    unobserve(node) {\n      observer.unobserve(node)\n    },\n\n    disconnect() {\n      // Take records before disconnecting.\n      const records = observer.takeRecords()\n      observer.disconnect()\n      if (records.length \u0026gt; 0) observerFn(records)\n    },\n    \n    takeRecords() {\n      return observer.takeRecords()\n    },\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow we can stop observing with the \u003ccode\u003eunobserve\u003c/code\u003e or \u003ccode\u003edisconnect\u003c/code\u003e method.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst node = document.querySelector(\u0026#39;.some-element\u0026#39;)\nconst obs = intersectionObserver(node, /*...*/)\n\n// Disconnect the observer\nobs.disconnect()\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch4 id=\"-intersectionobserver-options\"\u003e\u003ccode\u003eIntersectionObserver\u003c/code\u003e options\u003c/h4\u003e\n\n\n\u003cp\u003eIn case you were wondering, \u003ccode\u003eIntersectionObserver\u003c/code\u003e takes in three options:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eroot\u003c/code\u003e: The element used to check if observed elements are visible\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003erootMargin\u003c/code\u003e: Lets you specify an offset amount from the edges of the root\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003ethreshold\u003c/code\u003e: Determines when to log an observer entry\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eHereâ€™s an article to help you \u003ca href=\"https://css-tricks.com/an-explanation-of-how-the-intersection-observer-watches/\"\u003eunderstand \u003ccode\u003eIntersectionObserver\u003c/code\u003e options\u003c/a\u003e.\u003c/p\u003e\n\n\n\u003ch3 id=\"using-this-in-practice-via-splendid-labz\"\u003eUsing this in practice via Splendid Labz\u003c/h3\u003e\n\n\n\u003cp\u003eSplendid Labz has a \u003ca href=\"https://splendidlabz.com/utils\" rel=\"noopener\"\u003e\u003ccode\u003eutils\u003c/code\u003e\u003c/a\u003e library that contains \u003ccode\u003eresizeObserver\u003c/code\u003e, \u003ccode\u003emutationObserver\u003c/code\u003e and \u003ccode\u003eIntersectionObserver\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou can use them if you donâ€™t want to copy-paste the above snippets into every project.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eimport { \n  resizeObserver, \n  intersectionObserver, \n  mutationObserver \n} from \u0026#39;splendidlabz/utils/dom\u0026#39;\n\nconst mode = document.querySelector(â€˜some-elementâ€™)\n\nconst resizeObs = resizeObserver(node, /* ... */)\nconst intersectObs = intersectionObserver(node, /* ... */)\nconst mutateObs = mutationObserver(node, /* ... */)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAside from the code weâ€™ve written together above (and in the \u003ca href=\"\"\u003eprevious article\u003c/a\u003e), each observer method in Splendid Labz is capable of letting you observe and stop observing multiple elements at once (except \u003ccode\u003emutationObserver\u003c/code\u003e because it doesnâ€™t have a \u003ccode\u003eunobserve\u003c/code\u003e method)\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst items = document.querySelectorAll(\u0026#39;.elements\u0026#39;)\nconst obs = resizeObserver(items, {\n  callback ({ entry, entries }) {\n    /* Do what you want here */\n  }\n})\n\n// Unobserves two items at once\nconst subset = [items[0], items[1]]\nobs.unobserve(subset)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSo it might be just a tad easier to use the functions Iâ€™ve already created for you. ðŸ˜‰\u003c/p\u003e\n\n\n\n\u003cp\u003eShameless Plug: \u003ca href=\"https://splendidlabz.com\" rel=\"noopener\"\u003eSplendid Labz\u003c/a\u003e contains a ton of useful utilities â€” for CSS, JavaScript, Astro, and Svelte â€” that I have created over the last few years.\u003c/p\u003e\n\n\n\n\u003cp\u003eIâ€™ve parked them all in into Splendid Labz, so I no longer need to scour the internet for useful functions for most of my web projects. If you take a look, you might just enjoy what Iâ€™ve complied!\u003c/p\u003e\n\n\n\n\u003cp\u003e(Iâ€™m still making the docs at the time of writing so it can seem relatively empty. Check back every now and then!)\u003c/p\u003e\n\n\n\u003ch3 id=\"learning-to-refactor-stuff\"\u003eLearning to refactor stuff\u003c/h3\u003e\n\n\n\u003cp\u003eIf you love the way I explained how to refactor the observer APIs, you may find how I teach JavaScript interesting.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn \u003ca href=\"https://learnjavascript.today\" rel=\"noopener\"\u003emy JavaScript course\u003c/a\u003e, youâ€™ll learn to build 20 real life components. Weâ€™ll start off simple, add features, and refactor along the way.\u003c/p\u003e\n\n\n\n\u003cp\u003eRefactoring is such an important skill to learn â€” and in here, I make sure you got cement it into your brain.\u003c/p\u003e\n\n\n\n\u003cp\u003eThatâ€™s it! Hope you had fun reading this piece!\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2025-06-23T07:41:34-06:00",
  "modifiedTime": "2025-06-23T07:41:44-06:00"
}
