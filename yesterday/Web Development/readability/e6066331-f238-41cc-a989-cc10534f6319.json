{
  "id": "e6066331-f238-41cc-a989-cc10534f6319",
  "title": "Better CSS Shapes Using shape() — Part 2: More on Arcs",
  "link": "https://css-tricks.com/better-css-shapes-using-shape-part-2-more-on-arcs/",
  "description": "This is the second part of a series that dives deep into the CSS shape() command, continuing with a more detailed look at the arc command. Better CSS Shapes Using shape() — Part 2: More on Arcs originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Temani Afif",
  "published": "Fri, 30 May 2025 13:45:43 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "art",
    "clip-path",
    "css shapes",
    "functions"
  ],
  "byline": "Temani Afif",
  "length": 11710,
  "excerpt": "This is the second part of a series that dives deep into the CSS shape() command, continuing with a more detailed look at the arc command.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "Ready for the second part? We are still exploring the shape() function, and more precisely, the arc command. I hope you took the time to digest the first part because we will jump straight into creating more shapes! As a reminder, the shape() function is only supported in Chrome 137+ and Safari 18.4+ as I’m writing this in May 2025. Sector shape Another classic shape that can also be used in pie-like charts. It’s already clear that we have one arc. As for the points, we have two points that don’t move and one that moves depending on how much the sector is filled. The code will look like this: .sector { --v: 35; /* [0 100]*/ aspect-ratio: 1; clip-path: shape(from top, arc to X Y of R, line to center); } We define a variable that will control the filling of the sector. It has a value between 0 and 100. To draw the shape, we start from the top, create an arc until the point (X, Y), and then we move to the center. Are we allowed to use keyword values like top and center? Yes! Unlike the polygon() function, we have keywords for the particular cases such as top, bottom, left, etc. It’s exactly like background-position that way. I don’t think I need to detail this part as it’s trivial, but it’s good to know because it can make your shape a bit easier to read. The radius of the arc should be equal to 50%. We are working with a square element and the sector, which is a portion of a circle, need to fill the whole element so the radius is equal to half the width (or height).1 As for the point, it’s placed within that circle, and its position depends on the V value. You don’t want a boring math explanation, right? No need for it, here is the formula of X and Y: X = 50% + 50% * sin(V * 3.6deg) Y = 50% - 50% * cos(V * 3.6deg) Our code becomes: .sector { --v: 35; /* [0 100] */ aspect-ratio: 1; clip-path: shape(from top, arc to calc(50% + 50% * sin(var(--v) * 3.6deg)) calc(50% - 50% * cos(var(--v) * 3.6deg)) of 50%, line to center); } Hmm, the result is not good, but there are no mistakes in the code. Can you figure out what we are missing? It’s the size and direction of the arc! Remember what I told you in the last article? You will always have trouble with them, but if we try the different combinations, we can easily fix the issue. In our case, we need to use: small cw. Better! Let’s try it with more values and see how the shape behaves: Oops, some values are good, but others not so much. The direction needs to be clockwise, but maybe we should use large instead of small? Let’s try: Still not working. The issue here is that we are moving one point of the arc based on the V value, and this movement creates a different configuration for the arc command. Here is an interactive demo to better visualize what is happening: When you update the value, notice how large cw always tries to follow the largest arc between the points, while small cw tries to follow the smallest one. When the value is smaller than 50, small cw gives us a good result. But when it’s bigger than 50, the large cw combination is the good one. I know, it’s a bit tricky and I wanted to study this particular example to emphasize the fact that we can have a lot of headaches working with arcs. But the more issues we face, the better we get at fixing them. The solution in this case is pretty simple. We keep the use of large cw and add a border-radius to the element. If you check the previous demo, you will notice that even if large cw is not producing a good result, it’s filling the area we want. All we need to do is clip the extra space and a simple border-radius: 50% will do the job! I am keeping the box-shadow in there so we can see the arc, but we can clearly see how border-radius is making a difference on the main shape. There is still one edge case we need to consider. When the value is equal to 100, both points of the arc will have the same coordinates, which is logical since the sector is full and we have a circle. But when it’s the case, the arc will do nothing by definition and we won’t get a full circle. To fix this, we can limit the value to, for example, 99.99 to avoid reaching 100. It’s kind of hacky, but it does the job. .sector { --v: 35; /* [0 100]*/ --_v: min(99.99, var(--v)); aspect-ratio: 1; clip-path: shape(from top, arc to calc(50% + 50% * sin(var(--_v) * 3.6deg)) calc(50% - 50% * cos(var(--_v) * 3.6deg)) of 50% large cw, line to center); border-radius: 50%; } Now our shape is perfect! And don’t forget that you can apply it to image elements: Arc shape Similar to the sector shape, we can also create an arc shape. After all, we are working with the arc command, so we have to do it. We already have half the code since it’s basically a sector shape without the inner part. We simply need to add more commands to cut the inner part. .arc { --v: 35; --b: 30px; --_v: min(99.99, var(--v)); aspect-ratio: 1; clip-path: shape(from top, arc to calc(50% + 50% * sin(var(--_v) * 3.6deg)) calc(50% - 50% * cos(var(--_v) * 3.6deg)) of 50% cw large, line to calc(50% + (50% - var(--b)) * sin(var(--_v) * 3.6deg)) calc(50% - (50% - var(--b)) * cos(var(--_v) * 3.6deg)), arc to 50% var(--b) of calc(50% - var(--b)) large ); border-radius: 50%; } From the sector shape, we remove the line to center piece and replace it with another line command that moves to a point placed on the inner circle. If you compare its coordinates with the previous point, you will see an offset equal to --b, which is a variable that defines the arc’s thickness. Then we draw an arc in the opposite direction (ccw) until the point 50% var(--b), which is also a point with an offset equal to --b from the top. I am not defining the direction of the second arc since, by default, the browser will use ccw. Ah, the same issue we hit with the sector shape is striking again! Not all the values are giving a good result due to the same logic we saw earlier, and, as you can see, border-radius is not fixing it. This time, we need to find a way to conditionally change the size of the arc based on the value. It should be large when V is bigger than 50, and small otherwise. Conditions in CSS? Yes, it’s possible! First, let’s convert the V value like this: --_f: round(down, var(--_v), 50) The value is within the range [0 99.99] (don’t forget that we don’t want to reach the value 100). We use round() to make sure it’s always equal to a multiple of a specific value, which is 50 in our case. If the value is smaller than 50, the result is 0, otherwise it’s 50. There are only two possible values, so we can easily add a condition. If --_f is equal to 0 we use small; otherwise, we use large: .arc { --v: 35; --b: 30px; --_v: min(99.99, var(--v)); --_f: round(down,var(--_v), 50); --_c: if(style(--_f: 0): small; else: large); clip-path: shape(from top, arc to calc(50% + 50% * sin(var(--_v) * 3.6deg)) calc(50% - 50% * cos(var(--_v) * 3.6deg)) of 50% cw var(--_c), line to calc(50% + (50% - var(--b)) * sin(var(--_v) * 3.6deg)) calc(50% - (50% - var(--b)) * cos(var(--_v) * 3.6deg)), arc to 50% var(--b) of calc(50% - var(--b)) var(--_c) ); } I know what you are thinking, but let me tell you that the above code is valid. You probably don’t know it yet, but CSS has recently introduced inline conditionals using an if() syntax. It’s still early to play with it, but we have found a perfect use case for it. Here is a demo that you can test using Chrome Canary: Another way to express conditions is to rely on style queries that have better support: .arc { --v: 35; --b: 30px; --_v: min(99.99, var(--v)); --_f: round(down, var(--_v), 50); aspect-ratio: 1; container-name: arc; } .arc:before { content: \"\"; clip-path: shape(from top, arc to calc(50% + 50% * sin(var(--_v) * 3.6deg)) calc(50% - 50% * cos(var(--_v) * 3.6deg)) of 50% cw var(--_c, large), line to calc(50% + (50% - var(--b)) * sin(var(--_v) * 3.6deg)) calc(50% - (50% - var(--b)) * cos(var(--_v) * 3.6deg)), arc to 50% var(--b) of calc(50% - var(--b)) var(--_c, large) ); @container style(--_f: 0) { --_c: small } } The logic is the same but, this feature requires a parent-child relation, which is why I am using a pseudo-element. By default, the size will be large, and if the value of --_f is equal to 0, we switch to small. Note that we have to register the variable --_f using @property to be able to either use the if() function or style queries. Did you notice another subtle change I have made to the shape? I removed border-radius and I applied the conditional logic to the first arc. Both have the same issue, but border-radius can fix only one of them while the conditional logic can fix both, so we can optimize the code a little. Arc shape with rounded edges What about adding rounded edges to our arc? It’s better, right? Can you see how it’s done? Take it as a small exercise and update the code from the previous examples to add those rounded edges. I hope you are able to find it by yourself because the changes are pretty straightforward — we update one line command with an arc command and we add another arc command at the end. clip-path: shape(from top, arc to calc(50% + 50% * sin(var(--_v) * 3.6deg)) calc(50% - 50% * cos(var(--_v) * 3.6deg)) of 50% cw var(--_c, large), arc to calc(50% + (50% - var(--b)) * sin(var(--_v) * 3.6deg)) calc(50% - (50% - var(--b)) * cos(var(--_v) * 3.6deg)) of 1% cw, arc to 50% var(--b) of calc(50% - var(--b)) var(--_c, large), arc to top of 1% cw ); If you do not understand the changes, get out a pen and paper, then draw the shape to better see the four arcs we are drawing. Previously, we had two arcs and two lines, but now we are working with arcs instead of lines. And did you remember the trick of using a 1% value for the radius? The new arcs are half circles, so we can rely on that trick where you specify a tiny radius and the browser will do the job for you and find the correct value! Conclusion We are done — enough about the arc command! I had to write two articles that focus on this command because it’s the trickiest one, but I hope it’s now clear how to use it and how to handle the direction and size thing, as that is probably the source of most headaches. By the way, I have only studied the case of circular arcs because, in reality, we can specify two radii and draw elliptical ones, which is even more complex. Unless you want to become a shape() master, you will rarely need elliptical arcs, so don’t bother yourself with them. Until the next article, I wrote an article for Frontend Masters where you can create more fancy shapes using the arc command that is a good follow-up to this one. Footnotes (1) The arc command is defined to draw elliptical arcs by taking two radii, but if we define one radius value, it means that the vertical and horizontal radius will use that same value and we have circular arcs. When it’s a length, it’s trivial, but when we use percentages, the value will resolve against the direction-agnostic size, which is equal to the length of the diagonal of the box, divided by sqrt(2). In our case, we have a square element so 50% of the direction-agnostic size will be equal to 50% of sqrt(Width² + Height²)/sqrt(2). And since both width and height are equal, we end with 50% of the width (or the height). ⮑",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/shape-fuinction-featured.webp",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eReady for the second part? We are still exploring the \u003ccode\u003eshape()\u003c/code\u003e function, and more precisely, the arc command. I hope you took the time to digest \u003ca href=\"https://css-tricks.com/better-css-shapes-using-shape-part-1-lines-and-arcs\"\u003ethe first part\u003c/a\u003e because we will jump straight into creating more shapes!\u003c/p\u003e\n\n\n\n\u003cp\u003eAs a reminder, the \u003ccode\u003eshape()\u003c/code\u003e function is only supported in Chrome 137+ and Safari 18.4+ as I’m writing this in May 2025.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"sector-shape\"\u003eSector shape\u003c/h3\u003e\n\n\n\u003cp\u003eAnother classic shape that can also be used in pie-like charts.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"719\" height=\"312\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747235922130_image.png.webp?resize=719%2C312\u0026amp;ssl=1\" alt=\"A series of three semi-circles.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747235922130_image.png.webp?w=719\u0026amp;ssl=1 719w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747235922130_image.png.webp?resize=300%2C130\u0026amp;ssl=1 300w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIt’s already clear that we have one arc. As for the points, we have two points that don’t move and one that moves depending on how much the sector is filled.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"595\" height=\"403\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747236487932_image.png.webp?resize=595%2C403\u0026amp;ssl=1\" alt=\"Diagram showing the fixed and variable lengths of an arc shape.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747236487932_image.png.webp?w=595\u0026amp;ssl=1 595w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747236487932_image.png.webp?resize=300%2C203\u0026amp;ssl=1 300w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe code will look like this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.sector {\n  --v: 35; /* [0 100]*/\n  \n  aspect-ratio: 1;\n  clip-path: shape(from top, arc to X Y of R, line to center);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe define a variable that will control the filling of the sector. It has a value between \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003e100\u003c/code\u003e. To draw the shape, we start from the \u003ccode\u003etop\u003c/code\u003e, create an arc until the point (X, Y), and then we move to the \u003ccode\u003ecenter\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eAre we allowed to use keyword values like \u003ccode\u003etop\u003c/code\u003e and \u003ccode\u003ecenter\u003c/code\u003e?\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eYes! Unlike the \u003ccode\u003epolygon()\u003c/code\u003e function, we have keywords for the particular cases such as \u003ccode\u003etop\u003c/code\u003e, \u003ccode\u003ebottom\u003c/code\u003e, \u003ccode\u003eleft\u003c/code\u003e, etc. It’s exactly like \u003ccode\u003ebackground-position\u003c/code\u003e that way. I don’t think I need to detail this part as it’s trivial, but it’s good to know because it can make your shape a bit easier to read.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe radius of the arc should be equal to \u003ccode\u003e50%\u003c/code\u003e. We are working with a square element and the sector, which is a portion of a circle, need to fill the whole element so the radius is equal to half the width (or height).\u003csup id=\"note-1\"\u003e\u003ca href=\"#footnote-1\"\u003e1\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eAs for the point, it’s placed within that circle, and its position depends on the V value. You don’t want a boring math explanation, right? No need for it, here is the formula of X and Y:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eX = 50% + 50% * sin(V * 3.6deg)\nY = 50% - 50% * cos(V * 3.6deg)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOur code becomes:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.sector {\n  --v: 35; /* [0 100] */\n  \n  aspect-ratio: 1;\n  clip-path: shape(from top,\n    arc to calc(50% + 50% * sin(var(--v) * 3.6deg)) \n           calc(50% - 50% * cos(var(--v) * 3.6deg)) of 50%,\n    line to center);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eHmm, the result is not good, but there are no mistakes in the code. Can you figure out what we are missing?\u003c/p\u003e\n\n\n\n\u003cp\u003eIt’s the size and direction of the arc!\u003c/p\u003e\n\n\n\n\u003cp\u003eRemember what I told you in the last article? You will always have trouble with them, but if we try the different combinations, we can easily fix the issue. In our case, we need to use: \u003ccode\u003esmall cw\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eBetter! Let’s try it with more values and see how the shape behaves:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eOops, some values are good, but others not so much. The direction needs to be clockwise, but maybe we should use \u003ccode\u003elarge\u003c/code\u003e instead of \u003ccode\u003esmall\u003c/code\u003e? Let’s try:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eStill not working. The issue here is that we are moving one point of the arc based on the V value, and this movement creates a different configuration for the \u003ccode\u003earc\u003c/code\u003e command.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is an interactive demo to better visualize what is happening:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWhen you update the value, notice how \u003ccode\u003elarge cw\u003c/code\u003e always tries to follow the largest arc between the points, while \u003ccode\u003esmall cw\u003c/code\u003e tries to follow the smallest one. When the value is smaller than \u003ccode\u003e50\u003c/code\u003e, \u003ccode\u003esmall cw\u003c/code\u003e gives us a good result. But when it’s bigger than \u003ccode\u003e50\u003c/code\u003e, the \u003ccode\u003elarge cw\u003c/code\u003e combination is the good one.\u003c/p\u003e\n\n\n\n\u003cp\u003eI know, it’s a bit tricky and I wanted to study this particular example to emphasize the fact that we can have a lot of headaches working with arcs. But the more issues we face, the better we get at fixing them.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe solution in this case is pretty simple. We keep the use of \u003ccode\u003elarge cw\u003c/code\u003e and add a \u003ccode\u003eborder-radius\u003c/code\u003e to the element. If you check the previous demo, you will notice that even if \u003ccode\u003elarge cw\u003c/code\u003e is not producing a good result, it’s filling the area we want. All we need to do is clip the extra space and a simple \u003ccode\u003eborder-radius: 50%\u003c/code\u003e will do the job!\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eI am keeping the \u003ccode\u003ebox-shadow\u003c/code\u003e in there so we can see the arc, but we can clearly see how \u003ccode\u003eborder-radius\u003c/code\u003e is making a difference on the main shape.\u003c/p\u003e\n\n\n\n\u003cp\u003eThere is still one edge case we need to consider. When the value is equal to \u003ccode\u003e100\u003c/code\u003e, both points of the arc will have the same coordinates, which is logical since the sector is full and we have a circle. But when it’s the case, the arc will do nothing by definition and we won’t get a full circle.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo fix this, we can limit the value to, for example, \u003ccode\u003e99.99\u003c/code\u003e to avoid reaching \u003ccode\u003e100\u003c/code\u003e. It’s kind of hacky, but it does the job.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.sector {\n  --v: 35; /* [0 100]*/\n  \n  --_v: min(99.99, var(--v));\n  aspect-ratio: 1;\n  clip-path: shape(from top,\n    arc to calc(50% + 50% * sin(var(--_v) * 3.6deg)) \n           calc(50% - 50% * cos(var(--_v) * 3.6deg)) of 50% large cw,\n    line to center);\n  border-radius: 50%;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow our shape is perfect! And don’t forget that you can apply it to image elements:\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"arc-shape\"\u003eArc shape\u003c/h3\u003e\n\n\n\u003cp\u003eSimilar to the sector shape, we can also create an arc shape. After all, we are working with the \u003ccode\u003earc\u003c/code\u003e command, so we have to do it.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"783\" height=\"335\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747257617920_image.png.webp?resize=783%2C335\u0026amp;ssl=1\" alt=\"A series of three circular rings at various lengths.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747257617920_image.png.webp?w=783\u0026amp;ssl=1 783w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747257617920_image.png.webp?resize=300%2C128\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747257617920_image.png.webp?resize=768%2C329\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWe already have half the code since it’s basically a sector shape without the inner part. We simply need to add more commands to cut the inner part.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"640\" height=\"436\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747258392197_image.png.webp?resize=640%2C436\u0026amp;ssl=1\" alt=\"Diagram showing the arc points of a semi-circle shape. There are two arcs, one on the outside and one on the inside. They are joined by straight lines.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747258392197_image.png.webp?w=640\u0026amp;ssl=1 640w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747258392197_image.png.webp?resize=300%2C204\u0026amp;ssl=1 300w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.arc {\n  --v: 35; \n  --b: 30px;\n  \n  --_v: min(99.99, var(--v));\n  aspect-ratio: 1;\n  clip-path: shape(from top,\n    arc to calc(50% + 50% * sin(var(--_v) * 3.6deg)) \n           calc(50% - 50% * cos(var(--_v) * 3.6deg)) of 50% cw large,\n    \n    line to calc(50% + (50% - var(--b)) * sin(var(--_v) * 3.6deg)) \n            calc(50% - (50% - var(--b)) * cos(var(--_v) * 3.6deg)),\n    arc to 50% var(--b) of calc(50% - var(--b)) large\n  );\n  border-radius: 50%;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFrom the sector shape, we remove the \u003ccode\u003eline to center\u003c/code\u003e piece and replace it with another \u003ccode\u003eline\u003c/code\u003e command that moves to a point placed on the inner circle. If you compare its coordinates with the previous point, you will see an offset equal to \u003ccode\u003e--b\u003c/code\u003e, which is a variable that defines the arc’s thickness. Then we draw an arc in the opposite direction (\u003ccode\u003eccw\u003c/code\u003e) until the point \u003ccode\u003e50% var(--b)\u003c/code\u003e, which is also a point with an offset equal to \u003ccode\u003e--b\u003c/code\u003e from the top.\u003c/p\u003e\n\n\n\n\u003cp\u003eI am not defining the direction of the second arc since, by default, the browser will use \u003ccode\u003eccw\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eAh, the same issue we hit with the sector shape is striking again! Not all the values are giving a good result due to the same logic we saw earlier, and, as you can see, \u003ccode\u003eborder-radius\u003c/code\u003e is not fixing it. This time, we need to find a way to conditionally change the size of the arc based on the value. It should be \u003ccode\u003elarge\u003c/code\u003e when V is bigger than \u003ccode\u003e50\u003c/code\u003e, and \u003ccode\u003esmall\u003c/code\u003e otherwise.\u003c/p\u003e\n\n\n\n\u003cp\u003eConditions in CSS? Yes, it’s possible! First, let’s convert the V value like this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e--_f: round(down, var(--_v), 50)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe value is within the range \u003ccode\u003e[0 99.99]\u003c/code\u003e (don’t forget that we don’t want to reach the value 100). We use \u003ccode\u003eround()\u003c/code\u003e to make sure it’s always equal to a multiple of a specific value, which is \u003ccode\u003e50\u003c/code\u003e in our case. If the value is smaller than \u003ccode\u003e50\u003c/code\u003e, the result is \u003ccode\u003e0\u003c/code\u003e, otherwise it’s \u003ccode\u003e50\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThere are only two possible values, so we can easily add a condition. If \u003ccode\u003e--_f\u003c/code\u003e is equal to \u003ccode\u003e0\u003c/code\u003e we use small; otherwise, we use large:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"6,7\"\u003e\u003ccode markup=\"tt\"\u003e.arc {\n  --v: 35;\n  --b: 30px;\n  \n  --_v: min(99.99, var(--v));\n  --_f: round(down,var(--_v), 50);\n  --_c: if(style(--_f: 0): small; else: large);\n  clip-path: shape(from top,\n    arc to calc(50% + 50% * sin(var(--_v) * 3.6deg)) \n           calc(50% - 50% * cos(var(--_v) * 3.6deg)) of 50% cw var(--_c),\n    line to calc(50% + (50% - var(--b)) * sin(var(--_v) * 3.6deg)) \n            calc(50% - (50% - var(--b)) * cos(var(--_v) * 3.6deg)),\n    arc to 50% var(--b) of calc(50% - var(--b)) var(--_c)\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eI know what you are thinking, but let me tell you that the above code is valid. You probably don’t know it yet, but CSS has recently introduced \u003ca href=\"https://css-tricks.com/if-css-gets-inline-conditionals/\"\u003einline conditionals using an\u003c/a\u003e \u003ca href=\"https://css-tricks.com/if-css-gets-inline-conditionals/\"\u003e\u003ccode\u003eif()\u003c/code\u003e syntax\u003c/a\u003e. It’s still early to play with it, but we have found a perfect use case for it. Here is a demo that you can test using Chrome Canary:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eAnother way to express conditions is to rely on \u003ca href=\"https://css-tricks.com/digging-deeper-into-container-style-queries/\"\u003estyle queries\u003c/a\u003e that have better support:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"8,19\"\u003e\u003ccode markup=\"tt\"\u003e.arc {\n  --v: 35;\n  --b: 30px;\n  \n  --_v: min(99.99, var(--v));\n  --_f: round(down, var(--_v), 50);\n  aspect-ratio: 1;\n  container-name: arc;\n}\n.arc:before {\n  content: \u0026#34;\u0026#34;;\n  clip-path: shape(from top,\n    arc to calc(50% + 50% * sin(var(--_v) * 3.6deg)) \n           calc(50% - 50% * cos(var(--_v) * 3.6deg)) of 50% cw var(--_c, large),\n    line to calc(50% + (50% - var(--b)) * sin(var(--_v) * 3.6deg)) \n            calc(50% - (50% - var(--b)) * cos(var(--_v) * 3.6deg)),\n    arc to 50% var(--b) of calc(50% - var(--b)) var(--_c, large)\n  );\n  @container style(--_f: 0) { --_c: small }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe logic is the same but, this feature requires a parent-child relation, which is why I am using a pseudo-element. By default, the size will be \u003ccode\u003elarge\u003c/code\u003e, and if the value of \u003ccode\u003e--_f\u003c/code\u003e is equal to \u003ccode\u003e0\u003c/code\u003e, we switch to \u003ccode\u003esmall\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eNote that we have to register the variable \u003ccode\u003e--_f\u003c/code\u003e using \u003ccode\u003e@property\u003c/code\u003e to be able to either use the \u003ccode\u003eif()\u003c/code\u003e function or style queries.\u003c/p\u003e\n\n\n\n\u003cp\u003eDid you notice another subtle change I have made to the shape? I removed \u003ccode\u003eborder-radius\u003c/code\u003e and I applied the conditional logic to the first arc. Both have the same issue, but \u003ccode\u003eborder-radius\u003c/code\u003e can fix only one of them while the conditional logic can fix both, so we can optimize the code a little.\u003c/p\u003e\n\n\n\u003ch3 id=\"arc-shape-with-rounded-edges\"\u003eArc shape with rounded edges\u003c/h3\u003e\n\n\n\u003cp\u003eWhat about adding rounded edges to our arc? It’s better, right?\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"691\" height=\"291\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747262479797.webp?resize=691%2C291\u0026amp;ssl=1\" alt=\"A series of three semi-circles with rounded edges at varying lengths.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747262479797.webp?w=691\u0026amp;ssl=1 691w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/s_8CE93768242FD9A6B9E096BADABB68650B618F30768964FE1F5B79353F471E4D_1747262479797.webp?resize=300%2C126\u0026amp;ssl=1 300w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eCan you see how it’s done? Take it as a small exercise and update the code from the previous examples to add those rounded edges. I hope you are able to find it by yourself because the changes are pretty straightforward — we update one \u003ccode\u003eline\u003c/code\u003e command with an \u003ccode\u003earc\u003c/code\u003e command and we add another \u003ccode\u003earc\u003c/code\u003e command at the end.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"4,5,7\"\u003e\u003ccode markup=\"tt\"\u003eclip-path: shape(from top,\n  arc to calc(50% + 50% * sin(var(--_v) * 3.6deg)) \n         calc(50% - 50% * cos(var(--_v) * 3.6deg)) of 50% cw var(--_c, large),\n  arc to calc(50% + (50% - var(--b)) * sin(var(--_v) * 3.6deg))\n         calc(50% - (50% - var(--b)) * cos(var(--_v) * 3.6deg)) of 1% cw,\n  arc to 50% var(--b) of calc(50% - var(--b)) var(--_c, large),\n  arc to top of 1% cw\n);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf you do not understand the changes, get out a pen and paper, then draw the shape to better see the four arcs we are drawing. Previously, we had two arcs and two lines, but now we are working with arcs instead of lines.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnd did you remember the trick of using a \u003ccode\u003e1%\u003c/code\u003e value for the radius? The new arcs are half circles, so we can rely on that trick where you specify a tiny radius and the browser will do the job for you and find the correct value!\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\n\n\u003cp\u003eWe are done — enough about the \u003ccode\u003earc\u003c/code\u003e command! I had to write two articles that focus on this command because it’s the trickiest one, but I hope it’s now clear how to use it and how to handle the direction and size thing, as that is probably the source of most headaches.\u003c/p\u003e\n\n\n\n\u003cp\u003eBy the way, I have only studied the case of circular arcs because, in reality, we can specify two radii and draw elliptical ones, which is even more complex. Unless you want to become a \u003ccode\u003eshape()\u003c/code\u003e master, you will rarely need elliptical arcs, so don’t bother yourself with them.\u003c/p\u003e\n\n\n\n\u003cp\u003eUntil the next article, \u003ca href=\"https://frontendmasters.com/blog/creating-flower-shapes-using-clip-path-shape/\" rel=\"noopener\"\u003eI wrote an article for Frontend Masters\u003c/a\u003e where you can create more fancy shapes using the \u003ccode\u003earc\u003c/code\u003e command that is a good follow-up to this one.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"883\" height=\"354\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/8hogoSIf.webp?resize=883%2C354\u0026amp;ssl=1\" alt=\"Three shapes. The first looks like a flower. The second looks like a sun. The third looks like a blob.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/8hogoSIf.webp?w=883\u0026amp;ssl=1 883w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/8hogoSIf.webp?resize=300%2C120\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/05/8hogoSIf.webp?resize=768%2C308\u0026amp;ssl=1 768w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003chr/\u003e\n\n\n\u003ch4 id=\"footnotes\"\u003eFootnotes\u003c/h4\u003e\n\n\n\u003cp id=\"footnote-1\"\u003e\u003cstrong\u003e(1)\u003c/strong\u003e The \u003ccode\u003earc\u003c/code\u003e command is defined to draw elliptical arcs by taking two radii, but if we define one radius value, it means that the vertical and horizontal radius will use that same value and we have circular arcs. When it’s a length, it’s trivial, but when we use percentages, the value will resolve against the \u003ca href=\"https://drafts.csswg.org/css-shapes-2/#direction-agnostic-size\" rel=\"noopener\"\u003edirection-agnostic size\u003c/a\u003e, which is equal to the length of the diagonal of the box, divided by \u003ccode\u003esqrt(2)\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn our case, we have a square element so 50% of the direction-agnostic size will be equal to 50% of \u003ccode\u003esqrt(Width² + Height²)/sqrt(2)\u003c/code\u003e. And since both width and height are equal, we end with 50% of the width (or the height). \u003ca href=\"#note-1\" data-type=\"internal\" data-id=\"#note-1\"\u003e⮑\u003c/a\u003e\u003c/p\u003e\n\n\n\n\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-05-30T07:45:43-06:00",
  "modifiedTime": "2025-05-30T07:45:46-06:00"
}
