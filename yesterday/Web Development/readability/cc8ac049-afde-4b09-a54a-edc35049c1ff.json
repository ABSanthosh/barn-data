{
  "id": "cc8ac049-afde-4b09-a54a-edc35049c1ff",
  "title": "Crafting Strong DX With Astro Components and TypeScript",
  "link": "https://css-tricks.com/crafting-strong-dx-with-astro-components-and-typescript/",
  "description": "One thing we can do to help teams code consistently is provide type-checking so that all of the configurable options for a specific component are available while coding. Bryan demonstrates how he does this with TypeScript when working with Astro components. Crafting Strong DX With Astro Components and TypeScript originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Bryan Robinson",
  "published": "Tue, 01 Apr 2025 13:50:58 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "astro",
    "ide",
    "typescript"
  ],
  "byline": "Bryan Robinson",
  "length": 14426,
  "excerpt": "One thing we can do to help teams code consistently is provide type-checking so that all of the configurable options for a specific component are available while coding. Bryan demonstrates how he does this with TypeScript when working with Astro components.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "I’m a big fan of Astro’s focus on developer experience (DX) and the onboarding of new developers. While the basic DX is strong, I can easily make a convoluted system that is hard to onboard my own developers to. I don’t want that to happen. If I have multiple developers working on a project, I want them to know exactly what to expect from every component that they have at their disposal. This goes double for myself in the future when I’ve forgotten how to work with my own system! To do that, a developer could go read each component and get a strong grasp of it before using one, but that feels like the onboarding would be incredibly slow. A better way would be to set up the interface so that as the developer is using the component, they have the right knowledge immediately available. Beyond that, it would bake in some defaults that don’t allow developers to make costly mistakes and alerts them to what those mistakes are before pushing code! Enter, of course, TypeScript. Astro comes with TypeScript set up out of the box. You don’t have to use it, but since it’s there, let’s talk about how to use it to craft a stronger DX for our development teams. Watch I’ve also recorded a video version of this article that you can watch if that’s your jam. Check it out on YouTube for chapters and closed captioning. Setup In this demo, we’re going to use a basic Astro project. To get this started, run the following command in your terminal and choose the “Minimal” template. npm create astro@latest This will create a project with an index route and a very simple “Welcome” component. For clarity, I recommend removing the \u003cWelcome /\u003e component from the route to have a clean starting point for your project. To add a bit of design, I’d recommend setting up Tailwind for Astro (though, you’re welcome to style your component however you would like including a style block in the component). npx astro add tailwind Once this is complete, you’re ready to write your first component. Creating the basic Heading component Let’s start by defining exactly what options we want to provide in our developer experience. For this component, we want to let developers choose from any HTML heading level (H1-H6). We also want them to be able to choose a specific font size and font weight — it may seem obvious now, but we don’t want people choosing a specific heading level for the weight and font size, so we separate those concerns. Finally, we want to make sure that any additional HTML attributes can be passed through to our component. There are few things worse than having a component and then not being able to do basic functionality later. Using Dynamic tags to create the HTML element Let’s start by creating a simple component that allows the user to dynamically choose the HTML element they want to use. Create a new component at ./src/components/Heading.astro. --- // ./src/component/Heading.astro const { as } = Astro.props; const As = as; --- \u003cAs\u003e \u003cslot /\u003e \u003c/As\u003e To use a prop as a dynamic element name, we need the variable to start with a capital letter. We can define this as part of our naming convention and make the developer always capitalize this prop in their use, but that feels inconsistent with how most naming works within props. Instead, let’s keep our focus on the DX, and take that burden on for ourselves. In order to dynamically register an HTML element in our component, the variable must start with a capital letter. We can convert that in the frontmatter of our component. We then wrap all the children of our component in the \u003cAs\u003e component by using Astro’s built-in \u003cslot /\u003e component. Now, we can use this component in our index route and render any HTML element we want. Import the component at the top of the file, and then add \u003ch1\u003e and \u003ch2\u003e elements to the route. --- // ./src/pages/index.astro import Layout from '../layouts/Layout.astro'; import Heading from '../components/Heading.astro'; --- \u003cLayout\u003e \u003cHeading as=\"h1\"\u003eHello!\u003c/Heading\u003e \u003cHeading as=\"h2\"\u003eHello world\u003c/Heading\u003e \u003c/Layout\u003e This will render them correctly on the page and is a great start. Adding more custom props as a developer interface Let’s clean up the element choosing by bringing it inline to our props destructuring, and then add in additional props for weight, size, and any additional HTML attributes. To start, let’s bring the custom element selector into the destructuring of the Astro.props object. At the same time, let’s set a sensible default so that if a developer forgets to pass this prop, they still will get a heading. --- // ./src/component/Heading.astro const { as: As=\"h2\" } = Astro.props; --- \u003cAs\u003e \u003cslot /\u003e \u003c/As\u003e Next, we’ll get weight and size. Here’s our next design choice for our component system: do we make our developers know the class names they need to use or do we provide a generic set of sizes and do the mapping ourselves? Since we’re building a system, I think it’s important to move away from class names and into a more declarative setup. This will also future-proof our system by allowing us to change out the underlying styling and class system without affecting the DX. Not only do we future proof it, but we also are able to get around a limitation of Tailwind by doing this. Tailwind, as it turns out can’t handle dynamically-created class strings, so by mapping them, we solve an immediate issue as well. In this case, our sizes will go from small (sm) to six times the size (6xl) and our weights will go from “light” to “bold”. Let’s start by adjusting our frontmatter. We need to get these props off the Astro.props object and create a couple objects that we can use to map our interface to the proper class structure. --- // ./src/component/Heading.astro const weights = { \"bold\": \"font-bold\", \"semibold\": \"font-semibold\", \"medium\": \"font-medium\", \"light\": \"font-light\" } const sizes= { \"6xl\": \"text-6xl\", \"5xl\": \"text-5xl\", \"4xl\": \"text-4xl\", \"3xl\": \"text-3xl\", \"2xl\": \"text-2xl\", \"xl\": \"text-xl\", \"lg\": \"text-lg\", \"md\": \"text-md\", \"sm\": \"text-sm\" } const { as: As=\"h2\", weight=\"medium\", size=\"2xl\" } = Astro.props; --- Depending on your use case, this amount of sizes and weights might be overkill. The great thing about crafting your own component system is that you get to choose and the only limitations are the ones you set for yourself. From here, we can then set the classes on our component. While we could add them in a standard class attribute, I find using Astro’s built-in class:list directive to be the cleaner way to programmatically set classes in a component like this. The directive takes an array of classes that can be strings, arrays themselves, objects, or variables. In this case, we’ll select the correct size and weight from our map objects in the frontmatter. --- // ./src/component/Heading.astro const weights = { bold: \"font-bold\", semibold: \"font-semibold\", medium: \"font-medium\", light: \"font-light\", }; const sizes = { \"6xl\": \"text-6xl\", \"5xl\": \"text-5xl\", \"4xl\": \"text-4xl\", \"3xl\": \"text-3xl\", \"2xl\": \"text-2xl\", xl: \"text-xl\", lg: \"text-lg\", md: \"text-md\", sm: \"text-sm\", }; const { as: As = \"h2\", weight = \"medium\", size = \"2xl\" } = Astro.props; --- \u003cAs class:list={[ sizes[size], weights[weight] ]} \u003e \u003cslot /\u003e \u003c/As\u003e Your front-end should automatically shift a little in this update. Now your font weight will be slightly thicker and the classes should be applied in your developer tools. From here, add the props to your index route, and find the right configuration for your app. --- // ./src/pages/index.astro import Layout from '../layouts/Layout.astro'; import Heading from '../components/Heading.astro'; --- \u003cLayout\u003e \u003cHeading as=\"h1\" size=\"6xl\" weight=\"light\"\u003eHello!\u003c/Heading\u003e \u003cHeading as=\"h3\" size=\"xl\" weight=\"bold\"\u003eHello world\u003c/Heading\u003e \u003c/Layout\u003e Our custom props are finished, but currently, we can’t use any default HTML attributes, so let’s fix that. Adding HTML attributes to the component We don’t know what sorts of attributes our developers will want to add, so let’s make sure they can add any additional ones they need. To do that, we can spread any other prop being passed to our component, and then add them to the rendered component. --- // ./src/component/Heading.astro const weights = { // etc. }; const sizes = { // etc. }; const { as: As = \"h2\", weight = \"medium\", size = \"md\", ...attrs } = Astro.props; --- \u003cAs class:list={[ sizes[size], weights[weight] ]} {...attrs} \u003e \u003cslot /\u003e \u003c/As\u003e From here, we can add any arbitrary attributes to our element. --- // ./src/pages/index.astro import Layout from '../layouts/Layout.astro'; import Heading from '../components/Heading.astro'; --- \u003cLayout\u003e \u003cHeading id=\"my-id\" as=\"h1\" size=\"6xl\" weight=\"light\"\u003eHello!\u003c/Heading\u003e \u003cHeading class=\"text-blue-500\" as=\"h3\" size=\"xl\" weight=\"bold\"\u003eHello world\u003c/Heading\u003e \u003c/Layout\u003e I’d like to take a moment to truly appreciate one aspect of this code. Our \u003ch1\u003e, we add an id attribute. No big deal. Our \u003ch3\u003e, though, we’re adding an additional class. My original assumption when creating this was that this would conflict with the class:list set in our component. Astro takes that worry away. When the class is passed and added to the component, Astro knows to merge the class prop with the class:list directive and automatically makes it work. One less line of code! In many ways, I like to consider these additional attributes as “escape hatches” in our component library. Sure, we want our developers to use our tools exactly as intended, but sometimes, it’s important to add new attributes or push our design system’s boundaries. For this, we allow them to add their own attributes, and it can create a powerful mix. It looks done, but are we? At this point, if you’re following along, it might feel like we’re done, but we have two issues with our code right now: (1) our component has “red squiggles” in our code editor and (2) our developers can make a BIG mistake if they choose. The red squiggles come from type errors in our component. Astro gives us TypeScript and linting by default, and sizes and weights can’t be of type: any. Not a big deal, but concerning depending on your deployment settings. The other issue is that our developers don’t have to choose a heading element for their heading. I’m all for escape hatches, but only if they don’t break the accessibility and SEO of my site. Imagine, if a developer used this with a div instead of an h1 on the page. What would happen?We don’t have to imagine, make the change and see. It looks identical, but now there’s no \u003ch1\u003e element on the page. Our semantic structure is broken, and that’s bad news for many reasons. Let’s use typing to help our developers make the best decisions and know what options are available for each prop. Adding types to the component To set up our types, first we want to make sure we handle any HTML attributes that come through. Astro, again, has our backs and has the typing we need to make this work. We can import the right HTML attribute types from Astro’s typing package. Import the type and then we can extend that type for our own props. In our example, we’ll select the h1 types, since that should cover most anything we need for our headings. Inside the Props interface, we’ll also add our first custom type. We’ll specify that the as prop must be one of a set of strings, instead of just a basic string type. In this case, we want it to be h1–h6 and nothing else. --- // ./src/component/Heading.astro import type { HTMLAttributes } from 'astro/types'; interface Props extends HTMLAttributes\u003c'h1'\u003e { as: \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"h5\" | \"h6\"; } //... The rest of the file --- After adding this, you’ll note that in your index route, the \u003ch1\u003e component should now have a red underline for the as=\"div\" property. When you hover over it, it will let you know that the as type does not allow for div and it will show you a list of acceptable strings. If you delete the div, you should also now have the ability to see a list of what’s available as you try to add the string. While it’s not a big deal for the element selection, knowing what’s available is a much bigger deal to the rest of the props, since those are much more custom. Let’s extend the custom typing to show all the available options. We also denote these items as optional by using the ?:before defining the type. While we could define each of these with the same type functionality as our as type, that doesn’t keep this future proofed. If we add a new size or weight, we’d have to make sure to update our type. To solve this, we can use a fun trick in TypeScript: keyof typeof. There are two helper functions in TypeScript that will help us convert our weights and sizes object maps into string literal types: typeof: This helper takes an object and converts it to a type. For instance typeof weights would return type { bold: string, semibold: string, ...etc} keyof: This helper function takes a type and returns a list of string literals from that type’s keys. For instance keyof type { bold: string, semibold: string, ...etc} would return \"bold\" | \"semibold\" | ...etc which is exactly what we want for both weights and sizes. --- // ./src/component/Heading.astro import type { HTMLAttributes } from 'astro/types'; interface Props extends HTMLAttributes\u003c'h1'\u003e { as: \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"h5\" | \"h6\"; weight?: keyof typeof weights; size?: keyof typeof sizes; } // ... The rest of the file Now, when we want to add a size or weight, we get a dropdown list in our code editor showing exactly what’s available on the type. If something is selected, outside the list, it will show an error in the code editor helping the developer know what they missed. While none of this is necessary in the creation of Astro components, the fact that it’s built in and there’s no additional tooling to set up means that using it is very easy to opt into. I’m by no means a TypeScript expert, but getting this set up for each component takes only a few additional minutes and can save a lot of time for developers down the line (not to mention, it makes onboarding developers to your system much easier).",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/type-checking-astro.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eI’m a big fan of Astro’s focus on developer experience (DX) and the onboarding of new developers. While the basic DX is strong, I can easily make a convoluted system that is hard to onboard my own developers to. I don’t want that to happen.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf I have multiple developers working on a project, I want them to know exactly what to expect from every component that they have at their disposal. This goes double for myself in the future when I’ve forgotten how to work with my own system!\u003c/p\u003e\n\n\n\n\u003cp\u003eTo do that, a developer could go read each component and get a strong grasp of it before using one, but that feels like the onboarding would be incredibly slow. A better way would be to set up the interface so that as the developer is using the component, they have the right knowledge immediately available. Beyond that, it would bake in some defaults that don’t allow developers to make costly mistakes and alerts them to what those mistakes are before pushing code!\u003c/p\u003e\n\n\n\n\u003cp\u003eEnter, of course, TypeScript. Astro comes with TypeScript set up out of the box. You don’t have to use it, but since it’s there, let’s talk about how to use it to craft a stronger DX for our development teams.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"watch\"\u003eWatch\u003c/h3\u003e\n\n\n\u003cp\u003eI’ve also recorded a video version of this article that you can watch if that’s your jam. \u003ca href=\"https://www.youtube.com/watch?v=xS3SQG17wT0\" rel=\"noopener\"\u003eCheck it out on YouTube\u003c/a\u003e for chapters and closed captioning.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://css-tricks.com/wp-content/plugins/breeze/assets/images/placeholder.mp4\" data-breeze=\"https://css-tricks.com/wp-content/uploads/2025/03/typed-component-1.mp4\" playsinline=\"\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\u003ch3 id=\"setup\"\u003eSetup\u003c/h3\u003e\n\n\n\u003cp\u003eIn this demo, we’re going to use a basic Astro project. To get this started, run the following command in your terminal and choose the “Minimal” template.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"Terminal\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003enpm create astro@latest\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis will create a project with an index route and a very simple “Welcome” component. For clarity, I recommend removing the \u003ccode\u003e\u0026lt;Welcome /\u0026gt;\u003c/code\u003e component from the route to have a clean starting point for your project.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo add a bit of design, I’d recommend setting up Tailwind for Astro (though, you’re welcome to style your component however you would like including a style block in the component).\u003c/p\u003e\n\n\n\n\u003cpre rel=\"Terminal\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003enpx astro add tailwind\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOnce this is complete, you’re ready to write your first component.\u003c/p\u003e\n\n\n\u003ch3 id=\"creating-the-basic-heading-component\"\u003eCreating the basic Heading component\u003c/h3\u003e\n\n\n\u003cp\u003eLet’s start by defining exactly what options we want to provide in our developer experience.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor this component, we want to let developers choose from any HTML heading level (H1-H6). We also want them to be able to choose a specific font size and font weight — it may seem obvious now, but we don’t want people choosing a specific heading level for the weight and font size, so we separate those concerns.\u003c/p\u003e\n\n\n\n\u003cp\u003eFinally, we want to make sure that any additional HTML attributes can be passed through to our component. There are few things worse than having a component and then not being able to do basic functionality later.\u003c/p\u003e\n\n\n\u003ch4 id=\"using-dynamic-tags-to-create-the-html-element\"\u003eUsing Dynamic tags to create the HTML element\u003c/h4\u003e\n\n\n\u003cp\u003eLet’s start by creating a simple component that allows the user to dynamically choose the HTML element they want to use. Create a new component at \u003ccode\u003e./src/components/Heading.astro\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e---\n// ./src/component/Heading.astro\nconst { as } = Astro.props;\nconst As = as;\n---\n\n\u0026lt;As\u0026gt;\n  \u0026lt;slot /\u0026gt;\n\u0026lt;/As\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTo use a prop as a dynamic element name, we need the variable to start with a capital letter. We can define this as part of our naming convention and make the developer always capitalize this prop in their use, but that feels inconsistent with how most naming works within props. Instead, let’s keep our focus on the DX, and take that burden on for ourselves.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn order to dynamically register an HTML element in our component, the variable must start with a capital letter. We can convert that in the frontmatter of our component. We then wrap all the children of our component in the \u003ccode\u003e\u0026lt;As\u0026gt;\u003c/code\u003e component by using Astro’s built-in \u003ccode\u003e\u0026lt;slot /\u0026gt;\u003c/code\u003e component.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow, we can use this component in our index route and render any HTML element we want. Import the component at the top of the file, and then add \u003ccode\u003e\u0026lt;h1\u0026gt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;h2\u0026gt;\u003c/code\u003e elements to the route.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e---\n// ./src/pages/index.astro\nimport Layout from \u0026#39;../layouts/Layout.astro\u0026#39;;\nimport Heading from \u0026#39;../components/Heading.astro\u0026#39;;\n\n---\n\n\u0026lt;Layout\u0026gt;\n  \u0026lt;Heading as=\u0026#34;h1\u0026#34;\u0026gt;Hello!\u0026lt;/Heading\u0026gt;\n  \u0026lt;Heading as=\u0026#34;h2\u0026#34;\u0026gt;Hello world\u0026lt;/Heading\u0026gt;\n\u0026lt;/Layout\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"689\" height=\"222\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image.png?resize=689%2C222\u0026amp;ssl=1\" alt=\"Showing the h1 and h3 elements inspected in DevTools.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image.png?w=689\u0026amp;ssl=1 689w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image.png?resize=300%2C97\u0026amp;ssl=1 300w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThis will render them correctly on the page and is a great start.\u003c/p\u003e\n\n\n\u003ch4 id=\"adding-more-custom-props-as-a-developer-interface\"\u003eAdding more custom props as a developer interface\u003c/h4\u003e\n\n\n\u003cp\u003eLet’s clean up the element choosing by bringing it inline to our props destructuring, and then add in additional props for weight, size, and any additional HTML attributes.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo start, let’s bring the custom element selector into the destructuring of the \u003ccode\u003eAstro.props\u003c/code\u003e object. At the same time, let’s set a sensible default so that if a developer forgets to pass this prop, they still will get a heading.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e---\n// ./src/component/Heading.astro\nconst { as: As=\u0026#34;h2\u0026#34; } = Astro.props;\n---\n\n\u0026lt;As\u0026gt;\n  \u0026lt;slot /\u0026gt;\n\u0026lt;/As\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, we’ll get weight and size. Here’s our next design choice for our component system: do we make our developers know the class names they need to use or do we provide a generic set of sizes and do the mapping ourselves? Since we’re building a system, I think it’s important to move away from class names and into a more declarative setup. This will also future-proof our system by allowing us to change out the underlying styling and class system without affecting the DX.\u003c/p\u003e\n\n\n\n\u003cp\u003eNot only do we future proof it, but we also are able to get around a limitation of Tailwind by doing this. Tailwind, as it turns out can’t handle dynamically-created class strings, so by mapping them, we solve an immediate issue as well.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this case, our sizes will go from small (\u003ccode\u003esm\u003c/code\u003e) to six times the size (\u003ccode\u003e6xl\u003c/code\u003e) and our weights will go from “light” to “bold”.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s start by adjusting our frontmatter. We need to get these props off the \u003ccode\u003eAstro.props\u003c/code\u003e object and create a couple objects that we can use to map our interface to the proper class structure.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e---\n// ./src/component/Heading.astro\n\nconst weights = {\n    \u0026#34;bold\u0026#34;: \u0026#34;font-bold\u0026#34;,\n    \u0026#34;semibold\u0026#34;: \u0026#34;font-semibold\u0026#34;,\n    \u0026#34;medium\u0026#34;: \u0026#34;font-medium\u0026#34;,\n    \u0026#34;light\u0026#34;: \u0026#34;font-light\u0026#34;\n}\nconst sizes= {\n    \u0026#34;6xl\u0026#34;: \u0026#34;text-6xl\u0026#34;,\n    \u0026#34;5xl\u0026#34;: \u0026#34;text-5xl\u0026#34;,\n    \u0026#34;4xl\u0026#34;: \u0026#34;text-4xl\u0026#34;,\n    \u0026#34;3xl\u0026#34;: \u0026#34;text-3xl\u0026#34;,\n    \u0026#34;2xl\u0026#34;: \u0026#34;text-2xl\u0026#34;,\n    \u0026#34;xl\u0026#34;: \u0026#34;text-xl\u0026#34;,\n    \u0026#34;lg\u0026#34;: \u0026#34;text-lg\u0026#34;,\n    \u0026#34;md\u0026#34;: \u0026#34;text-md\u0026#34;,\n    \u0026#34;sm\u0026#34;: \u0026#34;text-sm\u0026#34;\n}\n\nconst { as: As=\u0026#34;h2\u0026#34;, weight=\u0026#34;medium\u0026#34;, size=\u0026#34;2xl\u0026#34; } = Astro.props;\n---\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eDepending on your use case, this amount of sizes and weights might be overkill. The great thing about crafting your own component system is that you get to choose and the only limitations are the ones you set for yourself.\u003c/p\u003e\n\n\n\n\u003cp\u003eFrom here, we can then set the classes on our component. While we could add them in a standard \u003ccode\u003eclass\u003c/code\u003e attribute, I find using Astro’s built-in \u003ccode\u003eclass:list\u003c/code\u003e directive to be the cleaner way to programmatically set classes in a component like this. The directive takes an array of classes that can be strings, arrays themselves, objects, or variables. In this case, we’ll select the correct size and weight from our map objects in the frontmatter.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e---\n// ./src/component/Heading.astro\n\nconst weights = {\n  bold: \u0026#34;font-bold\u0026#34;,\n  semibold: \u0026#34;font-semibold\u0026#34;,\n  medium: \u0026#34;font-medium\u0026#34;,\n  light: \u0026#34;font-light\u0026#34;,\n};\nconst sizes = {\n  \u0026#34;6xl\u0026#34;: \u0026#34;text-6xl\u0026#34;,\n  \u0026#34;5xl\u0026#34;: \u0026#34;text-5xl\u0026#34;,\n  \u0026#34;4xl\u0026#34;: \u0026#34;text-4xl\u0026#34;,\n  \u0026#34;3xl\u0026#34;: \u0026#34;text-3xl\u0026#34;,\n  \u0026#34;2xl\u0026#34;: \u0026#34;text-2xl\u0026#34;,\n  xl: \u0026#34;text-xl\u0026#34;,\n  lg: \u0026#34;text-lg\u0026#34;,\n  md: \u0026#34;text-md\u0026#34;,\n  sm: \u0026#34;text-sm\u0026#34;,\n};\n\nconst { as: As = \u0026#34;h2\u0026#34;, weight = \u0026#34;medium\u0026#34;, size = \u0026#34;2xl\u0026#34; } = Astro.props;\n---\n\n\u0026lt;As class:list={[\n  sizes[size], \n  weights[weight]\n]}\n\u0026gt;\n  \u0026lt;slot /\u0026gt;\n\u0026lt;/As\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eYour front-end should automatically shift a little in this update. Now your font weight will be slightly thicker and the classes should be applied in your developer tools.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"921\" height=\"226\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image2.png?resize=921%2C226\u0026amp;ssl=1\" alt=\"Showing the h1 and h3 elements inspected in DevTools with the relevant classnames applied.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image2.png?w=921\u0026amp;ssl=1 921w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image2.png?resize=300%2C74\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image2.png?resize=768%2C188\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eFrom here, add the props to your index route, and find the right configuration for your app.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e---\n// ./src/pages/index.astro\nimport Layout from \u0026#39;../layouts/Layout.astro\u0026#39;;\nimport Heading from \u0026#39;../components/Heading.astro\u0026#39;;\n---\n\n\u0026lt;Layout\u0026gt;\n  \u0026lt;Heading as=\u0026#34;h1\u0026#34; size=\u0026#34;6xl\u0026#34; weight=\u0026#34;light\u0026#34;\u0026gt;Hello!\u0026lt;/Heading\u0026gt;\n  \u0026lt;Heading as=\u0026#34;h3\u0026#34; size=\u0026#34;xl\u0026#34; weight=\u0026#34;bold\u0026#34;\u0026gt;Hello world\u0026lt;/Heading\u0026gt;\n\u0026lt;/Layout\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"881\" height=\"304\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image3.png?resize=881%2C304\u0026amp;ssl=1\" alt=\"Showing the h1 and h3 elements inspected in DevTools revealing the applied classes.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image3.png?w=881\u0026amp;ssl=1 881w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image3.png?resize=300%2C104\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image3.png?resize=768%2C265\u0026amp;ssl=1 768w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOur custom props are finished, but currently, we can’t use any default HTML attributes, so let’s fix that.\u003c/p\u003e\n\n\n\u003ch3 id=\"adding-html-attributes-to-the-component\"\u003eAdding HTML attributes to the component\u003c/h3\u003e\n\n\n\u003cp\u003eWe don’t know what sorts of attributes our developers will want to add, so let’s make sure they can add any additional ones they need.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo do that, we can spread any other prop being passed to our component, and then add them to the rendered component.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e---\n// ./src/component/Heading.astro\n\nconst weights = {\n  // etc.\n};\nconst sizes = {\n  // etc.\n};\n\nconst { as: As = \u0026#34;h2\u0026#34;, weight = \u0026#34;medium\u0026#34;, size = \u0026#34;md\u0026#34;, ...attrs } = Astro.props;\n---\n\n\u0026lt;As class:list={[\n  sizes[size], \n  weights[weight]\n]}\n{...attrs}\n\u0026gt;\n  \u0026lt;slot /\u0026gt;\n\u0026lt;/As\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFrom here, we can add any arbitrary attributes to our element.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e---\n// ./src/pages/index.astro\nimport Layout from \u0026#39;../layouts/Layout.astro\u0026#39;;\nimport Heading from \u0026#39;../components/Heading.astro\u0026#39;;\n\n---\n\n\u0026lt;Layout\u0026gt;\n  \u0026lt;Heading id=\u0026#34;my-id\u0026#34; as=\u0026#34;h1\u0026#34; size=\u0026#34;6xl\u0026#34; weight=\u0026#34;light\u0026#34;\u0026gt;Hello!\u0026lt;/Heading\u0026gt;\n  \u0026lt;Heading class=\u0026#34;text-blue-500\u0026#34; as=\u0026#34;h3\u0026#34; size=\u0026#34;xl\u0026#34; weight=\u0026#34;bold\u0026#34;\u0026gt;Hello world\u0026lt;/Heading\u0026gt;\n\u0026lt;/Layout\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eI’d like to take a moment to truly appreciate one aspect of this code. Our \u003ccode\u003e\u0026lt;h1\u0026gt;\u003c/code\u003e, we add an \u003ccode\u003eid\u003c/code\u003e attribute. No big deal. Our \u003ccode\u003e\u0026lt;h3\u0026gt;\u003c/code\u003e, though, we’re adding an additional class. My original assumption when creating this was that this would conflict with the \u003ccode\u003eclass:list\u003c/code\u003e set in our component. Astro takes that worry away. When the class is passed and added to the component, Astro knows to merge the class prop with the \u003ccode\u003eclass:list\u003c/code\u003e directive and automatically makes it work. One less line of code!\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"947\" height=\"237\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image4.png?resize=947%2C237\u0026amp;ssl=1\" alt=\"Showing the h1 and h3 elements inspected in DevTools.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image4.png?w=947\u0026amp;ssl=1 947w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image4.png?resize=300%2C75\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image4.png?resize=768%2C192\u0026amp;ssl=1 768w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn many ways, I like to consider these additional attributes as “escape hatches” in our component library. Sure, we want our developers to use our tools exactly as intended, but sometimes, it’s important to add new attributes or push our design system’s boundaries. For this, we allow them to add their own attributes, and it can create a powerful mix.\u003c/p\u003e\n\n\n\u003ch3 id=\"it-looks-done-but-are-we\"\u003eIt looks done, but are we?\u003c/h3\u003e\n\n\n\u003cp\u003eAt this point, if you’re following along, it might feel like we’re done, but we have two issues with our code right now: (1) our component has “red squiggles” in our code editor and (2) our developers can make a BIG mistake if they choose.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe red squiggles come from type errors in our component. Astro gives us TypeScript and linting by default, and sizes and weights can’t be of \u003ccode\u003etype: any\u003c/code\u003e. Not a big deal, but concerning depending on your deployment settings.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe other issue is that our developers don’t have to choose a heading element for their heading. I’m all for escape hatches, but only if they don’t break the accessibility and SEO of my site.\u003c/p\u003e\n\n\n\n\u003cp\u003eImagine, if a developer used this with a \u003ccode\u003ediv\u003c/code\u003e instead of an \u003ccode\u003eh1\u003c/code\u003e on the page. What would happen?We don’t have to imagine, make the change and see.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"950\" height=\"205\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image5.png?resize=950%2C205\u0026amp;ssl=1\" alt=\"Showing the div and h3 elements inspected in DevTools.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image5.png?w=950\u0026amp;ssl=1 950w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image5.png?resize=300%2C65\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image5.png?resize=768%2C166\u0026amp;ssl=1 768w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIt looks identical, but now there’s no \u003ccode\u003e\u0026lt;h1\u0026gt;\u003c/code\u003e element on the page. Our semantic structure is broken, and that’s bad news for many reasons. Let’s use typing to help our developers make the best decisions and know what options are available for each prop.\u003c/p\u003e\n\n\n\u003ch3 id=\"adding-types-to-the-component\"\u003eAdding types to the component\u003c/h3\u003e\n\n\n\u003cp\u003eTo set up our types, first we want to make sure we handle any HTML attributes that come through. Astro, again, has our backs and has the typing we need to make this work. We can import the right HTML attribute types from Astro’s typing package. Import the type and then we can extend that type for our own props. In our example, we’ll select the \u003ccode\u003eh1\u003c/code\u003e types, since that should cover most anything we need for our headings.\u003c/p\u003e\n\n\n\n\u003cp\u003eInside the \u003ccode\u003eProps\u003c/code\u003e interface, we’ll also add our first custom type. We’ll specify that the \u003ccode\u003eas\u003c/code\u003e prop must be one of a set of strings, instead of just a basic string type. In this case, we want it to be \u003ccode\u003eh1\u003c/code\u003e–\u003ccode\u003eh6\u003c/code\u003e and nothing else.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e---\n// ./src/component/Heading.astro\nimport type { HTMLAttributes } from \u0026#39;astro/types\u0026#39;;\n\ninterface Props extends HTMLAttributes\u0026lt;\u0026#39;h1\u0026#39;\u0026gt; {\n  as: \u0026#34;h1\u0026#34; | \u0026#34;h2\u0026#34; | \u0026#34;h3\u0026#34; | \u0026#34;h4\u0026#34; | \u0026#34;h5\u0026#34; | \u0026#34;h6\u0026#34;;\n}\n\n//... The rest of the file\n---\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAfter adding this, you’ll note that in your index route, the \u003ccode\u003e\u0026lt;h1\u0026gt;\u003c/code\u003e component should now have a red underline for the \u003ccode\u003eas=\u0026#34;div\u0026#34;\u003c/code\u003e property. When you hover over it, it will let you know that the \u003ccode\u003eas\u003c/code\u003e type does not allow for \u003ccode\u003ediv\u003c/code\u003e and it will show you a list of acceptable strings.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you delete the \u003ccode\u003ediv\u003c/code\u003e, you should also now have the ability to see a list of what’s available as you try to add the string.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"2150\" height=\"662\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image6.png?resize=2150%2C662\u0026amp;ssl=1\" alt=\"Showing a contextual menu that displays all of heading level options for the heading component while the code is being typed.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image6.png?w=2150\u0026amp;ssl=1 2150w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image6.png?resize=300%2C92\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image6.png?resize=1024%2C315\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image6.png?resize=768%2C236\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image6.png?resize=1536%2C473\u0026amp;ssl=1 1536w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image6.png?resize=2048%2C631\u0026amp;ssl=1 2048w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWhile it’s not a big deal for the element selection, knowing what’s available is a much bigger deal to the rest of the props, since those are much more custom.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s extend the custom typing to show all the available options. We also denote these items as optional by using the \u003ccode\u003e?:\u003c/code\u003ebefore defining the type.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhile we could define each of these with the same type functionality as our \u003ccode\u003eas\u003c/code\u003e type, that doesn’t keep this future proofed. If we add a new size or weight, we’d have to make sure to update our type. To solve this, we can use a fun trick in TypeScript: \u003ccode\u003ekeyof typeof\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThere are two helper functions in TypeScript that will help us convert our weights and sizes object maps into string literal types:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etypeof\u003c/code\u003e: This helper takes an object and converts it to a type. For instance \u003ccode\u003etypeof weights\u003c/code\u003e would return \u003ccode\u003etype { bold: string, semibold: string, ...etc}\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003ekeyof\u003c/code\u003e: This helper function takes a type and returns a list of string literals from that type’s keys. For instance \u003ccode\u003ekeyof type { bold: string, semibold: string, ...etc}\u003c/code\u003e would return \u003ccode\u003e\u0026#34;bold\u0026#34; | \u0026#34;semibold\u0026#34; | ...etc\u003c/code\u003e which is exactly what we want for both weights and sizes.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e---\n// ./src/component/Heading.astro\nimport type { HTMLAttributes } from \u0026#39;astro/types\u0026#39;;\n\ninterface Props extends HTMLAttributes\u0026lt;\u0026#39;h1\u0026#39;\u0026gt; {\n  as: \u0026#34;h1\u0026#34; | \u0026#34;h2\u0026#34; | \u0026#34;h3\u0026#34; | \u0026#34;h4\u0026#34; | \u0026#34;h5\u0026#34; | \u0026#34;h6\u0026#34;;\n  weight?: keyof typeof weights;\n  size?: keyof typeof sizes;\n}\n\n// ... The rest of the file\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow, when we want to add a size or weight, we get a dropdown list in our code editor showing exactly what’s available on the type. If something is selected, outside the list, it will show an error in the code editor helping the developer know what they missed.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1906\" height=\"912\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image7.png?resize=1906%2C912\u0026amp;ssl=1\" alt=\"Showing a contextual menu that displays all of the size options for the heading component while the code is being typed.\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image7.png?w=1906\u0026amp;ssl=1 1906w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image7.png?resize=300%2C144\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image7.png?resize=1024%2C490\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image7.png?resize=768%2C367\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/03/image7.png?resize=1536%2C735\u0026amp;ssl=1 1536w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eWhile none of this is necessary in the creation of Astro components, the fact that it’s built in and there’s no additional tooling to set up means that using it is very easy to opt into.\u003c/p\u003e\n\n\n\n\u003cp\u003eI’m by no means a TypeScript expert, but getting this set up for each component takes only a few additional minutes and can save a lot of time for developers down the line (not to mention, it makes onboarding developers to your system much easier).\u003c/p\u003e\n\n\n\n\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2025-04-01T07:50:58-06:00",
  "modifiedTime": "2025-04-01T07:53:05-06:00"
}
