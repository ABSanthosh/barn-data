{
  "id": "3a84de0b-2f2f-4690-ac60-a93662d4386e",
  "title": "Yet Another Anchor Positioning Quirk",
  "link": "https://css-tricks.com/yet-another-anchor-positioning-quirk/",
  "description": "As awesome as I think it is, CSS Anchor Positioning has a lot of quirks, some of which are the product of its novelty and others due to its unique way of working. Today, I want to bring you yet another Anchor Positioning quirk that has bugged me since I first saw it. Yet Another Anchor Positioning Quirk originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Juan Diego Rodríguez",
  "published": "Mon, 09 Dec 2024 16:54:00 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "anchor positioning"
  ],
  "byline": "Juan Diego Rodríguez",
  "length": 6774,
  "excerpt": "As awesome as I think it is, CSS Anchor Positioning has a lot of quirks, some of which are the product of its novelty and others due to its unique way of working. Today, I want to bring you yet another Anchor Positioning quirk that has bugged me since I first saw it.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "I strongly believe Anchor Positioning will go down as one of the greatest additions to CSS. It may not be as game-changing as Flexbox or Grid, but it does fill a positioning gap that has been missing for decades. As awesome as I think it is, CSS Anchor Positioning has a lot of quirks, some of which are the product of its novelty and others due to its unique way of working. Today, I want to bring you yet another Anchor Positioning quirk that has bugged me since I first saw it. The inception It all started a month ago when I was reading about what other people have made using Anchor Positioning, specifically this post by Temani Afif about “Anchor Positioning \u0026 Scroll-Driven Animations.” I strongly encourage you to read it and find out what caught my eye there. Combining Anchor Positioning and Scroll-Driven Animation, he makes a range slider that changes colors while it progresses. Amazing by itself, but it’s interesting that he is using two target elements with the same anchor name, each attached to its corresponding anchor, just like magic. If this doesn’t seem as interesting as it looks, we should then briefly recap how Anchor Positioning works. CSS Anchor Positioning and the anchor-scope property See our complete CSS Anchor Positioning Guide for a comprehensive deep dive. Anchor Positioning brings two new concepts to CSS, an anchor element and a target element. The anchor is the element used as a reference for positioning other elements, hence the anchor name. While the target is an absolutely-positioned element placed relative to one or more anchors. An anchor and a target can be almost every element, so you can think of them as just two div sitting next to each other: \u003cdiv class=\"anchor\"\u003eanchor\u003c/div\u003e \u003cdiv class=\"target\"\u003etarget\u003c/div\u003e To start, we first have to register the anchor element in CSS using the anchor-name property: .anchor { anchor-name: --my-anchor; } And the position-anchor property on an absolutely-positioned element attaches it to an anchor of the same name. However, to move the target around the anchor we need the position-area property. .target { position: absolute; position-anchor: --my-anchor; position-area: top right; } This works great, but things get complicated if we change our markup to include more anchors and targets: \u003cul\u003e \u003cli\u003e \u003cdiv class=\"anchor\"\u003eanchor 1\u003c/div\u003e \u003cdiv class=\"target\"\u003etarget 1\u003c/div\u003e \u003c/li\u003e \u003cli\u003e \u003cdiv class=\"anchor\"\u003eanchor 2\u003c/div\u003e \u003cdiv class=\"target\"\u003etarget 2\u003c/div\u003e \u003c/li\u003e \u003cli\u003e \u003cdiv class=\"anchor\"\u003eanchor 3\u003c/div\u003e \u003cdiv class=\"target\"\u003etarget 3\u003c/div\u003e \u003c/li\u003e \u003c/ul\u003e Instead of each target attaching to its closest anchor, they all pile up at the last registered anchor in the DOM. The anchor-scope property was introduced in Chrome 131 as an answer to this issue. It limits the scope of anchors to a subtree so that each target attaches correctly. However, I don’t want to focus on this property, because what initially caught my attention was that Temani didn’t use it. For some reason, they all attached correctly, again, like magic. What’s happening? Targets usually attach to the last anchor on the DOM instead of their closest anchor, but in our first example, we saw two anchors with the same anchor-name and their corresponding targets attached. All this without the anchor-scope property. What’s happening? Two words: Containing Block. Something to know about Anchor Positioning is that it relies a lot on how an element’s containing block is built. This isn’t something inherently from Anchor Positioning but from absolute positioning. Absolute elements are positioned relative to their containing block, and inset properties like top: 0px, left: 30px or inset: 1rem are just moving an element around its containing block boundaries, creating what’s called the inset-modified containing block. A target attached to an anchor isn’t any different, and what the position-area property does under the table is change the target’s inset-modified containing block so it is right next to the anchor. Usually, the containing block of an absolutely-positioned element is the whole viewport, but it can be changed by any ancestor with a position other than static (usually relative). Temani takes advantage of this fact and creates a new containing block for each slider, so they can only be attached to their corresponding anchors. If you snoop around the code, you can find it at the beginning: label { position: relative; /* No, It's not useless so don't remove it (or remove it and see what happens) */ } If we use this tactic on our previous examples, suddenly they are all correctly attached! Yet another quirk We didn’t need to use the anchor-scope property to attach each anchor to its respective target, but instead took advantage of how the containing block of absolute elements is computed. However, there is yet another approach, one that doesn’t need any extra bits of code. This occurred to me when I was also experimenting with Scroll-Driven Animations and Anchor Positioning and trying to attach text-bubble footnotes on the side of a post, like the following: Logically, each footnote would be a target, but the choice of an anchor is a little more tricky. I initially thought that each paragraph would work as an anchor, but that would mean having more than one anchor with the same anchor-name. The result: all the targets would pile up at the last anchor: This could be solved using our prior approach of creating a new containing block for each note. However, there is another route we can take, what I call the reductionist method. The problem comes when there is more than one anchor with the same anchor-name, so we will reduce the number of anchors to one, using an element that could work as the common anchor for all targets. In this case, we just want to position each target on the sides of the post so we can use the entire body of the post as an anchor, and since each target is naturally aligned on the vertical axis, what’s left is to move them along the horizontal axis: You can better check how it was done on the original post! Conclusion The anchor-scope may be the most recent CSS property to be shipped to a browser (so far, just in Chrome 131+), so we can’t expect its support to be something out of this world. And while I would love to use it every now and there, it will remain bound to short demos for a while. This isn’t a reason to limit the use of other Anchor Positioning properties, which are supported in Chrome 125 onwards (and let’s hope in other browsers in the near future), so I hope these little quirks can help you to keep using Anchor Positioning without any fear.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/Yet-Another-Anchor-Positioning-Quirk.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eI strongly believe Anchor Positioning will go down as one of the greatest additions to CSS. It may not be as game-changing as Flexbox or Grid, but it does fill a positioning gap that has been missing for decades. As awesome as I think it is, \u003ca href=\"https://css-tricks.com/anchor-positioning-quirks/\"\u003eCSS Anchor Positioning has a lot of quirks\u003c/a\u003e, some of which are the product of its novelty and others due to its unique way of working. Today, I want to bring you yet another Anchor Positioning quirk that has bugged me since I first saw it.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"the-inception\"\u003eThe inception\u003c/h3\u003e\n\n\n\u003cp\u003eIt all started a month ago when I was reading about what other people have made using Anchor Positioning, specifically this post by \u003ca href=\"https://css-tricks.com/author/afiftemani/\"\u003eTemani Afif\u003c/a\u003e about \u003ca href=\"https://frontendmasters.com/blog/custom-range-slider-using-anchor-positioning-scroll-driven-animations/\" rel=\"noopener\"\u003e“Anchor Positioning \u0026amp; Scroll-Driven Animations.”\u003c/a\u003e I strongly encourage you to read it and find out what caught my eye there. Combining Anchor Positioning and \u003ca href=\"https://css-tricks.com/unleash-the-power-of-scroll-driven-animations/\"\u003eScroll-Driven Animation\u003c/a\u003e, he makes a range slider that changes colors while it progresses.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eAmazing by itself, but it’s interesting that he is using two target elements with the same anchor name, each attached to its corresponding anchor, just like magic. If this doesn’t seem as interesting as it looks, we should then briefly recap how Anchor Positioning works.\u003c/p\u003e\n\n\n\u003ch3 id=\"anchor-positioning-and-the-anchor-scope-property\"\u003eCSS Anchor Positioning and the \u003ccode\u003eanchor-scope\u003c/code\u003e property\u003c/h3\u003e\n\n\n\u003cp\u003eSee our complete \u003ca href=\"https://css-tricks.com/css-anchor-positioning-guide/\"\u003eCSS Anchor Positioning Guide\u003c/a\u003e for a comprehensive deep dive.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnchor Positioning brings two new concepts to CSS, an \u003cem\u003eanchor\u003c/em\u003e element and a \u003cem\u003etarget\u003c/em\u003e element. The anchor is the element used as a reference for positioning other elements, hence the anchor name. While the target is an absolutely-positioned element placed relative to one or more anchors.\u003c/p\u003e\n\n\n\n\u003cp\u003eAn anchor and a target can be almost every element, so you can think of them as just two \u003ccode\u003ediv\u003c/code\u003e sitting next to each other:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div class=\u0026#34;anchor\u0026#34;\u0026gt;anchor\u0026lt;/div\u0026gt;\n\u0026lt;div class=\u0026#34;target\u0026#34;\u0026gt;target\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTo start, we first have to register the anchor element in CSS using the \u003ca href=\"https://css-tricks.com/almanac/properties/a/anchor-name/\"\u003e\u003ccode\u003eanchor-name\u003c/code\u003e\u003c/a\u003e property:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.anchor {\n  anchor-name: --my-anchor;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd the \u003ca href=\"https://css-tricks.com/almanac/properties/p/position-anchor/\"\u003e\u003ccode\u003eposition-anchor\u003c/code\u003e\u003c/a\u003e property on an absolutely-positioned element attaches it to an anchor of the same name. However, to move the target around the anchor we need the \u003ca href=\"https://css-tricks.com/almanac/properties/p/position-area/\"\u003e\u003ccode\u003eposition-area\u003c/code\u003e\u003c/a\u003e property.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.target {\n  position: absolute;\n  position-anchor: --my-anchor;\n  position-area: top right;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThis works great, but things get complicated if we change our markup to include more anchors and targets:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\n    \u0026lt;div class=\u0026#34;anchor\u0026#34;\u0026gt;anchor 1\u0026lt;/div\u0026gt;\n    \u0026lt;div class=\u0026#34;target\u0026#34;\u0026gt;target 1\u0026lt;/div\u0026gt;\n  \u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\n    \u0026lt;div class=\u0026#34;anchor\u0026#34;\u0026gt;anchor 2\u0026lt;/div\u0026gt;\n    \u0026lt;div class=\u0026#34;target\u0026#34;\u0026gt;target 2\u0026lt;/div\u0026gt;\n  \u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\n    \u0026lt;div class=\u0026#34;anchor\u0026#34;\u0026gt;anchor 3\u0026lt;/div\u0026gt;\n    \u0026lt;div class=\u0026#34;target\u0026#34;\u0026gt;target 3\u0026lt;/div\u0026gt;\n  \u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eInstead of each target attaching to its closest anchor, they all pile up at the last registered anchor in the DOM.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThe \u003ca href=\"https://css-tricks.com/almanac/properties/a/anchor-scope/#aa-why-we-need-anchor-scope\"\u003e\u003ccode\u003eanchor-scope\u003c/code\u003e\u003c/a\u003e property was introduced in Chrome 131 as an answer to this issue. It limits the scope of anchors to a subtree so that each target attaches correctly. However, I don’t want to focus on this property, because what initially caught my attention was that \u003cstrong\u003eTemani didn’t use it\u003c/strong\u003e. For some reason, they all attached correctly, again, like magic.\u003c/p\u003e\n\n\n\u003ch3 id=\"what-s-happening-\"\u003eWhat’s happening?\u003c/h3\u003e\n\n\n\u003cp\u003eTargets usually attach to the last anchor on the DOM instead of their closest anchor, but in our first example, we saw two anchors with the same \u003ccode\u003eanchor-name\u003c/code\u003e and their corresponding targets attached. All this without the \u003ccode\u003eanchor-scope\u003c/code\u003e property. What’s happening?\u003c/p\u003e\n\n\n\n\u003cp\u003eTwo words: \u003cstrong\u003eContaining Block\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eSomething to know about Anchor Positioning is that it relies a lot on how an element’s containing block is built. This isn’t something inherently from Anchor Positioning but from absolute positioning. Absolute elements are positioned relative to their containing block, and inset properties like \u003ccode\u003etop: 0px\u003c/code\u003e, \u003ccode\u003eleft: 30px\u003c/code\u003e or \u003ccode\u003einset: 1rem\u003c/code\u003e are just moving an element around its containing block boundaries, creating what’s called the \u003cstrong\u003e\u003ca href=\"https://www.w3.org/TR/css-position-3/#resolving-insets\" rel=\"noopener\"\u003einset-modified containing block\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"1920\" height=\"1080\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-example.png?resize=1920%2C1080\u0026amp;ssl=1\" alt=\"An element being shrunk by its inset-modified containing block\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-example.png?w=1920\u0026amp;ssl=1 1920w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-example.png?resize=300%2C169\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-example.png?resize=1024%2C576\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-example.png?resize=768%2C432\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-example.png?resize=1536%2C864\u0026amp;ssl=1 1536w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eA target attached to an anchor isn’t any different, and what the \u003ccode\u003eposition-area\u003c/code\u003e property does under the table is change the target’s inset-modified containing block so it is right next to the anchor.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" decoding=\"async\" width=\"1920\" height=\"1080\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-target.png?resize=1920%2C1080\u0026amp;ssl=1\" alt=\"A target element inset-modified containing block shrunk to be in the top left corner of an anchor\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-target.png?w=1920\u0026amp;ssl=1 1920w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-target.png?resize=300%2C169\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-target.png?resize=1024%2C576\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-target.png?resize=768%2C432\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/inset-modified-containing-block-target.png?resize=1536%2C864\u0026amp;ssl=1 1536w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eUsually, the containing block of an absolutely-positioned element is the whole viewport, but it can be changed by any ancestor with a position other than \u003ccode\u003estatic\u003c/code\u003e (usually \u003ccode\u003erelative\u003c/code\u003e). Temani takes advantage of this fact and creates a new containing block for each slider, so they can only be attached to their corresponding anchors. If you snoop around the code, you can find it at the beginning:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003elabel {\n  position: relative;\n  /* No, It\u0026#39;s not useless so don\u0026#39;t remove it (or remove it and see what happens) */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf we use this tactic on our previous examples, suddenly they are all correctly attached!\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"yet-another-quirk\"\u003eYet another quirk\u003c/h3\u003e\n\n\n\u003cp\u003eWe didn’t need to use the \u003ccode\u003e\u003ca href=\"https://css-tricks.com/almanac/properties/a/anchor-scope/\"\u003eanchor-scope\u003c/a\u003e\u003c/code\u003e property to attach each anchor to its respective target, but instead took advantage of how the containing block of absolute elements is computed. However, there is yet another approach, one that doesn’t need any extra bits of code.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis occurred to me when I was also experimenting with \u003ca href=\"https://css-tricks.com/popping-comments-with-css-anchor-positioning-and-view-driven-animations/\"\u003eScroll-Driven Animations and Anchor Positioning\u003c/a\u003e and trying to attach text-bubble footnotes on the side of a post, like the following:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" loading=\"lazy\" decoding=\"async\" width=\"1920\" height=\"1080\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/moving-anchors-in-one-direction.png?resize=1920%2C1080\u0026amp;ssl=1\" alt=\"A blog post body with paragraphs, the paragraphs have footnotes attached on the sides\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/moving-anchors-in-one-direction.png?w=1920\u0026amp;ssl=1 1920w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/moving-anchors-in-one-direction.png?resize=300%2C169\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/moving-anchors-in-one-direction.png?resize=1024%2C576\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/moving-anchors-in-one-direction.png?resize=768%2C432\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2024/12/moving-anchors-in-one-direction.png?resize=1536%2C864\u0026amp;ssl=1 1536w\" sizes=\"auto, (min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eLogically, each footnote would be a target, but the choice of an anchor is a little more tricky. I initially thought that each paragraph would work as an anchor, but that would mean having more than one anchor with the same \u003ccode\u003eanchor-name\u003c/code\u003e. The result: all the targets would pile up at the last anchor:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThis could be solved using our prior approach of creating a new containing block for each note. However, there is another route we can take, what I call the reductionist method. The problem comes when there is more than one anchor with the same \u003ccode\u003eanchor-name\u003c/code\u003e, so we will reduce the number of anchors to one, using an element that could work as the common anchor for all targets.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this case, we just want to position each target on the sides of the post so we can use the entire body of the post as an anchor, and since each target is naturally aligned on the vertical axis, what’s left is to move them along the horizontal axis:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eYou can better check how it was done on the original post!\u003c/p\u003e\n\n\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\n\n\n\u003cbaseline-status featureid=\"anchor-positioning\"\u003e\u003c/baseline-status\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eanchor-scope\u003c/code\u003e may be the most recent CSS property to be shipped to a browser (so far, just in Chrome 131+), so we can’t expect its support to be something out of this world. And while I would love to use it every now and there, it will remain bound to short demos for a while. This isn’t a reason to limit the use of other Anchor Positioning properties, which are supported in Chrome 125 onwards (and let’s hope in other browsers in the near future), so I hope these little quirks can help you to keep using Anchor Positioning without any fear.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-12-09T09:54:00-07:00",
  "modifiedTime": "2024-12-09T09:54:02-07:00"
}
