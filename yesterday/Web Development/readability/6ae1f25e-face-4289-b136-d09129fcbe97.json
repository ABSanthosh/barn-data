{
  "id": "6ae1f25e-face-4289-b136-d09129fcbe97",
  "title": "Grouping¬†Selection¬†List¬†Items Together¬†With¬†CSS¬†Grid",
  "link": "https://css-tricks.com/grouping-selection-list-items-together-with-css-grid/",
  "description": "Preethi demonstrates how to make a user interface to group selected items using CSS Grid using two different methods: the auto-fill keyword for stable layouts and the span keyword for flexible arrangements. Grouping¬†Selection¬†List¬†Items Together¬†With¬†CSS¬†Grid originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Preethi",
  "published": "Wed, 05 Mar 2025 13:16:32 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "forms",
    "layout"
  ],
  "byline": "Preethi",
  "length": 6096,
  "excerpt": "Preethi demonstrates how to make a user interface to group selected items using CSS Grid using two different methods: the auto-fill keyword for stable layouts and the span keyword for flexible arrangements.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "Grouping selected items is a design choice often employed to help users quickly grasp which items are selected and unselected. For instance, checked-off items move up the list in to-do lists, allowing users to focus on the remaining tasks when they revisit the list. We‚Äôll design a UI that follows a similar grouping pattern. Instead of simply rearranging the list of selected items, we‚Äôll also lay them out horizontally using CSS Grid. This further distinguishes between the selected and unselected items. We‚Äôll explore two approaches for this. One involves using auto-fill, which is suitable when the selected items don‚Äôt exceed the grid container‚Äôs boundaries, ensuring a stable layout. In contrast, CSS Grid‚Äôs span keyword provides another approach that offers greater flexibility. The HTML is the same for both methods: \u003cul\u003e \u003cli\u003e \u003clabel\u003e \u003cinput type=\"checkbox\" /\u003e \u003cdiv class=icon\u003eüç±\u003c/div\u003e \u003cdiv class=text\u003eBento\u003c/div\u003e \u003c/label\u003e \u003c/li\u003e \u003cli\u003e \u003clabel\u003e \u003cinput type=\"checkbox\" /\u003e \u003cdiv class=icon\u003eüç°\u003c/div\u003e \u003cdiv class=text\u003eDangos\u003c/div\u003e \u003c/label\u003e \u003c/li\u003e \u003c!-- more list items --\u003e \u003c/ul\u003e The markup consists of an unordered list (\u003cul\u003e). However, we don‚Äôt necessarily have to use \u003cul\u003e and \u003cli\u003e elements since the layout of the items will be determined by the CSS grid properties. Note that I am using an implicit \u003clabel\u003e around the \u003cinput\u003e elements mostly as a way to avoid needing an extra wrapper around things, but that explicit labels are generally better supported by assistive technologies. Method 1: Using auto-fill ul { width: 250px; display: grid; gap: 14px 10px; grid-template-columns: repeat(auto-fill, 40px); justify-content: center; /* etc. */ } The \u003cul\u003e element, which contains the items, has a display: grid style rule, turning it into a grid container. It also has gaps of 14px and 10px between its grid rows and columns. The grid content is justified (inline alignment) to center. The grid-template-columns property specifies how column tracks will be sized in the grid. Initially, all items will be in a single column. However, when items are selected, they will be moved to the first row, and each selected item will be in its own column. The key part of this declaration is the auto-fill value. The auto-fill value is added where the repeat count goes in the repeat() function. This ensures the columns repeat, with each column‚Äôs track sizing being the given size in repeat() (40px in our example), that will fit inside the grid container‚Äôs boundaries. For now, let‚Äôs make sure that the list items are positioned in a single column: li { width: inherit; grid-column: 1; /* Equivalent to: grid-column-start: 1; grid-column-end: auto; */ /* etc. */ } When an item is checked, that is when an \u003cli\u003e element :has() a :checked checkbox, we‚Äôre selecting that. And when we do, the \u003cli\u003e is given a grid-area that puts it in the first row, and its column will be auto-placed within the grid in the first row as per the value of the grid-template-columns property of the grid container (\u003cul\u003e). This causes the selected items to group at the top of the list and be arranged horizontally: li { width: inherit; grid-column: 1; /* etc. */ \u0026:has(:checked) { grid-area: 1; /* Equivalent to: grid-row-start: 1; grid-column-start: auto; grid-row-end: auto; grid-column-end: auto; */ width: 40px; /* etc. */ } /* etc. */ } And that gives us our final result! Let‚Äôs compare that with the second method I want to show you. Method 2: Using the span keyword We won‚Äôt be needing the grid-template-columns property now. Here‚Äôs the new \u003cul\u003e style ruleset: ul { width: 250px; display: grid; gap: 14px 10px; justify-content: center; justify-items: center; /* etc. */ } The inclusion of justify-items will help with the alignment of grid items as we‚Äôll see in a moment. Here are the updated styles for the \u003cli\u003e element: li { width: inherit; grid-column: 1 / span 6; /* Equivalent to: grid-column-start: 1; grid-column-end: span 6; */ /* etc. */ } As before, each item is placed in the first column, but now they also span six column tracks (since there are six items). This ensures that when multiple columns appear in the grid, as items are selected, the following unselected items remain in a single column under the selected items ‚Äî now the unselected items span across multiple column tracks. The justify-items: center declaration will keep the items aligned to the center. li { width: inherit; grid-column: 1 / span 6; /* etc. */ \u0026:has(:checked) { grid-area: 1; width: 120px; /* etc. */ } /* etc. */ } The width of the selected items has been increased from the previous example, so the layout of the selection UI can be viewed for when the selected items overflow the container. Selection order The order of selected and unselected items will remain the same as the source order. If the on-screen order needs to match the user‚Äôs selection, dynamically assign an incremental order value to the items as they are selected. onload = ()=\u003e{ let i=1; document.querySelectorAll('input').forEach((input)=\u003e{ input.addEventListener(\"click\", () =\u003e { input.parentElement.parentElement.style.order = input.checked ? i++ : (i--, 0); }); }); } Wrapping up CSS Grid helps make both approaches very flexible without a ton of configuration. By using auto-fill to place items on either axis (rows or columns), the selected items can be easily grouped within the grid container without disturbing the layout of the unselected items in the same container, for as long as the selected items don‚Äôt overflow the container. If they do overflow the container, using the span approach helps maintain the layout irrespective of how long the group of selected items gets in a given axis. Some design alternatives for the UI are grouping the selected items at the end of the list, or swapping the horizontal and vertical structure.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/selection-list.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eGrouping selected items is a design choice often employed to help users quickly grasp which items are selected and unselected. For instance, checked-off items move up the list in to-do lists, allowing users to focus on the remaining tasks when they revisit the list.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe‚Äôll design a UI that follows a similar grouping pattern. Instead of simply rearranging the list of selected items, we‚Äôll also lay them out horizontally using CSS Grid. This further distinguishes between the selected and unselected items.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe‚Äôll explore two approaches for this. One involves using \u003ccode\u003eauto-fill\u003c/code\u003e, which is suitable when the selected items don‚Äôt exceed the grid container‚Äôs boundaries, ensuring a stable layout. In contrast, CSS Grid‚Äôs \u003ccode\u003espan\u003c/code\u003e keyword provides another approach that offers greater flexibility.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe HTML is the same for both methods:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\n    \u0026lt;label\u0026gt;\n      \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt;\n      \u0026lt;div class=icon\u0026gt;üç±\u0026lt;/div\u0026gt;\n      \u0026lt;div class=text\u0026gt;Bento\u0026lt;/div\u0026gt;\n    \u0026lt;/label\u0026gt;\n  \u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\n    \u0026lt;label\u0026gt;\n      \u0026lt;input type=\u0026#34;checkbox\u0026#34; /\u0026gt;\n      \u0026lt;div class=icon\u0026gt;üç°\u0026lt;/div\u0026gt;\n      \u0026lt;div class=text\u0026gt;Dangos\u0026lt;/div\u0026gt;\n    \u0026lt;/label\u0026gt;\n  \u0026lt;/li\u0026gt;\n  \u0026lt;!-- more list items --\u0026gt;\n\u0026lt;/ul\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe markup consists of an unordered list (\u003ccode\u003e\u0026lt;ul\u0026gt;\u003c/code\u003e). However, we don‚Äôt necessarily have to use \u003ccode\u003e\u0026lt;ul\u0026gt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;li\u0026gt;\u003c/code\u003e elements since the layout of the items will be determined by the CSS grid properties. Note that I am using an implicit \u003ccode\u003e\u0026lt;label\u0026gt;\u003c/code\u003e around the \u003ccode\u003e\u0026lt;input\u0026gt;\u003c/code\u003e elements mostly as a way to avoid needing an extra wrapper around things, but that \u003ca href=\"https://www.w3.org/WAI/tutorials/forms/labels/#associating-labels-implicitly\" rel=\"noopener\"\u003eexplicit labels are generally better supported by assistive technologies\u003c/a\u003e.\u003c/p\u003e\n\n\n\u003ch3 id=\"method-1-using-auto-fill-\"\u003eMethod 1: Using \u003ccode\u003eauto-fill\u003c/code\u003e\u003c/h3\u003e\n\n\n\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eul {\n  width: 250px;\n  display: grid;\n  gap: 14px 10px;\n  grid-template-columns: repeat(auto-fill, 40px);\n  justify-content: center;\n  /* etc. */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003e\u0026lt;ul\u0026gt;\u003c/code\u003e element, which contains the items, has a \u003ccode\u003edisplay:\u003c/code\u003e \u003ccode\u003egrid\u003c/code\u003e style rule, turning it into a grid container. It also has gaps of \u003ccode\u003e14px\u003c/code\u003e and \u003ccode\u003e10px\u003c/code\u003e between its grid rows and columns. The grid content is justified (inline alignment) to \u003ccode\u003ecenter\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003egrid-template-columns\u003c/code\u003e property specifies how column tracks will be sized in the grid. Initially, all items will be in a single column. However, when items are selected, they will be moved to the first row, and each selected item will be in its own column. The key part of this declaration is the \u003ccode\u003eauto-fill\u003c/code\u003e value.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eauto-fill\u003c/code\u003e value is added where the repeat count goes in the \u003ccode\u003erepeat()\u003c/code\u003e function. This ensures the columns repeat, with each column‚Äôs track sizing being the given size in \u003ccode\u003erepeat()\u003c/code\u003e (\u003ccode\u003e40px\u003c/code\u003e in our example), that will fit inside the grid container‚Äôs boundaries.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor now, let‚Äôs make sure that the list items are positioned in a single column:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli {\n  width: inherit;\n  grid-column: 1;\n  /* Equivalent to: \n      grid-column-start: 1;\n      grid-column-end: auto; */\n  /* etc. */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen an item is checked, that is when an \u003ccode\u003e\u0026lt;li\u0026gt;\u003c/code\u003e element \u003ccode\u003e:has()\u003c/code\u003e a \u003ccode\u003e:checked\u003c/code\u003e checkbox, we‚Äôre selecting that. And when we do, the \u003ccode\u003e\u0026lt;li\u0026gt;\u003c/code\u003e is given a \u003ccode\u003egrid-area\u003c/code\u003e that puts it in the first row, and its column will be auto-placed within the grid in the first row as per the value of the \u003ccode\u003egrid-template-columns\u003c/code\u003e property of the grid container (\u003ccode\u003e\u0026lt;ul\u0026gt;\u003c/code\u003e). This causes the selected items to group at the top of the list and be arranged horizontally:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli {\n  width: inherit;\n  grid-column: 1;\n  /* etc. */\n  \u0026amp;:has(:checked) {\n    grid-area: 1;\n    /* Equivalent to: \n      grid-row-start: 1;\n      grid-column-start: auto;\n      grid-row-end: auto;\n      grid-column-end: auto; */\n    width: 40px;\n    /* etc. */\n  }\n  /* etc. */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd that gives us our final result! Let‚Äôs compare that with the second method I want to show you.\u003c/p\u003e\n\n\n\u003ch3 id=\"method-2-using-the-span-keyword\"\u003eMethod 2: Using the \u003ccode\u003espan\u003c/code\u003e keyword\u003c/h3\u003e\n\n\n\n\n\n\n\u003cp\u003eWe won‚Äôt be needing the \u003ccode\u003egrid-template-columns\u003c/code\u003e property now. Here‚Äôs the new \u003ccode\u003e\u0026lt;ul\u0026gt;\u003c/code\u003e style ruleset:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eul {\n  width: 250px;\n  display: grid;\n  gap: 14px 10px;\n  justify-content: center;\n  justify-items: center;\n  /* etc. */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe inclusion of \u003ccode\u003ejustify-items\u003c/code\u003e will help with the alignment of grid items as we‚Äôll see in a moment. Here are the updated styles for the \u003ccode\u003e\u0026lt;li\u0026gt;\u003c/code\u003e element:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli {\n  width: inherit;\n  grid-column: 1 / span 6;\n  /* Equivalent to: \n     grid-column-start: 1;\n     grid-column-end: span 6; */\n  /* etc. */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAs before, each item is placed in the first column, but now they also \u003ccode\u003espan\u003c/code\u003e six column tracks (since there are six items). This ensures that when multiple columns appear in the grid, as items are selected, the following unselected items remain in a single column under the selected items ‚Äî now the unselected items span across multiple column tracks. The \u003ccode\u003ejustify-items: center\u003c/code\u003e declaration will keep the items aligned to the center.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eli {\n  width: inherit;\n  grid-column: 1 / span 6;\n  /* etc. */\n  \u0026amp;:has(:checked) {\n    grid-area: 1;\n    width: 120px;\n    /* etc. */\n  }\n  /* etc. */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe width of the selected items has been increased from the previous example, so the layout of the selection UI can be viewed for when the selected items overflow the container.\u003c/p\u003e\n\n\n\u003ch3 id=\"selection-order\"\u003eSelection order\u003c/h3\u003e\n\n\n\u003cp\u003eThe order of selected and unselected items will remain the same as the source order. If the on-screen order needs to match the user‚Äôs selection, dynamically assign an incremental \u003ccode\u003eorder\u003c/code\u003e value to the items as they are selected.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eonload = ()=\u0026gt;{\n  let i=1;\n  document.querySelectorAll(\u0026#39;input\u0026#39;).forEach((input)=\u0026gt;{\n    input.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; {\n      input.parentElement.parentElement.style.order = input.checked ? i++ : (i--, 0);\n    });\n  });\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\u003ch3 id=\"wrapping-up\"\u003eWrapping up\u003c/h3\u003e\n\n\n\u003cp\u003eCSS Grid helps make both approaches very flexible without a ton of configuration. By using \u003ccode\u003eauto-fill\u003c/code\u003e to place items on either axis (rows or columns), the selected items can be easily grouped within the grid container without disturbing the layout of the unselected items in the same container, for as long as the selected items don‚Äôt overflow the container.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf they do overflow the container, using the \u003ccode\u003espan\u003c/code\u003e approach helps maintain the layout irrespective of how long the group of selected items gets in a given axis. Some design alternatives for the UI are grouping the selected items at the end of the list, or swapping the horizontal and vertical structure.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-03-05T06:16:32-07:00",
  "modifiedTime": "2025-03-05T06:16:34-07:00"
}
