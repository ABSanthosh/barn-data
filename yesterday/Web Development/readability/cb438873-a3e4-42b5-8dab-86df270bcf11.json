{
  "id": "cb438873-a3e4-42b5-8dab-86df270bcf11",
  "title": "Chrome 133 Goodies",
  "link": "https://css-tricks.com/chrome-133-goodies/",
  "description": "Did you see the release notes for Chrome 133? It's currently in beta, but the Chrome team has been publishing a slew of new articles with pretty incredible demos that are tough to ignore. I figured I'd round those up in one place. Chrome 133 Goodies originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Geoff Graham",
  "published": "Fri, 31 Jan 2025 15:27:50 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "attributes",
    "container-queries"
  ],
  "byline": "Geoff Graham",
  "length": 5452,
  "excerpt": "Did you see the release notes for Chrome 133? It's currently in beta, but the Chrome team has been publishing a slew of new articles with pretty incredible demos that are tough to ignore. I figured I'd round those up in one place.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "I often wonder what it’s like working for the Chrome team. You must get issued some sort of government-level security clearance for the latest browser builds that grants you permission to bash on them ahead of everyone else and come up with these rad demos showing off the latest features. No, I’m, not jealous, why are you asking? Totally unrelated, did you see the release notes for Chrome 133? It’s currently in beta, but the Chrome team has been publishing a slew of new articles with pretty incredible demos that are tough to ignore. I figured I’d round those up in one place. attr() for the masses! We’ve been able to use HTML attributes in CSS for some time now, but it’s been relegated to the content property and only parsed strings. \u003ch1 data-color=\"orange\"\u003eSome text\u003c/h1\u003e h1::before { content: ' (Color: ' attr(data-color) ') '; } Bramus demonstrates how we can now use it on any CSS property, including custom properties, in Chrome 133. So, for example, we can take the attribute’s value and put it to use on the element’s color property: h1 { color: attr(data-color type(\u003ccolor\u003e), #fff) } This is a trite example, of course. But it helps illustrate that there are three moving pieces here: the attribute (data-color) the type (type(\u003ccolor\u003e)) the fallback value (#fff) We make up the attribute. It’s nice to have a wildcard we can insert into the markup and hook into for styling. The type() is a new deal that helps CSS know what sort of value it’s working with. If we had been working with a numeric value instead, we could ditch that in favor of something less verbose. For example, let’s say we’re using an attribute for the element’s font size: \u003cdiv data-size=\"20\"\u003eSome text\u003c/div\u003e Now we can hook into the data-size attribute and use the assigned value to set the element’s font-size property, based in px units: h1 { color: attr(data-size px, 16); } The fallback value is optional and might not be necessary depending on your use case. This is a mind-blowing one. If you’ve ever wanted a way to style a sticky element when it’s in a “stuck” state, then you already know how cool it is to have something like this. Adam Argyle takes the classic pattern of an alphabetical list and applies styles to the letter heading when it sticks to the top of the viewport. The same is true of elements with scroll snapping and elements that are scrolling containers. In other words, we can style elements when they are “stuck”, when they are “snapped”, and when they are “scrollable”. Quick little example that you’ll want to open in a Chromium browser: The general idea (and that’s all I know for now) is that we register a container… you know, a container that we can query. We give that container a container-type that is set to the type of scrolling we’re working with. In this case, we’re working with sticky positioning where the element “sticks” to the top of the page. .sticky-nav { container-type: scroll-state; } A container can’t query itself, so that basically has to be a wrapper around the element we want to stick. Menus are a little funny because we have the \u003cnav\u003e element and usually stuff it with an unordered list of links. So, our \u003cnav\u003e can be the container we query since we’re effectively sticking an unordered list to the top of the page. \u003cnav class=\"sticky-nav\"\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"#\"\u003eHome\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003eAbout\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#\"\u003eBlog\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e We can put the sticky logic directly on the \u003cnav\u003e since it’s technically holding what gets stuck: .sticky-nav { container-type: scroll-state; /* set a scroll container query */ position: sticky; /* set sticky positioning */ top: 0; /* stick to the top of the page */ } I supposed we could use the container shorthand if we were working with multiple containers and needed to distinguish one from another with a container-name. Either way, now that we’ve defined a container, we can query it using @container! In this case, we declare the type of container we’re querying: @container scroll-state() { } And we tell it the state we’re looking for: @container scroll-state(stuck: top) { If we were working with a sticky footer instead of a menu, then we could say stuck: bottom instead. But the kicker is that once the \u003cnav\u003e element sticks to the top, we get to apply styles to it in the @container block, like so: .sticky-nav { border-radius: 12px; container-type: scroll-state; position: sticky; top: 0; /* When the nav is in a \"stuck\" state */ @container scroll-state(stuck: top) { border-radius: 0; box-shadow: 0 3px 10px hsl(0 0 0 / .25); width: 100%; } } It seems to work when nesting other selectors in there. So, for example, we can change the links in the menu when the navigation is in its stuck state: .sticky-nav { /* Same as before */ a { color: #000; font-size: 1rem; } /* When the nav is in a \"stuck\" state */ @container scroll-state(stuck: top) { /* Same as before */ a { color: orangered; font-size: 1.5rem; } } } So, yeah. As I was saying, it must be pretty cool to be on the Chrome developer team and get ahead of stuff like this, as it’s released. Big ol’ thanks to Bramus and Adam for consistently cluing us in on what’s new and doing the great work it takes to come up with such amazing demos to show things off.",
  "image": "https://css-tricks.com/wp-json/social-image-generator/v1/image/383910",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eI often wonder what it’s like working for the Chrome team. You must get issued some sort of government-level security clearance for the latest browser builds that grants you permission to bash on them ahead of everyone else and come up with these rad demos showing off the latest features. No, I’m, not jealous, why are you asking?\u003c/p\u003e\n\n\n\n\u003cp\u003eTotally unrelated, did you see the \u003ca href=\"https://developer.chrome.com/blog/chrome-133-beta\" rel=\"noopener\"\u003erelease notes for Chrome 133\u003c/a\u003e? It’s currently in beta, but the Chrome team has been publishing a slew of new articles with pretty incredible demos that are tough to ignore. I figured I’d round those up in one place.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"attr-for-the-masses\"\u003e\u003ccode\u003eattr()\u003c/code\u003e for the masses!\u003c/h3\u003e\n\n\n\u003cp\u003eWe’ve been able to use HTML attributes in CSS for some time now, but it’s been relegated to the \u003ccode\u003econtent\u003c/code\u003e property and only parsed strings.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;h1 data-color=\u0026#34;orange\u0026#34;\u0026gt;Some text\u0026lt;/h1\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eh1::before {\n  content: \u0026#39; (Color: \u0026#39; attr(data-color) \u0026#39;) \u0026#39;;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBramus demonstrates how we can now use it on any CSS property, including custom properties, in Chrome 133. So, for example, we can take the attribute’s value and put it to use on the element’s \u003ccode\u003ecolor\u003c/code\u003e property:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eh1 {\n  color: attr(data-color type(\u0026lt;color\u0026gt;), #fff)\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is a trite example, of course. But it helps illustrate that there are three moving pieces here:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003ethe attribute (\u003ccode\u003edata-color\u003c/code\u003e)\u003c/li\u003e\n\n\n\n\u003cli\u003ethe type (\u003ccode\u003etype(\u0026lt;color\u0026gt;)\u003c/code\u003e)\u003c/li\u003e\n\n\n\n\u003cli\u003ethe fallback value (\u003ccode\u003e#fff\u003c/code\u003e)\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eWe make up the attribute. It’s nice to have a wildcard we can insert into the markup and hook into for styling. The \u003ccode\u003etype()\u003c/code\u003e is a new deal that helps CSS know what sort of value it’s working with. If we had been working with a numeric value instead, we could ditch that in favor of something less verbose. For example, let’s say we’re using an attribute for the element’s font size:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;div data-size=\u0026#34;20\u0026#34;\u0026gt;Some text\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow we can hook into the \u003ccode\u003edata-size\u003c/code\u003e attribute and use the assigned value to set the element’s \u003ccode\u003efont-size\u003c/code\u003e property, based in \u003ccode\u003epx\u003c/code\u003e units:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eh1 {\n  color: attr(data-size px, 16);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThe fallback value is optional and might not be necessary depending on your use case.\u003c/p\u003e\n\n\n\n\n\n\u003cp\u003eThis is a mind-blowing one. If you’ve ever wanted a way to style a sticky element when it’s in a “stuck” state, then you already know how cool it is to have something like this. Adam Argyle takes the classic pattern of an alphabetical list and applies styles to the letter heading when it sticks to the top of the viewport. The same is true of elements with scroll snapping and elements that are scrolling containers.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn other words, we can style elements when they are “stuck”, when they are “snapped”, and when they are “scrollable”.\u003c/p\u003e\n\n\n\n\u003cp\u003eQuick little example that you’ll want to open in a Chromium browser:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThe general idea (and that’s all I know for now) is that we register a container… you know, \u003ca href=\"https://css-tricks.com/css-container-queries/\"\u003ea container that we can query\u003c/a\u003e. We give that container a \u003ccode\u003econtainer-type\u003c/code\u003e that is set to the type of scrolling we’re working with. In this case, we’re working with sticky positioning where the element “sticks” to the top of the page.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.sticky-nav {\n  container-type: scroll-state;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eA container can’t query itself, so that basically has to be a wrapper around the element we want to stick. Menus are a little funny because we have the \u003ccode\u003e\u0026lt;nav\u0026gt;\u003c/code\u003e element and usually stuff it with an unordered list of links. So, our \u003ccode\u003e\u0026lt;nav\u0026gt;\u003c/code\u003e can be the container we query since we’re effectively sticking an unordered list to the top of the page.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;nav class=\u0026#34;sticky-nav\u0026#34;\u0026gt;\n  \u0026lt;ul\u0026gt;\n    \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n    \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n    \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Blog\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n\u0026lt;/nav\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe can put the sticky logic directly on the \u003ccode\u003e\u0026lt;nav\u0026gt;\u003c/code\u003e since it’s technically holding what gets stuck:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.sticky-nav {\n  container-type: scroll-state; /* set a scroll container query */\n  position: sticky; /* set sticky positioning */\n  top: 0; /* stick to the top of the page */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eI supposed we could use the \u003ccode\u003econtainer\u003c/code\u003e shorthand if we were working with multiple containers and needed to distinguish one from another with a \u003ccode\u003econtainer-name\u003c/code\u003e. Either way, now that we’ve defined a container, we can query it using \u003ccode\u003e@container\u003c/code\u003e! In this case, we declare the type of container we’re querying:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@container scroll-state() { }\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd we tell it the state we’re looking for:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@container scroll-state(stuck: top) {\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf we were working with a sticky footer instead of a menu, then we could say \u003ccode\u003estuck: bottom\u003c/code\u003e instead. But the kicker is that once the \u003ccode\u003e\u0026lt;nav\u0026gt;\u003c/code\u003e element sticks to the top, we get to apply styles to it in the \u003ccode\u003e@container\u003c/code\u003e block, like so:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.sticky-nav {\n  border-radius: 12px;\n  container-type: scroll-state;\n  position: sticky;\n  top: 0;\n\n  /* When the nav is in a \u0026#34;stuck\u0026#34; state */\n  @container scroll-state(stuck: top) {\n    border-radius: 0;\n    box-shadow: 0 3px 10px hsl(0 0 0 / .25);\n    width: 100%;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIt seems to work when nesting other selectors in there. So, for example, we can change the links in the menu when the navigation is in its stuck state:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.sticky-nav {\n  /* Same as before */\n\n  a {\n    color: #000;\n    font-size: 1rem;\n  }\n\n  /* When the nav is in a \u0026#34;stuck\u0026#34; state */\n  @container scroll-state(stuck: top) {\n    /* Same as before */\n\n    a {\n      color: orangered;\n      font-size: 1.5rem;\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eSo, yeah. As I was saying, it must be pretty cool to be on the Chrome developer team and get ahead of stuff like this, as it’s released. Big ol’ thanks to Bramus and Adam for consistently cluing us in on what’s new and doing the great work it takes to come up with such amazing demos to show things off.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-01-31T08:27:50-07:00",
  "modifiedTime": "2025-01-31T09:14:57-07:00"
}
