{
  "id": "1b2bde7d-23dc-4531-9eae-69dae069becc",
  "title": "A Better API for the Resize Observer",
  "link": "https://css-tricks.com/a-better-api-for-the-resize-observer/",
  "description": "ResizeObserver, MutationObserver, and IntersectionObserver enhance performance over their predecessors. Zell discusses their API similarities, usage steps, refactoring strategies, and advantages with practical examples. A Better API for the Resize Observer originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Zell Liew",
  "published": "Mon, 16 Jun 2025 12:47:51 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "JavaScript"
  ],
  "byline": "Zell Liew",
  "length": 9984,
  "excerpt": "ResizeObserver, MutationObserver, and IntersectionObserver enhance performance over their predecessors. Zell discusses their API similarities, usage steps, refactoring strategies, and advantages with practical examples.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "Resize Observer, Mutation Observer, and Intersection Observers are all good APIs that are more performant than their older counterparts: ResizeObserver is better than the resize event MutationObserver replaces the now deprecated Mutation Events IntersectionObserver lets you do certain scroll interactions with less performance overhead. The API for these three observers are quite similar (but they have their differences which we will go into later). To use an observer, you have to follow the steps below: Create a new observer with the new keyword: This observer takes in an observer function to execute. Do something with the observed changes: This is done via the observer function that is passed into the observer. Observe a specific element: By using the observe method. (Optionally) unobserve the element: By using the unobserve or disconnect method. (depending on which observer you’re using). In practice, the above steps looks like this with the ResizeObserver. // Step 1: Create a new observer const observer = new ResizeObserver(observerFn) // Step 2: Do something with the observed changes function observerFn (entries) { for (let entry of entries) { // Do something with entry } } // Step 3: Observe an element const element = document.querySelector('#some-element') observer.observe(element); // Step 4 (optional): Disconnect the observer observer.disconnect(element) This looks clear (and understandable) after the steps have been made clear. But it can look like a mess without the comments: const observer = new ResizeObserver(observerFn) function observerFn (entries) { for (let entry of entries) { // Do something with entry } } const element = document.querySelector('#some-element') observer.observe(element); The good news is: I think we can improve the observer APIs and make them easier to use. The Resize Observer Let’s start with the ResizeObserver since it’s the simplest of them all. We’ll begin by writing a function that encapsulates the resizeObserver that we create. function resizeObserver () { // ... Do something } The easiest way to begin refactoring the ResizeObserver code is to put everything we’ve created into our resizeObserver first. function resizeObserver () { const observer = new ResizeObserver(observerFn) function observerFn (entries) { for (let entry of entries) { // Do something with entry } } const node = document.querySelector('#some-element') observer.observe(node); } Next, we can pass the element into the function to make it simpler. When we do this, we can eliminate the document.querySelector line. function resizeObserver (element) { const observer = new ResizeObserver(observerFn) function observerFn (entries) { for (let entry of entries) { // Do something with entry } } observer.observe(node); } This makes the function more versatile since we can now pass any element into it. // Usage of the resizeObserver function const node = document.querySelector('#some-element') const obs = resizeObserver(node) This is already much easier than writing all of the ResizeObserver code from scratch whenever you wish to use it. Next, it’s quite obvious that we have to pass in an observer function to the callback. So, we can potentially do this: // Not great function resizeObserver (node, observerFn) { const observer = new ResizeObserver(observerFn) observer.observe(node); } Since observerFn is always the same — it loops through the entries and acts on every entry — we could keep the observerFn and pass in a callback to perform tasks when the element is resized. // Better function resizeObserver (node, callback) { const observer = new ResizeObserver(observerFn) function observerFn (entries) { for (let entry of entries) { callback(entry) } } observer.observe(node); } To use this, we can pass callback into the resizeObserver — this makes resizeObserver operate somewhat like an event listener which we are already familiar with. // Usage of the resizeObserver function const node = document.querySelector('#some-element') const obs = resizeObserver(node, entry =\u003e { // Do something with each entry }) We can make the callback slightly better by providing both entry and entries. There’s no performance hit for passing an additional variable so there’s no harm providing more flexibility here. function resizeObserver (element, callback) { const observer = new ResizeObserver(observerFn) function observerFn (entries) { for (let entry of entries) { callback({ entry, entries }) } } observer.observe(element); } Then we can grab entries in the callback if we need to. // Usage of the resizeObserver function // ... const obs = resizeObserver(node, ({ entry, entries }) =\u003e { // ... }) Next, it makes sense to pass the callback as an option parameter instead of a variable. This will make resizeObserver more consistent with the mutationObserver and intersectionObserver functions that we will create in the next article. function resizeObserver (element, options = {}) { const { callback } = options const observer = new ResizeObserver(observerFn) function observerFn (entries) { for (let entry of entries) { callback({ entry, entries }) } } observer.observe(element); } Then we can use resizeObserver like this. const obs = resizeObserver(node, { callback ({ entry, entries }) { // Do something ... } }) The observer can take in an option too ResizeObserver‘s observe method can take in an options object that contains one property, box. This determines whether the observer will observe changes to content-box, border-box or device-pixel-content-box. So, we need to extract these options from the options object and pass them to observe. function resizeObserver (element, options = {}) { const { callback, ...opts } = options // ... observer.observe(element, opts); } Optional: Event listener pattern I prefer using callback because it’s quite straightforward. But if you want to use a standard event listener pattern, we can do that, too. The trick here is to emit an event. We’ll call it resize-obs since resize is already taken. function resizeObserver (element, options = {}) { // ... function observerFn (entries) { for (let entry of entries) { if (callback) callback({ entry, entries }) else { node.dispatchEvent( new CustomEvent('resize-obs', { detail: { entry, entries }, }), ) } } } // ... } Then we can listen to the resize-obs event, like this: const obs = resizeObserver(node) node.addEventListener('resize-obs', event =\u003e { const { entry, entries } = event.detail }) Again, this is optional. Unobserving the element One final step is to allow the user to stop observing the element(s) when observation is no longer required. To do this, we can return two of the observer methods: unobserve: Stops observing one Element disconnect: Stops observing all Elements function resizeObserver (node, options = {}) { // ... return { unobserve(node) { observer.unobserve(node) }, disconnect() { observer.disconnet() } } } Both methods do the same thing for what we have built so far since we only allowed resizeObserver to observe one element. So, pick whatever method you prefer to stop observing the element. const obs = resizeObserver(node, { callback ({ entry, entries }) { // Do something ... } }) // Stops observing all elements obs.disconect() With this, we’ve completed the creation of a better API for the ResizeObserver — the resizeObserver function. Code snippet Here’s the code we’ve wrote for resizeObserver export function resizeObserver(node, options = {}) { const observer = new ResizeObserver(observerFn) const { callback, ...opts } = options function observerFn(entries) { for (const entry of entries) { // Callback pattern if (callback) callback({ entry, entries, observer }) // Event listener pattern else { node.dispatchEvent( new CustomEvent('resize-obs', { detail: { entry, entries, observer }, }) ) } } } observer.observe(node) return { unobserve(node) { observer.unobserve(node) }, disconnect() { observer.disconnect() } } } Using this in practice via Splendid Labz Splendid Labz has a utils library that contains an enhanced version of the resizeObserver we made above. You can use it if you wanna use a enhanced observer, or if you don’t want to copy-paste the observer code into your projects. import { resizeObserver } from '@splendidlabz/utils/dom' const node = document.querySelector('.some-element') const obs = resizeObserver(node, { callback ({ entry, entries }) { /* Do what you want here */ } }) Bonus: The Splendid Labz resizeObserver is capable of observing multiple elements at once. It can also unobserve multiple elements at once. const items = document.querySelectorAll('.elements') const obs = resizeObserver(items, { callback ({ entry, entries }) { /* Do what you want here */ } }) // Unobserves two items at once const subset = [items[0], items[1]] obs.unobserve(subset) Found this refactoring helpful? Refactoring is ultra useful (and important) because its a process that lets us create code that’s easy to use or maintain. If you found this refactoring exercise useful, you might just love how I teach JavaScript to budding developers in my Learn JavaScript course. In this course, you’ll learn to build 20 real-world components. For each component, we start off simple. Then we add features and you’ll learn to refactor along the way. That’s it! Hope you enjoyed this piece and see you in the next one.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/04/code-resize-observer.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eResize Observer, Mutation Observer, and Intersection Observers are all good APIs that are more performant than their older counterparts:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eResizeObserver\u003c/code\u003e is \u003ca href=\"https://web.dev/articles/resize-observer\" rel=\"noopener\"\u003ebetter\u003c/a\u003e than the \u003ccode\u003eresize\u003c/code\u003e event\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eMutationObserver\u003c/code\u003e replaces the now deprecated \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/MutationEvent\" rel=\"noopener\"\u003eMutation Events\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eIntersectionObserver\u003c/code\u003e lets you do certain \u003ccode\u003escroll\u003c/code\u003e interactions with \u003ca href=\"https://www.smashingmagazine.com/2021/07/dynamic-header-intersection-observer/\" rel=\"noopener\"\u003eless performance overhead\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe API for these three observers are quite similar (but they have their differences which we will go into later). To use an observer, you have to follow the steps below:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eCreate a new observer with the \u003ccode\u003enew\u003c/code\u003e keyword:\u003c/strong\u003e This observer takes in an observer function to execute.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eDo something with the observed changes\u003c/strong\u003e: This is done via the observer function that is passed into the observer.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eObserve a specific element\u003c/strong\u003e: By using the \u003ccode\u003eobserve\u003c/code\u003e method.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003e(Optionally) unobserve the element\u003c/strong\u003e: By using the \u003ccode\u003eunobserve\u003c/code\u003e or \u003ccode\u003edisconnect\u003c/code\u003e method. (depending on which observer you’re using).\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eIn practice, the above steps looks like this with the \u003ccode\u003eResizeObserver\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// Step 1: Create a new observer\nconst observer = new ResizeObserver(observerFn)\n\n// Step 2: Do something with the observed changes\nfunction observerFn (entries) {\n  for (let entry of entries) {\n    // Do something with entry\n  }\n}\n\n// Step 3: Observe an element\nconst element = document.querySelector(\u0026#39;#some-element\u0026#39;)\nobserver.observe(element);\n\n// Step 4 (optional): Disconnect the observer\nobserver.disconnect(element)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis looks clear (and understandable) after the steps have been made clear. But it can look like a mess without the comments:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst observer = new ResizeObserver(observerFn)\n\nfunction observerFn (entries) {\n  for (let entry of entries) {\n    // Do something with entry\n  }\n}\n\nconst element = document.querySelector(\u0026#39;#some-element\u0026#39;)\nobserver.observe(element);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe good news is: I think we can improve the observer APIs and make them easier to use.\u003c/p\u003e\n\n\n\u003ch3 id=\"the-resize-observer\"\u003eThe Resize Observer\u003c/h3\u003e\n\n\n\u003cp\u003eLet’s start with the \u003ccode\u003e\u003ca href=\"https://splendidlabz.com/docs/utils/dom/resize-observer\" rel=\"noopener\"\u003eResizeObserver\u003c/a\u003e\u003c/code\u003e since it’s the simplest of them all. We’ll begin by writing a function that encapsulates the \u003ccode\u003eresizeObserver\u003c/code\u003e that we create.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003efunction resizeObserver () {\n  // ... Do something\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe easiest way to begin refactoring the \u003ccode\u003eResizeObserver\u003c/code\u003e code is to put everything we’ve created into our \u003ccode\u003eresizeObserver\u003c/code\u003e first.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003efunction resizeObserver () {\n  const observer = new ResizeObserver(observerFn)\n\n  function observerFn (entries) {\n    for (let entry of entries) {\n      // Do something with entry\n    }\n  }\n\n  const node = document.querySelector(\u0026#39;#some-element\u0026#39;)\n  observer.observe(node);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, we can pass the \u003ccode\u003eelement\u003c/code\u003e into the function to make it simpler. When we do this, we can eliminate the \u003ccode\u003edocument.querySelector\u003c/code\u003e line.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003efunction resizeObserver (element) {\n  const observer = new ResizeObserver(observerFn)\n\n  function observerFn (entries) {\n    for (let entry of entries) {\n      // Do something with entry\n    }\n  }\n\n  observer.observe(node);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis makes the function more versatile since we can now pass any element into it.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// Usage of the resizeObserver function\nconst node = document.querySelector(\u0026#39;#some-element\u0026#39;)\nconst obs = resizeObserver(node)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is already much easier than writing all of the \u003ccode\u003eResizeObserver\u003c/code\u003e code from scratch whenever you wish to use it.\u003c/p\u003e\n\n\n\n\u003cp\u003eNext, it’s quite obvious that we have to pass in an observer function to the callback. So, we can potentially do this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// Not great\nfunction resizeObserver (node, observerFn) {\n  const observer = new ResizeObserver(observerFn)\n  observer.observe(node);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSince \u003ccode\u003eobserverFn\u003c/code\u003e is always the same — it loops through the \u003ccode\u003eentries\u003c/code\u003e and acts on every \u003ccode\u003eentry\u003c/code\u003e — we could keep the \u003ccode\u003eobserverFn\u003c/code\u003e and pass in a \u003ccode\u003ecallback\u003c/code\u003e to perform tasks when the element is resized.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// Better \nfunction resizeObserver (node, callback) {\n  const observer = new ResizeObserver(observerFn)\n\n  function observerFn (entries) {\n    for (let entry of entries) {\n      callback(entry)\n    }\n  }\n\n  observer.observe(node);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTo use this, we can pass \u003ccode\u003ecallback\u003c/code\u003e into the \u003ccode\u003eresizeObserver\u003c/code\u003e — this makes \u003ccode\u003eresizeObserver\u003c/code\u003e operate somewhat like an event listener which we are already familiar with.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// Usage of the resizeObserver function\nconst node = document.querySelector(\u0026#39;#some-element\u0026#39;)\nconst obs = resizeObserver(node, entry =\u0026gt; {\n  // Do something with each entry\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe can make the callback slightly better by providing both \u003ccode\u003eentry\u003c/code\u003e and \u003ccode\u003eentries\u003c/code\u003e. There’s no performance hit for passing an additional variable so there’s no harm providing more flexibility here.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"6\"\u003e\u003ccode markup=\"tt\"\u003efunction resizeObserver (element, callback) {\n  const observer = new ResizeObserver(observerFn)\n\n  function observerFn (entries) {\n    for (let entry of entries) {\n      callback({ entry, entries })\n    }\n  }\n\n  observer.observe(element);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThen we can grab \u003ccode\u003eentries\u003c/code\u003e in the \u003ccode\u003ecallback\u003c/code\u003e if we need to.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e// Usage of the resizeObserver function\n// ...\nconst obs = resizeObserver(node, ({ entry, entries }) =\u0026gt; {\n  // ...\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, it makes sense to pass the callback as an option parameter instead of a variable. This will make \u003ccode\u003eresizeObserver\u003c/code\u003e more consistent with the \u003ccode\u003e\u003ca href=\"https://splendidlabz.com/docs/utils/dom/mutation-observer\" rel=\"noopener\"\u003emutationObserver\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca href=\"https://splendidlabz.com/docs/utils/dom/intersection-observer\" rel=\"noopener\"\u003eintersectionObserver\u003c/a\u003e\u003c/code\u003e functions that we will create in the next article.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"1,2\"\u003e\u003ccode markup=\"tt\"\u003efunction resizeObserver (element, options = {}) {\n  const { callback } = options\n  const observer = new ResizeObserver(observerFn)\n\n  function observerFn (entries) {\n    for (let entry of entries) {\n        callback({ entry, entries })\n      }\n  }\n\n  observer.observe(element);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThen we can use \u003ccode\u003eresizeObserver\u003c/code\u003e like this.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst obs = resizeObserver(node, {\n  callback ({ entry, entries }) {\n    // Do something ...\n  }\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"the-observer-can-take-in-an-option-too\"\u003eThe observer can take in an option too\u003c/h3\u003e\n\n\n\u003cp\u003e\u003ccode\u003eResizeObserver\u003c/code\u003e‘s \u003ccode\u003eobserve\u003c/code\u003e method can take in an \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/observe#options\" rel=\"noopener\"\u003eoptions\u003c/a\u003e object that contains one property, \u003ccode\u003ebox\u003c/code\u003e. This determines whether the observer will observe changes to \u003ccode\u003econtent-box\u003c/code\u003e, \u003ccode\u003eborder-box\u003c/code\u003e or \u003ccode\u003edevice-pixel-content-box\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eSo, we need to extract these options from the \u003ccode\u003eoptions\u003c/code\u003e object and pass them to \u003ccode\u003eobserve\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003efunction resizeObserver (element, options = {}) {\n  const { callback, ...opts } = options\n  // ...\n  observer.observe(element, opts);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"optional-event-listener-pattern\"\u003eOptional: Event listener pattern\u003c/h3\u003e\n\n\n\u003cp\u003eI prefer using \u003ccode\u003ecallback\u003c/code\u003e because it’s quite straightforward. But if you want to use a standard event listener pattern, we can do that, too. The trick here is to emit an event. We’ll call it \u003ccode\u003eresize-obs\u003c/code\u003e since \u003ccode\u003eresize\u003c/code\u003e is already taken.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003efunction resizeObserver (element, options = {}) {\n  // ...\n  function observerFn (entries) {\n    for (let entry of entries) {\n      if (callback) callback({ entry, entries })\n      else {\n        node.dispatchEvent(\n          new CustomEvent(\u0026#39;resize-obs\u0026#39;, {\n            detail: { entry, entries },\n          }),\n        )\n      }\n    }\n  }\n\n  // ...\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThen we can listen to the \u003ccode\u003eresize-obs\u003c/code\u003e event, like this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst obs = resizeObserver(node)\nnode.addEventListener(\u0026#39;resize-obs\u0026#39;, event =\u0026gt; {\n  const { entry, entries } = event.detail\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAgain, this is optional.\u003c/p\u003e\n\n\n\u003ch3 id=\"unobserving-the-element\"\u003eUnobserving the element\u003c/h3\u003e\n\n\n\u003cp\u003eOne final step is to allow the user to stop observing the element(s) when observation is no longer required. To do this, we can return two of the \u003ccode\u003eobserver\u003c/code\u003e methods:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eunobserve\u003c/code\u003e: Stops observing one \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element\" rel=\"noopener\"\u003e\u003ccode\u003eElement\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003edisconnect\u003c/code\u003e: Stops observing all \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element\" rel=\"noopener\"\u003e\u003ccode\u003eElements\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003efunction resizeObserver (node, options = {}) {\n  // ...\n  return {\n    unobserve(node) {\n      observer.unobserve(node)\n    },\n    \n    disconnect() {\n      observer.disconnet()\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBoth methods do the same thing for what we have built so far since we only allowed \u003ccode\u003eresizeObserver\u003c/code\u003e to observe one element. So, pick whatever method you prefer to stop observing the element.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst obs = resizeObserver(node, {\n  callback ({ entry, entries }) {\n    // Do something ...\n  }\n})\n\n// Stops observing all elements \nobs.disconect()\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith this, we’ve completed the creation of a better API for the \u003ccode\u003eResizeObserver\u003c/code\u003e — the \u003ccode\u003eresizeObserver\u003c/code\u003e function.\u003c/p\u003e\n\n\n\u003ch3 id=\"code-snippet\"\u003eCode snippet\u003c/h3\u003e\n\n\n\u003cp\u003eHere’s the code we’ve wrote for \u003ccode\u003eresizeObserver\u003c/code\u003e\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eexport function resizeObserver(node, options = {}) {\n  const observer = new ResizeObserver(observerFn)\n  const { callback, ...opts } = options\n\n  function observerFn(entries) {\n    for (const entry of entries) {\n      // Callback pattern\n      if (callback) callback({ entry, entries, observer })\n      // Event listener pattern\n      else {\n        node.dispatchEvent(\n          new CustomEvent(\u0026#39;resize-obs\u0026#39;, {\n            detail: { entry, entries, observer },\n          })\n        )\n      }\n    }\n  }\n \n  observer.observe(node)\n\n  return {\n    unobserve(node) {\n      observer.unobserve(node)\n    },\n    \n    disconnect() {\n      observer.disconnect()\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"using-this-in-practice-via-splendid-labz\"\u003eUsing this in practice via Splendid Labz\u003c/h3\u003e\n\n\n\u003cp\u003eSplendid Labz has a \u003ca href=\"https://splendidlabz.com/docs/utils\" rel=\"noopener\"\u003e\u003ccode\u003eutils\u003c/code\u003e\u003c/a\u003e library that contains an enhanced version of the \u003ccode\u003eresizeObserver\u003c/code\u003e we made above. You can use it if you wanna use a enhanced observer, or if you don’t want to copy-paste the observer code into your projects.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eimport { resizeObserver } from \u0026#39;@splendidlabz/utils/dom\u0026#39;\n\nconst node = document.querySelector(\u0026#39;.some-element\u0026#39;)\nconst obs = resizeObserver(node, {\n  callback ({ entry, entries }) {\n    /* Do what you want here */\n  }\n})\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eBonus:\u003c/strong\u003e The Splendid Labz \u003ccode\u003eresizeObserver\u003c/code\u003e is capable of observing multiple elements at once. It can also unobserve multiple elements at once.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003econst items = document.querySelectorAll(\u0026#39;.elements\u0026#39;)\nconst obs = resizeObserver(items, {\n  callback ({ entry, entries }) {\n    /* Do what you want here */\n  }\n})\n\n// Unobserves two items at once\nconst subset = [items[0], items[1]]\nobs.unobserve(subset) \u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"found-this-refactoring-helpful-\"\u003eFound this refactoring helpful?\u003c/h3\u003e\n\n\n\u003cp\u003eRefactoring is ultra useful (and important) because its a process that lets us create code that’s easy to use or maintain.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you found this refactoring exercise useful, you might just love how I teach JavaScript to budding developers in my \u003ca href=\"https://learnjavascript.today\" rel=\"noopener\"\u003eLearn JavaScript\u003c/a\u003e course.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this course, you’ll learn to build 20 real-world components. For each component, we start off simple. Then we add features and you’ll learn to refactor along the way.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat’s it!\u003c/p\u003e\n\n\n\n\u003cp\u003eHope you enjoyed this piece and see you in the next one.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-06-16T06:47:51-06:00",
  "modifiedTime": "2025-06-16T07:20:44-06:00"
}
