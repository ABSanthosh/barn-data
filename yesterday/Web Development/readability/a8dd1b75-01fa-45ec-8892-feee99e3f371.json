{
  "id": "a8dd1b75-01fa-45ec-8892-feee99e3f371",
  "title": "Typecasting and Viewport Transitions in CSS With tan(atan2())",
  "link": "https://css-tricks.com/typecasting-and-viewport-transitions-in-css-with-tanatan2/",
  "description": "We’ve been able to get the length of the viewport in CSS since… checks notes… 2013! Surprisingly, that was more than a decade ago. Getting the viewport width is as easy these days as easy as writing 100vw, but … Typecasting and Viewport Transitions in CSS With tan(atan2()) originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Juan Diego Rodríguez",
  "published": "Wed, 12 Feb 2025 14:15:28 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "functions",
    "view transitions"
  ],
  "byline": "Juan Diego Rodríguez",
  "length": 10065,
  "excerpt": "We've been able to get the length of the viewport in CSS since... checks notes... 2013! Surprisingly, that was more than a decade ago. Getting the",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "We’ve been able to get the length of the viewport in CSS since… checks notes… 2013! Surprisingly, that was more than a decade ago. Getting the viewport width is as easy these days as easy as writing 100vw, but what does that translate to, say, in pixels? What about the other properties, like those that take a percentage, an angle, or an integer? Think about changing an element’s opacity, rotating it, or setting an animation progress based on the screen size. We would first need the viewport as an integer — which isn’t currently possible in CSS, right? What I am about to say isn’t a groundbreaking discovery, it was first described amazingly by Jane Ori in 2023. In short, we can use a weird hack (or feature) involving the tan() and atan2() trigonometric functions to typecast a length (such as the viewport) to an integer. This opens many new layout possibilities, but my first experience was while writing an Almanac entry in which I just wanted to make an image’s opacity responsive. Resize the CodePen and the image will get more transparent as the screen size gets smaller, of course with some boundaries, so it doesn’t become invisible: This is the simplest we can do, but there is a lot more. Take, for example, this demo I did trying to combine many viewport-related effects. Resize the demo and the page feels alive: objects move, the background changes and the text smoothly wraps in place. I think it’s really cool, but I am no designer, so that’s the best my brain could come up with. Still, it may be too much for an introduction to this typecasting hack, so as a middle-ground, I’ll focus only on the title transition to showcase how all of it works: Setting things up The idea behind this is to convert 100vw to radians (a way to write angles) using atan2(), and then back to its original value using tan(), with the perk of coming out as an integer. It should be achieved like this: :root { --int-width: tan(atan2(100vw, 1px)); } But! Browsers aren’t too keep on this method, so a lot more wrapping is needed to make it work across all browsers. The following may seem like magic (or nonsense), so I recommend reading Jane’s post to better understand it, but this way it will work in all browsers: @property --100vw { syntax: \"\u003clength\u003e\"; initial-value: 0px; inherits: false; } :root { --100vw: 100vw; --int-width: calc(10000 * tan(atan2(var(--100vw), 10000px))); } Don’t worry too much about it. What’s important is our precious --int-width variable, which holds the viewport size as an integer! Wideness: One number to rule them all Right now we have the viewport as an integer, but that’s just the first step. That integer isn’t super useful by itself. We oughta convert it to something else next since: different properties have different units, and we want each property to go from a start value to an end value. Think about an image’s opacity going from 0 to 1, an object rotating from 0deg to 360deg, or an element’s offset-distance going from 0% to 100%. We want to interpolate between these values as --int-width gets bigger, but right now it’s just an integer that usually ranges between 0 to 1600, which is inflexible and can’t be easily converted to any of the end values. The best solution is to turn --int-width into a number that goes from 0 to 1. So, as the screen gets bigger, we can multiply it by the desired end value. Lacking a better name, I call this “0-to-1” value --wideness. If we have --wideness, all the last examples become possible: /* If `--wideness is 0.5 */ .element { opacity: var(--wideness); /* is 0.5 */ translate: rotate(calc(wideness(400px, 1200px) * 360deg)); /* is 180deg */ offset-distance: calc(var(--wideness) * 100%); /* is 50% */ } So --wideness is a value between 0 to 1 that represents how wide the screen is: 0 represents when the screen is narrow, and 1 represents when it’s wide. But we still have to set what those values mean in the viewport. For example, we may want 0 to be 400px and 1 to be 1200px, our viewport transitions will run between these values. Anything below and above is clamped to 0 and 1, respectively. In CSS, we can write that as follows: :root { /* Both bounds are unitless */ --lower-bound: 400; --upper-bound: 1200; --wideness: calc( (clamp(var(--lower-bound), var(--int-width), var(--upper-bound)) - var(--lower-bound)) / (var(--upper-bound) - var(--lower-bound)) ); } Besides easy conversions, the --wideness variable lets us define the lower and upper limits in which the transition should run. And what’s even better, we can set the transition zone at a middle spot so that the user can see it in its full glory. Otherwise, the screen would need to be 0px so that --wideness reaches 0 and who knows how wide to reach 1. We got the --wideness. What’s next? For starters, the title’s markup is divided into spans since there is no CSS-way to select specific words in a sentence: \u003ch1\u003e\u003cspan\u003eResize\u003c/span\u003e and \u003cspan\u003eenjoy!\u003c/span\u003e\u003c/h1\u003e And since we will be doing the line wrapping ourselves, it’s important to unset some defaults: h1 { position: absolute; /* Keeps the text at the center */ white-space: nowrap; /* Disables line wrapping */ } The transition should work without the base styling, but it’s just too plain-looking. They are below if you want to copy them onto your stylesheet: And just as a recap, our current hack looks like this: @property --100vw { syntax: \"\u003clength\u003e\"; initial-value: 0px; inherits: false; } :root { --100vw: 100vw; --int-width: calc(10000 * tan(atan2(var(--100vw), 10000px))); --lower-bound: 400; --upper-bound: 1200; --wideness: calc( (clamp(var(--lower-bound), var(--int-width), var(--upper-bound)) - var(--lower-bound)) / (var(--upper-bound) - var(--lower-bound)) ); } OK, enough with the set-up. It’s time to use our new values and make the viewport transition. We first gotta identify how the title should be rearranged for smaller screens: as you saw in the initial demo, the first span goes up and right, while the second span does the opposite and goes down and left. So, the end position for both spans translates to the following values: h1 { span:nth-child(1) { display: inline-block; /* So transformations work */ position: relative; bottom: 1.2lh; left: 50%; transform: translate(-50%); } span:nth-child(2) { display: inline-block; /* So transformations work */ position: relative; bottom: -1.2lh; left: -50%; transform: translate(50%); } } Before going forward, both formulas are basically the same, but with different signs. We can rewrite them at once bringing one new variable: --direction. It will be either 1 or -1 and define which direction to run the transition: h1 { span { display: inline-block; position: relative; bottom: calc(1.2lh * var(--direction)); left: calc(50% * var(--direction)); transform: translate(calc(-50% * var(--direction))); } span:nth-child(1) { --direction: 1; } span:nth-child(2) { --direction: -1; } } The next step would be bringing --wideness into the formula so that the values change as the screen resizes. However, we can’t just multiply everything by --wideness. Why? Let’s see what happens if we do: span { display: inline-block; position: relative; bottom: calc(var(--wideness) * 1.2lh * var(--direction)); left: calc(var(--wideness) * 50% * var(--direction)); transform: translate(calc(var(--wideness) * -50% * var(--direction))); } As you’ll see, everything is backwards! The words wrap when the screen is too wide, and unwrap when the screen is too narrow: Unlike our first examples, in which the transition ends as --wideness increases from 0 to 1, we want to complete the transition as --wideness decreases from 1 to 0, i.e. while the screen gets smaller the properties need to reach their end value. This isn’t a big deal, as we can rewrite our formula as a subtraction, in which the subtracting number gets bigger as --wideness increases: span { display: inline-block; position: relative; bottom: calc((1.2lh - var(--wideness) * 1.2lh) * var(--direction)); left: calc((50% - var(--wideness) * 50%) * var(--direction)); transform: translate(calc((-50% - var(--wideness) * -50%) * var(--direction))); } And now everything moves in the right direction while resizing the screen! However, you will notice how words move in a straight line and some words overlap while resizing. We can’t allow this since a user with a specific screen size may get stuck at that point in the transition. Viewport transitions are cool, but not at the expense of ruining the experience for certain screen sizes. Instead of moving in a straight line, words should move in a curve such that they pass around the central word. Don’t worry, making a curve here is easier than it looks: just move the spans twice as fast in the x-axis as they do in the y-axis. This can be achieved by multiplying --wideness by 2, although we have to cap it at 1 so it doesn’t overshoot past the final value. span { display: inline-block; position: relative; bottom: calc((1.2lh - var(--wideness) * 1.2lh) * var(--direction)); left: calc((50% - min(var(--wideness) * 2, 1) * 50%) * var(--direction)); transform: translate(calc((-50% - min(var(--wideness) * 2, 1) * -50%) * var(--direction))); } Look at that beautiful curve, just avoiding the central text: This is just the beginning! It’s surprising how powerful having the viewport as an integer can be, and what’s even crazier, the last example is one of the most basic transitions you could make with this typecasting hack. Once you do the initial setup, I can imagine a lot more possible transitions, and --widenesss is so useful, it’s like having a new CSS feature right now. I expect to see more about “Viewport Transitions” in the future because they do make websites feel more “alive” than adaptive.",
  "image": "https://css-tricks.com/wp-json/social-image-generator/v1/image/384339",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eWe’ve been able to \u003ca href=\"https://css-tricks.com/snippets/css/calculate-viewport-size-in-css/\"\u003eget the length of the viewport in CSS\u003c/a\u003e since… \u003cem\u003echecks notes\u003c/em\u003e… 2013! Surprisingly, that was more than a decade ago. Getting the viewport width is as easy these days as easy as writing \u003ccode\u003e100vw\u003c/code\u003e, but what does that translate to, say, in \u003cem\u003epixels\u003c/em\u003e? What about the other properties, like those that take a percentage, an angle, or an integer?\u003c/p\u003e\n\n\n\n\u003cp\u003eThink about changing an element’s opacity, rotating it, or setting an animation progress based on the screen size. We would first need the \u003cstrong\u003eviewport as an integer\u003c/strong\u003e — which isn’t currently possible in CSS, right?\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat I am about to say isn’t a groundbreaking discovery, it was first \u003ca href=\"https://dev.to/janeori/css-type-casting-to-numeric-tanatan2-scalars-582j\" rel=\"noopener\"\u003edescribed amazingly by Jane Ori\u003c/a\u003e in 2023. In short, we can use a weird hack (or feature) involving the \u003ccode\u003etan()\u003c/code\u003e and \u003ccode\u003eatan2()\u003c/code\u003e trigonometric functions to typecast a length (such as the viewport) to an integer. This opens \u003cem\u003emany\u003c/em\u003e new layout possibilities, but my first experience was while writing an Almanac entry in which I just wanted to make an image’s opacity responsive.\u003c/p\u003e\n\n\n\n\u003cp\u003eResize the CodePen and the image will get more transparent as the screen size gets smaller, of course with some boundaries, so it doesn’t become invisible:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThis is the simplest we can do, but there is a lot more. Take, for example, this demo I did trying to combine many viewport-related effects. Resize the demo and the page feels alive: objects move, the background changes and the text smoothly wraps in place.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eI think it’s really cool, but I am no designer, so that’s the best my brain could come up with. Still, it may be too much for an introduction to this typecasting hack, so as a middle-ground, I’ll focus only on the title transition to showcase how all of it works:\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"setting-up-the-_hack_-or-_feature_-\"\u003eSetting things up\u003c/h3\u003e\n\n\n\u003cp\u003eThe idea behind this is to convert \u003ccode\u003e100vw\u003c/code\u003e to radians (a way to write angles) using \u003ccode\u003eatan2()\u003c/code\u003e, and then back to its original value using \u003ccode\u003etan()\u003c/code\u003e, with the perk of coming out as an integer. It should be achieved like this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e:root {\n  --int-width: tan(atan2(100vw, 1px));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBut! Browsers aren’t too keep on this method, so a lot more wrapping is needed to make it work across all browsers. The following may seem like magic (or nonsense), so I recommend \u003ca href=\"https://dev.to/janeori/css-type-casting-to-numeric-tanatan2-scalars-582j\" rel=\"noopener\"\u003ereading Jane’s post\u003c/a\u003e to better understand it, but this way it will work in all browsers:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@property --100vw {\n  syntax: \u0026#34;\u0026lt;length\u0026gt;\u0026#34;;\n  initial-value: 0px;\n  inherits: false;\n}\n\n:root {\n  --100vw: 100vw;\n  --int-width: calc(10000 * tan(atan2(var(--100vw), 10000px)));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eDon’t worry too much about it. What’s important is our precious \u003ccode\u003e--int-width\u003c/code\u003e variable, which holds the viewport size as an integer!\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"wideness-one-number-to-rule-them-all\"\u003eWideness: One number to rule them all\u003c/h3\u003e\n\n\n\u003cp\u003eRight now we have the viewport as an integer, but that’s just the first step. That integer isn’t super useful by itself. We oughta convert it to something else next since:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003edifferent properties have different units, and\u003c/li\u003e\n\n\n\n\u003cli\u003ewe want each property to go from a start value to an end value.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThink about an image’s \u003ccode\u003eopacity\u003c/code\u003e going from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e1\u003c/code\u003e, an object rotating from \u003ccode\u003e0deg\u003c/code\u003e to \u003ccode\u003e360deg\u003c/code\u003e, or an element’s \u003ccode\u003eoffset-distance\u003c/code\u003e going from \u003ccode\u003e0%\u003c/code\u003e to \u003ccode\u003e100%\u003c/code\u003e. We want to interpolate between these values as \u003ccode\u003e--int-width\u003c/code\u003e gets bigger, but right now it’s just an integer that usually ranges between \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e1600\u003c/code\u003e, which is inflexible and can’t be easily converted to any of the end values.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe best solution is to turn \u003ccode\u003e--int-width\u003c/code\u003e into a number that goes from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e1\u003c/code\u003e. So, as the screen gets bigger, we can multiply it by the desired end value. Lacking a better name, I call this “0-to-1” value \u003ccode\u003e--wideness\u003c/code\u003e. If we have \u003ccode\u003e--wideness\u003c/code\u003e, all the last examples become possible:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* If `--wideness is 0.5 */\n\n.element {\n  opacity: var(--wideness); /* is 0.5 */\n  translate: rotate(calc(wideness(400px, 1200px) * 360deg)); /* is 180deg */\n  offset-distance: calc(var(--wideness) * 100%); /* is 50% */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSo \u003ccode\u003e--wideness\u003c/code\u003e is a value between \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e1\u003c/code\u003e that represents how wide the screen is: \u003ccode\u003e0\u003c/code\u003e represents when the screen is narrow, and \u003ccode\u003e1\u003c/code\u003e represents when it’s wide. But we still have to set what those values mean in the viewport. For example, we may want \u003ccode\u003e0\u003c/code\u003e to be \u003ccode\u003e400px\u003c/code\u003e and \u003ccode\u003e1\u003c/code\u003e to be \u003ccode\u003e1200px\u003c/code\u003e, our viewport transitions will run between these values. Anything below and above is clamped to \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003e1\u003c/code\u003e, respectively.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" data-recalc-dims=\"1\" fetchpriority=\"high\" decoding=\"async\" width=\"1024\" height=\"576\" src=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/animation-zone.png?resize=1024%2C576\u0026amp;ssl=1\" alt=\"Animation Zone between 400px and 1200px\" srcset=\"https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/animation-zone.png?resize=1024%2C576\u0026amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/animation-zone.png?resize=300%2C169\u0026amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/animation-zone.png?resize=768%2C432\u0026amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/animation-zone.png?resize=1536%2C864\u0026amp;ssl=1 1536w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2025/02/animation-zone.png?w=1920\u0026amp;ssl=1 1920w\" sizes=\"(min-width: 735px) 864px, 96vw\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn CSS, we can write that as follows:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e:root {\n  /* Both bounds are unitless */\n  --lower-bound: 400; \n  --upper-bound: 1200;\n\n  --wideness: calc(\n    (clamp(var(--lower-bound), var(--int-width), var(--upper-bound)) - var(--lower-bound)) / (var(--upper-bound) - var(--lower-bound))\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBesides easy conversions, the \u003ccode\u003e--wideness\u003c/code\u003e variable lets us define the lower and upper limits in which the transition should run. And what’s even better, we can set the transition zone at a middle spot so that the user can see it in its full glory. Otherwise, the screen would need to be \u003ccode\u003e0px\u003c/code\u003e so that \u003ccode\u003e--wideness\u003c/code\u003e reaches \u003ccode\u003e0\u003c/code\u003e and who knows how wide to reach \u003ccode\u003e1\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"we-got-the-wideness-what-s-next-\"\u003eWe got the \u003ccode\u003e--wideness\u003c/code\u003e. What’s next?\u003c/h3\u003e\n\n\n\u003cp\u003eFor starters, the title’s markup is divided into spans since there is no CSS-way to select specific words in a sentence:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;h1\u0026gt;\u0026lt;span\u0026gt;Resize\u0026lt;/span\u0026gt; and \u0026lt;span\u0026gt;enjoy!\u0026lt;/span\u0026gt;\u0026lt;/h1\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd since we will be doing the line wrapping ourselves, it’s important to unset some defaults:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eh1 {\n  position: absolute; /* Keeps the text at the center */\n  white-space: nowrap; /* Disables line wrapping */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe transition should work without the base styling, but it’s just too plain-looking. They are below if you want to copy them onto your stylesheet:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eAnd just as a recap, our current hack looks like this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@property --100vw {\n  syntax: \u0026#34;\u0026lt;length\u0026gt;\u0026#34;;\n  initial-value: 0px;\n  inherits: false;\n}\n\n:root {\n  --100vw: 100vw;\n  --int-width: calc(10000 * tan(atan2(var(--100vw), 10000px)));\n  --lower-bound: 400;\n  --upper-bound: 1200;\n\n  --wideness: calc(\n    (clamp(var(--lower-bound), var(--int-width), var(--upper-bound)) - var(--lower-bound)) / (var(--upper-bound) - var(--lower-bound))\n  );\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOK, enough with the set-up. It’s time to use our new values and make the viewport transition. We first gotta identify \u003cem\u003ehow\u003c/em\u003e the title should be rearranged for smaller screens: as you saw in the initial demo, the first \u003ccode\u003espan\u003c/code\u003e goes up and right, while the second \u003ccode\u003espan\u003c/code\u003e does the opposite and goes down and left. So, the end position for both spans translates to the following values:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eh1 {\n  span:nth-child(1) {\n    display: inline-block; /* So transformations work */\n    position: relative;\n    bottom: 1.2lh;\n    left: 50%;\n    transform: translate(-50%);\n  }\n\n  span:nth-child(2) {\n    display: inline-block; /* So transformations work */\n    position: relative;\n    bottom: -1.2lh;\n    left: -50%;\n    transform: translate(50%);\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBefore going forward, both formulas are basically the same, but with different signs. We can rewrite them at once bringing one new variable: \u003ccode\u003e--direction\u003c/code\u003e. It will be either \u003ccode\u003e1\u003c/code\u003e or \u003ccode\u003e-1\u003c/code\u003e and define which direction to run the transition:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eh1 {\n  span {\n    display: inline-block;\n    position: relative;\n    bottom: calc(1.2lh * var(--direction));\n    left: calc(50% * var(--direction));\n    transform: translate(calc(-50% * var(--direction)));\n    }\n\n  span:nth-child(1) {\n    --direction: 1;\n  }\n\n  span:nth-child(2) {\n    --direction: -1;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThe next step would be bringing \u003ccode\u003e--wideness\u003c/code\u003e into the formula so that the values change as the screen resizes. However, we can’t just multiply everything by \u003ccode\u003e--wideness\u003c/code\u003e. Why? Let’s see what happens if we do:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003espan {\n  display: inline-block;\n  position: relative;\n  bottom: calc(var(--wideness) * 1.2lh * var(--direction));\n  left: calc(var(--wideness) * 50% * var(--direction));\n  transform: translate(calc(var(--wideness) * -50% * var(--direction)));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAs you’ll see, everything is backwards! The words wrap when the screen is too wide, and unwrap when the screen is too narrow:\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eUnlike our first examples, in which the transition ends as \u003ccode\u003e--wideness\u003c/code\u003e increases from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e1\u003c/code\u003e, we want to complete the transition as \u003ccode\u003e--wideness\u003c/code\u003e decreases from \u003ccode\u003e1\u003c/code\u003e to \u003ccode\u003e0\u003c/code\u003e, i.e. while the screen gets smaller the properties need to reach their end value. This isn’t a big deal, as we can rewrite our formula as a subtraction, in which the subtracting number gets bigger as \u003ccode\u003e--wideness\u003c/code\u003e increases:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003espan {\n  display: inline-block;\n  position: relative;\n  bottom: calc((1.2lh - var(--wideness) * 1.2lh) * var(--direction));\n  left: calc((50% - var(--wideness) * 50%) * var(--direction));\n  transform: translate(calc((-50% - var(--wideness) * -50%) * var(--direction)));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd now everything moves in the right direction while resizing the screen!\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eHowever, you will notice how words move in a straight line and some words overlap while resizing. We can’t allow this since a user with a specific screen size may get stuck at that point in the transition. Viewport transitions are cool, but not at the expense of ruining the experience for certain screen sizes.\u003c/p\u003e\n\n\n\n\u003cp\u003eInstead of moving in a straight line, words should move in a curve such that they pass around the central word. Don’t worry, making a curve here is easier than it looks: just move the spans twice as fast in the x-axis as they do in the y-axis. This can be achieved by multiplying \u003ccode\u003e--wideness\u003c/code\u003e by \u003ccode\u003e2\u003c/code\u003e, although we have to cap it at \u003ccode\u003e1\u003c/code\u003e so it doesn’t overshoot past the final value.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003espan {\n display: inline-block;\n position: relative;\n bottom: calc((1.2lh - var(--wideness) * 1.2lh) * var(--direction));\n left: calc((50% - min(var(--wideness) * 2, 1) * 50%) * var(--direction));\n transform: translate(calc((-50% - min(var(--wideness) * 2, 1) * -50%) * var(--direction)));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eLook at that beautiful curve, just avoiding the central text:\u003c/p\u003e\n\n\n\n\n\n\n\u003ch3 id=\"this-is-just-the-beginning-\"\u003eThis is just the beginning!\u003c/h3\u003e\n\n\n\u003cp\u003eIt’s surprising how powerful having the viewport as an integer can be, and what’s even crazier, the last example is one of the most basic transitions you could make with this typecasting hack. Once you do the initial setup, I can imagine a lot more possible transitions, and \u003ccode\u003e--widenesss\u003c/code\u003e is so useful, it’s like having a new CSS feature right now.\u003c/p\u003e\n\n\n\n\u003cp\u003eI expect to see more about “Viewport Transitions” in the future because they do make websites feel more “alive” than adaptive.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-02-12T07:15:28-07:00",
  "modifiedTime": null
}
