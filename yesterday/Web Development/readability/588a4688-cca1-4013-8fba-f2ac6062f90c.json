{
  "id": "588a4688-cca1-4013-8fba-f2ac6062f90c",
  "title": "Exploring the CSS contrast-color() Function… a Second Time",
  "link": "https://css-tricks.com/exploring-the-css-contrast-color-function-a-second-time/",
  "description": "The contrast-color() function doesn’t check color contrast, but rather it outright resolves to either black or white (whichever one contrasts the most with your chosen color). Safari Technology Preview recently implemented it and we explore its possible uses in this article. Exploring the CSS contrast-color() Function… a Second Time originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Daniel Schwarz",
  "published": "Thu, 05 Jun 2025 13:45:56 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "accessibility",
    "color",
    "CSS functions"
  ],
  "byline": "Daniel Schwarz",
  "length": 10505,
  "excerpt": "The contrast-color() function doesn’t check color contrast, but rather it outright resolves to either black or white (whichever one contrasts the most with your chosen color). Safari Technology Preview recently implemented it and we explore its possible uses in this article.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "In many countries, web accessibility is a human right and the law, and there can be heavy fines for non-compliance. Naturally, this means that text and icons and such must have optimal color contrast in accordance with the benchmarks set by the Web Content Accessibility Guidelines (WCAG). Now, there are quite a few color contrast checkers out there (Figma even has one built-in now), but the upcoming contrast-color() function doesn’t check color contrast, it outright resolves to either black or white (whichever one contrasts the most with your chosen color). Right off the bat, you should know that we’ve sorta looked at this feature before. Back then, however, it was called color-contrast() instead of contrast-color() and had a much more convoluted way of going about things. It was only released in Safari Technology Preview 122 back in 2021, and that’s still the case at the time I’m writing this (now at version 220). You’d use it like this: button { --background-color: darkblue; background-color: var(--background-color); color: contrast-color(var(--background-color)); } Here, contrast-color() has determined that white contrasts with darkblue better than black does, which is why contrast-color() resolves to white. Pretty simple, really, but there are a few shortcomings, which includes a lack of browser support (again, it’s only in Safari Technology Preview at the moment). We can use contrast-color() conditionally, though: @supports (color: contrast-color(red)) { /* contrast-color() supported */ } @supports not (color: contrast-color(red)) { /* contrast-color() not supported */ } The shortcomings of contrast-color() First, let me just say that improvements are already being considered, so here I’ll explain the shortcomings as well as any improvements that I’ve heard about. Undoubtedly, the number one shortcoming is that contrast-color() only resolves to either black or white. If you don’t want black or white, well… that sucks. However, the draft spec itself alludes to more control over the resolved color in the future. But there’s one other thing that’s surprisingly easy to overlook. What happens when neither black nor white is actually accessible against the chosen color? That’s right, it’s possible for contrast-color() to just… not provide a contrasting color. Ideally, I think we’d want contrast-color() to resolve to the closest accessible variant of a preferred color. Until then, contrast-color() isn’t really usable. Another shortcoming of contrast-color() is that it only accepts arguments of the \u003ccolor\u003e data type, so it’s just not going to work with images or anything like that. I did, however, manage to make it “work” with a gradient (basically, two instances of contrast-color() for two color stops/one linear gradient): \u003cbutton\u003e \u003cspan\u003eA button\u003c/span\u003e \u003c/button\u003e button { background: linear-gradient(to right, red, blue); span { background: linear-gradient(to right, contrast-color(red), contrast-color(blue)); color: transparent; background-clip: text; } } The reason this looks so horrid is that, as mentioned before, contrast-color() only resolves to black or white, so in the middle of the gradient we essentially have 50% grey on purple. This problem would also get solved by contrast-color() resolving to a wider spectrum of colors. But what about the font size? As you might know already, the criteria for color contrast depends on the font size, so how does that work? Well, at the moment it doesn’t, but I think it’s safe to assume that it’ll eventually take the font-size into account when determining the resolved color. Which brings us to APCA. APCA (Accessible Perceptual Contrast Algorithm) is a new algorithm for measuring color contrast reliably. Andrew Somers, creator of APCA, conducted studies (alongside many other independent studies) and learned that 23% of WCAG 2 “Fails” are actually accessible. In addition, an insane 47% of “Passes” are inaccessible. Not only should APCA do a better job, but the APCA Readability Criterion (ARC) is far more nuanced, taking into account a much wider spectrum of font sizes and weights (hooray for me, as I’m very partial to 600 as a standard font weight). While the criterion is expectedly complex and unnecessarily confusing, the APCA Contrast Calculator does a decent-enough job of explaining how it all works visually, for now. contrast-color() doesn’t use APCA, but the draft spec does allude to offering more algorithms in the future. This wording is odd as it suggests that we’ll be able to choose between the APCA and WCAG algorithms. Then again, we have to remember that the laws of some countries will require WCAG 2 compliance while others require WCAG 3 compliance (when it becomes a standard). That’s right, we’re a long way off of APCA becoming a part of WCAG 3, let alone contrast-color(). In fact, it might not even be a part of it initially (or at all), and there are many more hurdles after that, but hopefully this sheds some light on the whole thing. For now, contrast-color() is using WCAG 2 only. Using contrast-color() Here’s a simple example (the same one from earlier) of a darkblue-colored button with accessibly-colored text chosen by contrast-color(). I’ve put this darkblue color into a CSS variable so that we can define it once but reference it as many times as is necessary (which is just twice for now). button { --background-color: darkblue; background-color: var(--background-color); /* Resolves to white */ color: contrast-color(var(--background-color)); } And the same thing but with lightblue: button { --background-color: lightblue; background-color: var(--background-color); /* Resolves to black */ color: contrast-color(var(--background-color)); } First of all, we can absolutely switch this up and use contrast-color() on the background-color property instead (or in-place of any \u003ccolor\u003e, in fact, like on a border): button { --color: darkblue; color: var(--color); /* Resolves to white */ background-color: contrast-color(var(--color)); } Any valid \u003ccolor\u003e will work (named, HEX, RGB, HSL, HWB, etc.): button { /* HSL this time */ --background-color: hsl(0 0% 0%); background-color: var(--background-color); /* Resolves to white */ color: contrast-color(var(--background-color)); } Need to change the base color on the fly (e.g., on hover)? Easy: button { --background-color: hsl(0 0% 0%); background-color: var(--background-color); /* Starts off white, becomes black on hover */ color: contrast-color(var(--background-color)); \u0026:hover { /* 50% lighter */ --background-color: hsl(0 0% 50%); } } Similarly, we could use contrast-color() with the light-dark() function to ensure accessible color contrast across light and dark modes: :root { /* Dark mode if checked */ \u0026:has(input[type=\"checkbox\"]:checked) { color-scheme: dark; } /* Light mode if not checked */ \u0026:not(:has(input[type=\"checkbox\"]:checked)) { color-scheme: light; } body { /* Different background for each mode */ background: light-dark(hsl(0 0% 50%), hsl(0 0% 0%)); /* Different contrasted color for each mode */ color: light-dark(contrast-color(hsl(0 0% 50%)), contrast-color(hsl(0 0% 0%)); } } The interesting thing about APCA is that it accounts for the discrepancies between light mode and dark mode contrast, whereas the current WCAG algorithm often evaluates dark mode contrast inaccurately. This one nuance of many is why we need not only a new color contrast algorithm but also the contrast-color() CSS function to handle all of these nuances (font size, font weight, etc.) for us. This doesn’t mean that contrast-color() has to ensure accessibility at the expense of our “designed” colors, though. Instead, we can use contrast-color() within the prefers-contrast: more media query only: button { --background-color: hsl(270 100% 50%); background-color: var(--background-color); /* Almost white (WCAG AA: Fail) */ color: hsl(270 100% 90%); @media (prefers-contrast: more) { /* Resolves to white (WCAG AA: Pass) */ color: contrast-color(var(--background-color)); } } Personally, I’m not keen on prefers-contrast: more as a progressive enhancement. Great color contrast benefits everyone, and besides, we can’t be sure that those who need more contrast are actually set up for it. Perhaps they’re using a brand new computer, or they just don’t know how to customize accessibility settings. Closing thoughts So, contrast-color() obviously isn’t useful in its current form as it only resolves to black or white, which might not be accessible. However, if it were improved to resolve to a wider spectrum of colors, that’d be awesome. Even better, if it were to upgrade colors to a certain standard (e.g., WCAG AA) if they don’t already meet it, but let them be if they do. Sort of like a failsafe approach? This means that web browsers would have to take the font size, font weight, element, and so on into account. To throw another option out there, there’s also the approach that Windows takes for its High Contrast Mode. This mode triggers web browsers to overwrite colors using the forced-colors: active media query, which we can also use to make further customizations. However, this effect is quite extreme (even though we can opt out of it using the forced-colors-adjust CSS property and use our own colors instead) and macOS’s version of the feature doesn’t extend to the web. I think that forced colors is an incredible idea as long as users can set their contrast preferences when they set up their computer or browser (the browser would be more enforceable), and there are a wider range of contrast options. And then if you, as a designer or developer, don’t like the enforced colors, then you have the option to meet accessibility standards so that they don’t get enforced. In my opinion, this approach is the most user-friendly and the most developer-friendly (assuming that you care about accessibility). For complete flexibility, there could be a CSS property for opting out, or something. Just color contrast by default, but you can keep the colors you’ve chosen as long as they’re accessible. What do you think? Is contrast-color() the right approach, or should the user agent bear some or all of the responsibility? Or perhaps you’re happy for color contrast to be considered manually?",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/03/contrast-colors.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eIn many countries, web accessibility is a human right and the law, and there can be heavy fines for non-compliance. Naturally, this means that text and icons and such must have optimal color contrast in accordance with the benchmarks set by the Web Content Accessibility Guidelines (WCAG). Now, there are quite a few color contrast checkers out there (Figma even has one built-in now), but the upcoming \u003ccode\u003econtrast-color()\u003c/code\u003e function doesn’t \u003cem\u003echeck\u003c/em\u003e color contrast, it outright resolves to either black or white (whichever one contrasts the most with your chosen color).\u003c/p\u003e\n\n\n\n\u003cp\u003eRight off the bat, you should know that \u003ca href=\"https://css-tricks.com/exploring-color-contrast-for-the-first-time/\"\u003ewe’ve sorta looked at this feature before\u003c/a\u003e. Back then, however, it was called \u003ccode\u003ecolor-contrast()\u003c/code\u003e instead of \u003ccode\u003econtrast-color()\u003c/code\u003e and had a much more convoluted way of going about things. It was only released in \u003ca href=\"https://webkit.org/blog/11577/release-notes-for-safari-technology-preview-122/\" rel=\"noopener\"\u003eSafari Technology Preview 122 back in 2021\u003c/a\u003e, and that’s still the case at the time I’m writing this (now at version 220).\u003c/p\u003e\n\n\n\n\u003cp\u003eYou’d use it like this:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebutton {\n  --background-color: darkblue;\n  background-color: var(--background-color);\n  color: contrast-color(var(--background-color));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eHere, \u003ccode\u003econtrast-color()\u003c/code\u003e has determined that white contrasts with \u003ccode\u003edarkblue\u003c/code\u003e better than black does, which is why \u003ccode\u003econtrast-color()\u003c/code\u003e resolves to \u003ccode\u003ewhite\u003c/code\u003e. Pretty simple, really, but there are a few shortcomings, which includes a lack of browser support (again, it’s only in \u003ca href=\"https://developer.apple.com/safari/technology-preview/\" rel=\"noopener\"\u003eSafari Technology Preview\u003c/a\u003e at the moment).\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can use \u003ccode\u003econtrast-color()\u003c/code\u003e conditionally, though:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e@supports (color: contrast-color(red)) {\n  /* contrast-color() supported */\n}\n\n@supports not (color: contrast-color(red)) {\n  /* contrast-color() not supported */\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"the-shortcomings-of-contrast-color-\"\u003eThe shortcomings of \u003ccode\u003econtrast-color()\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003eFirst, let me just say that improvements are already being considered, so here I’ll explain the shortcomings as well as any improvements that I’ve heard about.\u003c/p\u003e\n\n\n\n\u003cp\u003eUndoubtedly, the number one shortcoming is that \u003ccode\u003econtrast-color()\u003c/code\u003e only resolves to either black or white. If you don’t want black or white, well… that sucks. However, \u003ca href=\"https://drafts.csswg.org/css-color-5/#contrast-color\" rel=\"noopener\"\u003ethe draft spec\u003c/a\u003e itself alludes to more control over the resolved color in the future.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut there’s one other thing that’s surprisingly easy to overlook. What happens when neither black nor white is actually accessible against the chosen color? That’s right, it’s possible for \u003ccode\u003econtrast-color()\u003c/code\u003e to just… \u003cem\u003enot provide a contrasting color\u003c/em\u003e. Ideally, I think we’d want \u003ccode\u003econtrast-color()\u003c/code\u003e to resolve to the closest accessible variant of a \u003cem\u003epreferred\u003c/em\u003e color. Until then, \u003ccode\u003econtrast-color()\u003c/code\u003e isn’t really usable.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnother shortcoming of \u003ccode\u003econtrast-color()\u003c/code\u003e is that it only accepts arguments of the \u003ccode\u003e\u0026lt;color\u0026gt;\u003c/code\u003e data type, so it’s just not going to work with images or anything like that. I did, however, manage to make it “work” with a gradient (basically, two instances of \u003ccode\u003econtrast-color()\u003c/code\u003e for two color stops/one linear gradient):\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;button\u0026gt;\n  \u0026lt;span\u0026gt;A button\u0026lt;/span\u0026gt;\n\u0026lt;/button\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebutton {\n  background: linear-gradient(to right, red, blue);\n\n  span {\n    background: linear-gradient(to right, contrast-color(red), contrast-color(blue));\n    color: transparent;\n    background-clip: text;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe reason this looks so horrid is that, as mentioned before, \u003ccode\u003econtrast-color()\u003c/code\u003e only resolves to black or white, so in the middle of the gradient we essentially have 50% grey on purple. This problem would also get solved by \u003ccode\u003econtrast-color()\u003c/code\u003e resolving to a wider spectrum of colors.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut what about the font size? As you might know already, the criteria for color contrast depends on the font size, so how does \u003cem\u003ethat\u003c/em\u003e work? Well, at the moment it doesn’t, but I think it’s safe to assume that it’ll eventually take the \u003ccode\u003efont-size\u003c/code\u003e into account when determining the resolved color. Which brings us to APCA.\u003c/p\u003e\n\n\n\n\u003cp\u003eAPCA (\u003ca href=\"https://git.apcacontrast.com/documentation/APCA_in_a_Nutshell.html\" rel=\"noopener\"\u003eAccessible Perceptual Contrast Algorithm\u003c/a\u003e) is a new algorithm for measuring color contrast reliably. Andrew Somers, creator of APCA, conducted studies (alongside many other independent studies) and learned that \u003ca href=\"https://medium.com/@colleengratzer/how-apca-changes-accessible-contrast-with-andrew-somers-3d47627a5e16\" rel=\"noopener\"\u003e23% of WCAG 2 “Fails” are actually accessible. In addition, an insane 47% of “Passes” are inaccessible\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eNot only should APCA do a better job, but the \u003ca href=\"https://readtech.org/ARC/#conformance\" rel=\"noopener\"\u003eAPCA Readability Criterion\u003c/a\u003e (ARC) is far more nuanced, taking into account a much wider spectrum of font sizes and weights (hooray for me, as I’m very partial to \u003ccode\u003e600\u003c/code\u003e as a standard font weight). While the criterion is expectedly complex and unnecessarily confusing, the \u003ca href=\"https://apcacontrast.com/\" rel=\"noopener\"\u003eAPCA Contrast Calculator\u003c/a\u003e does a decent-enough job of explaining how it all works visually, for now.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003econtrast-color()\u003c/code\u003e doesn’t use APCA, but \u003ca href=\"https://drafts.csswg.org/css-color-5/#contrast-color\" rel=\"noopener\"\u003ethe draft spec\u003c/a\u003e \u003cem\u003edoes\u003c/em\u003e allude to offering more algorithms in the future. This wording is odd as it suggests that we’ll be able to choose between the APCA and WCAG algorithms. Then again, we have to remember that the laws of some countries will require WCAG 2 compliance while others require WCAG 3 compliance (when it becomes a standard).\u003c/p\u003e\n\n\n\n\u003cp\u003eThat’s right, we’re a long way off of APCA becoming a part of WCAG 3, let alone \u003ccode\u003econtrast-color()\u003c/code\u003e. In fact, \u003ca href=\"https://github.com/w3c/silver/pull/663#issuecomment-1408914402\" rel=\"noopener\"\u003eit might not even be a part of it initially\u003c/a\u003e (or at all), and there are many more hurdles after that, but hopefully this sheds some light on the whole thing. For now, \u003ccode\u003econtrast-color()\u003c/code\u003e is using WCAG 2 \u003cem\u003eonly\u003c/em\u003e.\u003c/p\u003e\n\n\n\u003ch3 id=\"using-contrast-color-\"\u003eUsing \u003ccode\u003econtrast-color()\u003c/code\u003e\u003c/h3\u003e\n\n\n\u003cp\u003eHere’s a simple example (the same one from earlier) of a \u003ccode\u003edarkblue\u003c/code\u003e-colored button with accessibly-colored text chosen by \u003ccode\u003econtrast-color()\u003c/code\u003e. I’ve put this \u003ccode\u003edarkblue\u003c/code\u003e color into a CSS variable so that we can define it once but reference it as many times as is necessary (which is just twice for now).\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebutton {\n  --background-color: darkblue;\n  background-color: var(--background-color);\n  /* Resolves to white */\n  color: contrast-color(var(--background-color));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd the same thing but with \u003ccode\u003elightblue\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebutton {\n  --background-color: lightblue;\n  background-color: var(--background-color);\n  /* Resolves to black */\n  color: contrast-color(var(--background-color));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFirst of all, we can absolutely switch this up and use \u003ccode\u003econtrast-color()\u003c/code\u003e on the \u003ccode\u003ebackground-color\u003c/code\u003e property instead (or in-place of any \u003ccode\u003e\u0026lt;color\u0026gt;\u003c/code\u003e, in fact, like on a border):\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebutton {\n  --color: darkblue;\n  color: var(--color);\n  /* Resolves to white */\n  background-color: contrast-color(var(--color));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAny valid \u003ccode\u003e\u0026lt;color\u0026gt;\u003c/code\u003e will work (named, HEX, RGB, HSL, HWB, etc.):\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebutton {\n  /* HSL this time */\n  --background-color: hsl(0 0% 0%);\n  background-color: var(--background-color);\n  /* Resolves to white */\n  color: contrast-color(var(--background-color));\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNeed to change the base color on the fly (e.g., on hover)? Easy:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebutton {\n  --background-color: hsl(0 0% 0%);\n  background-color: var(--background-color);\n  /* Starts off white, becomes black on hover */\n  color: contrast-color(var(--background-color));\n\n  \u0026amp;:hover {\n    /* 50% lighter */\n    --background-color: hsl(0 0% 50%);\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eSimilarly, we could use \u003ccode\u003econtrast-color()\u003c/code\u003e with the \u003ca href=\"https://css-tricks.com/almanac/functions/l/light-dark/\"\u003e\u003ccode\u003elight-dark()\u003c/code\u003e\u003c/a\u003e function to ensure accessible color contrast across light and dark modes:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e:root {\n  /* Dark mode if checked */\n  \u0026amp;:has(input[type=\u0026#34;checkbox\u0026#34;]:checked) {\n    color-scheme: dark;\n  }\n\n  /* Light mode if not checked */\n  \u0026amp;:not(:has(input[type=\u0026#34;checkbox\u0026#34;]:checked)) {\n    color-scheme: light;\n  }\n\n  body {\n    /* Different background for each mode */\n    background: light-dark(hsl(0 0% 50%), hsl(0 0% 0%));\n    /* Different contrasted color for each mode */\n    color: light-dark(contrast-color(hsl(0 0% 50%)), contrast-color(hsl(0 0% 0%));\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThe interesting thing about APCA is that it accounts for the discrepancies between light mode and dark mode contrast, whereas the current WCAG algorithm often evaluates dark mode contrast inaccurately. This one nuance of many is why we need not only a new color contrast algorithm but also the \u003ccode\u003econtrast-color()\u003c/code\u003e CSS function to handle all of these nuances (font size, font weight, etc.) for us.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis doesn’t mean that \u003ccode\u003econtrast-color()\u003c/code\u003e has to ensure accessibility at the expense of our “designed” colors, though. Instead, we can use \u003ccode\u003econtrast-color()\u003c/code\u003e within the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-contrast\" rel=\"noopener\"\u003e\u003ccode\u003eprefers-contrast: more\u003c/code\u003e media query\u003c/a\u003e only:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ebutton {\n  --background-color: hsl(270 100% 50%);\n  background-color: var(--background-color);\n  /* Almost white (WCAG AA: Fail) */\n  color: hsl(270 100% 90%);\n\n  @media (prefers-contrast: more) {\n    /* Resolves to white (WCAG AA: Pass) */\n    color: contrast-color(var(--background-color));\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003ePersonally, I’m not keen on \u003ccode\u003eprefers-contrast: more\u003c/code\u003e as a progressive enhancement. Great color contrast benefits everyone, and besides, we can’t be sure that those who need more contrast are actually set up for it. Perhaps they’re using a brand new computer, or they just don’t know how to customize accessibility settings.\u003c/p\u003e\n\n\n\u003ch3 id=\"closing-thoughts\"\u003eClosing thoughts\u003c/h3\u003e\n\n\n\u003cp\u003eSo, \u003ccode\u003econtrast-color()\u003c/code\u003e obviously isn’t useful in its current form as it only resolves to black or white, which might not be accessible. However, if it were improved to resolve to a wider spectrum of colors, that’d be awesome. Even better, if it were to upgrade colors to a certain standard (e.g., WCAG AA) if they don’t already meet it, but let them be if they do. Sort of like a failsafe approach? This means that web browsers would have to take the font size, font weight, element, and so on into account.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo throw another option out there, there’s also the approach that Windows takes for its High Contrast Mode. This mode triggers web browsers to overwrite colors using the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/forced-colors\" rel=\"noopener\"\u003e\u003ccode\u003eforced-colors: active\u003c/code\u003e\u003c/a\u003e media query, which we can also use to make further customizations. However, \u003ca href=\"https://support.microsoft.com/en-gb/windows/change-color-contrast-in-windows-fedc744c-90ac-69df-aed5-c8a90125e696\" rel=\"noopener\"\u003ethis effect is quite extreme\u003c/a\u003e (even though we \u003cem\u003ecan\u003c/em\u003e opt out of it using the \u003ccode\u003eforced-colors-adjust\u003c/code\u003e CSS property and use our own colors instead) and macOS’s version of the feature doesn’t extend to the web.\u003c/p\u003e\n\n\n\n\u003cp\u003eI think that forced colors is an incredible idea as long as users can set their contrast preferences when they set up their computer or browser (the browser would be more enforceable), and there are a wider range of contrast options. And then if you, as a designer or developer, don’t like the enforced colors, then you have the option to meet accessibility standards so that they don’t get enforced. In my opinion, this approach is the most user-friendly and the most developer-friendly (assuming that you care about accessibility). For \u003cem\u003ecomplete\u003c/em\u003e flexibility, there could be a CSS property for opting out, or something. Just color contrast by default, but you can keep the colors you’ve chosen as long as they’re accessible.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat do you think? Is \u003ccode\u003econtrast-color()\u003c/code\u003e the right approach, or should the user agent bear some or all of the responsibility? Or perhaps you’re happy for color contrast to be considered manually?\u003c/p\u003e\n\n\n\n\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2025-06-05T07:45:56-06:00",
  "modifiedTime": "2025-06-05T07:45:59-06:00"
}
