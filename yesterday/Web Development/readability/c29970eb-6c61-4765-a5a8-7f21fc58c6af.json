{
  "id": "c29970eb-6c61-4765-a5a8-7f21fc58c6af",
  "title": "Setting Line Length in CSS (and Fitting Text to a Container)",
  "link": "https://css-tricks.com/setting-line-length-in-css-and-fitting-text-to-a-container/",
  "description": "The many ways to juggle line length when working with text... including two proposed properties that could make it easier in the future. Setting Line Length in CSS (and Fitting Text to a Container) originally published on CSS-Tricks, which is part of the DigitalOcean family. You should get the newsletter.",
  "author": "Daniel Schwarz",
  "published": "Mon, 14 Jul 2025 12:38:23 +0000",
  "source": "https://css-tricks.com/feed/",
  "categories": [
    "Articles",
    "typography"
  ],
  "byline": "Daniel Schwarz",
  "length": 10093,
  "excerpt": "The many ways to juggle line length when working with text... including two proposed properties that could make it easier in the future.",
  "siteName": "CSS-Tricks",
  "favicon": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/07/star.png?fit=180%2C180\u0026ssl=1",
  "text": "First, what is line length? Line length is the length of a container that holds a body of multi-line text. “Multi-line” is the key part here, because text becomes less readable if the beginning of a line of text is too far away from the end of the prior line of text. This causes users to reread lines by mistake, and generally get lost while reading. Luckily, the Web Content Accessibility Guidelines (WCAG) gives us a pretty hard rule to follow: no more than 80 characters on a line (40 if the language is Chinese, Japanese, or Korean), which is super easy to implement using character (ch) units: width: 80ch; The width of 1ch is equal to the width of the number 0 in your chosen font, so the exact width depends on the font. Setting the optimal line length Just because you’re allowed up to 80 characters on a line, it doesn’t mean that you have to aim for that number. A study by the Baymard Institute revealed that a line length of 50-75 characters is the optimal length — this takes into consideration that smaller line lengths mean more lines and, therefore, more opportunities for users to make reading mistakes. That being said, we also have responsive design to think about, so setting a minimum width (e.g., min-width: 50ch) isn’t a good idea because you’re unlikely to fit 50 characters on a line with, for example, a screen/window size that is 320 pixels wide. So, there’s a bit of nuance involved, and the best way to handle that is by combining the clamp() and min() functions: clamp(): Set a fluid value that’s relative to a container using percentage, viewport, or container query units, but with minimum and maximum constraints. min(): Set the smallest value from a list of comma-separated values. Let’s start with min(). One of the arguments is 93.75vw. Assuming that the container extends across the whole viewport, this’d equal 300px when the viewport width is 320px (allowing for 20px of spacing to be distributed as you see fit) and 1350px when the viewport width is 1440px. However, for as long as the other argument (50ch) is the smallest of the two values, that’s the value that min() will resolve to. min(93.75vw, 50ch); Next is clamp(), which accepts three arguments in the following order: the minimum, preferred, and maximum values. This is how we’ll set the line length. For the minimum, you’d plug in your min() function, which sets the 50ch line length but only conditionally. For the maximum, I suggest 75ch, as mentioned before. The preferred value is totally up to you — this will be the width of your container when not hitting the minimum or maximum. width: clamp(min(93.75vw, 50ch), 70vw, 75ch); In addition, you can use min(), max(), and calc() in any of those arguments to add further nuance. If the container feels too narrow, then the font-size might be too large. If it feels too wide, then the font-size might be too small. Fit text to container (with JavaScript) You know that design trend where text is made to fit the width of a container? Typically, to utilize as much of the available space as possible? You’ll often see it applied to headings on marketing pages and blog posts. Well, Chris wrote about it back in 2018, rounding up several ways to achieve the effect with JavaScript or jQuery, unfortunately with limitations. However, the ending reveals that you can just use SVG as long as you know the viewBox values, and I actually have a trick for getting them. Although it still requires 3-5 lines of JavaScript, it’s the shortest method I’ve found. It also slides into HTML and CSS perfectly, particularly since the SVG inherits many CSS properties (including the color, thanks to fill: currentColor): \u003ch1 class=\"container\"\u003e \u003csvg\u003e \u003ctext\u003eFit text to container\u003c/text\u003e \u003c/svg\u003e \u003c/h1\u003e h1.container { /* Container size */ width: 100%; /* Type styles (\u003ctext\u003e will inherit most of them) */ font: 900 1em system-ui; color: hsl(43 74% 3%); text { /* We have to use fill: instead of color: here But we can use currentColor to inherit the color */ fill: currentColor; } } /* Select all SVGs */ const svg = document.querySelectorAll(\"svg\"); /* Loop all SVGs */ svg.forEach(element =\u003e { /* Get bounding box of \u003ctext\u003e element */ const bbox = element.querySelector(\"text\").getBBox(); /* Apply bounding box values to SVG element as viewBox */ element.setAttribute(\"viewBox\", [bbox.x, bbox.y, bbox.width, bbox.height].join(\" \")); }); Fit text to container (pure CSS) If you’re hell-bent on a pure-CSS method, you are in luck. However, despite the insane things that we can do with CSS these days, Roman Komarov’s fit-to-width hack is a bit complicated (albeit rather impressive). Here’s the gist of it: The text is duplicated a couple of times (although hidden accessibly with aria-hidden and hidden literally with visibility: hidden) so that we can do math with the hidden ones, and then apply the result to the visible one. Using container queries/container query units, the math involves dividing the inline size of the text by the inline size of the container to get a scaling factor, which we then use on the visible text’s font-size to make it grow or shrink. To make the scaling factor unitless, we use the tan(atan2()) type-casting trick. Certain custom properties must be registered using the @property at-rule (otherwise they don’t work as intended). The final font-size value utilizes clamp() to set minimum and maximum font sizes, but these are optional. \u003cspan class=\"text-fit\"\u003e \u003cspan\u003e \u003cspan class=\"text-fit\"\u003e \u003cspan\u003e\u003cspan\u003efit-to-width text\u003c/span\u003e\u003c/span\u003e \u003cspan aria-hidden=\"true\"\u003efit-to-width text\u003c/span\u003e \u003c/span\u003e \u003c/span\u003e \u003cspan aria-hidden=\"true\"\u003efit-to-width text\u003c/span\u003e \u003c/span\u003e .text-fit { display: flex; container-type: inline-size; --captured-length: initial; --support-sentinel: var(--captured-length, 9999px); \u0026 \u003e [aria-hidden] { visibility: hidden; } \u0026 \u003e :not([aria-hidden]) { flex-grow: 1; container-type: inline-size; --captured-length: 100cqi; --available-space: var(--captured-length); \u0026 \u003e * { --support-sentinel: inherit; --captured-length: 100cqi; --ratio: tan( atan2( var(--available-space), var(--available-space) - var(--captured-length) ) ); --font-size: clamp( 1em, 1em * var(--ratio), var(--max-font-size, infinity * 1px) - var(--support-sentinel) ); inline-size: var(--available-space); \u0026:not(.text-fit) { display: block; font-size: var(--font-size); @container (inline-size \u003e 0) { white-space: nowrap; } } /* Necessary for variable fonts that use optical sizing */ \u0026.text-fit { --captured-length2: var(--font-size); font-variation-settings: \"opsz\" tan(atan2(var(--captured-length2), 1px)); } } } } @property --captured-length { syntax: \"\u003clength\u003e\"; initial-value: 0px; inherits: true; } @property --captured-length2 { syntax: \"\u003clength\u003e\"; initial-value: 0px; inherits: true; } Watch for new text-grow/text-shrink properties To make fitting text to a container possible in just one line of CSS, a number of solutions have been discussed. The favored solution seems to be two new text-grow and text-shrink properties. Personally, I don’t think we need two different properties. In fact, I prefer the simpler alternative, font-size: fit-width, but since text-grow and text-shrink are already on the table (Chrome intends to prototype and you can track it), let’s take a look at how they could work. The first thing that you need to know is that, as proposed, the text-grow and text-shrink properties can apply to multiple lines of wrapped text within a container, and that’s huge because we can’t do that with my JavaScript technique or Roman’s CSS technique (where each line needs to have its own container). Both have the same syntax, and you’ll need to use both if you want to allow both growing and shrinking: text-grow: \u003cfit-target\u003e \u003cfit-method\u003e? \u003clength\u003e?; text-shrink: \u003cfit-target\u003e \u003cfit-method\u003e? \u003clength\u003e?; \u003cfit-target\u003e per-line: For text-grow, lines of text shorter than the container will grow to fit it. For text-shrink, lines of text longer than the container will shrink to fit it. consistent: For text-grow, the shortest line will grow to fit the container while all other lines grow by the same scaling factor. For text-shrink, the longest line will shrink to fit the container while all other lines shrink by the same scaling factor. \u003cfit-method\u003e (optional) scale: Scale the glyphs instead of changing the font-size. scale-inline: Scale the glyphs instead of changing the font-size, but only horizontally. font-size: Grow or shrink the font size accordingly. (I don’t know what the default value would be, but I imagine this would be it.) letter-spacing: The letter spacing will grow/shrink instead of the font-size. \u003clength\u003e (optional): The maximum font size for text-grow or minimum font size for text-shrink. Again, I think I prefer the font-size: fit-width approach as this would grow and shrink all lines to fit the container in just one line of CSS. The above proposal does way more than I want it to, and there are already a number of roadblocks to overcome (many of which are accessibility-related). That’s just me, though, and I’d be curious to know your thoughts in the comments. Conclusion It’s easier to set line length with CSS now than it was a few years ago. Now we have character units, clamp() and min() (and max() and calc() if you wanted to throw those in too), and wacky things that we can do with SVGs and CSS to fit text to a container. It does look like text-grow and text-shrink (or an equivalent solution) are what we truly need though, at least in some scenarios. Until we get there, this is a good time to weigh-in, which you can do by adding your feedback, tests, and use-cases to the GitHub issue.",
  "image": "https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/04/type-scale.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n          \n          \n\u003cp\u003eFirst, what is line length? \u003cdfn\u003eLine length\u003c/dfn\u003e is the length of a container that holds a body of multi-line text. “Multi-line” is the key part here, because text becomes less readable if the beginning of a line of text is too far away from the end of the prior line of text. This causes users to reread lines by mistake, and generally get lost while reading.\u003c/p\u003e\n\n\n\n\u003cp\u003eLuckily, the Web Content Accessibility Guidelines (WCAG) gives us a pretty hard rule to follow: \u003ca href=\"https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-visual-presentation\" rel=\"noopener\"\u003eno more than 80 characters on a line\u003c/a\u003e (40 if the language is Chinese, Japanese, or Korean), which is super easy to implement using character (\u003ccode\u003ech\u003c/code\u003e) units:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ewidth: 80ch;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe width of \u003ccode\u003e1ch\u003c/code\u003e is equal to the width of the number \u003ccode\u003e0\u003c/code\u003e in your chosen font, so the exact width depends on the font.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"setting-the-optimal-line-length\"\u003eSetting the \u003cem\u003eoptimal\u003c/em\u003e line length\u003c/h3\u003e\n\n\n\u003cp\u003eJust because you’re allowed up to 80 characters on a line, it doesn’t mean that you \u003cem\u003ehave\u003c/em\u003e to aim for that number. A study by the \u003ca href=\"https://baymard.com/blog/line-length-readability\" rel=\"noopener\"\u003eBaymard Institute\u003c/a\u003e revealed that a line length of 50-75 characters is the optimal length — this takes into consideration that smaller line lengths mean more lines and, therefore, more opportunities for users to make reading mistakes.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat being said, we also have responsive design to think about, so setting a minimum width (e.g., \u003ccode\u003emin-width: 50ch\u003c/code\u003e) isn’t a good idea because you’re unlikely to fit 50 characters on a line with, for example, a screen/window size that is 320 pixels wide. So, there’s a bit of nuance involved, and the best way to handle that is by combining the \u003ca href=\"https://css-tricks.com/almanac/functions/c/clamp/\"\u003e\u003ccode\u003eclamp()\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://css-tricks.com/almanac/functions/m/min/\"\u003e\u003ccode\u003emin()\u003c/code\u003e\u003c/a\u003e functions:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eclamp()\u003c/code\u003e:\u003c/strong\u003e Set a fluid value that’s relative to a container using percentage, viewport, or container query units, but with minimum and maximum constraints.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003emin()\u003c/code\u003e:\u003c/strong\u003e Set the smallest value from a list of comma-separated values.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eLet’s start with \u003ccode\u003emin()\u003c/code\u003e. One of the arguments is \u003ccode\u003e93.75vw\u003c/code\u003e. Assuming that the container extends across the whole viewport, this’d equal \u003ccode\u003e300px\u003c/code\u003e when the viewport width is \u003ccode\u003e320px\u003c/code\u003e (allowing for \u003ccode\u003e20px\u003c/code\u003e of spacing to be distributed as you see fit) and \u003ccode\u003e1350px\u003c/code\u003e when the viewport width is \u003ccode\u003e1440px\u003c/code\u003e. However, for as long as the other argument (\u003ccode\u003e50ch\u003c/code\u003e) is the smallest of the two values, that’s the value that \u003ccode\u003emin()\u003c/code\u003e will resolve to.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003emin(93.75vw, 50ch);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext is \u003ccode\u003eclamp()\u003c/code\u003e, which accepts three arguments in the following order: the minimum, preferred, and maximum values. This is how we’ll set the line length.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor the minimum, you’d plug in your \u003ccode\u003emin()\u003c/code\u003e function, which sets the \u003ccode\u003e50ch\u003c/code\u003e line length but only conditionally. For the maximum, I suggest \u003ccode\u003e75ch\u003c/code\u003e, as mentioned before. The preferred value is totally up to you — this will be the width of your container when not hitting the minimum or maximum.\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003ewidth: clamp(min(93.75vw, 50ch), 70vw, 75ch);\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn addition, you can use \u003ca href=\"https://css-tricks.com/almanac/functions/m/min/\"\u003e\u003ccode\u003emin()\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://css-tricks.com/almanac/functions/m/max/\"\u003e\u003ccode\u003emax()\u003c/code\u003e\u003c/a\u003e, and \u003ca href=\"https://css-tricks.com/a-complete-guide-to-calc-in-css/\"\u003e\u003ccode\u003ecalc()\u003c/code\u003e\u003c/a\u003e in any of those arguments to add further nuance.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf the container feels too narrow, then the \u003ca href=\"https://css-tricks.com/almanac/properties/f/font-size/\"\u003e\u003ccode\u003efont-size\u003c/code\u003e\u003c/a\u003e might be too large. If it feels too wide, then the \u003ccode\u003efont-size\u003c/code\u003e might be too small.\u003c/p\u003e\n\n\n\u003ch3 id=\"fit-text-to-container-with-javascript-\"\u003eFit text to container (with JavaScript)\u003c/h3\u003e\n\n\n\u003cp\u003eYou know that design trend where text is made to fit the width of a container? Typically, to utilize as much of the available space as possible? You’ll often see it applied to headings on marketing pages and blog posts. Well, \u003ca href=\"https://css-tricks.com/fitting-text-to-a-container/\"\u003eChris wrote about it\u003c/a\u003e back in 2018, rounding up several ways to achieve the effect with JavaScript or jQuery, unfortunately with limitations. However, the ending reveals that you can just use SVG as long as you know the \u003ccode\u003eviewBox\u003c/code\u003e values, and I actually have a trick for getting them.\u003c/p\u003e\n\n\n\n\u003cp\u003eAlthough it still requires 3-5 lines of JavaScript, it’s the shortest method I’ve found. It also slides into HTML and CSS perfectly, particularly since the SVG inherits many CSS properties (including the color, thanks to \u003ccode\u003efill: currentColor\u003c/code\u003e):\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;h1 class=\u0026#34;container\u0026#34;\u0026gt;\n  \u0026lt;svg\u0026gt;\n    \u0026lt;text\u0026gt;Fit text to container\u0026lt;/text\u0026gt;\n  \u0026lt;/svg\u0026gt;\n\u0026lt;/h1\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003eh1.container {\n  /* Container size */\n  width: 100%;\n\n  /* Type styles (\u0026lt;text\u0026gt; will inherit most of them) */\n  font: 900 1em system-ui;\n  color: hsl(43 74% 3%);\n\n  text {\n    /*\n      We have to use fill: instead of color: here\n      But we can use currentColor to inherit the color\n    */\n    fill: currentColor;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre rel=\"JavaScript\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e/* Select all SVGs */\nconst svg = document.querySelectorAll(\u0026#34;svg\u0026#34;);\n\n/* Loop all SVGs */\nsvg.forEach(element =\u0026gt; {\n  /* Get bounding box of \u0026lt;text\u0026gt; element */\n  const bbox = element.querySelector(\u0026#34;text\u0026#34;).getBBox();\n  /* Apply bounding box values to SVG element as viewBox */\n  element.setAttribute(\u0026#34;viewBox\u0026#34;, [bbox.x, bbox.y, bbox.width, bbox.height].join(\u0026#34; \u0026#34;));\n});\u003c/code\u003e\u003c/pre\u003e\n\n\n\u003ch3 id=\"fit-text-to-container-pure-css-\"\u003eFit text to container (pure CSS)\u003c/h3\u003e\n\n\n\u003cp\u003eIf you’re hell-bent on a pure-CSS method, you \u003cem\u003eare\u003c/em\u003e in luck. However, despite the insane things that we can do with CSS these days, \u003ca href=\"https://kizu.dev/fit-to-width/\" rel=\"noopener\"\u003eRoman Komarov’s fit-to-width hack\u003c/a\u003e is a bit complicated (albeit rather impressive). Here’s the gist of it:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThe text is duplicated a couple of times (although hidden accessibly with \u003ccode\u003earia-hidden\u003c/code\u003e and hidden literally with \u003ccode\u003evisibility: hidden\u003c/code\u003e) so that we can do math with the hidden ones, and then apply the result to the visible one.\u003c/li\u003e\n\n\n\n\u003cli\u003eUsing container queries/container query units, the math involves dividing the inline size of the text by the inline size of the container to get a scaling factor, which we then use on the visible text’s \u003ccode\u003efont-size\u003c/code\u003e to make it grow or shrink.\u003c/li\u003e\n\n\n\n\u003cli\u003eTo make the scaling factor unitless, we use the \u003ca href=\"https://dev.to/janeori/css-type-casting-to-numeric-tanatan2-scalars-582j\" rel=\"noopener\"\u003e\u003ccode\u003etan(atan2())\u003c/code\u003e type-casting trick\u003c/a\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eCertain custom properties must be registered using the \u003ca href=\"https://css-tricks.com/almanac/rules/p/property/\"\u003e\u003ccode\u003e@property\u003c/code\u003e\u003c/a\u003e at-rule (otherwise they don’t work as intended).\u003c/li\u003e\n\n\n\n\u003cli\u003eThe final \u003ccode\u003efont-size\u003c/code\u003e value utilizes \u003ccode\u003eclamp()\u003c/code\u003e to set minimum and maximum font sizes, but these are optional.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cpre rel=\"HTML\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e\u0026lt;span class=\u0026#34;text-fit\u0026#34;\u0026gt;\n  \u0026lt;span\u0026gt;\n    \u0026lt;span class=\u0026#34;text-fit\u0026#34;\u0026gt;\n      \u0026lt;span\u0026gt;\u0026lt;span\u0026gt;fit-to-width text\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n      \u0026lt;span aria-hidden=\u0026#34;true\u0026#34;\u0026gt;fit-to-width text\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;\n  \u0026lt;/span\u0026gt;\n  \u0026lt;span aria-hidden=\u0026#34;true\u0026#34;\u0026gt;fit-to-width text\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003e.text-fit {\n  display: flex;\n  container-type: inline-size;\n\n  --captured-length: initial;\n  --support-sentinel: var(--captured-length, 9999px);\n\n  \u0026amp; \u0026gt; [aria-hidden] {\n    visibility: hidden;\n  }\n\n  \u0026amp; \u0026gt; :not([aria-hidden]) {\n    flex-grow: 1;\n    container-type: inline-size;\n\n    --captured-length: 100cqi;\n    --available-space: var(--captured-length);\n\n    \u0026amp; \u0026gt; * {\n      --support-sentinel: inherit;\n      --captured-length: 100cqi;\n      --ratio: tan(\n        atan2(\n          var(--available-space),\n          var(--available-space) - var(--captured-length)\n        )\n      );\n      --font-size: clamp(\n        1em,\n        1em * var(--ratio),\n        var(--max-font-size, infinity * 1px) - var(--support-sentinel)\n      );\n      inline-size: var(--available-space);\n\n      \u0026amp;:not(.text-fit) {\n        display: block;\n        font-size: var(--font-size);\n\n        @container (inline-size \u0026gt; 0) {\n          white-space: nowrap;\n        }\n      }\n\n      /* Necessary for variable fonts that use optical sizing */\n      \u0026amp;.text-fit {\n        --captured-length2: var(--font-size);\n        font-variation-settings: \u0026#34;opsz\u0026#34; tan(atan2(var(--captured-length2), 1px));\n      }\n    }\n  }\n}\n\n@property --captured-length {\n  syntax: \u0026#34;\u0026lt;length\u0026gt;\u0026#34;;\n  initial-value: 0px;\n  inherits: true;\n}\n\n@property --captured-length2 {\n  syntax: \u0026#34;\u0026lt;length\u0026gt;\u0026#34;;\n  initial-value: 0px;\n  inherits: true;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\u003ch4 id=\"watch-for-new-text-grow-text-shrink-properties\"\u003eWatch for new \u003ccode\u003etext-grow\u003c/code\u003e/\u003ccode\u003etext-shrink\u003c/code\u003e properties\u003c/h4\u003e\n\n\n\u003cp\u003eTo make fitting text to a container possible in just \u003cem\u003eone\u003c/em\u003e line of CSS, \u003ca href=\"https://github.com/w3c/csswg-drafts/issues/2528\" rel=\"noopener\"\u003ea number of solutions have been discussed\u003c/a\u003e. The favored solution seems to be two new \u003ca href=\"https://github.com/explainers-by-googlers/css-fit-text/blob/main/README.md#potential-solution\" rel=\"noopener\"\u003e\u003ccode\u003etext-grow\u003c/code\u003e and \u003ccode\u003etext-shrink\u003c/code\u003e properties\u003c/a\u003e. Personally, I don’t think we need two different properties. In fact, I prefer the simpler alternative, \u003ca href=\"https://github.com/explainers-by-googlers/css-fit-text/blob/main/README.md#considered-alternatives\" rel=\"noopener\"\u003e\u003ccode\u003efont-size: fit-width\u003c/code\u003e\u003c/a\u003e, but since \u003ccode\u003etext-grow\u003c/code\u003e and \u003ccode\u003etext-shrink\u003c/code\u003e are already on the table (\u003ca href=\"https://groups.google.com/a/chromium.org/g/blink-dev/c/I3aG24t4bwI/m/xLBLyAJKDwAJ\" rel=\"noopener\"\u003eChrome intends to prototype\u003c/a\u003e and you can \u003ca href=\"https://chromestatus.com/feature/5104141688635392?gate=5084590997504000\" rel=\"noopener\"\u003etrack it\u003c/a\u003e), let’s take a look at how they could work.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe first thing that you need to know is that, as proposed, the \u003ccode\u003etext-grow\u003c/code\u003e and \u003ccode\u003etext-shrink\u003c/code\u003e properties can apply to multiple lines of wrapped text within a container, and that’s huge because we can’t do that with my JavaScript technique or Roman’s CSS technique (where each line needs to have its own container).\u003c/p\u003e\n\n\n\n\u003cp\u003eBoth have the same syntax, and you’ll need to use both if you want to allow both growing \u003cem\u003eand\u003c/em\u003e shrinking:\u003c/p\u003e\n\n\n\n\u003cpre rel=\"CSS\" data-line=\"\"\u003e\u003ccode markup=\"tt\"\u003etext-grow: \u0026lt;fit-target\u0026gt; \u0026lt;fit-method\u0026gt;? \u0026lt;length\u0026gt;?;\ntext-shrink: \u0026lt;fit-target\u0026gt; \u0026lt;fit-method\u0026gt;? \u0026lt;length\u0026gt;?;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e\u0026lt;fit-target\u0026gt;\u003c/code\u003e\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eper-line\u003c/code\u003e: For \u003ccode\u003etext-grow\u003c/code\u003e, lines of text shorter than the container will grow to fit it. For \u003ccode\u003etext-shrink\u003c/code\u003e, lines of text \u003cem\u003elonger\u003c/em\u003e than the container will \u003cem\u003eshrink\u003c/em\u003e to fit it.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003econsistent\u003c/code\u003e: For \u003ccode\u003etext-grow\u003c/code\u003e, the shortest line will grow to fit the container while all other lines grow by the same scaling factor. For \u003ccode\u003etext-shrink\u003c/code\u003e, the \u003cem\u003elongest\u003c/em\u003e line will \u003cem\u003eshrink\u003c/em\u003e to fit the container while all other lines shrink by the same scaling factor.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e\u0026lt;fit-method\u0026gt;\u003c/code\u003e\u003c/strong\u003e (optional)\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003escale\u003c/code\u003e: Scale the glyphs instead of changing the \u003ccode\u003efont-size\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003escale-inline\u003c/code\u003e: Scale the glyphs instead of changing the \u003ccode\u003efont-size\u003c/code\u003e, but only horizontally.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003efont-size\u003c/code\u003e: Grow or shrink the font size accordingly. (I don’t know what the default value would be, but I imagine this would be it.)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eletter-spacing\u003c/code\u003e: The letter spacing will grow/shrink instead of the \u003ccode\u003efont-size\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e\u0026lt;length\u0026gt;\u003c/code\u003e\u003c/strong\u003e (optional): The maximum font size for \u003ccode\u003etext-grow\u003c/code\u003e or minimum font size for \u003ccode\u003etext-shrink\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAgain, I think I prefer the \u003ccode\u003efont-size: fit-width\u003c/code\u003e approach as this would grow and shrink all lines to fit the container in just one line of CSS. The above proposal does way more than I want it to, and there are already \u003ca href=\"https://github.com/explainers-by-googlers/css-fit-text/blob/main/README.md#detailed-design-discussion\" rel=\"noopener\"\u003ea number of roadblocks\u003c/a\u003e to overcome (many of which are accessibility-related). That’s just me, though, and I’d be curious to know your thoughts in the comments.\u003c/p\u003e\n\n\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\n\n\u003cp\u003eIt’s easier to set line length with CSS now than it was a few years ago. Now we have character units, \u003ccode\u003eclamp()\u003c/code\u003e and \u003ccode\u003emin()\u003c/code\u003e (and \u003ccode\u003emax()\u003c/code\u003e and \u003ccode\u003ecalc()\u003c/code\u003e if you wanted to throw those in too), and wacky things that we can do with SVGs and CSS to fit text to a container. It does look like \u003ccode\u003etext-grow\u003c/code\u003e and \u003ccode\u003etext-shrink\u003c/code\u003e (or an equivalent solution) are what we truly need though, at least in some scenarios.\u003c/p\u003e\n\n\n\n\u003cp\u003eUntil we get there, this is a good time to weigh-in, which you can do by adding your feedback, tests, and use-cases to the \u003ca href=\"https://github.com/w3c/csswg-drafts/issues/2528\" rel=\"noopener\"\u003eGitHub issue\u003c/a\u003e.\u003c/p\u003e\n\n          \n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-07-14T06:38:23-06:00",
  "modifiedTime": "2025-07-14T06:38:26-06:00"
}
