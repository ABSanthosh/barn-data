{
  "id": "34b68226-c13b-4793-9987-05b6b9352f99",
  "title": "Announcing Official Puppeteer Support for Firefox",
  "link": "https://hacks.mozilla.org/2024/08/puppeteer-support-for-firefox/",
  "description": "We’re pleased to announce that, as of version 23, the Puppeteer browser automation library now has first-class support for Firefox. This means that it’s now easy to write automation and perform end-to-end testing using Puppeteer, and run against both Chrome and Firefox. The post Announcing Official Puppeteer Support for Firefox appeared first on Mozilla Hacks - the Web developer blog.",
  "author": "James Graham",
  "published": "Wed, 07 Aug 2024 15:44:40 +0000",
  "source": "https://hacks.mozilla.org/feed/",
  "categories": [
    "Featured Article",
    "Firefox",
    "Web Developers",
    "browser",
    "chrome",
    "firefox",
    "webDriver"
  ],
  "byline": "https://hoppipolla.co.uk",
  "length": 13092,
  "excerpt": "Puppeteer 23 now supports Firefox, simplifying browser automation and testing across both Chrome and Firefox.",
  "siteName": "Mozilla Hacks – the Web developer blog",
  "favicon": "",
  "text": "We’re pleased to announce that, as of version 23, the Puppeteer browser automation library now has first-class support for Firefox. This means that it’s now easy to write automation and perform end-to-end testing using Puppeteer, and run against both Chrome and Firefox. How to Use Puppeteer With Firefox To get started, simply set the product to “firefox” when starting Puppeteer: import puppeteer from \"puppeteer\"; const browser = await puppeteer.launch({ browser: \"firefox\" }); const page = await browser.newPage(); // ... await browser.close(); As with Chrome, Puppeteer is able to download and launch the latest stable version of Firefox, so running against either browser should offer the same developer experience that Puppeteer users have come to expect. Whilst the features offered by Puppeteer won’t be a surprise, bringing support to multiple browsers has been a significant undertaking. The Firefox support is not based on a Firefox-specific automation protocol, but on WebDriver BiDi, a cross browser protocol that’s undergoing standardization at the W3C, and currently has implementation in both Gecko and Chromium. This use of a cross-browser protocol should make it much easier to support many different browsers going forward. Later in this post we’ll dive into some of the more technical background behind WebDriver BiDi. But first we’d like to call out how today’s announcement is a great demonstration of how productive collaboration can advance the state of the art on the web. Developing a new browser automation protocol is a lot of work, and great thanks goes to the Puppeteer team and the other members of the W3C Browser Testing and Tools Working Group, for all their efforts in getting us to this point. You can also check out the Puppeteer team’s post about making WebDriver BiDi production ready. Key Features For long-time Puppeteer users, the features available are familiar. However for people in other automation and testing ecosystems — particularly those that until recently relied entirely on HTTP-based WebDriver — this section outlines some of the new functionality that WebDriver BiDi makes possible to implement in a cross-browser manner. Capturing of Log Messages A common requirement when testing web apps is to ensure that there are no unexpected errors reported to the console. This is also a case where an event-based protocol shines, since it avoids the need to poll the browser for new log messages. import puppeteer from \"puppeteer\"; const browser = await puppeteer.launch({ browser: \"firefox\" }); const page = await browser.newPage(); page.on('console', msg =\u003e { console.log(`[console] ${msg.type()}: ${msg.text()}`); }); await page.evaluate(() =\u003e console.debug('Some Info')); await browser.close(); Output: [console] debug: Some Info Device Emulation Often when testing a reactive layout it’s useful to be able to ensure that the layout works well at multiple screen dimensions, and device pixel ratios. This can be done by using a real mobile browser, either on a device, or on an emulator. However for simplicity it can be useful to perform the testing on a desktop set up to mimic the viewport of a mobile device. The example below shows loading a page with Firefox configured to emulate the viewport size and device pixel ratio of a Pixel 5 phone. import puppeteer from \"puppeteer\"; const device = puppeteer.KnownDevices[\"Pixel 5\"]; const browser = await puppeteer.launch({ browser: \"firefox\" }); const page = await browser.newPage(); await page.emulate(device); const viewport = page.viewport(); console.log( `[emulate] Pixel 5: ${viewport.width}x${viewport.height}` + ` (dpr=${viewport.deviceScaleFactor}, mobile=${viewport.isMobile})` ); await page.goto(\"https://www.mozilla.org\"); await browser.close(); Output: [emulate] Pixel 5: 393x851 (dpr=3, mobile=true) Network Interception A common requirement for testing is to be able to track and intercept network requests. Interception is especially useful for avoiding requests to third party services during tests, and providing mock response data. It can also be used to handle HTTP authentication dialogs, and override parts of the request and response, for example adding or removing headers. In the example below we use network request interception to block all requests to web fonts on a page, which might be useful to ensure that these fonts failing to load doesn’t break the site layout. import puppeteer from \"puppeteer\"; const browser = await puppeteer.launch({ browser: 'firefox' }); const page = await browser.newPage(); await page.setRequestInterception(true); page.on(\"request\", request =\u003e { if (request.url().includes(\".woff2\")) { // Block requests to custom user fonts. console.log(`[intercept] Request aborted: ${request.url()}`); request.abort(); } else { request.continue(); } }); const response = await page.goto(\"https://support.mozilla.org\"); console.log( `[navigate] status=${response.status()} url=${response.url()}` ); await browser.close(); Output: [intercept] Request aborted: https://assets-prod.sumo.prod.webservices.mozgcp.net/static/Inter-Bold.3717db0be15085ac.woff2 [navigate] status=200 url=https://support.mozilla.org/en-US/ Preload Scripts Often automation tooling wants to provide custom functionality that can be implemented in JavaScript. Whilst WebDriver has always allowed injecting scripts, it wasn’t possible to ensure that an injected script was always run before the page started loading, making it impossible to avoid races between the page scripts and the injected script. WebDriver BiDi provides “preload” scripts which can be run before a page is loaded. It also provides a means to emit custom events from scripts. This can be used, for example, to avoid polling for expected elements, but instead using a mutation observer that fires as soon as the element is available. In the example below we wait for the \u003ctitle\u003e element to appear on the page, and log its contents. import puppeteer from \"puppeteer\"; const browser = await puppeteer.launch({ browser: 'firefox', }); const page = await browser.newPage(); const gotMessage = new Promise(resolve =\u003e page.exposeFunction(\"sendMessage\", async message =\u003e { console.log(`[script] Message from pre-load script: ${message}`); resolve(); }) ); await page.evaluateOnNewDocument(() =\u003e { const observer = new MutationObserver(mutationList =\u003e { for (const mutation of mutationList) { if (mutation.type === \"childList\") { for (const node of mutation.addedNodes) { if (node.tagName === \"TITLE\") { sendMessage(node.textContent); } } } }; }); observer.observe(document.documentElement, { subtree: true, childList: true, }); }); await page.goto(\"https://support.mozilla.org\"); await gotMessage; await browser.close(); Output: [script] Message from pre-load script: Mozilla Support Technical Background Until recently people wishing to automate browsers had two main choices: Use the W3C WebDriver API, which was based on earlier work by the Selenium project. Use a browser-specific API for talking to each supported browser such as Chrome DevTools Protocol (CDP) for Chromium-based browsers, or Firefox’s Remote Debugging Protocol (RDP) for Gecko-based browsers. Unfortunately both of those options come with significant tradeoffs. The “classic” WebDriver API is HTTP-based, and its model involves automation sending a command to the browser and waiting for a response. That works well for automation scenarios where you load a page and then verify, for example, that some element is displayed, but the inability to get events — e.g. console logs — back from the browser, or run multiple commands concurrently, makes the API a poor fit for more advanced use cases. By contrast, browser-specific APIs have generally been designed around supporting the complex use cases of in-browser devtools. This has given them a feature set far in advance of what’s possible using WebDriver, as they need to support use cases such as recording console logs, or network requests. Therefore, browser automation clients have been forced to make the choice between supporting many browsers using a single protocol and providing a limited feature set, or providing a richer feature set but having to implement multiple protocols to provide functionality separately for each supported browser. This obviously increased the cost and complexity of creating great cross-browser automation, which isn’t a good situation, especially when developers commonly cite cross-browser testing as one the main pain points in developing for the web. Long time developers might notice the analogy here to the situation with editors before the development of Language Server Protocol (LSP). At that time each text editor or IDE had to implement bespoke support for each different programming language. That made it hard to get support for a new language into all the tools that developers were using. The advent of LSP changed that by providing a common protocol that could be supported by any combination of editor and programming language. For a new programming language like TypeScript to be supported across all editors it no longer needs to get them to add support one-by-one; it only needs to provide an LSP server and it will automatically be supported across any LSP-supporting editor. The advent of this common protocol has also enabled things that were hard to imagine before. For example specific libraries like Tailwind getting their own LSP implementation to enable bespoke editor functionality. So to improve cross-browser automation we’ve taken a similar approach: developing WebDriver BiDi, which brings the automation featureset previously limited to browser-specific protocols to a standardized protocol that can be implemented by any browser and used by any automation tooling in any programming language. At Mozilla we see this strategy of standardizing protocols in order to remove barriers to entry, allow a diverse ecosystem of interoperable implementations to flourish, and enable users to choose those best suited to their needs as a key part of our manifesto and web vision. For more details about the design of WebDriver BiDi and how it relates to classic WebDriver, please see our earlier posts. Removing experimental CDP support in Firefox As part of our early work on improving cross-browser testing, we shipped a partial implementation of CDP, limited to a few commands and events needed to support testing use cases. This was previously the basis of experimental support for Firefox in Puppeteer. However, once it became clear that this was not the way forward for cross-browser automation, effort on this was stopped. As a result it is unmaintained and doesn’t work with modern Firefox features such as site isolation. Therefore support is scheduled to be removed at the end of 2024. If you are currently using CDP with Firefox, and don’t know how to transition to WebDriver BiDi, please reach out using one of the channels listed at the bottom of this post, and we will discuss your requirements. What’s Next? Although Firefox is now officially supported in Puppeteer, and has enough functionality to cover many automation and testing scenarios, there are still some APIs that remain unsupported. These broadly fall into three categories (consult the Puppeteer documentation for a full list): Highly CDP-specific APIs, notably those in the CDPSession module. These are unlikely to be supported directly, but specific use cases that currently require these APIs could be candidates for standardization. APIs which require further standards work. For example page.accessibility.snapshot returns a dump of the Chromium accessibility tree. However because there’s currently no standardized description of what that tree should look like this is hard to make work in a cross-browser way. There are also cases which are much more straightforward, as they only require work on the WebDriver BiDi spec itself; for example page.setGeolocation. APIs which have a standard but are not yet implemented, for example the ability to execute scripts in workers required for commands like WebWorker.evaluate. We expect to fill these gaps going forward. To help prioritize, we’re interested in your feedback: Please try running your Puppeteer tests in Firefox! If you’re unable to get them in Firefox because of a bug or missing feature, please let us know using one of the methods below so that we can take it into account when planning our future standards and implementation work: Software engineer focused on maintaining a healthy open web. Web-platform-tests core team member. More articles by James Graham… More articles by Henrik Skupin… More articles by Julian Descottes… More articles by Alexandra Borovova…",
  "image": "https://hacks.mozilla.org/wp-content/uploads/2023/12/pptr-fx.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle role=\"article\"\u003e\n    \n\u003cp\u003eWe’re pleased to announce that, as of version 23, the \u003ca href=\"https://pptr.dev/\"\u003ePuppeteer\u003c/a\u003e browser automation library now has first-class support for Firefox. This means that it’s now easy to write automation and perform end-to-end testing using Puppeteer, and run against both Chrome and Firefox.\u003c/p\u003e\n\u003ch2\u003eHow to Use Puppeteer With Firefox\u003c/h2\u003e\n\u003cp\u003eTo get started, simply set the product to “\u003ccode\u003efirefox\u003c/code\u003e” when starting Puppeteer:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport puppeteer from \u0026#34;puppeteer\u0026#34;;\n\nconst browser = await puppeteer.launch({\n  browser: \u0026#34;firefox\u0026#34;\n});\n\nconst page = await browser.newPage();\n// ...\nawait browser.close();\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs with Chrome, Puppeteer is able to download and launch the latest stable version of Firefox, so running against either browser should offer the same developer experience that Puppeteer users have come to expect.\u003c/p\u003e\n\u003cp\u003eWhilst the features offered by Puppeteer won’t be a surprise, bringing support to multiple browsers has been a significant undertaking. The Firefox support is not based on a Firefox-specific automation protocol, but on WebDriver BiDi, a cross browser protocol that’s undergoing standardization at the W3C, and currently has implementation in both Gecko and Chromium. This use of a cross-browser protocol should make it much easier to support many different browsers going forward.\u003c/p\u003e\n\u003cp\u003eLater in this post we’ll dive into some of the more technical background behind WebDriver BiDi. But first we’d like to call out how today’s announcement is a great demonstration of how productive collaboration can advance the state of the art on the web. Developing a new browser automation protocol is a lot of work, and great thanks goes to the Puppeteer team and the other members of the W3C Browser Testing and Tools Working Group, for all their efforts in getting us to this point.\u003c/p\u003e\n\u003cp\u003eYou can also check out the Puppeteer team’s\u003ca href=\"https://developer.chrome.com/blog/firefox-support-in-puppeteer-with-webdriver-bidi\"\u003e post\u003c/a\u003e about making WebDriver BiDi production ready.\u003c/p\u003e\n\u003ch2\u003eKey Features\u003c/h2\u003e\n\u003cp\u003eFor long-time Puppeteer users, the features available are familiar. However for people in other automation and testing ecosystems — particularly those that until recently relied entirely on HTTP-based WebDriver — this section outlines some of the new functionality that WebDriver BiDi makes possible to implement in a cross-browser manner.\u003c/p\u003e\n\u003ch3\u003eCapturing of Log Messages\u003c/h3\u003e\n\u003cp\u003eA common requirement when testing web apps is to ensure that there are no unexpected errors reported to the console. This is also a case where an event-based protocol shines, since it avoids the need to poll the browser for new log messages.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport puppeteer from \u0026#34;puppeteer\u0026#34;;\n\nconst browser = await puppeteer.launch({\n  browser: \u0026#34;firefox\u0026#34;\n});\n\nconst page = await browser.newPage();\npage.on(\u0026#39;console\u0026#39;, msg =\u0026gt; {\n  console.log(`[console] ${msg.type()}: ${msg.text()}`);\n});\n\nawait page.evaluate(() =\u0026gt; console.debug(\u0026#39;Some Info\u0026#39;));\nawait browser.close();\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOutput:\u003c/p\u003e\n\u003cpre\u003e[console] debug: Some Info\u003c/pre\u003e\n\u003ch3\u003eDevice Emulation\u003c/h3\u003e\n\u003cp\u003eOften when testing a reactive layout it’s useful to be able to ensure that the layout works well at multiple screen dimensions, and device pixel ratios. This can be done by using a real mobile browser, either on a device, or on an emulator. However for simplicity it can be useful to perform the testing on a desktop set up to mimic the viewport of a mobile device. The example below shows loading a page with Firefox configured to emulate the viewport size and device pixel ratio of a Pixel 5 phone.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport puppeteer from \u0026#34;puppeteer\u0026#34;;\n\nconst device = puppeteer.KnownDevices[\u0026#34;Pixel 5\u0026#34;];\n\nconst browser = await puppeteer.launch({\n  browser: \u0026#34;firefox\u0026#34;\n});\n\nconst page = await browser.newPage();\nawait page.emulate(device);\n\nconst viewport = page.viewport();\n\nconsole.log(\n  `[emulate] Pixel 5: ${viewport.width}x${viewport.height}` +\n  ` (dpr=${viewport.deviceScaleFactor}, mobile=${viewport.isMobile})`\n);\n\nawait page.goto(\u0026#34;https://www.mozilla.org\u0026#34;);\nawait browser.close();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOutput:\u003c/p\u003e\n\u003cpre\u003e[emulate] Pixel 5: 393x851 (dpr=3, mobile=true)\u003c/pre\u003e\n\u003ch3\u003eNetwork Interception\u003c/h3\u003e\n\u003cp\u003eA common requirement for testing is to be able to track and intercept network requests. Interception is especially useful for avoiding requests to third party services during tests, and providing mock response data. It can also be used to handle HTTP authentication dialogs, and override parts of the request and response, for example adding or removing headers. In the example below we use network request interception to block all requests to web fonts on a page, which might be useful to ensure that these fonts failing to load doesn’t break the site layout.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport puppeteer from \u0026#34;puppeteer\u0026#34;;\n\nconst browser = await puppeteer.launch({\n  browser: \u0026#39;firefox\u0026#39;\n});\n\nconst page = await browser.newPage();\nawait page.setRequestInterception(true);\n\npage.on(\u0026#34;request\u0026#34;, request =\u0026gt; {\n  if (request.url().includes(\u0026#34;.woff2\u0026#34;)) {\n    // Block requests to custom user fonts.\n    console.log(`[intercept] Request aborted: ${request.url()}`);\n    request.abort();\n  } else {\n    request.continue();\n  }\n});\n\nconst response = await page.goto(\u0026#34;https://support.mozilla.org\u0026#34;);\nconsole.log(\n  `[navigate] status=${response.status()} url=${response.url()}`\n);\nawait browser.close();\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOutput:\u003c/p\u003e\n\u003cpre\u003e[intercept] Request aborted: https://assets-prod.sumo.prod.webservices.mozgcp.net/static/Inter-Bold.3717db0be15085ac.woff2\n[navigate] status=200 url=https://support.mozilla.org/en-US/\n\u003c/pre\u003e\n\u003ch3\u003ePreload Scripts\u003c/h3\u003e\n\u003cp\u003eOften automation tooling wants to provide custom functionality that can be implemented in JavaScript. Whilst WebDriver has always allowed injecting scripts, it wasn’t possible to ensure that an injected script was always run before the page started loading, making it impossible to avoid races between the page scripts and the injected script.\u003c/p\u003e\n\u003cp\u003eWebDriver BiDi provides “preload” scripts which can be run before a page is loaded. It also provides a means to emit custom events from scripts. This can be used, for example, to avoid polling for expected elements, but instead using a mutation observer that fires as soon as the element is available. In the example below we wait for the \u0026lt;title\u0026gt; element to appear on the page, and log its contents.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport puppeteer from \u0026#34;puppeteer\u0026#34;;\n\nconst browser = await puppeteer.launch({\n  browser: \u0026#39;firefox\u0026#39;,\n});\n\nconst page = await browser.newPage();\n\nconst gotMessage = new Promise(resolve =\u0026gt;\n  page.exposeFunction(\u0026#34;sendMessage\u0026#34;, async message =\u0026gt; {\n    console.log(`[script] Message from pre-load script: ${message}`);\n    resolve();\n  })\n);\n\nawait page.evaluateOnNewDocument(() =\u0026gt; {\n  const observer = new MutationObserver(mutationList =\u0026gt; {\n    for (const mutation of mutationList) {\n      if (mutation.type === \u0026#34;childList\u0026#34;) {\n        for (const node of mutation.addedNodes) {\n          if (node.tagName === \u0026#34;TITLE\u0026#34;) {\n            sendMessage(node.textContent);\n          }\n        }\n      }\n    };\n  });\n\n  observer.observe(document.documentElement, {\n    subtree: true,\n    childList: true,\n  });\n});\n\nawait page.goto(\u0026#34;https://support.mozilla.org\u0026#34;);\nawait gotMessage;\nawait browser.close();\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOutput:\u003c/p\u003e\n\u003cpre\u003e[script] Message from pre-load script: Mozilla Support\u003c/pre\u003e\n\u003ch2\u003eTechnical Background\u003c/h2\u003e\n\u003cp\u003eUntil recently people wishing to automate browsers had two main choices:\u003c/p\u003e\n\u003cul\u003e\n\u003cli aria-level=\"1\"\u003eUse the W3C \u003ca href=\"https://w3c.github.io/webdriver/\"\u003eWebDriver\u003c/a\u003e API, which was based on earlier work by the Selenium project.\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003eUse a browser-specific API for talking to each supported browser such as \u003ca href=\"https://chromedevtools.github.io/devtools-protocol/\"\u003eChrome DevTools Protocol\u003c/a\u003e (CDP) for Chromium-based browsers, or Firefox’s \u003ca href=\"https://firefox-source-docs.mozilla.org/devtools/backend/protocol.html\"\u003eRemote Debugging Protocol\u003c/a\u003e (RDP) for Gecko-based browsers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUnfortunately both of those options come with significant tradeoffs. The “classic” WebDriver API is HTTP-based, and its model involves automation sending a command to the browser and waiting for a response. That works well for automation scenarios where you load a page and then verify, for example, that some element is displayed, but the inability to get events — e.g. console logs — back from the browser, or run multiple commands concurrently, makes the API a poor fit for more advanced use cases.\u003c/p\u003e\n\u003cp\u003eBy contrast, browser-specific APIs have generally been designed around supporting the complex use cases of in-browser devtools. This has given them a feature set far in advance of what’s possible using WebDriver, as they need to support use cases such as recording console logs, or network requests.\u003c/p\u003e\n\u003cp\u003eTherefore, browser automation clients have been forced to make the choice between supporting many browsers using a single protocol and providing a limited feature set, or providing a richer feature set but having to implement multiple protocols to provide functionality separately for each supported browser. This obviously increased the cost and complexity of creating great cross-browser automation, which isn’t a good situation, especially when developers \u003ca href=\"https://mdn.dev/archives/insights/reports/mdn-web-testing-report-2021.html\"\u003ecommonly cite\u003c/a\u003e cross-browser testing as one the main pain points in developing for the web.\u003c/p\u003e\n\u003cp\u003eLong time developers might notice the analogy here to the situation with editors before the development of \u003ca href=\"https://microsoft.github.io/language-server-protocol/\"\u003eLanguage Server Protocol\u003c/a\u003e (LSP). At that time each text editor or IDE had to implement bespoke support for each different programming language. That made it hard to get support for a new language into all the tools that developers were using. The advent of LSP changed that by providing a common protocol that could be supported by any combination of editor and programming language. For a new programming language like TypeScript to be supported across all editors it no longer needs to get them to add support one-by-one; it only needs to provide an LSP server and it will automatically be supported across any LSP-supporting editor. The advent of this common protocol has also enabled things that were hard to imagine before. For example specific libraries like Tailwind getting their own \u003ca href=\"https://www.npmjs.com/package/@tailwindcss/language-server\"\u003eLSP implementation\u003c/a\u003e to enable bespoke editor functionality.\u003c/p\u003e\n\u003cp\u003eSo to improve cross-browser automation we’ve taken a similar approach: developing \u003ca href=\"https://w3c.github.io/webdriver-bidi/\"\u003eWebDriver BiDi\u003c/a\u003e, which brings the automation featureset previously limited to browser-specific protocols to a standardized protocol that can be implemented by any browser and used by any automation tooling in any programming language.\u003c/p\u003e\n\u003cp\u003eAt Mozilla we see this strategy of standardizing protocols in order to remove barriers to entry, allow a diverse ecosystem of interoperable implementations to flourish, and enable users to choose those best suited to their needs as a key part of our manifesto and \u003ca href=\"https://www.mozilla.org/en-US/about/webvision/full/#openness\"\u003eweb vision\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFor more details about the design of WebDriver BiDi and how it relates to classic WebDriver, please see our \u003ca href=\"https://hacks.mozilla.org/2020/12/cross-browser-testing-part-1-web-app-testing-today/\"\u003eearlier\u003c/a\u003e \u003ca href=\"https://hacks.mozilla.org/2021/01/improving-cross-browser-testing-part-2-new-automation-features-in-firefox-nightly/\"\u003eposts\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eRemoving experimental CDP support in Firefox\u003c/h2\u003e\n\u003cp\u003eAs part of our early work on improving cross-browser testing, we shipped a partial implementation of CDP, limited to a few commands and events needed to support testing use cases. This was previously the basis of experimental support for Firefox in Puppeteer. However, once it became clear that this was not the way forward for cross-browser automation, effort on this was stopped. As a result it is unmaintained and doesn’t work with modern Firefox features such as site isolation. Therefore support is \u003ca href=\"https://fxdx.dev/deprecating-cdp-support-in-firefox-embracing-the-future-with-webdriver-bidi/\"\u003escheduled to be removed\u003c/a\u003e at the end of 2024.\u003c/p\u003e\n\u003cp\u003eIf you are currently using CDP with Firefox, and don’t know how to transition to WebDriver BiDi, please reach out using one of the \u003ca href=\"#contact-us\"\u003echannels listed at the bottom of this post\u003c/a\u003e, and we will discuss your requirements.\u003c/p\u003e\n\u003ch2\u003eWhat’s Next?\u003c/h2\u003e\n\u003cp\u003eAlthough Firefox is now officially supported in Puppeteer, and has enough functionality to cover many automation and testing scenarios, there are still some APIs that remain unsupported. These broadly fall into three categories (consult the \u003ca href=\"https://pptr.dev/webdriver-bidi\"\u003ePuppeteer documentation\u003c/a\u003e for a full list):\u003c/p\u003e\n\u003cul\u003e\n\u003cli aria-level=\"1\"\u003eHighly CDP-specific APIs, notably those in the \u003ca href=\"https://pptr.dev/api/puppeteer.cdpsession\"\u003eCDPSession\u003c/a\u003e module. These are unlikely to be supported directly, but specific use cases that currently require these APIs could be candidates for standardization.\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003eAPIs which require further standards work. For example \u003ca href=\"https://pptr.dev/api/puppeteer.accessibility.snapshot\"\u003epage.accessibility.snapshot\u003c/a\u003e returns a dump of the Chromium accessibility tree. However because there’s currently no standardized description of what that tree should look like this is hard to make work in a cross-browser way. There are also cases which are much more straightforward, as they only require work on the WebDriver BiDi spec itself; for example \u003ca href=\"https://pptr.dev/api/puppeteer.page.setgeolocation\"\u003epage.setGeolocation\u003c/a\u003e.\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003eAPIs which have a standard but are not yet implemented, for example the ability to execute scripts in workers required for commands like \u003ca href=\"https://pptr.dev/api/puppeteer.webworker.evaluate\"\u003eWebWorker.evaluate\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe expect to fill these gaps going forward. To help prioritize, we’re interested in your feedback: Please try running your Puppeteer tests in Firefox! If you’re unable to get them in Firefox because of a bug or missing feature, please let us know using one of the methods below so that we can take it into account when planning our future standards and implementation work:\u003c/p\u003e\n\n    \u003csection\u003e\n                                \n                      \u003cp\u003eSoftware engineer focused on maintaining a healthy open web. Web-platform-tests core team member.\u003c/p\u003e\n                                \u003cp\u003e\u003ca href=\"https://hacks.mozilla.org/author/jgrahammozilla-com/\"\u003eMore articles by James Graham…\u003c/a\u003e\u003c/p\u003e\n                  \n                                \u003cp\u003e\u003ca href=\"https://hacks.mozilla.org/author/hskupinmozilla-com/\"\u003eMore articles by Henrik Skupin…\u003c/a\u003e\u003c/p\u003e\n                  \n                                \u003cp\u003e\u003ca href=\"https://hacks.mozilla.org/author/jdescottesmozilla-com/\"\u003eMore articles by Julian Descottes…\u003c/a\u003e\u003c/p\u003e\n                  \n                                \u003cp\u003e\u003ca href=\"https://hacks.mozilla.org/author/aborovovamozilla-com/\"\u003eMore articles by Alexandra Borovova…\u003c/a\u003e\u003c/p\u003e\n                  \u003c/section\u003e\n  \u003c/article\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
