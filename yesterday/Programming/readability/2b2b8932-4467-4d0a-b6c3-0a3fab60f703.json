{
  "id": "2b2b8932-4467-4d0a-b6c3-0a3fab60f703",
  "title": "Faster Time-to-Code in IntelliJ IDEA",
  "link": "https://blog.jetbrains.com/idea/2024/11/faster-time-to-code-in-intellij-idea/",
  "description": "IntelliJ IDEA’s power and wide range of functionality can make it somewhat resource-hungry. Depending on the project you’re working with, the IDE has been known to lag, which can naturally be frustrating. Perhaps the most common scenario in which developers are required to wait is when opening a project. IntelliJ IDEA needs to load and […]",
  "author": "Dmitriy Smirnov",
  "published": "Thu, 14 Nov 2024 14:57:03 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "idea",
    "news",
    "indexing",
    "intellij-idea"
  ],
  "byline": "",
  "length": 10969,
  "excerpt": "IntelliJ IDEA’s power and wide range of functionality can make it somewhat resource-hungry. Depending on the project you’re working with, the IDE has been known to lag, which can naturally be frustrat",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA – the Leading Java and Kotlin IDE, by JetBrains IntelliJ IDEA NewsFaster Time-to-Code in IntelliJ IDEA IntelliJ IDEA’s power and wide range of functionality can make it somewhat resource-hungry. Depending on the project you’re working with, the IDE has been known to lag, which can naturally be frustrating. Perhaps the most common scenario in which developers are required to wait is when opening a project. IntelliJ IDEA needs to load and synchronize the project, perform indexing, and do a lot of other small things to enable all the useful features it has. In this post, we’ll look at the steps we’ve taken to improve performance in newer versions of IntelliJ IDEA, reducing time-to-code and making the IDE more responsive right from startup. Our mission: improve time-to-code If you take a look at an IntelliJ IDEA version from before 2023.2, the IDE had to wait for the full sync of your project’s Maven or Gradle project model before it could even start indexing. Then, while waiting for indexing to finish, all the smart features of the IDE, including code highlighting and navigation, were disabled. Only after indexing was complete could they be used. Here’s a schematic representation of components involved: The time it took to synchronize and index projects increased the larger the projects got. While this was to be expected, as huge projects are more complex for the IDE to work with, waiting several minutes before being able to start working was still tedious. Unfortunately, with so many steps to perform while loading a project, significant time could be spent even on smaller ones, resulting in the perception that IntelliJ IDEA was performing slowly. Nobody likes having to wait, especially when you’re thinking about the work you want to dive into. That’s why we made improving this situation a high-priority task. To gauge our progress, we decided to track what we call time-to-code – the time between the application starting or the project opening and the moment when it becomes possible to comfortably work with code in it. Our goal was simply to reduce time-to-code as much as possible. Improving the project opening flow and experience The problem of improving startup and project opening in IntelliJ IDEA is actually complex, as it depends on several components and their interconnection. This complexity has an advantage, however, as it allows us to approach the problem from multiple angles. While we wait for longer-term efforts on technical improvements to bear fruit, we’ve also been able to adjust IntelliJ IDEA’s approach to indexing for significant time-to-code benefits that can already be experienced. Technical improvements One obvious approach to reducing time-to-code is performing technical updates to improve the IDE’s performance – optimizing code and architecture, using better hardware, parallelizing, etc. IntelliJ IDEA is more than 20 years old, and some architectural and algorithmic decisions made in the early days are still present in the product.  Work is being done here. We’ve invested a lot of effort into proper monitoring, investigating, and optimizing performance bottlenecks, and this has already delivered some noticeable results. We’ve improved the application’s startup Application Performance Index (Apdex) to the top category with a score of 0.94, improved the speed of multi-threaded indexing by 25%, and got rid of unnecessary locks during parallel indexing, reducing the time other threads have to wait for such locks to become available. But this is going to be a long journey, as refactorings can have consequences for other subsystems in the IDE and need to be evaluated carefully over a longer time. For more details about technical performance improvements, check out this great talk by Yuri Artamonov, and stay tuned for more articles. While we worked on the technical side, we also decided to take a different approach, addressing the perceived performance of the IDE.  Phased sync indexing The IDE does not necessarily need to be technically improved in order for users to experience it as faster. As long as they are able to start working sooner, they will perceive a performance improvement. From our research, we know that a lot of users think that the IDE is ready for work when they can see the project structure and proper code highlighting. So that is where we concentrated our efforts. The IDE has to perform several crucial steps before highlighting and navigation can work, but we wondered whether these steps really need to run in series, sequentially. Some promising experiments in version 2023.3 showed that splitting the process of syncing and indexing into several stages and running them in an asynchronous manner allowed users to get to their code much faster. So as a first step, we made IntelliJ IDEA start indexing the files in the project directory before it actually gets the project model from the underlying build tool like Gradle or Maven. The downside of this was that unnecessary files got indexed, and after synchronizing with the build tool, reindexing was required. Nevertheless, the overall time-to-code (including both the sync and the full indexing) decreased significantly, becoming up to 1.5 times faster on big projects, according to our test suite. Without the project model loaded, however, it was not possible to properly build relationships between parts of the project, show the correct project tree, highlight, or provide navigation. To address this problem, we implemented what we call phased sync. Instead of requesting the full project model from the build tool all at once, we had the IDE get the model in phases. Currently, there are two. Phase 1: Skip resolving dependencies In the first phase, which happens as early in the project-loading process as possible, IntelliJ IDEA does not resolve dependencies or connect to the internet. It simply provides a model that’s accurate enough to allow the IDE to show the project tree, index the most necessary parts of the project, and provide some essential smart features.  Obviously, some dependencies might still be missing after this phase, causing resolution problems and cases where code gets marked red even if it is correct. The IDE is actually aware of these false positive errors, and it addresses them at the level of individual language support by suppressing errors that are caused by missing dependencies. It is also able to properly handle navigation attempts with respective messages. Since version 2024.2, this error suppression has worked for Java, and in 2024.3, the support was extended to Kotlin. This first phase is especially fast in Maven because its static pom.xml configuration files can be parsed by the IDE without launching Maven, while still providing enough knowledge to build a very accurate model. For Gradle, which is dynamic by nature and very flexible in its scripts, IntelliJ IDEA cannot parse scripts on its own at the moment – meaning it has to run the Gradle daemon. We sped up this process by only requesting sourceSets, the required language level, and other basic information from Gradle. However, with the Declarative Gradle initiative, we may be able to improve this dramatically in the future. Phase 2: Download and resolve dependencies During the second phase, IntelliJ IDEA downloads all plugins and dependencies, properly resolves all configurations, and provides a fully accurate model for the IDE to work with. Indexes are then updated based on the full model. With this two-phase approach, you get an almost fully functional version of IntelliJ IDEA much faster, while dependencies are still downloaded and resolved. As an additional improvement, we’ve made it possible for a lot of features to work while indexes are not yet ready, further decreasing time-to-code. The most important ones are code highlighting within individual files, partial code resolution, and run configurations. Of course, having the underlying index ready makes these operations even faster, but they work reliably even with only partial indexes. The result From a bird’s eye view, the entire process now looks like this:  How do we know it was worth it? Depending on the project, time-to-code (or, more precisely, time before full highlighting in the schema above) in our test suite is up to several times faster the first time a project is opened. Here is an example showing how fast the project tree is displayed and highlighting is enabled in a project where it used to take tens of seconds to access these features. Surveys show that around 30% of our users think IntelliJ IDEA 2024.2 allows them to get started with coding faster than before. What’s next? While not all of IntelliJ IDEA’s features are available while indexing a project, the two-phased syncing approach has definitely sped up overall startup performance, giving you a faster time-to-code. Additionally, we’ve made many actions compatible with having no index or only a partial one available. And in the version 2024.2, around 10% of our users do actually write code before the entire sync and indexing process finishes. But we’re not done yet. Our aim now is to improve phased syncing, especially with Gradle, to improve time-to-code even further. We’re also updating the UX of working with your project while dependencies have not yet been resolved.In the meantime, we hope you enjoy the fruits of the labor we put in improving time-to-code. Download the latest version of IntelliJ IDEA and let us know what you think! Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2024/11/ij-social_share_blog_1280x720_en-6.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA – the Leading Java and Kotlin IDE, by JetBrains\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/category/idea/\"\u003eIntelliJ IDEA\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/idea/category/news/\"\u003eNews\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eFaster Time-to-Code in IntelliJ IDEA\u003c/h2\u003e                    \u003cdiv\u003e\n                            \u003cp\u003e\u003cimg src=\"https://secure.gravatar.com/avatar/fd760d218f46441a1c7e3c88c0f09157?s=200\u0026amp;r=g\" width=\"200\" height=\"200\" alt=\"Dmitriy Smirnov\" loading=\"lazy\"/\u003e\n                                                                                                                    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2023/09/maarten-2020-800x800-1-200x200.jpg\" width=\"200\" height=\"200\" alt=\"Maarten Balliauw\" loading=\"lazy\"/\u003e\n                                                                                                \u003c/p\u003e\n                            \n                        \u003c/div\u003e\n                    \n\u003cp\u003eIntelliJ IDEA’s power and wide range of functionality can make it somewhat resource-hungry. Depending on the project you’re working with, the IDE has been known to lag, which can naturally be frustrating.\u003c/p\u003e\n\n\n\n\u003cp\u003ePerhaps the most common scenario in which developers are required to wait is when opening a project. IntelliJ IDEA needs to load and synchronize the project, perform indexing, and do a lot of other small things to enable all the useful features it has.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this post, we’ll look at the steps we’ve taken to improve performance in newer versions of IntelliJ IDEA, reducing time-to-code and making the IDE more responsive right from startup.\u003c/p\u003e\n\n\n    \n\n\n\n\n\n\n\n\u003ch2\u003eOur mission: improve time-to-code\u003c/h2\u003e\n\n\n\n\u003cp\u003eIf you take a look at an IntelliJ IDEA version from before 2023.2, the IDE had to wait for the full sync of your project’s Maven or Gradle project model before it could even start indexing. Then, while waiting for indexing to finish, all the smart features of the IDE, including code highlighting and navigation, were disabled. Only after indexing was complete could they be used.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere’s a schematic representation of components involved:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1231\" height=\"811\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/image-18.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe time it took to synchronize and index projects increased the larger the projects got. While this was to be expected, as huge projects are more complex for the IDE to work with, waiting several minutes before being able to start working was still tedious.\u003c/p\u003e\n\n\n\n\u003cp\u003eUnfortunately, with so many steps to perform while loading a project, significant time could be spent even on smaller ones, resulting in the perception that IntelliJ IDEA was performing slowly.\u003c/p\u003e\n\n\n\n\u003cp\u003eNobody likes having to wait, especially when you’re thinking about the work you want to dive into. That’s why we made improving this situation a high-priority task.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo gauge our progress, we decided to track what we call time-to-code – the time between the application starting or the project opening and the moment when it becomes possible to comfortably work with code in it. Our goal was simply to reduce time-to-code as much as possible.\u003c/p\u003e\n\n\n\n\u003ch2\u003eImproving the project opening flow and experience\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe problem of improving startup and project opening in IntelliJ IDEA is actually complex, as it depends on several components and their interconnection. This complexity has an advantage, however, as it allows us to approach the problem from multiple angles. While we wait for longer-term efforts on technical improvements to bear fruit, we’ve also been able to adjust IntelliJ IDEA’s approach to indexing for significant time-to-code benefits that can already be experienced.\u003c/p\u003e\n\n\n\n\u003ch3\u003eTechnical improvements\u003c/h3\u003e\n\n\n\n\u003cp\u003eOne obvious approach to reducing time-to-code is performing technical updates to improve the IDE’s performance – optimizing code and architecture, using better hardware, parallelizing, etc. IntelliJ IDEA is more than 20 years old, and some architectural and algorithmic decisions made in the early days are still present in the product. \u003c/p\u003e\n\n\n\n\u003cp\u003eWork is being done here. We’ve invested a lot of effort into proper monitoring, investigating, and optimizing performance bottlenecks, and this has already delivered some noticeable results. We’ve improved the application’s startup Application Performance Index (Apdex) to the top category with a score of 0.94, improved the speed of multi-threaded indexing by 25%, and got rid of unnecessary locks during parallel indexing, reducing the time other threads have to wait for such locks to become available. But this is going to be a long journey, as refactorings can have consequences for other subsystems in the IDE and need to be evaluated carefully over a longer time. For more details about technical performance improvements, check out this \u003ca href=\"https://www.youtube.com/watch?v=oG9iYkZQpcw\u0026amp;t\" target=\"_blank\" rel=\"noopener\"\u003egreat talk by Yuri Artamonov\u003c/a\u003e, and stay tuned for more articles.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhile we worked on the technical side, we also decided to take a different approach, addressing the perceived performance of the IDE. \u003c/p\u003e\n\n\n\n\u003ch3\u003ePhased sync indexing\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe IDE does not necessarily need to be technically improved in order for users to experience it as faster. As long as they are able to start working sooner, they will perceive a performance improvement. From our research, we know that a lot of users think that the IDE is ready for work when they can see the project structure and proper code highlighting. So that is where we concentrated our efforts.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe IDE has to perform several crucial steps before highlighting and navigation can work, but we wondered whether these steps really need to run in series, sequentially.\u003c/p\u003e\n\n\n\n\u003cp\u003eSome promising experiments in version 2023.3 showed that splitting the process of syncing and indexing into several stages and running them in an asynchronous manner allowed users to get to their code much faster.\u003c/p\u003e\n\n\n\n\u003cp\u003eSo as a first step, we made IntelliJ IDEA start indexing the files in the project directory before it actually gets the project model from the underlying build tool like Gradle or Maven. The downside of this was that unnecessary files got indexed, and after synchronizing with the build tool, reindexing was required. Nevertheless, the overall time-to-code (including both the sync and the full indexing) decreased significantly, becoming up to 1.5 times faster on big projects, according to our test suite.\u003c/p\u003e\n\n\n\n\u003cp\u003eWithout the project model loaded, however, it was not possible to properly build relationships between parts of the project, show the correct project tree, highlight, or provide navigation.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo address this problem, we implemented what we call \u003cem\u003ephased sync\u003c/em\u003e. Instead of requesting the full project model from the build tool all at once, we had the IDE get the model in phases. Currently, there are two. \u003c/p\u003e\n\n\n\n\u003ch4\u003ePhase 1: Skip resolving dependencies\u003c/h4\u003e\n\n\n\n\u003cp\u003eIn the first phase, which happens as early in the project-loading process as possible, IntelliJ IDEA does not resolve dependencies or connect to the internet. It simply provides a model that’s accurate enough to allow the IDE to show the project tree, index the most necessary parts of the project, and provide some essential smart features. \u003c/p\u003e\n\n\n\n\u003cp\u003eObviously, some dependencies might still be missing after this phase, causing resolution problems and cases where code gets marked red even if it is correct. The IDE is actually aware of these false positive errors, and it addresses them at the level of individual language support by suppressing errors that are caused by missing dependencies. It is also able to properly handle navigation attempts with respective messages. Since version 2024.2, this error suppression has worked for Java, and in 2024.3, the support was extended to Kotlin.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis first phase is especially fast in Maven because its static pom.xml configuration files can be parsed by the IDE without launching Maven, while still providing enough knowledge to build a very accurate model.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor Gradle, which is dynamic by nature and very flexible in its scripts, IntelliJ IDEA cannot parse scripts on its own at the moment – meaning it has to run the Gradle daemon. We sped up this process by only requesting sourceSets, the required language level, and other basic information from Gradle. However, with the \u003ca href=\"https://blog.gradle.org/declarative-gradle-first-eap\" target=\"_blank\" rel=\"noopener\"\u003eDeclarative Gradle\u003c/a\u003e initiative, we may be able to improve this dramatically in the future.\u003c/p\u003e\n\n\n\n\u003ch4\u003ePhase 2: Download and resolve dependencies\u003c/h4\u003e\n\n\n\n\u003cp\u003eDuring the second phase, IntelliJ IDEA downloads all plugins and dependencies, properly resolves all configurations, and provides a fully accurate model for the IDE to work with. Indexes are then updated based on the full model.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith this two-phase approach, you get an almost fully functional version of IntelliJ IDEA much faster, while dependencies are still downloaded and resolved.\u003c/p\u003e\n\n\n\n\u003cp\u003eAs an additional improvement, we’ve made it possible for a lot of features to work while indexes are not yet ready, further decreasing time-to-code. The most important ones are code highlighting within individual files, partial code resolution, and run configurations. Of course, having the underlying index ready makes these operations even faster, but they work reliably even with only partial indexes.\u003c/p\u003e\n\n\n\n\u003ch2\u003eThe result\u003c/h2\u003e\n\n\n\n\u003cp\u003eFrom a bird’s eye view, the entire process now looks like this: \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"2023\" height=\"494\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/image-16.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eHow do we know it was worth it?\u003c/p\u003e\n\n\n\n\u003cp\u003eDepending on the project, time-to-code (or, more precisely, time before full highlighting in the schema above) in our test suite is up to several times faster the first time a project is opened.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is an example showing how fast the project tree is displayed and highlighting is enabled in a project where it used to take tens of seconds to access these features.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1500\" height=\"600\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/image-1.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eSurveys show that around 30% of our users think IntelliJ IDEA 2024.2 allows them to get started with coding faster than before.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhat’s next?\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhile not all of IntelliJ IDEA’s features are available while indexing a project, the two-phased syncing approach has definitely sped up overall startup performance, giving you a faster time-to-code. Additionally, we’ve made many actions compatible with having no index or only a partial one available. And in the version 2024.2, around 10% of our users do actually write code before the entire sync and indexing process finishes. But we’re not done yet.\u003c/p\u003e\n\n\n\n\u003cp\u003eOur aim now is to improve phased syncing, especially with Gradle, to improve time-to-code even further. We’re also updating the UX of working with your project while dependencies have not yet been resolved.\u003cbr/\u003eIn the meantime, we hope you enjoy the fruits of the labor we put in improving time-to-code. \u003ca href=\"https://www.jetbrains.com/idea/\" target=\"_blank\" rel=\"noopener\"\u003eDownload the latest version of IntelliJ IDEA\u003c/a\u003e and let us know what you think!\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": null,
  "modifiedTime": null
}
