{
  "id": "7910dfae-59fe-4990-9cca-812d533699c3",
  "title": "How Uber Sped Up SQL-based Data Analytics with Presto and Express Queries",
  "link": "https://www.infoq.com/news/2024/11/uber-presto-express/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "Uber uses Presto, an open-source distributed SQL query engine, to provide analytics across several data sources, including Apache Hive, Apache Pinot, MySQL, and Apache Kafka. To improve its performance, Uber engineers explored the advantages of dealing with quick queries, a.k.a. express queries, in a specific way and found they could improve both Presto utilization and response times. By Sergio De Simone",
  "author": "Sergio De Simone",
  "published": "Mon, 18 Nov 2024 16:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Performance \u0026 Scalability",
    "SQL",
    "Data Analytics",
    "Development",
    "AI, ML \u0026 Data Engineering",
    "Architecture \u0026 Design",
    "news"
  ],
  "byline": "Sergio De Simone",
  "length": 3802,
  "excerpt": "Uber uses Presto, an open-source distributed SQL query engine, to provide analytics across several data sources, including Apache Hive, Apache Pinot, MySQL, and Apache Kafka. To improve its performanc",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s2_20241112123203/apple-touch-icon.png",
  "text": "Uber uses Presto, an open-source distributed SQL query engine, to provide analytics across several data sources, including Apache Hive, Apache Pinot, MySQL, and Apache Kafka. To improve its performance, Uber engineers explored the advantages of dealing with quick queries, a.k.a. express queries, in a specific way and found they could improve both Presto utilization and response times. Express queries, i.e. queries that execute in under two minutes, amounted to about half the total queries Uber analytics process. Engineers at Uber found out that handling them just as the rest of queries caused underutilization and high latency due to them being throttled to avoid overloading the system. To prevent express queries from being throttled, the first step was to predict when an incoming query is an express queries. Uber engineers based this prediction on historical data where each query was assigned an exact fingerprint, that is, a unique hash calculated after removing comments, whitespaces, and any literal values. We tested the P90 and P95 query execution times using the exact fingerprint and abstract fingerprint of the query with lookback windows of 2 days, 5 days, and 7 days. [...] We used this candidate definition to predict if a query was express: if the X runtime of the query in the last Y days based on Z fingerprint was less than 2 minutes. Using this definition, Uber engineers found that the P90 value of the abstract fingerprint with a 5-day lookback window provided the best accuracy and coverage to predict which queries would complete in less than two minutes. They also kept enough data in the table used to look up if an incoming query is an express query to be able to change to a different percentile and/or larger or smaller lookback window. While this idea seemed straightforward, its design and implementation went through a couple of iterations, moving from the idea of introducing express-query handling as late as possible in the system pipeline to handling them as early as possible. In their first design, Uber engineers decided to queue up express and non-express queries in the same queues based on their user-priority. That means, all queries, either express or non express, went to the queue corresponding to their user-priority, e.g., batch or interactive. Each queue had its own designated Presto cluster, with a subset of it dedicated to handle express queries after all user/source and cluster limits checks were carried through. This design led to underutilizing the express Presto clusters, basically because of mixing slow and express queries in the same queues, which made slow queries still dictate the pace at which express queries reached express clusters. As a second attempt at designing the system, Uber engineers tried to use a dedicated queue for express queries, which were routed as soon as entering the system after the validation step. So, express queries had a direct, faster path to the designated express clusters, bringing an order-of-magnitude improvement in end-to-end SLA for over 75% of scheduled queries. While this approach improved cluster utilization and running time for express queries, Uber engineers are considering how to improve it even more. In fact, running this design in production showed that express query handling is so fast that it is not necessary to route express queries across different queues based on their priority. This made Uber engineers start to work on a further evolution of their design were express queries have a completely dedicated subsystem, which promises to further increase cluster utilization and simplify routing logic. About the Author Sergio De Simone",
  "image": "https://res.infoq.com/news/2024/11/uber-presto-express/en/headerimage/uber-presto-express-1731943236007.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eUber uses \u003ca href=\"https://prestodb.io\"\u003ePresto\u003c/a\u003e, an open-source distributed SQL query engine, to provide analytics across several data sources, including Apache Hive, Apache Pinot, MySQL, and Apache Kafka. To improve its performance, \u003ca href=\"https://www.uber.com/en-AU/blog/presto-express/\"\u003eUber engineers explored the advantages of dealing with quick queries, a.k.a. \u003cem\u003eexpress queries\u003c/em\u003e, in a specific way\u003c/a\u003e and found they could improve both Presto utilization and response times.\u003c/p\u003e\n\n\u003cp\u003eExpress queries, i.e. queries that execute in under two minutes, amounted to about half the total queries Uber analytics process. Engineers at Uber found out that handling them just as the rest of queries caused underutilization and high latency due to them being throttled to avoid overloading the system.\u003c/p\u003e\n\n\u003cp\u003eTo prevent express queries from being throttled, the first step was to predict when an incoming query is an express queries. Uber engineers based this prediction on historical data where each query was assigned an \u003cem\u003eexact fingerprint\u003c/em\u003e, that is, a unique hash calculated after removing comments, whitespaces, and any literal values.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eWe tested the P90 and P95 query execution times using the exact fingerprint and abstract fingerprint of the query with lookback windows of 2 days, 5 days, and 7 days. [...] We used this candidate definition to predict if a query was express: if the X runtime of the query in the last Y days based on Z fingerprint was less than 2 minutes.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eUsing this definition, Uber engineers found that the P90 value of the abstract fingerprint with a 5-day lookback window provided the best accuracy and coverage to predict which queries would complete in less than two minutes. They also kept enough data in the table used to look up if an incoming query is an express query to be able to change to a different percentile and/or larger or smaller lookback window.\u003c/p\u003e\n\n\u003cp\u003eWhile this idea seemed straightforward, its design and implementation went through a couple of iterations, moving from the idea of introducing express-query handling as late as possible in the system pipeline to handling them as early as possible.\u003c/p\u003e\n\n\u003cp\u003eIn their first design, Uber engineers decided to queue up express and non-express queries in the same queues based on their user-priority. That means, all queries, either express or non express, went to the queue corresponding to their user-priority, e.g., batch or interactive. Each queue had its own designated Presto cluster, with a subset of it dedicated to handle express queries after all user/source and cluster limits checks were carried through.\u003c/p\u003e\n\n\u003cp\u003eThis design led to underutilizing the express Presto clusters, basically because of mixing slow and express queries in the same queues, which made slow queries still dictate the pace at which express queries reached express clusters.\u003c/p\u003e\n\n\u003cp\u003eAs a second attempt at designing the system, Uber engineers tried to use a dedicated queue for express queries, which were routed as soon as entering the system after the validation step. So, express queries had a direct, faster path to the designated express clusters, bringing an order-of-magnitude improvement in end-to-end SLA for over 75% of scheduled queries.\u003c/p\u003e\n\n\u003cp\u003eWhile this approach improved cluster utilization and running time for express queries, Uber engineers are considering how to improve it even more. In fact, running this design in production showed that express query handling is so fast that it is not necessary to route express queries across different queues based on their priority.\u003c/p\u003e\n\n\u003cp\u003eThis made Uber engineers start to work on a further evolution of their design were express queries have a completely dedicated subsystem, which promises to further increase cluster utilization and simplify routing logic.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Sergio-De-Simone\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eSergio De Simone\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2024-11-18T00:00:00Z",
  "modifiedTime": null
}
