{
  "id": "a293dec7-0f1c-4367-8413-42ab292d85b4",
  "title": "4 ways to accelerate embedded development with GitLab",
  "link": "https://about.gitlab.com/blog/2025/06/05/4-ways-to-accelerate-embedded-development-with-gitlab",
  "description": "",
  "author": "Darwin Sanoy",
  "published": "2025-06-05T00:00:00.000Z",
  "source": "https://about.gitlab.com/atom.xml",
  "categories": null,
  "byline": "Darwin Sanoy, Matt DeLaney",
  "length": 13154,
  "excerpt": "Learn how automated hardware testing, standard builds, collaborative workflows, and integrated compliance eliminate bottlenecks in firmware development.",
  "siteName": "GitLab",
  "favicon": "https://about.gitlab.com/blog/nuxt-images/ico/favicon-192x192.png?cache=2022041",
  "text": "Software in embedded systems is no longer just a part number — it's a critical differentiator. This shift has led to enormous complexity in the firmware running in our cars, airplanes, and industrial machines. The number of lines of code in the average car is expected to reach 650 million by the end of 2025, up from 200 million just five years ago. In aerospace systems, the complexity of embedded software has nearly doubled every four years for the last several decades. Traditional embedded development approaches cannot effectively handle the software challenges of modern machines. This shortcoming slows engineers down, in part, by exacerbating challenges such as: Hardware testing bottlenecks Inconsistent build environments Siloed development practices Manual functional safety compliance processes Embedded developers need a new approach to deal with the rapid increase in code. In this article, we’ll explain four ways you can use the GitLab AI-native DevSecOps platform to shorten feedback loops, work collaboratively and iteratively, and streamline compliance. Challenge 1: Hardware testing bottlenecks Unlike enterprise software that can run on virtually any cloud server, embedded automotive software must be tested on specialized hardware that precisely matches production environments. Traditional hardware-in-the-loop (HIL) testing processes often follow this pattern: Developers write code for an embedded system (e.g., an electronic control unit) They request access to limited, expensive hardware test benches (costing $500,000-$10M each) They wait days or weeks for their scheduled access window They manually deploy and test their code on physical hardware at their desks They document results, pass the hardware to the next developer, and go to the back of the hardware testing queue This process is extremely inefficient. Embedded developers may finish writing their code today and wait weeks to test it on a hardware target. By then, they've moved on to other tasks. This context switching drains productivity. Not only that, developers may wait weeks to learn they had a simple math error in their code. Solution: Automated hardware allocation and continuous integration You can streamline hardware testing through automation using the GitLab On-Premises Device Cloud, a CI/CD component. This lets you automate the orchestration of scarce hardware resources, turning a manual, time-intensive process into a streamlined, continuous workflow. The On-Premises Device Cloud: Creates pools of shared hardware resources Automatically — and exclusively — allocates hardware to a developer’s hardware testing pipeline tasks based on availability Deploys and executes tests without manual intervention Collects and reports results through integrated pipelines Automatically deallocates hardware back into the “available” pool After submitting code, you’ll receive results in hours instead of days, often without ever physically touching the test hardware. What this video for an introduction to the GitLab On-Premises Device Cloud CI/CD Component to orchestrate the remote allocation of shared hardware for HIL: You can also adopt multi-pronged testing strategies that balance speed and quality. Bring the following embedded test patterns and environments into automated GitLab CI pipelines: Software-in-the-loop (SIL): Testing on virtual hardware simulators for quicker initial feedback Processor-in-the-loop (PIL): Testing on representative processor hardware for faster feedback at a lower cost Hardware-in-the-loop (HIL): Testing on full production-equivalent hardware and test benches for late-stage verification By automating the orchestration of these tests within CI pipelines, you’ll be able to identify issues earlier, iterate faster, and accelerate time to market. Challenge 2: Inconsistent build environments Another significant challenge in embedded development is build environment inconsistency. Embedded developers often manually execute builds on their local machines with varying configurations, compiler versions, and dependencies. Then they’ll paste the binaries from their local build to a shared codebase. This approach creates several problems: Inconsistent outputs: Builds for the same source code produce different results on different machines \"Works on my machine\" syndrome: Code that builds locally fails in shared environments Poor traceability: Limited audit trail of who built what and when Knowledge silos: Build expertise becomes concentrated in a few individuals This approach can lead to errors, bottlenecks, and costly delays. Solution: Standardized build automation You can address these challenges by implementing standardized build automation within CI/CD pipelines in GitLab. This approach creates consistent, repeatable, container-based build environments that eliminate machine-specific variations. Through the use of special Embedded Gateway Runner provisioning scripts, containers can interface with hardware for flashing and port monitoring for automated testing. Key elements of this solution include: Lifecycle managed environments: Define complex embedded simulation environments as code; automatically deploy environments for testing and destroy them afterward Containerization: Use Docker containers to ensure identical build environments Automated dependency management: Control and version all dependencies Central build execution: Run builds on shared infrastructure rather than local machines Follow this tutorial to learn how to automate embedded software builds within a GitLab CI pipeline. By standardizing and automating the build process, you can ensure that every build follows the same steps with the same dependencies, producing consistent outputs regardless of who initiated it. This not only improves quality but also democratizes the build process, enabling more team members to participate without specialized knowledge. Challenge 3: Siloed development practices Enterprise development teams have widely adopted collaborative practices such as DevOps, underpinned by shared source code management (SCM) and continuous integration/continuous delivery (CI/CD) systems. Embedded developers, on the other hand, have historically worked alone at their desks. There are valid technical reasons for this. For example, consider hardware virtualization, which is a key enabler of DevOps automation. The industry has been slower to virtualize the massive range of specialized processors and boards used in embedded systems. This is due in large part to the difficulties of virtualizing production real-time systems and the associated lack of economic incentives. Compare that to cloud virtualization which has been commoditized and benefited enterprise SaaS development for over a decade. Many providers are now embracing virtualization-first for the sake of speeding up embedded development. If teams fail to adopt virtual testing options, however, their silos will remain and negatively impact the business through: Knowledge fragmentation: Critical insights remain scattered across individuals and teams Redundant development: Multiple teams solve identical problems, creating inconsistencies Late-stage discovery during big-bang integrations: Problems are found late in the process when multiple developers integrate their code at once, when errors are more costly to fix Stifled innovation: Solutions from one domain rarely influence others, hampering the development of new product ideas Solution: Collaborative engineering through a unified platform An important step in breaking down these silos is to standardize embedded development around GitLab’s unified DevSecOps platform. In this regard, GitLab is aligned with the shift of embedded systems toward more consolidated, shared platforms on embedded devices. GitLab enables: Shared visibility: Make all code, Issues, and documentation visible across teams Collaborative workflows: Enable peer review and knowledge sharing through merge requests Centralized knowledge: Maintain a single source of truth for all development artifacts Asynchronous collaboration: Allow teams to work together across different locations and time zones Human-AI agent collaboration is a fundamental ingredient to fueling the customer-facing innovations that digital natives and established embedded brands desire. GitLab enables human-AI collaboration as well. By creating transparency across the development lifecycle, GitLab changes embedded development from an isolated activity to a collaborative practice. Engineers can see each other's work in progress, learn from collective experiences, and build upon shared solutions. Watch this presentation from Embedded World Germany 2025, which explains the power of embedded developers collaborating and sharing “work in progress”. The demo portion from 24:42 to 36:51 shows how to integrate HIL into a GitLab CI pipeline and enable collaborative development. Perhaps most importantly, by achieving greater collaboration through DevSecOps, teams can unlock embedded systems innovations that would otherwise remain hidden. Indeed, collaboration fuels innovation. One study, for example, found that group brainstorming, when properly structured, can lead to more innovative and creative outcomes than individuals working alone. Collaborative development is crucial in the race to develop software-defined products. Challenge 4: Manual functional safety compliance processes Embedded systems in the automotive and aerospace industries must comply with rigorous functional safety standards, including ISO 26262, MISRA C/C++, DO-178C, and DO-254. Traditional compliance approaches involve manual reviews, extensive documentation, and separate verification activities that occur late in the development cycle. This often creates security review bottlenecks. When specialized embedded security and code quality scanners detect vulnerabilities in a developer’s code, the scan issue gets added to a pile of other issues that haven’t been resolved. Developers can’t integrate their code, and security personnel need to wade through a backlog of code violations. This creates delays and makes compliance more difficult. Some of the challenges can best be summed up as: Late-stage compliance issues: Problems discovered after development is complete Documentation burden: Extensive manual effort to create and maintain compliance evidence Process bottlenecks: Serial compliance activities that block development progress Expertise dependence: Reliance on limited specialists for compliance activities As a result, teams often need to choose between velocity and compliance — a precarious trade-off in safety-critical systems. Solution: Automated functional safety compliance workflow building blocks Rather than treating security and compliance as post-development verification activities, you can codify compliance requirements and enforce them automatically through customizable frameworks in GitLab. To do this for functional safety standards, in particular, you can integrate GitLab with specialized embedded tools, which provide the depth of firmware scanning required by functional safety standards. Meanwhile, GitLab provides automated compliance checks, full audit trails, and merge request gating — all features needed to support a robust continuous compliance program. This integrated approach includes: Compliance-as-code: Define compliance requirements as automated checks Integrated specialized tools: Connect tools like CodeSonar into the DevSecOps platform for automotive-specific compliance Continuous compliance verification: Verify requirements throughout development Automated evidence collection: Gather compliance artifacts as a by-product of development Watch this video to learn how to use Custom Compliance Frameworks in GitLab to create your own compliance policies. You can create compliance policies related to any standard (e.g., ISO 26262) and automatically enforce those policies in GitLab. By shifting compliance left and embedding it within normal development workflows, you can maintain safety standards without sacrificing velocity. Automated checks catch issues early when they're easier and less expensive to fix, while continuous evidence collection reduces the documentation burden. Realizing the power of embedded DevOps Embedded development is changing fast. Teams that remain stuck in manual processes and isolated workflows will find themselves increasingly left behind, while those that embrace automated, collaborative practices will define the future of software-defined smart systems. Explore our Embedded DevOps Workshop to start automating embedded development workflows with GitLab, or watch this presentation from GitLab's Field Chief Cloud Architect to learn how leading organizations are bringing hardware-in-the-loop testing into continuous integration workflows to accelerate embedded development. Learn more Why GitLab Premium with Duo for embedded systems development? Why GitLab Ultimate with Duo for embedded systems development? More embedded development systems presentations from GitLab",
  "image": "https://images.ctfassets.net/r9o86ar0p03f/35zruDUtYFMOf2QU7qzhhv/0299e673bc10e07bed303ef22db94835/REFERENCE_-_display_preview_for_blog_images.png?fm=webp\u0026w=820\u0026h=500",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-v-67d56f21=\"\" data-v-53094866=\"\" data-v-74bd29c6=\"\"\u003e\u003cp\u003eSoftware in embedded systems is no longer just a part number — it\u0026#39;s a critical differentiator. This shift has led to enormous complexity in the firmware running in our cars, airplanes, and industrial machines. The number of lines of code in the average car is expected to reach \u003ca href=\"https://www.statista.com/statistics/1370978/automotive-software-average-lines-of-codes-per-vehicle-globally/\"\u003e650 million\u003c/a\u003e by the end of 2025, up from 200 million just five years ago. In aerospace systems, the complexity of embedded software has nearly \u003ca href=\"https://www.mckinsey.com/industries/aerospace-and-defense/our-insights/debugging-the-software-talent-gap-in-aerospace-and-defense\"\u003edoubled every four years\u003c/a\u003e for the last several decades.\u003c/p\u003e\n\u003cp\u003eTraditional embedded development approaches cannot effectively handle the software challenges of modern machines. This shortcoming slows engineers down, in part, by exacerbating challenges such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#challenge-1-hardware-testing-bottlenecks\"\u003eHardware testing bottlenecks\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#challenge-2-inconsistent-build-environments\"\u003eInconsistent build environments\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#challenge-3-siloed-development-practices\"\u003eSiloed development practices\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#challenge-4-manual-functional-safety-compliance-processes\"\u003eManual functional safety compliance processes\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEmbedded developers need a new approach to deal with the rapid increase in code. In this article, we’ll explain four ways you can use the GitLab AI-native DevSecOps platform to shorten feedback loops, work collaboratively and iteratively, and streamline compliance.\u003c/p\u003e\n\u003ch2 id=\"challenge-1-hardware-testing-bottlenecks\" tabindex=\"-1\"\u003eChallenge 1: Hardware testing bottlenecks \u003ca href=\"#challenge-1-hardware-testing-bottlenecks\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eUnlike enterprise software that can run on virtually any cloud server, embedded automotive software must be tested on specialized hardware that precisely matches production environments. Traditional hardware-in-the-loop (HIL) testing processes often follow this pattern:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDevelopers write code for an embedded system (e.g., an electronic control unit)\u003c/li\u003e\n\u003cli\u003eThey request access to limited, expensive hardware test benches (costing $500,000-$10M each)\u003c/li\u003e\n\u003cli\u003eThey wait days or weeks for their scheduled access window\u003c/li\u003e\n\u003cli\u003eThey manually deploy and test their code on physical hardware at their desks\u003c/li\u003e\n\u003cli\u003eThey document results, pass the hardware to the next developer, and go to the back of the hardware testing queue\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis process is extremely inefficient. Embedded developers may finish writing their code today and wait weeks to test it on a hardware target. By then, they\u0026#39;ve moved on to other tasks. This context switching drains productivity. Not only that, developers may wait weeks to learn they had a simple math error in their code.\u003c/p\u003e\n\u003ch3 id=\"solution-automated-hardware-allocation-and-continuous-integration\" tabindex=\"-1\"\u003eSolution: Automated hardware allocation and continuous integration \u003ca href=\"#solution-automated-hardware-allocation-and-continuous-integration\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eYou can streamline hardware testing through automation using the \u003ca href=\"https://gitlab.com/guided-explorations/embedded/ci-components/device-cloud\"\u003eGitLab On-Premises Device Cloud\u003c/a\u003e, a CI/CD component. This lets you automate the orchestration of scarce hardware resources, turning a manual, time-intensive process into a streamlined, continuous workflow.\u003c/p\u003e\n\u003cp\u003eThe On-Premises Device Cloud:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCreates pools of shared hardware resources\u003c/li\u003e\n\u003cli\u003eAutomatically — and exclusively — allocates hardware to a developer’s hardware testing pipeline tasks based on availability\u003c/li\u003e\n\u003cli\u003eDeploys and executes tests without manual intervention\u003c/li\u003e\n\u003cli\u003eCollects and reports results through integrated pipelines\u003c/li\u003e\n\u003cli\u003eAutomatically deallocates hardware back into the “available” pool\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAfter submitting code, you’ll receive results in hours instead of days, often without ever physically touching the test hardware.\u003c/p\u003e\n\u003cp\u003eWhat this video for an introduction to the GitLab On-Premises Device Cloud CI/CD Component to orchestrate the remote allocation of shared hardware for HIL:\u003c/p\u003e\n\n\u003cfigure\u003e\n  \u003ciframe src=\"https://www.youtube.com/embed/ltr2CIM9Zag?si=NOij3t1YYz4zKajC\" frameborder=\"0\" allowfullscreen=\"\"\u003e \u003c/iframe\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eYou can also adopt multi-pronged testing strategies that balance speed and quality. Bring the following embedded test patterns and environments into automated GitLab CI pipelines:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSoftware-in-the-loop (SIL):\u003c/strong\u003e Testing on virtual hardware simulators for quicker initial feedback\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProcessor-in-the-loop (PIL):\u003c/strong\u003e Testing on representative processor hardware for faster feedback at a lower cost\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHardware-in-the-loop (HIL):\u003c/strong\u003e Testing on full production-equivalent hardware and test benches for late-stage verification\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBy automating the orchestration of these tests within CI pipelines, you’ll be able to identify issues earlier, iterate faster, and accelerate time to market.\u003c/p\u003e\n\u003ch2 id=\"challenge-2-inconsistent-build-environments\" tabindex=\"-1\"\u003eChallenge 2: Inconsistent build environments \u003ca href=\"#challenge-2-inconsistent-build-environments\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAnother significant challenge in embedded development is build environment inconsistency. Embedded developers often manually execute builds on their local machines with varying configurations, compiler versions, and dependencies. Then they’ll paste the binaries from their local build to a shared codebase.\u003c/p\u003e\n\u003cp\u003eThis approach creates several problems:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eInconsistent outputs:\u003c/strong\u003e Builds for the same source code produce different results on different machines\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u0026#34;Works on my machine\u0026#34; syndrome:\u003c/strong\u003e Code that builds locally fails in shared environments\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePoor traceability:\u003c/strong\u003e Limited audit trail of who built what and when\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKnowledge silos:\u003c/strong\u003e Build expertise becomes concentrated in a few individuals\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis approach can lead to errors, bottlenecks, and costly delays.\u003c/p\u003e\n\u003ch3 id=\"solution-standardized-build-automation\" tabindex=\"-1\"\u003eSolution: Standardized build automation \u003ca href=\"#solution-standardized-build-automation\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eYou can address these challenges by implementing standardized build automation within CI/CD pipelines in GitLab. This approach creates consistent, repeatable, container-based build environments that eliminate machine-specific variations. Through the use of special Embedded Gateway Runner provisioning scripts, containers can interface with hardware for flashing and port monitoring for automated testing.\u003c/p\u003e\n\u003cp\u003eKey elements of this solution include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLifecycle managed environments:\u003c/strong\u003e Define complex embedded simulation environments as code; automatically deploy environments for testing and destroy them afterward\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eContainerization:\u003c/strong\u003e Use Docker containers to ensure identical build environments\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAutomated dependency management:\u003c/strong\u003e Control and version all dependencies\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCentral build execution:\u003c/strong\u003e Run builds on shared infrastructure rather than local machines\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFollow this tutorial to learn \u003ca href=\"https://gitlab.com/guided-explorations/embedded/workshops/embedded-devops-workshop-refactoring-to-ci/-/blob/main/TUTORIAL2.md%20\"\u003ehow to automate embedded software builds within a GitLab CI pipeline\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eBy standardizing and automating the build process, you can ensure that every build follows the same steps with the same dependencies, producing consistent outputs regardless of who initiated it. This not only improves quality but also democratizes the build process, enabling more team members to participate without specialized knowledge.\u003c/p\u003e\n\u003ch2 id=\"challenge-3-siloed-development-practices\" tabindex=\"-1\"\u003eChallenge 3: Siloed development practices \u003ca href=\"#challenge-3-siloed-development-practices\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eEnterprise development teams have widely adopted collaborative practices such as DevOps, underpinned by shared source code management (SCM) and continuous integration/continuous delivery (CI/CD) systems. Embedded developers, on the other hand, have historically worked alone at their desks. There are valid technical reasons for this.\u003c/p\u003e\n\u003cp\u003eFor example, consider hardware virtualization, which is a key enabler of DevOps automation. The industry has been slower to virtualize the massive range of specialized processors and boards used in embedded systems. This is due in large part to the difficulties of virtualizing production real-time systems and the associated lack of economic incentives. Compare that to cloud virtualization which has been commoditized and benefited enterprise SaaS development for over a decade.\u003c/p\u003e\n\u003cp\u003eMany providers are now embracing virtualization-first for the sake of speeding up embedded development. If teams fail to adopt virtual testing options, however, their silos will remain and negatively impact the business through:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eKnowledge fragmentation\u003c/strong\u003e: Critical insights remain scattered across individuals and teams\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRedundant development\u003c/strong\u003e: Multiple teams solve identical problems, creating inconsistencies\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLate-stage discovery during big-bang integrations\u003c/strong\u003e: Problems are found late in the process when multiple developers integrate their code at once, when errors are more costly to fix\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStifled innovation\u003c/strong\u003e: Solutions from one domain rarely influence others, hampering the development of new product ideas\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"solution-collaborative-engineering-through-a-unified-platform\" tabindex=\"-1\"\u003eSolution: Collaborative engineering through a unified platform \u003ca href=\"#solution-collaborative-engineering-through-a-unified-platform\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAn important step in breaking down these silos is to standardize embedded development around GitLab’s unified DevSecOps platform. In this regard, GitLab is aligned with the shift of embedded systems toward more consolidated, shared platforms on embedded devices. GitLab enables:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eShared visibility:\u003c/strong\u003e Make all code, Issues, and documentation visible across teams\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCollaborative workflows:\u003c/strong\u003e Enable peer review and knowledge sharing through merge requests\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCentralized knowledge:\u003c/strong\u003e Maintain a single source of truth for all development artifacts\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAsynchronous collaboration:\u003c/strong\u003e Allow teams to work together across different locations and time zones\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHuman-AI agent collaboration is a fundamental ingredient to fueling the customer-facing innovations that digital natives and established embedded brands desire. GitLab enables human-AI collaboration as well. By creating transparency across the development lifecycle, GitLab changes embedded development from an isolated activity to a collaborative practice. Engineers can see each other\u0026#39;s work in progress, learn from collective experiences, and build upon shared solutions.\u003c/p\u003e\n\u003cp\u003eWatch this presentation from Embedded World Germany 2025, which explains the power of embedded developers collaborating and sharing “work in progress”. The demo portion from 24:42 to 36:51 shows how to integrate HIL into a GitLab CI pipeline and enable collaborative development.\u003c/p\u003e\n\n\u003cfigure\u003e\n  \u003ciframe src=\"https://www.youtube.com/embed/F_rlOyq0hzc?si=eF4alDY6HK98uZPj\" frameborder=\"0\" allowfullscreen=\"\"\u003e \u003c/iframe\u003e\n\u003c/figure\u003e\n\n\u003cp\u003ePerhaps most importantly, by achieving greater collaboration through DevSecOps, teams can unlock embedded systems innovations that would otherwise remain hidden. Indeed, collaboration fuels innovation. \u003ca href=\"https://www.sciencedirect.com/science/article/abs/pii/S0749597800928887\"\u003eOne study\u003c/a\u003e, for example, found that group brainstorming, when properly structured, can lead to more innovative and creative outcomes than individuals working alone. Collaborative development is crucial in the race to develop software-defined products.\u003c/p\u003e\n\u003ch2 id=\"challenge-4-manual-functional-safety-compliance-processes\" tabindex=\"-1\"\u003eChallenge 4: Manual functional safety compliance processes \u003ca href=\"#challenge-4-manual-functional-safety-compliance-processes\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eEmbedded systems in the automotive and aerospace industries must comply with rigorous functional safety standards, including ISO 26262, MISRA C/C++, DO-178C, and DO-254. Traditional compliance approaches involve manual reviews, extensive documentation, and separate verification activities that occur late in the development cycle. This often creates security review bottlenecks. When specialized embedded security and code quality scanners detect vulnerabilities in a developer’s code, the scan issue gets added to a pile of other issues that haven’t been resolved. Developers can’t integrate their code, and security personnel need to wade through a backlog of code violations. This creates delays and makes compliance more difficult.\u003c/p\u003e\n\u003cp\u003eSome of the challenges can best be summed up as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLate-stage compliance issues\u003c/strong\u003e: Problems discovered after development is complete\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDocumentation burden\u003c/strong\u003e: Extensive manual effort to create and maintain compliance evidence\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProcess bottlenecks\u003c/strong\u003e: Serial compliance activities that block development progress\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExpertise dependence\u003c/strong\u003e: Reliance on limited specialists for compliance activities\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAs a result, teams often need to choose between velocity and compliance — a precarious trade-off in safety-critical systems.\u003c/p\u003e\n\u003ch3 id=\"solution-automated-functional-safety-compliance-workflow-building-blocks\" tabindex=\"-1\"\u003eSolution: Automated functional safety compliance workflow building blocks \u003ca href=\"#solution-automated-functional-safety-compliance-workflow-building-blocks\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eRather than treating security and compliance as post-development verification activities, you can codify compliance requirements and enforce them automatically through \u003ca href=\"https://about.gitlab.com/blog/2025/04/17/introducing-custom-compliance-frameworks-in-gitlab/\"\u003ecustomizable frameworks in GitLab\u003c/a\u003e. To do this for functional safety standards, in particular, you can integrate GitLab with specialized embedded tools, which provide the depth of firmware scanning required by functional safety standards. Meanwhile, GitLab provides automated compliance checks, full audit trails, and merge request gating — all features needed to support a robust continuous compliance program.\u003c/p\u003e\n\u003cp\u003eThis integrated approach includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCompliance-as-code:\u003c/strong\u003e Define compliance requirements as automated checks\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIntegrated specialized tools:\u003c/strong\u003e Connect tools like CodeSonar into the DevSecOps platform for automotive-specific compliance\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eContinuous compliance verification:\u003c/strong\u003e Verify requirements throughout development\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAutomated evidence collection:\u003c/strong\u003e Gather compliance artifacts as a by-product of development\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWatch this video to learn how to use Custom Compliance Frameworks in GitLab to create your own compliance policies. You can create compliance policies related to any standard (e.g., ISO 26262) and automatically enforce those policies in GitLab.\u003c/p\u003e\n\n\u003cfigure\u003e\n  \u003ciframe src=\"https://www.youtube.com/embed/S-FQjzSyVJw?si=0UdtGNuugLPG0SLL\" frameborder=\"0\" allowfullscreen=\"\"\u003e \u003c/iframe\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eBy shifting compliance left and embedding it within normal development workflows, you can maintain safety standards without sacrificing velocity. Automated checks catch issues early when they\u0026#39;re easier and less expensive to fix, while continuous evidence collection reduces the documentation burden.\u003c/p\u003e\n\u003ch2 id=\"realizing-the-power-of-embedded-devops\" tabindex=\"-1\"\u003eRealizing the power of embedded DevOps \u003ca href=\"#realizing-the-power-of-embedded-devops\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eEmbedded development is changing fast. Teams that remain stuck in manual processes and isolated workflows will find themselves increasingly left behind, while those that embrace automated, collaborative practices will define the future of software-defined smart systems.\u003c/p\u003e\n\u003cp\u003eExplore our \u003ca href=\"https://gitlab.com/guided-explorations/embedded/workshops/embedded-devops-workshop-refactoring-to-ci\"\u003eEmbedded DevOps Workshop\u003c/a\u003e to start automating embedded development workflows with GitLab, or \u003ca href=\"https://content.gitlab.com/viewer/0a35252831bd130f879b0725738f70ed\"\u003ewatch this presentation from GitLab\u0026#39;s Field Chief Cloud Architect\u003c/a\u003e to learn how leading organizations are bringing hardware-in-the-loop testing into continuous integration workflows to accelerate embedded development.\u003c/p\u003e\n\u003ch2 id=\"learn-more\" tabindex=\"-1\"\u003eLearn more \u003ca href=\"#learn-more\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://content.gitlab.com/viewer/438451cba726dd017da7b95fd0fb1b59\"\u003eWhy GitLab Premium with Duo for embedded systems development?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://content.gitlab.com/viewer/87f5104c26720e2c0d73a6b377522a44\"\u003eWhy GitLab Ultimate with Duo for embedded systems development?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://content.gitlab.com/viewer/e59c40099d5e3c8f9307afb27c4a923f\"\u003eMore embedded development systems presentations from GitLab\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2025-06-05T00:00:00Z",
  "modifiedTime": null
}
