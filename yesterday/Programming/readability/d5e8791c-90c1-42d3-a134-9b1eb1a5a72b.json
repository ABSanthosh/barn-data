{
  "id": "d5e8791c-90c1-42d3-a134-9b1eb1a5a72b",
  "title": "The Angular Language Server: Understanding IDE Integration Approaches",
  "link": "https://blog.jetbrains.com/webstorm/2025/03/the-angular-language-server-understanding-ide-integration-approaches/",
  "description": "The Language Server Protocol (LSP) has been a fundamental part of the code editor landscape for years, providing a consistent development experience across different editors. The Angular Language Server leverages this protocol to provide Angular-specific features to compatible editors. However, not all IDEs take the same approach to delivering these capabilities. Let’s look at the […]",
  "author": "Jan-Niklas Wortmann",
  "published": "Thu, 06 Mar 2025 18:26:00 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "all-things-web",
    "web-development",
    "webstorm"
  ],
  "byline": "Jan-Niklas Wortmann",
  "length": 10014,
  "excerpt": "Learn about the Angular Language Server and different IDE integration approaches. Learn why WebStorm doesn't use the Angular Language server ... or does it?",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "The JavaScript and TypeScript IDE All Things Web Web Development WebStormThe Angular Language Server: Understanding IDE Integration Approaches The Language Server Protocol (LSP) has been a fundamental part of the code editor landscape for years, providing a consistent development experience across different editors. The Angular Language Server leverages this protocol to provide Angular-specific features to compatible editors. However, not all IDEs take the same approach to delivering these capabilities. Let’s look at the major differences between VS Code, NeoVim, and WebStorm and finally answer the age-old question, “Why does WebStorm not just use the Angular Language Server?!” What is a language server, and how does the LSP work? Modern code editors need to understand your code to provide features like autocompletion, go to definition, or error detection. Traditionally, each editor needed to implement this understanding for every programming language, leading to duplicated effort and inconsistent experiences across editors. The Language Server Protocol (LSP) solves this by standardizing how editors communicate with language-specific analysis tools. Here’s how it works: Your editor (the client) sends information about your code (typically the file that is currently open in your editor) to a language server. The language server analyzes the code and responds with insights. Your editor displays these insights as squiggly error lines, autocompletion popups, or other UI elements. // When you type this in your editor @Component({ template: ` \u003cdiv *ngFor=\"let item of items\"\u003e {{ item.property }} \u003c/div\u003e ` }) class MyComponent { } Your editor sends the file content to the language server. The server analyzes it and might respond with: { \"diagnostics\": [{ \"message\": \"Property 'property' does not exist on type 'any'\", \"range\": { \"start\": {\"line\": 3, \"character\": 12}, \"end\": {\"line\": 3, \"character\": 20} } }] } // Your editor then shows the error underline This standardization means that: Developers of editors and IDEs can add support for new languages just by implementing the LSP client once. Language tool developers can support all LSP-compatible editors with a single server and very small client implementations (JetBrains IDE plugin or VS Code plugin). Developers get consistent features across different editors. The Angular Language Server specifically provides Angular-aware code analysis, offering features like template type checking, component property completion, and Angular-specific refactorings to any editor that supports LSP. Benefits of the Language Server Protocol The LSP has established itself as the standard for providing editor intelligence across different development environments. It enables consistent features like type checking, code completion, and navigation across any LSP-compatible editor: @Component({ template: ` \u003cdiv *ngFor=\"let item of items\"\u003e {{ item?.deeply?.nested?.property }} \u003c/div\u003e ` }) class WhyTypeCheckingMatters { } While the Angular compiler would catch these template errors during build time, the language server provides immediate feedback in your editor. This means you can spot and fix type errors as you write your code, without waiting for the compilation step. VS Code: LSP’s golden child VS Code’s integration with the Angular Language Server is seamless and intuitive. Here are some of the features that you’ll be able to use after installing the necessary plugin: Template type checking: Because nobody likes finding out about undefined properties in production. Go To Definition: Jump straight to your TypeScript references. Autocompletion: For when you can’t remember the syntax of *ngFor or @switch. Real-time error detection: Catch those typos before they catch you out. The best part? It’s all standardized. The same language server that powers VS Code can power any editor that speaks LSP. Neovim: for when Vim users want nice things, too Remember when Vim users had to type out every import statement manually? Pepperidge Farm remembers. Now, thanks to LSP, you get: -- Neovim config that actually gives you IDE features require'lspconfig'.angularls.setup{ -- Look ma, real autocomplete! } Neovim users now enjoy the same powerful features as VS Code users while keeping their beloved modal editing. It’s the best of both worlds – modern IDE features with an outstanding editing experience. The caveats of language servers Language servers are great – they provide a consistent developer experience and guarantee correctness. However, the fact that language servers adhere to a standardized protocol means that they do have some limitations. For instance, even though most languages and frameworks have some kind of test support, the LSP is not aware of this concept, and, therefore, tests must be configured manually within the editor. This is also the case when working with debuggers, too. Additionally, language servers generally look at the codebase on a “file by file” basis, and, more specifically, at the current cursor position. Generally speaking, this works great until it doesn’t… Implementing a multi-file refactoring, for instance, can be difficult (though not impossible). For this reason, extracting some HTML code into a new Angular component is not as straightforward as it might first sound. On top of that, language servers can usually only process one language at a time; therefore, refactoring a CSS class across languages can quickly become very cumbersome in a language server implementation. The Angular Language Server has a very clever trick for handling HTML and TypeScript, but more on that in the next section. CSS, on the other hand, doesn’t enjoy the same level of support.  What’s more, adding further support for parts that don’t have dedicated compiler functionality is difficult to accomplish. One such example would be IntelliSense for the host property of the component decorator. WebStorm: a slightly different approach Now, here’s where things get interesting. WebStorm and other JetBrains IDEs take a different approach, and it’s not just about being contrarian. For the last few years, the Angular plugin has been pre-installed with WebStorm. As of now, this plugin does not utilize the Angular Language Server, but a custom-type engine. As part of our new Service-powered type engine (more about this in the future), we made some major changes to our Angular integration. Instead of using the entire Angular Language Server, WebStorm adopted Angular’s TCB (type-check block) engine, an integral part of the Angular Language Server. For more details, you can check out this talk at NG DE, but in short, the Angular Language Server converts the HTML code into TypeScript code and uses the generated TypeScript code to map errors and IntelliSense features back to the cursor position in the original HTML file. The screenshot below visualizes this concept. See how this.counter is used in the template, which gets converted to the function _tcb1 on the right side, but isn’t properly declared in TestComponent.  You might now be asking, why doesn’t WebStorm just use the Angular Language Server? Well, it turns out template type checking is just one piece of the IDE puzzle. WebStorm’s architecture already handles most of what the Angular Language Server provides: Navigation Code completion Quick-fixes Furthermore, it offers parts of functionality that our users appreciate and that are not offered by the language server: Unit and E2E test integration for Jasmine, Jest, Vitest, Cypress, and Playwright. Debugging integration. Semantic highlighting of signals (fun fact: the Angular LSP does not provide syntax highlighting, which is part of the VS Code plugin). Special refactoring and quick-fix capabilities (e.g. extract Angular Component, create a signal ‘property’, etc.). IntelliSense without compiler support, like the host property mentioned above. Enhanced search capabilities (e.g. Find Usages for components). The real-world implications So what does this mean for you, the developer, just trying to get work done? VS Code and Neovim users Standardized experience across editors Regular updates with Angular releases Built-in type correctness WebStorm users Built-in integration of broader IDE tools (debugger, test runner, run configurations, etc.) Direct TCB integration for template type checking Additional navigation, refactoring features, and consistent development experiences across different languages (HTML, CSS, and TypeScript) Looking forward The Angular Language Server continues to evolve, making developers’ lives easier. Meanwhile, WebStorm’s specialized approach shows that there’s more than one way to achieve excellent Angular support. Subscribe to WebStorm Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/03/ws-social_share_blog_1280x720_en.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/webstorm/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/WebStorm-2.svg\" alt=\"Webstorm logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eThe JavaScript and TypeScript IDE\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/webstorm/category/all-things-web/\"\u003eAll Things Web\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/webstorm/category/web-development/\"\u003eWeb Development\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/webstorm/category/webstorm/\"\u003eWebStorm\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eThe Angular Language Server: Understanding IDE Integration Approaches\u003c/h2\u003e                    \n                    \n\u003cp\u003eThe Language Server Protocol (LSP) has been a fundamental part of the code editor landscape for years, providing a consistent development experience across different editors. The Angular Language Server leverages this protocol to provide Angular-specific features to compatible editors. However, not all IDEs take the same approach to delivering these capabilities. Let’s look at the major differences between VS Code, NeoVim, and WebStorm and finally answer the age-old question, “Why does WebStorm not just use the Angular Language Server?!”\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eWhat is a language server, and how does the LSP work?\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eModern code editors need to understand your code to provide features like autocompletion, go to definition, or error detection. Traditionally, each editor needed to implement this understanding for every programming language, leading to duplicated effort and inconsistent experiences across editors.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe Language Server Protocol (LSP) solves this by standardizing how editors communicate with language-specific analysis tools. Here’s how it works:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eYour editor (the client) sends information about your code (typically the file that is currently open in your editor) to a language server.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe language server analyzes the code and responds with insights.\u003c/li\u003e\n\n\n\n\u003cli\u003eYour editor displays these insights as squiggly error lines, autocompletion popups, or other UI elements.\u003cbr/\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cpre\u003e// When you type this in your editor\n@Component({\n  template: `\n    \u0026lt;div *ngFor=\u0026#34;let item of items\u0026#34;\u0026gt;\n      {{ item.property }}\n    \u0026lt;/div\u0026gt;\n  `\n})\nclass MyComponent { }\u003c/pre\u003e\n\n\n\n\u003cp\u003eYour editor sends the file content to the language server. The server analyzes it and might respond with:\u003c/p\u003e\n\n\n\n\u003cpre\u003e{\n  \u0026#34;diagnostics\u0026#34;: [{\n    \u0026#34;message\u0026#34;: \u0026#34;Property \u0026#39;property\u0026#39; does not exist on type \u0026#39;any\u0026#39;\u0026#34;,\n    \u0026#34;range\u0026#34;: {\n      \u0026#34;start\u0026#34;: {\u0026#34;line\u0026#34;: 3, \u0026#34;character\u0026#34;: 12},\n      \u0026#34;end\u0026#34;: {\u0026#34;line\u0026#34;: 3, \u0026#34;character\u0026#34;: 20}\n    }\n  }]\n}\n// Your editor then shows the error underline\u003c/pre\u003e\n\n\n\n\u003ch2\u003eThis standardization means that:\u003c/h2\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eDevelopers of editors and IDEs can add support for new languages just by implementing the LSP client once.\u003c/li\u003e\n\n\n\n\u003cli\u003eLanguage tool developers can support all LSP-compatible editors with a single server and very small client implementations (JetBrains IDE plugin or VS Code plugin).\u003c/li\u003e\n\n\n\n\u003cli\u003eDevelopers get consistent features across different editors.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe Angular Language Server specifically provides Angular-aware code analysis, offering features like template type checking, component property completion, and Angular-specific refactorings to any editor that supports LSP.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eBenefits of the Language Server Protocol\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe LSP has established itself as the standard for providing editor intelligence across different development environments. It enables consistent features like type checking, code completion, and navigation across any LSP-compatible editor:\u003c/p\u003e\n\n\n\n\u003cpre\u003e@Component({\n  template: `\n    \u0026lt;div *ngFor=\u0026#34;let item of items\u0026#34;\u0026gt;\n      {{ item?.deeply?.nested?.property }}\n    \u0026lt;/div\u0026gt;\n  `\n})\nclass WhyTypeCheckingMatters { }\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhile the Angular compiler would catch these template errors during build time, the language server provides immediate feedback in your editor. This means you can spot and fix type errors as you write your code, without waiting for the compilation step.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eVS Code: LSP’s golden child\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eVS Code’s integration with the Angular Language Server is seamless and intuitive. Here are some of the features that you’ll be able to use after installing the \u003ca href=\"https://marketplace.visualstudio.com/items?itemName=Angular.ng-template\" target=\"_blank\" rel=\"noopener\"\u003enecessary plugin\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eTemplate type checking:\u003c/strong\u003e Because nobody likes finding out about undefined properties in production.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cem\u003eGo To Definition\u003c/em\u003e: Jump straight to your TypeScript references.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eAutocompletion:\u003c/strong\u003e For when you can’t remember the syntax of \u003cstrong\u003e\u003ccode\u003e*ngFor\u003c/code\u003e\u003c/strong\u003e or \u003cstrong\u003e\u003ccode\u003e@switch\u003c/code\u003e\u003c/strong\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eReal-time error detection:\u003c/strong\u003e Catch those typos before they catch you out.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eThe best part? It’s all standardized. The same language server that powers VS Code can power any editor that speaks LSP.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eNeovim: for when Vim users want nice things, too\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eRemember when Vim users had to type out every import statement manually? Pepperidge Farm remembers. Now, thanks to LSP, you get:\u003c/p\u003e\n\n\n\n\u003cpre\u003e-- Neovim config that actually gives you IDE features\nrequire\u0026#39;lspconfig\u0026#39;.angularls.setup{\n  -- Look ma, real autocomplete!\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eNeovim users now enjoy the same powerful features as VS Code users while keeping their beloved modal editing. It’s the best of both worlds – modern IDE features with an outstanding editing experience.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eThe caveats of language servers\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eLanguage servers are great – they provide a consistent developer experience and guarantee correctness. However, the fact that language servers adhere to a standardized protocol means that they do have some limitations. For instance, even though most languages and frameworks have some kind of test support,\u003ca href=\"https://github.com/microsoft/language-server-protocol/issues/1267\" target=\"_blank\" rel=\"noopener\"\u003e the LSP is not aware of this concept\u003c/a\u003e, and, therefore, tests must be configured manually within the editor. This is also the case when working with debuggers, too.\u003c/p\u003e\n\n\n\n\u003cp\u003eAdditionally, language servers generally look at the codebase on a “file by file” basis, and, more specifically, at the current cursor position. Generally speaking, this works great until it doesn’t… Implementing a multi-file refactoring, for instance, can be difficult (though not impossible). For this reason, extracting some HTML code into a new Angular component is not as straightforward as it might first sound. On top of that, language servers can usually only process one language at a time; therefore, refactoring a CSS class across languages can quickly become very cumbersome in a language server implementation. The Angular Language Server has a very clever trick for handling HTML and TypeScript, but more on that in the next section. CSS, on the other hand, doesn’t enjoy the same level of support. \u003c/p\u003e\n\n\n\n\u003cp\u003eWhat’s more, adding further support for parts that don’t have dedicated compiler functionality is difficult to accomplish. One such example would be IntelliSense for the\u003ca href=\"https://github.com/angular/vscode-ng-language-service/issues/1730\" target=\"_blank\" rel=\"noopener\"\u003e host property\u003c/a\u003e of the component decorator.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eWebStorm: a slightly different approach\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow, here’s where things get interesting. WebStorm and other JetBrains IDEs take a different approach, and it’s not just about being contrarian. For the last few years, the Angular plugin has been pre-installed with WebStorm. As of now, this plugin does not utilize the Angular Language Server, but a custom-type engine. As part of our\u003ca href=\"https://blog.jetbrains.com/webstorm/2023/12/try-the-future-typescript-engine-with-the-webstorm-next-program/\"\u003e new Service-powered type engine (more about this in the future), \u003c/a\u003ewe made some major changes to our Angular integration. Instead of using the entire Angular Language Server, WebStorm adopted Angular’s TCB (type-check block) engine, an integral part of the Angular Language Server. For more details, you can check out this\u003ca href=\"https://www.youtube.com/watch?v=_ccNQTLmxe8\" target=\"_blank\" rel=\"noopener\"\u003e talk at NG DE\u003c/a\u003e, but in short, the Angular Language Server converts the HTML code into TypeScript code and uses the generated TypeScript code to map errors and IntelliSense features back to the cursor position in the original HTML file. The screenshot below visualizes this concept.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1600\" height=\"801\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/03/Screenshot-2025-03-03-at-12.22.40-PM.png\" alt=\"Screenshot of WebStorm, showing a regular Angular Component with some unknown property error on the left side, whereas the right side shows the translated typescript code.\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eSee how \u003ccode\u003ethis.counter\u003c/code\u003e is used in the template, which gets converted to the function \u003ccode\u003e_tcb1\u003c/code\u003e on the right side, but isn’t properly declared in \u003ccode\u003eTestComponent\u003c/code\u003e. \u003c/p\u003e\n\n\n\n\u003cp\u003eYou might now be asking, why doesn’t WebStorm just use the Angular Language Server? Well, it turns out template type checking is just one piece of the IDE puzzle. WebStorm’s architecture already handles most of what the Angular Language Server provides:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eNavigation\u003c/li\u003e\n\n\n\n\u003cli\u003eCode completion\u003c/li\u003e\n\n\n\n\u003cli\u003eQuick-fixes\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eFurthermore, it offers parts of functionality that our users appreciate and that are not offered by the language server:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eUnit and E2E test integration for Jasmine, Jest, Vitest, Cypress, and Playwright.\u003c/li\u003e\n\n\n\n\u003cli\u003eDebugging integration.\u003c/li\u003e\n\n\n\n\u003cli\u003eSemantic highlighting of signals (fun fact: the Angular LSP does not provide syntax highlighting, which is part of the VS Code plugin).\u003c/li\u003e\n\n\n\n\u003cli\u003eSpecial refactoring and \u003cem\u003equick-fix\u003c/em\u003e capabilities (e.g. \u003cem\u003eextract Angular Component\u003c/em\u003e, \u003cem\u003ecreate a signal ‘property’\u003c/em\u003e, etc.).\u003c/li\u003e\n\n\n\n\u003cli\u003eIntelliSense without compiler support, like the host property mentioned above.\u003c/li\u003e\n\n\n\n\u003cli\u003eEnhanced search capabilities (e.g. \u003cem\u003eFind Usages\u003c/em\u003e for components).\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eThe real-world implications\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eSo what does this mean for you, the developer, just trying to get work done?\u003c/p\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eVS Code and Neovim users\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eStandardized experience across editors\u003c/li\u003e\n\n\n\n\u003cli\u003eRegular updates with Angular releases\u003c/li\u003e\n\n\n\n\u003cli\u003eBuilt-in type correctness\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eWebStorm users\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eBuilt-in integration of broader IDE tools (debugger, test runner, run configurations, etc.)\u003c/li\u003e\n\n\n\n\u003cli\u003eDirect TCB integration for template type checking\u003c/li\u003e\n\n\n\n\u003cli\u003eAdditional navigation, refactoring features, and consistent development experiences across different languages (HTML, CSS, and TypeScript)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eLooking forward\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe Angular Language Server continues to evolve, making developers’ lives easier. Meanwhile, WebStorm’s specialized approach shows that there’s more than one way to achieve excellent Angular support.\u003c/p\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to WebStorm Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": null,
  "modifiedTime": null
}
