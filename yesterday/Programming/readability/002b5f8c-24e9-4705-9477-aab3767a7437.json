{
  "id": "002b5f8c-24e9-4705-9477-aab3767a7437",
  "title": "Getting Started With the JetBrains Bazel Plugin",
  "link": "https://blog.jetbrains.com/idea/2024/12/getting-started-with-the-jetbrains-bazel-plugin/",
  "description": "Large Bazel projects are becoming increasingly common in modern software development. Unfortunately, the IDE experience for these projects often leaves much to be desired. In this blog post, we’ll explore the new JetBrains Bazel plugin and how it can enhance your daily work with Bazel projects. We’ll begin with an overview of what Bazel users […]",
  "author": "Vitaly Bragilevsky",
  "published": "Fri, 13 Dec 2024 09:42:02 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "news",
    "tutorials",
    "bazel",
    "intellij-idea"
  ],
  "byline": "Vitaly Bragilevsky",
  "length": 11394,
  "excerpt": "Large Bazel projects are becoming increasingly common in modern software development. Unfortunately, the IDE experience for these projects often leaves much to be desired. In this blog post, we’ll exp",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA – the Leading Java and Kotlin IDE, by JetBrains News TutorialsGetting Started With the JetBrains Bazel Plugin Large Bazel projects are becoming increasingly common in modern software development. Unfortunately, the IDE experience for these projects often leaves much to be desired. In this blog post, we’ll explore the new JetBrains Bazel plugin and how it can enhance your daily work with Bazel projects. We’ll begin with an overview of what Bazel users typically expect from IDEs and then dive into the features you can start using right away. Bazel in your IDE Bazel is a fast, scalable, and extensible build and test system that helps you manage complex codebases efficiently. It works with multi-language projects, offering support for C++, Java, Kotlin, Python, Rust, and other languages, and ensures consistent, reproducible builds across environments. With incremental build capabilities that recompile only what’s necessary and rich caching and parallel execution features, Bazel significantly enhances performance. Designed with extensibility in mind, it allows you to define custom build rules and scales seamlessly for monorepos and large-scale projects. When it comes to Bazel support in IDEs, a variety of features are essential for streamlining workflows and boosting productivity. Seamless integration with Bazel configuration files (such as BUILD, MODULE.bazel, and WORKSPACE files) is a key requirement, with crucial support including syntax highlighting, code completion, and error checking to simplify the creation and maintenance of build rules. IDEs should also manage dependencies intelligently, automatically resolving them to ensure accurate project structures and robust code navigation, refactoring, and search capabilities. Incremental build execution is another critical feature, enabling you to trigger and monitor Bazel builds directly from the IDE while leveraging performance-oriented features such as incremental compilation. Integrated test support is equally important, allowing developers to run and debug Bazel tests with tools like breakpoints and test filters. For multi-language projects, IDEs must handle cross-language dependencies effectively to ensure a smooth workflow. Support for custom Bazel rules and plugins is extremely valuable, as it lets developers tailor the build process without sacrificing IDE functionality. Efficient indexing and caching are also essential for maintaining responsiveness, especially in large monorepos or with complex configurations. Finally, seamless integration with complementary tools like debuggers and profilers creates a cohesive and efficient development environment. These capabilities allow you to focus on writing code while Bazel manages the complexities of builds and dependencies. Introducing our sample project To demonstrate the features available in the JetBrains Bazel plugin and help you get started with it, we’ll take a look at the CLI implementation of an oversimplified calculator. Despite its simplicity, this calculator has evolved over years of development into a large monorepo with an advanced architecture, containing six packages implemented in Java and Kotlin – the languages the plugin currently supports: From this diagram, you can see that some packages are nested while others are on the first level. The calc_core package serves as the foundation, with every other package in the project depending on it. Some packages, such as kotlin-div and kotlin-sub, can be developed independently of others, but they still require a dependency on calc_core. The developer of kotlin-div has also provided JUnit 5 tests that can be executed using Bazel. Tests for calc_add, on the other hand, are generated by Bazel. For this project, we use the Bzlmod approach. The Bazel-related files are located within the project as follows: . ├── .bazelrc ├── BUILD ├── MODULE.bazel ├── calc_cli │ ├── BUILD │ ├── rules.bzl │ └── src ├── calc_core │ ├── BUILD │ ├── operations │ │ ├── addition │ │ │ ├── BUILD │ │ │ ├── gen_tests.bzl │ │ │ └── src │ │ └── multiplication │ │ ├── BUILD │ │ └── src │ └── src ├── calc_div │ ├── BUILD │ └── src └── calc_sub ├── BUILD └── src Note that we have MODULE.bazel (which defines the whole Bazel repository), a collection of BUILD files defining various targets, and files with rule definitions (*.bzl) here and there.  Working with a Bazel project in IntelliJ IDEA Let’s explore the most common workflows in Bazel projects and see how the JetBrains Bazel plugin can assist. Opening the project: Exploring the structure and project views When we first open our Bazel project in IntelliJ IDEA, the Bazel plugin works with both Bazel and IDE to map Bazel packages onto IntelliJ IDEA’s workspace model. The JetBrains Bazel plugin aims to minimize the time required for the initial sync by waiting until a later stage to load all dependencies and metadata. Here’s what we get as a result: IntelliJ IDEA’s ability to properly recognize the project structure significantly enhances its performance for routine tasks like code completion and navigation. Several tools are available to help us examine the structure, including the Project tool window’s Packages view and the Bazel tool window: The Bazel tool window gives us access to the project-wide operations (such as resyncing, building, and configuring) and lists all the Bazel targets discovered during the latest sync. At some point, we might be interested in a subset of targets, for example tests, or in filtering targets by name: The filtered target view can be plain or hierarchical, and when searching through targets, we can use case-sensitive prompts or regular expressions.  Even with the improved mapping of Bazel projects onto the IntelliJ IDEA workspace, very large projects might be too big for IDE support. For those cases, we support project views, special configuration files that restrict the area for which the IDE is responsible.  When you open a Bazel project without .bazelproject files, the JetBrains Bazel plugin creates a default view in the .bazelbsp  directory. Alternatively, you can create one yourself, for example, projectview.bazelproject: derive_targets_from_directories: true directories: . Here, we include all the project’s directories and derive all the targets from them. For another example, with the following div-dev.bazelproject file, we can create a project view that provides support to only the directories needed for developers working on a Kotlin library that implements a division operation for our calculator: derive_targets_from_directories: true directories:   calc_div   calc_core   -calc_core/operations These declarations mean that we include only two directories: calc_div and calc_core (excluding everything below calc_core/operations). Setting derive_targets_from_directories to true instructs the plugin also to include all the targets found in the specified directories.  Let’s put the div-dev.bazelproject file in the root folder of the project and execute the Load Project View action: As a result, the following subset of targets becomes available in the project, while the previous subset becomes unavailable: Reducing IDE support for packages outside the project view in this way should improve performance.  In general, you can have more than one project view file in the root folder of your project. The one that is currently in effect is highlighted in the Project tool window: To get back to the full project, we can load the default .bazelbsp/.bazelproject file or the  projectview.bazelproject file we created earlier. Switching between project views may take some time because it requires resyncing the whole project. Editing, building, running, debugging, and testing Once IntelliJ IDEA has loaded all the information from the Bazel configuration, we can use the IDE as usual. Among other things, project configuration makes it possible to provide a smoother code editing experience, as the IDE is aware of available libraries, provides meaningful completion suggestions, and supports navigation through the codebase: We can also use Bazel to run or debug an application or test: Another option is to run a test from the Bazel tool window: From the Bazel tool window, we can also initiate a build for a particular target or jump to the corresponding BUILD file to tweak any configuration options: Reconfiguring or extending the project Changes in Bazel configuration files might require the project to be resynced with IntelliJ IDEA. The plugin detects such changes and suggests syncing with the IDE: Adding files or packages to our repository is also detected and requires syncing for IntelliJ IDEA to work correctly.  Working with Starlark code The JetBrains Bazel plugin also provides code completion, navigation, and debugging support for Starlark code.  In the following two screenshots, we change the name of tests generated for the addition operation, set a breakpoint, and launch a Starlark debugging session. Once we’re suspended on the breakpoint, we can inspect the available variables, and then we can continue the debugging session by using Step Into or Step Over or resuming execution.  When debugging Starlark code, it’s always helpful to remember that Bazel checks if there are any changes since the last time the code was executed. Before we can start debugging, we need to have changed something in the corresponding files.  Conclusion In this blog post, we’ve reviewed how the JetBrains Bazel plugin integrates Bazel projects into IntelliJ IDEA, covering everything from project setup to debugging Starlark code. The plugin provides tools to help manage large and complex codebases, such as project views, target filtering, and incremental builds. These features aim to simplify working with Bazel projects by improving navigation, build management, and test execution within the IDE. While it may require some initial setup, the plugin can make handling Bazel configurations and workflows more straightforward over time. If you’re working with Bazel, check out the plugin to see how it can complement your development process. Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2024/12/ij-social_share_blog_1280x720_en-5.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA – the Leading Java and Kotlin IDE, by JetBrains\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/category/news/\"\u003eNews\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/idea/category/tutorials/\"\u003eTutorials\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eGetting Started With the JetBrains Bazel Plugin\u003c/h2\u003e                    \n                    \n\u003cp\u003eLarge Bazel projects are becoming increasingly common in modern software development. Unfortunately, the IDE experience for these projects often leaves much to be desired. In this blog post, we’ll explore the new JetBrains Bazel plugin and how it can enhance your daily work with Bazel projects. We’ll begin with an overview of what Bazel users typically expect from IDEs and then dive into the features you can start using right away.\u003c/p\u003e\n\n\n\n\u003ch2\u003eBazel in your IDE\u003c/h2\u003e\n\n\n\n\u003cp\u003eBazel is a fast, scalable, and extensible build and test system that helps you manage complex codebases efficiently. It works with multi-language projects, offering support for C++, Java, Kotlin, Python, Rust, and other languages, and ensures consistent, reproducible builds across environments. With incremental build capabilities that recompile only what’s necessary and rich caching and parallel execution features, Bazel significantly enhances performance. Designed with extensibility in mind, it allows you to define custom build rules and scales seamlessly for monorepos and large-scale projects.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen it comes to Bazel support in IDEs, a variety of features are essential for streamlining workflows and boosting productivity. Seamless integration with Bazel configuration files (such as BUILD, MODULE.bazel, and WORKSPACE files) is a key requirement, with crucial support including syntax highlighting, code completion, and error checking to simplify the creation and maintenance of build rules. IDEs should also manage dependencies intelligently, automatically resolving them to ensure accurate project structures and robust code navigation, refactoring, and search capabilities.\u003c/p\u003e\n\n\n\n\u003cp\u003eIncremental build execution is another critical feature, enabling you to trigger and monitor Bazel builds directly from the IDE while leveraging performance-oriented features such as incremental compilation. Integrated test support is equally important, allowing developers to run and debug Bazel tests with tools like breakpoints and test filters. For multi-language projects, IDEs must handle cross-language dependencies effectively to ensure a smooth workflow.\u003c/p\u003e\n\n\n\n\u003cp\u003eSupport for custom Bazel rules and plugins is extremely valuable, as it lets developers tailor the build process without sacrificing IDE functionality. Efficient indexing and caching are also essential for maintaining responsiveness, especially in large monorepos or with complex configurations. Finally, seamless integration with complementary tools like debuggers and profilers creates a cohesive and efficient development environment. These capabilities allow you to focus on writing code while Bazel manages the complexities of builds and dependencies.\u003c/p\u003e\n\n\n\n\u003ch2\u003eIntroducing our sample project\u003c/h2\u003e\n\n\n\n\u003cp\u003eTo demonstrate the features available in the JetBrains Bazel plugin and help you get started with it, we’ll take a look at the CLI implementation of an \u003ca href=\"https://github.com/bravit/bazel-java-kotlin-sample\" target=\"_blank\" rel=\"noopener\"\u003eoversimplified calculator\u003c/a\u003e. Despite its simplicity, this calculator has evolved over years of development into a large monorepo with an advanced architecture, containing six packages implemented in Java and Kotlin – the languages the plugin currently supports:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1600\" height=\"345\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-3.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eFrom this diagram, you can see that some packages are nested while others are on the first level. The \u003ckbd\u003ecalc_core\u003c/kbd\u003e package serves as the foundation, with every other package in the project depending on it. Some packages, such as \u003ckbd\u003ekotlin-div\u003c/kbd\u003e and \u003ckbd\u003ekotlin-sub\u003c/kbd\u003e, can be developed independently of others, but they still require a dependency on \u003ckbd\u003ecalc_core\u003c/kbd\u003e. The developer of \u003ckbd\u003ekotlin-div\u003c/kbd\u003e has also provided JUnit 5 tests that can be executed using Bazel. Tests for \u003ckbd\u003ecalc_add\u003c/kbd\u003e, on the other hand, are generated by Bazel.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor this project, we use the \u003ca href=\"https://bazel.build/external/overview#bzlmod\" target=\"_blank\" rel=\"noopener\"\u003eBzlmod\u003c/a\u003e approach. The Bazel-related files are located within the project as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"raw\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e.\n├── .bazelrc\n├── BUILD\n├── MODULE.bazel\n├── calc_cli\n│   ├── BUILD\n│   ├── rules.bzl\n│   └── src\n├── calc_core\n│   ├── BUILD\n│   ├── operations\n│   │   ├── addition\n│   │   │   ├── BUILD\n│   │   │   ├── gen_tests.bzl\n│   │   │   └── src\n│   │   └── multiplication\n│   │   \t├── BUILD\n│   │   \t└── src\n│   └── src\n├── calc_div\n│   ├── BUILD\n│   └── src\n└── calc_sub\n    ├── BUILD\n    └── src\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eNote that we have \u003ckbd\u003eMODULE.bazel\u003c/kbd\u003e (which defines the whole Bazel repository), a collection of \u003ckbd\u003eBUILD\u003c/kbd\u003e files defining various targets, and files with rule definitions (\u003ckbd\u003e*.bzl\u003c/kbd\u003e) here and there. \u003c/p\u003e\n\n\n\n\u003ch2\u003eWorking with a Bazel project in IntelliJ IDEA\u003c/h2\u003e\n\n\n\n\u003cp\u003eLet’s explore the most common workflows in Bazel projects and see how the JetBrains Bazel plugin can assist.\u003c/p\u003e\n\n\n\n\u003ch3\u003eOpening the project: Exploring the structure and project views\u003c/h3\u003e\n\n\n\n\u003cp\u003eWhen we first open our Bazel project in IntelliJ IDEA, the Bazel plugin works with both Bazel and IDE to map Bazel packages onto IntelliJ IDEA’s workspace model. The JetBrains Bazel plugin aims to minimize the time required for the initial sync by waiting until a later stage to load all dependencies and metadata.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere’s what we get as a result:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1600\" height=\"900\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-4.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIntelliJ IDEA’s ability to properly recognize the project structure significantly enhances its performance for routine tasks like code completion and navigation. Several tools are available to help us examine the structure, including the \u003cem\u003eProject\u003c/em\u003e tool window’s \u003cem\u003ePackages \u003c/em\u003eview and the \u003cem\u003eBazel \u003c/em\u003etool window:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1600\" height=\"900\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-5.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe \u003cem\u003eBazel \u003c/em\u003etool window gives us access to the project-wide operations (such as resyncing, building, and configuring) and lists all the Bazel targets discovered during the latest sync. At some point, we might be interested in a subset of targets, for example tests, or in filtering targets by name:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"683\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-6.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe filtered target view can be plain or hierarchical, and when searching through targets, we can use case-sensitive prompts or regular expressions. \u003c/p\u003e\n\n\n\n\u003cp\u003eEven with the improved mapping of Bazel projects onto the IntelliJ IDEA workspace, very large projects might be too big for IDE support. For those cases, we support project views, special configuration files that restrict the area for which the IDE is responsible. \u003c/p\u003e\n\n\n\n\u003cp\u003eWhen you open a Bazel project without \u003ckbd\u003e.bazelproject\u003c/kbd\u003e files, the JetBrains Bazel plugin creates a default view in the \u003ckbd\u003e.bazelbsp\u003c/kbd\u003e  directory. Alternatively, you can create one yourself, for example, \u003ckbd\u003eprojectview.bazelproject\u003c/kbd\u003e:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"raw\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003ederive_targets_from_directories: true\ndirectories: .\u003c/pre\u003e\n\n\n\n\u003cp\u003eHere, we include all the project’s directories and derive all the targets from them.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor another example, with the following \u003ckbd\u003ediv-dev.bazelproject\u003c/kbd\u003e file, we can create a project view that provides support to only the directories needed for developers working on a Kotlin library that implements a division operation for our calculator:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"raw\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003ederive_targets_from_directories: true\ndirectories:\n  calc_div\n  calc_core\n  -calc_core/operations\u003c/pre\u003e\n\n\n\n\u003cp\u003eThese declarations mean that we include only two directories: \u003ckbd\u003ecalc_div\u003c/kbd\u003e and \u003ckbd\u003ecalc_core\u003c/kbd\u003e (excluding everything below \u003ckbd\u003ecalc_core/operations\u003c/kbd\u003e). Setting \u003ccode\u003ederive_targets_from_directories\u003c/code\u003e to \u003ccode\u003etrue\u003c/code\u003e instructs the plugin also to include all the targets found in the specified directories. \u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s put the \u003ckbd\u003ediv-dev.bazelproject\u003c/kbd\u003e file in the root folder of the project and execute the \u003cem\u003eLoad Project View\u003c/em\u003e action:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"900\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-7.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAs a result, the following subset of targets becomes available in the project, while the previous subset becomes unavailable:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"827\" height=\"609\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-8.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eReducing IDE support for packages outside the project view in this way should improve performance. \u003c/p\u003e\n\n\n\n\u003cp\u003eIn general, you can have more than one project view file in the root folder of your project. The one that is currently in effect is highlighted in the \u003cem\u003eProject \u003c/em\u003etool window:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1065\" height=\"476\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-9.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eTo get back to the full project, we can load the default \u003ckbd\u003e.bazelbsp/.bazelproject\u003c/kbd\u003e file or the  \u003ckbd\u003eprojectview.bazelproject\u003c/kbd\u003e file we created earlier. Switching between project views may take some time because it requires resyncing the whole project.\u003c/p\u003e\n\n\n\n\u003ch3\u003eEditing, building, running, debugging, and testing\u003c/h3\u003e\n\n\n\n\u003cp\u003eOnce IntelliJ IDEA has loaded all the information from the Bazel configuration, we can use the IDE as usual. Among other things, project configuration makes it possible to provide a smoother code editing experience, as the IDE is aware of available libraries, provides meaningful completion suggestions, and supports navigation through the codebase:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"855\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-10.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWe can also use Bazel to run or debug an application or test:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"372\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-11.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1396\" height=\"730\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-12.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAnother option is to run a test from the \u003cem\u003eBazel \u003c/em\u003etool window:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1381\" height=\"1452\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-13.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eFrom the \u003cem\u003eBazel t\u003c/em\u003eool window, we can also initiate a build for a particular target or jump to the corresponding \u003ckbd\u003eBUILD\u003c/kbd\u003e file to tweak any configuration options:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1151\" height=\"1284\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-14.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eReconfiguring or extending the project\u003c/h3\u003e\n\n\n\n\u003cp\u003eChanges in Bazel configuration files might require the project to be resynced with IntelliJ IDEA. The plugin detects such changes and suggests syncing with the IDE:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"369\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-15.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAdding files or packages to our repository is also detected and requires syncing for IntelliJ IDEA to work correctly. \u003c/p\u003e\n\n\n\n\u003ch3\u003eWorking with Starlark code\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe JetBrains Bazel plugin also provides code completion, navigation, and debugging support for Starlark code. \u003c/p\u003e\n\n\n\n\u003cp\u003eIn the following two screenshots, we change the name of tests generated for the addition operation, set a breakpoint, and launch a Starlark debugging session. Once we’re suspended on the breakpoint, we can inspect the available variables, and then we can continue the debugging session by using \u003cem\u003eStep Into\u003c/em\u003e or \u003cem\u003eStep Over\u003c/em\u003e or resuming execution. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"900\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-16.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1600\" height=\"900\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/12/image-17.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWhen debugging Starlark code, it’s always helpful to remember that Bazel checks if there are any changes since the last time the code was executed. Before we can start debugging, we need to have changed something in the corresponding files. \u003c/p\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn this blog post, we’ve reviewed how the JetBrains Bazel plugin integrates Bazel projects into IntelliJ IDEA, covering everything from project setup to debugging Starlark code. The plugin provides tools to help manage large and complex codebases, such as project views, target filtering, and incremental builds.\u003c/p\u003e\n\n\n\n\u003cp\u003eThese features aim to simplify working with Bazel projects by improving navigation, build management, and test execution within the IDE. While it may require some initial setup, the plugin can make handling Bazel configurations and workflows more straightforward over time. If you’re working with Bazel, check out the plugin to see how it can complement your development process.\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": null,
  "modifiedTime": null
}
