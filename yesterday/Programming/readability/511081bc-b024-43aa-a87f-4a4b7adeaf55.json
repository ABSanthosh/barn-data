{
  "id": "511081bc-b024-43aa-a87f-4a4b7adeaf55",
  "title": "Highlights from Git 2.48",
  "link": "https://github.blog/open-source/git/highlights-from-git-2-48/",
  "description": "The open source Git project just released Git 2.48. Here is GitHub's look at some of the most interesting features and changes introduced since last time. The post Highlights from Git 2.48 appeared first on The GitHub Blog.",
  "author": "Taylor Blau",
  "published": "Fri, 10 Jan 2025 18:28:50 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Git",
    "Open Source"
  ],
  "byline": "Taylor Blau",
  "length": 11244,
  "excerpt": "The open source Git project just released Git 2.48. Here is GitHub's look at some of the most interesting features and changes introduced since last time.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "The open source Git project just released Git 2.48 with features and bug fixes from over 93 contributors, 35 of them new. We last caught up with you on the latest in Git back when 2.47 was released. To celebrate this most recent release, here is GitHub’s look at some of the most interesting features and changes introduced since last time. Faster SHA-1s without compromising security When we published our coverage of Git’s 2.47 release, we neglected to mention a handful of performance changes that went in toward the very end of the cycle. Because this version contains a bugfix related to those changes, we figured now was as good a time as any1 to discuss those changes. You likely know that Git famously uses SHA-1 hashes by default to identify objects within your repository. (We have covered Git’s capability to use SHA-256 as its primary hash function instead, but for this tidbit we’ll focus on Git in its SHA-1 mode). What you may not know is that Git uses SHA-1 hashes internally in a couple of spots, too. Most notable for our purposes is that the pack format includes a trailing SHA-1 that stores the checksum of the preceding bytes. Git uses this data to validate that a pack’s contents matches what was advertised, and didn’t get corrupted in transit. By default, Git uses a collision detecting implementation of SHA-1, hardening it against common SHA-1 attacks like SHAttered and Shambles. (GitHub also uses the collision detecting SHA-1 implementation). While the collision detecting SHA-1 implementation protects Git against collision attacks, it does so at the cost of a few extra CPU cycles to look for the telltale signs of these attacks while checksumming. In most cases, the performance impact is negligible, and the benefit outweighs the minor performance cost. But when computing the checksum of a large pack (like when cloning a large repository), the cost adds up. For instance, we used Callgrind and measured that Git spends around 78% of its CPU computing a checksum during a simulated clone of torvalds/linux. Luckily, the trailing checksum is a data integrity measure, not a security one. For our purposes, this means that we can safely use a faster, non-collision-detecting implementation of SHA-1 specifically when computing trailing checksums (but nowhere else) without compromising security. Git 2.47 introduced new build-time options to specify a separate hash function implementation used specifically when computing trailing checksums. GitHub has used this option, and as a result measured a 10-13% performance improvement in serving fetches/clones across all repositories. You can try out Git’s ability to select alternative hash function implementations by building with make OPENSSL_SHA1_UNSAFE=1, or other _UNSAFE variants. [source, source, source] Bringing --remerge-diff to range-diff Regular readers of this series will no doubt recall our coverage of Git’s range-diff command (introduced back in Git 2.19), and the newer –remerge-diff option (released in Git 2.36). In case you’re a first-time reader, or neither of those ring a bell for you, don’t worry; here’s a brief refresher. Git’s range-diff command allows you to compare two sequences of commits, including changes to their order, commit messages, and the actual content changes they introduce. This can be useful when comparing a sequence of commits that were rebased (potentially tweaking the order and changes within the patches along the way), to what that set of commits looked like before the rebase. Git’s --remerge-diff option tells git show, git log, or various diff-related commands to view the differences between where Git would have stopped with the merge, and what is recorded in the merge. This can be useful when dealing with merge conflicts, since the --remerge-diff view will show you the difference between the conflicts and their resolution, showing you how a given merge conflict was handled. In Git 2.48, these two features meet for the first time, and range-diff now accepts a --remerge-diff option, so that if someone rebases a sequence of commits with --rebase-merges and potentially needs to make some changes, then the changes in merge commits can also be reviewed as part of the range-diff. As a side effect of this work, a longstanding bug with --remerge-diff was also fixed, which in particular will allow git log –remerge-diff to be used together with options that change the order of commit traversal (such as --reverse). [source, source] Memory leak-free tests in Git Beginning all the way back in Git 2.34, the Git project has been focused on reducing memory leaks with the goal of ultimately making Git leak-free. Since Git is a command line tool, each execution typically only lasts for a brief period of time, after which the kernel will free any memory allocated to Git that Git itself did not free. Because of this, memory leaks in Git have not posed a significant practical issue for everyday use. But, having memory leaks in Git makes it difficult to convert much of Git’s internals into a callable library, where having memory leaks would be a significant issue. To address this, there has been a concerted effort over many years to reduce the number of memory leaks in Git’s codebase, with the ultimate goal of eliminating them altogether. After much effort toward that end, Git can now run its test suite successfully with leak checking enabled. As a satisfying end result, much of the test infrastructure we talked about back in 2.34 was removed, resulting in a simpler test infrastructure. Making Git memory leak-free represents significant progress toward being able to convert parts of Git’s internals into a callable library. [source, source, source, source, source, source, source, source, source, source, source, source] Introducing Meson into Git The Git project uses GNU Make as the primary means to compile Git, meaning that if you can obtain a copy of Git’s source, running make should be all you need to get a working Git binary (provided you have the necessary dependencies, etc.). There are a couple of exceptions, namely that Git has some support for Autoconf and CMake, though they are not as up-to-date as Git’s Makefile. But as the Git project approaches its 20th anniversary later this year, its Makefile is starting to show its age. There have been over 2,000 commits to the Makefile, resulting in a build script that is nearly 4,000 lines long. In this release, the Git project has support for a new build system, Meson, as an alternative to building with GNU Make. While support for Meson is not yet as robust as building with Make, Meson does offer a handful of advantages over Make. Meson is easier to use than Make, making the project more accessible to newcomers or contributors who don’t have significant experience working with Make. Meson also has extensive IDE support, and supports out-of-tree and cross-platform builds, which are both significant assets to the Git project. Git will retain support for Make and CMake in addition to Meson for the foreseeable future, and retain support for Autoconf for a little longer. But if you’re curious to experiment with Git’s newest build system, you can run meson setup build \u0026\u0026 ninja -C build on a fresh copy of Git 2.48 or newer. [source] As the Git project has grown over the years, it has accumulated a number of features and modes that, while reasonable when first introduced, have since become outdated or superseded and are now deprecated. In Git 2.48, the Git project began collecting these now-deprecated features in a list stored in Documentation/BreakingChanges.txt. This document enables the Git project to discuss deprecating certain features and collects the project’s anticipated deprecations in a single place. On the other side of the equation, it allows users to see if they might be affected by an upcoming deprecation, and share their use-case of a particular feature with the project. Check out the list to see if there is anything on there that you might miss, and to get an early picture of what an eventual Git 3.0 release might look like! [source] If you’ve ever scripted around your repository’s references, you are likely familiar with Git’s for-each-ref command. In case you’re not, for-each-ref is a flexible tool that allows you to list references in your repository, apply custom formatting specifiers to them, and much more. Back in Git 2.44, we talked about some performance improvements that allowed git for-each-ref to run significantly faster by combining reference filtering and formatting into the same codepath, eliminating the need to store and sort the results in certain conditions. Git 2.48 extends those changes by allowing us to take advantage of the same optimizations even when asked to output the references in sorted order (under certain conditions). As long as those conditions are met, you can quickly output a small number of references even under --sort=refname independent of how many references your repository actually has. [source] While we’re on the topic of references, the reftable subsystem has received some more attention in this release. Git’s reftable implementation was updated to avoid explicit dependencies on some of Git’s convenience APIs, making further progress on being able to compile the reftable code without libgit.a. The reftable implementation was also updated to gracefully handle memory allocation failures instead of exiting the process immediately. Last but not least, the reftable code was updated to be able to reuse reference iterators, resulting in faster reference creation and lower memory usage when using reftables. For more about reftables, check out our previous coverage of reftables. [source, source, source, source] When you clone from a remote repository, the default branch that the remote repository uses is reflected in refs/remotes/origin/HEAD locally2. In prior versions of Git, subsequent fetches and pulls did not update this symbolic reference. With Git 2.48, if the remote has a default branch but refs/remotes/origin/HEAD is missing locally, then a fetch will update it. If you want to take it a step further, you can set remote.origin.followRemoteHead configuration to warn or always; if you do so, when refs/remotes/origin/HEAD already exists but does not match the default branch on the remote side, then when you run git fetch it will either warn you about the change or just automatically update refs/remote/origin/HEAD to the appropriate value depending on what setting you used. [source, source] Partial clones also received some love this cycle, fixing an infinite loop and avoiding promisor to non-promisor references that could break the repository after a git gc. For those unfamiliar with partial clones or want to learn more about their internals, you can read the guide “Get up to speed with partial clone and shallow clone.” [source, source, source, source] The rest of the iceberg That’s just a sample of changes from the latest release. For more, check out the release notes for 2.48, or any previous version in the Git repository. Notes Written by Taylor Blau is a Staff Software Engineer at GitHub where he works on Git.",
  "image": "https://github.blog/wp-content/uploads/2025/01/git-248.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eThe open source Git project just \u003ca href=\"https://lore.kernel.org/git/xmqqplku7cvm.fsf@gitster.g/\"\u003ereleased Git 2.48\u003c/a\u003e with features and bug fixes from over 93 contributors, 35 of them new. We last caught up with you on the latest in Git back when \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-47/\"\u003e2.47 was released\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eTo celebrate this most recent release, here is GitHub’s look at some of the most interesting features and changes introduced since last time.\u003c/p\u003e\n\u003ch2 id=\"faster-sha-1s-without-compromising-security\" id=\"faster-sha-1s-without-compromising-security\"\u003eFaster SHA-1s without compromising security\u003ca href=\"#faster-sha-1s-without-compromising-security\" aria-label=\"Faster SHA-1s without compromising security\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWhen we published our coverage of Git’s 2.47 release, we neglected to mention a handful of performance changes that went in toward the very end of the cycle. Because this version contains a bugfix related to those changes, we figured now was as good a time as any\u003csup id=\"fnref-81991-1\"\u003e\u003ca href=\"#fn-81991-1\" title=\"Read footnote.\"\u003e1\u003c/a\u003e\u003c/sup\u003e to discuss those changes.\u003c/p\u003e\n\u003cp\u003eYou likely know that Git famously uses SHA-1 hashes by default to identify objects within your repository. (We \u003ca href=\"https://github.blog/open-source/git/git-2-29-released\"\u003ehave covered\u003c/a\u003e Git’s capability to use SHA-256 as its primary hash function instead, but for this tidbit we’ll focus on Git in its SHA-1 mode). What you may not know is that Git uses SHA-1 hashes internally in a couple of spots, too. Most notable for our purposes is that the \u003ca href=\"https://git-scm.com/docs/pack-format\"\u003epack format\u003c/a\u003e includes a trailing SHA-1 that stores the checksum of the preceding bytes. Git uses this data to validate that a pack’s contents matches what was advertised, and didn’t get corrupted in transit.\u003c/p\u003e\n\u003cp\u003eBy default, Git uses a collision detecting implementation of SHA-1, hardening it against common SHA-1 attacks like \u003ca href=\"https://shattered.io/\"\u003eSHAttered\u003c/a\u003e and \u003ca href=\"https://sha-mbles.github.io/\"\u003eShambles\u003c/a\u003e. (GitHub \u003ca href=\"https://github.blog/news-insights/company-news/sha-1-collision-detection-on-github-com/\"\u003ealso uses\u003c/a\u003e the collision detecting SHA-1 implementation). While the collision detecting SHA-1 implementation protects Git against collision attacks, it does so at the cost of a few extra CPU cycles to look for the telltale signs of these attacks while checksumming.\u003c/p\u003e\n\u003cp\u003eIn most cases, the performance impact is negligible, and the benefit outweighs the minor performance cost. But when computing the checksum of a large pack (like when cloning a large repository), the cost adds up. For instance, we used \u003ca href=\"https://valgrind.org/docs/manual/cl-manual.html\"\u003eCallgrind\u003c/a\u003e and measured that Git spends around 78% of its CPU computing a checksum during a simulated clone of \u003ccode\u003etorvalds/linux\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eLuckily, the trailing checksum is a data integrity measure, not a security one. For our purposes, this means that we can safely use a faster, non-collision-detecting implementation of SHA-1 specifically when computing trailing checksums (but nowhere else) without compromising security. Git 2.47 introduced new build-time options to specify a separate hash function implementation used specifically when computing trailing checksums. GitHub has used this option, and as a result measured a 10-13% performance improvement in serving fetches/clones across all repositories.\u003c/p\u003e\n\u003cp\u003eYou can try out Git’s ability to select alternative hash function implementations by building with \u003ccode\u003emake OPENSSL_SHA1_UNSAFE=1\u003c/code\u003e, or other \u003ca href=\"https://github.com/git/git/blob/v2.48.0/Makefile#L513-L532\"\u003e\u003ccode\u003e_UNSAFE\u003c/code\u003e variants\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/59ee4f70136a12feb47979ca90baaf7c7beafe73...1b9e9be8b4694ea52d8aae93f311b1607c3576b7\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/b1c6ed40cde2c0e2fd9b41c51555eba48bce49a8...4638250b7b9288c197c16600630cefd4e196b4fc\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/6d81fe64dd646654bdb84fa5832c717954bf1696...863f2459a2047406c93758e8c3352cd5d2836f1e\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003ch2 id=\"bringing-remerge-diff-to-range-diff\" id=\"bringing-remerge-diff-to-range-diff\"\u003eBringing \u003ccode\u003e--remerge-diff\u003c/code\u003e to range-diff\u003ca href=\"#bringing-remerge-diff-to-range-diff\" aria-label=\"Bringing \u0026lt;code\u0026gt;--remerge-diff\u0026lt;/code\u0026gt; to range-diff\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eRegular readers of this series will no doubt recall our coverage of \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-19/#user-content-compare-histories-with-git-range-diff\"\u003eGit’s range-diff command\u003c/a\u003e (introduced back in Git 2.19), and \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-36/#review-merge-conflict-resolution-with-remerge-diff\"\u003ethe newer –remerge-diff option\u003c/a\u003e (released in Git 2.36). In case you’re a first-time reader, or neither of those ring a bell for you, don’t worry; here’s a brief refresher.\u003c/p\u003e\n\u003cp\u003eGit’s \u003ccode\u003erange-diff\u003c/code\u003e command allows you to compare two \u003cem\u003esequences\u003c/em\u003e of commits, including changes to their order, commit messages, and the actual content changes they introduce. This can be useful when comparing a sequence of commits that were rebased (potentially tweaking the order and changes within the patches along the way), to what that set of commits looked like before the rebase.\u003c/p\u003e\n\u003cp\u003eGit’s \u003ccode\u003e--remerge-diff\u003c/code\u003e option tells \u003ccode\u003egit show\u003c/code\u003e, \u003ccode\u003egit log\u003c/code\u003e, or various diff-related commands to view the differences between where Git would have stopped with the merge, and what is recorded in the merge. This can be useful when dealing with merge conflicts, since the \u003ccode\u003e--remerge-diff\u003c/code\u003e view will show you the difference between the conflicts and their resolution, showing you how a given merge conflict was handled.\u003c/p\u003e\n\u003cp\u003eIn Git 2.48, these two features meet for the first time, and \u003ccode\u003erange-diff\u003c/code\u003e now accepts a \u003ccode\u003e--remerge-diff\u003c/code\u003e option, so that if someone rebases a sequence of commits with \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-22/#rebase-merges-interactively\"\u003e\u003ccode\u003e--rebase-merges\u003c/code\u003e\u003c/a\u003e and potentially needs to make some changes, then the changes in merge commits can also be reviewed as part of the range-diff.\u003c/p\u003e\n\u003cp\u003eAs a side effect of this work, a longstanding bug with \u003ccode\u003e--remerge-diff\u003c/code\u003e was also fixed, which in particular will allow \u003ccode\u003egit log –remerge-diff\u003c/code\u003e to be used together with options that change the order of commit traversal (such as \u003ccode\u003e--reverse\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/c4cc685a62ffc06c86b1ecd1382c1b5cd0166189...88e59f8027ed0260584ccc0abd6fe435031614eb\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/commit/f94bfa151623d7e675db9465ae7ff0b33e4825f3\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003ch2 id=\"memory-leak-free-tests-in-git\" id=\"memory-leak-free-tests-in-git\"\u003eMemory leak-free tests in Git\u003ca href=\"#memory-leak-free-tests-in-git\" aria-label=\"Memory leak-free tests in Git\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eBeginning \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-34/\"\u003eall the way back in Git 2.34\u003c/a\u003e, the Git project has been focused on reducing \u003ca href=\"https://en.wikipedia.org/wiki/Memory_leak\"\u003ememory leaks\u003c/a\u003e with the goal of ultimately making Git leak-free. Since Git is a command line tool, each execution typically only lasts for a brief period of time, after which the kernel will free any memory allocated to Git that Git itself did not free. Because of this, memory leaks in Git have not posed a significant practical issue for everyday use.\u003c/p\u003e\n\u003cp\u003eBut, having memory leaks in Git makes it difficult to convert much of Git’s internals into a callable library, where having memory leaks would be a significant issue. To address this, there has been a concerted effort over many years to reduce the number of memory leaks in Git’s codebase, with the ultimate goal of eliminating them altogether.\u003c/p\u003e\n\u003cp\u003eAfter much effort toward that end, Git can now run its test suite successfully with leak checking enabled. As a satisfying end result, much of the test infrastructure we talked about back in 2.34 was removed, resulting in a simpler test infrastructure. Making Git memory leak-free represents significant progress toward being able to convert parts of Git’s internals into a callable library.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/98009afd24e2304bf923a64750340423473809ff...9972cd6004ac46a919d2e8773be976ef1e2d6a65\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/2a1a882890a3336f6f44d33793eedb70ff75d37a...fba95dad6ad83fd27eaf57cf526110faa8a20833\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/7b0defb3915eaa0bd118f0996e8c00b4eb2dc1ca...ebdbefa4fe9f618347124b37d44e517e0c6a3e4c\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/ecf7fc600a5218c9ee3863ee70d5a6e312164f30...fbf7a46d881429ef5495af7bbf3a6c3dacbf80b3\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/25673b1c476756ec0587fb0596ab3c22b96dc52a...f30bfafcd41d0f13575361957dc361aa2be4d4c5\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/3a7362eb9fad0c4838f5cfaa95ed3c51a4c18d93...77d4b3dd73c44b2c617345a6d9686d2f7f5b8a68\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/f123c19e72190e666fbcd827924fd1f090a9d6ae...13b23d2da552b9476a0025562bc4ab8954d5be45\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/2b800ec45e53051c41a85900009430704bfdf031...46f6ca2a68e02dd68132ed0b64cd55a8b6569e29\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/9293a931868f21029baf55935f2f092c3f06415f...12dfc2475ce4808df696fb67fc71a66793f78f06\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/d29d644d18737c7fbc2651ddbda64a3b552d9acb...66893a14d0c0d3850227def321312a7290317610\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/b31fb630c0fc6869a33ed717163e8a1210460d94...c810549be1dd31e1a0a1de5060a519a461533564\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/2f605347da0f6859175d6110cfd49b2d8937dea4...fc1ddf42af6742fae7e770cae20e30d7902014c0\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003ch2 id=\"introducing-meson-into-git\" id=\"introducing-meson-into-git\"\u003eIntroducing Meson into Git\u003ca href=\"#introducing-meson-into-git\" aria-label=\"Introducing Meson into Git\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe Git project uses \u003ca href=\"https://www.gnu.org/software/make/manual/make.html\"\u003eGNU Make\u003c/a\u003e as the primary means to compile Git, meaning that if you can obtain a copy of Git’s source, running \u003ccode\u003emake\u003c/code\u003e should be all you need to get a working Git binary (provided you have the necessary dependencies, etc.). There are a couple of exceptions, namely that Git has some support for Autoconf and CMake, though they are not as up-to-date as Git’s \u003ccode\u003eMakefile\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBut as the Git project approaches its 20th anniversary later this year, its \u003ccode\u003eMakefile\u003c/code\u003e is starting to show its age. There have been \u003ca href=\"https://github.com/git/git/commits/v2.48.0/Makefile\"\u003eover 2,000 commits\u003c/a\u003e to the \u003ccode\u003eMakefile\u003c/code\u003e, resulting in a build script that is nearly 4,000 lines long.\u003c/p\u003e\n\u003cp\u003eIn this release, the Git project has support for a new build system, \u003ca href=\"https://en.wikipedia.org/wiki/Meson_(software)\"\u003eMeson\u003c/a\u003e, as an alternative to building with GNU Make. While support for Meson is not yet as robust as building with Make, Meson does offer a handful of advantages over Make. Meson is easier to use than Make, making the project more accessible to newcomers or contributors who don’t have significant experience working with Make. Meson also has extensive IDE support, and supports out-of-tree and cross-platform builds, which are both significant assets to the Git project.\u003c/p\u003e\n\u003cp\u003eGit will retain support for Make and CMake in addition to Meson for the foreseeable future, and retain support for Autoconf for a little longer. But if you’re curious to experiment with Git’s newest build system, you can run \u003ccode\u003emeson setup build \u0026amp;\u0026amp; ninja -C build\u003c/code\u003e on a fresh copy of Git 2.48 or newer.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/ededd0d5dceefc308c670f4ed5f9fc727184e83d...904339edbd80ec5676616af6e072b41804c1c8eb\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003chr/\u003e\n\u003cul\u003e\n\u003cli\u003eAs the Git project has grown over the years, it has accumulated a number of features and modes that, while reasonable when first introduced, have since become outdated or superseded and are now deprecated. In Git 2.48, the Git project began collecting these now-deprecated features in a list stored in \u003ca href=\"https://github.com/git/git/blob/v2.48.0/Documentation/BreakingChanges.txt\"\u003e\u003ccode\u003eDocumentation/BreakingChanges.txt\u003c/code\u003e\u003c/a\u003e.\n\u003cp\u003eThis document enables the Git project to discuss deprecating certain features and collects the project’s anticipated deprecations in a single place. On the other side of the equation, it allows users to see if they might be affected by an upcoming deprecation, and share their use-case of a particular feature with the project. Check out the list to see if there is anything on there that you might miss, and to get an early picture of what an eventual Git 3.0 release might look like!\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/23d289d273d861f0a6244480e89ff937f66efa77...2454970930851179fb6486e6faa6342f008e7d9d\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf you’ve ever scripted around your repository’s references, you are likely familiar with Git’s \u003ccode\u003efor-each-ref\u003c/code\u003e command. In case you’re not, \u003ccode\u003efor-each-ref\u003c/code\u003e is a flexible tool that allows you to list references in your repository, apply custom formatting specifiers to them, and much more.\u003c/p\u003e\n\u003cp\u003eBack \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-44/\"\u003ein Git 2.44\u003c/a\u003e, we talked about \u003ca href=\"https://github.com/git/git/compare/e020e55a62dc3281504858d4091847d18ca63b2d...294bfc24418e81dfb204d14a3c3c24af9b195179\"\u003esome performance improvements\u003c/a\u003e that allowed \u003ccode\u003egit for-each-ref\u003c/code\u003e to run significantly faster by combining reference filtering and formatting into the same codepath, eliminating the need to store and sort the results in certain conditions.\u003c/p\u003e\n\u003cp\u003eGit 2.48 extends those changes by allowing us to take advantage of the same optimizations even when asked to output the references in sorted order (under certain conditions). As long as those conditions are met, you can quickly output a small number of references even under \u003ccode\u003e--sort=refname\u003c/code\u003e independent of how many references your repository actually has.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/bc627658b06155a0b1c3d0b1b0bf72db70770dc9...2e7c6d2f4112dd374f615f4e612e1cebbcb6d431\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhile we’re on the topic of references, the \u003ca href=\"https://github.com/git/git/tree/v2.48.0-rc0/reftable\"\u003ereftable subsystem\u003c/a\u003e has received some more attention in this release. Git’s reftable implementation was updated to avoid explicit dependencies on some of Git’s convenience APIs, making further progress on being able to compile the reftable code without \u003ccode\u003elibgit.a\u003c/code\u003e. The reftable implementation was also updated to gracefully handle memory allocation failures instead of exiting the process immediately. Last but not least, the reftable code was updated to be able to reuse reference iterators, resulting in faster reference creation and lower memory usage when using reftables.\u003c/p\u003e\n\u003cp\u003eFor more about reftables, check out \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-45/#preliminary-reftable-support\"\u003eour previous coverage of reftables\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/799450316b606d4b6cd5db6a6cc814f1710d923f...2179b5c831f6bc286acda15c7c7f4a573291ee5c\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/6a11438f43469f3815f2f0fc997bd45792ff04c0...20590cd287ada9c96efdf804e2bcdac0117c01b8\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/35f40385e441d5aa885f5aa813539d5ed9dc2d26...988e7f5e952bbb7b6ae885f4da744f536f22693f\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/de9278127e107455fda269d2db280782d77e5eba...7cf65e266020f23d31863a1f9508f375be818071\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhen you clone from a remote repository, the default branch that the remote repository uses is reflected in \u003ccode\u003erefs/remotes/origin/HEAD\u003c/code\u003e locally\u003csup id=\"fnref-81991-2\"\u003e\u003ca href=\"#fn-81991-2\" title=\"Read footnote.\"\u003e2\u003c/a\u003e\u003c/sup\u003e. In prior versions of Git, subsequent fetches and pulls did not update this symbolic reference. With Git 2.48, if the remote has a default branch but \u003ccode\u003erefs/remotes/origin/HEAD\u003c/code\u003e is missing locally, then a fetch will update it.\u003c/p\u003e\n\u003cp\u003eIf you want to take it a step further, you can set \u003ccode\u003eremote.origin.followRemoteHead\u003c/code\u003e configuration to \u003ccode\u003ewarn\u003c/code\u003e or \u003ccode\u003ealways\u003c/code\u003e; if you do so, when \u003ccode\u003erefs/remotes/origin/HEAD\u003c/code\u003e already exists but does not match the default branch on the remote side, then when you run \u003ccode\u003egit fetch\u003c/code\u003e it will either warn you about the change or just automatically update \u003ccode\u003erefs/remote/origin/HEAD\u003c/code\u003e to the appropriate value depending on what setting you used.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/cc01bad4a9f566cf4453c7edd6b433851b0835e2...761e62a09a8248bbab065a7159977a5de6d12aba\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/ae75cefd94075045edeb1d23283a47e4e48a9360...a1f34d5955035dc64f2e25da0ba2cc0a0c73c21c\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePartial clones also received some love this cycle, fixing an infinite loop and avoiding promisor to non-promisor references that could break the repository after a \u003ccode\u003egit gc\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor those unfamiliar with partial clones or want to learn more about their internals, you can read the guide “\u003ca href=\"https://github.blog/open-source/git/get-up-to-speed-with-partial-clone-and-shallow-clone/\"\u003eGet up to speed with partial clone and shallow clone\u003c/a\u003e.”\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/51ba60116019e03dee4c1b98107fb376aabcf1b1...486c9d3995c432510457656332a810b4d4dab547\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/090d24e9af6e9f59c3f7bee97c42bb1ae3c7f559...0c11ef13565b7428437645d8c54cce4fbbc7df36\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/8eaa06590fe916d4f2baa1fdb93959f1cfa9ab47...1f3d9b981465a8320878c725d2dd5924f452e786\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/4007617fda480f18a879ee733a5bc6540e29352c...ededd0d5dceefc308c670f4ed5f9fc727184e83d\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr/\u003e\n\u003ch2 id=\"the-rest-of-the-iceberg\" id=\"the-rest-of-the-iceberg\"\u003eThe rest of the iceberg\u003ca href=\"#the-rest-of-the-iceberg\" aria-label=\"The rest of the iceberg\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThat’s just a sample of changes from the latest release. For more, check out the release notes for \u003ca href=\"https://github.com/git/git/blob/v2.48.0/Documentation/RelNotes/2.48.0.txt\"\u003e2.48\u003c/a\u003e, or \u003ca href=\"https://github.com/git/git/tree/v2.48.0/Documentation/RelNotes\"\u003eany previous version\u003c/a\u003e in \u003ca href=\"https://github.com/git/git\"\u003ethe Git repository\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch4 id=\"notes\" id=\"notes\"\u003eNotes\u003ca href=\"#notes\" aria-label=\"Notes\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/443245?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/443245?v=4\u0026amp;s=200\" alt=\"Taylor Blau\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eTaylor Blau is a Staff Software Engineer at GitHub where he works on Git.\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2025-01-10T18:28:50Z",
  "modifiedTime": null
}
