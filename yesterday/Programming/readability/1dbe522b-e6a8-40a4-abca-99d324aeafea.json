{
  "id": "1dbe522b-e6a8-40a4-abca-99d324aeafea",
  "title": "Static as a Server",
  "link": "https://overreacted.io/static-as-a-server/",
  "description": "You wouldn't download a site.",
  "author": "",
  "published": "Thu, 08 May 2025 00:00:00 GMT",
  "source": "https://overreacted.io/rss.xml",
  "categories": null,
  "byline": "",
  "length": 4177,
  "excerpt": "You wouldn't download a site.",
  "siteName": "",
  "favicon": "https://overreacted.io/icon.png?e0852c1e2c7f0e65",
  "text": "RSC means React Server Components. And yet, although this blog is built with RSC, it is statically served from a Cloudflare CDN using their free static hosting plan. It costs me exactly zero. Zero. How is this possible? Aren’t these React Server Components? In the past, “server” and “static” frameworks were thought of as separate tools. For example, you might use Rails or PHP for a “server” app, but if you wanted to generate a “static” HTML+CSS+JS site, you might use Jekyll or Hugo instead. However, it’s getting more common for frameworks to support both “server” and “static” output modes. This builds on an insight that seems obvious in retrospect: you can take any “server” framework and get a “static” site out of it by running its “server” during the build and hitting it with a request for every page you want to generate, and then storing the responses on disk. It would be annoying to do this by hand, which is why newer frameworks tend to support this out of the box. I’ll call these frameworks “hybrid”. They’re conceptually “server” frameworks following the request/response model, but with an option for “static” output. Sometimes, focusing on one use case and nailing it makes the specialization worth it. But I don’t think this is happening here. I’m not aware of any way in which a “static” tool adds value to developers or to end users by being “static”-only. This doesn’t mean “static”-only tools are bad, but I see no reason to prefer them. On the other hand, I see several tangible reasons to prefer “hybrid” frameworks. First, the “hybrid” approach reduces tooling fragmentation—why have two ecosystems when the overlap is so large? The difference is just when the code runs. The “hybrid” approach also gives you both more flexibility and more granularity. It doesn’t lock you into a specific approach. In fact, the choice to do “server” or “static” rendering could now be done route by route. You can start with a fully “static” site and then later add a “server” page to show some dynamic content. Or you might start with a “server” site, and then add some “static” marketing pages. Your projects, some fully “static” and some “server”, can share code and plugins. And arguably, the request/response mental model itself feels natural and intuitive. There’s nothing RSC-specific to this approach. For example, Astro is not an RSC framework, but it is a “hybrid” framework. It produces “static” sites by default but you can opt into “server” features like API routes and on-demand rendering. Of course, the same applies to RSC. My blog is built with Next.js, which emits “static” sites by default. In fact, I’m enforcing that with the output: \"export\" option which disables any features that require a “server”—which I do not have. If I try to use any “server” features, my “static” build will fail, which is exactly what I want to happen in this case. In other words, this React Server Component runs at the build time during deploy: export default async function Home() { const posts = await getPosts(); return ( \u003cdiv className=\"relative -top-[10px] flex flex-col gap-8\"\u003e {posts.map((post) =\u003e ( \u003cLink key={post.slug} className=\"block py-4 hover:scale-[1.005] will-change-transform\" href={\"/\" + post.slug + \"/\"} \u003e \u003carticle\u003e \u003cPostTitle post={post} /\u003e \u003cPostMeta post={post} /\u003e \u003cPostSubtitle post={post} /\u003e \u003c/article\u003e \u003c/Link\u003e ))} \u003c/div\u003e ); } You can see its output on my homepage. The await getPosts() call reads from the filesystem—it’s neither some kind of a client fetch nor some kind of a server runtime code. This Server Component runs during deployment of my static blog. Yes, it’s confusing that we say “React Server components” even when we run them “statically”. But I’ve already explained that any “server” framework is already a “static” framework. You just need to hit it early and save its responses to the disk. So let’s just collectively agree to get over this. The code we write is exactly the same. “Static” is a “server” that runs ahead of time.Pay what you likeDiscuss on Bluesky  ·  Edit on GitHub",
  "image": "https://overreacted.io/static-as-a-server/opengraph-image?5b0b970dfd19bb8c",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eRSC means React \u003cem\u003eServer\u003c/em\u003e Components.\u003c/p\u003e\n\u003cp\u003eAnd yet, although this blog is built with RSC, it is statically served from a Cloudflare CDN using their free static hosting plan. It costs me exactly zero.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eZero.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eHow is this possible?\u003c/p\u003e\n\u003cp\u003eAren’t these React \u003cem\u003eServer\u003c/em\u003e Components?\u003c/p\u003e\n\u003cp\u003eIn the past, “server” and “static” frameworks were thought of as separate tools. For example, you might use Rails or PHP for a “server” app, but if you wanted to generate a “static” HTML+CSS+JS site, you might use Jekyll or Hugo instead.\u003c/p\u003e\n\u003cp\u003eHowever, it’s getting more common for frameworks to support both “server” and “static” \u003cem\u003eoutput modes.\u003c/em\u003e This builds on an insight that seems obvious in retrospect: you can take any “server” framework and get a “static” site out of it by running its “server” during the build and hitting it with a request for every page you want to generate, and then storing the responses on disk. It would be annoying to do this by hand, which is why newer frameworks tend to support this out of the box.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI’ll call these frameworks “hybrid”. They’re conceptually “server” frameworks following the request/response model, but with an option for “static” output.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eSometimes, focusing on one use case and nailing it makes the specialization worth it. But I don’t think this is happening here. I’m not aware of any way in which a “static” tool adds value to developers or to end users \u003cem\u003eby being\u003c/em\u003e “static”-only. This doesn’t mean “static”-only tools are bad, but I see no reason to \u003cem\u003eprefer\u003c/em\u003e them. On the other hand, I see several tangible reasons to prefer “hybrid” frameworks.\u003c/p\u003e\n\u003cp\u003eFirst, the “hybrid” approach reduces tooling fragmentation—why have two ecosystems when the overlap is so large? The difference is just \u003cem\u003ewhen\u003c/em\u003e the code runs.\u003c/p\u003e\n\u003cp\u003eThe “hybrid” approach also gives you both more flexibility and more granularity. It doesn’t lock you into a specific approach. In fact, the choice to do “server” or “static” rendering could now be done route by route. You can start with a fully “static” site and then later add a “server” page to show some dynamic content. Or you might start with a “server” site, and then add some “static” marketing pages. Your projects, some fully “static” and some “server”, can share code and plugins. And arguably, the request/response mental model itself feels natural and intuitive.\u003c/p\u003e\n\u003cp\u003eThere’s nothing RSC-specific to this approach. For example, \u003ca target=\"_blank\" href=\"https://docs.astro.build/\"\u003eAstro\u003c/a\u003e is \u003ca href=\"https://overreacted.io/rsc-for-astro-developers/\"\u003e\u003cem\u003enot\u003c/em\u003e\u003c/a\u003e an RSC framework, but it \u003cem\u003eis\u003c/em\u003e a “hybrid” framework. It produces “static” sites by default but you can opt into “server” features like \u003ca target=\"_blank\" href=\"https://docs.astro.build/en/guides/endpoints/#server-endpoints-api-routes\"\u003eAPI routes\u003c/a\u003e and \u003ca target=\"_blank\" href=\"https://docs.astro.build/en/guides/on-demand-rendering/\"\u003eon-demand rendering.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eOf course, the same applies to RSC.\u003c/p\u003e\n\u003cp\u003eMy blog is built with Next.js, which emits “static” sites by default. In fact, I’m \u003cem\u003eenforcing\u003c/em\u003e that with the \u003ca target=\"_blank\" href=\"https://nextjs.org/docs/pages/guides/static-exports\"\u003e\u003ccode\u003eoutput: \u0026#34;export\u0026#34;\u003c/code\u003e option\u003c/a\u003e which disables any features that require a “server”—which I do not have. If I try to use any “server” features, my “static” build will fail, which is exactly what I want to happen in this case.\u003c/p\u003e\n\u003cp\u003eIn other words, this \u003cem\u003eReact Server Component\u003c/em\u003e runs at the build time during deploy:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport\u003c/span\u003e\u003cspan\u003e default\u003c/span\u003e\u003cspan\u003e async\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e Home\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const \u003c/span\u003e\u003cspan\u003eposts\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e await \u003c/span\u003e\u003cspan\u003egetPosts\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003ediv\u003c/span\u003e\u003cspan\u003e className=\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003erelative -top-[10px] flex flex-col gap-8\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      {\u003c/span\u003e\u003cspan\u003eposts\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e =\u0026gt;\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e        \u0026lt;\u003c/span\u003e\u003cspan\u003eLink\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e          key={\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eslug\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e          className=\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eblock py-4 hover:scale-[1.005] will-change-transform\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e          href={\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e + \u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eslug\u003c/span\u003e\u003cspan\u003e + \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e        \u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e          \u0026lt;\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e            \u0026lt;\u003c/span\u003e\u003cspan\u003ePostTitle\u003c/span\u003e\u003cspan\u003e post={\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e            \u0026lt;\u003c/span\u003e\u003cspan\u003ePostMeta\u003c/span\u003e\u003cspan\u003e post={\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e            \u0026lt;\u003c/span\u003e\u003cspan\u003ePostSubtitle\u003c/span\u003e\u003cspan\u003e post={\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e          \u0026lt;/\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e        \u0026lt;/\u003c/span\u003e\u003cspan\u003eLink\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      ))}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003ediv\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eYou can see its output on my \u003ca href=\"https://overreacted.io/\"\u003ehomepage.\u003c/a\u003e The \u003ccode\u003eawait getPosts()\u003c/code\u003e call reads from the filesystem—it’s neither some kind of a client fetch nor some kind of a server runtime code. This Server Component runs \u003cem\u003eduring deployment\u003c/em\u003e of my static blog.\u003c/p\u003e\n\u003cp\u003eYes, it’s confusing that we say “React \u003cem\u003eServer\u003c/em\u003e components” even when we run them “statically”. But I’ve already explained that \u003cem\u003eany\u003c/em\u003e “server” framework is \u003cem\u003ealready\u003c/em\u003e a “static” framework. You just need to hit it early and save its responses to the disk.\u003c/p\u003e\n\u003cp\u003eSo let’s just collectively agree to get over this.\u003c/p\u003e\n\u003cp\u003eThe code we write is exactly the same.\u003c/p\u003e\n\u003cp\u003e“Static” is a “server” that runs ahead of time.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://ko-fi.com/gaearon\" target=\"_blank\"\u003e\u003cspan\u003e\u003c/span\u003ePay what you like\u003c/a\u003e\u003c/p\u003e\u003chr/\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://bsky.app/search?q=https%3A%2F%2Foverreacted.io%2Fstatic-as-a-server%2F\"\u003eDiscuss on Bluesky\u003c/a\u003e  ·  \u003ca target=\"_blank\" href=\"https://github.com/gaearon/overreacted.io/edit/main/public/static-as-a-server/index.md\"\u003eEdit on GitHub\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
