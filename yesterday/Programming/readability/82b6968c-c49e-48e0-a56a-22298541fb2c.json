{
  "id": "82b6968c-c49e-48e0-a56a-22298541fb2c",
  "title": "Challenges and Lessons Porting Code from C to Rust",
  "link": "https://www.infoq.com/news/2024/10/porting-av1-decoder-rust/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "In a two-installment series, Stephen Crane and Khyber Sen, software engineers at Immunant, recount how they ported VideoLAN and FFmpeg AV1 decoder from C to Rust for the Internet Security Research Group (ISRG). The series includes plenty of detail about how they ensured not to break things and optimized performance. By Sergio De Simone",
  "author": "Sergio De Simone",
  "published": "Wed, 16 Oct 2024 07:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Video Codec",
    "Open Source",
    "Safety",
    "Rust",
    "C",
    "Development",
    "news"
  ],
  "byline": "Sergio De Simone",
  "length": 5007,
  "excerpt": "In a two-installment series, Stephen Crane and Khyber Sen, software engineers at Immunant, recount how they ported VideoLAN and FFmpeg AV1 decoder from C to Rust for the Internet Security Research Gro",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s2_20241001113644/apple-touch-icon.png",
  "text": "In a two-installment series, Stephen Crane and Khyber Sen, software engineers at Immunant, recount how they ported VideoLAN and FFmpeg AV1 decoder from C to Rust for the Internet Security Research Group (ISRG). The series includes plenty of detail about how they ensured not to break things and optimized performance. The AV1 decoder used in VideoLan VLC and FFMpeg, dav1d, has been under development for over six years and contains about 50k lines of C code and 250k lines of assembly. As Crane notes, it is mature, fast, and widely used. It is also highly optimized to be small, portable and very fast. This strongly suggested to port it instead of rewriting it from scratch in Rust. The first choice engineers at Immunant had to make was whether to do the porting step by step or transpiling the entire codebase using c2rust to get an unsafe but runnable implementation in Rust, then refactor and rewrite it to make it safe and idiomatic. They decided to go the c2rust route because of two major advantages: the possibility to test the ported code while refactoring it and the reduced need for expert domain knowledge it required. We found that full CI testing from the beginning while rewriting and improving the Rust code was immensely beneficial. We could make cross-cutting changes to the codebase and run the existing dav1d tests on every commit. [...] The majority of the team on this project were experts in systems programming and Rust, but did not have previous experience with AV codecs. Our codec expert on the project, Frank Bossen, provided invaluable guidance but did not need to be involved in the bulk of the effort. The task of refactoring the ported Rust code into safe, idiomatic Rust was encumbered by several challenges, some related to mismatches between C and Rust, such as with lifetime management (borrowing), memory ownership, buffer pointers, and unions; others arising from dav1d design, strongly relying on shared mutable access across threads. Thread safety issues related to shared state were addressed through locks using Mutex and RwLock and validating at runtime that a thread could access data without introducing delays with Mutex::try_lock() and RwLock::try_read() / RwLock::try_write(). This approach was just fine to handle the cases where only a single thread needed to mutate a value shared across thread. However, dav1d also relies on concurrent access to a single buffer from multiple threads where each thread accesses a specific subrange of the buffer. Instead of using the more idiomatic Rust approach based on using disjoint slices exclusively assigned to different threads, Immunant engineers resorted to creating a buffer wrapper type, DisjointMut, responsible for handling mutable borrows and ensuring each of them has exclusive access. Two other challenging areas were self-referential structures, mostly used for cursors tracking buffer positions and links between context structures, and untagged unions. Since Rust does not allow to have self-referential structures, cursor pointers were replaced by integer indices while context structures were unlinked and referenced through function parameters. Untagged unions were converted into tagged Rust unions were convenient, while in other cases the zerocopy crate helped reinterpret the same bytes as two different types at runtime to avoid changing the union representation and size. A major goal of the porting was to preserve performance, so Immunant engineers took care to monitor performance regression throughout the refactoring stage for each commit. As they progressed in the transition to safe code, they realized performance was mostly impacted by rather subtle factors such as the cost of dynamic dispatch to assembly code, bounds checking, and structure initialization. Finally, they dealt with finer optimizations related to branching, inlining, and stack usage. The work on performance optimization brought a significant reduction in the overhead introduced by the porting, which went down to 6% from 11%. Overall, the process of porting dav1d to rav1d took over 20 person-months with a team of 3 developers and required more manual effort than it was initially foreseen, says Crane, but it showed it is possible to rewrite existing C code into safe, performant Rust and solve all threading and borrowing challenges. For applications where safety is paramount, rav1d offers a memory safe implementation without additional overhead from mitigations such as sandboxing. We believe that with continued optimization and improvements, the Rust implementation can compete favorably with a C implementation in all situations, while also providing memory safety. There is much more to learn from the process that led to the creation of rav1d than can be covered here, so do not miss the original write-up for the full detail. About the Author Sergio De Simone",
  "image": "https://res.infoq.com/news/2024/10/porting-av1-decoder-rust/en/headerimage/porting-dav1d-to-rust-1729008344356.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eIn a two-installment series, Stephen Crane and Khyber Sen, software engineers at \u003ca href=\"https://immunant.com/\"\u003eImmunant\u003c/a\u003e, recount how they \u003ca href=\"https://www.memorysafety.org/blog/porting-c-to-rust-for-av1/\"\u003eported VideoLAN and FFmpeg AV1 decoder from C to Rust\u003c/a\u003e for the Internet Security Research Group (ISRG). The series includes plenty of detail about how they ensured not to break things and \u003ca href=\"https://www.memorysafety.org/blog/rav1d-performance-optimization/\"\u003eoptimized performance\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ca href=\"https://en.wikipedia.org/wiki/AV1\"\u003eAV1 decoder\u003c/a\u003e used in VideoLan VLC and FFMpeg, \u003ca href=\"https://code.videolan.org/videolan/dav1d\"\u003edav1d\u003c/a\u003e, has been under development for over six years and contains about 50k lines of C code and 250k lines of assembly. As Crane notes, it is mature, fast, and widely used. It is also \u003ca href=\"https://code.videolan.org/videolan/dav1d#roadmap\"\u003ehighly optimized to be small, portable and very fast\u003c/a\u003e. This strongly suggested to port it instead of rewriting it from scratch in Rust.\u003c/p\u003e\n\n\u003cp\u003eThe first choice engineers at Immunant had to make was whether to do the porting step by step or transpiling the entire codebase using \u003ca href=\"http://c2ru.st/\"\u003ec2rust\u003c/a\u003e to get an unsafe but runnable implementation in Rust, then refactor and rewrite it to make it safe and idiomatic. They decided to go the \u003ccode\u003ec2rust\u003c/code\u003e route because of two major advantages: the possibility to test the ported code while refactoring it and the reduced need for expert domain knowledge it required.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eWe found that full CI testing from the beginning while rewriting and improving the Rust code was immensely beneficial. We could make cross-cutting changes to the codebase and run the existing dav1d tests on every commit. [...] The majority of the team on this project were experts in systems programming and Rust, but did not have previous experience with AV codecs. Our codec expert on the project, Frank Bossen, provided invaluable guidance but did not need to be involved in the bulk of the effort.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eThe task of refactoring the ported Rust code into safe, idiomatic Rust was encumbered by several challenges, some related to mismatches between C and Rust, such as with lifetime management (borrowing), memory ownership, buffer pointers, and unions; others arising from dav1d design, strongly relying on shared mutable access across threads.\u003c/p\u003e\n\n\u003cp\u003eThread safety issues related to shared state were addressed through locks using \u003ccode\u003eMutex\u003c/code\u003e and \u003ccode\u003eRwLock\u003c/code\u003e and validating at runtime that a thread could access data without introducing delays with \u003ccode\u003eMutex::try_lock()\u003c/code\u003e and \u003ccode\u003eRwLock::try_read()\u003c/code\u003e / \u003ccode\u003eRwLock::try_write()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis approach was just fine to handle the cases where only a single thread needed to mutate a value shared across thread. However, dav1d also relies on concurrent access to a single buffer from multiple threads where each thread accesses a specific subrange of the buffer. Instead of using the more idiomatic Rust approach based on using disjoint slices exclusively assigned to different threads, Immunant engineers resorted to creating a buffer wrapper type, \u003ccode\u003eDisjointMut\u003c/code\u003e, responsible for handling mutable borrows and ensuring each of them has exclusive access.\u003c/p\u003e\n\n\u003cp\u003eTwo other challenging areas were self-referential structures, mostly used for cursors tracking buffer positions and links between context structures, and untagged unions. Since Rust does not allow to have self-referential structures, cursor pointers were replaced by integer indices while context structures were unlinked and referenced through function parameters. Untagged unions were converted into tagged Rust unions were convenient, while in other cases the \u003ca href=\"https://docs.rs/zerocopy\"\u003ezerocopy\u003c/a\u003e crate helped reinterpret the same bytes as two different types at runtime to avoid changing the union representation and size.\u003c/p\u003e\n\n\u003cp\u003eA major goal of the porting was to preserve performance, so Immunant engineers took care to monitor performance regression throughout the refactoring stage for each commit. As they progressed in the transition to safe code, they realized performance was mostly impacted by rather subtle factors such as the cost of \u003ca href=\"https://www.memorysafety.org/blog/rav1d-performance-optimization/#dynamic-dispatch\"\u003edynamic dispatch\u003c/a\u003e to assembly code, \u003ca href=\"https://www.memorysafety.org/blog/rav1d-performance-optimization/#bounds-checking\"\u003ebounds checking\u003c/a\u003e, and \u003ca href=\"https://www.memorysafety.org/blog/rav1d-performance-optimization/#initialization\"\u003estructure initialization\u003c/a\u003e. Finally, they dealt with finer optimizations related to \u003ca href=\"https://www.memorysafety.org/blog/rav1d-performance-optimization/#branchless-instructions-and-stack-usage\"\u003ebranching, inlining, and stack usage\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe work on performance optimization brought a significant reduction in the overhead introduced by the porting, which went down to 6% from 11%. Overall, the process of porting dav1d to \u003ca href=\"https://github.com/memorysafety/rav1d/\"\u003erav1d\u003c/a\u003e took over 20 person-months with a team of 3 developers and required more manual effort than it was initially foreseen, says Crane, but it showed it is possible to rewrite existing C code into safe, performant Rust and solve all threading and borrowing challenges.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eFor applications where safety is paramount, rav1d offers a memory safe implementation without additional overhead from mitigations such as sandboxing. We believe that with continued optimization and improvements, the Rust implementation can compete favorably with a C implementation in all situations, while also providing memory safety.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eThere is much more to learn from the process that led to the creation of \u003ccode\u003erav1d\u003c/code\u003e than can be covered here, so do not miss the original write-up for the full detail.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Sergio-De-Simone\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eSergio De Simone\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-10-16T00:00:00Z",
  "modifiedTime": null
}
