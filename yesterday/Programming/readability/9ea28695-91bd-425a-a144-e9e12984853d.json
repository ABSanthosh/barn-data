{
  "id": "9ea28695-91bd-425a-a144-e9e12984853d",
  "title": "Modeling CORS frameworks with CodeQL to find security vulnerabilities",
  "link": "https://github.blog/security/application-security/modeling-cors-frameworks-with-codeql-to-find-security-vulnerabilities/",
  "description": "Discover how to increase the coverage of your CodeQL CORS security by modeling developer headers and frameworks. The post Modeling CORS frameworks with CodeQL to find security vulnerabilities appeared first on The GitHub Blog.",
  "author": "Kevin Stubbings",
  "published": "Thu, 10 Jul 2025 17:38:14 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Application security",
    "Security",
    "CodeQL",
    "GitHub Security Lab",
    "security research"
  ],
  "byline": "Kevin Stubbings",
  "length": 15034,
  "excerpt": "Discover how to increase the coverage of your CodeQL CORS security by modeling developer headers and frameworks.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "There are many different types of vulnerabilities that can occur when setting up CORS for your web application, and insecure usage of CORS frameworks and logic errors in homemade CORS implementations can lead to serious security vulnerabilities that allow attackers to bypass authentication. What’s more, attackers can utilize CORS misconfigurations to escalate the severity of other existing vulnerabilities in web applications to access services on the intranet. In this blog post, I’ll show how developers and security researchers can use CodeQL to model their own libraries, using work that I’ve done on CORS frameworks in Go as an example. Since the techniques that I used are useful for modeling other frameworks, this blog post can help you model and find vulnerabilities in your own projects. Because static analyzers like CodeQL have the ability to get the detailed information about structures, functions, and imported libraries, they’re more versatile than simple tools like grep. Plus, since CORS frameworks often use set configurations via specific structures and functions, using CodeQL is the easiest way to find misconfigurations in your codebases. When adding code to CodeQL, it’s best practice to always check the related queries and frameworks that are already available so that we’re not reinventing the wheel. For most languages, CodeQL already has a CORS query that covers many of the default cases. The easiest and simplest way of implementing CORS is by manually setting the  Access-Control-Allow-Origin and Access-Control-Allow-Credentials response headers. By modeling the frameworks for a language (e.g., Django, FastAPI, and Flask), CodeQL can identify where in the code those headers are set. Building on those models by looking for specific header values, CodeQL can find simple examples of CORS and see if they match vulnerable values. In the following Go example, unauthenticated resources on the servers could be accessed by arbitrary websites. func saveHandler(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Access-Control-Allow-Origin\", \"*\") } This may be troublesome for web applications that do not have authentication, such as tools intended to be hosted locally, because any dangerous endpoint could be accessed and exploited by an attacker. This is a snippet of the Go http framework where CodeQL models the Set method to find security-related header writes for this framework. Header writes are modeled by the HeaderWrite class in HTTP.qll, which is extended by other modules and classes in order to find all header writes. /** Provides a class for modeling new HTTP header-write APIs. */ module HeaderWrite { /** * A data-flow node that represents a write to an HTTP header. * * Extend this class to model new APIs. If you want to refine existing API models, * extend `HTTP::HeaderWrite` instead. */ abstract class Range extends DataFlow::ExprNode { /** Gets the (lower-case) name of a header set by this definition. */ string getHeaderName() { result = this.getName().getStringValue().toLowerCase() } Some useful methods such as getHeaderName and getHeaderValue can also  help in developing security queries related to headers, like CORS misconfiguration. Unlike the previous code example, the below pattern is an example of a CORS misconfiguration whose effect is much more impactful. func saveHandler(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Access-Control-Allow-Origin\", r.Header.Get(\"Origin\")) w.Header().Set(\"Access-Control-Allow-Credentials\", \"true\") } Reflecting the request origin header and allowing credentials permits an attacking website to make requests as the current logged in user, which could compromise the entire web application. Using CodeQL, we can model the headers, looking for specific headers and methods in order to help CodeQL identify the relevant security code structures to find CORS vulnerabilities. /** * An `Access-Control-Allow-Credentials` header write. */ class AllowCredentialsHeaderWrite extends Http::HeaderWrite { AllowCredentialsHeaderWrite() { this.getHeaderName() = headerAllowCredentials() } } /** * predicate for CORS query. */ predicate allowCredentialsIsSetToTrue(DataFlow::ExprNode allowOriginHW) { exists(AllowCredentialsHeaderWrite allowCredentialsHW | allowCredentialsHW.getHeaderValue().toLowerCase() = \"true\" Here, the HTTP::HeaderWrite class, as previously discussed, is used as a superclass for AllowCredentialsHeaderWrite, which finds all header writes of the value Access-Control-Allow-Credentials. Then, when our CORS misconfiguration query checks whether credentials are enabled, we use AllowCredentialsHeaderWrite as one of the possible sources to check. The simplest way for developers to set a CORS policy is by setting headers on HTTP responses in their server. By modeling all instances where a header is set, we can check for these CORS cases in our CORS query.  When modeling web frameworks using CodeQL, creating classes that extend more generic superclasses such as HTTP::HeaderWrite allows the impact of the model to be used in all CodeQL security queries that need them. Since headers in web applications can be so important, modeling all the ways they can be written to in a framework can be a great first step to adding that web framework to CodeQL. Modeling frameworks in CodeQL Rather than setting the CORS headers manually, many developers use a CORS framework instead.  Generally, CORS frameworks use middleware in the router of a web framework in order to add headers for every response. Some web frameworks will have their own CORS middleware, or you may have to include a third-party package. When modeling a CORS framework in CodeQL, you’re usually modeling the relevant structures and methods that signify a CORS policy. Once the modeled structure or methods have the correct values, the query should check that the structure is actually used in the codebase. For frameworks, we’ll look into Go as our language of choice since it has great support for CORS. Go provides a couple of CORS frameworks, but most follow the structure of Gin CORS, a CORS middleware framework for the Gin web framework. Here’s an example of a Gin configuration for CORS: package main import ( \"time\" \"github.com/gin-contrib/cors\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() router.Use(cors.New(cors.Config{ AllowOrigins: []string{\"https://foo.com\"}, AllowMethods: []string{\"PUT\", \"PATCH\"}, AllowHeaders: []string{\"Origin\"}, ExposeHeaders: []string{\"Content-Length\"}, AllowCredentials: true, AllowOriginFunc: func(origin string) bool { return origin == \"https://github.com\" } })) router.Run() } Now that we’ve modeled the router.Use method and cors.New — ensuring that cors.Config structure is at some point put into a router.Use function for actual use — we should then check all cors.Config structures for appropriate headers. Next, we find the appropriate headers fields we want to model. For a basic CORS misconfiguration query, we would model AllowOrigins, AllowCredentials, AllowOriginFunc. My pull requests for adding GinCors and RSCors to CodeQL can be used as references if you’re interested in seeing everything that goes into adding a framework to CodeQL. Below I’ll discuss some of the most important details. /** * A variable of type Config that holds the headers to be set. */ class GinConfig extends Variable { SsaWithFields v; GinConfig() { this = v.getBaseVariable().getSourceVariable() and v.getType().hasQualifiedName(packagePath(), \"Config\") } /** * Get variable declaration of GinConfig */ SsaWithFields getV() { result = v } } I modeled the Config type by using SSAWithFields, which is a single static assignment with fields. By using getSourceVariable(), we can get the variable that the structure was assigned to, which can help us see where the config is used. This allows us to find track variables that contain the CORS config structure across the codebase, including ones that are often initialized like this: func main() { ... // We can now track the corsConfig variable for further updates,such as when one of the fields is updated. corsConfig:= cors.New(cors.Config{ ... })} Now that we have the variable containing the relevant structure, we want to find all the instances where the variable is written to. By doing this, we can get an understanding of the relevant property values that have been assigned to it, and thus decide whether the CORS config is misconfigured. /** * A write to the value of Access-Control-Allow-Origins header */ class AllowOriginsWrite extends UniversalOriginWrite { DataFlow::Node base; // This models all writes to the AllowOrigins field of the Config type AllowOriginsWrite() { exists(Field f, Write w | f.hasQualifiedName(packagePath(), \"Config\", \"AllowOrigins\") and w.writesField(base, f, this) and // To ensure we are finding the correct field, we look for a write of type string (SliceLit) this.asExpr() instanceof SliceLit ) } /** * Get config variable holding header values */ override GinConfig getConfig() { exists(GinConfig gc | ( gc.getV().getBaseVariable().getDefinition().(SsaExplicitDefinition).getRhs() = base.asInstruction() or gc.getV().getAUse() = base ) and result = gc ) } } By adding the getConfig function, we return the previously created GinConfig, which allows us to verify that any writes to relevant headers affect the same configuration structure. For example, a developer may create a config that has a vulnerable origin and another config that allows credentials. The config that allows credentials wouldn’t be highlighted because only configs with vulnerable origins would create a security issue. By allowing CORS relevant header writes from different frameworks to all extend UniversalOriginWrite and UniversalCredentialsWrite, we can use those in our CORS misconfiguration query.  Writing CORS misconfiguration queries in CodeQL CORS issues are separated into two types: those without credentials (where we’re looking for * or null) and CORS with credentials (where we’re looking for origin reflection or null). If you want to keep the CodeQL query simple, you can create one query for each type of CORS vulnerability and assign their severity accordingly. For the Go language, CodeQL only has a “CORS with credentials” type of query because it’s applicable to all applications.  Let’s tie in the models we just created above to see how they’re used in the Go CORS misconfiguration query itself.  from DataFlow::ExprNode allowOriginHW, string message where allowCredentialsIsSetToTrue(allowOriginHW) and ( flowsFromUntrustedToAllowOrigin(allowOriginHW, message) or allowOriginIsNull(allowOriginHW, message) ) and not flowsToGuardedByCheckOnUntrusted(allowOriginHW) ... select allowOriginHW, message This query is only interested in critical vulnerabilities, so it checks whether credentials are allowed, and whether the allowed origins either come from a remote source or are hardcoded as null. In order to prevent false positives, it checks if there are certain guards — such as string comparisons —  before the remote source gets to the origin. Let’s take a closer look at the predicate allowCredentialsIsSetToTrue. /** * Holds if the provided `allowOriginHW` HeaderWrite's parent ResponseWriter * also has another HeaderWrite that sets a `Access-Control-Allow-Credentials` * header to `true`. */ predicate allowCredentialsIsSetToTrue(DataFlow::ExprNode allowOriginHW) { exists(AllowCredentialsHeaderWrite allowCredentialsHW | allowCredentialsHW.getHeaderValue().toLowerCase() = \"true\" | allowOriginHW.(AllowOriginHeaderWrite).getResponseWriter() = allowCredentialsHW.getResponseWriter() ) or ... For the first part of the predicate, we’ll use one of the headers we previously modeled, AllowCredentialsHeaderWrite, in order to compare headers. This will help us filter out all header writes that don’t have credentials set. exists(UniversalAllowCredentialsWrite allowCredentialsGin | allowCredentialsGin.getExpr().getBoolValue() = true | allowCredentialsGin.getConfig() = allowOriginHW.(UniversalOriginWrite).getConfig() and not exists(UniversalAllowAllOriginsWrite allowAllOrigins | allowAllOrigins.getExpr().getBoolValue() = true and allowCredentialsGin.getConfig() = allowAllOrigins.getConfig() ) or allowCredentialsGin.getBase() = allowOriginHW.(UniversalOriginWrite).getBase() and not exists(UniversalAllowAllOriginsWrite allowAllOrigins | allowAllOrigins.getExpr().getBoolValue() = true and allowCredentialsGin.getBase() = allowAllOrigins.getBase() ) ) } If CORS is not set through a header, we check for CORS frameworks using UniversalAllowCredentialsWrite.To filter out all instances whose corresponding Origin value is set to “*”, we use the not CodeQL keyword on UniversalAllowAllOriginsWrite,  since these are not applicable to this vulnerability. flowsFromUntrustedToAllowOrigin and allowOriginIsNull follow similar logic to ensure that the resulting header rights are vulnerable. When you model CodeQL queries to detect vulnerabilities related to CORS, you can’t use a one-size-fits-all approach. Instead, you have to tailor your queries to each web framework for two reasons:  Each framework implements CORS policies in its own way Vulnerability patterns depend on a framework’s behavior For example, we saw before in Gin CORS that there is an AllowOriginFunc. After looking at the documentation or experimenting with the code, we can see that it may override AllowOrigins. To improve our query, we could write a CodeQL query that looks for AllowOriginFuncs that always return true, which will result in a high severity vulnerability if paired with credentials. Take this with you  Once you understand the behavior of web frameworks and headers with CodeQL, it’s simple to find security issues in your code and reduce the chance of vulnerabilities making their way into your work. The number of CodeQL languages that support CORS misconfiguration queries is still growing, and there is always room for improvement from the community .  If this blog has been helpful in helping you write CodeQL queries, please feel free to open anything you’d like to share with the community in our CodeQL Community Packs. Finally, GitHub Code Security can help you secure your project by detecting and suggesting a fix for bugs such as CORS misconfiguration! Explore more GitHub Security Lab blog posts \u003e Written by",
  "image": "https://github.blog/wp-content/uploads/2025/03/github_logo_invertocat_dark_3.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eThere are many \u003ca href=\"https://github.blog/security/application-security/localhost-dangers-cors-and-dns-rebinding/\"\u003edifferent types of vulnerabilities\u003c/a\u003e that can occur when setting up CORS for your web application, and insecure usage of CORS frameworks and logic errors in homemade CORS implementations can lead to serious security vulnerabilities that allow attackers to bypass authentication. What’s more, attackers can utilize CORS misconfigurations to escalate the severity of other existing vulnerabilities in web applications to access services on the intranet.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" loading=\"lazy\" height=\"847\" width=\"1024\" src=\"https://github.blog/wp-content/uploads/2025/07/cors1.jpg?resize=1024%2C847\" alt=\"A CORS diagram showing communication between two websites in the browser.\" srcset=\"https://github.blog/wp-content/uploads/2025/07/cors1.jpg?w=1600 1600w, https://github.blog/wp-content/uploads/2025/07/cors1.jpg?w=300 300w, https://github.blog/wp-content/uploads/2025/07/cors1.jpg?w=768 768w, https://github.blog/wp-content/uploads/2025/07/cors1.jpg?w=1024 1024w, https://github.blog/wp-content/uploads/2025/07/cors1.jpg?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn this blog post, I’ll show how developers and security researchers can use CodeQL to model their own libraries, using work that I’ve done on CORS frameworks in Go as an example. Since the techniques that I used are useful for modeling other frameworks, this blog post can help you model and find vulnerabilities in your own projects. Because static analyzers like CodeQL have the ability to get the detailed information about structures, functions, and imported libraries, they’re more versatile than simple tools like grep. Plus, since CORS frameworks often use set configurations via specific structures and functions, using CodeQL is the easiest way to find misconfigurations in your codebases.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWhen adding code to CodeQL, it’s best practice to always check the related queries and frameworks that are already available so that we’re not reinventing the wheel. For most languages, CodeQL already has a CORS query that covers many of the default cases. The easiest and simplest way of implementing CORS is by manually setting the  \u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e and \u003ccode\u003eAccess-Control-Allow-Credentials\u003c/code\u003e \u003ca href=\"https://developer.mozilla.org/en-US/docs/Glossary/Response_header\"\u003eresponse headers\u003c/a\u003e. By modeling the frameworks for a language (e.g., Django, FastAPI, and Flask), CodeQL can identify where in the code those headers are set. Building on those models by looking for specific header values, CodeQL can find simple examples of CORS and see if they match vulnerable values.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn the following Go example, unauthenticated resources on the servers could be accessed by arbitrary websites.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003efunc saveHandler(w http.ResponseWriter, r *http.Request) { \n    w.Header().Set(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;) \n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis may be troublesome for web applications that do not have authentication, such as tools intended to be hosted locally, because any dangerous endpoint could be accessed and exploited by an attacker.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is a snippet of the Go http framework where CodeQL models the \u003ccode\u003eSet\u003c/code\u003e method to find security-related header writes for this framework. Header writes are modeled by the \u003ccode\u003eHeaderWrite\u003c/code\u003e class in \u003ccode\u003eHTTP.qll\u003c/code\u003e, which is extended by other modules and classes in order to find all header writes.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e /** Provides a class for modeling new HTTP header-write APIs. */\n  module HeaderWrite {\n    /**\n     * A data-flow node that represents a write to an HTTP header.\n     *\n     * Extend this class to model new APIs. If you want to refine existing API models,\n     * extend `HTTP::HeaderWrite` instead.\n     */\n    abstract class Range extends DataFlow::ExprNode {\n      /** Gets the (lower-case) name of a header set by this definition. */\n      string getHeaderName() { result = this.getName().getStringValue().toLowerCase() }\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eSome useful methods such as \u003ccode\u003egetHeaderName\u003c/code\u003e and \u003ccode\u003egetHeaderValue\u003c/code\u003e can also  help in developing security queries related to headers, like CORS misconfiguration. Unlike the previous code example, the below pattern is an example of a CORS misconfiguration whose effect is much more impactful.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003efunc saveHandler(w http.ResponseWriter, r *http.Request) { \n    w.Header().Set(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \n    r.Header.Get(\u0026#34;Origin\u0026#34;))\n    w.Header().Set(\u0026#34;Access-Control-Allow-Credentials\u0026#34;, \n    \u0026#34;true\u0026#34;) \n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eReflecting the request origin header and allowing credentials permits an attacking website to make requests as the current logged in user, which could compromise the entire web application.\u003c/p\u003e\n\n\n\n\u003cp\u003eUsing CodeQL, we can model the headers, looking for specific headers and methods in order to help CodeQL identify the relevant security code structures to find CORS vulnerabilities.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e/**\n * An `Access-Control-Allow-Credentials` header write.\n */\nclass AllowCredentialsHeaderWrite extends Http::HeaderWrite {\n    AllowCredentialsHeaderWrite() {\n        this.getHeaderName() = headerAllowCredentials()\n    }\n}\n\n/**\n * predicate for CORS query.\n */\npredicate allowCredentialsIsSetToTrue(DataFlow::ExprNode allowOriginHW) {\n        exists(AllowCredentialsHeaderWrite allowCredentialsHW |\n                allowCredentialsHW.getHeaderValue().toLowerCase() = \u0026#34;true\u0026#34;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eHere, the \u003ccode\u003eHTTP::HeaderWrite\u003c/code\u003e class, as previously discussed, is used as a superclass for \u003ccode\u003eAllowCredentialsHeaderWrite\u003c/code\u003e, which finds all header writes of the value \u003ccode\u003eAccess-Control-Allow-Credentials\u003c/code\u003e. Then, when our CORS misconfiguration query checks whether credentials are enabled, we use AllowCredentialsHeaderWrite as one of the possible sources to check.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe simplest way for developers to set a CORS policy is by setting headers on HTTP responses in their server. By modeling all instances where a header is set, we can check for these CORS cases in our CORS query. \u003c/p\u003e\n\n\n\n\u003cp\u003eWhen modeling web frameworks using CodeQL, creating classes that extend more generic superclasses such as \u003ccode\u003eHTTP::HeaderWrite\u003c/code\u003e allows the impact of the model to be used in all CodeQL security queries that need them. Since headers in web applications can be so important, modeling all the ways they can be written to in a framework can be a great first step to adding that web framework to CodeQL.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"modeling-frameworks-in-codeql\"\u003eModeling frameworks in CodeQL\u003c/h2\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"961\" height=\"877\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/07/cors2.png?resize=961%2C877\" alt=\"A computer with two windows open showing secure code.\" srcset=\"https://github.blog/wp-content/uploads/2025/07/cors2.png?w=961 961w, https://github.blog/wp-content/uploads/2025/07/cors2.png?w=300 300w, https://github.blog/wp-content/uploads/2025/07/cors2.png?w=768 768w\" sizes=\"auto, (max-width: 961px) 100vw, 961px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eRather than setting the CORS headers manually, many developers use a CORS framework instead.  Generally, CORS frameworks use middleware in the router of a web framework in order to add headers for every response. Some web frameworks will have their own CORS middleware, or you may have to include a third-party package. When modeling a CORS framework in CodeQL, you’re usually modeling the relevant structures and methods that signify a CORS policy. Once the modeled structure or methods have the correct values, the query should check that the structure is actually used in the codebase.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor frameworks, we’ll look into Go as our language of choice since it has great support for CORS. Go provides a couple of CORS frameworks, but most follow the structure of Gin CORS, a CORS middleware framework for the Gin web framework. Here’s an example of a Gin configuration for CORS:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport (\n  \u0026#34;time\u0026#34;\n\n  \u0026#34;github.com/gin-contrib/cors\u0026#34;\n  \u0026#34;github.com/gin-gonic/gin\u0026#34;\n)\n\nfunc main() {\n  router := gin.Default()\n  router.Use(cors.New(cors.Config{\n    AllowOrigins:     []string{\u0026#34;https://foo.com\u0026#34;},\n    AllowMethods:     []string{\u0026#34;PUT\u0026#34;, \u0026#34;PATCH\u0026#34;},\n    AllowHeaders:     []string{\u0026#34;Origin\u0026#34;},\n    ExposeHeaders:    []string{\u0026#34;Content-Length\u0026#34;},\n    AllowCredentials: true,\n    AllowOriginFunc: func(origin string) bool {\n      return origin == \u0026#34;https://github.com\u0026#34;\n    }\n  }))\n  router.Run()\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow that we’ve modeled the \u003ccode\u003erouter.Use\u003c/code\u003e method and \u003ccode\u003ecors.New\u003c/code\u003e — ensuring that \u003ccode\u003ecors.Config\u003c/code\u003e structure is at some point put into a \u003ccode\u003erouter.Use\u003c/code\u003e function for actual use — we should then check all \u003ccode\u003ecors.Config\u003c/code\u003e structures for appropriate headers.\u003c/p\u003e\n\n\n\n\u003cp\u003eNext, we find the appropriate headers fields we want to model. For a basic CORS misconfiguration query, we would model \u003ccode\u003eAllowOrigins\u003c/code\u003e, \u003ccode\u003eAllowCredentials\u003c/code\u003e, \u003ccode\u003eAllowOriginFunc\u003c/code\u003e. My pull requests for adding GinCors and RSCors to CodeQL can be used as references if you’re interested in seeing everything that goes into adding a framework to CodeQL. Below I’ll discuss some of the most important details.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e /**\n   * A variable of type Config that holds the headers to be set.\n   */\n  class GinConfig extends Variable {\n    SsaWithFields v;\n\n    GinConfig() {\n      this = v.getBaseVariable().getSourceVariable() and\n      v.getType().hasQualifiedName(packagePath(), \u0026#34;Config\u0026#34;)\n    }\n\n    /**\n     * Get variable declaration of GinConfig\n     */\n    SsaWithFields getV() { result = v }\n  }\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eI modeled the Config type by using SSAWithFields, which is a \u003ca href=\"https://en.wikipedia.org/wiki/Static_single-assignment_form\"\u003esingle static assignment\u003c/a\u003e with fields. By using \u003ccode\u003egetSourceVariable()\u003c/code\u003e, we can get the variable that the structure was assigned to, which can help us see where the config is used. This allows us to find track variables that contain the CORS config structure across the codebase, including ones that are often initialized like this:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003efunc main() {\n...\n// We can now track the corsConfig variable for further updates,such as when one of the fields is updated.\ncorsConfig:= cors.New(cors.Config{\n...\n})}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow that we have the variable containing the relevant structure, we want to find all the instances where the variable is written to. By doing this, we can get an understanding of the relevant property values that have been assigned to it, and thus decide whether the CORS config is misconfigured.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e /**\n   * A write to the value of Access-Control-Allow-Origins header\n   */\n  class AllowOriginsWrite extends UniversalOriginWrite {\n    DataFlow::Node base;\n\t\n\t// This models all writes to the AllowOrigins field of the Config type\n    AllowOriginsWrite() {\n\n      exists(Field f, Write w |\n        f.hasQualifiedName(packagePath(), \u0026#34;Config\u0026#34;, \u0026#34;AllowOrigins\u0026#34;) and\n        w.writesField(base, f, this) and\n\n\t\t// To ensure we are finding the correct field, we look for a write of type string (SliceLit)\n        this.asExpr() instanceof SliceLit\n      )\n\n    }\n\n    /**\n     * Get config variable holding header values\n     */\n    override GinConfig getConfig() {\n      exists(GinConfig gc |\n        (\n          gc.getV().getBaseVariable().getDefinition().(SsaExplicitDefinition).getRhs() =\n            base.asInstruction() or\n          gc.getV().getAUse() = base\n        ) and\n        result = gc\n      )\n    }\n  }\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eBy adding the \u003ccode\u003egetConfig\u003c/code\u003e function, we return the previously created \u003ccode\u003eGinConfig\u003c/code\u003e, which allows us to verify that any writes to relevant headers affect the same configuration structure. For example, a developer may create a config that has a vulnerable origin and another config that allows credentials. The config that allows credentials wouldn’t be highlighted because only configs with vulnerable origins would create a security issue. By allowing CORS relevant header writes from different frameworks to all extend \u003ccode\u003eUniversalOriginWrite\u003c/code\u003e and \u003ccode\u003eUniversalCredentialsWrite\u003c/code\u003e, we can use those in our CORS misconfiguration query. \u003c/p\u003e\n\n\n\n\u003ch2 id=\"writing-cors-misconfiguration-queries-in-codeql\"\u003eWriting CORS misconfiguration queries in CodeQL\u003c/h2\u003e\n\n\n\n\u003cp\u003eCORS issues are separated into two types: those without credentials (where we’re looking for * or null) and CORS with credentials (where we’re looking for origin reflection or null). If you want to keep the CodeQL query simple, you can create one query for each type of CORS vulnerability and assign their severity accordingly. For the Go language, CodeQL only has a “CORS with credentials” type of query because it’s applicable to all applications. \u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s tie in the models we just created above to see how they’re used in the Go CORS misconfiguration query itself. \u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003efrom DataFlow::ExprNode allowOriginHW, string message\nwhere\n  allowCredentialsIsSetToTrue(allowOriginHW) and\n  (\n    flowsFromUntrustedToAllowOrigin(allowOriginHW, message)\n    or\n    allowOriginIsNull(allowOriginHW, message)\n  ) and\n  not flowsToGuardedByCheckOnUntrusted(allowOriginHW)\n...\nselect allowOriginHW, message\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis query is only interested in critical vulnerabilities, so it checks whether credentials are allowed, and whether the allowed origins either come from a remote source or are hardcoded as null. In order to prevent false positives, it checks if there are certain guards — such as string comparisons —  before the remote source gets to the origin. Let’s take a closer look at the predicate \u003ccode\u003eallowCredentialsIsSetToTrue\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e/**\n * Holds if the provided `allowOriginHW` HeaderWrite\u0026#39;s parent ResponseWriter\n * also has another HeaderWrite that sets a `Access-Control-Allow-Credentials`\n * header to `true`.\n */\npredicate allowCredentialsIsSetToTrue(DataFlow::ExprNode allowOriginHW) {\n  exists(AllowCredentialsHeaderWrite allowCredentialsHW |\n    allowCredentialsHW.getHeaderValue().toLowerCase() = \u0026#34;true\u0026#34;\n  |\n    allowOriginHW.(AllowOriginHeaderWrite).getResponseWriter() =\n      allowCredentialsHW.getResponseWriter()\n  )\n  or\n...\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFor the first part of the predicate, we’ll use one of the headers we previously modeled, AllowCredentialsHeaderWrite, in order to compare headers. This will help us filter out all header writes that don’t have credentials set.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e  exists(UniversalAllowCredentialsWrite allowCredentialsGin |\n    allowCredentialsGin.getExpr().getBoolValue() = true\n  |\n    allowCredentialsGin.getConfig() = allowOriginHW.(UniversalOriginWrite).getConfig() and\n    not exists(UniversalAllowAllOriginsWrite allowAllOrigins |\n      allowAllOrigins.getExpr().getBoolValue() = true and\n      allowCredentialsGin.getConfig() = allowAllOrigins.getConfig()\n    )\n    or\n    allowCredentialsGin.getBase() = allowOriginHW.(UniversalOriginWrite).getBase() and\n    not exists(UniversalAllowAllOriginsWrite allowAllOrigins |\n      allowAllOrigins.getExpr().getBoolValue() = true and\n      allowCredentialsGin.getBase() = allowAllOrigins.getBase()\n    )\n  )\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf CORS is not set through a header, we check for CORS frameworks using \u003ccode\u003eUniversalAllowCredentialsWrite\u003c/code\u003e.To filter out all instances whose corresponding Origin value is set to “*”, we use the \u003ccode\u003enot\u003c/code\u003e CodeQL keyword on \u003ccode\u003eUniversalAllowAllOriginsWrite\u003c/code\u003e,  since these are not applicable to this vulnerability. \u003ccode\u003eflowsFromUntrustedToAllowOrigin\u003c/code\u003e and \u003ccode\u003eallowOriginIsNull\u003c/code\u003e follow similar logic to ensure that the resulting header rights are vulnerable.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWhen you model CodeQL queries to detect vulnerabilities related to CORS, you can’t use a one-size-fits-all approach. Instead, you have to tailor your queries to each web framework for two reasons: \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eEach framework implements CORS policies in its own way\u003c/li\u003e\n\n\n\n\u003cli\u003eVulnerability patterns depend on a framework’s behavior\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eFor example, we saw before in Gin CORS that there is an \u003ccode\u003eAllowOriginFunc\u003c/code\u003e. After looking at the documentation or experimenting with the code, we can see that it may override \u003ccode\u003eAllowOrigins\u003c/code\u003e. To improve our query, we could write a CodeQL query that looks for \u003ccode\u003eAllowOriginFunc\u003c/code\u003es that always return true, which will result in a high severity vulnerability if paired with credentials.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"take-this-with-you\"\u003eTake this with you \u003c/h2\u003e\n\n\n\n\u003cp\u003eOnce you understand the behavior of web frameworks and headers with CodeQL, it’s simple to find security issues in your code and reduce the chance of vulnerabilities making their way into your work. The number of CodeQL languages that support CORS misconfiguration queries is still growing, and there is always room for improvement from the community . \u003c/p\u003e\n\n\n\n\u003cp\u003eIf this blog has been helpful in helping you write CodeQL queries, please feel free to open anything you’d like to share with the community in our \u003ca href=\"https://github.com/GitHubSecurityLab/CodeQL-Community-Packs\"\u003eCodeQL Community Packs\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eFinally, \u003ca href=\"https://github.com/security/advanced-security/code-security\"\u003eGitHub Code Security\u003c/a\u003e can help you secure your project by detecting and suggesting a fix for bugs such as \u003ca href=\"https://codeql.github.com/codeql-query-help/javascript/js-cors-misconfiguration-for-credentials/\"\u003eCORS misconfiguration\u003c/a\u003e!\u003c/p\u003e\n\n\n\n\u003cdiv\u003e\n\u003cp\u003e\u003cstrong\u003eExplore more\u003c/strong\u003e GitHub Security Lab \u003ca href=\"https://github.blog/tag/github-security-lab/\"\u003eblog posts \u0026gt;\u003c/a\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/11400619?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/11400619?v=4\u0026amp;s=200\" alt=\"Kevin Stubbings\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2025-07-10T17:38:14Z",
  "modifiedTime": "2025-07-10T17:38:15Z"
}
