{
  "id": "9f273cf6-9cc7-4d2e-9754-1c7a3abee5b3",
  "title": "Steve Klabnik and Herb Sutter Talk About Rust and C++",
  "link": "https://www.infoq.com/news/2024/10/klabnik-sutter-on-cpp-rust/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "In a Software Engineering Daily podcast hosted by Kevin Ball, Steve Klabnik and Herb Sutter discuss several topics related to Rust and C++, including what the languages have in common and what is unique to them, where they differ, how they evolve, and more. By Sergio De Simone",
  "author": "Sergio De Simone",
  "published": "Sun, 27 Oct 2024 17:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Programming Languages",
    "Asynchronous Programming",
    "C++",
    "Rust",
    "Safety",
    "Development",
    "news"
  ],
  "byline": "Sergio De Simone",
  "length": 5843,
  "excerpt": "In a Software Engineering Daily podcast hosted by Kevin Ball, Steve Klabnik and Herb Sutter discuss several topics related to Rust and C++, including what the languages have in common and what is uniq",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s1_20241022062452/apple-touch-icon.png",
  "text": "In a Software Engineering Daily podcast hosted by Kevin Ball, Steve Klabnik and Herb Sutter discuss several topics related to Rust and C++, including what the languages have in common and what is unique to them, where they differ, how they evolve, and more. The perfect language does not exist For Klabnik, besides the common idea about Rust being a memory-safe language, what really makes it different is its taking inspiration from ideas that have not been popular in more recent programming languages but that are well-known in the programming languages space. Sutter, on the other hand, stresses the idea of zero-overhead abstraction, i.e., the idea you can express things in a higher-level way without paying an excessive cost for that abstraction. Here Klabnik echoes Sutter considering how the primary mechanism Rust achieves \"zero-cost\" abstractions is through types: [Klabnik] Basically, the more that you could express in the type system, the less you needed to check at runtime. But not all abstractions are zero-overhead, says Sutter, bringing the example of two C++ features that compilers invariably offer the option to disable: exception handling and runtime typing. [Sutter] If you look at why, it's because those two can be written better by hand. Or you pay for them even if you don't use them. So that brings both to the idea that language design is just as much of an art or a craft, heavily influenced by taste and a philosophy of what a language ought to be, so we are not yer to the point where a language can be the perfect language. Areas of applicability Coming to how the languages are used, Sutter says they have a very similar target, with ecosystem maturity and thread-safety guarantees being what may lead to choose one over the other. Klabnik stresses out the fact that Rust is being often adopted to create networked services, even at large companies: [Klabnik] Cloudflare, for example, is using Rust code as their backend. And they power 10% of internet traffic. Other companies [...] had some stuff in Python and they rewrote it in Rust. And then they were able to drop thousands of servers off of their cloud bill. Sutter highlights the ability of C++ of giving you control of time and space and the richness of the tool ecosystem that has been built around C++ for 30+ years, while Rust is comparatively still a young language. [Sutter] Right now, there are things where I can't ship code out of the company unless it goes through this tool. And it understands C++ but it doesn't understand Rust. I can't ship that code. If I write in Rust, I'm not allowed to ship it without a VP exception How languages evolve When it comes to language evolution, the key point is when it is worth to add complexity to the language for a new feature, which is not always an easy decision. In this regard, one of the things Klabnik praises about C++ is its commitment to backwards compatibility \"within reason\". [Klabnik] I'm not saying that the rust team necessarily doesn't have a similar view in the large. But there's been some recent proposals about some things that kind of add a degree of complexity that I'm am not necessarily personally comfortable with. Sutter mentions how the C# team at some point decided to add nullability to the language and, although this is surely a great thing to have, it also brought hidden costs: [Sutter] Because there's complexity for users and the complexity in the language now but also for the next 20 years. Because you're going to be supporting this thing forever, right? And it's going to constrain evolution forever. [...] It turns out that once you add nullability [...] the whole language needs to know about it more than you first thought. To further stress how hard it is to take such kinds of decisions, Klabnik recalls a case where he fought against Rust's postfix syntax for await, which differs from most other languages where it is prefix: [Klabnik] Now that I'm writing a lot of code with async and await, gosh, I'm glad they went with postfix await. Because it's like so, so much nicer and in so many ways. The power of language editions One way for the Rust Core team to manage change is defining language editions to preserve source compatibility when new features are added. Sutter shows himself to be interested in understanding whether this mechanism could have made it possible to introduce C++ async/await support without needing to adopt the co_async and co_await keywords to prevent clashing existing codebases. Klabnik explains editions are a powerful mechanism to add new syntax, but they have limitations: [Klabnik] Changing mute to unique as a purely syntactic change would absolutely work. Because what ends up happening is when it compiles one package for 2015 and one package for 2024, and 2024 adds unique or whatever, it would desugar to the same internal [representation ... but] you can't like add a GC in an edition, because that would really change the way that things work on a more deep level. Similarly, the Rust standard library is a unique binary and thus you have to ensure it includes all functions that are used in all editions. Klabnik and Sutter cover more ground and detail in the podcast than we can summarize here. Those include the importance for C++ of its standardization process; whether having an ISO standard language would be of any interest to the Rust community; the reasons for and implications of having multiple compilers vs. just one in Rust's case; how to deal with conformance; and the value of teaching languages like C++ or Rust in universities. Do not miss the full podcast if you are interested in learning more. About the Author Sergio De Simone",
  "image": "https://res.infoq.com/news/2024/10/klabnik-sutter-on-cpp-rust/en/headerimage/rust-cpp-sutter-klabnik-1730045123542.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eIn a \u003ca href=\"http://softwareengineeringdaily.com\"\u003eSoftware Engineering Daily\u003c/a\u003e podcast hosted by \u003ca href=\"https://www.kball.llc/\"\u003eKevin Ball\u003c/a\u003e, \u003ca href=\"https://softwareengineeringdaily.com/2024/10/23/rust-vs-c-with-steve-klabnik-herb-sutter/\"\u003eSteve Klabnik and Herb Sutter discuss several topics related to Rust and C++\u003c/a\u003e, including what the languages have in common and what is unique to them, where they differ, how they evolve, and more.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eThe perfect language does not exist\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eFor Klabnik, besides the common idea about Rust being a memory-safe language, what really makes it different is its taking inspiration from ideas that have not been popular in more recent programming languages but that are well-known in the programming languages space.\u003c/p\u003e\n\n\u003cp\u003eSutter, on the other hand, stresses the idea of zero-overhead abstraction, i.e., the idea you can express things in a higher-level way without paying an excessive cost for that abstraction. Here Klabnik echoes Sutter considering how the primary mechanism Rust achieves \u0026#34;zero-cost\u0026#34; abstractions is through types:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e[Klabnik] Basically, the more that you could express in the type system, the less you needed to check at runtime.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eBut not all abstractions are zero-overhead, says Sutter, bringing the example of two C++ features that compilers invariably offer the option to disable: exception handling and runtime typing.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e[Sutter] If you look at why, it\u0026#39;s because those two can be written better by hand. Or you pay for them even if you don\u0026#39;t use them.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eSo that brings both to the idea that language design is just as much of an art or a craft, heavily influenced by taste and a philosophy of what a language ought to be, so we are not yer to the point where a language can be the \u003cem\u003eperfect language\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eAreas of applicability\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eComing to how the languages are used, Sutter says they have a very similar target, with ecosystem maturity and thread-safety guarantees being what may lead to choose one over the other. Klabnik stresses out the fact that Rust is being often adopted to create networked services, even at large companies:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e[Klabnik] Cloudflare, for example, is using Rust code as their backend. And they power 10% of internet traffic. Other companies [...] had some stuff in Python and they rewrote it in Rust. And then they were able to drop thousands of servers off of their cloud bill.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eSutter highlights the ability of C++ of giving you control of time and space and the richness of the tool ecosystem that has been built around C++ for 30+ years, while Rust is comparatively still a young language.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e[Sutter] Right now, there are things where I can\u0026#39;t ship code out of the company unless it goes through this tool. And it understands C++ but it doesn\u0026#39;t understand Rust. I can\u0026#39;t ship that code. If I write in Rust, I\u0026#39;m not allowed to ship it without a VP exception\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003cstrong\u003eHow languages evolve\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eWhen it comes to language evolution, the key point is when it is worth to add complexity to the language for a new feature, which is not always an easy decision. In this regard, one of the things Klabnik praises about C++ is its commitment to backwards compatibility \u0026#34;within reason\u0026#34;.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e[Klabnik] I\u0026#39;m not saying that the rust team necessarily doesn\u0026#39;t have a similar view in the large. But there\u0026#39;s been some recent proposals about some things that kind of add a degree of complexity that I\u0026#39;m am not necessarily personally comfortable with.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eSutter mentions how the C# team at some point decided to add nullability to the language and, although this is surely a great thing to have, it also brought hidden costs:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e[Sutter] Because there\u0026#39;s complexity for users and the complexity in the language now but also for the next 20 years. Because you\u0026#39;re going to be supporting this thing forever, right? And it\u0026#39;s going to constrain evolution forever. [...] It turns out that once you add nullability [...] the whole language needs to know about it more than you first thought.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eTo further stress how hard it is to take such kinds of decisions, Klabnik recalls a case where he fought against Rust\u0026#39;s postfix syntax for \u003ccode\u003eawait\u003c/code\u003e, which differs from most other languages where it is prefix:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e[Klabnik] Now that I\u0026#39;m writing a lot of code with async and await, gosh, I\u0026#39;m glad they went with postfix await. Because it\u0026#39;s like so, so much nicer and in so many ways.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003cstrong\u003eThe power of language editions\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eOne way for the Rust Core team to manage change is defining \u003ca href=\"https://www.infoq.com/news/2021/05/rust-six-years-2021-edition/\"\u003elanguage editions\u003c/a\u003e to preserve source compatibility when new features are added.\u003c/p\u003e\n\n\u003cp\u003eSutter shows himself to be interested in understanding whether this mechanism could have made it possible to introduce C++ \u003ccode\u003easync/await\u003c/code\u003e support without needing to adopt the \u003ca href=\"https://news.ycombinator.com/item?id=36025757\"\u003e\u003ccode\u003eco_async\u003c/code\u003e and \u003ccode\u003eco_await\u003c/code\u003e keywords\u003c/a\u003e to prevent clashing existing codebases. Klabnik explains editions are a powerful mechanism to add new syntax, but they have limitations:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e[Klabnik] Changing \u003ccode\u003emute\u003c/code\u003e to \u003ccode\u003eunique\u003c/code\u003e as a purely syntactic change would absolutely work. Because what ends up happening is when it compiles one package for 2015 and one package for 2024, and 2024 adds \u003ccode\u003eunique\u003c/code\u003e or whatever, it would desugar to the same internal [representation ... but] you can\u0026#39;t like add a GC in an edition, because that would really change the way that things work on a more deep level.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eSimilarly, the Rust standard library is a unique binary and thus you have to ensure it includes all functions that are used in all editions.\u003c/p\u003e\n\n\u003cp\u003eKlabnik and Sutter cover more ground and detail in the podcast than we can summarize here. Those include the importance for C++ of its standardization process; whether having an ISO standard language would be of any interest to the Rust community; the reasons for and implications of having multiple compilers vs. just one in Rust\u0026#39;s case; how to deal with conformance; and the value of teaching languages like C++ or Rust in universities. Do not miss the full podcast if you are interested in learning more.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Sergio-De-Simone\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eSergio De Simone\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2024-10-27T00:00:00Z",
  "modifiedTime": null
}
