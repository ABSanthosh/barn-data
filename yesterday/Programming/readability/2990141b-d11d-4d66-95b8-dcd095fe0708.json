{
  "id": "2990141b-d11d-4d66-95b8-dcd095fe0708",
  "title": "In Memory of Stiver",
  "link": "https://blog.jetbrains.com/idea/2024/11/in-memory-of-stiver/",
  "description": "On October 20, the original author of the Fernflower Java decompiler, Stiver, passed away after a long fight against glioblastoma. Stiver was a German programmer of Russian origin, primarily developing software for medical equipment. Twenty years ago, he developed a deep professional interest in Java virtual machine internals. You may remember his research blog posts, […]",
  "author": "Tagir Valeev",
  "published": "Sat, 02 Nov 2024 13:24:18 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "compiler",
    "fernflower",
    "stiver"
  ],
  "byline": "Tagir Valeev",
  "length": 6077,
  "excerpt": "On October 20, the original author of the Fernflower Java decompiler, Stiver, passed away after a long fight against glioblastoma. Stiver was a German programmer of Russian origin, primarily devel",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA – the Leading Java and Kotlin IDE, by JetBrains In Memory of Stiver On October 20, the original author of the Fernflower Java decompiler, Stiver, passed away after a long fight against glioblastoma. Stiver was a German programmer of Russian origin, primarily developing software for medical equipment. Twenty years ago, he developed a deep professional interest in Java virtual machine internals. You may remember his research blog posts, like this one (in Russian) from 2006 about how to tweak the Java class hierarchy using Unsafe when Java 1.5 was just released. Around 2008, Stiver became fascinated by Java decompilation. The Java decompilation landscape was very poor at that time. The first generation of decompilers like JAD or JODE came to an end. While Java as a language evolved, the existing decompilers were mainly unmaintained, which limited their usefulness. New language constructs like assertion statements, annotations, and generic types were not supported. Moreover, the deprecation of JSR/RET instructions in Java bytecode caused a significant difference in how try-finally blocks are compiled. The decompilers failed to handle the new bytecode. Another big problem with existing decompilers was their approach to decompilation. They simply looked for specific bytecode patterns and translated them to the corresponding Java statements and expressions. While simple, this approach is fragile – any minor semantically equivalent change in generated bytecode made proper decompilation impossible. This severely limited the decompiler application. Stiver decided to write his own decompiler as a side project. To overcome the weaknesses of existing alternatives, he took a different approach. After reading the bytecode, he constructed a control-flow graph in static single-assignment form, which is much better to express the program semantics abstracting the particular shape of bytecode. At the beginning of this project, Stiver knew little about static analysis and compiler design and had to learn a lot, but the effort was worth it. The resulting decompiler produced much better results than anything available at that time. It could even decompile the bytecode produced by some obfuscators without any explicit support. Stiver did the main development himself between 2008 and 2010. The first public version became available in May 2009 as a web service. A user could upload an individual CLASS file or a whole JAR file and get the decompiled result. The decompiler quickly gained popularity – during the first four months, users decompiled more than half a million Java classes. There was no public standalone version, but Stiver sent it privately to a few Beta testers. After the release, Stiver made numerous improvements and fixed many bugs thanks to early adopters. After 2010, the active development of the decompiler stopped, as Stiver became busier with his primary job. A few third-party software vendors asked Stiver to provide the decompiler for their projects. Notably, it was used with permission in Mod Coder Pack, which is a toolkit for creating mods for the game Minecraft. Still, it became difficult for a regular Java user to find a working version of Fernflower. In 2013, JetBrains approached Stiver with a suggestion to include Fernflower in IntelliJ IDEA. Part of the deal was making Fernflower open source. Everything went well, and the contract was signed. On July 11, 2014, the early access version of IntelliJ IDEA 14 was released, including the decompiler for the first time. You can still see the initial import of the Fernflower source code in the IntelliJ IDEA Git history, on March 4, 2014. While Stiver was never a JetBrains employee, he helped improve the decompiler for almost a year after the initial import. As Java 8 had just been released, it was necessary to support new language constructs like lambdas. Another big challenge was integrating the decompiler with the IntelliJ IDEA debugger. Line numbers in decompiled code differ from line numbers in the original source, and Stiver helped provide a transparent mapping between them so you can seamlessly debug decompiled code. As Fernflower became open source, many other tools in the Java world used it – you can find a number of forks on GitHub. The Java team at JetBrains is constantly improving Fernflower, but it’s still mainly Stiver’s code. If Fernflower hadn’t existed, we likely would have had to invest substantial resources into developing our own decompiler. This could have resulted in IntelliJ IDEA lacking a decompiler or having one that was significantly less effective. Stiver’s work was a real game-changer for Java developers over the past 10 years. With no better alternative to decompile Java bytecode, his contributions have saved developers countless hours while debugging Java code without sources.  Thank you, Stiver! We are deeply saddened by the loss of such a brilliant pioneer whose work and dedication had such a lasting and profound impact.  Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2024/11/ij-social_share_blog_1280x720_en.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA – the Leading Java and Kotlin IDE, by JetBrains\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                                        \u003ch2 id=\"major-updates\"\u003eIn Memory of Stiver\u003c/h2\u003e                    \n                    \n\u003cp\u003eOn October 20, the original author of the Fernflower Java decompiler, \u003cabbr title=\"Stiver always strived to remain anonymous online, a desire we will respect.\"\u003eStiver\u003c/abbr\u003e, passed away after a long fight against glioblastoma. \u003c/p\u003e\n\n\n\n\u003cp\u003eStiver was a German programmer of Russian origin, primarily developing software for medical equipment. Twenty years ago, he developed a deep professional interest in Java virtual machine internals. You may remember his research blog posts, like \u003ca href=\"https://wasm.in/blogs/unsafe-java-i-nebezopasnaja-zhaba.416/\" target=\"_blank\" rel=\"noopener\"\u003ethis one\u003c/a\u003e (in Russian) from 2006 about how to tweak the Java class hierarchy using Unsafe when Java 1.5 was just released. Around 2008, Stiver became fascinated by Java decompilation.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe Java decompilation landscape was very poor at that time. The first generation of decompilers like \u003ca href=\"https://en.wikipedia.org/wiki/JAD_(software)\" target=\"_blank\" rel=\"noopener\"\u003eJAD\u003c/a\u003e or \u003ca href=\"https://jode.sourceforge.io/\" target=\"_blank\" rel=\"noopener\"\u003eJODE\u003c/a\u003e came to an end. While Java as a language evolved, the existing decompilers were mainly unmaintained, which limited their usefulness. New language constructs like assertion statements, annotations, and generic types were not supported. Moreover, the deprecation of JSR/RET instructions in Java bytecode caused a significant difference in how try-finally blocks are compiled. The decompilers failed to handle the new bytecode.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnother big problem with existing decompilers was their approach to decompilation. They simply looked for specific bytecode patterns and translated them to the corresponding Java statements and expressions. While simple, this approach is fragile – any minor semantically equivalent change in generated bytecode made proper decompilation impossible. This severely limited the decompiler application.\u003c/p\u003e\n\n\n\n\u003cp\u003eStiver decided to write his own decompiler as a side project. To overcome the weaknesses of existing alternatives, he took a different approach. After reading the bytecode, he constructed a control-flow graph in \u003ca href=\"https://en.wikipedia.org/wiki/Static_single-assignment_form\" target=\"_blank\" rel=\"noopener\"\u003estatic single-assignment form\u003c/a\u003e, which is much better to express the program semantics abstracting the particular shape of bytecode. At the beginning of this project, Stiver knew little about static analysis and compiler design and had to learn a lot, but the effort was worth it. The resulting decompiler produced much better results than anything available at that time. It could even decompile the bytecode produced by some obfuscators without any explicit support.\u003c/p\u003e\n\n\n\n\u003cp\u003eStiver did the main development himself between 2008 and 2010. The first public version became available in May 2009 as a web service. A user could upload an individual CLASS file or a whole JAR file and get the decompiled result. The decompiler quickly gained popularity – during the first four months, users decompiled more than half a million Java classes. There was no public standalone version, but Stiver sent it privately to a few Beta testers. After the release, Stiver made numerous improvements and fixed many bugs thanks to early adopters.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfTOJIKpkB5nZrAKRpoVQVPZpzJrddXpy_il_buTx1cXemr5IPdDMaB5-c9dd0ZVALmIcpDbjBdbUg1FTTz7nsE7mqdr26jLFJO5h7N9FAavV2sqPyGxsljdSGPlmz5HKvAwuHgcDBiwj4wggp93wBlWH-4?key=CSCaPaa-triKZ-1qCdcZiQ\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAfter 2010, the active development of the decompiler stopped, as Stiver became busier with his primary job. A few third-party software vendors asked Stiver to provide the decompiler for their projects. Notably, it was used with permission in Mod Coder Pack, which is a toolkit for creating mods for the game Minecraft. Still, it became difficult for a regular Java user to find a working version of Fernflower.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn 2013, JetBrains approached Stiver with a suggestion to include Fernflower in IntelliJ IDEA. Part of the deal was making Fernflower open source. Everything went well, and the contract was signed. On July 11, 2014, the early access version of IntelliJ IDEA 14 was \u003ca href=\"https://blog.jetbrains.com/idea/2014/07/intellij-idea-14-eap-138-1029-is-out/\"\u003ereleased\u003c/a\u003e, including the decompiler for the first time. You can still see the initial import of the Fernflower source code in the IntelliJ IDEA \u003ca href=\"https://github.com/JetBrains/intellij-community/blob/b83c803a51c302fa91aafa5320f5cd0a6496c4bf/plugins/java-decompiler/engine/src/de/fernflower/main/Fernflower.java#L5\" target=\"_blank\" rel=\"noopener\"\u003eGit history\u003c/a\u003e, on March 4, 2014.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhile Stiver was never a JetBrains employee, he helped improve the decompiler for almost a year after the initial import. As Java 8 had just been released, it was necessary to support new language constructs like lambdas. Another big challenge was integrating the decompiler with the IntelliJ IDEA debugger. Line numbers in decompiled code differ from line numbers in the original source, and Stiver helped provide a transparent mapping between them so you can seamlessly debug decompiled code.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXe9yx-1UQEHfQpyHxhDQixTGLvNHIPOB-S5FsZmtlrFKuTHeUI0shFuiD99r1VL-Zn-hBalo7_2KMwBjlhgMh9b-ECAf_goW9cqQE-rVQlywX9il3rAaTKBxv9W242Mf1CYlJCT5tcUokDozoAhwbkewMsf?key=CSCaPaa-triKZ-1qCdcZiQ\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAs Fernflower became open source, many other tools in the Java world used it – you can find a number of forks on GitHub. The Java team at JetBrains is constantly improving Fernflower, but it’s still mainly Stiver’s code. If Fernflower hadn’t existed, we likely would have had to invest substantial resources into developing our own decompiler. This could have resulted in IntelliJ IDEA lacking a decompiler or having one that was significantly less effective. Stiver’s work was a real game-changer for Java developers over the past 10 years. With no better alternative to decompile Java bytecode, his contributions have saved developers countless hours while debugging Java code without sources. \u003c/p\u003e\n\n\n\n\u003cp\u003eThank you, Stiver! We are deeply saddened by the loss of such a brilliant pioneer whose work and dedication had such a lasting and profound impact. \u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
