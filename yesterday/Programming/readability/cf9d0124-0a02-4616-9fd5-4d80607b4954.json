{
  "id": "cf9d0124-0a02-4616-9fd5-4d80607b4954",
  "title": "Integration Tests for Plugin Developers: UI Testing",
  "link": "https://blog.jetbrains.com/platform/2025/02/integration-tests-for-plugin-developers-ui-testing/",
  "description": "In our previous blog post, we created a basic integration test that:  Now, let’s explore how to interact with UI elements in our tests. UI hierarchy IntelliJ-based IDEs primarily use Swing and AWT for their user interface, while JCEF is used in specific cases like Markdown rendering. This UI framework organizes elements in a parent-child […]",
  "author": "Maxim Kolmakov",
  "published": "Fri, 28 Feb 2025 18:30:11 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "plugin-development",
    "marketplace",
    "plugins",
    "testing"
  ],
  "byline": "Maxim Kolmakov",
  "length": 10813,
  "excerpt": "The second post of the series explores how to effectively interact with UI elements in plugin tests.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "Plugin and extension development for JetBrains products. Development Marketplace PluginsIntegration Tests for Plugin Developers: UI Testing In our previous blog post, we created a basic integration test that:  Installed a plugin in the IDE. Opened a project. Waited for background processes to complete. Performed an exit. Now, let’s explore how to interact with UI elements in our tests. UI hierarchy IntelliJ-based IDEs primarily use Swing and AWT for their user interface, while JCEF is used in specific cases like Markdown rendering. This UI framework organizes elements in a parent-child hierarchy, similar to HTML’s DOM structure: Top-level containers (IDE frame and dialogs). Nested containers. Individual components (buttons, text fields, and lists). Every UI element (except top-level containers) must have a parent container, creating a clear hierarchical structure.  The Driver framework provides a Kotlin DSL that mirrors this hierarchy. Here’s an example: ideFrame { invokeAction(\"SearchEverywhere\") searchEverywherePopup { actionButtonByXpath(xQuery { byAccessibleName(\"Preview\")}).click() } } This code demonstrates hierarchical navigation: Find the main IDE window (ideFrame). Trigger the Search Everywhere action (invokeAction(\"SearchEverywhere\")). Locate the Search Everywhere popup (searchEverywherePopup). Find and click the Preview button within the popup (actionButtonByXpath(xQuery { byAccessibleName(\"Preview\")}).click()). You could write more concise code: ideFrame { actionButtonByXpath(xQuery { byAccessibleName(\"Preview\")}).click() } But the shorter code has two significant drawbacks: Reduced precision: The code searches for the Preview button throughout the entire IDE frame. It might find unintended matches in the project explorer, tool windows, or other UI elements. This can make your tests unreliable and prone to breaking when the UI content changes. Decreased readability: While the code is more concise, it doesn’t communicate the intended navigation path. The longer version makes it clear exactly where we expect to find the Preview button, making the code more maintainable and easier to debug. So, being explicit about the component hierarchy helps create more robust and maintainable UI automation code, even though it requires writing more code. Searching components While the Driver framework provides many pre-built components (like ideFrame, codeEditor, button, tree, etc.), you’ll sometimes need to locate custom elements. Let’s explore how to find any UI component in your tests. First, let’s modify our test to pause the IDE so we can examine its UI structure: @Test fun simpleTest() { Starter.newContext( \"testExample\", TestCase( IdeProductProvider.IC, GitHubProject.fromGithub(branchName = \"master\", repoRelativeUrl = \"JetBrains/ij-perf-report-aggregator\")) .withVersion(\"2024.3\") ).apply { val pathToPlugin = System.getProperty(\"path.to.build.plugin\") PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin)) }.runIdeWithDriver().useDriverAndCloseIde { Thread.sleep(30.minutes.inWholeMilliseconds) } } When you run this test, look for this line in the logs: http://localhost:63343/api/remote-driver/. Opening this URL reveals an HTML representation of the IDE’s Swing component tree: Using Developer Tools in the browser, you can inspect detailed component attributes. Here’s an example component: \u003cdiv accessiblename=\"Current File\" actionmap=\"javax.swing.ActionMap@47d64fb9\" actionmap_created=\"8\" asstring=\"com.intellij.execution.ui.RedesignedRunConfigurationSelector$createCustomComponent$1[,12,0,118x40,alignmentX=0.0,alignmentY=0.0,border=com.intellij.openapi.actionSystem.impl.ActionToolbarImpl$ActionButtonBorder@19487628,flags=384,maximumSize=,minimumSize=,preferredSize=]\" class=\"ActionButtonWithText\" classhierarchy=\"com.intellij.openapi.actionSystem.impl.ActionButtonWithText -\u003e com.intellij.openapi.actionSystem.impl.ActionButton -\u003e javax.swing.JComponent\" enabled=\"true\" hashcode=\"2064836191\" hide_dropdown_icon=\"HIDE_DROPDOWN_ICON\" icon_text_space=\"2\" javaclass=\"com.intellij.execution.ui.RedesignedRunConfigurationSelector$createCustomComponent$1\" myaction=\"Select Run/Debug Configuration (null)\" myhorizontaltextalignment=\"2\" myhorizontaltextposition=\"11\" mynoiconsinpopup=\"false\" rdtarget=\"DEFAULT\" refid=\"DEFAULT_5\" text_arrow_space=\"2\" tool_tip_text_key=\"ToolTipText\" visible=\"true\" visible_text=\"Current File\" visible_text_keys=\"\"\u003e\u003cdiv\u003e The element corresponds to the following button: Similar to web testing frameworks like Selenium, we use XPath to locate components. The Driver framework provides a simple XPath builder. Here are several ways to find the same component: xQuery { byVisibleText(\"Current File\") } xQuery { byAccessibleName(\"Current File\") } xQuery { byType(\"com.intellij.execution.ui.RedesignedRunConfigurationSelector\\$createCustomComponent$1\") } For reliable component identification, prioritize these attributes: accessiblename, visible_text, icon, javaclass. You can combine multiple attributes for a more precise selection. Interaction with components  Once you’ve located a component, you’ll want to interact with it or verify its properties. So, let’s now explore how to perform various UI interactions. To click the Current File button we found earlier, we need to enter: x(xQuery { byVisibleText(\"Current File\") }).click() The x() call creates a lazy reference to the component. It means that the XPath query isn’t executed immediately and component lookup happens only when an action (like click()) is invoked. Here’s our test that incorporates UI interaction: fun simpleTestForCustomUIElement() { Starter.newContext( \"testExample\", TestCase( IdeProductProvider.IC, GitHubProject.fromGithub(branchName = \"master\", repoRelativeUrl = \"JetBrains/ij-perf-report-aggregator\")) .withVersion(\"2024.3\") ).apply { val pathToPlugin = System.getProperty(\"path.to.build.plugin\") PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin)) }.runIdeWithDriver().useDriverAndCloseIde { waitForIndicators(1.minutes) ideFrame { x(xQuery { byVisibleText(\"Current File\") }).click() } } } Beyond mouse clicks, you can simulate keyboard input and shortcuts: keyboard { enterText(\"Sample text\") enter() hotKey(if (SystemInfo.isMac) KeyEvent.VK_META else KeyEvent.VK_CONTROL, KeyEvent.VK_A) backspace() } Note: On macOS, the interaction via java.awt.Robot requires special permissions. IntelliJ IDEA should be granted the necessary permissions via the Accessibility page, which can be found under System Settings | Privacy \u0026 Security.  Asserting properties and putting it all together Let’s combine everything we’ve learned and add property assertions to create a complete UI test: @Test fun simpleTestForCustomUIElement() { Starter.newContext( \"testExample\", TestCase( IdeProductProvider.IC, GitHubProject.fromGithub(branchName = \"master\", repoRelativeUrl = \"JetBrains/ij-perf-report-aggregator\")) .withVersion(\"2024.3\") ).apply { val pathToPlugin = System.getProperty(\"path.to.build.plugin\") PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin)) }.runIdeWithDriver().useDriverAndCloseIde { waitForIndicators(1.minutes) ideFrame { x(xQuery { byVisibleText(\"Current File\") }).click() val configurations = popup().jBlist(xQuery { contains(byVisibleText(\"Edit Configurations\")) }) configurations.shouldBe(\"Configuration list is not present\", present) Assertions.assertTrue(configurations.rawItems.contains(\"backup-data\"), \"Configurations list doesn't contain 'backup-data' item: ${configurations.rawItems}\") } } } Let’s break down each step: Opening the popup Click the Current File button. Popup menu appears. Finding the list  Use popup() to locate the popup with a configuration list. Note: This works without any XPath because at the moment of the call, there are no other popups shown on the UI. Find the list containing the text Edit Configurations by using the following query: jBlist(xQuery { contains(byVisibleText(\"Edit Configurations\")) }). XQuery searches for the list component that contains the visible text \"Edit Configurations\". Verifying list presence Use shouldBe(\u003cmessage\u003e, present) to ensure the list exists. This is important because popup().jBlist creates a lazy reference without actually checking the results. The actual check happens when shouldBe calls the present method. The shouldBe method waits 15 seconds until the condition is met and can be used to assert various properties. Checking list contents Access the rawItems property to get all list items. Verify the 'backup-data' exists in the list. Include full list content in the error message for debugging. You can find the full source code here. What’s next? You now have the foundation to create UI tests that can interact with IDE components, verify user scenarios, and catch UI-related regressions. But this is just the beginning of your testing journey! Stay tuned for upcoming blog posts in this series, where we’ll cover: API Testing: working with plugin APIs effectively via JMX calls. GitHub Actions: setting up continuous integration. Common Pitfalls: tips and tricks for stable UI tests. Subscribe to JetBrains Platform updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/02/mp-social_share_blog_1280x720_en-2.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/platform/\"\u003e\n                                                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/JetBrains-icon-1.svg\" alt=\"Platform logo\"/\u003e\n                                                                                                                            \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003ePlugin and extension development for JetBrains products. \u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/platform/category/plugin-development/\"\u003eDevelopment\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/platform/category/marketplace/\"\u003eMarketplace\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/platform/category/plugins/\"\u003ePlugins\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eIntegration Tests for Plugin Developers: UI Testing\u003c/h2\u003e                    \n                    \n\u003cp\u003eIn our \u003ca href=\"https://blog.jetbrains.com/platform/2025/02/integration-tests-for-plugin-developers-intro-dependencies-and-first-integration-test/\" data-type=\"link\" data-id=\"https://blog.jetbrains.com/platform/2025/02/integration-tests-for-plugin-developers-intro-dependencies-and-first-integration-test/\"\u003eprevious blog post\u003c/a\u003e, we created a basic integration test that: \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eInstalled a plugin in the IDE.\u003c/li\u003e\n\n\n\n\u003cli\u003eOpened a project.\u003c/li\u003e\n\n\n\n\u003cli\u003eWaited for background processes to complete.\u003c/li\u003e\n\n\n\n\u003cli\u003ePerformed an exit.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eNow, let’s explore how to interact with UI elements in our tests.\u003c/p\u003e\n\n\n\n\u003ch2\u003eUI hierarchy\u003c/h2\u003e\n\n\n\n\u003cp\u003eIntelliJ-based IDEs primarily use Swing and AWT for their user interface, while JCEF is used in specific cases like Markdown rendering. This UI framework organizes elements in a parent-child hierarchy, similar to HTML’s DOM structure:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eTop-level containers (IDE frame and dialogs).\u003c/li\u003e\n\n\n\n\u003cli\u003eNested containers.\u003c/li\u003e\n\n\n\n\u003cli\u003eIndividual components (buttons, text fields, and lists).\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eEvery UI element (except top-level containers) must have a parent container, creating a clear hierarchical structure. \u003c/p\u003e\n\n\n\n\u003cp\u003eThe Driver framework provides a Kotlin DSL that mirrors this hierarchy. Here’s an example:\u003c/p\u003e\n\n\n\n\u003cpre\u003eideFrame {\n     invokeAction(\u0026#34;SearchEverywhere\u0026#34;)\n     searchEverywherePopup {\n          actionButtonByXpath(xQuery { byAccessibleName(\u0026#34;Preview\u0026#34;)}).click()\n     }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis code demonstrates hierarchical navigation:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eFind the main IDE window (\u003ccode\u003eideFrame)\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eTrigger the \u003cem\u003eSearch Everywhere\u003c/em\u003e action (\u003ccode\u003einvokeAction(\u0026#34;SearchEverywhere\u0026#34;)\u003c/code\u003e).\u003c/li\u003e\n\n\n\n\u003cli\u003eLocate the \u003cem\u003eSearch Everywhere\u003c/em\u003e popup (\u003ccode\u003esearchEverywherePopup\u003c/code\u003e).\u003c/li\u003e\n\n\n\n\u003cli\u003eFind and click the \u003cem\u003ePreview \u003c/em\u003ebutton within the popup (\u003ccode\u003eactionButtonByXpath(xQuery { byAccessibleName(\u0026#34;Preview\u0026#34;)}).click()\u003c/code\u003e).\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eYou could write more concise code:\u003c/p\u003e\n\n\n\n\u003cpre\u003eideFrame { \n     actionButtonByXpath(xQuery { byAccessibleName(\u0026#34;Preview\u0026#34;)}).click() \n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eBut the shorter code has two significant drawbacks:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eReduced precision:\u003c/strong\u003e The code searches for the \u003cem\u003ePreview\u003c/em\u003e button throughout the entire IDE frame. It might find unintended matches in the project explorer, tool windows, or other UI elements. This can make your tests unreliable and prone to breaking when the UI content changes.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eDecreased readability:\u003c/strong\u003e While the code is more concise, it doesn’t communicate the intended navigation path. The longer version makes it clear exactly where we expect to find the \u003cem\u003ePreview\u003c/em\u003e button, making the code more maintainable and easier to debug.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eSo, being explicit about the component hierarchy helps create more robust and maintainable UI automation code, even though it requires writing more code.\u003c/p\u003e\n\n\n\n\u003ch2\u003eSearching components\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhile the Driver framework provides many pre-built components (like ideFrame, codeEditor, button, tree, etc.), you’ll sometimes need to locate custom elements. Let’s explore how to find any UI component in your tests.\u003c/p\u003e\n\n\n\n\u003cp\u003eFirst, let’s modify our test to pause the IDE so we can examine its UI structure:\u003c/p\u003e\n\n\n\n\u003cpre\u003e@Test\nfun simpleTest() {\n   Starter.newContext(\n       \u0026#34;testExample\u0026#34;,\n       TestCase(\n           IdeProductProvider.IC,\n           GitHubProject.fromGithub(branchName = \u0026#34;master\u0026#34;,\n               repoRelativeUrl = \u0026#34;JetBrains/ij-perf-report-aggregator\u0026#34;))\n           .withVersion(\u0026#34;2024.3\u0026#34;)\n   ).apply {\n       val pathToPlugin = System.getProperty(\u0026#34;path.to.build.plugin\u0026#34;)\n       PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin))\n   }.runIdeWithDriver().useDriverAndCloseIde {\n       Thread.sleep(30.minutes.inWholeMilliseconds)\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen you run this test, look for this line in the logs: \u003ca href=\"http://localhost:63343/api/remote-driver/\" target=\"_blank\" rel=\"noopener\"\u003ehttp://localhost:63343/api/remote-driver/\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eOpening this URL reveals an HTML representation of the IDE’s Swing component tree:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"2730\" height=\"1696\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/SCR-20250228-pqep.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eUsing \u003cem\u003eDeveloper Tools\u003c/em\u003e in the browser, you can inspect detailed component attributes. Here’s an example component:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u0026lt;div accessiblename=\u0026#34;Current File\u0026#34; actionmap=\u0026#34;javax.swing.ActionMap@47d64fb9\u0026#34; \nactionmap_created=\u0026#34;8\u0026#34;\nasstring=\u0026#34;com.intellij.execution.ui.RedesignedRunConfigurationSelector$createCustomComponent$1[,12,0,118x40,alignmentX=0.0,alignmentY=0.0,border=com.intellij.openapi.actionSystem.impl.ActionToolbarImpl$ActionButtonBorder@19487628,flags=384,maximumSize=,minimumSize=,preferredSize=]\u0026#34;\nclass=\u0026#34;ActionButtonWithText\u0026#34; classhierarchy=\u0026#34;com.intellij.openapi.actionSystem.impl.ActionButtonWithText -\u0026gt;\ncom.intellij.openapi.actionSystem.impl.ActionButton -\u0026gt; javax.swing.JComponent\u0026#34; enabled=\u0026#34;true\u0026#34;\nhashcode=\u0026#34;2064836191\u0026#34; hide_dropdown_icon=\u0026#34;HIDE_DROPDOWN_ICON\u0026#34; icon_text_space=\u0026#34;2\u0026#34;\njavaclass=\u0026#34;com.intellij.execution.ui.RedesignedRunConfigurationSelector$createCustomComponent$1\u0026#34; myaction=\u0026#34;Select Run/Debug Configuration (null)\u0026#34; myhorizontaltextalignment=\u0026#34;2\u0026#34; myhorizontaltextposition=\u0026#34;11\u0026#34; mynoiconsinpopup=\u0026#34;false\u0026#34; rdtarget=\u0026#34;DEFAULT\u0026#34; refid=\u0026#34;DEFAULT_5\u0026#34;\ntext_arrow_space=\u0026#34;2\u0026#34;\ntool_tip_text_key=\u0026#34;ToolTipText\u0026#34; visible=\u0026#34;true\u0026#34; visible_text=\u0026#34;Current File\u0026#34; visible_text_keys=\u0026#34;\u0026#34;\u0026gt;\u0026lt;div\u0026gt;\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe element corresponds to the following button:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"2720\" height=\"1920\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/SCR-20250228-pqmb.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eSimilar to web testing frameworks like Selenium, we use XPath to locate components. The Driver framework provides a simple \u003ca href=\"https://www.w3schools.com/Xml/xpath_syntax.asp\" target=\"_blank\" rel=\"noopener\"\u003eXPath\u003c/a\u003e builder. Here are several ways to find the same component:\u003c/p\u003e\n\n\n\n\u003cpre\u003exQuery { byVisibleText(\u0026#34;Current File\u0026#34;) }\nxQuery { byAccessibleName(\u0026#34;Current File\u0026#34;) }\nxQuery { byType(\u0026#34;com.intellij.execution.ui.RedesignedRunConfigurationSelector\\$createCustomComponent$1\u0026#34;) }\u003c/pre\u003e\n\n\n\n\u003cp\u003eFor reliable component identification, prioritize these attributes: \u003ccode\u003eaccessiblename, visible_text, icon, javaclass\u003c/code\u003e. You can combine multiple attributes for a more precise selection.\u003c/p\u003e\n\n\n\n\u003ch2\u003eInteraction with components \u003c/h2\u003e\n\n\n\n\u003cp\u003eOnce you’ve located a component, you’ll want to interact with it or verify its properties. So, let’s now explore how to perform various UI interactions. \u003cbr/\u003eTo click the \u003cem\u003eCurrent File\u003c/em\u003e button we found earlier, we need to enter:\u003c/p\u003e\n\n\n\n\u003cpre\u003ex(xQuery { byVisibleText(\u0026#34;Current File\u0026#34;) }).click()\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003ex()\u003c/code\u003e call creates a lazy reference to the component. It means that the XPath query isn’t executed immediately and component lookup happens only when an action (like \u003ccode\u003eclick()\u003c/code\u003e) is invoked. \u003cbr/\u003eHere’s our test that incorporates UI interaction:\u003c/p\u003e\n\n\n\n\u003cpre\u003efun simpleTestForCustomUIElement() {\n   Starter.newContext(\n       \u0026#34;testExample\u0026#34;,\n       TestCase(\n           IdeProductProvider.IC,\n           GitHubProject.fromGithub(branchName = \u0026#34;master\u0026#34;,\n               repoRelativeUrl = \u0026#34;JetBrains/ij-perf-report-aggregator\u0026#34;))\n           .withVersion(\u0026#34;2024.3\u0026#34;)\n   ).apply {\n       val pathToPlugin = System.getProperty(\u0026#34;path.to.build.plugin\u0026#34;)\n       PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin))\n   }.runIdeWithDriver().useDriverAndCloseIde {\n       waitForIndicators(1.minutes)\n       ideFrame {\n           x(xQuery { byVisibleText(\u0026#34;Current File\u0026#34;) }).click()\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eBeyond mouse clicks, you can simulate keyboard input and shortcuts:\u003c/p\u003e\n\n\n\n\u003cpre\u003ekeyboard {\n   enterText(\u0026#34;Sample text\u0026#34;)\n   enter()\n   hotKey(if (SystemInfo.isMac) KeyEvent.VK_META else KeyEvent.VK_CONTROL, KeyEvent.VK_A)\n   backspace()\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eNote: On macOS, the interaction via java.awt.Robot requires special permissions. IntelliJ IDEA should be granted the necessary permissions via the Accessibility page, which can be found under System Settings | Privacy \u0026amp; Security. \u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eAsserting properties and putting it all together\u003c/h2\u003e\n\n\n\n\u003cp\u003eLet’s combine everything we’ve learned and add property assertions to create a complete UI test:\u003c/p\u003e\n\n\n\n\u003cpre\u003e@Test\nfun simpleTestForCustomUIElement() {\n   Starter.newContext(\n       \u0026#34;testExample\u0026#34;,\n       TestCase(\n           IdeProductProvider.IC,\n           GitHubProject.fromGithub(branchName = \u0026#34;master\u0026#34;,\n               repoRelativeUrl = \u0026#34;JetBrains/ij-perf-report-aggregator\u0026#34;))\n           .withVersion(\u0026#34;2024.3\u0026#34;)\n   ).apply {\n       val pathToPlugin = System.getProperty(\u0026#34;path.to.build.plugin\u0026#34;)\n       PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin))\n   }.runIdeWithDriver().useDriverAndCloseIde {\n       waitForIndicators(1.minutes)\n       ideFrame {\n           x(xQuery { byVisibleText(\u0026#34;Current File\u0026#34;) }).click()\n           val configurations = popup().jBlist(xQuery { contains(byVisibleText(\u0026#34;Edit Configurations\u0026#34;)) })\n           configurations.shouldBe(\u0026#34;Configuration list is not present\u0026#34;, present)\n           Assertions.assertTrue(configurations.rawItems.contains(\u0026#34;backup-data\u0026#34;),\n               \u0026#34;Configurations list doesn\u0026#39;t contain \u0026#39;backup-data\u0026#39; item: ${configurations.rawItems}\u0026#34;)\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s break down each step:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eOpening the popup\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eClick the \u003cem\u003eCurrent File\u003c/em\u003e button.\u003c/li\u003e\n\n\n\n\u003cli\u003ePopup menu appears.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eFinding the list \u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eUse \u003ccode\u003e\u003cem\u003epopup\u003c/em\u003e()\u003c/code\u003e to locate the popup with a configuration list. \u003cem\u003eNote: This works without any XPath because at the moment of the call, there are no other popups shown on the UI\u003c/em\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eFind the list containing the text \u003cem\u003eEdit Configurations\u003c/em\u003e by using the following query:\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003e\u003cem\u003ejBlist\u003c/em\u003e(\u003cem\u003exQuery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003econtains(byVisibleText(\u0026#34;Edit Configurations\u0026#34;)) \u003cstrong\u003e}\u003c/strong\u003e)\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eXQuery searches for the list component that contains the visible text \u003ccode\u003e\u0026#34;Edit Configurations\u0026#34;\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003col start=\"3\"\u003e\n\u003cli\u003e\u003cstrong\u003eVerifying list presence\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eUse \u003ccode\u003e\u003cem\u003eshouldBe\u003c/em\u003e(\u0026lt;message\u0026gt;, \u003cem\u003epresent\u003c/em\u003e)\u003c/code\u003e\u003cmessage\u003e to ensure the list exists.\u003c/message\u003e\n\u003cul\u003e\n\u003cli\u003eThis is important because \u003ccode\u003e\u003cem\u003epopup\u003c/em\u003e().\u003cem\u003ejBlist \u003c/em\u003e\u003c/code\u003ecreates a lazy reference without actually checking the results.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003eThe actual check happens when \u003cem\u003e\u003ccode\u003eshouldBe\u003c/code\u003e\u003c/em\u003e calls the \u003ccode\u003e\u003cem\u003epresent\u003c/em\u003e\u003c/code\u003e method.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003cem\u003e\u003ccode\u003eshouldBe\u003c/code\u003e \u003c/em\u003emethod waits 15 seconds until the condition is met and can be used to assert various properties.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eChecking list contents\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eAccess the \u003ccode\u003erawItems\u003c/code\u003e property to get all list items.\u003c/li\u003e\n\n\n\n\u003cli\u003eVerify the \u003ccode\u003e\u0026#39;backup-data\u0026#39;\u003c/code\u003e exists in the list.\u003c/li\u003e\n\n\n\n\u003cli\u003eInclude full list content in the error message for debugging.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eYou can find the full source code \u003ca href=\"https://github.com/MaXal/IntelliJ-Platform-Gradle-Plugin-and-Starter-Demo/blob/blog-part2/src/test/kotlin/PluginTest.kt\" target=\"_blank\" rel=\"noopener\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eWhat’s next?\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eYou now have the foundation to create UI tests that can interact with IDE components, verify user scenarios, and catch UI-related regressions. But this is just the beginning of your testing journey!\u003c/p\u003e\n\n\n\n\u003cp\u003eStay tuned for upcoming blog posts in this series, where we’ll cover:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eAPI Testing: working with plugin APIs effectively via JMX calls.\u003c/li\u003e\n\n\n\n\u003cli\u003eGitHub Actions: setting up continuous integration.\u003c/li\u003e\n\n\n\n\u003cli\u003eCommon Pitfalls: tips and tricks for stable UI tests.\u003c/li\u003e\n\u003c/ul\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to JetBrains Platform updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": null,
  "modifiedTime": null
}
