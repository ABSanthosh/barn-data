{
  "id": "4f6c98b4-fed2-4e1c-9cbe-86a3ff34eeda",
  "title": "Challenges of Creating iOS App Extensions at Lyft",
  "link": "https://www.infoq.com/news/2024/12/lyft-ios-maps-extension/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "In a recent article, Lyft engineers Artur Stepaniuk and Max Husar described how Lyft handles the complexity of creating an app extension for their iOS app without breaking the tight RAM and binary size constraints set by Apple nor impair user experience. By Sergio De Simone",
  "author": "Sergio De Simone",
  "published": "Tue, 17 Dec 2024 16:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Apple",
    "Optimization",
    "iOS",
    "Bazel",
    "Mobile",
    "Development",
    "news"
  ],
  "byline": "Sergio De Simone",
  "length": 3656,
  "excerpt": "In a recent article, Lyft engineers Artur Stepaniuk and Max Husar described how Lyft handles the complexity of creating an app extension for their iOS app without breaking the tight RAM and binary siz",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s1_20241210082243/apple-touch-icon.png",
  "text": "In a recent article, Lyft engineers Artur Stepaniuk and Max Husar described how Lyft handles the complexity of creating an app extension for their iOS app without breaking the tight RAM and binary size constraints set by Apple nor impair user experience. Lyft's iOS app includes an extension to integrate it with Apple Maps and provide information about Lyft offers from within the Maps app. As Stepaniuk and Husar explain, the key to create an iOS app extension in an efficient way is to correctly manage dependencies to maximize code reuse across the app and the extension while optimizing binary size and memory usage. The main complexity factor in this process is the impossibility of using dynamic linking to avoid the cost of loading them into memory at launch time, which would make the app too slow on launch. This makes static linking the only viable option, albeit at the cost of increasing the app binary size as well as its memory footprint. However, A larger binary size can lead to longer download and install times, potentially reducing the number of installs. The worst-case scenario is hitting the 200 MB download size limit, which triggers an additional confirmation dialog during app download when using cellular data. On the memory side, Lyft engineers found out that extensions may be limited to using between 20 and 50MB of RAM depending on the iOS version, device model, and other factors. To reduce the app binary size and memory footprint, Lyft engineers analyzed the dependency graph of their app to identify the modules that contributed most to that. Since Lyft uses Bazel, they relied on a graph visualization software, Graphviz, to create an image from the data produced by Bazel using the query --output=graph command. To measure the binary size impact in detail, each module can be added as the only dependency to the Apple Maps extension and analyzed using the binary-size-diff tool. binary-size-diff is a tool to compare the binary size difference between the base branch and a given pull request. This makes it possible to measure the actual effect of removing (or including) a dependency. Once that information is available, the next step is identifying any dependencies that appear to be unnecessarily included. To this aim, Lyft engineers used another feature of Bazel's to show the transitive dependencies between two modules. bazel query 'allpaths(INITIAL_MODULE_PATH:INITIAL_MODULE_NAME, TARGET_MODULE_PATH:TARGET_MODULE_NAME)' --output=graph | grep -v ' node \\[shape=box\\];' \u003e relations.dot This command shows which modules are included along the path connecting the module under investigation to each of its larger dependencies, so you can either remove them or make the target module not dependent on them. In a specific case, the Lyft team decided to duplicate a service to create a minimalist dependency with the aim to break the dependency with larger modules. Using this approach Lyft engineers could reduce the binary size of their extension from 45MB to 15MB. While a 30MB reduction is not significant for a server-side or desktop app, it amounts to 15% of the \"safe\" size limit of 200MB. Stepaniuk and Husar's article contains additional details related to the process of releasing an app extension, such as how to ensure the extension is available for all supported regions, the effect of using the APPLICATION_EXTENSION_API_ONLY build setting, and SiriKit idiosyncrasies, so do not miss it if you are interested in these topics. About the Author Sergio De Simone",
  "image": "https://res.infoq.com/news/2024/12/lyft-ios-maps-extension/en/headerimage/lyft-ios-app-extension-1734447783723.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eIn a recent article, Lyft engineers Artur Stepaniuk and Max Husar \u003ca href=\"https://eng.lyft.com/integrating-extensions-into-large-scale-ios-apps-8f15dc5f3be9\"\u003edescribed how Lyft handles the complexity of creating an app extension for their iOS app\u003c/a\u003e without breaking the tight RAM and binary size constraints set by Apple nor impair user experience.\u003c/p\u003e\n\n\u003cp\u003eLyft\u0026#39;s iOS app includes an \u003ca href=\"https://developer.apple.com/app-extensions/\"\u003eextension\u003c/a\u003e to integrate it with Apple Maps and provide information about Lyft offers from within the Maps app. As Stepaniuk and Husar explain, the key to create an iOS app extension in an efficient way is to correctly manage dependencies to maximize code reuse across the app and the extension while optimizing binary size and memory usage.\u003c/p\u003e\n\n\u003cp\u003eThe main complexity factor in this process is the impossibility of using dynamic linking to avoid the cost of loading them into memory at launch time, which would make the app too slow on launch. This makes static linking the only viable option, albeit at the cost of increasing the app binary size as well as its memory footprint. However,\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eA larger binary size can lead to longer download and install times, potentially reducing the number of installs. The worst-case scenario is hitting the 200 MB download size limit, which triggers an additional confirmation dialog during app download when using cellular data.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eOn the memory side, Lyft engineers found out that extensions may be limited to using between 20 and 50MB of RAM depending on the iOS version, device model, and other factors.\u003c/p\u003e\n\n\u003cp\u003eTo reduce the app binary size and memory footprint, Lyft engineers analyzed the dependency graph of their app to identify the modules that contributed most to that. Since Lyft uses Bazel, they relied on a graph visualization software, Graphviz, to create an image from the data produced by Bazel using the \u003ccode\u003equery --output=graph\u003c/code\u003e command.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eTo measure the binary size impact in detail, each module can be added as the only dependency to the Apple Maps extension and analyzed using the \u003ccode\u003ebinary-size-diff\u003c/code\u003e tool.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ccode\u003ebinary-size-diff\u003c/code\u003e is a tool to compare the binary size difference between the base branch and a given pull request. This makes it possible to measure the actual effect of removing (or including) a dependency.\u003c/p\u003e\n\n\u003cp\u003eOnce that information is available, the next step is identifying any dependencies that appear to be unnecessarily included. To this aim, Lyft engineers used another feature of Bazel\u0026#39;s to show the transitive dependencies between two modules.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\nbazel query \u0026#39;allpaths(INITIAL_MODULE_PATH:INITIAL_MODULE_NAME, TARGET_MODULE_PATH:TARGET_MODULE_NAME)\u0026#39; --output=graph | grep -v \u0026#39;  node \\[shape=box\\];\u0026#39; \u0026gt; relations.dot\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis command shows which modules are included along the path connecting the module under investigation to each of its larger dependencies, so you can either remove them or make the target module not dependent on them. In a specific case, the Lyft team decided to duplicate a service to create a minimalist dependency with the aim to break the dependency with larger modules.\u003c/p\u003e\n\n\u003cp\u003eUsing this approach Lyft engineers could reduce the binary size of their extension from 45MB to 15MB. While a 30MB reduction is not significant for a server-side or desktop app, it amounts to 15% of the \u0026#34;safe\u0026#34; size limit of 200MB.\u003c/p\u003e\n\n\u003cp\u003eStepaniuk and Husar\u0026#39;s article contains additional details related to the process of releasing an app extension, such as how to ensure the extension is available for all supported regions, the effect of using the \u003ccode\u003eAPPLICATION_EXTENSION_API_ONLY\u003c/code\u003e build setting, and SiriKit idiosyncrasies, so do not miss it if you are interested in these topics.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Sergio-De-Simone\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eSergio De Simone\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2024-12-17T00:00:00Z",
  "modifiedTime": null
}
