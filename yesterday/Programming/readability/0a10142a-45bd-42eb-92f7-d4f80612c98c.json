{
  "id": "0a10142a-45bd-42eb-92f7-d4f80612c98c",
  "title": "Exploring GitHub CLI: How to interact with GitHub‚Äôs GraphQL API endpoint",
  "link": "https://github.blog/developer-skills/github/exploring-github-cli-how-to-interact-with-githubs-graphql-api-endpoint/",
  "description": "Discover practical tips and tricks for forming effective GraphQL queries and mutations. The post Exploring GitHub CLI: How to interact with GitHub‚Äôs GraphQL API endpoint appeared first on The GitHub Blog.",
  "author": "Joshua Johanning",
  "published": "Tue, 22 Apr 2025 16:00:01 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Developer skills",
    "GitHub",
    "GitHub CLI",
    "GraphQL"
  ],
  "byline": "Joshua Johanning",
  "length": 15116,
  "excerpt": "Master GitHub CLI and GraphQL with this guide. Learn to query and manipulate data efficiently, enhancing your workflow and productivity.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "You might have heard of the GitHub CLI and all of the awesome things you can do with it. However, one of its hidden superpowers is the ability to execute complex queries and mutations through GitHub‚Äôs GraphQL API. This post will walk you through what GitHub‚Äôs GraphQL API endpoint is and how to query it with the GitHub CLI. What is GraphQL? Let‚Äôs start with the basics: GraphQL is a query language for APIs and a runtime for executing those queries against your data. Unlike traditional REST APIs that provide fixed data structures from predefined endpoints, GraphQL allows clients to request exactly the data they need in a single request. This single-request approach reduces network overhead, speeds up application performance, and simplifies client-side logic by eliminating the need to reconcile multiple API responses‚Äîa capability that has been openly available since the specification was open sourced in 2015. GraphQL operations come in two primary types: queries and mutations. Queries are read-only operations that retrieve data without making any changes‚Äîsimilar to GET requests in REST. Mutations, on the other hand, are used to modify server-side data (create, update, or delete)‚Äîcomparable to POST, PATCH, PUT, and DELETE in REST APIs. This clear separation between reading and writing operations makes GraphQL interactions predictable while maintaining the flexibility to precisely specify what data should be returned after a change is made. How is GraphQL used at GitHub? GitHub implemented GraphQL in 2016 to address limitations of RESTful APIs. This adoption has significantly enhanced the developer experience when working with GitHub data. With the GraphQL endpoint, you can retrieve a repository‚Äôs issues, its labels, assignees, and comments with a single GraphQL query. Using our REST APIs, this would have otherwise taken several sets of nested calls. Some GitHub data and operations are only accessible through the GraphQL API (such as discussions, projects, and some enterprise settings), others exclusively through REST APIs (such as querying actions workflows, runners, or logs), and some using either endpoint (such as repositories, issues, pull requests, and user information). GitHub‚Äôs GraphQL endpoint is accessible at api.github.com/graphql and you can explore the full schema in our GraphQL documentation or through the interactive GraphQL Explorer. A key consideration when choosing between the REST API and the GraphQL API is how the rate limits are calculated. As a quick summary for how this is implemented: REST API: Limited by number of requests (typically 5,000 requests per hour for authenticated users and up to 15,000 for GitHub Apps installed in an Enterprise) GraphQL API: Limited by ‚Äúpoints‚Äù (typically 5,000 points per hour for authenticated users but can go up to 10,000-12,500 points per hour for GitHub Apps) Each GraphQL query costs at least one point, but the cost increases based on the complexity of your query (number of nodes requested, connections traversed, etc.). The GraphQL API provides a rateLimit field you can include in your queries to check your current limit status. For scenarios where you need to fetch related data that would otherwise require multiple REST calls, GraphQL is often more rate limit friendly because: One complex GraphQL query might cost 5-10 points but replace 5-10 separate REST API calls. You avoid ‚Äúover-fetching‚Äù data you don‚Äôt need, which indirectly helps with rate limits. The GraphQL API allows for more granular field selection, potentially reducing the complexity and point cost. However, poorly optimized GraphQL queries that request large amounts of nested data could potentially use up your rate limit faster than equivalent REST requests‚Äîand quickly run into secondary rate limit issues. A quick rule of thumb on deciding between which to use: For querying relational objects, such as GitHub Projects and their issues, GraphQL is often more effective, especially if it‚Äôs a discrete number of items. For bulk data of one type or single data points, such as pulling in a list of repository names in an organization, the REST API is often preferred. Sometimes there isn‚Äôt a right or wrong answer; so as long as the object exists, try one out! Why use GitHub CLI for GraphQL? While many developers start with GitHub‚Äôs GraphQL Explorer on the web, curl, or other API querying tools, there‚Äôs a more streamlined approach: using built-in GraphQL support in the GitHub CLI. Before diving into the how-to, let‚Äôs understand why GitHub CLI is often my go-to tool for GraphQL queries and mutations: Authentication is handled automatically: No need to manage personal access tokens manually. Streamlined syntax: Simpler than crafting curl commands. Local development friendly: Run queries and mutations right from your terminal. JSON processing: Built-in options for filtering and formatting results. Pagination support: Ability to work with cursor-based pagination in GraphQL responses. Consistent experience: Same tool you‚Äôre likely using for other GitHub tasks. How to get started with gh api graphql First, ensure you have GitHub CLI installed and authenticated with gh auth login. The basic syntax for making a GraphQL query with gh api graphql is: gh api graphql -H X-Github-Next-Global-ID:1 -f query=' query { viewer { login name bio } } ' This simple query returns your GitHub username, the name you have defined in your profile, and your bio. The -f flag defines form variables, with query= being the GraphQL query itself. Here‚Äôs our example output: { \"data\": { \"viewer\": { \"login\": \"joshjohanning\", \"name\": \"Josh Johanning\", \"bio\": \"DevOps Architect | GitHub\" } } } Running queries and mutations Basic query example Let‚Äôs try something more practical‚Äîfetching information about a repository. To get started, we‚Äôll use the following query: gh api graphql -H X-Github-Next-Global-ID:1 -f query=' query($owner:String!, $repo:String!) { repository(owner:$owner, name:$repo) { name description id stargazerCount forkCount issues(states:OPEN) { totalCount } } } ' -F owner=octocat -F repo=Hello-World The -F flag sets variable values that are referenced in the query with $variable. Here‚Äôs our example output: { \"data\": { \"repository\": { \"name\": \"Hello-World\", \"description\": \"My first repository on GitHub!\", \"id\": \"R_kgDOABPHjQ\", \"stargazerCount\": 2894, \"forkCount\": 2843, \"issues\": { \"totalCount\": 1055 } } } } üí° Tip: The -H X-Github-Next-Global-ID:1 parameter sets an HTTP header that instructs GitHub‚Äôs GraphQL API to use the new global node ID format rather than the legacy format. While your query will function without this header, including it prevents deprecation warnings when referencing node IDs (such as when passing repository.ID in subsequent operations). GitHub recommends adopting this format for all new integrations to ensure long-term compatibility. Running mutations Mutations work similarly. Here‚Äôs how to create a new issue: gh api graphql -H X-Github-Next-Global-ID:1 -f query=' mutation($repositoryId:ID!, $title:String!, $body:String) { createIssue(input:{repositoryId:$repositoryId, title:$title, body:$body}) { issue { url number title body state } } } ' -F repositoryId=\"R_kgDOABPHjQ\" -F title=\"Creating issue with GraphQL\" -F body=\"Issue body created via GraphQL\\!\" Make sure to update the repositoryId parameter with the actual repository‚Äôs GraphQL ID (an example of returning a repository‚Äôs ID is shown in the basic query above!). Here‚Äôs our example output: { \"data\": { \"createIssue\": { \"issue\": { \"url\": \"https://github.com/octocat/Hello-World/issues/3706\", \"number\": 3706, \"title\": \"Creating issue with GraphQL\", \"body\": \"Issue body created via GraphQL!\", \"state\": \"OPEN\" } } } } Filtering GraphQL results GitHub CLI supports JQ-style filtering for extracting specific parts of the response, which is invaluable when you need to parse just the repository names or URLs from a query for use in automation scripts. Here is an example of using the --jq flag: gh api graphql -H X-Github-Next-Global-ID:1 -f query=' query($owner:String!, $repo:String!) { repository(owner:$owner, name:$repo) { issues(first:3, states:OPEN) { nodes { number title url } } } } ' -F owner=octocat -F repo=Hello-World --jq '.data.repository.issues.nodes[]' The --jq flag accepts JQ expressions to process JSON output. This query returns just the array of issues, without the surrounding GraphQL response structure. Here‚Äôs our example output: { \"number\": 26, \"title\": \"test issue\", \"url\": \"https://github.com/octocat/Hello-World/issues/26\" } { \"number\": 27, \"title\": \"just for test\", \"url\": \"https://github.com/octocat/Hello-World/issues/27\" } { \"number\": 28, \"title\": \"Test\", \"url\": \"https://github.com/octocat/Hello-World/issues/28\" } We could have modified the --jq flag to just return the issue URLs, like so: gh api graphql -H X-Github-Next-Global-ID:1 -f query=' query($owner:String!, $repo:String!) { repository(owner:$owner, name:$repo) { issues(first:3, states:OPEN) { nodes { number title url } } } } ' -F owner=octocat -F repo=Hello-World --jq '.data.repository.issues.nodes[].url' Here‚Äôs our example output: https://github.com/octocat/Hello-World/issues/26 https://github.com/octocat/Hello-World/issues/27 https://github.com/octocat/Hello-World/issues/28 Handling pagination GitHub‚Äôs GraphQL API limits results to a maximum of 100 items per page, which means you‚Äôll need pagination to retrieve larger datasets. Pagination in GraphQL works by returning a ‚Äúcursor‚Äù with each page of results, which acts as a pointer to where the next set of results should begin. When you request the next page, you provide this cursor to indicate where to start. The easiest way to handle this pagination in the GitHub CLI is with the --paginate flag, which automatically collects all pages of results for you by managing these cursors behind the scenes. Here‚Äôs what that looks like in a query: gh api graphql --paginate -H X-Github-Next-Global-ID:1 -f query=' query($owner:String!, $repo:String!, $endCursor:String) { repository(owner:$owner, name:$repo) { issues(first:100, after:$endCursor, states:OPEN, orderBy:{field:CREATED_AT, direction:DESC}) { pageInfo { hasNextPage endCursor } nodes { number title createdAt } } } } ' -F owner=octocat -F repo=Hello-World The pageInfo object with its hasNextPage and endCursor fields is essential for pagination. When you use the --paginate flag, GitHub CLI automatically uses these fields to fetch all available pages for your query, combining the results into a single response. Here‚Äôs our example output: { \"data\": { \"repository\": { \"issues\": { \"pageInfo\": { \"hasNextPage\": true, \"endCursor\": \"Y3Vyc29yOnYyOpK5MjAyNC0xMi0zMFQxNDo0ODo0NC0wNjowMM6kunD3\" }, \"nodes\": [ { \"number\": 3708, \"title\": \"Creating issue with GraphQL once more\", \"createdAt\": \"2025-04-02T18:15:11Z\", \"author\": { \"login\": \"joshjohanning\" } }, { \"number\": 3707, \"title\": \"Creating issue with GraphQL again\", \"createdAt\": \"2025-04-02T18:15:02Z\", \"author\": { \"login\": \"joshjohanning\" } }, { \"number\": 3706, \"title\": \"Creating issue with GraphQL\", \"createdAt\": \"2025-04-02T18:14:37Z\", \"author\": { \"login\": \"joshjohanning\" } }, ‚Ä¶ and so on ] } } } } This approach works great for moderate amounts of data, but keep in mind that GitHub‚Äôs GraphQL API has rate limits, so extremely large queries might need to implement delays between requests. üí° Important limitation: The --paginate flag can only handle pagination for a single connection at a time. For example, when listing repository issues as shown above, it can paginate through all issues, but cannot simultaneously paginate through each issue‚Äôs comments. For nested pagination, you‚Äôll need to implement custom logic. Building complex scripts: Chaining GraphQL queries together When working with GitHub‚Äôs GraphQL API, you often need to connect multiple queries to accomplish a complex task. Let‚Äôs look at how to chain GraphQL calls together using the GitHub CLI: ISSUE_ID=$(gh api graphql -H X-Github-Next-Global-ID:1 -f query=' query($owner: String!, $repo: String!, $issue_number: Int!) { repository(owner: $owner, name: $repo) { issue(number: $issue_number) { id } } } ' -F owner=joshjohanning -F repo=graphql-fun -F issue_number=1 --jq '.data.repository.issue.id') gh api graphql -H GraphQL-Features:sub_issues -H X-Github-Next-Global-ID:1 -f query=' query($issueId: ID!) { node(id: $issueId) { ... on Issue { subIssuesSummary { total completed percentCompleted } } } }' -F issueId=\"$ISSUE_ID\" Here‚Äôs what this shell script is doing: The first query captures an issue‚Äôs ID using the repository name and issue number The --jq flag extracts just the ID value and stores it in a variable The second query passes this ID to retrieve a summary of sub-issues Here‚Äôs our example output: { \"data\": { \"node\": { \"subIssuesSummary\": { \"total\": 3, \"completed\": 1, \"percentCompleted\": 33 } } } } Take this with you The gh api graphql command provides a convenient way to interact with GitHub‚Äôs GraphQL API directly from your terminal. It eliminates the need for token management, simplifies query syntax and formatting, and handles basic pagination that would otherwise be complex to implement. Whether you‚Äôre running complex queries or simple mutations, this approach offers a streamlined developer experience. Next time you need to interact with GitHub‚Äôs GraphQL API, skip the GraphQL Explorer on the web and try the GitHub CLI approach. It might just become your preferred method for working with GitHub‚Äôs powerful GraphQL API capabilities. Written by Josh is a senior DevOps architect on the GitHub FastTrack team. He has extensive experience promoting DevOps principles to companies large and small from his time as a consultant and now at GitHub. He is very passionate about accelerating teams' cloud journeys with GitHub and GitHub Actions. In his off time, Josh enjoys home improvement projects, traveling to new places, mixing craft cocktails, and spending time with his wife, cats, and daughter.",
  "image": "https://github.blog/wp-content/uploads/2025/04/wallpaper_github_generic_2.png?fit=1920%2C1080",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eYou might have heard of the \u003ca href=\"https://cli.github.com/\"\u003eGitHub CLI\u003c/a\u003e and \u003ca href=\"https://github.blog/developer-skills/github/how-to-level-up-your-git-game-with-github-cli/\"\u003eall of the awesome things\u003c/a\u003e you can do with it. However, one of its hidden superpowers is the ability to execute complex queries and mutations through GitHub‚Äôs GraphQL API. This post will walk you through what GitHub‚Äôs GraphQL API endpoint is and how to query it with the GitHub CLI.\u003c/p\u003e\n\u003ch2 id=\"what-is-graphql\" id=\"what-is-graphql\"\u003eWhat is GraphQL?\u003ca href=\"#what-is-graphql\" aria-label=\"What is GraphQL?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLet‚Äôs start with the basics: \u003ca href=\"https://graphql.org/learn\"\u003eGraphQL\u003c/a\u003e is a query language for APIs and a runtime for executing those queries against your data. Unlike traditional REST APIs that provide fixed data structures from predefined endpoints, GraphQL allows clients to request exactly the data they need in a single request. This single-request approach reduces network overhead, speeds up application performance, and simplifies client-side logic by eliminating the need to reconcile multiple API responses‚Äîa capability that has been openly available since the specification was \u003ca href=\"https://spec.graphql.org/\"\u003eopen sourced in 2015\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eGraphQL operations come in two primary types: queries and mutations. \u003cstrong\u003eQueries\u003c/strong\u003e are read-only operations that retrieve data without making any changes‚Äîsimilar to GET requests in REST. \u003cstrong\u003eMutations\u003c/strong\u003e, on the other hand, are used to modify server-side data (create, update, or delete)‚Äîcomparable to POST, PATCH, PUT, and DELETE in REST APIs. This clear separation between reading and writing operations makes GraphQL interactions predictable while maintaining the flexibility to precisely specify what data should be returned after a change is made.\u003c/p\u003e\n\u003ch2 id=\"how-is-graphql-used-at-github\" id=\"how-is-graphql-used-at-github\"\u003eHow is GraphQL used at GitHub?\u003ca href=\"#how-is-graphql-used-at-github\" aria-label=\"How is GraphQL used at GitHub?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGitHub \u003ca href=\"https://github.blog/developer-skills/github/the-github-graphql-api/\"\u003eimplemented GraphQL in 2016\u003c/a\u003e to address limitations of RESTful APIs. This adoption has significantly enhanced the developer experience when working with GitHub data. With the GraphQL endpoint, you can retrieve a repository‚Äôs issues, its labels, assignees, and comments with a single GraphQL query. Using our REST APIs, this would have otherwise taken several sets of nested calls.\u003c/p\u003e\n\u003cp\u003eSome GitHub data and operations are only accessible through the GraphQL API (such as discussions, projects, and some enterprise settings), others exclusively through REST APIs (such as querying actions workflows, runners, or logs), and some using either endpoint (such as repositories, issues, pull requests, and user information). GitHub‚Äôs GraphQL endpoint is accessible at \u003ca href=\"https://api.github.com/graphql\"\u003e\u003ccode\u003eapi.github.com/graphql\u003c/code\u003e\u003c/a\u003e and you can explore the full schema in our \u003ca href=\"https://docs.github.com/graphql/overview/about-the-graphql-api\"\u003eGraphQL documentation\u003c/a\u003e or through the interactive \u003ca href=\"https://docs.github.com/graphql/overview/explorer\"\u003eGraphQL Explorer\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eA key consideration when choosing between the REST API and the GraphQL API is how the rate limits are calculated. As a quick summary for how this is implemented:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eREST API\u003c/strong\u003e: Limited by number of requests (typically 5,000 requests per hour for authenticated users and up to 15,000 for GitHub Apps installed in an Enterprise)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGraphQL API\u003c/strong\u003e: Limited by ‚Äúpoints‚Äù (typically 5,000 points per hour for authenticated users but can go up to 10,000-12,500 points per hour for GitHub Apps)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEach GraphQL query costs at least one point, but the cost increases based on the complexity of your query (number of nodes requested, connections traversed, etc.). The GraphQL API provides a \u003ccode\u003erateLimit\u003c/code\u003e field you can include in your queries to check your current limit status.\u003c/p\u003e\n\u003cp\u003eFor scenarios where you need to fetch related data that would otherwise require multiple REST calls, GraphQL is often more rate limit friendly because:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOne complex GraphQL query might cost 5-10 points but replace 5-10 separate REST API calls.\u003c/li\u003e\n\u003cli\u003eYou avoid ‚Äúover-fetching‚Äù data you don‚Äôt need, which indirectly helps with rate limits.\u003c/li\u003e\n\u003cli\u003eThe GraphQL API allows for more granular field selection, potentially reducing the complexity and point cost.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHowever, poorly optimized GraphQL queries that request large amounts of nested data could potentially use up your rate limit faster than equivalent REST requests‚Äîand quickly run into \u003ca href=\"https://docs.github.com/graphql/overview/rate-limits-and-node-limits-for-the-graphql-api#secondary-rate-limits\"\u003esecondary rate limit\u003c/a\u003e issues.\u003c/p\u003e\n\u003cp\u003eA quick rule of thumb on deciding between which to use:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFor querying relational objects, such as GitHub Projects and their issues, GraphQL is often more effective, especially if it‚Äôs a discrete number of items.\u003c/li\u003e\n\u003cli\u003eFor bulk data of one type or single data points, such as pulling in a list of repository names in an organization, the REST API is often preferred.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSometimes there isn‚Äôt a right or wrong answer; so as long as the object exists, try one out!\u003c/p\u003e\n\u003ch2 id=\"why-use-github-cli-for-graphql\" id=\"why-use-github-cli-for-graphql\"\u003eWhy use GitHub CLI for GraphQL?\u003ca href=\"#why-use-github-cli-for-graphql\" aria-label=\"Why use GitHub CLI for GraphQL?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWhile many developers start with \u003ca href=\"https://docs.github.com/graphql/overview/explorer\"\u003eGitHub‚Äôs GraphQL Explorer\u003c/a\u003e on the web, \u003ccode\u003ecurl\u003c/code\u003e, or other API querying tools, there‚Äôs a more streamlined approach: using built-in GraphQL support in the GitHub CLI. Before diving into the how-to, let‚Äôs understand why GitHub CLI is often my go-to tool for GraphQL queries and mutations:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eAuthentication is handled automatically: No need to manage personal access tokens manually.\u003c/li\u003e\n\u003cli\u003eStreamlined syntax: Simpler than crafting \u003ccode\u003ecurl\u003c/code\u003e commands.\u003c/li\u003e\n\u003cli\u003eLocal development friendly: Run queries and mutations right from your terminal.\u003c/li\u003e\n\u003cli\u003eJSON processing: Built-in options for filtering and formatting results.\u003c/li\u003e\n\u003cli\u003ePagination support: Ability to work with cursor-based pagination in GraphQL responses.\u003c/li\u003e\n\u003cli\u003eConsistent experience: Same tool you‚Äôre likely using for other GitHub tasks.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"how-to-get-started-with-gh-api-graphql\" id=\"how-to-get-started-with-gh-api-graphql\"\u003eHow to get started with \u003ccode\u003egh api graphql\u003c/code\u003e\u003ca href=\"#how-to-get-started-with-gh-api-graphql\" aria-label=\"How to get started with \u0026lt;code\u0026gt;gh api graphql\u0026lt;/code\u0026gt;\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFirst, ensure you have \u003ca href=\"https://cli.github.com\"\u003eGitHub CLI installed\u003c/a\u003e and \u003ca href=\"https://cli.github.com/manual/gh_auth_login\"\u003eauthenticated\u003c/a\u003e with \u003ccode\u003egh auth login\u003c/code\u003e. The basic syntax for making a GraphQL query with \u003ca href=\"https://cli.github.com/manual/gh_api\"\u003e\u003ccode\u003egh api graphql\u003c/code\u003e\u003c/a\u003e is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egh api graphql -H X-Github-Next-Global-ID:1 -f query=\u0026#39;\n  query {\n    viewer {\n      login\n      name\n      bio\n    }\n  }\n\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis simple query returns your GitHub username, the name you have defined in your profile, and your bio. The \u003ccode\u003e-f\u003c/code\u003e flag defines form variables, with \u003ccode\u003equery=\u003c/code\u003e being the GraphQL query itself.\u003c/p\u003e\n\u003cp\u003eHere‚Äôs our example output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;data\u0026#34;: {\n    \u0026#34;viewer\u0026#34;: {\n      \u0026#34;login\u0026#34;: \u0026#34;joshjohanning\u0026#34;,\n      \u0026#34;name\u0026#34;: \u0026#34;Josh Johanning\u0026#34;,\n      \u0026#34;bio\u0026#34;: \u0026#34;DevOps Architect | GitHub\u0026#34;\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"running-queries-and-mutations\" id=\"running-queries-and-mutations\"\u003eRunning queries and mutations\u003ca href=\"#running-queries-and-mutations\" aria-label=\"Running queries and mutations\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"basic-query-example\" id=\"basic-query-example\"\u003eBasic query example\u003ca href=\"#basic-query-example\" aria-label=\"Basic query example\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLet‚Äôs try something more practical‚Äîfetching information about a repository. To get started, we‚Äôll use the following query:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egh api graphql -H X-Github-Next-Global-ID:1 -f query=\u0026#39;\n  query($owner:String!, $repo:String!) {\n    repository(owner:$owner, name:$repo) {\n      name\n      description\n      id\n      stargazerCount\n      forkCount\n      issues(states:OPEN) {\n        totalCount\n      }\n    }\n  }\n\u0026#39; -F owner=octocat -F repo=Hello-World\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e-F\u003c/code\u003e flag sets variable values that are referenced in the query with \u003ccode\u003e$variable\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHere‚Äôs our example output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;data\u0026#34;: {\n    \u0026#34;repository\u0026#34;: {\n      \u0026#34;name\u0026#34;: \u0026#34;Hello-World\u0026#34;,\n      \u0026#34;description\u0026#34;: \u0026#34;My first repository on GitHub!\u0026#34;,\n      \u0026#34;id\u0026#34;: \u0026#34;R_kgDOABPHjQ\u0026#34;,\n      \u0026#34;stargazerCount\u0026#34;: 2894,\n      \u0026#34;forkCount\u0026#34;: 2843,\n      \u0026#34;issues\u0026#34;: {\n        \u0026#34;totalCount\u0026#34;: 1055\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv\u003e\u003cp\u003e\nüí° \u003cstrong\u003eTip\u003c/strong\u003e: The \u003ccode\u003e-H X-Github-Next-Global-ID:1\u003c/code\u003e parameter sets an HTTP header that instructs GitHub‚Äôs GraphQL API to use the \u003ca href=\"https://docs.github.com/graphql/guides/migrating-graphql-global-node-ids\"\u003enew global node ID format\u003c/a\u003e rather than the legacy format. While your query will function without this header, including it prevents deprecation warnings when referencing node IDs (such as when passing \u003ccode\u003erepository.ID\u003c/code\u003e in subsequent operations). GitHub recommends adopting this format for all new integrations to ensure long-term compatibility.\n\u003c/p\u003e\u003c/div\u003e\n\u003ch3 id=\"running-mutations\" id=\"running-mutations\"\u003eRunning mutations\u003ca href=\"#running-mutations\" aria-label=\"Running mutations\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eMutations work similarly. Here‚Äôs how to create a new issue:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egh api graphql -H X-Github-Next-Global-ID:1 -f query=\u0026#39;\n  mutation($repositoryId:ID!, $title:String!, $body:String) {\n    createIssue(input:{repositoryId:$repositoryId, title:$title, body:$body}) {\n      issue {\n        url\n        number\n        title\n        body\n        state\n      }\n    }\n  }\n\u0026#39; -F repositoryId=\u0026#34;R_kgDOABPHjQ\u0026#34; -F title=\u0026#34;Creating issue with GraphQL\u0026#34; -F body=\u0026#34;Issue body created via GraphQL\\!\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMake sure to update the \u003ccode\u003erepositoryId\u003c/code\u003e parameter with the actual repository‚Äôs GraphQL ID (an example of returning a repository‚Äôs ID is shown in the basic query above!).\u003c/p\u003e\n\u003cp\u003eHere‚Äôs our example output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;data\u0026#34;: {\n    \u0026#34;createIssue\u0026#34;: {\n      \u0026#34;issue\u0026#34;: {\n        \u0026#34;url\u0026#34;: \u0026#34;https://github.com/octocat/Hello-World/issues/3706\u0026#34;,\n        \u0026#34;number\u0026#34;: 3706,\n        \u0026#34;title\u0026#34;: \u0026#34;Creating issue with GraphQL\u0026#34;,\n        \u0026#34;body\u0026#34;: \u0026#34;Issue body created via GraphQL!\u0026#34;,\n        \u0026#34;state\u0026#34;: \u0026#34;OPEN\u0026#34;\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"filtering-graphql-results\" id=\"filtering-graphql-results\"\u003eFiltering GraphQL results\u003ca href=\"#filtering-graphql-results\" aria-label=\"Filtering GraphQL results\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGitHub CLI supports \u003ca href=\"https://github.com/jqlang/jq\"\u003eJQ\u003c/a\u003e-style filtering for extracting specific parts of the response, which is invaluable when you need to parse just the repository names or URLs from a query for use in automation scripts. Here is an example of using the \u003ccode\u003e--jq\u003c/code\u003e flag:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egh api graphql -H X-Github-Next-Global-ID:1 -f query=\u0026#39;\n  query($owner:String!, $repo:String!) {\n    repository(owner:$owner, name:$repo) {\n      issues(first:3, states:OPEN) {\n        nodes {\n          number\n          title\n          url\n        }\n      }\n    }\n  }\n\u0026#39; -F owner=octocat -F repo=Hello-World --jq \u0026#39;.data.repository.issues.nodes[]\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e--jq\u003c/code\u003e flag accepts JQ expressions to process JSON output. This query returns just the array of issues, without the surrounding GraphQL response structure.\u003c/p\u003e\n\u003cp\u003eHere‚Äôs our example output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;number\u0026#34;: 26,\n  \u0026#34;title\u0026#34;: \u0026#34;test issue\u0026#34;,\n  \u0026#34;url\u0026#34;: \u0026#34;https://github.com/octocat/Hello-World/issues/26\u0026#34;\n}\n{\n  \u0026#34;number\u0026#34;: 27,\n  \u0026#34;title\u0026#34;: \u0026#34;just for test\u0026#34;,\n  \u0026#34;url\u0026#34;: \u0026#34;https://github.com/octocat/Hello-World/issues/27\u0026#34;\n}\n{\n  \u0026#34;number\u0026#34;: 28,\n  \u0026#34;title\u0026#34;: \u0026#34;Test\u0026#34;,\n  \u0026#34;url\u0026#34;: \u0026#34;https://github.com/octocat/Hello-World/issues/28\u0026#34;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe could have modified the \u003ccode\u003e--jq\u003c/code\u003e flag to just return the issue URLs, like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egh api graphql -H X-Github-Next-Global-ID:1 -f query=\u0026#39;\n  query($owner:String!, $repo:String!) {\n    repository(owner:$owner, name:$repo) {\n      issues(first:3, states:OPEN) {\n        nodes {\n          number\n          title\n          url\n        }\n      }\n    }\n  }\n\u0026#39; -F owner=octocat -F repo=Hello-World --jq \u0026#39;.data.repository.issues.nodes[].url\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere‚Äôs our example output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttps://github.com/octocat/Hello-World/issues/26\nhttps://github.com/octocat/Hello-World/issues/27\nhttps://github.com/octocat/Hello-World/issues/28\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"handling-pagination\" id=\"handling-pagination\"\u003eHandling pagination\u003ca href=\"#handling-pagination\" aria-label=\"Handling pagination\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGitHub‚Äôs GraphQL API limits results to a maximum of \u003ca href=\"https://docs.github.com/graphql/guides/using-pagination-in-the-graphql-api#about-pagination\"\u003e100 items per page\u003c/a\u003e, which means you‚Äôll need pagination to retrieve larger datasets.\u003c/p\u003e\n\u003cp\u003ePagination in GraphQL works by returning a ‚Äúcursor‚Äù with each page of results, which acts as a pointer to where the next set of results should begin. When you request the next page, you provide this cursor to indicate where to start.\u003c/p\u003e\n\u003cp\u003eThe easiest way to handle this pagination in the GitHub CLI is with the \u003ccode\u003e--paginate\u003c/code\u003e flag, which automatically collects all pages of results for you by managing these cursors behind the scenes. Here‚Äôs what that looks like in a query:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egh api graphql --paginate -H X-Github-Next-Global-ID:1 -f query=\u0026#39;\n  query($owner:String!, $repo:String!, $endCursor:String) {\n    repository(owner:$owner, name:$repo) {\n      issues(first:100, after:$endCursor, states:OPEN, orderBy:{field:CREATED_AT, direction:DESC}) {\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        nodes {\n          number\n          title\n          createdAt\n        }\n      }\n    }\n  }\n\u0026#39; -F owner=octocat -F repo=Hello-World\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe pageInfo object with its \u003ccode\u003ehasNextPage\u003c/code\u003e and \u003ccode\u003eendCursor\u003c/code\u003e fields is essential for pagination. When you use the \u003ccode\u003e--paginate\u003c/code\u003e flag, GitHub CLI automatically uses these fields to fetch all available pages for your query, combining the results into a single response.\u003c/p\u003e\n\u003cp\u003eHere‚Äôs our example output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;data\u0026#34;: {\n    \u0026#34;repository\u0026#34;: {\n      \u0026#34;issues\u0026#34;: {\n        \u0026#34;pageInfo\u0026#34;: {\n          \u0026#34;hasNextPage\u0026#34;: true,\n          \u0026#34;endCursor\u0026#34;: \u0026#34;Y3Vyc29yOnYyOpK5MjAyNC0xMi0zMFQxNDo0ODo0NC0wNjowMM6kunD3\u0026#34;\n        },\n        \u0026#34;nodes\u0026#34;: [\n          {\n            \u0026#34;number\u0026#34;: 3708,\n            \u0026#34;title\u0026#34;: \u0026#34;Creating issue with GraphQL once more\u0026#34;,\n            \u0026#34;createdAt\u0026#34;: \u0026#34;2025-04-02T18:15:11Z\u0026#34;,\n            \u0026#34;author\u0026#34;: {\n              \u0026#34;login\u0026#34;: \u0026#34;joshjohanning\u0026#34;\n            }\n          },\n          {\n            \u0026#34;number\u0026#34;: 3707,\n            \u0026#34;title\u0026#34;: \u0026#34;Creating issue with GraphQL again\u0026#34;,\n            \u0026#34;createdAt\u0026#34;: \u0026#34;2025-04-02T18:15:02Z\u0026#34;,\n            \u0026#34;author\u0026#34;: {\n              \u0026#34;login\u0026#34;: \u0026#34;joshjohanning\u0026#34;\n            }\n          },\n          {\n            \u0026#34;number\u0026#34;: 3706,\n            \u0026#34;title\u0026#34;: \u0026#34;Creating issue with GraphQL\u0026#34;,\n            \u0026#34;createdAt\u0026#34;: \u0026#34;2025-04-02T18:14:37Z\u0026#34;,\n            \u0026#34;author\u0026#34;: {\n              \u0026#34;login\u0026#34;: \u0026#34;joshjohanning\u0026#34;\n            }\n          },\n          ‚Ä¶ and so on\n        ]\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis approach works great for moderate amounts of data, but keep in mind that GitHub‚Äôs GraphQL API has \u003ca href=\"https://docs.github.com/graphql/overview/rate-limits-and-node-limits-for-the-graphql-api\"\u003erate limits\u003c/a\u003e, so extremely large queries might need to implement delays between requests.\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003eüí° \u003cstrong\u003eImportant limitation\u003c/strong\u003e: The \u003ccode\u003e--paginate\u003c/code\u003e flag can only handle pagination for a single connection at a time. For example, when listing repository issues as shown above, it can paginate through all issues, but cannot simultaneously paginate through each issue‚Äôs comments. For nested pagination, you‚Äôll need to implement custom logic.\u003c/p\u003e\u003c/div\u003e\n\u003ch2 id=\"building-complex-scripts-chaining-graphql-queries-together\" id=\"building-complex-scripts-chaining-graphql-queries-together\"\u003eBuilding complex scripts: Chaining GraphQL queries together\u003ca href=\"#building-complex-scripts-chaining-graphql-queries-together\" aria-label=\"Building complex scripts: Chaining GraphQL queries together\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWhen working with GitHub‚Äôs GraphQL API, you often need to connect multiple queries to accomplish a complex task. Let‚Äôs look at how to chain GraphQL calls together using the GitHub CLI:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eISSUE_ID=$(gh api graphql -H X-Github-Next-Global-ID:1 -f query=\u0026#39;\n  query($owner: String!, $repo: String!, $issue_number: Int!) {\n    repository(owner: $owner, name: $repo) {\n      issue(number: $issue_number) {\n        id\n      }\n    }\n  }\n\u0026#39; -F owner=joshjohanning -F repo=graphql-fun -F issue_number=1 --jq \u0026#39;.data.repository.issue.id\u0026#39;) \ngh api graphql -H GraphQL-Features:sub_issues -H X-Github-Next-Global-ID:1 -f query=\u0026#39;\nquery($issueId: ID!) {\n  node(id: $issueId) {\n    ... on Issue {\n      subIssuesSummary {\n        total\n        completed\n        percentCompleted\n      }\n    }\n  }\n}\u0026#39; -F issueId=\u0026#34;$ISSUE_ID\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere‚Äôs what this shell script is doing:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe first query captures an issue‚Äôs ID using the repository name and issue number\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003e--jq\u003c/code\u003e flag extracts just the ID value and stores it in a variable\u003c/li\u003e\n\u003cli\u003eThe second query passes this ID to retrieve a summary of sub-issues\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHere‚Äôs our example output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;data\u0026#34;: {\n    \u0026#34;node\u0026#34;: {\n      \u0026#34;subIssuesSummary\u0026#34;: {\n        \u0026#34;total\u0026#34;: 3,\n        \u0026#34;completed\u0026#34;: 1,\n        \u0026#34;percentCompleted\u0026#34;: 33\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"take-this-with-you\" id=\"take-this-with-you\"\u003eTake this with you\u003ca href=\"#take-this-with-you\" aria-label=\"Take this with you\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"https://cli.github.com/manual/gh_api\"\u003e\u003ccode\u003egh api graphql\u003c/code\u003e\u003c/a\u003e command provides a convenient way to interact with GitHub‚Äôs GraphQL API directly from your terminal. It eliminates the need for token management, simplifies query syntax and formatting, and handles basic pagination that would otherwise be complex to implement. Whether you‚Äôre running complex queries or simple mutations, this approach offers a streamlined developer experience.\u003c/p\u003e\n\u003cp\u003eNext time you need to interact with GitHub‚Äôs GraphQL API, skip the GraphQL Explorer on the web and try the GitHub CLI approach. It might just become your preferred method for working with GitHub‚Äôs powerful GraphQL API capabilities.\u003c/p\u003e\n\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/19912012?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/19912012?v=4\u0026amp;s=200\" alt=\"Joshua Johanning\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eJosh is a senior DevOps architect on the GitHub FastTrack team. He has extensive experience promoting DevOps principles to companies large and small from his time as a consultant and now at GitHub. He is very passionate about accelerating teams\u0026#39; cloud journeys with GitHub and GitHub Actions. In his off time, Josh enjoys home improvement projects, traveling to new places, mixing craft cocktails, and spending time with his wife, cats, and daughter.\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2025-04-22T16:00:01Z",
  "modifiedTime": null
}
