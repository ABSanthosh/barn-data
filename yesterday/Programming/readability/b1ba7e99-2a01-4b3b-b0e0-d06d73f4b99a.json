{
  "id": "b1ba7e99-2a01-4b3b-b0e0-d06d73f4b99a",
  "title": "OpenTelemetry Plugin for JetBrains Rider: Observability Inside Your IDE",
  "link": "https://blog.jetbrains.com/dotnet/2025/06/16/opentelemetry-plugin-for-jetbrains-rider/",
  "description": "Understanding how your application behaves at runtime has always been a challenge. Traditional debugging and profiling tools can help you understand what’s happening at specific points in time – but getting a complete picture of system behavior, performance patterns, and architectural relationships often means jumping between external tools and dashboards. We’re building the OpenTelemetry plugin […]",
  "author": "Sasha Ivanova",
  "published": "Mon, 16 Jun 2025 14:52:53 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "rider",
    "observability",
    "opentelemetry"
  ],
  "byline": "Sasha Ivanova",
  "length": 7826,
  "excerpt": "Understanding how your application behaves at runtime has always been a challenge. Traditional debugging and profiling tools can help you understand what's happening at specific points in time – but g",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "Essential productivity kit for .NET and game developers RiderOpenTelemetry Plugin for JetBrains Rider: Observability Inside Your IDE Understanding how your application behaves at runtime has always been a challenge. Traditional debugging and profiling tools can help you understand what’s happening at specific points in time – but getting a complete picture of system behavior, performance patterns, and architectural relationships often means jumping between external tools and dashboards. We’re building the OpenTelemetry plugin for JetBrains Rider to bring runtime observability directly into your development environment. What is the OpenTelemetry plugin for Rider? This plugin is designed for observability during local and dev/test development. It’s not a debugger or profiler – instead, it lets you correlate runtime behavior (logs, metrics, traces) with your code inside Rider. It helps you answer questions like: What happened right before this error? Which services did this endpoint call? Why is this request slower today than yesterday? If you’ve been following our work on observability, you might have already seen OpenTelemetry support in our .NET Aspire plugin. This new plugin builds on that experience, but it stands on its own. It doesn’t require Aspire or any other specific tooling. Just run your application from Rider, and the plugin gives you access to runtime data inside the IDE. It’s designed to support a wide range of .NET development workflows, whether or not Aspire is part of your stack. With everything in one place, you can jump straight from a log to the responsible line of code – no external dashboards needed. Imagine this You’re implementing a new feature in a cloud-based .NET system: a few services, a PostgreSQL database, and a message queue. Typically, validating its behavior would mean setting up external tools for logs, metrics, and traces, wiring them into your environment, and flipping between dashboards to piece everything together. With the OpenTelemetry plugin for Rider, you just run the app and watch everything come into focus – logs appear instantly, metrics stream in with zero setup, and an architecture diagram shows exactly how your feature flows through services and dependencies. No dashboards to set up. No context-switching. Just insight, right where you work. Key features  Comprehensive log management The plugin includes a table-style log viewer with advanced search and filtering capabilities to help you quickly find the information you need. You can filter by log level, text content, and other parameters to focus on what matters most. The real power lies in its tight integration with the source code. When you find an issue in the logs, you can click through directly to the relevant line of code. This connection between runtime behavior and source makes it more than a typical monitoring tool. The log viewer with filtering capabilities and different log levels . Detailed log view showing timestamps, levels, and messages for different log types. Detailed log information panel showing trace IDs, span IDs, and the “Navigate To Code” functionality. Runtime metrics at your fingertips The metrics viewer presents a detailed metric tree showing your application’s runtime performance. Instead of guessing about resource usage or performance bottlenecks, you can see exactly how your application behaves under different conditions. The metrics viewer displays ASP.NET Core routing performance data with real-time charts. Automatic architecture visualization Most interestingly, the plugin can automatically generate architecture diagrams from your execution traces. These aren’t static diagrams you have to maintain – they’re built directly from how your system actually behaves at runtime, showing services, endpoints, databases, and message queues as they interact in real scenarios. Automatically generated service map showing the relationship between API endpoints, internal services, RabbitMQ, and PostgreSQL based on actual runtime traces. Zero-setup auto-instrumentation You don’t need to manually add OpenTelemetry instrumentation to your application. If you start your application using a .NET Project or a launchSettings.json configuration, the plugin will automatically inject the required OpenTelemetry packages  — as long as you’ve enabled the Allow automatic instrumentation option under Settings/Preferences | Tools | OpenTelemetry. With that setting enabled, you’ll get runtime observability without modifying your codebase or managing dependencies yourself.  Real-world use cases Manual testing and debugging Instead of adding console.WriteLine statements or setting breakpoints everywhere, you can inspect logs, metrics, and traces to understand runtime behavior while developing or testing features. Most importantly, when you identify an issue, you can immediately jump to the relevant source code without leaving your development environment. Team onboarding New developers joining your team can visualize system architecture and understand runtime context without learning a separate set of tools. Just install Rider and start exploring. This is just the beginning We’re just getting started with this tooling. Here’s what we’re currently exploring: Multi-IDE support: OpenTelemetry is language- and vendor-agnostic, which opens the door to supporting additional IDEs like IntelliJ IDEA and PyCharm in the future. AI-powered insights: We’re exploring how runtime data can be used to explain issues or suggest improvements. Imagine having AI explain error logs in context, adding runtime data to AI Assistant conversations for better suggestions, or even running automated testing agents that can analyze system behavior. Cloud integration: While the current focus is on local and dev environments, the OpenTelemetry standard enables natural integration with cloud observability workflows for deeper insights in production environments. Some final notes This functionality is the product of a collaborative effort between the Rider Execution team and the Dynamic Program Analysis team at JetBrains Research. This launch is the first step in exploring how telemetry analysis can help us build development tools that better adapt to real-world developer workflows. Tell us what you think The OpenTelemetry Plugin for Rider is available now as part of the Early Access Program for Rider 2025.2. Download the latest preview build and give it a try: We’re actively developing this plugin and would love your feedback. Share your thoughts in the comments, or add your input to this ticket. If you encounter any issues, please report them via our issue tracker. Subscribe to a monthly digest curated from the .NET Tools blog: Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/06/RD-social-BlogSocialShare-1280x720-2x.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/dotnet/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/Frame-1321314548.svg\" alt=\"Dotnet logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eEssential productivity kit for .NET and game developers\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/dotnet/category/rider/\"\u003eRider\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eOpenTelemetry Plugin for JetBrains Rider: Observability Inside Your IDE\u003c/h2\u003e                    \n                    \n\u003cp\u003eUnderstanding how your application behaves at runtime has always been a challenge. Traditional debugging and profiling tools can help you understand what’s happening at specific points in time – but getting a complete picture of system behavior, performance patterns, and architectural relationships often means jumping between external tools and dashboards.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe’re building \u003cstrong\u003e\u003ca href=\"https://plugins.jetbrains.com/plugin/27488-opentelemetry/\" target=\"_blank\" data-type=\"link\" data-id=\"https://plugins.jetbrains.com/plugin/27488-opentelemetry/\" rel=\"noreferrer noopener\"\u003ethe OpenTelemetry plugin for JetBrains Rider\u003c/a\u003e \u003c/strong\u003eto bring runtime observability directly into your development environment.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhat is the OpenTelemetry plugin for Rider?\u003c/h2\u003e\n\n\n\n\u003cp\u003eThis plugin is designed for observability during local and dev/test development. It’s not a debugger or profiler – instead, it lets you correlate runtime behavior (logs, metrics, traces) with your code inside Rider.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt helps you answer questions like:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eWhat happened right before this error?\u003c/li\u003e\n\n\n\n\u003cli\u003eWhich services did this endpoint call?\u003c/li\u003e\n\n\n\n\u003cli\u003eWhy is this request slower today than yesterday?\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\n\n\n\n\u003cp\u003eIf you’ve been following our work on observability, you might have already seen OpenTelemetry support in our \u003ca href=\"https://plugins.jetbrains.com/plugin/23289--net-aspire\" target=\"_blank\" rel=\"noopener\"\u003e.NET Aspire plugin\u003c/a\u003e. This new plugin builds on that experience, but it stands on its own. It doesn’t require Aspire or any other specific tooling. Just run your application from Rider, and the plugin gives you access to runtime data inside the IDE. It’s designed to support a wide range of .NET development workflows, whether or not Aspire is part of your stack.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith everything in one place, you can jump straight from a log to the responsible line of code – no external dashboards needed.\u003c/p\u003e\n\n\n\n\u003ch2\u003eImagine this\u003c/h2\u003e\n\n\n\n\u003cp\u003eYou’re implementing a new feature in a cloud-based .NET system: a few services, a PostgreSQL database, and a message queue. Typically, validating its behavior would mean setting up external tools for logs, metrics, and traces, wiring them into your environment, and flipping between dashboards to piece everything together.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith the OpenTelemetry plugin for Rider, you just run the app and watch everything come into focus – logs appear instantly, metrics stream in with zero setup, and an architecture diagram shows exactly how your feature flows through services and dependencies.\u003c/p\u003e\n\n\n\n\u003cp\u003eNo dashboards to set up. No context-switching. Just insight, right where you work.\u003c/p\u003e\n\n\n\n\u003ch2\u003eKey features \u003c/h2\u003e\n\n\n\n\u003ch3\u003eComprehensive log management\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe plugin includes a table-style log viewer with advanced search and filtering capabilities to help you quickly find the information you need. You can filter by log level, text content, and other parameters to focus on what matters most.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe real power lies in its tight integration with the source code. When you find an issue in the logs, you can click through directly to the relevant line of code. This connection between runtime behavior and source makes it more than a typical monitoring tool.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1999\" height=\"762\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/image1.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eThe log viewer with filtering capabilities and different log levels .\u003c/em\u003e\u003cbr/\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/image-24.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eDetailed log view showing timestamps, levels, and messages for different log types\u003c/em\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1999\" height=\"757\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/image4.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eDetailed log information panel showing trace IDs, span IDs, and the “Navigate To Code” functionalit\u003c/em\u003ey.\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eRuntime metrics at your fingertips\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe metrics viewer presents a detailed metric tree showing your application’s runtime performance. Instead of guessing about resource usage or performance bottlenecks, you can see exactly how your application behaves under different conditions.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1999\" height=\"502\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/image3.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eThe metrics viewer displays ASP.NET Core routing performance data with real-time charts\u003c/em\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eAutomatic architecture visualization\u003c/h3\u003e\n\n\n\n\u003cp\u003eMost interestingly, the plugin can automatically generate architecture diagrams from your execution traces. These aren’t static diagrams you have to maintain – they’re built directly from how your system actually behaves at runtime, showing services, endpoints, databases, and message queues as they interact in real scenarios.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1999\" height=\"1222\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/image2-1.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eAutomatically generated service map showing the relationship between API endpoints, internal services, RabbitMQ, and PostgreSQL based on actual runtime traces\u003c/em\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eZero-setup auto-instrumentation\u003c/h3\u003e\n\n\n\n\u003cp\u003eYou don’t need to manually add OpenTelemetry instrumentation to your application. If you start your application using a .NET Project or a launchSettings.json configuration, the plugin will automatically inject the required OpenTelemetry packages  — as long as you’ve enabled the \u003cem\u003eAllow automatic instrumentation\u003c/em\u003e option under \u003cem\u003eSettings/Preferences | Tools | OpenTelemetry\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith that setting enabled, you’ll get runtime observability without modifying your codebase or managing dependencies yourself. \u003c/p\u003e\n\n\n\n\u003ch2\u003eReal-world use cases\u003c/h2\u003e\n\n\n\n\u003ch3\u003eManual testing and debugging\u003c/h3\u003e\n\n\n\n\u003cp\u003eInstead of adding console.WriteLine statements or setting breakpoints everywhere, you can inspect logs, metrics, and traces to understand runtime behavior while developing or testing features. Most importantly, when you identify an issue, you can immediately jump to the relevant source code without leaving your development environment.\u003c/p\u003e\n\n\n\n\u003ch3\u003eTeam onboarding\u003c/h3\u003e\n\n\n\n\u003cp\u003eNew developers joining your team can visualize system architecture and understand runtime context without learning a separate set of tools. Just install Rider and start exploring.\u003c/p\u003e\n\n\n\n\u003ch2\u003eThis is just the beginning\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe’re just getting started with this tooling. Here’s what we’re currently exploring:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eMulti-IDE support\u003c/strong\u003e: OpenTelemetry is language- and vendor-agnostic, which opens the door to supporting additional IDEs like IntelliJ IDEA and PyCharm in the future.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eAI-powered insights\u003c/strong\u003e: We’re exploring how runtime data can be used to explain issues or suggest improvements. Imagine having AI explain error logs in context, adding runtime data to AI Assistant conversations for better suggestions, or even running automated testing agents that can analyze system behavior.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eCloud integration\u003c/strong\u003e: While the current focus is on local and dev environments, the OpenTelemetry standard enables natural integration with cloud observability workflows for deeper insights in production environments.\u003c/p\u003e\n\n\n\n\u003ch2\u003eSome final notes\u003c/h2\u003e\n\n\n\n\u003cp\u003eThis functionality is the product of a collaborative effort between the Rider Execution team and the Dynamic Program Analysis team at JetBrains Research. This launch is the first step in exploring how telemetry analysis can help us build development tools that better adapt to real-world developer workflows.\u003c/p\u003e\n\n\n\n\u003ch2\u003eTell us what you think\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://plugins.jetbrains.com/plugin/27488-opentelemetry/\" data-type=\"link\" data-id=\"https://plugins.jetbrains.com/plugin/27488-opentelemetry/\" target=\"_blank\" rel=\"noopener\"\u003e\u003cstrong\u003eThe OpenTelemetry Plugin for Rider\u003c/strong\u003e\u003c/a\u003e is available now as part of the Early Access Program for Rider 2025.2. Download the latest preview build and give it a try:\u003c/p\u003e\n\n\n    \n\n\n\n\n\n\n\n\u003cp\u003eWe’re actively developing this plugin and would love your feedback. Share your thoughts in the comments, or add your input to \u003ca href=\"https://youtrack.jetbrains.com/issue/RIDER-102188/OpenTelemetry-plugin-for-Rider\" target=\"_blank\" rel=\"noopener\"\u003ethis ticket.\u003c/a\u003e If you encounter any issues, please report them via our issue tracker.\u003c/p\u003e\n                    \n                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to a monthly digest curated from the .NET Tools blog:\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": null,
  "modifiedTime": null
}
