{
  "id": "c17dd14f-26bf-451a-8f6a-722dc904c544",
  "title": "Case Study: Why Kakao Pay Chose Kotlin for Backend Development",
  "link": "https://blog.jetbrains.com/kotlin/2025/07/case-study-why-kakao-pay-chose-kotlin-for-backend-development/",
  "description": "This blog post is a JetBrains translation of the original post by katfun.joy, a backend developer at Kakao Pay. Kakao Pay leverages Kotlin with Spring for backend development across various services, including its insurance offerings. Check out Kakao Pay‚Äôs story to see how Kotlin helps it address the complex requirements of the insurance industry and [‚Ä¶]",
  "author": "Jessie Cho",
  "published": "Thu, 03 Jul 2025 05:50:17 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "best-practices",
    "kotlin",
    "backend",
    "casestudy",
    "server-side"
  ],
  "byline": "Jessie Cho",
  "length": 23871,
  "excerpt": "This blog post is a JetBrains translation of the original post by katfun.joy, a backend developer at Kakao Pay. Kakao Pay leverages Kotlin with Spring for backend development across various services,",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "A concise multiplatform language developed by JetBrains Best Practices KotlinCase Study: Why Kakao Pay Chose Kotlin for Backend Development This blog post is a JetBrains translation of the original post by katfun.joy, a backend developer at Kakao Pay. Kakao Pay leverages Kotlin with Spring for backend development across various services, including its insurance offerings. Check out Kakao Pay‚Äôs story to see how Kotlin helps it address the complex requirements of the insurance industry and enables the reliable development and operation of services. Note: At Kakao Pay, each employees have their own nicknames to represent themselves. They address each other by calling their nickname instead of the actual name. Kuyho Chung, the writer of this post, uses ‚Äòkatfun.joy‚Äô as his nickname. katfun.joy, a backend developer at Kakao Pay, uses Kotlin to develop stable backend services. In this post, he introduces some of Kotlin‚Äôs most impressive features, such as value validation object creation, safe null handling, utility library creation using extension functions, and efficient unit tests, based on direct usage experience. If you are a backend developer interested in developing stable web services, it is recommended to read this. üí° Reviewer‚Äôs One-Line Review yun.cheese: Gain Kotlin tips that can be directly applied to actual service development through the vivid experiences of a developer deeply immersed in Kotlin‚Äôs charm! noah.you: A compelling Kotlin use case to address the complex requirements of insurance! There are many good examples, so take a look! ari.a: Why does Kakao Pay use Kotlin for the backend development of its services? For those curious, we recommend Katfun‚Äôs Kotlin use case! Getting Started Hello. I am Katfun, and I develop and operate services such as insurance comparison recommendations and car management services at Kakao Pay Insurance Market department. At Kakao Pay, we use Kotlin for backend service development, including for our insurance services and various other services. Before joining Kakao Pay, I had no experience with Kotlin, but as I used it, I became captivated by its convenience and various advantages. For example, here are some of Kotlin‚Äôs charms. Using Kotlin allows us to make the services we operate more robust, stable, and efficient. We easily gathered and managed content for specific domains or created libraries exclusively for our services. Writing test codes with clear purposes and targets was also easily done through Kotlin. After joining Kakao Pay and developing and operating several services with Kotlin, I wanted to introduce the charm of Kotlin that I experienced firsthand. Of the many great things about Kotlin, I have focused on four of its key charming aspects. This is a particularly good read for backend developers interested in developing stable web services, like me. Creating objects with validated values at creation When creating a VO(1) representing a value, there are cases where input values need to be transformed or validated. Although validation logic can be separated into a different class, if you have to call the validation logic separately each time, there is a possibility of skipping validation by mistake. Here is an example of concise code that guarantees validation using various Kotlin features. In this VO representing a car number, we use Kotlin‚Äôs value class. @JvmInline value class CarNumber(val input: String) A value class is a wrapper class for representing values in Kotlin. It can only have a single immutable field, and in the JVM environment, the class is unwrapped during compilation and replaced with its internal value. Thanks to this, primitive type values can be handled like objects, and it also solves the overhead problem of using wrapper classes. For more details, please refer to the Project Valhalla content in the References section. Let‚Äôs assume the following rules for license plate numbers (car numbers). Spaces aren‚Äôt allowed The car number format must be one of the following 12Í∞Ä1234 123Í∞Ä1234 ÏÑúÏö∏1Í∞Ä1234 ÏÑúÏö∏12Í∞Ä1234 When creating a CarNumber instance, we want to remove the spaces and implement the following criteria: The region name must be from the given list (Seoul, Gyeonggi, Daejeon, etc.), otherwise, an exception occurs. If there is no region name, the first number must be 2‚Äì3 digits, and the last number must be 4 digits. If there is a region name, the first number must be 1‚Äì2 digits, and the last number must be 4 digits. This was added as validation in the factory method. @JvmInline value class CarNumber(val value: String) { companion object { private val CAR_NUMBER_REGEX = Regex(\"(\\\\d{2,3})([Í∞Ä-Ìû£])(\\\\d{4})\") private val OLD_CAR_NUMBER_REGEX = Regex(\"^([Í∞Ä-Ìû£]{1,2})?(\\\\d{1,2})([Í∞Ä-Ìû£])(\\\\d{4})\\$\") private val LOCATION_NAMES = setOf(\"ÏÑúÏö∏\", \"Î∂ÄÏÇ∞\", \"ÎåÄÍµ¨\", \"Ïù∏Ï≤ú\", \"Í¥ëÏ£º\", \"ÎåÄÏ†Ñ\", \"Ïö∏ÏÇ∞\", \"Í≤ΩÍ∏∞\", \"Í∞ïÏõê\", \"Ï∂©Î∂Å\", \"Ï∂©ÎÇ®\", \"Ï†ÑÎ∂Å\", \"Ï†ÑÎÇ®\", \"Í≤ΩÎ∂Å\", \"Í≤ΩÎÇ®\", \"Ï†úÏ£º\") fun from(carNumber: String): CarNumber { return CarNumber(carNumber.removeSpaces()) // Remove spaces } } init { validateCarNumber(value) } private fun validateCarNumber(number: String) { val oldCarNumberMatch = OLD_CAR_NUMBER_REGEX.matchEntire(number) if (oldCarNumberMatch != null) { val (location, _, _) = oldCarNumberMatch.destructured require(location in LOCATION_NAMES) { \"Unknown registration region.\" } // Exception occurs if the region name of the old car number is not in the list } else { require(CAR_NUMBER_REGEX.matches(number)) { \"Please check the car number format.\" } // Exception occurs if it does not match the car number forma } } } Although the code may seem a bit complex, the steps are as follows. Call the CarNumber.from() factory method to remove hyphens and spaces. Invoke the logic during instance creation using the init { } block. Verify whether it matches one of the two regular expressions (new car number, old car number). If it is an old car number, check whether the region name is in the list. The regular expressions (regex) and region names used for validation are written in the companion object and used as a singleton. Does writing the code like this solve all the problems? Unfortunately, there is still the issue of the constructor being exposed. val carNumber = CarNumber(\"123 Í∞Ä 4567\") // Exception occurs because spaces are not removed. If the constructor is called directly, the space removal process created in the factory method cannot be applied. Fortunately, it is possible to prevent the constructor from being called directly. You can add the private constructor access modifier to it. value class CarNumber private constructor(val value: String) { By adding private constructor, you can enforce the creation of CarNumber instances only through the factory method. However, this implementation may be somewhat unfriendly to CarNumber users. Users may attempt to create an instance using the constructor like CarNumber(\"123 Í∞Ä 4567\"), but until they write the code, they won‚Äôt know that the constructor is blocked with private and that they need to use the factory method like CarNumber.from(\"123 Í∞Ä 4567\") instead. This can be resolved by overloading Kotlin‚Äôs invoke operator. Kotlin provides guidance that ‚Äúfunction-type values can be called using the invoke operator‚Äù. @JvmInline value class CarNumber private constructor(val value: String) { companion object { // ... @JsonCreator fun from(carNumber: String): CarNumber { return CarNumber(carNumber.removeSpacesAndHyphens()) } operator fun invoke(carNumber: String): CarNumber = from(carNumber) } } // Usage example val carNumber = CarNumber(\"123 Í∞Ä 4567\") // Actually calls from instead of the constructor. This allows users to create CarNumber instances as if they are directly calling the constructor, but internally, it hides the call to the factory method from. In some cases, the factory method from can also be hidden with private. This makes it so users no longer need to worry about whether to use the constructor or the factory method when creating a CarNumber instance. At the same time, it also prevents the creation of CarNumber instances with broken consistency. Finally, when using Jackson for serialization and deserialization, add the @JsonCreator annotation to the from factory method to use it. This completes a VO that satisfies all intended conditions. Below is the final completed CarNumber class. @JvmInline value class CarNumber private constructor(val value: String) { companion object { private val CAR_NUMBER_REGEX = Regex(\"(\\\\d{2,3})([Í∞Ä-Ìû£])(\\\\d{4})\") private val OLD_CAR_NUMBER_REGEX = Regex(\"^([Í∞Ä-Ìû£]{1,2})?(\\\\d{1,2})([Í∞Ä-Ìû£])(\\\\d{4})\\$\") private val LOCATION_NAMES = setOf(\"ÏÑúÏö∏\", \"Î∂ÄÏÇ∞\", \"ÎåÄÍµ¨\", \"Ïù∏Ï≤ú\", \"Í¥ëÏ£º\", \"ÎåÄÏ†Ñ\", \"Ïö∏ÏÇ∞\", \"Í≤ΩÍ∏∞\", \"Í∞ïÏõê\", \"Ï∂©Î∂Å\", \"Ï∂©ÎÇ®\", \"Ï†ÑÎ∂Å\", \"Ï†ÑÎÇ®\", \"Í≤ΩÎ∂Å\", \"Í≤ΩÎÇ®\", \"Ï†úÏ£º\") @JsonCreator fun from(carNumber: String): CarNumber { return CarNumber(carNumber.removeSpacesAndHyphens()) } operator fun invoke(carNumber: String): CarNumber = from(carNumber) } init { validateCarNumber(value) } private fun validateCarNumber(number: String) { val oldCarNumberMatch = OLD_CAR_NUMBER_REGEX.matchEntire(number) if (oldCarNumberMatch != null) { val (location, _, _) = oldCarNumberMatch.destructured require(location in LOCATION_NAMES) { \"Unknown registration region.\" } } else { require(CAR_NUMBER_REGEX.matches(number)) { \"Please check the car number format.\" } } } } When writing code like the example above in Kotlin, you can create VOs for various values and perform validation and transformation before instance creation. Writing the code this way allows you to delegate all roles and responsibilities related to car numbers to the VO. If policies related to car numbers change, you only need to check the CarNumber class. This naturally prevents unintended values from being used as car numbers and helps create stable services. Example Let‚Äôs take a closer look with a simple example. There is an API that receives input from users as shown below. If you declare the carNumber field in the request class as a CarNumber VO instead of a string, an exception will be immediately raised when the API is called with a car number that does not meet the conditions. There is no need to call separate validation logic, and if a CarNumber instance is successfully created, it guarantees that the car number value is valid. @RestController class CarController { @PostMapping(\"/car\") fun carInformation(@RequestBody request: CarInformationRequest) { // ... } } data class CarInformationRequest( val carNumber: CarNumber ) Ensuring null safety Kotlin provides various ways to handle null safely. Here‚Äôs an example of one that helps with writing and understanding logic through immutability and smart casting(2) There is a retryLogic method that resends an existing request. It performs the following actions: Explore the retryUseCase that matches the received category code.‚Äì Throw an exception if not found. Send a retry request using the found retryUseCase. The code is as follows: fun retryLogic( categoryCode: CategoryCode, transactionId: String, request: RetryRequest ) { val retryUseCase: UseCase? = activeUseCases().firstOrNull { it.type == categoryCode } requireNotNull(retryUseCase) { \"The retry request is currently unavailable.\" } // Separate business logic return retryUseCase.getPrice(transactionId, request) } val retryUseCase is a value of type UseCase?. This indicates that the value could either be a UseCase or null. In Kotlin, unless you explicitly specify that the value‚Äôs type is nullable by adding a ? after it, the value cannot hold null by default. Next, perform a null check on the received value. The commonly used method is to check for nullability using if. if (retryUseCase == null) throw IllegalArgumentException(\"The retry request is currently unavailable.\") In Kotlin, you can write the exact same functionality using a contract called requireNotNull. Even after checking for nullability, the problem is not completely resolved. If the value changes in the middle after the null check, then even if you previously checked for null on retryUseCase, you cannot be certain that it is still not null. In the above code, this is represented as the ‚Äòseparate business logic‚Äô section. The reason Kotlin is particularly strong in this area is because of Kotlin‚Äôs immutability. Values are declared using either val or var, and values declared with val are immutable. In other words, once a value is assigned, it does not change. This also applies when checking for null; once a value is confirmed to be not null, it is guaranteed to remain not null. In the example above, after requireNotNull(retryUseCase), the value is guaranteed not to be null. This is also confirmed from a Kotlin language perspective through smart casting. Through smart casting, the Kotlin compiler treats the type of retryUseCase as UseCase rather than UseCase? after requireNotNull(retryUseCase). The green-highlighted part in the image above represents this. Thanks to this, when writing or debugging code, you can confirm that a value that could be null is not null and proceed with the logic with confidence. This is, of course, a great help in the stable operation of services. Creating a utility library using extension functions Several utility codes are commonly used in the development of insurance services. In particular, there are many cases where something is manipulated for primitive type fields or strings. These were gathered to create a library called insurance-common. Kotlin‚Äôs extension functions and object declarations can be used in the creation of such a library. Kotlin‚Äôs extension functions allow you to extend methods without separate design patterns or the inheritance of specific classes. Object declarations are used to contain content independent of the state of a specific instance. At the language level, they are declared as singletons, which is good for preventing the unnecessary creation of the same content multiple times. For example, a method called maskingName is written to mask the corresponding code when a specific pattern is found in strings. private val maskingNameRegex = Regex(\"(?i)Name=[^,)]++[,)]\") /** * Masks numbers surrounded by \"Number=\" and \",\" or \")\" in a string, except for the first digit */ fun maskingName(input: String): String { return input.replace(maskingNameRegex) { \"${it.value.substring(0, 6)}*${it.value.last()}\" } } // Usage example val maskedValue = maskingName(userName) If the above code is refactored using Kotlin‚Äôs extension functions, it can be modified as follows. fun String.maskingName() = this.replace(maskingNameRegex) { \"${it.value.substring(0, 6)}*${it.value.last()}\" } // Usage example val maskedValue = userName.maskingName() The masking method was extended to the string class. This method is unrelated to the state of a specific instance. In other words, declaring it as a singleton(3)¬†and reusing it is advantageous for resource management. It can be used as a singleton by using a Kotlin object declaration. object StringUtils { private val maskingNameRegex = Regex(\"(?i)Name=[^,)]++[,)]\") /** * Masks strings surrounded by \"Number=\" and \",\" or \")\", except for the first character */ fun String.maskingName() = this.replace(maskingNameRegex) { \"${it.value.substring(0, 6)}*${it.value.last()}\" } } Examples of its usage can be confirmed through unit tests. @DisplayName(\"Masks strings surrounded by Number= and , or ) except for the first character\") @Test fun maskingName() { // given val name = \"Kim Chun-sik\" val text = \"userName=$name, result=\\\"success\\\"\" val lowerText = \"name=$name, result=\\\"success\\\"\" // when val result = text.maskingName() val lowerResult = lowerText.maskingName() // then val expectedMaskedResult = \"Kim*\" assertThat(result).isEqualTo(\"userName=$expectedMaskedResult, result=\\\"success\\\"\") assertThat(lowerResult).isEqualTo(\"name=$expectedMaskedResult, result=\\\"success\\\"\") } In this way, functions used throughout the insurance service are being turned into libraries. This has reduced duplicate code across multiple ongoing projects and allowed their use without any performance degradation or other drawbacks. All of this is thanks to Kotlin‚Äôs extension functions and object declarations. Code managed this way is easy to read and maintain, greatly aiding in service operation. Simple and efficient unit testing using data classes When writing unit tests, data classes can be useful for setting up situations for testing. A data class in Kotlin is, as the name suggests, a class for representing data. Unlike regular classes, equals() and hashCode() are redefined, and other methods like copy() are automatically generated. Using data classes is useful when writing classes that represent data, such as DTOs(4). This is an example of a DTO that needs to be tested. data class UserInformation( val name: String, val age: Int, val birthDate: LocalDate, val address: String, val gender: Gender, val isDisplay: Boolean ) { enum class Gender { MALE, FEMALE; } init { require(age \u003e= 18) } } The goal is to test whether age validation works. If the age is 18 or older, no exception should be thrown, and if it is under 18, an IllegalArgumentException should be thrown. Here‚Äôs one way to write the test: class WhateverTest() { @Test fun `Throws IllegalArgumentException if age is under 18`() { assertThrows { val userInformation = UserInformation( name = \"Chung Katfun\", age = 17, birthDate = LocalDate.of(2022, 12, 19), address = \"Kakao Pangyo Agit\", gender = UserInformation.Gender.MALE, isDisplay = true ) } } @Test fun `Does not throw exception if age is 18 or older`() { assertDoesNotThrow { val userInformation = UserInformation( name = \"Chung Katfun\", age = 18, birthDate = LocalDate.of(2022, 12, 19), address = \"Kakao Pangyo Agit\", gender = UserInformation.Gender.MALE, isDisplay = true ) } } } Do you see the problem? The target of the test is unclear.Unnecessary code is repeated. It is difficult to determine from the test code above which values in UserInformation contribute to the exception. Adding comments could partially resolve this, but if the DTO has dozens of fields, it would be hard to identify which fields have comments at a glance. Additionally, to create a UserInformation instance, appropriate values must be assigned to fields other than age. To address this, the copy() function of the data class can be used. copy() has the following characteristics: A completely identical data class instance is created. When compared with the original instance using equals(), they are considered equal.When calling copy(), you can specify values for parameters. In this case, only the specified values of the corresponding parameters are copied. Returning to the code above, let‚Äôs separate the common parts and revise it to make the test target clearer. class WhateverTest() { @Test fun `Throws IllegalArgumentException if age is under 18`() { val invalidAge = 17 assertThrows { val userInformation = successUserInformation.copy(age = invalidAge) } } @Test fun `Does not throw exception if age is 18 or older`() { val validAge = 18 assertDoesNotThrow { val userInformation = successUserInformation.copy(age = validAge) } } private val successUserInformation = UserInformation( name = \"Chung Katfun\", age = 28, birthDate = LocalDate.of(2022, 12, 19), address = \"Kakao Pangyo Agit\", gender = UserInformation.Gender.MALE, isDisplay = true ) } Here are the two versions of the code arranged side by side for comparison. Do you notice the difference? Using copy(): Reduced repeated code. Clearly highlighted the target affecting the test. This lowers the barrier to writing tests and improves their readability. As a result, tests can better serve as documentation, and they can be used to write stable services. This is also valid when writing tests in a BDD(5) style, such as given-when-then or arrange-act-assert. Conclusion As someone responsible for the server side of our system, my priority is building services that are stable, readable, and scalable. Since I started using Kotlin two years ago at Kakao Pay, I‚Äôve been able to meet these goals step by step while developing a variety of applications. I wrote this blog post to share my experience in the hope that it helps others build and operate reliable backend systems. Whether you‚Äôre exploring Kotlin or aiming to create more stable backends, I hope you find it useful. References [Project Valhalla: Value Class] [Effective Kotlin Item 48: Consider Using Object Declarations] [Kotlin Operator Overloading ‚Äì invoke operator] [Kotlin Smart Casts] Value Object ‚Äì an object that represents a specific value (entity). This refers to a key feature of Kotlin where the compiler tracks type checks and explicit casting for immutable values and adds implicit casting when necessary. Singleton Pattern ‚Äì a design pattern where only one instance of a specific class is created and used globally. Data Transfer Object ‚Äì an object used for transferring data. Behaviour Driven Development ‚Äì Describing the behavior of code using domain language when writing tests. About Kuyho Chung (katfun.joy) A server developer at Kakao Pay, I really enjoy solving difficulties and inconveniences through technology. I strive to write each line of code with a solid rationale. Subscribe to Kotlin Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/06/Social-Share-1280x720-3.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/kotlin/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/Kotlin-5.svg\" alt=\"Kotlin logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eA concise multiplatform language developed by JetBrains\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/kotlin/category/best-practices/\"\u003eBest Practices\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/kotlin/category/kotlin/\"\u003eKotlin\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eCase Study: Why Kakao Pay Chose Kotlin for Backend Development\u003c/h2\u003e                    \n                    \n\u003cp\u003e\u003cem\u003eThis blog post is a JetBrains translation of \u003ca href=\"https://tech.kakaopay.com/post/katfun-joy-kotlin/\" target=\"_blank\" rel=\"noopener\"\u003ethe original post by katfun.joy\u003c/a\u003e, a backend developer at Kakao Pay. Kakao Pay leverages Kotlin with Spring for backend development across various services, including its insurance offerings. Check out Kakao Pay‚Äôs story to see how Kotlin helps it address the complex requirements of the insurance industry and enables the reliable development and operation of services.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eNote: At Kakao Pay, each employees have their own nicknames to represent themselves. They address each other by calling their nickname instead of the actual name. Kuyho Chung, the writer of this post, uses ‚Äòkatfun.joy‚Äô as his nickname.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1280\" height=\"720\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/Blog-Featured-1280x720-5.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003ekatfun.joy, a backend developer at Kakao Pay, uses Kotlin to develop stable backend services. In this post, he introduces some of Kotlin‚Äôs most impressive features, such as value validation object creation, safe null handling, utility library creation using extension functions, and efficient unit tests, based on direct usage experience. If you are a backend developer interested in developing stable web services, it is recommended to read this.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eüí°\u003c/span\u003e\u003cb\u003e Reviewer‚Äôs One-Line Review\u003c/b\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cb\u003eyun.cheese\u003c/b\u003e\u003cspan\u003e: Gain Kotlin tips that can be directly applied to actual service development through the vivid experiences of a developer deeply immersed in Kotlin‚Äôs charm!\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cb\u003enoah.you:\u003c/b\u003e\u003cspan\u003e A compelling Kotlin use case to address the complex requirements of insurance! There are many good examples, so take a look!\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cb\u003eari.a\u003c/b\u003e\u003cspan\u003e: Why does Kakao Pay use Kotlin for the backend development of its services? For those curious, we recommend Katfun‚Äôs Kotlin use case!\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cspan\u003eGetting Started\u003c/span\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eHello. I am Katfun, and I develop and operate services such as insurance comparison recommendations and car management services at Kakao Pay Insurance Market department.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eAt Kakao Pay, we use Kotlin for backend service development, including for our insurance services and various other services.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eBefore joining Kakao Pay, I had no experience with Kotlin, but as I used it, I became captivated by its convenience and various advantages. For example, here are some of Kotlin‚Äôs charms.\u003c/span\u003e\u003ci\u003e\u003c/i\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ci\u003e\u003cspan\u003eUsing Kotlin allows us to make the services we operate more robust, stable, and efficient.\u003c/span\u003e\u003c/i\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cem\u003e\u003cspan\u003eWe easily gathered and managed content for specific domains or created libraries exclusively for our services.\u003c/span\u003e\u003c/em\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cem\u003e\u003cspan\u003eWriting test codes with clear purposes and targets was also easily done through Kotlin.\u003c/span\u003e\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eAfter joining Kakao Pay and developing and operating several services with Kotlin, I wanted to introduce the charm of Kotlin that I experienced firsthand. Of the many great things about Kotlin, I have focused on four of its key charming aspects. This is a particularly good read for backend developers interested in developing stable web services, like me.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cspan\u003eCreating objects with validated values at creation\u003c/span\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eWhen creating a \u003c/span\u003eVO\u003csup\u003e\u003ca href=\"#footnote-1\"\u003e(1)\u003c/a\u003e\u003c/sup\u003e\u003cspan\u003e representing a value, there are cases where input values need to be transformed or validated. Although validation logic can be separated into a different class, if you have to call the validation logic separately each time, there is a possibility of skipping validation by mistake. Here is an example of concise code that guarantees validation using various Kotlin features.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eIn this VO representing a car number, we use Kotlin‚Äôs \u003ccode\u003evalue class\u003c/code\u003e.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@JvmInline\nvalue class CarNumber(val input: String)\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eA \u003ccode\u003evalue class\u003c/code\u003e is a wrapper class for representing values in Kotlin. It can only have a single immutable field, and in the JVM environment, the class is unwrapped during compilation and replaced with its internal value. Thanks to this, primitive type values can be handled like objects, \u003c/span\u003e\u003cspan\u003eand it also solves the overhead problem of using wrapper classes. For more details, please refer to the Project Valhalla content in the References section.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eLet‚Äôs assume the following rules for license plate numbers (car numbers).\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cspan\u003eSpaces aren‚Äôt allowed\u003c/span\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cspan\u003eThe car number format must be one of the following\u003c/span\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cspan\u003e12Í∞Ä1234\u003c/span\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e123Í∞Ä1234\u003c/li\u003e\n\n\n\n\u003cli\u003eÏÑúÏö∏1Í∞Ä1234\u003c/li\u003e\n\n\n\n\u003cli\u003eÏÑúÏö∏12Í∞Ä1234\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eWhen creating a \u003ccode\u003eCarNumber\u003c/code\u003e instance, we want to remove the spaces and implement the following\u003c/span\u003e\u003cspan\u003e criteria:\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cspan\u003eThe region name must be from the given list (Seoul, Gyeonggi, Daejeon, etc.), otherwise, an exception occurs.\u003c/span\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eIf there is no region name, the first number must be 2‚Äì3 digits, and the last number must be 4 digits.\u003c/li\u003e\n\n\n\n\u003cli\u003eIf there is a region name, the first number must be 1‚Äì2 digits, and the last number must be 4 digits.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eThis was added as validation in the factory method.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@JvmInline\nvalue class CarNumber(val value: String) {\n    companion object {\n        private val CAR_NUMBER_REGEX = Regex(\u0026#34;(\\\\d{2,3})([Í∞Ä-Ìû£])(\\\\d{4})\u0026#34;)\n        private val OLD_CAR_NUMBER_REGEX = Regex(\u0026#34;^([Í∞Ä-Ìû£]{1,2})?(\\\\d{1,2})([Í∞Ä-Ìû£])(\\\\d{4})\\$\u0026#34;)\n        private val LOCATION_NAMES = setOf(\u0026#34;ÏÑúÏö∏\u0026#34;, \u0026#34;Î∂ÄÏÇ∞\u0026#34;, \u0026#34;ÎåÄÍµ¨\u0026#34;, \u0026#34;Ïù∏Ï≤ú\u0026#34;, \u0026#34;Í¥ëÏ£º\u0026#34;, \u0026#34;ÎåÄÏ†Ñ\u0026#34;, \u0026#34;Ïö∏ÏÇ∞\u0026#34;, \u0026#34;Í≤ΩÍ∏∞\u0026#34;, \u0026#34;Í∞ïÏõê\u0026#34;, \u0026#34;Ï∂©Î∂Å\u0026#34;, \u0026#34;Ï∂©ÎÇ®\u0026#34;, \u0026#34;Ï†ÑÎ∂Å\u0026#34;, \u0026#34;Ï†ÑÎÇ®\u0026#34;, \u0026#34;Í≤ΩÎ∂Å\u0026#34;, \u0026#34;Í≤ΩÎÇ®\u0026#34;, \u0026#34;Ï†úÏ£º\u0026#34;)\n\n        fun from(carNumber: String): CarNumber {\n            return CarNumber(carNumber.removeSpaces())\t// Remove spaces\n        }\n    }\n\n    init {\n        validateCarNumber(value)\n    }\n\n    private fun validateCarNumber(number: String) {\n        val oldCarNumberMatch = OLD_CAR_NUMBER_REGEX.matchEntire(number)\n        if (oldCarNumberMatch != null) {\n            val (location, _, _) = oldCarNumberMatch.destructured\n            require(location in LOCATION_NAMES) { \u0026#34;Unknown registration region.\u0026#34; }\t// Exception occurs if the region name of the old car number is not in the list\n        } else {\n            require(CAR_NUMBER_REGEX.matches(number)) { \u0026#34;Please check the car number format.\u0026#34; }\t// Exception occurs if it does not match the car number forma\n        }\n    }\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eAlthough the code may seem a bit complex, the steps are as follows.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCall the \u003ccode\u003eCarNumber.from()\u003c/code\u003e factory method to remove hyphens and spaces.\u003c/li\u003e\n\n\n\n\u003cli\u003eInvoke the logic during instance creation using the \u003ccode\u003einit { }\u003c/code\u003e block.\n\u003cul\u003e\n\u003cli\u003eVerify whether it matches one of the two regular expressions (new car number, old car number).\u003c/li\u003e\n\n\n\n\u003cli\u003eIf it is an old car number, check whether the region name is in the list.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe regular expressions (regex) and region names used for validation are written in the companion object and used as a singleton.\u003c/p\u003e\n\n\n\n\u003cp\u003eDoes writing the code like this solve all the problems? Unfortunately, there is still the issue of the constructor being exposed.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eval carNumber = CarNumber(\u0026#34;123 Í∞Ä 4567\u0026#34;) // Exception occurs because spaces are not removed.\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf the constructor is called directly, the space removal process created in the factory method cannot be applied. Fortunately, it is possible to prevent the constructor from being called directly. You can add the \u003ccode\u003eprivate constructor\u003c/code\u003e access modifier to it.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003evalue class CarNumber private constructor(val value: String) {\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eBy adding \u003ccode\u003eprivate constructor\u003c/code\u003e, you can enforce the creation of \u003ccode\u003eCarNumber\u003c/code\u003e instances only through the factory method. However, this implementation may be somewhat unfriendly to \u003ccode\u003eCarNumber\u003c/code\u003e users. Users may attempt to create an instance using the constructor like \u003ccode\u003eCarNumber(\u0026#34;123 Í∞Ä 4567\u0026#34;)\u003c/code\u003e, but until they write the code, they won‚Äôt know that the constructor is blocked with \u003ccode\u003eprivate\u003c/code\u003e and that they need to use the factory method like \u003ccode\u003eCarNumber.from(\u0026#34;123 Í∞Ä 4567\u0026#34;)\u003c/code\u003e instead.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"790\" height=\"146\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/kakaopay_screenshot_01.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThis can be resolved by overloading Kotlin‚Äôs \u003ccode\u003einvoke\u003c/code\u003e operator. Kotlin provides guidance that ‚Äúfunction-type values can be called using the invoke operator‚Äù.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@JvmInline\nvalue class CarNumber private constructor(val value: String) {\n    companion object {\n        // ...\n\n        @JsonCreator\n        fun from(carNumber: String): CarNumber {\n            return CarNumber(carNumber.removeSpacesAndHyphens())\n        }\n\n        operator fun invoke(carNumber: String): CarNumber = from(carNumber)\n    }\n}\n\n// Usage example\nval carNumber = CarNumber(\u0026#34;123 Í∞Ä 4567\u0026#34;)\t// Actually calls from instead of the constructor.\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis allows users to create \u003ccode\u003eCarNumber\u003c/code\u003e instances as if they are directly calling the constructor, but internally, it hides the call to the factory method \u003ccode\u003efrom\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn some cases, the factory method \u003ccode\u003efrom\u003c/code\u003e can also be hidden with \u003ccode\u003eprivate\u003c/code\u003e. This makes it so users no longer need to worry about whether to use the constructor or the factory method when creating a \u003ccode\u003eCarNumber\u003c/code\u003e instance. At the same time, it also prevents the creation of \u003ccode\u003eCarNumber\u003c/code\u003e instances with broken consistency.\u003c/p\u003e\n\n\n\n\u003cp\u003eFinally, when using Jackson for serialization and deserialization, add the \u003ccode\u003e@JsonCreator\u003c/code\u003e annotation to the \u003ccode\u003efrom\u003c/code\u003e factory method to use it. This completes a VO that satisfies all intended conditions. Below is the final completed \u003ccode\u003eCarNumber\u003c/code\u003e class.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@JvmInline\nvalue class CarNumber private constructor(val value: String) {\n    companion object {\n        private val CAR_NUMBER_REGEX = Regex(\u0026#34;(\\\\d{2,3})([Í∞Ä-Ìû£])(\\\\d{4})\u0026#34;)\n        private val OLD_CAR_NUMBER_REGEX = Regex(\u0026#34;^([Í∞Ä-Ìû£]{1,2})?(\\\\d{1,2})([Í∞Ä-Ìû£])(\\\\d{4})\\$\u0026#34;)\n        private val LOCATION_NAMES =\n            setOf(\u0026#34;ÏÑúÏö∏\u0026#34;, \u0026#34;Î∂ÄÏÇ∞\u0026#34;, \u0026#34;ÎåÄÍµ¨\u0026#34;, \u0026#34;Ïù∏Ï≤ú\u0026#34;, \u0026#34;Í¥ëÏ£º\u0026#34;, \u0026#34;ÎåÄÏ†Ñ\u0026#34;, \u0026#34;Ïö∏ÏÇ∞\u0026#34;, \u0026#34;Í≤ΩÍ∏∞\u0026#34;, \u0026#34;Í∞ïÏõê\u0026#34;, \u0026#34;Ï∂©Î∂Å\u0026#34;, \u0026#34;Ï∂©ÎÇ®\u0026#34;, \u0026#34;Ï†ÑÎ∂Å\u0026#34;, \u0026#34;Ï†ÑÎÇ®\u0026#34;, \u0026#34;Í≤ΩÎ∂Å\u0026#34;, \u0026#34;Í≤ΩÎÇ®\u0026#34;, \u0026#34;Ï†úÏ£º\u0026#34;)\n\n        @JsonCreator\n        fun from(carNumber: String): CarNumber {\n            return CarNumber(carNumber.removeSpacesAndHyphens())\n        }\n\n        operator fun invoke(carNumber: String): CarNumber = from(carNumber)\n    }\n\n    init {\n        validateCarNumber(value)\n    }\n\n    private fun validateCarNumber(number: String) {\n        val oldCarNumberMatch = OLD_CAR_NUMBER_REGEX.matchEntire(number)\n        if (oldCarNumberMatch != null) {\n            val (location, _, _) = oldCarNumberMatch.destructured\n            require(location in LOCATION_NAMES) { \u0026#34;Unknown registration region.\u0026#34; }\n        } else {\n            require(CAR_NUMBER_REGEX.matches(number)) { \u0026#34;Please check the car number format.\u0026#34; }\n        }\n    }\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen writing code like the example above in Kotlin, you can create VOs for various values and perform validation and transformation before instance creation. Writing the code this way allows you to delegate all roles and responsibilities related to car numbers to the VO. If policies related to car numbers change, you only need to check the \u003ccode\u003eCarNumber\u003c/code\u003e class. This naturally prevents unintended values from being used as car numbers and helps create stable services.\u003c/p\u003e\n\n\n\n\u003ch3\u003eExample\u003c/h3\u003e\n\n\n\n\u003cp\u003eLet‚Äôs take a closer look with a simple example. There is an API that receives input from users as shown below. If you declare the \u003ccode\u003ecarNumber\u003c/code\u003e field in the \u003ccode\u003erequest\u003c/code\u003e class as a \u003ccode\u003eCarNumber\u003c/code\u003e VO instead of a string, an exception will be immediately raised when the API is called with a car number that does not meet the conditions. There is no need to call separate validation logic, and if a \u003ccode\u003eCarNumber\u003c/code\u003e instance is successfully created, it guarantees that the car number value is valid.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@RestController\nclass CarController {\n    @PostMapping(\u0026#34;/car\u0026#34;)\n    fun carInformation(@RequestBody request: CarInformationRequest) {\n        // ...\n    }\n}\n\ndata class CarInformationRequest(\n    val carNumber: CarNumber\n)\n\u003c/pre\u003e\n\n\n\n\u003ch2\u003eEnsuring null safety\u003c/h2\u003e\n\n\n\n\u003cp\u003eKotlin provides various ways to handle \u003ccode\u003enull\u003c/code\u003e safely. Here‚Äôs an example of one that helps with writing and understanding logic through immutability and smart casting\u003csup\u003e\u003ca href=\"#footnote-2\"\u003e(2)\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eThere is a \u003ccode\u003eretryLogic\u003c/code\u003e method that resends an existing request. It performs the following actions:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eExplore the \u003ccode\u003eretryUseCase\u003c/code\u003e that matches the received category code.\u003cbr/\u003e‚Äì Throw an exception if not found.\u003c/li\u003e\n\n\n\n\u003cli\u003eSend a retry request using the found \u003ccode\u003eretryUseCase\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eThe code is as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun retryLogic(\n    categoryCode: CategoryCode,\n    transactionId: String,\n    request: RetryRequest\n) {\n    val retryUseCase: UseCase? = activeUseCases().firstOrNull { it.type == categoryCode }\n    requireNotNull(retryUseCase) { \u0026#34;The retry request is currently unavailable.\u0026#34; }\n\n    // Separate business logic\n\n    return retryUseCase.getPrice(transactionId, request)\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003eval retryUseCase\u003c/code\u003e is a value of type \u003ccode\u003eUseCase?\u003c/code\u003e. This indicates that the value could either be a \u003ccode\u003eUseCase\u003c/code\u003e or \u003ccode\u003enull\u003c/code\u003e. In Kotlin, unless you explicitly specify that the value‚Äôs type is nullable by adding a \u003ccode\u003e?\u003c/code\u003e after it, the value cannot hold \u003ccode\u003enull\u003c/code\u003e by default.\u003c/p\u003e\n\n\n\n\u003cp\u003eNext, perform a null check on the received value. The commonly used method is to check for nullability using \u003ccode\u003eif\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eif (retryUseCase == null) throw IllegalArgumentException(\u0026#34;The retry request is currently unavailable.\u0026#34;)\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn Kotlin, you can write the exact same functionality using a contract called \u003ccode\u003erequireNotNull\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eEven after checking for nullability, the problem is not completely resolved. If the value changes in the middle after the null check, then even if you previously checked for null on \u003ccode\u003eretryUseCase\u003c/code\u003e, you cannot be certain that it is still not null. In the above code, this is represented as the ‚Äòseparate business logic‚Äô section.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe reason Kotlin is particularly strong in this area is because of Kotlin‚Äôs \u003cstrong\u003eimmutability\u003c/strong\u003e. Values are declared using either \u003ccode\u003eval\u003c/code\u003e or \u003ccode\u003evar\u003c/code\u003e, and values declared with \u003ccode\u003eval\u003c/code\u003e are immutable. In other words, once a value is assigned, it does not change. This also applies when checking for \u003ccode\u003enull\u003c/code\u003e; once a value is confirmed to be not null, it is guaranteed to remain not null. In the example above, after \u003ccode\u003erequireNotNull(retryUseCase)\u003c/code\u003e, the value is guaranteed not to be \u003ccode\u003enull\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is also confirmed from a Kotlin language perspective through smart casting.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"790\" height=\"411\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/kakaopay_screenshot_02.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThrough smart casting, the Kotlin compiler treats the type of \u003ccode\u003eretryUseCase\u003c/code\u003e as \u003ccode\u003eUseCase\u003c/code\u003e rather than \u003ccode\u003eUseCase?\u003c/code\u003e after \u003ccode\u003erequireNotNull(retryUseCase)\u003c/code\u003e. The green-highlighted part in the image above represents this. Thanks to this, when writing or debugging code, you can confirm that a value that could be null is not null and proceed with the logic with confidence. This is, of course, a great help in the stable operation of services.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cspan\u003eCreating a utility library using extension functions\u003c/span\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eSeveral utility codes are commonly used in the development of insurance services. In particular, there are many cases where something is manipulated for primitive type fields or strings. These were gathered to create a library called \u003ccode\u003einsurance-common\u003c/code\u003e.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eKotlin‚Äôs extension functions and object declarations can be used in the creation of such a library. Kotlin‚Äôs extension functions allow you to extend methods without separate design patterns or the inheritance of specific classes. Object declarations are used to contain content independent of the state of a specific instance. At the language level, they are declared as singletons, which is good for preventing the unnecessary creation of the same content multiple times.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eFor example, a method called \u003ccode\u003emaskingName\u003c/code\u003e is written to mask the corresponding code when a specific pattern is found in strings.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eprivate val maskingNameRegex = Regex(\u0026#34;(?i)Name=[^,)]++[,)]\u0026#34;)\n\n/**\n* Masks numbers surrounded by \u0026#34;Number=\u0026#34; and \u0026#34;,\u0026#34; or \u0026#34;)\u0026#34; in a string, except for the first digit\n*/\nfun maskingName(input: String): String {\n    return input.replace(maskingNameRegex) { \u0026#34;${it.value.substring(0, 6)}*${it.value.last()}\u0026#34; }\n}\n\n// Usage example\nval maskedValue = maskingName(userName)\n\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eIf the above code is refactored using Kotlin‚Äôs extension functions, it can be modified as follows.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efun String.maskingName() = this.replace(maskingNameRegex) { \u0026#34;${it.value.substring(0, 6)}*${it.value.last()}\u0026#34; }\n\n// Usage example\nval maskedValue = userName.maskingName()\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eThe masking method was extended to the string class. This method is unrelated to the state of a specific instance. In other words, declaring it as a singleton\u003csup\u003e\u003ca href=\"#footnote-3\"\u003e(3)\u003c/a\u003e\u003c/sup\u003e¬†and reusing it is advantageous for resource management. It can be used as a singleton by using a Kotlin object declaration.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eobject StringUtils {\n    private val maskingNameRegex = Regex(\u0026#34;(?i)Name=[^,)]++[,)]\u0026#34;)\n\n    /**\n     * Masks strings surrounded by \u0026#34;Number=\u0026#34; and \u0026#34;,\u0026#34; or \u0026#34;)\u0026#34;, except for the first character\n     */\n    fun String.maskingName() = this.replace(maskingNameRegex) { \u0026#34;${it.value.substring(0, 6)}*${it.value.last()}\u0026#34; }\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eExamples of its usage can be confirmed through unit tests.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@DisplayName(\u0026#34;Masks strings surrounded by Number= and , or ) except for the first character\u0026#34;)\n@Test\nfun maskingName() {\n    // given\n    val name = \u0026#34;Kim Chun-sik\u0026#34;\n    val text = \u0026#34;userName=$name, result=\\\u0026#34;success\\\u0026#34;\u0026#34;\n    val lowerText = \u0026#34;name=$name, result=\\\u0026#34;success\\\u0026#34;\u0026#34;\n\n    // when\n    val result = text.maskingName()\n    val lowerResult = lowerText.maskingName()\n\n    // then\n    val expectedMaskedResult = \u0026#34;Kim*\u0026#34;\n\n    assertThat(result).isEqualTo(\u0026#34;userName=$expectedMaskedResult, result=\\\u0026#34;success\\\u0026#34;\u0026#34;)\n    assertThat(lowerResult).isEqualTo(\u0026#34;name=$expectedMaskedResult, result=\\\u0026#34;success\\\u0026#34;\u0026#34;)\n    }\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn this way, functions used throughout the insurance service are being turned into libraries. This has reduced duplicate code across multiple ongoing projects and allowed their use without any performance degradation or other drawbacks. All of this is thanks to Kotlin‚Äôs extension functions and object declarations. Code managed this way is easy to read and maintain, greatly aiding in service operation.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cspan\u003eSimple and efficient unit testing using data classes\u003c/span\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eWhen writing unit tests, data classes can be useful for setting up situations for testing. A data class in Kotlin is, as the name suggests, a class for representing data. Unlike regular classes, \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e are redefined, and other methods like \u003ccode\u003ecopy()\u003c/code\u003e are automatically generated. Using data classes is useful when writing classes that represent data, such as DTOs\u003csup\u003e\u003ca href=\"#footnote-4\"\u003e(4)\u003c/a\u003e\u003c/sup\u003e.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eThis is an example of a DTO that needs to be tested.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003edata class UserInformation(\n    val name: String,\n    val age: Int,\n    val birthDate: LocalDate,\n    val address: String,\n    val gender: Gender,\n    val isDisplay: Boolean\n) {\n    enum class Gender {\n        MALE,\n        FEMALE;\n    }\n\n    init {\n        require(age \u0026gt;= 18)\n    }\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe goal is to test whether age validation works. If the age is 18 or older, no exception should be thrown, and if it is under 18, an \u003ccode\u003eIllegalArgumentException\u003c/code\u003e should be thrown. Here‚Äôs one way to write the test:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eclass WhateverTest() {\n    @Test\n    fun `Throws IllegalArgumentException if age is under 18`() {\n        assertThrows {\n            val userInformation = UserInformation(\n                name = \u0026#34;Chung Katfun\u0026#34;,\n                age = 17,\n                birthDate = LocalDate.of(2022, 12, 19),\n                address = \u0026#34;Kakao Pangyo Agit\u0026#34;,\n                gender = UserInformation.Gender.MALE,\n                isDisplay = true\n            )\n        }\n    }\n\n    @Test\n    fun `Does not throw exception if age is 18 or older`() {\n        assertDoesNotThrow {\n            val userInformation = UserInformation(\n                name = \u0026#34;Chung Katfun\u0026#34;,\n                age = 18,\n                birthDate = LocalDate.of(2022, 12, 19),\n                address = \u0026#34;Kakao Pangyo Agit\u0026#34;,\n                gender = UserInformation.Gender.MALE,\n                isDisplay = true\n            )\n        }\n    }\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eDo you see the problem?\u003c/p\u003e\n\n\n\n\u003cp\u003eThe target of the test is unclear.\u003cbr/\u003eUnnecessary code is repeated.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt is difficult to determine from the test code above which values in \u003ccode\u003eUserInformation\u003c/code\u003e contribute to the exception. Adding comments could partially resolve this, but if the DTO has dozens of fields, it would be hard to identify which fields have comments at a glance. Additionally, to create a \u003ccode\u003eUserInformation\u003c/code\u003e instance, appropriate values must be assigned to fields other than \u003ccode\u003eage\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo address this, the \u003ccode\u003ecopy()\u003c/code\u003e function of the data class can be used. \u003ccode\u003ecopy()\u003c/code\u003e has the following characteristics:\u003c/p\u003e\n\n\n\n\u003cp\u003eA completely identical data class instance is created. When compared with the original instance using \u003ccode\u003eequals()\u003c/code\u003e, they are considered equal.\u003cbr/\u003eWhen calling \u003ccode\u003ecopy()\u003c/code\u003e, you can specify values for parameters. In this case, only the specified values of the corresponding parameters are copied.\u003c/p\u003e\n\n\n\n\u003cp\u003eReturning to the code above, let‚Äôs separate the common parts and revise it to make the test target clearer.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eclass WhateverTest() {\n    @Test\n    fun `Throws IllegalArgumentException if age is under 18`() {\n        val invalidAge = 17\n        assertThrows {\n            val userInformation = successUserInformation.copy(age = invalidAge)\n        }\n    }\n\n    @Test\n    fun `Does not throw exception if age is 18 or older`() {\n        val validAge = 18\n        assertDoesNotThrow {\n            val userInformation = successUserInformation.copy(age = validAge)\n        }\n    }\n\n    private val successUserInformation = UserInformation(\n        name = \u0026#34;Chung Katfun\u0026#34;,\n        age = 28,\n        birthDate = LocalDate.of(2022, 12, 19),\n        address = \u0026#34;Kakao Pangyo Agit\u0026#34;,\n        gender = UserInformation.Gender.MALE,\n        isDisplay = true\n    )\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eHere are the two versions of the code arranged side by side for comparison.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"790\" height=\"440\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/kakaopay_screenshot_03.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eDo you notice the difference? Using \u003ccode\u003ecopy()\u003c/code\u003e:\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cspan\u003eReduced repeated code.\u003c/span\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eClearly highlighted the target affecting the test.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003cspan\u003eThis lowers the barrier to writing tests and improves their readability. As a result, tests can better serve as documentation, and they can be used to write stable services. This is also valid when writing tests in a BDD\u003csup\u003e\u003ca href=\"#footnote-5\"\u003e(5)\u003c/a\u003e\u003c/sup\u003e style, such as given-when-then or arrange-act-assert.\u003c/span\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eAs someone responsible for the server side of our system, my priority is building services that are stable, readable, and scalable. Since I started using Kotlin two years ago at Kakao Pay, I‚Äôve been able to meet these goals step by step while developing a variety of applications.\u003c/p\u003e\n\n\n\n\u003cp\u003eI wrote this blog post to share my experience in the hope that it helps others build and operate reliable backend systems. Whether you‚Äôre exploring Kotlin or aiming to create more stable backends, I hope you find it useful.\u003c/p\u003e\n\n\n\n\u003ch2\u003eReferences\u003c/h2\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://jaeyeong951.medium.com/project-valhalla-value-class-092a25aec7a6\" target=\"_blank\" rel=\"noopener\"\u003e[Project Valhalla: Value Class]\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://kt.academy/article/ek-object-declarations\" target=\"_blank\" rel=\"noopener\"\u003e[Effective Kotlin Item 48: Consider Using Object Declarations]\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://kotlinlang.org/docs/operator-overloading.html#invoke-operator\" target=\"_blank\" rel=\"noopener\"\u003e[Kotlin Operator Overloading ‚Äì invoke operator]\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://kotlinlang.org/docs/typecasts.html#smart-casts\" target=\"_blank\" rel=\"noopener\"\u003e[Kotlin Smart Casts]\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eValue Object ‚Äì an object that represents a specific value (entity).\u003c/li\u003e\n\n\n\n\u003cli\u003eThis refers to a key feature of Kotlin where the compiler tracks type checks and explicit casting for immutable values and adds implicit casting when necessary.\u003c/li\u003e\n\n\n\n\u003cli\u003eSingleton Pattern ‚Äì a design pattern where only one instance of a specific class is created and used globally.\u003c/li\u003e\n\n\n\n\u003cli\u003eData Transfer Object ‚Äì an object used for transferring data.\u003c/li\u003e\n\n\n\n\u003cli\u003eBehaviour Driven Development ‚Äì Describing the behavior of code using domain language when writing tests.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n    \u003cdiv\u003e\n                                                            \u003cp\u003e\u003cimg decoding=\"async\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/45638155.jpeg\" alt=\"\" loading=\"lazy\"/\u003e\n                        \u003c/p\u003e\n                                        \u003cdiv\u003e\n                                                    \u003ch4\u003eAbout Kuyho Chung (katfun.joy)\u003c/h4\u003e\n                                                \u003cp\u003e\u003cspan\u003eA server developer at Kakao Pay, I really enjoy solving difficulties and inconveniences through technology. I strive to write each line of code with a solid rationale.\u003c/span\u003e\u003c/p\u003e\n                    \u003c/div\u003e\n                            \u003c/div\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to Kotlin Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "25 min read",
  "publishedTime": null,
  "modifiedTime": null
}
