{
  "id": "691d13c7-5634-4e04-a6e5-fabd2d340841",
  "title": "How Meta Ported Million Lines of Android Code from Java to Kotlin",
  "link": "https://www.infoq.com/news/2024/12/meta-java-kotlin-port/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "In order to maximize the benefits brought by Kotlin in terms of productivity and safety, Meta engineers have been hard at work to translate their 10 million line Android codebase from Java into Kotlin. One year into this process, they have ported approximately half of their codebase and developed a specific tool, Kotlinator, to automate the process as much as possible. By Sergio De Simone",
  "author": "Sergio De Simone",
  "published": "Sat, 28 Dec 2024 12:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Java",
    "Compilers",
    "Facebook",
    "Safety",
    "Mobile",
    "JetBrains",
    "Productivity",
    "Kotlin",
    "Development",
    "news"
  ],
  "byline": "Sergio De Simone",
  "length": 4496,
  "excerpt": "In order to maximize the benefits brought by Kotlin in terms of productivity and safety, Meta engineers have been hard at work to translate their 10 million line Android codebase from Java into Kotlin",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s2_20241210082921/apple-touch-icon.png",
  "text": "In order to maximize the benefits brought by Kotlin in terms of productivity and safety, Meta engineers have been hard at work to translate their 10 million line Android codebase from Java into Kotlin. One year into this process, they have ported approximately half of their codebase and developed a specific tool, Kotlinator, to automate the process as much as possible. Instead of translating only actively developed code, which could sound the most convenient approach, Meta engineers decided to go for a full migration to avoid the risk that any remaining Java code could be the source of nullability issues but also to remove the drawbacks of using two different toolchains in parallel and the performance hit of having to compile a mixed codebase. From the beginning, it was clear to Meta engineers that the support provided by IntelliJ's J2K translation tool was not enough for such a large codebase and that they needed to automate the conversion process as much as possible. However, J2K provided the foundations for their conversion solution, Kotlinator. The first step was transforming J2K into a headless tool that could be run on a remote machine. The headless J2K was implemented as an IntelliJ plugin extending the ApplicationStarter class and calling directly into JavaToKotlinConverter, as the IntelliJ conversion button does. Before running the headless J2K, Kotlinator uses a pre- and post-conversion steps to make sure that converted code can build. These steps deal with nullability, apply some known J2K workarounds, and make the generated code more idiomatic. Both phases contain dozens of steps that take in the file being translated, analyze it (and sometimes its dependencies and dependents, too), and perform a Java-\u003eJava or Kotlin-\u003eKotlin transformation if needed. Meta open sourced some of those conversions so that they could be directly used and also to provide examples of Kotlin AST manipulation through the Kotlin compiler API. Most of the conversion steps are built using a metaprogramming tool leveraging JetBrains' Program Structure Interface (PSI) libraries, which can parse files and create syntactic and semantic code models without resorting to the compiler. This is important, say Meta engineers, because in many cases post-processed code would not compile at all, so an alternative method to transform it was required and PSI provided just that. Any build errors resulting from these steps are handled by interpreting the compiler's error messages just as a human would do, explain Meta engineers, but in an automated way specified using some metaprogramming. Instead of simply reducing developers' effort, these automated steps were also used to minimize the possibility of human error when converting code manually. In the process, Meta engineers collaborated with JetBrains to extend J2K to enable it to run hooks injected by client libraries directly in the IDE. As Meta engineers explain, a large part of their effort to make Java code translatable to Kotlin is aimed at making it null-safe. This can be achieved simply using a static analyzer, such as Nullsafe or NullAway, to detect all suspect cases, but it is still not enough to eliminate the risk of null-pointer exceptions (NPEs). NPEs, for example, can arise when some non null-safe dependency passes a null value into a formally non-nullable parameter to a function. One approach taken by Kotlinator to reduce this risk is \"erring on the side of more nullable\", which means defaulting to considering parameters and return types as nullable when the code does not suggest they actually are non-nullable. Additionally, they built a Java compiler plugin that collects nullability data at runtime to identify parameters and return types that could be null in spite of not being declared as nullable. As it is evident from Meta report, translating a large Java codebase into Kotlin is no trivial effort and requires some very advanced engineering. Meta's journey to make their codebase 100% Kotlin has not come to an end yet but it surely provides the opportunity for some deep understanding of the differences between the two languages and how to transform Kotlin code in a programmatic way. There is much more to this than can be covered here, so do not miss the original article if you are interested in the full detail. About the Author Sergio De Simone",
  "image": "https://res.infoq.com/news/2024/12/meta-java-kotlin-port/en/headerimage/meta-java-kotlin-port-1735383561177.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eIn order to maximize the benefits brought by Kotlin in terms of productivity and safety, \u003ca href=\"https://engineering.fb.com/2024/12/18/android/translating-java-to-kotlin-at-scale/\"\u003eMeta engineers have been hard at work to translate their 10 million line Android codebase from Java into Kotlin\u003c/a\u003e. One year into this process, they have ported approximately half of their codebase and developed a specific tool, Kotlinator, to automate the process as much as possible.\u003c/p\u003e\n\n\u003cp\u003eInstead of translating only actively developed code, which could sound the most convenient approach, Meta engineers decided to go for a full migration to avoid the risk that any remaining Java code could be the source of nullability issues but also to remove the drawbacks of using two different toolchains in parallel and the \u003ca href=\"https://stackoverflow.com/questions/76758325/kotlin-compiler-bad-performance-in-multi-maven-module-project\"\u003eperformance hit of having to compile a mixed codebase\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eFrom the beginning, it was clear to Meta engineers that the \u003ca href=\"https://github.com/JetBrains/intellij-community/tree/master/plugins/kotlin/j2k\"\u003esupport provided by IntelliJ\u0026#39;s J2K translation tool\u003c/a\u003e was not enough for such a large codebase and that they needed to automate the conversion process as much as possible. However, J2K provided the foundations for their conversion solution, Kotlinator.\u003c/p\u003e\n\n\u003cp\u003eThe first step was transforming J2K into a headless tool that could be run on a remote machine. The headless J2K was implemented as an IntelliJ plugin extending the \u003ccode\u003eApplicationStarter\u003c/code\u003e class and calling directly into \u003ccode\u003eJavaToKotlinConverter\u003c/code\u003e, as the IntelliJ conversion button does.\u003c/p\u003e\n\n\u003cp\u003eBefore running the headless J2K, Kotlinator uses a pre- and post-conversion steps to make sure that converted code can build. These steps deal with nullability, apply some known J2K workarounds, and make the generated code more idiomatic.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eBoth phases contain dozens of steps that take in the file being translated, analyze it (and sometimes its dependencies and dependents, too), and perform a Java-\u0026gt;Java or Kotlin-\u0026gt;Kotlin transformation if needed.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/fbsamples/kotlin_ast_tools\"\u003eMeta open sourced some of those conversions\u003c/a\u003e so that they could be directly used and also to provide examples of Kotlin AST manipulation through the Kotlin compiler API.\u003c/p\u003e\n\n\u003cp\u003eMost of the conversion steps are built using a metaprogramming tool leveraging \u003ca href=\"https://plugins.jetbrains.com/docs/intellij/psi.html\"\u003eJetBrains\u0026#39; Program Structure Interface (PSI)\u003c/a\u003e libraries, which can parse files and create syntactic and semantic code models without resorting to the compiler. This is important, say Meta engineers, because in many cases post-processed code would not compile at all, so an alternative method to transform it was required and PSI provided just that.\u003c/p\u003e\n\n\u003cp\u003eAny build errors resulting from these steps are handled by interpreting the compiler\u0026#39;s error messages just as a human would do, explain Meta engineers, but in an automated way specified using some metaprogramming.\u003c/p\u003e\n\n\u003cp\u003eInstead of simply reducing developers\u0026#39; effort, these automated steps were also used to minimize the possibility of human error when converting code manually. In the process, Meta engineers collaborated with JetBrains to extend J2K to enable it to run hooks injected by client libraries directly in the IDE.\u003c/p\u003e\n\n\u003cp\u003eAs Meta engineers explain, a large part of their effort to make Java code translatable to Kotlin is aimed at making it null-safe. This can be achieved simply using a static analyzer, such as \u003ca href=\"https://github.com/facebook/infer/blob/main/infer/annotations/src/main/java/com/facebook/infer/annotation/Nullsafe.java\"\u003eNullsafe\u003c/a\u003e or \u003ca href=\"https://github.com/uber/NullAway\"\u003eNullAway\u003c/a\u003e, to detect all suspect cases, but it is still not enough to eliminate the risk of null-pointer exceptions (NPEs).\u003c/p\u003e\n\n\u003cp\u003eNPEs, for example, can arise when some non null-safe dependency passes a \u003ccode\u003enull\u003c/code\u003e value into a formally non-nullable parameter to a function. One approach taken by Kotlinator to reduce this risk is \u0026#34;erring on the side of more nullable\u0026#34;, which means defaulting to considering parameters and return types as nullable when the code does not suggest they actually are non-nullable. Additionally, they built a Java compiler plugin that collects nullability data at runtime to identify parameters and return types that could be \u003ccode\u003enull\u003c/code\u003e in spite of not being declared as \u003ccode\u003enullable\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAs it is evident from Meta report, translating a large Java codebase into Kotlin is no trivial effort and requires some very advanced engineering. Meta\u0026#39;s journey to make their codebase 100% Kotlin has not come to an end yet but it surely provides the opportunity for some deep understanding of the differences between the two languages and how to transform Kotlin code in a programmatic way. There is much more to this than can be covered here, so do not miss the original article if you are interested in the full detail.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Sergio-De-Simone\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eSergio De Simone\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-12-28T00:00:00Z",
  "modifiedTime": null
}
