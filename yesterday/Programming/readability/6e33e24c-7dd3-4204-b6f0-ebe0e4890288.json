{
  "id": "6e33e24c-7dd3-4204-b6f0-ebe0e4890288",
  "title": "IntelliJ Scala Plugin 2024.3 Is Out!",
  "link": "https://blog.jetbrains.com/scala/2024/11/13/intellij-scala-plugin-2024-3-is-out/",
  "description": "Scala 3 support Transparent inline methods (experimental) Transparent inline methods in Scala 3 allow the compiler to reinterpret the method being inlined in the context of information known already at the compile time. Our support of this feature is still experimental and requires more work, but what we offer in this release already covers the […]",
  "author": "Maciej Gorywoda",
  "published": "Wed, 13 Nov 2024 15:40:41 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "news",
    "releases",
    "scala",
    "scala-programming",
    "intellij-idea"
  ],
  "byline": "Maciej Gorywoda",
  "length": 6941,
  "excerpt": "Scala Plugin 2024.3 is out with : -Support for transparent inline methods (experimental), named tuples, and opaque types -Better handling of Scala CLI projects -A new project model for sbt (beta) -AI multiline code completion",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "Scala Plugin for IntelliJ IDEA and Android Studio News Releases Scala Scala programmingIntelliJ Scala Plugin 2024.3 Is Out! Scala 3 support Transparent inline methods (experimental) Transparent inline methods in Scala 3 allow the compiler to reinterpret the method being inlined in the context of information known already at the compile time. Our support of this feature is still experimental and requires more work, but what we offer in this release already covers the most popular use cases. For example, when a transparent inline method serves as an entry point to a library that uses macro, you will now get much more information about the inferred types than before: Figuring out the result type of a transparent inline method call can often be quite complicated. To do this, we rely on the type information returned by the compiler, meaning that this feature is available only with Compiler-Based Highlighting. To enable the support for transparent inline methods in IntelliJ IDEA, go to Settings | Languages \u0026 Frameworks | Scala | Editor, ensure that the error highlighting mode is set to Compiler (as is the default for Scala 3), and check “Use types reported by the Scala compiler (experimental)”. We are still working on many improvements to this feature. We encourage you to try it out and let us know your thoughts. Your feedback is very valuable to us. Named tuples IntelliJ IDEA 2024.3 fully supports named tuples, a new experimental feature in Scala 3.5 that will become a standard feature in Scala 3.6. As the title suggests, named tuples allow you to name the components of a tuple so that they can be accessed with readable names.  On top of that, the compiler can infer the types of fields based on the assigned values. As we move towards Scala 3.6, named tuples will become an integral part of the Scala language, and we are proud to say that the IntelliJ Scala Plugin has supported them from day one. Opaque type aliases Additionally, IntelliJ IDEA is now better at recognizing opaque type aliases. We already recognized the opaque keyword, but in practice, IntelliJ IDEA has handled opaque type aliases just like standard (i.e., transparent) type aliases. Since the current release, they are treated as abstract types, meaning their underlying definitions are hidden from the outside code. Scala CLI IntelliJ IDEA 2024.3 introduces improved support for Scala CLI projects. When you open a folder containing a project.scala file, the plugin automatically recognizes it as a Scala CLI project. Additionally, the new release provides a convenient way to create new Scala CLI projects through the New Project wizard. And, when you do this, you can add new Scala files to the project, just as you can for sbt-based projects. This makes it easier than ever to start developing Scala CLI applications in IntelliJ IDEA. More improvements to Compiler-Based Highlighting On top of the support for transparent inline methods, the new release comes with faster and more reliable Compiler-Based Highlighting.  We reduced the number of cases when multiple compilations were necessary, e.g., in situations where refactorings that affect multiple files result in many compilation requests. IntelliJ IDEA analyzes and batches these requests in the new release and then issues a single request with a broader compilation scope. This reduces CPU resource utilization and optimizes the compiler’s highlighting experience. We’ve also fixed some edge cases where duplicated parser errors are shown, both from the IDEA Scala parser and the compiler. New project model for sbt projects (beta) We’re introducing a new mode that better represents the structure of sbt projects in IntelliJ IDEA by organizing main and test sources into separate modules. The improved layout resolves several issues with compilation and highlighting and allows the use of distinct compiler options for main and test sources. This feature is currently in “beta”. We strongly encourage you to try it out and share your feedback! Enable it via Settings | Build, Execution, Deployment | Build Tools | sbt and select “Create separate modules for production and test sources”. Stay tuned for a blog post we plan to publish soon, describing this new feature in detail! The debugger In the debugger, we now support the new encoding of lazy vals introduced in Scala 3.3, and we reintroduced the “Initialize” button for lazy vals. AI Assistant Completing just one line of code quite often is not enough, so since the new release, we have made multiline cloud-based code completion available for Scala. To enable it, go to Settings | Editor | General | Inline Completion, scroll down, and check “Enable cloud completion suggestions” if it’s not checked already. On the list below, check Scala. As you can see in the following short video, if the AI Assistant decides it can reliably guess the following lines of code you want to write, it will propose the whole chunk. To do it, though, the AI Assistant requires a connection to the server – the local model can still only propose one-line completions – so be sure you can use it. The AI Assistant comes with many other features that can help you in your work. You can read about them here. Other improvements We improved the IDE performance and fixed certain bugs that led to the UI freezing. This happened sometimes during refactorings and actions, e.g., when you extended a Java interface in Scala and requested IntelliJ IDEA implement the new class members. In some other cases, when the action actually needs some time, a progress bar will be shown. Also, if you open Run | Edit Configurations…, you will notice that the “Environment variables” field now accepts .env files. All Scala-related run configurations (Scalatest, MUnit, Specs2, uTest, Play Framework, SBT, and Scala REPL) can now read environment variables directly from an .env file – a popular format for storing environment-specific configuration variables as key-value pairs. This feature was implemented with help from the Scala community members.  As always, your feedback is very welcome. Please report any issues you find to YouTrack. If you have any questions, feel free to ask us on Discord. Happy developing! The IntelliJ Scala Plugin team Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2024/11/socialmedia_cover.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/scala/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-Scala-Plugin.svg\" alt=\"Scala logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eScala Plugin for IntelliJ IDEA and Android Studio\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/scala/category/news/\"\u003eNews\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/scala/category/releases/\"\u003eReleases\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/scala/category/scala/\"\u003eScala\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/scala/category/scala-programming/\"\u003eScala programming\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eIntelliJ Scala Plugin 2024.3 Is Out!\u003c/h2\u003e                    \n                    \n\u003ch2\u003eScala 3 support\u003c/h2\u003e\n\n\n\n\u003ch3\u003eTransparent inline methods (experimental)\u003c/h3\u003e\n\n\n\n\u003cp\u003eTransparent inline methods in Scala 3 allow the compiler to reinterpret the method being inlined in the context of information known already at the compile time. Our support of this feature is still experimental and requires more work, but what we offer in this release already covers the most popular use cases. For example, when a transparent inline method serves as an entry point to a library that uses macro, you will now get much more information about the inferred types than before:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1500\" height=\"600\" data-id=\"523407\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/TransparentInline_Before.png\" alt=\"Before: A snippet of ZIO code with inlay hints showing placeholders for type parameters\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1500\" height=\"600\" data-id=\"523406\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/TransparentInline_After.png\" alt=\"After: A snippet of ZIO code with inlay hints showing inferred type parameters\"/\u003e\u003c/figure\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003eFiguring out the result type of a transparent inline method call can often be quite complicated. To do this, we rely on the type information returned by the compiler, meaning that this feature is available only with Compiler-Based Highlighting. To enable the support for transparent inline methods in IntelliJ IDEA, go to \u003cstrong\u003eSettings | Languages \u0026amp; Frameworks | Scala | Editor\u003c/strong\u003e, ensure that the error highlighting mode is set to Compiler (as is the default for Scala 3), and check \u003cem\u003e“Use types reported by the Scala compiler (experimental)”\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe are still working on many improvements to this feature. We encourage you to try it out and let us know your thoughts. Your feedback is very valuable to us.\u003c/p\u003e\n\n\n\n\u003ch3\u003eNamed tuples\u003c/h3\u003e\n\n\n\n\u003cp\u003eIntelliJ IDEA 2024.3 fully supports named tuples, a new experimental feature in Scala 3.5 that will become a standard feature in Scala 3.6. As the title suggests, named tuples allow you to name the components of a tuple so that they can be accessed with readable names.  On top of that, the compiler can infer the types of fields based on the assigned values.\u003c/p\u003e\n\n\n\n\u003cp\u003eAs we move towards Scala 3.6, named tuples will become an integral part of the Scala language, and we are proud to say that the IntelliJ Scala Plugin has supported them from day one.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcnZWzgvftlMy6e6IAqUuKz3ZGeJyQwziG0iNUxE0KpHMng_oSt7WgBJJJKsmyWLcdPo0b-gPkDkRhPrepm6JgHypoWOrPaIoHG1iAIXyIGd442pKtCCEX2ufubbqA2IIRYdPO8DTWTwWU0HnuTKkPKwQMp?key=YIb1NOI0a7Blonivucj1VBvp\" alt=\"A named tuple `Person` with fields `afe` and `name`\"/\u003e\u003c/figure\u003e\n\n\n\n\n\n\n\n\u003ch3\u003eOpaque type aliases\u003c/h3\u003e\n\n\n\n\u003cp\u003eAdditionally, IntelliJ IDEA is now better at recognizing opaque type aliases. We already recognized the \u003ccode\u003eopaque\u003c/code\u003e keyword, but in practice, IntelliJ IDEA has handled opaque type aliases just like standard (i.e., transparent) type aliases. Since the current release, they are treated as abstract types, meaning their underlying definitions are hidden from the outside code.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXebIYI4Taox7Ho0ILpMJc6C2KshICB6WVXMOuyiAawzuO6fqsvCmm-qN87hzN4POwQX-0D6geQFdrAcrvaE1IEuJHD5jf5Hzm8Hvz5BF2X33fW6Ovp1a4qNNvLTYGV7HhkAH_PXocXhcovf6z4Czj940nzU?key=YIb1NOI0a7Blonivucj1VBvp\" alt=\"Error: type mismatch between the opaque type alias Foo and its internal type Int\"/\u003e\u003c/figure\u003e\n\n\n\n\n\n\n\n\u003ch2\u003eScala CLI\u003c/h2\u003e\n\n\n\n\u003cp\u003eIntelliJ IDEA 2024.3 introduces improved support for Scala CLI projects. When you open a folder containing a project.scala file, the plugin automatically recognizes it as a Scala CLI project. Additionally, the new release provides a convenient way to create new Scala CLI projects through the \u003cem\u003eNew Project\u003c/em\u003e wizard. And, when you do this, you can add new Scala files to the project, just as you can for sbt-based projects. This makes it easier than ever to start developing Scala CLI applications in IntelliJ IDEA.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/ScalaCLI.mp4\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\n\n\n\n\u003ch2\u003eMore improvements to Compiler-Based Highlighting\u003c/h2\u003e\n\n\n\n\u003cp\u003eOn top of the support for transparent inline methods, the new release comes with faster and more reliable Compiler-Based Highlighting.  We reduced the number of cases when multiple compilations were necessary, e.g., in situations where refactorings that affect multiple files result in many compilation requests. IntelliJ IDEA analyzes and batches these requests in the new release and then issues a single request with a broader compilation scope. This reduces CPU resource utilization and optimizes the compiler’s highlighting experience. We’ve also fixed some edge cases where duplicated parser errors are shown, both from the IDEA Scala parser and the compiler.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003ch2\u003eNew project model for sbt projects (beta)\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe’re introducing a new mode that better represents the structure of sbt projects in IntelliJ IDEA by organizing main and test sources into separate modules. The improved layout resolves several issues with compilation and highlighting and allows the use of distinct compiler options for main and test sources.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis feature is currently in “beta”. We strongly encourage you to try it out and share your feedback! Enable it via \u003cstrong\u003eSettings | Build, Execution, Deployment | Build Tools | sbt\u003c/strong\u003e and select \u003cem\u003e“Create separate modules for production and test sources”\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1500\" height=\"600\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/NewSbtModel.png\" alt=\"New sbt settings\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eStay tuned for a blog post we plan to publish soon, describing this new feature in detail!\u003c/p\u003e\n\n\n\n\u003ch2\u003eThe debugger\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn the debugger, we now support the new encoding of lazy vals introduced in Scala 3.3, and we reintroduced the “Initialize” button for lazy vals.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/LazyValInitialize.mp4\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\n\n\n\n\u003ch2\u003eAI Assistant\u003c/h2\u003e\n\n\n\n\u003cp\u003eCompleting just one line of code quite often is not enough, so since the new release, we have made multiline cloud-based code completion available for Scala. To enable it, go to \u003cstrong\u003eSettings | Editor | General | Inline Completion\u003c/strong\u003e, scroll down, and check \u003cem\u003e“Enable cloud completion suggestions”\u003c/em\u003e if it’s not checked already. On the list below, check Scala.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXf4lE1y0l_RUot4DP0qAof5_Lfo2Z6djWUq4TuSWEfg-v4QVJwy49lqdk5rxJu4t1uiODT_SV4pHrbk1Gkxaa5oDA1ZA7jwwM4a6O_gWT8BDFwAKQvAIsO-duKuzxmC-uDzICj8Sg3XRXfJdRlVMom3fRjH?key=YIb1NOI0a7Blonivucj1VBvp\" alt=\"The Settings view with a checkbox for cloud completion suggestions for Scala\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAs you can see in the following short video, if the AI Assistant decides it can reliably guess the following lines of code you want to write, it will propose the whole chunk. To do it, though, the AI Assistant requires a connection to the server – the local model can still only propose one-line completions – so be sure you can use it.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe AI Assistant comes with many other features that can help you in your work. \u003ca href=\"https://blog.jetbrains.com/ai/2024/11/jetbrains-ai-assistant-2024-3/\"\u003eYou can read about them here\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/MultilineCompletion-1.mp4\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\n\n\n\n\u003ch2\u003eOther improvements\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe improved the IDE performance and fixed certain bugs that led to the UI freezing. This happened sometimes during refactorings and actions, e.g., when you extended a Java interface in Scala and requested IntelliJ IDEA implement the new class members. In some other cases, when the action actually needs some time, a progress bar will be shown.\u003c/p\u003e\n\n\n\n\u003cp\u003eAlso, if you open \u003cstrong\u003eRun | Edit Configurations…\u003c/strong\u003e, you will notice that the \u003cem\u003e“Environment variables”\u003c/em\u003e field now accepts .env files. All Scala-related run configurations (Scalatest, MUnit, Specs2, uTest, Play Framework, SBT, and Scala REPL) can now read environment variables directly from an .env file – a popular format for storing environment-specific configuration variables as key-value pairs. This feature was implemented with help from the Scala community members. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeCZpQM7WHGiDJ_fvUV_zOOcUrpQz6d0CnuTCPeii9pR_ccfEDWlszC0vValUmvhTRXD-_36S1BOGGrkdul861sBlDZh3UN1kS8-dC_Hyt7VTKIUNuuNyp2gQ4xAbxARL5Atho1wo3YFsgNe7p_la5HZMjh?key=YIb1NOI0a7Blonivucj1VBvp\" alt=\"The Finder window opened to search for an .env file\"/\u003e\u003c/figure\u003e\n\n\n\n\n\n\n\n\u003cp\u003eAs always, your feedback is very welcome. Please report any issues you find to \u003ca href=\"https://youtrack.jetbrains.com/issues/SCL\" target=\"_blank\" rel=\"noopener\"\u003eYouTrack\u003c/a\u003e. If you have any questions, feel free to ask us on \u003ca href=\"https://discord.com/channels/931170831139217469\" target=\"_blank\" rel=\"noopener\"\u003eDiscord\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eHappy developing!\u003c/p\u003e\n\n\n\n\u003cp\u003eThe \u003ca href=\"https://plugins.jetbrains.com/plugin/1347-scala\" target=\"_blank\" rel=\"noopener\"\u003eIntelliJ Scala Plugin\u003c/a\u003e team\u003c/p\u003e\n                    \n                                                                                                                                                                                                                                    \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
