{
  "id": "e5ce164f-b794-449d-91e1-454cb8c4122b",
  "title": "Inside Netflixâ€™s Distributed Counter: Scalable, Accurate, and Real-Time Counting at Global Scale",
  "link": "https://www.infoq.com/news/2024/12/netflix-distributed-counter/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "Netflix engineers recently published a deep dive into their Distributed Counter Abstraction, a scalable service designed to track user interactions, feature usage, and business performance metrics with low latency. The system balances performance, accuracy, and cost through configurable counting modes, resilient data aggregation, and a globally distributed architecture. By Eran Stiller",
  "author": "Eran Stiller",
  "published": "Tue, 10 Dec 2024 11:30:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Distributed Systems",
    "Event Driven Architecture",
    "Netflix",
    "Cassandra",
    "Time Series Data",
    "Architecture \u0026 Design",
    "news"
  ],
  "byline": "Eran Stiller",
  "length": 4691,
  "excerpt": "Netflix engineers recently published a deep dive into their Distributed Counter Abstraction, a scalable service designed to track user interactions, feature usage, and business performance metrics wit",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s1_20241210082243/apple-touch-icon.png",
  "text": "Netflix engineers recently published a deep dive into their Distributed Counter Abstraction, a scalable service designed to track user interactions, feature usage, and business performance metrics with low latency globally. Built atop Netflix's TimeSeries Abstraction, the system balances performance, accuracy, and cost through configurable counting modes, resilient data aggregation, and a globally distributed architecture. Counting things might sound like a simple problem. However, Netflix's engineers highlight the hidden complexity: Distributed counting is a challenging problem in computer science. [...] At Netflix, our counting use cases include tracking millions of user interactions, monitoring how often specific features or experiences are shown to users, and counting multiple facets of data during A/B test experiments, among others. At the time of writing, this service processed close to 75K count requests/second globally across the different API endpoints and datasets while providing single-digit millisecond latencies for all its endpoints. Latency information for various distributed counter operations (source) Some counting use cases demand \"best-effort counting\", prioritizing low latency and minimal infrastructure costs over absolute accuracy. Others require \"eventually consistent counting\", ensuring precise and durable counts, albeit with a slight delay and increased operational costs. High availability, fault tolerance, and support for idempotent retries necessitate a balance between accuracy, performance, and scalability. While the best-effort counter got away with a relatively simple EVCache-based implementation, Netflix implemented the eventual consistency counter using an event-driven architecture on top of the TimeSeries abstraction. Each counting action is logged as an immutable event in the TimeSeries abstraction along with an idempotency key, ensuring durability and enabling idempotent retries. A background rollup process continuously aggregates these events using time-based windows, storing intermediate counts in a persistent store. This approach avoids data loss and supports consistent global aggregation through the data store's multi-region replication. The rollup process for logged counter events (source) Idempotency plays a crucial role in distributed systems. In a networked environment where failures, retries, and duplicate requests are common, idempotency ensures that repeated operations produce the same result as a single execution, allowing clients to retry their requests. The authors highlight a second useful strategy for clients in such environments: Hedging is when the client sends an identical competing request to the server, if the original request does not come back with a response in an expected amount of time. The client then responds with whichever request completes first. This is done to keep the tail latencies for an application relatively low. This can only be done safely if the mutations are idempotent. The TimeSeries abstraction itself is a scalable, high-throughput data platform that stores and queries temporal event data with millisecond-level latencies. It organizes data into time-series records, partitioning events by time and bucketing them within defined intervals. Each event is immutable, timestamped, and uniquely identified, enabling precise record-keeping and supporting efficient time-range queries. It currently processes nearly 15 million events/second across all datasets globally at peak time. The throughput of the TimeSeries abstraction at Netflix (source) Backed by storage solutions like Cassandra for durability and Elasticsearch for indexing, the abstraction ensures global availability and tunable consistency. Its architecture supports dynamic scaling, configurable retention policies, and adaptive query optimization, making it the foundation for data-intensive services like the Distributed Counter Abstraction. Netflix engineers are now experimenting with an Accurate Global Counter. This counter type enhances real-time aggregation by combining pre-aggregated counts with a live delta of recent events. Instead of waiting for background rollups, it dynamically computes the latest count by scanning unprocessed events since the last aggregation. While this increases read complexity and resource usage, parallel queries and dynamic batching keep latencies low, enabling near-real-time accuracy for critical metrics. High-level overview of the experimental Accurate Global Counter (source) About the Author Eran Stiller",
  "image": "https://res.infoq.com/news/2024/12/netflix-distributed-counter/en/headerimage/Netflix-Distributed-Counter-Header-1733822810485.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eNetflix engineers recently published \u003ca href=\"https://netflixtechblog.com/netflixs-distributed-counter-abstraction-8d0c45eb66b2\" target=\"_blank\"\u003ea deep dive into their Distributed Counter Abstraction\u003c/a\u003e, a scalable service designed to track user interactions, feature usage, and business performance metrics with low latency globally. Built atop \u003ca href=\"https://netflixtechblog.com/introducing-netflix-timeseries-data-abstraction-layer-31552f6326f8\" target=\"_blank\"\u003eNetflix\u0026#39;s TimeSeries Abstraction\u003c/a\u003e, the system balances performance, accuracy, and cost through configurable counting modes, resilient data aggregation, and a globally distributed architecture.\u003c/p\u003e\n\n\u003cp\u003eCounting things might sound like a simple problem. However, Netflix\u0026#39;s engineers highlight the hidden complexity:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eDistributed counting is a challenging problem in computer science. [...] At Netflix, our counting use cases include tracking millions of user interactions, monitoring how often specific features or experiences are shown to users, and counting multiple facets of data during A/B test experiments, among others.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eAt the time of writing, this service processed close to 75K count requests/second globally across the different API endpoints and datasets while providing single-digit millisecond latencies for all its endpoints.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" data-src=\"news/2024/12/netflix-distributed-counter/en/resources/1Netflix-Distributed-Counter-Latency-1733823095731.jpg\" src=\"https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/news/2024/12/netflix-distributed-counter/en/resources/1Netflix-Distributed-Counter-Latency-1733823095731.jpg\" rel=\"share\"/\u003e\u003cbr/\u003e\n\u003cem\u003eLatency information for various distributed counter operations (\u003ca href=\"https://netflixtechblog.com/netflixs-distributed-counter-abstraction-8d0c45eb66b2\" target=\"_blank\"\u003esource\u003c/a\u003e)\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eSome counting use cases demand \u0026#34;best-effort counting\u0026#34;, prioritizing low latency and minimal infrastructure costs over absolute accuracy. Others require \u0026#34;eventually consistent counting\u0026#34;, ensuring precise and durable counts, albeit with a slight delay and increased operational costs. High availability, fault tolerance, and support for idempotent retries necessitate a balance between accuracy, performance, and scalability.\u003c/p\u003e\n\n\u003cp\u003eWhile the best-effort counter got away with a relatively simple \u003ca href=\"https://github.com/Netflix/EVCache\" target=\"_blank\"\u003eEVCache\u003c/a\u003e-based implementation, Netflix implemented the eventual consistency counter using an \u003ca href=\"https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/event-driven\" target=\"_blank\"\u003eevent-driven architecture\u003c/a\u003e on top of the TimeSeries abstraction.\u003c/p\u003e\n\n\u003cp\u003eEach counting action is logged as an immutable event in the TimeSeries abstraction along with an idempotency key, ensuring durability and enabling idempotent retries. A background rollup process continuously aggregates these events using time-based windows, storing intermediate counts in a persistent store. This approach avoids data loss and supports consistent global aggregation through the data store\u0026#39;s multi-region replication.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" data-src=\"news/2024/12/netflix-distributed-counter/en/resources/1Netflix-Distributed-Counter-Rollup-1733823095731.png\" src=\"https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/news/2024/12/netflix-distributed-counter/en/resources/1Netflix-Distributed-Counter-Rollup-1733823095731.png\" rel=\"share\"/\u003e\u003cbr/\u003e\n\u003cem\u003eThe rollup process for logged counter events (\u003ca href=\"https://netflixtechblog.com/netflixs-distributed-counter-abstraction-8d0c45eb66b2\" target=\"_blank\"\u003esource\u003c/a\u003e)\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://restfulapi.net/idempotent-rest-apis/\" target=\"_blank\"\u003eIdempotency\u003c/a\u003e plays a crucial role in distributed systems. In a networked environment where \u003ca href=\"https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing\" target=\"_blank\"\u003efailures, retries, and duplicate requests are common\u003c/a\u003e, idempotency ensures that repeated operations produce the same result as a single execution, allowing clients to retry their requests. The authors highlight a second useful strategy for clients in such environments:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://research.google/pubs/the-tail-at-scale/\" target=\"_blank\"\u003eHedging\u003c/a\u003e is when the client sends an identical competing request to the server, if the original request does not come back with a response in an expected amount of time. The client then responds with whichever request completes first. This is done to keep the tail latencies for an application relatively low. This can only be done safely if the mutations are idempotent.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eThe TimeSeries abstraction itself is a scalable, high-throughput data platform that stores and queries temporal event data with millisecond-level latencies. It organizes data into time-series records, partitioning events by time and bucketing them within defined intervals. Each event is immutable, timestamped, and uniquely identified, enabling precise record-keeping and supporting efficient time-range queries. It currently processes nearly 15 million events/second across all datasets globally at peak time.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" data-src=\"news/2024/12/netflix-distributed-counter/en/resources/1Netflix-Distributed-Counter-TimeSeries-Throughput-1733823095731.png\" src=\"https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/news/2024/12/netflix-distributed-counter/en/resources/1Netflix-Distributed-Counter-TimeSeries-Throughput-1733823095731.png\" rel=\"share\"/\u003e\u003cbr/\u003e\n\u003cem\u003eThe throughput of the TimeSeries abstraction at Netflix (\u003ca href=\"https://netflixtechblog.com/introducing-netflix-timeseries-data-abstraction-layer-31552f6326f8\" target=\"_blank\"\u003esource\u003c/a\u003e)\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eBacked by storage solutions like \u003ca href=\"https://cassandra.apache.org/_/index.html\" target=\"_blank\"\u003eCassandra\u003c/a\u003e for durability and \u003ca href=\"https://www.elastic.co/elasticsearch\" target=\"_blank\"\u003eElasticsearch\u003c/a\u003e for indexing, the abstraction ensures global availability and tunable consistency. Its architecture supports dynamic scaling, configurable retention policies, and adaptive query optimization, making it the foundation for data-intensive services like the Distributed Counter Abstraction.\u003c/p\u003e\n\n\u003cp\u003eNetflix engineers are now experimenting with an Accurate Global Counter. This counter type enhances real-time aggregation by combining pre-aggregated counts with a live delta of recent events. Instead of waiting for background rollups, it dynamically computes the latest count by scanning unprocessed events since the last aggregation. While this increases read complexity and resource usage, parallel queries and dynamic batching keep latencies low, enabling near-real-time accuracy for critical metrics.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"\" data-src=\"news/2024/12/netflix-distributed-counter/en/resources/2Netflix-Distributed-Counter-Accurate-Global-Timer-1733823095731.png\" src=\"https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/news/2024/12/netflix-distributed-counter/en/resources/2Netflix-Distributed-Counter-Accurate-Global-Timer-1733823095731.png\" rel=\"share\"/\u003e\u003cbr/\u003e\n\u003cem\u003eHigh-level overview of the experimental Accurate Global Counter (\u003ca href=\"https://netflixtechblog.com/netflixs-distributed-counter-abstraction-8d0c45eb66b2\" target=\"_blank\"\u003esource\u003c/a\u003e)\u003c/em\u003e\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Eran-Stiller\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eEran Stiller\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-12-10T00:00:00Z",
  "modifiedTime": null
}
