{
  "id": "dd91ee8b-5d56-4ee8-8099-98498e78f4f6",
  "title": "Presentation: Rebuilding Prime Video UI with Rust and WebAssembly",
  "link": "https://www.infoq.com/presentations/prime-video-rust/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "Alexandru Ene features details of a new UI SDK in Rust for Prime Video that targets living room devices. By Alexandru Ene",
  "author": "Alexandru Ene",
  "published": "Fri, 21 Mar 2025 13:25:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Case Study",
    "Transcripts",
    "Rust",
    "Amazon",
    "QCon San Francisco 2024",
    "WebAssembly",
    "Development",
    "presentation"
  ],
  "byline": "Alexandru Ene",
  "length": 38937,
  "excerpt": "Alexandru Ene features details of a new UI SDK in Rust for Prime Video that targets living room devices.",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s2_20250320073856_u1/apple-touch-icon.png",
  "text": "Transcript Ene: We're going to talk about how we rebuilt a Prime Video UI for living room devices with Rust and WebAssembly, and the journey that got us there. I'm Alex. I've been a principal engineer with Amazon for about eight years. We've been working with Rust for a while actually in our tech stack for the clients. We had our low-level UI engine in WebAssembly and Rust for that log. Previously I worked on video games, game engines, interactive applications like that. I've quite a bit of experience in interactive applications. Content I'll talk about challenges in this space, because living room devices are things like set top boxes, gaming consoles, streaming sticks, TVs. People don't usually develop UIs for these devices, and they come with their own special set of challenges, so we're going to go through those. Then I'll show you how our architecture for the Prime Video App looked before we rewrote everything in Rust. We had a dual tech stack with the business code in React and JavaScript, and then low-level bits of the engine in Rust and WebAssembly, a bit of C++ in there as well. Then I'll show you some code with our new Rust UI SDK and how that looks, which is what we use right now in production. We're going to talk a little bit of how that code works with our low-level existing engine and how everything is organized. At the end, we're going to go a little bit to results, lessons learned. Challenges In This Space Living room devices, so as I said, these are gaming consoles, streaming sticks, set top boxes. They come with their own challenges, and some of them are obvious. There's performance differences that are huge. We're talking about a PlayStation 5 Pro, super nice gaming console, lots of power, but also a USB power streaming stick. Prime Video, we run the same application on all of these device types. Obviously, performance is really important for us. We can't quite have teams per device type, so one team that does set top boxes, then another team does gaming consoles, because then everything explodes. When you build a feature, you have to build it for everything. We were building things once and then deploying on all of these device categories here. We don't deploy this application that I'm talking about on mobile devices, like iPhone, iOS, mobile devices don't have this. This is just living room devices. Again, a huge range of performance. We're trying to write our code as optimal as possible. Usually, high performant code is code that you compile natively. Let's say Rust compiled to native, C++ compiled to native, but that doesn't quite cut it in this space and we'll see why. Another pain point and challenge is hardware capabilities between these devices is a pain. As SDK developers, we need to think a lot about what are reasonable fallbacks that application developers who write the app code and the app behavior, they don't need to think about when they write that code and every little hardware difference. We try to have some reasonable defaults. That's not always possible, so we use patterns like feature flags and things like that to let them have a bit more control. It's a fairly challenging thing. Another thing is we're trying to make this application as fast as possible with as many features as possible to every customer, but then updating native code on these device types is really hard. Part of that is these devices don't even have app stores, most of them. Maybe it goes up with a firmware update. That's a pain. It requires a manual process interacting with a third party that owns the platform. Even on places that do have an app store, if you try to update an app on an app store, it's quite a challenge as well. You need to wait. It's highly likely a manual process. We're having this tension between code that we're downloading over the air, like JavaScript, WebAssembly, and so on, fairly easy, and then code that works on a device that is very fast, but then really hard to update. We want to have this fast iteration cycle. Updating the app in a short amount of time is huge for us. Again, this is how the application looks like today. I've been there eight years and we changed it many times. I'm sure it's going to change again sometime as it happens with the UIs. We've added things to it like channels, live events, all sorts of new features that weren't there in the starting version. Part of us being able to do that was this focus on updatability that we had all the way in the beginning. Most of these applications were in a language like JavaScript that we can change basically everything on it and add all of these features almost without a need to go and touch the low-level native code. I'll show you the architecture and how it looks like. Today, if a developer adds some code, changes a feature, fixes a bug, does anything around the UI, that code goes through a fully CI/CD pipeline, no manual testing whatsoever. We test on virtual devices like Linux and on physical devices where we have a device farm. Once all of those tests pass, you get this new experience on your TV in your living room. That is way faster than a native app update for that platform. Right now, you'll see it working and you'll see a couple of features. This is a bunch of test profiles I was making because I was testing stuff. We have stuff like layout animation, so the whole layout gets recalculated. This is the Rust app in production today. Layout animations are a thing that was previously impossible with JavaScript and React, and now they just work. When you see this thing getting bigger, all the things get reordered on the page. These are things that are just possible right now due to the performance of Rust. Almost instant page transitions as well are things that weren't possible with TypeScript and React due to performance constraints. This is live today and this is how it looks like, so you have an idea on what is going on in there. We're going to get a little bit back to layout animations and those things later. For people who are not UI engineers, or don't quite know, this is the slide that will teach you everything you need to know about UI programming. Basically, every UI ever is a tree of nodes, and the job of a UI SDK is to manipulate as fast as possible this tree as a reaction to user inputs or some things that happen like some events. You either change properties on nodes, like maybe you animate a value like a position, and then the UI engine needs to take care of updating this tree and creating new nodes, deleting new nodes, depending on what the business logic code tells you to do. Those nodes could be view nodes that are maybe just a rectangle. Then, text nodes are quite common, and image nodes, those type of things. Nothing too complicated. It's really annoying that it's a tree, but we're going to move on because we're still having a tree, even in our Rust app we didn't innovate there, but it's just important to have this mental model. We call this in our UI engine, a scene tree, browsers call it a DOM, but it's basically the same thing everywhere. High-Level Architecture This is the high-level architecture before we rewrote everything in Rust. As you can see, we already added Rust, I think two years, three years ago, we already had it there for the low-level UI engine. There's a QCon talk about this journey. There's another part which is saying JavaScript here, but actually developers write TypeScript, that has the business logic code for the Prime Video App. This is the stuff we download. This is downloaded every time the application changes. This is what we output at the end of that full CI/CD pipeline. It's a bundle that has some WebAssembly compiled Rust code and some JavaScript that came from TypeScript and got transpiled to JavaScript. It maybe changes once per day, sometimes even more, sometimes less, depending on our pipelines and if the tests pass or not, but it's updated very frequently on all of the devices that I spoke about, the device categories. Then we have the stuff on device in our architecture. We're trying to keep it as thin as possible because it's really hard to update, so the less we touch this code, the better. It has a couple of virtual machines, some rendering backend, which mainly connects the higher-level stuff we download to things like OpenGL and other graphics APIs, networking. This is basically cURL. Some media APIs and storage and a bunch of other things, but they're in C++. We deploy them on a device and they sit there almost untouched unless there's some critical bug that needs to be fixed or some more tricky thing. This is how things work today. Prime Video App, (Before) With React and WebAssembly You might wonder, though, these are two separate virtual machines, so how do they actually work together? We're going to go through an example of how things worked before with this tech stack. The Prime Video App here takes high-level decisions, like what to show the user, maybe some carousels, maybe arrange some things on the screen. Let's say in this example, he wants to show some image on your TV. The Prime Video App is built with React. We call it React-Livingroom because it's a version of React that we've changed and made it usable for living room devices by pairing them some features, simplifying them, and also writing a few reconcilers because we have this application that works on this type of architecture, but also in browsers because some living room devices today have just an HTML5 browser and don't even have flash space big enough to put our native C++ engine. We needed that device abstraction here. Prime Video App says, I want to put an image node. It uses React-Livingroom as a UI SDK. Through the device abstraction layer, we figure out, you have a WebAssembly VM available. At that point in time, instead of doing the actual work, it just encodes a message and puts it on a message bus. This is literally a command which says, create me an image node with an ID, with a URL where we download the image from, some properties with height and position, and the parent ID to put it in that scene tree. The WebAssembly VM has the engine, and this engine has low-level things that actually manage that scene tree that we talked about. For example, the scene and resource manager will figure out, there's a new message. I have to create a node, put it in the tree. It's an image node, so it checks if that image is available or not. It issues a download request. Maybe it animates some properties if necessary. Once the image is downloaded, it gets decoded, uploaded to the GPU memory, and after that, the high-level renderer here, from the scene tree that could be quite big, it figures out what subset of nodes is visible on the screen and then issues commands, the C++ layer, that's with gray, to draw pixels on the screen. At the end of it all, you'll have The Marvelous Mrs. Maisel image in there as it should be. This is how it used to work. When we added Rust here, we had huge gains in animation fluidity and these types of things. However, things like input latency didn't quite improve, so the input latency is basically the time it takes from when you press a button on your remote control, in our case, until the application responds to your input. That's what we call input latency. That didn't improve much or at all because, basically, all of those decisions and all that business logic, like what happens as a response to an input event to the scene tree, is in JavaScript. That's a fairly slow language, especially since some of this hardware can be as, maybe, dual-core devices with not even 1 gigahertz worth of CPU speed and not much memory. Actually, those are medium. We have some that are even slower, so running JavaScript on those is time-consuming. We wanted to improve this input latency, and in the end, we did, but we ended up with this architecture. The engine is more or less the same, except we added certain systems that are specific to this application. For example, focus management, layout engine is now part of the engine. I didn't put it on this slide because it goes into that scene management. On top of it, we built a new Rust UI SDK that we then use to build the application. Everything is now in Rust. It's one single language. You don't even have the message bus to worry about. That wasn't even that slow anyway. It was almost instantaneous. The problem was JavaScript, so we don't have that anymore. We're actually not quite here because we are deploying this iteratively, page by page, because we wanted to get this out faster in front of customers, but we will get here early next year. UI Code Using the New Rust UI SDK This is going to be a bit intense, but here's some UI code with Rust, and this is actually working UI code that our UI SDK supports. I'm going to walk you through it because there's a few concepts here that I think are important. When it comes to UI programming, Rust isn't known for having lots of libraries, and then the ecosystem is not quite there. We had to build our own. We'd use some ideas from Leptos, like the signals that I'm going to talk about, but this is how things look like today. If you're familiar with React and SolidJS and those things, you'll see some familiar things here. First, you might notice, is that Composer macro over there, that gets attached to this function here that returns a composable. A composable is a reusable piece of tree, of hierarchy of nodes that we can plug in with other reusable bits and compose them, basically, together. This is our way of reusing UI. This Composer macro actually doesn't do that much except generate boilerplate code that gives us some nicer functionality in that compose macro you see later down in the function. It allows us to have named arguments as well as nicer error messages and optional arguments that might miss for functions. This is some quality-of-life thing. Then our developers don't need to specify every argument to these functions, like this hello function here that just takes a name as a string. In this case, the name is mandatory, but we can have optional arguments with optional values that you don't need to specify. Also, you can specify arguments in any order as long as you name them, and we'll see that below. It's just super nice quality-of-life thing. I wish Rust supported this out of the box for functions, but it doesn't, so this is where we are. Then, this is the core principle of our UI SDK. It uses signals and effects. The signal is a special value, so this name here will shadow the string above. Basically, this name is a signal, and that means when it changes, it will trigger effects that use it. For example, when this name changes, it will execute the function in this memo, which is a special signal, and it creates a new hello message with the new value the name has been set to. It executes the function you see here. It formats it. It concatenates, and it will give something like Hello Billy, or whatever. Then hello message is a special signal that also will trigger effects. Here you see in this function, we use the hello message. Whenever the hello message is updated, it will trigger this effect that we call here with create effect. This is very similar to how SolidJS, or if you're familiar with React, works. Actually, this is quite important because this is also what helps UI engineers be productive in this framework without knowing much Rust actually. The core of our UI engine is signals, effects, and memos, which are special signals that only trigger effects if the values that they got updated to are different from the previous value. By default, they just trigger the effect anyway. Then, we have this other macro here, which is the compose macro, and this does the heavy lifting. This is where you define how your UI hierarchy looks like. Here we have a row that then has children, which are label nodes. You see here the label has a text that is either a hardcoded value with three exclamation marks as a string, or it can take a signal that wraps a string. The first label here will be updated whenever hello message gets updated. Without the UI engineer doing anything, it just happens automatically that hello message gets updated, the label itself will render the new text, and it just works. If you're a UI engineer, this is the code you write. It's fairly easy to understand once you get the idea. Here we have some examples, for example, ChannelCard and MovieCard are just some other functions that allow you to pass parameters like a name, a main_texture, and maybe a title, a main_texture, and so on. Again, they could have optional parameters that you don't see here. You can even put signals instead of those hardcoded values. It doesn't quite matter, it's just these will be siblings of those two labels. All the way down we have button with a text, that says Click. Then it has a few callbacks on select, on click, and stuff like that, that are functions that get triggered whenever those events happen in the UI engine. For example, whenever we select this button, we set a signal. That name gets set to a new name. This triggers a cascade of actions, hello message gets updated to hello new name. Then, the effects gets trigger because that's a new value, so that thing will be printed. Then, lastly, the first label you see here, will get updated to a new value. Lastly, this row has properties or modifiers, so we can modify the background color. In this case, it's just set to a hardcoded value of blue. However, we support signals to be passed here as well. If you have a color, that's a signal of a color. Whenever that gets set, maybe on a timer or whatever, the color of the node just gets updated and you pass it here exactly like we set this parameter. That's another powerful way where we get behavior or effects as a consequence of business logic that happens in the UI code. This is what your engineers deal with, and it's quite high-level, and it's very similar to other UI engines, but it's in Rust this time. When we run that compose macro, this is how the UI hierarchy will look like in the scene tree. You have the row, and then it has a label. Then labels are special because they're widgets. Composables can be built out of widgets, which are special composables our UI SDK provides to the engineers, or other composables that eventually are built out of widgets. Widgets are then built out of a series of components. This is fairly important because we use entity component systems under the hood. Components, for now, you can think of them as structures without behavior, so just data without any behavior. The behavior comes from systems that operate on these components. In this case, this label has a layout component that helps the layout system. A base component, let's say maybe it has a position, a rotation, things like that. RenderInfo components, this is all the data you need to put the pixels on the screen for this widget once everything gets computed. A text component, this does text layout and things like that. Maybe a text cache component that is used to cache the text in the texture so we don't draw it letter by letter. The important bit is that widgets are special because they come as predefined composables from our UI SDK. Then, again, composables can be built out of other composables. This row has a few children here, but eventually it has to have widgets as the leaf nodes because those are the things that actually have the base behavior. Here maybe you have a button and another image, and the button has, all the way down, a focus component. This allows us to focus the button, and it gets automatically used by that system. The image component, again, just stores a URL and maybe the status, has this been downloaded, uploaded to GPU, and so on. It's fairly simple. Basically, this architecture in our low-level engine is used to manage complexity in behavior. We'll see a bit later how it works. Then we had another Movie Card in that example and, again, it eventually has to be built out of widgets. Widgets are the things that our UI SDK provides to UI developers out of the box. They can be row, columns, image, labels, stack, rich text, which is special text nodes that allows you to have images embedded and things like that. Stacks, row list, and column list, and these are scrollable either horizontally or vertically. I think we added grid recently because we needed it for something, but basically, we build this as we build the app. This is what we support now. I think button is another one of them that's just supported here out of the box that I somehow didn't put. Then, each widget is an entity ID. It has an ID and a collection of components. Then, the lower-level engine uses systems to modify and update the components. ECS is this entity component system. It's a way to organize your code and manage complexity without paying that much in terms of performance. It's been used by game engines, not a lot, but for example, Overwatch used it. Thief, I think, was the first game in 1998 that used it as a piece of trivia. It's a very simple idea, which is, you have entities, and these are just IDs that map to components. You have components that are data without behavior. Then you have systems, which are basically functions that act on tuples of components. It always acts on more things at the time, not on one thing at a time. It's a bit different than the other paradigms. It's really good to create behavior, because if you want a certain behavior for an entity, you just add the component and then the systems that need that component automatically will just work because the component is there. Here is how it might work in a game loop. For example, these systems are on the left side and then the components are on the right side. When I say components, you can basically imagine those as arrays and entity IDs as indices in those arrays. It's a bit more complicated than that, but that's basically it. Then the things on the left side with the yellow thing, those are systems, and they're basically functions that operate on those arrays at the same time. Let's say the resource management system needs to touch base components, image components, and read from them. This reading is with the white arrow, and it will write to RenderInfo components. For example, it will look where the image is, if it's close to the screen, look at the base component. It looks at the image component that contains the URL. It checks the image status that will be there. Is it downloaded? Has it been uploaded to the GPU? If it has been decoded and uploaded to the GPU, we update the RenderInfo components so we can draw the thing later on the screen. For this system, you need to have all three components on an entity, at least. You can have more, but we just ignore them. We don't care. This system just looks at that slice of an object, which is the base components, the image components, and RenderInfo components. You have to have all three of them. If you have only two without the third one, that entity just isn't touched by this system and it does nothing, the system widget. Then we have the layout system. Of course, this looks at a bunch of components and updates one at the end. It's quite complicated, but layout is complicated anyway. At least that complication and that complexity sits within a file or a function. You can tell from the signature that this reads from a million things, writes to one, but it is what it is. You can't quite build layout systems without touching all of those things. Maybe we have a text cache component that looks at text components and writes to a bunch of other things. Again, you need to have all three of these for an entity such that is updated by this system. All the way at the end, we have the rendering system that looks at RenderInfo components, reads from them. It doesn't write anywhere because it doesn't need to update any component. It will just call the functions in the C++ code in the renderer backend to put things on the screen. It just reads through this and then updates your screen with new pixels. It sounds complicated, but it's a very simple way to organize behavior. This has paid dividends organizing our low-level architecture like this for reasons that we'll see a little bit later, how and why. Not only for the new application, but also the old application because they use the same low-level engine. Again, going back to the architecture, this is what we have, Prime Video App at the top. We've seen how developers write the UI with composables using our UI SDK. Then we've seen how the UI SDK uses widgets that then get updated by the systems, and have components that are defined in the low-level engine. This is again, downloaded. Every time we write some new code, it goes through a pipeline, it gets built to WebAssembly, and then we just execute it on your TV set top box, whatever you have in your living room. Then we have the low-level stuff that interacts with the device that we try to keep as small as possible. This is what we shipped, I think, end of August. It's live today. The Good Parts Good parts. Developer productivity, actually, this was great for us. Previously, when we rewrote the engine, we had a bunch of developers who knew C++ and switched to Rust, and we had good results there. In this case, we switched people who knew only JavaScript and TypeScript to Rust, and they only knew stuff like React and those frameworks. We switched them with our Rust UI SDK with no loss in productivity. This is both self-reported and compared with. Whenever we build a feature, we have other clients that don't use this, so, for example, like the mobile client or the web client and so on. The Rust client, actually, when we were discussing some new features to be built now on all of the clients, was, I think, the second one in terms of speed, behind web. Then even mobile developers had higher estimations than we did here. Also, we did this whole rewrite in a really short amount of time. We had to be productive. We built the UI SDK and a large part of the app quite fast. The reason why I think this is true is because we did a lot of work in developer experience with those macros that maybe look a bit shocking if you don't know UI programming, but actually they felt very familiar to UI engineers. They could work with it right off the bat, they don't have to deal with much complexity in the borrow checker. Usually, in the UI code, you can clone things if necessary, or even use a Rc and things like that. You all know, this is not super optimal. Yes, we came from JavaScript, so this is fine, I promise. The gnarly bits are down in the engine, and there we take a lot of care about data management and memory and so on. In the UI code, we can afford it easy. Even on the lowest level hardware, I have some slides that you'll see the impact of this. Another thing in the SDK, as the SDK and engine team, we chose some constraints and they helped us build a simpler UI SDK and ship it faster. For example, one constraint our UI engine has, I might show it to you, is that when you define a label or a widget or something like that, you cannot read properties from it unless you've been the one setting properties. It's impossible to read where on the screen an element ends up after layout from the UI code. You never know. You just put them in there. We calculate things in the engine, but you can't read things unless you've been the one saying, this is your color, blue. Then you're like, yes, it's in my variable. I can read it, of course. Things like that, you can't read. This simplified vastly our UI architecture and we don't have to deal with a bunch of things, and slowness because of it. It seems like a shocking thing. Maybe you need to know where on the screen. No, you don't, because we shipped it. There was no need to know where you are on the screen, and there was no need to read a property that you haven't set. There are certain cases where we do notify UI developers through callbacks where they can attach a function and get notified if something happens. It's very rare. It happens usually in case of focus management and things like that. You will get a function call that you're focused, you're not focused anymore, and that works fine. Again, it's a tradeoff. It has worked perfectly fine for us. That's something that I think also has helped productivity. We only had one instance where developers asked to read a value of layout because they wanted something to grow, and maybe at 70% of the thing, they wanted something else to happen. Just use a timer and that was fixed. Another good thing is that we iteratively shipped this. This is only because we used, I think in my view, entity component systems as the basis of our lower-level engine. That low-level engine with the systems it has and the components it has, currently supports JavaScript pages. By pages, I mean everything on the screen is in Rust or everything on the screen is in JavaScript. For example, we shipped the profiles page, which is the page you select the profile. The collections page, that's the page right after you select the profile and you see all of the categories, all of the movies and everything. The details page, which is, once you choose something to watch, you can go to that place and see maybe episodes or just more details about the movie, and press play. We still have to move the search page, settings, and a bunch of other smaller pages. Those are still in JavaScript. This is work in progress, so we're just moving them over. It's just a function of time. We only have 20 people for both the UI SDK and the application. It takes a bit to move everything. It's just time. Another reason, it's just work in progress. We think it was good. That entity component system managed perfectly fine to have these two running side-by-side. I don't think we had one bug because of this. We only had to do some extra work to synchronize a bunch of state between these things, like the stack that you used to go back, the back stack and things like that, but it was worth it in the end. We got this out really fast. We actually first shipped the profiles page and then added the collections page and then the details page and then live and linear and whatnot. That's nice. Another good part is, in my opinion, we built tools as part of building this UI SDK. Because we built an SDK, so we had to build tools. I think one winning move here was, it's really easy in our codebase to add a new tool, mostly because we use egui, which is this Rust immediate mode UI library. You see there like the resource manager just appears on top of the UI. This is something a developer built because he was debugging an issue where a texture wasn't loading and he was trying to figure out, how much memory do we have? Is this a memory thing? The resource manager maybe didn't do something right. It just made it very easy to build tools. We built tools in parallel with building the application and the UI SDK. In reality, these are way below what you'd expect from browsers and things like that, but with literally 20% of the tools, you get 80% done. It's absolutely true. You just need mostly the basics. Of course, we have debugger and things like that that just work, but these are UI specific tools. We have layout inspectors and all sorts of other things, so you can figure out if you set the wrong property. Another cool thing, in my opinion, so we built this, which is essentially a rewrite of the whole Prime Video App. Obviously, we're against these things without a lot of data. One thing that really helped us make a point that this is worth it is to make a prototype that wasn't cheating, that we showed to leadership around, this is how it feels on the device before what we did, and this is with this new thing. Literally, features that were impossible before, like layout animations, are just super easy to do now. You see here, things are growing, layout just works, it rearranges everything. Things appear and disappear. Again, this is a layout animation here. Of course, this is programmer art, but has nothing to do with designers. We are just showcasing capabilities on a device. As you can see, things are over icons and under, it's just a prototype, but it felt so much nicer and responsive compared to what you could get on a device that it just convinced people instantly that it's worth the risk of building a UI in Rust and WebAssembly. Because even though we added Rust and it was part of our tech stack, we were using it for low-level bits, but this showed us that we can take a risk and try to build some UI in it. Here are some results. This is a really low-end device where input latency for the main page for collection page was as bad as 247 milliseconds, 250 milliseconds, horrible input latency, with the orange color, this is in JavaScript. With Rust in blue, 33 milliseconds, easy. Similarly, details page, 440 milliseconds. This also includes layout time, because if you press a button as the page loads and we do layout, you might wait that much. This is max. The device is very slow. Again, 30 milliseconds, because layout animations means we need to run layout as fast as an animation frame, which is usually 16 milliseconds or 30 milliseconds at 30 FPS. It's way faster and way more responsive. Again, that line is basically flat. It was great. Other devices have been closer to those two lines, but I picked this example because it really showcases even on the lowest-end device, you can get great results. The medium devices were like 70 milliseconds, and they went down to 16 or 33, but this is like the worst of them all. We have that. The Ugly Parts Ugly parts. WebAssembly System Interface is quite new. WebAssembly in general is quite new. We're part of the W3C community. We're working with them around features, things like that. There are certain things that are lacking. For example, we did add threads, but also there's things that happen in the ecosystem that break our code sometimes because we use something that's not fully standardized in production for a while. One such example was recently Rust 1.82, enabled some feature by default for WebAssembly WASI builds, that basically didn't work on older WebAssembly virtual machines that we had in production. We basically now have a way to disable it, even if you have a new default and things like that. It's worth it for us. That's something to think about. Also, WebAssembly System Interface keeps evolving and adding new features, and we're trying to be active as part of that effort as well. It requires engineering effort. We can't just quite take a dependency, or specifically on WebAssembly, and just be like, let's see where this ship goes. You need to get involved in there and help with feedback, with work on features and so on. Another one we found out is panic-free code is really hard. Of course, exceptions should be for exceptional things, but that's not how people write JavaScript. When the code panics in our new Rust app, the whole app gets just basically demolished, it crashes. You need to restart it from your TV menu. It's really annoying. Panics shouldn't quite happen. It's very easy to cause a Rust panic, just access an array with the wrong index, you panic, game over. Then, that's it. If you're an engineer who only worked in JavaScript, maybe you're familiar with exceptions, you can try-catch somewhere. Even if it's not ideal, you can catch the exception and maybe reset the customer at some nice position, closer to where they were before or literally where they were before. It's impossible with our new app, which is really annoying. We, of course, use Clippy to ban unwraps and expect and those things. We ban unsafe code, except in one engine crate that has to interact with the lower-level bits. Again, it required a bit of education for our UI engineers to rely on this pattern of using the result type from Rust and get comfortable with the idea that there is no stack unwinding, especially there is no stack unwinding in WebAssembly, which is tied to the first point. You can't even catch that in a panic handler. It just aborts the program. Again, this pretty big pain point for us. In the end, obviously we shipped, so we're happy. We almost never crashed, but it requires a bunch of work. This also generated a bunch of work on us because we were depending on some third-party libraries that were very happily panicking whenever you were calling some functions in a bit of a maybe not super correct way. Again, we would rather have results instead of panics for those cases. It led to a bit of work there that we didn't quite expect. That's something to think about especially in UI programming, or especially if you go, like we did, from JavaScript to Rust and WebAssembly. The Bytecode Alliance The Bytecode Alliance is this nonprofit organization we're part of, a bunch of companies are part of it, and builds on open-source standards like WebAssembly, WebAssembly System Interface. Then, the WebAssembly Micro Runtime, which is the virtual machine we use, is built over there, as well as Wasmtime, which is another popular Rust one, implemented in Rust this time. WebAssembly Micro Runtime is C. It's a good place to look at if you're interested in using Rust in production, and especially using WebAssembly in production more specifically. In our case, it comes with Rust and everything. Questions and Answers Participant: You mentioned you don't use this for your web clients. Would you think that something like this could work with using WebGL as the rendering target? Ene: We did some comparisons on devices. There's a bunch of pain points. First pain point is on the ones we do have to use a browser, because there's no space on the flash, on some set top boxes. The problem is those are some version of WebKit that has no WebAssembly. That's the big hurdle for us there. It could be possible. We did some experiments and it worked, but you do lose a few things that browsers have that we don't. Today, it's not worth it for us because those have very few customers. They work fairly ok in terms of comparing them to even the system UI. Even though they don't hit these numbers, it would be a significant amount of effort to get this SDK to work on a browser. Right now, it's just quite simple because it has one target, the one that has the native VM. It requires a bunch of functions from the native VM that we expose that aren't standard. Getting those would probably require to pipe them to JavaScript. Then you're like, what's going on? You might lose some performance and things like that. It's a bit of a tricky one, but we're keeping an eye on it. See more presentations with transcripts",
  "image": "https://res.infoq.com/presentations/prime-video-rust/en/card_header_image/alexandru-ene-twitter-card-1741257206752.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"presentationNotes\"\u003e\n                                    \u003ch2\u003eTranscript\u003c/h2\u003e\n\n\u003cp\u003eEne: We\u0026#39;re going to talk about how we rebuilt a Prime Video UI for living room devices with Rust and WebAssembly, and the journey that got us there. I\u0026#39;m Alex. I\u0026#39;ve been a principal engineer with Amazon for about eight years. We\u0026#39;ve been working with Rust for a while actually in our tech stack for the clients. We had our low-level UI engine in WebAssembly and Rust for that log. Previously I worked on video games, game engines, interactive applications like that. I\u0026#39;ve quite a bit of experience in interactive applications.\u003c/p\u003e\n\n\u003ch2\u003eContent\u003c/h2\u003e\n\n\u003cp\u003eI\u0026#39;ll talk about challenges in this space, because living room devices are things like set top boxes, gaming consoles, streaming sticks, TVs. People don\u0026#39;t usually develop UIs for these devices, and they come with their own special set of challenges, so we\u0026#39;re going to go through those. Then I\u0026#39;ll show you how our architecture for the Prime Video App looked before we rewrote everything in Rust. We had a dual tech stack with the business code in React and JavaScript, and then low-level bits of the engine in Rust and WebAssembly, a bit of C++ in there as well. Then I\u0026#39;ll show you some code with our new Rust UI SDK and how that looks, which is what we use right now in production. We\u0026#39;re going to talk a little bit of how that code works with our low-level existing engine and how everything is organized. At the end, we\u0026#39;re going to go a little bit to results, lessons learned.\u003c/p\u003e\n\n\u003ch2\u003eChallenges In This Space\u003c/h2\u003e\n\n\u003cp\u003eLiving room devices, so as I said, these are gaming consoles, streaming sticks, set top boxes. They come with their own challenges, and some of them are obvious. There\u0026#39;s performance differences that are huge. We\u0026#39;re talking about a PlayStation 5 Pro, super nice gaming console, lots of power, but also a USB power streaming stick. Prime Video, we run the same application on all of these device types. Obviously, performance is really important for us. We can\u0026#39;t quite have teams per device type, so one team that does set top boxes, then another team does gaming consoles, because then everything explodes. When you build a feature, you have to build it for everything. We were building things once and then deploying on all of these device categories here. We don\u0026#39;t deploy this application that I\u0026#39;m talking about on mobile devices, like iPhone, iOS, mobile devices don\u0026#39;t have this. This is just living room devices. Again, a huge range of performance. We\u0026#39;re trying to write our code as optimal as possible.\u003c/p\u003e\n\n\u003cp\u003eUsually, high performant code is code that you compile natively. Let\u0026#39;s say Rust compiled to native, C++ compiled to native, but that doesn\u0026#39;t quite cut it in this space and we\u0026#39;ll see why. Another pain point and challenge is hardware capabilities between these devices is a pain. As SDK developers, we need to think a lot about what are reasonable fallbacks that application developers who write the app code and the app behavior, they don\u0026#39;t need to think about when they write that code and every little hardware difference. We try to have some reasonable defaults. That\u0026#39;s not always possible, so we use patterns like feature flags and things like that to let them have a bit more control. It\u0026#39;s a fairly challenging thing.\u003c/p\u003e\n\n\u003cp\u003eAnother thing is we\u0026#39;re trying to make this application as fast as possible with as many features as possible to every customer, but then updating native code on these device types is really hard. Part of that is these devices don\u0026#39;t even have app stores, most of them. Maybe it goes up with a firmware update. That\u0026#39;s a pain. It requires a manual process interacting with a third party that owns the platform. Even on places that do have an app store, if you try to update an app on an app store, it\u0026#39;s quite a challenge as well. You need to wait. It\u0026#39;s highly likely a manual process. We\u0026#39;re having this tension between code that we\u0026#39;re downloading over the air, like JavaScript, WebAssembly, and so on, fairly easy, and then code that works on a device that is very fast, but then really hard to update. We want to have this fast iteration cycle. Updating the app in a short amount of time is huge for us.\u003c/p\u003e\n\n\u003cp\u003eAgain, this is how the application looks like today. I\u0026#39;ve been there eight years and we changed it many times. I\u0026#39;m sure it\u0026#39;s going to change again sometime as it happens with the UIs. We\u0026#39;ve added things to it like channels, live events, all sorts of new features that weren\u0026#39;t there in the starting version. Part of us being able to do that was this focus on updatability that we had all the way in the beginning. Most of these applications were in a language like JavaScript that we can change basically everything on it and add all of these features almost without a need to go and touch the low-level native code. I\u0026#39;ll show you the architecture and how it looks like.\u003c/p\u003e\n\n\u003cp\u003eToday, if a developer adds some code, changes a feature, fixes a bug, does anything around the UI, that code goes through a fully CI/CD pipeline, no manual testing whatsoever. We test on virtual devices like Linux and on physical devices where we have a device farm. Once all of those tests pass, you get this new experience on your TV in your living room. That is way faster than a native app update for that platform.\u003c/p\u003e\n\n\u003cp\u003eRight now, you\u0026#39;ll see it working and you\u0026#39;ll see a couple of features. This is a bunch of test profiles I was making because I was testing stuff. We have stuff like layout animation, so the whole layout gets recalculated. This is the Rust app in production today. Layout animations are a thing that was previously impossible with JavaScript and React, and now they just work. When you see this thing getting bigger, all the things get reordered on the page. These are things that are just possible right now due to the performance of Rust. Almost instant page transitions as well are things that weren\u0026#39;t possible with TypeScript and React due to performance constraints. This is live today and this is how it looks like, so you have an idea on what is going on in there. We\u0026#39;re going to get a little bit back to layout animations and those things later. For people who are not UI engineers, or don\u0026#39;t quite know, this is the slide that will teach you everything you need to know about UI programming.\u003c/p\u003e\n\n\u003cp\u003eBasically, every UI ever is a tree of nodes, and the job of a UI SDK is to manipulate as fast as possible this tree as a reaction to user inputs or some things that happen like some events. You either change properties on nodes, like maybe you animate a value like a position, and then the UI engine needs to take care of updating this tree and creating new nodes, deleting new nodes, depending on what the business logic code tells you to do. Those nodes could be view nodes that are maybe just a rectangle. Then, text nodes are quite common, and image nodes, those type of things. Nothing too complicated. It\u0026#39;s really annoying that it\u0026#39;s a tree, but we\u0026#39;re going to move on because we\u0026#39;re still having a tree, even in our Rust app we didn\u0026#39;t innovate there, but it\u0026#39;s just important to have this mental model. We call this in our UI engine, a scene tree, browsers call it a DOM, but it\u0026#39;s basically the same thing everywhere.\u003c/p\u003e\n\n\u003ch2\u003eHigh-Level Architecture\u003c/h2\u003e\n\n\u003cp\u003eThis is the high-level architecture before we rewrote everything in Rust. As you can see, we already added Rust, I think two years, three years ago, we already had it there for the low-level UI engine. There\u0026#39;s a QCon talk about this journey. There\u0026#39;s another part which is saying JavaScript here, but actually developers write TypeScript, that has the business logic code for the Prime Video App. This is the stuff we download. This is downloaded every time the application changes. This is what we output at the end of that full CI/CD pipeline. It\u0026#39;s a bundle that has some WebAssembly compiled Rust code and some JavaScript that came from TypeScript and got transpiled to JavaScript. It maybe changes once per day, sometimes even more, sometimes less, depending on our pipelines and if the tests pass or not, but it\u0026#39;s updated very frequently on all of the devices that I spoke about, the device categories.\u003c/p\u003e\n\n\u003cp\u003eThen we have the stuff on device in our architecture. We\u0026#39;re trying to keep it as thin as possible because it\u0026#39;s really hard to update, so the less we touch this code, the better. It has a couple of virtual machines, some rendering backend, which mainly connects the higher-level stuff we download to things like OpenGL and other graphics APIs, networking. This is basically cURL. Some media APIs and storage and a bunch of other things, but they\u0026#39;re in C++. We deploy them on a device and they sit there almost untouched unless there\u0026#39;s some critical bug that needs to be fixed or some more tricky thing. This is how things work today.\u003c/p\u003e\n\n\u003ch2\u003ePrime Video App, (Before) With React and WebAssembly\u003c/h2\u003e\n\n\u003cp\u003eYou might wonder, though, these are two separate virtual machines, so how do they actually work together? We\u0026#39;re going to go through an example of how things worked before with this tech stack. The Prime Video App here takes high-level decisions, like what to show the user, maybe some carousels, maybe arrange some things on the screen. Let\u0026#39;s say in this example, he wants to show some image on your TV. The Prime Video App is built with React. We call it React-Livingroom because it\u0026#39;s a version of React that we\u0026#39;ve changed and made it usable for living room devices by pairing them some features, simplifying them, and also writing a few reconcilers because we have this application that works on this type of architecture, but also in browsers because some living room devices today have just an HTML5 browser and don\u0026#39;t even have flash space big enough to put our native C++ engine. We needed that device abstraction here. Prime Video App says, I want to put an image node. It uses React-Livingroom as a UI SDK.\u003c/p\u003e\n\n\u003cp\u003eThrough the device abstraction layer, we figure out, you have a WebAssembly VM available. At that point in time, instead of doing the actual work, it just encodes a message and puts it on a message bus. This is literally a command which says, create me an image node with an ID, with a URL where we download the image from, some properties with height and position, and the parent ID to put it in that scene tree. The WebAssembly VM has the engine, and this engine has low-level things that actually manage that scene tree that we talked about.\u003c/p\u003e\n\n\u003cp\u003eFor example, the scene and resource manager will figure out, there\u0026#39;s a new message. I have to create a node, put it in the tree. It\u0026#39;s an image node, so it checks if that image is available or not. It issues a download request. Maybe it animates some properties if necessary. Once the image is downloaded, it gets decoded, uploaded to the GPU memory, and after that, the high-level renderer here, from the scene tree that could be quite big, it figures out what subset of nodes is visible on the screen and then issues commands, the C++ layer, that\u0026#39;s with gray, to draw pixels on the screen. At the end of it all, you\u0026#39;ll have The Marvelous Mrs. Maisel image in there as it should be.\u003c/p\u003e\n\n\u003cp\u003eThis is how it used to work. When we added Rust here, we had huge gains in animation fluidity and these types of things. However, things like input latency didn\u0026#39;t quite improve, so the input latency is basically the time it takes from when you press a button on your remote control, in our case, until the application responds to your input. That\u0026#39;s what we call input latency. That didn\u0026#39;t improve much or at all because, basically, all of those decisions and all that business logic, like what happens as a response to an input event to the scene tree, is in JavaScript. That\u0026#39;s a fairly slow language, especially since some of this hardware can be as, maybe, dual-core devices with not even 1 gigahertz worth of CPU speed and not much memory.\u003c/p\u003e\n\n\u003cp\u003eActually, those are medium. We have some that are even slower, so running JavaScript on those is time-consuming. We wanted to improve this input latency, and in the end, we did, but we ended up with this architecture. The engine is more or less the same, except we added certain systems that are specific to this application. For example, focus management, layout engine is now part of the engine. I didn\u0026#39;t put it on this slide because it goes into that scene management. On top of it, we built a new Rust UI SDK that we then use to build the application. Everything is now in Rust. It\u0026#39;s one single language. You don\u0026#39;t even have the message bus to worry about. That wasn\u0026#39;t even that slow anyway. It was almost instantaneous. The problem was JavaScript, so we don\u0026#39;t have that anymore. We\u0026#39;re actually not quite here because we are deploying this iteratively, page by page, because we wanted to get this out faster in front of customers, but we will get here early next year.\u003c/p\u003e\n\n\u003ch2\u003eUI Code Using the New Rust UI SDK\u003c/h2\u003e\n\n\u003cp\u003eThis is going to be a bit intense, but here\u0026#39;s some UI code with Rust, and this is actually working UI code that our UI SDK supports. I\u0026#39;m going to walk you through it because there\u0026#39;s a few concepts here that I think are important. When it comes to UI programming, Rust isn\u0026#39;t known for having lots of libraries, and then the ecosystem is not quite there. We had to build our own. We\u0026#39;d use some ideas from Leptos, like the signals that I\u0026#39;m going to talk about, but this is how things look like today. If you\u0026#39;re familiar with React and SolidJS and those things, you\u0026#39;ll see some familiar things here.\u003c/p\u003e\n\n\u003cp\u003eFirst, you might notice, is that Composer macro over there, that gets attached to this function here that returns a composable. A composable is a reusable piece of tree, of hierarchy of nodes that we can plug in with other reusable bits and compose them, basically, together. This is our way of reusing UI. This Composer macro actually doesn\u0026#39;t do that much except generate boilerplate code that gives us some nicer functionality in that compose macro you see later down in the function. It allows us to have named arguments as well as nicer error messages and optional arguments that might miss for functions.\u003c/p\u003e\n\n\u003cp\u003eThis is some quality-of-life thing. Then our developers don\u0026#39;t need to specify every argument to these functions, like this hello function here that just takes a name as a string. In this case, the name is mandatory, but we can have optional arguments with optional values that you don\u0026#39;t need to specify. Also, you can specify arguments in any order as long as you name them, and we\u0026#39;ll see that below. It\u0026#39;s just super nice quality-of-life thing. I wish Rust supported this out of the box for functions, but it doesn\u0026#39;t, so this is where we are.\u003c/p\u003e\n\n\u003cp\u003eThen, this is the core principle of our UI SDK. It uses signals and effects. The signal is a special value, so this name here will shadow the string above. Basically, this name is a signal, and that means when it changes, it will trigger effects that use it. For example, when this name changes, it will execute the function in this memo, which is a special signal, and it creates a new hello message with the new value the name has been set to. It executes the function you see here. It formats it. It concatenates, and it will give something like Hello Billy, or whatever. Then hello message is a special signal that also will trigger effects. Here you see in this function, we use the hello message.\u003c/p\u003e\n\n\u003cp\u003eWhenever the hello message is updated, it will trigger this effect that we call here with create effect. This is very similar to how SolidJS, or if you\u0026#39;re familiar with React, works. Actually, this is quite important because this is also what helps UI engineers be productive in this framework without knowing much Rust actually. The core of our UI engine is signals, effects, and memos, which are special signals that only trigger effects if the values that they got updated to are different from the previous value. By default, they just trigger the effect anyway.\u003c/p\u003e\n\n\u003cp\u003eThen, we have this other macro here, which is the compose macro, and this does the heavy lifting. This is where you define how your UI hierarchy looks like. Here we have a row that then has children, which are label nodes. You see here the label has a text that is either a hardcoded value with three exclamation marks as a string, or it can take a signal that wraps a string. The first label here will be updated whenever hello message gets updated. Without the UI engineer doing anything, it just happens automatically that hello message gets updated, the label itself will render the new text, and it just works. If you\u0026#39;re a UI engineer, this is the code you write. It\u0026#39;s fairly easy to understand once you get the idea. Here we have some examples, for example, ChannelCard and MovieCard are just some other functions that allow you to pass parameters like a name, a main_texture, and maybe a title, a main_texture, and so on.\u003c/p\u003e\n\n\u003cp\u003eAgain, they could have optional parameters that you don\u0026#39;t see here. You can even put signals instead of those hardcoded values. It doesn\u0026#39;t quite matter, it\u0026#39;s just these will be siblings of those two labels. All the way down we have button with a text, that says Click. Then it has a few callbacks on select, on click, and stuff like that, that are functions that get triggered whenever those events happen in the UI engine. For example, whenever we select this button, we set a signal. That name gets set to a new name. This triggers a cascade of actions, hello message gets updated to hello new name. Then, the effects gets trigger because that\u0026#39;s a new value, so that thing will be printed.\u003c/p\u003e\n\n\u003cp\u003eThen, lastly, the first label you see here, will get updated to a new value. Lastly, this row has properties or modifiers, so we can modify the background color. In this case, it\u0026#39;s just set to a hardcoded value of blue. However, we support signals to be passed here as well. If you have a color, that\u0026#39;s a signal of a color. Whenever that gets set, maybe on a timer or whatever, the color of the node just gets updated and you pass it here exactly like we set this parameter. That\u0026#39;s another powerful way where we get behavior or effects as a consequence of business logic that happens in the UI code. This is what your engineers deal with, and it\u0026#39;s quite high-level, and it\u0026#39;s very similar to other UI engines, but it\u0026#39;s in Rust this time.\u003c/p\u003e\n\n\u003cp\u003eWhen we run that compose macro, this is how the UI hierarchy will look like in the scene tree. You have the row, and then it has a label. Then labels are special because they\u0026#39;re widgets. Composables can be built out of widgets, which are special composables our UI SDK provides to the engineers, or other composables that eventually are built out of widgets. Widgets are then built out of a series of components. This is fairly important because we use entity component systems under the hood. Components, for now, you can think of them as structures without behavior, so just data without any behavior. The behavior comes from systems that operate on these components.\u003c/p\u003e\n\n\u003cp\u003eIn this case, this label has a layout component that helps the layout system. A base component, let\u0026#39;s say maybe it has a position, a rotation, things like that. RenderInfo components, this is all the data you need to put the pixels on the screen for this widget once everything gets computed. A text component, this does text layout and things like that. Maybe a text cache component that is used to cache the text in the texture so we don\u0026#39;t draw it letter by letter.\u003c/p\u003e\n\n\u003cp\u003eThe important bit is that widgets are special because they come as predefined composables from our UI SDK. Then, again, composables can be built out of other composables. This row has a few children here, but eventually it has to have widgets as the leaf nodes because those are the things that actually have the base behavior. Here maybe you have a button and another image, and the button has, all the way down, a focus component. This allows us to focus the button, and it gets automatically used by that system. The image component, again, just stores a URL and maybe the status, has this been downloaded, uploaded to GPU, and so on. It\u0026#39;s fairly simple. Basically, this architecture in our low-level engine is used to manage complexity in behavior. We\u0026#39;ll see a bit later how it works. Then we had another Movie Card in that example and, again, it eventually has to be built out of widgets.\u003c/p\u003e\n\n\u003cp\u003eWidgets are the things that our UI SDK provides to UI developers out of the box. They can be row, columns, image, labels, stack, rich text, which is special text nodes that allows you to have images embedded and things like that. Stacks, row list, and column list, and these are scrollable either horizontally or vertically. I think we added grid recently because we needed it for something, but basically, we build this as we build the app. This is what we support now. I think button is another one of them that\u0026#39;s just supported here out of the box that I somehow didn\u0026#39;t put. Then, each widget is an entity ID. It has an ID and a collection of components. Then, the lower-level engine uses systems to modify and update the components. ECS is this entity component system. It\u0026#39;s a way to organize your code and manage complexity without paying that much in terms of performance. It\u0026#39;s been used by game engines, not a lot, but for example, Overwatch used it.\u003c/p\u003e\n\n\u003cp\u003eThief, I think, was the first game in 1998 that used it as a piece of trivia. It\u0026#39;s a very simple idea, which is, you have entities, and these are just IDs that map to components. You have components that are data without behavior. Then you have systems, which are basically functions that act on tuples of components. It always acts on more things at the time, not on one thing at a time. It\u0026#39;s a bit different than the other paradigms. It\u0026#39;s really good to create behavior, because if you want a certain behavior for an entity, you just add the component and then the systems that need that component automatically will just work because the component is there.\u003c/p\u003e\n\n\u003cp\u003eHere is how it might work in a game loop. For example, these systems are on the left side and then the components are on the right side. When I say components, you can basically imagine those as arrays and entity IDs as indices in those arrays. It\u0026#39;s a bit more complicated than that, but that\u0026#39;s basically it. Then the things on the left side with the yellow thing, those are systems, and they\u0026#39;re basically functions that operate on those arrays at the same time. Let\u0026#39;s say the resource management system needs to touch base components, image components, and read from them. This reading is with the white arrow, and it will write to RenderInfo components. For example, it will look where the image is, if it\u0026#39;s close to the screen, look at the base component. It looks at the image component that contains the URL. It checks the image status that will be there. Is it downloaded? Has it been uploaded to the GPU? If it has been decoded and uploaded to the GPU, we update the RenderInfo components so we can draw the thing later on the screen.\u003c/p\u003e\n\n\u003cp\u003eFor this system, you need to have all three components on an entity, at least. You can have more, but we just ignore them. We don\u0026#39;t care. This system just looks at that slice of an object, which is the base components, the image components, and RenderInfo components. You have to have all three of them. If you have only two without the third one, that entity just isn\u0026#39;t touched by this system and it does nothing, the system widget. Then we have the layout system. Of course, this looks at a bunch of components and updates one at the end. It\u0026#39;s quite complicated, but layout is complicated anyway. At least that complication and that complexity sits within a file or a function. You can tell from the signature that this reads from a million things, writes to one, but it is what it is. You can\u0026#39;t quite build layout systems without touching all of those things. Maybe we have a text cache component that looks at text components and writes to a bunch of other things.\u003c/p\u003e\n\n\u003cp\u003eAgain, you need to have all three of these for an entity such that is updated by this system. All the way at the end, we have the rendering system that looks at RenderInfo components, reads from them. It doesn\u0026#39;t write anywhere because it doesn\u0026#39;t need to update any component. It will just call the functions in the C++ code in the renderer backend to put things on the screen. It just reads through this and then updates your screen with new pixels. It sounds complicated, but it\u0026#39;s a very simple way to organize behavior. This has paid dividends organizing our low-level architecture like this for reasons that we\u0026#39;ll see a little bit later, how and why. Not only for the new application, but also the old application because they use the same low-level engine.\u003c/p\u003e\n\n\u003cp\u003eAgain, going back to the architecture, this is what we have, Prime Video App at the top. We\u0026#39;ve seen how developers write the UI with composables using our UI SDK. Then we\u0026#39;ve seen how the UI SDK uses widgets that then get updated by the systems, and have components that are defined in the low-level engine. This is again, downloaded. Every time we write some new code, it goes through a pipeline, it gets built to WebAssembly, and then we just execute it on your TV set top box, whatever you have in your living room. Then we have the low-level stuff that interacts with the device that we try to keep as small as possible. This is what we shipped, I think, end of August. It\u0026#39;s live today.\u003c/p\u003e\n\n\u003ch2\u003eThe Good Parts\u003c/h2\u003e\n\n\u003cp\u003eGood parts. Developer productivity, actually, this was great for us. Previously, when we rewrote the engine, we had a bunch of developers who knew C++ and switched to Rust, and we had good results there. In this case, we switched people who knew only JavaScript and TypeScript to Rust, and they only knew stuff like React and those frameworks. We switched them with our Rust UI SDK with no loss in productivity. This is both self-reported and compared with. Whenever we build a feature, we have other clients that don\u0026#39;t use this, so, for example, like the mobile client or the web client and so on. The Rust client, actually, when we were discussing some new features to be built now on all of the clients, was, I think, the second one in terms of speed, behind web. Then even mobile developers had higher estimations than we did here. Also, we did this whole rewrite in a really short amount of time. We had to be productive. We built the UI SDK and a large part of the app quite fast.\u003c/p\u003e\n\n\u003cp\u003eThe reason why I think this is true is because we did a lot of work in developer experience with those macros that maybe look a bit shocking if you don\u0026#39;t know UI programming, but actually they felt very familiar to UI engineers. They could work with it right off the bat, they don\u0026#39;t have to deal with much complexity in the borrow checker. Usually, in the UI code, you can clone things if necessary, or even use a Rc and things like that. You all know, this is not super optimal. Yes, we came from JavaScript, so this is fine, I promise. The gnarly bits are down in the engine, and there we take a lot of care about data management and memory and so on. In the UI code, we can afford it easy. Even on the lowest level hardware, I have some slides that you\u0026#39;ll see the impact of this.\u003c/p\u003e\n\n\u003cp\u003eAnother thing in the SDK, as the SDK and engine team, we chose some constraints and they helped us build a simpler UI SDK and ship it faster. For example, one constraint our UI engine has, I might show it to you, is that when you define a label or a widget or something like that, you cannot read properties from it unless you\u0026#39;ve been the one setting properties. It\u0026#39;s impossible to read where on the screen an element ends up after layout from the UI code. You never know. You just put them in there. We calculate things in the engine, but you can\u0026#39;t read things unless you\u0026#39;ve been the one saying, this is your color, blue. Then you\u0026#39;re like, yes, it\u0026#39;s in my variable. I can read it, of course. Things like that, you can\u0026#39;t read. This simplified vastly our UI architecture and we don\u0026#39;t have to deal with a bunch of things, and slowness because of it. It seems like a shocking thing. Maybe you need to know where on the screen. No, you don\u0026#39;t, because we shipped it.\u003c/p\u003e\n\n\u003cp\u003eThere was no need to know where you are on the screen, and there was no need to read a property that you haven\u0026#39;t set. There are certain cases where we do notify UI developers through callbacks where they can attach a function and get notified if something happens. It\u0026#39;s very rare. It happens usually in case of focus management and things like that. You will get a function call that you\u0026#39;re focused, you\u0026#39;re not focused anymore, and that works fine. Again, it\u0026#39;s a tradeoff. It has worked perfectly fine for us. That\u0026#39;s something that I think also has helped productivity. We only had one instance where developers asked to read a value of layout because they wanted something to grow, and maybe at 70% of the thing, they wanted something else to happen. Just use a timer and that was fixed.\u003c/p\u003e\n\n\u003cp\u003eAnother good thing is that we iteratively shipped this. This is only because we used, I think in my view, entity component systems as the basis of our lower-level engine. That low-level engine with the systems it has and the components it has, currently supports JavaScript pages. By pages, I mean everything on the screen is in Rust or everything on the screen is in JavaScript. For example, we shipped the profiles page, which is the page you select the profile. The collections page, that\u0026#39;s the page right after you select the profile and you see all of the categories, all of the movies and everything. The details page, which is, once you choose something to watch, you can go to that place and see maybe episodes or just more details about the movie, and press play. We still have to move the search page, settings, and a bunch of other smaller pages. Those are still in JavaScript. This is work in progress, so we\u0026#39;re just moving them over. It\u0026#39;s just a function of time. We only have 20 people for both the UI SDK and the application. It takes a bit to move everything. It\u0026#39;s just time.\u003c/p\u003e\n\n\u003cp\u003eAnother reason, it\u0026#39;s just work in progress. We think it was good. That entity component system managed perfectly fine to have these two running side-by-side. I don\u0026#39;t think we had one bug because of this. We only had to do some extra work to synchronize a bunch of state between these things, like the stack that you used to go back, the back stack and things like that, but it was worth it in the end. We got this out really fast. We actually first shipped the profiles page and then added the collections page and then the details page and then live and linear and whatnot. That\u0026#39;s nice.\u003c/p\u003e\n\n\u003cp\u003eAnother good part is, in my opinion, we built tools as part of building this UI SDK. Because we built an SDK, so we had to build tools. I think one winning move here was, it\u0026#39;s really easy in our codebase to add a new tool, mostly because we use egui, which is this Rust immediate mode UI library. You see there like the resource manager just appears on top of the UI. This is something a developer built because he was debugging an issue where a texture wasn\u0026#39;t loading and he was trying to figure out, how much memory do we have? Is this a memory thing? The resource manager maybe didn\u0026#39;t do something right. It just made it very easy to build tools. We built tools in parallel with building the application and the UI SDK.\u003c/p\u003e\n\n\u003cp\u003eIn reality, these are way below what you\u0026#39;d expect from browsers and things like that, but with literally 20% of the tools, you get 80% done. It\u0026#39;s absolutely true. You just need mostly the basics. Of course, we have debugger and things like that that just work, but these are UI specific tools. We have layout inspectors and all sorts of other things, so you can figure out if you set the wrong property. Another cool thing, in my opinion, so we built this, which is essentially a rewrite of the whole Prime Video App. Obviously, we\u0026#39;re against these things without a lot of data. One thing that really helped us make a point that this is worth it is to make a prototype that wasn\u0026#39;t cheating, that we showed to leadership around, this is how it feels on the device before what we did, and this is with this new thing.\u003c/p\u003e\n\n\u003cp\u003eLiterally, features that were impossible before, like layout animations, are just super easy to do now. You see here, things are growing, layout just works, it rearranges everything. Things appear and disappear. Again, this is a layout animation here. Of course, this is programmer art, but has nothing to do with designers. We are just showcasing capabilities on a device. As you can see, things are over icons and under, it\u0026#39;s just a prototype, but it felt so much nicer and responsive compared to what you could get on a device that it just convinced people instantly that it\u0026#39;s worth the risk of building a UI in Rust and WebAssembly. Because even though we added Rust and it was part of our tech stack, we were using it for low-level bits, but this showed us that we can take a risk and try to build some UI in it.\u003c/p\u003e\n\n\u003cp\u003eHere are some results. This is a really low-end device where input latency for the main page for collection page was as bad as 247 milliseconds, 250 milliseconds, horrible input latency, with the orange color, this is in JavaScript. With Rust in blue, 33 milliseconds, easy. Similarly, details page, 440 milliseconds. This also includes layout time, because if you press a button as the page loads and we do layout, you might wait that much. This is max. The device is very slow. Again, 30 milliseconds, because layout animations means we need to run layout as fast as an animation frame, which is usually 16 milliseconds or 30 milliseconds at 30 FPS. It\u0026#39;s way faster and way more responsive. Again, that line is basically flat. It was great. Other devices have been closer to those two lines, but I picked this example because it really showcases even on the lowest-end device, you can get great results. The medium devices were like 70 milliseconds, and they went down to 16 or 33, but this is like the worst of them all. We have that.\u003c/p\u003e\n\n\u003ch2\u003eThe Ugly Parts\u003c/h2\u003e\n\n\u003cp\u003eUgly parts. WebAssembly System Interface is quite new. WebAssembly in general is quite new. We\u0026#39;re part of the W3C community. We\u0026#39;re working with them around features, things like that. There are certain things that are lacking. For example, we did add threads, but also there\u0026#39;s things that happen in the ecosystem that break our code sometimes because we use something that\u0026#39;s not fully standardized in production for a while. One such example was recently Rust 1.82, enabled some feature by default for WebAssembly WASI builds, that basically didn\u0026#39;t work on older WebAssembly virtual machines that we had in production. We basically now have a way to disable it, even if you have a new default and things like that. It\u0026#39;s worth it for us. That\u0026#39;s something to think about.\u003c/p\u003e\n\n\u003cp\u003eAlso, WebAssembly System Interface keeps evolving and adding new features, and we\u0026#39;re trying to be active as part of that effort as well. It requires engineering effort. We can\u0026#39;t just quite take a dependency, or specifically on WebAssembly, and just be like, let\u0026#39;s see where this ship goes. You need to get involved in there and help with feedback, with work on features and so on. Another one we found out is panic-free code is really hard. Of course, exceptions should be for exceptional things, but that\u0026#39;s not how people write JavaScript. When the code panics in our new Rust app, the whole app gets just basically demolished, it crashes. You need to restart it from your TV menu. It\u0026#39;s really annoying. Panics shouldn\u0026#39;t quite happen. It\u0026#39;s very easy to cause a Rust panic, just access an array with the wrong index, you panic, game over. Then, that\u0026#39;s it. If you\u0026#39;re an engineer who only worked in JavaScript, maybe you\u0026#39;re familiar with exceptions, you can try-catch somewhere.\u003c/p\u003e\n\n\u003cp\u003eEven if it\u0026#39;s not ideal, you can catch the exception and maybe reset the customer at some nice position, closer to where they were before or literally where they were before. It\u0026#39;s impossible with our new app, which is really annoying. We, of course, use Clippy to ban unwraps and expect and those things. We ban unsafe code, except in one engine crate that has to interact with the lower-level bits. Again, it required a bit of education for our UI engineers to rely on this pattern of using the result type from Rust and get comfortable with the idea that there is no stack unwinding, especially there is no stack unwinding in WebAssembly, which is tied to the first point. You can\u0026#39;t even catch that in a panic handler. It just aborts the program. Again, this pretty big pain point for us.\u003c/p\u003e\n\n\u003cp\u003eIn the end, obviously we shipped, so we\u0026#39;re happy. We almost never crashed, but it requires a bunch of work. This also generated a bunch of work on us because we were depending on some third-party libraries that were very happily panicking whenever you were calling some functions in a bit of a maybe not super correct way. Again, we would rather have results instead of panics for those cases. It led to a bit of work there that we didn\u0026#39;t quite expect. That\u0026#39;s something to think about especially in UI programming, or especially if you go, like we did, from JavaScript to Rust and WebAssembly.\u003c/p\u003e\n\n\u003ch2\u003eThe Bytecode Alliance\u003c/h2\u003e\n\n\u003cp\u003eThe Bytecode Alliance is this nonprofit organization we\u0026#39;re part of, a bunch of companies are part of it, and builds on open-source standards like WebAssembly, WebAssembly System Interface. Then, the WebAssembly Micro Runtime, which is the virtual machine we use, is built over there, as well as Wasmtime, which is another popular Rust one, implemented in Rust this time. WebAssembly Micro Runtime is C. It\u0026#39;s a good place to look at if you\u0026#39;re interested in using Rust in production, and especially using WebAssembly in production more specifically. In our case, it comes with Rust and everything.\u003c/p\u003e\n\n\u003ch2\u003eQuestions and Answers\u003c/h2\u003e\n\n\u003cp\u003eParticipant: You mentioned you don\u0026#39;t use this for your web clients. Would you think that something like this could work with using WebGL as the rendering target?\u003c/p\u003e\n\n\u003cp\u003eEne: We did some comparisons on devices. There\u0026#39;s a bunch of pain points. First pain point is on the ones we do have to use a browser, because there\u0026#39;s no space on the flash, on some set top boxes. The problem is those are some version of WebKit that has no WebAssembly. That\u0026#39;s the big hurdle for us there. It could be possible. We did some experiments and it worked, but you do lose a few things that browsers have that we don\u0026#39;t. Today, it\u0026#39;s not worth it for us because those have very few customers. They work fairly ok in terms of comparing them to even the system UI. Even though they don\u0026#39;t hit these numbers, it would be a significant amount of effort to get this SDK to work on a browser.\u003c/p\u003e\n\n\u003cp\u003eRight now, it\u0026#39;s just quite simple because it has one target, the one that has the native VM. It requires a bunch of functions from the native VM that we expose that aren\u0026#39;t standard. Getting those would probably require to pipe them to JavaScript. Then you\u0026#39;re like, what\u0026#39;s going on? You might lose some performance and things like that. It\u0026#39;s a bit of a tricky one, but we\u0026#39;re keeping an eye on it.\u003c/p\u003e\n\n\n\n\n\u003cp\u003e\u003cbig\u003e\u003cstrong\u003eSee more \u003ca href=\"https://www.infoq.com/transcripts/presentations/\"\u003epresentations with transcripts\u003c/a\u003e\u003c/strong\u003e\u003c/big\u003e\u003c/p\u003e\n\n\n\n                                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "41 min read",
  "publishedTime": "2025-03-21T00:00:00Z",
  "modifiedTime": null
}
