{
  "id": "f0eba385-bf0a-478b-81c9-9eff09418571",
  "title": "Hacking Reolink cameras for fun and profit",
  "link": "https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/",
  "description": "Table of Contents Sniffing traffic Dissecting traffic with Wireshark Inspecting the firmware Why doesn’t this camera support RTSP? Pwning the camera Low hanging fruit first Getting root Reversing the protocol Static analysis with Ghidra Strings: a bounty of information The Charlie Scrambler Dynamic analysis with gdb Feeding the watchdog Charlie strikes again A brief history of the Baichuan protocol Neolink: a new client Getting the video data Wrap it in maroon and white, er, RTSP Testing it with Blue Iris Future work Way back in late 2019, I dissected a Reolink B800 IP camera to demonstrate the various parts of an embedded Linux system. It’s fairly nice hardware, actually—it has a 4K video sensor, a microphone, power over Ethernet, and is nominally waterproof. And yes, it runs Linux. It came in a “kit” of six cameras and an NVR (a dedicated recording box that also powers the cameras). Unfortunately, the NVR is pretty anemic: it’s clearly an existing model with slight changes to support 4K cameras, and it struggles to support more than one viewer at a time. However, I bought these cameras because I believed they supported open standards such as ONVIF, so I’d just swap the NVR for a copy of Blue Iris running on my server. At the time, the Reolink support page clearly indicated that all of their non-battery-powered cameras supported RTSP. After the system was installed, it became apparent that the cameras did not in fact support RTSP—the only port open on them was port 9000. Then, barely outside my return window, Reolink updated their support page to say that the cameras would only work with their 8-channel NVR or proprietary viewer apps. This was, in the immortal words of Bill and Ted, bogus. Heinous. Most non-triumphant. Bogus enough that I decided to pwn the camera, reverse engineer the protocol, and write my own software to get the video stream. The end result is a new piece of open-source software called Neolink, which allows Blue Iris, Shinobi, or other NVR software to receive video from unmodified Reolink cameras. Here’s how I did it. Sniffing traffic As a first step, I fired up Wireshark and captured traffic between the camera and its official Reolink PC client1. The only thing that jumped out to me was the appearance of a sync word at the beginning of each packet, 0xf0debc0a. (In little endian, this is 0x0abcdef0.) On a lark, I Googled this, and actually found a project on GitHub from 2015 which was attempting to retrieve data from Swann cameras! A quick look at the code told me that although they share the sync word and packet header, the protocols for my camera and these older cameras were very different. The payload appeared to be encrypted in my captures. Furthermore, the code wouldn’t even run due to some questionable pointer juggling. Time to extract what I could—the header layout was correct—and move on. Dissecting traffic with Wireshark Always, always spend time developing debug or analysis tools. In my experience, such tools immediately pay back your time investment by a factor of 4 or more. With what I knew, I was able to write a “Baichuan” protocol dissector for Wireshark using Mika’s awesome tutorial. This was easy and fun: Wireshark lets you write dissectors in Lua (disclaimer: your definition of fun may vary). Now Wireshark could show me the payload lengths and message IDs. Not much, but it was a start. Inspecting the firmware In order to figure out whatever encryption and/or obfuscation the protocol was using, I planned to reverse engineer the firmware. I felt pretty confident that the underlying video was using a well-known protocol (especially since the camera seemed to have dedicated video encoding hardware). So “all” I’d have to do is reverse engineer the rest of the protocol. Easy peasy, right? Why doesn’t this camera support RTSP? As a quick aside, it’s natural to wonder why this camera doesn’t support RTSP and/or ONVIF. After all, plenty of other Reolink cameras do. Because I’d like to give them the benefit of the doubt, I’ll propose the possibility that Reolink ran out of storage on this camera and had to axe some features. After all, a 16MB flash chip would cost a whole 20 cents extra. This is just a cost-saving measure and definitely not vendor lock-in, hmmm? Pwning the camera Right, onward. With the protocol not immediately accessible, it was time to crack this camera open. My previous disassembly of the camera has already indicated that it uses SPI NOR flash—bog standard for a small Linux system like this. I was wanting to try out a really neat little SOIC socket I had discovered and ordered on Taobao a little while back. I desoldered the flash and soldered on a socket instead. The camera was now pwned, permanently—there was nothing I could do to brick it (I could always just reflash it with flashrom) and there was nothing Reolink could do to stop me from running my own code on it (since I had control of the first instruction executed, if need be2). With the flash now conveniently socketed, I dumped it and used binwalk to inspect the layout. Here’s the flash layout—the nice round byte offsets that engineers tend to pick.3 Bootloader, Linux uImage, squashfs rootfs, and JFFS2 persistent partition. DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 67266 0x106C2 eCos RTOS string reference 1769472 0x1B0000 uImage header 3604480 0x370000 Squashfs filesystem, little endian 7798784 0x770000 JFFS2 filesystem, little endian This also lines up nicely with this visualization of the flash image, made by a neat little tool called BinVis. binwalk also conveniently offers to unpack the filesystems it finds. Low hanging fruit first My first order of business was to find the actual camera binary. It was pretty easy to find; it’s sitting in its own directory at /mnt/app/dvr. The dvr binary also had an accompanying dvr.xml, which looked like a configuration file. A little grepping later, and… sure enough, here were the magic words ONVIF and RTSP! # .... push_server=\"pushx.reolink.com\" push_server_port=\"9501\" support_3gnet=\"0\" support_intelligence=\"0\" support_smartsearch=\"0\" support_onvif=\"0\" support_rtsp=\"0\" support_bc=\"1\" support_3dnr_config_interface=\"1\" default_3dnr_config=\"1\" # .... I suspected these were simply feature flags dictating to the software which features to enable. What if I just changed these zeros to ones? Rebuilding the rootfs wasn’t quite as easy as extracting it, but I cobbled together a command through trial and error. I wanted to get the squashfs format exactly the same as the one reported by binwalk, so that I could be sure that the stock kernel would mount it. Since I was mostly flying blind without a UART console, I didn’t want any trouble. $ mksquashfs new-squashfs-root/ new-squashfs.img -comp xz -b 262144 -all-root -noappend $ dd if=new-squashfs.img of=pwned.bin bs=1 seek=$((0x370000)) conv=notrunc $ flashrom -p ft2232_spi:type=2232H,port=A -w pwned.bin Alas, it was not to be this easy. The camera exhibited a remarkable lack of behavioral reform: no new ports opened, nothing. For comparison, I downloaded and unpacked a firmware update for a different Reolink camera that did support RTSP. The dvr binary for that camera was nearly 8 megabytes, while my victim’s was only a little over 3. Clearly, the engineers compiled out the unneeded bits. Getting root Fine. If Reolink has compiled the extra functionality out, then the least the camera could do is give me a shell. While I was here, I decided I’d make some, ahem, extra modifications. A quick Google did not yield prebuilt binaries of the tools I was looking for. Instead, I checked out a fresh copy of Buildroot and quickly set it up for a baseline MIPS configuration with static linking, then asked for copies of gdbserver, busybox with all the fixin’s, and strace: $ make qemu_mips32r2el_malta_defconfig $ make menuconfig # (with appropriate edits made) $ make busybox gdb strace Thirty minutes later, I had my tools. In the rootfs tree that binwalk had extracted, there’s the usual assortment of startup scripts in /etc/init.d. With my tricked-out Busybox copied to /bin, and a symlink created named telnetd, I added an extra line to one of the startup scripts: # Get a shell /bin/telnetd -l /bin/sh Fingers crossed, I reinstalled the flash and powered the camera. $ telnet 192.168.1.187 Trying 192.168.1.187... Connected to 192.168.1.187. Escape character is '^]'. /mnt/app # Mwahahaha. Reversing the protocol What to do with my newfound power? I planned to start with a static analysis of the firmware, first reverse engineering the encryption scheme. If I got stuck, I could interrogate the camera binary as it executed. Once I could undo the encryption, I’d be able to see what the actual protocol was like. Static analysis with Ghidra The traditional hobbyist tool for static analysis, IDA free edition, is no good here, because my binary is for MIPS, which the free IDA refuses to disassemble. Instead, the tool of choice is Ghidra, an astoundingly good open-source reverse engineering suite released by the NSA. Now, normally saying “I ran a binary the NSA gave me” will get you laughed out of the room. But Ghidra has been open source for a while now, so I feel reasonably safe installing it from the Arch Linux repository. If this website looks like it’s made by a government agency, it’s because it is. Ghidra is awesome. Seriously, this is a piece of software you’d have to pay $10000 for, and it should be your go-to for reverse engineering work. In addition to the disassembler and analyzer, Ghidra also includes a decompiler, which prints pseudo-C code instead of leaving you digging through MIPS assembly. It also re-analyzes in realtime as you annotate function arguments with type information and names. These features easily cut my time spent reverse engineering in half. So, armed with Ghidra and a false sense of confidence stemming from never having done any reverse engineering before, I went spelunking in the Baichuan binaries. Strings: a bounty of information There’s a reason most reverse engineers start by examining the strings in an unknown binary—it’s a technique that works. In my case, checking for strings in the desktop client and the firmware’s server yielded debug print statements, function names (which Ghidra automatically annotated), and a couple other oddball strings that I’ll talk about in a minute. Both codebases were clearly built around a shared proprietary “BCSDK” library. Searching for crypt yielded a couple of candidate functions that purported to perform encryption: Well, no RSA here, or anything resembling “real” encryption, except AES. (And I could find any AES keys embedded in the app in short order.) But what’s this string stuck nonchalantly in the middle of the others? That’s not a function name. I hit find-references and read the code that uses it. The Charlie Scrambler Ghidra took me to this gem of a function: Technically, this is the decryption function; there’s another one that works in reverse. It only takes a second to understand what’s going on here: the “encryption” scheme is simply: XOR the data with the string Charlie is the designer of P2P!!, then mix up the bytes. This isn’t encryption. This is just a scrambler. Bravo, Charlie, your “design” is permanently encoded in this protocol for all time. Don’t roll your own crypto, kids. Unfortunately, the Charlie Scrambler is only called from UDP functions (see the cross-reference at the bottom of the Ghidra window). This meant it wasn’t my pigeon; my camera uses TCP. At this point I had no idea which of the other “encryption” functions were the right one for my camera, so it was time to bring out my next weapon. Dynamic analysis with gdb With my shell access waiting, my next move was to attach a debugger and control the dvr program remotely from my workstation using my cross-compiled gdbserver and strace tools. My Busybox included an FTP server and a TCP wrapper: $ /bin/busybox tcpsvd -vE 0.0.0.0 21 ftpd / -w -A tcpsvd: listening on 0.0.0.0:21 With this setup I could push whatever tools I wanted to the camera filesystem, even though I hadn’t packed them into the firmware. I went through this process manually about twice before it became really tedious. This is the kind of thing it’s possible to automate with expect, a Tcl (!) program that pretends to be a console user. I scripted these interactions, which reduced the connect, tool push, and gdb setup to a simple: $ ./start-debug.exp An added benefit of this setup is that I could stick whatever gdb commands I wanted to run at startup at the end of the script, instead of writing a dedicated GDB script. These dynamic printf commands simply print in the GDB console when the camera hits a breakpoint, helpful for knowing which functions are being called without halting the camera: send_gdb \"dprintf *0x478908, \\\"_Nets_Without_Password_Login_V20\\\\n\\\"\" send_gdb \"dprintf *0x4780ac, \\\"FUN_004780ac\\\\n\\\"\" send_gdb \"dprintf *0x6310f0, \\\"Md5_string_encrypt\\\\n\\\"\" Feeding the watchdog After attaching and halting the dvr daemon, the camera promptly crashed and reset. After some quick investigation, the camera had a watchdog enabled at /dev/watchdog—a very common setup for embedded devices. I was doing open heart surgery on this software—I didn’t need some two-bit peripheral wandering by and hitting it with an AED! Busybox ships with a watchdog minder, so I simply fired it up: $ watchdog /dev/watchdog Problem solved. Charlie strikes again After my breakpoint was hit, I knew which encryption function I was dealing with: Nets_XmlEncryption. This was immediately good news, because after figuring out the encryption, I was likely dealing with nice ordinary XML, not some crazy half-baked bag of C structs. I took a look at the decompiled function in question in Ghidra, annotating as I went. Sure did look familiar… No engineering lessons had been learned during the redesign, and the influence of Charlie was alive and well! Here is the Charlie Scrambler back in force, but without the mixing step, and with a shorter key. Fine, whatever. Implementing the Scrambler in my Wireshark dissector didn’t take very long—although I was briefly baffled by a header of varying length depending on the message type. Once implemented, I was greeted with this glorious sight: Again, I highly recommend writing plugins for Wireshark. You can do it in Lua (or C if you’re that hardcore), and it only takes a couple hours to have a really nice debug tool. A brief history of the Baichuan protocol I won’t bore you with the gory details, but I’ll summarize my findings. The Baichuan protocol has had several iterations over the years. The very oldest seem to be UDP-based, using a proprietary SDK called TUTK, illicit copies of which can conveniently be found on GitHub. This is no longer used; it’s not even present in the camera code. The next variant is indeed a plaintext “bag of structs”, which consists of a header and a body specified by a message ID in the header. This “legacy variant” is briefly used on the B800 so that both clients can negotiate an upgrade to the “modern variant,” which is the scrambled XML-based scheme you see above. On top of this, modern messages can optionally have a payload. A certain XML message switches the entire message ID into “binary mode,” which supplies a raw data stream in subsequent messages. When the client sends a video-start command, the camera replies with a binary stream containing raw H.265 video. On top of that, the payload can also be more encrypted XML, separate from the main XML for some reason. On the whole, it’s really quite a pain to parse. Neolink: a new client Once my Wireshark dissector was humming along, it was time to write a new client. I wanted my software to be fast, high-level, and correct, since it would be part of a security system setup. That’s right: I rewrote Reolink’s software in Rust. Well, not exactly. Neolink is a new client completely from scratch. It speaks the same Baichuan protocol as the camera, and it extracts the video and forwards it to another real NVR client like Blue Iris over RTSP. The parsing code is somewhat hairy4, but other than that, it’s straightforward. Getting the video data Here’s all the client is capable of right now. It’s pretty easy to read if you want to look at the source. Send a legacy login message to get the camera to “upgrade” to modern messages. Note: this uses plain MD5 encryption for your password, another, um, interesting design choice. Use a password that isn’t in a rainbow table! Send a modern login message to actually authenticate to the camera. Send a start video request: let start_video = Bc::new_from_xml( BcMeta { msg_id: MSG_ID_VIDEO, client_idx: 0, encrypted: true, class: 0x6414, }, BcXml { preview: Some(Preview { version: xml_ver(), channel_id: 0, handle: 0, stream_type: \"mainStream\".to_string(), }), ..Default::default() }); sub_video.send(start_video)?; Spit out the binary data when it’s received: loop { let msg = sub_video.rx.recv_timeout(self.rx_timeout)?; if let BcBody::ModernMsg(ModernMsg { binary: Some(binary), .. }) = msg.body { data_out.write_all(binary.as_slice())?; } } Wrap it in maroon and white, er, RTSP5 For this part of the program I reached for Gstreamer, which ships with an RTSP server. Gstreamer is… complex. However, their examples are fantastic; they even provided a sample RTSP server in Rust! The general approach for feeding Gstreamer data from an arbitrary part of your program is to use a block called an appsrc. This lets you get a callback whenever Gstreamer wants data, or alternatively just push data whenever you have some and let Gstreamer handle scheduling it. The latter approach is the one I went with here, since the camera doesn’t wait for a signal to send video data. I wrapped everything in a Gstreamer pipeline: appsrc name=baichuan is-live=true emit-signals=false max-bytes=0 ! h265parse ! rtph265pay name=pay0 Testing it with Blue Iris The moment of truth arrived… could Blue Iris connect to my RTSP server and actually display the video? You bet. I present… me! In glorious 4K! Future work I’ve been soak-testing Neolink for a while now and I think it’s pretty stable. Going forward I’m packaging it up as a real Windows service (not a command line program) to run alongside Blue Iris on my server. Go look at it and download it for yourself! I’m also interested in getting Neolink working with other “NVR only” Reolink cameras, of which there are quite a few. So far I haven’t purchased any other hardware, so if you have one of these cameras, please get in touch so we can test it. It might Just Work out of the box. Port scan your cameras! If they have port 9000 available, chances are good that they speak the Baichuan protocol. This project was a “just right” intro to reverse engineering. Low-security systems like these let you teach yourself the principles without actively trying to thwart reverse engineering. I taught myself a lot, and I hope it provides a lot of value for folks who own these cameras. Finally, some shameless self-promotion: embedded Linux systems are actually pretty approachable! If you’d like to learn how to do this kind of thing, you might be interested in my Mastering Embedded Linux series, designed to help you become an expert in hacking low-cost embedded Linux systems just like this camera. If you enjoyed this, you can subscribe to my blog updates, or leave a comment below. Thanks for reading! The Reolink support forums always claim that their pages were “updated 8 hours ago.” This is obvious nonsense. They do update fairly frequently, but not constantly. ↩︎ This is exactly the point of secure boot schemes, where the immutable boot ROM validates code against immutable encryption keys, preventing tampering. Needless to say, this camera does not implement such niceties. ↩︎ binwalk also turns up a bunch of false positives, which are easy to ignore because they don’t have nice round offsets. ↩︎ Seriously, having packet decode be stateful is just ridiculous. ↩︎ Yes, I’m a proud Mississippi State University bulldog. You too can attend and become a computer engineer! ↩︎",
  "author": "George Hilliard",
  "published": "Sat, 16 May 2020 17:40:00 -0500",
  "source": "https://www.thirtythreeforty.net/posts/index.xml",
  "categories": null,
  "byline": "",
  "length": 20442,
  "excerpt": "Dragging Reolink, kicking and screaming, into the light of the open-standards day",
  "siteName": "",
  "favicon": "https://www.thirtythreeforty.net/apple-touch-icon-144-precomposed.png",
  "text": "Table of Contents Sniffing traffic Dissecting traffic with Wireshark Inspecting the firmware Why doesn’t this camera support RTSP? Pwning the camera Low hanging fruit first Getting root Reversing the protocol Static analysis with Ghidra Strings: a bounty of information The Charlie Scrambler Dynamic analysis with gdb Feeding the watchdog Charlie strikes again A brief history of the Baichuan protocol Neolink: a new client Getting the video data Wrap it in maroon and white, er, RTSP Testing it with Blue Iris Future work Way back in late 2019, I dissected a Reolink B800 IP camera to demonstrate the various parts of an embedded Linux system. It’s fairly nice hardware, actually—it has a 4K video sensor, a microphone, power over Ethernet, and is nominally waterproof. And yes, it runs Linux. It came in a “kit” of six cameras and an NVR (a dedicated recording box that also powers the cameras). Unfortunately, the NVR is pretty anemic: it’s clearly an existing model with slight changes to support 4K cameras, and it struggles to support more than one viewer at a time. However, I bought these cameras because I believed they supported open standards such as ONVIF, so I’d just swap the NVR for a copy of Blue Iris running on my server. At the time, the Reolink support page clearly indicated that all of their non-battery-powered cameras supported RTSP. After the system was installed, it became apparent that the cameras did not in fact support RTSP—the only port open on them was port 9000. Then, barely outside my return window, Reolink updated their support page to say that the cameras would only work with their 8-channel NVR or proprietary viewer apps. This was, in the immortal words of Bill and Ted, bogus. Heinous. Most non-triumphant. Bogus enough that I decided to pwn the camera, reverse engineer the protocol, and write my own software to get the video stream. The end result is a new piece of open-source software called Neolink, which allows Blue Iris, Shinobi, or other NVR software to receive video from unmodified Reolink cameras. Here’s how I did it. Sniffing traffic As a first step, I fired up Wireshark and captured traffic between the camera and its official Reolink PC client1. The only thing that jumped out to me was the appearance of a sync word at the beginning of each packet, 0xf0debc0a. (In little endian, this is 0x0abcdef0.) On a lark, I Googled this, and actually found a project on GitHub from 2015 which was attempting to retrieve data from Swann cameras! A quick look at the code told me that although they share the sync word and packet header, the protocols for my camera and these older cameras were very different. The payload appeared to be encrypted in my captures. Furthermore, the code wouldn’t even run due to some questionable pointer juggling. Time to extract what I could—the header layout was correct—and move on. Dissecting traffic with Wireshark Always, always spend time developing debug or analysis tools. In my experience, such tools immediately pay back your time investment by a factor of 4 or more. With what I knew, I was able to write a “Baichuan” protocol dissector for Wireshark using Mika’s awesome tutorial. This was easy and fun: Wireshark lets you write dissectors in Lua (disclaimer: your definition of fun may vary). Now Wireshark could show me the payload lengths and message IDs. Not much, but it was a start. Inspecting the firmware In order to figure out whatever encryption and/or obfuscation the protocol was using, I planned to reverse engineer the firmware. I felt pretty confident that the underlying video was using a well-known protocol (especially since the camera seemed to have dedicated video encoding hardware). So “all” I’d have to do is reverse engineer the rest of the protocol. Easy peasy, right? Why doesn’t this camera support RTSP? As a quick aside, it’s natural to wonder why this camera doesn’t support RTSP and/or ONVIF. After all, plenty of other Reolink cameras do. Because I’d like to give them the benefit of the doubt, I’ll propose the possibility that Reolink ran out of storage on this camera and had to axe some features. After all, a 16MB flash chip would cost a whole 20 cents extra. This is just a cost-saving measure and definitely not vendor lock-in, hmmm? Pwning the camera Right, onward. With the protocol not immediately accessible, it was time to crack this camera open. My previous disassembly of the camera has already indicated that it uses SPI NOR flash—bog standard for a small Linux system like this. I was wanting to try out a really neat little SOIC socket I had discovered and ordered on Taobao a little while back. I desoldered the flash and soldered on a socket instead. The camera was now pwned, permanently—there was nothing I could do to brick it (I could always just reflash it with flashrom) and there was nothing Reolink could do to stop me from running my own code on it (since I had control of the first instruction executed, if need be2). With the flash now conveniently socketed, I dumped it and used binwalk to inspect the layout. Here’s the flash layout—the nice round byte offsets that engineers tend to pick.3 Bootloader, Linux uImage, squashfs rootfs, and JFFS2 persistent partition. DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 67266 0x106C2 eCos RTOS string reference 1769472 0x1B0000 uImage header 3604480 0x370000 Squashfs filesystem, little endian 7798784 0x770000 JFFS2 filesystem, little endian This also lines up nicely with this visualization of the flash image, made by a neat little tool called BinVis. binwalk also conveniently offers to unpack the filesystems it finds. Low hanging fruit first My first order of business was to find the actual camera binary. It was pretty easy to find; it’s sitting in its own directory at /mnt/app/dvr. The dvr binary also had an accompanying dvr.xml, which looked like a configuration file. A little grepping later, and… sure enough, here were the magic words ONVIF and RTSP! # .... push_server=\"pushx.reolink.com\" push_server_port=\"9501\" support_3gnet=\"0\" support_intelligence=\"0\" support_smartsearch=\"0\" support_onvif=\"0\" support_rtsp=\"0\" support_bc=\"1\" support_3dnr_config_interface=\"1\" default_3dnr_config=\"1\" # .... I suspected these were simply feature flags dictating to the software which features to enable. What if I just changed these zeros to ones? Rebuilding the rootfs wasn’t quite as easy as extracting it, but I cobbled together a command through trial and error. I wanted to get the squashfs format exactly the same as the one reported by binwalk, so that I could be sure that the stock kernel would mount it. Since I was mostly flying blind without a UART console, I didn’t want any trouble. $ mksquashfs new-squashfs-root/ new-squashfs.img -comp xz -b 262144 -all-root -noappend $ dd if=new-squashfs.img of=pwned.bin bs=1 seek=$((0x370000)) conv=notrunc $ flashrom -p ft2232_spi:type=2232H,port=A -w pwned.bin Alas, it was not to be this easy. The camera exhibited a remarkable lack of behavioral reform: no new ports opened, nothing. For comparison, I downloaded and unpacked a firmware update for a different Reolink camera that did support RTSP. The dvr binary for that camera was nearly 8 megabytes, while my victim’s was only a little over 3. Clearly, the engineers compiled out the unneeded bits. Getting root Fine. If Reolink has compiled the extra functionality out, then the least the camera could do is give me a shell. While I was here, I decided I’d make some, ahem, extra modifications. A quick Google did not yield prebuilt binaries of the tools I was looking for. Instead, I checked out a fresh copy of Buildroot and quickly set it up for a baseline MIPS configuration with static linking, then asked for copies of gdbserver, busybox with all the fixin’s, and strace: $ make qemu_mips32r2el_malta_defconfig $ make menuconfig # (with appropriate edits made) $ make busybox gdb strace Thirty minutes later, I had my tools. In the rootfs tree that binwalk had extracted, there’s the usual assortment of startup scripts in /etc/init.d. With my tricked-out Busybox copied to /bin, and a symlink created named telnetd, I added an extra line to one of the startup scripts: # Get a shell /bin/telnetd -l /bin/sh Fingers crossed, I reinstalled the flash and powered the camera. $ telnet 192.168.1.187 Trying 192.168.1.187... Connected to 192.168.1.187. Escape character is '^]'. /mnt/app # Mwahahaha. Reversing the protocol What to do with my newfound power? I planned to start with a static analysis of the firmware, first reverse engineering the encryption scheme. If I got stuck, I could interrogate the camera binary as it executed. Once I could undo the encryption, I’d be able to see what the actual protocol was like. Static analysis with Ghidra The traditional hobbyist tool for static analysis, IDA free edition, is no good here, because my binary is for MIPS, which the free IDA refuses to disassemble. Instead, the tool of choice is Ghidra, an astoundingly good open-source reverse engineering suite released by the NSA. Now, normally saying “I ran a binary the NSA gave me” will get you laughed out of the room. But Ghidra has been open source for a while now, so I feel reasonably safe installing it from the Arch Linux repository. If this website looks like it’s made by a government agency, it’s because it is. Ghidra is awesome. Seriously, this is a piece of software you’d have to pay $10000 for, and it should be your go-to for reverse engineering work. In addition to the disassembler and analyzer, Ghidra also includes a decompiler, which prints pseudo-C code instead of leaving you digging through MIPS assembly. It also re-analyzes in realtime as you annotate function arguments with type information and names. These features easily cut my time spent reverse engineering in half. So, armed with Ghidra and a false sense of confidence stemming from never having done any reverse engineering before, I went spelunking in the Baichuan binaries. Strings: a bounty of information There’s a reason most reverse engineers start by examining the strings in an unknown binary—it’s a technique that works. In my case, checking for strings in the desktop client and the firmware’s server yielded debug print statements, function names (which Ghidra automatically annotated), and a couple other oddball strings that I’ll talk about in a minute. Both codebases were clearly built around a shared proprietary “BCSDK” library. Searching for crypt yielded a couple of candidate functions that purported to perform encryption: Well, no RSA here, or anything resembling “real” encryption, except AES. (And I could find any AES keys embedded in the app in short order.) But what’s this string stuck nonchalantly in the middle of the others? That’s not a function name. I hit find-references and read the code that uses it. The Charlie Scrambler Ghidra took me to this gem of a function: Technically, this is the decryption function; there’s another one that works in reverse. It only takes a second to understand what’s going on here: the “encryption” scheme is simply: XOR the data with the string Charlie is the designer of P2P!!, then mix up the bytes. This isn’t encryption. This is just a scrambler. Bravo, Charlie, your “design” is permanently encoded in this protocol for all time. Don’t roll your own crypto, kids. Unfortunately, the Charlie Scrambler is only called from UDP functions (see the cross-reference at the bottom of the Ghidra window). This meant it wasn’t my pigeon; my camera uses TCP. At this point I had no idea which of the other “encryption” functions were the right one for my camera, so it was time to bring out my next weapon. Dynamic analysis with gdb With my shell access waiting, my next move was to attach a debugger and control the dvr program remotely from my workstation using my cross-compiled gdbserver and strace tools. My Busybox included an FTP server and a TCP wrapper: $ /bin/busybox tcpsvd -vE 0.0.0.0 21 ftpd / -w -A tcpsvd: listening on 0.0.0.0:21 With this setup I could push whatever tools I wanted to the camera filesystem, even though I hadn’t packed them into the firmware. I went through this process manually about twice before it became really tedious. This is the kind of thing it’s possible to automate with expect, a Tcl (!) program that pretends to be a console user. I scripted these interactions, which reduced the connect, tool push, and gdb setup to a simple: An added benefit of this setup is that I could stick whatever gdb commands I wanted to run at startup at the end of the script, instead of writing a dedicated GDB script. These dynamic printf commands simply print in the GDB console when the camera hits a breakpoint, helpful for knowing which functions are being called without halting the camera: send_gdb \"dprintf *0x478908, \\\"_Nets_Without_Password_Login_V20\\\\n\\\"\" send_gdb \"dprintf *0x4780ac, \\\"FUN_004780ac\\\\n\\\"\" send_gdb \"dprintf *0x6310f0, \\\"Md5_string_encrypt\\\\n\\\"\" Feeding the watchdog After attaching and halting the dvr daemon, the camera promptly crashed and reset. After some quick investigation, the camera had a watchdog enabled at /dev/watchdog—a very common setup for embedded devices. I was doing open heart surgery on this software—I didn’t need some two-bit peripheral wandering by and hitting it with an AED! Busybox ships with a watchdog minder, so I simply fired it up: Problem solved. Charlie strikes again After my breakpoint was hit, I knew which encryption function I was dealing with: Nets_XmlEncryption. This was immediately good news, because after figuring out the encryption, I was likely dealing with nice ordinary XML, not some crazy half-baked bag of C structs. I took a look at the decompiled function in question in Ghidra, annotating as I went. Sure did look familiar… No engineering lessons had been learned during the redesign, and the influence of Charlie was alive and well! Here is the Charlie Scrambler back in force, but without the mixing step, and with a shorter key. Fine, whatever. Implementing the Scrambler in my Wireshark dissector didn’t take very long—although I was briefly baffled by a header of varying length depending on the message type. Once implemented, I was greeted with this glorious sight: Again, I highly recommend writing plugins for Wireshark. You can do it in Lua (or C if you’re that hardcore), and it only takes a couple hours to have a really nice debug tool. A brief history of the Baichuan protocol I won’t bore you with the gory details, but I’ll summarize my findings. The Baichuan protocol has had several iterations over the years. The very oldest seem to be UDP-based, using a proprietary SDK called TUTK, illicit copies of which can conveniently be found on GitHub. This is no longer used; it’s not even present in the camera code. The next variant is indeed a plaintext “bag of structs”, which consists of a header and a body specified by a message ID in the header. This “legacy variant” is briefly used on the B800 so that both clients can negotiate an upgrade to the “modern variant,” which is the scrambled XML-based scheme you see above. On top of this, modern messages can optionally have a payload. A certain XML message switches the entire message ID into “binary mode,” which supplies a raw data stream in subsequent messages. When the client sends a video-start command, the camera replies with a binary stream containing raw H.265 video. On top of that, the payload can also be more encrypted XML, separate from the main XML for some reason. On the whole, it’s really quite a pain to parse. Neolink: a new client Once my Wireshark dissector was humming along, it was time to write a new client. I wanted my software to be fast, high-level, and correct, since it would be part of a security system setup. That’s right: I rewrote Reolink’s software in Rust. Well, not exactly. Neolink is a new client completely from scratch. It speaks the same Baichuan protocol as the camera, and it extracts the video and forwards it to another real NVR client like Blue Iris over RTSP. The parsing code is somewhat hairy4, but other than that, it’s straightforward. Getting the video data Here’s all the client is capable of right now. It’s pretty easy to read if you want to look at the source. Send a legacy login message to get the camera to “upgrade” to modern messages. Note: this uses plain MD5 encryption for your password, another, um, interesting design choice. Use a password that isn’t in a rainbow table! Send a modern login message to actually authenticate to the camera. Send a start video request: let start_video = Bc::new_from_xml( BcMeta { msg_id: MSG_ID_VIDEO, client_idx: 0, encrypted: true, class: 0x6414, }, BcXml { preview: Some(Preview { version: xml_ver(), channel_id: 0, handle: 0, stream_type: \"mainStream\".to_string(), }), ..Default::default() }); sub_video.send(start_video)?; Spit out the binary data when it’s received: loop { let msg = sub_video.rx.recv_timeout(self.rx_timeout)?; if let BcBody::ModernMsg(ModernMsg { binary: Some(binary), .. }) = msg.body { data_out.write_all(binary.as_slice())?; } } Wrap it in maroon and white, er, RTSP5 For this part of the program I reached for Gstreamer, which ships with an RTSP server. Gstreamer is… complex. However, their examples are fantastic; they even provided a sample RTSP server in Rust! The general approach for feeding Gstreamer data from an arbitrary part of your program is to use a block called an appsrc. This lets you get a callback whenever Gstreamer wants data, or alternatively just push data whenever you have some and let Gstreamer handle scheduling it. The latter approach is the one I went with here, since the camera doesn’t wait for a signal to send video data. I wrapped everything in a Gstreamer pipeline: appsrc name=baichuan is-live=true emit-signals=false max-bytes=0 ! h265parse ! rtph265pay name=pay0 Testing it with Blue Iris The moment of truth arrived… could Blue Iris connect to my RTSP server and actually display the video? You bet. I present… me! In glorious 4K! Future work I’ve been soak-testing Neolink for a while now and I think it’s pretty stable. Going forward I’m packaging it up as a real Windows service (not a command line program) to run alongside Blue Iris on my server. Go look at it and download it for yourself! I’m also interested in getting Neolink working with other “NVR only” Reolink cameras, of which there are quite a few. So far I haven’t purchased any other hardware, so if you have one of these cameras, please get in touch so we can test it. It might Just Work out of the box. Port scan your cameras! If they have port 9000 available, chances are good that they speak the Baichuan protocol. This project was a “just right” intro to reverse engineering. Low-security systems like these let you teach yourself the principles without actively trying to thwart reverse engineering. I taught myself a lot, and I hope it provides a lot of value for folks who own these cameras. Finally, some shameless self-promotion: embedded Linux systems are actually pretty approachable! If you’d like to learn how to do this kind of thing, you might be interested in my Mastering Embedded Linux series, designed to help you become an expert in hacking low-cost embedded Linux systems just like this camera. If you enjoyed this, you can subscribe to my blog updates, or leave a comment below. Thanks for reading! The Reolink support forums always claim that their pages were “updated 8 hours ago.” This is obvious nonsense. They do update fairly frequently, but not constantly. ↩︎ This is exactly the point of secure boot schemes, where the immutable boot ROM validates code against immutable encryption keys, preventing tampering. Needless to say, this camera does not implement such niceties. ↩︎ binwalk also turns up a bunch of false positives, which are easy to ignore because they don’t have nice round offsets. ↩︎ Seriously, having packet decode be stateful is just ridiculous. ↩︎ Yes, I’m a proud Mississippi State University bulldog. You too can attend and become a computer engineer! ↩︎",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cdiv\u003e\n\u003cp\u003e\n\u003clabel for=\"tocToggle\"\u003eTable of Contents\u003c/label\u003e\u003c/p\u003e\u003cnav id=\"TableOfContents\"\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#sniffing-traffic\"\u003eSniffing traffic\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#dissecting-traffic-with-wireshark\"\u003eDissecting traffic with Wireshark\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#inspecting-the-firmware\"\u003eInspecting the firmware\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#why-doesnt-this-camera-support-rtsp\"\u003eWhy doesn’t this camera support RTSP?\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#pwning-the-camera\"\u003ePwning the camera\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#low-hanging-fruit-first\"\u003eLow hanging fruit first\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#getting-root\"\u003eGetting root\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#reversing-the-protocol\"\u003eReversing the protocol\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#static-analysis-with-ghidra\"\u003eStatic analysis with Ghidra\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#strings-a-bounty-of-information\"\u003eStrings: a bounty of information\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-charlie-scrambler\"\u003eThe Charlie Scrambler\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#dynamic-analysis-with-gdb\"\u003eDynamic analysis with gdb\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#feeding-the-watchdog\"\u003eFeeding the watchdog\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#charlie-strikes-again\"\u003eCharlie strikes again\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#a-brief-history-of-the-baichuan-protocol\"\u003eA brief history of the Baichuan protocol\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#neolink-a-new-client\"\u003eNeolink: a new client\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#getting-the-video-data\"\u003eGetting the video data\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#wrap-it-in-maroon-and-white-er-rtspmaroon\"\u003eWrap it in maroon and white, er, RTSP\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#testing-it-with-blue-iris\"\u003eTesting it with Blue Iris\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#future-work\"\u003eFuture work\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/nav\u003e\n\u003c/div\u003e\n\u003cp\u003eWay back in \u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/mastering-embedded-linux-part-2-hardware/\"\u003elate 2019\u003c/a\u003e, I dissected a Reolink B800 IP camera to demonstrate the various parts of an embedded Linux system.\nIt’s fairly nice hardware, actually—it has a 4K video sensor, a microphone, power over Ethernet, and is nominally waterproof.\nAnd yes, it runs Linux.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/b800.jpg\" alt=\"Reolink B800\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eIt came in a “kit” of six cameras and an NVR (a dedicated recording box that also powers the cameras).\nUnfortunately, the NVR is pretty anemic: it’s clearly an existing model with slight changes to support 4K cameras, and it struggles to support more than one viewer at a time.\u003c/p\u003e\n\u003cp\u003eHowever, I bought these cameras because I believed they supported open standards such as ONVIF, so I’d just swap the NVR for a copy of Blue Iris running on my server.\nAt the time, the Reolink support page clearly indicated that all of their non-battery-powered cameras supported RTSP.\nAfter the system was installed, it became apparent that the cameras did not in fact support RTSP—the only port open on them was port 9000.\nThen, barely outside my return window, Reolink updated their support page to say that the cameras would only work with their 8-channel NVR or proprietary viewer apps.\u003c/p\u003e\n\u003cp\u003eThis was, in the immortal words of Bill and Ted, bogus. Heinous. Most non-triumphant.\u003c/p\u003e\n\u003cp\u003eBogus enough that I decided to pwn the camera, reverse engineer the protocol, and write my own software to get the video stream.\nThe end result is a \u003ca href=\"https://github.com/thirtythreeforty/neolink\"\u003enew piece of open-source software called Neolink\u003c/a\u003e, which allows Blue Iris, Shinobi, or other NVR software to receive video from \u003cem\u003eunmodified\u003c/em\u003e Reolink cameras.\u003c/p\u003e\n\u003cp\u003eHere’s how I did it.\u003c/p\u003e\n\u003ch2 id=\"sniffing-traffic\"\u003eSniffing traffic\u003c/h2\u003e\n\u003cp\u003eAs a first step, I fired up Wireshark and captured traffic between the camera and its official \u003ca href=\"https://reolink.com/software-and-manual/\"\u003eReolink PC client\u003c/a\u003e\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/login-traffic.png\" alt=\"The login stream\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eThe only thing that jumped out to me was the appearance of a sync word at the beginning of each packet, \u003ccode\u003e0xf0debc0a\u003c/code\u003e.\n(In \u003ca href=\"https://en.wikipedia.org/wiki/Endianness#Little-endian\"\u003elittle endian\u003c/a\u003e, this is \u003ccode\u003e0x0abcdef0\u003c/code\u003e.)\nOn a lark, I Googled this, and actually found a \u003ca href=\"https://github.com/nvella/sdvr\"\u003eproject on GitHub from 2015\u003c/a\u003e which was attempting to retrieve data from Swann cameras!\nA quick look at the code told me that although they share the sync word and packet header, the protocols for my camera and these older cameras were very different.\nThe payload appeared to be encrypted in my captures.\nFurthermore, the code wouldn’t even run due to some questionable pointer juggling.\nTime to extract what I could—the header layout was correct—and move on.\u003c/p\u003e\n\u003ch3 id=\"dissecting-traffic-with-wireshark\"\u003eDissecting traffic with Wireshark\u003c/h3\u003e\n\u003cp\u003eAlways, always spend time developing debug or analysis tools. In my experience, such tools immediately pay back your time investment by a factor of 4 or more.\nWith what I knew, I was able to write a “Baichuan” protocol dissector for Wireshark using \u003ca href=\"https://mika-s.github.io/wireshark/lua/dissector/2017/11/04/creating-a-wireshark-dissector-in-lua-1.html\"\u003eMika’s awesome tutorial\u003c/a\u003e.\nThis was easy and fun: Wireshark lets you write dissectors in Lua (\u003cem\u003edisclaimer: your definition of fun may vary\u003c/em\u003e).\nNow Wireshark could show me the payload lengths and message IDs.\nNot much, but it was a start.\u003c/p\u003e\n\u003ch2 id=\"inspecting-the-firmware\"\u003eInspecting the firmware\u003c/h2\u003e\n\u003cp\u003eIn order to figure out whatever encryption and/or obfuscation the protocol was using, I planned to reverse engineer the firmware.\nI felt pretty confident that the underlying video was using a well-known protocol (especially since the camera seemed to have dedicated video encoding hardware).\nSo “all” I’d have to do is reverse engineer the rest of the protocol.\u003c/p\u003e\n\u003cp\u003eEasy peasy, right?\u003c/p\u003e\n\u003ch3 id=\"why-doesnt-this-camera-support-rtsp\"\u003eWhy doesn’t this camera support RTSP?\u003c/h3\u003e\n\u003cp\u003eAs a quick aside, it’s natural to wonder why this camera doesn’t support RTSP and/or ONVIF.\nAfter all, \u003ca href=\"https://support.reolink.com/hc/en-us/articles/360007010473-How-to-Live-View-Reolink-Cameras-via-VLC-Media-Player\"\u003eplenty of other Reolink cameras\u003c/a\u003e do.\nBecause I’d like to give them the benefit of the doubt, I’ll propose the possibility that Reolink ran out of storage on this camera and had to axe some features.\u003c/p\u003e\n\u003cp\u003eAfter all, a 16MB flash chip would cost a whole 20 cents extra.\nThis is just a cost-saving measure and definitely not vendor lock-in, hmmm?\u003c/p\u003e\n\u003ch2 id=\"pwning-the-camera\"\u003ePwning the camera\u003c/h2\u003e\n\u003cp\u003eRight, onward.\nWith the protocol not immediately accessible, it was time to crack this camera open.\nMy \u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/mastering-embedded-linux-part-2-hardware/\"\u003eprevious disassembly\u003c/a\u003e of the camera has already indicated that it uses SPI NOR flash—bog standard for a small Linux system like this.\nI was wanting to try out a really neat little SOIC socket I had discovered and ordered on Taobao a little while back.\nI desoldered the flash and soldered on a socket instead.\u003c/p\u003e\n\u003cp\u003e\n\u003ciframe src=\"https://www.youtube.com/embed/YIMo3sy0qIw\" allowfullscreen=\"\" title=\"YouTube Video\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\n\u003cp\u003eThe camera was now pwned, permanently—there was nothing I could do to brick it (I could always just reflash it with \u003ccode\u003eflashrom\u003c/code\u003e) and there was nothing Reolink could do to stop me from running my own code on it (since I had control of the first instruction executed, if need be\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e).\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/socketed-flash.jpg\" alt=\"The socketed flash\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eWith the flash now conveniently socketed, I dumped it and used \u003ccode\u003ebinwalk\u003c/code\u003e to inspect the layout.\nHere’s the flash layout—the nice round byte offsets that engineers tend to pick.\u003csup id=\"fnref:3\"\u003e\u003ca href=\"#fn:3\" role=\"doc-noteref\"\u003e3\u003c/a\u003e\u003c/sup\u003e\nBootloader, Linux uImage, squashfs rootfs, and JFFS2 persistent partition.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003eDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n67266         0x106C2         eCos RTOS string reference\n1769472       0x1B0000        uImage header\n3604480       0x370000        Squashfs filesystem, little endian\n7798784       0x770000        JFFS2 filesystem, little endian\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis also lines up nicely with this visualization of the flash image, made by \u003ca href=\"https://binvis.io/\"\u003ea neat little tool called BinVis\u003c/a\u003e.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/stock.png\" alt=\"The flash layout\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003e\u003ccode\u003ebinwalk\u003c/code\u003e also conveniently offers to unpack the filesystems it finds.\u003c/p\u003e\n\u003ch3 id=\"low-hanging-fruit-first\"\u003eLow hanging fruit first\u003c/h3\u003e\n\u003cp\u003eMy first order of business was to find the actual camera binary.\nIt was pretty easy to find; it’s sitting in its own directory at \u003ccode\u003e/mnt/app/dvr\u003c/code\u003e.\nThe \u003ccode\u003edvr\u003c/code\u003e binary also had an accompanying \u003ccode\u003edvr.xml\u003c/code\u003e, which looked like a configuration file.\nA little grepping later, and… sure enough, here were the magic words \u003ccode\u003eONVIF\u003c/code\u003e and \u003ccode\u003eRTSP\u003c/code\u003e!\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"ini\"\u003e\u003cspan\u003e# ....\u003c/span\u003e\n\u003cspan\u003epush_server\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;pushx.reolink.com\u0026#34;\u003c/span\u003e\n\u003cspan\u003epush_server_port\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;9501\u0026#34;\u003c/span\u003e\n\u003cspan\u003esupport_3gnet\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;0\u0026#34;\u003c/span\u003e\n\u003cspan\u003esupport_intelligence\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;0\u0026#34;\u003c/span\u003e\n\u003cspan\u003esupport_smartsearch\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;0\u0026#34;\u003c/span\u003e\n\u003cspan\u003esupport_onvif\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;0\u0026#34;\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003esupport_rtsp\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;0\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003esupport_bc\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;1\u0026#34;\u003c/span\u003e\n\u003cspan\u003esupport_3dnr_config_interface\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;1\u0026#34;\u003c/span\u003e\n\u003cspan\u003edefault_3dnr_config\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;1\u0026#34;\u003c/span\u003e\n\u003cspan\u003e# ....\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI suspected these were simply feature flags dictating to the software which features to enable.\nWhat if I just changed these zeros to ones?\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/1to0.png\" alt=\"Rick Sanchez changing a 1 to a 0\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eRebuilding the rootfs wasn’t quite as easy as extracting it, but I cobbled together a command through trial and error.\nI wanted to get the squashfs format exactly the same as the one reported by binwalk, so that I could be sure that the stock kernel would mount it.\nSince I was mostly flying blind without a UART console, I didn’t want any trouble.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e$ mksquashfs new-squashfs-root/ new-squashfs.img -comp xz -b 262144 -all-root -noappend\n$ dd if=new-squashfs.img of=pwned.bin bs=1 seek=$((0x370000)) conv=notrunc\n$ flashrom -p ft2232_spi:type=2232H,port=A -w pwned.bin\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAlas, it was not to be this easy.\nThe camera exhibited a remarkable lack of behavioral reform: no new ports opened, nothing.\u003c/p\u003e\n\u003cp\u003eFor comparison, I downloaded and unpacked a firmware update for a different Reolink camera that did support RTSP.\nThe \u003ccode\u003edvr\u003c/code\u003e binary for that camera was nearly 8 megabytes, while my victim’s was only a little over 3.\nClearly, the engineers compiled out the unneeded bits.\u003c/p\u003e\n\u003ch3 id=\"getting-root\"\u003eGetting root\u003c/h3\u003e\n\u003cp\u003eFine.\nIf Reolink has compiled the extra functionality out, then the least the camera could do is give me a shell.\nWhile I was here, I decided I’d make some, ahem, extra modifications.\u003c/p\u003e\n\u003cp\u003eA quick Google did not yield prebuilt binaries of the tools I was looking for.\nInstead, I checked out a fresh copy of Buildroot and quickly set it up for a baseline MIPS configuration with static linking, then asked for copies of \u003ccode\u003egdbserver\u003c/code\u003e, \u003ccode\u003ebusybox\u003c/code\u003e with all the fixin’s, and \u003ccode\u003estrace\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e$ make qemu_mips32r2el_malta_defconfig\n$ make menuconfig  # (with appropriate edits made)\n$ make busybox gdb strace\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThirty minutes later, I had my tools.\nIn the rootfs tree that \u003ccode\u003ebinwalk\u003c/code\u003e had extracted, there’s the usual assortment of startup scripts in \u003ccode\u003e/etc/init.d\u003c/code\u003e.\nWith my tricked-out Busybox copied to \u003ccode\u003e/bin\u003c/code\u003e, and a symlink created named \u003ccode\u003etelnetd\u003c/code\u003e, I added an extra line to one of the startup scripts:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"bash\"\u003e\u003cspan\u003e# Get a shell\u003c/span\u003e\n/bin/telnetd -l /bin/sh\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFingers crossed, I reinstalled the flash and powered the camera.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e$ telnet 192.168.1.187\nTrying 192.168.1.187...\nConnected to 192.168.1.187.\nEscape character is \u0026#39;^]\u0026#39;.\n\n/mnt/app #\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eMwahahaha.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/i-am-root.jpg\" alt=\"I am root\"/\u003e\n\u003c/figure\u003e\n\u003ch2 id=\"reversing-the-protocol\"\u003eReversing the protocol\u003c/h2\u003e\n\u003cp\u003eWhat to do with my newfound power?\nI planned to start with a static analysis of the firmware, first reverse engineering the encryption scheme.\nIf I got stuck, I could interrogate the camera binary as it executed.\u003c/p\u003e\n\u003cp\u003eOnce I could undo the encryption, I’d be able to see what the actual protocol was like.\u003c/p\u003e\n\u003ch3 id=\"static-analysis-with-ghidra\"\u003eStatic analysis with Ghidra\u003c/h3\u003e\n\u003cp\u003eThe traditional hobbyist tool for static analysis, \u003ca href=\"https://www.hex-rays.com/products/ida/support/download_freeware/\"\u003eIDA free edition\u003c/a\u003e, is no good here, because my binary is for MIPS, which the free IDA refuses to disassemble.\nInstead, the tool of choice is \u003ca href=\"https://ghidra-sre.org/\"\u003eGhidra\u003c/a\u003e, an astoundingly good open-source reverse engineering suite released by the NSA.\nNow, normally saying “I ran a binary the NSA gave me” will get you laughed out of the room.\nBut Ghidra has been open source for a while now, so I feel reasonably safe installing it from the Arch Linux repository.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/ghidra-website.png\" alt=\"The Ghidra website\"/\u003e\u003cfigcaption\u003e\n\u003cp\u003eIf this website looks like it’s made by a government agency, it’s because it is.\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eGhidra is awesome.\nSeriously, this is a piece of software you’d have to pay $10000 for, and it should be your go-to for reverse engineering work.\nIn addition to the disassembler and analyzer, Ghidra also includes a decompiler, which prints pseudo-C code instead of leaving you digging through MIPS assembly.\nIt also re-analyzes in realtime as you annotate function arguments with type information and names.\nThese features easily cut my time spent reverse engineering in half.\u003c/p\u003e\n\u003cp\u003eSo, armed with Ghidra and a false sense of confidence stemming from never having done any reverse engineering before, I went spelunking in the Baichuan binaries.\u003c/p\u003e\n\u003ch4 id=\"strings-a-bounty-of-information\"\u003eStrings: a bounty of information\u003c/h4\u003e\n\u003cp\u003eThere’s a reason most reverse engineers start by examining the strings in an unknown binary—it’s a technique that works.\nIn my case, checking for strings in the desktop client and the firmware’s server yielded debug print statements, function names (which Ghidra automatically annotated), and a couple other oddball strings that I’ll talk about in a minute.\nBoth codebases were clearly built around a shared proprietary “BCSDK” library.\u003c/p\u003e\n\u003cp\u003eSearching for \u003ccode\u003ecrypt\u003c/code\u003e yielded a couple of candidate functions that purported to perform encryption:\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/crypt.png\" alt=\"Functions matching crypt search\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eWell, no RSA here, or anything resembling “real” encryption, except AES.\n(And I could find any AES keys embedded in the app in short order.)\u003c/p\u003e\n\u003cp\u003eBut what’s this string stuck nonchalantly in the middle of the others?\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/charlie.png\" alt=\"A string referencing Charlie\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eThat’s not a function name.\nI hit find-references and read the code that uses it.\u003c/p\u003e\n\u003ch4 id=\"the-charlie-scrambler\"\u003eThe Charlie Scrambler\u003c/h4\u003e\n\u003cp\u003eGhidra took me to this gem of a function:\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/charlie-scrambler.png\" alt=\"The Charlie Scrambler in all its glory\"/\u003e\u003cfigcaption\u003e\n\u003cp\u003eTechnically, this is the decryption function; there’s another one that works in reverse.\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eIt only takes a second to understand what’s going on here: the “encryption” scheme is simply:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eXOR the data with the string \u003ccode\u003eCharlie is the designer of P2P!!\u003c/code\u003e, then\u003c/li\u003e\n\u003cli\u003emix up the bytes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis isn’t encryption.\nThis is just a scrambler.\u003c/p\u003e\n\u003cp\u003eBravo, Charlie, your “design” is permanently encoded in this protocol for all time.\nDon’t roll your own crypto, kids.\u003c/p\u003e\n\u003cp\u003eUnfortunately, the Charlie Scrambler is only called from UDP functions (see the cross-reference at the bottom of the Ghidra window).\nThis meant it wasn’t my pigeon; my camera uses TCP.\nAt this point I had no idea which of the other “encryption” functions were the right one for my camera, so it was time to bring out my next weapon.\u003c/p\u003e\n\u003ch3 id=\"dynamic-analysis-with-gdb\"\u003eDynamic analysis with gdb\u003c/h3\u003e\n\u003cp\u003eWith my shell access waiting, my next move was to attach a debugger and control the dvr program remotely from my workstation using my cross-compiled \u003ccode\u003egdbserver\u003c/code\u003e and \u003ccode\u003estrace\u003c/code\u003e tools.\nMy Busybox included an FTP server and a TCP wrapper:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e$ /bin/busybox tcpsvd -vE 0.0.0.0 21 ftpd / -w -A\ntcpsvd: listening on 0.0.0.0:21\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWith this setup I could push whatever tools I wanted to the camera filesystem, even though I hadn’t packed them into the firmware.\nI went through this process manually about twice before it became really tedious.\nThis is the kind of thing it’s possible to automate with \u003ccode\u003eexpect\u003c/code\u003e, a Tcl (!) program that pretends to be a console user.\nI \u003ca href=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/start-debug.exp\"\u003escripted these interactions\u003c/a\u003e, which reduced the connect, tool push, and gdb setup to a simple:\u003c/p\u003e\n\u003cp\u003eAn added benefit of this setup is that I could stick whatever gdb commands I wanted to run at startup at the end of the script, instead of writing a dedicated GDB script.\nThese \u003ca href=\"https://doc.ecoscentric.com/gnutools/doc/gdb/Dynamic-Printf.html\"\u003edynamic printf commands\u003c/a\u003e simply print in the GDB console when the camera hits a breakpoint, helpful for knowing which functions are being called without halting the camera:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003esend_gdb \u0026#34;dprintf *0x478908, \\\u0026#34;_Nets_Without_Password_Login_V20\\\\n\\\u0026#34;\u0026#34;\nsend_gdb \u0026#34;dprintf *0x4780ac, \\\u0026#34;FUN_004780ac\\\\n\\\u0026#34;\u0026#34;\nsend_gdb \u0026#34;dprintf *0x6310f0, \\\u0026#34;Md5_string_encrypt\\\\n\\\u0026#34;\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"feeding-the-watchdog\"\u003eFeeding the watchdog\u003c/h4\u003e\n\u003cp\u003eAfter attaching and halting the dvr daemon, the camera promptly crashed and reset.\nAfter some quick investigation, the camera had a watchdog enabled at \u003ccode\u003e/dev/watchdog\u003c/code\u003e—a very common setup for embedded devices.\nI was doing open heart surgery on this software—I didn’t need some two-bit peripheral wandering by and hitting it with an AED!\u003c/p\u003e\n\u003cp\u003eBusybox ships with a watchdog minder, so I simply fired it up:\u003c/p\u003e\n\u003cp\u003eProblem solved.\u003c/p\u003e\n\u003ch4 id=\"charlie-strikes-again\"\u003eCharlie strikes again\u003c/h4\u003e\n\u003cp\u003eAfter my breakpoint was hit, I knew which encryption function I was dealing with: \u003ccode\u003eNets_XmlEncryption\u003c/code\u003e.\nThis was immediately good news, because after figuring out the encryption, I was likely dealing with nice ordinary XML, not some crazy half-baked bag of C \u003ccode\u003estructs\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eI took a look at the decompiled function in question in Ghidra, annotating as I went.\nSure did look familiar…\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/Nets_XmlEncryption.png\" alt=\"The Nets_XmlEncryption disassembly\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eNo engineering lessons had been learned during the redesign, and the influence of Charlie was alive and well!\nHere is the Charlie Scrambler back in force, but without the mixing step, and with a shorter key.\u003c/p\u003e\n\u003cp\u003eFine, whatever.\nImplementing the Scrambler in my Wireshark dissector didn’t take very long—although I was briefly baffled by a header of \u003cem\u003evarying length\u003c/em\u003e depending on the message type.\nOnce implemented, I was greeted with this glorious sight:\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/baichuan-login.png\" alt=\"The decrypted login message in Wireshark\"/\u003e\u003cfigcaption\u003e\n\u003cp\u003eAgain, I highly recommend writing plugins for Wireshark. You can do it in Lua (or C if you’re that hardcore), and it only takes a couple hours to have a really nice debug tool.\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003ch3 id=\"a-brief-history-of-the-baichuan-protocol\"\u003eA brief history of the Baichuan protocol\u003c/h3\u003e\n\u003cp\u003eI won’t bore you with the gory details, but I’ll summarize my findings.\nThe Baichuan protocol has had several iterations over the years.\nThe very oldest seem to be UDP-based, using a proprietary SDK called TUTK, illicit copies of which can conveniently be found on GitHub.\nThis is no longer used; it’s not even present in the camera code.\u003c/p\u003e\n\u003cp\u003eThe next variant is indeed a plaintext “bag of structs”, which consists of a header and a body specified by a message ID in the header.\nThis “legacy variant” is briefly used on the B800 so that both clients can negotiate an upgrade to the “modern variant,” which is the scrambled XML-based scheme you see above.\u003c/p\u003e\n\u003cp\u003eOn top of this, modern messages can optionally have a payload.\nA certain XML message switches the entire message ID into “binary mode,” which supplies a raw data stream in subsequent messages.\nWhen the client sends a video-start command, the camera replies with a binary stream containing raw H.265 video.\nOn top of \u003cem\u003ethat\u003c/em\u003e, the payload can also be \u003cem\u003emore\u003c/em\u003e encrypted XML, separate from the main XML for some reason.\u003c/p\u003e\n\u003cp\u003eOn the whole, it’s really quite a pain to parse.\u003c/p\u003e\n\u003ch2 id=\"neolink-a-new-client\"\u003eNeolink: a new client\u003c/h2\u003e\n\u003cp\u003eOnce my Wireshark dissector was humming along, it was time to write a new client.\nI wanted my software to be fast, high-level, and correct, since it would be part of a security system setup.\u003c/p\u003e\n\u003cp\u003eThat’s right: I rewrote Reolink’s software in Rust.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/riir.png\" alt=\"Rust evangelism strike force badge\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eWell, not exactly.\nNeolink is a new client completely from scratch.\nIt speaks the same Baichuan protocol as the camera, and it extracts the video and forwards it to another real NVR client like Blue Iris over RTSP.\nThe parsing code is somewhat hairy\u003csup id=\"fnref:4\"\u003e\u003ca href=\"#fn:4\" role=\"doc-noteref\"\u003e4\u003c/a\u003e\u003c/sup\u003e, but other than that, it’s straightforward.\u003c/p\u003e\n\u003ch3 id=\"getting-the-video-data\"\u003eGetting the video data\u003c/h3\u003e\n\u003cp\u003eHere’s all the client is capable of right now.\nIt’s pretty easy to read if you want to \u003ca href=\"https://github.com/thirtythreeforty/neolink/blob/master/src/bc_protocol.rs\"\u003elook at the source\u003c/a\u003e.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eSend a legacy login message to get the camera to “upgrade” to modern messages.\nNote: this uses plain MD5 encryption for your password, another, um, interesting design choice.\nUse a password that isn’t in a rainbow table!\u003c/li\u003e\n\u003cli\u003eSend a modern login message to actually authenticate to the camera.\u003c/li\u003e\n\u003cli\u003eSend a start video request:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e \u003c/span\u003estart_video\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eBc::new_from_xml(\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003eBcMeta\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003emsg_id: \u003cspan\u003eMSG_ID_VIDEO\u003c/span\u003e,\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003eclient_idx: \u003cspan\u003e0\u003c/span\u003e,\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003eencrypted: \u003cspan\u003etrue\u003c/span\u003e,\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003eclass: \u003cspan\u003e0x6414\u003c/span\u003e,\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e},\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003eBcXml\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003epreview: \u003cspan\u003eSome\u003c/span\u003e(Preview\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e            \u003c/span\u003eversion: \u003cspan\u003exml_ver\u003c/span\u003e(),\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e            \u003c/span\u003echannel_id: \u003cspan\u003e0\u003c/span\u003e,\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e            \u003c/span\u003ehandle: \u003cspan\u003e0\u003c/span\u003e,\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e            \u003c/span\u003estream_type: \u003cspan\u003e\u0026#34;mainStream\u0026#34;\u003c/span\u003e.to_string(),\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e}),\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e..\u003cspan\u003eDefault\u003c/span\u003e::default()\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e});\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003esub_video.send(start_video)\u003cspan\u003e?\u003c/span\u003e;\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"4\"\u003e\n\u003cli\u003eSpit out the binary data when it’s received:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003eloop\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e \u003c/span\u003emsg\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003esub_video.rx.recv_timeout(self.rx_timeout)\u003cspan\u003e?\u003c/span\u003e;\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eBcBody::ModernMsg(ModernMsg\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e \u003c/span\u003ebinary: \u003cspan\u003eSome\u003c/span\u003e(binary),\u003cspan\u003e \u003c/span\u003e..\u003cspan\u003e \u003c/span\u003e})\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003emsg.body\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003edata_out.write_all(binary.as_slice())\u003cspan\u003e?\u003c/span\u003e;\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e}\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e}\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"wrap-it-in-maroon-and-white-er-rtspmaroon\"\u003eWrap it in \u003cdel\u003emaroon and white\u003c/del\u003e, er, RTSP\u003csup id=\"fnref:5\"\u003e\u003ca href=\"#fn:5\" role=\"doc-noteref\"\u003e5\u003c/a\u003e\u003c/sup\u003e\u003c/h3\u003e\n\u003cp\u003eFor this part of the program I reached for Gstreamer, which ships with an RTSP server.\nGstreamer is… complex.\nHowever, their examples are fantastic; they even provided a \u003ca href=\"https://gitlab.freedesktop.org/gstreamer/gstreamer-rs/-/blob/master/examples/src/bin/rtsp-server.rs\"\u003esample RTSP server \u003cem\u003ein Rust\u003c/em\u003e\u003c/a\u003e!\u003c/p\u003e\n\u003cp\u003eThe general approach for feeding Gstreamer data from an arbitrary part of your program is to use a \u003ca href=\"https://gstreamer.freedesktop.org/documentation/app/appsrc.html\"\u003eblock called an \u003ccode\u003eappsrc\u003c/code\u003e\u003c/a\u003e.\nThis lets you get a callback whenever Gstreamer wants data, or alternatively just push data whenever you have some and let Gstreamer handle scheduling it.\nThe latter approach is the one I went with here, since the camera doesn’t wait for a signal to send video data.\u003c/p\u003e\n\u003cp\u003eI wrapped everything in a Gstreamer pipeline:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003eappsrc name=baichuan is-live=true emit-signals=false max-bytes=0 ! h265parse ! rtph265pay name=pay0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"testing-it-with-blue-iris\"\u003eTesting it with Blue Iris\u003c/h3\u003e\n\u003cp\u003eThe moment of truth arrived… could Blue Iris connect to my RTSP server and actually display the video?\u003c/p\u003e\n\u003cp\u003eYou bet.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/05/hacking-reolink-cameras-for-fun-and-profit/blueiris.png\" alt=\"The Neolink stream in Blue Iris\"/\u003e\u003cfigcaption\u003e\n\u003cp\u003eI present… me! In glorious 4K!\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003ch2 id=\"future-work\"\u003eFuture work\u003c/h2\u003e\n\u003cp\u003eI’ve been soak-testing Neolink for a while now and I think it’s pretty stable.\nGoing forward I’m packaging it up as a real Windows service (not a command line program) to run alongside Blue Iris on my server.\n\u003ca href=\"https://github.com/thirtythreeforty/neolink\"\u003eGo look at it and download it for yourself!\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eI’m also interested in getting Neolink working with other “NVR only” Reolink cameras, of which there are quite a few.\nSo far I haven’t purchased any other hardware, so if you have one of these cameras, please get in touch so we can test it.\nIt might Just Work out of the box.\nPort scan your cameras!\nIf they have port 9000 available, chances are good that they speak the Baichuan protocol.\u003c/p\u003e\n\u003cp\u003eThis project was a “just right” intro to reverse engineering.\nLow-security systems like these let you teach yourself the principles without actively trying to thwart reverse engineering.\nI taught myself a lot, and I hope it provides a lot of value for folks who own these cameras.\u003c/p\u003e\n\u003cp\u003eFinally, some shameless self-promotion: embedded Linux systems are actually pretty approachable!\nIf you’d like to learn how to do this kind of thing, you might be interested in my \u003ca href=\"https://www.thirtythreeforty.net/posts/2019/08/mastering-embedded-linux-part-1-concepts/\"\u003eMastering Embedded Linux series\u003c/a\u003e, designed to help you become an expert in hacking low-cost embedded Linux systems just like this camera.\u003c/p\u003e\n\u003cp\u003eIf you enjoyed this, you can \u003ca href=\"https://www.thirtythreeforty.net/subscribe/\"\u003esubscribe to my blog updates\u003c/a\u003e, or leave a comment below.\nThanks for reading!\u003c/p\u003e\n\u003csection role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\" role=\"doc-endnote\"\u003e\n\u003cp\u003eThe Reolink support forums always claim that their pages were “updated 8 hours ago.” This is obvious nonsense. They do update fairly frequently, but not constantly. \u003ca href=\"#fnref:1\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:2\" role=\"doc-endnote\"\u003e\n\u003cp\u003eThis is exactly the point of secure boot schemes, where the immutable boot ROM validates code against immutable encryption keys, preventing tampering.\nNeedless to say, this camera does \u003cem\u003enot\u003c/em\u003e implement such niceties. \u003ca href=\"#fnref:2\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:3\" role=\"doc-endnote\"\u003e\n\u003cp\u003e\u003ccode\u003ebinwalk\u003c/code\u003e also turns up a bunch of false positives, which are easy to ignore because they don’t have nice round offsets. \u003ca href=\"#fnref:3\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:4\" role=\"doc-endnote\"\u003e\n\u003cp\u003eSeriously, having packet decode be \u003cem\u003estateful\u003c/em\u003e is just ridiculous. \u003ca href=\"#fnref:4\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:5\" role=\"doc-endnote\"\u003e\n\u003cp\u003eYes, I’m a proud \u003ca href=\"https://en.wikipedia.org/wiki/Mississippi_State_Bulldogs_football\"\u003eMississippi State University bulldog\u003c/a\u003e.\nYou too can attend and become a computer engineer! \u003ca href=\"#fnref:5\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "22 min read",
  "publishedTime": "2020-05-16T17:40:00-05:00",
  "modifiedTime": "2020-05-16T17:40:00-05:00"
}
